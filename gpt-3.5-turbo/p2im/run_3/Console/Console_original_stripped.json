{
    "functions": {
        "FUN_00000410": {
            "entrypoint": "0x00000410",
            "current_name": "initialize_uart_stdio_00000410",
            "code": "\nint initializeUartStdio_00000410(EVP_PKEY_CTX *context)\n\n{\n  uart_stdio_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_00000410": "initialize_uart_stdio_00000410",
                "ctx": "context"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "uart_stdio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000041c": {
            "entrypoint": "0x0000041c",
            "current_name": "FUNC_0000041c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0000041c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000041c": "FUNC_0000041c"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000428": {
            "entrypoint": "0x00000428",
            "current_name": "increment_heap_00000428",
            "code": "\nvoid * incrementHeap_00000428(_reentPtreent *reentPtr,ptreentPtrdiff_t increment)\n\n{\n  uint irqState;\n  ptreentPtrdiff_t localIncrement;\n  _reentPtreent *localReent;\n  uint irqState2;\n  void *result;\n  \n  irqState = ireentPtrq_disable();\n  result = heap_top;\n  if ((&_ereentPtram < heap_top + increment) || (heap_top + increment < &_sheap)) {\n    reentPtr->_ereentPtrreentPtrno = 0xc;\n    result = (void *)0xffffffff;\n  }\n  else {\n    heap_top = heap_top + increment;\n  }\n  ireentPtrq_resulttoreentPtre(irqState);\n  reentPtretureentPtrn result;\n}\n\n",
            "renaming": {
                "FUN_00000428": "increment_heap_00000428",
                "r": "reentPtr",
                "incr": "increment",
                "state_00": "irqState",
                "incr_local": "localIncrement",
                "r_local": "localReent",
                "state": "irqState2",
                "res": "result"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "irq_restore",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000490": {
            "entrypoint": "0x00000490",
            "current_name": "read_from_uart_00000490",
            "code": "\n_ssize_t read_from_uart_00000490(_reent_ptreent *reent_ptr,int fd,void *data_buffer,size_t buffer_size)\n\n{\n  int read_result;\n  size_t local_buffer_size;\n  void *local_data_buffer;\n  int local_file_descriptor;\n  _reent_ptreent *local_reent_ptr;\n  \n  read_result = uareent_ptrt_stdio_reent_ptread((chareent_ptr *)data_buffer,buffer_size);\n  reent_ptretureent_ptrn read_result;\n}\n\n",
            "renaming": {
                "FUN_00000490": "read_from_uart_00000490",
                "r": "reent_ptr",
                "buffer": "data_buffer",
                "count": "buffer_size",
                "count_local": "local_buffer_size",
                "buffer_local": "local_data_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reent_ptr",
                "iVar1": "read_result"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "uart_stdio_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004b2": {
            "entrypoint": "0x000004b2",
            "current_name": "write_to_uart_000004b2",
            "code": "\n_ssize_t write_to_uart_000004b2(_reentrant_structeent *reentrant_struct,int fd,void *buffer,size_t buffer_length)\n\n{\n  int write_result;\n  size_t local_buffer_length;\n  void *local_buffer;\n  int local_file_descriptor;\n  _reentrant_structeent *local_reentrant_struct;\n  \n  write_result = uareentrant_structt_stdio_wreentrant_structite((chareentrant_struct *)buffer,buffer_length);\n  reentrant_structetureentrant_structn write_result;\n}\n\n",
            "renaming": {
                "FUN_000004b2": "write_to_uart_000004b2",
                "r": "reentrant_struct",
                "data": "buffer",
                "count": "buffer_length",
                "count_local": "local_buffer_length",
                "data_local": "local_buffer",
                "fd_local": "local_file_descriptor",
                "r_local": "local_reentrant_struct",
                "iVar1": "write_result"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_stdio_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004d4": {
            "entrypoint": "0x000004d4",
            "current_name": "set_file_descriptor_error_000004d4",
            "code": "\nint setFileDescriptorError_000004d4(_reentPtreent *reentPtr,int fd)\n\n{\n  int localFileDescriptor;\n  _reentPtreent *localReent;\n  \n  reentPtr->_ereentPtrreentPtrno = 0x13;\n  reentPtretureentPtrn -1;\n}\n\n",
            "renaming": {
                "FUN_000004d4": "set_file_descriptor_error_000004d4",
                "r": "reentPtr",
                "fd_local": "localFileDescriptor",
                "r_local": "localReent"
            },
            "calling": [
                "__sclose"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000004f2": {
            "entrypoint": "0x000004f2",
            "current_name": "improved_code_000004f2",
            "code": "\n_off_t improvedCode_000004f2(reentry *reentryPointer,int fd,_off_t position,int direction)\n\n{\n  int localDirection;\n  _off_t localPosition;\n  int localFileDescriptor;\n  reentry *localReentryPointer;\n  \n  reentryPointer->_ereentryPointerreentryPointerno = 0x13;\n  reentryPointeretureentryPointern -1;\n}\n\n",
            "renaming": {
                "_reent": "reentry",
                "FUN_000004f2": "improved_code_000004f2",
                "r": "reentryPointer",
                "pos": "position",
                "dir": "direction",
                "dir_local": "localDirection",
                "pos_local": "localPosition",
                "fd_local": "localFileDescriptor",
                "r_local": "localReentryPointer"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000514": {
            "entrypoint": "0x00000514",
            "current_name": "set_error_message_00000514",
            "code": "\nint setErrorMessage_00000514(_reentrantStructureeent *reentrantStructure,int fd,fileStatusat *fileStatus)\n\n{\n  fileStatusat *localFileStatus;\n  int localFileDescriptor;\n  _reentrantStructureeent *localReentrantStructure;\n  \n  reentrantStructure->_ereentrantStructurereentrantStructureno = 0x13;\n  reentrantStructureetureentrantStructuren -1;\n}\n\n",
            "renaming": {
                "FUN_00000514": "set_error_message_00000514",
                "r": "reentrantStructure",
                "st": "fileStatus",
                "st_local": "localFileStatus",
                "fd_local": "localFileDescriptor",
                "r_local": "localReentrantStructure"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000534": {
            "entrypoint": "0x00000534",
            "current_name": "check_standard_file_descriptor_00000534",
            "code": "\nint checkStandardFileDescriptor_00000534(_reenteent *reent,int fd)\n\n{\n  int isValid;\n  int fd_local;\n  _reenteent *reent_local;\n  \n  reent->_ereentreentno = 0;\n  if (((fd == 0) || (fd == 1)) || (fd == 2)) {\n    isValid = 1;\n  }\n  else {\n    isValid = 0;\n  }\n  reentetureentn isValid;\n}\n\n",
            "renaming": {
                "FUN_00000534": "check_standard_file_descriptor_00000534",
                "r": "reent",
                "iVar1": "isValid"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000566": {
            "entrypoint": "0x00000566",
            "current_name": "convert_uint_to_reverse_bits_00000566",
            "code": "\nuint convertUintToReverseBits_00000566(uint input)\n\n{\n  byte bit0;\n  byte bit8;\n  byte bit16;\n  byte bit24;\n  uint result;\n  uint localInput;\n  \n  bit8 = (byte)input;\n  bit16 = (byte)(input >> 8);\n  bit24 = (byte)(input >> 0x10);\n  bit0 = (byte)(input >> 0x18);\n  result = LZCOUNT((uint)(byte)((((((((bit8 & 1) << 1 | bit8 >> 1 & 1) << 1 | bit8 >> 2 & 1) << 1\n                                  | bit8 >> 3 & 1) << 1 | bit8 >> 4 & 1) << 1 | bit8 >> 5 & 1) <<\n                                1 | bit8 >> 6 & 1) << 1 | bit8 >> 7) << 0x18 |\n                  (uint)(byte)((((((((bit16 & 1) << 1 | bit16 >> 1 & 1) << 1 | bit16 >> 2 & 1) << 1\n                                  | bit16 >> 3 & 1) << 1 | bit16 >> 4 & 1) << 1 | bit16 >> 5 & 1) <<\n                                1 | bit16 >> 6 & 1) << 1 | bit16 >> 7) << 0x10 |\n                  (uint)(byte)((((((((bit24 & 1) << 1 | bit24 >> 1 & 1) << 1 | bit24 >> 2 & 1) << 1\n                                  | bit24 >> 3 & 1) << 1 | bit24 >> 4 & 1) << 1 | bit24 >> 5 & 1) <<\n                                1 | bit24 >> 6 & 1) << 1 | bit24 >> 7) << 8 |\n                  (uint)(byte)((((((((bit0 & 1) << 1 | bit0 >> 1 & 1) << 1 | bit0 >> 2 & 1) << 1\n                                  | bit0 >> 3 & 1) << 1 | bit0 >> 4 & 1) << 1 | bit0 >> 5 & 1) <<\n                                1 | bit0 >> 6 & 1) << 1 | bit0 >> 7));\n  if (input == 0) {\n    result = 0xffffffff;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000566": "convert_uint_to_reverse_bits_00000566",
                "v": "input",
                "bVar1": "bit0",
                "bVar2": "bit8",
                "bVar3": "bit16",
                "bVar4": "bit24",
                "uVar5": "result",
                "v_local": "localInput"
            },
            "calling": [
                "sched_run"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000058e": {
            "entrypoint": "0x0000058e",
            "current_name": "insert_after_0000058e",
            "code": "\nvoid insertAfter_0000058e(ccurrentNode_node_t *currentNode,ccurrentNode_node_t *newNode)\n\n{\n  ccurrentNode_node_t *localNewNode;\n  ccurrentNode_node_t *localCurrentNode;\n  \n  if (currentNode->next == (currentNode_node *)0x0) {\n    newNode->next = newNode;\n  }\n  else {\n    newNode->next = currentNode->next->next;\n    currentNode->next->next = newNode;\n  }\n  currentNode->next = newNode;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000058e": "insert_after_0000058e",
                "list": "currentNode",
                "new_node": "newNode",
                "new_node_local": "localNewNode",
                "list_local": "localCurrentNode"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000005ca": {
            "entrypoint": "0x000005ca",
            "current_name": "remove_next_node_000005ca",
            "code": "\nccurrentNode_node_t * removeNextNode_000005ca(ccurrentNode_node_t *currentNode)\n\n{\n  currentNode_node *plVar1;\n  ccurrentNode_node_t *previousNode;\n  ccurrentNode_node_t *removedNode;\n  \n  if (currentNode->next == (currentNode_node *)0x0) {\n    plVar1 = (currentNode_node *)0x0;\n  }\n  else {\n    plVar1 = currentNode->next->next;\n    if (plVar1 == currentNode->next) {\n      currentNode->next = (currentNode_node *)0x0;\n    }\n    else {\n      currentNode->next->next = plVar1->next;\n    }\n  }\n  return plVar1;\n}\n\n",
            "renaming": {
                "FUN_000005ca": "remove_next_node_000005ca",
                "list": "currentNode",
                "list_local": "previousNode",
                "first": "removedNode"
            },
            "calling": [
                "sched_set_status"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000610": {
            "entrypoint": "0x00000610",
            "current_name": "context_switch_00000610",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint contextSwitch_00000610(void)\n\n{\n  thread_t *activeThread;\n  uint lsbIndex;\n  list_node *currentNode;\n  int result;\n  thread_t *activeThread;\n  int nextRq;\n  clist_node_t *tempNode;\n  thread_t *nextThread;\n  \n  activeThread = sched_activeThread;\n  sched_context_switch_request = 0;\n  lsbIndex = bitarithm_lsb(runqueue_bitcache);\n  currentNode = (sched_runqueues[lsbIndex].next)->next;\n  if (activeThread == (thread_t *)(currentNode + -2)) {\n    result = 0;\n  }\n  else {\n    if ((activeThread != (thread_t *)0x0) && (activeThread->status == '\\t')) {\n      activeThread->status = '\\n';\n    }\n    *(undefined *)&currentNode[-1].next = 9;\n    sched_active_pid = *(kernel_pid_t *)((int)&currentNode[-1].next + 2);\n    result = 1;\n    sched_activeThread = (thread_t *)(currentNode + -2);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00000610": "context_switch_00000610",
                "ptVar1": "activeThread",
                "uVar2": "lsbIndex",
                "plVar3": "currentNode",
                "iVar4": "result",
                "active_thread": "activeThread",
                "nextrq": "nextRq",
                "__m____": "tempNode",
                "next_thread": "nextThread"
            },
            "calling": [
                "isr_svc"
            ],
            "called": [
                "bitarithm_lsb"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000698": {
            "entrypoint": "0x00000698",
            "current_name": "update_process_status_00000698",
            "code": "\nvoid updateProcessStatus_00000698(thread_t *currentProcess,uint newStatus)\n\n{\n  uint localStatus;\n  thread_t *localProcess;\n  \n  if (newStatus < 9) {\n    if ((8 < currentProcess->newStatus) &&\n       (clist_lpop(sched_runqueues + currentProcess->priority),\n       sched_runqueues[currentProcess->priority].next == (list_node *)0x0)) {\n      runqueue_bitcache = runqueue_bitcache & ~(1 << currentProcess->priority);\n    }\n  }\n  else if (currentProcess->newStatus < 9) {\n    clist_rpush(sched_runqueues + currentProcess->priority,&currentProcess->rq_entry);\n    runqueue_bitcache = runqueue_bitcache | 1 << currentProcess->priority;\n  }\n  currentProcess->newStatus = (uint8_t)newStatus;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000698": "update_process_status_00000698",
                "process": "currentProcess",
                "status": "newStatus",
                "status_local": "localStatus",
                "process_local": "localProcess"
            },
            "calling": [
                "mutex_unlock",
                "thread_create",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [
                "clist_rpush",
                "clist_lpop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000738": {
            "entrypoint": "0x00000738",
            "current_name": "check_and_perform_context_switch_00000738",
            "code": "\nvoid checkAndPerformContextSwitch_00000738(uint16_t requestedPriority)\n\n{\n  int iVar1;\n  uint16_t localPriority;\n  uint16_t currentPriority;\n  thread_t *currentThread;\n  int isOnRunqueue;\n  \n  if ((sched_currentThread->status < 9) || (requestedPriority < sched_currentThread->priority)) {\n    iVar1 = irq_is_in();\n    if (iVar1 == 0) {\n      thread_yield_higher();\n    }\n    else {\n      sched_context_switch_request = 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000738": "check_and_perform_context_switch_00000738",
                "other_prio": "requestedPriority",
                "other_prio_local": "localPriority",
                "current_prio": "currentPriority",
                "active_thread": "currentThread",
                "on_runqueue": "isOnRunqueue"
            },
            "calling": [
                "mutex_unlock",
                "thread_create"
            ],
            "called": [
                "thread_yield_higher",
                "irq_is_in"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000794": {
            "entrypoint": "0x00000794",
            "current_name": "cleanup_thread_00000794",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cleanupThread_00000794(void)\n\n{\n  disableInterrupts();\n  threadTable[activePID] = (thread_t *)0x0;\n  numThreads = numThreads + -1;\n  setStatus(activeThread,0);\n  activeThread = (thread_t *)0x0;\n                    \n  switchContextExit();\n}\n\n",
            "renaming": {
                "FUN_00000794": "cleanup_thread_00000794",
                "irq_disable": "disableInterrupts",
                "sched_threads": "threadTable",
                "sched_active_pid": "activePID",
                "sched_num_threads": "numThreads",
                "sched_set_status": "setStatus",
                "sched_active_thread": "activeThread",
                "cpu_switch_context_exit": "switchContextExit"
            },
            "calling": [],
            "called": [
                "sched_set_status",
                "cpu_switch_context_exit",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000007dc": {
            "entrypoint": "0x000007dc",
            "current_name": "initialize_thread_000007dc",
            "code": "\nchar * initialize_thread_000007dc(thread_thread_task_function_t thread_task_function,voloop_variable_2d *argument,voloop_variable_2d *stack_address,loop_variable_2nt stack_sloop_variable_2ze)\n\n{\n  uloop_variable_2nt rounded_stack_size;\n  loop_variable_2nt local_stack_size;\n  voloop_variable_2d *local_stack_start;\n  voloop_variable_2d *local_argument;\n  thread_thread_task_function_t local_thread_task_function;\n  loop_variable_2nt loop_variable_1;\n  loop_variable_2nt loop_variable_2;\n  uloop_variable_2nt32_t *stack_pointer;\n  \n  rounded_stack_size = stack_sloop_variable_2ze + (loop_variable_2nt)stack_address & 0xfffffffc;\n  stack_pointer = (uloop_variable_2nt32_t *)(rounded_stack_size - 4);\n  *stack_pointer = 0x77777777;\n  loop_variable_2f (((uloop_variable_2nt)stack_pointer & 7) != 0) {\n    stack_pointer = (uloop_variable_2nt32_t *)(rounded_stack_size - 8);\n    *stack_pointer = 0x88888888;\n  }\n  stack_pointer[-1] = 0x1000000;\n  stack_pointer[-2] = (uloop_variable_2nt32_t)thread_task_function;\n  stack_pointer[-3] = 0x795;\n  stack_pointer = stack_pointer + -4;\n  *stack_pointer = 0;\n  for (loop_variable_2 = 3; 0 < loop_variable_2; loop_variable_2 = loop_variable_2 + -1) {\n    stack_pointer = stack_pointer + -1;\n    *stack_pointer = loop_variable_2;\n  }\n  stack_pointer = stack_pointer + -1;\n  *stack_pointer = (uloop_variable_2nt32_t)argument;\n  for (loop_variable_1 = 0xb; 3 < loop_variable_1; loop_variable_1 = loop_variable_1 + -1) {\n    stack_pointer = stack_pointer + -1;\n    *stack_pointer = loop_variable_1;\n  }\n  stack_pointer[-1] = 0xfffffffd;\n  return (char *)(stack_pointer + -1);\n}\n\n",
            "renaming": {
                "FUN_000007dc": "initialize_thread_000007dc",
                "task_func": "thread_task_function",
                "arg": "argument",
                "stack_start": "stack_address",
                "uVar1": "rounded_stack_size",
                "stack_size_local": "local_stack_size",
                "stack_start_local": "local_stack_start",
                "arg_local": "local_argument",
                "task_func_local": "local_thread_task_function",
                "i_1": "loop_variable_1",
                "i": "loop_variable_2",
                "stk": "stack_pointer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000008b8": {
            "entrypoint": "0x000008b8",
            "current_name": "count_used_words_000008b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint countUsedWords_000008b8(void)\n\n{\n  currentPtrdiff_t wordCount;\n  uint32_t *currentPtr;\n  \n  for (currentPtr = (uint32_t *)isr_stack; (*currentPtr == 0xe7fee7fe && (currentPtr < &heap_top)); currentPtr = currentPtr + 1) {\n  }\n  return ((int)&heap_top - (int)currentPtr >> 2) << 2;\n}\n\n",
            "renaming": {
                "FUN_000008b8": "count_used_words_000008b8",
                "num_used_words": "wordCount",
                "ptr": "currentPtr"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000900": {
            "entrypoint": "0x00000900",
            "current_name": "get_main_stack_pointer_and_return_00000900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * getMainStackPointerAndReturn_00000900(void)\n\n{\n  void *mainStackPointer;\n  uint32_t returnValue;\n  void *msp;\n  \n  mainStackPointer = (void *)getMainStackPointer();\n  return mainStackPointer;\n}\n\n",
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_and_return_00000900",
                "pvVar1": "mainStackPointer",
                "result": "returnValue"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000091c": {
            "entrypoint": "0x0000091c",
            "current_name": "get_isr_stack_0000091c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * get_isr_stack_0000091c(void)\n\n{\n  return ptr_isr_stack;\n}\n\n",
            "renaming": {
                "FUN_0000091c": "get_isr_stack_0000091c",
                "isr_stack": "ptr_isr_stack"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000930": {
            "entrypoint": "0x00000930",
            "current_name": "enable_interrupts_and_trigger_software_interrupt_00000930",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enable_interrupts_and_trigger_software_interrupt_00000930(void)\n\n{\n  enable_interrupts();\n  trigger_software_interrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000930": "enable_interrupts_and_trigger_software_interrupt_00000930",
                "irq_enable": "enable_interrupts",
                "software_interrupt": "trigger_software_interrupt"
            },
            "calling": [
                "kernel_init",
                "sched_task_exit"
            ],
            "called": [
                "irq_enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000093c": {
            "entrypoint": "0x0000093c",
            "current_name": "enable_interrupt_flag_0000093c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableInterruptFlag_0000093c(void)\n\n{\n  _DAT_e000ed04 = _DAT_e000ed04 | 0x10000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000093c": "enable_interrupt_flag_0000093c"
            },
            "calling": [
                "sched_switch",
                "cortexm_isr_end",
                "cortexm_isr_end",
                "_mutex_lock",
                "cortexm_isr_end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000958": {
            "entrypoint": "0x00000958",
            "current_name": "execute_system_task_00000958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeSystemTask_00000958(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  code *jumpTable;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  undefined4 param4;\n  undefined4 param5;\n  undefined4 param6;\n  undefined4 param7;\n  undefined4 param8;\n  undefined4 param9;\n  code **nextStackPointer;\n  \n  iVar2 = getStackPointer();\n  *(undefined4 *)(iVar2 + -4) = param8;\n  *(undefined4 *)(iVar2 + -8) = param7;\n  *(undefined4 *)(iVar2 + -0xc) = param6;\n  *(undefined4 *)(iVar2 + -0x10) = param5;\n  *(undefined4 *)(iVar2 + -0x14) = param4;\n  *(undefined4 *)(iVar2 + -0x18) = param3;\n  *(undefined4 *)(iVar2 + -0x1c) = param2;\n  *(undefined4 *)(iVar2 + -0x20) = param1;\n  *(undefined4 *)(iVar2 + -0x24) = param9;\n  activeThread->sp = (char *)(undefined4 *)(iVar2 + -0x24);\n  handleSvcInterrupt();\n  runScheduler();\n  jumpTable = *(code **)activeThread->sp;\n  nextStackPointer = (code **)((int)activeThread->sp + 0x24);\n  bVar1 = (bool)isPrivilegedMode();\n  if (bVar1) {\n    setStackPointer(nextStackPointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(jumpTable,nextStackPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000958": "execute_system_task_00000958",
                "unaff_r4": "param1",
                "unaff_r5": "param2",
                "unaff_r6": "param3",
                "unaff_r7": "param4",
                "unaff_r8": "param5",
                "unaff_r9": "param6",
                "unaff_r10": "param7",
                "unaff_r11": "param8",
                "in_lr": "param9",
                "getProcessStackPointer": "getStackPointer",
                "sched_active_thread": "activeThread",
                "isr_svc": "handleSvcInterrupt",
                "sched_run": "runScheduler",
                "ppcVar3": "nextStackPointer",
                "isCurrentModePrivileged": "isPrivilegedMode",
                "setProcessStackPointer": "setStackPointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "isr_svc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000974": {
            "entrypoint": "0x00000974",
            "current_name": "run_process_00000974",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid runProcess_00000974(void)\n\n{\n  bool isPrivileged;\n  code *jumptable;\n  code **processStack;\n  \n  sched_run();\n  jumptable = *(code **)activeThread->sp;\n  processStack = (code **)((int)activeThread->sp + 0x24);\n  isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    setProcessStackPointer(processStack);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable)(jumptable,processStack);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000974": "run_process_00000974",
                "UNRECOVERED_JUMPTABLE": "jumptable",
                "ppcVar2": "processStack",
                "bVar1": "isPrivileged",
                "sched_active_thread": "activeThread"
            },
            "calling": [
                "isr_pendsv"
            ],
            "called": [
                "sched_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000978": {
            "entrypoint": "0x00000978",
            "current_name": "execute_function_00000978",
            "code": "\nvoid executeFunction_00000978(void)\n\n{\n  bool isPrivilegedMode;\n  code *jumptable_func;\n  code **stack_pointer;\n  \n  jumptable_func = *(code **)activeThread->sp;\n  stack_pointer = (code **)((int)activeThread->sp + 0x24);\n  isPrivilegedMode = (bool)checkPrivilegedMode();\n  if (isPrivilegedMode) {\n    setStackPointer(stack_pointer);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable_func)(jumptable_func,stack_pointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000978": "execute_function_00000978",
                "sched_active_thread": "activeThread",
                "UNRECOVERED_JUMPTABLE": "jumptable_func",
                "ppcVar2": "stack_pointer",
                "bVar1": "isPrivilegedMode",
                "isCurrentModePrivileged": "checkPrivilegedMode",
                "setProcessStackPointer": "setStackPointer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000990": {
            "entrypoint": "0x00000990",
            "current_name": "FUNC_00000990",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000990(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000990": "FUNC_00000990"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000099c": {
            "entrypoint": "0x0000099c",
            "current_name": "initialize_system_0000099c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_0000099c(void)\n\n{\n  uint32_t stackTop;\n  uint32_t *stackPointer;\n  uint32_t *source;\n  uint32_t *destination;\n  \n  stackPointer = &stackTop;\n  source = (uint32_t *)&_etext;\n  pre_startup();\n  destination = (uint32_t *)isr_stack;\n  while (destination < &stackTop) {\n    *destination = 0xe7fee7fe;\n    destination = destination + 1;\n  }\n  destination = (uint32_t *)&heap_stackPointer;\n  while (destination < &sched_num_threads) {\n    *destination = *source;\n    source = source + 1;\n    destination = destination + 1;\n  }\n  destination = (uint32_t *)&sched_num_threads;\n  while (destination < &_sheap) {\n    *destination = 0;\n    destination = destination + 1;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000099c": "initialize_system_0000099c",
                "uStack_18": "stackTop",
                "top": "stackPointer",
                "src": "source",
                "dst": "destination"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "post_startup",
                "pre_startup",
                "kernel_init",
                "board_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a30": {
            "entrypoint": "0x00000a30",
            "current_name": "handle_nmi_00000a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_NMI_00000a30(void)\n\n{\n                    \n  core_panic(NMI_error_message,\"NMI HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000a30": "handle_nmi_00000a30",
                "PANIC_NMI_HANDLER": "NMI_error_message"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a40": {
            "entrypoint": "0x00000a40",
            "current_name": "calculate_stack_offset_00000a40",
            "code": "\nint calculateStackOffset_00000a40(uint32_t requiredOffset)\n\n{\n  uint32_t localOffset;\n  uint32_t *stackPointer;\n  \n  return (int)(&stack0xe000ffe8 + -requiredOffset);\n}\n\n",
            "renaming": {
                "FUN_00000a40": "calculate_stack_offset_00000a40",
                "required": "requiredOffset",
                "required_local": "localOffset",
                "sp": "stackPointer"
            },
            "calling": [
                "hard_fault_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000a64": {
            "entrypoint": "0x00000a64",
            "current_name": "handle_memory_corruption_00000a64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleMemoryCorruption_00000a64(void)\n\n{\n  uint32_t *stackPointer;\n  uint32_t isMemoryCorrupted;\n  uint32_t register4;\n  undefined4 register5;\n  undefined4 register6;\n  undefined4 register7;\n  undefined4 register8;\n  undefined4 register9;\n  undefined4 register10;\n  undefined4 register11;\n  uint linkRegister;\n  \n  if ((&_eram < &stack0x00000000) || (&stack0x00000000 < isr_stack + 0x159)) {\n    isMemoryCorrupted = 1;\n    register0x00000054 = (BADSPACEBASE *)&heap_top;\n  }\n  else {\n    isMemoryCorrupted = 0;\n  }\n  if ((linkRegister & 4) == 0) {\n    stackPointer = (uint32_t *)getMainStackPointer();\n  }\n  else {\n    stackPointer = (uint32_t *)getProcessStackPointer();\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) = register11;\n  *(undefined4 *)((int)register0x00000054 + -8) = register10;\n  *(undefined4 *)((int)register0x00000054 + -0xc) = register9;\n  *(undefined4 *)((int)register0x00000054 + -0x10) = register8;\n  *(undefined4 *)((int)register0x00000054 + -0x14) = register7;\n  *(undefined4 *)((int)register0x00000054 + -0x18) = register6;\n  *(undefined4 *)((int)register0x00000054 + -0x1c) = register5;\n  *(uint32_t *)((int)register0x00000054 + -0x20) = register4;\n                    \n  hard_fault_handler(stackPointer,isMemoryCorrupted,linkRegister,(uint32_t *)((int)register0x00000054 + -0x20));\n}\n\n",
            "renaming": {
                "FUN_00000a64": "handle_memory_corruption_00000a64",
                "sp": "stackPointer",
                "corrupted": "isMemoryCorrupted",
                "unaff_r4": "register4",
                "unaff_r5": "register5",
                "unaff_r6": "register6",
                "unaff_r7": "register7",
                "unaff_r8": "register8",
                "unaff_r9": "register9",
                "unaff_r10": "register10",
                "unaff_r11": "register11",
                "in_lr": "linkRegister"
            },
            "calling": [],
            "called": [
                "hard_fault_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000aa8": {
            "entrypoint": "0x00000aa8",
            "current_name": "handle_hard_fault_00000aa8",
            "code": "\n\n\nvoid handleHardFault_00000aa8(uint32_t *stackPointer,uint32_t isCorrupted,uint32_t exceptionReturn,uint32_t *registersR4ToR11Stack)\n\n{\n  uint cfsr;\n  undefined4 hfsr;\n  undefined4 dfsr;\n  undefined4 afs;\n  undefined4 bfar;\n  undefined4 mmfar;\n  int stackOverflow;\n  uint32_t r0;\n  uint32_t r1;\n  uint32_t r2;\n  uint32_t r3;\n  uint32_t r12;\n  uint32_t *registersR4ToR11StackLocal;\n  uint32_t exceptionReturnLocal;\n  uint32_t isCorruptedLocal;\n  uint32_t *stackPointerLocal;\n  int stackLeft;\n  uint32_t psr;\n  uint32_t lr;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *originalStackPointer;\n  uint32_t programCounter;\n  \n  mmfar = _DAT_e000ed3c;\n  bfar = _DAT_e000ed38;\n  afs = _DAT_e000ed34;\n  dfsr = _DAT_e000ed30;\n  hfsr = _DAT_e000ed2c;\n  cfsr = _DAT_e000ed28;\n  programCounter = 0;\n  if (isr_stack._0_4_ != -0x18011802) {\n    puts(\"\\nISR stack overflowed\");\n  }\n  if (isCorrupted == 0) {\n    r0 = *stackPointer;\n    r1 = stackPointer[1];\n    r2 = stackPointer[2];\n    r3 = stackPointer[4];\n    r12 = stackPointer[5];\n    programCounter = stackPointer[6];\n    puts(\"\\nContext before hardfault:\");\n    iprintf(\"   r0: 0x%08lx\\n   r1: 0x%08lx\\n   r2: 0x%08lx\\n   r3: 0x%08lx\\n\",r0,r1,r2);\n    iprintf(\"  r12: 0x%08lx\\n   lr: 0x%08lx\\n   programCounter: 0x%08lx\\n  psr: 0x%08lx\\n\\n\",r3,r12,programCounter);\n  }\n  else {\n    puts(\"Stack pointer isCorrupted, reset to top of stack\");\n  }\n  puts(\"FSR/FAR:\");\n  iprintf(\" CFSR: 0x%08lx\\n\",cfsr);\n  iprintf(\" HFSR: 0x%08lx\\n\",hfsr);\n  iprintf(\" DFSR: 0x%08lx\\n\",dfsr);\n  iprintf(\" AFSR: 0x%08lx\\n\",mmfar);\n  if ((cfsr & 0x8000) != 0) {\n    iprintf(\" BFAR: 0x%08lx\\n\",bfar);\n  }\n  if ((cfsr & 0x80) != 0) {\n    iprintf(\"MMFAR: 0x%08lx\\n\",afs);\n  }\n  puts(\"Misc\");\n  iprintf(\"EXC_RET: 0x%08lx\\n\",exceptionReturn);\n  if (isCorrupted == 0) {\n    puts(\"Attempting to reconstruct state for debugging...\");\n    iprintf(\"In GDB:\\n  set $programCounter=0x%lx\\n  frame 0\\n  bt\\n\",programCounter);\n    stackOverflow = _stack_size_left(0x158);\n    if (stackOverflow < 0) {\n      iprintf(\"\\nISR stack overflowed by at least %d bytes.\\n\",-stackOverflow);\n    }\n  }\n  software_bkpt(1);\n                    \n  core_panic(PANIC_HARD_FAULT,\"HARD FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000aa8": "handle_hard_fault_00000aa8",
                "sp": "stackPointer",
                "corrupted": "isCorrupted",
                "exc_return": "exceptionReturn",
                "r4_to_r11_stack": "registersR4ToR11Stack",
                "uVar1": "cfsr",
                "uVar2": "hfsr",
                "uVar3": "dfsr",
                "uVar4": "afs",
                "uVar5": "bfar",
                "uVar6": "mmfar",
                "iVar7": "stackOverflow",
                "uVar8": "r0",
                "uVar9": "r1",
                "uVar10": "r2",
                "uVar11": "r3",
                "uVar12": "r12",
                "r4_to_r11_stack_local": "registersR4ToR11StackLocal",
                "exc_return_local": "exceptionReturnLocal",
                "corrupted_local": "isCorruptedLocal",
                "sp_local": "stackPointerLocal",
                "stack_left": "stackLeft",
                "orig_sp": "originalStackPointer",
                "pc": "programCounter"
            },
            "calling": [
                "hard_fault_default"
            ],
            "called": [
                "core_panic",
                "iprintf",
                "puts",
                "_stack_size_left"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c80": {
            "entrypoint": "0x00000c80",
            "current_name": "handle_memory_management_00000c80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleMemoryManagement_00000c80(void)\n\n{\n                    \n  raiseError(memoryManagementError,\"MEM MANAGE HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c80": "handle_memory_management_00000c80",
                "PANIC_MEM_MANAGE": "memoryManagementError",
                "core_panic": "raiseError"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000c90": {
            "entrypoint": "0x00000c90",
            "current_name": "handle_bus_fault_00000c90",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleBusFault_00000c90(void)\n\n{\n                    \n  core_panic(busFaultErrorMessage,\"BUS FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000c90": "handle_bus_fault_00000c90",
                "PANIC_BUS_FAULT": "busFaultErrorMessage"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ca0": {
            "entrypoint": "0x00000ca0",
            "current_name": "handle_usage_fault_00000ca0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUsageFault_00000ca0(void)\n\n{\n                    \n  panic(USAGE_FAULT,\"USAGE FAULT HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000ca0": "handle_usage_fault_00000ca0",
                "PANIC_USAGE_FAULT": "USAGE_FAULT",
                "core_panic": "panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cb0": {
            "entrypoint": "0x00000cb0",
            "current_name": "handle_debug_mon_00000cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleDebugMon_00000cb0(void)\n\n{\n                    \n  panic(debugMonError,\"DEBUG MON HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cb0": "handle_debug_mon_00000cb0",
                "PANIC_DEBUG_MON": "debugMonError",
                "core_panic": "panic"
            },
            "calling": [],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cc0": {
            "entrypoint": "0x00000cc0",
            "current_name": "handle_dummy_00000cc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleDummy_00000cc0(void)\n\n{\n                    \n  core_panic(dummyErrorHandler,\"DUMMY HANDLER\");\n}\n\n",
            "renaming": {
                "FUN_00000cc0": "handle_dummy_00000cc0",
                "PANIC_DUMMY_HANDLER": "dummyErrorHandler"
            },
            "calling": [
                "dummy_handler"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cd0": {
            "entrypoint": "0x00000cd0",
            "current_name": "get_ir_qinterrupts_status_00000cd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint getIRQinterruptsStatus_00000cd0(void)\n\n{\n  bool isPrivilegedMode;\n  uint interruptsEnabled;\n  uint32_t returnValue;\n  uint32_t interruptsMask;\n  \n  interruptsEnabled = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cd0": "get_ir_qinterrupts_status_00000cd0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptsEnabled",
                "result": "returnValue",
                "mask": "interruptsMask"
            },
            "calling": [
                "pm_off",
                "core_panic",
                "mutex_unlock",
                "kernel_init",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock",
                "sched_task_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000cf0": {
            "entrypoint": "0x00000cf0",
            "current_name": "check_interrupt_status_00000cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint checkInterruptStatus_00000cf0(void)\n\n{\n  bool isPrivilegedMode;\n  uint interruptsEnabled;\n  uint32_t interruptStatus;\n  \n  enableIRQinterrupts();\n  interruptsEnabled = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    interruptsEnabled = isIRQinterruptsEnabled();\n  }\n  return interruptsEnabled;\n}\n\n",
            "renaming": {
                "FUN_00000cf0": "check_interrupt_status_00000cf0",
                "bVar1": "isPrivilegedMode",
                "uVar2": "interruptsEnabled",
                "result": "interruptStatus"
            },
            "calling": [
                "cpu_switch_context_exit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d0c": {
            "entrypoint": "0x00000d0c",
            "current_name": "enable_ir_qinterrupts_for_state_00000d0c",
            "code": "\nvoid enableIRQinterruptsForState_00000d0c(uint inputState)\n\n{\n  bool isPrivilegedMode;\n  uint localState;\n  \n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    enableIRQinterrupts((inputState & 1) == 1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d0c": "enable_ir_qinterrupts_for_state_00000d0c",
                "state": "inputState",
                "bVar1": "isPrivilegedMode",
                "state_local": "localState"
            },
            "calling": [
                "mutex_unlock",
                "kinetis_mcg_init",
                "thread_create",
                "_sbrk_r",
                "_mutex_lock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d2a": {
            "entrypoint": "0x00000d2a",
            "current_name": "get_exception_number_00000d2a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint getExceptionNumber_00000d2a(void)\n\n{\n  bool isPrivilegedMode;\n  uint exceptionNumber;\n  uint32_t exceptionBitmask;\n  \n  exceptionNumber = 0;\n  isPrivilegedMode = (bool)isCurrentModePrivileged();\n  if (isPrivilegedMode) {\n    exceptionNumber = getCurrentExceptionNumber();\n    exceptionNumber = exceptionNumber & 0x1f;\n  }\n  return exceptionNumber;\n}\n\n",
            "renaming": {
                "FUN_00000d2a": "get_exception_number_00000d2a",
                "bVar1": "isPrivilegedMode",
                "uVar2": "exceptionNumber",
                "result": "exceptionBitmask"
            },
            "calling": [
                "sched_switch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d44": {
            "entrypoint": "0x00000d44",
            "current_name": "calculate_offset_00000d44",
            "code": "\nvoid * calculateOffset_00000d44(void *inputPointer,uintinputPointer_t bitMask)\n\n{\n  uintinputPointer_t localBitMask;\n  void *localInputPointer;\n  \n  return (void *)(bitMask * 4 + ((uint)inputPointer & 0xf0000000 | ((uint)inputPointer & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "ptr": "inputPointer",
                "bit": "bitMask",
                "bit_local": "localBitMask",
                "ptr_local": "localInputPointer"
            },
            "calling": [
                "bit_clear32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d76": {
            "entrypoint": "0x00000d76",
            "current_name": "clear_bit_00000d76",
            "code": "\nvoid clearBit_00000d76(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *var_puVar1;\n  uint8_t var_bit_local;\n  uint32_t *var_ptr_local;\n  \n  var_puVar1 = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *var_puVar1 = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d76": "clear_bit_00000d76",
                "bit_local": "var_bit_local",
                "ptr_local": "var_ptr_local",
                "puVar1": "var_puVar1"
            },
            "calling": [
                "cpu_errata_fixes"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000d9c": {
            "entrypoint": "0x00000d9c",
            "current_name": "clear_register_bit_00000d9c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clearRegisterBit_00000d9c(void)\n\n{\n  bit_clear32((uint32_t *)0x40048040,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000d9c": "clear_register_bit_00000d9c"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [
                "bit_clear32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000db0": {
            "entrypoint": "0x00000db0",
            "current_name": "disable_watchdog_00000db0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_watchdog_00000db0(void)\n\n{\n  disable_watchdog_00000db0();\n  fix_cpu_errata();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000db0": "disable_watchdog_00000db0",
                "wdog_disable": "disable_watchdog",
                "cpu_errata_fixes": "fix_cpu_errata"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "wdog_disable",
                "cpu_errata_fixes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dc0": {
            "entrypoint": "0x00000dc0",
            "current_name": "initialize_default_handler_00000dc0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_default_handler_00000dc0(void)\n\n{\n  handle_default();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dc0": "initialize_default_handler_00000dc0",
                "dummy_handler_default": "handle_default"
            },
            "calling": [],
            "called": [
                "dummy_handler_default"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000dcc": {
            "entrypoint": "0x00000dcc",
            "current_name": "initialize_memory_00000dcc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_00000dcc(void)\n\n{\n  _DAT_4005200e = 0xd928;\n  _DAT_40052000 = 0xd2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000dcc": "initialize_memory_00000dcc"
            },
            "calling": [
                "pre_startup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000df4": {
            "entrypoint": "0x00000df4",
            "current_name": "initialize_uart_00000df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_00000df4(void)\n\n{\n  uart_init(0,0x1c200,isrpipe_write_callback + 1,&uart_stdio_callback);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000df4": "initialize_uart_00000df4",
                "isrpipe_write_one": "isrpipe_write_callback",
                "uart_stdio_isrpipe": "uart_stdio_callback"
            },
            "calling": [
                "_init"
            ],
            "called": [
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e14": {
            "entrypoint": "0x00000e14",
            "current_name": "read_uart_data_00000e14",
            "code": "\nint read_uart_data_00000e14(char *data_buffer,int buffer_size)\n\n{\n  int read_result;\n  int local_buffer_size;\n  char *local_data_buffer;\n  \n  read_result = isrpipe_read(&uart_stdio_isrpipe,data_buffer,buffer_size);\n  return read_result;\n}\n\n",
            "renaming": {
                "FUN_00000e14": "read_uart_data_00000e14",
                "buffer": "data_buffer",
                "count": "buffer_size",
                "iVar1": "read_result",
                "count_local": "local_buffer_size",
                "buffer_local": "local_data_buffer"
            },
            "calling": [
                "_read_r"
            ],
            "called": [
                "isrpipe_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e38": {
            "entrypoint": "0x00000e38",
            "current_name": "write_buffer_to_uart_00000e38",
            "code": "\nint write_buffer_to_uart_00000e38(char *buffer_ptr,int buffer_length)\n\n{\n  int local_buffer_length;\n  char *local_buffer_ptr;\n  \n  uart_write(0,(uint8_t *)buffer_ptr,buffer_length);\n  return buffer_length;\n}\n\n",
            "renaming": {
                "FUN_00000e38": "write_buffer_to_uart_00000e38",
                "buffer": "buffer_ptr",
                "len": "buffer_length",
                "len_local": "local_buffer_length",
                "buffer_local": "local_buffer_ptr"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000e58": {
            "entrypoint": "0x00000e58",
            "current_name": "FUNC_00000e58",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000e58(void)\n\n{\n  irq_disable();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000e58": "FUNC_00000e58"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "irq_disable"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000e64": {
            "entrypoint": "0x00000e64",
            "current_name": "initialize_gpio_00000e64",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_GPIO_00000e64(void)\n\n{\n  _DAT_40048038 = _DAT_40048038 | 0x200;\n  _DAT_40049048 = _DAT_40049048 & 0xfefff8ff;\n  cpu_init();\n  gpio_init(0x2056,GPIO_OUT);\n  gpio_init(0x511a,GPIO_OUT);\n  gpio_init(0x2055,GPIO_OUT);\n  gpio_set(0x2056);\n  gpio_set(0x511a);\n  gpio_set(0x2055);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000e64": "initialize_gpio_00000e64"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "gpio_set",
                "cpu_init",
                "gpio_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ed8": {
            "entrypoint": "0x00000ed8",
            "current_name": "print_lr_address_00000ed8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid print_lr_address_00000ed8(void)\n\n{\n  undefined4 lr_address;\n  uint32_t *lr_address_ptr;\n  \n  iprintf(\"%p\\n\",lr_address);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ed8": "print_lr_address_00000ed8",
                "in_lr": "lr_address",
                "lr_ptr": "lr_address_ptr"
            },
            "calling": [
                "core_panic"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000ef8": {
            "entrypoint": "0x00000ef8",
            "current_name": "FUNC_00000ef8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000ef8": "FUNC_00000ef8"
            },
            "calling": [
                "core_panic"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00000f04": {
            "entrypoint": "0x00000f04",
            "current_name": "handle_panic_00000f04",
            "code": "\nvoid handle_panic_00000f04(core_panic_t panic_code,char *panic_message)\n\n{\n  undefined4 uStack_18;\n  undefined4 uStack_14;\n  char *local_message;\n  core_panic_t local_panic_code;\n  \n  local_message = panic_message;\n  local_panic_code = panic_code;\n  if (is_crashed == 0) {\n    is_crashed = 1;\n    if (panic_code == ASSERTION_FAILED) {\n      print_last_instruction();\n    }\n    print_formatted(\"*** RIOT kernel panic:\\n%s\\n\\n\",local_message);\n    print_status();\n    print_formatted(\"\\n\");\n    print_formatted(\"*** halted.\\n\\n\");\n  }\n  irq_disable();\n  architecture_specific_panic();\n  uStack_14 = 0xf4d;\n  power_off();\n  uStack_18 = (int)&uStack_18 + 1;\n  initialize();\n  print_formatted(\"start_program(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  start_program();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000f04": "handle_panic_00000f04",
                "crash_code": "panic_code",
                "message": "panic_message",
                "message_local": "local_message",
                "crash_code_local": "local_panic_code",
                "crashed": "is_crashed",
                "PANIC_ASSERT_FAIL": "ASSERTION_FAILED",
                "cpu_print_last_instruction": "print_last_instruction",
                "iprintf": "print_formatted",
                "ps": "print_status",
                "panic_arch": "architecture_specific_panic",
                "pm_off": "power_off",
                "auto_init": "initialize",
                "main": "start_program"
            },
            "calling": [
                "debug_mon_default",
                "uart_init",
                "hard_fault_handler",
                "thread_add_to_list",
                "usage_fault_default",
                "bus_fault_default",
                "fmt_s32_dfp",
                "nmi_default",
                "mem_manage_default",
                "cib_init",
                "dummy_handler_default"
            ],
            "called": [
                "pm_off",
                "ps",
                "panic_arch",
                "cpu_print_last_instruction",
                "iprintf",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f5c": {
            "entrypoint": "0x00000f5c",
            "current_name": "initialize_riot_00000f5c",
            "code": "\nvoid * initialize_riot_00000f5c(void *arg_data)\n\n{\n  void *local_arg;\n  \n  perform_auto_initialization();\n  print_riot_version(\"call_main_function(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  call_main_function();\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_00000f5c": "initialize_riot_00000f5c",
                "arg": "arg_data",
                "arg_local": "local_arg",
                "auto_init": "perform_auto_initialization",
                "iprintf": "print_riot_version",
                "main": "call_main_function"
            },
            "calling": [],
            "called": [
                "auto_init",
                "iprintf",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f80": {
            "entrypoint": "0x00000f80",
            "current_name": "infinite_loop_00000f80",
            "code": "\nvoid * infiniteLoop_00000f80(void *arg)\n\n{\n  void *localArg;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00000f80": "infinite_loop_00000f80",
                "arg_local": "localArg"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000f8c": {
            "entrypoint": "0x00000f8c",
            "current_name": "initialize_system_00000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystem_00000f8c(void)\n\n{\n  irq_disable();\n  thread_create(idleStack,0x100,'\\x0f',0xc,idleThread + 1,(void *)0x0,idleThreadName);\n  thread_create(mainStack,0x600,'\\a',0xc,mainTrampoline + 1,(void *)0x0,mainThreadName);\n                    \n  cpu_switch_context_exit();\n}\n\n",
            "renaming": {
                "FUN_00000f8c": "initialize_system_00000f8c",
                "idle_stack": "idleStack",
                "main_stack": "mainStack",
                "idle_thread": "idleThread",
                "main_trampoline": "mainTrampoline",
                "idle_name": "idleThreadName",
                "main_name": "mainThreadName"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "cpu_switch_context_exit",
                "thread_create",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00000fec": {
            "entrypoint": "0x00000fec",
            "current_name": "initialize_circular_buffer_00000fec",
            "code": "\nvoid initializeCircularBuffer_00000fec(buffer_t *buffer,uint bufferSize)\n\n{\n  uint localBufferSize;\n  buffer_t *localBuffer;\n  buffer_t c;\n  \n  if ((bufferSize & bufferSize - 1) != 0) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  buffer->read_count = 0;\n  buffer->write_count = 0;\n  buffer->mask = bufferSize - 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00000fec": "initialize_circular_buffer_00000fec",
                "cib": "buffer",
                "size": "bufferSize",
                "size_local": "localBufferSize",
                "cib_local": "localBuffer"
            },
            "calling": [
                "thread_create"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001034": {
            "entrypoint": "0x00001034",
            "current_name": "insert_thread_into_list_00001034",
            "code": "\nvoid insertThreadIntoList_00001034(threadList_node_t *threadList,currentThread_t *currentThread)\n\n{\n  currentThread_t *tempThread;\n  threadList_node_t *tempList;\n  currentThread_t *entry;\n  cthreadList_node_t *unusedNode;\n  threadList_node_t *threadNode;\n  uint16_t threadPriority;\n  \n  if (currentThread->status < 9) {\n    tempList = threadList;\n    while ((tempList->next != (threadList_node *)0x0 &&\n           (*(byte *)((int)&tempList->next[-1].next + 1) <= currentThread->priority))) {\n      tempList = tempList->next;\n    }\n    (currentThread->rq_entry).next = tempList->next;\n    tempList->next = &currentThread->rq_entry;\n    return;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_00001034": "insert_thread_into_list_00001034",
                "list": "threadList",
                "thread": "currentThread",
                "thread_local": "tempThread",
                "list_local": "tempList",
                "list_entry": "entry",
                "__m____": "unusedNode",
                "new_node": "threadNode",
                "my_prio": "threadPriority"
            },
            "calling": [
                "_mutex_lock"
            ],
            "called": [
                "core_panic"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010a0": {
            "entrypoint": "0x000010a0",
            "current_name": "calculate_stack_space_000010a0",
            "code": "\nuintptr_t calculateStackSpace_000010a0(char *stackPointer)\n\n{\n  char *localStack;\n  uintptr_t freeSpace;\n  uintptr_t *currentStackPointer;\n  \n  for (currentStackPointer = (uintptr_t *)stackPointer; (uintptr_t *)*currentStackPointer == currentStackPointer; currentStackPointer = currentStackPointer + 1) {\n  }\n  return (int)currentStackPointer - (int)stackPointer;\n}\n\n",
            "renaming": {
                "FUN_000010a0": "calculate_stack_space_000010a0",
                "stack": "stackPointer",
                "stack_local": "localStack",
                "space_free": "freeSpace",
                "stackp": "currentStackPointer"
            },
            "calling": [
                "ps"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000010d4": {
            "entrypoint": "0x000010d4",
            "current_name": "create_thread_000010d4",
            "code": "\nkernel_new_thread_id_t\ncreate_thread_000010d4(char *stack_ptr,thread_indexnt stack_size,char thread_priority,thread_indexnt thread_flags,thread_structask_func_t task_func,vothread_indexd *task_arg\n            ,char *thread_name)\n\n{\n  uthread_indexnt disable_interrupts_state;\n  char *pointer_var;\n  thread_indexnt int_var;\n  uthread_indexnt total_stack_size;\n  thread_struct *new_thread;\n  thread_indexnt local_flags;\n  char local_priority;\n  thread_indexnt local_stack_size;\n  char *local_stack_ptr;\n  uthread_indexnt thread_state;\n  uthread_indexntptr_t *stack_max;\n  thread_struct *cb;\n  uthread_indexntptr_t stack_misalignment;\n  thread_indexnt full_stack_size;\n  uthread_indexntptr_t *stack_pointer;\n  kernel_new_thread_id_t thread_index;\n  kernel_new_thread_id_t new_thread_id;\n  \n  thread_indexf ((byte)thread_priority < 0x10) {\n    local_stack_size = stack_size;\n    local_stack_ptr = stack_ptr;\n    thread_indexf (((uthread_indexnt)stack_ptr & 3) != 0) {\n      int_var = 4 - ((uthread_indexnt)stack_ptr & 3);\n      local_stack_ptr = stack_ptr + int_var;\n      local_stack_size = stack_size - int_var;\n    }\n    total_stack_size = local_stack_size - 0x30U & 0xfffffffc;\n    new_thread = (thread_struct *)(local_stack_ptr + total_stack_size);\n    thread_indexf ((thread_flags & 8U) == 0) {\n      *(char **)local_stack_ptr = local_stack_ptr;\n    }\n    else {\n      for (stack_pointer = (uthread_indexntptr_t *)local_stack_ptr; stack_pointer < local_stack_ptr + total_stack_size; stack_pointer = stack_pointer + 1\n          ) {\n        *stack_pointer = (uthread_indexntptr_t)stack_pointer;\n      }\n    }\n    disable_interrupts_state = disable_interrupts();\n    new_thread_id = 0;\n    for (thread_index = 1; thread_index < 0x21; thread_index = thread_index + 1) {\n      thread_indexf (scheduled_threads[thread_index] == (thread_struct *)0x0) {\n        new_thread_id = thread_index;\n        break;\n      }\n    }\n    thread_indexf (new_thread_id == 0) {\n      restore_interrupts(disable_interrupts_state);\n      new_thread_id = -0x8b;\n    }\n    else {\n      scheduled_threads[new_thread_id] = new_thread;\n      new_thread->new_thread_id = new_thread_id;\n      pointer_var = initialize_thread_stack(task_func,task_arg,local_stack_ptr,total_stack_size);\n      new_thread->sp = pointer_var;\n      new_thread->stack_ptr_start = local_stack_ptr;\n      new_thread->total_stack_size = stack_size;\n      new_thread->thread_name = thread_name;\n      new_thread->thread_priority = thread_priority;\n      new_thread->status = '\\0';\n      (new_thread->rq_entry).next = (node *)0x0;\n      new_thread->wathread_indext_data = (vothread_indexd *)0x0;\n      (new_thread->msg_wathread_indexters).next = (node *)0x0;\n      initialize_cib(&new_thread->msg_queue,0);\n      new_thread->msg_array = (message *)0x0;\n      num_scheduled_threads = num_scheduled_threads + 1;\n      thread_indexf ((thread_flags & 1U) == 0) {\n        set_thread_status(new_thread,10);\n        thread_indexf ((thread_flags & 4U) == 0) {\n          restore_interrupts(disable_interrupts_state);\n          switch_thread((ushort)(byte)thread_priority);\n          return new_thread_id;\n        }\n      }\n      else {\n        set_thread_status(new_thread,1);\n      }\n      restore_interrupts(disable_interrupts_state);\n    }\n  }\n  else {\n    new_thread_id = -0x16;\n  }\n  return new_thread_id;\n}\n\n",
            "renaming": {
                "FUN_000010d4": "create_thread_000010d4",
                "stack": "stack_ptr",
                "stacksize": "stack_size",
                "priority": "thread_priority",
                "flags": "thread_flags",
                "function": "task_func",
                "arg": "task_arg",
                "name": "thread_name",
                "state_00": "disable_interrupts_state",
                "pcVar1": "pointer_var",
                "iVar2": "int_var",
                "stack_size": "total_stack_size",
                "process": "new_thread",
                "flags_local": "local_flags",
                "priority_local": "local_priority",
                "stacksize_local": "local_stack_size",
                "stack_local": "local_stack_ptr",
                "state": "thread_state",
                "stackmax": "stack_max",
                "misalignment": "stack_misalignment",
                "total_stacksize": "full_stack_size",
                "stackp": "stack_pointer",
                "i": "thread_index",
                "pid": "new_thread_id",
                "sched_threads": "scheduled_threads",
                "thread_t": "thread_struct",
                "irq_disable": "disable_interrupts",
                "irq_restore": "restore_interrupts",
                "thread_stack_init": "initialize_thread_stack",
                "sched_num_threads": "num_scheduled_threads",
                "sched_set_status": "set_thread_status",
                "sched_switch": "switch_thread",
                "list_node": "node",
                "cib_init": "initialize_cib",
                "msg_t": "message"
            },
            "calling": [
                "kernel_init"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "cib_init",
                "irq_disable",
                "thread_stack_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001274": {
            "entrypoint": "0x00001274",
            "current_name": "initialize_system_00001274",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_00001274(void)\n\n{\n  initialize_cortexm();\n  DAT_4007e000 = DAT_4007e000 | 0x28;\n  initialize_kinetis_mcg();\n  initialize_peripherals();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001274": "initialize_system_00001274",
                "cortexm_init": "initialize_cortexm",
                "kinetis_mcg_init": "initialize_kinetis_mcg",
                "periph_init": "initialize_peripherals"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "kinetis_mcg_init",
                "periph_init",
                "cortexm_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000129c": {
            "entrypoint": "0x0000129c",
            "current_name": "lock_mutex_0000129c",
            "code": "\nvoid lockMutex_0000129c(mutexPtr_t *mutexPtr)\n\n{\n  mutexPtr_t *localMutexPtr;\n  \n  _mutexPtr_lock(mutexPtr,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000129c": "lock_mutex_0000129c",
                "mutex": "mutexPtr",
                "mutex_local": "localMutexPtr"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "_mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012b4": {
            "entrypoint": "0x000012b4",
            "current_name": "add_character_to_buffer_000012b4",
            "code": "\nint addCharacterToBuffer_000012b4(inputPipe_t *inputPipe,char c)\n\n{\n  int returnValue;\n  char localCharacter;\n  inputPipe_t *localInputPipe;\n  int result;\n  \n  returnValue = tsrb_add_one(&inputPipe->tsrb,c);\n  mutex_unlock(&inputPipe->mutex);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_000012b4": "add_character_to_buffer_000012b4",
                "isrpipe": "inputPipe",
                "c_local": "localCharacter",
                "isrpipe_local": "localInputPipe",
                "res": "result",
                "iVar1": "returnValue"
            },
            "calling": [],
            "called": [
                "mutex_unlock",
                "tsrb_add_one"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000012e2": {
            "entrypoint": "0x000012e2",
            "current_name": "read_from_isr_pipe_000012e2",
            "code": "\nint readFromISRPipe_000012e2(pipe_t *pipe,char *dataBuffer,size_t bufferSize)\n\n{\n  int iVar1;\n  size_t localBufferSize;\n  char *localDataBuffer;\n  pipe_t *localPipe;\n  int result;\n  \n  while( true ) {\n    iVar1 = tsrb_get(&pipe->tsrb,dataBuffer,bufferSize);\n    if (iVar1 != 0) break;\n    mutex_lock(&pipe->mutex);\n  }\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_000012e2": "read_from_isr_pipe_000012e2",
                "isrpipe": "pipe",
                "buffer": "dataBuffer",
                "count": "bufferSize",
                "count_local": "localBufferSize",
                "buffer_local": "localDataBuffer",
                "isrpipe_local": "localPipe",
                "res": "result"
            },
            "calling": [
                "uart_stdio_read"
            ],
            "called": [
                "tsrb_get",
                "mutex_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001318": {
            "entrypoint": "0x00001318",
            "current_name": "set_irq_flag_00001318",
            "code": "\nvoid setIRQFlag_00001318(interruptNumber_Type interruptNumber)\n\n{\n  interruptNumber_Type localInterruptNumber;\n  \n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << (interruptNumber & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001318": "set_irq_flag_00001318",
                "IRQn": "interruptNumber",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "uart_init_uart"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001348": {
            "entrypoint": "0x00001348",
            "current_name": "handle_context_switch_00001348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_context_switch_00001348(void)\n\n{\n  if (context_switch_requested != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001348": "handle_context_switch_00001348",
                "sched_context_switch_request": "context_switch_requested"
            },
            "calling": [
                "irq_handler_uart"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001360": {
            "entrypoint": "0x00001360",
            "current_name": "calculate_offset_00001360",
            "code": "\nvoid * calculateOffset_00001360(void *originalPtr,uintoriginalPtr_t bitShift)\n\n{\n  uintoriginalPtr_t localBitShift;\n  void *localPtr;\n  \n  return (void *)(bitShift * 4 + ((uint)originalPtr & 0xf0000000 | ((uint)originalPtr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001360": "calculate_offset_00001360",
                "ptr": "originalPtr",
                "bit": "bitShift",
                "bit_local": "localBitShift",
                "ptr_local": "localPtr"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001392": {
            "entrypoint": "0x00001392",
            "current_name": "set_bit_value_00001392",
            "code": "\nvoid setBitValue_00001392(uint32_t *ptr,uint8_t bitPosition)\n\n{\n  undefined4 *bitAddress;\n  uint8_t localBit;\n  uint32_t *localPtr;\n  \n  bitAddress = (undefined4 *)bitPositionband_addr(ptr,(uint)bitPosition);\n  *bitAddress = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001392": "set_bit_value_00001392",
                "bit": "bitPosition",
                "bit_local": "localBit",
                "ptr_local": "localPtr",
                "puVar1": "bitAddress"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000013b8": {
            "entrypoint": "0x000013b8",
            "current_name": "initialize_uart_000013b8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000142e) */\n\nint initializeUart_000013b8(uartInstance_t uartInstance,uint32_t baudrate,uartInstance_receiveCallback_t receiveCallback,void *argument)\n\n{\n  void *localArgument;\n  uartInstance_receiveCallback_t localReceiveCallback;\n  uint32_t localBaudrate;\n  uartInstance_t localUart;\n  \n  if (uartInstance == 0) {\n    config[0].receiveCallback = receiveCallback;\n    config[0].argument = argument;\n    uartInstance_init_pins(0);\n    bit_set32((uint32_t *)&DAT_40048034,'\\n');\n    uartInstance_init_uartInstance(0,baudrate);\n    return 0;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
            "renaming": {
                "FUN_000013b8": "initialize_uart_000013b8",
                "uart": "uartInstance",
                "rx_cb": "receiveCallback",
                "arg": "argument",
                "arg_local": "localArgument",
                "rx_cb_local": "localReceiveCallback",
                "baudrate_local": "localBaudrate",
                "uart_local": "localUart"
            },
            "calling": [
                "uart_stdio_init"
            ],
            "called": [
                "uart_init_uart",
                "core_panic",
                "uart_init_pins",
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001448": {
            "entrypoint": "0x00001448",
            "current_name": "initialize_uart_00001448",
            "code": "\nvoid initializeUART_00001448(uartInstance_t uartInstance)\n\n{\n  uartInstance_t localUART;\n  \n  if (uartConfiguration[uartInstance].rxPin != 0xffff) {\n    gpio_init_port(uartConfiguration[uartInstance].rxPin,uartConfiguration[uartInstance].rxPinConfig);\n  }\n  if (uartConfiguration[uartInstance].txPin != 0xffff) {\n    gpio_init_port(uartConfiguration[uartInstance].txPin,uartConfiguration[uartInstance].txPinConfig);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001448": "initialize_uart_00001448",
                "uart": "uartInstance",
                "uart_local": "localUART",
                "uart_config": "uartConfiguration",
                "pin_rx": "rxPin",
                "pin_tx": "txPin",
                "pcr_rx": "rxPinConfig",
                "pcr_tx": "txPinConfig"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "gpio_init_port"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000014c4": {
            "entrypoint": "0x000014c4",
            "current_name": "configure_uart_000014c4",
            "code": "\nvoid configureUART_000014c4(uartDevice_t uartDevice,uint32_t desiredBaudRate)\n\n{\n  byte *uartDeviceConfig;\n  uint uartDeviceFreq;\n  uint baudRateDivisor;\n  uint32_t localBaudRate;\n  uartDevice_t localUART;\n  uint8_t transmitFifoSize;\n  uint8_t baudRateFineAdjust;\n  uint16_t uartBaudRateDivisor;\n  uint32_t clock;\n  UART_Type *uartDeviceRegister;\n  \n  uartDeviceConfig = (byte *)uartDeviceConfiguration[uartDevice].uartDeviceRegister;\n  uartDeviceFreq = uartDeviceConfiguration[uartDevice].uartDeviceFrequency;\n  uartDeviceConfig[3] = uartDeviceConfig[3] & 0xf3;\n  uartDeviceConfig[2] = uartDeviceConfiguration[uartDevice].mode;\n  baudRateDivisor = uartDeviceFreq / (desiredBaudRate << 4);\n  *uartDeviceConfig = (byte)(baudRateDivisor >> 8) & 0x1f;\n  uartDeviceConfig[1] = (byte)baudRateDivisor;\n  uartDeviceConfig[10] = (byte)((uartDeviceFreq << 2) / desiredBaudRate + 1 >> 1) & 0x1f;\n  uartDeviceConfig[0x10] = uartDeviceConfig[0x10] | 0x88;\n  if ((uartDeviceConfig[0x10] & 0x70) == 0) {\n    uartDeviceConfig[0x13] = 0;\n  }\n  else {\n    uartDeviceConfig[0x13] = (char)(2 << (uartDeviceConfig[0x10] >> 4 & 7)) - 1;\n  }\n  uartDeviceConfig[0x15] = 1;\n  uartDeviceConfig[0x11] = 0xc0;\n  uartDeviceConfig[3] = uartDeviceConfig[3] | 0x2c;\n  NVIC_EnableIRQ(uartDeviceConfiguration[uartDevice].uartDeviceIRQNumber);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000014c4": "configure_uart_000014c4",
                "uart": "uartDevice",
                "baudrate": "desiredBaudRate",
                "pbVar1": "uartDeviceConfig",
                "uVar2": "uartDeviceFreq",
                "uVar3": "baudRateDivisor",
                "baudrate_local": "localBaudRate",
                "uart_local": "localUART",
                "txfifo_size": "transmitFifoSize",
                "brfa": "baudRateFineAdjust",
                "ubd": "uartBaudRateDivisor",
                "clk": "clock",
                "dev": "uartDeviceRegister",
                "uart_config": "uartDeviceConfiguration",
                "freq": "uartDeviceFrequency",
                "irqn": "uartDeviceIRQNumber"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "NVIC_EnableIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000015d0": {
            "entrypoint": "0x000015d0",
            "current_name": "send_data_via_uart_000015d0",
            "code": "\nvoindexd sendDataViaUART_000015d0(uartDevice_t uartDevice,uindexnt8_t *dataBuffer,sindexze_t bufferLength)\n\n{\n  voindexd *uartDeviceConfig;\n  sindexze_t localLength;\n  uindexnt8_t *localData;\n  uartDevice_t localUART;\n  UART_Type *device;\n  sindexze_t index;\n  \n  uartDeviceConfig = uartDevice_confindexg[uartDevice].device;\n  for (index = 0; index < bufferLength; index = index + 1) {\n    do {\n    } whindexle (-1 < *(char *)((indexnt)uartDeviceConfig + 4));\n    *(uindexnt8_t *)((indexnt)uartDeviceConfig + 7) = dataBuffer[index];\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000015d0": "send_data_via_uart_000015d0",
                "uart": "uartDevice",
                "data": "dataBuffer",
                "len": "bufferLength",
                "len_local": "localLength",
                "data_local": "localData",
                "uart_local": "localUART",
                "dev": "device",
                "i": "index",
                "pvVar1": "uartDeviceConfig"
            },
            "calling": [
                "uart_stdio_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001628": {
            "entrypoint": "0x00001628",
            "current_name": "handle_uart_data_00001628",
            "code": "\nvoid handleUartData_00001628(uartInstance_t uartInstance)\n\n{\n  uartInstance_t localUart;\n  uint8_t receivedData;\n  UART_Type *uartDevice;\n  \n  if (((*(byte *)((int)uartInstance_config[uartInstance].uartDevice + 4) & 0x20) != 0) &&\n     (config[uartInstance].rx_cb != (uartInstance_rx_cb_t)0x0)) {\n    (*config[uartInstance].rx_cb)(config[uartInstance].arg,*(uint8_t *)((int)uartInstance_config[uartInstance].uartDevice + 7));\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001628": "handle_uart_data_00001628",
                "uart": "uartInstance",
                "uart_local": "localUart",
                "data": "receivedData",
                "dev": "uartDevice"
            },
            "calling": [
                "isr_uart0_rx_tx"
            ],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001688": {
            "entrypoint": "0x00001688",
            "current_name": "initialize_uart_irq_handler_00001688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_irq_handler_00001688(void)\n\n{\n  handle_uart_irq(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001688": "initialize_uart_irq_handler_00001688",
                "irq_handler_uart": "handle_uart_irq"
            },
            "calling": [],
            "called": [
                "irq_handler_uart"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001696": {
            "entrypoint": "0x00001696",
            "current_name": "calculate_offset_00001696",
            "code": "\nvoid * calculateOffset_00001696(void *originalPtr,uintoriginalPtr_t bitFlag)\n\n{\n  uintoriginalPtr_t localBitFlag;\n  void *localOriginalPtr;\n  \n  return (void *)(bitFlag * 4 + ((uint)originalPtr & 0xf0000000 | ((uint)originalPtr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001696": "calculate_offset_00001696",
                "ptr": "originalPtr",
                "bit": "bitFlag",
                "bit_local": "localBitFlag",
                "ptr_local": "localOriginalPtr"
            },
            "calling": [
                "bit_clear8",
                "bit_set8",
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016c8": {
            "entrypoint": "0x000016c8",
            "current_name": "set_bit_to1_000016c8",
            "code": "\nvoid setBitTo1_000016c8(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *pointerToBit;\n  uint8_t bitValue;\n  uint32_t *localPointer;\n  \n  pointerToBit = (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *pointerToBit = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016c8": "set_bit_to1_000016c8",
                "bit_local": "bitValue",
                "ptr_local": "localPointer",
                "puVar1": "pointerToBit"
            },
            "calling": [
                "kinetis_mcg_init_erclk32k"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000016ec": {
            "entrypoint": "0x000016ec",
            "current_name": "set_bit_000016ec",
            "code": "\nvoid setBit_000016ec(uint8_t *ptr,uint8_t bit_position)\n\n{\n  undefined *puVar1;\n  uint8_t bitValue;\n  uint8_t *localPtr;\n  \n  puVar1 = (undefined *)bit_positionband_addr(ptr,(uint)bit_position);\n  *puVar1 = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000016ec": "set_bit_000016ec",
                "bit": "bit_position",
                "bit_local": "bitValue",
                "ptr_local": "localPtr"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001710": {
            "entrypoint": "0x00001710",
            "current_name": "clear_bit_in_pointer_00001710",
            "code": "\nvoid clearBitInPointer_00001710(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *bitPtr;\n  uint8_t bit_local;\n  uint8_t *ptr_local;\n  \n  bitPtr = (undefined *)bitband_addr(ptr,(uint)bit);\n  *bitPtr = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001710": "clear_bit_in_pointer_00001710",
                "puVar1": "bitPtr"
            },
            "calling": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_disable_pll"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001734": {
            "entrypoint": "0x00001734",
            "current_name": "clear_bit_0x40064005_00001734",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clear_bit_0x40064005_00001734(void)\n\n{\n  bit_clear8(&DAT_40064005,'\\x06');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001734": "clear_bit_0x40064005_00001734"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_blpe"
            ],
            "called": [
                "bit_clear8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001748": {
            "entrypoint": "0x00001748",
            "current_name": "update_fll_factor_00001748",
            "code": "\nvoid updateFLLFactor_00001748(kinetis_mcg_fll_t newFactor)\n\n{\n  kinetis_mcg_fll_t localFactor;\n  \n  DAT_40064003 = newFactor | DAT_40064003 & ~KINETIS_MCG_FLL_FACTOR_2929;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001748": "update_fll_factor_00001748",
                "factor": "newFactor",
                "factor_local": "localFactor"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_safe_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001778": {
            "entrypoint": "0x00001778",
            "current_name": "update_flags_00001778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n/* WARNING: Unknown calling convention */\n\nvoid updateFlags_00001778(void)\n\n{\n  DAT_40064001 = DAT_40064001 & 0xcf | 0x20;\n  bit_clear8(&DAT_40064001,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001778": "update_flags_00001778"
            },
            "calling": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fee"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000017dc": {
            "entrypoint": "0x000017dc",
            "current_name": "set_bit_and_check_000017dc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid set_bit_and_check_000017dc(void)\n\n{\n  set_bit((uint32_t *)&DAT_4004803c,'\\x1d');\n  if ((_DAT_4003d010 & 0x100) == 0) {\n    _DAT_4003d010 = 0x104;\n  }\n  _DAT_40047000 = _DAT_40047000 & 0xfff3ffff | 0x80000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000017dc": "set_bit_and_check_000017dc",
                "bit_set32": "set_bit"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_set32"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000182c": {
            "entrypoint": "0x0000182c",
            "current_name": "clear_flags_0000182c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n/* WARNING: Unknown calling convention */\n\nvoid clearFlags_0000182c(void)\n\n{\n  uint8_t temporary;\n  \n  DAT_40064008 = DAT_40064008 & 0xd0;\n  bit_set8(&DAT_40064001,'\\0');\n  bit_clear8(&DAT_40064000,'\\x01');\n  bit_clear8(&DAT_40064000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000182c": "clear_flags_0000182c",
                "tmp": "temporary"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000018bc": {
            "entrypoint": "0x000018bc",
            "current_name": "initialize_clock_system_000018bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClockSystem_000018bc(void)\n\n{\n  kinetis_mcg_set_fll_factor(FLLFactor1464);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  clearBit8(&DAT_40064001,'\\x01');\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  operationMode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000018bc": "initialize_clock_system_000018bc",
                "KINETIS_MCG_FLL_FACTOR_1464": "FLLFactor1464",
                "bit_clear8": "clearBit8",
                "current_mode": "operationMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000191c": {
            "entrypoint": "0x0000191c",
            "current_name": "initialize_fll_0000191c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFLL_0000191c(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(FLL_FACTOR_1920);\n  DAT_40064000 = DAT_40064000 & 0x3b;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  current_mode = FEE_MODE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000191c": "initialize_fll_0000191c",
                "KINETIS_MCG_FLL_FACTOR_1920": "FLL_FACTOR_1920",
                "KINETIS_MCG_MODE_FEE": "FEE_MODE"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001960": {
            "entrypoint": "0x00001960",
            "current_name": "initialize_fll_00001960",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeFLL_00001960(void)\n\n{\n  kinetis_mcg_set_fll_factor(fllFactor1464);\n  bit_clear8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x44;\n  do {\n  } while ((DAT_40064006 & 0xc) != 4);\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  currentMode = KINETIS_MCG_MODE_FBI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001960": "initialize_fll_00001960",
                "KINETIS_MCG_FLL_FACTOR_1464": "fllFactor1464",
                "current_mode": "currentMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000019c0": {
            "entrypoint": "0x000019c0",
            "current_name": "initialize_system_000019c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_system_000019c0(void)\n\n{\n  enable_oscillator();\n  set_fll_factor(fll_factor);\n  clear_bit_8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3b | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  disable_pll();\n  current_operation_mode = fbe_mode;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000019c0": "initialize_system_000019c0",
                "KINETIS_MCG_FLL_FACTOR_1920": "fll_factor",
                "kinetis_mcg_enable_osc": "enable_oscillator",
                "kinetis_mcg_set_fll_factor": "set_fll_factor",
                "bit_clear8": "clear_bit_8",
                "kinetis_mcg_disable_pll": "disable_pll",
                "current_mode": "current_operation_mode",
                "KINETIS_MCG_MODE_FBE": "fbe_mode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_enable_osc",
                "kinetis_mcg_set_fll_factor",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a18": {
            "entrypoint": "0x00001a18",
            "current_name": "initialize_blpi_mode_00001a18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeBlpiMode_00001a18(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  disablePll();\n  mcgMode = KINETIS_MCG_MODE_BLPI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a18": "initialize_blpi_mode_00001a18",
                "kinetis_mcg_disable_pll": "disablePll",
                "current_mode": "mcgMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a3c": {
            "entrypoint": "0x00001a3c",
            "current_name": "initialize_blpe_mode_00001a3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeBlpeMode_00001a3c(void)\n\n{\n  bit_set8(&DAT_40064001,'\\x01');\n  disablePll();\n  operationMode = KINETIS_MCG_MODE_BLPE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a3c": "initialize_blpe_mode_00001a3c",
                "kinetis_mcg_disable_pll": "disablePll",
                "current_mode": "operationMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_set8",
                "kinetis_mcg_disable_pll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001a60": {
            "entrypoint": "0x00001a60",
            "current_name": "initialize_clock_00001a60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClock_00001a60(void)\n\n{\n  bit_clear8(&DAT_40064001,'\\x01');\n  DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n  do {\n  } while ((DAT_40064006 & 0xc) != 8);\n  bit_set8(&DAT_40064005,'\\x06');\n  do {\n  } while ((DAT_40064006 & 0x20) == 0);\n  do {\n  } while ((DAT_40064006 & 0x40) == 0);\n  clockMode = KINETIS_MCG_MODE_PBE;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001a60": "initialize_clock_00001a60",
                "current_mode": "clockMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [
                "bit_clear8",
                "bit_set8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ad4": {
            "entrypoint": "0x00001ad4",
            "current_name": "initialize_mcg_mode_00001ad4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCGMode_00001ad4(void)\n\n{\n  DAT_40064000 = DAT_40064000 & 0x3f;\n  do {\n  } while ((DAT_40064006 & 0xc) != 0xc);\n  mcgCurrentMode = PLLEnabledMode;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ad4": "initialize_mcg_mode_00001ad4",
                "current_mode": "mcgCurrentMode",
                "KINETIS_MCG_MODE_PEE": "PLLEnabledMode"
            },
            "calling": [
                "kinetis_mcg_set_mode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001b10": {
            "entrypoint": "0x00001b10",
            "current_name": "set_mcg_mode_00001b10",
            "code": "\nint setMCGMode_00001b10(kinetis_mcg_selectedMode_t selectedMode)\n\n{\n  int result;\n  kinetis_mcg_selectedMode_t currentMode;\n  \n  if (selectedMode < KINETIS_MCG_MODE_NUMOF) {\n    do {\n      switch(mcg_selectedMode_routing[current_selectedMode][selectedMode]) {\n      case '\\0':\n        kinetis_mcg_set_fei();\n        break;\n      case '\\x01':\n        kinetis_mcg_set_fee();\n        break;\n      case '\\x02':\n        kinetis_mcg_set_fbi();\n        break;\n      case '\\x03':\n        kinetis_mcg_set_fbe();\n        break;\n      case '\\x04':\n        kinetis_mcg_set_blpi();\n        break;\n      case '\\x05':\n        kinetis_mcg_set_blpe();\n        break;\n      case '\\x06':\n        kinetis_mcg_set_pbe();\n        break;\n      case '\\a':\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return -1;\n      }\n    } while (selectedMode != current_selectedMode);\n    result = 0;\n  }\n  else {\n    result = -1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00001b10": "set_mcg_mode_00001b10",
                "mode": "selectedMode",
                "iVar1": "result",
                "mode_local": "currentMode"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "kinetis_mcg_set_fbe",
                "kinetis_mcg_set_fbi",
                "kinetis_mcg_set_fee",
                "kinetis_mcg_set_fei",
                "kinetis_mcg_set_pbe",
                "kinetis_mcg_set_blpi",
                "kinetis_mcg_set_pee",
                "kinetis_mcg_set_blpe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001bb8": {
            "entrypoint": "0x00001bb8",
            "current_name": "initialize_mcu_generator_00001bb8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCUGenerator_00001bb8(void)\n\n{\n  if ((DAT_40064001 & 2) != 0) {\n    bit_clear8(&DAT_40064001,'\\x01');\n  }\n  if ((DAT_40064005 & 0x40) != 0) {\n    if ((DAT_40064000 & 0xc0) == 0) {\n      DAT_40064000 = DAT_40064000 & 0x3f | 0x80;\n      do {\n      } while ((DAT_40064006 & 0xc) != 8);\n    }\n    bit_clear8(&DAT_40064005,'\\x06');\n    do {\n    } while ((DAT_40064006 & 0x20) != 0);\n  }\n  setFLLFactor(fllFactor);\n  DAT_40064000 = DAT_40064000 & 0x3b | 4;\n  do {\n  } while ((DAT_40064006 & 0x10) == 0);\n  do {\n  } while ((DAT_40064006 & 0xc) != 0);\n  mode = KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001bb8": "initialize_mcu_generator_00001bb8",
                "kinetis_mcg_set_fll_factor": "setFLLFactor",
                "KINETIS_MCG_FLL_FACTOR_640": "fllFactor",
                "current_mode": "mode"
            },
            "calling": [
                "kinetis_mcg_init"
            ],
            "called": [
                "bit_clear8",
                "kinetis_mcg_set_fll_factor"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001c84": {
            "entrypoint": "0x00001c84",
            "current_name": "initialize_mcu_00001c84",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMCU_00001c84(void)\n\n{\n  uint interruptState;\n  uint interruptMask;\n  \n  interruptState = irq_disable();\n  kinetis_mcg_set_safe_mode();\n  _DAT_40048044 = 0x220000;\n  DAT_4006400c = 0;\n  DAT_40064000 = DAT_40064000 & 199 | 0x38;\n  DAT_40064004 = 0x13;\n  DAT_40064005 = 0;\n  kinetis_mcg_init_mcgirclk();\n  kinetis_mcg_init_erclk32k();\n  kinetis_mcg_set_mode(KINETIS_MCG_MODE_PEE);\n  irq_restore(interruptState);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001c84": "initialize_mcu_00001c84",
                "state": "interruptState",
                "mask": "interruptMask"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "kinetis_mcg_init_mcgirclk",
                "kinetis_mcg_init_erclk32k",
                "irq_restore",
                "kinetis_mcg_set_safe_mode",
                "kinetis_mcg_set_mode",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001cf0": {
            "entrypoint": "0x00001cf0",
            "current_name": "check_and_yield_00001cf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_00001cf0(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001cf0": "check_and_yield_00001cf0"
            },
            "calling": [
                "irq_handler"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d08": {
            "entrypoint": "0x00001d08",
            "current_name": "calculate_offset_00001d08",
            "code": "\nvoid * calculateOffset_00001d08(void *ptr,uintptr_t bit)\n\n{\n  uintptr_t bit;\n  void *input;\n  \n  return (void *)(bit * 4 + ((uint)ptr & 0xf0000000 | ((uint)ptr & 0xfffff) << 5) + 0x2000000);\n}\n\n",
            "renaming": {
                "FUN_00001d08": "calculate_offset_00001d08",
                "bit_local": "bit",
                "ptr_local": "input"
            },
            "calling": [
                "bit_set32"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d3a": {
            "entrypoint": "0x00001d3a",
            "current_name": "set_bit_00001d3a",
            "code": "\nvoid setBit_00001d3a(uint32_t *ptr,uint8_t bitNumber)\n\n{\n  undefined4 *pointer;\n  uint8_t bitNumber_local;\n  uint32_t *ptr_local;\n  \n  pointer = (undefined4 *)bitNumberband_addr(ptr,(uint)bitNumber);\n  *pointer = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001d3a": "set_bit_00001d3a",
                "bit": "bitNumber",
                "bit_local": "bitNumber_local",
                "puVar1": "pointer"
            },
            "calling": [
                "clk_en"
            ],
            "called": [
                "bitband_addr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d5e": {
            "entrypoint": "0x00001d5e",
            "current_name": "get_port_type_from_pin_00001d5e",
            "code": "\nPortType * getPortTypeFromPin_00001d5e(gpio_t pin)\n\n{\n  gpio_t localPin;\n  \n  return (PortType *)(pin & 0x7000 | 0x40048000);\n}\n\n",
            "renaming": {
                "FUN_00001d5e": "get_port_type_from_pin_00001d5e",
                "pin_local": "localPin",
                "PORT_Type": "PortType"
            },
            "calling": [
                "gpio_init_port",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001d80": {
            "entrypoint": "0x00001d80",
            "current_name": "get_gpio_type_from_pin_00001d80",
            "code": "\ngpio_type * get_GPIO_Type_from_pin_00001d80(gpio_t pin)\n\n{\n  gpio_t local_pin;\n  \n  return (gpio_type *)(pin & 0x1c0 | 0x400ff000);\n}\n\n",
            "renaming": {
                "FUN_00001d80": "get_gpio_type_from_pin_00001d80",
                "pin_local": "local_pin",
                "GPIO_Type": "gpio_type"
            },
            "calling": [
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001da2": {
            "entrypoint": "0x00001da2",
            "current_name": "extract_gpio_pin_bits_00001da2",
            "code": "\nint extractGpioPinBits_00001da2(gpio_t pinValue)\n\n{\n  gpio_t localPinValue;\n  \n  return pinValue >> 6 & 7;\n}\n\n",
            "renaming": {
                "FUN_00001da2": "extract_gpio_pin_bits_00001da2",
                "pin": "pinValue",
                "pin_local": "localPinValue"
            },
            "calling": [
                "gpio_init_port",
                "clk_en"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001dc0": {
            "entrypoint": "0x00001dc0",
            "current_name": "extract_gpio_bits_00001dc0",
            "code": "\nint extractGPIOBits_00001dc0(gpio_t pinValue)\n\n{\n  gpio_t localPin;\n  \n  return pinValue & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_00001dc0": "extract_gpio_bits_00001dc0",
                "pin": "pinValue",
                "pin_local": "localPin"
            },
            "calling": [
                "gpio_init_port",
                "gpio_set",
                "gpio_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ddc": {
            "entrypoint": "0x00001ddc",
            "current_name": "set_pin_function_00001ddc",
            "code": "\nvoid setPinFunction_00001ddc(gpio_t targetPin)\n\n{\n  int portNumber;\n  gpio_t newPin;\n  \n  portNumber = port_num(targetPin);\n  bit_set32((uint32_t *)&DAT_40048038,(char)portNumber + '\\t');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ddc": "set_pin_function_00001ddc",
                "pin": "targetPin",
                "iVar1": "portNumber",
                "pin_local": "newPin"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "bit_set32",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e0c": {
            "entrypoint": "0x00001e0c",
            "current_name": "get_pin_value_00001e0c",
            "code": "\nint getPinValue_00001e0c(int portNumber,int pinNumber)\n\n{\n  int localPin;\n  int localPort;\n  \n  return isr_map[(pinNumber >> 3) + portNumber * 4] >> ((pinNumber & 7U) << 2) & 0xf;\n}\n\n",
            "renaming": {
                "FUN_00001e0c": "get_pin_value_00001e0c",
                "port": "portNumber",
                "pin": "pinNumber",
                "pin_local": "localPin",
                "port_local": "localPort"
            },
            "calling": [
                "ctx_clear",
                "irq_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001e44": {
            "entrypoint": "0x00001e44",
            "current_name": "update_isr_map_00001e44",
            "code": "\nvoid updateISRMap_00001e44(int port,int pin,int context)\n\n{\n  int shiftAmount;\n  int localContext;\n  int localPin;\n  int localPort;\n  \n  shiftAmount = pin >> 3;\n  isr_map[shiftAmount + port * 4] = isr_map[shiftAmount + port * 4] & ~(0xf << ((pin & 7U) << 2));\n  isr_map[shiftAmount + port * 4] = isr_map[shiftAmount + port * 4] | context << ((pin & 7U) << 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001e44": "update_isr_map_00001e44",
                "ctx": "context",
                "iVar1": "shiftAmount",
                "ctx_local": "localContext",
                "pin_local": "localPin",
                "port_local": "localPort"
            },
            "calling": [
                "ctx_clear"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ec4": {
            "entrypoint": "0x00001ec4",
            "current_name": "write_context_to_map_00001ec4",
            "code": "\nvoid writeContextToMap_00001ec4(int inputPort,int inputPin)\n\n{\n  int context;\n  int localPin;\n  int localPort;\n  int context;\n  \n  context = get_context(inputPort,inputPin);\n  write_map(inputPort,inputPin,context);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ec4": "write_context_to_map_00001ec4",
                "port": "inputPort",
                "pin": "inputPin",
                "ctx_00": "context",
                "pin_local": "localPin",
                "port_local": "localPort",
                "ctx": "context"
            },
            "calling": [
                "gpio_init_port"
            ],
            "called": [
                "get_ctx",
                "write_map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001eea": {
            "entrypoint": "0x00001eea",
            "current_name": "initialize_gpio_00001eea",
            "code": "\nint initializeGPIO_00001eea(gpio_t gpioPin,gpio_gpioMode_t gpioMode)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPtr;\n  PORT_Type *portPtr;\n  int pinNum;\n  gpio_gpioMode_t localMode;\n  gpio_t localPin;\n  \n  gpio_init_port(gpioPin,0);\n  if ((char)gpioMode < '\\0') {\n    pinNumber = gpioPin_num(gpioPin);\n    gpioPtr = gpio(gpioPin);\n    gpioPtr->PDDR = gpioPtr->PDDR | 1 << (pinNumber & 0xff);\n  }\n  else {\n    pinNumber = gpioPin_num(gpioPin);\n    gpioPtr = gpio(gpioPin);\n    gpioPtr->PDDR = gpioPtr->PDDR & ~(1 << (pinNumber & 0xff));\n  }\n  portPtr = port(gpioPin);\n  pinNum = gpioPin_num(gpioPin);\n  portPtr->PCR[pinNum] = gpioMode & 0x23 | 0x100;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00001eea": "initialize_gpio_00001eea",
                "pin": "gpioPin",
                "mode": "gpioMode",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPtr",
                "pPVar3": "portPtr",
                "iVar4": "pinNum",
                "mode_local": "localMode",
                "pin_local": "localPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio_init_port",
                "gpio",
                "port",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001f80": {
            "entrypoint": "0x00001f80",
            "current_name": "set_pin_configuration_00001f80",
            "code": "\nvoid setPinConfiguration_00001f80(gpio_t gpioPin,uint32_t pinConfiguration)\n\n{\n  PORT_Type *portPtr;\n  int pinIndex;\n  int pinNum;\n  uint previousPcrVal;\n  uint32_t localPinConfiguration;\n  gpio_t localGpioPin;\n  uint32_t interruptState;\n  \n  clk_en(gpioPin);\n  portPtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  previousPcrVal = portPtr->PCR[pinIndex];\n  portPtr = port(gpioPin);\n  pinIndex = gpioPin_num(gpioPin);\n  portPtr->PCR[pinIndex] = pinConfiguration;\n  if ((previousPcrVal & 0xf0000) != 0) {\n    pinIndex = port_num(gpioPin);\n    pinNum = gpioPin_num(gpioPin);\n    ctx_clear(pinIndex,pinNum);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001f80": "set_pin_configuration_00001f80",
                "pin": "gpioPin",
                "pcr": "pinConfiguration",
                "pPVar1": "portPtr",
                "iVar2": "pinIndex",
                "pin_00": "pinNum",
                "uVar3": "previousPcrVal",
                "pcr_local": "localPinConfiguration",
                "pin_local": "localGpioPin",
                "isr_state": "interruptState"
            },
            "calling": [
                "uart_init_pins",
                "gpio_init"
            ],
            "called": [
                "port",
                "pin_num",
                "ctx_clear",
                "clk_en",
                "port_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00001ff6": {
            "entrypoint": "0x00001ff6",
            "current_name": "set_pin_output_high_00001ff6",
            "code": "\nvoid setPinOutputHigh_00001ff6(gpio_t gpioPin)\n\n{\n  uint pinNumber;\n  GPIO_Type *gpioPort;\n  gpio_t localPin;\n  \n  pinNumber = gpioPin_num(gpioPin);\n  gpioPort = gpio(gpioPin);\n  gpioPort->PSOR = 1 << (pinNumber & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00001ff6": "set_pin_output_high_00001ff6",
                "pin": "gpioPin",
                "uVar1": "pinNumber",
                "pGVar2": "gpioPort",
                "pin_local": "localPin"
            },
            "calling": [
                "board_init"
            ],
            "called": [
                "gpio",
                "pin_num"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002028": {
            "entrypoint": "0x00002028",
            "current_name": "process_interrupts_00002028",
            "code": "\nvoid processInterrupts_00002028(PORT_Type *portType,int portNumber)\n\n{\n  int index;\n  uint isfrValue;\n  int localPortNumber;\n  PORT_Type *localPortType;\n  int context;\n  uint32_t status;\n  int i;\n  \n  isfrValue = portType->ISFR;\n  for (i = 0; i < 0x20; i = i + 1) {\n    if (((isfrValue & 1 << (i & 0xffU)) != 0) && ((portType->PCR[i] & 0xf0000) != 0)) {\n      portType->ISFR = 1 << (i & 0xffU);\n      index = get_context(portNumber,i);\n      (*isr_context[index].cb)(isr_context[index].arg);\n    }\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002028": "process_interrupts_00002028",
                "port": "portType",
                "port_num": "portNumber",
                "iVar1": "index",
                "uVar2": "isfrValue",
                "port_num_local": "localPortNumber",
                "port_local": "localPortType",
                "ctx": "context"
            },
            "calling": [
                "isr_portc",
                "isr_portd",
                "isr_porte",
                "isr_portb",
                "isr_porta"
            ],
            "called": [
                "get_ctx",
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020b8": {
            "entrypoint": "0x000020b8",
            "current_name": "initialize_irq_handler_000020b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQHandler_000020b8(void)\n\n{\n  irq_handler((PORT_Type *)0x40049000,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020b8": "initialize_irq_handler_000020b8"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020cc": {
            "entrypoint": "0x000020cc",
            "current_name": "initialize_interrupt_000020cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeInterrupt_000020cc(void)\n\n{\n  irq_handler((PORT_Type *)0x4004a000,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020cc": "initialize_interrupt_000020cc"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020e0": {
            "entrypoint": "0x000020e0",
            "current_name": "initialize_port_interrupt_000020e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePortInterrupt_000020e0(void)\n\n{\n  irq_handler((PORT_Type *)0x4004b000,2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020e0": "initialize_port_interrupt_000020e0"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000020f4": {
            "entrypoint": "0x000020f4",
            "current_name": "initialize_irq_000020f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQ_000020f4(void)\n\n{\n  irq_handler((port *)0x4004c000,3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000020f4": "initialize_irq_000020f4",
                "PORT_Type": "port"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002108": {
            "entrypoint": "0x00002108",
            "current_name": "initialize_irq_handler_00002108",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeIRQHandler_00002108(void)\n\n{\n  irq_handler((port *)0x4004d000,4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002108": "initialize_irq_handler_00002108",
                "PORT_Type": "port"
            },
            "calling": [],
            "called": [
                "irq_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000211c": {
            "entrypoint": "0x0000211c",
            "current_name": "print_thread_stack_info_0000211c",
            "code": "\n/* WARNING: Unknown callpidng conventpidon */\n\nvopidd printThreadStackInfo_0000211c(vopidd)\n\n{\n  byte bVar1;\n  pidnt pidVar2;\n  vopidd *threadvVar3;\n  vopidd *threadvVar4;\n  upidntthreadtr_t uVar5;\n  thread_type *threadtVar6;\n  char *threadcVar7;\n  char queue_name [2];\n  pidnt stack_size;\n  char *queued;\n  char *state_name;\n  pidnt status;\n  thread_type *thread;\n  vopidd *isr_stack_pointer;\n  vopidd *isr_stack_start;\n  pidnt isr_stack_usage;\n  kernel_process_id_t pid;\n  pidnt total_used_stack;\n  pidnt total_stack_size;\n  \n  queue_name[0] = '_';\n  queue_name[1] = 'Q';\n  total_used_stack = 0;\n  print_formatted(\"\\tprocess_id | %-21s| %-9sQ | threadrpid | stack  ( used) | base addr  | current     \\n\",&DAT_000070b8,\n          \"status\");\n  pidVar2 = get_isr_stack_usage();\n  threadvVar3 = get_isr_stack_start();\n  threadvVar4 = get_isr_stack_pointer();\n  print_formatted(\"\\t  - | pidsr_stack            | -        - |   - | %6pid (%5pid) | %10thread | %10thread\\n\",0x200,pidVar2,\n          threadvVar3,threadvVar4);\n  total_stack_size = 0x200;\n  pidf (0 < pidVar2) {\n    total_used_stack = pidVar2;\n  }\n  for (pid = 1; pid < 0x21; pid = pid + 1) {\n    threadtVar6 = scheduling_threads[pid];\n    pidf (threadtVar6 != (thread_type *)0x0) {\n      bVar1 = threadtVar6->thread_status;\n      threadcVar7 = status_names[bVar1];\n      pidVar2 = threadtVar6->stack_spidze;\n      total_stack_size = pidVar2 + total_stack_size;\n      uVar5 = measure_stack_free(threadtVar6->stack_start);\n      pidVar2 = pidVar2 - uVar5;\n      total_used_stack = pidVar2 + total_used_stack;\n      print_formatted(\"\\t%3hpid | %-20s | %-8s %.1s | %3pid | %6pid (%5pid) | %10thread | %10thread \\n\",(pidnt)threadtVar6->process_id,\n              threadtVar6->thread_name,threadcVar7,queue_name + (8 < bVar1),(upidnt)threadtVar6->threadrpidorpidty,\n              threadtVar6->stack_spidze,pidVar2,threadtVar6->stack_start,threadtVar6->stack_pointer);\n    }\n  }\n  print_formatted(\"\\t%5s %-21s|%13s%6s %6pid (%5pid)\\n\",&DAT_00007190,&DAT_00007194,&DAT_00007190,&DAT_00007190,\n          total_stack_size,total_used_stack);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000211c": "print_thread_stack_info_0000211c",
                "queued_name": "queue_name",
                "stacksz": "stack_size",
                "sname": "state_name",
                "state": "status",
                "p": "thread",
                "isr_sp": "isr_stack_pointer",
                "isr_start": "isr_stack_start",
                "isr_usage": "isr_stack_usage",
                "i": "pid",
                "overall_used": "total_used_stack",
                "overall_stacksz": "total_stack_size",
                "thread_isr_stack_usage": "get_isr_stack_usage",
                "thread_isr_stack_start": "get_isr_stack_start",
                "thread_isr_stack_pointer": "get_isr_stack_pointer",
                "iprintf": "print_formatted",
                "thread_measure_stack_free": "measure_stack_free",
                "sched_threads": "scheduling_threads",
                "status": "thread_status",
                "state_names": "status_names",
                "thread_t": "thread_type",
                "pid": "process_id",
                "name": "thread_name",
                "sp": "stack_pointer"
            },
            "calling": [
                "core_panic",
                "_ps_handler"
            ],
            "called": [
                "thread_isr_stack_start",
                "thread_isr_stack_usage",
                "iprintf",
                "thread_isr_stack_pointer",
                "thread_measure_stack_free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002270": {
            "entrypoint": "0x00002270",
            "current_name": "count_set_bits_00002270",
            "code": "\nint countSetBits_00002270(tsbitArray_t *bitArray)\n\n{\n  byte bVar1;\n  uint writeCount;\n  bool isEqual;\n  tsbitArray_t *localBitArray;\n  \n  writeCount = bitArray->writes;\n  isEqual = bitArray->reads == writeCount;\n  if (isEqual) {\n    writeCount = 1;\n  }\n  bVar1 = (byte)writeCount;\n  if (!isEqual) {\n    bVar1 = 0;\n  }\n  return (uint)bVar1;\n}\n\n",
            "renaming": {
                "FUN_00002270": "count_set_bits_00002270",
                "rb": "bitArray",
                "uVar2": "writeCount",
                "bVar3": "isEqual",
                "rb_local": "localBitArray"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002294": {
            "entrypoint": "0x00002294",
            "current_name": "check_circular_buffer_fullness_00002294",
            "code": "\nint checkCircularBufferFullness_00002294(tscircularBuffer_t *circularBuffer)\n\n{\n  byte isFull;\n  uint bufferSize;\n  bool isBufferFull;\n  tscircularBuffer_t *localCircularBuffer;\n  \n  bufferSize = circularBuffer->size;\n  isBufferFull = circularBuffer->writes - circularBuffer->reads == bufferSize;\n  if (isBufferFull) {\n    bufferSize = 1;\n  }\n  isFull = (byte)bufferSize;\n  if (!isBufferFull) {\n    isFull = 0;\n  }\n  return (uint)isFull;\n}\n\n",
            "renaming": {
                "FUN_00002294": "check_circular_buffer_fullness_00002294",
                "rb": "circularBuffer",
                "bVar1": "isFull",
                "uVar2": "bufferSize",
                "bVar3": "isBufferFull",
                "rb_local": "localCircularBuffer"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022be": {
            "entrypoint": "0x000022be",
            "current_name": "write_char_to_ring_buffer_000022be",
            "code": "\nvoid writeCharToRingBuffer_000022be(tsringBuffer_t *ringBuffer,char c)\n\n{\n  uint writeIndex;\n  char localChar;\n  tsringBuffer_t *localRingBuffer;\n  \n  writeIndex = ringBuffer->writes;\n  ringBuffer->writes = writeIndex + 1;\n  ringBuffer->buf[writeIndex & ringBuffer->size - 1] = c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000022be": "write_char_to_ring_buffer_000022be",
                "rb": "ringBuffer",
                "uVar1": "writeIndex",
                "c_local": "localChar",
                "rb_local": "localRingBuffer"
            },
            "calling": [
                "tsrb_add_one"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000022f0": {
            "entrypoint": "0x000022f0",
            "current_name": "read_from_circular_buffer_000022f0",
            "code": "\nchar readFromCircularBuffer_000022f0(tscircBuffer_t *circBuffer)\n\n{\n  uint readIndex;\n  tscircBuffer_t *localBuffer;\n  \n  readIndex = circBuffer->reads;\n  circBuffer->reads = readIndex + 1;\n  return circBuffer->buf[readIndex & circBuffer->size - 1];\n}\n\n",
            "renaming": {
                "FUN_000022f0": "read_from_circular_buffer_000022f0",
                "rb": "circBuffer",
                "uVar1": "readIndex",
                "rb_local": "localBuffer"
            },
            "calling": [
                "tsrb_get"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000231c": {
            "entrypoint": "0x0000231c",
            "current_name": "extract_data_from_tsrb_0000231c",
            "code": "\nisizet extract_data_from_tsrb_0000231c(tstsrb_t *tsrb,char *output,size_t size)\n\n{\n  char current_element;\n  isizet is_empty;\n  size_t remaining_size;\n  char *dst_ptr;\n  tstsrb_t *rb_ptr;\n  size_t remaining_elements;\n  \n  dst_ptr = output;\n  remaining_elements = size;\n  while ((remaining_elements != 0 && (is_empty = tstsrb_empty(tsrb), is_empty == 0))) {\n    current_element = _pop(tsrb);\n    *dst_ptr = current_element;\n    remaining_elements = remaining_elements - 1;\n    dst_ptr = dst_ptr + 1;\n  }\n  retursize size - remaining_elements;\n}\n\n",
            "renaming": {
                "FUN_0000231c": "extract_data_from_tsrb_0000231c",
                "rb": "tsrb",
                "dst": "output",
                "n": "size",
                "n_local": "remaining_size",
                "dst_local": "dst_ptr",
                "rb_local": "rb_ptr",
                "tmp": "remaining_elements",
                "cVar1": "current_element",
                "iVar2": "is_empty"
            },
            "calling": [
                "isrpipe_read"
            ],
            "called": [
                "tsrb_empty",
                "_pop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002364": {
            "entrypoint": "0x00002364",
            "current_name": "add_character_to_ring_buffer_00002364",
            "code": "\nint addCharacterToRingBuffer_00002364(tsringBuffer_t *ringBuffer,char c)\n\n{\n  int isBufferFull;\n  char localCharacter;\n  tsringBuffer_t *localRingBuffer;\n  \n  isBufferFull = tsringBuffer_full(ringBuffer);\n  if (isBufferFull == 0) {\n    _push(ringBuffer,c);\n    isBufferFull = 0;\n  }\n  else {\n    isBufferFull = -1;\n  }\n  return isBufferFull;\n}\n\n",
            "renaming": {
                "FUN_00002364": "add_character_to_ring_buffer_00002364",
                "rb": "ringBuffer",
                "iVar1": "isBufferFull",
                "c_local": "localCharacter",
                "rb_local": "localRingBuffer"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "_push",
                "tsrb_full"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002396": {
            "entrypoint": "0x00002396",
            "current_name": "initialize_rtc_00002396",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_rtc_00002396(void)\n\n{\n  initialize_real_time_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002396": "initialize_rtc_00002396",
                "rtc_init": "initialize_real_time_clock"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "rtc_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023a4": {
            "entrypoint": "0x000023a4",
            "current_name": "initialize_shell_000023a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeShell_000023a4(void)\n\n{\n  char lineBuffer [128];\n  \n  startForkserver(0);\n  puts(\"Welcome to RIOT!\");\n                    \n  shell_run((shell_command_t *)0x0,lineBuffer,0x80);\n}\n\n",
            "renaming": {
                "FUN_000023a4": "initialize_shell_000023a4",
                "line_buf": "lineBuffer"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [
                "startForkserver",
                "puts",
                "shell_run"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023c8": {
            "entrypoint": "0x000023c8",
            "current_name": "handle_interrupt_000023c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t handle_interrupt_000023c8(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_000023c8": "handle_interrupt_000023c8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000023d0": {
            "entrypoint": "0x000023d0",
            "current_name": "execute_hyper_call_000023d0",
            "code": "\nint executeHyperCall_000023d0(int inputTicks)\n\n{\n  uint32_t callResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    callResult = aflCall(1,inputTicks,0);\n  }\n  else {\n    callResult = 0;\n  }\n  return callResult;\n}\n\n",
            "renaming": {
                "FUN_000023d0": "execute_hyper_call_000023d0",
                "ticks": "inputTicks",
                "uVar1": "callResult",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002400": {
            "entrypoint": "0x00002400",
            "current_name": "FUNC_00002400",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00002400(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002400": "FUNC_00002400"
            },
            "calling": [
                "main_trampoline"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0000240c": {
            "entrypoint": "0x0000240c",
            "current_name": "remove_list_node_0000240c",
            "code": "\nlistHead_node_t * removeListNode_0000240c(listHead_node_t *listHead)\n\n{\n  listHead_node *nextNode;\n  listHead_node_t *currentListNode;\n  listHead_node_t *listEnd;\n  \n  nextNode = listHead->next;\n  if (nextNode != (listHead_node *)0x0) {\n    listHead->next = nextNode->next;\n  }\n  return nextNode;\n}\n\n",
            "renaming": {
                "FUN_0000240c": "remove_list_node_0000240c",
                "list": "listHead",
                "plVar1": "nextNode",
                "list_local": "currentListNode",
                "head": "listEnd"
            },
            "calling": [
                "mutex_unlock"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002434": {
            "entrypoint": "0x00002434",
            "current_name": "acquire_mutex_00002434",
            "code": "\nint acquireMutex_00002434(mutexPtr_t *mutexPtr,int isBlocking)\n\n{\n  currentThread_t *currentThread;\n  uint irqState;\n  int result;\n  int localBlocking;\n  mutexPtr_t *localMutex;\n  uint irqState2;\n  currentThread_t *currentThread;\n  \n  irqState = irq_disable();\n  currentThread = sched_active_currentThread;\n  if ((mutexPtr->queue).next == (list_node *)0x0) {\n    (mutexPtr->queue).next = (list_node *)0xffffffff;\n    irq_restore(irqState);\n    result = 1;\n  }\n  else if (isBlocking == 0) {\n    irq_restore(irqState);\n    result = 0;\n  }\n  else {\n    sched_set_status(sched_active_currentThread,2);\n    if ((mutexPtr->queue).next == (list_node *)0xffffffff) {\n      (mutexPtr->queue).next = &currentThread->rq_entry;\n      ((mutexPtr->queue).next)->next = (list_node *)0x0;\n    }\n    else {\n      currentThread_add_to_list(&mutexPtr->queue,currentThread);\n    }\n    irq_restore(irqState);\n    currentThread_yield_higher();\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00002434": "acquire_mutex_00002434",
                "mutex": "mutexPtr",
                "blocking": "isBlocking",
                "thread": "currentThread",
                "state": "irqState",
                "iVar1": "result",
                "blocking_local": "localBlocking",
                "mutex_local": "localMutex",
                "irqstate": "irqState2",
                "me": "currentThread"
            },
            "calling": [
                "mutex_lock"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "thread_yield_higher",
                "thread_add_to_list",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000024bc": {
            "entrypoint": "0x000024bc",
            "current_name": "process_mutex_function_000024bc",
            "code": "\nvoid processMutexFunction_000024bc(processMutex_t *processMutex)\n\n{\n  byte byteValue;\n  uint irqState;\n  list_node_t *removedNode;\n  processMutex_t *localMutex;\n  uint16_t priority;\n  uint irqState;\n  clist_node_t *clnode;\n  list_node_t *nextNode;\n  thread_t *currentProcess;\n  \n  irqState = irq_disable();\n  if ((processMutex->queue).nextNode == (list_node *)0x0) {\n    irq_restore(irqState);\n  }\n  else if ((processMutex->queue).nextNode == (list_node *)0xffffffff) {\n    (processMutex->queue).nextNode = (list_node *)0x0;\n    irq_restore(irqState);\n  }\n  else {\n    removedNode = list_remove_head(&processMutex->queue);\n    sched_set_status((thread_t *)(removedNode + -2),10);\n    if ((processMutex->queue).nextNode == (list_node *)0x0) {\n      (processMutex->queue).nextNode = (list_node *)0xffffffff;\n    }\n    byteValue = *(byte *)((int)&removedNode[-1].nextNode + 1);\n    irq_restore(irqState);\n    sched_switch((ushort)byteValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000024bc": "process_mutex_function_000024bc",
                "mutex": "processMutex",
                "bVar1": "byteValue",
                "state": "irqState",
                "plVar2": "removedNode",
                "mutex_local": "localMutex",
                "process_priority": "priority",
                "irqstate": "irqState",
                "__m____": "clnode",
                "next": "nextNode",
                "process": "currentProcess"
            },
            "calling": [
                "isrpipe_write_one"
            ],
            "called": [
                "irq_restore",
                "sched_set_status",
                "sched_switch",
                "list_remove_head",
                "irq_disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002538": {
            "entrypoint": "0x00002538",
            "current_name": "set_priority_00002538",
            "code": "\nvoid setPriority_00002538(interruptNumber_Type interruptNumber,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < DMA0_interruptNumber) {\n    (&DAT_e000ed14)[(byte)interruptNumber & 0xf] = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002538": "set_priority_00002538",
                "IRQn": "interruptNumber",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "cortexm_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000258c": {
            "entrypoint": "0x0000258c",
            "current_name": "initialize_interrupts_0000258c",
            "code": "\n\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeInterrupts_0000258c(voindexd)\n\n{\n  uindexnt index;\n  \n  _DAT_e000ed08 = 0;\n  NVIC_SetPrindexorindexty(PendSVInterrupt,1);\n  NVIC_SetPrindexorindexty(SVCallInterrupt,1);\n  for (index = 0; index < 0x66; index = index + 1) {\n    NVIC_SetPrindexorindexty((InterruptType)index,1);\n  }\n  _DAT_e000ed10 = _DAT_e000ed10 | 0x10;\n  _DAT_e000ed14 = _DAT_e000ed14 | 0x200;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000258c": "initialize_interrupts_0000258c",
                "i": "index",
                "PendSV_IRQn": "PendSVInterrupt",
                "SVCall_IRQn": "SVCallInterrupt",
                "IRQn_Type": "InterruptType"
            },
            "calling": [
                "cpu_init"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000025f4": {
            "entrypoint": "0x000025f4",
            "current_name": "initialize_round_trip_timer_000025f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_round_trip_timer_000025f4(void)\n\n{\n  initialize_round_trip_timer_000025f4_internal();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000025f4": "initialize_round_trip_timer_000025f4",
                "rtt_init": "initialize_round_trip_timer_internal"
            },
            "calling": [
                "periph_init"
            ],
            "called": [
                "rtt_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002600": {
            "entrypoint": "0x00002600",
            "current_name": "set_counter_00002600",
            "code": "\nintimeValue setCounter_00002600(timeValuem *inputTime)\n\n{\n  uintimeValue32_timeValue counterValue;\n  timeValuem *localTime;\n  inputTime_timeValue timeValue;\n  \n  counterValue = mkinputTime((timeValuem *)inputTime);\n  rtimeValuetimeValue_setimeValue_counterValue(counterValue);\n  retimeValueurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002600": "set_counter_00002600",
                "time": "inputTime",
                "counter": "counterValue",
                "time_local": "localTime",
                "t": "timeValue"
            },
            "calling": [
                "_rtc_settime"
            ],
            "called": [
                "mktime",
                "rtt_set_counter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002624": {
            "entrypoint": "0x00002624",
            "current_name": "convert_counter_to_time_00002624",
            "code": "\nincounter convertCounterToTime_00002624(counterm *timeStruct)\n\n{\n  counterm *localTimeStruct;\n  timeStruct_counter counter;\n  \n  counter_low = rcountercounter_gecounter_councounterer();\n  counter_high = 0;\n  gmtimeStruct_r((timeStruct_counter *)&counter,(counterm *)timeStruct);\n  recounterurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002624": "convert_counter_to_time_00002624",
                "time": "timeStruct",
                "time_local": "localTimeStruct",
                "t": "counter",
                "t._0_4_": "counter_low",
                "t._4_4_": "counter_high"
            },
            "calling": [
                "_rtc_gettime"
            ],
            "called": [
                "rtt_get_counter",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002654": {
            "entrypoint": "0x00002654",
            "current_name": "set_rtc_alarm_00002654",
            "code": "\ninconvertedTime setRTCAlarm_00002654(convertedTimem *timestamp,rconvertedTimec_alarmTime_cb_convertedTime cb,void *userArgument)\n\n{\n  uinconvertedTime32_convertedTime alarmTime;\n  void *localArgument;\n  rconvertedTimec_alarmTime_cb_convertedTime localCallback;\n  convertedTimem *localTimestamp;\n  timestamp_convertedTime convertedTime;\n  \n  alarmTime = mktimestamp((convertedTimem *)timestamp);\n  rconvertedTimec_callback.cb = cb;\n  rconvertedTimeconvertedTime_seconvertedTime_alarmTime(alarmTime,rconvertedTimec_cb + 1,userArgument);\n  reconvertedTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002654": "set_rtc_alarm_00002654",
                "time": "timestamp",
                "arg": "userArgument",
                "alarm": "alarmTime",
                "arg_local": "localArgument",
                "cb_local": "localCallback",
                "time_local": "localTimestamp",
                "t": "convertedTime"
            },
            "calling": [
                "_rtc_setalarm"
            ],
            "called": [
                "mktime",
                "rtt_set_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002690": {
            "entrypoint": "0x00002690",
            "current_name": "convert_to_utc_00002690",
            "code": "\ninalarmTime convertToUtc_00002690(alarmTimem *inputTime)\n\n{\n  alarmTimem *localTime;\n  inputTime_alarmTime alarmTime;\n  \n  alarmTime._0_4_ = ralarmTimealarmTime_gealarmTime_alarm();\n  alarmTime._4_4_ = 0;\n  gminputTime_r((inputTime_alarmTime *)&alarmTime,(alarmTimem *)inputTime);\n  realarmTimeurn 0;\n}\n\n",
            "renaming": {
                "FUN_00002690": "convert_to_utc_00002690",
                "time": "inputTime",
                "time_local": "localTime",
                "t": "alarmTime"
            },
            "calling": [
                "_rtc_getalarm"
            ],
            "called": [
                "rtt_get_alarm",
                "gmtime_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026c0": {
            "entrypoint": "0x000026c0",
            "current_name": "clear_rtc_alarm_000026c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid clear_rtc_alarm_000026c0(void)\n\n{\n  rtt_clear_alarm();\n  rtc_alarm_callback.cb = (rtc_alarm_cb_t)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026c0": "clear_rtc_alarm_000026c0",
                "rtc_callback": "rtc_alarm_callback"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_clear_alarm"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026d8": {
            "entrypoint": "0x000026d8",
            "current_name": "power_on_rtt_000026d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid power_on_rtt_000026d8(void)\n\n{\n  power_on_rtt_000026d8();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026d8": "power_on_rtt_000026d8",
                "rtt_poweron": "power_on_rtt"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026e4": {
            "entrypoint": "0x000026e4",
            "current_name": "power_off_rtt_000026e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid power_off_rtt_000026e4(void)\n\n{\n  power_off();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026e4": "power_off_rtt_000026e4",
                "rtt_poweroff": "power_off"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtt_poweroff"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000026f0": {
            "entrypoint": "0x000026f0",
            "current_name": "handle_rtc_callback_000026f0",
            "code": "\nvoid handle_rtc_callback_000026f0(void *callback_arg)\n\n{\n  void *local_arg;\n  \n  if (rtc_callback.cb != (rtc_alarm_cb_t)0x0) {\n    (*rtc_callback.cb)(callback_arg);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000026f0": "handle_rtc_callback_000026f0",
                "arg": "callback_arg",
                "arg_local": "local_arg"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002714": {
            "entrypoint": "0x00002714",
            "current_name": "set_irq_priority_00002714",
            "code": "\nvoid setIRQPriority_00002714(interruptType_Type interruptType)\n\n{\n  interruptType_Type localInterruptType;\n  \n  *(int *)(((uint)(int)interruptType >> 5) * 4 + -0x1fff1f00) = 1 << (interruptType & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002714": "set_irq_priority_00002714",
                "IRQn": "interruptType",
                "IRQn_local": "localInterruptType"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002744": {
            "entrypoint": "0x00002744",
            "current_name": "set_irq_priority_00002744",
            "code": "\nvoid setIRQPriority_00002744(interrupt_Type interrupt,uint32_t newPriority)\n\n{\n  uint32_t localPriority;\n  interrupt_Type localInterrupt;\n  \n  if (interrupt < DMA0_interrupt) {\n    (&DAT_e000ed14)[(byte)interrupt & 0xf] = (char)((newPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interrupt + -0x1fff1c00) = (char)((newPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002744": "set_irq_priority_00002744",
                "IRQn": "interrupt",
                "priority": "newPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterrupt"
            },
            "calling": [
                "rtt_set_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002798": {
            "entrypoint": "0x00002798",
            "current_name": "check_and_yield_00002798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid check_and_yield_00002798(void)\n\n{\n  if (sched_context_switch_request != 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002798": "check_and_yield_00002798"
            },
            "calling": [
                "isr_rtc"
            ],
            "called": [
                "thread_yield_higher"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000027b0": {
            "entrypoint": "0x000027b0",
            "current_name": "initialize_rtc_000027b0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRTC_000027b0(void)\n\n{\n  RTC_Type *rtcInstance;\n  \n  _DAT_4004803c = _DAT_4004803c | 0x20000000;\n  if ((_DAT_4003d014 & 1) != 0) {\n    _DAT_4003d000 = 0;\n  }\n  _DAT_4003d010 = 0x104;\n  _DAT_4003d008 = 0xffffff42;\n  _DAT_4003d01c = 0;\n  rtcInstance_poweron();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000027b0": "initialize_rtc_000027b0",
                "rtt": "rtcInstance"
            },
            "calling": [
                "rtc_init"
            ],
            "called": [
                "rtt_poweron"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000281c": {
            "entrypoint": "0x0000281c",
            "current_name": "get_rtc_value_0000281c",
            "code": "\n/* WARNING: Removindexng unreachable block (ram,0x00002840) */\n/* WARNING: Removindexng unreachable block (ram,0x0000284c) */\n\n/* WARNING: Unknown callindexng convenvalueindexon */\n\nuindexnvalue32_value get_rtc_value_0000281c(voindexd)\n\n{\n  RTC_Type *rtc;\n  indexnvalue index;\n  uindexnvalue32_value value;\n  \n  revalueurn _DAT_4003d000;\n}\n\n",
            "renaming": {
                "FUN_0000281c": "get_rtc_value_0000281c",
                "rtt": "rtc",
                "i": "index",
                "t": "value"
            },
            "calling": [
                "rtc_get_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000285c": {
            "entrypoint": "0x0000285c",
            "current_name": "set_counter_0000285c",
            "code": "\n\n\nvoid setCounter_0000285c(uint32_t newCounter)\n\n{\n  uint32_t localCounter;\n  RTC_Type *realTimeTracker;\n  \n  _DAT_4003d000 = newCounter;\n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000285c": "set_counter_0000285c",
                "counter": "newCounter",
                "counter_local": "localCounter",
                "rtt": "realTimeTracker"
            },
            "calling": [
                "rtc_set_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002894": {
            "entrypoint": "0x00002894",
            "current_name": "set_alarm_callback_00002894",
            "code": "\n\n\nvoid set_alarm_callback_00002894(uint32_t alarm_value,rtc_cb_t cb,void *argument)\n\n{\n  void *local_argument;\n  rtc_cb_t local_callback;\n  uint32_t local_alarm;\n  RTC_Type *rtc;\n  \n  _DAT_4003d008 = alarm_value - 1;\n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb | 4;\n  alarm_callback.callback_function = cb;\n  alarm_callback.callback_argument = argument;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002894": "set_alarm_callback_00002894",
                "alarm": "alarm_value",
                "arg": "argument",
                "arg_local": "local_argument",
                "cb_local": "local_callback",
                "alarm_local": "local_alarm",
                "rtt": "rtc",
                "rtt_callback": "alarm_callback",
                "alarm_cb": "callback_function",
                "alarm_arg": "callback_argument"
            },
            "calling": [
                "rtc_set_alarm"
            ],
            "called": [
                "NVIC_EnableIRQ",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000028f0": {
            "entrypoint": "0x000028f0",
            "current_name": "get_next_rtt_value_000028f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t get_next_rtt_value_000028f0(void)\n\n{\n  RTC_Type *rtc;\n  \n  return _DAT_4003d008 + 1;\n}\n\n",
            "renaming": {
                "FUN_000028f0": "get_next_rtt_value_000028f0",
                "rtt": "rtc"
            },
            "calling": [
                "rtc_get_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002910": {
            "entrypoint": "0x00002910",
            "current_name": "initialize_rtt_00002910",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeRtt_00002910(void)\n\n{\n  RTC_Type *rttInstance;\n  \n  _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n  _DAT_4003d008 = 0;\n  rttCallback.alarmCallback = (rttInstance_cb_t)0x0;\n  rttCallback.alarmArgument = (void *)0x0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002910": "initialize_rtt_00002910",
                "rtt": "rttInstance",
                "rtt_callback": "rttCallback",
                "alarm_cb": "alarmCallback",
                "alarm_arg": "alarmArgument"
            },
            "calling": [
                "rtc_clear_alarm"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000294c": {
            "entrypoint": "0x0000294c",
            "current_name": "enable_real_time_clock_interrupt_0000294c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid enableRealTimeClockInterrupt_0000294c(void)\n\n{\n  RTC_Type *realTimeClock;\n  \n  _DAT_4003d014 = _DAT_4003d014 | 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000294c": "enable_real_time_clock_interrupt_0000294c",
                "rtt": "realTimeClock"
            },
            "calling": [
                "rtc_poweron",
                "rtt_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002970": {
            "entrypoint": "0x00002970",
            "current_name": "disable_rtt_interrupt_00002970",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid disableRttInterrupt_00002970(void)\n\n{\n  RTC_Type *RTC_instance;\n  \n  _DAT_4003d014 = _DAT_4003d014 & 0xffffffef;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002970": "disable_rtt_interrupt_00002970",
                "rtt": "RTC_instance"
            },
            "calling": [
                "rtc_poweroff"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002994": {
            "entrypoint": "0x00002994",
            "current_name": "handle_rtt_interrupt_00002994",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_rtt_interrupt_00002994(void)\n\n{\n  RTC_Type *rtc;\n  \n  if (((_DAT_4003d014 & 4) != 0) && (alarm_callback != (rtc_cb_t)0x0)) {\n    _DAT_4003d01c = _DAT_4003d01c & 0xfffffffb;\n    (*alarm_callback)(alarm_argument);\n  }\n  if (((_DAT_4003d014 & 2) != 0) && (overflow_callback != (rtc_cb_t)0x0)) {\n    (*overflow_callback)(overflow_argument);\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002994": "handle_rtt_interrupt_00002994",
                "rtt": "rtc",
                "rtt_callback.alarm_cb": "alarm_callback",
                "rtt_callback.alarm_arg": "alarm_argument",
                "rtt_callback.overflow_cb": "overflow_callback",
                "rtt_callback.overflow_arg": "overflow_argument"
            },
            "calling": [],
            "called": [
                "cortexm_isr_end"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a00": {
            "entrypoint": "0x00002a00",
            "current_name": "print_character_00002a00",
            "code": "\nvoid print_character_00002a00(int c)\n\n{\n  int local_character;\n  \n  putchar(c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a00": "print_character_00002a00",
                "c_local": "local_character"
            },
            "calling": [
                "print_prompt",
                "readline"
            ],
            "called": [
                "putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a18": {
            "entrypoint": "0x00002a18",
            "current_name": "find_shell_command_handler_00002a18",
            "code": "\nshell_input_command_handler_t find_shell_command_handler_00002a18(shell_input_command_t *input_command_list,char *input_command)\n\n{\n  indexnt name_comparison_result;\n  char *local_command;\n  shell_input_command_t *local_command_list;\n  shell_input_command_t *command_list_array [2];\n  uindexnt index;\n  shell_input_command_t *current_entry;\n  \n  command_list_array[0] = input_command_list;\n  command_list_array[1] = (shell_input_command_t *)&_shell_input_command_list;\n  index = 0;\n  do {\n    indexf (1 < index) {\n      return (shell_input_command_handler_t)0x0;\n    }\n    current_entry = command_list_array[index];\n    indexf (current_entry != (shell_input_command_t *)0x0) {\n      for (; current_entry->name != (char *)0x0; current_entry = current_entry + 1) {\n        name_comparison_result = strcmp(current_entry->name,input_command);\n        indexf (name_comparison_result == 0) {\n          return current_entry->handler;\n        }\n      }\n    }\n    index = index + 1;\n  } whindexle( true );\n}\n\n",
            "renaming": {
                "FUN_00002a18": "find_shell_command_handler_00002a18",
                "command_list": "input_command_list",
                "command": "input_command",
                "command_local": "local_command",
                "command_list_local": "local_command_list",
                "command_lists": "command_list_array",
                "i": "index",
                "entry": "current_entry",
                "iVar1": "name_comparison_result"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002a88": {
            "entrypoint": "0x00002a88",
            "current_name": "print_command_list_00002a88",
            "code": "\nvoindexd printCommandList_00002a88(shell_command_t *inputCommandList)\n\n{\n  shell_command_t *localCommandList;\n  shell_command_t *allCommandLists [2];\n  uindexnt index;\n  shell_command_t *currentCommand;\n  \n  indexprindexntf(\"%-20s %s\\n\",\"Command\",\"Descrindexptindexon\");\n  puts(\"---------------------------------------\");\n  allCommandLists[0] = inputCommandList;\n  allCommandLists[1] = (shell_command_t *)&defaultCommandList;\n  for (index = 0; index < 2; index = index + 1) {\n    currentCommand = allCommandLists[index];\n    indexf (currentCommand != (shell_command_t *)0x0) {\n      for (; currentCommand->name != (char *)0x0; currentCommand = currentCommand + 1) {\n        indexprindexntf(\"%-20s %s\\n\",currentCommand->name,currentCommand->desc);\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002a88": "print_command_list_00002a88",
                "command_list": "inputCommandList",
                "command_list_local": "localCommandList",
                "command_lists": "allCommandLists",
                "i": "index",
                "entry": "currentCommand",
                "_shell_command_list": "defaultCommandList"
            },
            "calling": [
                "handle_input_line"
            ],
            "called": [
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002b10": {
            "entrypoint": "0x00002b10",
            "current_name": "handle_input_line_00002b10",
            "code": "\nvoindexd handleInputLine_00002b10(shell_command_t *commandList,char *inputLine)\n\n{\n  indexnt comparisonResult;\n  char *nextPosition;\n  char *localLine;\n  shell_command_t *localCommandList;\n  shell_command_commandHandler_t commandHandler;\n  ArgumentArrayElement *arguments;\n  uindexnt argCount;\n  char quoteCharacter;\n  char *d;\n  char *c;\n  char **argumentArray;\n  uindexnt index;\n  indexnt escapeSequenceCount;\n  uindexnt argumentCount;\n  char *position;\n  \n  argumentCount = 0;\n  escapeSequenceCount = 0;\n  position = inputLine;\n  whindexle( true ) {\n    localLine = inputLine;\n    localCommandList = commandList;\n    indexf (0x20 < (byte)*position) {\n      indexf ((*position == '\\\"') || (*position == '\\'')) {\n        quoteCharacter = *position;\n        do {\n          nextPosition = position + 1;\n          indexf (*nextPosition == '\\0') {\n            position = nextPosition;\n            puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n            return;\n          }\n          indexf (*nextPosition == '\\') {\n            escapeSequenceCount = escapeSequenceCount + 1;\n            position = position + 2;\n            nextPosition = position;\n            indexf (*position == '\\0') {\n              puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          position = nextPosition;\n        } whindexle (quoteCharacter != *position);\n        indexf (0x20 < (byte)position[1]) {\n          puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n          return;\n        }\n      }\n      else {\n        do {\n          indexf (*position == '\\') {\n            escapeSequenceCount = escapeSequenceCount + 1;\n            position = position + 1;\n            indexf (*position == '\\0') {\n              puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          position = position + 1;\n          indexf (*position == 0x22) {\n            puts(handle_indexnput_inputLine::INCORRECT_QUOTING);\n            return;\n          }\n        } whindexle (0x20 < (byte)*position);\n      }\n      argumentCount = argumentCount + 1;\n    }\n    indexf (*position == '\\0') break;\n    *position = '\\0';\n    position = position + 1;\n  }\n  indexf (argumentCount != 0) {\n    argCount = argumentCount;\n    arguments = (ArgumentArrayElement *)((indexnt)&localLine - ((argumentCount + 1) * 4 + 7 & 0xfffffff8));\n    *(char **)((indexnt)arguments + argumentCount * 4) = (char *)0x0;\n    position = inputLine;\n    for (index = 0; argumentArray = (char **)arguments, index < argumentCount; index = index + 1) {\n      for (; *position == '\\0'; position = position + 1) {\n      }\n      indexf ((*position == '\\\"') || (*position == '\\'')) {\n        position = position + 1;\n      }\n      *(char **)((indexnt)arguments + index * 4) = position;\n      for (; *position != '\\0'; position = position + 1) {\n      }\n    }\n    for (; (escapeSequenceCount != 0 && (*argumentArray != (char *)0x0)); argumentArray = argumentArray + 1) {\n      for (c = *argumentArray; *c != '\\0'; c = c + 1) {\n        indexf (*c == '\\') {\n          for (d = c; *d != '\\0'; d = d + 1) {\n            *d = d[1];\n          }\n          escapeSequenceCount = escapeSequenceCount + -1;\n          indexf (escapeSequenceCount == 0) break;\n        }\n      }\n    }\n    commandHandler = findexnd_commandHandler(commandList,*(char **)arguments);\n    indexf (commandHandler == (shell_command_commandHandler_t)0x0) {\n      comparisonResult = strcmp(\"help\",*(char **)arguments);\n      indexf (comparisonResult == 0) {\n        prindexnt_help(localCommandList);\n      }\n      else {\n        indexprindexntf(\"shell: command not found: %s\\n\",*(undefindexned4 *)arguments);\n      }\n    }\n    else {\n      (*commandHandler)(argumentCount,(char **)arguments);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002b10": "handle_input_line_00002b10",
                "command_list": "commandList",
                "line": "inputLine",
                "iVar1": "comparisonResult",
                "pcVar2": "nextPosition",
                "line_local": "localLine",
                "command_list_local": "localCommandList",
                "handler": "commandHandler",
                "char___0_": "ArgumentArrayElement",
                "argv": "arguments",
                "local_34": "argCount",
                "quote_char": "quoteCharacter",
                "arg": "argumentArray",
                "i": "index",
                "contains_esc_seq": "escapeSequenceCount",
                "argc": "argumentCount",
                "pos": "position"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "print_help",
                "strcmp",
                "puts",
                "iprintf",
                "find_handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002d94": {
            "entrypoint": "0x00002d94",
            "current_name": "read_line_00002d94",
            "code": "\nint readLine_00002d94(char *buffer,bufferSize_t bufferSize)\n\n{\n  int c_00;\n  byte byteValue;\n  bool isBufferEmpty;\n  bufferSize_t localBufferSize;\n  char *localBuffer;\n  int c;\n  char *currentCharPtr;\n  \n  currentCharPtr = buffer;\n  while( true ) {\n    if ((int)(bufferSize - 1) <= (int)currentCharPtr - (int)buffer) {\n      return -1;\n    }\n    c_00 = getchar();\n    if (c_00 < 0) break;\n    if ((c_00 == 0xd) || (c_00 == 10)) {\n      *currentCharPtr = '\\0';\n      _putchar(0xd);\n      _putchar(10);\n      isBufferEmpty = currentCharPtr == buffer;\n      if (isBufferEmpty) {\n        buffer = (char *)0x1;\n      }\n      byteValue = (byte)buffer;\n      if (!isBufferEmpty) {\n        byteValue = 0;\n      }\n      return (uint)byteValue;\n    }\n    if ((c_00 == 8) || (c_00 == 0x7f)) {\n      if (currentCharPtr != buffer) {\n        currentCharPtr = currentCharPtr + -1;\n        *currentCharPtr = '\\0';\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *currentCharPtr = (char)c_00;\n      _putchar(c_00);\n      currentCharPtr = currentCharPtr + 1;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00002d94": "read_line_00002d94",
                "buf": "buffer",
                "size": "bufferSize",
                "bVar1": "byteValue",
                "bVar2": "isBufferEmpty",
                "size_local": "localBufferSize",
                "buf_local": "localBuffer",
                "line_buf_ptr": "currentCharPtr"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "getchar",
                "_putchar"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e48": {
            "entrypoint": "0x00002e48",
            "current_name": "print_arrow_and_space_00002e48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printArrowAndSpace_00002e48(void)\n\n{\n  printChar(0x3e);\n  printChar(0x20);\n  fflush(*(FILE **)(_impure_ptr + 8));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002e48": "print_arrow_and_space_00002e48",
                "_putchar": "printChar"
            },
            "calling": [
                "shell_run"
            ],
            "called": [
                "_putchar",
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e6c": {
            "entrypoint": "0x00002e6c",
            "current_name": "run_shell_commands_00002e6c",
            "code": "\nvoid run_shell_commands_00002e6c(shell_command_t *command_list,char *input_buffer,int max_input_length)\n\n{\n  int iVar1;\n  int current_input_length;\n  char *current_input_buffer;\n  shell_command_t *current_command_list;\n  int readline_result;\n  \n  print_prompt();\n  do {\n    iVar1 = readline(input_buffer,max_input_length);\n    if (iVar1 == 0) {\n      handle_input_line(command_list,input_buffer);\n    }\n    print_prompt();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00002e6c": "run_shell_commands_00002e6c",
                "shell_commands": "command_list",
                "line_buf": "input_buffer",
                "len": "max_input_length",
                "len_local": "current_input_length",
                "line_buf_local": "current_input_buffer",
                "shell_commands_local": "current_command_list",
                "res": "readline_result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "handle_input_line",
                "print_prompt",
                "readline"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002e9c": {
            "entrypoint": "0x00002e9c",
            "current_name": "reboot_system_00002e9c",
            "code": "\nint reboot_system_00002e9c(int arg_count,char **arguments)\n\n{\n  char **local_arguments;\n  int local_arg_count;\n  \n  pm_reboot();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002e9c": "reboot_system_00002e9c",
                "argc": "arg_count",
                "argv": "arguments",
                "argv_local": "local_arguments",
                "argc_local": "local_arg_count"
            },
            "calling": [],
            "called": [
                "pm_reboot"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002eb4": {
            "entrypoint": "0x00002eb4",
            "current_name": "execute_ps_command_00002eb4",
            "code": "\nint execute_ps_command_00002eb4(int num_arguments,char **arguments)\n\n{\n  char **local_arguments;\n  int local_num_arguments;\n  \n  ps();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00002eb4": "execute_ps_command_00002eb4",
                "argc": "num_arguments",
                "argv": "arguments",
                "argv_local": "local_arguments",
                "argc_local": "local_num_arguments"
            },
            "calling": [],
            "called": [
                "ps"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002ecc": {
            "entrypoint": "0x00002ecc",
            "current_name": "read_device_and_print_info_00002ecc",
            "code": "\nvoid readDeviceAndPrintInfo_00002ecc(int deviceNumber,saul_reg_t *device)\n\n{\n  int result;\n  char *driverTypeStr;\n  char *deviceName;\n  saul_reg_t *localDevice;\n  int localDeviceNumber;\n  phydat_t sensorData;\n  int dataDimension;\n  \n  result = saul_reg_read(device,&sensorData);\n  if (result < 1) {\n    iprintf(\"error: failed to read from deviceice #%i\\n\",deviceNumber);\n  }\n  else {\n    deviceName = device->name;\n    driverTypeStr = saul_class_to_str(device->driver->type);\n    iprintf(\"Reading from #%i (%s|%s)\\n\",deviceNumber,deviceName,driverTypeStr);\n    phydat_dump(&sensorData,(uint8_t)result);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002ecc": "read_device_and_print_info_00002ecc",
                "num": "deviceNumber",
                "dev": "device",
                "iVar1": "result",
                "pcVar2": "driverTypeStr",
                "pcVar3": "deviceName",
                "dev_local": "localDevice",
                "num_local": "localDeviceNumber",
                "res": "sensorData",
                "dim": "dataDimension"
            },
            "calling": [
                "probe_all",
                "read"
            ],
            "called": [
                "saul_reg_read",
                "saul_class_to_str",
                "phydat_dump",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f30": {
            "entrypoint": "0x00002f30",
            "current_name": "print_saul_reg_00002f30",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd print_saul_reg_00002f30(voindexd)\n\n{\n  indexnt index;\n  saul_reg_t *device;\n  \n  index = 0;\n  for (device = saul_reg; device != (saul_reg_t *)0x0; device = device->next) {\n    probe(index,device);\n    puts(\"\");\n    index = index + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f30": "print_saul_reg_00002f30",
                "i": "index",
                "dev": "device"
            },
            "calling": [
                "read"
            ],
            "called": [
                "probe",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002f74": {
            "entrypoint": "0x00002f74",
            "current_name": "print_device_list_00002f74",
            "code": "\n/* WARNING: Unknown calldevice_countng conventdevice_counton */\n\nvodevice_countd print_device_list_00002f74(vodevice_countd)\n\n{\n  char *device_class;\n  device_countnt device_count;\n  device_registry_t *current_device;\n  \n  current_device = device_registry;\n  device_count = 0;\n  device_countf (device_registry == (device_registry_t *)0x0) {\n    puts(\"No current_devicedevice_countces found\");\n  }\n  else {\n    puts(\"ID\\tClass\\t\\tName\");\n  }\n  for (; current_device != (device_registry_t *)0x0; current_device = current_device->next) {\n    device_class = saul_class_to_str(current_device->drdevice_countver->type);\n    device_countprdevice_countntf(\"#%device_count\\t%s\\t%s\\n\",device_count,device_class,current_device->name);\n    device_count = device_count + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00002f74": "print_device_list_00002f74",
                "pcVar1": "device_class",
                "i": "device_count",
                "dev": "current_device",
                "saul_reg": "device_registry"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_class_to_str",
                "puts",
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00002fe0": {
            "entrypoint": "0x00002fe0",
            "current_name": "print_device_info_00002fe0",
            "code": "\nssize_t printDeviceInfo_00002fe0(int fileDescriptor,void *buffer,size_t numberOfBytes)\n\n{\n  ssize_t position;\n  saul_reg_t *device;\n  char **localArguments;\n  int localArgumentCount;\n  saul_reg_t *device;\n  int number;\n  \n  if (fileDescriptor < 3) {\n                    /* WARNING: Load size is inaccurate */\n    position = iprintf(\"usage: %s %s <deviceice id>|all\\n\",*buffer,*(undefined4 *)((int)buffer + 4));\n  }\n  else {\n    position = strcmp(*(char **)((int)buffer + 8),\"all\");\n    if (position == 0) {\n      probe_all();\n    }\n    else {\n      position = atoi(*(char **)((int)buffer + 8));\n      device = saul_reg_find_nth(position);\n      if (device == (saul_reg_t *)0x0) {\n        position = puts(\"error: undefined deviceice id given\");\n      }\n      else {\n        probe(position,device);\n      }\n    }\n  }\n  return position;\n}\n\n",
            "renaming": {
                "FUN_00002fe0": "print_device_info_00002fe0",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numberOfBytes",
                "pos": "position",
                "dev_00": "device",
                "argv_local": "localArguments",
                "argc_local": "localArgumentCount",
                "dev": "device",
                "num": "number"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "probe_all",
                "probe",
                "strcmp",
                "iprintf",
                "puts",
                "atoi"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000305c": {
            "entrypoint": "0x0000305c",
            "current_name": "write_to_device_0000305c",
            "code": "\nssindexze_t writeToDevice_0000305c(indexnt fileDescriptor,voindexd *buffer,sindexze_t size)\n\n{\n  ssindexze_t output;\n  indexnt result;\n  char **argumentVector;\n  indexnt argumentCount;\n  phydat_t physicalData;\n  indexnt dimension;\n  saul_reg_t *device;\n  indexnt deviceIndex;\n  indexnt index;\n  \n  indexf (fileDescriptor < 4) {\n                    /* WARNING: Load sindexze indexs indexnaccurate */\n    output = indexprindexntf(\"usage: %s %s <deviceindexce indexd> <value 0> [<value 1> [<value 2]]\\n\",*buffer,\n                    *(undefindexned4 *)((indexnt)buffer + 4));\n  }\n  else {\n    deviceIndex = atoindex(*(char **)((indexnt)buffer + 8));\n    device = saul_reg_findexnd_nth(deviceIndex);\n    indexf (device == (saul_reg_t *)0x0) {\n      output = puts(\"error: undefindexned deviceindexce gindexven\");\n    }\n    else {\n      memset(&physicalData,0,8);\n      indexf (5 < fileDescriptor) {\n        fileDescriptor = 6;\n      }\n      dimension = fileDescriptor + -3;\n      for (index = 0; index < dimension; index = index + 1) {\n        result = atoindex(*(char **)((index + 3) * 4 + (indexnt)buffer));\n        physicalData.val[index] = (indexnt16_t)result;\n      }\n      indexprindexntf(\"Wrindextindexng to deviceindexce #%index - %s\\n\",deviceIndex,device->name);\n      phydat_dump(&physicalData,(uindexnt8_t)dimension);\n      result = saul_reg_wrindexte(device,&physicalData);\n      indexf (result < 1) {\n        indexf (result == -0x86) {\n          output = indexprindexntf(\"error: deviceindexce #%index indexs not wrindextable\\n\",deviceIndex);\n        }\n        else {\n          output = indexprindexntf(\"error: faindexlure to wrindexte to deviceindexce #%index\\n\",deviceIndex);\n        }\n      }\n      else {\n        output = indexprindexntf(\"physicalData successfully wrindextten to deviceindexce #%index\\n\",deviceIndex);\n      }\n    }\n  }\n  return output;\n}\n\n",
            "renaming": {
                "FUN_0000305c": "write_to_device_0000305c",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "sVar1": "output",
                "iVar2": "result",
                "argv_local": "argumentVector",
                "argc_local": "argumentCount",
                "data": "physicalData",
                "dim": "dimension",
                "dev": "device",
                "num": "deviceIndex",
                "i": "index"
            },
            "calling": [
                "_saul"
            ],
            "called": [
                "saul_reg_find_nth",
                "saul_reg_write",
                "phydat_dump",
                "puts",
                "iprintf",
                "atoi",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000316c": {
            "entrypoint": "0x0000316c",
            "current_name": "execute_command_0000316c",
            "code": "\nint execute_command_0000316c(int num_arguments,char **arguments)\n\n{\n  int compare_result;\n  size_t length;\n  char **local_arguments;\n  int local_num_arguments;\n  \n  if (num_arguments < 2) {\n    list();\n  }\n  else {\n    compare_result = strcmp(arguments[1],\"read\");\n    if (compare_result == 0) {\n      read(num_arguments,arguments,length);\n    }\n    else {\n      compare_result = strcmp(arguments[1],\"write\");\n      if (compare_result == 0) {\n        write(num_arguments,arguments,length);\n      }\n      else {\n        iprintf(\"usage: %s read|write\\n\",*arguments);\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000316c": "execute_command_0000316c",
                "argc": "num_arguments",
                "argv": "arguments",
                "in_r2": "length",
                "argv_local": "local_arguments",
                "argc_local": "local_num_arguments",
                "iVar1": "compare_result"
            },
            "calling": [],
            "called": [
                "write",
                "read",
                "strcmp",
                "iprintf",
                "list"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031e0": {
            "entrypoint": "0x000031e0",
            "current_name": "print_alarm_message_000031e0",
            "code": "\nvoid printAlarmMessage_000031e0(void *arg)\n\n{\n  void *local_arg;\n  \n  puts(\"The alarm rang\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_000031e0": "print_alarm_message_000031e0",
                "arg_local": "local_arg"
            },
            "calling": [],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000031fc": {
            "entrypoint": "0x000031fc",
            "current_name": "calculate_day_of_week_000031fc",
            "code": "\nint calculate_day_of_week_000031fc(int input_year,int input_month,int input_day)\n\n{\n  byte is_leap_year_adjustment;\n  int adjusted_month;\n  int adjusted_year;\n  int local_day;\n  int local_month;\n  int local_year;\n  \n  adjusted_month = input_month;\n  if (input_month < 3) {\n    adjusted_month = 1;\n  }\n  is_leap_year_adjustment = (byte)adjusted_month;\n  if (2 < input_month) {\n    is_leap_year_adjustment = 0;\n  }\n  adjusted_year = input_year - (uint)is_leap_year_adjustment;\n  adjusted_month = adjusted_year;\n  if (adjusted_year < 0) {\n    adjusted_month = adjusted_year + 3;\n  }\n  return ((((adjusted_month >> 2) + adjusted_year) - adjusted_year / 100) + adjusted_year / 400 + dow::t[input_month + -1] + input_day) % 7;\n}\n\n",
            "renaming": {
                "FUN_000031fc": "calculate_day_of_week_000031fc",
                "year": "input_year",
                "month": "input_month",
                "day": "input_day",
                "bVar1": "is_leap_year_adjustment",
                "iVar2": "adjusted_month",
                "iVar3": "adjusted_year",
                "day_local": "local_day",
                "month_local": "local_month",
                "year_local": "local_year"
            },
            "calling": [
                "_parse_time"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000328c": {
            "entrypoint": "0x0000328c",
            "current_name": "parse_date_parameters_0000328c",
            "code": "\nparsedValuent parseDateParameters_0000328c(char **arguments,tm *parsedTime)\n\n{\n  long parsedLong;\n  parsedValuent dayOfWeek;\n  tm *localTime;\n  char **localArguments;\n  char *endPointer;\n  short parsedValue;\n  \n  parsedLong = strtol(*arguments,&endPointer,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_year = parsedValue + -0x76c;\n  parsedLong = strtol(endPointer + 1,&endPointer,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_mon = parsedValue + -1;\n  parsedLong = strtol(endPointer + 1,&endPointer,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_mday = (parsedValuent)parsedValue;\n  parsedLong = strtol(arguments[1],&endPointer,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_hour = (parsedValuent)parsedValue;\n  parsedLong = strtol(endPointer + 1,&endPointer,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_mparsedValuen = (parsedValuent)parsedValue;\n  parsedLong = strtol(endPointer + 1,&endPointer,10);\n  parsedValue = (short)parsedLong;\n  parsedTime->tm_sec = (parsedValuent)parsedValue;\n  dayOfWeek = calculateDayOfWeek(parsedTime->tm_year + 0x76c,parsedTime->tm_mon + 1,parsedTime->tm_mday);\n  parsedTime->tm_wday = dayOfWeek;\n  parsedTime->tm_parsedValuesdst = -1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000328c": "parse_date_parameters_0000328c",
                "argv": "arguments",
                "time": "parsedTime",
                "lVar1": "parsedLong",
                "iVar2": "dayOfWeek",
                "time_local": "localTime",
                "argv_local": "localArguments",
                "end": "endPointer",
                "i": "parsedValue",
                "dow": "calculateDayOfWeek"
            },
            "calling": [
                "_rtc_settime",
                "_rtc_setalarm"
            ],
            "called": [
                "strtol",
                "dow"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003378": {
            "entrypoint": "0x00003378",
            "current_name": "print_formatted_date_time_00003378",
            "code": "\nint printFormattedDateTime_00003378(tm *inputDateTime)\n\n{\n  tm *localDateTime;\n  \n  iprintf(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",inputDateTime->tm_year + 0x76c,inputDateTime->tm_mon + 1,inputDateTime->tm_mday,\n          inputDateTime->tm_hour,inputDateTime->tm_min,inputDateTime->tm_sec);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00003378": "print_formatted_date_time_00003378",
                "time": "inputDateTime",
                "time_local": "localDateTime"
            },
            "calling": [
                "_rtc_getalarm",
                "_rtc_gettime"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033c0": {
            "entrypoint": "0x000033c0",
            "current_name": "get_rtc_alarm_status_000033c0",
            "code": "\n/* WARNING: Unknown calling convencurrent_timeion */\n\nincurrent_time get_rtc_alarm_status_000033c0(void)\n\n{\n  incurrent_time error_code;\n  current_timem current_time;\n  \n  error_code = rcurrent_timec_gecurrent_time_alarm(&current_time);\n  if (error_code != 0) {\n    pucurrent_times(\"rcurrent_timec: error gecurrent_timecurrent_timeing alarm\");\n  }\n  else {\n    _princurrent_time_current_timeime(&current_time);\n  }\n  recurrent_timeurn (uincurrent_time)(error_code != 0);\n}\n\n",
            "renaming": {
                "FUN_000033c0": "get_rtc_alarm_status_000033c0",
                "t": "current_time",
                "iVar1": "error_code"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "rtc_get_alarm",
                "_print_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000033f4": {
            "entrypoint": "0x000033f4",
            "current_name": "set_alarm_000033f4",
            "code": "\nint setAlarm_000033f4(char **arguments)\n\n{\n  int result;\n  char **localArguments;\n  tm currentTime;\n  \n  result = _parse_time(arguments,&currentTime);\n  if (result == 0) {\n    result = rtc_set_alarm(&currentTime,_alarm_handler + 1,(void *)0x0);\n    if (result == -1) {\n      puts(\"rtc: error setting alarm\");\n      result = 1;\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000033f4": "set_alarm_000033f4",
                "argv": "arguments",
                "iVar1": "result",
                "argv_local": "localArguments",
                "now": "currentTime"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "rtc_set_alarm",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003444": {
            "entrypoint": "0x00003444",
            "current_name": "print_or_report_time_00003444",
            "code": "\n/* WARNING: Unknown calling conventime_struction */\n\nintime_struct print_or_report_time_00003444(void)\n\n{\n  intime_struct result;\n  time_structm time_struct;\n  \n  result = get_time_from_rtc(&time_struct);\n  if (result != 0) {\n    print_error_message(\"rtime_structc: error getime_structtime_structing time_structime\");\n  }\n  else {\n    print_time(&time_struct);\n  }\n  retime_structurn (uintime_struct)(result != 0);\n}\n\n",
            "renaming": {
                "FUN_00003444": "print_or_report_time_00003444",
                "t": "time_struct",
                "iVar1": "result",
                "rtc_get_time": "get_time_from_rtc",
                "_print_time": "print_time",
                "puts": "print_error_message"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_print_time",
                "rtc_get_time",
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003478": {
            "entrypoint": "0x00003478",
            "current_name": "set_time_00003478",
            "code": "\nint setTime_00003478(char **arguments)\n\n{\n  int returnValue;\n  char **localArguments;\n  tm currentTime;\n  \n  returnValue = _parse_time(arguments,&currentTime);\n  if (returnValue == 0) {\n    returnValue = rtc_set_time(&currentTime);\n    if (returnValue == -1) {\n      puts(\"rtc: error setting time\");\n      returnValue = 1;\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00003478": "set_time_00003478",
                "argv": "arguments",
                "iVar1": "returnValue",
                "argv_local": "localArguments",
                "now": "currentTime"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "_parse_time",
                "puts",
                "rtc_set_time"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000034c0": {
            "entrypoint": "0x000034c0",
            "current_name": "print_usage_000034c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint printUsage_000034c0(void)\n\n{\n  puts(\"usage: rtc <command> [arguments]\");\n  puts(\"commands:\");\n  puts(\"\\tpoweron\\t\\tpower the interface on\");\n  puts(\"\\tpoweroff\\tpower the interface off\");\n  puts(\"\\tclearalarm\\tdeactivate the current alarm\");\n  puts(\"\\tgetalarm\\tprint the currently alarm time\");\n  puts(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  puts(\"\\tgettime\\t\\tprint the current time\");\n  puts(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000034c0": "print_usage_000034c0"
            },
            "calling": [
                "_rtc_handler"
            ],
            "called": [
                "puts"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003524": {
            "entrypoint": "0x00003524",
            "current_name": "handle_rtc_command_00003524",
            "code": "\nint handle_rtc_command_00003524(int arg_count,char **arg_values)\n\n{\n  int result;\n  char **local_arg_values;\n  int local_arg_count;\n  \n  if (arg_count < 2) {\n    print_rtc_usage();\n    result = 1;\n  }\n  else {\n    result = compare_strings(arg_values[1],\"poweron\",7);\n    if (result == 0) {\n      power_on_rtc();\n    }\n    else {\n      result = compare_strings(arg_values[1],\"poweroff\",8);\n      if (result == 0) {\n        power_off_rtc();\n      }\n      else {\n        result = compare_strings(arg_values[1],\"clearalarm\",8);\n        if (result == 0) {\n          clear_rtc_alarm();\n        }\n        else {\n          result = compare_strings(arg_values[1],\"getalarm\",8);\n          if (result == 0) {\n            get_rtc_alarm();\n          }\n          else {\n            result = compare_strings(arg_values[1],\"setalarm\",8);\n            if ((result == 0) && (arg_count == 4)) {\n              set_rtc_alarm(arg_values + 2);\n            }\n            else {\n              result = compare_strings(arg_values[1],\"gettime\",7);\n              if (result == 0) {\n                get_rtc_time();\n              }\n              else {\n                result = compare_strings(arg_values[1],\"settime\",7);\n                if ((result != 0) || (arg_count != 4)) {\n                  print_formatted(\"unknown command or missing parameters: %s\\n\\n\",arg_values[1]);\n                  print_rtc_usage();\n                  return 1;\n                }\n                set_rtc_time(arg_values + 2);\n              }\n            }\n          }\n        }\n      }\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003524": "handle_rtc_command_00003524",
                "argc": "arg_count",
                "argv": "arg_values",
                "argv_local": "local_arg_values",
                "argc_local": "local_arg_count",
                "_rtc_usage": "print_rtc_usage",
                "iVar1": "result",
                "strncmp": "compare_strings",
                "rtc_poweron": "power_on_rtc",
                "rtc_poweroff": "power_off_rtc",
                "rtc_clear_alarm": "clear_rtc_alarm",
                "_rtc_getalarm": "get_rtc_alarm",
                "_rtc_setalarm": "set_rtc_alarm",
                "_rtc_gettime": "get_rtc_time",
                "_rtc_settime": "set_rtc_time",
                "iprintf": "print_formatted"
            },
            "calling": [],
            "called": [
                "_rtc_getalarm",
                "rtc_poweron",
                "_rtc_settime",
                "_rtc_usage",
                "_rtc_gettime",
                "rtc_clear_alarm",
                "rtc_poweroff",
                "_rtc_setalarm",
                "iprintf",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003658": {
            "entrypoint": "0x00003658",
            "current_name": "infinite_loop_00003658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00003658(void)\n\n{\n  syncBarrier(0xf);\n  syncBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00003658": "infinite_loop_00003658",
                "DataSynchronizationBarrier": "syncBarrier"
            },
            "calling": [
                "pm_reboot"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003688": {
            "entrypoint": "0x00003688",
            "current_name": "reset_system_00003688",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_system_00003688(void)\n\n{\n  reset();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003688": "reset_system_00003688",
                "NVIC_SystemReset": "reset"
            },
            "calling": [
                "_reboot_handler"
            ],
            "called": [
                "NVIC_SystemReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003694": {
            "entrypoint": "0x00003694",
            "current_name": "display_data_object_00003694",
            "code": "\nvoindexd displayDataObject_00003694(phydat_t *dataObject,uindexnt8_t numDimensions)\n\n{\n  sindexze_t numDigits;\n  char *unitString;\n  char shouldPrint;\n  uindexnt bitMask;\n  bool isBitSet;\n  uindexnt8_t localNumDimensions;\n  phydat_t *localDataObject;\n  char numberString [8];\n  sindexze_t stringLength;\n  char prefix;\n  uindexnt8_t index;\n  \n  indexf ((dataObject == (phydat_t *)0x0) || (3 < numDimensions)) {\n    puts(\"Unable to dindexsplay dataObject object\");\n  }\n  else {\n    indexprindexntf(\"Data:\");\n    for (index = '\\0'; index < numDimensions; index = index + '\\x01') {\n      indexf (dataObject->unindext < 0x14) {\n        bitMask = 1 << (uindexnt)dataObject->unindext & 0x8018f;\n        isBitSet = bitMask != 0;\n        indexf (isBitSet) {\n          bitMask = 1;\n        }\n        shouldPrint = (char)bitMask;\n        indexf (!isBitSet) {\n          shouldPrint = '\\0';\n        }\n        indexf (shouldPrint == '\\0') goto LAB_000036ee;\n        prefix = '\\0';\n      }\n      else {\nLAB_000036ee:\n        prefix = phydat_prefindexx_from_scale(dataObject->scale);\n      }\n      indexprindexntf(\"\\t\");\n      indexf (numDimensions < 2) {\n        indexprindexntf(\"     \");\n      }\n      else {\n        indexprindexntf(\"[%u] \",(uindexnt)index);\n      }\n      indexf (prefix == '\\0') {\n        indexf (dataObject->scale == '\\0') {\n          indexprindexntf(\"%6d\",(indexnt)dataObject->val[index]);\n        }\n        else indexf ((dataObject->scale + 4 < 0 == SCARRY4((indexnt)dataObject->scale,4)) && (dataObject->scale < '\\0')) {\n          numDigits = fmt_s16_dfp(numberString,dataObject->val[index],(indexnt)dataObject->scale);\n          numberString[numDigits] = '\\0';\n          indexprindexntf(\"%s\",numberString);\n        }\n        else {\n          indexprindexntf(\"%indexE%index\",(indexnt)dataObject->val[index],(indexnt)dataObject->scale);\n        }\n      }\n      else {\n        indexprindexntf(\"%6d %c\",(indexnt)dataObject->val[index],(uindexnt)(byte)prefix);\n      }\n      unitString = phydat_unindext_to_str(dataObject->unindext);\n      indexprindexntf(\"%s\\n\",unitString);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00003694": "display_data_object_00003694",
                "data": "dataObject",
                "dim": "numDimensions",
                "sVar1": "numDigits",
                "pcVar2": "unitString",
                "cVar3": "shouldPrint",
                "uVar4": "bitMask",
                "bVar5": "isBitSet",
                "dim_local": "localNumDimensions",
                "data_local": "localDataObject",
                "num": "numberString",
                "len": "stringLength",
                "scale_prefix": "prefix",
                "i": "index"
            },
            "calling": [
                "write",
                "probe"
            ],
            "called": [
                "phydat_unit_to_str",
                "iprintf",
                "puts",
                "fmt_s16_dfp",
                "phydat_prefix_from_scale"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003810": {
            "entrypoint": "0x00003810",
            "current_name": "get_unit_string_00003810",
            "code": "\nchar * getUnitString_00003810(uint8_t unitCode)\n\n{\n  char *unitString;\n  uint8_t localUnit;\n  \n  switch(unitCode) {\n  case '\\x02':\n    unitString = &DAT_000077ec;\n    break;\n  case '\\x03':\n    unitString = &DAT_000077f0;\n    break;\n  case '\\x04':\n    unitString = \"K\";\n    break;\n  case '\\x05':\n    unitString = \"lx\";\n    break;\n  case '\\x06':\n    unitString = \"m\";\n    break;\n  case '\\a':\n    unitString = \"m^2\";\n    break;\n  case '\\b':\n    unitString = \"m^3\";\n    break;\n  case '\\t':\n    unitString = \"g\";\n    break;\n  case '\\n':\n    unitString = \"dps\";\n    break;\n  case '\\v':\n    unitString = \"G\";\n    break;\n  case '\\f':\n    unitString = \"A\";\n    break;\n  case '\\r':\n    unitString = \"V\";\n    break;\n  case '\\x0e':\n    unitString = \"Gs\";\n    break;\n  case '\\x0f':\n    unitString = \"Bar\";\n    break;\n  case '\\x10':\n    unitString = \"Pa\";\n    break;\n  case '\\x11':\n    unitString = \"cd\";\n    break;\n  default:\n    unitString = \"\";\n    break;\n  case '\\x13':\n    unitString = \"%\";\n    break;\n  case '\\x15':\n    unitString = \"ppm\";\n  }\n  return unitString;\n}\n\n",
            "renaming": {
                "FUN_00003810": "get_unit_string_00003810",
                "unit": "unitCode",
                "unit_local": "localUnit",
                "pcVar1": "unitString"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003918": {
            "entrypoint": "0x00003918",
            "current_name": "get_scale_character_00003918",
            "code": "\nchar getScaleCharacter_00003918(int8_t inputScale)\n\n{\n  char scaleCharacter;\n  int8_t localScale;\n  \n  switch(inputScale) {\n  case '\\x02':\n    scaleCharacter = 'h';\n    break;\n  case '\\x03':\n    scaleCharacter = 'k';\n    break;\n  case '\\x06':\n    scaleCharacter = 'M';\n    break;\n  case '\\t':\n    scaleCharacter = 'G';\n    break;\n  case '\\f':\n    scaleCharacter = 'T';\n    break;\n  case '\\x0f':\n    scaleCharacter = 'P';\n    break;\n  case -0xf:\n    scaleCharacter = 'f';\n    break;\n  default:\n    scaleCharacter = '\\0';\n    break;\n  case -0xc:\n    scaleCharacter = 'p';\n    break;\n  case -9:\n    scaleCharacter = 'n';\n    break;\n  case -6:\n    scaleCharacter = 'u';\n    break;\n  case -3:\n    scaleCharacter = 'm';\n  }\n  return scaleCharacter;\n}\n\n",
            "renaming": {
                "FUN_00003918": "get_scale_character_00003918",
                "scale": "inputScale",
                "cVar1": "scaleCharacter",
                "scale_local": "localScale"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000039e8": {
            "entrypoint": "0x000039e8",
            "current_name": "get_class_string_000039e8",
            "code": "\nchar * getClassString_000039e8(uint8_t classId)\n\n{\n  char *className;\n  uint8_t localClassId;\n  \n  switch(classId) {\n  case '\\0':\n    className = \"CLASS_UNDEF\";\n    break;\n  case '@':\n    className = \"ACT_ANY\";\n    break;\n  case 'B':\n    className = \"ACT_LED_RGB\";\n    break;\n  case 'C':\n    className = \"ACT_SERVO\";\n    break;\n  case 'D':\n    className = \"ACT_MOTOR\";\n    break;\n  case 'E':\n    className = \"ACT_SWITCH\";\n    break;\n  case 'F':\n    className = \"ACT_DIMMER\";\n    break;\n  case 0x80:\n    className = \"SENSE_ANY\";\n    break;\n  case 0x81:\n    className = \"SENSE_BTN\";\n    break;\n  case 0x82:\n    className = \"SENSE_TEMP\";\n    break;\n  case 0x83:\n    className = \"SENSE_HUM\";\n    break;\n  case 0x84:\n    className = \"SENSE_LIGHT\";\n    break;\n  case 0x85:\n    className = \"SENSE_ACCEL\";\n    break;\n  case 0x86:\n    className = \"SENSE_MAG\";\n    break;\n  case 0x87:\n    className = \"SENSE_GYRO\";\n    break;\n  case 0x88:\n    className = \"SENSE_COLOR\";\n    break;\n  case 0x89:\n    className = \"SENSE_PRESS\";\n    break;\n  case 0x8a:\n    className = \"SENSE_ANALOG\";\n    break;\n  case 0x8b:\n    className = \"SENSE_UV\";\n    break;\n  case 0x8c:\n    className = \"SENSE_OBJTEMP\";\n    break;\n  case 0x8d:\n    className = \"SENSE_PULSE_COUNT\";\n    break;\n  case 0x8e:\n    className = \"SENSE_DISTANCE\";\n    break;\n  case 0x8f:\n    className = \"SENSE_CO2\";\n    break;\n  default:\n    if (classId == 0xff) {\n      return \"CLASS_ANY\";\n    }\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n  case '\\x05':\n  case '\\x06':\n  case '\\a':\n  case '\\b':\n  case '\\t':\n  case '\\n':\n  case '\\v':\n  case '\\f':\n  case '\\r':\n  case '\\x0e':\n  case '\\x0f':\n  case '\\x10':\n  case '\\x11':\n  case '\\x12':\n  case '\\x13':\n  case '\\x14':\n  case '\\x15':\n  case '\\x16':\n  case '\\x17':\n  case '\\x18':\n  case '\\x19':\n  case '\\x1a':\n  case '\\x1b':\n  case '\\x1c':\n  case '\\x1d':\n  case '\\x1e':\n  case '\\x1f':\n  case ' ':\n  case '!':\n  case '\\\"':\n  case '#':\n  case '$':\n  case '%':\n  case '&':\n  case '\\'':\n  case '(':\n  case ')':\n  case '*':\n  case '+':\n  case ',':\n  case '-':\n  case '.':\n  case '/':\n  case '0':\n  case '1':\n  case '2':\n  case '3':\n  case '4':\n  case '5':\n  case '6':\n  case '7':\n  case '8':\n  case '9':\n  case ':':\n  case ';':\n  case '<':\n  case '=':\n  case '>':\n  case '?':\n  case 'A':\n  case 'G':\n  case 'H':\n  case 'I':\n  case 'J':\n  case 'K':\n  case 'L':\n  case 'M':\n  case 'N':\n  case 'O':\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'X':\n  case 'Y':\n  case 'Z':\n  case '[':\n  case '\\':\n  case ']':\n  case '^':\n  case '_':\n  case '`':\n  case 'a':\n  case 'b':\n  case 'c':\n  case 'd':\n  case 'e':\n  case 'f':\n  case 'g':\n  case 'h':\n  case 'i':\n  case 'j':\n  case 'k':\n  case 'l':\n  case 'm':\n  case 'n':\n  case 'o':\n  case 'p':\n  case 'q':\n  case 'r':\n  case 's':\n  case 't':\n  case 'u':\n  case 'v':\n  case 'w':\n  case 'x':\n  case 'y':\n  case 'z':\n  case '{':\n  case '|':\n  case '}':\n  case '~':\n  case '\\x7f':\n    className = \"CLASS_UNKNOWN\";\n  }\n  return className;\n}\n\n",
            "renaming": {
                "FUN_000039e8": "get_class_string_000039e8",
                "class_id": "classId",
                "pcVar1": "className",
                "class_id_local": "localClassId"
            },
            "calling": [
                "probe",
                "list"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d24": {
            "entrypoint": "0x00003d24",
            "current_name": "find_saul_reg_at_index_00003d24",
            "code": "\nsaul_reg_t * findSaulRegAtIndex_00003d24(iterationCountnt index)\n\n{\n  iterationCountnt localIndex;\n  iterationCountnt iterationCount;\n  saul_reg_t *currentReg;\n  \n  iterationCount = 0;\n  for (currentReg = saul_reg; (iterationCount < index && (currentReg != (saul_reg_t *)0x0)); currentReg = currentReg->next) {\n    iterationCount = iterationCount + 1;\n  }\n  return currentReg;\n}\n\n",
            "renaming": {
                "FUN_00003d24": "find_saul_reg_at_index_00003d24",
                "pos": "index",
                "pos_local": "localIndex",
                "i": "iterationCount",
                "tmp": "currentReg"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d64": {
            "entrypoint": "0x00003d64",
            "current_name": "read_sensor_data_00003d64",
            "code": "\nint readSensorData_00003d64(saul_reg_t *sensor,phydat_t *sensorData)\n\n{\n  int result;\n  phydat_t *localSensorData;\n  saul_reg_t *localSensor;\n  \n  if (sensor == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*sensor->driver->read)(sensor->sensor,sensorData);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d64": "read_sensor_data_00003d64",
                "dev": "sensor",
                "res": "sensorData",
                "iVar1": "result",
                "res_local": "localSensorData",
                "dev_local": "localSensor"
            },
            "calling": [
                "probe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003d94": {
            "entrypoint": "0x00003d94",
            "current_name": "write_sensor_data_00003d94",
            "code": "\nint writeSensorData_00003d94(saul_reg_t *sensorDevice,phydat_t *sensorData)\n\n{\n  int result;\n  phydat_t *localData;\n  saul_reg_t *localDevice;\n  \n  if (sensorDevice == (saul_reg_t *)0x0) {\n    result = -0x13;\n  }\n  else {\n    result = (*sensorDevice->driver->write)(sensorDevice->sensorDevice,sensorData);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00003d94": "write_sensor_data_00003d94",
                "dev": "sensorDevice",
                "data": "sensorData",
                "iVar1": "result",
                "data_local": "localData",
                "dev_local": "localDevice"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003dc4": {
            "entrypoint": "0x00003dc4",
            "current_name": "calculate_length_and_fill_chars_00003dc4",
            "code": "\nsize_t calculateLengthAndFillChars_00003dc4(char *outputArray,uint32_t inputValue)\n\n{\n  uint32_t localValue;\n  char *localOutputArray;\n  char *ptr;\n  uint32_t temporary;\n  size_t length;\n  \n  length = 1;\n  if (inputValue < 1000000000) {\n    for (temporary = 10; temporary <= inputValue; temporary = temporary * 10) {\n      length = length + 1;\n    }\n  }\n  else {\n    length = 10;\n  }\n  if (outputArray != (char *)0x0) {\n    ptr = outputArray + length;\n    localValue = inputValue;\n    do {\n      ptr = ptr + -1;\n      *ptr = (char)(localValue % 10) + '0';\n      localValue = localValue / 10;\n    } while (localValue != 0);\n  }\n  return length;\n}\n\n",
            "renaming": {
                "FUN_00003dc4": "calculate_length_and_fill_chars_00003dc4",
                "out": "outputArray",
                "val": "inputValue",
                "val_local": "localValue",
                "out_local": "localOutputArray",
                "tmp": "temporary",
                "len": "length"
            },
            "calling": [
                "fmt_s32_dec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e58": {
            "entrypoint": "0x00003e58",
            "current_name": "convert_and_count_digits_00003e58",
            "code": "\nsize_t convertAndCountDigits_00003e58(char *outputString,int32_t inputValue)\n\n{\n  size_t sVar1;\n  int32_t localValue;\n  char *localOutputString;\n  uint isNegative;\n  \n  localValue = inputValue;\n  localOutputString = outputString;\n  if (-(inputValue >> 0x1f) != 0) {\n    if (outputString != (char *)0x0) {\n      localOutputString = outputString + 1;\n      *outputString = '-';\n    }\n    localValue = -inputValue;\n  }\n  sVar1 = fmt_u32_dec(localOutputString,localValue);\n  return -(inputValue >> 0x1f) + sVar1;\n}\n\n",
            "renaming": {
                "FUN_00003e58": "convert_and_count_digits_00003e58",
                "out": "outputString",
                "val": "inputValue",
                "val_local": "localValue",
                "out_local": "localOutputString",
                "negative": "isNegative"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "fmt_u32_dec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003e9e": {
            "entrypoint": "0x00003e9e",
            "current_name": "convert_to_fixed_point_00003e9e",
            "code": "\nsize_t convertToFixedPoint_00003e9e(char *outputString,int16_t value,int fixedPointDigits)\n\n{\n  size_t sVar1;\n  int fixedPointDigits_local;\n  int16_t value_local;\n  char *outputString_local;\n  \n  sVar1 = fmt_s32_dfp(outputString,(int)value,fixedPointDigits);\n  return sVar1;\n}\n\n",
            "renaming": {
                "FUN_00003e9e": "convert_to_fixed_point_00003e9e",
                "out": "outputString",
                "val": "value",
                "fp_digits": "fixedPointDigits",
                "fp_digits_local": "fixedPointDigits_local",
                "val_local": "value_local",
                "out_local": "outputString_local"
            },
            "calling": [
                "phydat_dump"
            ],
            "called": [
                "fmt_s32_dfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ec4": {
            "entrypoint": "0x00003ec4",
            "current_name": "format_float_to_string_00003ec4",
            "code": "\nsize_t formatFloatToString_00003ec4(char *outputString,int32_t value,int fractionalDigits)\n\n{\n  size_t writtenChars;\n  uint valDivisor;\n  int currentPos;\n  int fractionalDigits_local;\n  int32_t value_local;\n  char *outputString_local;\n  uint divisorLength;\n  int32_t absoluteValue;\n  uint32_t e;\n  int32_t division;\n  uint position;\n  \n  if (fractionalDigits + 7 < 0 != SCARRY4(fractionalDigits,7)) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  position = 0;\n  if (fractionalDigits == 0) {\n    position = fmt_s32_dec(outputString,value);\n  }\n  else if (fractionalDigits < 1) {\n    valDivisor = (uint)value / _tenmap[-fractionalDigits];\n    division = value - _tenmap[-fractionalDigits] * valDivisor;\n    if (division < 0) {\n      division = -division;\n    }\n    if ((valDivisor == 0) && (value < 0)) {\n      if (outputString != (char *)0x0) {\n        *outputString = '-';\n      }\n      position = 1;\n    }\n    if (outputString == (char *)0x0) {\n      writtenChars = fmt_s32_dec((char *)0x0,valDivisor);\n      position = writtenChars + 1 + position;\n    }\n    else {\n      writtenChars = fmt_s32_dec(outputString + position,valDivisor);\n      currentPos = position + writtenChars;\n      position = currentPos + 1;\n      outputString[currentPos] = '.';\n      writtenChars = fmt_s32_dec(outputString + position,division);\n      fmt_lpad(outputString + position,writtenChars,-fractionalDigits,'0');\n    }\n    position = -fractionalDigits + position;\n  }\n  else {\n    writtenChars = fmt_s32_dec(outputString,value);\n    if (outputString != (char *)0x0) {\n      memset(outputString + writtenChars,0x30,fractionalDigits);\n    }\n    position = fractionalDigits + writtenChars;\n  }\n  return position;\n}\n\n",
            "renaming": {
                "FUN_00003ec4": "format_float_to_string_00003ec4",
                "out": "outputString",
                "val": "value",
                "fp_digits": "fractionalDigits",
                "sVar1": "writtenChars",
                "val_00": "valDivisor",
                "iVar2": "currentPos",
                "fp_digits_local": "fractionalDigits_local",
                "val_local": "value_local",
                "out_local": "outputString_local",
                "div_len": "divisorLength",
                "abs": "absoluteValue",
                "div": "division",
                "pos": "position"
            },
            "calling": [
                "fmt_s16_dfp"
            ],
            "called": [
                "core_panic",
                "fmt_s32_dec",
                "fmt_lpad",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00003ff4": {
            "entrypoint": "0x00003ff4",
            "current_name": "pad_and_fill_00003ff4",
            "code": "\nsize_t padAndFill_00003ff4(char *output,size_t input_length,size_t padding_length,char padding_character)\n\n{\n  size_t sVar1;\n  char local_padding_character;\n  size_t local_padding_length;\n  size_t local_input_length;\n  char *local_output;\n  size_t iter;\n  \n  sVar1 = input_length;\n  if ((input_length < padding_length) && (sVar1 = padding_length, output != (char *)0x0)) {\n    memmove(output + (padding_length - input_length),output,input_length);\n    memset(output,(uiitert)(byte)padding_character,padding_length - input_length);\n  }\n  returiter sVar1;\n}\n\n",
            "renaming": {
                "FUN_00003ff4": "pad_and_fill_00003ff4",
                "out": "output",
                "in_len": "input_length",
                "pad_len": "padding_length",
                "pad_char": "padding_character",
                "pad_char_local": "local_padding_character",
                "pad_len_local": "local_padding_length",
                "in_len_local": "local_input_length",
                "out_local": "local_output",
                "n": "iter"
            },
            "calling": [
                "fmt_s32_dfp"
            ],
            "called": [
                "memmove",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004042": {
            "entrypoint": "0x00004042",
            "current_name": "convert_string_to_long_00004042",
            "code": "\nint convertStringToLong_00004042(char *stringToConvert)\n\n{\n  long convertedValue;\n  \n  convertedValue = strtol(stringToConvert,(char **)0x0,10);\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_00004042": "convert_string_to_long_00004042",
                "__nptr": "stringToConvert",
                "lVar1": "convertedValue"
            },
            "calling": [
                "write",
                "read"
            ],
            "called": [
                "strtol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000404c": {
            "entrypoint": "0x0000404c",
            "current_name": "process_data_0000404c",
            "code": "\nundefined4 processData_0000404c(uint *dataBuffer,int *paramBuffer)\n\n{\n  int chunkSize;\n  int *ptr;\n  uint ushortValue;\n  ushort flags;\n  int offset;\n  code *callback;\n  int remainingSize;\n  uint tempValue;\n  bool isZeroChunk;\n  \n  flags = *(ushort *)(paramBuffer + 3);\n  ushortValue = (uint)flags;\n  if ((int)(ushortValue << 0x1c) < 0) {\n    chunkSize = paramBuffer[4];\n    if (chunkSize != 0) {\n      offset = ushortValue << 0x1e;\n      isZeroChunk = offset == 0;\n      remainingSize = *paramBuffer;\n      if (isZeroChunk) {\n        offset = paramBuffer[5];\n      }\n      *paramBuffer = chunkSize;\n      if (!isZeroChunk) {\n        offset = 0;\n      }\n      paramBuffer[2] = offset;\n      for (remainingSize = remainingSize - chunkSize; 0 < remainingSize; remainingSize = remainingSize - offset) {\n        offset = (*(code *)paramBuffer[10])(dataBuffer,paramBuffer[8],chunkSize,remainingSize);\n        if (offset < 1) {\n          *(ushort *)(paramBuffer + 3) = *(ushort *)(paramBuffer + 3) | 0x40;\n          return 0xffffffff;\n        }\n        chunkSize = chunkSize + offset;\n      }\n    }\n  }\n  else {\n    if ((paramBuffer[1] < 1) && (paramBuffer[0x10] < 1)) {\n      return 0;\n    }\n    callback = (code *)paramBuffer[0xb];\n    if (callback == (code *)0x0) {\n      return 0;\n    }\n    tempValue = *dataBuffer;\n    *dataBuffer = 0;\n    if ((flags & 0x1000) == 0) {\n      chunkSize = (*callback)(dataBuffer,paramBuffer[8],ushortValue & 0x1000,1);\n      if ((chunkSize == -1) && (ushortValue = *dataBuffer, ushortValue != 0)) {\n        if ((ushortValue == 0x1d) || (ushortValue == 0x16)) {\n          *dataBuffer = tempValue;\n          return 0;\n        }\n        flags = *(ushort *)(paramBuffer + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      chunkSize = paramBuffer[0x15];\n    }\n    if (((int)((uint)*(ushort *)(paramBuffer + 3) << 0x1d) < 0) &&\n       (chunkSize = chunkSize - paramBuffer[1], paramBuffer[0xd] != 0)) {\n      chunkSize = chunkSize - paramBuffer[0x10];\n    }\n    chunkSize = (*(code *)paramBuffer[0xb])(dataBuffer,paramBuffer[8],chunkSize,0);\n    flags = *(ushort *)(paramBuffer + 3);\n    if ((chunkSize == -1) &&\n       ((0x1d < *dataBuffer || (-1 < (int)((0x20400001U >> (*dataBuffer & 0xff)) << 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(paramBuffer + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n    paramBuffer[1] = 0;\n    *paramBuffer = paramBuffer[4];\n    if (((int)((uint)flags << 0x13) < 0) && ((chunkSize != -1 || (*dataBuffer == 0)))) {\n      paramBuffer[0x15] = chunkSize;\n    }\n    ptr = (int *)paramBuffer[0xd];\n    *dataBuffer = tempValue;\n    if (ptr != (int *)0x0) {\n      if (ptr != paramBuffer + 0x11) {\n        _free_r(dataBuffer);\n      }\n      paramBuffer[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "dataBuffer",
                "param_2": "paramBuffer",
                "iVar1": "chunkSize",
                "piVar2": "ptr",
                "uVar3": "ushortValue",
                "uVar4": "flags",
                "iVar5": "offset",
                "pcVar6": "callback",
                "iVar7": "remainingSize",
                "uVar8": "tempValue",
                "bVar9": "isZeroChunk"
            },
            "calling": [
                "_fflush_r",
                "__srefill_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004158": {
            "entrypoint": "0x00004158",
            "current_name": "flush_stream_if_needed_00004158",
            "code": "\nundefined4 flushStreamIfNeeded_00004158(int streamHandle,undefined4 *streamBuffer)\n\n{\n  undefined4 result;\n  \n  if (streamBuffer[4] != 0) {\n    if ((streamHandle != 0) && (*(int *)(streamHandle + 0x18) == 0)) {\n      initializeStream();\n    }\n    if (streamBuffer == &fakeStdin) {\n      streamBuffer = *(undefined4 **)(streamHandle + 4);\n    }\n    else if (streamBuffer == (undefined4 *)&fakeStdout) {\n      streamBuffer = *(undefined4 **)(streamHandle + 8);\n    }\n    else if (streamBuffer == (undefined4 *)&fakeStderr) {\n      streamBuffer = *(undefined4 **)(streamHandle + 0xc);\n    }\n    if (*(short *)(streamBuffer + 3) != 0) {\n      if ((-1 < (int)(streamBuffer[0x19] << 0x1f)) && (-1 < (int)*(short *)(streamBuffer + 3) << 0x16)) {\n        acquireLockRecursive(streamBuffer[0x16]);\n      }\n      result = flushStream(streamHandle,streamBuffer);\n      if ((int)(streamBuffer[0x19] << 0x1f) < 0) {\n        return result;\n      }\n      if ((int)((uint)*(ushort *)(streamBuffer + 3) << 0x16) < 0) {\n        return result;\n      }\n      releaseLockRecursive(streamBuffer[0x16]);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004158": "flush_stream_if_needed_00004158",
                "param_1": "streamHandle",
                "param_2": "streamBuffer",
                "uVar1": "result",
                "__sf_fake_stdin": "fakeStdin",
                "__sf_fake_stdout": "fakeStdout",
                "__sf_fake_stderr": "fakeStderr",
                "__sinit": "initializeStream",
                "__sflush_r": "flushStream",
                "__retarget_lock_acquire_recursive": "acquireLockRecursive",
                "__retarget_lock_release_recursive": "releaseLockRecursive"
            },
            "calling": [
                "__swbuf_r",
                "fflush",
                "__srefill_r"
            ],
            "called": [
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sflush_r",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041d0": {
            "entrypoint": "0x000041d0",
            "current_name": "flush_file_buffer_000041d0",
            "code": "\nint flushFileBuffer_000041d0(FILE *stream)\n\n{\n  int result;\n  \n  if (stream == (FILE *)0x0) {\n    result = _fwalk_reent(&impure_data,0x4159);\n    return result;\n  }\n  result = _fflush_r(_impure_ptr,stream);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000041d0": "flush_file_buffer_000041d0",
                "__stream": "stream",
                "iVar1": "result"
            },
            "calling": [
                "lflush",
                "print_prompt"
            ],
            "called": [
                "_fwalk_reent",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000041f4": {
            "entrypoint": "0x000041f4",
            "current_name": "initialize_parameters_000041f4",
            "code": "\nvoid initializeParameters_000041f4(undefined4 *outputBuffer,undefined2 value1,undefined2 value2)\n\n{\n  *outputBuffer = 0;\n  outputBuffer[1] = 0;\n  outputBuffer[4] = 0;\n  outputBuffer[5] = 0;\n  outputBuffer[2] = 0;\n  *(undefined2 *)(outputBuffer + 3) = value1;\n  outputBuffer[0x19] = 0;\n  *(undefined2 *)((int)outputBuffer + 0xe) = value2;\n  outputBuffer[6] = 0;\n  memset(outputBuffer + 0x17,0,8);\n  outputBuffer[9] = 0x4dc9;\n  outputBuffer[10] = 0x4def;\n  outputBuffer[0xb] = 0x4e27;\n  outputBuffer[8] = outputBuffer;\n  outputBuffer[0xc] = 0x4e4b;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000041f4": "initialize_parameters_000041f4",
                "param_1": "outputBuffer",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000423c": {
            "entrypoint": "0x0000423c",
            "current_name": "execute_file_walk_0000423c",
            "code": "\nvoid execute_file_walk_0000423c(undefined4 reentrant)\n\n{\n  file_walk_with_reent(reentrant,0x4159);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000423c": "execute_file_walk_0000423c",
                "param_1": "reentrant",
                "_fwalk_reent": "file_walk_with_reent"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004248": {
            "entrypoint": "0x00004248",
            "current_name": "allocate_memory_00004248",
            "code": "\nundefined4 * allocateMemory_00004248(undefined4 size,int numElements)\n\n{\n  undefined4 *allocatedMemory;\n  int offset;\n  \n  offset = (numElements + -1) * 0x68;\n  allocatedMemory = (undefined4 *)_malloc_r(size,offset + 0x74);\n  if (allocatedMemory != (undefined4 *)0x0) {\n    *allocatedMemory = 0;\n    allocatedMemory[1] = numElements;\n    allocatedMemory[2] = allocatedMemory + 3;\n    memset(allocatedMemory + 3,0,offset + 0x68);\n  }\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_00004248": "allocate_memory_00004248",
                "param_1": "size",
                "param_2": "numElements",
                "puVar1": "allocatedMemory",
                "iVar2": "offset"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004274": {
            "entrypoint": "0x00004274",
            "current_name": "acquire_recursive_lock_00004274",
            "code": "\nvoid acquireRecursiveLock_00004274(void)\n\n{\n  lockAcquireRecursive(&sfpRecursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004274": "acquire_recursive_lock_00004274",
                "__retarget_lock_acquire_recursive": "lockAcquireRecursive",
                "__lock___sfp_recursive_mutex": "sfpRecursiveMutex"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004280": {
            "entrypoint": "0x00004280",
            "current_name": "release_recursive_lock_00004280",
            "code": "\nvoid releaseRecursiveLock_00004280(void)\n\n{\n  __retarget_lock_release_recursive(&__lock___sfp_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004280": "release_recursive_lock_00004280"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000428c": {
            "entrypoint": "0x0000428c",
            "current_name": "acquire_recursive_lock_for_init_0000428c",
            "code": "\nvoid acquireRecursiveLockForInit_0000428c(void)\n\n{\n  lockAcquireRecursive(&sinitRecursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000428c": "acquire_recursive_lock_for_init_0000428c",
                "__retarget_lock_acquire_recursive": "lockAcquireRecursive",
                "__lock___sinit_recursive_mutex": "sinitRecursiveMutex"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004298": {
            "entrypoint": "0x00004298",
            "current_name": "release_recursive_lock_00004298",
            "code": "\nvoid releaseRecursiveLock_00004298(void)\n\n{\n  releaseRecursiveLock_00004298Wrapper(recursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004298": "release_recursive_lock_00004298",
                "__retarget_lock_release_recursive": "releaseRecursiveLockWrapper",
                "&__lock___sinit_recursive_mutex": "recursiveMutex"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000042a4": {
            "entrypoint": "0x000042a4",
            "current_name": "initialize_data_000042a4",
            "code": "\nvoid initializeData_000042a4(undefined1 *dataPtr)\n\n{\n  undefined4 sfpResult;\n  undefined1 *impureDataPtr;\n  \n  __sinit_lock_acquire();\n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    impureDataPtr = &impure_data;\n    *(undefined4 *)(dataPtr + 0x28) = 0x423d;\n    if (dataPtr == &impure_data) {\n      impureDataPtr = (undefined1 *)0x1;\n    }\n    if (dataPtr == &impure_data) {\n      *(undefined1 **)(dataPtr + 0x18) = impureDataPtr;\n    }\n    sfpResult = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 4) = sfpResult;\n    sfpResult = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = sfpResult;\n    sfpResult = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = sfpResult;\n    std(*(undefined4 *)(dataPtr + 4),4,0);\n    std(*(undefined4 *)(dataPtr + 8),9,1);\n    std(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  __sinit_lock_release();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000042a4": "initialize_data_000042a4",
                "param_1": "dataPtr",
                "uVar1": "sfpResult",
                "puVar2": "impureDataPtr"
            },
            "calling": [
                "__sfp",
                "_fflush_r",
                "_puts_r",
                "iprintf",
                "_putc_r",
                "_getc_r",
                "__srefill_r",
                "putchar",
                "__swbuf_r",
                "getchar",
                "__srget_r",
                "_vfprintf_r",
                "__swsetup_r"
            ],
            "called": [
                "__sfp",
                "std",
                "__sinit_lock_acquire",
                "__sinit_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004314": {
            "entrypoint": "0x00004314",
            "current_name": "initialize_lock_00004314",
            "code": "\nint * initializeLock_00004314(undefined4 *lock_param)\n\n{\n  int *current_lock;\n  int *current_lock_data;\n  int **lock_list_ptr;\n  \n  __sfp_lock_acquire();\n  if (DAT_1fff029c == 0) {\n    __sinit(&impure_data);\n  }\n  lock_list_ptr = (int **)&DAT_1fff02cc;\n  do {\n    current_lock = lock_list_ptr[1];\n    current_lock_data = lock_list_ptr[2];\n    while (current_lock = (int *)((int)current_lock + -1), -1 < (int)current_lock) {\n      if (*(short *)(current_lock_data + 3) == 0) {\n        current_lock_data[3] = -0xffff;\n        current_lock_data[0x19] = 0;\n        __retarget_lock_init_recursive(current_lock_data + 0x16);\n        __sfp_lock_release();\n        current_lock_data[1] = 0;\n        current_lock_data[2] = 0;\n        current_lock_data[4] = 0;\n        current_lock_data[5] = 0;\n        *current_lock_data = 0;\n        current_lock_data[6] = 0;\n        memset(current_lock_data + 0x17,0,8);\n        current_lock_data[0xd] = 0;\n        current_lock_data[0xe] = 0;\n        current_lock_data[0x12] = 0;\n        current_lock_data[0x13] = 0;\n        return current_lock_data;\n      }\n      current_lock_data = current_lock_data + 0x1a;\n    }\n    if (*lock_list_ptr == (int *)0x0) {\n      current_lock = (int *)__sfmoreglue(lock_param,4);\n      *lock_list_ptr = current_lock;\n      if (current_lock == (int *)0x0) {\n        __sfp_lock_release();\n        *lock_param = 0xc;\n        return (int *)0x0;\n      }\n    }\n    lock_list_ptr = (int **)*lock_list_ptr;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00004314": "initialize_lock_00004314",
                "param_1": "lock_param",
                "piVar1": "current_lock",
                "piVar2": "current_lock_data",
                "ppiVar3": "lock_list_ptr"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sfp_lock_acquire",
                "__sinit",
                "__sfp_lock_release",
                "__retarget_lock_init_recursive",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043a0": {
            "entrypoint": "0x000043a0",
            "current_name": "process_data_000043a0",
            "code": "\nuint process_data_000043a0(int data_offset,code *callback)\n\n{\n  uint result;\n  int *ptr_list;\n  int current_item;\n  uint combined_result;\n  int remaining_items;\n  \n  ptr_list = (int *)(data_offset + 0x48);\n  combined_result = 0;\n  do {\n    remaining_items = ptr_list[1];\n    current_item = ptr_list[2];\n    while (remaining_items = remaining_items + -1, -1 < remaining_items) {\n      if ((1 < *(ushort *)(current_item + 0xc)) && (*(short *)(current_item + 0xe) != -1)) {\n        result = (*callback)(current_item);\n        combined_result = combined_result | result;\n      }\n      current_item = current_item + 0x68;\n    }\n    ptr_list = (int *)*ptr_list;\n  } while (ptr_list != (int *)0x0);\n  return combined_result;\n}\n\n",
            "renaming": {
                "FUN_000043a0": "process_data_000043a0",
                "param_1": "data_offset",
                "param_2": "callback",
                "piVar2": "ptr_list",
                "iVar3": "current_item",
                "uVar1": "result",
                "iVar5": "remaining_items",
                "uVar4": "combined_result"
            },
            "calling": [
                "__srefill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000043da": {
            "entrypoint": "0x000043da",
            "current_name": "process_data_000043da",
            "code": "\nuint processData_000043da(int inputPointer,code *callbackFunction,undefined4 paramA,undefined4 paramB)\n\n{\n  uint returnValue;\n  int counter;\n  int *pointerArray;\n  int dataOffset;\n  uint result;\n  int innerCounter;\n  \n  pointerArray = (int *)(inputPointer + 0x48);\n  result = 0;\n  do {\n    innerCounter = pointerArray[1];\n    dataOffset = pointerArray[2];\n    while (innerCounter = innerCounter + -1, -1 < innerCounter) {\n      if ((1 < *(ushort *)(dataOffset + 0xc)) && (counter = *(short *)(dataOffset + 0xe) + 1, counter != 0)) {\n        returnValue = (*callbackFunction)(inputPointer,dataOffset,paramA,counter,paramB);\n        result = result | returnValue;\n      }\n      dataOffset = dataOffset + 0x68;\n    }\n    pointerArray = (int *)*pointerArray;\n  } while (pointerArray != (int *)0x0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000043da": "process_data_000043da",
                "param_1": "inputPointer",
                "param_2": "callbackFunction",
                "param_3": "paramA",
                "param_4": "paramB",
                "piVar3": "pointerArray",
                "iVar2": "counter",
                "iVar4": "dataOffset",
                "uVar1": "returnValue",
                "uVar5": "result",
                "iVar6": "innerCounter"
            },
            "calling": [
                "_cleanup_r",
                "fflush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004418": {
            "entrypoint": "0x00004418",
            "current_name": "read_character_00004418",
            "code": "\n\n\nint readCharacter_00004418(void)\n\n{\n  int ptrValue;\n  \n  ptrValue = ptr;\n  if ((ptr != 0) && (*(int *)(ptr + 0x18) == 0)) {\n    __sinit(ptr);\n  }\n  ptrValue = _getc_r(ptrValue,*(undefined4 *)(ptrValue + 4));\n  return ptrValue;\n}\n\n",
            "renaming": {
                "FUN_00004418": "read_character_00004418",
                "_impure_ptr": "ptr",
                "iVar1": "ptrValue"
            },
            "calling": [
                "readline"
            ],
            "called": [
                "__sinit",
                "_getc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000443c": {
            "entrypoint": "0x0000443c",
            "current_name": "calculate_date_time_0000443c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\ntm * calculateDateTime_0000443c(time_t *timer,tm *timeStruct)\n\n{\n  int quotient;\n  uint daysSinceEpoch;\n  uint remainingSeconds;\n  uint totalDays;\n  int dayOfYear;\n  uint leapYearCycles;\n  time_t timeVal1;\n  time_t timeVal2;\n  uint year;\n  bool isNegative;\n  \n  timeVal1 = *timer;\n  timeVal2 = timer[1];\n  quotient = __aeabi_ldivmod(timeVal1,timeVal2,0x15180,0);\n  remainingSeconds = 0x15180;\n  __aeabi_ldivmod(timeVal1,timeVal2,0x15180,0);\n  isNegative = (int)remainingSeconds < 0;\n  if (isNegative) {\n    remainingSeconds = remainingSeconds + 0x15180;\n  }\n  if (isNegative) {\n    daysSinceEpoch = quotient + 0xafa6b;\n  }\n  else {\n    daysSinceEpoch = quotient + 0xafa6c;\n  }\n  timeStruct->tm_hour = remainingSeconds / 0xe10;\n  timeStruct->tm_min = (remainingSeconds % 0xe10) / 0x3c;\n  timeStruct->tm_sec = (remainingSeconds % 0xe10) % 0x3c;\n  timeStruct->tm_wday = (daysSinceEpoch + 3) % 7;\n  remainingSeconds = daysSinceEpoch;\n  if ((int)daysSinceEpoch < 0) {\n    remainingSeconds = daysSinceEpoch - 0x23ab0;\n  }\n  daysSinceEpoch = (remainingSeconds / 0x23ab1) * -0x23ab1 + daysSinceEpoch;\n  totalDays = ((daysSinceEpoch / 0x8eac + daysSinceEpoch) - daysSinceEpoch / 0x5b4) - daysSinceEpoch / 0x23ab0;\n  leapYearCycles = totalDays / 0x16d;\n  daysSinceEpoch = (leapYearCycles / 100 - totalDays / 0x5b4) + daysSinceEpoch + leapYearCycles * -0x16d;\n  year = daysSinceEpoch * 5 + 2;\n  totalDays = year / 0x99;\n  if (year < 0x5fa) {\n    quotient = 2;\n  }\n  else {\n    quotient = -10;\n  }\n  year = totalDays + quotient;\n  quotient = (remainingSeconds / 0x23ab1) * 400 + leapYearCycles;\n  if (year < 2) {\n    quotient = quotient + 1;\n  }\n  if (daysSinceEpoch < 0x132) {\n    if (((leapYearCycles & 3) == 0) && (leapYearCycles != (leapYearCycles / 100) * 100)) {\n      remainingSeconds = 1;\n    }\n    else {\n      remainingSeconds = (uint)(leapYearCycles % 400 == 0);\n    }\n    dayOfYear = daysSinceEpoch + 0x3b + remainingSeconds;\n  }\n  else {\n    dayOfYear = daysSinceEpoch - 0x132;\n  }\n  timeStruct->tm_yday = dayOfYear;\n  timeStruct->tm_mday = (daysSinceEpoch + 1) - (totalDays * 0x99 + 2) / 5;\n  timeStruct->tm_mon = year;\n  timeStruct->tm_year = quotient + -0x76c;\n  timeStruct->tm_isdst = 0;\n  return timeStruct;\n}\n\n",
            "renaming": {
                "FUN_0000443c": "calculate_date_time_0000443c",
                "__timer": "timer",
                "__tp": "timeStruct",
                "iVar1": "quotient",
                "uVar2": "daysSinceEpoch",
                "uVar3": "remainingSeconds",
                "uVar4": "totalDays",
                "iVar5": "dayOfYear",
                "uVar6": "leapYearCycles",
                "tVar7": "timeVal1",
                "tVar8": "timeVal2",
                "uVar9": "year",
                "bVar10": "isNegative"
            },
            "calling": [
                "rtc_get_alarm",
                "rtc_get_time"
            ],
            "called": [
                "__aeabi_ldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000459c": {
            "entrypoint": "0x0000459c",
            "current_name": "execute_cleanup_functions_0000459c",
            "code": "\nvoid execute_cleanup_functions_0000459c(EVP_PKEY_CTX *ctx)\n\n{\n  code **function_array_ptr;\n  int index;\n  \n  function_array_ptr = (code **)&__fini_array_end;\n  for (index = 0; index != 0; index = index + 1) {\n    ctx = (EVP_PKEY_CTX *)(**function_array_ptr)();\n    function_array_ptr = function_array_ptr + 1;\n  }\n  _init(ctx);\n  function_array_ptr = (code **)&__fini_array_end;\n  for (index = 0; index != 0; index = index + 1) {\n    (**function_array_ptr)();\n    function_array_ptr = function_array_ptr + 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000459c": "execute_cleanup_functions_0000459c",
                "param_1": "ctx",
                "ppcVar1": "function_array_ptr",
                "iVar2": "index"
            },
            "calling": [
                "reset_handler_default"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000045e4": {
            "entrypoint": "0x000045e4",
            "current_name": "FUNC_000045e4",
            "code": "\nvoid FUNC_000045e4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e4": "FUNC_000045e4"
            },
            "calling": [
                "__sfp"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e6": {
            "entrypoint": "0x000045e6",
            "current_name": "FUNC_000045e6",
            "code": "\nvoid FUNC_000045e6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e6": "FUNC_000045e6"
            },
            "calling": [
                "__tz_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045e8": {
            "entrypoint": "0x000045e8",
            "current_name": "FUNC_000045e8",
            "code": "\nvoid FUNC_000045e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045e8": "FUNC_000045e8"
            },
            "calling": [
                "__env_lock",
                "_fflush_r",
                "__sfp_lock_acquire",
                "__malloc_lock",
                "_puts_r",
                "_vfprintf_r",
                "__sinit_lock_acquire",
                "_putc_r",
                "_getc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ea": {
            "entrypoint": "0x000045ea",
            "current_name": "FUNC_000045ea",
            "code": "\nvoid FUNC_000045ea(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ea": "FUNC_000045ea"
            },
            "calling": [
                "__tz_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ec": {
            "entrypoint": "0x000045ec",
            "current_name": "FUNC_000045ec",
            "code": "\nvoid FUNC_000045ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000045ec": "FUNC_000045ec"
            },
            "calling": [
                "_fflush_r",
                "_puts_r",
                "__sfp_lock_release",
                "__malloc_unlock",
                "_vfprintf_r",
                "_putc_r",
                "__env_unlock",
                "_getc_r",
                "__sinit_lock_release"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000045ee": {
            "entrypoint": "0x000045ee",
            "current_name": "copy_reverse_memory_000045ee",
            "code": "\nvoid * copy_reverse_memory_000045ee(void *destination,void *source,size_t size)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)source + size);\n  if ((source < destination) && (destination < src_ptr)) {\n    dest_ptr = (undefined *)(size + (int)destination);\n    while (dest_ptr != (undefined *)destination) {\n      src_ptr = src_ptr + -1;\n      dest_ptr = dest_ptr + -1;\n      *dest_ptr = *src_ptr;\n    }\n  }\n  else {\n    dest_ptr = (undefined *)((int)destination + -1);\n    for (; (undefined *)source != src_ptr; source = (void *)((int)source + 1)) {\n      dest_ptr = dest_ptr + 1;\n      *dest_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000045ee": "copy_reverse_memory_000045ee",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "fmt_lpad"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004622": {
            "entrypoint": "0x00004622",
            "current_name": "memset_00004622",
            "code": "\nvoid * memset_00004622(void *destination,int value,size_t size)\n\n{\n  undefined *ptr;\n  \n  for (ptr = (undefined *)destination; ptr != (undefined *)(size + (int)destination); ptr = ptr + 1) {\n    *ptr = (char)value;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00004622": "memset_00004622",
                "__s": "destination",
                "__c": "value",
                "__n": "size",
                "puVar1": "ptr"
            },
            "calling": [
                "__sfmoreglue",
                "__sfp",
                "std",
                "fmt_lpad",
                "write",
                "fmt_s32_dfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004634": {
            "entrypoint": "0x00004634",
            "current_name": "calculate_date_00004634",
            "code": "\nvoid calculateDate_00004634(uint *date,uint year,undefined4 daysOffset)\n\n{\n  int monthDays;\n  uint day;\n  uint leapYears;\n  int yearType;\n  bool isNegative;\n  uint *quotient;\n  uint remainder;\n  undefined4 param_3Copy;\n  \n  quotient = date;\n  remainder = year;\n  param_3Copy = daysOffset;\n  if (0x3b < *date) {\n    div((int)&quotient,*date);\n    day = date[1] + (int)quotient;\n    date[1] = day;\n    if ((int)remainder < 0) {\n      day = day - 1;\n      *date = remainder + 0x3c;\n    }\n    else {\n      *date = remainder;\n    }\n    if ((int)remainder < 0) {\n      date[1] = day;\n    }\n  }\n  if (0x3b < date[1]) {\n    div((int)&quotient,date[1]);\n    isNegative = (int)remainder < 0;\n    leapYears = date[2] + (int)quotient;\n    date[2] = leapYears;\n    day = remainder;\n    if (isNegative) {\n      day = remainder + 0x3c;\n      leapYears = leapYears - 1;\n    }\n    if (!isNegative) {\n      date[1] = day;\n    }\n    if (isNegative) {\n      date[1] = day;\n    }\n    if (isNegative) {\n      date[2] = leapYears;\n    }\n  }\n  if (0x17 < date[2]) {\n    div((int)&quotient,date[2]);\n    isNegative = (int)remainder < 0;\n    leapYears = date[3] + (int)quotient;\n    date[3] = leapYears;\n    day = remainder;\n    if (isNegative) {\n      day = remainder + 0x18;\n      leapYears = leapYears - 1;\n    }\n    if (!isNegative) {\n      date[2] = day;\n    }\n    if (isNegative) {\n      date[2] = day;\n    }\n    if (isNegative) {\n      date[3] = leapYears;\n    }\n  }\n  if (0xb < date[4]) {\n    div((int)&quotient,date[4]);\n    isNegative = (int)remainder < 0;\n    day = date[5] + (int)quotient;\n    date[5] = day;\n    if (isNegative) {\n      remainder = remainder + 0xc;\n      day = day - 1;\n    }\n    if (!isNegative) {\n      date[4] = remainder;\n    }\n    if (isNegative) {\n      date[4] = remainder;\n    }\n    if (isNegative) {\n      date[5] = day;\n    }\n  }\n  day = date[5];\n  if ((day & 3) == 0) {\n    if (day == (day / 100) * 100) {\n      if ((day + 0x76c) % 400 == 0) {\n        yearType = 0x1d;\n      }\n      else {\n        yearType = 0x1c;\n      }\n    }\n    else {\n      yearType = 0x1d;\n    }\n  }\n  else {\n    yearType = 0x1c;\n  }\n  if ((int)date[3] < 1) {\n    while ((int)date[3] < 1) {\n      day = date[4];\n      date[4] = day - 1;\n      if (day - 1 == 0xffffffff) {\n        leapYears = date[5];\n        day = leapYears - 1;\n        date[4] = 0xb;\n        date[5] = day;\n        if ((day & 3) == 0) {\n          if (day == (day / 100) * 100) {\n            if ((leapYears + 0x76b) % 400 == 0) {\n              yearType = 0x1d;\n            }\n            else {\n              yearType = 0x1c;\n            }\n          }\n          else {\n            yearType = 0x1d;\n          }\n        }\n        else {\n          yearType = 0x1c;\n        }\n      }\n      monthDays = yearType;\n      if (date[4] != 1) {\n        monthDays = *(int *)(&DAYS_IN_MONTH + date[4] * 4);\n      }\n      date[3] = monthDays + date[3];\n    }\n  }\n  else {\n    while( true ) {\n      day = date[4];\n      monthDays = yearType;\n      if (day != 1) {\n        monthDays = *(int *)(&DAYS_IN_MONTH + day * 4);\n      }\n      if ((int)date[3] <= monthDays) break;\n      date[3] = date[3] - monthDays;\n      date[4] = day + 1;\n      if (day + 1 == 0xc) {\n        leapYears = date[5];\n        day = leapYears + 1;\n        date[4] = 0;\n        date[5] = day;\n        if ((day & 3) == 0) {\n          if (day % 100 == 0) {\n            if ((leapYears + 0x76d) % 400 == 0) {\n              yearType = 0x1d;\n            }\n            else {\n              yearType = 0x1c;\n            }\n          }\n          else {\n            yearType = 0x1d;\n          }\n        }\n        else {\n          yearType = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004634": "calculate_date_00004634",
                "param_1": "date",
                "param_2": "year",
                "param_3": "daysOffset",
                "iVar1": "monthDays",
                "uVar2": "day",
                "uVar3": "leapYears",
                "iVar4": "yearType",
                "bVar5": "isNegative",
                "local_20": "quotient",
                "local_1c": "remainder",
                "uStack_18": "param_3Copy"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "div"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000047e4": {
            "entrypoint": "0x000047e4",
            "current_name": "convert_t_mto_time_t_000047e4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t convertTMtoTimeT_000047e4(tm *timeInfo)\n\n{\n  longlong totalSeconds;\n  int *tzInfo;\n  uint daylight;\n  int daysBeforeMonth;\n  int days;\n  int leapYearAdjustment;\n  uint startOfYear;\n  uint endOfYear;\n  uint startOfMonth;\n  int daysOfYear;\n  uint year;\n  uint adjustedDst;\n  uint originalDst;\n  uint totalSeconds32;\n  time_t result;\n  bool isDST;\n  \n  tzInfo = (int *)__gettzinfo();\n  validate_structure(timeInfo);\n  year = timeInfo->tm_year;\n  daysOfYear = timeInfo->tm_mday + -1 + *(int *)(&_DAYS_BEFORE_MONTH + timeInfo->tm_mon * 4);\n  if (((1 < timeInfo->tm_mon) && ((year & 3) == 0)) &&\n     ((year != (year / 100) * 100 || (year + 0x76c == ((year + 0x76c) / 400) * 400)))) {\n    daysOfYear = daysOfYear + 1;\n  }\n  timeInfo->tm_yday = daysOfYear;\n  if (20000 < (int)&DAT_00002710 + year) {\n    return -1;\n  }\n  if ((int)year < 0x47) {\n    if (year != 0x46) {\n      for (endOfYear = 0x45; (int)year < (int)endOfYear; endOfYear = endOfYear - 1) {\n        if ((endOfYear & 3) == 0) {\n          if (endOfYear == (endOfYear / 100) * 100) {\n            if ((endOfYear + 0x76c) % 400 == 0) {\n              leapYearAdjustment = 0x16e;\n            }\n            else {\n              leapYearAdjustment = 0x16d;\n            }\n          }\n          else {\n            leapYearAdjustment = 0x16e;\n          }\n        }\n        else {\n          leapYearAdjustment = 0x16d;\n        }\n        daysOfYear = daysOfYear - leapYearAdjustment;\n      }\n      if ((endOfYear & 3) == 0) {\n        if (year == (year / 100) * 100) {\n          leapYearAdjustment = 0x16d;\n          if ((year + 0x76c) % 400 == 0) {\n            leapYearAdjustment = 0x16e;\n          }\n        }\n        else {\n          leapYearAdjustment = 0x16e;\n        }\n      }\n      else {\n        leapYearAdjustment = 0x16d;\n      }\n      daysOfYear = daysOfYear - leapYearAdjustment;\n    }\n  }\n  else {\n    endOfYear = 0x46;\n    do {\n      if ((endOfYear & 3) == 0) {\n        if (endOfYear % 100 == 0) {\n          if ((endOfYear + 0x76c) % 400 == 0) {\n            leapYearAdjustment = 0x16e;\n          }\n          else {\n            leapYearAdjustment = 0x16d;\n          }\n        }\n        else {\n          leapYearAdjustment = 0x16e;\n        }\n      }\n      else {\n        leapYearAdjustment = 0x16d;\n      }\n      endOfYear = endOfYear + 1;\n      daysOfYear = daysOfYear + leapYearAdjustment;\n    } while (year != endOfYear);\n  }\n  totalSeconds = (longlong)daysOfYear * 0x15180 +\n          (longlong)(timeInfo->tm_hour * 0xe10 + timeInfo->tm_min * 0x3c + timeInfo->tm_sec);\n  totalSeconds32 = (uint)totalSeconds;\n  leapYearAdjustment = (int)((ulonglong)totalSeconds >> 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  endOfYear = _daylight;\n  if (_daylight == 0) {\nLAB_00004934:\n    result = totalSeconds32 + tzInfo[10];\n  }\n  else {\n    originalDst = timeInfo->tm_isdst;\n    adjustedDst = originalDst;\n    if (0 < (int)originalDst) {\n      adjustedDst = 1;\n    }\n    if ((tzInfo[1] == timeInfo->tm_year + 0x76c) || (daysBeforeMonth = __tzcalc_limits(), daysBeforeMonth != 0)) {\n      startOfMonth = tzInfo[0x14];\n      daylight = tzInfo[0x12];\n      startOfYear = tzInfo[10];\n      endOfYear = daylight - startOfYear;\n      daysBeforeMonth = (tzInfo[0x13] - ((int)startOfYear >> 0x1f)) - (uint)(daylight < startOfYear);\n      if (((int)((leapYearAdjustment - daysBeforeMonth) - (uint)(totalSeconds32 < endOfYear)) < 0 ==\n           (SBORROW4(leapYearAdjustment,daysBeforeMonth) != SBORROW4(leapYearAdjustment - daysBeforeMonth,(uint)(totalSeconds32 < endOfYear)))) &&\n         (days = (tzInfo[0x13] - ((int)startOfMonth >> 0x1f)) - (uint)(daylight < startOfMonth),\n         isDST = totalSeconds32 < daylight - startOfMonth,\n         (int)((leapYearAdjustment - days) - (uint)isDST) < 0 !=\n         (SBORROW4(leapYearAdjustment,days) != SBORROW4(leapYearAdjustment - days,(uint)isDST)))) goto LAB_00004a88;\n      daylight = tzInfo[8] - startOfMonth;\n      days = (tzInfo[9] - ((int)startOfMonth >> 0x1f)) - (uint)((uint)tzInfo[8] < startOfMonth);\n      if (*tzInfo != 0) {\n        if ((int)((leapYearAdjustment - days) - (uint)(totalSeconds32 < daylight)) < 0 ==\n            (SBORROW4(leapYearAdjustment,days) != SBORROW4(leapYearAdjustment - days,(uint)(totalSeconds32 < daylight))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        endOfYear = 0;\n        if ((int)originalDst < 0) goto LAB_00004934;\nLAB_00004a14:\n        originalDst = adjustedDst ^ endOfYear;\n        adjustedDst = endOfYear;\n        if (originalDst == 1) {\n          if (endOfYear == 0) {\n            leapYearAdjustment = startOfMonth - startOfYear;\n          }\n          else {\n            leapYearAdjustment = startOfYear - startOfMonth;\n          }\n          daysBeforeMonth = timeInfo->tm_mday;\n          totalSeconds32 = totalSeconds32 + leapYearAdjustment;\n          timeInfo->tm_sec = timeInfo->tm_sec + leapYearAdjustment;\n          validate_structure(timeInfo);\n          daysBeforeMonth = timeInfo->tm_mday - daysBeforeMonth;\n          if (daysBeforeMonth != 0) {\n            if (daysBeforeMonth < 2) {\n              if (daysBeforeMonth == -2 || daysBeforeMonth + 2 < 0 != SCARRY4(daysBeforeMonth,2)) {\n                daysBeforeMonth = 1;\n              }\n            }\n            else {\n              daysBeforeMonth = -1;\n            }\n            leapYearAdjustment = daysBeforeMonth + timeInfo->tm_yday;\n            daysOfYear = daysOfYear + daysBeforeMonth;\n            if (leapYearAdjustment < 0) {\n              endOfYear = year - 1;\n              if ((endOfYear & 3) == 0) {\n                if (endOfYear == (endOfYear / 100) * 100) {\n                  leapYearAdjustment = 0x16d;\n                  if ((year + 0x76b) % 400 != 0) {\n                    leapYearAdjustment = 0x16c;\n                  }\n                }\n                else {\n                  leapYearAdjustment = 0x16d;\n                }\n              }\n              else {\n                leapYearAdjustment = 0x16c;\n              }\n            }\n            else {\n              if ((year & 3) == 0) {\n                if (year == (year / 100) * 100) {\n                  daysBeforeMonth = 0x16d;\n                  if ((year + 0x76c) % 400 == 0) {\n                    daysBeforeMonth = 0x16e;\n                  }\n                }\n                else {\n                  daysBeforeMonth = 0x16e;\n                }\n              }\n              else {\n                daysBeforeMonth = 0x16d;\n              }\n              if (daysBeforeMonth <= leapYearAdjustment) {\n                leapYearAdjustment = leapYearAdjustment - daysBeforeMonth;\n              }\n            }\n            timeInfo->tm_yday = leapYearAdjustment;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((leapYearAdjustment - days) - (uint)(totalSeconds32 < daylight)) < 0 !=\n          (SBORROW4(leapYearAdjustment,days) != SBORROW4(leapYearAdjustment - days,(uint)(totalSeconds32 < daylight)))) {\nLAB_0000491e:\n        if ((int)((leapYearAdjustment - daysBeforeMonth) - (uint)(totalSeconds32 < endOfYear)) < 0 ==\n            (SBORROW4(leapYearAdjustment,daysBeforeMonth) != SBORROW4(leapYearAdjustment - daysBeforeMonth,(uint)(totalSeconds32 < endOfYear))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)originalDst) {\n        endOfYear = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      endOfYear = adjustedDst;\n      if (adjustedDst != 1) goto LAB_00004934;\n    }\n    result = totalSeconds32 + tzInfo[0x14];\n    endOfYear = 1;\n  }\n  __tz_unlock();\n  timeInfo->tm_isdst = endOfYear;\n  timeInfo->tm_wday = (daysOfYear + 4U) % 7;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000047e4": "convert_t_mto_time_t_000047e4",
                "__tp": "timeInfo",
                "lVar1": "totalSeconds",
                "piVar2": "tzInfo",
                "uVar3": "daylight",
                "iVar4": "daysBeforeMonth",
                "iVar5": "days",
                "iVar6": "leapYearAdjustment",
                "uVar7": "startOfYear",
                "uVar8": "endOfYear",
                "uVar9": "startOfMonth",
                "iVar10": "daysOfYear",
                "uVar11": "year",
                "uVar12": "adjustedDst",
                "uVar13": "originalDst",
                "uVar14": "totalSeconds32",
                "tVar15": "result",
                "bVar16": "isDST"
            },
            "calling": [
                "rtc_set_alarm",
                "rtc_set_time"
            ],
            "called": [
                "_tzset_unlocked",
                "validate_structure",
                "__tz_lock",
                "__gettzinfo",
                "__tz_unlock",
                "__tzcalc_limits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004b34": {
            "entrypoint": "0x00004b34",
            "current_name": "allocate_memory_block_00004b34",
            "code": "\nvoid allocateMemoryBlock_00004b34(undefined4 *lock,int size,undefined4 arg3,undefined4 arg4)\n\n{\n  int *tempPtr;\n  int **returnPtr;\n  int **currentPtr;\n  int **prevPtr;\n  int **nextPtr;\n  int **newPtr;\n  bool isSamePtr;\n  \n  if (size == 0) {\n    return;\n  }\n  newPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newPtr = (int **)((int)newPtr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  prevPtr = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    newPtr[1] = (int *)0x0;\n    currentPtr = returnPtr;\n    __malloc_free_list = newPtr;\n  }\n  else {\n    nextPtr = __malloc_free_list;\n    if (newPtr < __malloc_free_list) {\n      currentPtr = (int **)*newPtr;\n      prevPtr = (int **)((int)newPtr + (int)currentPtr);\n      isSamePtr = __malloc_free_list == prevPtr;\n      if (isSamePtr) {\n        prevPtr = (int **)*__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n      }\n      newPtr[1] = (int *)__malloc_free_list;\n      __malloc_free_list = newPtr;\n      if (isSamePtr) {\n        prevPtr = (int **)((int)prevPtr + (int)currentPtr);\n        *newPtr = (int *)prevPtr;\n      }\n    }\n    else {\n      do {\n        prevPtr = nextPtr;\n        nextPtr = (int **)prevPtr[1];\n        if (nextPtr == (int **)0x0) break;\n      } while (nextPtr <= newPtr);\n      currentPtr = (int **)*prevPtr;\n      if ((int **)((int)prevPtr + (int)currentPtr) == newPtr) {\n        currentPtr = (int **)((int)currentPtr + (int)*newPtr);\n        *prevPtr = (int *)currentPtr;\n        if (nextPtr == (int **)((int)prevPtr + (int)currentPtr)) {\n          tempPtr = *nextPtr;\n          prevPtr[1] = nextPtr[1];\n          currentPtr = (int **)((int)currentPtr + (int)tempPtr);\n          *prevPtr = (int *)currentPtr;\n        }\n      }\n      else if (newPtr < (int **)((int)prevPtr + (int)currentPtr)) {\n        *lock = 0xc;\n      }\n      else {\n        currentPtr = (int **)((int)newPtr + (int)*newPtr);\n        isSamePtr = nextPtr == currentPtr;\n        if (isSamePtr) {\n          currentPtr = (int **)*nextPtr;\n          nextPtr = (int **)nextPtr[1];\n        }\n        newPtr[1] = (int *)nextPtr;\n        if (isSamePtr) {\n          currentPtr = (int **)((int)currentPtr + (int)*newPtr);\n          *newPtr = (int *)currentPtr;\n        }\n        prevPtr[1] = (int *)newPtr;\n      }\n    }\n  }\n  __malloc_unlock(lock,currentPtr,prevPtr,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004b34": "allocate_memory_block_00004b34",
                "param_1": "lock",
                "param_2": "size",
                "param_3": "arg3",
                "param_4": "arg4",
                "piVar1": "tempPtr",
                "extraout_r1": "returnPtr",
                "ppiVar2": "currentPtr",
                "ppiVar3": "prevPtr",
                "ppiVar4": "nextPtr",
                "ppiVar5": "newPtr",
                "bVar6": "isSamePtr"
            },
            "calling": [
                "_realloc_r",
                "__ssrefill_r",
                "free",
                "__sflush_r",
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004bd0": {
            "entrypoint": "0x00004bd0",
            "current_name": "allocate_memory_00004bd0",
            "code": "\nuint allocate_memory_00004bd0(_reent *reentrancy_structure,uint requested_size)\n\n{\n  uint *current_entry;\n  void *temp_ptr;\n  int difference;\n  uint remaining_size;\n  uint *previous_entry;\n  uint allocated_size;\n  \n  allocated_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < requested_size)) {\n    reentrancy_structure->_errno = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_entry = __malloc_free_list;\n    for (previous_entry = __malloc_free_list; previous_entry != (uint *)0x0; previous_entry = (uint *)previous_entry[1]) {\n      remaining_size = *previous_entry - allocated_size;\n      if (-1 < (int)remaining_size) {\n        if (0xb < remaining_size) {\n          *previous_entry = remaining_size;\n          previous_entry = (uint *)((int)previous_entry + remaining_size);\n          goto LAB_00004c34;\n        }\n        if (current_entry == previous_entry) {\n          __malloc_free_list = (uint *)previous_entry[1];\n        }\n        if (current_entry != previous_entry) {\n          current_entry[1] = (uint)(uint *)previous_entry[1];\n        }\n        goto LAB_00004c42;\n      }\n      current_entry = previous_entry;\n    }\n    if (__malloc_sbrk_start == (void *)0x0) {\n      __malloc_sbrk_start = _sbrk_r(reentrancy_structure,0);\n    }\n    current_entry = (uint *)_sbrk_r(reentrancy_structure,allocated_size);\n    if ((current_entry != (uint *)0xffffffff) &&\n       ((previous_entry = (uint *)((int)current_entry + 3U & 0xfffffffc), current_entry == previous_entry ||\n        (temp_ptr = _sbrk_r(reentrancy_structure,(int)previous_entry - (int)current_entry), temp_ptr != (void *)0xffffffff)))) {\nLAB_00004c34:\n      *previous_entry = allocated_size;\nLAB_00004c42:\n      __malloc_unlock(reentrancy_structure);\n      allocated_size = (int)previous_entry + 0xbU & 0xfffffff8;\n      difference = allocated_size - (int)(previous_entry + 1);\n      if (difference == 0) {\n        return allocated_size;\n      }\n      *(uint *)((int)previous_entry + difference) = (int)(previous_entry + 1) - allocated_size;\n      return allocated_size;\n    }\n    reentrancy_structure->_errno = 0xc;\n    __malloc_unlock(reentrancy_structure);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004bd0": "allocate_memory_00004bd0",
                "param_1": "reentrancy_structure",
                "param_2": "requested_size",
                "puVar1": "current_entry",
                "pvVar2": "temp_ptr",
                "iVar3": "difference",
                "uVar4": "remaining_size",
                "puVar5": "previous_entry",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__sfmoreglue",
                "__submore",
                "__smakebuf_r",
                "_realloc_r",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004c84": {
            "entrypoint": "0x00004c84",
            "current_name": "print_formatted_00004c84",
            "code": "\nint print_formatted_00004c84(char *format_string,...)\n\n{\n  int impure_ptr;\n  undefined4 arg1;\n  undefined4 arg2;\n  undefined4 arg3;\n  char *format_ptr;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  \n  impure_ptr = _impure_ptr;\n  format_ptr = format_string;\n  temp1 = arg1;\n  temp2 = arg2;\n  temp3 = arg3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impure_ptr = _vfprintf_r(impure_ptr,*(undefined4 *)(impure_ptr + 8),format_string,&temp1,format_ptr,&temp1);\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_00004c84": "print_formatted_00004c84",
                "__format": "format_string",
                "iVar1": "impure_ptr",
                "in_r1": "arg1",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "pcVar2": "format_ptr",
                "uStack_c": "temp1",
                "uStack_8": "temp2",
                "uStack_4": "temp3"
            },
            "calling": [
                "main_trampoline",
                "read",
                "hard_fault_handler",
                "_rtc_handler",
                "handle_input_line",
                "cpu_print_last_instruction",
                "probe",
                "phydat_dump",
                "core_panic",
                "_saul",
                "write",
                "print_help",
                "ps",
                "_print_time",
                "list"
            ],
            "called": [
                "__sinit",
                "_vfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cb4": {
            "entrypoint": "0x00004cb4",
            "current_name": "print_character_00004cb4",
            "code": "\nint print_character_00004cb4(int character)\n\n{\n  int pointer;\n  undefined4 temporary_register;\n  \n  pointer = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  pointer = _putc_r(pointer,character,*(undefined4 *)(pointer + 8),temporary_register);\n  return pointer;\n}\n\n",
            "renaming": {
                "FUN_00004cb4": "print_character_00004cb4",
                "__c": "character",
                "iVar1": "pointer",
                "in_r3": "temporary_register"
            },
            "calling": [
                "_putchar"
            ],
            "called": [
                "__sinit",
                "_putc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004cdc": {
            "entrypoint": "0x00004cdc",
            "current_name": "write_to_output_file_00004cdc",
            "code": "\nundefined4 write_to_output_file_00004cdc(int output_file_handle,int input_character)\n\n{\n  char current_character;\n  int buffer_status;\n  char *buffer_pointer;\n  char **file_stream;\n  undefined4 return_value;\n  char *input_pointer;\n  \n  if ((output_file_handle != 0) && (*(int *)(output_file_handle + 0x18) == 0)) {\n    __sinit();\n  }\n  file_stream = *(char ***)(output_file_handle + 8);\n  if (*(int *)(output_file_handle + 0x18) == 0) {\n    __sinit(output_file_handle);\n  }\n  if (file_stream == (char **)&__sf_fake_stdin) {\n    file_stream = *(char ***)(output_file_handle + 4);\n  }\n  else if (file_stream == (char **)&__sf_fake_stdout) {\n    file_stream = *(char ***)(output_file_handle + 8);\n  }\n  else if (file_stream == (char **)&__sf_fake_stderr) {\n    file_stream = *(char ***)(output_file_handle + 0xc);\n  }\n  if ((-1 < (int)file_stream[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(file_stream[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(file_stream + 3) << 0x1c) < 0) && (file_stream[4] != (char *)0x0)) ||\n     (buffer_status = __swsetup_r(output_file_handle,file_stream), buffer_status == 0)) {\n    input_pointer = (char *)(input_character + -1);\n    do {\n      while( true ) {\n        input_pointer = input_pointer + 1;\n        current_character = *input_pointer;\n        buffer_pointer = file_stream[2] + -1;\n        file_stream[2] = buffer_pointer;\n        if (current_character == '\\0') {\n          if (-1 < (int)buffer_pointer) {\n            input_pointer = *file_stream;\n            return_value = 10;\n            *file_stream = input_pointer + 1;\n            *input_pointer = '\\n';\n            goto LAB_00004d64;\n          }\n          buffer_status = __swbuf_r(output_file_handle,10,file_stream);\n          if (buffer_status != -1) {\n            return_value = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)buffer_pointer < 0) && (((int)buffer_pointer < (int)file_stream[6] || (current_character == '\\n')))) break;\n        buffer_pointer = *file_stream;\n        *file_stream = buffer_pointer + 1;\n        *buffer_pointer = current_character;\n      }\n      buffer_status = __swbuf_r(output_file_handle,current_character,file_stream);\n    } while (buffer_status != -1);\n  }\nLAB_00004d60:\n  return_value = 0xffffffff;\nLAB_00004d64:\n  if ((-1 < (int)file_stream[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(file_stream + 3) << 0x16))) {\n    __retarget_lock_release_recursive(file_stream[0x16]);\n  }\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_00004cdc": "write_to_output_file_00004cdc",
                "param_1": "output_file_handle",
                "param_2": "input_character",
                "cVar1": "current_character",
                "iVar2": "buffer_status",
                "pcVar3": "buffer_pointer",
                "ppcVar4": "file_stream",
                "uVar5": "return_value",
                "pcVar6": "input_pointer"
            },
            "calling": [
                "puts"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004db8": {
            "entrypoint": "0x00004db8",
            "current_name": "print_string_00004db8",
            "code": "\nint print_string_00004db8(char *string_to_print)\n\n{\n  int print_result;\n  \n  print_result = _puts_r(_impure_ptr,string_to_print);\n  return print_result;\n}\n\n",
            "renaming": {
                "FUN_00004db8": "print_string_00004db8",
                "__s": "string_to_print",
                "iVar1": "print_result"
            },
            "calling": [
                "_rtc_usage",
                "_rtc_gettime",
                "read",
                "hard_fault_handler",
                "handle_input_line",
                "_alarm_handler",
                "phydat_dump",
                "_rtc_setalarm",
                "main",
                "_rtc_getalarm",
                "probe_all",
                "_rtc_settime",
                "write",
                "print_help",
                "list"
            ],
            "called": [
                "_puts_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dc8": {
            "entrypoint": "0x00004dc8",
            "current_name": "read_and_update_data_00004dc8",
            "code": "\nvoid readAndUpdateData_00004dc8(_reent *reentPointer,int pointerOffset,void *dataPointer,size_t dataSize)\n\n{\n  _ssize_t readResult;\n  uint updatedValue;\n  bool isSuccessful;\n  \n  readResult = _read_r(reentPointer,(int)*(short *)(pointerOffset + 0xe),dataPointer,dataSize);\n  isSuccessful = -1 < readResult;\n  if (isSuccessful) {\n    updatedValue = *(int *)(pointerOffset + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(pointerOffset + 0xc) & 0xffffefff;\n  }\n  if (isSuccessful) {\n    *(uint *)(pointerOffset + 0x54) = updatedValue;\n  }\n  if (!isSuccessful) {\n    *(short *)(pointerOffset + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dc8": "read_and_update_data_00004dc8",
                "param_1": "reentPointer",
                "param_2": "pointerOffset",
                "param_3": "dataPointer",
                "param_4": "dataSize",
                "_Var1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dea": {
            "entrypoint": "0x00004dea",
            "current_name": "get_zero_00004dea",
            "code": "\nundefined4 getZero_00004dea(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00004dea": "get_zero_00004dea"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004dee": {
            "entrypoint": "0x00004dee",
            "current_name": "write_to_file_00004dee",
            "code": "\nvoid writeToFile_00004dee(Reent *reentPointer,int dataPointer,void *buffer,size_t size)\n\n{\n  if ((int)((uint)*(UnsignedShort *)(dataPointer + 0xc) << 0x17) < 0) {\n    lseek(reentPointer,(int)*(short *)(dataPointer + 0xe),0,2);\n  }\n  *(UnsignedShort *)(dataPointer + 0xc) = *(UnsignedShort *)(dataPointer + 0xc) & 0xefff;\n  write(reentPointer,(int)*(short *)(dataPointer + 0xe),buffer,size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004dee": "write_to_file_00004dee",
                "param_1": "reentPointer",
                "param_2": "dataPointer",
                "param_3": "buffer",
                "param_4": "size",
                "ushort": "UnsignedShort",
                "_reent": "Reent",
                "_lseek_r": "lseek",
                "_write_r": "write"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e26": {
            "entrypoint": "0x00004e26",
            "current_name": "update_file_offset_00004e26",
            "code": "\nvoid updateFileOffset_00004e26(_reent *reentPointer,int dataPointer,_off_t newOffset,int whence)\n\n{\n  _off_t result;\n  ushort flags;\n  bool isError;\n  \n  result = _lseek_r(reentPointer,(int)*(short *)(dataPointer + 0xe),newOffset,whence);\n  isError = result == -1;\n  if (isError) {\n    flags = *(ushort *)(dataPointer + 0xc) & 0xefff;\n  }\n  else {\n    *(_off_t *)(dataPointer + 0x54) = result;\n    flags = *(ushort *)(dataPointer + 0xc) | 0x1000;\n  }\n  if (isError) {\n    *(ushort *)(dataPointer + 0xc) = flags;\n  }\n  if (!isError) {\n    *(ushort *)(dataPointer + 0xc) = flags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e26": "update_file_offset_00004e26",
                "param_1": "reentPointer",
                "param_2": "dataPointer",
                "param_3": "newOffset",
                "param_4": "whence",
                "_Var1": "result",
                "uVar2": "flags",
                "bVar3": "isError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e4a": {
            "entrypoint": "0x00004e4a",
            "current_name": "close_file_00004e4a",
            "code": "\nvoid closeFile_00004e4a(_reent *reentStruct,int dataOffset)\n\n{\n  _close_r(reentStruct,(int)*(short *)(dataOffset + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00004e4a": "close_file_00004e4a",
                "param_1": "reentStruct",
                "param_2": "dataOffset"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e52": {
            "entrypoint": "0x00004e52",
            "current_name": "compare_strings_00004e52",
            "code": "\nint compareStrings_00004e52(char *string_1,char *string_2)\n\n{\n  byte current_byte;\n  uint string1_byte;\n  bool equal_bytes;\n  \n  do {\n    string1_byte = (uint)(byte)*string_1;\n    current_byte = *string_2;\n    equal_bytes = string1_byte == 1;\n    if (string1_byte != 0) {\n      equal_bytes = string1_byte == current_byte;\n    }\n    string_1 = (char *)((byte *)string_1 + 1);\n    string_2 = (char *)((byte *)string_2 + 1);\n  } while (equal_bytes);\n  return string1_byte - current_byte;\n}\n\n",
            "renaming": {
                "FUN_00004e52": "compare_strings_00004e52",
                "__s1": "string_1",
                "__s2": "string_2",
                "bVar1": "current_byte",
                "uVar2": "string1_byte",
                "bVar3": "equal_bytes"
            },
            "calling": [
                "_saul",
                "read",
                "handle_input_line",
                "strcmp",
                "find_handler",
                "_tzset_unlocked_r"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e66": {
            "entrypoint": "0x00004e66",
            "current_name": "compare_strings_00004e66",
            "code": "\nint compareStrings_00004e66(char *string1,char *string2,size_t length)\n\n{\n  byte *bytePtr1;\n  int result;\n  byte *bytePtr2;\n  uint byteValue;\n  \n  if (length == 0) {\n    result = 0;\n  }\n  else {\n    bytePtr2 = (byte *)(string2 + -1);\n    bytePtr1 = (byte *)string1;\n    do {\n      byteValue = (uint)*bytePtr1;\n      bytePtr2 = bytePtr2 + 1;\n      if ((byteValue != *bytePtr2) || (bytePtr1 + 1 == (byte *)(string1 + length))) break;\n      bytePtr1 = bytePtr1 + 1;\n    } while (byteValue != 0);\n    result = byteValue - *bytePtr2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "__s1": "string1",
                "__s2": "string2",
                "__n": "length",
                "pbVar1": "bytePtr1",
                "iVar2": "result",
                "pbVar3": "bytePtr2",
                "uVar4": "byteValue"
            },
            "calling": [
                "_findenv_r",
                "_rtc_handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004e8c": {
            "entrypoint": "0x00004e8c",
            "current_name": "parse_integer_00004e8c",
            "code": "\nuint parseInteger_00004e8c(undefined4 *result,byte *inputStr,byte **remainingStr,uint base)\n\n{\n  uint result;\n  uint ch;\n  uint isHex;\n  uint digitValue;\n  int status;\n  uint maxInteger;\n  uint divisionResult;\n  byte *currentChar;\n  byte *nextChar;\n  \n  nextChar = inputStr;\n  do {\n    currentChar = nextChar;\n    nextChar = currentChar + 1;\n    ch = (uint)*currentChar;\n    isHex = (byte)(&DAT_00007a99)[ch] & 8;\n  } while (((&DAT_00007a99)[ch] & 8) != 0);\n  if (ch == 0x2d) {\n    ch = (uint)*nextChar;\n    isHex = 1;\n    nextChar = currentChar + 2;\n  }\n  else if (ch == 0x2b) {\n    ch = (uint)*nextChar;\n    nextChar = currentChar + 2;\n  }\n  if (base == 0) {\n    if (ch != 0x30) {\n      base = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((base != 0x10) || (ch != 0x30)) goto LAB_00004ed6;\n  if ((*nextChar & 0xdf) == 0x58) {\n    ch = (uint)nextChar[1];\n    base = 0x10;\n    nextChar = nextChar + 2;\n  }\n  else {\n    ch = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00004ed6:\n  maxInteger = isHex + 0x7fffffff;\n  status = 0;\n  divisionResult = maxInteger / base;\n  result = 0;\n  do {\n    digitValue = ch - 0x30;\n    if (9 < digitValue) {\n      if (ch - 0x41 < 0x1a) {\n        digitValue = ch - 0x37;\n      }\n      else {\n        if (0x19 < ch - 0x61) break;\n        digitValue = ch - 0x57;\n      }\n    }\n    if ((int)base <= (int)digitValue) break;\n    if (status != -1) {\n      if ((divisionResult < result) || ((divisionResult == result && ((int)(maxInteger - base * divisionResult) < (int)digitValue)))) {\n        status = -1;\n      }\n      else {\n        result = result * base + digitValue;\n        status = 1;\n      }\n    }\n    ch = (uint)*nextChar;\n    nextChar = nextChar + 1;\n  } while( true );\n  if (status == -1) {\n    *result = 0x22;\n    result = maxInteger;\n    if (remainingStr == (byte **)0x0) {\n      return maxInteger;\n    }\n  }\n  else {\n    if (isHex != 0) {\n      result = -result;\n    }\n    if (remainingStr == (byte **)0x0) {\n      return result;\n    }\n    if (status == 0) goto LAB_00004f64;\n  }\n  inputStr = nextChar + -1;\nLAB_00004f64:\n  *remainingStr = inputStr;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004e8c": "parse_integer_00004e8c",
                "param_1": "result",
                "param_2": "inputStr",
                "param_3": "remainingStr",
                "param_4": "base",
                "uVar1": "result",
                "uVar2": "ch",
                "uVar3": "isHex",
                "uVar4": "digitValue",
                "iVar5": "status",
                "uVar6": "maxInteger",
                "uVar7": "divisionResult",
                "pbVar8": "currentChar",
                "pbVar9": "nextChar"
            },
            "calling": [
                "strtol",
                "_strtol_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f80": {
            "entrypoint": "0x00004f80",
            "current_name": "FUN_00004f80",
            "code": "\nuint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 = param_2;\n  do {\n    pbVar8 = pbVar9;\n    pbVar9 = pbVar8 + 1;\n    uVar2 = (uint)*pbVar8;\n    uVar3 = (byte)(&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar9;\n    uVar3 = 1;\n    pbVar9 = pbVar8 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar8 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar9[1];\n    param_4 = 0x10;\n    pbVar9 = pbVar9 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 = uVar3 + 0x7fffffff;\n  iVar5 = 0;\n  uVar7 = uVar6 / param_4;\n  uVar1 = 0;\n  do {\n    uVar4 = uVar2 - 0x30;\n    if (9 < uVar4) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar4 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar4 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar4) break;\n    if (iVar5 != -1) {\n      if ((uVar7 < uVar1) || ((uVar7 == uVar1 && ((int)(uVar6 - param_4 * uVar7) < (int)uVar4)))) {\n        iVar5 = -1;\n      }\n      else {\n        uVar1 = uVar1 * param_4 + uVar4;\n        iVar5 = 1;\n      }\n    }\n    uVar2 = (uint)*pbVar9;\n    pbVar9 = pbVar9 + 1;\n  } while( true );\n  if (iVar5 == -1) {\n    *param_1 = 0x22;\n    uVar1 = uVar6;\n    if (param_3 == (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 == 0) goto LAB_00004f64;\n  }\n  param_2 = pbVar9 + -1;\nLAB_00004f64:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f84": {
            "entrypoint": "0x00004f84",
            "current_name": "convert_string_to_long_00004f84",
            "code": "\nlong convertStringToLong_00004f84(char *inputString,char **endPointer,int base)\n\n{\n  long convertedLong;\n  \n  convertedLong = _strtol_l_isra_0(_impure_ptr,inputString,endPointer,base);\n  return convertedLong;\n}\n\n",
            "renaming": {
                "FUN_00004f84": "convert_string_to_long_00004f84",
                "__nptr": "inputString",
                "__endptr": "endPointer",
                "__base": "base",
                "lVar1": "convertedLong"
            },
            "calling": [
                "_parse_time",
                "atoi"
            ],
            "called": [
                "_strtol_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00004f98": {
            "entrypoint": "0x00004f98",
            "current_name": "calculate_day_of_week_00004f98",
            "code": "\nundefined4 calculateDayOfWeek_00004f98(uint year)\n\n{\n  uint *timezoneInfo;\n  undefined4 result;\n  uint totalDays;\n  int days;\n  uint *dateInfo;\n  int leapYears;\n  uint isLeapYear;\n  int month;\n  int firstDayOfMonth;\n  uint isDivisibleBy400;\n  \n  timezoneInfo = (uint *)__gettzinfo();\n  if ((int)year < 0x7b2) {\n    result = 0;\n  }\n  else {\n    leapYears = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) +\n            (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    timezoneInfo[1] = year;\n    isDivisibleBy400 = (uint)(year % 400 == 0);\n    dateInfo = timezoneInfo;\n    do {\n      totalDays = dateInfo[5];\n      if (*(char *)(dateInfo + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)totalDays < 0x3c) {\n            days = 0;\n          }\n          else {\n            days = 1;\n          }\n        }\n        else {\n          days = 0;\n        }\n        days = days + leapYears + totalDays + -1;\n      }\n      else if (*(char *)(dateInfo + 2) == 'D') {\n        days = leapYears + totalDays;\n      }\n      else {\n        isLeapYear = isDivisibleBy400;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          isLeapYear = 1;\n        }\n        month = 0;\n        days = leapYears;\n        while( true ) {\n          month = month + 1;\n          if ((int)dateInfo[3] <= month) break;\n          days = days + *(int *)(&UNK_00007b98 + month * 4 + isLeapYear * 0x30);\n        }\n        firstDayOfMonth = totalDays - (days + 4U) % 7;\n        if (firstDayOfMonth < 0) {\n          firstDayOfMonth = firstDayOfMonth + 7;\n        }\n        for (firstDayOfMonth = (dateInfo[4] - 1) * 7 + firstDayOfMonth;\n            *(int *)(&UNK_00007b98 + month * 4 + isLeapYear * 0x30) <= firstDayOfMonth; firstDayOfMonth = firstDayOfMonth + -7) {\n        }\n        days = days + firstDayOfMonth;\n      }\n      totalDays = dateInfo[10] + days * 0x15180 + dateInfo[6];\n      dateInfo[8] = totalDays;\n      dateInfo[9] = (int)totalDays >> 0x1f;\n      dateInfo = dateInfo + 10;\n    } while (timezoneInfo + 0x14 != dateInfo);\n    totalDays = timezoneInfo[9];\n    isDivisibleBy400 = timezoneInfo[0x13];\n    *timezoneInfo = (uint)((int)((totalDays - isDivisibleBy400) - (uint)(timezoneInfo[8] < timezoneInfo[0x12])) < 0 !=\n                    (SBORROW4(totalDays,isDivisibleBy400) !=\n                    SBORROW4(totalDays - isDivisibleBy400,(uint)(timezoneInfo[8] < timezoneInfo[0x12]))));\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00004f98": "calculate_day_of_week_00004f98",
                "param_1": "year",
                "puVar1": "timezoneInfo",
                "uVar2": "result",
                "uVar3": "totalDays",
                "iVar4": "days",
                "puVar5": "dateInfo",
                "iVar6": "leapYears",
                "uVar7": "isLeapYear",
                "iVar8": "month",
                "iVar9": "firstDayOfMonth",
                "uVar10": "isDivisibleBy400"
            },
            "calling": [
                "mktime",
                "_tzset_unlocked_r"
            ],
            "called": [
                "__gettzinfo"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050e8": {
            "entrypoint": "0x000050e8",
            "current_name": "acquire_tz_mutex_000050e8",
            "code": "\nvoid acquire_tz_mutex_000050e8(void)\n\n{\n  __retarget_lock_acquire(&tz_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050e8": "acquire_tz_mutex_000050e8",
                "__lock___tz_mutex": "tz_mutex"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_acquire"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000050f4": {
            "entrypoint": "0x000050f4",
            "current_name": "release_retarget_lock_000050f4",
            "code": "\nvoid releaseRetargetLock_000050f4(void)\n\n{\n  __retarget_lock_release(&retargetLockMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000050f4": "release_retarget_lock_000050f4",
                "__lock___tz_mutex": "retargetLockMutex"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "__retarget_lock_release"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005100": {
            "entrypoint": "0x00005100",
            "current_name": "initialize_timezone_00005100",
            "code": "\nvoid initializeTimezone_00005100(void)\n\n{\n  setTimezone(timezonePointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005100": "initialize_timezone_00005100",
                "_tzset_unlocked_r": "setTimezone",
                "_impure_ptr": "timezonePointer"
            },
            "calling": [
                "mktime"
            ],
            "called": [
                "_tzset_unlocked_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000510c": {
            "entrypoint": "0x0000510c",
            "current_name": "set_time_zone_info_0000510c",
            "code": "\nvoid setTimeZoneInfo_0000510c(undefined4 environment)\n\n{\n  int tzInfoPtr;\n  char *envValue;\n  size_t envLength;\n  int comparisonResult;\n  int scanResult;\n  ulong timeValue;\n  undefined timeType;\n  char *timeString;\n  bool isDst;\n  ushort *addr1;\n  int *addr2;\n  ushort *addr3;\n  int *addr4;\n  ushort hours1;\n  ushort minutes1;\n  ushort seconds1;\n  ushort hours2;\n  ushort minutes2;\n  ushort seconds2;\n  int index;\n  char *temp [2];\n  \n  tzInfoPtr = _getTimeZoneInfo();\n  envValue = (char *)getEnvironmentVariable(environment,&DAT_00007a5c);\n  if (envValue == (char *)0x0) {\n    timezoneNames = &DAT_00007a5f;\n    DAT_1fff02e8 = &DAT_00007a5f;\n    isDaylight = envValue;\n    currentTimeZone = envValue;\n    free(previousEnv);\n    previousEnv = (char *)0x0;\n  }\n  else if ((previousEnv == (char *)0x0) || (comparisonResult = strcmp(envValue,previousEnv), comparisonResult != 0)) {\n    free(previousEnv);\n    envLength = strlen(envValue);\n    previousEnv = (char *)allocateMemory(environment,envLength + 1);\n    if (previousEnv != (char *)0x0) {\n      strcpy(previousEnv,envValue);\n    }\n    if (*envValue == ':') {\n      envValue = envValue + 1;\n    }\n    comparisonResult = readFormattedInput(envValue,\"%10[^0-9,+-]%n\",&standardTimeZoneName,&index);\n    if (0 < comparisonResult) {\n      timeString = envValue + index;\n      if (envValue[index] == '-') {\n        timeString = timeString + 1;\n        comparisonResult = -1;\n      }\n      else {\n        if (envValue[index] == '+') {\n          timeString = timeString + 1;\n        }\n        comparisonResult = 1;\n      }\n      minutes1 = 0;\n      seconds1 = 0;\n      addr1 = &minutes1;\n      addr2 = &index;\n      addr3 = &seconds1;\n      addr4 = &index;\n      scanResult = readFormattedInput(timeString,\"%hu%n:%hu%n:%hu%n\",&hours1,&index,&minutes1,&index,&seconds1,\n                      &index);\n      if (0 < scanResult) {\n        *(uint *)(tzInfoPtr + 0x28) =\n             ((uint)hours1 * 0xe10 + (uint)minutes1 * 0x3c + (uint)seconds1) * comparisonResult;\n        timezoneNames = &standardTimeZoneName;\n        timeString = timeString + index;\n        comparisonResult = readFormattedInput(timeString,\"%10[^0-9,+-]%n\",&dstTimeZoneName,&index,addr1,addr2,addr3,\n                        addr4);\n        if (comparisonResult < 1) {\n          DAT_1fff02e8 = timezoneNames;\n          currentTimeZone = *(char **)(tzInfoPtr + 0x28);\n          isDaylight = (char *)0x0;\n        }\n        else {\n          DAT_1fff02e8 = &dstTimeZoneName;\n          envValue = timeString + index;\n          if (timeString[index] == '-') {\n            envValue = envValue + 1;\n            comparisonResult = -1;\n          }\n          else {\n            if (timeString[index] == '+') {\n              envValue = envValue + 1;\n            }\n            comparisonResult = 1;\n          }\n          hours1 = 0;\n          minutes1 = 0;\n          seconds1 = 0;\n          index = 0;\n          scanResult = readFormattedInput(envValue,\"%hu%n:%hu%n:%hu%n\",&hours1,&index,&minutes1,&index,\n                          &seconds1,&index);\n          if (scanResult < 1) {\n            comparisonResult = *(int *)(tzInfoPtr + 0x28) + -0xe10;\n          }\n          else {\n            comparisonResult = ((uint)hours1 * 0xe10 + (uint)minutes1 * 0x3c + (uint)seconds1) * comparisonResult;\n          }\n          *(int *)(tzInfoPtr + 0x50) = comparisonResult;\n          envValue = envValue + index;\n          isDst = false;\n          comparisonResult = tzInfoPtr;\n          while( true ) {\n            if (*envValue == ',') {\n              envValue = envValue + 1;\n            }\n            if (*envValue == 'M') {\n              scanResult = readFormattedInput(envValue,\"M%hu%n.%hu%n.%hu%n\",&hours2,&index,&minutes2,&index,\n                              &seconds2,&index);\n              if (scanResult != 3) {\n                return;\n              }\n              if (0xb < hours2 - 1) {\n                return;\n              }\n              if (4 < minutes2 - 1) {\n                return;\n              }\n              if (6 < seconds2) {\n                return;\n              }\n              *(uint *)(comparisonResult + 0xc) = (uint)hours2;\n              *(uint *)(comparisonResult + 0x10) = (uint)minutes2;\n              *(undefined *)(comparisonResult + 8) = 0x4d;\n              *(uint *)(comparisonResult + 0x14) = (uint)seconds2;\n              timeString = envValue + index;\n            }\n            else {\n              if (*envValue == 'J') {\n                envValue = envValue + 1;\n                timeType = 0x4a;\n              }\n              else {\n                timeType = 0x44;\n              }\n              timeValue = strtoul(envValue,temp,10);\n              seconds2 = (ushort)timeValue;\n              timeString = temp[0];\n              if (temp[0] == envValue) {\n                if (isDst) {\n                  *(undefined *)(tzInfoPtr + 0x30) = 0x4d;\n                  *(undefined4 *)(tzInfoPtr + 0x34) = 0xb;\n                  *(undefined4 *)(tzInfoPtr + 0x38) = 1;\n                  *(undefined4 *)(tzInfoPtr + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(tzInfoPtr + 8) = 0x4d;\n                  *(undefined4 *)(tzInfoPtr + 0xc) = 3;\n                  *(undefined4 *)(tzInfoPtr + 0x10) = 2;\n                  *(undefined4 *)(tzInfoPtr + 0x14) = 0;\n                }\n              }\n              else {\n                *(undefined *)(comparisonResult + 8) = timeType;\n                *(ulong *)(comparisonResult + 0x14) = timeValue & 0xffff;\n              }\n            }\n            hours1 = 2;\n            minutes1 = 0;\n            seconds1 = 0;\n            index = 0;\n            if (*timeString == '/') {\n              readFormattedInput(timeString,\"/%hu%n:%hu%n:%hu%n\",&hours1,&index,&minutes1,&index,&seconds1,\n                      &index);\n            }\n            *(uint *)(comparisonResult + 0x18) =\n                 (uint)hours1 * 0xe10 + (uint)minutes1 * 0x3c + (uint)seconds1;\n            comparisonResult = comparisonResult + 0x28;\n            envValue = timeString + index;\n            if (isDst) break;\n            isDst = true;\n          }\n          __tzcalc_limits(*(undefined4 *)(tzInfoPtr + 4));\n          currentTimeZone = *(char **)(tzInfoPtr + 0x28);\n          isDaylight = (char *)(*(int *)(tzInfoPtr + 0x50) - (int)currentTimeZone);\n          if (isDaylight != (char *)0x0) {\n            isDaylight = (char *)0x1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000510c": "set_time_zone_info_0000510c",
                "param_1": "environment",
                "iVar1": "tzInfoPtr",
                "pcVar2": "envValue",
                "sVar3": "envLength",
                "iVar4": "comparisonResult",
                "iVar5": "scanResult",
                "uVar6": "timeValue",
                "uVar7": "timeType",
                "pcVar8": "timeString",
                "bVar9": "isDst",
                "puVar10": "addr1",
                "piVar11": "addr2",
                "puVar12": "addr3",
                "piVar13": "addr4",
                "local_3c": "hours1",
                "local_3a": "minutes1",
                "local_38": "seconds1",
                "local_36": "hours2",
                "local_34": "minutes2",
                "local_32": "seconds2",
                "local_30": "index",
                "local_2c": "temp",
                "_gettzinfo": "getTimeZoneInfo",
                "_getenv_r": "getEnvironmentVariable",
                "_tzname": "timezoneNames",
                "_daylight": "isDaylight",
                "_timezone": "currentTimeZone",
                "prev_tzenv": "previousEnv",
                "_malloc_r": "allocateMemory",
                "__tzname_std": "standardTimeZoneName",
                "__tzname_dst": "dstTimeZoneName",
                "siscanf": "readFormattedInput"
            },
            "calling": [
                "_tzset_unlocked"
            ],
            "called": [
                "_malloc_r",
                "_getenv_r",
                "__gettzinfo",
                "siscanf",
                "free",
                "strlen",
                "strtoul",
                "strcmp",
                "__tzcalc_limits",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005404": {
            "entrypoint": "0x00005404",
            "current_name": "process_input_00005404",
            "code": "\nuint processInput_00005404(int inputBuffer,uint inputLength,int *streamPointer,undefined4 streamMode)\n\n{\n  int tempVar1;\n  uint tempVar2;\n  undefined *tempVar3;\n  \n  if ((inputBuffer != 0) && (*(int *)(inputBuffer + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamPointer == &__sf_fake_stdin) {\n    streamPointer = *(int **)(inputBuffer + 4);\n  }\n  else if (streamPointer == (int *)&__sf_fake_stdout) {\n    streamPointer = *(int **)(inputBuffer + 8);\n  }\n  else if (streamPointer == (int *)&__sf_fake_stderr) {\n    streamPointer = *(int **)(inputBuffer + 0xc);\n  }\n  streamPointer[2] = streamPointer[6];\n  tempVar2 = (uint)*(ushort *)(streamPointer + 3);\n  tempVar1 = tempVar2 << 0x1c;\n  if (((tempVar1 < 0) && (tempVar2 = streamPointer[4], tempVar2 != 0)) ||\n     (tempVar1 = __swsetup_r(inputBuffer,streamPointer,tempVar1,tempVar2,streamMode), tempVar1 == 0)) {\n    tempVar1 = *streamPointer - streamPointer[4];\n    inputLength = inputLength & 0xff;\n    if ((tempVar1 < streamPointer[5]) || (tempVar1 = _fflush_r(inputBuffer,streamPointer), tempVar1 == 0)) {\n      streamPointer[2] = streamPointer[2] + -1;\n      tempVar3 = (undefined *)*streamPointer;\n      *streamPointer = (int)(tempVar3 + 1);\n      *tempVar3 = (char)inputLength;\n      if (streamPointer[5] != tempVar1 + 1) {\n        if (-1 < (int)((uint)*(ushort *)(streamPointer + 3) << 0x1f)) {\n          return inputLength;\n        }\n        if (inputLength != 10) {\n          return inputLength;\n        }\n      }\n      tempVar1 = _fflush_r(inputBuffer,streamPointer);\n      if (tempVar1 == 0) {\n        return inputLength;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00005404": "process_input_00005404",
                "param_1": "inputBuffer",
                "param_2": "inputLength",
                "param_3": "streamPointer",
                "param_4": "streamMode",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "puVar3": "tempVar3"
            },
            "calling": [
                "__sfputc_r",
                "_puts_r",
                "_putc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000054a8": {
            "entrypoint": "0x000054a8",
            "current_name": "process_stream_000054a8",
            "code": "\nuint processStream_000054a8(undefined4 *outputStream,undefined4 *inputStream)\n\n{\n  ushort temp1;\n  int impurePtr;\n  ushort temp2;\n  uint temp3;\n  uint temp4;\n  \n  impurePtr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (inputStream == &__sf_fake_stdin) {\n    inputStream = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (inputStream == (undefined4 *)&__sf_fake_stdout) {\n    inputStream = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (inputStream == (undefined4 *)&__sf_fake_stderr) {\n    inputStream = *(undefined4 **)(impurePtr + 0xc);\n  }\n  temp3 = (uint)*(ushort *)(inputStream + 3);\n  temp2 = *(ushort *)(inputStream + 3);\n  if (-1 < (int)(temp3 << 0x1c)) {\n    if (-1 < (int)(temp3 << 0x1b)) {\n      *outputStream = 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(temp3 << 0x1d) < 0) {\n      if ((undefined4 *)inputStream[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)inputStream[0xd] != inputStream + 0x11) {\n          _free_r(outputStream);\n        }\n        inputStream[0xd] = 0;\n      }\n      *(ushort *)(inputStream + 3) = *(ushort *)(inputStream + 3) & 0xffdb;\n      inputStream[1] = 0;\n      *inputStream = inputStream[4];\n    }\n    *(ushort *)(inputStream + 3) = *(ushort *)(inputStream + 3) | 8;\n  }\n  if ((inputStream[4] == 0) && ((*(ushort *)(inputStream + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(outputStream,inputStream);\n  }\n  temp1 = *(ushort *)(inputStream + 3);\n  temp3 = (uint)temp1;\n  temp2 = *(ushort *)(inputStream + 3);\n  temp4 = temp3 & 1;\n  if ((temp1 & 1) == 0) {\n    if (-1 < (int)(temp3 << 0x1e)) {\n      temp4 = inputStream[5];\n    }\n    inputStream[2] = temp4;\n  }\n  else {\n    inputStream[2] = 0;\n    inputStream[6] = -inputStream[5];\n  }\n  if (inputStream[4] != 0) {\n    return 0;\n  }\n  if ((temp1 & 0x80) == 0) {\n    return temp3 & 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(inputStream + 3) = temp2 | 0x40;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000054a8": "process_stream_000054a8",
                "param_1": "outputStream",
                "param_2": "inputStream",
                "uVar1": "temp1",
                "iVar2": "impurePtr",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "uVar5": "temp4"
            },
            "calling": [
                "__swbuf_r",
                "_puts_r",
                "_vfprintf_r"
            ],
            "called": [
                "__smakebuf_r",
                "__sinit",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005584": {
            "entrypoint": "0x00005584",
            "current_name": "divide_00005584",
            "code": "\ndiv_t divide_00005584(int numerator,int denominator)\n\n{\n  uint remainder;\n  int temp;\n  uint quotient;\n  div_t result;\n  \n  quotient = (uint)denominator / remainder;\n  temp = denominator - remainder * quotient;\n  if (denominator < 0) {\n    if (0 < temp) {\n      quotient = quotient - 1;\n      temp = temp + remainder;\n    }\n  }\n  else if (temp < 0) {\n    quotient = quotient + 1;\n    temp = temp - remainder;\n  }\n  *(uint *)numerator = quotient;\n  *(int *)(numerator + 4) = temp;\n  result.rem = denominator;\n  result.quot = numerator;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005584": "divide_00005584",
                "__numer": "numerator",
                "__denom": "denominator",
                "in_r2": "remainder",
                "iVar1": "temp",
                "uVar2": "quotient",
                "dVar3": "result"
            },
            "calling": [
                "validate_structure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000055ac": {
            "entrypoint": "0x000055ac",
            "current_name": "read_from_stream_000055ac",
            "code": "\nuint readFromStream_000055ac(int stream,byte **streamPtr)\n\n{\n  uint result;\n  byte *currentByte;\n  \n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamPtr == (byte **)&__sf_fake_stdin) {\n    streamPtr = *(byte ***)(stream + 4);\n  }\n  else if (streamPtr == (byte **)&__sf_fake_stdout) {\n    streamPtr = *(byte ***)(stream + 8);\n  }\n  else if (streamPtr == (byte **)&__sf_fake_stderr) {\n    streamPtr = *(byte ***)(stream + 0xc);\n  }\n  if ((-1 < (int)streamPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(streamPtr + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(streamPtr[0x16]);\n  }\n  currentByte = streamPtr[1];\n  streamPtr[1] = currentByte + -1;\n  if ((int)(currentByte + -1) < 0) {\n    result = __srget_r(stream,streamPtr);\n  }\n  else {\n    currentByte = *streamPtr;\n    *streamPtr = currentByte + 1;\n    result = (uint)*currentByte;\n  }\n  if ((-1 < (int)streamPtr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(streamPtr + 3) << 0x16))) {\n    __retarget_lock_release_recursive(streamPtr[0x16]);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000055ac": "read_from_stream_000055ac",
                "param_1": "stream",
                "param_2": "streamPtr",
                "uVar1": "result",
                "pbVar2": "currentByte"
            },
            "calling": [
                "getchar"
            ],
            "called": [
                "__sinit",
                "__srget_r",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000562c": {
            "entrypoint": "0x0000562c",
            "current_name": "find_environment_variable_0000562c",
            "code": "\nchar * findEnvironmentVariable_0000562c(undefined4 lock,char *variableName,int *index)\n\n{\n  char currentChar;\n  char **environIterator;\n  int comparisonResult;\n  char *currentEnvVar;\n  char **iterativeEnvironIterator;\n  size_t nameLength;\n  \n  __env_lock();\n  currentEnvVar = variableName;\n  if (environ != (char **)0x0) {\n    do {\n      currentChar = *currentEnvVar;\n      if (currentChar == '\\0') {\n        nameLength = (int)currentEnvVar - (int)variableName;\n        environIterator = environ;\n        while( true ) {\n          iterativeEnvironIterator = environIterator;\n          if (*iterativeEnvironIterator == (char *)0x0) break;\n          comparisonResult = strncmp(*iterativeEnvironIterator,variableName,nameLength);\n          environIterator = iterativeEnvironIterator + 1;\n          if ((comparisonResult == 0) && (currentEnvVar = *iterativeEnvironIterator, currentEnvVar[nameLength] == '=')) {\n            *index = (int)iterativeEnvironIterator - (int)environ >> 2;\n            __env_unlock(lock);\n            return currentEnvVar + nameLength + 1;\n          }\n        }\n        break;\n      }\n      currentEnvVar = currentEnvVar + 1;\n    } while (currentChar != '=');\n  }\n  __env_unlock(lock);\n  return (char *)0x0;\n}\n\n",
            "renaming": {
                "FUN_0000562c": "find_environment_variable_0000562c",
                "param_1": "lock",
                "param_2": "variableName",
                "param_3": "index",
                "cVar1": "currentChar",
                "ppcVar2": "environIterator",
                "iVar3": "comparisonResult",
                "pcVar4": "currentEnvVar",
                "ppcVar5": "iterativeEnvironIterator",
                "__n": "nameLength"
            },
            "calling": [
                "_getenv_r"
            ],
            "called": [
                "__env_lock",
                "__env_unlock",
                "strncmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056a0": {
            "entrypoint": "0x000056a0",
            "current_name": "find_environment_variables_000056a0",
            "code": "\nvoid find_environment_variables_000056a0(undefined4 arg1,undefined4 envp,undefined4 start,undefined4 toc)\n\n{\n  undefined4 envp_copy;\n  undefined4 start_copy;\n  \n  envp_copy = envp;\n  start_copy = start;\n  _findenv_r(arg1,envp,&envp_copy,toc,arg1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000056a0": "find_environment_variables_000056a0",
                "param_1": "arg1",
                "param_2": "envp",
                "param_3": "start",
                "param_4": "toc",
                "uStack_c": "envp_copy",
                "uStack_8": "start_copy"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_findenv_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b0": {
            "entrypoint": "0x000056b0",
            "current_name": "get_time_zone_info_000056b0",
            "code": "\nundefined1 * getTimeZoneInfo_000056b0(void)\n\n{\n  return timezoneInfo;\n}\n\n",
            "renaming": {
                "FUN_000056b0": "get_time_zone_info_000056b0",
                "&tzinfo": "timezoneInfo"
            },
            "calling": [
                "mktime",
                "__tzcalc_limits",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000056b8": {
            "entrypoint": "0x000056b8",
            "current_name": "check_file_permissions_000056b8",
            "code": "\nundefined4 checkFilePermissions_000056b8(_reent *reentPointer,int fileDescriptor,undefined4 *permissionResult,uint *isExecutable)\n\n{\n  int fileStatus;\n  undefined4 permissionFlag;\n  stat fileStatistics;\n  \n  if ((*(short *)(fileDescriptor + 0xe) < 0) ||\n     (fileStatus = _fstat_r(reentPointer,(int)*(short *)(fileDescriptor + 0xe),&fileStatistics), fileStatus < 0)) {\n    *isExecutable = 0;\n    if ((int)((uint)*(ushort *)(fileDescriptor + 0xc) << 0x18) < 0) {\n      permissionFlag = 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *isExecutable = (uint)((fileStatistics.st_mode & 0xf000) == 0x2000);\n  }\n  permissionFlag = 0x400;\nLAB_000056f8:\n  *permissionResult = permissionFlag;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000056b8": "check_file_permissions_000056b8",
                "param_1": "reentPointer",
                "param_2": "fileDescriptor",
                "param_3": "permissionResult",
                "param_4": "isExecutable",
                "iVar1": "fileStatus",
                "uVar2": "permissionFlag",
                "sStack_68": "fileStatistics"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005700": {
            "entrypoint": "0x00005700",
            "current_name": "initialize_file_handle_00005700",
            "code": "\nvoid initializeFileHandle_00005700(_reent *reentPointer,int *fileHandle)\n\n{\n  ushort bufferType;\n  int allocatedMemory;\n  _reent *reentLocal;\n  int *fileHandleLocal;\n  \n  if (-1 < (int)((uint)*(ushort *)(fileHandle + 3) << 0x1e)) {\n    reentLocal = reentPointer;\n    fileHandleLocal = fileHandle;\n    bufferType = __swhatbuf_r(reentPointer,fileHandle,&reentLocal,&fileHandleLocal);\n    allocatedMemory = _malloc_r(reentPointer,reentLocal);\n    if (allocatedMemory != 0) {\n      reentPointer->__cleanup = _cleanup_r + 1;\n      *fileHandle = allocatedMemory;\n      *(ushort *)(fileHandle + 3) = *(ushort *)(fileHandle + 3) | 0x80;\n      fileHandle[5] = (int)reentLocal;\n      fileHandle[4] = allocatedMemory;\n      if ((fileHandleLocal != (int *)0x0) &&\n         (allocatedMemory = _isatty_r(reentPointer,(int)*(short *)((int)fileHandle + 0xe)), allocatedMemory != 0)) {\n        *(ushort *)(fileHandle + 3) = *(ushort *)(fileHandle + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(fileHandle + 3) = bufferType | *(ushort *)(fileHandle + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(fileHandle + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(fileHandle + 3) = *(ushort *)(fileHandle + 3) & 0xfffc | 2;\n  }\n  *fileHandle = (int)fileHandle + 0x47;\n  fileHandle[4] = (int)fileHandle + 0x47;\n  fileHandle[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005700": "initialize_file_handle_00005700",
                "param_1": "reentPointer",
                "param_2": "fileHandle",
                "uVar1": "bufferType",
                "iVar2": "allocatedMemory",
                "local_18": "reentLocal",
                "local_14": "fileHandleLocal"
            },
            "calling": [
                "__srefill_r",
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005780": {
            "entrypoint": "0x00005780",
            "current_name": "free_memory_00005780",
            "code": "\nvoid freeMemory_00005780(void *memoryPtr)\n\n{\n  free(impurePtr,memoryPtr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005780": "free_memory_00005780",
                "__ptr": "memoryPtr",
                "_free_r": "free",
                "_impure_ptr": "impurePtr"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005790": {
            "entrypoint": "0x00005790",
            "current_name": "acquire_recursive_lock_00005790",
            "code": "\nvoid acquire_recursive_lock_00005790(void)\n\n{\n  acquire_recursive_lock_00005790(&__malloc_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005790": "acquire_recursive_lock_00005790",
                "__retarget_lock_acquire_recursive": "acquire_recursive_lock",
                "__lock___malloc_recursive_mutex": "__malloc_recursive_mutex"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000579c": {
            "entrypoint": "0x0000579c",
            "current_name": "release_malloc_recursive_mutex_0000579c",
            "code": "\nvoid releaseMallocRecursiveMutex_0000579c(void)\n\n{\n  __retarget_lock_release_recursive(&__lock___malloc_recursive_mutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0000579c": "release_malloc_recursive_mutex_0000579c"
            },
            "calling": [
                "_malloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057a8": {
            "entrypoint": "0x000057a8",
            "current_name": "write_character_000057a8",
            "code": "\nint writeCharacter_000057a8(undefined4 stream,int character,undefined4 *buffer)\n\n{\n  int currentIndex;\n  undefined *currentPointer;\n  \n  currentIndex = buffer[2] + -1;\n  buffer[2] = currentIndex;\n  if ((currentIndex < 0) && ((currentIndex < (int)buffer[6] || (character == 10)))) {\n    currentIndex = __swbuf_r();\n    return currentIndex;\n  }\n  currentPointer = (undefined *)*buffer;\n  *buffer = currentPointer + 1;\n  *currentPointer = (char)character;\n  return character;\n}\n\n",
            "renaming": {
                "FUN_000057a8": "write_character_000057a8",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "buffer",
                "iVar1": "currentIndex",
                "puVar2": "currentPointer"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057d2": {
            "entrypoint": "0x000057d2",
            "current_name": "write_to_stream_000057d2",
            "code": "\nint writeToStream_000057d2(undefined4 stream,undefined4 mode,undefined *data,int length)\n\n{\n  int result;\n  undefined *endPtr;\n  int count;\n  \n  endPtr = data + length;\n  count = length;\n  do {\n    if (data == endPtr) {\n      return 0;\n    }\n    result = __sfputc_r(stream,*data,mode,length,count);\n    length = result + 1;\n    data = data + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000057d2": "write_to_stream_000057d2",
                "param_1": "stream",
                "param_2": "mode",
                "param_3": "data",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "endPtr",
                "iVar3": "count"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000057f8": {
            "entrypoint": "0x000057f8",
            "current_name": "process_printf_format_000057f8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000059f0) */\n\nint processPrintfFormat_000057f8(int streamID,undefined4 *stream,byte *formatString,int *argList)\n\n{\n  bool isNumber;\n  int intValue;\n  int result;\n  void *charPtr;\n  int *intPtr;\n  byte *bytePtr1;\n  int unusedVar;\n  byte *bytePtr2;\n  int *argListIndex;\n  uint flags;\n  int precision;\n  undefined4 fieldWidth;\n  int calculatedFieldWidth;\n  int numCharsWritten;\n  byte conversionType;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined prefixFlag;\n  undefined4 zeroFlag;\n  \n  if ((streamID != 0) && (*(int *)(streamID + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(undefined4 **)(streamID + 4);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = *(undefined4 **)(streamID + 8);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = *(undefined4 **)(streamID + 0xc);\n  }\n  if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream[0x16]);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1c)) || (stream[4] == 0)) &&\n     (intValue = __swsetup_r(streamID,stream), intValue != 0)) {\n    if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16)))\n    {\n      __retarget_lock_release_recursive(stream[0x16]);\n    }\n    return -1;\n  }\n  numCharsWritten = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  bytePtr2 = formatString;\n  argListIndex = argList;\nLAB_0000588e:\n  bytePtr1 = bytePtr2;\n  if (*bytePtr1 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  bytePtr2 = bytePtr1 + 1;\n  if (*bytePtr1 == 0x25) {\nLAB_0000589a:\n    intValue = (int)bytePtr1 - (int)formatString;\n    if (intValue != 0) {\n      result = __sfputs_r(streamID,stream,formatString,intValue);\n      if (result == -1) {\nLAB_00005a06:\n        if ((-1 < (int)(stream[0x19] << 0x1f)) &&\n           (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n          __retarget_lock_release_recursive(stream[0x16]);\n        }\n        if ((int)((uint)*(ushort *)(stream + 3) << 0x19) < 0) {\n          return -1;\n        }\n        return numCharsWritten;\n      }\n      numCharsWritten = numCharsWritten + intValue;\n    }\n    if (*bytePtr1 == 0) goto LAB_00005a06;\n    precision = -1;\n    fieldWidth = 0;\n    flags = 0;\n    calculatedFieldWidth = 0;\n    prefixFlag = 0;\n    zeroFlag = 0;\n    bytePtr2 = bytePtr1 + 1;\n    while( true ) {\n      bytePtr1 = bytePtr2 + 1;\n      charPtr = memchr(\"#-0+ \",(uint)*bytePtr2,5);\n      if (charPtr == (void *)0x0) break;\n      flags = 1 << ((int)charPtr - 0x7bfcU & 0xff) | flags;\n      bytePtr2 = bytePtr1;\n    }\n    if ((int)(flags << 0x1b) < 0) {\n      prefixFlag = 0x20;\n    }\n    if ((int)(flags << 0x1c) < 0) {\n      prefixFlag = 0x2b;\n    }\n    if (*bytePtr2 == 0x2a) {\n      intPtr = argListIndex + 1;\n      calculatedFieldWidth = *argListIndex;\n      argListIndex = intPtr;\n      if (calculatedFieldWidth < 0) {\n        calculatedFieldWidth = -calculatedFieldWidth;\n        flags = flags | 2;\n      }\n    }\n    else {\n      isNumber = false;\n      intValue = calculatedFieldWidth;\n      bytePtr1 = bytePtr2;\n      while( true ) {\n        if (9 < *bytePtr1 - 0x30) break;\n        intValue = intValue * 10 + (*bytePtr1 - 0x30);\n        isNumber = true;\n        bytePtr1 = bytePtr1 + 1;\n      }\n      if (isNumber) {\n        calculatedFieldWidth = intValue;\n      }\n    }\n    if (*bytePtr1 == 0x2e) {\n      if (bytePtr1[1] == 0x2a) {\n        precision = *argListIndex;\n        if (precision < 0) {\n          precision = -1;\n        }\n        bytePtr1 = bytePtr1 + 2;\n        argListIndex = argListIndex + 1;\n      }\n      else {\n        isNumber = false;\n        precision = 0;\n        intValue = 0;\n        while( true ) {\n          bytePtr1 = bytePtr1 + 1;\n          if (9 < *bytePtr1 - 0x30) break;\n          intValue = intValue * 10 + (*bytePtr1 - 0x30);\n          isNumber = true;\n        }\n        if (isNumber) {\n          precision = intValue;\n        }\n      }\n    }\n    charPtr = memchr(&DAT_00007c02,(uint)*bytePtr1,3);\n    if (charPtr != (void *)0x0) {\n      flags = flags | 0x40 << ((int)charPtr - 0x7c02U & 0xff);\n      bytePtr1 = bytePtr1 + 1;\n    }\n    formatString = bytePtr1 + 1;\n    conversionType = *bytePtr1;\n    charPtr = memchr(\"efgEFG\",(uint)conversionType,6);\n    if (charPtr == (void *)0x0) {\n      unusedVar = _printf_i(streamID,&flags,stream,0x57d3,&argListIndex);\n      if (unusedVar == -1) goto LAB_00005a06;\n    }\n    else {\n      argListIndex = (int *)(((int)argListIndex + 7U & 0xfffffff8) + 8);\n    }\n    numCharsWritten = numCharsWritten + unusedVar;\n    bytePtr2 = formatString;\n  }\n  goto LAB_0000588e;\n}\n\n",
            "renaming": {
                "FUN_000057f8": "process_printf_format_000057f8",
                "param_1": "streamID",
                "param_2": "stream",
                "param_3": "formatString",
                "param_4": "argList",
                "bVar1": "isNumber",
                "iVar2": "intValue",
                "iVar3": "result",
                "pvVar4": "charPtr",
                "piVar5": "intPtr",
                "pbVar6": "bytePtr1",
                "unaff_r7": "unusedVar",
                "pbVar7": "bytePtr2",
                "local_8c": "argListIndex",
                "local_88": "flags",
                "local_84": "precision",
                "uStack_80": "fieldWidth",
                "local_7c": "calculatedFieldWidth",
                "local_74": "numCharsWritten",
                "local_70": "conversionType",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "prefixFlag",
                "local_30": "zeroFlag"
            },
            "calling": [
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__sfputs_r",
                "__retarget_lock_release_recursive",
                "memchr",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005a58": {
            "entrypoint": "0x00005a58",
            "current_name": "process_data_00005a58",
            "code": "\nundefined4\nprocessData_00005a58(undefined4 input,uint *data,uint *output,undefined4 param,code *callback)\n\n{\n  int index;\n  undefined4 result;\n  int status;\n  uint maxValue;\n  uint count;\n  bool condition;\n  \n  maxValue = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    maxValue = data[2];\n  }\n  *output = maxValue;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *output = maxValue + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *output = *output + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (index = 0; index < (int)(data[3] - *output); index = index + 1) {\n      status = (*callback)(input,param,(int)data + 0x19,1);\n      if (status == -1) goto LAB_00005afc;\n    }\n  }\n  maxValue = (uint)*(byte *)((int)data + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + maxValue + 0x43) = 0x30;\n    *(undefined *)((int)data + maxValue + 0x44) = *(undefined *)((int)data + 0x45);\n    maxValue = maxValue + 2;\n  }\n  index = (*callback)(input,param,(int)data + 0x43,maxValue);\n  if (index == -1) {\nLAB_00005afc:\n    result = 0xffffffff;\n  }\n  else {\n    maxValue = data[3];\n    condition = (*data & 6) == 4;\n    if (condition) {\n      maxValue = maxValue - *output;\n    }\n    if (condition) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    else {\n      maxValue = 0;\n    }\n    if ((int)data[4] < (int)data[2]) {\n      maxValue = maxValue + (data[2] - data[4]);\n    }\n    for (count = 0; maxValue != count; count = count + 1) {\n      index = (*callback)(input,param,(int)data + 0x1a,1);\n      if (index == -1) goto LAB_00005afc;\n    }\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005a58": "process_data_00005a58",
                "param_1": "input",
                "param_2": "data",
                "param_3": "output",
                "param_4": "param",
                "param_5": "callback",
                "iVar1": "index",
                "uVar2": "result",
                "iVar3": "status",
                "uVar4": "maxValue",
                "uVar5": "count",
                "bVar6": "condition"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005b34": {
            "entrypoint": "0x00005b34",
            "current_name": "print_formatted_value_00005b34",
            "code": "\ncode * printFormattedValue_00005b34(undefined4 formatSpecifier,uint *argList,undefined4 stream,code *putcFunction,uint **wideArgList\n                   )\n\n{\n  bool isGreater;\n  byte byteValue;\n  int returnValue;\n  code *formattedValue;\n  char *hexDigits;\n  void *foundNull;\n  int printfRetVal;\n  char *stringValue;\n  uint value;\n  uint *wideArgValue;\n  uint base;\n  uint **wideArgListPtr;\n  char **ptrString;\n  uint strLen;\n  char *currentChar;\n  uint *argValue;\n  undefined4 argType;\n  code *formatBuffer;\n  \n  byteValue = *(byte *)(argList + 6);\n  stringValue = (char *)((int)argList + 0x43);\n  argValue = argList;\n  argType = stream;\n  formatBuffer = putcFunction;\n  if (0x78 < byteValue) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)argList + 0x42) = byteValue;\nLAB_00005bdc:\n    stringValue = (char *)((int)argList + 0x42);\n    value = 1;\nLAB_00005d28:\n    argList[4] = value;\n    *(undefined *)((int)argList + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (byteValue < 99) {\n    if (byteValue == 0) goto LAB_00005d06;\n    if (byteValue == 0x58) {\n      hexDigits = \"0123456789ABCDEF\";\n      *(undefined *)((int)argList + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(byteValue) {\n  case 99:\n    value = **wideArgList;\n    *wideArgList = *wideArgList + 1;\n    *(char *)((int)argList + 0x42) = (char)value;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    base = *argList;\n    wideArgValue = *wideArgList;\n    if ((int)(base << 0x18) < 0) {\n      value = *wideArgValue;\n      *wideArgList = wideArgValue + 1;\n    }\n    else {\n      value = *wideArgValue;\n      *wideArgList = wideArgValue + 1;\n      if ((base & 0x40) != 0) {\n        value = (uint)(short)value;\n      }\n    }\n    if ((int)value < 0) {\n      value = -value;\n      *(undefined *)((int)argList + 0x43) = 0x2d;\n    }\n    hexDigits = \"0123456789ABCDEF\";\n    base = 10;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    wideArgListPtr = (uint **)*wideArgList;\n    base = *argList;\n    value = argList[5];\n    *wideArgList = (uint *)(wideArgListPtr + 1);\n    wideArgValue = *wideArgListPtr;\n    if (((int)(base << 0x18) < 0) || (-1 < (int)(base << 0x19))) {\n      *wideArgValue = value;\n    }\n    else {\n      *(short *)wideArgValue = (short)value;\n    }\nLAB_00005d06:\n    argList[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    wideArgValue = *wideArgList;\n    value = *argList;\n    *wideArgList = wideArgValue + 1;\n    if (((int)(value << 0x18) < 0) || (-1 < (int)(value << 0x19))) {\n      value = *wideArgValue;\n    }\n    else {\n      value = (uint)*(ushort *)wideArgValue;\n    }\n    hexDigits = \"0123456789ABCDEF\";\n    if (byteValue == 0x6f) {\n      base = 8;\n    }\n    else {\n      base = 10;\n    }\n    break;\n  case 0x70:\n    *argList = *argList | 0x20;\n  case 0x78:\n    hexDigits = \"0123456789abcdef\";\n    *(undefined *)((int)argList + 0x45) = 0x78;\nLAB_00005ca8:\n    base = *argList;\n    value = **wideArgList;\n    *wideArgList = *wideArgList + 1;\n    if ((-1 < (int)(base << 0x18)) && ((int)(base << 0x19) < 0)) {\n      value = value & 0xffff;\n    }\n    if ((int)(base << 0x1f) < 0) {\n      *argList = base | 0x20;\n    }\n    if (value == 0) {\n      *argList = *argList & 0xffffffdf;\n    }\n    base = 0x10;\n    break;\n  case 0x73:\n    ptrString = (char **)*wideArgList;\n    *wideArgList = (uint *)(ptrString + 1);\n    stringValue = *ptrString;\n    foundNull = memchr(stringValue,0,argList[1]);\n    if (foundNull != (void *)0x0) {\n      argList[1] = (int)foundNull - (int)stringValue;\n    }\n    value = argList[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)argList + 0x43) = 0;\nLAB_00005c36:\n  strLen = argList[1];\n  argList[2] = strLen;\n  if (-1 < (int)strLen) {\n    *argList = *argList & 0xfffffffb;\n  }\n  currentChar = stringValue;\n  if ((value != 0) || (strLen != 0)) {\n    do {\n      currentChar = currentChar + -1;\n      *currentChar = hexDigits[value - base * (value / base)];\n      isGreater = base <= value;\n      value = value / base;\n    } while (isGreater);\n  }\n  if (((base == 8) && ((int)(*argList << 0x1f) < 0)) && ((int)argList[1] <= (int)argList[4])) {\n    currentChar[-1] = '0';\n    currentChar = currentChar + -1;\n  }\n  argList[4] = (int)stringValue - (int)currentChar;\n  stringValue = currentChar;\nLAB_00005c84:\n  returnValue = _printf_common(formatSpecifier,argList,&formatBuffer,stream,putcFunction,argValue,argType);\n  if ((returnValue == -1) || (returnValue = (*putcFunction)(formatSpecifier,stream,stringValue,argList[4]), returnValue == -1)) {\nLAB_00005c98:\n    formattedValue = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*argList << 0x1e) < 0) {\n      for (returnValue = 0; returnValue < (int)(argList[3] - (int)formatBuffer); returnValue = returnValue + 1) {\n        printfRetVal = (*putcFunction)(formatSpecifier,stream,(int)argList + 0x19,1);\n        if (printfRetVal == -1) goto LAB_00005c98;\n      }\n    }\n    formattedValue = (code *)argList[3];\n    if ((int)(code *)argList[3] < (int)formatBuffer) {\n      formattedValue = formatBuffer;\n    }\n  }\n  return formattedValue;\n}\n\n",
            "renaming": {
                "FUN_00005b34": "print_formatted_value_00005b34",
                "param_1": "formatSpecifier",
                "param_2": "argList",
                "param_3": "stream",
                "param_4": "putcFunction",
                "param_5": "wideArgList",
                "bVar1": "isGreater",
                "bVar2": "byteValue",
                "iVar3": "returnValue",
                "pcVar4": "formattedValue",
                "pcVar5": "hexDigits",
                "pvVar6": "foundNull",
                "iVar7": "printfRetVal",
                "__s": "stringValue",
                "uVar8": "value",
                "puVar9": "wideArgValue",
                "uVar10": "base",
                "uVar13": "strLen",
                "pcVar14": "currentChar",
                "puVar15": "argValue",
                "uVar16": "argType",
                "local_24": "formatBuffer",
                "ppuVar11": "wideArgListPtr",
                "ppcVar12": "ptrString"
            },
            "calling": [
                "_vfprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005d80": {
            "entrypoint": "0x00005d80",
            "current_name": "process_input_byte_00005d80",
            "code": "\nuint processInputByte_00005d80(int inputPtr,uint inputByte,undefined4 *stream)\n\n{\n  int bufferSize;\n  undefined *bufferPtr;\n  \n  if ((inputPtr != 0) && (*(int *)(inputPtr + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(undefined4 **)(inputPtr + 4);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = *(undefined4 **)(inputPtr + 8);\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = *(undefined4 **)(inputPtr + 0xc);\n  }\n  if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_acquire_recursive(stream[0x16]);\n  }\n  bufferSize = stream[2] + -1;\n  stream[2] = bufferSize;\n  if ((bufferSize < 0) && ((bufferSize < (int)stream[6] || ((inputByte & 0xff) == 10)))) {\n    inputByte = __swbuf_r(inputPtr,inputByte,stream);\n  }\n  else {\n    bufferPtr = (undefined *)*stream;\n    *stream = bufferPtr + 1;\n    *bufferPtr = (char)inputByte;\n    inputByte = inputByte & 0xff;\n  }\n  if ((-1 < (int)(stream[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x16))) {\n    __retarget_lock_release_recursive(stream[0x16]);\n  }\n  return inputByte;\n}\n\n",
            "renaming": {
                "FUN_00005d80": "process_input_byte_00005d80",
                "param_1": "inputPtr",
                "param_2": "inputByte",
                "param_3": "stream",
                "iVar1": "bufferSize",
                "puVar2": "bufferPtr"
            },
            "calling": [
                "putchar"
            ],
            "called": [
                "__swbuf_r",
                "__sinit",
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e10": {
            "entrypoint": "0x00005e10",
            "current_name": "read_byte_from_stream_00005e10",
            "code": "\nuint readByteFromStream_00005e10(int streamPtr,byte **streamBuf)\n\n{\n  int refillResult;\n  uint readByte;\n  byte *currentByte;\n  \n  if ((streamPtr != 0) && (*(int *)(streamPtr + 0x18) == 0)) {\n    __sinit();\n  }\n  if (streamBuf == (byte **)&__sf_fake_stdin) {\n    streamBuf = *(byte ***)(streamPtr + 4);\n  }\n  else if (streamBuf == (byte **)&__sf_fake_stdout) {\n    streamBuf = *(byte ***)(streamPtr + 8);\n  }\n  else if (streamBuf == (byte **)&__sf_fake_stderr) {\n    streamBuf = *(byte ***)(streamPtr + 0xc);\n  }\n  refillResult = __srefill_r(streamPtr,streamBuf);\n  if (refillResult == 0) {\n    streamBuf[1] = streamBuf[1] + -1;\n    currentByte = *streamBuf;\n    *streamBuf = currentByte + 1;\n    readByte = (uint)*currentByte;\n  }\n  else {\n    readByte = 0xffffffff;\n  }\n  return readByte;\n}\n\n",
            "renaming": {
                "FUN_00005e10": "read_byte_from_stream_00005e10",
                "param_1": "streamPtr",
                "param_2": "streamBuf",
                "iVar1": "refillResult",
                "uVar2": "readByte",
                "pbVar3": "currentByte"
            },
            "calling": [
                "_getc_r"
            ],
            "called": [
                "__sinit",
                "__srefill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005e68": {
            "entrypoint": "0x00005e68",
            "current_name": "parse_input_00005e68",
            "code": "\nint parseInput_00005e68(char *inputString,char *formatString,...)\n\n{\n  int returnValue;\n  undefined4 register2;\n  undefined4 register3;\n  char *stringPointer;\n  size_t stringLength;\n  undefined2 bufferSize;\n  undefined2 bufferSize2;\n  char *stringPointer2;\n  size_t stringLength2;\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined4 constant3;\n  undefined4 stackVariable1;\n  undefined4 stackVariable2;\n  \n  bufferSize = 0x204;\n  stringPointer = inputString;\n  stringPointer2 = inputString;\n  stackVariable1 = register2;\n  stackVariable2 = register3;\n  stringLength = strlen(inputString);\n  constant1 = 0x4deb;\n  constant2 = 0;\n  constant3 = 0;\n  bufferSize2 = 0xffff;\n  stringLength2 = stringLength;\n  returnValue = inputStringsvfiscanf_r(_impure_ptr,&stringPointer,formatString,&stackVariable1);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00005e68": "parse_input_00005e68",
                "__s": "inputString",
                "__format": "formatString",
                "iVar1": "returnValue",
                "in_r2": "register2",
                "in_r3": "register3",
                "local_80": "stringPointer",
                "local_7c": "stringLength",
                "local_74": "bufferSize",
                "local_72": "bufferSize2",
                "local_70": "stringPointer2",
                "local_6c": "stringLength2",
                "local_5c": "constant1",
                "local_4c": "constant2",
                "local_38": "constant3",
                "uStack_8": "stackVariable1",
                "uStack_4": "stackVariable2"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "__ssvfiscanf_r",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ebc": {
            "entrypoint": "0x00005ebc",
            "current_name": "copy_string_00005ebc",
            "code": "\nchar * copyString_00005ebc(char *destination,char *source)\n\n{\n  char currentChar;\n  char *destinationPtr;\n  \n  destinationPtr = destination;\n  do {\n    currentChar = *source;\n    *destinationPtr = currentChar;\n    source = source + 1;\n    destinationPtr = destinationPtr + 1;\n  } while (currentChar != '\\0');\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "currentChar",
                "pcVar2": "destinationPtr"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ecc": {
            "entrypoint": "0x00005ecc",
            "current_name": "calculate_string_length_00005ecc",
            "code": "\nsize_t calculateStringLength_00005ecc(char *string)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 = string;\n  do {\n    pcVar2 = pcVar3 + 1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar2;\n  } while (cVar1 != '\\0');\n  return (size_t)(pcVar2 + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_00005ecc": "calculate_string_length_00005ecc",
                "__s": "string"
            },
            "calling": [
                "siscanf",
                "_tzset_unlocked_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005edc": {
            "entrypoint": "0x00005edc",
            "current_name": "parse_numeric_string_00005edc",
            "code": "\nuint parseNumericString_00005edc(undefined4 *outputValue,byte *inputString,byte **remainingString,uint base)\n\n{\n  uint result;\n  uint currentChar;\n  byte isNegative;\n  int status;\n  uint digitValue;\n  uint maxQuotient;\n  byte *currentByte;\n  byte *nextByte;\n  \n  nextByte = inputString;\n  do {\n    currentByte = nextByte;\n    nextByte = currentByte + 1;\n    currentChar = (uint)*currentByte;\n    isNegative = (&DAT_00007a99)[currentChar] & 8;\n  } while (((&DAT_00007a99)[currentChar] & 8) != 0);\n  if (currentChar == 0x2d) {\n    currentChar = (uint)*nextByte;\n    isNegative = 1;\n    nextByte = currentByte + 2;\n  }\n  else if (currentChar == 0x2b) {\n    currentChar = (uint)*nextByte;\n    nextByte = currentByte + 2;\n  }\n  if (base == 0) {\n    if (currentChar != 0x30) {\n      base = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((base != 0x10) || (currentChar != 0x30)) goto LAB_00005f26;\n  if ((*nextByte & 0xdf) == 0x58) {\n    currentChar = (uint)nextByte[1];\n    base = 0x10;\n    nextByte = nextByte + 2;\n  }\n  else {\n    currentChar = 0x30;\n    if (base == 0) {\n      base = 8;\n    }\n  }\nLAB_00005f26:\n  status = 0;\n  maxQuotient = 0xffffffff / base;\n  result = 0;\n  do {\n    digitValue = currentChar - 0x30;\n    if (9 < digitValue) {\n      if (currentChar - 0x41 < 0x1a) {\n        digitValue = currentChar - 0x37;\n      }\n      else {\n        if (0x19 < currentChar - 0x61) break;\n        digitValue = currentChar - 0x57;\n      }\n    }\n    if ((int)base <= (int)digitValue) break;\n    if (((status < 0) || (maxQuotient < result)) ||\n       ((maxQuotient == result && ((int)~(base * maxQuotient) < (int)digitValue)))) {\n      status = -1;\n    }\n    else {\n      result = result * base + digitValue;\n      status = 1;\n    }\n    currentChar = (uint)*nextByte;\n    nextByte = nextByte + 1;\n  } while( true );\n  if (status < 0) {\n    *outputValue = 0x22;\n    result = 0xffffffff;\n    if (remainingString == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (isNegative != 0) {\n      result = -result;\n    }\n    if (remainingString == (byte **)0x0) {\n      return result;\n    }\n    if (status == 0) goto LAB_00005fb8;\n  }\n  inputString = nextByte + -1;\nLAB_00005fb8:\n  *remainingString = inputString;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005edc": "parse_numeric_string_00005edc",
                "param_1": "outputValue",
                "param_2": "inputString",
                "param_3": "remainingString",
                "param_4": "base",
                "uVar1": "result",
                "uVar2": "currentChar",
                "bVar3": "isNegative",
                "iVar4": "status",
                "uVar5": "digitValue",
                "uVar6": "maxQuotient",
                "pbVar7": "currentByte",
                "pbVar8": "nextByte"
            },
            "calling": [
                "_strtoul_r",
                "strtoul"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd4": {
            "entrypoint": "0x00005fd4",
            "current_name": "FUN_00005fd4",
            "code": "\nuint _strtoul_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 = param_2;\n  do {\n    pbVar7 = pbVar8;\n    pbVar8 = pbVar7 + 1;\n    uVar2 = (uint)*pbVar7;\n    bVar3 = (&DAT_00007a99)[uVar2] & 8;\n  } while (((&DAT_00007a99)[uVar2] & 8) != 0);\n  if (uVar2 == 0x2d) {\n    uVar2 = (uint)*pbVar8;\n    bVar3 = 1;\n    pbVar8 = pbVar7 + 2;\n  }\n  else if (uVar2 == 0x2b) {\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar7 + 2;\n  }\n  if (param_4 == 0) {\n    if (uVar2 != 0x30) {\n      param_4 = 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 != 0x10) || (uVar2 != 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 & 0xdf) == 0x58) {\n    uVar2 = (uint)pbVar8[1];\n    param_4 = 0x10;\n    pbVar8 = pbVar8 + 2;\n  }\n  else {\n    uVar2 = 0x30;\n    if (param_4 == 0) {\n      param_4 = 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 = 0;\n  uVar6 = 0xffffffff / param_4;\n  uVar1 = 0;\n  do {\n    uVar5 = uVar2 - 0x30;\n    if (9 < uVar5) {\n      if (uVar2 - 0x41 < 0x1a) {\n        uVar5 = uVar2 - 0x37;\n      }\n      else {\n        if (0x19 < uVar2 - 0x61) break;\n        uVar5 = uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 <= (int)uVar5) break;\n    if (((iVar4 < 0) || (uVar6 < uVar1)) ||\n       ((uVar6 == uVar1 && ((int)~(param_4 * uVar6) < (int)uVar5)))) {\n      iVar4 = -1;\n    }\n    else {\n      uVar1 = uVar1 * param_4 + uVar5;\n      iVar4 = 1;\n    }\n    uVar2 = (uint)*pbVar8;\n    pbVar8 = pbVar8 + 1;\n  } while( true );\n  if (iVar4 < 0) {\n    *param_1 = 0x22;\n    uVar1 = 0xffffffff;\n    if (param_3 == (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 != 0) {\n      uVar1 = -uVar1;\n    }\n    if (param_3 == (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 == 0) goto LAB_00005fb8;\n  }\n  param_2 = pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 = param_2;\n  return uVar1;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fd8": {
            "entrypoint": "0x00005fd8",
            "current_name": "parse_unsigned_number_00005fd8",
            "code": "\nulong parseUnsignedNumber_00005fd8(char *inputString,char **endPointer,int base)\n\n{\n  ulong result;\n  \n  result = _strtoul_l_isra_0(_impure_ptr,inputString,endPointer,base);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00005fd8": "parse_unsigned_number_00005fd8",
                "__nptr": "inputString",
                "__endptr": "endPointer",
                "__base": "base",
                "uVar1": "result"
            },
            "calling": [
                "_tzset_unlocked_r"
            ],
            "called": [
                "_strtoul_l.isra.0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005fec": {
            "entrypoint": "0x00005fec",
            "current_name": "acquire_recursive_lock_00005fec",
            "code": "\nvoid acquireRecursiveLock_00005fec(void)\n\n{\n  lockAcquireRecursive(&recursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005fec": "acquire_recursive_lock_00005fec",
                "__retarget_lock_acquire_recursive": "lockAcquireRecursive",
                "__lock___env_recursive_mutex": "recursiveMutex"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00005ff8": {
            "entrypoint": "0x00005ff8",
            "current_name": "release_recursive_lock_00005ff8",
            "code": "\nvoid releaseRecursiveLock_00005ff8(void)\n\n{\n  releaseRecursiveLock_00005ff8_internal(&recursiveLock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00005ff8": "release_recursive_lock_00005ff8",
                "__retarget_lock_release_recursive": "releaseRecursiveLock_internal",
                "__lock___env_recursive_mutex": "recursiveLock"
            },
            "calling": [
                "_findenv_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006010": {
            "entrypoint": "0x00006010",
            "current_name": "find_byte_sequence_00006010",
            "code": "\nvoid * find_byte_sequence_00006010(void *data,int target_value,size_t data_size)\n\n{\n  byte current_byte;\n  char comparison_result_1;\n  char comparison_result_2;\n  char comparison_result_3;\n  char comparison_result_4;\n  byte *ptr_comparison_1;\n  uint *ptr_data;\n  byte *ptr_comparison_2;\n  uint target_byte;\n  uint align_offset;\n  uint remaining_data_size;\n  uint comparison_result_byte_1;\n  uint comparison_result_byte_2;\n  bool comparison_result_byte_1_bool;\n  bool comparison_result_byte_2_bool;\n  bool comparison_result_byte_3_bool;\n  bool comparison_result_byte_4_bool;\n  \n  target_byte = target_value & 0xff;\n  if ((int)data_size < 0x10) {\njoined_r0x00006070:\n    do {\n      if (data_size == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      ptr_data = (uint *)((int)data + 1);\n      current_byte = *data;\n      data_size = data_size - 1;\n      data = ptr_data;\n    } while (current_byte != target_byte);\n  }\n  else {\n    align_offset = (uint)data & 7;\n    while( true ) {\n      if (align_offset == 0) {\n        align_offset = target_byte | target_byte << 8;\n        align_offset = align_offset | align_offset << 0x10;\n        remaining_data_size = data_size & 0xfffffff8;\n        do {\n          ptr_data = (uint *)((int)data + 8);\n                    /* WARNING: Load size is inaccurate */\n          remaining_data_size = remaining_data_size - 8;\n          comparison_result_byte_1 = *data ^ align_offset;\n          comparison_result_byte_2 = *(uint *)((int)data + 4) ^ align_offset;\n          comparison_result_1 = -((char)comparison_result_byte_1 == '\\0');\n          comparison_result_2 = -((char)(comparison_result_byte_1 >> 8) == '\\0');\n          comparison_result_3 = -((char)(comparison_result_byte_1 >> 0x10) == '\\0');\n          comparison_result_4 = -((char)(comparison_result_byte_1 >> 0x18) == '\\0');\n          comparison_result_byte_1 = CONCAT13(comparison_result_4,CONCAT12(comparison_result_3,CONCAT11(comparison_result_2,comparison_result_1)));\n          comparison_result_byte_1_bool = (char)comparison_result_byte_2 != '\\0';\n          comparison_result_byte_2_bool = (char)(comparison_result_byte_2 >> 8) != '\\0';\n          comparison_result_byte_3_bool = (char)(comparison_result_byte_2 >> 0x10) != '\\0';\n          comparison_result_byte_4_bool = (char)(comparison_result_byte_2 >> 0x18) != '\\0';\n          comparison_result_byte_2 = CONCAT13(comparison_result_byte_4_bool * comparison_result_4 - !comparison_result_byte_4_bool,\n                            CONCAT12(comparison_result_byte_3_bool * comparison_result_3 - !comparison_result_byte_3_bool,\n                                     CONCAT11(comparison_result_byte_2_bool * comparison_result_2 - !comparison_result_byte_2_bool,comparison_result_byte_1_bool * comparison_result_1 - !comparison_result_byte_1_bool)));\n          if (comparison_result_byte_2 != 0) {\n            if (comparison_result_byte_1 == 0) {\n              ptr_comparison_2 = (byte *)((int)data + 5);\n              comparison_result_byte_1 = comparison_result_byte_2;\n            }\n            else {\n              ptr_comparison_2 = (byte *)((int)data + 1);\n            }\n            if ((comparison_result_byte_1 & 1) == 0) {\n              comparison_result_byte_1_bool = (comparison_result_byte_1 & 0x100) == 0;\n              ptr_comparison_1 = ptr_comparison_2 + 1;\n              if (comparison_result_byte_1_bool) {\n                comparison_result_byte_1_bool = (comparison_result_byte_1 & 0x18000) == 0;\n                ptr_comparison_1 = ptr_comparison_2 + 2;\n              }\n              ptr_comparison_2 = ptr_comparison_1;\n              if (comparison_result_byte_1_bool) {\n                ptr_comparison_2 = ptr_comparison_2 + 1;\n              }\n            }\n            return ptr_comparison_2 + -1;\n          }\n          data = ptr_data;\n        } while (remaining_data_size != 0);\n        data_size = data_size & 7;\n        goto joined_r0x00006070;\n      }\n                    /* WARNING: Load size is inaccurate */\n      ptr_data = (uint *)((int)data + 1);\n      data_size = data_size - 1;\n      if (*data == target_byte) break;\n      align_offset = (uint)ptr_data & 7;\n      data = ptr_data;\n      if (data_size == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)ptr_data + -1);\n}\n\n",
            "renaming": {
                "FUN_00006010": "find_byte_sequence_00006010",
                "__s": "data",
                "__c": "target_value",
                "__n": "data_size",
                "bVar1": "current_byte",
                "cVar2": "comparison_result_1",
                "cVar3": "comparison_result_2",
                "cVar4": "comparison_result_3",
                "cVar5": "comparison_result_4",
                "pbVar6": "ptr_comparison_1",
                "puVar7": "ptr_data",
                "pbVar8": "ptr_comparison_2",
                "uVar9": "target_byte",
                "uVar10": "align_offset",
                "uVar11": "remaining_data_size",
                "uVar12": "comparison_result_byte_1",
                "uVar13": "comparison_result_byte_2",
                "bVar14": "comparison_result_byte_1_bool",
                "bVar15": "comparison_result_byte_2_bool",
                "bVar16": "comparison_result_byte_3_bool",
                "bVar17": "comparison_result_byte_4_bool"
            },
            "calling": [
                "_printf_i",
                "__ssvfiscanf_r",
                "_vfprintf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060b0": {
            "entrypoint": "0x000060b0",
            "current_name": "copy_memory_000060b0",
            "code": "\nvoid * copy_memory_000060b0(void *destination,void *source,size_t length)\n\n{\n  undefined *source_ptr;\n  undefined *end_ptr;\n  undefined *dest_ptr;\n  \n  end_ptr = (undefined *)(length + (int)source);\n  dest_ptr = (undefined *)((int)destination + -1);\n  if ((undefined *)source != end_ptr) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      source_ptr = (undefined *)((int)source + 1);\n      dest_ptr = dest_ptr + 1;\n      *dest_ptr = *source;\n      source = source_ptr;\n    } while (source_ptr != end_ptr);\n    return destination;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000060b0": "copy_memory_000060b0",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "source_ptr",
                "puVar2": "end_ptr",
                "puVar3": "dest_ptr"
            },
            "calling": [
                "__submore",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000060cc": {
            "entrypoint": "0x000060cc",
            "current_name": "realloc_or_malloc_000060cc",
            "code": "\nvoid * realloc_or_malloc_000060cc(undefined4 context,void *original_ptr,uint new_size,undefined4 extra_size)\n\n{\n  void *result_ptr;\n  uint original_size;\n  \n  if (original_ptr != (void *)0x0) {\n    if (new_size == 0) {\n      _free_r();\n      result_ptr = (void *)0x0;\n    }\n    else {\n      original_size = _malloc_usable_size_r();\n      result_ptr = original_ptr;\n      if ((original_size < new_size) && (result_ptr = (void *)_malloc_r(context,new_size), result_ptr != (void *)0x0))\n      {\n        memcpy(result_ptr,original_ptr,new_size);\n        _free_r(context,original_ptr);\n      }\n    }\n    return result_ptr;\n  }\n  result_ptr = (void *)_malloc_r(context,new_size,new_size,extra_size);\n  return result_ptr;\n}\n\n",
            "renaming": {
                "FUN_000060cc": "realloc_or_malloc_000060cc",
                "param_1": "context",
                "param_2": "original_ptr",
                "param_3": "new_size",
                "param_4": "extra_size",
                "pvVar1": "result_ptr",
                "uVar2": "original_size"
            },
            "calling": [
                "__submore"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_malloc_usable_size_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006118": {
            "entrypoint": "0x00006118",
            "current_name": "process_data_00006118",
            "code": "\nuint process_data_00006118(undefined4 arg1,uint arg2,uint *data_array,undefined4 arg4)\n\n{\n  int temp_var1;\n  uint temp_var2;\n  uint temp_var3;\n  \n  if (arg2 == 0xffffffff) {\nLAB_00006120:\n    arg2 = 0xffffffff;\n  }\n  else {\n    *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xffdf;\n    temp_var2 = data_array[1];\n    arg2 = arg2 & 0xff;\n    if (data_array[0xd] == 0) {\n      temp_var3 = *data_array;\n      if (((data_array[4] != 0) && (data_array[4] < temp_var3)) && (*(byte *)(temp_var3 - 1) == arg2)) {\n        *data_array = temp_var3 - 1;\n        data_array[1] = temp_var2 + 1;\n        return arg2;\n      }\n      data_array[0xf] = temp_var3;\n      data_array[0x10] = temp_var2;\n      data_array[0xd] = (uint)(data_array + 0x11);\n      data_array[0xe] = 3;\n      *(undefined *)((int)data_array + 0x46) = (char)arg2;\n      *data_array = (uint)(undefined *)((int)data_array + 0x46);\n      temp_var2 = 1;\n    }\n    else {\n      if (((int)data_array[0xe] <= (int)temp_var2) &&\n         (temp_var1 = __submore(arg1,data_array,temp_var2,data_array[0xe],arg4), temp_var1 != 0))\n      goto LAB_00006120;\n      temp_var2 = *data_array;\n      *data_array = temp_var2 - 1;\n      *(char *)(temp_var2 - 1) = (char)arg2;\n      temp_var2 = data_array[1] + 1;\n    }\n    data_array[1] = temp_var2;\n  }\n  return arg2;\n}\n\n",
            "renaming": {
                "FUN_00006118": "process_data_00006118",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "data_array",
                "param_4": "arg4",
                "iVar1": "temp_var1",
                "uVar2": "temp_var2",
                "uVar3": "temp_var3"
            },
            "calling": [],
            "called": [
                "__submore"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006192": {
            "entrypoint": "0x00006192",
            "current_name": "initialize_data_00006192",
            "code": "\nundefined4 initializeData_00006192(undefined4 param1,undefined4 *dataArray)\n\n{\n  if ((undefined4 *)dataArray[0xd] != (undefined4 *)0x0) {\n    if ((undefined4 *)dataArray[0xd] != dataArray + 0x11) {\n      _free_r();\n    }\n    dataArray[1] = dataArray[0x10];\n    dataArray[0xd] = 0;\n    if (dataArray[0x10] != 0) {\n      *dataArray = dataArray[0xf];\n      return 0;\n    }\n  }\n  *dataArray = dataArray[4];\n  dataArray[1] = 0;\n  *(ushort *)(dataArray + 3) = *(ushort *)(dataArray + 3) | 0x20;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006192": "initialize_data_00006192",
                "param_1": "param1",
                "param_2": "dataArray"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000061cc": {
            "entrypoint": "0x000061cc",
            "current_name": "parse_and_read_data_000061cc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006482) */\n\nint parseAndReadData_000061cc(undefined4 param_1,byte **buffer,byte *format,int **output)\n\n{\n  int result;\n  void *ptr;\n  uint currentChar;\n  byte *nextChar;\n  uint flags;\n  int **outputPtr;\n  undefined stackBuffer [256];\n  uint flags1;\n  undefined4 base;\n  uint flags2;\n  int count;\n  int length;\n  undefined *stackPtr;\n  int type;\n  undefined4 localVar1;\n  code *localVar2;\n  \n  count = 0;\n  length = 0;\n  localVar1 = 0x6119;\n  localVar2 = __ssrefill_r + 1;\n  outputPtr = output;\n  stackPtr = stackBuffer;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      flags = (uint)*format;\n      if (flags == 0) {\n        return count;\n      }\n      currentChar = (byte)(&DAT_00007a99)[flags] & 8;\n      nextChar = format + 1;\n      if (((&DAT_00007a99)[flags] & 8) == 0) break;\n      while (((format = nextChar, 0 < (int)buffer[1] ||\n              (result = (*localVar2)(param_1,buffer), result == 0)) &&\n             ((int)((uint)(byte)(&DAT_00007a99)[**buffer] << 0x1c) < 0))) {\n        length = length + 1;\n        buffer[1] = buffer[1] + -1;\n        *buffer = *buffer + 1;\n      }\n    }\n    if (flags == 0x25) break;\nLAB_00006352:\n    if (((int)buffer[1] < 1) && (result = (*localVar2)(param_1,buffer), result != 0))\n    goto LAB_00006380;\n    if (**buffer != flags) {\n      return count;\n    }\n    *buffer = *buffer + 1;\n    length = length + 1;\n    buffer[1] = buffer[1] + -1;\n    format = nextChar;\n  }\n  flags2 = currentChar;\n  flags1 = currentChar;\n  if (format[1] == 0x2a) {\n    nextChar = format + 2;\n    flags1 = 0x10;\n  }\n  while( true ) {\n    currentChar = (uint)*nextChar;\n    if (9 < currentChar - 0x30) break;\n    nextChar = nextChar + 1;\n    flags2 = (flags2 * 10 + currentChar) - 0x30;\n  }\n  ptr = memchr(&DAT_00007c02,currentChar,3);\n  if (ptr != (void *)0x0) {\n    flags1 = 1 << ((int)ptr - 0x7c02U & 0xff) | flags1;\n    nextChar = nextChar + 1;\n  }\n  format = nextChar + 1;\n  currentChar = (uint)*nextChar;\n  if (currentChar < 0x79) {\n    if (0x57 < currentChar) {\n      switch(currentChar) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        format = (byte *)__sccl(stackBuffer,format);\n        flags1 = flags1 | 0x40;\n        type = 1;\n        break;\n      case 99:\n        flags1 = flags1 | 0x40;\n        type = 0;\n        break;\n      case 100:\n      case 0x75:\n        base = 10;\nLAB_000063a0:\n        if (currentChar < 0x6f) {\n          type = 3;\n        }\n        else {\n          type = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        type = 5;\n        break;\n      case 0x69:\n        base = 0;\n        type = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(flags1 << 0x1b)) {\n          if ((int)(flags1 << 0x1f) < 0) {\n            *(short *)*outputPtr = (short)length;\n            outputPtr = outputPtr + 1;\n          }\n          else {\n            **outputPtr = length;\n            outputPtr = outputPtr + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        base = 8;\n        type = 4;\n        break;\n      case 0x70:\n        flags1 = flags1 | 0x20;\n      case 0x58:\n      case 0x78:\n        flags1 = flags1 | 0x200;\n        base = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        type = 2;\n      }\nLAB_000063ac:\n      if (((int)buffer[1] < 1) && (result = (*localVar2)(param_1,buffer), result != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(flags1 << 0x19)) {\n        while ((int)((uint)(byte)(&DAT_00007a99)[**buffer] << 0x1c) < 0) {\n          length = length + 1;\n          nextChar = buffer[1];\n          buffer[1] = nextChar + -1;\n          if ((int)(nextChar + -1) < 1) {\n            result = (*localVar2)(param_1,buffer);\n            if (result != 0) goto LAB_00006380;\n          }\n          else {\n            *buffer = *buffer + 1;\n          }\n        }\n      }\n      if (type < 3) {\n        result = _scanf_chars(param_1,&flags1,buffer,&outputPtr);\n      }\n      else {\n        if (4 < type) goto LAB_000061f6;\n        result = _scanf_i(param_1,&flags1,buffer,&outputPtr);\n      }\n      if (result == 1) {\n        return count;\n      }\n      if (result == 2) {\nLAB_00006380:\n        if (count == 0) {\nLAB_00006388:\n          count = -1;\n        }\n        else if ((*(ushort *)(buffer + 3) & 0x40) != 0) {\n          count = -1;\n        }\n        return count;\n      }\n      goto LAB_000061f6;\n    }\n    nextChar = format;\n    if (currentChar == 0x25) goto LAB_00006352;\n    if (currentChar < 0x26) {\n      if (currentChar != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (currentChar - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  type = 3;\n  base = 10;\n  goto LAB_000063ac;\n}\n\n",
            "renaming": {
                "FUN_000061cc": "parse_and_read_data_000061cc",
                "param_2": "buffer",
                "param_3": "format",
                "param_4": "output",
                "iVar1": "result",
                "pvVar2": "ptr",
                "uVar3": "currentChar",
                "pbVar4": "nextChar",
                "uVar5": "flags",
                "local_2b0": "outputPtr",
                "auStack_2ac": "stackBuffer",
                "local_1ac": "flags1",
                "local_1a8": "base",
                "local_1a4": "flags2",
                "local_1a0": "count",
                "local_19c": "length",
                "local_198": "stackPtr",
                "local_194": "type",
                "local_30": "localVar1",
                "local_2c": "localVar2"
            },
            "calling": [
                "siscanf"
            ],
            "called": [
                "__sccl",
                "__ssrefill_r",
                "_scanf_chars",
                "_scanf_i",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000064bc": {
            "entrypoint": "0x000064bc",
            "current_name": "decode_and_process_data_000064bc",
            "code": "\nundefined4 decode_and_process_data_000064bc(undefined4 initial_value,uint *decode_params,byte **data_ptr,undefined4 *status_ptr)\n\n{\n  int result;\n  uint temp_var;\n  byte **data_ptr_ptr;\n  byte *data_ptr_1;\n  byte *temp_data_ptr;\n  byte *current_data_ptr;\n  int iteration_count;\n  \n  if (decode_params[2] == 0) {\n    if (decode_params[6] == 0) {\n      temp_var = 1;\n    }\n    else {\n      temp_var = 0xffffffff;\n    }\n    decode_params[2] = temp_var;\n  }\n  if (-1 < (int)(*decode_params << 0x1b)) {\n    data_ptr_ptr = (byte **)*status_ptr;\n    *status_ptr = data_ptr_ptr + 1;\n    temp_data_ptr = *data_ptr_ptr;\n  }\n  iteration_count = 0;\n  do {\n    temp_var = decode_params[6];\n    if (temp_var != 0) {\n      if (temp_var == 1) {\n        if (*(char *)(decode_params[5] + (uint)**data_ptr) == '\\0') {\n          if (iteration_count == 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*decode_params & 0x10) == 0) && (decode_params[3] = decode_params[3] + 1, decode_params[6] != 0)) {\n            *temp_data_ptr = 0;\n          }\n          decode_params[4] = iteration_count + decode_params[4];\n          return 0;\n        }\n      }\n      else if ((temp_var != 2) || ((int)((uint)(byte)(&DAT_00007a99)[**data_ptr] << 0x1c) < 0))\n      goto LAB_0000654a;\n    }\n    current_data_ptr = temp_data_ptr;\n    if (-1 < (int)(*decode_params << 0x1b)) {\n      current_data_ptr = temp_data_ptr + 1;\n      *temp_data_ptr = **data_ptr;\n    }\n    data_ptr_1 = data_ptr[1];\n    *data_ptr = *data_ptr + 1;\n    temp_var = decode_params[2] - 1;\n    data_ptr[1] = data_ptr_1 + -1;\n    iteration_count = iteration_count + 1;\n    decode_params[2] = temp_var;\n    temp_data_ptr = current_data_ptr;\n    if ((temp_var == 0) ||\n       (((int)(data_ptr_1 + -1) < 1 &&\n        (result = (*(code *)decode_params[0x60])(initial_value,data_ptr,temp_var,(code *)decode_params[0x60],status_ptr),\n        result != 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000064bc": "decode_and_process_data_000064bc",
                "param_1": "initial_value",
                "param_2": "decode_params",
                "param_3": "data_ptr",
                "param_4": "status_ptr",
                "iVar1": "result",
                "uVar2": "temp_var",
                "ppbVar3": "data_ptr_ptr",
                "pbVar4": "data_ptr_1",
                "unaff_r6": "temp_data_ptr",
                "pbVar5": "current_data_ptr",
                "iVar6": "iteration_count"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000656c": {
            "entrypoint": "0x0000656c",
            "current_name": "parse_data_0000656c",
            "code": "\nundefined4 parseData_0000656c(undefined4 input,uint *data,byte **buffer,undefined4 *output)\n\n{\n  code *strToNumFunc;\n  void *foundChar;\n  int result;\n  undefined4 parsedValue;\n  uint remainingSize;\n  byte *currentByte;\n  uint dataSize;\n  undefined4 *outputPtr;\n  uint *bufferPtr;\n  uint *tempPtr;\n  uint *dataStart;\n  int extraBytes;\n  int iteration;\n  undefined *searchArr [4];\n  \n  searchArr[0] = &DAT_00007c2f;\n  searchArr[1] = &DAT_00007c32;\n  searchArr[2] = &DAT_00007c35;\n  strToNumFunc = _strtol_r;\n  if (data[6] != 3) {\n    strToNumFunc = _strtoul_r;\n  }\n  dataSize = data[2];\n  remainingSize = dataSize - 1;\n  if (0x15c < remainingSize) {\n    extraBytes = dataSize - 0x15d;\n    dataSize = 0x15d;\n  }\n  if (0x15c < remainingSize) {\n    data[2] = dataSize;\n  }\n  dataStart = data + 7;\n  if (remainingSize < 0x15d) {\n    extraBytes = 0;\n  }\n  *data = *data | 0xd00;\n  iteration = 0;\n  tempPtr = dataStart;\n  do {\n    foundChar = memchr(searchArr[iteration],(uint)**buffer,2);\n    if (foundChar != (void *)0x0) {\n      if (iteration == 1) {\n        if (data[1] == 0) {\n          data[1] = 8;\n          *data = *data | 0x200;\n        }\n        remainingSize = *data & 0xfffffaff;\nLAB_000065f4:\n        *data = remainingSize;\n      }\n      else if (iteration == 2) {\n        if ((*data & 0x600) != 0x200) goto LAB_00006624;\n        data[1] = 0x10;\n        remainingSize = *data | 0x100;\n        goto LAB_000065f4;\n      }\n      remainingSize = data[2];\n      data[2] = remainingSize - 1;\n      if (remainingSize != 0) {\n        currentByte = *buffer;\n        *buffer = currentByte + 1;\n        bufferPtr = (uint *)((int)tempPtr + 1);\n        *(byte *)tempPtr = *currentByte;\n        currentByte = buffer[1];\n        buffer[1] = currentByte + -1;\n        tempPtr = bufferPtr;\n        if (((int)(currentByte + -1) < 1) &&\n           (result = (*(code *)data[0x60])(input,buffer), result != 0)) {\n          iteration = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iteration = iteration + 1;\n  } while (iteration != 3);\n  if (data[1] == 0) {\n    data[1] = 10;\n  }\n  __sccl(data[5],\"01234567]\" + (8 - data[1]));\n  iteration = 0;\n  while( true ) {\n    bufferPtr = tempPtr;\n    if (data[2] == 0) break;\n    currentByte = *buffer;\n    remainingSize = (uint)*currentByte;\n    if (*(char *)(data[5] + remainingSize) == '\\0') break;\n    if ((remainingSize == 0x30) && ((int)(*data << 0x14) < 0)) {\n      iteration = iteration + 1;\n      if (extraBytes != 0) {\n        extraBytes = extraBytes + -1;\n        data[2] = data[2] + 1;\n      }\n    }\n    else {\n      *data = *data & 0xfffff6ff;\n      bufferPtr = (uint *)((int)tempPtr + 1);\n      *(byte *)tempPtr = *currentByte;\n    }\n    currentByte = buffer[1];\n    buffer[1] = currentByte + -1;\n    if ((int)(currentByte + -1) < 1) {\n      result = (*(code *)data[0x60])(input,buffer);\n      if (result != 0) break;\n    }\n    else {\n      *buffer = *buffer + 1;\n    }\n    data[2] = data[2] - 1;\n    tempPtr = bufferPtr;\n  }\nLAB_000066ca:\n  if ((int)(*data << 0x17) < 0) {\n    if (dataStart < bufferPtr) {\n      (*(code *)data[0x5f])(input,*(byte *)((int)bufferPtr + -1),buffer);\n      bufferPtr = (uint *)((int)bufferPtr + -1);\n    }\n    if (bufferPtr == dataStart) {\n      return 1;\n    }\n  }\n  if ((*data & 0x10) == 0) {\n    *(byte *)bufferPtr = 0;\n    parsedValue = (*(strToNumFunc + 1))(input,dataStart,0,data[1]);\n    outputPtr = (undefined4 *)*output;\n    remainingSize = *data;\n    *output = outputPtr + 1;\n    outputPtr = (undefined4 *)*outputPtr;\n    if ((remainingSize & 0x20) == 0) {\n      if ((int)(remainingSize << 0x1f) < 0) {\n        *(short *)outputPtr = (short)parsedValue;\n      }\n      else {\n        *outputPtr = parsedValue;\n      }\n    }\n    else {\n      *outputPtr = parsedValue;\n    }\n    data[3] = data[3] + 1;\n  }\n  data[4] = (uint)((int)bufferPtr + data[4] + (iteration - (int)dataStart));\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0000656c": "parse_data_0000656c",
                "param_1": "input",
                "param_2": "data",
                "param_3": "buffer",
                "param_4": "output",
                "pcVar1": "strToNumFunc",
                "pvVar2": "foundChar",
                "iVar3": "result",
                "uVar4": "parsedValue",
                "uVar5": "remainingSize",
                "pbVar6": "currentByte",
                "uVar7": "dataSize",
                "puVar8": "outputPtr",
                "puVar9": "bufferPtr",
                "puVar10": "tempPtr",
                "puVar11": "dataStart",
                "unaff_r9": "extraBytes",
                "iVar12": "iteration",
                "local_34": "searchArr"
            },
            "calling": [
                "__ssvfiscanf_r"
            ],
            "called": [
                "__sccl",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006754": {
            "entrypoint": "0x00006754",
            "current_name": "flush_file_00006754",
            "code": "\nint flushFile_00006754(FILE *filePtr)\n\n{\n  int flushResult;\n  \n  if ((*(ushort *)&filePtr->_IO_read_base & 9) == 9) {\n    flushResult = fflush(filePtr);\n    return flushResult;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00006754": "flush_file_00006754",
                "param_1": "filePtr",
                "iVar1": "flushResult"
            },
            "calling": [],
            "called": [
                "fflush"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006768": {
            "entrypoint": "0x00006768",
            "current_name": "process_stream_00006768",
            "code": "\nundefined4\nprocessStream_00006768(undefined4 *streamInfo,undefined4 *stream,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined2 flag;\n  int result;\n  undefined4 temp;\n  ushort status;\n  uint tempUint;\n  \n  if ((streamInfo != (undefined4 *)0x0) && (streamInfo[6] == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = (undefined4 *)streamInfo[1];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stdout) {\n    stream = (undefined4 *)streamInfo[2];\n  }\n  else if (stream == (undefined4 *)&__sf_fake_stderr) {\n    stream = (undefined4 *)streamInfo[3];\n  }\n  status = *(ushort *)(stream + 3);\n  stream[1] = 0;\n  tempUint = (uint)*(ushort *)(stream + 3);\n  if ((int)(tempUint << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(tempUint << 0x1d) < 0) {\n    if ((undefined4 *)stream[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)stream[0xd] != stream + 0x11) {\n        _free_r(streamInfo);\n      }\n      stream[1] = stream[0x10];\n      stream[0xd] = 0;\n      if (stream[0x10] != 0) {\n        *stream = stream[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(tempUint << 0x1b)) {\n      *streamInfo = 9;\n      status = status | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(tempUint << 0x1c) < 0) {\n      result = _fflush_r(streamInfo,stream,tempUint << 0x1c,tempUint,param_4);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      stream[2] = 0;\n      *(ushort *)(stream + 3) = *(ushort *)(stream + 3) & 0xfff7;\n      stream[6] = 0;\n    }\n    *(ushort *)(stream + 3) = *(ushort *)(stream + 3) | 4;\n  }\n  if (stream[4] == 0) {\n    __smakebuf_r(streamInfo,stream);\n  }\n  status = *(ushort *)(stream + 3);\n  flag = *(undefined2 *)(stream + 3);\n  if ((status & 3) != 0) {\n    *(undefined2 *)(stream + 3) = 1;\n    _fwalk(&impure_data,0x6755);\n    *(undefined2 *)(stream + 3) = flag;\n    if ((status & 9) == 9) {\n      __sflush_r(streamInfo,stream);\n    }\n  }\n  temp = stream[4];\n  *stream = temp;\n  result = (*(code *)stream[9])(streamInfo,stream[8],temp,stream[5]);\n  stream[1] = result;\n  if (0 < result) {\n    return 0;\n  }\n  status = *(ushort *)(stream + 3);\n  if (result != 0) {\n    temp = 0;\n  }\n  else {\n    status = status | 0x20;\n  }\n  if (result != 0) {\n    stream[1] = temp;\n    status = status | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(stream + 3) = status;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00006768": "process_stream_00006768",
                "param_1": "streamInfo",
                "param_2": "stream",
                "uVar1": "flag",
                "iVar2": "result",
                "uVar3": "temp",
                "uVar4": "status",
                "uVar5": "tempUint"
            },
            "calling": [
                "__srget_r"
            ],
            "called": [
                "_fflush_r",
                "__sinit",
                "__smakebuf_r",
                "_fwalk",
                "__sflush_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0000687c": {
            "entrypoint": "0x0000687c",
            "current_name": "expand_pattern_0000687c",
            "code": "\nbyte * expandPattern_0000687c(int patternSize,byte *patternData)\n\n{\n  byte *result;\n  uint temp1;\n  int index;\n  uint patternByte;\n  uint temp2;\n  uint temp3;\n  bool isPatternRepeating;\n  \n  patternByte = (uint)*patternData;\n  isPatternRepeating = patternByte == 0x5e;\n  if (isPatternRepeating) {\n    patternByte = (uint)patternData[1];\n    patternData = patternData + 2;\n  }\n  else {\n    patternData = patternData + 1;\n  }\n  index = patternSize + -1;\n  do {\n    index = index + 1;\n    *(bool *)index = isPatternRepeating;\n  } while (index != patternSize + 0xff);\n  if (patternByte == 0) {\n    result = patternData + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      temp2 = patternByte;\n      *(bool *)(patternSize + temp2) = !isPatternRepeating;\n      patternData = patternData + 1;\n      while( true ) {\n        patternByte = (uint)patternData[-1];\n        if (patternByte != 0x2d) break;\n        temp3 = (uint)*patternData;\n        if ((temp3 == 0x5d) || (temp1 = temp2, (int)temp3 < (int)temp2)) goto LAB_000068aa;\n        do {\n          temp1 = temp1 + 1;\n          *(bool *)(patternSize + temp1) = !isPatternRepeating;\n        } while ((int)temp1 < (int)temp3);\n        index = ~temp2 + temp3;\n        if ((int)temp3 <= (int)temp2) {\n          index = 0;\n        }\n        temp2 = temp2 + 1 + index;\n        patternData = patternData + 2;\n      }\n      result = patternData;\n    } while ((patternByte != 0x5d) && (result = patternData + -1, patternByte != 0));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0000687c": "expand_pattern_0000687c",
                "param_1": "patternSize",
                "param_2": "patternData",
                "pbVar1": "result",
                "uVar2": "temp1",
                "iVar3": "index",
                "uVar4": "patternByte",
                "uVar5": "temp2",
                "uVar6": "temp3",
                "bVar7": "isPatternRepeating"
            },
            "calling": [
                "__ssvfiscanf_r",
                "_scanf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000068f0": {
            "entrypoint": "0x000068f0",
            "current_name": "initialize_flash_config_field_000068f0",
            "code": "\nundefined4 initializeFlashConfigField_000068f0(undefined4 param,void **configParams)\n\n{\n  void *allocatedMemory;\n  void *currentConfigSize;\n  \n  if ((void **)configParams[0xd] == configParams + 0x11) {\n    allocatedMemory = (void *)_malloc_r(param,0x400);\n    if (allocatedMemory != (void *)0x0) {\n      configParams[0xe] = flash_configuration_field;\n      configParams[0xd] = allocatedMemory;\n      *(undefined *)((int)allocatedMemory + 0x3ff) = *(undefined *)((int)configParams + 0x46);\n      *(undefined *)((int)allocatedMemory + 0x3fe) = *(undefined *)((int)configParams + 0x45);\n      *(undefined *)((int)allocatedMemory + 0x3fd) = *(undefined *)(configParams + 0x11);\n      *configParams = (void *)((int)allocatedMemory + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    currentConfigSize = configParams[0xe];\n    allocatedMemory = (void *)_realloc_r(param,configParams[0xd],(void *)((int)currentConfigSize << 1));\n    if (allocatedMemory != (void *)0x0) {\n      memcpy((void *)((int)allocatedMemory + (int)currentConfigSize),allocatedMemory,(size_t)currentConfigSize);\n      configParams[0xd] = allocatedMemory;\n      configParams[0xe] = (void *)((int)currentConfigSize << 1);\n      *configParams = (void *)((int)allocatedMemory + (int)currentConfigSize);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000068f0": "initialize_flash_config_field_000068f0",
                "param_1": "param",
                "param_2": "configParams",
                "pvVar1": "allocatedMemory",
                "__n": "currentConfigSize"
            },
            "calling": [
                "_sungetc_r"
            ],
            "called": [
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006964": {
            "entrypoint": "0x00006964",
            "current_name": "calculate_new_value_00006964",
            "code": "\nint calculateNewValue_00006964(undefined4 inputValue,int arrayIndex)\n\n{\n  int result;\n  \n  result = *(int *)(arrayIndex + -4) + -4;\n  if (*(int *)(arrayIndex + -4) < 0) {\n    result = result + *(int *)(arrayIndex + result);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006964": "calculate_new_value_00006964",
                "param_1": "inputValue",
                "param_2": "arrayIndex",
                "iVar1": "result"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006974": {
            "entrypoint": "0x00006974",
            "current_name": "divide_00006974",
            "code": "\nint divide_00006974(int divide_00006974nd,int divisor,int divide_00006974nd_negative,int divisor_negative)\n\n{\n  int result;\n  undefined temp [8];\n  \n  if ((divisor_negative == 0) && (divide_00006974nd_negative == 0)) {\n    if (divisor < 0) {\n      divide_00006974nd = 0;\n      divisor = -0x80000000;\n    }\n    else if (divisor != 0 || divide_00006974nd != 0) {\n      divisor = 0x7fffffff;\n      divide_00006974nd = -1;\n    }\n    result = __aeabi_idiv0(divide_00006974nd,divisor);\n    return result;\n  }\n  if (divisor < 0) {\n    result = -divisor - (uint)(divide_00006974nd != 0);\n    if (divisor_negative < 0) {\n      result = __udivmoddi4(-divide_00006974nd,result,-divide_00006974nd_negative,-divisor_negative - (uint)(divide_00006974nd_negative != 0),temp);\n      return result;\n    }\n    result = __udivmoddi4(-divide_00006974nd,result,divide_00006974nd_negative,divisor_negative,temp);\n    return -result;\n  }\n  if (divisor_negative < 0) {\n    result = __udivmoddi4(divide_00006974nd,divisor,-divide_00006974nd_negative,-divisor_negative - (uint)(divide_00006974nd_negative != 0),temp);\n    return -result;\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00006974": "divide_00006974",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "dividend_negative",
                "param_4": "divisor_negative",
                "iVar1": "result",
                "local_8": "temp"
            },
            "calling": [
                "gmtime_r"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006a14": {
            "entrypoint": "0x00006a14",
            "current_name": "calculate_division_with_remainder_00006a14",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong calculate_division_with_remainder_00006a14(uint dividend,uint dividend_high,uint divisor,uint remainder,uint *quotient)\n\n{\n  code *jump_table;\n  uint temp;\n  int shift_amount;\n  uint divisor_high;\n  uint original_quotient;\n  uint shifted_divisor;\n  uint temp1;\n  uint temp2;\n  uint reduced_quotient;\n  uint reduced_divisor;\n  bool bVar10;\n  ulonglong result;\n  \n  if (remainder == 0) {\n    if (dividend_high < divisor) {\n      shift_amount = LZCOUNT(divisor);\n      shifted_divisor = divisor;\n      if (shift_amount != 0) {\n        shifted_divisor = divisor << shift_amount;\n        dividend_high = dividend >> (0x20U - shift_amount & 0xff) | dividend_high << shift_amount;\n        dividend = dividend << shift_amount;\n      }\n      temp1 = shifted_divisor >> 0x10;\n      reduced_quotient = dividend_high / temp1;\n      divisor_high = dividend >> 0x10 | (dividend_high - temp1 * reduced_quotient) * 0x10000;\n      temp = reduced_quotient * (shifted_divisor & 0xffff);\n      original_quotient = reduced_quotient;\n      if (divisor_high <= temp && temp - divisor_high != 0) {\n        bVar10 = CARRY4(shifted_divisor,divisor_high);\n        divisor_high = shifted_divisor + divisor_high;\n        original_quotient = reduced_quotient - 1;\n        if ((bVar10 == false) && (divisor_high <= temp && temp - divisor_high != 0)) {\n          original_quotient = reduced_quotient - 2;\n          divisor_high = divisor_high + shifted_divisor;\n        }\n      }\n      reduced_quotient = (divisor_high - temp) / temp1;\n      temp1 = dividend & 0xffff | ((divisor_high - temp) - temp1 * reduced_quotient) * 0x10000;\n      divisor_high = reduced_quotient * (shifted_divisor & 0xffff);\n      temp = reduced_quotient;\n      if (temp1 <= divisor_high && divisor_high - temp1 != 0) {\n        bVar10 = CARRY4(shifted_divisor,temp1);\n        temp1 = shifted_divisor + temp1;\n        temp = reduced_quotient - 1;\n        if ((bVar10 == false) && (temp1 <= divisor_high && divisor_high - temp1 != 0)) {\n          temp = reduced_quotient - 2;\n          temp1 = temp1 + shifted_divisor;\n        }\n      }\n      temp1 = temp1 - divisor_high;\n      temp = temp | original_quotient << 0x10;\n      shifted_divisor = 0;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        jump_table = (code *)software_udf(0xff,0x6abc);\n        result = (*jump_table)();\n        return result;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        dividend_high = dividend_high - divisor;\n        reduced_divisor = divisor >> 0x10;\n        temp2 = divisor & 0xffff;\n        shifted_divisor = 1;\n        original_quotient = divisor;\n      }\n      else {\n        original_quotient = divisor << shift_amount;\n        reduced_divisor = original_quotient >> 0x10;\n        temp = dividend_high >> (0x20U - shift_amount & 0xff);\n        shifted_divisor = dividend >> (0x20U - shift_amount & 0xff) | dividend_high << shift_amount;\n        divisor_high = temp / reduced_divisor;\n        temp2 = original_quotient & 0xffff;\n        reduced_quotient = shifted_divisor >> 0x10 | (temp - reduced_divisor * divisor_high) * 0x10000;\n        temp1 = divisor_high * temp2;\n        dividend = dividend << shift_amount;\n        temp = divisor_high;\n        if (reduced_quotient <= temp1 && temp1 - reduced_quotient != 0) {\n          bVar10 = CARRY4(original_quotient,reduced_quotient);\n          reduced_quotient = original_quotient + reduced_quotient;\n          temp = divisor_high - 1;\n          if ((bVar10 == false) && (reduced_quotient <= temp1 && temp1 - reduced_quotient != 0)) {\n            temp = divisor_high - 2;\n            reduced_quotient = reduced_quotient + original_quotient;\n          }\n        }\n        divisor_high = (reduced_quotient - temp1) / reduced_divisor;\n        dividend_high = shifted_divisor & 0xffff | ((reduced_quotient - temp1) - reduced_divisor * divisor_high) * 0x10000;\n        temp1 = divisor_high * temp2;\n        shifted_divisor = divisor_high;\n        if (dividend_high <= temp1 && temp1 - dividend_high != 0) {\n          bVar10 = CARRY4(original_quotient,dividend_high);\n          dividend_high = original_quotient + dividend_high;\n          shifted_divisor = divisor_high - 1;\n          if ((bVar10 == false) && (dividend_high <= temp1 && temp1 - dividend_high != 0)) {\n            shifted_divisor = divisor_high - 2;\n            dividend_high = dividend_high + original_quotient;\n          }\n        }\n        dividend_high = dividend_high - temp1;\n        shifted_divisor = shifted_divisor | temp << 0x10;\n      }\n      reduced_quotient = dividend_high / reduced_divisor;\n      temp1 = dividend >> 0x10 | (dividend_high - reduced_divisor * reduced_quotient) * 0x10000;\n      temp = temp2 * reduced_quotient;\n      divisor_high = reduced_quotient;\n      if (temp1 <= temp && temp - temp1 != 0) {\n        bVar10 = CARRY4(original_quotient,temp1);\n        temp1 = original_quotient + temp1;\n        divisor_high = reduced_quotient - 1;\n        if ((bVar10 == false) && (temp1 <= temp && temp - temp1 != 0)) {\n          divisor_high = reduced_quotient - 2;\n          temp1 = temp1 + original_quotient;\n        }\n      }\n      reduced_quotient = (temp1 - temp) / reduced_divisor;\n      temp1 = dividend & 0xffff | ((temp1 - temp) - reduced_divisor * reduced_quotient) * 0x10000;\n      temp2 = temp2 * reduced_quotient;\n      temp = reduced_quotient;\n      if (temp1 <= temp2 && temp2 - temp1 != 0) {\n        bVar10 = CARRY4(original_quotient,temp1);\n        temp1 = original_quotient + temp1;\n        temp = reduced_quotient - 1;\n        if ((bVar10 == false) && (temp1 <= temp2 && temp2 - temp1 != 0)) {\n          temp = reduced_quotient - 2;\n          temp1 = temp1 + original_quotient;\n        }\n      }\n      temp1 = temp1 - temp2;\n      temp = temp | divisor_high << 0x10;\n    }\n    if (quotient != (uint *)0x0) {\n      *quotient = temp1 >> LZCOUNT(divisor);\n      quotient[1] = 0;\n    }\n  }\n  else if (dividend_high < remainder) {\n    if (quotient != (uint *)0x0) {\n      *quotient = dividend;\n      quotient[1] = dividend_high;\n      return 0;\n    }\n    temp = 0;\n    shifted_divisor = 0;\n  }\n  else {\n    shift_amount = LZCOUNT(remainder);\n    if (shift_amount != 0) {\n      temp2 = 0x20 - shift_amount;\n      divisor_high = divisor >> (temp2 & 0xff) | remainder << shift_amount;\n      reduced_divisor = divisor_high >> 0x10;\n      temp = dividend_high >> (temp2 & 0xff);\n      shifted_divisor = dividend >> (temp2 & 0xff) | dividend_high << shift_amount;\n      temp1 = temp / reduced_divisor;\n      original_quotient = shifted_divisor >> 0x10 | (temp - reduced_divisor * temp1) * 0x10000;\n      reduced_quotient = temp1 * (divisor_high & 0xffff);\n      dividend = dividend << shift_amount;\n      temp = temp1;\n      if (original_quotient <= reduced_quotient && reduced_quotient - original_quotient != 0) {\n        bVar10 = CARRY4(divisor_high,original_quotient);\n        original_quotient = divisor_high + original_quotient;\n        temp = temp1 - 1;\n        if ((bVar10 == false) && (original_quotient <= reduced_quotient && reduced_quotient - original_quotient != 0)) {\n          temp = temp1 - 2;\n          original_quotient = original_quotient + divisor_high;\n        }\n      }\n      temp1 = (original_quotient - reduced_quotient) / reduced_divisor;\n      original_quotient = shifted_divisor & 0xffff | ((original_quotient - reduced_quotient) - reduced_divisor * temp1) * 0x10000;\n      reduced_quotient = temp1 * (divisor_high & 0xffff);\n      shifted_divisor = temp1;\n      if (original_quotient <= reduced_quotient && reduced_quotient - original_quotient != 0) {\n        bVar10 = CARRY4(divisor_high,original_quotient);\n        original_quotient = divisor_high + original_quotient;\n        shifted_divisor = temp1 - 1;\n        if ((bVar10 == false) && (original_quotient <= reduced_quotient && reduced_quotient - original_quotient != 0)) {\n          shifted_divisor = temp1 - 2;\n          original_quotient = original_quotient + divisor_high;\n        }\n      }\n      shifted_divisor = shifted_divisor | temp << 0x10;\n      result = (ulonglong)shifted_divisor * (ulonglong)(divisor << shift_amount);\n      if (CONCAT44(original_quotient - reduced_quotient,dividend) < result) {\n        result = result - CONCAT44(divisor_high,divisor << shift_amount);\n        shifted_divisor = shifted_divisor - 1;\n      }\n      if (quotient != (uint *)0x0) {\n        temp = ((original_quotient - reduced_quotient) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *quotient = temp << (temp2 & 0xff) | dividend - (uint)result >> shift_amount;\n        quotient[1] = temp >> shift_amount;\n      }\n      return (ulonglong)shifted_divisor;\n    }\n    if ((remainder < dividend_high) || (divisor <= dividend)) {\n      bVar10 = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_high = (dividend_high - remainder) - (uint)bVar10;\n      temp = 1;\n    }\n    else {\n      temp = 0;\n    }\n    shifted_divisor = 0;\n    if (quotient != (uint *)0x0) {\n      *quotient = dividend;\n      quotient[1] = dividend_high;\n    }\n  }\n  return CONCAT44(shifted_divisor,temp);\n}\n\n",
            "renaming": {
                "FUN_00006a14": "calculate_division_with_remainder_00006a14",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "remainder",
                "param_5": "quotient",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "uVar1": "temp",
                "iVar2": "shift_amount",
                "uVar3": "divisor_high",
                "uVar4": "original_quotient",
                "uVar5": "shifted_divisor",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "uVar8": "reduced_quotient",
                "uVar9": "reduced_divisor",
                "uVar11": "result"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00006cd4": {
            "entrypoint": "0x00006cd4",
            "current_name": "FUNC_00006cd4",
            "code": "\nvoid FUNC_00006cd4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00006cd4": "FUNC_00006cd4"
            },
            "calling": [
                "__aeabi_ldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 144492,
    "layers": [
        [
            "FUN_00000410",
            "FUN_00000428",
            "FUN_00000490",
            "FUN_000004b2",
            "FUN_000004d4",
            "FUN_000004f2",
            "FUN_00000514",
            "FUN_00000534",
            "FUN_00000566",
            "FUN_0000058e",
            "FUN_000005ca",
            "FUN_00000610",
            "FUN_00000698",
            "FUN_00000738",
            "FUN_00000794",
            "FUN_000007dc",
            "FUN_000008b8",
            "FUN_00000900",
            "FUN_0000091c",
            "FUN_00000930",
            "FUN_0000093c",
            "FUN_00000958",
            "FUN_00000974",
            "FUN_00000978",
            "FUN_0000099c",
            "FUN_00000a30",
            "FUN_00000a40",
            "FUN_00000a64",
            "FUN_00000aa8",
            "FUN_00000c80",
            "FUN_00000c90",
            "FUN_00000ca0",
            "FUN_00000cb0",
            "FUN_00000cc0",
            "FUN_00000cd0",
            "FUN_00000cf0",
            "FUN_00000d0c",
            "FUN_00000d2a",
            "FUN_00000d44",
            "FUN_00000d76",
            "FUN_00000d9c",
            "FUN_00000db0",
            "FUN_00000dc0",
            "FUN_00000dcc",
            "FUN_00000df4",
            "FUN_00000e14",
            "FUN_00000e38",
            "FUN_00000e58",
            "FUN_00000e64",
            "FUN_00000ed8",
            "FUN_00000f04",
            "FUN_00000f5c",
            "FUN_00000f80",
            "FUN_00000f8c",
            "FUN_00000fec",
            "FUN_00001034",
            "FUN_000010a0",
            "FUN_000010d4",
            "FUN_00001274",
            "FUN_0000129c",
            "FUN_000012b4",
            "FUN_000012e2",
            "FUN_00001318",
            "FUN_00001348",
            "FUN_00001360",
            "FUN_00001392",
            "FUN_000013b8",
            "FUN_00001448",
            "FUN_000014c4",
            "FUN_000015d0",
            "FUN_00001628",
            "FUN_00001688",
            "FUN_00001696",
            "FUN_000016c8",
            "FUN_000016ec",
            "FUN_00001710",
            "FUN_00001734",
            "FUN_00001748",
            "FUN_00001778",
            "FUN_000017dc",
            "FUN_0000182c",
            "FUN_000018bc",
            "FUN_0000191c",
            "FUN_00001960",
            "FUN_000019c0",
            "FUN_00001a18",
            "FUN_00001a3c",
            "FUN_00001a60",
            "FUN_00001ad4",
            "FUN_00001b10",
            "FUN_00001bb8",
            "FUN_00001c84",
            "FUN_00001cf0",
            "FUN_00001d08",
            "FUN_00001d3a",
            "FUN_00001d5e",
            "FUN_00001d80",
            "FUN_00001da2",
            "FUN_00001dc0",
            "FUN_00001ddc",
            "FUN_00001e0c",
            "FUN_00001e44",
            "FUN_00001ec4",
            "FUN_00001eea",
            "FUN_00001f80",
            "FUN_00001ff6",
            "FUN_00002028",
            "FUN_000020b8",
            "FUN_000020cc",
            "FUN_000020e0",
            "FUN_000020f4",
            "FUN_00002108",
            "FUN_0000211c",
            "FUN_00002270",
            "FUN_00002294",
            "FUN_000022be",
            "FUN_000022f0",
            "FUN_0000231c",
            "FUN_00002364",
            "FUN_00002396",
            "FUN_000023a4",
            "FUN_000023c8",
            "FUN_000023d0",
            "FUN_0000240c",
            "FUN_00002434",
            "FUN_000024bc",
            "FUN_00002538",
            "FUN_0000258c",
            "FUN_000025f4",
            "FUN_00002600",
            "FUN_00002624",
            "FUN_00002654",
            "FUN_00002690",
            "FUN_000026c0",
            "FUN_000026d8",
            "FUN_000026e4",
            "FUN_000026f0",
            "FUN_00002714",
            "FUN_00002744",
            "FUN_00002798",
            "FUN_000027b0",
            "FUN_0000281c",
            "FUN_0000285c",
            "FUN_00002894",
            "FUN_000028f0",
            "FUN_00002910",
            "FUN_0000294c",
            "FUN_00002970",
            "FUN_00002994",
            "FUN_00002a00",
            "FUN_00002a18",
            "FUN_00002a88",
            "FUN_00002b10",
            "FUN_00002d94",
            "FUN_00002e48",
            "FUN_00002e6c",
            "FUN_00002e9c",
            "FUN_00002eb4",
            "FUN_00002ecc",
            "FUN_00002f30",
            "FUN_00002f74",
            "FUN_00002fe0",
            "FUN_0000305c",
            "FUN_0000316c",
            "FUN_000031e0",
            "FUN_000031fc",
            "FUN_0000328c",
            "FUN_00003378",
            "FUN_000033c0",
            "FUN_000033f4",
            "FUN_00003444",
            "FUN_00003478",
            "FUN_000034c0",
            "FUN_00003524",
            "FUN_00003658",
            "FUN_00003688",
            "FUN_00003694",
            "FUN_00003810",
            "FUN_00003918",
            "FUN_000039e8",
            "FUN_00003d24",
            "FUN_00003d64",
            "FUN_00003d94",
            "FUN_00003dc4",
            "FUN_00003e58",
            "FUN_00003e9e",
            "FUN_00003ec4",
            "FUN_00003ff4",
            "FUN_00004042",
            "FUN_0000404c",
            "FUN_00004158",
            "FUN_000041d0",
            "FUN_000041f4",
            "FUN_0000423c",
            "FUN_00004248",
            "FUN_00004274",
            "FUN_00004280",
            "FUN_0000428c",
            "FUN_00004298",
            "FUN_000042a4",
            "FUN_00004314",
            "FUN_000043a0",
            "FUN_000043da",
            "FUN_00004418",
            "FUN_0000443c",
            "FUN_0000459c",
            "FUN_000045ee",
            "FUN_00004622",
            "FUN_00004634",
            "FUN_000047e4",
            "FUN_00004b34",
            "FUN_00004bd0",
            "FUN_00004c84",
            "FUN_00004cb4",
            "FUN_00004cdc",
            "FUN_00004db8",
            "FUN_00004dc8",
            "FUN_00004dea",
            "FUN_00004dee",
            "FUN_00004e26",
            "FUN_00004e4a",
            "FUN_00004e52",
            "FUN_00004e66",
            "FUN_00004e8c",
            "FUN_00004f84",
            "FUN_00004f98",
            "FUN_000050e8",
            "FUN_000050f4",
            "FUN_00005100",
            "FUN_0000510c",
            "FUN_00005404",
            "FUN_000054a8",
            "FUN_00005584",
            "FUN_000055ac",
            "FUN_0000562c",
            "FUN_000056a0",
            "FUN_000056b0",
            "FUN_000056b8",
            "FUN_00005700",
            "FUN_00005780",
            "FUN_00005790",
            "FUN_0000579c",
            "FUN_000057a8",
            "FUN_000057d2",
            "FUN_000057f8",
            "FUN_00005a58",
            "FUN_00005b34",
            "FUN_00005d80",
            "FUN_00005e10",
            "FUN_00005e68",
            "FUN_00005ebc",
            "FUN_00005ecc",
            "FUN_00005edc",
            "FUN_00005fd8",
            "FUN_00005fec",
            "FUN_00005ff8",
            "FUN_00006010",
            "FUN_000060b0",
            "FUN_000060cc",
            "FUN_00006118",
            "FUN_00006192",
            "FUN_000061cc",
            "FUN_000064bc",
            "FUN_0000656c",
            "FUN_00006754",
            "FUN_00006768",
            "FUN_0000687c",
            "FUN_000068f0",
            "FUN_00006964",
            "FUN_00006974",
            "FUN_00006a14"
        ]
    ],
    "locked_functions": []
}