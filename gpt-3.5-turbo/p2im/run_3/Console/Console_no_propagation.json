{
    "functions": {
        "FUN_000026c0": {
            "renaming": {
                "FUN_000026c0": "initializePointerToZero_000026c0",
                "FUN_00002910": "callFunctionToInitialize",
                "PTR_DAT_000026d4": "pointerToData"
            },
            "code": "void initializePointerToZero_000026c0(void)\n{\n  callFunctionToInitialize();\n  *(undefined4 *)PTR_DAT_000026d4 = 0;\n  return;\n}",
            "called": [
                "FUN_00002910"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initializePointerToZero_000026c0"
        },
        "FUN_00004bd0": {
            "renaming": {
                "FUN_00004bd0": "allocate_memory_block_00004bd0",
                "param_1": "out_param",
                "param_2": "requested_size",
                "puVar1": "unused_pointer",
                "uVar2": "allocation_result",
                "puVar3": "previous_block_ptr",
                "iVar4": "padding_size",
                "uVar5": "remaining_size",
                "puVar6": "current_block_ptr",
                "uVar7": "aligned_size"
            },
            "code": "uint allocate_memory_block_00004bd0(undefined4 *out_param, uint requested_size, undefined4 param_3, undefined4 param_4)\n{\n  uint aligned_size;\n  uint *current_block_ptr;\n  uint remaining_size;\n  uint *previous_block_ptr;\n  uint block_size;\n  uint *new_block_ptr;\n  \n  aligned_size = (requested_size + 3 & 0xfffffffc) + 8;\n  if (aligned_size < 0xc) {\n    aligned_size = 0xc;\n  }\n  if (((int)aligned_size < 0) || (aligned_size < requested_size)) {\n    *out_param = 0xc;\n  }\n  else {\n    acquire_memory_lock();\n    previous_block_ptr = PTR_DAT_00004c7c;\n    current_block_ptr = *(uint **)PTR_DAT_00004c7c;\n    for (new_block_ptr = *(uint **)PTR_DAT_00004c7c; new_block_ptr != (uint *)0x0; new_block_ptr = (uint *)new_block_ptr[1]) {\n      remaining_size = *new_block_ptr - aligned_size;\n      if (-1 < (int)remaining_size) {\n        if (0xb < remaining_size) {\n          *new_block_ptr = remaining_size;\n          new_block_ptr = (uint *)((int)new_block_ptr + remaining_size);\n          goto LAB_00004c34;\n        }\n        block_size = new_block_ptr[1];\n        if (current_block_ptr == new_block_ptr) {\n          *(uint **)PTR_DAT_00004c7c = (uint *)block_size;\n        }\n        if (current_block_ptr != new_block_ptr) {\n          current_block_ptr[1] = block_size;\n        }\n        goto LAB_00004c42;\n      }\n      previous_block_ptr = new_block_ptr;\n    }\n    if (*(int *)PTR_DAT_00004c80 == 0) {\n      uint allocation_result = FUN_00000428(out_param, 0, previous_block_ptr, 0, param_4);\n      *(undefined4 *)PTR_DAT_00004c80 = allocation_result;\n    }\n    current_block_ptr = (uint *)FUN_00000428(out_param, aligned_size);\n    if ((current_block_ptr != (uint *)0xffffffff) && ((new_block_ptr = (uint *)((int)current_block_ptr + 3U & 0xfffffffc), current_block_ptr == new_block_ptr || (block_size = FUN_00000428(out_param, (int)new_block_ptr - (int)current_block_ptr), block_size != -1)))) {\n      *new_block_ptr = aligned_size;\nLAB_00004c42:\n      release_memory_lock();\n      uint block_end = (int)new_block_ptr + 0xbU & 0xfffffff8;\n      int padding_size = block_end - (int)(new_block_ptr + 1);\n      if (padding_size == 0) {\n        return block_end;\n      }\n      *(uint *)((int)new_block_ptr + padding_size) = (int)(new_block_ptr + 1) - block_end;\n      return block_end;\n    }\n    *out_param = 0xc;\n    release_memory_lock();\n  }\n  return 0;\n}",
            "called": [
                "FUN_00000428",
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004bd0",
            "calling": [
                "FUN_000068f0",
                "FUN_00005100",
                "FUN_00004248",
                "FUN_000060cc",
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00004bd0"
        },
        "FUN_00000794": {
            "renaming": {
                "FUN_00000794": "allocate_memory_00000794",
                "extraout_r1": "extra_out",
                "iVar1": "memory_size",
                "puVar2": "memory_ptr",
                "uVar3": "aligned_offset",
                "iStack_1c": "i",
                "iStack_18": "i",
                "piStack_14": "memory_ptr",
                "FUN_00000cd0": "initialize_memory",
                "*psRam000007cc": "*memory_offset",
                "iRam000007d0": "memory_start",
                "*piRam000007d4": "*memory_end",
                "puRam000007d8": "memory_ptr_start",
                "FUN_00000698": "set_memory",
                "DAT_000008b4": "memory_constant"
            },
            "code": "int* allocate_memory_00000794(void)\n{\n    int extra_out;\n    int memory_offset;\n    int memory_size;\n    int* memory_ptr;\n    uint aligned_offset;\n\n    initialize_memory();\n\n    *(undefined4 *)(iRam000007d0 + *psRam000007cc * 4) = 0;\n    *piRam000007d4 = *piRam000007d4 - 1;\n    FUN_00000698(*puRam000007d8, 0);\n\n    memory_ptr = puRam000007d8;\n    memory_size = 0;\n    *puRam000007d8 = 0;\n    calculate_memory_size(&memory_size);\n\n    aligned_offset = (int)memory_ptr + memory_size & 0xfffffffc;\n    memory_offset = aligned_offset - 4;\n    memory_ptr = (int *)memory_offset;\n\n    *memory_ptr = 0x77777777;\n    if (((uint)memory_ptr & 7) != 0)\n    {\n        memory_offset = aligned_offset - 8;\n        memory_ptr = (int *)memory_offset;\n        *memory_ptr = 0x88888888;\n    }\n\n    memory_ptr[-1] = 0x1000000;\n    memory_ptr[-2] = memory_size << 0xd;\n    memory_ptr[-3] = DAT_000008b4;\n    memory_ptr = memory_ptr - 4;\n    *memory_ptr = 0;\n\n    for (int i = 3; i > 0; i--)\n    {\n        memory_ptr = memory_ptr - 1;\n        *memory_ptr = i;\n    }\n\n    memory_ptr = memory_ptr - 1;\n    *memory_ptr = extra_out;\n\n    for (int i = 0xb; i > 3; i--)\n    {\n        memory_ptr = memory_ptr - 1;\n        *memory_ptr = i;\n    }\n\n    memory_ptr[-1] = -3;\n    return memory_ptr - 1;\n}",
            "called": [
                "FUN_00000cd0",
                "FUN_00000930",
                "FUN_00000698"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000794",
            "calling": [],
            "imported": false,
            "current_name": "allocate_memory_00000794"
        },
        "FUN_000064bc": {
            "renaming": {
                "FUN_000064bc": "process_data_000064bc",
                "param_1": "data",
                "param_2": "counter",
                "param_3": "buffer",
                "param_4": "callback",
                "puVar1": "data_ptr",
                "iVar2": "result",
                "uVar3": "count",
                "ppbVar4": "buffer_ptr",
                "pbVar5": "next_data",
                "unaff_r6": "output_buffer",
                "pbVar6": "current_output",
                "iVar7": "index"
            },
            "code": "int process_data_000064bc(int data, uint *counter, byte **buffer, int *callback)\n{\n  int index = 0;\n  byte *output_buffer = NULL;\n  if (counter[2] == 0) {\n    if (counter[6] == 0) {\n      counter[2] = 1;\n    }\n    else {\n      counter[2] = 0xffffffff;\n    }\n  }\n  byte *data_buffer = *buffer;\n  if (-1 < (int)(*counter << 0x1b)) {\n    byte **buffer_ptr = (byte **)*callback;\n    *callback = buffer_ptr + 1;\n    output_buffer = *buffer_ptr;\n  }\n  do {\n    uint count = counter[6];\n    if (count != 0) {\n      if (count == 1) {\n        if (*(char *)(counter[5] + (uint)**buffer) == '\\0') {\n          if (index == 0) {\n            return 1;\n          }\n          if (((*counter & 0x10) == 0) && (counter[3] = counter[3] + 1, counter[6] != 0)) {\n            *output_buffer = 0;\n          }\n          counter[4] = index + counter[4];\n          return 0;\n        }\n      }\n      else if ((count != 2) || ((int)((uint)(byte)data_buffer[**buffer] << 0x1c) < 0))\n        goto LAB_0000654a;\n    }\n    byte *current_output = output_buffer;\n    if (-1 < (int)(*counter << 0x1b)) {\n      current_output = output_buffer + 1;\n      *output_buffer = **buffer;\n    }\n    byte *next_data = (*buffer)[1];\n    *buffer = *buffer + 1;\n    count = counter[2] - 1;\n    (*buffer)[1] = next_data + -1;\n    index = index + 1;\n    counter[2] = count;\n    output_buffer = current_output;\n    if ((count == 0) || (((int)(next_data + -1) < 1 && (iVar2 = (*(code *)counter[0x60])(data, buffer, count, (code *)counter[0x60], callback), iVar2 != 0))))\n      goto LAB_0000654a;\n  } while(true);\n\nLAB_0000654a:\n  if (((*counter & 0x10) == 0) && (counter[3] = counter[3] + 1, counter[6] != 0)) {\n    *output_buffer = 0;\n  }\n  counter[4] = index + counter[4];\n  return 0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000064bc",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "process_data_000064bc"
        },
        "FUN_00002970": {
            "renaming": {
                "FUN_00002970": "clear_bit_in_uint_at_offset_from_dat_00002970",
                "DAT_00002990": "dat",
                "PTR_": "ptr",
                "uint": "unsigned_int",
                "offset": "offset",
                "uint_ptr": "unsigned_int_ptr",
                "mask": "mask"
            },
            "code": "void clear_bit_in_uint_at_offset_from_dat_00002970(uint offset)\n{\n  uint* uint_PTR_ = (uint*)(DAT_00002990 + offset);\n  uint mask = 0xffffffef;\n  *uint_PTR_ = *uint_PTR_ & mask;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002970",
            "calling": [
                "FUN_000026e4"
            ],
            "imported": false,
            "current_name": "clear_bit_in_uint_at_offset_from_dat_00002970"
        },
        "FUN_00000dc0": {
            "renaming": {
                "FUN_00000dc0": "execute_function_00000dc0",
                "FUN_00000cc0": "call_another_function"
            },
            "code": "void execute_function_00000dc0(void)\n{\n  call_another_function();\n  return;\n}",
            "called": [
                "FUN_00000cc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dc0",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_00000dc0"
        },
        "FUN_00000d0c": {
            "renaming": {
                "FUN_00000d0c": "enableIRQInterruptsIfPrivileged_00000d0c",
                "param_1": "interruptFlag",
                "bVar1": "isPrivileged"
            },
            "code": "void enableIRQInterruptsIfPrivileged_00000d0c(uint interruptFlag)\n{\n  bool isPrivileged = (bool)isCurrentModePrivileged();\n  if (isPrivileged) {\n    enableIRQinterrupts((interruptFlag & 1) == 1);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d0c",
            "calling": [
                "FUN_00001c84",
                "FUN_00000428",
                "FUN_000024bc",
                "FUN_000010d4",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "enableIRQInterruptsIfPrivileged_00000d0c"
        },
        "FUN_00003d94": {
            "renaming": {
                "FUN_00003d94": "execute_function_00003d94",
                "param_1": "function_pointer",
                "param_2": "arg2",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d94(int function_pointer, int arg1, int arg2) {\n  int result;\n  if (function_pointer == 0) {\n    result = -19;\n  }\n  else {\n    result = (**(int (**)(int, int))(**(int *)(function_pointer + 12) + 4))(arg1, arg2);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d94",
            "calling": [
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "execute_function_00003d94"
        },
        "FUN_0000579c": {
            "renaming": {
                "FUN_0000579c": "do_nothing_with_pointer_0000579c",
                "PTR_DAT_000057a4": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_0000579c(void)\n{\n  do_nothing(PTR_DAT_000057a4);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000579c",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_0000579c"
        },
        "FUN_000015d0": {
            "renaming": {
                "FUN_000015d0": "copy_data_to_memory_000015d0",
                "param_1": "start_index",
                "param_2": "dest_address",
                "param_3": "data_length",
                "iVar1": "memory_address",
                "local_c": "i"
            },
            "code": "void copy_data_to_memory_000015d0(int start_index, int dest_address, uint data_length) {\n  int memory_address = *(int *)(PTR_DAT_00001624 + start_index * 0x20);\n  for (uint i = 0; i < data_length; i++) {\n    do {\n    } while (-1 < *(char *)(memory_address + 4));\n    *(undefined *)(memory_address + 7) = *(undefined *)(i + dest_address);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000015d0",
            "calling": [
                "FUN_00000e38"
            ],
            "imported": false,
            "current_name": "copy_data_to_memory_000015d0"
        },
        "FUN_00005e68": {
            "renaming": {
                "FUN_00005e68": "process_data_00005e68",
                "param_1": "input_data",
                "param_2": "input_size",
                "param_3": "output_data",
                "param_4": "output_size",
                "local_80": "local_input_copy",
                "local_7c": "local_output_copy",
                "local_74": "constant_0x204",
                "local_72": "constant_0xFFFF",
                "local_70": "local_input_copy",
                "uStack_8": "local_1C",
                "uStack_4": "local_18",
                "local_5c": "local_pointer_to_data",
                "local_4c": "local_zero",
                "local_38": "unknown_variable"
            },
            "code": "void process_data_00005e68(undefined4 input_data, undefined4 input_size, undefined4 output_data, undefined4 output_size)\n{\n    undefined4 local_input_copy;\n    undefined4 local_output_copy;\n    undefined2 constant_0x204 = 0x204;\n    undefined2 constant_0xFFFF = 0xFFFF;\n    undefined4 local_1C;\n    undefined4 local_18;\n    undefined *local_pointer_to_data = PTR_LAB_00004dea_1_00005eb4;\n    undefined4 local_zero = 0;\n\n    local_input_copy = input_data;\n    local_output_copy = input_data;\n    local_1C = input_size;\n    local_18 = output_size;\n    local_1C = FUN_00005ecc();\n    local_74 = constant_0x204;\n    local_72 = constant_0xFFFF;\n    local_6c = local_1C;\n    FUNC_000061cc(*DAT_00005eb8, &local_input_copy, &local_1C, &local_output_copy);\n    return;\n}\n",
            "called": [
                "FUN_00005ecc",
                "FUN_000061cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e68",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "process_data_00005e68"
        },
        "FUN_00000dcc": {
            "renaming": {
                "FUN_00000dcc": "set_data_00000dcc",
                "DAT_00000df0": "data_pointer"
            },
            "code": "void set_data_00000dcc(void)\n{\n    int* DAT_00000df0 = DAT_00000df0;\n    DAT_00000df0[7] = 0xc520;\n    DAT_00000df0[7] = 0xd928;\n    *DAT_00000df0 = 0xd2;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000dcc",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "set_data_00000dcc"
        },
        "FUN_0000285c": {
            "renaming": {
                "FUN_0000285c": "set_flag_and_store_value_in_array_0000285c",
                "param_1": "value_to_store",
                "puVar1": "array_pointer"
            },
            "code": "void set_flag_and_store_value_in_array_0000285c(int32_t value_to_store)\n{\n  int32_t *array_pointer;\n  array_pointer = DAT_00002890;\n  DAT_00002890[5] &= 0xffffffef;\n  *array_pointer = value_to_store;\n  array_pointer[5] |= 0x10;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000285c",
            "calling": [
                "FUN_00002600"
            ],
            "imported": false,
            "current_name": "set_flag_and_store_value_in_array_0000285c"
        },
        "FUN_00000e58": {
            "renaming": {
                "FUN_00000e58": "run_infinite_loop_00000e58",
                "FUN_00000cd0": "initialize_system"
            },
            "code": "void run_infinite_loop_00000e58(void)\n{\n  initialize_system();\n  while(true) {\n    // Do nothing, just loop infinitely\n  }\n}",
            "called": [
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e58",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "run_infinite_loop_00000e58"
        },
        "FUN_00001778": {
            "renaming": {
                "FUN_00001778": "set_bit_00001778",
                "DAT_000017d0": "data",
                "DAT_000017d8": "data_to_set",
                "byte": "uint8_t",
                "PTR_": "ptr_",
                "DAT_": "dat_",
                "FUN_": "fun_"
            },
            "code": "void set_bit_00001778(byte *DAT_000017d0, int bit_position) {\n  byte mask = 0x20;\n  byte* target_byte = DAT_000017d0 + 1;\n  *target_byte = (*target_byte & ~(1 << bit_position)) | (mask << bit_position);\n  set_DAT_000017d0(DAT_000017d8, 2);\n}\n",
            "called": [
                "FUN_00001710",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001778",
            "calling": [
                "FUN_000019c0",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_bit_00001778"
        },
        "FUN_000026d8": {
            "renaming": {
                "FUN_000026d8": "initiate_system_000026d8",
                "FUN_0000294c": "initialize_components"
            },
            "code": "void initiate_system_000026d8(void)\n{\n  initialize_components();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026d8",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "initiate_system_000026d8"
        },
        "FUN_00000566": {
            "renaming": {
                "FUN_00000566": "count_leading_zeroes_in_four_bytes_00000566",
                "param_1": "input",
                "bVar1": "byte_1",
                "bVar2": "byte_2",
                "bVar3": "byte_3",
                "bVar4": "byte_4",
                "uVar5": "leading_zeroes_count"
            },
            "code": "uint32_t count_leading_zeroes_in_four_bytes_00000566(uint32_t input)\n{\n  uint8_t byte_1 = (uint8_t)input;\n  uint8_t byte_2 = (uint8_t)(input >> 8);\n  uint8_t byte_3 = (uint8_t)(input >> 16);\n  uint8_t byte_4 = (uint8_t)(input >> 24);\n  uint32_t concatenated_input = (byte_1 << 24) | (byte_2 << 16) | (byte_3 << 8) | byte_4;\n  uint32_t leading_zeroes_count = count_leading_zeroes(concatenated_input);\n  if (input == 0) {\n    leading_zeroes_count = 32;\n  }\n  return leading_zeroes_count;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000566",
            "calling": [
                "FUN_00000610"
            ],
            "imported": false,
            "current_name": "count_leading_zeroes_in_four_bytes_00000566"
        },
        "FUN_00001d08": {
            "renaming": {
                "FUN_00001d08": "calculate_result_00001d08",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "code": "int calculate_result_00001d08(uint input_value, int multiplier) {\n    uint masked_value = input_value & 0xf0000000;\n    uint shifted_value = (input_value & 0xfffff) << 5;\n    int result = (multiplier * 4) + masked_value + shifted_value + 0x2000000;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d08",
            "calling": [
                "FUN_00001d3a"
            ],
            "imported": false,
            "current_name": "calculate_result_00001d08"
        },
        "FUN_000031fc": {
            "renaming": {
                "FUN_000031fc": "calculate_result_000031fc",
                "param_1": "input",
                "param_2": "value1",
                "param_3": "value2",
                "iVar2": "result",
                "bVar1": "value1_byte"
            },
            "code": "int calculate_result_000031fc(int input, int value1, int value2)\n{\n  int result = value1;\n  if (value1 < 3) {\n    result = 1;\n  }\n  byte value1_byte = (byte)result;\n  if (2 < value1) {\n    value1_byte = 0;\n  }\n  input = input - (uint)value1_byte;\n  result = input;\n  if (input < 0) {\n    result = input + 3;\n  }\n  result = (((result >> 2) + input) - (int)((longlong)DAT_00003280 * (longlong)input >> 0x25)) + (int)((longlong)DAT_00003280 * (longlong)input >> 0x27) + *(int *)(DAT_00003284 + (value1 + -1) * 4) + value2;\n  return result + (((int)((ulonglong)((longlong)DAT_00003288 * (longlong)result) >> 0x20) + result >> 2) - (result >> 0x1f)) * -7;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031fc",
            "calling": [
                "FUN_0000328c"
            ],
            "imported": false,
            "current_name": "calculate_result_000031fc"
        },
        "FUN_000016ec": {
            "renaming": {
                "FUN_000016ec": "set_pointer_to_one_000016ec",
                "param_1": "arg1",
                "param_2": "arg2",
                "puVar1": "pointer_to_undefined",
                "FUN_00001696": "get_pointer_to_undefined"
            },
            "code": "void set_pointer_to_one_000016ec(undefined4 arg1, undefined arg2) {\n  undefined *pointer_to_undefined;\n  pointer_to_undefined = (undefined *)get_pointer_to_undefined(arg1, arg2);\n  *pointer_to_undefined = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016ec",
            "calling": [
                "FUN_0000182c",
                "FUN_00001a18",
                "FUN_00001a60",
                "FUN_00001778",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "set_pointer_to_one_000016ec"
        },
        "FUN_00005100": {
            "renaming": {
                "FUN_00005100": "FUNC_00005100"
            },
            "code": "\nvoid FUNC_00005100(void)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined4 *puVar3;\n  undefined4 uVar4;\n  int iVar5;\n  char *pcVar6;\n  int iVar7;\n  int iVar8;\n  char cVar9;\n  char *pcVar10;\n  bool bVar11;\n  ushort *puVar12;\n  int *piVar13;\n  ushort *puVar14;\n  int *piVar15;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  uVar4 = *DAT_00005108;\n  iVar5 = FUN_000056b0();\n  puVar1 = PTR_DAT_000053d8;\n  pcVar6 = (char *)FUN_000056a0(uVar4,PTR_DAT_000053d4);\n  puVar2 = PTR_DAT_000053e0;\n  if (pcVar6 == (char *)0x0) {\n    *(undefined4 *)PTR_DAT_000053dc = 0;\n    *(undefined4 *)PTR_DAT_000053e4 = 0;\n    puVar3 = DAT_000053e8;\n    uVar4 = *(undefined4 *)puVar1;\n    *DAT_000053e8 = puVar2;\n    puVar3[1] = puVar2;\n    FUN_00005780(uVar4);\n    *(undefined4 *)puVar1 = 0;\n  }\n  else if ((*(int *)puVar1 == 0) || (iVar7 = FUN_00004e52(), iVar7 != 0)) {\n    FUN_00005780(*(undefined4 *)puVar1);\n    iVar7 = FUN_00005ecc(pcVar6);\n    iVar7 = FUN_00004bd0(uVar4,iVar7 + 1);\n    *(int *)puVar1 = iVar7;\n    if (iVar7 != 0) {\n      FUN_00005ebc(iVar7,pcVar6);\n    }\n    if (*pcVar6 == ':') {\n      pcVar6 = pcVar6 + 1;\n    }\n    iVar7 = FUN_00005e68(pcVar6,PTR_s__10__0_9_____n_000053f0,PTR_DAT_000053ec,&local_30);\n    if (0 < iVar7) {\n      pcVar10 = pcVar6 + local_30;\n      if (pcVar6[local_30] == '-') {\n        pcVar10 = pcVar10 + 1;\n        iVar7 = -1;\n      }\n      else {\n        if (pcVar6[local_30] == '+') {\n          pcVar10 = pcVar10 + 1;\n        }\n        iVar7 = 1;\n      }\n      local_3a = 0;\n      local_38 = 0;\n      puVar12 = &local_3a;\n      piVar13 = &local_30;\n      puVar14 = &local_38;\n      piVar15 = &local_30;\n      iVar8 = FUN_00005e68(pcVar10,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a,\n                           &local_30,&local_38,&local_30);\n      puVar1 = PTR_DAT_00005400;\n      if (0 < iVar8) {\n        *(uint *)(iVar5 + 0x28) =\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n        puVar3 = DAT_000053e8;\n        *DAT_000053e8 = PTR_DAT_000053ec;\n        pcVar10 = pcVar10 + local_30;\n        iVar7 = FUN_00005e68(pcVar10,PTR_s__10__0_9_____n_000053f0,puVar1,&local_30,puVar12,piVar13,\n                             puVar14,piVar15);\n        if (iVar7 < 1) {\n          puVar3[1] = *puVar3;\n          *(undefined4 *)PTR_DAT_000053dc = *(undefined4 *)(iVar5 + 0x28);\n          *(undefined4 *)PTR_DAT_000053e4 = 0;\n        }\n        else {\n          puVar3[1] = puVar1;\n          pcVar6 = pcVar10 + local_30;\n          if (pcVar10[local_30] == '-') {\n            pcVar6 = pcVar6 + 1;\n            iVar7 = -1;\n          }\n          else {\n            if (pcVar10[local_30] == '+') {\n              pcVar6 = pcVar6 + 1;\n            }\n            iVar7 = 1;\n          }\n          local_3c = 0;\n          local_3a = 0;\n          local_38 = 0;\n          local_30 = 0;\n          iVar8 = FUN_00005e68(pcVar6,PTR_s__hu_n__hu_n__hu_n_000053f4,&local_3c,&local_30,&local_3a\n                               ,&local_30,&local_38,&local_30);\n          if (iVar8 < 1) {\n            iVar7 = *(int *)(iVar5 + 0x28) + -0xe10;\n          }\n          else {\n            iVar7 = ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar7;\n          }\n          *(int *)(iVar5 + 0x50) = iVar7;\n          pcVar6 = pcVar6 + local_30;\n          bVar11 = false;\n          iVar7 = iVar5;\n          while( true ) {\n            if (*pcVar6 == ',') {\n              pcVar6 = pcVar6 + 1;\n            }\n            cVar9 = *pcVar6;\n            if (cVar9 == 'M') {\n              iVar8 = FUN_00005e68(pcVar6,PTR_s_M_hu_n__hu_n__hu_n_000053f8,&local_36,&local_30,\n                                   &local_34,&local_30,&local_32,&local_30);\n              if (iVar8 != 3) {\n                return;\n              }\n              if (0xb < local_36 - 1) {\n                return;\n              }\n              if (4 < local_34 - 1) {\n                return;\n              }\n              if (6 < local_32) {\n                return;\n              }\n              *(uint *)(iVar7 + 0xc) = (uint)local_36;\n              *(uint *)(iVar7 + 0x10) = (uint)local_34;\n              *(undefined *)(iVar7 + 8) = 0x4d;\n              *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              pcVar10 = pcVar6 + local_30;\n            }\n            else {\n              if (cVar9 == 'J') {\n                pcVar6 = pcVar6 + 1;\n              }\n              else {\n                cVar9 = 'D';\n              }\n              local_32 = FUN_00005fd8(pcVar6,local_2c,10);\n              pcVar10 = local_2c[0];\n              if (local_2c[0] == pcVar6) {\n                if (bVar11) {\n                  *(undefined *)(iVar5 + 0x30) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0x34) = 0xb;\n                  *(undefined4 *)(iVar5 + 0x38) = 1;\n                  *(undefined4 *)(iVar5 + 0x3c) = 0;\n                }\n                else {\n                  *(undefined *)(iVar5 + 8) = 0x4d;\n                  *(undefined4 *)(iVar5 + 0xc) = 3;\n                  *(undefined4 *)(iVar5 + 0x10) = 2;\n                  *(undefined4 *)(iVar5 + 0x14) = 0;\n                }\n              }\n              else {\n                *(char *)(iVar7 + 8) = cVar9;\n                *(uint *)(iVar7 + 0x14) = (uint)local_32;\n              }\n            }\n            local_3c = 2;\n            local_3a = 0;\n            local_38 = 0;\n            local_30 = 0;\n            if (*pcVar10 == '/') {\n              FUN_00005e68(pcVar10,PTR_DAT_000053fc,&local_3c,&local_30,&local_3a,&local_30,\n                           &local_38,&local_30);\n            }\n            *(uint *)(iVar7 + 0x18) =\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar7 = iVar7 + 0x28;\n            pcVar6 = pcVar10 + local_30;\n            if (bVar11) break;\n            bVar11 = true;\n          }\n          FUN_00004f98(*(undefined4 *)(iVar5 + 4));\n          iVar7 = *(int *)(iVar5 + 0x28);\n          *(int *)PTR_DAT_000053dc = iVar7;\n          iVar7 = *(int *)(iVar5 + 0x50) - iVar7;\n          if (iVar7 != 0) {\n            iVar7 = 1;\n          }\n          *(int *)PTR_DAT_000053e4 = iVar7;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005780",
                "FUN_00005ecc",
                "FUN_00004bd0",
                "FUN_00005e68",
                "FUN_00004e52",
                "FUN_00005fd8",
                "FUN_000056b0",
                "FUN_00005ebc",
                "FUN_00004f98",
                "FUN_000056a0"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005100",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00005100"
        },
        "FUN_00005584": {
            "renaming": {
                "FUN_00005584": "divide_and_remainder_00005584",
                "param_1": "result",
                "param_2": "dividend",
                "param_3": "divisor",
                "uVar1": "remainder",
                "uVar2": "quotient"
            },
            "code": "void divide_and_remainder_00005584(uint *result, uint dividend, uint divisor)\n{\n  uint quotient;\n  uint remainder;\n  quotient = dividend / divisor;\n  remainder = dividend % divisor;\n  if ((int)dividend < 0 && remainder > 0) {\n    quotient--;\n    remainder += divisor;\n  }\n  else if ((int)remainder < 0) {\n    quotient++;\n    remainder -= divisor;\n  }\n  *result = quotient;\n  result[1] = remainder;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005584",
            "calling": [
                "FUN_00004634"
            ],
            "imported": false,
            "current_name": "divide_and_remainder_00005584"
        },
        "FUN_00004248": {
            "renaming": {
                "FUN_00004248": "allocate_memory_block_00004248",
                "param_1": "memory_location",
                "param_2": "block_number",
                "puVar1": "memory_block_ptr",
                "iVar2": "block_offset"
            },
            "code": "undefined4* allocate_memory_block_00004248(undefined4 memory_location, int block_number) {\n  undefined4* memory_block_ptr;\n  int block_offset = (block_number - 1) * 0x68;\n  memory_block_ptr = (undefined4*)FUN_00004bd0(memory_location, block_offset + 0x74);\n  if (memory_block_ptr != (undefined4*)0x0) {\n    *memory_block_ptr = 0;\n    memory_block_ptr[1] = block_number;\n    memory_block_ptr[2] = memory_block_ptr + 3;\n    FUN_00004622(memory_block_ptr + 3, 0, block_offset + 0x68);\n  }\n  return memory_block_ptr;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004248",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "allocate_memory_block_00004248"
        },
        "FUN_00001da2": {
            "renaming": {
                "FUN_00001da2": "extract_bits_00001da2",
                "param_1": "value",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "unsigned short extract_bits_00001da2(unsigned short value) {\n    unsigned short shifted_value = value >> 6;\n    unsigned short extracted_bits = shifted_value & 7;\n    return extracted_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001da2",
            "calling": [
                "FUN_00001f80",
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "extract_bits_00001da2"
        },
        "FUN_00001ec4": {
            "renaming": {
                "FUN_00001ec4": "calculate_and_store_result_00001ec4",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result",
                "FUN_00001e0c": "calculate",
                "FUN_00001e44": "store_result"
            },
            "code": "void calculate_and_store_result_00001ec4(int input1, int input2) {\n  int result = calculate(input1, input2);\n  store_result(input1, input2, result);\n  return;\n}",
            "called": [
                "FUN_00001e44",
                "FUN_00001e0c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ec4",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "calculate_and_store_result_00001ec4"
        },
        "FUN_00002744": {
            "renaming": {
                "FUN_00002744": "set_data_00002744",
                "param_1": "data",
                "param_2": "value",
                "DAT_00002790": "data_array_ptr",
                "DAT_00002794": "data_ptr"
            },
            "code": "void set_data_00002744(byte data, uint value) {\n    if (data < 0) {\n        *(char *)((data & 0xf) + DAT_00002790 + 0x14) = (char)((value & 0xff) << 4);\n    }\n    else {\n        *(char *)((char)data + DAT_00002794 + 0x300) = (char)((value & 0xff) << 4);\n    }\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002744",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_data_00002744"
        },
        "FUN_00002624": {
            "renaming": {
                "FUN_00002624": "copy_data_to_buffer_and_return_zero_00002624",
                "param_1": "buffer",
                "local_10": "copy_size",
                "uStack_c": "bytes_copied",
                "FUN_0000281c": "get_copy_size",
                "FUN_0000443c": "copy_data"
            },
            "code": "int copy_data_to_buffer_and_return_zero_00002624(void* buffer, int data_size) {\n    int copy_size = get_copy_size();\n    int bytes_copied = 0;\n    bytes_copied = copy_data(buffer, data_size);\n    return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_0000281c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002624",
            "calling": [
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "copy_data_to_buffer_and_return_zero_00002624"
        },
        "FUN_00001e0c": {
            "renaming": {
                "FUN_00001e0c": "get_bits_from_memory_00001e0c",
                "param_1": "index",
                "param_2": "bit_offset",
                "PTR_DAT_00001e40": "memory_address",
                "DAT_00001e40": "memory_data"
            },
            "code": "uint get_bits_from_memory_00001e0c(int index, uint bit_offset) {\n    uint* PTR_DAT_00001e40 = (uint*)(PTR_DAT_00001e40 + (((int)bit_offset >> 3) + index * 4) * 4);\n    uint bits = (*PTR_DAT_00001e40 >> ((bit_offset & 7) << 2)) & 0xf;\n    return bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e0c",
            "calling": [
                "FUN_00002028",
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "get_bits_from_memory_00001e0c"
        },
        "FUN_00000ef8": {
            "renaming": {
                "FUN_00000ef8": "do_nothing_00000ef8"
            },
            "code": "\nvoid do_nothing_00000ef8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ef8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00000ef8"
        },
        "FUN_000041d0": {
            "renaming": {
                "FUN_000041d0": "process_data_000041d0",
                "param_1": "data_len",
                "pcVar1": "data_processor",
                "iVar2": "data_ptr",
                "piVar5": "data_header",
                "uVar7": "result",
                "puVar9": "data_start",
                "iVar8": "block_len",
                "iVar6": "block_ptr",
                "iVar4": "block_len_plus_one"
            },
            "code": "uint process_data_000041d0(int data_len, undefined4 param_2, undefined4 param_3)\n{\n  code *data_processor;\n  int data_ptr;\n  uint result = 0;\n  int *data_header;\n  int block_ptr;\n  int block_len;\n  undefined *data_start;\n  data_processor = DAT_000041ec;\n  if (data_len == 0) {\n    data_ptr = *(int *)PTR_DAT_000041e8;\n    data_header = (int *)(data_ptr + 0x48);\n    data_start = PTR_DAT_000041e8;\n    do {\n      block_ptr = data_header[1];\n      block_len = data_header[2];\n      while (block_len = block_len + -1, block_len >= 0) {\n        if ((1 < *(ushort *)(block_ptr + 0xc)) && (*(short *)(block_ptr + 0xe) + 1 != 0)) {\n          uint block_result = (*data_processor)(data_ptr, block_ptr, param_3, *(short *)(block_ptr + 0xe) + 1, data_start);\n          result = result | block_result;\n        }\n        block_ptr = block_ptr + 0x68;\n      }\n      data_header = (int *)*data_header;\n    } while (data_header != (int *)0x0);\n    return result;\n  }\n  result = FUN_00004158(*DAT_000041f0, data_len);\n  return result;\n}",
            "called": [
                "FUN_00004158"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041d0",
            "calling": [
                "FUN_00002e48"
            ],
            "imported": false,
            "current_name": "process_data_000041d0"
        },
        "FUN_0000459c": {
            "renaming": {
                "FUN_0000459c": "execute_functions_0000459c",
                "puVar1": "start",
                "puVar2": "end",
                "iVar3": "num_functions",
                "ppcVar4": "function_pointer",
                "iVar5": "i"
            },
            "code": "void execute_functions_0000459c(void)\n{\n  undefined *start = PTR_DAT_000045d4;\n  undefined *end = PTR_DAT_000045e0;\n  int num_functions = (int)end - (int)start;\n  code **function_pointer = (code **)start;\n  for (int i = 0; i < num_functions/4; i++) {\n    (**function_pointer)();\n    function_pointer++;\n  }\n  FUN_00000410();\n  function_pointer = (code **)PTR_DAT_000045dc;\n  num_functions = (int)PTR_DAT_000045e0 - (int)PTR_DAT_000045dc;\n  for (int i = 0; i < num_functions/4; i++) {\n    (**function_pointer)();\n    function_pointer++;\n  }\n  return;\n}",
            "called": [
                "FUN_00000410"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000459c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "execute_functions_0000459c"
        },
        "FUN_000014c4": {
            "renaming": {
                "FUN_000014c4": "set_data_000014c4",
                "param_1": "index",
                "param_2": "value",
                "pbVar1": "data_ptr",
                "uVar2": "data_size",
                "uVar3": "temp"
            },
            "code": "void set_data_000014c4(int index, uint value) {\n    byte *data_ptr = *(byte **)(PTR_DAT_000015cc + index * 0x20);\n    uint data_size = *(uint *)(PTR_DAT_000015cc + index * 0x20 + 4);\n    \n    // Update data values\n    data_ptr[3] &= 0xf3;\n    data_ptr[2] = PTR_DAT_000015cc[index * 0x20 + 0x1d];\n    uint temp = data_size / (value << 4);\n    data_ptr[0] = (byte)(temp >> 8) & 0x1f;\n    data_ptr[1] = (byte)temp;\n    data_ptr[10] = (byte)((data_size << 2) / value + 1 >> 1) & 0x1f;\n    data_ptr[0x10] |= 0x88;\n    \n    // Update control values\n    if ((data_ptr[0x10] & 0x70) == 0) {\n        data_ptr[0x13] = 0;\n    }\n    else {\n        data_ptr[0x13] = (char)(2 << (data_ptr[0x10] >> 4 & 7)) - 1;\n    }\n    data_ptr[0x15] = 1;\n    data_ptr[0x11] = 0xc0;\n    data_ptr[3] |= 0x2c;\n    FUN_00001318((int)(char)PTR_DAT_000015cc[index * 0x20 + 0x14]);\n}",
            "called": [
                "FUN_00001318"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000014c4",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_data_000014c4"
        },
        "FUN_00004b34": {
            "renaming": {
                "FUN_00004b34": "insert_node_at_end_00004b34",
                "param_1": "head",
                "param_2": "data",
                "param_3": "N/A",
                "param_4": "N/A",
                "puVar1": "new_node",
                "piVar2": "N/A",
                "extraout_r1": "N/A",
                "ppiVar3": "current_node",
                "ppiVar4": "N/A",
                "ppiVar5": "N/A",
                "ppiVar6": "N/A",
                "bVar7": "N/A"
            },
            "code": "void insert_node_at_end_00004b34(int *head, int data) {\n    int *new_node = malloc(sizeof(int));\n    *new_node = data;\n    new_node[1] = 0;\n    if (*head == 0) {\n        *head = (int)new_node;\n        return;\n    }\n    int *current_node = (int *)*head;\n    while (current_node[1] != 0) {\n        current_node = (int *)current_node[1];\n    }\n    current_node[1] = (int)new_node;\n}",
            "called": [
                "FUN_0000579c",
                "FUN_00005790"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004b34",
            "calling": [
                "FUN_00005780",
                "FUN_00006192",
                "FUN_0000404c",
                "FUN_00006768",
                "FUN_000054a8",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "insert_node_at_end_00004b34"
        },
        "FUN_000004f2": {
            "renaming": {
                "FUN_000004f2": "set_param_to_0x13_000004f2",
                "param_1": "param_ptr",
                "*param_1": "*param_ptr"
            },
            "code": "unsigned int set_param_to_0x13_000004f2(unsigned int *param_ptr) {\n    *param_ptr = 0x13;\n    return 0xffffffff;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000004f2",
            "calling": [
                "FUN_00004e26",
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "set_param_to_0x13_000004f2"
        },
        "FUN_00004e66": {
            "renaming": {
                "FUN_00004e66": "compare_strings_00004e66",
                "param_1": "string1",
                "param_2": "length",
                "param_3": "string2_length",
                "pbVar1": "string1_ptr",
                "pbVar2": "string2_ptr",
                "uVar3": "current_char"
            },
            "code": "int compare_strings_00004e66(byte *string1, int length, int string2_length)\n{\n    byte *string2_ptr;\n    byte *string1_ptr;\n    uint current_char;\n    \n    if (string2_length != 0) {\n        string2_ptr = (byte *)(length - 1);\n        string1_ptr = string1;\n        do {\n            current_char = (uint)*string1_ptr;\n            string2_ptr = string2_ptr + 1;\n            if ((current_char != *string2_ptr) || (string1_ptr + 1 == string1 + string2_length)) break;\n            string1_ptr = string1_ptr + 1;\n        } while (current_char != 0);\n        string2_length = current_char - *string2_ptr;\n    }\n    return string2_length;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e66",
            "calling": [
                "FUN_00003524",
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "compare_strings_00004e66"
        },
        "FUN_00005ecc": {
            "renaming": {
                "FUN_00005ecc": "get_end_of_string_00005ecc",
                "param_1": "str",
                "pcVar3": "current_char",
                "pcVar2": "next_char",
                "cVar1": "current_char_value"
            },
            "code": "char* get_end_of_string_00005ecc(char* str) {\n  char* current_char = str;\n  while (*current_char != '\\0') {\n    current_char++;\n  }\n  return current_char;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ecc",
            "calling": [
                "FUN_00005100",
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "get_end_of_string_00005ecc"
        },
        "FUN_0000129c": {
            "renaming": {
                "FUN_0000129c": "initialize_device_0000129c",
                "param_1": "device_id",
                "FUN_00002434": "set_device_state"
            },
            "code": "void initialize_device_0000129c(undefined4 device_id)\n{\n  set_device_state(device_id, 1);\n  return;\n}",
            "called": [
                "FUN_00002434"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000129c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "initialize_device_0000129c"
        },
        "FUN_00001628": {
            "renaming": {
                "FUN_00001628": "check_and_call_function_00001628",
                "param_1": "index",
                "PTR_DAT_00001680": "data_ptr_1",
                "PTR_DAT_00001684": "data_ptr_2",
                "byte": "byte_type",
                "flags": "byte_flags",
                "int": "int_type",
                "func_ptr": "function_ptr",
                "code": "function_type",
                "arg1": "argument_1",
                "arg2": "argument_2",
                "FUN_00001348": "perform_cleanup"
            },
            "code": "void check_and_call_function_00001628(int index)\n{\n    int* ptr = *(int*)(PTR_DAT_00001680 + index * 0x20);\n    byte flags = *(byte*)(ptr + 4);\n    int* func_ptr = *(int*)(PTR_DAT_00001684 + index * 8);\n    if ((flags & 0x20) != 0 && func_ptr != 0)\n    {\n        code* func = *(code**)func_ptr;\n        undefined4 arg1 = *(undefined4*)(func_ptr + 1);\n        undefined arg2 = *(undefined*)(ptr + 7);\n        func(arg1, arg2);\n    }\n    perform_cleanup();\n}\n",
            "called": [
                "FUN_00001348"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001628",
            "calling": [
                "FUN_00001688"
            ],
            "imported": false,
            "current_name": "check_and_call_function_00001628"
        },
        "FUN_00001748": {
            "renaming": {
                "FUN_00001748": "set_byte_value_00001748",
                "param_1": "new_value",
                "DAT_00001774": "data_pointer"
            },
            "code": "void set_byte_value_00001748(byte new_value)\n{\n    byte* DAT_00001774 = (byte*)(DAT_00001774 + 3);\n    byte old_value = *DAT_00001774;\n    byte mask = 0x1f;\n    *DAT_00001774 = (new_value | (old_value & mask));\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001748",
            "calling": [
                "FUN_000019c0",
                "FUN_00001bb8",
                "FUN_000018bc",
                "FUN_00001960",
                "FUN_0000191c"
            ],
            "imported": false,
            "current_name": "set_byte_value_00001748"
        },
        "FUN_0000294c": {
            "renaming": {
                "FUN_0000294c": "set_flag_on_0000294c",
                "DAT_0000296c": "data_ptr",
                "PTR_00002980": "flag_ptr"
            },
            "code": "void set_flag_on_0000294c(uint* DAT_0000296c) {\n    uint* PTR_00002980 = DAT_0000296c + 0x14;\n    *PTR_00002980 |= 0x10;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000294c",
            "calling": [
                "FUN_000027b0",
                "FUN_000026d8"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000294c"
        },
        "FUN_00005790": {
            "renaming": {
                "FUN_00005790": "do_nothing_with_pointer_00005790",
                "PTR_DAT_00005798": "PTR_DATA"
            },
            "code": "void do_nothing_with_pointer_00005790(void)\n{\n  do_nothing(PTR_DAT_00005798);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005790",
            "calling": [
                "FUN_00004bd0",
                "FUN_00004b34"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00005790"
        },
        "FUN_00000534": {
            "renaming": {
                "FUN_00000534": "is_valid_input_00000534",
                "*param_1": "*input_ptr",
                "param_2": "input_value",
                "uVar1": "is_valid"
            },
            "code": "int is_valid_input_00000534(int *input_ptr, int input_value) {\n  *input_ptr = 0;\n  if (input_value >= 0 && input_value <= 2) {\n    return 1;\n  }\n  else {\n    return 0;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000534",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "is_valid_input_00000534"
        },
        "FUN_000017dc": {
            "renaming": {
                "FUN_000017dc": "set_flag_if_not_set_000017dc",
                "DAT_00001820": "data_ptr",
                "DAT_00001824": "flag_ptr",
                "DAT_00001828": "data_ptr",
                "PTR_": "ptr_",
                "uint": "uint32_t",
                "0x1d": "data_size",
                "0x100": "flag_value"
            },
            "code": "void set_flag_if_not_set_000017dc(uint32_t *DAT_00001820, uint32_t data_size)\n{\n  uint32_t *DAT_00001824 = DAT_00001820 + 4;\n  uint32_t flag_value = 0x100;\n  if ((*((uint32_t *)(DAT_00001820 + 4)) & 0x100) == 0) {\n    *((uint32_t *)(DAT_00001820 + 4)) = flag_value;\n  }\n  *DAT_00001820 = (*DAT_00001820 & 0xfff3ffff) | 0x80000;\n  return;\n}",
            "called": [
                "FUN_000016c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000017dc",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "set_flag_if_not_set_000017dc"
        },
        "FUN_00000410": {
            "renaming": {
                "FUN_00000410": "initialize_system_00000410",
                "FUN_00000df4": "initialize_components"
            },
            "code": "void initialize_system_00000410(void)\n{\n  initialize_components();\n  return;\n}",
            "called": [
                "FUN_00000df4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000410",
            "calling": [
                "FUN_0000459c"
            ],
            "imported": false,
            "current_name": "initialize_system_00000410"
        },
        "FUN_000005ca": {
            "renaming": {
                "FUN_000005ca": "reverse_linked_list_000005ca",
                "param_1": "head_ptr",
                "puVar1": "new_head_ptr",
                "*param_1": "*head_ptr",
                "(undefined4 *)0x0": "(undefined4 *)NULL"
            },
            "code": "undefined4 *reverse_linked_list_000005ca(int *head_ptr)\n{\n  undefined4 *new_head_ptr;\n  \n  if (*head_ptr == 0) {\n    new_head_ptr = (undefined4 *)0x0;\n  }\n  else {\n    new_head_ptr = *(undefined4 **)*head_ptr;\n    if (new_head_ptr == (undefined4 *)*head_ptr) {\n      *head_ptr = 0;\n    }\n    else {\n      *(undefined4 *)*head_ptr = *new_head_ptr;\n    }\n  }\n  return new_head_ptr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000005ca",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "reverse_linked_list_000005ca"
        },
        "FUN_00005ff8": {
            "renaming": {
                "FUN_00005ff8": "do_nothing_with_data_00005ff8",
                "DAT_00006000": "DAT_data",
                "do_nothing_000045ec": "do_nothing"
            },
            "code": "void do_nothing_with_data_00005ff8(void)\n{\n  do_nothing(DAT_00006000);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ff8",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005ff8"
        },
        "FUN_00002714": {
            "renaming": {
                "FUN_00002714": "set_bit_in_array_00002714",
                "param_1": "bit_index",
                "DAT_00002740": "array_ptr",
                "uint": "uint32_t",
                "int": "int32_t",
                "byte": "uint8_t",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "void set_bit_in_array_00002714(uint8_t bit_index) {\n    uint32_t* DAT_00002740 = (uint32_t*)(DAT_00002740 + (bit_index >> 5) * 4);\n    uint8_t bit_offset = bit_index & 0x1f;\n    uint32_t bit_mask = 1 << bit_offset;\n    *DAT_00002740 = bit_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002714",
            "calling": [
                "FUN_00002894"
            ],
            "imported": false,
            "current_name": "set_bit_in_array_00002714"
        },
        "FUN_000020e0": {
            "renaming": {
                "FUN_000020e0": "print_array_elements_000020e0",
                "DAT_000020f0": "array",
                "FUN_00002028": "print_elements"
            },
            "code": "void print_array_elements_000020e0(int* DAT_000020f0, int size)\n{\n    print_elements(DAT_000020f0, size);\n    return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020e0",
            "calling": [],
            "imported": false,
            "current_name": "print_array_elements_000020e0"
        },
        "FUN_00005fec": {
            "renaming": {
                "FUN_00005fec": "do_nothing_with_data_00005fec",
                "DAT_00005ff4": "DAT_data"
            },
            "code": "void do_nothing_with_data_00005fec(void)\n{\n  do_nothing(DAT_00005ff4);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fec",
            "calling": [
                "FUN_0000562c"
            ],
            "imported": false,
            "current_name": "do_nothing_with_data_00005fec"
        },
        "FUN_00004f84": {
            "renaming": {
                "FUN_00004f84": "convert_byte_string_to_uint_00004f84",
                "param_1": "byte_string",
                "param_2": "endptr",
                "param_3": "base",
                "uVar1": "result",
                "uVar2": "digit_char",
                "uVar3": "char_info",
                "uVar4": "digit_val",
                "uVar5": "negative",
                "uVar6": "max_uint",
                "uVar7": "max_dividend",
                "iVar5": "overflow",
                "pbVar8": "prev_char",
                "pbVar9": "current_char"
            },
            "code": "uint convert_byte_string_to_uint_00004f84(byte *byte_string, byte **endptr, uint base) {\n  uint result = 0;\n  int negative = 0;\n  uint digit_val;\n  byte *current_char = byte_string;\n  while (isspace(*current_char)) {\n    current_char++;\n  }\n  if (*current_char == '-') {\n    negative = 1;\n    current_char++;\n  }\n  else if (*current_char == '+') {\n    current_char++;\n  }\n  if (base == 0) {\n    if (*current_char == '0') {\n      base = 8;\n      current_char++;\n      if ((*current_char == 'x') || (*current_char == 'X')) {\n        base = 16;\n        current_char++;\n      }\n    }\n    else {\n      base = 10;\n    }\n  }\n  while (1) {\n    if (isdigit(*current_char)) {\n      digit_val = *current_char - '0';\n    }\n    else if (isalpha(*current_char)) {\n      if (isupper(*current_char)) {\n        digit_val = *current_char - 'A' + 10;\n      }\n      else {\n        digit_val = *current_char - 'a' + 10;\n      }\n    }\n    else {\n      break;\n    }\n    if (digit_val >= base) {\n      break;\n    }\n    if (negative) {\n      if (-result < ((INT_MIN + digit_val) / base)) {\n        *endptr = current_char;\n        return UINT_MAX;\n      }\n    }\n    else {\n      if (result > ((UINT_MAX - digit_val) / base)) {\n        *endptr = current_char;\n        return UINT_MAX;\n      }\n    }\n    result = result * base + digit_val;\n    current_char++;\n  }\n  if (endptr != NULL) {\n    *endptr = current_char;\n  }\n  if (negative) {\n    return -result;\n  }\n  else {\n    return result;\n  }\n}\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f84",
            "calling": [
                "FUN_0000328c",
                "FUN_00004042"
            ],
            "imported": false,
            "current_name": "convert_byte_string_to_uint_00004f84"
        },
        "FUN_000028f0": {
            "renaming": {
                "FUN_000028f0": "get_dat_value_plus_one_000028f0",
                "DAT_0000290c": "data_pointer"
            },
            "code": "int get_dat_value_plus_one_000028f0(void)\n{\n    int* DAT_0000290c = (int *)(DAT_0000290c + 8);\n    int data_value = *DAT_0000290c;\n    int result = data_value + 1;\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000028f0",
            "calling": [
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "get_dat_value_plus_one_000028f0"
        },
        "FUN_00004f98": {
            "renaming": {
                "FUN_00004f98": "calculate_leap_years_00004f98",
                "param_1": "year",
                "puVar1": "calendar",
                "uVar2": "result",
                "uVar3": "days_in_month",
                "iVar4": "is_leap_year",
                "puVar5": "current_month",
                "iVar6": "days_since_1900",
                "uVar7": "leap_years_offset",
                "iVar8": "i",
                "iVar9": "days_since_week_start",
                "uVar10": "leap_years_count",
                "PTR_DAT_000050e4": "leap_years_data",
                "DAT_000050e0": "days_in_year"
            },
            "code": "undefined4 calculate_leap_years_00004f98(uint year)\n{\n  uint *calendar = (uint *)FUN_000056b0();\n  uint leap_years_count = count_leading_zeroes(year % 400);\n  if ((int)year < 0x7b2) {\n    return 0;\n  }\n  else {\n    int days_since_1900 = (year - 0x7b2) * 0x16d + ((int)(year - 0x7b1) >> 2) + (year - 0x76d) / 0xffffff9c + (year - 0x641) / 400;\n    calendar[1] = year;\n    uint *current_month = calendar;\n    do {\n      uint days_in_month = current_month[5];\n      if (*(char *)(current_month + 2) == 'J') {\n        if ((((year & 3) == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n          if ((int)days_in_month < 0x3c) {\n            days_since_1900 += 0;\n          }\n          else {\n            days_since_1900 += 1;\n          }\n        }\n        else {\n          days_since_1900 += 0;\n        }\n        days_since_1900 += days_in_month + leap_years_count - 1;\n      }\n      else if (*(char *)(current_month + 2) == 'D') {\n        days_since_1900 += days_in_month;\n      }\n      else {\n        uint leap_years_offset = leap_years_count >> 5;\n        if (((year & 3) == 0) && (year % 100 != 0)) {\n          leap_years_offset = 1;\n        }\n        int days_since_leap_years = days_since_1900;\n        int i = 0;\n        while (i < (int)current_month[3]) {\n          days_since_leap_years += *(int *)(PTR_DAT_000050e4 + i * 4 + leap_years_offset * 0x30 + -4);\n          i++;\n        }\n        int days_since_week_start = days_since_leap_years + 4U;\n        if (days_since_week_start < 0) {\n          days_since_week_start += 7;\n        }\n        for (days_since_week_start = (current_month[4] - 1) * 7 + days_since_week_start; *(int *)(PTR_DAT_000050e4 + i * 4 + leap_years_offset * 0x30 + -4) <= days_since_week_start; days_since_week_start -= 7) {\n        }\n        days_since_1900 += days_since_week_start;\n      }\n      days_in_month = current_month[10] + DAT_000050e0 * days_since_1900 + current_month[6];\n      current_month[8] = days_in_month;\n      current_month[9] = (int)days_in_month >> 0x1f;\n      current_month += 10;\n    } while (calendar + 0x14 != current_month);\n    uint days_since_1900_0 = calendar[9];\n    uint days_since_1900_1 = calendar[0x13];\n    *calendar = (uint)((int)((days_since_1900_0 - days_since_1900_1) - (uint)(calendar[8] < calendar[0x12])) < 0 != (SBORROW4(days_since_1900_0, days_since_1900_1) != SBORROW4(days_since_1900_0 - days_since_1900_1, (uint)(calendar[8] < calendar[0x12]))));\n    return 1;\n  }\n}",
            "called": [
                "FUN_000056b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004f98",
            "calling": [
                "FUN_000047e4",
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "calculate_leap_years_00004f98"
        },
        "FUN_00004dee": {
            "renaming": {
                "FUN_00004dee": "check_and_update_value_of_pointer_00004dee",
                "param_1": "value1",
                "param_2": "pointer_to_value",
                "param_3": "value2",
                "param_4": "value3",
                "uVar1": "updated_value",
                "ushort": "uint16_t",
                "FUN_000004f2": "call_function_with_4_arguments",
                "short": "int16_t",
                "FUN_00000e38": "another_function_with_2_arguments"
            },
            "code": "int check_and_update_value_of_pointer_00004dee(int value1, int pointer_to_value, int value2, int value3)\n{\n  int updated_value;\n  int shifted_value = (uint16_t)*(uint16_t *)(pointer_to_value + 0xc) << 0x17;\n  if (shifted_value < 0) {\n    call_function_with_4_arguments(value1, (int)*(int16_t *)(pointer_to_value + 0xe), 0, 2);\n  }\n  *(uint16_t *)(pointer_to_value + 0xc) &= 0xefff;\n  updated_value = another_function_with_2_arguments(value2, value3);\n  return updated_value;\n}",
            "called": [
                "FUN_00000e38",
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dee",
            "calling": [],
            "imported": false,
            "current_name": "check_and_update_value_of_pointer_00004dee"
        },
        "FUN_00000fec": {
            "renaming": {
                "FUN_00000fec": "initialize_memory_block_00000fec",
                "param_1": "memory_block_start",
                "param_2": "memory_block_size",
                "*param_1": "memory_block_start[0]",
                "param_1[1]": "memory_block_start[1]",
                "param_1[2]": "memory_block_start[2]",
                "PTR_s_FAILED_ASSERTION__00001030": "error_message"
            },
            "code": "void initialize_memory_block_00000fec(undefined4 *memory_block_start, uint32_t memory_block_size) {\n  if ((memory_block_size & (memory_block_size - 1)) != 0) {\n    assert(false && \"Memory block size is not a power of two.\");\n  }\n  memory_block_start[0] = 0;\n  memory_block_start[1] = 0;\n  memory_block_start[2] = memory_block_size - 1;\n  return;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000fec",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "initialize_memory_block_00000fec"
        },
        "FUN_00000428": {
            "renaming": {
                "FUN_00000428": "validate_param_and_update_offset_00000428",
                "*param_1": "*param_offset",
                "param_2": "param_size",
                "uVar1": "result",
                "local_c": "offset_value",
                "PTR_Elf32_Rel_ARRAY_00000484": "current_offset",
                "DAT_00000488": "MAX_ALLOWED_OFFSET",
                "DAT_0000048c": "MIN_ALLOWED_OFFSET"
            },
            "code": "undefined4 validate_param_and_update_offset_00000428(uint32_t *param_offset, int param_size)\n{\n  undefined4 result;\n  uint32_t offset_value;\n  result = get_current_time();\n  uint32_t PTR_Elf32_Rel_ARRAY_00000484 = *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n  if ((DAT_00000488 < (uint)(param_size + PTR_Elf32_Rel_ARRAY_00000484)) || ((uint)(param_size + PTR_Elf32_Rel_ARRAY_00000484) < DAT_0000048c)) {\n    *param_offset = 0xc;\n    offset_value = 0xffffffff;\n  }\n  else {\n    *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484 = param_size + PTR_Elf32_Rel_ARRAY_00000484;\n    offset_value = *(uint32_t *)PTR_Elf32_Rel_ARRAY_00000484;\n  }\n  FUN_00000d0c(result);\n  return offset_value;\n}\n",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000428",
            "calling": [
                "FUN_00004bd0"
            ],
            "imported": false,
            "current_name": "validate_param_and_update_offset_00000428"
        },
        "FUN_000039e8": {
            "renaming": {
                "FUN_000039e8": "getClass_000039e8",
                "param_1": "classCode",
                "puVar1": "result"
            },
            "code": "undefined* getClass_000039e8(char classCode) {\n    undefined* result = PTR_s_CLASS_UNKNOWN_00003d20;\n    switch(classCode) {\n        case '\\0':\n            result = DAT_00003cc0;\n            break;\n        case '@':\n            result = DAT_00003cc4;\n            break;\n        case 'B':\n            result = DAT_00003cc8;\n            break;\n        case 'C':\n            result = PTR_s_ACT_SERVO_00003ccc;\n            break;\n        case 'D':\n            result = PTR_s_ACT_MOTOR_00003cd0;\n            break;\n        case 'E':\n            result = PTR_s_ACT_SWITCH_00003cd4;\n            break;\n        case 'F':\n            result = PTR_s_ACT_DIMMER_00003cd8;\n            break;\n        case -0x80:\n            result = PTR_s_SENSE_ANY_00003cdc;\n            break;\n        case -0x7f:\n            result = PTR_s_SENSE_BTN_00003ce0;\n            break;\n        case -0x7e:\n            result = PTR_s_SENSE_TEMP_00003ce4;\n            break;\n        case -0x7d:\n            result = PTR_s_SENSE_HUM_00003ce8;\n            break;\n        case -0x7c:\n            result = PTR_s_SENSE_LIGHT_00003cec;\n            break;\n        case -0x7b:\n            result = PTR_s_SENSE_ACCEL_00003cf0;\n            break;\n        case -0x7a:\n            result = PTR_s_SENSE_MAG_00003cf4;\n            break;\n        case -0x79:\n            result = PTR_s_SENSE_GYRO_00003cf8;\n            break;\n        case -0x78:\n            result = PTR_s_SENSE_COLOR_00003cfc;\n            break;\n        case -0x77:\n            result = PTR_s_SENSE_PRESS_00003d00;\n            break;\n        case -0x76:\n            result = PTR_s_SENSE_ANALOG_00003d04;\n            break;\n        case -0x75:\n            result = PTR_s_SENSE_UV_00003d08;\n            break;\n        case -0x74:\n            result = PTR_s_SENSE_OBJTEMP_00003d0c;\n            break;\n        case -0x73:\n            result = PTR_s_SENSE_PULSE_COUNT_00003d10;\n            break;\n        case -0x72:\n            result = PTR_s_SENSE_DISTANCE_00003d14;\n            break;\n        case -0x71:\n            result = PTR_s_SENSE_CO2_00003d18;\n            break;\n        default:\n            if (classCode == -1) {\n                return PTR_s_CLASS_ANY_00003d1c;\n            }\n            break;\n    }\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000039e8",
            "calling": [
                "FUN_00002ecc",
                "FUN_00002f74"
            ],
            "imported": false,
            "current_name": "getClass_000039e8"
        },
        "FUN_00000e38": {
            "renaming": {
                "FUN_00000e38": "process_data_00000e38",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "FUN_000015d0": "call_data_processor"
            },
            "code": "int32_t process_data_00000e38(int32_t input_param_1, int32_t input_param_2)\n{\n  call_data_processor(0, input_param_1, input_param_2);\n  return input_param_2;\n}",
            "called": [
                "FUN_000015d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e38",
            "calling": [
                "FUN_00004dee"
            ],
            "imported": false,
            "current_name": "process_data_00000e38"
        },
        "FUN_00002294": {
            "renaming": {
                "FUN_00002294": "is_difference_equal_to_third_00002294",
                "param_1": "ptr_param1",
                "uVar1": "is_equal",
                "iVar2": "third",
                "bVar3": "is_equal"
            },
            "code": "bool is_difference_equal_to_third_00002294(int ptr_param1)\n{\n    int difference = *(int *)(ptr_param1 + 0xC) - *(int *)(ptr_param1 + 0x8);\n    int third = *(int *)(ptr_param1 + 0x4);\n    bool is_equal = difference == third;\n    return is_equal;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002294",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "is_difference_equal_to_third_00002294"
        },
        "FUN_00003e9e": {
            "renaming": {
                "FUN_00003e9e": "perform_action_on_data_00003e9e",
                "param_1": "data_address",
                "param_2": "data_length",
                "param_3": "operation_type",
                "uVar1": "result",
                "FUN_00003ec4": "perform_operation"
            },
            "code": "int perform_action_on_data_00003e9e(unsigned int data_address, int data_length, unsigned int operation_type){\n  int result = perform_operation(data_address, data_length, operation_type);\n  return result;\n}",
            "called": [
                "FUN_00003ec4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e9e",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "perform_action_on_data_00003e9e"
        },
        "FUN_00003378": {
            "renaming": {
                "FUN_00003378": "calculate_checksum_00003378",
                "param_1": "data",
                "PTR_s__04i__02i__02i__02i__02i__02i_000033bc": "sum",
                "DAT_00003408": "length",
                "DAT_0000340c": "i",
                "*param_1": "checksum"
            },
            "code": "DAT_0000340cnt calculate_checksum_00003378(unsDAT_0000340cgned DAT_0000340cnt *data)\n{\n    unsDAT_0000340cgned DAT_0000340cnt PTR_s__04DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c_000033bc = data[5] + 0x76c;\n    unsDAT_0000340cgned DAT_0000340cnt DAT_00003408 = data[4] + 1;\n    unsDAT_0000340cgned DAT_0000340cnt DAT_0000340c = 0;\n    unsDAT_0000340cgned DAT_0000340cnt checkPTR_s__04DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c_000033bc = data[0];\n    for(DAT_0000340c = 0; DAT_0000340c < DAT_00003408; DAT_0000340c++)\n    {\n        checkPTR_s__04DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c_000033bc += data[DAT_0000340c+1];\n        DAT_0000340cf(checkPTR_s__04DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c_000033bc >= PTR_s__04DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c_000033bc)\n        {\n            checkPTR_s__04DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c_000033bc -= PTR_s__04DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c_000033bc;\n        }\n    }\n    return checkPTR_s__04DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c__02DAT_0000340c_000033bc;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003378",
            "calling": [
                "FUN_000033c0",
                "FUN_00003444"
            ],
            "imported": false,
            "current_name": "calculate_checksum_00003378"
        },
        "FUN_00006768": {
            "renaming": {
                "FUN_00006768": "process_input_data_00006768",
                "param_1": "input_buffer",
                "param_2": "output_buffer",
                "param_3": "buffer_size",
                "param_4": "some_data",
                "uVar1": "flag",
                "iVar2": "status",
                "uVar3": "temp",
                "uVar4": "size",
                "uVar5": "data",
                "FUN_000042a4": "initialize",
                "PTR_DAT_00006868": "output_buffer_1",
                "PTR_DAT_0000686c": "output_buffer_2",
                "PTR_DAT_00006870": "output_buffer_3",
                "FUN_00004b34": "cleanup",
                "output_buffer_0xd": "prev_output_buffer",
                "output_buffer_0x10": "next_output_buffer",
                "output_buffer_0xf": "output_data",
                "FUN_00004158": "process_data",
                "FUN_00005700": "process_output_data",
                "PTR_DAT_00006874": "data_pointer",
                "PTR_LAB_00006754_1_00006878": "label_pointer",
                "FUN_0000404c": "do_something_else",
                "output_buffer_4": "temp_data"
            },
            "code": "undefined4 process_input_data_00006768(undefined4 *input_buffer, undefined4 *output_buffer, undefined4 buffer_size, undefined4 some_data)\n{\n  undefined2 flag;\n  int status;\n  undefined4 temp;\n  ushort size;\n  uint data;\n  \n  if ((input_buffer != (undefined4 *)0x0) && (input_buffer[6] == 0)) {\n    initialize();\n  }\n  if (output_buffer == (undefined4 *)PTR_DAT_00006868) {\n    output_buffer = (undefined4 *)input_buffer[1];\n  }\n  else if (output_buffer == (undefined4 *)PTR_DAT_0000686c) {\n    output_buffer = (undefined4 *)input_buffer[2];\n  }\n  else if (output_buffer == (undefined4 *)PTR_DAT_00006870) {\n    output_buffer = (undefined4 *)input_buffer[3];\n  }\n  size = *(ushort *)(output_buffer + 3);\n  output_buffer[1] = 0;\n  data = (uint)*(ushort *)(output_buffer + 3);\n  if ((int)(data << 0x1a) < 0) {\n    return 0xffffffff;\n  }\n  if ((int)(data << 0x1d) < 0) {\n    if ((undefined4 *)output_buffer[0xd] != (undefined4 *)0x0) {\n      if ((undefined4 *)output_buffer[0xd] != output_buffer + 0x11) {\n        cleanup(input_buffer);\n      }\n      output_buffer[1] = output_buffer[0x10];\n      output_buffer[0xd] = 0;\n      if (output_buffer[0x10] != 0) {\n        *output_buffer = output_buffer[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 < (int)(data << 0x1b)) {\n      *input_buffer = 9;\n      size = size | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(data << 0x1c) < 0) {\n      status = process_data(input_buffer, output_buffer, data << 0x1c, data, some_data);\n      if (status != 0) {\n        return 0xffffffff;\n      }\n      output_buffer[2] = 0;\n      *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) & 0xfff7;\n      output_buffer[6] = 0;\n    }\n    *(ushort *)(output_buffer + 3) = *(ushort *)(output_buffer + 3) | 4;\n  }\n  if (output_buffer[4] == 0) {\n    process_output_data(input_buffer, output_buffer);\n  }\n  size = *(ushort *)(output_buffer + 3);\n  flag = *(undefined2 *)(output_buffer + 3);\n  if ((size & 3) != 0) {\n    *(undefined2 *)(output_buffer + 3) = 1;\n    do_something(*(undefined4 *)PTR_DAT_00006874,PTR_LAB_00006754_1_00006878);\n    *(undefined2 *)(output_buffer + 3) = flag;\n    if ((size & 9) == 9) {\n      do_something_else(input_buffer,output_buffer);\n    }\n  }\n  temp = output_buffer[4];\n  *output_buffer = temp;\n  status = (*(code *)output_buffer[9])(input_buffer,output_buffer[8],temp,output_buffer[5]);\n  output_buffer[1] = status;\n  if (0 < status) {\n    return 0;\n  }\n  size = *(ushort *)(output_buffer + 3);\n  if (status != 0) {\n    output_buffer[1] = temp;\n    size = size | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(output_buffer + 3) = size;\n  return 0xffffffff;\n}",
            "called": [
                "FUN_00004158",
                "FUN_0000404c",
                "FUN_00004b34",
                "FUN_000043a0",
                "FUN_000042a4",
                "FUN_00005700"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006768",
            "calling": [
                "FUN_00005e10"
            ],
            "imported": false,
            "current_name": "process_input_data_00006768"
        },
        "FUN_00000db0": {
            "renaming": {
                "FUN_00000db0": "initialize_system_00000db0",
                "FUN_00000dcc": "initialize_subsystem1",
                "FUN_00000d9c": "initialize_subsystem2"
            },
            "code": "void initialize_system_00000db0(void)\n{\n  initialize_subsystem1();\n  initialize_subsystem2();\n  return;\n}",
            "called": [
                "FUN_00000d9c",
                "FUN_00000dcc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000db0",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_system_00000db0"
        },
        "FUN_00002600": {
            "renaming": {
                "FUN_00002600": "process_data_and_return_zero_00002600",
                "param_1": "input",
                "uVar1": "processed_data",
                "FUNC_000047e4": "process",
                "FUN_0000285c": "print_processed_data"
            },
            "code": "int process_data_and_return_zero_00002600(int input)\n{\n  int processed_data = process(input);\n  print_processed_data(processed_data);\n  return 0;\n}",
            "called": [
                "FUN_000047e4",
                "FUN_0000285c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002600",
            "calling": [
                "FUN_00003478"
            ],
            "imported": false,
            "current_name": "process_data_and_return_zero_00002600"
        },
        "FUN_00003810": {
            "renaming": {
                "FUN_00003810": "get_label_for_param_00003810"
            },
            "code": "\\\nchar* get_label_for_param_00003810(int param) {\\\n    char* label;\\\n    switch(param) {\\\n        case 2:\\\n            label = PTR_LAB_000038cc;\\\n            break;\\\n        case 3:\\\n            label = PTR_LAB_000038d0;\\\n            break;\\\n        case 4:\\\n            label = PTR_LAB_000038d4;\\\n            break;\\\n        case 5:\\\n            label = PTR_LAB_000038d8;\\\n            break;\\\n        case 6:\\\n            label = PTR_LAB_000038dc;\\\n            break;\\\n        case 7:\\\n            label = PTR_LAB_000038e0;\\\n            break;\\\n        case 8:\\\n            label = PTR_LAB_000038e4;\\\n            break;\\\n        case 9:\\\n            label = PTR_LAB_000038e8;\\\n            break;\\\n        case 10:\\\n            label = PTR_LAB_000038ec;\\\n            break;\\\n        case 11:\\\n            label = PTR_LAB_000038f0;\\\n            break;\\\n        case 12:\\\n            label = PTR_LAB_000038f4;\\\n            break;\\\n        case 13:\\\n            label = PTR_LAB_000038f8;\\\n            break;\\\n        case 14:\\\n            label = PTR_LAB_000038fc;\\\n            break;\\\n        case 15:\\\n            label = PTR_LAB_00003900;\\\n            break;\\\n        case 16:\\\n            label = PTR_LAB_00003904;\\\n            break;\\\n        case 17:\\\n            label = PTR_LAB_0000390c;\\\n            break;\\\n        case 19:\\\n            label = PTR_LAB_00003910;\\\n            break;\\\n        case 21:\\\n            label = PTR_LAB_00003908;\\\n            break;\\\n        default:\\\n            label = PTR_LAB_00003914;\\\n            break;\\\n    }\\\n    return label;\\\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003810",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_label_for_param_00003810"
        },
        "FUN_00000ed8": {
            "renaming": {
                "FUN_00000ed8": "execute_function_00000ed8",
                "in_lr": "function_param",
                "FUN_00004c84": "execute_another_function"
            },
            "code": "void execute_function_00000ed8(void)\n{\n  undefined4 function_param;\n  execute_another_function(PTR_DAT_00000ef4, function_param);\n  return;\n}",
            "called": [
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000ed8",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "execute_function_00000ed8"
        },
        "FUN_000031e0": {
            "renaming": {
                "FUN_000031e0": "alarm_rang_handler_000031e0",
                "FUN_00004db8": "print_alarm_message"
            },
            "code": "void alarm_rang_handler_000031e0(void)\n{\n  print_alarm_message(PTR_s_The_alarm_rang_000031f8);\n  return;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000031e0",
            "calling": [],
            "imported": false,
            "current_name": "alarm_rang_handler_000031e0"
        },
        "FUN_000020f4": {
            "renaming": {
                "FUN_000020f4": "print_data_000020f4",
                "FUN_00002028": "print_array",
                "DAT_00002104": "array_data"
            },
            "code": "void print_data_000020f4(void)\n{\n  print_array(DAT_00002104, 3);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020f4",
            "calling": [],
            "imported": false,
            "current_name": "print_data_000020f4"
        },
        "FUN_0000687c": {
            "renaming": {
                "FUN_0000687c": "reverse_and_invert_0000687c",
                "param_1": "length",
                "param_2": "input",
                "pbVar1": "output",
                "uVar2": "range_start",
                "iVar3": "i",
                "uVar4": "current_char",
                "uVar5": "range_end",
                "uVar6": "temp",
                "bVar7": "is_caret"
            },
            "code": "byte * reverse_and_invert_0000687c(int length, byte *input)\n{\n  byte *output;\n  uint current_char;\n  bool is_caret = false;\n  uint i = 0;\n  while (i < length)\n  {\n    if (is_caret)\n    {\n      current_char = (uint)input[1];\n      input += 2;\n    }\n    else\n    {\n      current_char = (uint)*input;\n      input++;\n    }\n    for (uint j = 0; j < 256; j++)\n    {\n      *(bool *)(i + j) = is_caret;\n    }\n    if (current_char == 0)\n    {\n      output = input - 1;\n    }\n    else\n    {\n      while (true)\n      {\n        uint range_end = current_char;\n        *(bool *)(i + range_end) = !is_caret;\n        input++;\n        while (*input == 0x2d)\n        {\n          uint range_start = range_end;\n          range_end = (uint)input[1];\n          if (range_end == 0x5d || range_end < range_start)\n          {\n            goto end_of_input;\n          }\n          input += 2;\n          for (uint k = range_start + 1; k < range_end; k++)\n          {\n            *(bool *)(i + k) = !is_caret;\n          }\n          range_end = range_start + range_end - 1;\n        }\n        output = input - 1;\n        if (current_char == 0x5d)\n        {\n          break;\n        }\n        current_char = (uint)*output;\n      }\n    }\n    end_of_input:\n    return output;\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000687c",
            "calling": [
                "FUN_0000656c",
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "reverse_and_invert_0000687c"
        },
        "FUN_00005edc": {
            "renaming": {
                "FUN_00005edc": "parse_number_00005edc",
                "param_1": "result",
                "param_2": "input_string",
                "param_3": "next_char",
                "param_4": "base",
                "uVar1": "parsed_number",
                "uVar2": "digit_value",
                "bVar3": "overflow_flag",
                "iVar4": "is_negative",
                "uVar5": "temp",
                "uVar6": "max_digit",
                "pbVar7": "current_char",
                "pbVar8": "next_char_candidate"
            },
            "code": "uint parse_number_00005edc(undefined4 *result, byte *input_string, byte **next_char, uint base) {\n  uint digit_value;\n  uint is_negative = 0;\n  uint overflow_flag = 0;\n  uint max_digit = UINT32_MAX / base;\n  uint parsed_number = 0;\n  byte *current_char = input_string;\n\n  // skip leading whitespace\n  while (isspace(*current_char)) {\n    current_char++;\n  }\n\n  // check for sign\n  if (*current_char == '-') {\n    is_negative = 1;\n    current_char++;\n  } else if (*current_char == '+') {\n    current_char++;\n  }\n\n  // determine base if not provided\n  if (base == 0) {\n    if (*current_char != '0') {\n      base = 10;\n    } else if (toupper(current_char[1]) == 'X') {\n      base = 16;\n      current_char += 2;\n    } else {\n      base = 8;\n    }\n  }\n\n  // parse digits\n  while (1) {\n    if (isdigit(*current_char)) {\n      digit_value = *current_char - '0';\n    } else if (isalpha(*current_char)) {\n      digit_value = toupper(*current_char) - 'A' + 10;\n    } else {\n      break;\n    }\n\n    if (digit_value >= base) {\n      break;\n    }\n\n    if (parsed_number > max_digit || (parsed_number == max_digit && digit_value > UINT32_MAX % base)) {\n      overflow_flag = 1;\n      parsed_number = 0;\n    } else {\n      parsed_number = parsed_number * base + digit_value;\n    }\n\n    current_char++;\n  }\n\n  if (overflow_flag) {\n    *result = '\"';\n    parsed_number = UINT32_MAX;\n    if (next_char == NULL) {\n      return UINT32_MAX;\n    }\n  } else {\n    if (is_negative) {\n      parsed_number = -parsed_number;\n    }\n    if (next_char == NULL) {\n      return parsed_number;\n    }\n    if (parsed_number == 0) {\n      *next_char = input_string;\n    } else {\n      *next_char = current_char;\n    }\n  }\n\n  *result = 0;\n  return parsed_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005edc",
            "calling": [
                "FUN_00005fd8"
            ],
            "imported": false,
            "current_name": "parse_number_00005edc"
        },
        "FUN_00001eea": {
            "renaming": {
                "FUN_00001eea": "set_bit_or_clear_bit_and_set_value_of_byte_at_index_00001eea",
                "param_1": "str",
                "param_2": "value",
                "uVar1": "bit_mask",
                "iVar2": "byte_index",
                "iVar3": "byte_array_index"
            },
            "code": "int set_bit_or_clear_bit_and_set_value_of_byte_at_index_00001eea(char *str, uint8_t index, uint8_t value) {\n  uint8_t bit_mask = 1 << (index & 0xff);\n  int byte_index = get_byte_index(str);\n  if (value < 0) {\n    *(uint *)(byte_index + 0x14) |= bit_mask;\n  }\n  else {\n    *(uint *)(byte_index + 0x14) &= ~bit_mask;\n  }\n  int byte_array_index = get_byte_array_index(str);\n  *(uint *)(byte_index + byte_array_index * 4) = value & 0x23 | 0x100;\n  return 0;\n}",
            "called": [
                "FUN_00001d5e",
                "FUN_00001f80",
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001eea",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bit_or_clear_bit_and_set_value_of_byte_at_index_00001eea"
        },
        "FUN_000023a4": {
            "renaming": {
                "FUN_000023a4": "initialize_system_000023a4",
                "uVar1": "return_value",
                "auStack_88": "stack_buffer",
                "FUN_000023d0": "initialize_subsystem",
                "FUN_00004db8": "initialize_memory",
                "FUN_00002e6c": "initialize_subsystem_2",
                "software_interrupt": "trigger_interrupt"
            },
            "code": "int initialize_system_000023a4(void)\n{\n  int return_value;\n  char stack_buffer[128];\n  initialize_subsystem(0);\n  initialize_memory(uRam000023c4);\n  return_value = initialize_subsystem_2(0, stack_buffer, 0x80);\n  trigger_interrupt(0x3f);\n  return return_value;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00002e6c",
                "FUN_000023d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023a4",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "initialize_system_000023a4"
        },
        "FUN_0000240c": {
            "renaming": {
                "FUN_0000240c": "getNextPointer_0000240c",
                "param_1": "currentPtr",
                "puVar1": "nextPtr"
            },
            "code": "undefined4* getNextPointer_0000240c(undefined4* currentPtr) {\n    undefined4* nextPtr = (undefined4*)*currentPtr;\n    if (nextPtr != (undefined4*)0x0) {\n        *currentPtr = *nextPtr;\n    }\n    return nextPtr;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000240c",
            "calling": [
                "FUN_000024bc"
            ],
            "imported": false,
            "current_name": "getNextPointer_0000240c"
        },
        "FUN_00004280": {
            "renaming": {
                "FUN_00004280": "do_nothing_with_pointer_00004280",
                "PTR_DAT_00004288": "PTR_pointer"
            },
            "code": "void do_nothing_with_pointer_00004280(void)\n{\n  do_nothing(PTR_DAT_00004288);\n  return;\n}",
            "called": [
                "FUN_000045ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004280",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004280"
        },
        "FUN_00001448": {
            "renaming": {
                "FUN_00001448": "check_and_call_functions_00001448",
                "param_1": "index",
                "PTR_DAT_000014c0": "data_pointer",
                "first_short": "first_short_value",
                "second_short": "second_short_value",
                "first_undefined2": "first_undefined2_value",
                "first_undefined4": "first_undefined4_value",
                "second_undefined2": "second_undefined2_value",
                "second_undefined4": "second_undefined4_value"
            },
            "code": "void check_and_call_functions_00001448(int index)\n{\n    short first_short = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n    short second_short = *(short *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n    if (first_short != -1) {\n        undefined2 first_undefined2 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 8);\n        undefined4 first_undefined4 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0xc);\n        FUN_00001f80(first_undefined2, first_undefined4);\n    }\n    if (second_short != -1) {\n        undefined2 second_undefined2 = *(undefined2 *)(PTR_DAT_000014c0 + index * 0x20 + 10);\n        undefined4 second_undefined4 = *(undefined4 *)(PTR_DAT_000014c0 + index * 0x20 + 0x10);\n        FUN_00001f80(second_undefined2, second_undefined4);\n    }\n}",
            "called": [
                "FUN_00001f80"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001448",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "check_and_call_functions_00001448"
        },
        "FUN_00001688": {
            "renaming": {
                "FUN_00001688": "initialize_data_00001688",
                "FUN_00001628": "initialize_pointer",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "void initialize_data_00001688(void)\n{\n  initialize_pointer(0);\n  return;\n}",
            "called": [
                "FUN_00001628"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001688",
            "calling": [],
            "imported": false,
            "current_name": "initialize_data_00001688"
        },
        "FUN_00004042": {
            "renaming": {
                "FUN_00004042": "print_numbers_00004042",
                "param_1": "number",
                "FUN_00004f84": "print_range"
            },
            "code": "void print_numbers_00004042(int number)\n{\n  print_range(number, 0, 10);\n  return;\n}",
            "called": [
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004042",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "print_numbers_00004042"
        },
        "FUN_00000cf0": {
            "renaming": {
                "FUN_00000cf0": "are_interrupts_enabled_00000cf0",
                "uVar2": "are_irq_interrupts_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "bool are_interrupts_enabled_00000cf0(void)\n{\n  bool is_privileged_mode = isCurrentModePrivileged();\n  bool are_irq_interrupts_enabled = false;\n  enableIRQinterrupts();\n  if (is_privileged_mode) {\n    are_irq_interrupts_enabled = isIRQinterruptsEnabled();\n  }\n  return are_irq_interrupts_enabled;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cf0",
            "calling": [
                "FUN_00000930"
            ],
            "imported": false,
            "current_name": "are_interrupts_enabled_00000cf0"
        },
        "FUN_00000f8c": {
            "renaming": {
                "FUN_00000f8c": "initialize_memory_00000f8c",
                "puVar2": "memory_ptr",
                "uVar1": "num_bits_set",
                "uVar3": "memory_size",
                "iStack_24": "stack_var_1",
                "piStack_20": "stack_var_2",
                "uStack_1c": "stack_var_3",
                "FUN_00000cd0": "initialize_system",
                "FUN_000010d4": "initialize_memory_region"
            },
            "code": "void initialize_memory_00000f8c(void)\n{\n  uint num_bits_set;\n  undefined4 *memory_ptr;\n  uint memory_size;\n  int stack_var_1;\n  int *stack_var_2;\n  undefined4 stack_var_3;\n  undefined4 local_var_1;\n  undefined4 local_var_2;\n  undefined4 local_var_3;\n  initialize_system();\n  local_var_3 = *puRam00000fd4;\n  local_var_2 = 0;\n  local_var_1 = uRam00000fd8;\n  initialize_memory_00000f8c_region(uRam00000fdc, 0x100, 0xf, 0xc);\n  local_var_3 = *puRam00000fe0;\n  local_var_2 = 0;\n  local_var_1 = uRam00000fe4;\n  memory_size = 0xc;\n  initialize_memory_00000f8c_region(uRam00000fe8, 0x600, 7);\n  stack_var_3 = 0xfd3;\n  num_bits_set = count_bits_set();\n  num_bits_set = num_bits_set >> 0x1e;\n  memory_ptr = (undefined4 *)(memory_size * 0x100);\n  stack_var_1 = (memory_size >> 0x1d) << 0x11;\n  stack_var_2 = &stack_var_1;\n  if ((num_bits_set & num_bits_set - 1) != 0) {\n    handle_error(3, PTR_s_FAILED_ASSERTION__00001030);\n  }\n  *memory_ptr = 0;\n  memory_ptr[1] = 0;\n  memory_ptr[2] = num_bits_set - 1;\n  return;\n}",
            "called": [
                "FUN_00000cd0",
                "FUN_000010d4",
                "FUN_00000930"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f8c",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "initialize_memory_00000f8c"
        },
        "FUN_00002894": {
            "renaming": {
                "FUN_00002894": "update_data_00002894",
                "param_1": "data",
                "param_2": "param_2",
                "param_3": "param_3",
                "iVar1": "data_address",
                "DAT_000028e8": "DATA_ADDRESS",
                "PTR_DAT_000028ec": "PTR_DATA_ADDRESS",
                "mask": "mask"
            },
            "code": "void update_data_00002894(int data, uint32_t param_2, uint32_t param_3)\n{\n  int data_address = DAT_000028e8;\n  uint32_t mask = 0xfffffffb;\n  *(uint *)(data_address + 0x1c) = *(uint *)(data_address + 0x1c) & mask;\n  *(int *)(data_address + 8) = data - 1;\n  *(uint32_t *)PTR_DAT_000028ec = param_2;\n  *(uint32_t *)(PTR_DAT_000028ec + 4) = param_3;\n  *(uint *)(data_address + 0x1c) = *(uint *)(data_address + 0x1c) | 4;\n  send_message(0x2e, 10);\n  wait_for_response(0x2e);\n  return;\n}",
            "called": [
                "FUN_00002744",
                "FUN_00002714"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002894",
            "calling": [
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "update_data_00002894"
        },
        "FUN_00004158": {
            "renaming": {
                "FUN_00004158": "perform_operation_00004158",
                "param_1": "operation_id",
                "param_2": "data",
                "uVar1": "result",
                "PTR_DAT_000041c4": "ptr_dat_1",
                "PTR_DAT_000041c8": "ptr_dat_2",
                "PTR_DAT_000041cc": "ptr_dat_3",
                "ptr_data_16": "ptr_data_offset_16",
                "ptr_data_c": "ptr_data_offset_c",
                "ptr_data_100": "ptr_data_offset_100",
                "ptr_data_c_shifted": "ptr_data_offset_c_shifted"
            },
            "code": "int perform_operation_00004158(int operation_id, void* data)\n{\n    int result = 0;\n    int* ptr_data_16 = (int*)(data + 0x10);\n\n    if (*ptr_data_16 != 0)\n    {\n        if (operation_id != 0 && *(int*)(operation_id + 0x18) == 0)\n        {\n            call_function_000042a4();\n        }\n\n        if (data == PTR_DAT_000041c4)\n        {\n            data = *(void**)(operation_id + 4);\n        }\n        else if (data == PTR_DAT_000041c8)\n        {\n            data = *(void**)(operation_id + 8);\n        }\n        else if (data == PTR_DAT_000041cc)\n        {\n            data = *(void**)(operation_id + 0xc);\n        }\n\n        short* ptr_data_c = (short*)(data + 0xc);\n\n        if (*ptr_data_c != 0)\n        {\n            int* ptr_data_100 = (int*)(data + 100);\n            short* ptr_data_c_shifted = (short*)(data + 0xc);\n\n            if (*ptr_data_100 < 0 && *ptr_data_c_shifted < 0)\n            {\n                do_nothing_000045e8(*(int*)(data + 0x58));\n            }\n\n            result = perform_sub_operation(operation_id, data);\n\n            if (*ptr_data_100 < 0 || (int)((unsigned short)(*ptr_data_c_shifted) << 0x10) < 0)\n            {\n                return result;\n            }\n\n            do_nothing_000045ec(*(int*)(data + 0x58));\n            return result;\n        }\n    }\n\n    return result;\n}",
            "called": [
                "FUN_0000404c",
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004158",
            "calling": [
                "FUN_000041d0",
                "FUN_00006768",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "perform_operation_00004158"
        },
        "FUN_00002654": {
            "renaming": {
                "FUN_00002654": "initialize_device_and_set_parameters_00002654",
                "param_1": "device_id",
                "param_2": "parameter_1",
                "param_3": "parameter_2",
                "uVar1": "device_handle",
                "PTR_DAT_00002688": "device_parameters",
                "FUN_00002894": "set_device_parameters",
                "PTR_FUN_000026f0_1_0000268c": "device_parameter_function"
            },
            "code": "int initialize_device_and_set_parameters_00002654(int device_id, int parameter_1, int parameter_2)\n{\n  int device_handle = open_device(device_id);\n  *(int *)PTR_DAT_00002688 = parameter_1;\n  set_PTR_DAT_00002688(device_handle, PTR_FUN_000026f0_1_0000268c, parameter_2);\n  return 0;\n}",
            "called": [
                "FUN_00002894",
                "FUN_000047e4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002654",
            "calling": [
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "initialize_device_and_set_parameters_00002654"
        },
        "FUN_00002538": {
            "renaming": {
                "FUN_00002538": "set_data_00002538",
                "param_1": "data",
                "param_2": "value",
                "DAT_00002584": "data_ptr_1",
                "DAT_00002588": "data_ptr_2"
            },
            "code": "void set_data_00002538(byte data, uint value) {\n  if (data < 0) {\n    *(char *)((data & 0xf) + DAT_00002584 + 0x14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)data + DAT_00002588 + 0x300) = (char)((value & 0xff) << 4);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002538",
            "calling": [
                "FUN_0000258c"
            ],
            "imported": false,
            "current_name": "set_data_00002538"
        },
        "FUN_00004c84": {
            "renaming": {
                "FUN_00004c84": "process_data_00004c84",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "param_4": "data4",
                "*DAT_00004cb0": "*PTR_00004cb0",
                "iVar1": "ptr_i",
                "uVar2": "param_1",
                "uStack_c": "param_2",
                "uStack_8": "param_3",
                "uStack_4": "param_4",
                "FUN_000042a4": "cleanup",
                "FUNC_000057f8": "process_data_internal"
            },
            "code": "void process_data_00004c84(undefined4 data1, undefined4 data2, undefined4 data3, undefined4 data4)\n{\n    int* ptr_i = *DAT_00004cb0;\n    undefined4 param_1 = data1;\n    undefined4 param_2 = data2;\n    undefined4 param_3 = data3;\n    undefined4 param_4 = data4;\n    if ((ptr_i != 0) && (*(int *)(ptr_i + 0x18) == 0)) {\n        cleanup(ptr_i);\n    }\n    process_data_00004c84_internal(ptr_i, *(undefined4 *)(ptr_i + 8), data1, &param_2, param_1, &param_2);\n    return;\n}",
            "called": [
                "FUN_000057f8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004c84",
            "calling": [
                "FUN_00002ecc",
                "FUN_0000305c",
                "FUN_00003524",
                "FUN_00003694",
                "FUN_00002fe0",
                "FUN_00000f04",
                "FUN_00002a88",
                "FUN_0000211c",
                "FUN_00003378",
                "FUN_00002f74",
                "FUN_0000316c",
                "FUN_00000ed8",
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "process_data_00004c84"
        },
        "FUN_0000305c": {
            "renaming": {
                "FUN_0000305c": "write_data_to_device_0000305c",
                "param_1": "num_params",
                "param_2": "params",
                "uVar1": "data_element",
                "auStack_20": "data",
                "local_18": "num_data",
                "local_14": "device_info",
                "local_10": "device_id",
                "local_c": "i"
            },
            "code": "void write_data_to_device_0000305c(int num_params, undefined4 *params)\n{\n    undefined2 data[4];\n    uint num_data = num_params - 3;\n    int device_id = FUN_00004042(params[2]);\n    int device_info = FUN_00003d24(device_id);\n    if (num_params < 4) {\n        print_error(PTR_s_usage___s__s__device_id___value_0_00003154, *params, params[1]);\n    }\n    else if (device_info == 0) {\n        print_error(PTR_s_error__undefined_device_given_00003158);\n    }\n    else {\n        for (int i = 0; i < num_data; i++) {\n            data[i] = FUN_00004042(params[i + 3]);\n        }\n        if (num_params > 5) {\n            num_params = 6;\n        }\n        print_info(PTR_s_Writing_to_device___i____s_0000315c, device_id, *(undefined4 *)(device_info + 8));\n        write_to_device(data, num_data & 0xff);\n        int write_status = FUN_00003d94(device_info, data);\n        if (write_status < 1) {\n            if (write_status == -0x86) {\n                print_error(PTR_s_error__device___i_is_not_writabl_00003160, device_id);\n            }\n            else {\n                print_error(PTR_s_error__failure_to_write_to_devic_00003164, device_id);\n            }\n        }\n        else {\n            print_info(PTR_s_data_successfully_written_to_dev_00003168, device_id);\n        }\n    }\n}",
            "called": [
                "FUN_00003d24",
                "FUN_00004db8",
                "FUN_00004042",
                "FUN_00004c84",
                "FUN_00003d94",
                "FUN_00003694",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000305c",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "write_data_to_device_0000305c"
        },
        "FUN_000012b4": {
            "renaming": {
                "FUN_000012b4": "processData_000012b4",
                "param_1": "data",
                "param_2": "flag",
                "uVar1": "processedData",
                "FUN_00002364": "processDataHelper",
                "FUN_000024bc": "cleanupData"
            },
            "code": "int processData_000012b4(int data, undefined flag) {\n int processedData = processData_000012b4Helper(data + 4, flag);\n cleanupData(data);\n return processedData;\n}",
            "called": [
                "FUN_000024bc",
                "FUN_00002364"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012b4",
            "calling": [],
            "imported": false,
            "current_name": "processData_000012b4"
        },
        "FUN_00005b34": {
            "renaming": {
                "FUN_00005b34": "FUNC_00005b34"
            },
            "code": "\ncode * FUNC_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5\n                   )\n\n{\n  bool bVar1;\n  byte bVar2;\n  undefined *puVar3;\n  int iVar4;\n  code *pcVar5;\n  int iVar6;\n  undefined *puVar7;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  uint uVar12;\n  undefined *puVar13;\n  code *local_24;\n  \n  puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n  bVar2 = *(byte *)(param_2 + 6);\n  puVar7 = (undefined *)((int)param_2 + 0x43);\n  local_24 = param_4;\n  if (0x78 < bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) = bVar2;\nLAB_00005bdc:\n    puVar7 = (undefined *)((int)param_2 + 0x42);\n    uVar8 = 1;\nLAB_00005d28:\n    param_2[4] = uVar8;\n    *(undefined *)((int)param_2 + 0x43) = 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 < 99) {\n    if (bVar2 == 0) goto LAB_00005d06;\n    if (bVar2 == 0x58) {\n      *(undefined *)((int)param_2 + 0x45) = 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) = (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 = *param_2;\n    puVar9 = *param_5;\n    if ((int)(uVar10 << 0x18) < 0) {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n    }\n    else {\n      uVar8 = *puVar9;\n      *param_5 = puVar9 + 1;\n      if ((uVar10 & 0x40) != 0) {\n        uVar8 = (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 < 0) {\n      uVar8 = -uVar8;\n      *(undefined *)((int)param_2 + 0x43) = 0x2d;\n    }\n    uVar10 = 10;\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 = (uint **)*param_5;\n    uVar10 = *param_2;\n    uVar8 = param_2[5];\n    *param_5 = (uint *)(ppuVar11 + 1);\n    puVar9 = *ppuVar11;\n    if (((int)(uVar10 << 0x18) < 0) || (-1 < (int)(uVar10 << 0x19))) {\n      *puVar9 = uVar8;\n    }\n    else {\n      *(short *)puVar9 = (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] = 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 = *param_5;\n    uVar8 = *param_2;\n    *param_5 = puVar9 + 1;\n    if (((int)(uVar8 << 0x18) < 0) || (-1 < (int)(uVar8 << 0x19))) {\n      uVar8 = *puVar9;\n    }\n    else {\n      uVar8 = (uint)*(ushort *)puVar9;\n    }\n    puVar3 = PTR_s_0123456789ABCDEF_00005d78;\n    if (bVar2 == 0x6f) {\n      uVar10 = 8;\n    }\n    else {\n      uVar10 = 10;\n    }\n    break;\n  case 0x70:\n    *param_2 = *param_2 | 0x20;\n  case 0x78:\n    puVar3 = PTR_s_0123456789abcdef_00005d7c;\n    *(undefined *)((int)param_2 + 0x45) = 0x78;\nLAB_00005ca8:\n    uVar10 = *param_2;\n    uVar8 = **param_5;\n    *param_5 = *param_5 + 1;\n    if ((-1 < (int)(uVar10 << 0x18)) && ((int)(uVar10 << 0x19) < 0)) {\n      uVar8 = uVar8 & 0xffff;\n    }\n    if ((int)(uVar10 << 0x1f) < 0) {\n      *param_2 = uVar10 | 0x20;\n    }\n    if (uVar8 == 0) {\n      *param_2 = *param_2 & 0xffffffdf;\n    }\n    uVar10 = 0x10;\n    break;\n  case 0x73:\n    puVar9 = *param_5;\n    *param_5 = puVar9 + 1;\n    puVar7 = (undefined *)*puVar9;\n    iVar4 = FUN_00006010(puVar7,0,param_2[1],puVar9,param_1,param_2,param_3);\n    if (iVar4 != 0) {\n      param_2[1] = iVar4 - (int)puVar7;\n    }\n    uVar8 = param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) = 0;\nLAB_00005c36:\n  uVar12 = param_2[1];\n  param_2[2] = uVar12;\n  if (-1 < (int)uVar12) {\n    *param_2 = *param_2 & 0xfffffffb;\n  }\n  puVar13 = puVar7;\n  if ((uVar8 != 0) || (uVar12 != 0)) {\n    do {\n      puVar13 = puVar13 + -1;\n      *puVar13 = puVar3[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 = uVar10 <= uVar8;\n      uVar8 = uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 == 8) && ((int)(*param_2 << 0x1f) < 0)) && ((int)param_2[1] <= (int)param_2[4])) {\n    puVar13[-1] = 0x30;\n    puVar13 = puVar13 + -1;\n  }\n  param_2[4] = (int)puVar7 - (int)puVar13;\n  puVar7 = puVar13;\nLAB_00005c84:\n  iVar4 = FUN_00005a58(param_1,param_2,&local_24,param_3,param_4);\n  if ((iVar4 == -1) || (iVar4 = (*param_4)(param_1,param_3,puVar7,param_2[4]), iVar4 == -1)) {\nLAB_00005c98:\n    pcVar5 = (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 << 0x1e) < 0) {\n      for (iVar4 = 0; iVar4 < (int)(param_2[3] - (int)local_24); iVar4 = iVar4 + 1) {\n        iVar6 = (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar6 == -1) goto LAB_00005c98;\n      }\n    }\n    pcVar5 = (code *)param_2[3];\n    if ((int)(code *)param_2[3] < (int)local_24) {\n      pcVar5 = local_24;\n    }\n  }\n  return pcVar5;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_00005a58"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00005b34",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "FUNC_00005b34"
        },
        "FUN_0000058e": {
            "renaming": {
                "FUN_0000058e": "update_linked_list_0000058e",
                "param_1": "head_ptr",
                "param_2": "new_node_ptr",
                "*param_1": "*head_ptr",
                "*param_2": "*new_node_ptr",
                "*(undefined4 *)*param_1": "*(undefined4 *)*head_ptr",
                "*(undefined4 **) *param_1": "*(undefined4 **) *head_ptr"
            },
            "code": "void update_linked_list_0000058e(int *head_ptr, undefined4 *new_node_ptr) {\n  if (*head_ptr == 0) {\n    *new_node_ptr = new_node_ptr;\n  }\n  else {\n    *new_node_ptr = *(undefined4 *)*head_ptr;\n    *(undefined4 **) *head_ptr = new_node_ptr;\n  }\n  *head_ptr = (int)new_node_ptr;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000058e",
            "calling": [
                "FUN_00000698"
            ],
            "imported": false,
            "current_name": "update_linked_list_0000058e"
        },
        "FUN_0000656c": {
            "renaming": {
                "FUN_0000656c": "FUNC_0000656c"
            },
            "code": "\nundefined4 FUNC_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  code *pcVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  undefined4 *puVar7;\n  uint *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  int unaff_r9;\n  int iVar11;\n  undefined4 local_34 [4];\n  \n  local_34[0] = *(undefined4 *)PTR_PTR_DAT_00006744;\n  local_34[1] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 4);\n  local_34[2] = *(undefined4 *)(PTR_PTR_DAT_00006744 + 8);\n  pcVar3 = (code *)PTR_LAB_00004f80_1_0000674c;\n  if (param_2[6] != 3) {\n    pcVar3 = (code *)PTR_LAB_00005fd4_1_00006748;\n  }\n  uVar6 = param_2[2];\n  uVar4 = uVar6 - 1;\n  if (0x15c < uVar4) {\n    unaff_r9 = uVar6 - 0x15d;\n    uVar6 = 0x15d;\n  }\n  if (0x15c < uVar4) {\n    param_2[2] = uVar6;\n  }\n  puVar10 = param_2 + 7;\n  if (uVar4 < 0x15d) {\n    unaff_r9 = 0;\n  }\n  *param_2 = *param_2 | 0xd00;\n  iVar11 = 0;\n  puVar9 = puVar10;\n  do {\n    iVar1 = FUN_00006010(local_34[iVar11],**param_3,2);\n    if (iVar1 != 0) {\n      if (iVar11 == 1) {\n        if (param_2[1] == 0) {\n          param_2[1] = 8;\n          *param_2 = *param_2 | 0x200;\n        }\n        uVar4 = *param_2 & 0xfffffaff;\nLAB_000065f4:\n        *param_2 = uVar4;\n      }\n      else if (iVar11 == 2) {\n        if ((*param_2 & 0x600) != 0x200) goto LAB_00006624;\n        param_2[1] = 0x10;\n        uVar4 = *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar4 = param_2[2];\n      param_2[2] = uVar4 - 1;\n      if (uVar4 != 0) {\n        pbVar5 = *param_3;\n        *param_3 = pbVar5 + 1;\n        puVar8 = (uint *)((int)puVar9 + 1);\n        *(byte *)puVar9 = *pbVar5;\n        pbVar5 = param_3[1];\n        param_3[1] = pbVar5 + -1;\n        puVar9 = puVar8;\n        if (((int)(pbVar5 + -1) < 1) &&\n           (iVar1 = (*(code *)param_2[0x60])(param_1,param_3), iVar1 != 0)) {\n          iVar11 = 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar11 = iVar11 + 1;\n  } while (iVar11 != 3);\n  if (param_2[1] == 0) {\n    param_2[1] = 10;\n  }\n  FUN_0000687c(param_2[5],(int)PTR_DAT_00006750 - param_2[1]);\n  iVar11 = 0;\n  while( true ) {\n    puVar8 = puVar9;\n    if (param_2[2] == 0) break;\n    pbVar5 = *param_3;\n    uVar4 = (uint)*pbVar5;\n    if (*(char *)(param_2[5] + uVar4) == '\\0') break;\n    if ((uVar4 == 0x30) && ((int)(*param_2 << 0x14) < 0)) {\n      iVar11 = iVar11 + 1;\n      if (unaff_r9 != 0) {\n        unaff_r9 = unaff_r9 + -1;\n        param_2[2] = param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 = *param_2 & 0xfffff6ff;\n      puVar8 = (uint *)((int)puVar9 + 1);\n      *(byte *)puVar9 = *pbVar5;\n    }\n    pbVar5 = param_3[1];\n    param_3[1] = pbVar5 + -1;\n    if ((int)(pbVar5 + -1) < 1) {\n      iVar1 = (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar1 != 0) break;\n    }\n    else {\n      *param_3 = *param_3 + 1;\n    }\n    param_2[2] = param_2[2] - 1;\n    puVar9 = puVar8;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 << 0x17) < 0) {\n    if (puVar10 < puVar8) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar8 + -1),param_3);\n      puVar8 = (uint *)((int)puVar8 + -1);\n    }\n    if (puVar8 == puVar10) {\n      return 1;\n    }\n  }\n  if ((*param_2 & 0x10) == 0) {\n    *(byte *)puVar8 = 0;\n    uVar2 = (*pcVar3)(param_1,puVar10,0,param_2[1]);\n    puVar7 = (undefined4 *)*param_4;\n    uVar4 = *param_2;\n    *param_4 = puVar7 + 1;\n    puVar7 = (undefined4 *)*puVar7;\n    if ((uVar4 & 0x20) == 0) {\n      if ((int)(uVar4 << 0x1f) < 0) {\n        *(short *)puVar7 = (short)uVar2;\n      }\n      else {\n        *puVar7 = uVar2;\n      }\n    }\n    else {\n      *puVar7 = uVar2;\n    }\n    param_2[3] = param_2[3] + 1;\n  }\n  param_2[4] = (uint)((int)puVar8 + param_2[4] + (iVar11 - (int)puVar10));\n  return 0;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006010"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0000656c",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "FUNC_0000656c"
        },
        "FUN_000025f4": {
            "renaming": {
                "FUN_000025f4": "initialize_system_000025f4",
                "FUN_000027b0": "initialize_hardware"
            },
            "code": "void initialize_system_000025f4(void)\n{\n  initialize_hardware();\n  return;\n}",
            "called": [
                "FUN_000027b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000025f4",
            "calling": [
                "FUN_00002396"
            ],
            "imported": false,
            "current_name": "initialize_system_000025f4"
        },
        "FUN_00001ddc": {
            "renaming": {
                "FUN_00001ddc": "print_char_after_tab_00001ddc",
                "param_1": "input_char",
                "DAT_00001e08": "output_stream",
                "FUN_00001da2": "get_char",
                "FUN_00001d3a": "print_to_screen",
                "cVar1": "char_to_print"
            },
            "code": "void print_char_after_tab_00001ddc(undefined2 input_char)\n{\n  char char_to_print;\n  char_to_print = get_char(input_char);\n  print_to_screen(DAT_00001e08, char_to_print + '\t');\n  return;\n}",
            "called": [
                "FUN_00001d3a",
                "FUN_00001da2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ddc",
            "calling": [
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "print_char_after_tab_00001ddc"
        },
        "FUN_00002ecc": {
            "renaming": {
                "FUN_00002ecc": "read_data_from_device_and_print_00002ecc",
                "param_1": "device_address",
                "param_2": "data_size",
                "uVar1": "device_type",
                "uVar2": "device_data",
                "auStack_1c": "data_buffer",
                "local_14": "read_size"
            },
            "code": "void read_data_from_device_and_print_00002ecc(uint32_t device_address, int data_size) {\n  uint32_t read_size;\n  uint8_t data_buffer[data_size];\n  read_size = read_from_device(device_address, data_buffer);\n  if (read_size < 1) {\n    print_error(\"error: failed to read from device\", device_address);\n  }\n  else {\n    uint32_t device_data = *(uint32_t *)(data_buffer + 8);\n    uint8_t device_type = *(uint8_t *)(*(int *)(data_buffer + 12) + 8);\n    print_data(\"Reading from %i: %s %s\", device_address, device_data, get_device_type_string(device_type));\n    process_data(data_buffer, read_size & 0xff);\n  }\n  return;\n}",
            "called": [
                "FUN_00003d64",
                "FUN_00004c84",
                "FUN_000039e8",
                "FUN_00003694"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002ecc",
            "calling": [
                "FUN_00002f30",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "read_data_from_device_and_print_00002ecc"
        },
        "FUN_00000d76": {
            "renaming": {
                "FUN_00000d76": "clearMemoryAfterFunctionCall_00000d76",
                "param_1": "functionParam",
                "param_2": "memoryParam",
                "puVar1": "memoryPointer",
                "FUN_00000d44": "getMemoryPointer",
                "*puVar1": "*memoryPointer"
            },
            "code": "void clearMemoryAfterFunctionCall_00000d76(undefined4 functionParam, undefined memoryParam)\n{\n  undefined4 *memoryPointer;\n  memoryPointer = (undefined4 *)getMemoryPointer(functionParam, memoryParam);\n  *memoryPointer = 0;\n  return;\n}",
            "called": [
                "FUN_00000d44"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d76",
            "calling": [
                "FUN_00000d9c"
            ],
            "imported": false,
            "current_name": "clearMemoryAfterFunctionCall_00000d76"
        },
        "FUN_000057a8": {
            "renaming": {
                "FUN_000057a8": "decrement_and_append_000057a8",
                "param_1": "count",
                "param_2": "value",
                "param_3": "buffer",
                "iVar1": "remaining_count",
                "puVar2": "current_position",
                "FUN_00005404": "allocate_memory"
            },
            "code": "int decrement_and_append_000057a8(int count, int value, int* buffer) {\n  int remaining_count = buffer[2] - 1;\n  buffer[2] = remaining_count;\n  if ((remaining_count < 0) && ((remaining_count < (int)buffer[6] || (value == 10)))) {\n    int result = allocate_memory();\n    return result;\n  }\n  undefined *current_position = (undefined *)*buffer;\n  *buffer = current_position + 1;\n  *current_position = (char)value;\n  return value;\n}",
            "called": [
                "FUN_00005404"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057a8",
            "calling": [
                "FUN_000057d2"
            ],
            "imported": false,
            "current_name": "decrement_and_append_000057a8"
        },
        "FUN_00001696": {
            "renaming": {
                "FUN_00001696": "calculate_offset_00001696",
                "param_1": "memory_address",
                "param_2": "offset",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_offset_00001696(uint32_t memory_address, int offset) {\n\tint shifted_memory_address = (memory_address & 0xfffff) << 5;\n\tint masked_memory_address = (memory_address & 0xf0000000);\n\tint result = (offset * 4) + shifted_memory_address + masked_memory_address + 0x2000000;\n\treturn result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001696",
            "calling": [
                "FUN_00001710",
                "FUN_000016c8",
                "FUN_000016ec"
            ],
            "imported": false,
            "current_name": "calculate_offset_00001696"
        },
        "FUN_000008b8": {
            "renaming": {
                "FUN_000008b8": "count_elf32_rel_entries_000008b8",
                "local_c": "entry_ptr",
                "PTR_DAT_000008f4": "elf32_rel_array_start",
                "DAT_000008f8": "elf32_rel_entry_value",
                "PTR_Elf32_Rel_ARRAY_000008fc": "elf32_rel_array_end"
            },
            "code": "int count_elf32_rel_entries_000008b8(void)\n{\n  int *entry_ptr;\n  for (entry_ptr = (int *)PTR_DAT_000008f4; (*entry_ptr == DAT_000008f8 && (entry_ptr < PTR_Elf32_Rel_ARRAY_000008fc)); entry_ptr = entry_ptr + 1)\n  {\n  }\n  return ((int)PTR_Elf32_Rel_ARRAY_000008fc - (int)entry_ptr >> 2) << 2;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000008b8",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_elf32_rel_entries_000008b8"
        },
        "FUN_000024bc": {
            "renaming": {
                "FUN_000024bc": "check_and_print_000024bc",
                "param_1": "input",
                "uVar1": "undefined_variable",
                "uVar2": "random_number",
                "iVar3": "ptr_input_minus_3",
                "FUN_00000cd0": "generate_random_number",
                "FUN_00000d0c": "print_error",
                "FUN_0000240c": "subtract_3_from_input",
                "FUN_00000698": "print_result",
                "FUN_00000738": "print_output"
            },
            "code": "void check_and_print_000024bc(int *input)\n{\n    undefined uVar1;\n    undefined4 random_number = generate_random_number();\n    if (*input == 0) {\n        print_error(random_number);\n    }\n    else if (*input == -1) {\n        *input = 0;\n        print_error(random_number);\n    }\n    else {\n        int ptr_input_minus_3 = subtract_3_from_input(input);\n        print_result(ptr_input_minus_3 - 8, 10);\n        if (*input == 0) {\n            *input = -1;\n        }\n        uVar1 = *(undefined *)(ptr_input_minus_3 - 3);\n        print_error(random_number);\n        print_output(uVar1);\n    }\n    return;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_0000240c",
                "FUN_00000738",
                "FUN_00000698"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000024bc",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "check_and_print_000024bc"
        },
        "FUN_00000490": {
            "renaming": {
                "FUN_00000490": "calculate_result_00000490",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "FUN_00000e14": "perform_calculation"
            },
            "code": "int calculate_result_00000490(int input1, int input2, int input3, int input4) {\n  int result = perform_calculation(input3, input4);\n  return result;\n}",
            "called": [
                "FUN_00000e14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000490",
            "calling": [
                "FUN_00004dc8"
            ],
            "imported": false,
            "current_name": "calculate_result_00000490"
        },
        "FUN_0000091c": {
            "renaming": {
                "FUN_0000091c": "get_pointer_data_0000091c",
                "PTR_DAT_0000092c": "pointer_data"
            },
            "code": "const char* get_pointer_data_0000091c() {\n  return PTR_DAT_0000092c;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000091c",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_pointer_data_0000091c"
        },
        "FUN_00001f80": {
            "renaming": {
                "FUN_00001f80": "update_data_in_buffer_00001f80",
                "param_1": "buffer_index",
                "param_2": "new_data",
                "iVar1": "index_offset",
                "iVar2": "buffer_index_offset",
                "uVar3": "param_1",
                "uVar4": "index_offset",
                "uVar5": "current_data",
                "FUN_00001ddc": "initialize_buffer",
                "FUN_00001d5e": "get_buffer_index",
                "FUN_00001dc0": "get_index_offset",
                "FUN_00001da2": "get_param_1",
                "FUN_00001ec4": "call_another_function"
            },
            "code": "void update_data_in_buffer_00001f80(int buffer_index, int new_data) {\n  int index_offset = get_index_offset(buffer_index);\n  uint32_t current_data = *(uint32_t *)(buffer_index + index_offset * 4);\n  *(uint32_t *)(buffer_index + index_offset * 4) = new_data;\n  if ((current_data & 0xf0000) != 0) {\n    undefined4 param_1 = get_param_1(buffer_index);\n    int index_offset = get_index_offset(buffer_index);\n    call_another_function(param_1, index_offset);\n  }\n  return;\n}",
            "called": [
                "FUN_00001d5e",
                "FUN_00001ec4",
                "FUN_00001da2",
                "FUN_00001ddc",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001f80",
            "calling": [
                "FUN_00001eea",
                "FUN_00001448"
            ],
            "imported": false,
            "current_name": "update_data_in_buffer_00001f80"
        },
        "FUN_00000e64": {
            "renaming": {
                "FUN_00000e64": "set_flags_and_call_functions_00000e64",
                "FUN_00001274": "call_function1",
                "FUN_00001eea": "call_function2",
                "FUN_00001ff6": "call_function3",
                "DAT_00000ed0": "data1",
                "DAT_00000ed4": "data2",
                "PTR_": "ptr_"
            },
            "code": "void set_flags_and_call_functions_00000e64(void)\n{\n  uint32_t* ptr1 = (uint32_t*)(FUN_00001034 + DAT_00000ed0 + 4);\n  uint32_t* ptr2 = (uint32_t*)(DAT_00000ed4 + 0x48);\n  *ptr1 |= 0x200;\n  *ptr2 &= 0xfefff8ff;\n  call_function1();\n  call_function2(0x2056,0x80);\n  call_function2(0x511a,0x80);\n  call_function2(0x2055,0x80);\n  call_function3(0x2056);\n  call_function3(0x511a);\n  call_function3(0x2055);\n  return;\n}",
            "called": [
                "FUN_00001eea",
                "FUN_00001274",
                "FUN_00001ff6"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e64",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "set_flags_and_call_functions_00000e64"
        },
        "FUN_000026e4": {
            "renaming": {
                "FUN_000026e4": "execute_function_000026e4",
                "FUN_00002970": "initialize_resources"
            },
            "code": "void execute_function_000026e4(void)\n{\n  initialize_resources();\n  return;\n}",
            "called": [
                "FUN_00002970"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026e4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "execute_function_000026e4"
        },
        "FUN_00000d44": {
            "renaming": {
                "FUN_00000d44": "calculate_offset_00000d44",
                "param_1": "address",
                "param_2": "index",
                "PTR_": "PTR_",
                "DAT_": "DAT_"
            },
            "code": "int calculate_offset_00000d44(uint32_t address, int index) {\n    uint32_t high_bits = address & 0xf0000000;\n    uint32_t low_bits = address & 0xfffff;\n    uint32_t shifted_low_bits = low_bits << 5;\n    int offset = index * 4 + high_bits + shifted_low_bits + 0x2000000;\n    return offset;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d44",
            "calling": [
                "FUN_00000d76"
            ],
            "imported": false,
            "current_name": "calculate_offset_00000d44"
        },
        "FUN_00000698": {
            "renaming": {
                "FUN_00000698": "update_status_00000698",
                "param_1": "status",
                "param_2": "index",
                "PTR_DAT_00000730": "sensor_data",
                "PTR_DAT_00000734": "status_reg",
                "get_sensor_value": "get_sensor_reading",
                "set_sensor_value": "set_sensor_reading"
            },
            "code": "void update_status_00000698(int status, uint8_t index) {\n    if (status < 9) {\n        uint8_t sensor_id = *(uint8_t *)(index + 5);\n        if ((8 < *(uint8_t *)(index + 4)) && (get_sensor_value(sensor_id) == 0)) {\n            *PTR_DAT_00000734 = *PTR_DAT_00000734 & ~(1 << sensor_id);\n        }\n    }\n    else if (*(uint8_t *)(index + 4) < 9) {\n        set_sensor_value(*(uint8_t *)(index + 5), index + 8);\n        *PTR_DAT_00000734 = *PTR_DAT_00000734 | 1 << *(uint8_t *)(index + 5);\n    }\n    *(uint8_t *)(index + 4) = (uint8_t)status;\n    return;\n}",
            "called": [
                "FUN_0000058e",
                "FUN_000005ca"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000698",
            "calling": [
                "FUN_000024bc",
                "FUN_00000794",
                "FUN_000010d4",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "update_status_00000698"
        },
        "FUN_00000cd0": {
            "renaming": {
                "FUN_00000cd0": "check_irq_interrupts_enabled_00000cd0",
                "uVar2": "are_interrupts_enabled",
                "bVar1": "is_privileged_mode"
            },
            "code": "check_irq_interrupts_enabled_00000cd0bcheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0pcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0vcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0gcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0mcheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0=check_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0(check_irq_interrupts_enabled_00000cd0bcheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0)check_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0Ccheck_irq_interrupts_enabled_00000cd0ucheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0Mcheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0Pcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0vcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0gcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0(check_irq_interrupts_enabled_00000cd0)check_irq_interrupts_enabled_00000cd0;check_irq_interrupts_enabled_00000cd0\ncheck_irq_interrupts_enabled_00000cd0bcheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0ucheck_irq_interrupts_enabled_00000cd0pcheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0bcheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0=check_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0fcheck_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0;check_irq_interrupts_enabled_00000cd0\ncheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0fcheck_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0(check_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0pcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0vcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0gcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0mcheck_irq_interrupts_enabled_00000cd0ocheck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0)check_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0{check_irq_interrupts_enabled_00000cd0\ncheck_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0ucheck_irq_interrupts_enabled_00000cd0pcheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0bcheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0=check_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0Icheck_irq_interrupts_enabled_00000cd0Rcheck_irq_interrupts_enabled_00000cd0Qcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0ucheck_irq_interrupts_enabled_00000cd0pcheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0Echeck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0bcheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0(check_irq_interrupts_enabled_00000cd0)check_irq_interrupts_enabled_00000cd0;check_irq_interrupts_enabled_00000cd0\ncheck_irq_interrupts_enabled_00000cd0}check_irq_interrupts_enabled_00000cd0\ncheck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0bcheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0Icheck_irq_interrupts_enabled_00000cd0Rcheck_irq_interrupts_enabled_00000cd0Qcheck_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0ucheck_irq_interrupts_enabled_00000cd0pcheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0(check_irq_interrupts_enabled_00000cd0)check_irq_interrupts_enabled_00000cd0;check_irq_interrupts_enabled_00000cd0\ncheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0ucheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0 check_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0icheck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0rcheck_irq_interrupts_enabled_00000cd0ucheck_irq_interrupts_enabled_00000cd0pcheck_irq_interrupts_enabled_00000cd0tcheck_irq_interrupts_enabled_00000cd0scheck_irq_interrupts_enabled_00000cd0_check_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0ncheck_irq_interrupts_enabled_00000cd0acheck_irq_interrupts_enabled_00000cd0bcheck_irq_interrupts_enabled_00000cd0lcheck_irq_interrupts_enabled_00000cd0echeck_irq_interrupts_enabled_00000cd0dcheck_irq_interrupts_enabled_00000cd0;check_irq_interrupts_enabled_00000cd0",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cd0",
            "calling": [
                "FUN_00001c84",
                "FUN_00000f04",
                "FUN_00000f8c",
                "FUN_00000e58",
                "FUN_00000428",
                "FUN_000024bc",
                "FUN_00000794",
                "FUN_000010d4",
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "check_irq_interrupts_enabled_00000cd0"
        },
        "FUN_00000cc0": {
            "renaming": {
                "FUN_00000cc0": "check_interrupts_enabled_00000cc0",
                "uVar2": "interrupts_enabled",
                "bVar1": "is_privileged",
                "isCurrentModePrivileged": "is_current_mode_privileged",
                "isIRQinterruptsEnabled": "is_irq_interrupts_enabled",
                "disableIRQinterrupts": "disable_irq_interrupts",
                "uRam00000ccc": "interrupt_control_block"
            },
            "code": "int check_interrupts_enabled_00000cc0(void)\n{\n  bool is_privileged;\n  int interrupts_enabled = 0;\n\n  set_interrupt_priority(10, interrupt_control_block);\n  is_privileged = (bool)is_current_mode_privileged();\n  if (is_privileged) {\n    interrupts_enabled = is_irq_interrupts_enabled();\n  }\n  disable_irq_interrupts();\n  return interrupts_enabled;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000cc0",
            "calling": [
                "FUN_00000dc0"
            ],
            "imported": false,
            "current_name": "check_interrupts_enabled_00000cc0"
        },
        "FUN_00002994": {
            "renaming": {
                "FUN_00002994": "execute_function_00002994",
                "DAT_000029f8": "data",
                "PTR_DAT_000029fc": "function_pointer"
            },
            "code": "void execute_function_00002994(void)\n{\n  int DAT_000029f8 = DAT_000029f8;\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 4) != 0) && (*(int *)PTR_DAT_000029fc != 0)) {\n    *(uint *)(DAT_000029f8 + 0x1c) = *(uint *)(DAT_000029f8 + 0x1c) & 0xfffffffb;\n    (**(code **)PTR_DAT_000029fc)(*(undefined4 *)(PTR_DAT_000029fc + 4));\n  }\n  if (((*(uint *)(DAT_000029f8 + 0x14) & 2) != 0) && (*(int *)(PTR_DAT_000029fc + 8) != 0)) {\n    (**(code **)(PTR_DAT_000029fc + 8))(*(undefined4 *)(PTR_DAT_000029fc + 0xc));\n  }\n  execute_another_function();\n  return;\n}",
            "called": [
                "FUN_00002798"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002994",
            "calling": [],
            "imported": false,
            "current_name": "execute_function_00002994"
        },
        "FUN_00000d2a": {
            "renaming": {
                "FUN_00000d2a": "get_current_exception_number_if_privileged_00000d2a",
                "bVar1": "is_privileged_mode",
                "uVar2": "current_exception_number"
            },
            "code": "uint get_current_exception_number_if_privileged_00000d2a(void)\n{\n  bool is_privileged_mode;\n  uint current_exception_number;\n  \n  current_exception_number = 0;\n  is_privileged_mode = (bool)isCurrentModePrivileged();\n  if (is_privileged_mode) {\n    current_exception_number = getCurrentExceptionNumber();\n    current_exception_number = current_exception_number & 0x1f;\n  }\n  return current_exception_number;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d2a",
            "calling": [
                "FUN_00000738"
            ],
            "imported": false,
            "current_name": "get_current_exception_number_if_privileged_00000d2a"
        },
        "FUN_00001ff6": {
            "renaming": {
                "FUN_00001ff6": "set_bit_in_integer_00001ff6",
                "param_1": "bit_position",
                "uVar1": "bit_mask",
                "iVar2": "integer_ptr",
                "*(int *)(iVar2 + 4)": "*(integer_ptr + 1)",
                "FUN_00001dc0": "get_bit_mask",
                "FUN_00001d80": "get_integer_ptr"
            },
            "code": "void set_bit_in_integer_00001ff6(int bit_position){\n  uint8_t bit_mask = get_bit_mask(bit_position);\n  int* integer_ptr = get_integer_ptr();\n  *(integer_ptr + 1) = 1 << bit_mask;\n  return;\n}",
            "called": [
                "FUN_00001d80",
                "FUN_00001dc0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ff6",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "set_bit_in_integer_00001ff6"
        },
        "FUN_000013b8": {
            "renaming": {
                "FUN_000013b8": "store_data_000013b8",
                "param_1": "index",
                "param_2": "data",
                "param_3": "flag",
                "param_4": "unused",
                "uVar1": "result",
                "PTR_s_FAILED_ASSERTION__0000143c": "FAILED_ASSERTION",
                "PTR_DAT_00001440": "DATA_ARRAY",
                "FUN_00001448": "update_data",
                "FUN_00001392": "process_data",
                "PTR_DAT_00001444": "CONFIG_ARRAY",
                "FUN_000014c4": "process_result"
            },
            "code": "int store_data_000013b8(int index, int data, int flag, int unused) {\\n  \\n  if (index != 0) {\\n    print_error(3, PTR_s_FAILED_ASSERTION__0000143c);\\n  }\\n  *(int *)(PTR_DAT_00001440 + index * 8) = data;\\n  *(int *)(PTR_DAT_00001440 + index * 8 + 4) = flag;\\n  update_data(index);\\n  process_data(*(int *)(PTR_DAT_00001444 + index * 0x20 + 0x18), PTR_DAT_00001444[index * 0x20 + 0x1c]);\\n  if (PTR_DAT_00001444[index * 0x20 + 0x1e] == \"\\0\") {\\n    process_result(index, unused);\\n    return 0;\\n  }\\n  else {\\n    return -1;\\n  }\\n}",
            "called": [
                "FUN_00000f04",
                "FUN_00001392",
                "FUN_00001448",
                "FUN_000014c4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000013b8",
            "calling": [
                "FUN_00000df4"
            ],
            "imported": false,
            "current_name": "store_data_000013b8"
        },
        "FUN_00002a88": {
            "renaming": {
                "FUN_00002a88": "print_command_descriptions_00002a88",
                "param_1": "commands",
                "local_18": "command_ptr",
                "local_10": "index",
                "local_c": "description_ptr",
                "PTR_s___20s__s_00002b04": "COMMAND_HEADER",
                "PTR_s_Command_00002b00": "COMMAND_DESCRIPTION",
                "PTR_s_Description_00002afc": "COMMAND_DESCRIPTION",
                "PTR_s__________________________________00002b08": "COMMAND_FOOTER",
                "PTR_PTR_s_reboot_00002b0c": "REBOOT_COMMAND"
            },
            "code": "void print_command_descriptions_00002a88(int *commands)\n{\n  int *command_ptr [2];\n  uint index;\n  int *description_ptr;\n\n  print_header(\"\\n%s %s\\n\", PTR_s___20s__s_00002b04, PTR_s_Command_00002b00);\n  print_footer(PTR_s__________________________________00002b08);\n  command_ptr[0] = commands;\n  command_ptr[1] = (int *)PTR_PTR_s_reboot_00002b0c;\n  for (index = 0; index < 2; index = index + 1) {\n    description_ptr = command_ptr[index];\n    if (description_ptr != (int *)0x0) {\n      for (; *description_ptr != 0; description_ptr = description_ptr + 3) {\n        print_command_description(\"%s %s\", *description_ptr, description_ptr[1]);\n      }\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00004c84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a88",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "print_command_descriptions_00002a88"
        },
        "FUN_00002f30": {
            "renaming": {
                "FUN_00002f30": "iterate_list_and_call_functions_00002f30",
                "local_10": "index",
                "local_c": "current_node",
                "FUN_00002ecc": "call_function_with_index_and_node",
                "FUN_00004db8": "call_function_with_ptr"
            },
            "code": "void iterate_list_and_call_functions_00002f30(void)\n{\n  int index = 0;\n  undefined4 *current_node = *(undefined4 **)PTR_DAT_00002f6c;\n  while (current_node != (undefined4 *)0x0) {\n    call_function_with_index_and_node(index, current_node);\n    call_function_with_ptr(PTR_DAT_00002f70);\n    index++;\n    current_node = (undefined4 *)*current_node;\n  }\n  return;\n}",
            "called": [
                "FUN_00002ecc",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f30",
            "calling": [
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "iterate_list_and_call_functions_00002f30"
        },
        "FUN_00001e44": {
            "renaming": {
                "FUN_00001e44": "write_bits_to_memory_00001e44",
                "param_1": "memory_address",
                "param_2": "bit_position",
                "param_3": "value",
                "iVar1": "byte_offset",
                "PTR_DAT_00001ec0": "memory_pointer"
            },
            "code": "void write_bits_to_memory_00001e44(int memory_address, uint bit_position, int value) {\n  int byte_offset = (int)bit_position >> 3;\n  uint* target_byte = (uint*)(PTR_DAT_00001ec0 + (byte_offset + memory_address * 4) * 4);\n  int bit_offset = (bit_position & 7) << 2;\n  uint mask = ~(0xf << bit_offset);\n  *target_byte = (*target_byte & mask) | value << bit_offset;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001e44",
            "calling": [
                "FUN_00001ec4"
            ],
            "imported": false,
            "current_name": "write_bits_to_memory_00001e44"
        },
        "FUN_00001318": {
            "renaming": {
                "FUN_00001318": "set_bit_at_index_00001318",
                "param_1": "index",
                "DAT_00001344": "ptr_start"
            },
            "code": "void set_bit_at_index_00001318(uint8_t index) {\n    uint32_t *ptr = (uint32_t *)(DAT_00001344 + ((uint32_t)index >> 5) * 4);\n    uint32_t bit_mask = 1 << (index & 0x1f);\n    *ptr = bit_mask;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001318",
            "calling": [
                "FUN_000014c4"
            ],
            "imported": false,
            "current_name": "set_bit_at_index_00001318"
        },
        "FUN_00000900": {
            "renaming": {
                "FUN_00000900": "get_main_stack_pointer_00000900",
                "uVar1": "main_stack_pointer"
            },
            "code": "uint32_t get_main_stack_pointer_00000900(void)\n{\n  uint32_t main_stack_pointer;\n  main_stack_pointer = getMainStackPointer();\n  return main_stack_pointer;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000900",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "get_main_stack_pointer_00000900"
        },
        "FUN_00004274": {
            "renaming": {
                "FUN_00004274": "do_nothing_with_pointer_00004274",
                "PTR_DAT_0000427c": "PTR_data"
            },
            "code": "void do_nothing_with_pointer_00004274(void)\n{\n  do_nothing(PTR_DAT_0000427c);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004274",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_with_pointer_00004274"
        },
        "FUN_00002fe0": {
            "renaming": {
                "FUN_00002fe0": "check_device_id_00002fe0",
                "param_1": "num_params",
                "param_2": "params",
                "iVar1": "device_id",
                "uVar2": "device_id_ptr",
                "PTR_s_usage___s__s__device_id__all_00003050": "USAGE_STRING",
                "PTR_DAT_00003054": "DEVICE_IDS",
                "FUN_00004e52": "get_device_id",
                "FUN_00002f30": "print_usage_error",
                "FUN_00004042": "get_device_id_ptr",
                "FUN_00003d24": "set_device_id",
                "PTR_s_error__undefined_device_id_given_00003058": "ERROR_STRING",
                "FUN_00004db8": "print_error",
                "FUN_00002ecc": "set_device_id"
            },
            "code": "void check_device_id_00002fe0(int num_params, undefined4 *params)\n{\n  int device_id;\n  undefined4 device_id_ptr;\n  if (num_params < 3) {\n    print_usage_error(PTR_s_usage___s__s__device_id__all_00003050, *params, params[1]);\n  }\n  else {\n    device_id = get_device_id(params[2], PTR_DAT_00003054);\n    if (device_id == 0) {\n      print_error(PTR_s_error__undefined_device_id_given_00003058);\n    }\n    else {\n      device_id_ptr = get_device_id_ptr(params[2], device_id);\n      set_device_id(device_id_ptr, device_id);\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00002ecc",
                "FUN_00003d24",
                "FUN_00004db8",
                "FUN_00004042",
                "FUN_00004c84",
                "FUN_00002f30",
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002fe0",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "check_device_id_00002fe0"
        },
        "FUN_00001dc0": {
            "renaming": {
                "FUN_00001dc0": "get_last_six_bits_00001dc0",
                "param_1": "number"
            },
            "code": "ushort get_last_six_bits_00001dc0(ushort number) {\n    ushort last_six_bits = number & 0x3f;\n    return last_six_bits;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001dc0",
            "calling": [
                "FUN_00001eea",
                "FUN_00001f80",
                "FUN_00001ff6"
            ],
            "imported": false,
            "current_name": "get_last_six_bits_00001dc0"
        },
        "FUN_00000df4": {
            "renaming": {
                "FUN_00000df4": "initialize_data_00000df4",
                "PTR_FUN_000012b4_1_00000e10": "function_pointer_1",
                "DAT_00000e0c": "data",
                "FUN_000013b8": "function_2"
            },
            "code": "void initialize_data_00000df4(void)\n{\n  int starting_address = 0x1c200;\n  PTR_FUN_000012b4_1_00000e10 = &function_1;\n  DAT_00000e0c = 0x1234;\n  function_2(0, starting_address, PTR_FUN_000012b4_1_00000e10, DAT_00000e0c);\n  return;\n}",
            "called": [
                "FUN_000013b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000df4",
            "calling": [
                "FUN_00000410"
            ],
            "imported": false,
            "current_name": "initialize_data_00000df4"
        },
        "FUN_00002400": {
            "renaming": {
                "FUN_00002400": "do_nothing_00002400"
            },
            "code": "\nvoid do_nothing_00002400(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002400",
            "calling": [
                "FUN_00000f04"
            ],
            "imported": false,
            "current_name": "do_nothing_00002400"
        },
        "FUN_00002eb4": {
            "renaming": {
                "FUN_00002eb4": "run_application_00002eb4",
                "FUN_0000211c": "initialize_application"
            },
            "code": "int run_application_00002eb4(void)\n{\n  initialize_application();\n  return 0;\n}",
            "called": [
                "FUN_0000211c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002eb4",
            "calling": [],
            "imported": false,
            "current_name": "run_application_00002eb4"
        },
        "FUN_0000328c": {
            "renaming": {
                "FUN_0000328c": "decode_data_and_compute_checksum_0000328c",
                "param_1": "data_to_decode",
                "param_2": "output_data",
                "local_10": "current_index",
                "local_a": "decoded_value",
                "FUN_00004f84": "decode_value",
                "iVar1": "checksum"
            },
            "code": "int decode_data_and_compute_checksum_0000328c(int* data_to_decode, int* output_data){\n    int decoded_value;\n    int current_index = 0;\n\n    decoded_value = decode_value(*data_to_decode, &current_index, 10);\n    output_data[5] = decoded_value - 1892;\n\n    decoded_value = decode_value(current_index + 1, &current_index, 10);\n    output_data[4] = decoded_value - 1;\n\n    decoded_value = decode_value(current_index + 1, &current_index, 10);\n    output_data[3] = decoded_value;\n\n    decoded_value = decode_value(data_to_decode[1], &current_index, 10);\n    output_data[2] = decoded_value;\n\n    decoded_value = decode_value(current_index + 1, &current_index, 10);\n    output_data[1] = decoded_value;\n\n    decoded_value = decode_value(current_index + 1, &current_index, 10);\n    *output_data = decoded_value;\n\n    int checksum = compute_checksum(output_data[5] + 1892, output_data[4] + 1, output_data[3]);\n    output_data[6] = checksum;\n    output_data[8] = -1;\n    return 0;\n}",
            "called": [
                "FUN_000031fc",
                "FUN_00004f84"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000328c",
            "calling": [
                "FUN_00003478",
                "FUN_000033f4"
            ],
            "imported": false,
            "current_name": "decode_data_and_compute_checksum_0000328c"
        },
        "FUN_000041f4": {
            "renaming": {
                "FUN_000041f4": "initialize_parameters_000041f4",
                "param_1": "param_array",
                "param_2": "param_2",
                "param_3": "param_3",
                "puVar1": "ptr_to_label",
                "PTR_FUN_00004dc8_1_0000422c": "ptr_to_function_1",
                "DAT_00004230": "data_variable_1",
                "PTR_FUN_00004e26_1_00004234": "ptr_to_function_2",
                "PTR_LAB_00004e4a_1_00004238": "ptr_to_label"
            },
            "code": "void initialize_parameters_000041f4(int *param_array, int param_2, int param_3)\n{\n    int *ptr_to_self = param_array;\n    int *PTR_FUN_00004dc8_1_0000422c = param_array + 9;\n    int *PTR_FUN_00004e26_1_00004234 = param_array + 0xb;\n    int *PTR_LAB_00004e4a_1_00004238 = param_array + 0xc;\n\n    // Initializing parameters\n    *ptr_to_self = 0;\n    *(ptr_to_self + 1) = 0;\n    *(ptr_to_self + 2) = 0;\n    *(ptr_to_self + 3) = 0;\n    *(ptr_to_self + 4) = 0;\n    *(ptr_to_self + 5) = 0;\n    *(ptr_to_self + 6) = 0;\n    *(ptr_to_self + 0x19) = 0;\n    *(ptr_to_self + 0xe) = param_3;\n    *(ptr_to_self + 3) = (short)param_2;\n\n    // Function pointers and data variables\n    *PTR_FUN_00004dc8_1_0000422c = PTR_FUN_00004dc8_1_0000422c;\n    *(PTR_FUN_00004dc8_1_0000422c + 1) = DAT_00004230;\n    *PTR_FUN_00004e26_1_00004234 = PTR_FUN_00004e26_1_00004234;\n    *ptr_to_self = (int)ptr_to_self;\n    *PTR_LAB_00004e4a_1_00004238 = PTR_LAB_00004e4a_1_00004238;\n}\n",
            "called": [
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000041f4",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "initialize_parameters_000041f4"
        },
        "FUN_0000316c": {
            "renaming": {
                "FUN_0000316c": "check_input_and_call_function_0000316c",
                "param_1": "num_args",
                "param_2": "args",
                "iVar1": "result",
                "FUN_00002f74": "print_error_message",
                "FUN_00004e52": "compare_strings",
                "FUN_00002fe0": "call_function1",
                "FUN_0000305c": "call_function2",
                "FUN_00004c84": "print_error_message",
                "PTR_DAT_000031d4": "constant_string_1",
                "PTR_s_write_000031d8": "constant_string_2",
                "PTR_s_usage___s_read_write_000031dc": "error_message"
            },
            "code": "int check_input_and_call_function_0000316c(int num_args, undefined4 *args) {\n  int result;\n  if (num_args < 2) {\n    print_PTR_s_usage___s_read_write_000031dc();\n  }\n  else {\n    result = compare_strings(args[1],PTR_DAT_000031d4);\n    if (result == 0) {\n      call_function1(num_args, args);\n    }\n    else {\n      result = compare_strings(args[1],PTR_s_write_000031d8);\n      if (result == 0) {\n        call_function2(num_args, args);\n      }\n      else {\n        print_PTR_s_usage___s_read_write_000031dc(PTR_s_usage___s_read_write_000031dc,*args);\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_0000305c",
                "FUN_00004c84",
                "FUN_00004e52",
                "FUN_00002f74",
                "FUN_00002fe0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000316c",
            "calling": [],
            "imported": false,
            "current_name": "check_input_and_call_function_0000316c"
        },
        "FUN_000026f0": {
            "renaming": {
                "FUN_000026f0": "call_function_if_not_null_000026f0",
                "param_1": "parameter",
                "PTR_DAT_00002710": "pointer_to_data",
                "code": "function_pointer"
            },
            "code": "void call_function_if_not_null_000026f0(int parameter) {\n  int* PTR_DAT_00002710 = (int*)PTR_DAT_00002710;\n  if (*PTR_DAT_00002710 != 0) {\n    code* function_pointer = *(code**)PTR_DAT_00002710;\n    (*function_pointer)(parameter);\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000026f0",
            "calling": [],
            "imported": false,
            "current_name": "call_function_if_not_null_000026f0"
        },
        "FUN_000057d2": {
            "renaming": {
                "FUN_000057d2": "process_data_000057d2",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "data",
                "param_4": "data_length",
                "puVar2": "end_of_data",
                "iVar1": "processed_data",
                "iVar3": "processed_data_length",
                "FUN_000057a8": "process_single_data"
            },
            "code": "int process_data_000057d2(undefined4 param1, undefined4 param2, undefined *data, int data_length) {\n  int processed_data_length = 0;\n  undefined *end_of_data = data + data_length;\n  while (data != end_of_data) {\n    if (processed_data_length == 0) {\n      return 0;\n    }\n    int processed_data = process_single_data(param1, *data, param2, data_length, processed_data_length);\n    data++;\n    processed_data_length = processed_data + 1;\n  }\n  return processed_data;\n}",
            "called": [
                "FUN_000057a8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000057d2",
            "calling": [
                "FUN_000057f8"
            ],
            "imported": false,
            "current_name": "process_data_000057d2"
        },
        "FUN_000056b8": {
            "renaming": {
                "FUN_000056b8": "check_flag_000056b8",
                "param_1": "flag",
                "param_2": "flag_length",
                "param_3": "out",
                "param_4": "result",
                "iVar1": "flag_result",
                "uVar2": "out_value",
                "auStack_68": "stack"
            },
            "code": "int check_flag_000056b8(int flag, int flag_length, int *out, unsigned int *result) {\n    int flag_check = *(short *)(flag_length + 0xe);\n    unsigned int stack[1];\n    if (flag_check < 0 || FUN_00000514(flag, flag_check, stack) < 0) {\n        *result = 0;\n        if ((*(ushort *)(flag_length + 0xc) << 0x18) < 0) {\n            *out = 0x40;\n            goto LAB_000056f8;\n        }\n    }\n    else {\n        *result = (unsigned int)((stack[0] & 0xf000) == 0x2000);\n    }\n    *out = 0x400;\nLAB_000056f8:\n    return 0;\n}",
            "called": [
                "FUN_00000514"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b8",
            "calling": [
                "FUN_00005700"
            ],
            "imported": false,
            "current_name": "check_flag_000056b8"
        },
        "FUN_00001a18": {
            "renaming": {
                "FUN_00001a18": "set_data_and_value_00001a18",
                "FUN_000016ec": "set_data",
                "FUN_00001734": "update_value",
                "DAT_00001a34": "DAT_data",
                "PTR_DAT_00001a38": "PTR_result"
            },
            "code": "void set_data_and_value_00001a18(void)\n{\n  set_data(DAT_00001a34, 1);\n  update_value();\n  *PTR_DAT_00001a38 = 4;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a18",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_data_and_value_00001a18"
        },
        "FUN_00000d9c": {
            "renaming": {
                "FUN_00000d9c": "configure_device_00000d9c",
                "FUN_00000d76": "set_device_configuration",
                "DAT_00000dac": "device_data"
            },
            "code": "void configure_device_00000d9c(void)\n{\n  set_device_configuration(DAT_00000dac,0);\n  return;\n}",
            "called": [
                "FUN_00000d76"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000d9c",
            "calling": [
                "FUN_00000db0"
            ],
            "imported": false,
            "current_name": "configure_device_00000d9c"
        },
        "FUN_00003ff4": {
            "renaming": {
                "FUN_00003ff4": "update_value_if_less_than_00003ff4",
                "param_1": "current_value",
                "param_2": "new_value",
                "param_3": "max_value",
                "uVar1": "updated_value",
                "FUN_000045ee": "update_value",
                "FUN_00004622": "update_value",
                "param_4": "param_4"
            },
            "code": "uint update_value_if_less_than_00003ff4(uint current_value, uint new_value, uint max_value, undefined param_4)\n{\n  uint updated_value = new_value;\n  if ((new_value < max_value) && (current_value != 0)) {\n    update_value((max_value - new_value) + current_value, current_value, new_value);\n    update_value(param_4, updated_value, max_value - new_value);\n  }\n  return updated_value;\n}",
            "called": [
                "FUN_000045ee",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ff4",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "update_value_if_less_than_00003ff4"
        },
        "FUN_00004634": {
            "renaming": {
                "FUN_00004634": "FUNC_00004634"
            },
            "code": "\nvoid FUNC_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  undefined *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  bool bVar6;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 = param_1;\n  local_1c = param_2;\n  uStack_18 = param_3;\n  if (0x3b < *param_1) {\n    FUN_00005584(&local_20,*param_1,0x3c);\n    uVar3 = param_1[1] + (int)local_20;\n    param_1[1] = uVar3;\n    if ((int)local_1c < 0) {\n      uVar3 = uVar3 - 1;\n      *param_1 = local_1c + 0x3c;\n    }\n    else {\n      *param_1 = local_1c;\n    }\n    if ((int)local_1c < 0) {\n      param_1[1] = uVar3;\n    }\n  }\n  if (0x3b < param_1[1]) {\n    FUN_00005584(&local_20,param_1[1],0x3c);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[2] + (int)local_20;\n    param_1[2] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x3c;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[1] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar4;\n    }\n  }\n  if (0x17 < param_1[2]) {\n    FUN_00005584(&local_20,param_1[2],0x18);\n    bVar6 = (int)local_1c < 0;\n    uVar4 = param_1[3] + (int)local_20;\n    param_1[3] = uVar4;\n    uVar3 = local_1c;\n    if (bVar6) {\n      uVar3 = local_1c + 0x18;\n      uVar4 = uVar4 - 1;\n    }\n    if (!bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[2] = uVar3;\n    }\n    if (bVar6) {\n      param_1[3] = uVar4;\n    }\n  }\n  if (0xb < param_1[4]) {\n    FUN_00005584(&local_20,param_1[4],0xc);\n    bVar6 = (int)local_1c < 0;\n    uVar3 = param_1[5] + (int)local_20;\n    param_1[5] = uVar3;\n    if (bVar6) {\n      local_1c = local_1c + 0xc;\n      uVar3 = uVar3 - 1;\n    }\n    if (!bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[4] = local_1c;\n    }\n    if (bVar6) {\n      param_1[5] = uVar3;\n    }\n  }\n  puVar1 = PTR_DAT_000047e0;\n  uVar3 = param_1[5];\n  if ((uVar3 & 3) == 0) {\n    if (uVar3 == (uVar3 / 100) * 100) {\n      if ((uVar3 + 0x76c) % 400 == 0) {\n        iVar5 = 0x1d;\n      }\n      else {\n        iVar5 = 0x1c;\n      }\n    }\n    else {\n      iVar5 = 0x1d;\n    }\n  }\n  else {\n    iVar5 = 0x1c;\n  }\n  if ((int)param_1[3] < 1) {\n    while ((int)param_1[3] < 1) {\n      uVar3 = param_1[4];\n      param_1[4] = uVar3 - 1;\n      if (uVar3 - 1 == 0xffffffff) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 - 1;\n        param_1[4] = 0xb;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 == (uVar3 / 100) * 100) {\n            if ((uVar4 + 0x76b) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n      iVar2 = iVar5;\n      if (param_1[4] != 1) {\n        iVar2 = *(int *)(puVar1 + param_1[4] * 4);\n      }\n      param_1[3] = iVar2 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar3 = param_1[4];\n      iVar2 = iVar5;\n      if (uVar3 != 1) {\n        iVar2 = *(int *)(puVar1 + uVar3 * 4);\n      }\n      if ((int)param_1[3] <= iVar2) break;\n      param_1[3] = param_1[3] - iVar2;\n      param_1[4] = uVar3 + 1;\n      if (uVar3 + 1 == 0xc) {\n        uVar4 = param_1[5];\n        uVar3 = uVar4 + 1;\n        param_1[4] = 0;\n        param_1[5] = uVar3;\n        if ((uVar3 & 3) == 0) {\n          if (uVar3 % 100 == 0) {\n            if ((uVar4 + 0x76d) % 400 == 0) {\n              iVar5 = 0x1d;\n            }\n            else {\n              iVar5 = 0x1c;\n            }\n          }\n          else {\n            iVar5 = 0x1d;\n          }\n        }\n        else {\n          iVar5 = 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00005584"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00004634",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "FUNC_00004634"
        },
        "FUN_00001d5e": {
            "renaming": {
                "FUN_00001d5e": "extract_bits_00001d5e",
                "param_1": "input"
            },
            "code": "uint16_t extract_bits_00001d5e(uint16_t input){\n    uint16_t mask = 0x7000;\n    uint16_t output = mask & input | 0x40048000;\n    return output;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d5e",
            "calling": [
                "FUN_00001eea",
                "FUN_00001f80"
            ],
            "imported": false,
            "current_name": "extract_bits_00001d5e"
        },
        "FUN_0000191c": {
            "renaming": {
                "FUN_0000191c": "initialize_system_0000191c",
                "FUN_00001778": "disable_interrupts",
                "FUN_00001748": "set_system_clock",
                "*DAT_00001958": "*system_flags",
                "*PTR_DAT_0000195c": "*system_status"
            },
            "code": "void initialize_system_0000191c(void)\n{\n  disable_interrupts();\n  set_system_clock(0x40);\n  *DAT_00001958 = *DAT_00001958 & 0x3b;\n  do {\n  } while ((*DAT_00001958 & 0xc) != 0);\n  *PTR_DAT_0000195c = 1;\n  return;\n}",
            "called": [
                "FUN_00001748",
                "FUN_00001778"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000191c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_system_0000191c"
        },
        "FUN_000050f4": {
            "renaming": {
                "FUN_000050f4": "get_pointer_data_000050f4",
                "PTR_DAT_000050fc": "pointer_data"
            },
            "code": "const void* get_pointer_data_000050f4() {\n  return PTR_DAT_000050fc;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050f4",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_data_000050f4"
        },
        "FUN_00005a58": {
            "renaming": {
                "FUN_00005a58": "calculate_length_and_print_string_00005a58",
                "param_1": "initial_value",
                "param_2": "input_array",
                "param_3": "output_array",
                "param_4": "param_4",
                "param_5": "print_function",
                "iVar1": "index",
                "uVar2": "return_value",
                "uVar3": "max_length",
                "uVar4": "current_length",
                "bVar5": "is_length_4",
                "LAB_00005afc": "error_handling"
            },
            "code": "undefined4 calculate_length_and_print_string_00005a58(undefined4 initial_value, uint *input_array, uint *output_array, undefined4 param_4, code *print_function)\n{\n    int index;\n    undefined4 return_value;\n    uint max_length = input_array[4];\n    if ((int)input_array[4] < (int)input_array[2]) {\n        max_length = input_array[2];\n    }\n    *output_array = max_length;\n    if (*(char *)((int)input_array + 0x43) != '\\0') {\n        *output_array = max_length + 1;\n    }\n    if ((int)(*input_array << 0x1a) < 0) {\n        *output_array = *output_array + 2;\n    }\n    uint current_length = *input_array & 6;\n    if (current_length == 0) {\n        for (; (int)current_length < (int)(input_array[3] - *output_array); current_length = current_length + 1) {\n            index = (*print_function)(initial_value, param_4, (int)input_array + 0x19, 1);\n            if (index == -1) goto LAB_00005afc;\n        }\n    }\n    current_length = (uint)*(byte *)((int)input_array + 0x43);\n    if (current_length != 0) {\n        current_length = 1;\n    }\n    if ((int)(*input_array << 0x1a) < 0) {\n        *(undefined *)((int)input_array + current_length + 0x43) = 0x30;\n        *(undefined *)((int)input_array + current_length + 0x44) = *(undefined *)((int)input_array + 0x45);\n        current_length = current_length + 2;\n    }\n    index = (*print_function)(initial_value, param_4, (int)input_array + 0x43, current_length);\n    if (index == -1) {\n        goto LAB_00005afc;\n    }\n    uint remaining_length = input_array[3];\n    bool is_length_4 = (*input_array & 6) == 4;\n    if (is_length_4) {\n        remaining_length = remaining_length - *output_array;\n    }\n    if (is_length_4) {\n        remaining_length = remaining_length & ~((int)remaining_length >> 0x1f);\n    }\n    else {\n        remaining_length = 0;\n    }\n    if ((int)input_array[4] < (int)input_array[2]) {\n        remaining_length = remaining_length + (input_array[2] - input_array[4]);\n    }\n    for (uint i = 0; remaining_length != i; i = i + 1) {\n        index = (*print_function)(initial_value, param_4, (int)input_array + 0x1a, 1);\n        if (index == -1) goto LAB_00005afc;\n    }\n    return_value = 0;\nLAB_00005afc:\n    return return_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005a58",
            "calling": [
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "calculate_length_and_print_string_00005a58"
        },
        "FUN_000056b0": {
            "renaming": {
                "FUN_000056b0": "get_dat_value_000056b0",
                "DAT_000056b4": "dat_value"
            },
            "code": "int get_dat_value_000056b0()\n{\n    return DAT_000056b4;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056b0",
            "calling": [
                "FUN_000047e4",
                "FUN_00005100",
                "FUN_00004f98"
            ],
            "imported": false,
            "current_name": "get_dat_value_000056b0"
        },
        "FUN_00003d24": {
            "renaming": {
                "FUN_00003d24": "find_element_00003d24",
                "param_1": "num_elements",
                "local_c": "current_element",
                "local_10": "element_count"
            },
            "code": "undefined4* find_element_00003d24(int num_elements) {\n  undefined4 *current_element = *(undefined4 **)PTR_DAT_00003d60;\n  int element_count = 0;\n  while (element_count < num_elements && current_element != (undefined4 *)0x0) {\n    current_element = (undefined4 *)*current_element;\n    element_count++;\n  }\n  return current_element;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d24",
            "calling": [
                "FUN_0000305c",
                "FUN_00002fe0"
            ],
            "imported": false,
            "current_name": "find_element_00003d24"
        },
        "FUN_000060cc": {
            "renaming": {
                "FUN_000060cc": "calculate_result_000060cc",
                "param_1": "mem_address",
                "param_2": "input_value_1",
                "param_3": "input_value_2",
                "param_4": "mem_value",
                "uVar1": "result",
                "uVar2": "temp",
                "FUN_00004b34": "initialize",
                "FUN_00006964": "process_data",
                "FUN_00004bd0": "calculate"
            },
            "code": "uint calculate_result_000060cc(undefined4 mem_address, uint input_value_1, uint input_value_2, undefined4 mem_value){\n  uint result = 0;\n  if (input_value_1 != 0) {\n    if (input_value_2 == 0) {\n      initialize();\n      result = input_value_2;\n    }\n    else {\n      uint temp = process_data();\n      result = input_value_1;\n      if ((temp < input_value_2) && (result = calculate(mem_address, input_value_2), result != 0)) {\n        calculate_result_000060cc(result, input_value_1, input_value_2);\n        initialize(mem_address, input_value_1);\n      }\n    }\n    return result;\n  }\n  result = calculate(mem_address, input_value_2, input_value_2, mem_value);\n  return result;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00004b34",
                "FUN_000060b0",
                "FUN_00006964"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060cc",
            "calling": [
                "FUN_000068f0"
            ],
            "imported": false,
            "current_name": "calculate_result_000060cc"
        },
        "FUN_00003dc4": {
            "renaming": {
                "FUN_00003dc4": "count_digits_00003dc4",
                "param_1": "num",
                "param_2": "limit",
                "local_20": "multiplier",
                "local_14": "digits",
                "local_10": "digit_count",
                "local_c": "result"
            },
            "code": "int count_digits_00003dc4(int num, uint limit)\n{\n  uint multiplier;\n  char *digits;\n  uint digit_count;\n  int result;\n  result = 1;\n  if (DAT_00003e50 < limit) {\n    result = 10;\n  }\n  else {\n    for (multiplier = 10; multiplier <= limit; multiplier *= 10) {\n      result++;\n    }\n  }\n  if (num != 0) {\n    digits = (char *)(result + num);\n    multiplier = limit;\n    do {\n      digits--;\n      *digits = (char)multiplier + (char)(uint)((ulonglong)DAT_00003e54 * (ulonglong)multiplier >> 0x23) * -10 + '0';\n      multiplier = (uint)((ulonglong)DAT_00003e54 * (ulonglong)multiplier >> 0x23);\n    } while (multiplier != 0);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003dc4",
            "calling": [
                "FUN_00003e58"
            ],
            "imported": false,
            "current_name": "count_digits_00003dc4"
        },
        "FUN_000022be": {
            "renaming": {
                "FUN_000022be": "increment_and_store_value_at_address_000022be",
                "param_1": "ptr_array",
                "param_2": "value",
                "uVar1": "index",
                "address": "address"
            },
            "code": "void increment_and_store_value_at_address_000022be(int *ptr_array, undefined value) {\n  uint index = ptr_array[3];\n  ptr_array[3] = index + 1;\n  uint address = (index & ptr_array[1] - 1U) + *ptr_array;\n  *(undefined *)(address) = value;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022be",
            "calling": [
                "FUN_00002364"
            ],
            "imported": false,
            "current_name": "increment_and_store_value_at_address_000022be"
        },
        "FUN_00002108": {
            "renaming": {
                "FUN_00002108": "print_four_bytes_of_data_00002108",
                "FUN_00002028": "print_data",
                "DAT_00002118": "PTR_data"
            },
            "code": "void print_four_bytes_of_data_00002108(void)\n{\n  print_data(DAT_00002118, 4);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002108",
            "calling": [],
            "imported": false,
            "current_name": "print_four_bytes_of_data_00002108"
        },
        "FUN_00001d80": {
            "renaming": {
                "FUN_00001d80": "getFlaggedValue_00001d80",
                "param_1": "value",
                "PTR_": "ptr_",
                "DAT_": "dat_"
            },
            "code": "uint16_t getFlaggedValue_00001d80(uint16_t value) {\n  uint16_t maskedValue = value & 0x1c0;\n  uint16_t flaggedValue = maskedValue | 0x400ff000;\n  return flaggedValue;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d80",
            "calling": [
                "FUN_00001eea",
                "FUN_00001ff6"
            ],
            "imported": false,
            "current_name": "getFlaggedValue_00001d80"
        },
        "FUN_000033c0": {
            "renaming": {
                "FUN_000033c0": "check_alarm_000033c0",
                "iVar1": "alarm_status",
                "auStack_2c": "alarm_data",
                "FUN_00002690": "get_alarm_data",
                "FUN_00004db8": "print_error",
                "FUN_00003378": "process_alarm_data"
            },
            "code": "bool check_alarm_000033c0(void)\n{\n  int alarm_status;\n  undefined alarm_data [36];\n  alarm_status = get_alarm_data(alarm_data);\n  if (alarm_status != 0) {\n    print_error(PTR_s_rtc__error_getting_alarm_000033f0);\n  }\n  else {\n    process_alarm_data(alarm_data);\n  }\n  return alarm_status != 0;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00003378",
                "FUN_00002690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "check_alarm_000033c0"
        },
        "FUN_00002b10": {
            "renaming": {
                "FUN_00002b10": "parse_args_and_execute_command_00002b10",
                "param_1": "command",
                "param_2": "args",
                "local_48": "arg_ptrs",
                "local_3c": "command_func",
                "local_38": "arg_ptrs",
                "local_34": "error_code",
                "local_2d": "quote_type",
                "local_2c": "d",
                "local_28": "c",
                "local_24": "arg_ptr",
                "local_20": "i",
                "local_1c": "escape_count",
                "local_18": "arg_count",
                "local_14": "args"
            },
            "code": "void parse_args_and_execute_command_00002b10(uint32_t command, char *args)\n{\n  int escape_count = 0;\n  uint32_t arg_count = 0;\n  char *current_arg_start = args;\n  while (*args != 0)\n  {\n    if (*args > 32)\n    {\n      if ((*args == 34) || (*args == 39))\n      {\n        char quote_type = *args;\n        do\n        {\n          args++;\n          if (*args == 0)\n          {\n            print_error_message(\"Command line ended unexpectedly\");\n            return;\n          }\n          if (*args == 92)\n          {\n            escape_count++;\n            args++;\n            if (*args == 0)\n            {\n              print_error_message(\"Command line ended unexpectedly\");\n              return;\n            }\n          }\n        } while (quote_type != *args);\n        if (*++args > 32)\n        {\n          print_error_message(\"Invalid argument\");\n          return;\n        }\n      }\n      else\n      {\n        do\n        {\n          if (*args == 92)\n          {\n            escape_count++;\n            args++;\n            if (*args == 0)\n            {\n              print_error_message(\"Command line ended unexpectedly\");\n              return;\n            }\n          }\n          args++;\n          if (*args == 34)\n          {\n            print_error_message(\"Invalid argument\");\n            return;\n          }\n        } while (*args > 32);\n      }\n      arg_count++;\n    }\n    if (*args == 0)\n    {\n      break;\n    }\n    *args = 0;\n    args++;\n  }\n  if (arg_count != 0)\n  {\n    char **arg_ptrs = (char **)(&command - ((arg_count + 1) * 4 + 7 & 0xfffffff8));\n    arg_ptrs[arg_count] = NULL;\n    args = current_arg_start;\n    for (uint32_t i = 0; i < arg_count; i++)\n    {\n      while (*args == 0)\n      {\n        args++;\n      }\n      if ((*args == 34) || (*args == 39))\n      {\n        args++;\n      }\n      arg_ptrs[i] = args;\n      while (*args != 0)\n      {\n        args++;\n      }\n    }\n    for (char **arg_ptr = arg_ptrs; (escape_count != 0 && (*arg_ptr != NULL)); arg_ptr++)\n    {\n      for (char *c = *arg_ptr; *c != '\\0'; c++)\n      {\n        if (*c == '\\')\n        {\n          for (char *d = c; *d != '\\0'; d++)\n          {\n            *d = *(d + 1);\n          }\n          escape_count--;\n          if (escape_count == 0)\n          {\n            break;\n          }\n        }\n      }\n    }\n    code *command_func = (code *)parse_command(command, arg_ptrs);\n    if (command_func == NULL)\n    {\n      int error_code = find_error_code(arg_ptrs);\n      if (error_code == 0)\n      {\n        execute_builtin_command(command, arg_ptrs);\n      }\n      else\n      {\n        print_error_message(get_error_message(error_code), arg_ptrs);\n      }\n    }\n    else\n    {\n      (*command_func)(arg_count, arg_ptrs);\n    }\n  }\n  return;\n}",
            "called": [
                "FUN_00002a18",
                "FUN_00004db8",
                "FUN_00002a88",
                "FUN_00004c84",
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002b10",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "parse_args_and_execute_command_00002b10"
        },
        "FUN_00001b10": {
            "renaming": {
                "FUN_00001b10": "execute_sequence_of_functions_00001b10",
                "param_1": "sequence_length",
                "PTR_DAT_00001bb4": "function_sequence",
                "PTR_DAT_00001bb0": "function_sequence_length",
                "uVar1": "result"
            },
            "code": "uint32_t execute_sequence_of_functions_00001b10(byte sequence_length) {\n    uint32_t result;\n\n    if (sequence_length >= 8) {\n        result = 0xffffffff;\n    } else {\n        do {\n            switch (PTR_DAT_00001bb4[(uint)sequence_length + (uint)(byte)*PTR_DAT_00001bb0 * 8]) {\n                case 0:\n                    execute_function_0();\n                    break;\n                case 1:\n                    execute_function_1();\n                    break;\n                case 2:\n                    execute_function_2();\n                    break;\n                case 3:\n                    execute_function_3();\n                    break;\n                case 4:\n                    execute_function_4();\n                    break;\n                case 5:\n                    execute_function_5();\n                    break;\n                case 6:\n                    execute_function_6();\n                    break;\n                case 7:\n                    execute_function_7();\n                    break;\n                default:\n                    return 0xffffffff;\n            }\n        } while (sequence_length != *PTR_DAT_00001bb0);\n        result = 0;\n    }\n\n    return result;\n}",
            "called": [
                "FUN_00001a18",
                "FUN_00001ad4",
                "FUN_000019c0",
                "FUN_00001a60",
                "FUN_00001960",
                "FUN_000018bc",
                "FUN_00001a3c",
                "FUN_0000191c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001b10",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "execute_sequence_of_functions_00001b10"
        },
        "FUN_000047e4": {
            "renaming": {
                "FUN_000047e4": "FUNC_000047e4"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 FUNC_000047e4(int *param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  int *piVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  uint uVar15;\n  bool bVar16;\n  \n  piVar3 = (int *)FUN_000056b0();\n  FUNC_00004634(param_1);\n  uVar12 = param_1[5];\n  iVar11 = param_1[3] + -1 + *(int *)(PTR_DAT_00004adc + param_1[4] * 4);\n  if (((1 < param_1[4]) && ((uVar12 & 3) == 0)) &&\n     ((uVar12 != (uVar12 / 100) * 100 || (uVar12 + 0x76c == ((uVar12 + 0x76c) / 400) * 400)))) {\n    iVar11 = iVar11 + 1;\n  }\n  param_1[7] = iVar11;\n  if (20000 < (int)&PTR_DAT_00002710 + uVar12) {\n    iVar7 = -1;\n    iVar5 = -1;\n    goto LAB_00004aba;\n  }\n  if ((int)uVar12 < 0x47) {\n    if (uVar12 != 0x46) {\n      for (uVar9 = 0x45; (int)uVar12 < (int)uVar9; uVar9 = uVar9 - 1) {\n        if ((uVar9 & 3) == 0) {\n          if (uVar9 == (uVar9 / 100) * 100) {\n            if ((uVar9 + 0x76c) % 400 == 0) {\n              iVar7 = 0x16e;\n            }\n            else {\n              iVar7 = 0x16d;\n            }\n          }\n          else {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16d;\n        }\n        iVar11 = iVar11 - iVar7;\n      }\n      if ((uVar9 & 3) == 0) {\n        if (uVar12 == (uVar12 / 100) * 100) {\n          iVar7 = 0x16d;\n          if ((uVar12 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      iVar11 = iVar11 - iVar7;\n    }\n  }\n  else {\n    uVar9 = 0x46;\n    do {\n      if ((uVar9 & 3) == 0) {\n        if (uVar9 % 100 == 0) {\n          if ((uVar9 + 0x76c) % 400 == 0) {\n            iVar7 = 0x16e;\n          }\n          else {\n            iVar7 = 0x16d;\n          }\n        }\n        else {\n          iVar7 = 0x16e;\n        }\n      }\n      else {\n        iVar7 = 0x16d;\n      }\n      uVar9 = uVar9 + 1;\n      iVar11 = iVar11 + iVar7;\n    } while (uVar12 != uVar9);\n  }\n  lVar1 = (longlong)DAT_00004ae0 * (longlong)iVar11 +\n          (longlong)(param_1[2] * 0xe10 + param_1[1] * 0x3c + *param_1);\n  uVar15 = (uint)lVar1;\n  iVar7 = (int)((ulonglong)lVar1 >> 0x20);\n  FUN_000050e8();\n  FUNC_00005100();\n  uVar9 = *(uint *)PTR_DAT_00004ae4;\n  if (*(uint *)PTR_DAT_00004ae4 == 0) {\nLAB_00004934:\n    uVar12 = piVar3[10];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n  }\n  else {\n    uVar14 = param_1[8];\n    uVar13 = uVar14;\n    if (0 < (int)uVar14) {\n      uVar13 = 1;\n    }\n    if ((piVar3[1] == param_1[5] + 0x76c) || (iVar5 = FUN_00004f98(), iVar5 != 0)) {\n      uVar10 = piVar3[0x14];\n      uVar4 = piVar3[0x12];\n      uVar8 = piVar3[10];\n      uVar9 = uVar4 - uVar8;\n      iVar5 = (piVar3[0x13] - ((int)uVar8 >> 0x1f)) - (uint)(uVar4 < uVar8);\n      if (((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n           (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9)))) &&\n         (iVar6 = (piVar3[0x13] - ((int)uVar10 >> 0x1f)) - (uint)(uVar4 < uVar10),\n         bVar16 = uVar15 < uVar4 - uVar10,\n         (int)((iVar7 - iVar6) - (uint)bVar16) < 0 !=\n         (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)bVar16)))) goto LAB_00004a88;\n      uVar4 = piVar3[8] - uVar10;\n      iVar6 = (piVar3[9] - ((int)uVar10 >> 0x1f)) - (uint)((uint)piVar3[8] < uVar10);\n      if (*piVar3 != 0) {\n        if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 ==\n            (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar9 = 0;\n        if ((int)uVar14 < 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar15 = uVar13 ^ uVar9;\n        uVar13 = uVar9;\n        if (uVar15 == 1) {\n          if (uVar9 == 0) {\n            iVar7 = uVar10 - uVar8;\n          }\n          else {\n            iVar7 = uVar8 - uVar10;\n          }\n          iVar5 = param_1[3];\n          *param_1 = *param_1 + iVar7;\n          lVar2 = lVar1 + iVar7;\n          FUNC_00004634(param_1);\n          iVar5 = param_1[3] - iVar5;\n          lVar1 = lVar1 + iVar7;\n          if (iVar5 != 0) {\n            if (iVar5 < 2) {\n              if (iVar5 == -2 || iVar5 + 2 < 0 != SCARRY4(iVar5,2)) {\n                iVar5 = 1;\n              }\n            }\n            else {\n              iVar5 = -1;\n            }\n            iVar7 = iVar5 + param_1[7];\n            iVar11 = iVar11 + iVar5;\n            if (iVar7 < 0) {\n              uVar9 = uVar12 - 1;\n              if ((uVar9 & 3) == 0) {\n                if (uVar9 == (uVar9 / 100) * 100) {\n                  iVar7 = 0x16d;\n                  if ((uVar12 + 0x76b) % 400 != 0) {\n                    iVar7 = 0x16c;\n                  }\n                }\n                else {\n                  iVar7 = 0x16d;\n                }\n              }\n              else {\n                iVar7 = 0x16c;\n              }\n            }\n            else {\n              if ((uVar12 & 3) == 0) {\n                if (uVar12 == (uVar12 / 100) * 100) {\n                  iVar5 = 0x16d;\n                  if ((uVar12 + 0x76c) % 400 == 0) {\n                    iVar5 = 0x16e;\n                  }\n                }\n                else {\n                  iVar5 = 0x16e;\n                }\n              }\n              else {\n                iVar5 = 0x16d;\n              }\n              if (iVar5 <= iVar7) {\n                iVar7 = iVar7 - iVar5;\n              }\n            }\n            param_1[7] = iVar7;\n            lVar1 = lVar2;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar7 - iVar6) - (uint)(uVar15 < uVar4)) < 0 !=\n          (SBORROW4(iVar7,iVar6) != SBORROW4(iVar7 - iVar6,(uint)(uVar15 < uVar4)))) {\nLAB_0000491e:\n        if ((int)((iVar7 - iVar5) - (uint)(uVar15 < uVar9)) < 0 ==\n            (SBORROW4(iVar7,iVar5) != SBORROW4(iVar7 - iVar5,(uint)(uVar15 < uVar9))))\n        goto LAB_0000492a;\n      }\n      if (-1 < (int)uVar14) {\n        uVar9 = 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar9 = uVar13;\n      if (uVar13 != 1) goto LAB_00004934;\n    }\n    uVar12 = piVar3[0x14];\n    iVar7 = (uint)lVar1 + uVar12;\n    iVar5 = (int)((ulonglong)lVar1 >> 0x20) +\n            ((int)uVar12 >> 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n    uVar9 = 1;\n  }\n  FUN_000050f4();\n  param_1[8] = uVar9;\n  param_1[6] = (iVar11 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(iVar5,iVar7);\n}\n\n",
            "called": [
                "FUN_00005100",
                "FUN_00004634",
                "FUN_000050f4",
                "FUN_000050e8",
                "FUN_000056b0",
                "FUN_00004f98"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000047e4",
            "calling": [
                "FUN_00002600",
                "FUN_00002654"
            ],
            "imported": false,
            "current_name": "FUNC_000047e4"
        },
        "FUN_000023c8": {
            "renaming": {
                "FUN_000023c8": "trigger_software_interrupt_000023c8",
                "0x3f": "SWI_RESET"
            },
            "code": "void trigger_software_interrupt_000023c8(void)\n{\n  software_interrupt(SWI_RESET);\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023c8",
            "calling": [
                "FUN_000023d0"
            ],
            "imported": false,
            "current_name": "trigger_software_interrupt_000023c8"
        },
        "FUN_00002e48": {
            "renaming": {
                "FUN_00002e48": "printDataFromMemory_00002e48",
                "FUN_00002a00": "setValue",
                "FUN_000041d0": "printData",
                "PTR_00002e68": "memoryPointer",
                "DAT_00002e68": "memoryData"
            },
            "code": "void printDataFromMemory_00002e48(void)\n{\n  int firstValue = 62;\n  int secondValue = 32;\n  int* memoryAddress = (int*)(*DAT_00002e68 + 8);\n  int dataToPrint = *memoryAddress;\n  printData(dataToPrint);\n  return;\n}",
            "called": [
                "FUN_000041d0",
                "FUN_00002a00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e48",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "printDataFromMemory_00002e48"
        },
        "FUN_00000930": {
            "renaming": {
                "FUN_00000930": "execute_software_interrupt_00000930",
                "FUN_00000cf0": "initialize_hardware",
                "software_interrupt": "trigger_interrupt"
            },
            "code": "void execute_software_interrupt_00000930(void)\n{\n  initialize_hardware();\n  trigger_interrupt(1);\n  while( true )\n  {\n    // Do nothing, wait for interrupt to occur\n  }\n}",
            "called": [
                "FUN_00000cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000930",
            "calling": [
                "FUN_00000f8c",
                "FUN_00000794"
            ],
            "imported": false,
            "current_name": "execute_software_interrupt_00000930"
        },
        "FUN_00001348": {
            "renaming": {
                "FUN_00001348": "checkAndCallFunctionIfNotNull_00001348",
                "PTR_DAT_0000135c": "ptrToData",
                "FUN_0000093c": "callFunction"
            },
            "code": "void checkAndCallFunctionIfNotNull_00001348(void)\n{\n  int* PTR_DAT_0000135c = (int*)PTR_DAT_0000135c;\n  if (*PTR_DAT_0000135c != 0)\n  {\n    FUN_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001348",
            "calling": [
                "FUN_00001628"
            ],
            "imported": false,
            "current_name": "checkAndCallFunctionIfNotNull_00001348"
        },
        "FUN_00001d3a": {
            "renaming": {
                "FUN_00001d3a": "set_flag_00001d3a",
                "param_1": "id",
                "param_2": "value",
                "puVar1": "flag_ptr",
                "FUN_00001d08": "get_flag_address"
            },
            "code": "void set_flag_00001d3a(int id, unsigned char value)\n{\n  int *flag_ptr;\n  flag_ptr = (int *)get_flag_address(id, value);\n  *flag_ptr = 1;\n  return;\n}",
            "called": [
                "FUN_00001d08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001d3a",
            "calling": [
                "FUN_00001ddc"
            ],
            "imported": false,
            "current_name": "set_flag_00001d3a"
        },
        "FUN_00002434": {
            "renaming": {
                "FUN_00002434": "initialize_array_00002434",
                "param_1": "array",
                "param_2": "size",
                "uVar1": "success",
                "iVar2": "new_size",
                "PTR_DAT_000024b8": "memory"
            },
            "code": "int initialize_array_00002434(int *array, int size)\n{\n    int success = 0;\n    int new_size = size * sizeof(int);\n    void *PTR_DAT_000024b8 = malloc(new_size);\n    if (PTR_DAT_000024b8 != NULL) {\n        *array = PTR_DAT_000024b8;\n        memset(PTR_DAT_000024b8, 0, new_size);\n        success = 1;\n    }\n    return success;\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_0000093c",
                "FUN_00000cd0",
                "FUN_00001034",
                "FUN_00000698"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002434",
            "calling": [
                "FUN_0000129c"
            ],
            "imported": false,
            "current_name": "initialize_array_00002434"
        },
        "FUN_00005700": {
            "renaming": {
                "FUN_00005700": "process_data_00005700",
                "param_1": "data_length",
                "param_2": "data_array",
                "local_18": "index",
                "local_14": "temp_data_array",
                "uVar1": "flag",
                "iVar2": "value",
                "FUN_000056b8": "process_data_helper",
                "FUN_00004bd0": "get_data_value",
                "PTR_DAT_0000577c": "data_pointer",
                "FUN_00000534": "check_data_value"
            },
            "code": "void process_data_00005700(int data_length, int *data_array)\n{\n  ushort flag;\n  int index;\n  int value;\n  int *temp_data_array;\n  \n  if (-1 < (int)((uint)*(ushort *)(data_array + 3) << 0x1e))) {\n    temp_data_array = data_array;\n    flag = process_data_00005700_helper(data_length, data_array, &index, &temp_data_array);\n    value = get_data_value(data_length, index);\n    if (value != 0) {\n      *(undefined **)(data_length + 0x28) = PTR_DAT_0000577c;\n      *data_array = value;\n      *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) | 0x80;\n      data_array[5] = index;\n      data_array[4] = value;\n      if ((temp_data_array != (int *)0x0) &&\n         (value = check_data_value(data_length,(int)*(short *)((int)data_array + 0xe)), value != 0)) {\n        *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(data_array + 3) = flag | *(ushort *)(data_array + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(data_array + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 2;\n  }\n  *data_array = (int)data_array + 0x47;\n  data_array[4] = (int)data_array + 0x47;\n  data_array[5] = 1;\n  return;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_00000534",
                "FUN_000056b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005700",
            "calling": [
                "FUN_00006768",
                "FUN_000054a8"
            ],
            "imported": false,
            "current_name": "process_data_00005700"
        },
        "FUN_00002798": {
            "renaming": {
                "FUN_00002798": "checkAndCallFunctionIfNotNull_00002798",
                "PTR_DAT_000027ac": "ptr",
                "FUN_0000093c": "callFunction",
                "*PTR_DAT_000027ac": "*ptr"
            },
            "code": "void checkAndCallFunctionIfNotNull_00002798(void)\n{\n  int* PTR_DAT_000027ac = (int*)PTR_DAT_000027ac;\n  if (*PTR_DAT_000027ac != 0) {\n    FUN_0000093c();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002798",
            "calling": [
                "FUN_00002994"
            ],
            "imported": false,
            "current_name": "checkAndCallFunctionIfNotNull_00002798"
        },
        "FUN_00003524": {
            "renaming": {
                "FUN_00003524": "handle_command_00003524",
                "param_1": "command_count",
                "param_2": "command_data",
                "iVar1": "command_index",
                "uVar2": "result",
                "PTR_s_poweron_00003638": "POWER_ON_COMMAND",
                "PTR_s_poweroff_0000363c": "POWER_OFF_COMMAND",
                "PTR_s_clearalarm_00003640": "CLEAR_ALARM_COMMAND",
                "PTR_s_getalarm_00003644": "GET_ALARM_COMMAND",
                "PTR_s_setalarm_00003648": "SET_ALARM_COMMAND",
                "PTR_s_gettime_0000364c": "GET_TIME_COMMAND",
                "PTR_s_settime_00003650": "SET_TIME_COMMAND",
                "PTR_s_unknown_command_or_missing_param_00003654": "UNKNOWN_COMMAND_ERROR",
                "FUN_00004e66": "find_command",
                "FUN_000034c0": "print_error",
                "FUN_000026d8": "print_unknown_command",
                "FUN_000026e4": "print_error",
                "FUN_000026c0": "print_error",
                "FUN_000033c0": "print_error",
                "FUN_000033f4": "set_alarm",
                "FUN_00003444": "print_error",
                "FUN_00003478": "set_time"
            },
            "code": "int handle_command_00003524(int command_count, int command_data) {\n  int result;\n  if (command_count < 2) {\n    print_error();\n    result = 1;\n  }\n  else {\n    int command_index = find_command(command_data);\n    if (command_index == -1) {\n      print_unknown_command();\n      print_error();\n      result = 1;\n    }\n    else {\n      switch (command_index) {\n        case 0:\n          result = power_on();\n          break;\n        case 1:\n          result = power_off();\n          break;\n        case 2:\n          result = clear_alarm();\n          break;\n        case 3:\n          result = get_alarm();\n          break;\n        case 4:\n          result = set_alarm(command_data + 8);\n          break;\n        case 5:\n          result = get_time();\n          break;\n        case 6:\n          result = set_time(command_data + 8);\n          break;\n        default:\n          print_unknown_command();\n          print_error();\n          result = 1;\n      }\n    }\n  }\n  return result;\n}",
            "called": [
                "FUN_000026e4",
                "FUN_000026c0",
                "FUN_000033c0",
                "FUN_000034c0",
                "FUN_00004e66",
                "FUN_00004c84",
                "FUN_000026d8",
                "FUN_00003444",
                "FUN_00003478",
                "FUN_000033f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003524",
            "calling": [],
            "imported": false,
            "current_name": "handle_command_00003524"
        },
        "FUN_00001bb8": {
            "renaming": {
                "FUN_00001bb8": "process_data_00001bb8",
                "DAT_00001c74": "input_data",
                "DAT_00001c78": "subdata1",
                "DAT_00001c7c": "subdata2",
                "PTR_DAT_00001c80": "input_ptr",
                "MASK_1": "2",
                "MASK_2": "64",
                "MASK_3": "192",
                "MASK_4": "63",
                "MASK_5": "128",
                "MASK_6": "12",
                "MASK_7": "32",
                "MASK_8": "59",
                "MASK_9": "16",
                "MASK_10": "8",
                "FLAG": "8",
                "FLAG_2": "4"
            },
            "code": "void process_data_00001bb8(void)\n{\n  if ((DAT_00001c74[1] & MASK_1) != 0) {\n    process_subdata(DAT_00001c74[2],1);\n  }\n  if ((DAT_00001c74[5] & MASK_2) != 0) {\n    if ((DAT_00001c74[0] & MASK_3) == 0) {\n      DAT_00001c74[0] = DAT_00001c74[0] & MASK_4 | MASK_5;\n      while ((DAT_00001c74[6] & MASK_6) != FLAG) {\n      }\n    }\n    process_subdata(DAT_00001c74[3],6);\n    while ((DAT_00001c74[6] & MASK_7) != 0) {\n    }\n  }\n  process_subdata(0,0);\n  DAT_00001c74[0] = DAT_00001c74[0] & MASK_8 | FLAG_2;\n  while ((DAT_00001c74[6] & MASK_9) == 0) {\n  }\n  while ((DAT_00001c74[6] & MASK_10) != 0) {\n  }\n  *PTR_DAT_00001c80 = 0;\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001bb8",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "process_data_00001bb8"
        },
        "FUN_0000428c": {
            "renaming": {
                "FUN_0000428c": "do_nothing_and_return_0000428c",
                "DAT_00004294": "data_pointer",
                "do_nothing_000045e8": "do_nothing_with_data_pointer"
            },
            "code": "void do_nothing_and_return_0000428c(void)\n{\n  do_nothing_with_DAT_00004294(DAT_00004294);\n  return;\n}",
            "called": [
                "FUN_000045e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000428c",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "do_nothing_and_return_0000428c"
        },
        "FUN_0000404c": {
            "renaming": {
                "FUN_0000404c": "process_data_0000404c",
                "param_1": "data_ptr",
                "param_2": "params_ptr",
                "iVar1": "total_bytes_processed",
                "piVar2": "block_ptrs",
                "uVar3": "flags_as_uint32",
                "uVar4": "flags",
                "iVar5": "block_size",
                "pcVar6": "process_block",
                "iVar7": "data_offset",
                "uVar8": "data_length",
                "bVar9": "block_size_is_zero"
            },
            "code": "int process_data_0000404c(uint *data_ptr, int *params_ptr) {\n    int total_bytes_processed = 0;\n    uint16_t flags = *(uint16_t *)(params_ptr + 3);\n    uint32_t flags_as_uint32 = (uint32_t)flags;\n    if ((int)(flags_as_uint32 << 0x1c) < 0) {\n        int bytes_to_process = params_ptr[4];\n        if (bytes_to_process != 0) {\n            int block_size = flags_as_uint32 << 0x1e;\n            bool block_size_is_zero = block_size == 0;\n            int data_offset = *params_ptr;\n            if (block_size_is_zero) {\n                block_size = params_ptr[5];\n            }\n            *params_ptr = bytes_to_process;\n            if (!block_size_is_zero) {\n                block_size = 0;\n            }\n            params_ptr[2] = block_size;\n            for (data_offset = data_offset - bytes_to_process; 0 < data_offset; data_offset = data_offset - block_size) {\n                block_size = (*(code *)params_ptr[10])(data_ptr, params_ptr[8], bytes_to_process, data_offset);\n                if (block_size < 1) {\n                    *(uint16_t *)(params_ptr + 3) = *(uint16_t *)(params_ptr + 3) | 0x40;\n                    return -1;\n                }\n                bytes_to_process = bytes_to_process + block_size;\n            }\n        }\n    }\n    else {\n        if ((params_ptr[1] < 1) && (params_ptr[0x10] < 1)) {\n            return 0;\n        }\n        code *process_block = (code *)params_ptr[0xb];\n        if (process_block == (code *)0x0) {\n            return 0;\n        }\n        uint32_t data_length = *data_ptr;\n        *data_ptr = 0;\n        if ((flags & 0x1000) == 0) {\n            int block_size = (*process_block)(data_ptr, params_ptr[8], flags_as_uint32 & 0x1000, 1);\n            if ((block_size == -1) && (data_length = *data_ptr, data_length != 0)) {\n                if ((data_length == 0x1d) || (data_length == 0x16)) {\n                    *data_ptr = data_length;\n                    return 0;\n                }\n                flags = *(uint16_t *)(params_ptr + 3);\n                goto LAB_00004104;\n            }\n        }\n        else {\n            int block_size = params_ptr[0x15];\n        }\n        if (((int)((uint)*(uint16_t *)(params_ptr + 3) << 0x1d) < 0) && (block_size = block_size - params_ptr[1], params_ptr[0xd] != 0)) {\n            block_size = block_size - params_ptr[0x10];\n        }\n        block_size = (*(code *)params_ptr[0xb])(data_ptr, params_ptr[8], block_size, 0);\n        flags = *(uint16_t *)(params_ptr + 3);\n        if ((block_size == -1) && ((0x1d < *data_ptr || (-1 < (int)((DAT_00004154 >> (*data_ptr & 0xff)) << 0x1f)))) {\n            LAB_00004104:\n            *(uint16_t *)(params_ptr + 3) = flags | 0x40;\n            return block_size;\n        }\n        params_ptr[1] = 0;\n        *params_ptr = params_ptr[4];\n        if (((int)((uint)flags << 0x13) < 0) && ((block_size != -1 || (*data_ptr == 0)))) {\n            params_ptr[0x15] = block_size;\n        }\n        int *block_ptrs = (int *)params_ptr[0xd];\n        *data_ptr = data_length;\n        if (block_ptrs != (int *)0x0) {\n            if (block_ptrs != params_ptr + 0x11) {\n                FUN_00004b34(data_ptr);\n            }\n            params_ptr[0xd] = 0;\n            return 0;\n        }\n    }\n    return 0;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000404c",
            "calling": [
                "FUN_00004158",
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "process_data_0000404c"
        },
        "FUN_00002f74": {
            "renaming": {
                "FUN_00002f74": "print_device_info_00002f74",
                "local_14": "current_device_ptr",
                "local_18": "device_count",
                "uVar1": "device_info_ptr"
            },
            "code": "void print_device_info_00002f74(void)\n{\n  undefined4 device_info_ptr;\n  int device_count = 0;\n  undefined4 *current_device_ptr;\n  \n  current_device_ptr = *(undefined4 **)PTR_DAT_00002fd0;\n  if (current_device_ptr == (undefined4 *)0x0) {\n    print_message(PTR_s_No_devices_found_00002fd8);\n  }\n  else {\n    print_message(PTR_s_ID_Class_Name_00002fd4);\n  }\n  for (; current_device_ptr != (undefined4 *)0x0; current_device_ptr = (undefined4 *)*current_device_ptr) {\n    device_info_ptr = get_device_info(*(undefined *)(current_device_ptr[3] + 8));\n    print_message(PTR_s___i__s__s_00002fdc, device_count, device_info_ptr, current_device_ptr[2]);\n    device_count++;\n  }\n  return;\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00004c84",
                "FUN_000039e8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002f74",
            "calling": [
                "FUN_0000316c"
            ],
            "imported": false,
            "current_name": "print_device_info_00002f74"
        },
        "FUN_000010a0": {
            "renaming": {
                "FUN_000010a0": "count_elements_until_mismatch_000010a0",
                "param_1": "elements",
                "local_c": "current_element"
            },
            "code": "int count_elements_until_mismatch_000010a0(int *elements) {\n  int *current_element;\n\n  for (current_element = elements; (int *)*current_element == current_element; current_element++) {\n  }\n  return (int)current_element - (int)elements;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010a0",
            "calling": [
                "FUN_0000211c"
            ],
            "imported": false,
            "current_name": "count_elements_until_mismatch_000010a0"
        },
        "FUN_000012e2": {
            "renaming": {
                "FUN_000012e2": "process_data_000012e2",
                "param_1": "data",
                "param_2": "arg2",
                "param_3": "arg3",
                "iVar1": "result",
                "FUN_0000231c": "process_data_internal",
                "FUN_0000129c": "cleanup_data"
            },
            "code": "int process_data_000012e2(int data, undefined4 arg2, undefined4 arg3) {\n  int result;\n  while (true) {\n    result = process_data_000012e2_internal(data + 4, arg2, arg3);\n    if (result != 0) {\n      break;\n    }\n    cleanup_data(data);\n  }\n  return result;\n}",
            "called": [
                "FUN_0000231c",
                "FUN_0000129c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000012e2",
            "calling": [
                "FUN_00000e14"
            ],
            "imported": false,
            "current_name": "process_data_000012e2"
        },
        "FUN_000056a0": {
            "renaming": {
                "FUN_000056a0": "process_data_000056a0",
                "param_1": "data",
                "param_2": "output1",
                "param_3": "output2",
                "param_4": "flag",
                "uStack_c": "temp1",
                "uStack_8": "temp2",
                "FUN_0000562c": "perform_operation"
            },
            "code": "void process_data_000056a0(int data, int* output1, int* output2, int flag) {\n  int temp1 = *output1;\n  int temp2 = *output2;\n  perform_operation(data, *output1, &temp1, flag, data);\n  return;\n}",
            "called": [
                "FUN_0000562c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000056a0",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "process_data_000056a0"
        },
        "FUN_0000231c": {
            "renaming": {
                "FUN_0000231c": "copy_bytes_from_memory_0000231c",
                "param_1": "starting_address",
                "param_2": "destination",
                "param_3": "num_bytes_to_copy",
                "iVar2": "bytes_copied",
                "local_20": "current_destination",
                "local_14": "num_bytes_left"
            },
            "code": "int copy_bytes_from_memory_0000231c(undefined4 starting_address, undefined *destination, int num_bytes_to_copy) {\n  undefined byte_to_copy;\n  int bytes_copied = 0;\n  undefined *current_destination = destination;\n  while ((num_bytes_to_copy != 0 && (bytes_copied = check_memory_access(starting_address), bytes_copied == 0))) {\n    byte_to_copy = read_byte_from_memory(starting_address);\n    *current_destination = byte_to_copy;\n    num_bytes_to_copy--;\n    current_destination++;\n  }\n  return (num_bytes_to_copy - bytes_copied);\n}",
            "called": [
                "FUN_00002270",
                "FUN_000022f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000231c",
            "calling": [
                "FUN_000012e2"
            ],
            "imported": false,
            "current_name": "copy_bytes_from_memory_0000231c"
        },
        "FUN_000061cc": {
            "renaming": {
                "FUN_000061cc": "FUNC_000061cc"
            },
            "code": "\nint FUNC_000061cc(int param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined *local_30;\n  code *local_2c;\n  \n  puVar2 = PTR_DAT_000064b4;\n  puVar1 = PTR_DAT_000064b0;\n  local_1a0 = 0;\n  local_19c = 0;\n  local_30 = PTR_LAB_00006118_1_000064a8;\n  local_2c = DAT_000064ac;\n  local_2b0 = param_4;\n  local_198 = auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar6 = (uint)*param_3;\n      if (uVar6 == 0) {\n        return local_1a0;\n      }\n      uVar4 = (byte)puVar1[uVar6] & 8;\n      pbVar5 = param_3 + 1;\n      if ((puVar1[uVar6] & 8) == 0) break;\n      while (((param_3 = pbVar5, 0 < (int)param_2[1] ||\n              (iVar3 = (*local_2c)(param_1,param_2), iVar3 == 0)) &&\n             ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0))) {\n        local_19c = local_19c + 1;\n        param_2[1] = param_2[1] + -1;\n        *param_2 = *param_2 + 1;\n      }\n    }\n    if (uVar6 == 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n    goto LAB_00006380;\n    if (**param_2 != uVar6) {\n      return local_1a0;\n    }\n    *param_2 = *param_2 + 1;\n    local_19c = local_19c + 1;\n    param_2[1] = param_2[1] + -1;\n    param_3 = pbVar5;\n  }\n  local_1a4 = uVar4;\n  local_1ac = uVar4;\n  if (param_3[1] == 0x2a) {\n    pbVar5 = param_3 + 2;\n    local_1ac = 0x10;\n  }\n  while( true ) {\n    uVar4 = (uint)*pbVar5;\n    if (9 < uVar4 - 0x30) break;\n    pbVar5 = pbVar5 + 1;\n    local_1a4 = (local_1a4 * 10 + uVar4) - 0x30;\n  }\n  iVar3 = FUN_00006010(PTR_DAT_000064b4,uVar4,3);\n  if (iVar3 != 0) {\n    local_1ac = 1 << (iVar3 - (int)puVar2 & 0xffU) | local_1ac;\n    pbVar5 = pbVar5 + 1;\n  }\n  param_3 = pbVar5 + 1;\n  uVar4 = (uint)*pbVar5;\n  if (uVar4 < 0x79) {\n    if (0x57 < uVar4) {\n      switch(uVar4) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 = (byte *)FUN_0000687c(auStack_2ac,param_3);\n        local_1ac = local_1ac | 0x40;\n        local_194 = 1;\n        break;\n      case 99:\n        local_1ac = local_1ac | 0x40;\n        local_194 = 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 = 10;\nLAB_000063a0:\n        if (uVar4 < 0x6f) {\n          local_194 = 3;\n        }\n        else {\n          local_194 = 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 = 5;\n        break;\n      case 0x69:\n        local_1a8 = 0;\n        local_194 = 3;\n        break;\n      case 0x6e:\n        if (-1 < (int)(local_1ac << 0x1b)) {\n          if ((int)(local_1ac << 0x1f) < 0) {\n            *(short *)*local_2b0 = (short)local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n          else {\n            **local_2b0 = local_19c;\n            local_2b0 = local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 = 8;\n        local_194 = 4;\n        break;\n      case 0x70:\n        local_1ac = local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac = local_1ac | 0x200;\n        local_1a8 = 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 = 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] < 1) && (iVar3 = (*local_2c)(param_1,param_2), iVar3 != 0))\n      goto LAB_00006380;\n      if (-1 < (int)(local_1ac << 0x19)) {\n        while ((int)((uint)(byte)puVar1[**param_2] << 0x1c) < 0) {\n          local_19c = local_19c + 1;\n          pbVar5 = param_2[1];\n          param_2[1] = pbVar5 + -1;\n          if ((int)(pbVar5 + -1) < 1) {\n            iVar3 = (*local_2c)(param_1,param_2);\n            if (iVar3 != 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 = *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 < 3) {\n        iVar3 = FUN_000064bc(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else if (local_194 < 5) {\n        iVar3 = FUNC_0000656c(param_1,&local_1ac,param_2,&local_2b0);\n      }\n      else {\n        iVar3 = param_1;\n        if (DAT_000064b8 == 0) goto LAB_000061f6;\n      }\n      if (iVar3 == 1) {\n        return local_1a0;\n      }\n      if (iVar3 == 2) {\nLAB_00006380:\n        if (local_1a0 == 0) {\nLAB_00006388:\n          local_1a0 = -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) & 0x40) != 0) {\n          local_1a0 = -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar5 = param_3;\n    if (uVar4 == 0x25) goto LAB_00006352;\n    if (uVar4 < 0x26) {\n      if (uVar4 != 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar4 - 0x45 < 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 = 3;\n  local_1a8 = 10;\n  goto LAB_000063ac;\n}\n\n",
            "called": [
                "FUN_0000687c",
                "FUN_00006192",
                "FUN_00006010",
                "FUN_0000656c",
                "FUN_000064bc"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000061cc",
            "calling": [
                "FUN_00005e68"
            ],
            "imported": false,
            "current_name": "FUNC_000061cc"
        },
        "FUN_00002690": {
            "renaming": {
                "FUN_00002690": "process_input_data_00002690",
                "param_1": "input_data",
                "local_10": "local_variable_1",
                "uStack_c": "local_variable_2",
                "FUN_000028f0": "get_data_from_source",
                "FUN_0000443c": "copy_data"
            },
            "code": "int process_input_data_00002690(undefined4 input_data)\n{\n  undefined4 local_variable_1;\n  undefined4 local_variable_2;\n  local_variable_1 = get_data_from_source();\n  local_variable_2 = 0;\n  copy_data(&local_variable_1, input_data);\n  return 0;\n}",
            "called": [
                "FUN_0000443c",
                "FUN_000028f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002690",
            "calling": [
                "FUN_000033c0"
            ],
            "imported": false,
            "current_name": "process_input_data_00002690"
        },
        "FUN_00006010": {
            "renaming": {
                "FUN_00006010": "find_byte_in_buffer_00006010",
                "param_1": "buffer",
                "param_2": "buffer_size",
                "param_3": "byte_to_find",
                "bVar1": "byte_value",
                "cVar2": "bit_0",
                "cVar3": "bit_8",
                "cVar4": "bit_16",
                "cVar5": "bit_24",
                "pbVar6": "result_ptr",
                "puVar7": "buffer_ptr",
                "pbVar8": "result_ptr_2",
                "uVar9": "buffer_offset",
                "uVar10": "buffer_size_aligned",
                "uVar11": "word_xor_pattern_1",
                "uVar12": "word_xor_pattern_2",
                "bVar13": "byte_0",
                "bVar14": "byte_8",
                "bVar15": "byte_16",
                "bVar16": "byte_24"
            },
            "code": "byte* find_byte_in_buffer_00006010(uint* buffer, uint buffer_size, uint byte_to_find) {\n    byte* result = NULL;\n\n    buffer_size = buffer_size & 0xff;\n\n    if ((int)buffer < 0x10) {\n        goto end;\n    }\n\n    uint buffer_offset = (uint)buffer & 7;\n    uint byte_pattern = byte_to_find | byte_to_find << 8 | byte_to_find << 16 | byte_to_find << 24;\n\n    while (true) {\n        if (buffer_offset == 0) {\n            uint buffer_size_aligned = buffer_size & 0xfffffff8;\n            for (uint i = 0; i < buffer_size_aligned; i += 8) {\n                uint* buffer_word = buffer + i / 4;\n                uint word_xor_pattern_1 = *buffer_word ^ byte_pattern;\n                uint word_xor_pattern_2 = *(buffer_word + 1) ^ byte_pattern;\n\n                if (word_xor_pattern_1 != 0) {\n                    if (word_xor_pattern_2 == 0) {\n                        result = (byte*)(buffer_word + 1);\n                    } else {\n                        result = (byte*)(buffer_word + 5);\n                    }\n                    break;\n                }\n            }\n            buffer_size = buffer_size & 7;\n            goto end;\n        }\n\n        buffer_size--;\n        if (*(byte*)buffer == byte_to_find) {\n            result = (byte*)buffer;\n            break;\n        }\n\n        buffer_offset = (uint)((byte*)buffer + 1) & 7;\n        buffer = (uint*)((byte*)buffer + 1);\n        if (buffer_size == 0) {\n            goto end;\n        }\n    }\n\n    end:\n    return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006010",
            "calling": [
                "FUN_000061cc",
                "FUN_0000656c",
                "FUN_000057f8",
                "FUN_00005b34"
            ],
            "imported": false,
            "current_name": "find_byte_in_buffer_00006010"
        },
        "FUN_00001cf0": {
            "renaming": {
                "FUN_00001cf0": "checkAndExecuteIfNotZero_00001cf0",
                "PTR_DAT_00001d04": "ptr",
                "FUN_0000093c": "executeFunction"
            },
            "code": "void checkAndExecuteIfNotZero_00001cf0(void)\n{\n  int* PTR_DAT_00001d04 = (int*)PTR_DAT_00001d04;\n  if (*PTR_DAT_00001d04 != 0) {\n    executeFunction();\n  }\n  return;\n}",
            "called": [
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001cf0",
            "calling": [
                "FUN_00002028"
            ],
            "imported": false,
            "current_name": "checkAndExecuteIfNotZero_00001cf0"
        },
        "FUN_00003ec4": {
            "renaming": {
                "FUN_00003ec4": "format_number_string_00003ec4",
                "param_1": "output_string",
                "param_2": "input_number",
                "param_3": "num_decimal_places",
                "iVar1": "integer_length",
                "uVar2": "decimal_length",
                "uVar3": "divisor",
                "local_10": "remainder",
                "local_c": "output_length"
            },
            "code": "int format_number_string_00003ec4(char *output_string, uint32_t input_number, int num_decimal_places) {\n    int output_length = 0;\n    if (num_decimal_places + 7 < 0 != __builtin_sadd_overflow(num_decimal_places, 7, &output_length)) {\n        handle_error(3, \"Failed assertion: num_decimal_places + 7 >= 0\");\n    }\n    if (num_decimal_places == 0) {\n        output_length = format_integer_string(output_string, input_number);\n    }\n    else if (num_decimal_places < 1) {\n        uint32_t divisor = *(uint32_t *)(PTR_DAT_00003ff0 + num_decimal_places * -4);\n        uint32_t remainder = input_number - divisor * (input_number / divisor);\n        if (remainder < 0) {\n            remainder = -remainder;\n        }\n        if ((input_number < 0) && (divisor == 0)) {\n            if (output_string != NULL) {\n                *output_string = '-';\n            }\n            output_length = 1;\n        }\n        if (output_string == NULL) {\n            int integer_length = format_integer_string(NULL, input_number / divisor);\n            output_length = integer_length + 1 + output_length;\n        }\n        else {\n            int integer_length = format_integer_string(output_string + output_length, input_number / divisor);\n            output_length = output_length + integer_length + 1;\n            output_string[output_length - 1] = '.';\n            uint32_t decimal_length = format_integer_string(output_string + output_length, remainder);\n            handle_error(0, \"Failed assertion: decimal_length <= num_decimal_places\");\n            format_with_padding(output_string + output_length, decimal_length, -num_decimal_places, '0');\n            output_length = -num_decimal_places + output_length + decimal_length;\n        }\n    }\n    else {\n        output_length = format_integer_string(output_string, input_number);\n        if (output_string != NULL) {\n            format_with_padding(output_string + output_length, 0, num_decimal_places, '0');\n        }\n        output_length = num_decimal_places + output_length;\n    }\n    return output_length;\n}",
            "called": [
                "FUN_00003e58",
                "FUN_00000f04",
                "FUN_00003ff4",
                "FUN_00004622"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003ec4",
            "calling": [
                "FUN_00003e9e"
            ],
            "imported": false,
            "current_name": "format_number_string_00003ec4"
        },
        "FUN_00001360": {
            "renaming": {
                "FUN_00001360": "calculate_offset_00001360",
                "param_1": "input_value",
                "param_2": "multiplier"
            },
            "code": "int calculate_offset_00001360(uint input_value, int multiplier) {\n\tint shifted_value = (input_value & 0xfffff) << 5;\n\tint masked_value = (input_value & 0xf0000000);\n\tint constant_value = 0x2000000;\n\treturn multiplier * 4 + shifted_value + masked_value + constant_value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001360",
            "calling": [
                "FUN_00001392"
            ],
            "imported": false,
            "current_name": "calculate_offset_00001360"
        },
        "FUN_00004622": {
            "renaming": {
                "FUN_00004622": "set_memory_00004622",
                "param_1": "memory",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "end_of_memory"
            },
            "code": "void set_memory_00004622(void *memory, unsigned char value, int size) {\n  void *end_of_memory = memory + size;\n  for (; memory != end_of_memory; memory++) {\n    *memory = value;\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004622",
            "calling": [
                "FUN_00004314",
                "FUN_0000305c",
                "FUN_00003ff4",
                "FUN_00003ec4",
                "FUN_00004248",
                "FUN_000041f4"
            ],
            "imported": false,
            "current_name": "set_memory_00004622"
        },
        "FUN_0000093c": {
            "renaming": {
                "FUN_0000093c": "set_flag_on_0000093c",
                "DAT_00000954": "data_ptr",
                "PTR_00000958": "flag_ptr",
                "<unnamed>": "flag_mask"
            },
            "code": "void set_flag_on_0000093c(uint32_t *DAT_00000954)\n{\n    uint32_t *PTR_00000958 = DAT_00000954 + 1;\n    uint32_t flag_mask = 0x10000000;\n    *PTR_00000958 |= flag_mask;\n    return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000093c",
            "calling": [
                "FUN_00002434",
                "FUN_00002798",
                "FUN_00000738",
                "FUN_00001cf0",
                "FUN_00001348"
            ],
            "imported": false,
            "current_name": "set_flag_on_0000093c"
        },
        "FUN_00003658": {
            "renaming": {
                "FUN_00003658": "synchronize_data_00003658",
                "DAT_00003680": "data_pointer",
                "DAT_00003684": "data_value"
            },
            "code": "void synchronize_data_00003658(void)\n{\n    DataSynchronizationBarrier(0xf);\n    uint* data_ptr = (uint*)(DAT_00003680 + 0xc);\n    *data_ptr = DAT_00003684 | (*data_ptr & 0x700);\n    DataSynchronizationBarrier(0xf);\n    while(true)\n    {\n        // Do nothing block with infinite loop\n    }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003658",
            "calling": [
                "FUN_00003688"
            ],
            "imported": false,
            "current_name": "synchronize_data_00003658"
        },
        "FUN_000019c0": {
            "renaming": {
                "FUN_000019c0": "initialize_system_000019c0",
                "FUN_00001778": "enable_interrupts",
                "FUN_00001748": "set_clock_speed",
                "FUN_00001710": "set_power_mode",
                "FUN_00001734": "set_default_values",
                "DAT_00001a0c": "power_mode",
                "DAT_00001a10": "system_parameters",
                "PTR_DAT_00001a14": "system_status"
            },
            "code": "void initialize_system_000019c0(void)\n{\n  enable_interrupts();\n  set_clock_speed(0x40);\n  set_DAT_00001a0c(DAT_00001a0c,1);\n  *DAT_00001a10 = *DAT_00001a10 & 0x3b | 0x80;\n  do {\n  } while ((DAT_00001a10[6] & 0xc) != 8);\n  set_default_values();\n  *PTR_DAT_00001a14 = 3;\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_00001748",
                "FUN_00001734",
                "FUN_00001778"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000019c0",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_system_000019c0"
        },
        "FUN_000060b0": {
            "renaming": {
                "FUN_000060b0": "copy_string_000060b0",
                "param_1": "dest_offset",
                "param_2": "source",
                "param_3": "num_chars",
                "puVar1": "next_char",
                "puVar2": "source_end",
                "puVar3": "dest"
            },
            "code": "void copy_string_000060b0(int dest_offset, char *source, int num_chars)\n{\n  char *source_end = source + num_chars;\n  char *dest = (char *)(dest_offset - 1);\n  if (source != source_end) {\n    do {\n      char *next_char = source + 1;\n      dest++;\n      *dest = *source;\n      source = next_char;\n    } while (source != source_end);\n  }\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000060b0",
            "calling": [
                "FUN_000068f0",
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "copy_string_000060b0"
        },
        "FUN_00006a14": {
            "renaming": {
                "FUN_00006a14": "FUNC_00006a14"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUNC_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  bool bVar11;\n  ulonglong uVar12;\n  \n  if (param_4 == 0) {\n    if (param_2 < param_3) {\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 != 0) {\n        param_3 = param_3 << (uVar4 & 0xff);\n        param_2 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        param_1 = param_1 << (uVar4 & 0xff);\n      }\n      uVar7 = param_3 >> 0x10;\n      uVar9 = param_2 / uVar7;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar7 * uVar9) * 0x10000;\n      uVar1 = uVar9 * (param_3 & 0xffff);\n      uVar6 = uVar9;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar9 = (uVar5 - uVar1) / uVar7;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar7 * uVar9) * 0x10000;\n      uVar7 = uVar9 * (param_3 & 0xffff);\n      uVar1 = uVar9;\n      if (uVar5 <= uVar7 && uVar7 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar9 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar7 && uVar7 - uVar5 != 0)) {\n          uVar1 = uVar9 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar7;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n      puVar3 = (uint *)0x0;\n    }\n    else {\n      if (param_3 == 0) {\n                    /* WARNING: Could not recover jumptable at 0x00006abc. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x6abc);\n        uVar12 = (*UNRECOVERED_JUMPTABLE)();\n        return uVar12;\n      }\n      uVar4 = count_leading_zeroes(param_3);\n      if (uVar4 == 0) {\n        param_2 = param_2 - param_3;\n        uVar10 = param_3 >> 0x10;\n        uVar8 = param_3 & 0xffff;\n        puVar3 = (uint *)0x1;\n      }\n      else {\n        param_3 = param_3 << (uVar4 & 0xff);\n        uVar10 = param_3 >> 0x10;\n        uVar6 = param_2 >> (0x20 - uVar4 & 0xff);\n        uVar1 = param_1 >> (0x20 - uVar4 & 0xff) | param_2 << (uVar4 & 0xff);\n        uVar5 = uVar6 / uVar10;\n        uVar8 = param_3 & 0xffff;\n        uVar9 = uVar1 >> 0x10 | (uVar6 - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        param_1 = param_1 << (uVar4 & 0xff);\n        uVar6 = uVar5;\n        if (uVar9 <= uVar7 && uVar7 - uVar9 != 0) {\n          bVar11 = CARRY4(param_3,uVar9);\n          uVar9 = param_3 + uVar9;\n          uVar6 = uVar5 - 1;\n          if ((bVar11 == false) && (uVar9 <= uVar7 && uVar7 - uVar9 != 0)) {\n            uVar6 = uVar5 - 2;\n            uVar9 = uVar9 + param_3;\n          }\n        }\n        uVar5 = (uVar9 - uVar7) / uVar10;\n        param_2 = uVar1 & 0xffff | ((uVar9 - uVar7) - uVar10 * uVar5) * 0x10000;\n        uVar7 = uVar5 * uVar8;\n        uVar1 = uVar5;\n        if (param_2 <= uVar7 && uVar7 - param_2 != 0) {\n          bVar11 = CARRY4(param_3,param_2);\n          param_2 = param_3 + param_2;\n          uVar1 = uVar5 - 1;\n          if ((bVar11 == false) && (param_2 <= uVar7 && uVar7 - param_2 != 0)) {\n            uVar1 = uVar5 - 2;\n            param_2 = param_2 + param_3;\n          }\n        }\n        param_2 = param_2 - uVar7;\n        puVar3 = (uint *)(uVar1 | uVar6 << 0x10);\n      }\n      uVar7 = param_2 / uVar10;\n      uVar5 = param_1 >> 0x10 | (param_2 - uVar10 * uVar7) * 0x10000;\n      uVar1 = uVar8 * uVar7;\n      uVar6 = uVar7;\n      if (uVar5 <= uVar1 && uVar1 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar1 && uVar1 - uVar5 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar7 = (uVar5 - uVar1) / uVar10;\n      uVar5 = param_1 & 0xffff | ((uVar5 - uVar1) - uVar10 * uVar7) * 0x10000;\n      uVar8 = uVar8 * uVar7;\n      uVar1 = uVar7;\n      if (uVar5 <= uVar8 && uVar8 - uVar5 != 0) {\n        bVar11 = CARRY4(param_3,uVar5);\n        uVar5 = param_3 + uVar5;\n        uVar1 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar5 <= uVar8 && uVar8 - uVar5 != 0)) {\n          uVar1 = uVar7 - 2;\n          uVar5 = uVar5 + param_3;\n        }\n      }\n      uVar5 = uVar5 - uVar8;\n      puVar2 = (uint *)(uVar1 | uVar6 << 0x10);\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = uVar5 >> (uVar4 & 0xff);\n      param_5[1] = 0;\n    }\n  }\n  else if (param_2 < param_4) {\n    puVar2 = param_5;\n    puVar3 = param_5;\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n      return 0;\n    }\n  }\n  else {\n    puVar3 = (uint *)count_leading_zeroes(param_4);\n    if (puVar3 != (uint *)0x0) {\n      uVar8 = 0x20 - (int)puVar3;\n      uVar5 = param_3 >> (uVar8 & 0xff) | param_4 << ((uint)puVar3 & 0xff);\n      uVar10 = uVar5 >> 0x10;\n      uVar4 = param_2 >> (uVar8 & 0xff);\n      uVar6 = param_1 >> (uVar8 & 0xff) | param_2 << ((uint)puVar3 & 0xff);\n      uVar7 = uVar4 / uVar10;\n      uVar1 = uVar6 >> 0x10 | (uVar4 - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      param_3 = param_3 << ((uint)puVar3 & 0xff);\n      param_1 = param_1 << ((uint)puVar3 & 0xff);\n      uVar4 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar4 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar4 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar7 = (uVar1 - uVar9) / uVar10;\n      uVar1 = uVar6 & 0xffff | ((uVar1 - uVar9) - uVar10 * uVar7) * 0x10000;\n      uVar9 = uVar7 * (uVar5 & 0xffff);\n      uVar6 = uVar7;\n      if (uVar1 <= uVar9 && uVar9 - uVar1 != 0) {\n        bVar11 = CARRY4(uVar5,uVar1);\n        uVar1 = uVar5 + uVar1;\n        uVar6 = uVar7 - 1;\n        if ((bVar11 == false) && (uVar1 <= uVar9 && uVar9 - uVar1 != 0)) {\n          uVar6 = uVar7 - 2;\n          uVar1 = uVar1 + uVar5;\n        }\n      }\n      uVar6 = uVar6 | uVar4 << 0x10;\n      uVar12 = (ulonglong)uVar6 * (ulonglong)param_3;\n      if (CONCAT44(uVar1 - uVar9,param_1) < uVar12) {\n        uVar12 = uVar12 - CONCAT44(uVar5,param_3);\n        uVar6 = uVar6 - 1;\n      }\n      if (param_5 != (uint *)0x0) {\n        uVar4 = ((uVar1 - uVar9) - (int)(uVar12 >> 0x20)) - (uint)(param_1 < (uint)uVar12);\n        *param_5 = uVar4 << (uVar8 & 0xff) | param_1 - (uint)uVar12 >> ((uint)puVar3 & 0xff);\n        param_5[1] = uVar4 >> ((uint)puVar3 & 0xff);\n      }\n      return (ulonglong)uVar6;\n    }\n    if ((param_4 < param_2) || (puVar2 = puVar3, param_3 <= param_1)) {\n      bVar11 = param_1 < param_3;\n      param_1 = param_1 - param_3;\n      param_2 = (param_2 - param_4) - (uint)bVar11;\n      puVar2 = (uint *)0x1;\n    }\n    if (param_5 != (uint *)0x0) {\n      *param_5 = param_1;\n      param_5[1] = param_2;\n    }\n  }\n  return CONCAT44(puVar3,puVar2);\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00006a14",
            "calling": [
                "FUN_00006974"
            ],
            "imported": false,
            "current_name": "FUNC_00006a14"
        },
        "FUN_000023d0": {
            "renaming": {
                "FUN_000023d0": "check_initialized_000023d0",
                "param_1": "input_param",
                "uVar1": "result",
                "PTR_DAT_000023fc": "data_pointer"
            },
            "code": "int check_initialized_000023d0(int input_param) {\n    int* PTR_DAT_000023fc = (int*) PTR_DAT_000023fc;\n    if (*PTR_DAT_000023fc == 0) {\n        int result = FUN_000023c8(1, input_param, 0);\n        return result;\n    }\n    else {\n        return 0;\n    }\n}",
            "called": [
                "FUN_000023c8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000023d0",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "check_initialized_000023d0"
        },
        "FUN_00000a30": {
            "renaming": {
                "FUN_00000a30": "get_stack_top_00000a30",
                "auStack_20": "stack_frame",
                "in_r3": "stack_pointer"
            },
            "code": "char* get_stack_top_00000a30() {\n  int offset = -PTR_DAT_00000a60 - *(int *)(in_r3 + 0x4c);\n  char* stack_top = (char*)(&offset) + sizeof(offset);\n  return stack_top;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000a30",
            "calling": [],
            "imported": false,
            "current_name": "get_stack_top_00000a30"
        },
        "FUN_000034c0": {
            "renaming": {
                "FUN_000034c0": "register_commands_000034c0",
                "PTR_s_usage__rtc__command___arguments__00003500": "usage_rtc_command_arguments",
                "PTR_s_commands__00003504": "commands",
                "PTR_s__poweron_power_the_interface_on_00003508": "power_on_power_the_interface_on",
                "PTR_s__poweroff_power_the_interface_of_0000350c": "power_off_power_the_interface_off",
                "PTR_s__clearalarm_deactivate_the_curre_00003510": "clear_alarm_deactivate_current_alarm",
                "PTR_s__getalarm_print_the_currently_al_00003514": "get_alarm_print_current_alarm",
                "PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518": "set_alarm_set_date_time",
                "PTR_s__gettime_print_the_current_time_0000351c": "get_time_print_current_time",
                "PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520": "set_time_set_date_time"
            },
            "code": "int register_commands_000034c0(void)\n{\n  register_command(PTR_s_usage__rtc__command___arguments__00003500);\n  register_command(PTR_s_commands__00003504);\n  register_command(PTR_s__poweron_power_the_interface_on_00003508);\n  register_command(PTR_s__poweroff_power_the_interface_of_0000350c);\n  register_command(PTR_s__clearalarm_deactivate_the_curre_00003510);\n  register_command(PTR_s__getalarm_print_the_currently_al_00003514);\n  register_command(PTR_s__setalarm_YYYY_MM_DD_HH_MM_SS_se_00003518);\n  register_command(PTR_s__gettime_print_the_current_time_0000351c);\n  register_command(PTR_s__settime_YYYY_MM_DD_HH_MM_SS_set_00003520);\n  return 0;\n}",
            "called": [
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000034c0",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "register_commands_000034c0"
        },
        "FUN_000050e8": {
            "renaming": {
                "FUN_000050e8": "get_pointer_to_data_000050e8",
                "PTR_DAT_000050f0": "pointer_to_data"
            },
            "code": "const char* get_pointer_to_data_000050e8() {\n    return PTR_DAT_000050f0;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000050e8",
            "calling": [
                "FUN_000047e4"
            ],
            "imported": false,
            "current_name": "get_pointer_to_data_000050e8"
        },
        "FUN_000042a4": {
            "renaming": {
                "FUN_000042a4": "initialize_data_000042a4",
                "param_1": "data_ptr",
                "uVar1": "result",
                "iVar2": "data_ptr_2",
                "bVar3": "is_data_ptr_equal",
                "PTR_DAT_0000430c": "global_data_ptr",
                "PTR_DAT_00004310": "default_data_ptr",
                "FUN_00004314": "get_data_value",
                "DAT_000042a0": "some_data"
            },
            "code": "void initialize_data_000042a4(int data_ptr)\n{\n    initialize_global_data();\n    if (*(int *)(data_ptr + DATA_OFFSET) == 0)\n    {\n        set_data_values(data_ptr);\n        set_data_flags(data_ptr);\n        *(int *)(data_ptr + DATA_OFFSET) = 1;\n    }\n    do_nothing(DAT_000042a0);\n}",
            "called": [
                "FUN_00004314",
                "FUN_000045ec",
                "FUN_0000428c",
                "FUN_000041f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000042a4",
            "calling": [
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004314",
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00006768",
                "FUN_00004c84",
                "FUN_000054a8",
                "FUN_00005404",
                "FUN_00005e10",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "initialize_data_000042a4"
        },
        "FUN_00000514": {
            "renaming": {
                "FUN_00000514": "set_param_to_19_00000514",
                "*param_1": "*param_ptr",
                "*param_value": "*param_ptr",
                "0x13": "19",
                "0xffffffff": "-1"
            },
            "code": "int set_param_to_19_00000514(int *param_ptr)\n{\n  int param_value = 19;\n  *param_ptr = param_value;\n  return -1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000514",
            "calling": [
                "FUN_000056b8"
            ],
            "imported": false,
            "current_name": "set_param_to_19_00000514"
        },
        "FUN_00002e9c": {
            "renaming": {
                "FUN_00002e9c": "start_program_00002e9c",
                "FUN_00003688": "execute_startup"
            },
            "code": "int start_program_00002e9c(void)\n{\n  execute_startup();\n  return 0;\n}",
            "called": [
                "FUN_00003688"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e9c",
            "calling": [],
            "imported": false,
            "current_name": "start_program_00002e9c"
        },
        "FUN_00001960": {
            "renaming": {
                "FUN_00001960": "initializeSystem_00001960",
                "FUN_00001748": "setMode",
                "FUN_00001710": "enableInterrupt",
                "DAT_000019b4": "interruptRegister",
                "*DAT_000019b8": "registerData",
                "*PTR_DAT_000019bc": "pointerData"
            },
            "code": "void initializeSystem_00001960(void)\n{\n  setMode(0xa0);\n  enableInterrupt(DAT_000019b4, 1);\n  *DAT_000019b8 = (*DAT_000019b8 & 0x3b) | 0x44;\n  while ((DAT_000019b8[6] & 0xc) != 4);\n  while ((DAT_000019b8[6] & 0x10) == 0);\n  *PTR_DAT_000019bc = 2;\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001960",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initializeSystem_00001960"
        },
        "FUN_00000990": {
            "renaming": {
                "FUN_00000990": "do_nothing_00000990"
            },
            "code": "\nvoid do_nothing_00000990(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000990",
            "calling": [
                "FUN_0000099c"
            ],
            "imported": false,
            "current_name": "do_nothing_00000990"
        },
        "FUN_00001a3c": {
            "renaming": {
                "FUN_00001a3c": "set_data_to_five_00001a3c",
                "FUN_000016ec": "set_initial_data",
                "FUN_00001734": "perform_additional_tasks",
                "DAT_00001a58": "DAT_DATA",
                "PTR_DAT_00001a5c": "PTR_DATA_VALUE"
            },
            "code": "void set_data_to_five_00001a3c(void)\n{\n  set_initial_data(DAT_00001a58,1);\n  perform_additional_tasks();\n  *PTR_DAT_00001a5c = 5;\n  return;\n}",
            "called": [
                "FUN_00001734",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a3c",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "set_data_to_five_00001a3c"
        },
        "FUN_000045ee": {
            "renaming": {
                "FUN_000045ee": "reverse_copy_000045ee",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "n",
                "puVar1": "dest_end",
                "puVar2": "src_end"
            },
            "code": "void reverse_copy_000045ee(char *dest, char *src, int n)\n{\n  char *src_end = src + n;\n  if ((src < dest) && (dest < src_end)) {\n    char *dest_end = dest + n;\n    while (dest_end != dest) {\n      src_end--;\n      dest_end--;\n      *dest_end = *src_end;\n    }\n  }\n  else {\n    src--;\n    for (; src != src_end; src++, dest++) {\n      *dest = *src;\n    }\n  }\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ee",
            "calling": [
                "FUN_00003ff4"
            ],
            "imported": false,
            "current_name": "reverse_copy_000045ee"
        },
        "FUN_00005404": {
            "renaming": {
                "FUN_00005404": "processInput_00005404",
                "param_1": "inputLength",
                "param_2": "inputChar",
                "param_3": "inputBuffer",
                "param_4": "param_4",
                "iVar1": "offset",
                "uVar2": "bufferValue",
                "puVar3": "bufferPtr",
                "PTR_DAT_0000549c": "inputBuffer1",
                "PTR_DAT_000054a0": "inputBuffer2",
                "PTR_DAT_000054a4": "inputBuffer3"
            },
            "code": "uint processInput_00005404(int inputLength, uint inputChar, int *inputBuffer, undefined4 param_4) {\n  int offset = 0;\n  uint bufferValue = 0;\n  int *bufferOffsetPtr;\n  if (inputLength != 0 && *(int *)(inputLength + 0x18) == 0) {\n    initializeBuffer();\n  }\n  if (inputBuffer == (int *)PTR_DAT_0000549c) {\n    bufferOffsetPtr = *(int **)(inputLength + 4);\n  }\n  else if (inputBuffer == (int *)PTR_DAT_000054a0) {\n    bufferOffsetPtr = *(int **)(inputLength + 8);\n  }\n  else if (inputBuffer == (int *)PTR_DAT_000054a4) {\n    bufferOffsetPtr = *(int **)(inputLength + 0xc);\n  }\n  bufferOffsetPtr[2] = bufferOffsetPtr[6];\n  bufferValue = (uint)*(ushort *)(bufferOffsetPtr + 3);\n  offset = bufferValue << 0x1c;\n  if (((offset < 0) && (bufferValue = bufferOffsetPtr[4], bufferValue != 0)) ||\n     (offset = validateInput(inputLength, bufferOffsetPtr, offset, bufferValue, param_4), offset == 0)) {\n    offset = *bufferOffsetPtr - bufferOffsetPtr[4];\n    inputChar = inputChar & 0xff;\n    if ((offset < bufferOffsetPtr[5]) || (offset = addInputToBuffer(inputLength, bufferOffsetPtr), offset == 0)) {\n      bufferOffsetPtr[2] = bufferOffsetPtr[2] + -1;\n      char *bufferPtr = (char *)*bufferOffsetPtr;\n      *bufferOffsetPtr = (int)(bufferPtr + 1);\n      *bufferPtr = (char)inputChar;\n      if (bufferOffsetPtr[5] != offset + 1) {\n        if (-1 < (int)((uint)*(ushort *)(bufferOffsetPtr + 3) << 0x1f)) {\n          return inputChar;\n        }\n        if (inputChar != 10) {\n          return inputChar;\n        }\n      }\n      offset = addInputToBuffer(inputLength, bufferOffsetPtr);\n      if (offset == 0) {\n        return inputChar;\n      }\n    }\n  }\n  return 0xffffffff;\n}",
            "called": [
                "FUN_00004158",
                "FUN_000054a8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005404",
            "calling": [
                "FUN_00004db8",
                "FUN_000057a8",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "processInput_00005404"
        },
        "FUN_00006974": {
            "renaming": {
                "FUN_00006974": "convert_signed_integers_to_longlong_00006974",
                "param_1": "first_integer",
                "param_2": "second_integer",
                "param_3": "third_integer",
                "param_4": "fourth_integer",
                "iVar1": "temp_integer",
                "uVar2": "concatenated_integers",
                "local_8": "local_array"
            },
            "code": "undefined8 convert_signed_integers_to_longlong_00006974(int first_integer, int second_integer, int third_integer, int fourth_integer) {\n    int temp_integer;\n    undefined8 concatenated_integers;\n    undefined local_array[8];\n    \n    if ((fourth_integer == 0) && (third_integer == 0)) {\n        if (second_integer < 0) {\n            first_integer = 0;\n            second_integer = -0x80000000;\n        }\n        else if (second_integer != 0 || first_integer != 0) {\n            second_integer = 0x7fffffff;\n            first_integer = -1;\n        }\n        return CONCAT44(second_integer, first_integer);\n    }\n    if (second_integer < 0) {\n        temp_integer = -second_integer - (uint)(first_integer != 0);\n        if (fourth_integer < 0) {\n            concatenated_integers = FUNC_00006a14(-first_integer, temp_integer, -third_integer, -fourth_integer - (uint)(third_integer != 0), local_array);\n            return concatenated_integers;\n        }\n        concatenated_integers = FUNC_00006a14(-first_integer, temp_integer, third_integer, fourth_integer, local_array);\n        return CONCAT44(-(int)((ulonglong)concatenated_integers >> 0x20) - (uint)((int)concatenated_integers != 0), -(int)concatenated_integers);\n    }\n    if (fourth_integer < 0) {\n        concatenated_integers = FUNC_00006a14(first_integer, second_integer, -third_integer, -fourth_integer - (uint)(third_integer != 0), local_array);\n        return CONCAT44(-(int)((ulonglong)concatenated_integers >> 0x20) - (uint)((int)concatenated_integers != 0), -(int)concatenated_integers);\n    }\n    concatenated_integers = FUNC_00006a14();\n    return concatenated_integers;\n}",
            "called": [
                "FUN_00006a14"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006974",
            "calling": [
                "FUN_0000443c"
            ],
            "imported": false,
            "current_name": "convert_signed_integers_to_longlong_00006974"
        },
        "FUN_00004314": {
            "renaming": {
                "FUN_00004314": "find_and_reset_00004314",
                "param_1": "error_code",
                "piVar1": "current_ptr",
                "piVar2": "next_ptr",
                "iVar3": "base_address",
                "ppiVar4": "list_ptr",
                "PTR_DAT_00004398": "GLOBAL_PTR",
                "DAT_0000439c": "GLOBAL_CONST",
                "FUN_00004274": "initialize",
                "FUN_000042a4": "cleanup",
                "FUN_00004248": "allocate_memory",
                "do_nothing_000045e4": "do_nothing",
                "FUN_00004280": "initialize",
                "FUN_00004622": "clear_memory"
            },
            "code": "int * find_and_reset_00004314(int *error_code) {\n  int *current_ptr;\n  int *next_ptr;\n  int base_address;\n  int **list_ptr;\n\n  initialize();\n  base_address = *(int *)PTR_DAT_00004398;\n  if (*(int *)(base_address + 0x18) == 0) {\n    cleanup(base_address);\n  }\n  list_ptr = (int **)(base_address + 0x48);\n  do {\n    current_ptr = list_ptr[1];\n    next_ptr = list_ptr[2];\n    while (current_ptr = (int *)((int)current_ptr + -1), -1 < (int)current_ptr) {\n      if (*(short *)(next_ptr + 3) == 0) {\n        next_ptr[3] = DAT_0000439c;\n        next_ptr[0x19] = 0;\n        do_nothing(next_ptr + 0x16);\n        initialize();\n        next_ptr[1] = 0;\n        next_ptr[2] = 0;\n        next_ptr[4] = 0;\n        next_ptr[5] = 0;\n        *next_ptr = 0;\n        next_ptr[6] = 0;\n        clear_memory(next_ptr + 0x17,0,8);\n        next_ptr[0xd] = 0;\n        next_ptr[0xe] = 0;\n        next_ptr[0x12] = 0;\n        next_ptr[0x13] = 0;\n        return next_ptr;\n      }\n      next_ptr = next_ptr + 0x1a;\n    }\n    if (*list_ptr == (int *)0x0) {\n      current_ptr = (int *)allocate_memory(error_code,4);\n      *list_ptr = current_ptr;\n      if (current_ptr == (int *)0x0) {\n        initialize();\n        *error_code = 0xc;\n        return (int *)0x0;\n      }\n    }\n    list_ptr = (int **)*list_ptr;\n  } while( true );\n}\n",
            "called": [
                "FUN_00004274",
                "FUN_00004280",
                "FUN_000045e4",
                "FUN_00004248",
                "FUN_00004622",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004314",
            "calling": [
                "FUN_000042a4"
            ],
            "imported": false,
            "current_name": "find_and_reset_00004314"
        },
        "FUN_00004dc8": {
            "renaming": {
                "FUN_00004dc8": "update_data_pointer_00004dc8",
                "param_1": "data",
                "param_2": "data_pointer_address",
                "iVar1": "data_pointer_offset",
                "uVar2": "updated_data_pointer",
                "bVar3": "is_data_pointer_valid"
            },
            "code": "void update_data_pointer_00004dc8(int data, int data_pointer_address)\\\n\\\n{\\\n  int data_pointer_offset;\\\n  uint updated_data_pointer;\\\n  bool is_data_pointer_valid;\\\n  \\\n  data_pointer_offset = get_data_pointer_offset(data_pointer_address, (int)*(short *)(data + 0xe));\\\n  is_data_pointer_valid = data_pointer_offset >= 0;\\\n  if (is_data_pointer_valid) {\\\n    updated_data_pointer = *(int *)(data + 0x54) + data_pointer_offset;\\\n  }\\\n  else {\\\n    updated_data_pointer = *(ushort *)(data + 0xc) & 0xffffefff;\\\n  }\\\n  if (is_data_pointer_valid) {\\\n    *(uint *)(data + 0x54) = updated_data_pointer;\\\n  }\\\n  if (!is_data_pointer_valid) {\\\n    *(short *)(data + 0xc) = (short)updated_data_pointer;\\\n  }\\\n  return;\\\n}",
            "called": [
                "FUN_00000490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004dc8",
            "calling": [],
            "imported": false,
            "current_name": "update_data_pointer_00004dc8"
        },
        "FUN_00005fd8": {
            "renaming": {
                "FUN_00005fd8": "process_data_00005fd8",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "*DAT_00005fe8": "data_pointer",
                "FUN_00005edc": "call_data_processing_function"
            },
            "code": "void process_data_00005fd8(int* *DAT_00005fe8, int param1, int param2, int param3)\n{\n  call_data_processing_function(**DAT_00005fe8, param1, param2, param3);\n  return;\n}",
            "called": [
                "FUN_00005edc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005fd8",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "process_data_00005fd8"
        },
        "FUN_00005e10": {
            "renaming": {
                "FUN_00005e10": "read_byte_00005e10",
                "param_1": "buffer_address",
                "param_2": "byte_pointer",
                "iVar1": "read_status",
                "uVar2": "byte_value",
                "pbVar3": "current_byte"
            },
            "code": "uint read_byte_00005e10(int buffer_address, byte **byte_pointer){\n    int read_status;\n    uint byte_value;\n    byte *current_byte;\n    if ((buffer_address != 0) && (*(int *)(buffer_address + 0x18) == 0)) {\n        initialize_buffer();\n    }\n    if (byte_pointer == (byte **)PTR_DAT_00005e5c) {\n        byte_pointer = *(byte ***)(buffer_address + 4);\n    }\n    else if (byte_pointer == (byte **)PTR_DAT_00005e60) {\n        byte_pointer = *(byte ***)(buffer_address + 8);\n    }\n    else if (byte_pointer == (byte **)PTR_DAT_00005e64) {\n        byte_pointer = *(byte ***)(buffer_address + 0xc);\n    }\n    read_status = read_from_buffer(buffer_address, byte_pointer);\n    if (read_status == 0) {\n        byte_pointer[1] = byte_pointer[1] - 1;\n        current_byte = *byte_pointer;\n        *byte_pointer = current_byte + 1;\n        byte_value = (uint)*current_byte;\n    }\n    else {\n        byte_value = 0xffffffff;\n    }\n    return byte_value;\n}",
            "called": [
                "FUN_00006768",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005e10",
            "calling": [
                "FUN_00004418"
            ],
            "imported": false,
            "current_name": "read_byte_00005e10"
        },
        "FUN_000033f4": {
            "renaming": {
                "FUN_000033f4": "set_alarm_if_valid_time_000033f4",
                "param_1": "time",
                "iVar1": "result",
                "auStack_2c": "time_string",
                "FUN_0000328c": "get_formatted_time_string",
                "PTR_FUN_000031e0_1_0000343c": "PTR_FUN_000031e0_1_0000343c",
                "FUN_00002654": "set_alarm",
                "PTR_s_rtc__error_setting_alarm_00003440": "PTR_s_rtc__error_setting_alarm_00003440"
            },
            "code": "int set_alarm_if_valid_time_000033f4(int time)\n{\n  int result;\n  char time_string[36];\n\n  result = get_formatted_time_string(time, time_string);\n  if (result == 0) {\n    result = set_alarm(time_string, PTR_FUN_000031e0_1_0000343c, 0);\n    if (result == -1) {\n      log_error(PTR_s_rtc__error_setting_alarm_00003440);\n      result = 1;\n    }\n    else {\n      result = 0;\n    }\n  }\n  else {\n    result = 1;\n  }\n  return result;\n}",
            "called": [
                "FUN_0000328c",
                "FUN_00004db8",
                "FUN_00002654"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000033f4",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "set_alarm_if_valid_time_000033f4"
        },
        "FUN_0000443c": {
            "renaming": {
                "FUN_0000443c": "convert_unix_time_to_date_0000443c",
                "param_1": "unix_time",
                "param_2": "date",
                "iVar1": "days_since_1970",
                "uVar2": "weekday",
                "uVar3": "remaining_days",
                "uVar4": "leap_years",
                "uVar5": "non_leap_years",
                "uVar6": "days_in_year",
                "uVar7": "days_in_month",
                "uVar8": "days_in_week",
                "bVar9": "is_negative",
                "DAT_0000458c": "DAYS_BETWEEN_1970_AND_2000",
                "DAT_00004594": "DAYS_IN_400_YEARS",
                "DAT_00004590": "DAYS_IN_100_YEARS",
                "DAT_00004598": "DAYS_IN_4_YEARS",
                "*param_1": "*unix_time",
                "param_1[1]": "*(unix_time + 1)"
            },
            "code": "uint * convert_unix_time_to_date_0000443c(uint32_t *unix_time, uint32_t *date)\n{\n  int days_since_1970;\n  uint leap_years, non_leap_years, days_in_year, days_in_month, weekday, year, month, day;\n  uint remaining_days;\n  \n  days_since_1970 = FUN_00006974(*unix_time, *(unix_time + 1), DAT_0000458c, 0);\n  \n  if (days_since_1970 < 0) {\n    days_since_1970 += 0x15180;\n  }\n  \n  if (days_since_1970 % 7 < 2) {\n    weekday = (days_since_1970 % 7) + 5;\n  } else {\n    weekday = days_since_1970 % 7 - 2;\n  }\n  \n  remaining_days = days_since_1970 - ((days_since_1970 / 146097) * 146097);\n  leap_years = remaining_days / 36524;\n  remaining_days -= leap_years * 36524;\n  non_leap_years = remaining_days / 365 + remaining_days / 1461 - remaining_days / 36524;\n  remaining_days -= (non_leap_years * 365) + (non_leap_years / 4) - (non_leap_years / 100) + (non_leap_years / 400);\n  \n  if (remaining_days < 0x132) {\n    year = (remaining_days / 31) + 1;\n    days_in_month = remaining_days % 31 + 1;\n  } else {\n    year = remaining_days / 365;\n    days_in_month = remaining_days % 365 - 306;\n    if (days_in_month < 0) {\n      year--;\n      days_in_month += 365 + IS_LEAP_YEAR(year);\n    }\n    year += 1970;\n  }\n  \n  month = get_month_from_days_in_month(days_in_month, IS_LEAP_YEAR(year));\n  day = days_in_month - get_days_in_month(month, IS_LEAP_YEAR(year)) + 1;\n  \n  date[0] = year;\n  date[1] = month;\n  date[2] = day;\n  date[3] = weekday;\n  date[4] = non_leap_years;\n  date[5] = leap_years;\n  date[6] = 0;\n  \n  return date;\n}\n\nint get_month_from_days_in_month(int days_in_month, int is_leap_year)\n{\n  int month;\n  \n  if (is_leap_year && days_in_month > 58) {\n    month = (days_in_month * 12 + 373) / 367;\n  } else {\n    month = (days_in_month * 12 + 373) / 367 - 1;\n  }\n  \n  return month;\n}\n\nint get_days_in_month(int month, int is_leap_year)\n{\n  int days_in_month;\n  \n  if (month == 1) {\n    days_in_month = 28 + is_leap_year;\n  } else {\n    days_in_month = 31 - ((month - 1) % 7 % 2);\n  }\n  \n  return days_in_month;\n}\n\nint IS_LEAP_YEAR(int year)\n{\n  if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n",
            "called": [
                "FUN_00006974"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000443c",
            "calling": [
                "FUN_00002624",
                "FUN_00002690"
            ],
            "imported": false,
            "current_name": "convert_unix_time_to_date_0000443c"
        },
        "FUN_000027b0": {
            "renaming": {
                "FUN_000027b0": "initialize_device_000027b0",
                "puVar1": "device_data",
                "DAT_00002814": "device_data_ptr",
                "DAT_00002818": "device_data_addr",
                "uint": "uint32_t"
            },
            "code": "void initialize_device_000027b0(void)\n{\n  uint32_t *device_data = DAT_00002814;\n  *(uint32_t *)(DAT_00002818 + 0x103c) |= 0x20000000;\n  device_data[4] = 1;\n  device_data[4] = 0;\n  if ((device_data[5] & 1) != 0) {\n    *device_data = 0;\n  }\n  device_data[4] = 0x104;\n  device_data[2] = 0xffffff42;\n  device_data[7] = 0;\n  setup_device();\n  return;\n}",
            "called": [
                "FUN_0000294c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000027b0",
            "calling": [
                "FUN_000025f4"
            ],
            "imported": false,
            "current_name": "initialize_device_000027b0"
        },
        "FUN_00005ebc": {
            "renaming": {
                "FUN_00005ebc": "copy_string_00005ebc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_char"
            },
            "code": "void copy_string_00005ebc(char *destination, char *source) {\n  char current_char;\n  do {\n    current_char = *source;\n    *destination = current_char;\n    source++;\n    destination++;\n  } while (current_char != '\\0');\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005ebc",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "copy_string_00005ebc"
        },
        "FUN_00006192": {
            "renaming": {
                "FUN_00006192": "clear_flag_00006192",
                "param_1": "flag",
                "param_2": "data",
                "PTR_": "",
                "DAT_": "",
                "undefined4": "unsigned int",
                "ushort": "unsigned short"
            },
            "code": "unsigned int clear_flag_00006192(unsigned int flag, unsigned int *data)\n{\n    unsigned int *flag_ptr = (unsigned int *)data[13];\n    if (flag_ptr != NULL)\n    {\n        if (flag_ptr != data + 17)\n        {\n            do_something();\n        }\n        data[1] = data[16];\n        data[13] = NULL;\n        if (data[16] != 0)\n        {\n            *data = data[15];\n            return 0;\n        }\n    }\n    *data = data[4];\n    data[1] = 0;\n    *(unsigned short *)(data + 6) |= flag;\n    return 0xffffffff;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006192",
            "calling": [
                "FUN_000061cc"
            ],
            "imported": false,
            "current_name": "clear_flag_00006192"
        },
        "FUN_00001734": {
            "renaming": {
                "FUN_00001734": "print_data_00001734",
                "FUN_00001710": "print_string",
                "DAT_00001744": "data"
            },
            "code": "void print_data_00001734(void)\n{\n    print_string(DAT_00001744, 6);\n    return;\n}",
            "called": [
                "FUN_00001710"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001734",
            "calling": [
                "FUN_00001a18",
                "FUN_000019c0",
                "FUN_00001a3c"
            ],
            "imported": false,
            "current_name": "print_data_00001734"
        },
        "FUN_00000e14": {
            "renaming": {
                "FUN_00000e14": "calculate_result_00000e14",
                "param_1": "first_param",
                "param_2": "second_param",
                "uVar1": "result"
            },
            "code": "int calculate_result_00000e14(int first_param, int second_param) {\n  int result = calculate(DAT_00000e34, first_param, second_param);\n  return result;\n}",
            "called": [
                "FUN_000012e2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000e14",
            "calling": [
                "FUN_00000490"
            ],
            "imported": false,
            "current_name": "calculate_result_00000e14"
        },
        "FUN_0000281c": {
            "renaming": {
                "FUN_0000281c": "find_first_non_matching_element_0000281c",
                "local_10": "count",
                "local_c": "current_element"
            },
            "code": "int find_first_non_matching_element_0000281c(void)\n{\n  int count = 0;\n  int current_element;\n  while (count < 3 && (current_element = *DAT_00002858, current_element != *DAT_00002858)) {\n    count++;\n  }\n  return current_element;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000281c",
            "calling": [
                "FUN_00002624"
            ],
            "imported": false,
            "current_name": "find_first_non_matching_element_0000281c"
        },
        "FUN_00002270": {
            "renaming": {
                "FUN_00002270": "is_last_element_00002270",
                "param_1": "array",
                "iVar2": "last_element",
                "bVar3": "is_last",
                "uVar1": "result"
            },
            "code": "bool is_last_element_00002270(int *array, int array_size, int element_index) {\n                      int last_element = *(array + array_size - 1);\n                      bool is_last = element_index == last_element;\n                      return is_last;\n                  }",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002270",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "is_last_element_00002270"
        },
        "FUN_00005780": {
            "renaming": {
                "FUN_00005780": "execute_function_with_param_00005780",
                "param_1": "parameter",
                "DAT_0000578c": "function_ptr",
                "FUN_00004b34": "function_ptr",
                "*DAT_0000578c": "function_ptr"
            },
            "code": "void execute_function_with_param_00005780(void* DAT_0000578c, int parameter) {\n  DAT_0000578c(parameter);\n  return;\n}",
            "called": [
                "FUN_00004b34"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00005780",
            "calling": [
                "FUN_00005100"
            ],
            "imported": false,
            "current_name": "execute_function_with_param_00005780"
        },
        "FUN_000020cc": {
            "renaming": {
                "FUN_000020cc": "initialize_data_000020cc",
                "FUN_00002028": "set_data_defaults",
                "DAT_000020dc": "data_array"
            },
            "code": "void initialize_data_000020cc(void)\n{\n  set_data_defaults(DAT_000020dc, 1);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020cc",
            "calling": [],
            "imported": false,
            "current_name": "initialize_data_000020cc"
        },
        "FUN_00002396": {
            "renaming": {
                "FUN_00002396": "execute_function_00002396",
                "FUN_000025f4": "perform_initialization"
            },
            "code": "void execute_function_00002396(void)\n{\n  perform_initialization();\n  return;\n}",
            "called": [
                "FUN_000025f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002396",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "execute_function_00002396"
        },
        "FUN_00004cb4": {
            "renaming": {
                "FUN_00004cb4": "decrease_and_store_00004cb4",
                "param_1": "value",
                "puVar1": "data_pointer",
                "uVar2": "result",
                "puVar3": "char_pointer",
                "unaff_r4": "unused_r4",
                "iVar4": "data_offset",
                "unaff_r5": "unused_r5"
            },
            "code": "uint decrease_and_store_00004cb4(uint value)\n{\n  undefined4 *data_pointer;\n  uint result;\n  undefined *char_pointer;\n  undefined4 unused_r4;\n  int data_offset;\n  undefined4 unused_r5;\n  \n  data_offset = *DAT_00004cd8;\n  if ((data_offset != 0) && (*(int *)(data_offset + 0x18) == 0)) {\n    FUN_000042a4(data_offset);\n  }\n  data_pointer = *(undefined4 **)(data_offset + 8);\n  if ((data_offset != 0) && (*(int *)(data_offset + 0x18) == 0)) {\n    FUN_000042a4();\n  }\n  if (data_pointer == (undefined4 *)PTR_DAT_00005e04) {\n    data_pointer = *(undefined4 **)(data_offset + 4);\n  }\n  else if (data_pointer == (undefined4 *)PTR_DAT_00005e08) {\n    data_pointer = *(undefined4 **)(data_offset + 8);\n  }\n  else if (data_pointer == (undefined4 *)PTR_DAT_00005e0c) {\n    data_pointer = *(undefined4 **)(data_offset + 0xc);\n  }\n  if ((-1 < (int)(data_pointer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(data_pointer + 3) << 0x16))) {\n    do_nothing_000045e8(data_pointer[0x16]);\n  }\n  result = data_pointer[2] - 1;\n  data_pointer[2] = result;\n  if (((int)result < 0) && (((int)result < (int)data_pointer[6] || (result = value & 0xff, result == 10))))\n  {\n    value = FUN_00005404(data_offset,value,data_pointer,result,unused_r4,unused_r5);\n  }\n  else {\n    char_pointer = (undefined *)*data_pointer;\n    *data_pointer = char_pointer + 1;\n    *char_pointer = (char)value;\n    value = value & 0xff;\n  }\n  if ((-1 < (int)(data_pointer[0x19] << 0x1f)) && (-1 < (int)((uint)*(ushort *)(data_pointer + 3) << 0x16))) {\n    do_nothing_000045ec(data_pointer[0x16]);\n  }\n  return value;\n}",
            "called": [
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_00005404",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004cb4",
            "calling": [
                "FUN_00002a00"
            ],
            "imported": false,
            "current_name": "decrease_and_store_00004cb4"
        },
        "FUN_00003478": {
            "renaming": {
                "FUN_00003478": "set_time_and_check_error_00003478",
                "param_1": "time_to_set",
                "iVar1": "set_time_result",
                "uVar2": "error_check_result",
                "auStack_2c": "time_buffer"
            },
            "code": "int set_time_and_check_error_00003478(int time_to_set){\n                          int set_time_result;\n                          undefined4 error_check_result;\n                          undefined time_buffer[36];\n                          \n                          set_time_result = FUN_0000328c(time_to_set, time_buffer);\n                          if (set_time_result == 0) {\n                            error_check_result = FUN_00002600(time_buffer);\n                            if (error_check_result == -1) {\n                              FUN_00004db8(PTR_s_rtc__error_setting_time_000034bc);\n                              return 1;\n                            }\n                            else {\n                              return 0;\n                            }\n                          }\n                          else {\n                            return 1;\n                          }\n                        }",
            "called": [
                "FUN_00002600",
                "FUN_0000328c",
                "FUN_00004db8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003478",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "set_time_and_check_error_00003478"
        },
        "FUN_00002028": {
            "renaming": {
                "FUN_00002028": "process_data_00002028",
                "param_1": "data_array",
                "param_2": "data_length",
                "iVar1": "function_index",
                "uVar2": "current_bits",
                "local_c": "bit_mask",
                "PTR_DAT_000020b4": "function_table"
            },
            "code": "void process_data_00002028(int data_array[], int data_length) {\n  int index;\n  uint32_t bit_mask;\n  uint32_t current_bits;\n  for (index = 0; index < data_length; index++) {\n    current_bits = *(uint32_t *)(data_array + index * 4);\n    for (bit_mask = 0x1; bit_mask < 0x100000; bit_mask = bit_mask << 1) {\n      if ((current_bits & bit_mask) != 0) {\n        int function_index = get_function_index(bit_mask);\n        if (function_index >= 0) {\n          call_function(function_index);\n        }\n      }\n    }\n  }\n  finalize_processing();\n}\n",
            "called": [
                "FUN_00001e0c",
                "FUN_00001cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002028",
            "calling": [
                "FUN_000020b8",
                "FUN_00002108",
                "FUN_000020f4",
                "FUN_000020cc",
                "FUN_000020e0"
            ],
            "imported": false,
            "current_name": "process_data_00002028"
        },
        "FUN_000016c8": {
            "renaming": {
                "FUN_000016c8": "set_pointer_value_to_one_000016c8",
                "param_1": "pointer_value",
                "param_2": "unused_parameter",
                "puVar1": "pointer_to_value",
                "FUN_00001696": "get_pointer_value"
            },
            "code": "void set_pointer_value_to_one_000016c8(undefined4 pointer_value, undefined unused_parameter)\n{\n  undefined4 *pointer_to_value;\n  pointer_to_value = (undefined4 *)get_pointer_value(pointer_value, unused_parameter);\n  *pointer_to_value = 1;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000016c8",
            "calling": [
                "FUN_000017dc"
            ],
            "imported": false,
            "current_name": "set_pointer_value_to_one_000016c8"
        },
        "FUN_00001a60": {
            "renaming": {
                "FUN_00001a60": "initialize_data_transfer_00001a60",
                "DAT_00001ac4": "DAT_buffer",
                "*DAT_00001ac8": "*control_register",
                "FUN_00001710": "set_data_rate",
                "DAT_00001acc": "DAT_buffer",
                "FUN_000016ec": "set_data_length",
                "*PTR_DAT_00001ad0": "*PTR_status_register"
            },
            "code": "void initialize_data_transfer_00001a60(void)\n{\n  set_data_rate(DAT_00001ac4,1);\n  *DAT_00001ac8 = *DAT_00001ac8 & 0x3f | 0x80;\n  do {\n  } while ((control_register[6] & 0xc) != 8);\n  set_data_length(DAT_00001ac4,6);\n  do {\n  } while ((control_register[6] & 0x20) == 0);\n  do {\n  } while ((control_register[6] & 0x40) == 0);\n  *PTR_DAT_00001ad0 = 6;\n  return;\n}\n",
            "called": [
                "FUN_00001710",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001a60",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "initialize_data_transfer_00001a60"
        },
        "FUN_0000099c": {
            "renaming": {
                "FUN_0000099c": "initialize_memory_0000099c",
                "uStack_18": "stack_variable",
                "local_14": "stack_pointer",
                "local_10": "data_pointer",
                "local_c": "memory_pointer",
                "DAT_00000a14": "DATA_00000a14",
                "FUN_00000db0": "initialize_system",
                "PTR_DAT_00000a18": "PTR_DATA_00000a18",
                "DAT_00000a1c": "DATA_00000a1c",
                "PTR_Elf32_Rel_ARRAY_00000a20": "PTR_DATA_00000a20",
                "PTR_DAT_00000a24": "PTR_DATA_00000a24",
                "PTR_DAT_00000a28": "PTR_DATA_00000a28",
                "DAT_00000a2c": "DATA_00000a2c",
                "do_nothing_00000990": "do_nothing",
                "FUN_00000e64": "initialize_subsystem",
                "FUN_0000459c": "initialize_components",
                "FUN_00000f8c": "initialize_finalization"
            },
            "code": "void initialize_memory_0000099c(void)\n{\n  undefined4 stack_variable;\n  undefined4 *stack_pointer = &stack_variable;\n  undefined4 *data_pointer = DAT_00000a14;\n  initialize_system();\n  undefined4 *memory_pointer = (undefined4 *)PTR_DAT_00000a18;\n  while (memory_pointer < &stack_variable) {\n    *memory_pointer = DAT_00000a1c;\n    memory_pointer++;\n  }\n  memory_pointer = (undefined4 *)PTR_Elf32_Rel_ARRAY_00000a20;\n  while (memory_pointer < PTR_DAT_00000a24) {\n    *memory_pointer = *data_pointer;\n    data_pointer++;\n    memory_pointer++;\n  }\n  memory_pointer = (undefined4 *)PTR_DAT_00000a28;\n  while (true) {\n    if (DAT_00000a2c <= memory_pointer) break;\n    *memory_pointer = 0;\n    memory_pointer++;\n  }\n  do_nothing();\n  initialize_subsystem();\n  initialize_components();\n  initialize_finalization();\n  return;\n}",
            "called": [
                "FUN_0000459c",
                "FUN_00000f8c",
                "FUN_00000e64",
                "FUN_00000990",
                "FUN_00000db0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000099c",
            "calling": [],
            "imported": false,
            "current_name": "initialize_memory_0000099c"
        },
        "FUN_00002d94": {
            "renaming": {
                "FUN_00002d94": "reverse_input_string_and_return_first_char_index_00002d94",
                "param_1": "input_string",
                "param_2": "string_length",
                "iVar1": "current_char_code",
                "bVar2": "current_byte",
                "bVar3": "is_first_char",
                "local_c": "current_char_ptr"
            },
            "code": "uint reverse_input_string_and_return_first_char_index_00002d94(undefined *input_string, int string_length)\n{\n  int current_char_code;\n  byte current_byte;\n  bool is_first_char = true;\n  undefined *current_char_ptr = input_string;\n  while( true ) {\n    if (string_length + -1 <= (int)current_char_ptr - (int)input_string) {\n      return 0xffffffff;\n    }\n    current_char_code = FUN_00004418();\n    if (current_char_code < 0) break;\n    if ((current_char_code == 0xd) || (current_char_code == 10)) {\n      *current_char_ptr = 0;\n      FUN_00002a00(0xd);\n      FUN_00002a00(10);\n      if (is_first_char) {\n        input_string = (undefined *)0x1;\n      }\n      current_byte = (byte)input_string;\n      if (!is_first_char) {\n        current_byte = 0;\n      }\n      return (uint)current_byte;\n    }\n    if ((current_char_code == 8) || (current_char_code == 0x7f)) {\n      if (current_char_ptr != input_string) {\n        current_char_ptr = current_char_ptr + -1;\n        *current_char_ptr = 0;\n        FUN_00002a00(8);\n        FUN_00002a00(0x20);\n        FUN_00002a00(8);\n      }\n    }\n    else {\n      *current_char_ptr = (char)current_char_code;\n      FUN_00002a00(current_char_code);\n      current_char_ptr = current_char_ptr + 1;\n      is_first_char = false;\n    }\n  }\n  return 1;\n}",
            "called": [
                "FUN_00004418",
                "FUN_00002a00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002d94",
            "calling": [
                "FUN_00002e6c"
            ],
            "imported": false,
            "current_name": "reverse_input_string_and_return_first_char_index_00002d94"
        },
        "FUN_00003918": {
            "renaming": {
                "FUN_00003918": "get_value_from_param_00003918",
                "param_1": "param",
                "uVar1": "value"
            },
            "code": "int get_value_from_param_00003918(int param) {\n    int value;\n    switch(param) {\n        case 2:\n            value = 0x68;\n            break;\n        case 3:\n            value = 0x6b;\n            break;\n        case 6:\n            value = 0x4d;\n            break;\n        case 9:\n            value = 0x47;\n            break;\n        case 0xc:\n            value = 0x54;\n            break;\n        case 0xf:\n            value = 0x50;\n            break;\n        case 0xf1:\n            value = 0x66;\n            break;\n        case 0xf4:\n            value = 0x70;\n            break;\n        case 0xf7:\n            value = 0x6e;\n            break;\n        case 0xfa:\n            value = 0x75;\n            break;\n        case 0xfd:\n            value = 0x6d;\n            break;\n        default:\n            value = 0;\n            break;\n    }\n    return value;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003918",
            "calling": [
                "FUN_00003694"
            ],
            "imported": false,
            "current_name": "get_value_from_param_00003918"
        },
        "FUN_00003d64": {
            "renaming": {
                "FUN_00003d64": "execute_function_00003d64",
                "param_1": "function_pointer",
                "param_2": "arg1",
                "uVar1": "result"
            },
            "code": "int execute_function_00003d64(int function_pointer, int arg1) {\n  int result;\n  if (function_pointer == 0) {\n    result = -19;\n  }\n  else {\n    result = (***(int ***)(function_pointer + 0xc))(*(int *)(function_pointer + 4), arg1);\n  }\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003d64",
            "calling": [
                "FUN_00002ecc"
            ],
            "imported": false,
            "current_name": "execute_function_00003d64"
        },
        "FUN_00004e52": {
            "renaming": {
                "FUN_00004e52": "compare_bytes_00004e52",
                "param_1": "first_byte",
                "param_2": "second_byte",
                "bVar1": "second_value",
                "uVar2": "index",
                "bVar3": "values_match"
            },
            "code": "int compare_bytes_00004e52(byte *first_byte, byte *second_byte) {\n    byte first_value;\n    byte second_value;\n    uint index = 0;\n    bool values_match;\n    do {\n        first_value = *first_byte;\n        second_value = *second_byte;\n        values_match = (first_value == second_value) || (first_value == 0);\n        first_byte++;\n        second_byte++;\n        index++;\n    } while (values_match);\n    return (int)first_value - (int)second_value;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e52",
            "calling": [
                "FUN_00002a18",
                "FUN_00005100",
                "FUN_00004e52",
                "FUN_00002fe0",
                "FUN_0000316c",
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "compare_bytes_00004e52"
        },
        "FUN_000010d4": {
            "renaming": {
                "FUN_000010d4": "process_data_000010d4",
                "param_1": "data_offset",
                "param_2": "data_length",
                "param_3": "data_size",
                "param_4": "options",
                "uVar1": "alloc_result",
                "uVar2": "data",
                "iVar3": "return_value",
                "uVar4": "allocated_data_size",
                "puVar5": "allocated_data",
                "local_30": "remaining_data_length",
                "local_2c": "allocated_data_offset",
                "local_10": "i",
                "local_c": "free_index",
                "local_a": "index"
            },
            "code": "int process_data_000010d4(uint data_offset, int data_length, byte data_size, uint options, undefined4 param_5, undefined4 param_6, undefined4 param_7)\n{\n    undefined4 alloc_result;\n    undefined4 *allocated_data;\n    int remaining_data_length;\n    uint allocated_data_offset;\n    short free_index;\n    short index;\n\n    if (data_size >= 0x10) {\n        return -0x16;\n    }\n\n    remaining_data_length = data_length;\n    allocated_data_offset = data_offset;\n\n    if ((data_offset & 3) != 0) {\n        int padding = 4 - (data_offset & 3);\n        allocated_data_offset = padding + data_offset;\n        remaining_data_length = data_length - padding;\n    }\n\n    uint allocated_data_size = (remaining_data_length - 0x30U) & 0xfffffffc;\n    allocated_data = (undefined4 *)(allocated_data_size + allocated_data_offset);\n\n    if ((options & 8) == 0) {\n        *(uint *)allocated_data_offset = allocated_data_offset;\n    }\n    else {\n        for (uint i = allocated_data_offset; i < allocated_data_size + allocated_data_offset; i = i + 4) {\n            *(uint *)i = i;\n        }\n    }\n\n    alloc_result = allocate_memory();\n    free_index = 0;\n    for (index = 1; index < 0x21; index++) {\n        if (*(int *)(PTR_DAT_0000126c + index * 4) == 0) {\n            free_index = index;\n            break;\n        }\n    }\n\n    if (free_index == 0) {\n        free_memory(alloc_result);\n        return -0x8b;\n    }\n    else {\n        *(undefined4 **)(PTR_DAT_0000126c + free_index * 4) = allocated_data;\n        *(short *)((int)allocated_data + 6) = free_index;\n        undefined4 data = process_data_000010d4(param_5, param_6, allocated_data_offset, allocated_data_size);\n        *allocated_data = data;\n        allocated_data[9] = allocated_data_offset;\n        allocated_data[0xb] = data_length;\n        allocated_data[10] = param_7;\n        *(byte *)((int)allocated_data + 5) = data_size;\n        *(undefined *)(allocated_data + 1) = 0;\n        allocated_data[2] = 0;\n        allocated_data[3] = 0;\n        allocated_data[4] = 0;\n        process_data_000010d4(allocated_data + 5, 0);\n        allocated_data[8] = 0;\n        *(int *)PTR_DAT_00001270 = *(int *)PTR_DAT_00001270 + 1;\n        if ((options & 1) == 0) {\n            process_data_000010d4(allocated_data, 10);\n            if ((options & 4) == 0) {\n                free_memory(alloc_result);\n                free_data(data_size);\n                return (int)free_index;\n            }\n        }\n        else {\n            process_data_000010d4(allocated_data, 1);\n        }\n        free_memory(alloc_result);\n        return (int)free_index;\n    }\n}",
            "called": [
                "FUN_00000d0c",
                "FUN_00000cd0",
                "FUN_00000fec",
                "FUN_000007dc",
                "FUN_00000738",
                "FUN_00000698"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000010d4",
            "calling": [
                "FUN_00000f8c"
            ],
            "imported": false,
            "current_name": "process_data_000010d4"
        },
        "FUN_000045e4": {
            "renaming": {
                "FUN_000045e4": "do_nothing_000045e4"
            },
            "code": "\nvoid do_nothing_000045e4(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e4",
            "calling": [
                "FUN_00004314"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e4"
        },
        "FUN_00000738": {
            "renaming": {
                "FUN_00000738": "validate_input_00000738",
                "param_1": "input",
                "iVar1": "result",
                "PTR_DAT_0000078c": "ptr_data_1",
                "PTR_DAT_00000790": "ptr_data_2"
            },
            "code": "void validate_input_00000738(ushort input){\n    int num_of_elements = *(byte *)(*(int *)PTR_DAT_0000078c + 4);\n    int min_input = *(byte *)(*(int *)PTR_DAT_0000078c + 5);\n\n    if (num_of_elements < 9 || input < min_input){\n        int result = FUN_00000d2a();\n        if (result == 0){\n            FUN_0000093c();\n        }\n        else{\n            *(undefined4 *)PTR_DAT_00000790 = 1;\n        }\n    }\n    return;\n}",
            "called": [
                "FUN_00000d2a",
                "FUN_0000093c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000738",
            "calling": [
                "FUN_000024bc",
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "validate_input_00000738"
        },
        "FUN_00003e58": {
            "renaming": {
                "FUN_00003e58": "reverse_number_string_00003e58",
                "param_1": "number_string",
                "param_2": "string_length",
                "local_18": "string_length_copy",
                "local_14": "number_string_copy",
                "FUN_00003dc4": "reverse_string",
                "iVar1": "reversed_number",
                "*param_1": "*number_string"
            },
            "code": "int reverse_number_string_00003e58(char *number_string, int string_length) {\n  int is_negative = string_length > 0 && number_string[0] == '-';\n  if (is_negative) {\n    number_string++;\n    string_length--;\n  }\n  int reversed_number = reverse_string(number_string, string_length);\n  if (is_negative) {\n    reversed_number = -reversed_number;\n  }\n  return reversed_number;\n}",
            "called": [
                "FUN_00003dc4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003e58",
            "calling": [
                "FUN_00003ec4"
            ],
            "imported": false,
            "current_name": "reverse_number_string_00003e58"
        },
        "FUN_00004e26": {
            "renaming": {
                "FUN_00004e26": "check_and_set_value_00004e26",
                "param_1": "input",
                "param_2": "param_2",
                "iVar1": "result",
                "uVar2": "modified_value",
                "bVar3": "is_negative"
            },
            "code": "void check_and_set_value_00004e26(undefined4 input, int param_2)\n{\n    int result = FUN_000004f2(input, (int)*(short *)(param_2 + 0xe));\n    bool is_negative = result == -1;\n    ushort modified_value;\n    if (is_negative)\n    {\n        modified_value = *(ushort *)(param_2 + 0xc) & 0xefff;\n    }\n    else\n    {\n        *(int *)(param_2 + 0x54) = result;\n        modified_value = *(ushort *)(param_2 + 0xc) | 0x1000;\n    }\n    *(ushort *)(param_2 + 0xc) = modified_value;\n}\n",
            "called": [
                "FUN_000004f2"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004e26",
            "calling": [],
            "imported": false,
            "current_name": "check_and_set_value_00004e26"
        },
        "FUN_000045e8": {
            "renaming": {
                "FUN_000045e8": "do_nothing_000045e8"
            },
            "code": "\nvoid do_nothing_000045e8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045e8",
            "calling": [
                "FUN_00004274",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00005fec",
                "FUN_0000428c",
                "FUN_00005790",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045e8"
        },
        "FUN_000057f8": {
            "renaming": {
                "FUN_000057f8": "FUNC_000057f8"
            },
            "code": "\nint FUNC_000057f8(int param_1,undefined *param_2,byte *param_3,int *param_4)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  int iVar3;\n  int iVar4;\n  int *piVar5;\n  bool bVar6;\n  byte *pbVar7;\n  int unaff_r7;\n  byte *pbVar8;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 != 0) && (*(int *)(param_1 + 0x18) == 0)) {\n    FUN_000042a4();\n  }\n  if (param_2 == PTR_DAT_00005a38) {\n    param_2 = *(undefined **)(param_1 + 4);\n  }\n  else if (param_2 == PTR_DAT_00005a3c) {\n    param_2 = *(undefined **)(param_1 + 8);\n  }\n  else if (param_2 == PTR_DAT_00005a40) {\n    param_2 = *(undefined **)(param_1 + 0xc);\n  }\n  if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n     (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n    do_nothing_000045e8(*(undefined4 *)(param_2 + 0x58));\n  }\n  if (((-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x1c)) || (*(int *)(param_2 + 0x10) == 0)) &&\n     (iVar3 = FUN_000054a8(param_1,param_2), iVar3 != 0)) {\n    if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n       (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n      do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n    }\n    return -1;\n  }\n  puVar1 = PTR_s___0__00005a44;\n  local_74 = 0;\n  local_6f = 0x20;\n  local_6e = 0x30;\n  pbVar8 = param_3;\n  local_8c = param_4;\nLAB_0000588e:\n  pbVar7 = pbVar8;\n  if (*pbVar7 != 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar8 = pbVar7 + 1;\n  if (*pbVar7 != 0x25) goto LAB_0000588e;\nLAB_0000589a:\n  iVar3 = (int)pbVar7 - (int)param_3;\n  if (iVar3 != 0) {\n    iVar4 = FUN_000057d2(param_1,param_2,param_3,iVar3);\n    if (iVar4 == -1) {\nLAB_00005a06:\n      if ((-1 < *(int *)(param_2 + 100) << 0x1f) &&\n         (-1 < (int)((uint)*(ushort *)(param_2 + 0xc) << 0x16))) {\n        do_nothing_000045ec(*(undefined4 *)(param_2 + 0x58));\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) << 0x19) < 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 = local_74 + iVar3;\n  }\n  if (*pbVar7 == 0) goto LAB_00005a06;\n  local_84 = -1;\n  uStack_80 = 0;\n  local_88 = 0;\n  local_7c = 0;\n  local_45 = 0;\n  local_30 = 0;\n  pbVar8 = pbVar7 + 1;\n  while( true ) {\n    pbVar7 = pbVar8 + 1;\n    iVar3 = FUN_00006010(PTR_s___0__00005a44,*pbVar8,5);\n    puVar2 = PTR_DAT_00005a54;\n    if (iVar3 == 0) break;\n    local_88 = 1 << (iVar3 - (int)puVar1 & 0xffU) | local_88;\n    pbVar8 = pbVar7;\n  }\n  if ((int)(local_88 << 0x1b) < 0) {\n    local_45 = 0x20;\n  }\n  if ((int)(local_88 << 0x1c) < 0) {\n    local_45 = 0x2b;\n  }\n  if (*pbVar8 == 0x2a) {\n    piVar5 = local_8c + 1;\n    local_7c = *local_8c;\n    local_8c = piVar5;\n    if (local_7c < 0) {\n      local_7c = -local_7c;\n      local_88 = local_88 | 2;\n    }\n  }\n  else {\n    bVar6 = false;\n    iVar3 = local_7c;\n    pbVar7 = pbVar8;\n    while( true ) {\n      if (9 < *pbVar7 - 0x30) break;\n      iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n      bVar6 = true;\n      pbVar7 = pbVar7 + 1;\n    }\n    if (bVar6) {\n      local_7c = iVar3;\n    }\n  }\n  if (*pbVar7 == 0x2e) {\n    if (pbVar7[1] == 0x2a) {\n      local_84 = *local_8c;\n      if (local_84 < 0) {\n        local_84 = -1;\n      }\n      pbVar7 = pbVar7 + 2;\n      local_8c = local_8c + 1;\n    }\n    else {\n      bVar6 = false;\n      local_84 = 0;\n      iVar3 = 0;\n      while( true ) {\n        pbVar7 = pbVar7 + 1;\n        if (9 < *pbVar7 - 0x30) break;\n        iVar3 = iVar3 * 10 + (*pbVar7 - 0x30);\n        bVar6 = true;\n      }\n      if (bVar6) {\n        local_84 = iVar3;\n      }\n    }\n  }\n  iVar3 = FUN_00006010(PTR_DAT_00005a54,*pbVar7,3);\n  if (iVar3 != 0) {\n    local_88 = local_88 | 0x40 << (iVar3 - (int)puVar2 & 0xffU);\n    pbVar7 = pbVar7 + 1;\n  }\n  param_3 = pbVar7 + 1;\n  local_70 = *pbVar7;\n  iVar3 = FUN_00006010(PTR_s_efgEFG_00005a48,local_70,6);\n  if (iVar3 == 0) {\n    iVar3 = FUNC_00005b34(param_1,&local_88,param_2,DAT_00005a50,&local_8c);\n  }\n  else {\n    iVar3 = param_1;\n    if (DAT_00005a4c == 0) {\n      local_8c = (int *)(((int)local_8c + 7U & 0xfffffff8) + 8);\n      iVar3 = unaff_r7;\n      goto LAB_000059b4;\n    }\n  }\n  if (iVar3 == -1) goto LAB_00005a06;\nLAB_000059b4:\n  local_74 = local_74 + iVar3;\n  pbVar8 = param_3;\n  unaff_r7 = iVar3;\n  goto LAB_0000588e;\n}\n\n",
            "called": [
                "FUN_00006010",
                "FUN_000057d2",
                "FUN_000045ec",
                "FUN_000054a8",
                "FUN_00005b34",
                "FUN_000045e8",
                "FUN_000042a4"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x000057f8",
            "calling": [
                "FUN_00004c84"
            ],
            "imported": false,
            "current_name": "FUNC_000057f8"
        },
        "FUN_000018bc": {
            "renaming": {
                "FUN_000018bc": "waitForFlag_000018bc",
                "FUN_00001748": "setFlag",
                "DAT_00001910": "statusRegister",
                "FUN_00001710": "delay",
                "PTR_DAT_00001918": "counter"
            },
            "code": "void waitForFlag_000018bc(void)\n{\n  setFlag(0xa0);\n  *DAT_00001910 = *DAT_00001910 & 0x3b | 4;\n  delay(1);\n  while ((DAT_00001910[6] & 0x10) == 0);\n  while ((DAT_00001910[6] & 0xc) != 0);\n  *PTR_DAT_00001918 = 0;\n  return;\n}",
            "called": [
                "FUN_00001710",
                "FUN_00001748"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000018bc",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "waitForFlag_000018bc"
        },
        "FUN_00000f04": {
            "renaming": {
                "FUN_00000f04": "initialize_00000f04",
                "param_1": "device_type",
                "param_2": "device_id",
                "uStack_18": "counter",
                "UNRECOVERED_JUMPTABLE": "jump_table",
                "local_10": "local_var_1",
                "local_9": "local_var_2",
                "piRam00000f4c": "ptr_ram_f4c",
                "uRam00000f50": "ram_f50",
                "uRam00000f54": "ram_f54",
                "uRam00000f58": "ram_f58"
            },
            "code": "void initialize_00000f04(char device_type, undefined4 device_id)\n{\n  undefined4 counter;\n  code *jump_table;\n  undefined4 local_var_1;\n  char local_var_2;\n  \n  local_var_1 = device_id;\n  local_var_2 = device_type;\n  \n  if (*piRam00000f4c == 0) {\n    *piRam00000f4c = 1;\n    if (device_type == '\\x03') {\n      initialize_00000f04_device();\n    }\n    set_device_id(uRam00000f50, local_var_1);\n    initialize_00000f04_component_1();\n    set_component_2();\n    set_component_3();\n  }\n  \n  execute_component_4();\n  do_nothing_1();\n  jump_table = (code *)0xf4d;\n  execute_component_5();\n  counter = (int)&counter + 1;\n  do_nothing_2();\n  set_main_component(PTR_s_main____This_is_RIOT___Version__2_00000f7c);\n  execute_component_6();\n  \n  (*jump_table)(0);\n  return;\n}",
            "called": [
                "FUN_00000e58",
                "FUN_00000ef8",
                "FUN_00000cd0",
                "FUN_0000211c",
                "FUN_000023a4",
                "FUN_00002400",
                "FUN_00004c84",
                "FUN_00000ed8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000f04",
            "calling": [
                "FUN_000013b8",
                "FUN_00000fec",
                "FUN_00003ec4",
                "FUN_00000cc0",
                "FUN_00000a30",
                "FUN_00001034"
            ],
            "imported": false,
            "current_name": "initialize_00000f04"
        },
        "FUN_00000610": {
            "renaming": {
                "FUN_00000610": "initialize_data_00000610",
                "iVar1": "current_index",
                "iVar2": "target_index",
                "uVar3": "result"
            },
            "code": "int initialize_data_00000610()\n{\n    int current_index;\n    int target_index;\n    int result;\n    \n    *(int*)PTR_DATA = 0;\n    target_index = *(int*)PTR_TARGET_INDEX;\n    current_index = get_current_index(*(int*)PTR_CURRENT_INDEX);\n    current_index = **(int **)(PTR_DATA_ARRAY + current_index * 4);\n    if (target_index == current_index - 8) {\n        result = 0;\n    }\n    else {\n        if ((target_index != 0) && (*(char *)(target_index + 4) == '\t')) {\n            *(char *)(target_index + 4) = '\\n';\n        }\n        *(char *)(current_index - 4) = '\\t';\n        *(short *)PTR_NEXT_INDEX = *(short *)(current_index - 2);\n        *(int *)PTR_TARGET_INDEX = current_index - 8;\n        result = 1;\n    }\n    return result;\n}",
            "called": [
                "FUN_00000566"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00000610",
            "calling": [],
            "imported": false,
            "current_name": "initialize_data_00000610"
        },
        "FUN_00003694": {
            "renaming": {
                "FUN_00003694": "display_data_object_00003694",
                "param_1": "data_object",
                "param_2": "data_object_size",
                "uVar1": "data_object_type",
                "cVar2": "is_bit_set",
                "uVar3": "bit_mask",
                "bVar4": "is_bit_set_bool",
                "auStack_18": "stack_buffer",
                "local_10": "buffer_size",
                "local_a": "display_char",
                "local_9": "current_byte_index"
            },
            "code": "void display_data_object_00003694(int data_object, byte data_object_size) {\\n  undefined4 uVar1;\\n  char is_bit_set;\\n  uint bit_mask;\\n  bool is_bit_set_bool;\\n  undefined stack_buffer [8];\\n  int buffer_size;\\n  char display_char;\\n  byte current_byte_index;\\n  if ((data_object == 0) || (3 < data_object_size)) {\\n    display_error_message(PTR_s_Unable_to_display_data_object_00003694_000037e4);\\n  }\\n  else {\\n    display_message(PTR_s_Data__000037e8);\\n    for (current_byte_index = 0; current_byte_index < data_object_size; current_byte_index++) {\\n      if (*(byte *)(data_object + 6) < 0x14) {\\n        bit_mask = DAT_000037ec & 1 << (uint)*(byte *)(data_object + 6);\\n        is_bit_set_bool = bit_mask != 0;\\n        if (is_bit_set_bool) {\\n          bit_mask = 1;\\n        }\\n        is_bit_set = (char)bit_mask;\\n        if (!is_bit_set_bool) {\\n          is_bit_set = \"\\0\";\\n        }\\n        if (is_bit_set == \"\\0\") goto LAB_000036ee;\\n        display_char = \"\\0\";\\n      }\\n      else {\\nLAB_000036ee:\\n        display_char = get_display_char((int)*(char *)(data_object + 7));\\n      }\\n      display_message(PTR_LAB_000037f0);\\n      if (data_object_size < 2) {\\n        display_message(PTR_s__000037f8);\\n      }\\n      else {\\n        display_message(PTR_s___u__000037f4, current_byte_index);\\n      }\\n      if (display_char == \"\\0\") {\\n        if (*(char *)(data_object + 7) == \"\\0\") {\\n          display_message(PTR_LAB_00003800,(int)*(short *)(data_object + (uint)current_byte_index * 2));\\n        }\\n        else if ((*(char *)(data_object + 7) + 4 < 0 == SCARRY4((int)*(char *)(data_object + 7),4)) && (*(char *)(data_object + 7) < \"\\0\")) {\\n          buffer_size = get_display_buffer(stack_buffer,(int)*(short *)(data_object + (uint)current_byte_index * 2),\\n                                  (int)*(char *)(data_object + 7));\\n          stack_buffer[buffer_size] = 0;\\n          display_message(PTR_LAB_00003804,stack_buffer);\\n        }\\n        else {\\n          display_message(PTR_s__iE_i_00003808,(int)*(short *)(data_object + (uint)current_byte_index * 2),\\n                       (int)*(char *)(data_object + 7));\\n        }\\n      }\\n      else {\\n        display_message(PTR_s__6d__c_000037fc,(int)*(short *)(data_object + (uint)current_byte_index * 2),display_char);\\n      }\\n      uVar1 = get_data_object_type(*(undefined *)(data_object + 6));\\n      display_message(PTR_LAB_0000380c,uVar1);\\n    }\\n  }\\n  return;\\n}",
            "called": [
                "FUN_00004db8",
                "FUN_00003810",
                "FUN_00003e9e",
                "FUN_00004c84",
                "FUN_00003918"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003694",
            "calling": [
                "FUN_00002ecc",
                "FUN_0000305c"
            ],
            "imported": false,
            "current_name": "display_data_object_00003694"
        },
        "FUN_00002364": {
            "renaming": {
                "FUN_00002364": "check_and_execute_command_00002364",
                "param_1": "command",
                "param_2": "data",
                "iVar1": "is_valid_command",
                "uVar2": "return_value",
                "FUN_00002294": "check_command",
                "FUN_000022be": "execute_command"
            },
            "code": "int check_and_execute_command_00002364(int command, unsigned char data){\n    int is_valid_command = check_command(command);\n    if (is_valid_command == 0) {\n        execute_command(command, data);\n        return 0;\n    }\n    else {\n        return -1;\n    }\n}",
            "called": [
                "FUN_00002294",
                "FUN_000022be"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002364",
            "calling": [
                "FUN_000012b4"
            ],
            "imported": false,
            "current_name": "check_and_execute_command_00002364"
        },
        "FUN_00001ad4": {
            "renaming": {
                "FUN_00001ad4": "reset_bits_00001ad4",
                "DAT_00001b08": "data_ptr",
                "PTR_DAT_00001b0c": "PTR_reset_bits"
            },
            "code": "void reset_bits_00001ad4(void)\n{\n  unsigned char* DAT_00001b08 = DAT_00001b08;\n  *DAT_00001b08 = (*DAT_00001b08) & 0x3f;\n  while((DAT_00001b08[6] & 0xc) != 0xc);\n  *PTR_DAT_00001b0c = 7;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001ad4",
            "calling": [
                "FUN_00001b10"
            ],
            "imported": false,
            "current_name": "reset_bits_00001ad4"
        },
        "FUN_00001274": {
            "renaming": {
                "FUN_00001274": "initialize_device_00001274",
                "FUN_0000258c": "enable_interrupts",
                "FUN_00001c84": "configure_device",
                "FUN_00002396": "initialize_communication",
                "DAT_00001298": "device_status_register"
            },
            "code": "void initialize_device_00001274(void)\n{\n  enable_interrupts();\n  *DAT_00001298 = *DAT_00001298 | 0x28;\n  configure_device();\n  initialize_communication();\n  return;\n}",
            "called": [
                "FUN_00001c84",
                "FUN_0000258c",
                "FUN_00002396"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001274",
            "calling": [
                "FUN_00000e64"
            ],
            "imported": false,
            "current_name": "initialize_device_00001274"
        },
        "FUN_00002e6c": {
            "renaming": {
                "FUN_00002e6c": "check_and_execute_function_00002e6c",
                "param_1": "data_ptr",
                "param_2": "param_2_ptr",
                "param_3": "param_3_ptr",
                "iVar1": "result",
                "FUN_00002e48": "execute_setup_function",
                "FUN_00002d94": "check_data",
                "FUN_00002b10": "execute_function"
            },
            "code": "void check_and_execute_function_00002e6c(int* data_ptr, int* param_2_ptr, int* param_3_ptr)\n{\n  int result;\n  execute_setup_function();\n  do {\n    result = check_data(param_2_ptr, param_3_ptr);\n    if (result == 0) {\n      execute_function(data_ptr, param_2_ptr);\n    }\n    execute_setup_function();\n  } while( true );\n}",
            "called": [
                "FUN_00002e48",
                "FUN_00002d94",
                "FUN_00002b10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002e6c",
            "calling": [
                "FUN_000023a4"
            ],
            "imported": false,
            "current_name": "check_and_execute_function_00002e6c"
        },
        "FUN_00003444": {
            "renaming": {
                "FUN_00003444": "get_time_success_00003444",
                "iVar1": "result",
                "auStack_2c": "time_buffer",
                "FUN_00002624": "get_time",
                "FUN_00004db8": "log_error",
                "PTR_s_rtc__error_getting_time_00003474": "PTR_s_rtc__error_getting_time_00003474",
                "FUN_00003378": "process_time"
            },
            "code": "bool get_time_success_00003444(void)\n{\n  int result;\n  undefined time_buffer [36];\n  result = get_time(time_buffer);\n  if (result != 0) {\n    log_error(PTR_s_rtc__error_getting_time_00003474);\n  }\n  else {\n    process_time(time_buffer);\n  }\n  return result != 0;\n}",
            "called": [
                "FUN_00002624",
                "FUN_00004db8",
                "FUN_00003378"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003444",
            "calling": [
                "FUN_00003524"
            ],
            "imported": false,
            "current_name": "get_time_success_00003444"
        },
        "FUN_00003688": {
            "renaming": {
                "FUN_00003688": "execute_function_00003688",
                "FUN_00003658": "call_another_function"
            },
            "code": "void execute_function_00003688(void)\n{\n  call_another_function();\n  return;\n}",
            "called": [
                "FUN_00003658"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00003688",
            "calling": [
                "FUN_00002e9c"
            ],
            "imported": false,
            "current_name": "execute_function_00003688"
        },
        "FUN_00001392": {
            "renaming": {
                "FUN_00001392": "set_value_to_one_00001392",
                "param_1": "memory_address",
                "param_2": "size",
                "puVar1": "ptr_to_memory_address",
                "*puVar1": "*(int *)ptr_to_memory_address",
                "FUN_00001360": "get_memory_address"
            },
            "code": "void set_value_to_one_00001392(void *memory_address, int size) {\n  void *ptr_to_memory_address = (void *)get_memory_address(memory_address, size);\n  *(int *)ptr_to_memory_address = 1;\n  return;\n}",
            "called": [
                "FUN_00001360"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001392",
            "calling": [
                "FUN_000013b8"
            ],
            "imported": false,
            "current_name": "set_value_to_one_00001392"
        },
        "FUN_00002910": {
            "renaming": {
                "FUN_00002910": "clear_flags_00002910",
                "DAT_00002944": "data_address",
                "PTR_DAT_00002948": "flags_pointer"
            },
            "code": "void clear_flags_00002910(void)\n{\n  int DAT_00002944 = DAT_00002944;\n  uint* flags_address = (uint*)(DAT_00002944 + 0x1c);\n  *flags_address &= 0xfffffffb;\n  *(undefined4*)(DAT_00002944 + 8) = 0;\n  *(undefined4*)PTR_DAT_00002948 = 0;\n  *(undefined4*)(PTR_DAT_00002948 + 4) = 0;\n  return;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002910",
            "calling": [
                "FUN_000026c0"
            ],
            "imported": false,
            "current_name": "clear_flags_00002910"
        },
        "FUN_00004418": {
            "renaming": {
                "FUN_00004418": "read_byte_00004418",
                "uVar1": "byte_value",
                "ppbVar2": "byte_ptr_ptr",
                "pbVar3": "byte_ptr",
                "iVar4": "data_ptr"
            },
            "code": "uint read_byte_00004418()\n{\n  uint byte_value;\n  byte **byte_ptr_ptr;\n  byte *byte_ptr;\n  int data_ptr;\n  \n  data_ptr = *data_ptr_ptr;\n  if ((data_ptr != 0) && (*(int *)(data_ptr + 0x18) == 0)) {\n    free_data(data_ptr);\n  }\n  byte_ptr_ptr = *(byte ***)(data_ptr + 4);\n  if ((data_ptr != 0) && (*(int *)(data_ptr + 0x18) == 0)) {\n    free_data(data_ptr);\n  }\n  if (byte_ptr_ptr == (byte **)byte_array_ptr_1) {\n    byte_ptr_ptr = *(byte ***)(data_ptr + 4);\n  }\n  else if (byte_ptr_ptr == (byte **)byte_array_ptr_2) {\n    byte_ptr_ptr = *(byte ***)(data_ptr + 8);\n  }\n  else if (byte_ptr_ptr == (byte **)byte_array_ptr_3) {\n    byte_ptr_ptr = *(byte ***)(data_ptr + 0xc);\n  }\n  if ((-1 < (int)byte_ptr_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(byte_ptr_ptr + 3) << 0x16))) {\n    do_nothing_1(byte_ptr_ptr[0x16]);\n  }\n  byte_ptr = byte_ptr_ptr[1];\n  byte_ptr_ptr[1] = byte_ptr - 1;\n  if ((int)(byte_ptr - 1) < 0) {\n    byte_value = read_data(data_ptr, byte_ptr_ptr);\n  }\n  else {\n    byte_ptr = *byte_ptr_ptr;\n    *byte_ptr_ptr = byte_ptr + 1;\n    byte_value = (uint)*byte_ptr;\n  }\n  if ((-1 < (int)byte_ptr_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(byte_ptr_ptr + 3) << 0x16))) {\n    do_nothing_2(byte_ptr_ptr[0x16]);\n  }\n  return byte_value;\n}",
            "called": [
                "FUN_000045ec",
                "FUN_000045e8",
                "FUN_000042a4",
                "FUN_00005e10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004418",
            "calling": [
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "read_byte_00004418"
        },
        "FUN_0000258c": {
            "renaming": {
                "FUN_0000258c": "initialize_data_0000258c",
                "local_c": "count",
                "FUN_00002538": "send_data",
                "DAT_000025ec": "PTR_data",
                "DAT_000025f0": "PTR_data2"
            },
            "code": "void initialize_data_0000258c(void)\n{\n  uint32_t count;\n  *(uint32_t *)(DAT_000025ec + 8) = DAT_000025f0;\n  send_data(0xfffffffe,1);\n  send_data(0xfffffffb,1);\n  for (count = 0; count < 0x66; count = count + 1) {\n    send_data((int)(char)count,1);\n  }\n  *(uint32_t *)(DAT_000025ec + 0x10) = *(uint32_t *)(DAT_000025ec + 0x10) | 0x10;\n  *(uint32_t *)(DAT_000025ec + 0x14) = *(uint32_t *)(DAT_000025ec + 0x14) | 0x200;\n  return;\n}",
            "called": [
                "FUN_00002538"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000258c",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_data_0000258c"
        },
        "FUN_00002a00": {
            "renaming": {
                "FUN_00002a00": "call_function_with_param_00002a00",
                "param_1": "input_param",
                "FUN_00004cb4": "call_another_function"
            },
            "code": "void call_function_with_param_00002a00(void* input_param)\n{\n  call_another_function(input_param);\n  return;\n}",
            "called": [
                "FUN_00004cb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a00",
            "calling": [
                "FUN_00002e48",
                "FUN_00002d94"
            ],
            "imported": false,
            "current_name": "call_function_with_param_00002a00"
        },
        "FUN_000043a0": {
            "renaming": {
                "FUN_000043a0": "find_and_execute_non_negative_shorts_000043a0",
                "param_1": "base_address",
                "param_2": "execute_code",
                "piVar2": "pointer",
                "iVar3": "inner_pointer",
                "uVar1": "execute_result",
                "uVar4": "result",
                "iVar5": "inner_count"
            },
            "code": "uint find_and_execute_non_negative_shorts_000043a0(int base_address, code *execute_code) {\n  uint result = 0;\n  int *pointer = (int *)(base_address + 0x48);\n  do {\n    int inner_pointer = pointer[2];\n    int inner_count = pointer[1];\n    while (inner_count-- > 0) {\n      ushort value = *(ushort *)(inner_pointer + 0xc);\n      short check = *(short *)(inner_pointer + 0xe);\n      if (value > 1 && check != -1) {\n        result |= (*execute_code)(inner_pointer);\n      }\n      inner_pointer += 0x68;\n    }\n    pointer = (int *)*pointer;\n  } while (pointer != (int *)0x0);\n  return result;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000043a0",
            "calling": [
                "FUN_00006768"
            ],
            "imported": false,
            "current_name": "find_and_execute_non_negative_shorts_000043a0"
        },
        "FUN_0000211c": {
            "renaming": {
                "FUN_0000211c": "process_data_0000211c",
                "local_40": "pid",
                "local_3c": "irq_data_ptr",
                "local_38": "stack_ptr",
                "local_34": "irq_func",
                "local_30": "irq_data_size",
                "local_2c": "irq_data",
                "local_28": "irq_priority",
                "local_24": "isr_stack_size",
                "local_20": "stack_size",
                "local_1a": "i",
                "local_18": "total_state",
                "local_14": "total_data_size"
            },
            "code": "void process_data_0000211c()\n{\n  int total_data_size = 0;\n  int total_state = 0;\n  uint8_t stack[512];\n  uint8_t *isr_stack;\n  uint32_t isr_stack_size;\n  uint32_t pid;\n  uint32_t priority;\n  uint32_t state;\n  uint32_t *data_ptr;\n  uint32_t data_size;\n  uint32_t stack_ptr;\n  uint32_t stack_size;\n  uint32_t irq_num;\n  uint32_t irq_priority;\n  uint32_t irq_state;\n  uint32_t irq_data_ptr;\n  uint32_t irq_data_size;\n  uint32_t irq_func;\n  uint32_t i;\n  uint32_t *irq_data;\n  pid = 0x515f;\n  FUN_00004c84(PTR_s__pid_____21s____9sQ___pri___stac_00002250,PTR_DAT_0000224c,PTR_s_state_00002248);\n  stack_size = FUN_000008b8();\n  isr_stack_size = FUN_0000091c();\n  irq_num = FUN_00000900();\n  isr_stack = &stack[total_data_size];\n  FUN_00004c84(PTR_s______isr_stack______________6i___00002254,0x200,stack_size,isr_stack_size,irq_num);\n  total_data_size += 0x200;\n  if (stack_size > 0)\n  {\n    total_state += stack_size;\n  }\n  for (i = 1; i < 0x21; i++)\n  {\n    irq_data = *(uint32_t **)(PTR_DAT_00002258 + i * 4);\n    if (irq_data != NULL)\n    {\n      irq_data_size = (uint32_t)*(uint8_t *)(irq_data + 1);\n      irq_func = *(uint32_t *)(DAT_0000225c + irq_data_size * 4);\n      stack_ptr = (uint32_t)&pid + (uint32_t)(8 < irq_data_size);\n      irq_data_ptr = irq_data[0xb];\n      total_data_size += irq_data_ptr;\n      irq_priority = FUN_000010a0(irq_data[9]);\n      irq_data_ptr -= irq_priority;\n      total_state += irq_data_ptr;\n      FUN_00004c84(PTR_s___3hi_____20s_____8s___1s____3i___00002260,\n                   (int)*(short *)((int)irq_data + 6),irq_data[10],irq_func,stack_ptr,\n                   *(uint8_t *)((int)irq_data + 5),irq_data[0xb],irq_data_ptr,irq_data[9],*irq_data);\n    }\n  }\n  FUN_00004c84(PTR_s___5s___21s__13s_6s__6i___5i__0000226c,PTR_DAT_00002264,PTR_DAT_00002268,\n               PTR_DAT_00002264,PTR_DAT_00002264,total_data_size,total_state);\n  return;\n}",
            "called": [
                "FUN_0000091c",
                "FUN_00000900",
                "FUN_000010a0",
                "FUN_00004c84",
                "FUN_000008b8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000211c",
            "calling": [
                "FUN_00000f04",
                "FUN_00002eb4"
            ],
            "imported": false,
            "current_name": "process_data_0000211c"
        },
        "FUN_0000562c": {
            "renaming": {
                "FUN_0000562c": "find_parameter_value_0000562c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "cVar1": "current_char",
                "ppiVar2": "double_pointer_to_int",
                "piVar3": "pointer_to_int",
                "iVar4": "current_int",
                "pcVar5": "current_char_pointer",
                "piVar6": "pointer_to_int_array",
                "iVar7": "index",
                "DAT_0000569c": "list_of_pointers_to_ints",
                "FUN_00005fec": "initialize",
                "FUN_00005ff8": "finalize",
                "FUN_00004e66": "check_value"
            },
            "code": "int find_parameter_value_0000562c(int param1, char *param2, int *param3) {\n  char current_char;\n  int **double_pointer_to_int;\n  int *pointer_to_int;\n  int index;\n  char *current_char_pointer;\n  int *pointer_to_int_array;\n  int current_int;\n  initialize();\n  double_pointer_to_int = DAT_0000569c;\n  current_char_pointer = param2;\n  if (**DAT_0000569c != NULL) {\n    do {\n      current_char = *current_char_pointer;\n      if (current_char == '\\0') {\n        index = (int)current_char_pointer - (int)param2;\n        pointer_to_int_array = *DAT_0000569c;\n        while (true) {\n          pointer_to_int = pointer_to_int_array;\n          if (*pointer_to_int == 0) break;\n          current_int = check_value(*pointer_to_int, param2, index);\n          pointer_to_int_array = pointer_to_int + 1;\n          if ((current_int == 0) && (current_int = *pointer_to_int, *(char *)(current_int + index) == '=')) {\n            *param3 = (int)pointer_to_int - (int)*double_pointer_to_int >> 2;\n            finalize(param1);\n            return current_int + index + 1;\n          }\n        }\n        break;\n      }\n      current_char_pointer++;\n    } while (current_char != '=');\n  }\n  finalize(param1);\n  return 0;\n}",
            "called": [
                "FUN_00005ff8",
                "FUN_00004e66",
                "FUN_00005fec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000562c",
            "calling": [
                "FUN_000056a0"
            ],
            "imported": false,
            "current_name": "find_parameter_value_0000562c"
        },
        "FUN_000020b8": {
            "renaming": {
                "FUN_000020b8": "initialize_data_000020b8",
                "FUN_00002028": "initialize_pointers",
                "DAT_000020c8": "PTR_data"
            },
            "code": "void initialize_data_000020b8(void)\n{\n  initialize_pointers(DAT_000020c8, 0);\n  return;\n}",
            "called": [
                "FUN_00002028"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000020b8",
            "calling": [],
            "imported": false,
            "current_name": "initialize_data_000020b8"
        },
        "FUN_00002a18": {
            "renaming": {
                "FUN_00002a18": "find_value_from_array_00002a18",
                "param_1": "array",
                "param_2": "value_to_find",
                "local_18": "arrays",
                "local_10": "index",
                "local_c": "current_array",
                "iVar1": "result"
            },
            "code": "int find_value_from_array_00002a18(int *array, int value_to_find) {\n  int index, *current_array;\n  int *arrays[] = {array, PTR_PTR_s_reboot_00002a84};\n  for (index = 0; index < 2; index++) {\n    current_array = arrays[index];\n    if (current_array != NULL) {\n      while (*current_array != 0) {\n        if (FUN_00004e52(*current_array, value_to_find) == 0) {\n          return current_array[2];\n        }\n        current_array += 3;\n      }\n    }\n  }\n  return 0;\n}",
            "called": [
                "FUN_00004e52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00002a18",
            "calling": [
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "find_value_from_array_00002a18"
        },
        "FUN_000054a8": {
            "renaming": {
                "FUN_000054a8": "calculateResult_000054a8",
                "*param_1": "*result",
                "*param_2": "*input",
                "uVar1": "firstValue",
                "uVar2": "secondValue",
                "uVar3": "tempValue",
                "uVar4": "variable2",
                "iVar5": "variable1"
            },
            "code": "uint calculateResult_000054a8(uint *result, uint *input) {\n  ushort firstValue = *(ushort *)(input + 3);\n  ushort secondValue = *(ushort *)(input + 3);\n  uint tempValue = (uint)firstValue;\n  uint returnValue = 0;\n  int variable1 = *DAT_00005574;\n\n  if (variable1 != 0 && *(int *)(variable1 + 0x18) == 0) {\n    FUN_000042a4(variable1);\n  }\n\n  if (input == (uint *)PTR_DAT_00005578) {\n    input = *(uint **)(variable1 + 4);\n  }\n  else if (input == (uint *)PTR_DAT_0000557c) {\n    input = *(uint **)(variable1 + 8);\n  }\n  else if (input == (uint *)PTR_DAT_00005580) {\n    input = *(uint **)(variable1 + 0xc);\n  }\n\n  tempValue = tempValue << 0x1c;\n  if ((int)tempValue >= 0) {\n    tempValue = tempValue << 1;\n    if ((int)tempValue >= 0) {\n      *result = 9;\n      goto LAB_000054d8;\n    }\n    if ((uint *)(input[0xd]) != (uint *)0x0) {\n      if ((uint *)(input[0xd]) != input + 0x11) {\n        FUN_00004b34(result);\n      }\n      input[0xd] = 0;\n    }\n    *(ushort *)(input + 3) = *(ushort *)(input + 3) & 0xffdb;\n    input[1] = 0;\n    *input = input[4];\n  }\n\n  if (input[4] == 0 && (*(ushort *)(input + 3) & 0x280) != 0x200) {\n    FUN_00005700(result, input);\n  }\n\n  tempValue = (uint)secondValue;\n  uint variable2 = tempValue & 1;\n  if ((tempValue & 1) == 0) {\n    tempValue = tempValue << 0x1e;\n    if ((int)tempValue >= 0) {\n      variable2 = input[5];\n    }\n    input[2] = variable2;\n  }\n  else {\n    input[2] = 0;\n    input[6] = -input[5];\n  }\n\n  if (input[4] != 0) {\n    return 0;\n  }\n\n  if ((*(ushort *)(input + 3) & 0x80) == 0) {\n    returnValue = tempValue & 0x80;\n  }\n  else {\n    *(ushort *)(input + 3) = secondValue | 0x40;\n    returnValue = 0xffffffff;\n  }\n\nLAB_000054d8:\n  return returnValue;\n}",
            "called": [
                "FUN_00004b34",
                "FUN_000042a4",
                "FUN_00005700"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000054a8",
            "calling": [
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_00005404"
            ],
            "imported": false,
            "current_name": "calculateResult_000054a8"
        },
        "FUN_000007dc": {
            "renaming": {
                "FUN_000007dc": "allocate_memory_000007dc",
                "param_1": "size",
                "param_2": "param_2",
                "param_3": "param_3",
                "param_4": "param_4",
                "uVar1": "aligned_size",
                "local_14": "i",
                "local_10": "i",
                "local_c": "mem_ptr"
            },
            "code": "int *allocate_memory_000007dc(int size, int param_2, int param_3, int param_4)\n{\n  uint aligned_size;\n  int i;\n  int *mem_ptr;\n  aligned_size = (param_4 + param_3) & 0xfffffffc;\n  mem_ptr = (int *)(aligned_size - 4);\n  *mem_ptr = 0x77777777;\n  if (((uint)mem_ptr & 7) != 0) {\n    mem_ptr = (int *)(aligned_size - 8);\n    *mem_ptr = 0x88888888;\n  }\n  mem_ptr[-1] = 0x1000000;\n  mem_ptr[-2] = size;\n  mem_ptr[-3] = DAT_000008b4;\n  mem_ptr = mem_ptr - 4;\n  *mem_ptr = 0;\n  for (i = 3; i > 0; i--) {\n    mem_ptr--;\n    *mem_ptr = i;\n  }\n  mem_ptr--;\n  *mem_ptr = param_2;\n  for (i = 0xb; i > 3; i--) {\n    mem_ptr--;\n    *mem_ptr = i;\n  }\n  mem_ptr[-1] = -3;\n  return mem_ptr - 1;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000007dc",
            "calling": [
                "FUN_000010d4"
            ],
            "imported": false,
            "current_name": "allocate_memory_000007dc"
        },
        "FUN_00001710": {
            "renaming": {
                "FUN_00001710": "set_null_terminator_at_ptr_to_char_00001710",
                "param_1": "ptr_to_char",
                "param_2": "length",
                "puVar1": "ptr_to_null_terminator",
                "FUN_00001696": "get_ptr_to_null_terminator"
            },
            "code": "void set_null_terminator_at_ptr_to_char_00001710(void* ptr_to_char, unsigned char length)\n{\n  undefined* ptr_to_null_terminator = (undefined*) get_ptr_to_null_terminator(ptr_to_char, length);\n  *ptr_to_null_terminator = 0;\n  return;\n}",
            "called": [
                "FUN_00001696"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001710",
            "calling": [
                "FUN_0000182c",
                "FUN_000019c0",
                "FUN_00001a60",
                "FUN_00001734",
                "FUN_00001bb8",
                "FUN_000018bc",
                "FUN_00001778",
                "FUN_00001960"
            ],
            "imported": false,
            "current_name": "set_null_terminator_at_ptr_to_char_00001710"
        },
        "FUN_000045ec": {
            "renaming": {
                "FUN_000045ec": "do_nothing_000045ec"
            },
            "code": "\nvoid do_nothing_000045ec(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000045ec",
            "calling": [
                "FUN_00004280",
                "FUN_00005ff8",
                "FUN_00004158",
                "FUN_00004418",
                "FUN_00004db8",
                "FUN_000057f8",
                "FUN_0000579c",
                "FUN_000042a4",
                "FUN_00004cb4"
            ],
            "imported": false,
            "current_name": "do_nothing_000045ec"
        },
        "FUN_00001034": {
            "renaming": {
                "FUN_00001034": "findInsertionPoint_00001034",
                "param_1": "list",
                "param_2": "insertionData",
                "local_1c": "currentNode",
                "PTR_s_FAILED_ASSERTION__0000109c": "FAILED_ASSERTION"
            },
            "code": "void findInsertionPoint_00001034(int **list, int insertionData) {\n\tint **currentNode;\n\tif (insertionData > 8) {\n\t\tassertionFailed(3, PTR_s_FAILED_ASSERTION__0000109c);\n\t}\n\tfor (currentNode = list; (*currentNode != (int *)0x0 && (getDataSize((int)*currentNode) <= insertionData)); currentNode = (int **)*currentNode) {\n\t}\n\t*(int **)(insertionData + 8) = *currentNode;\n\t*currentNode = (int *)(int **)(insertionData + 8);\n\treturn;\n}",
            "called": [
                "FUN_00000f04"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001034",
            "calling": [
                "FUN_00002434"
            ],
            "imported": false,
            "current_name": "findInsertionPoint_00001034"
        },
        "FUN_00006964": {
            "renaming": {
                "FUN_00006964": "calculate_new_position_00006964",
                "param_1": "current_position",
                "param_2": "positions",
                "iVar1": "new_position"
            },
            "code": "int calculate_new_position_00006964(int current_position, int* positions) {\n    int new_position = positions[current_position - 1] - 4;\n    if (current_position < 0) {\n        new_position += positions[new_position];\n    }\n    return new_position;\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00006964",
            "calling": [
                "FUN_000060cc"
            ],
            "imported": false,
            "current_name": "calculate_new_position_00006964"
        },
        "FUN_0000182c": {
            "renaming": {
                "FUN_0000182c": "clear_bits_0000182c",
                "DAT_000018b4": "PTR_data",
                "DAT_000018b8": "PTR_data2"
            },
            "code": "void clear_bits_0000182c(byte* data, int bit_index, byte value) {\n    data[bit_index / 8] = (data[bit_index / 8] & ~(1 << (bit_index % 8))) | ((value & 1) << (bit_index % 8));\n}\n\nvoid clear_bits_0000182c_0x08() {\n    clear_bits_0000182c((byte*)(DAT_000018b4 + 8), 4, 0);\n}\n\nvoid clear_bits_0000182c() {\n    FUN_000016ec(DAT_000018b8, 0);\n    FUN_00001710(DAT_000018b4, 1);\n    FUN_00001710(DAT_000018b4, 0);\n}",
            "called": [
                "FUN_00001710",
                "FUN_000016ec"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0000182c",
            "calling": [
                "FUN_00001c84"
            ],
            "imported": false,
            "current_name": "clear_bits_0000182c"
        },
        "FUN_00004db8": {
            "renaming": {
                "FUN_00004db8": "process_input_00004db8",
                "param_1": "input",
                "cVar1": "current_char",
                "iVar2": "result",
                "iVar3": "data_section_ptr",
                "pcVar4": "buffer_ptr",
                "ppcVar5": "string_ptr_ptr",
                "uVar6": "result",
                "pcVar7": "buffer"
            },
            "code": "int process_input_00004db8(int input)\n{\n  char current_char;\n  int data_ptr;\n  int data_section_ptr;\n  char *buffer_ptr;\n  char **string_ptr_ptr;\n  int result;\n  char *buffer;\n  \n  data_section_ptr = *data_section_ptr_ptr;\n  if ((data_section_ptr != 0) && (*(int *)(data_section_ptr + 0x18) == 0)) {\n    reset_data_section_ptr();\n  }\n  string_ptr_ptr = *(char ***)(data_section_ptr + 8);\n  if (*(int *)(data_section_ptr + 0x18) == 0) {\n    reset_data_section_ptr(data_section_ptr);\n  }\n  if (string_ptr_ptr == (char **)string_ptr_1) {\n    string_ptr_ptr = *(char ***)(data_section_ptr + 4);\n  }\n  else if (string_ptr_ptr == (char **)string_ptr_2) {\n    string_ptr_ptr = *(char ***)(data_section_ptr + 8);\n  }\n  else if (string_ptr_ptr == (char **)string_ptr_3) {\n    string_ptr_ptr = *(char ***)(data_section_ptr + 0xc);\n  }\n  if ((-1 < (int)string_ptr_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(string_ptr_ptr + 3) << 0x16))) {\n    do_nothing_1(string_ptr_ptr[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(string_ptr_ptr + 3) << 0x1c) < 0) && (string_ptr_ptr[4] != (char *)0x0)) || (result = process_data(data_section_ptr,string_ptr_ptr), result == 0)) {\n    buffer = (char *)(input + -1);\n    do {\n      while( true ) {\n        buffer = buffer + 1;\n        current_char = *buffer;\n        buffer_ptr = string_ptr_ptr[2] + -1;\n        string_ptr_ptr[2] = buffer_ptr;\n        if (current_char == '\\0') {\n          if (-1 < (int)buffer_ptr) {\n            buffer = *string_ptr_ptr;\n            result = 10;\n            *string_ptr_ptr = buffer + 1;\n            *buffer = '\\n';\n            goto LAB_00004d64;\n          }\n          data_section_ptr = write_data_section(data_section_ptr,10,string_ptr_ptr);\n          if (data_section_ptr != -1) {\n            result = 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)buffer_ptr < 0) && (((int)buffer_ptr < (int)string_ptr_ptr[6] || (current_char == '\\n')))) break;\n        buffer_ptr = *string_ptr_ptr;\n        *string_ptr_ptr = buffer_ptr + 1;\n        *buffer_ptr = current_char;\n      }\n      result = write_data_section(data_section_ptr,current_char,string_ptr_ptr);\n    } while (result != -1);\n  }\nLAB_00004d60:\n  result = -1;\nLAB_00004d64:\n  if ((-1 < (int)string_ptr_ptr[0x19] << 0x1f) && (-1 < (int)((uint)*(ushort *)(string_ptr_ptr + 3) << 0x16))) {\n    do_nothing_2(string_ptr_ptr[0x16]);\n  }\n  return result;\n}\n",
            "called": [
                "FUN_000045ec",
                "FUN_000054a8",
                "FUN_00005404",
                "FUN_000045e8",
                "FUN_000042a4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00004db8",
            "calling": [
                "FUN_000034c0",
                "FUN_0000305c",
                "FUN_000023a4",
                "FUN_00003444",
                "FUN_00003694",
                "FUN_000031e0",
                "FUN_00003478",
                "FUN_00002fe0",
                "FUN_000033c0",
                "FUN_00002a88",
                "FUN_00002f30",
                "FUN_00002f74",
                "FUN_000033f4",
                "FUN_00002b10"
            ],
            "imported": false,
            "current_name": "process_input_00004db8"
        },
        "FUN_000022f0": {
            "renaming": {
                "increment_index_value": "increment_index_value",
                "*param_1": "*array",
                "uVar1": "index",
                "param_1[2]": "array[2]",
                "param_1[1]": "array[1]",
                "*(undefined *)((uVar1 & param_1[1] - 1U) + *param_1)": "*(undefined *)((offset) + *array)",
                "offset": "offset",
                "FUN_000022f0": "increment_index_value_000022f0"
            },
            "code": "undefined increment_index_value_000022f0(int *array) {\n    uint index = array[2];\n    array[2] = index + 1;\n    uint offset = index & (array[1] - 1U);\n    return *(undefined *)((offset) + *array);\n}",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000022f0",
            "calling": [
                "FUN_0000231c"
            ],
            "imported": false,
            "current_name": "increment_index_value_000022f0"
        },
        "FUN_00001c84": {
            "renaming": {
                "FUN_00001c84": "initialize_system_00001c84",
                "FUN_00000cd0": "get_random_value",
                "FUN_00001bb8": "set_initial_values",
                "FUN_0000182c": "enable_subsystem",
                "FUN_000017dc": "configure_hardware",
                "FUN_00001b10": "configure_network",
                "FUN_00000d0c": "finalize_system",
                "DAT_00001ce8": "system_data"
            },
            "code": "void initialize_system_00001c84(void)\n{\n  undefined4 random_value = get_random_value();\n  set_initial_values();\n  *(undefined4 *)(DAT_00001ce8 + 0x1044) = 0x220000;\n  DAT_00001ce8[0xc] = 0;\n  *DAT_00001ce8 = *DAT_00001ce8 & 199 | 0x38;\n  DAT_00001ce8[4] = 0x13;\n  DAT_00001ce8[5] = 0;\n  enable_subsystem();\n  configure_hardware();\n  configure_network(7);\n  finalize_system(random_value);\n}\n",
            "called": [
                "FUN_00000d0c",
                "FUN_0000182c",
                "FUN_00001b10",
                "FUN_00000cd0",
                "FUN_000017dc",
                "FUN_00001bb8"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00001c84",
            "calling": [
                "FUN_00001274"
            ],
            "imported": false,
            "current_name": "initialize_system_00001c84"
        },
        "FUN_000068f0": {
            "renaming": {
                "FUN_000068f0": "allocate_memory_000068f0",
                "param_1": "requested_size",
                "param_2": "memory_array",
                "iVar1": "new_element",
                "iVar2": "current_size",
                "FUN_00004bd0": "allocate",
                "FUN_000060cc": "allocate",
                "FUN_000060b0": "copy_memory",
                "PTR_00000014": "last_element",
                "DAT_00000034": "new_size"
            },
            "code": "int allocate_memory_000068f0(int requested_size, int *memory_array)\n{\n  int current_size = memory_array[13];\n  int *PTR_00000014 = memory_array + 17;\n  \n  if ((int *)PTR_00000014 == memory_array + current_size)\n  {\n    int new_element = allocate(requested_size);\n    if (new_element != 0) {\n      memory_array[14] = requested_size;\n      memory_array[13] = new_element;\n      *(char *)(new_element + 1023) = *(char *)(memory_array + 70);\n      *(char *)(new_element + 1022) = *(char *)(memory_array + 69);\n      *(int *)(new_element + 1021) = *(int *)(memory_array + 17);\n      *memory_array = new_element + 1021;\n      return 0;\n    }\n  }\n  else {\n    int DAT_00000034 = current_size * 2;\n    int new_array = allocate(DAT_00000034);\n    if (new_array != 0) {\n      copy_memory(new_array + current_size, new_array, current_size);\n      memory_array[13] = new_array;\n      memory_array[14] = DAT_00000034;\n      *memory_array = new_array + current_size;\n      return 0;\n    }\n  }\n  return -1;\n}",
            "called": [
                "FUN_00004bd0",
                "FUN_000060b0",
                "FUN_000060cc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x000068f0",
            "calling": [],
            "imported": false,
            "current_name": "allocate_memory_000068f0"
        }
    },
    "used_tokens": 186286,
    "layers": [
        [
            "FUN_000026c0",
            "FUN_00004bd0",
            "FUN_00000794",
            "FUN_000064bc",
            "FUN_00002970",
            "FUN_00000dc0",
            "FUN_00000d0c",
            "FUN_00003d94",
            "FUN_0000579c",
            "FUN_000015d0",
            "FUN_00005e68",
            "FUN_00000dcc",
            "FUN_0000285c",
            "FUN_00000e58",
            "FUN_00001778",
            "FUN_000026d8",
            "FUN_00000566",
            "FUN_00001d08",
            "FUN_000031fc",
            "FUN_000016ec",
            "FUN_00005584",
            "FUN_00004248",
            "FUN_00001da2",
            "FUN_00001ec4",
            "FUN_00002744",
            "FUN_00002624",
            "FUN_00001e0c",
            "FUN_000041d0",
            "FUN_0000459c",
            "FUN_000014c4",
            "FUN_00004b34",
            "FUN_000004f2",
            "FUN_00004e66",
            "FUN_00005ecc",
            "FUN_0000129c",
            "FUN_00001628",
            "FUN_00001748",
            "FUN_0000294c",
            "FUN_00005790",
            "FUN_00000534",
            "FUN_000017dc",
            "FUN_00000410",
            "FUN_000005ca",
            "FUN_00005ff8",
            "FUN_00002714",
            "FUN_000020e0",
            "FUN_00005fec",
            "FUN_00004f84",
            "FUN_000028f0",
            "FUN_00004f98",
            "FUN_00004dee",
            "FUN_00000fec",
            "FUN_00000428",
            "FUN_000039e8",
            "FUN_00000e38",
            "FUN_00002294",
            "FUN_00003e9e",
            "FUN_00003378",
            "FUN_00006768",
            "FUN_00000db0",
            "FUN_00002600",
            "FUN_00003810",
            "FUN_00000ed8",
            "FUN_000031e0",
            "FUN_000020f4",
            "FUN_0000687c",
            "FUN_00005edc",
            "FUN_00001eea",
            "FUN_000023a4",
            "FUN_0000240c",
            "FUN_00004280",
            "FUN_00001448",
            "FUN_00001688",
            "FUN_00004042",
            "FUN_00000cf0",
            "FUN_00000f8c",
            "FUN_00002894",
            "FUN_00004158",
            "FUN_00002654",
            "FUN_00002538",
            "FUN_00004c84",
            "FUN_0000305c",
            "FUN_000012b4",
            "FUN_0000058e",
            "FUN_000025f4",
            "FUN_00001ddc",
            "FUN_00002ecc",
            "FUN_00000d76",
            "FUN_000057a8",
            "FUN_00001696",
            "FUN_000008b8",
            "FUN_000024bc",
            "FUN_00000490",
            "FUN_0000091c",
            "FUN_00001f80",
            "FUN_00000e64",
            "FUN_000026e4",
            "FUN_00000d44",
            "FUN_00000698",
            "FUN_00000cd0",
            "FUN_00000cc0",
            "FUN_00002994",
            "FUN_00000d2a",
            "FUN_00001ff6",
            "FUN_000013b8",
            "FUN_00002a88",
            "FUN_00002f30",
            "FUN_00001e44",
            "FUN_00001318",
            "FUN_00000900",
            "FUN_00004274",
            "FUN_00002fe0",
            "FUN_00001dc0",
            "FUN_00000df4",
            "FUN_00002eb4",
            "FUN_0000328c",
            "FUN_000041f4",
            "FUN_0000316c",
            "FUN_000026f0",
            "FUN_000057d2",
            "FUN_000056b8",
            "FUN_00001a18",
            "FUN_00000d9c",
            "FUN_00003ff4",
            "FUN_00001d5e",
            "FUN_0000191c",
            "FUN_000050f4",
            "FUN_00005a58",
            "FUN_000056b0",
            "FUN_00003d24",
            "FUN_000060cc",
            "FUN_00003dc4",
            "FUN_000022be",
            "FUN_00002108",
            "FUN_00001d80",
            "FUN_000033c0",
            "FUN_00002b10",
            "FUN_00001b10",
            "FUN_000023c8",
            "FUN_00002e48",
            "FUN_00000930",
            "FUN_00001348",
            "FUN_00001d3a",
            "FUN_00002434",
            "FUN_00005700",
            "FUN_00002798",
            "FUN_00003524",
            "FUN_00001bb8",
            "FUN_0000428c",
            "FUN_0000404c",
            "FUN_00002f74",
            "FUN_000010a0",
            "FUN_000012e2",
            "FUN_000056a0",
            "FUN_0000231c",
            "FUN_00002690",
            "FUN_00006010",
            "FUN_00001cf0",
            "FUN_00003ec4",
            "FUN_00001360",
            "FUN_00004622",
            "FUN_0000093c",
            "FUN_00003658",
            "FUN_000019c0",
            "FUN_000060b0",
            "FUN_000023d0",
            "FUN_00000a30",
            "FUN_000034c0",
            "FUN_000050e8",
            "FUN_000042a4",
            "FUN_00000514",
            "FUN_00002e9c",
            "FUN_00001960",
            "FUN_00001a3c",
            "FUN_000045ee",
            "FUN_00005404",
            "FUN_00006974",
            "FUN_00004314",
            "FUN_00004dc8",
            "FUN_00005fd8",
            "FUN_00005e10",
            "FUN_000033f4",
            "FUN_0000443c",
            "FUN_000027b0",
            "FUN_00005ebc",
            "FUN_00006192",
            "FUN_00001734",
            "FUN_00000e14",
            "FUN_0000281c",
            "FUN_00002270",
            "FUN_00005780",
            "FUN_000020cc",
            "FUN_00002396",
            "FUN_00004cb4",
            "FUN_00003478",
            "FUN_00002028",
            "FUN_000016c8",
            "FUN_00001a60",
            "FUN_0000099c",
            "FUN_00002d94",
            "FUN_00003918",
            "FUN_00003d64",
            "FUN_00004e52",
            "FUN_000010d4",
            "FUN_00000738",
            "FUN_00003e58",
            "FUN_00004e26",
            "FUN_000018bc",
            "FUN_00000f04",
            "FUN_00000610",
            "FUN_00003694",
            "FUN_00002364",
            "FUN_00001ad4",
            "FUN_00001274",
            "FUN_00002e6c",
            "FUN_00003444",
            "FUN_00003688",
            "FUN_00001392",
            "FUN_00002910",
            "FUN_00004418",
            "FUN_0000258c",
            "FUN_00002a00",
            "FUN_000043a0",
            "FUN_0000211c",
            "FUN_0000562c",
            "FUN_000020b8",
            "FUN_00002a18",
            "FUN_000054a8",
            "FUN_000007dc",
            "FUN_00001710",
            "FUN_00001034",
            "FUN_00006964",
            "FUN_0000182c",
            "FUN_00004db8",
            "FUN_000022f0",
            "FUN_00001c84",
            "FUN_000068f0"
        ],
        [
            "FUN_000022f0"
        ]
    ],
    "locked_functions": []
}