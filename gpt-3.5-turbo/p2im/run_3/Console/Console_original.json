{
  "functions": {
    "_init": {
      "entrypoint": "0x00000410",
      "current_name": "_init",
      "code": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  uart_stdio_init();\n  return (int)ctx;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [
        "uart_stdio_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fini": {
      "entrypoint": "0x0000041c",
      "current_name": "_fini",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk_r": {
      "entrypoint": "0x00000428",
      "current_name": "_sbrk_r",
      "code": "\nvoid * _sbrk_r(_reent *r,ptrdiff_t incr)\n\n{\n  uint state_00;\n  ptrdiff_t incr_local;\n  _reent *r_local;\n  uint state;\n  void *res;\n  \n  state_00 \u003d irq_disable();\n  res \u003d heap_top;\n  if ((\u0026_eram \u003c heap_top + incr) || (heap_top + incr \u003c \u0026_sheap)) {\n    r-\u003e_errno \u003d 0xc;\n    res \u003d (void *)0xffffffff;\n  }\n  else {\n    heap_top \u003d heap_top + incr;\n  }\n  irq_restore(state_00);\n  return res;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r"
      ],
      "called": [
        "irq_disable",
        "irq_restore"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read_r": {
      "entrypoint": "0x00000490",
      "current_name": "_read_r",
      "code": "\n_ssize_t _read_r(_reent *r,int fd,void *buffer,size_t count)\n\n{\n  int iVar1;\n  size_t count_local;\n  void *buffer_local;\n  int fd_local;\n  _reent *r_local;\n  \n  iVar1 \u003d uart_stdio_read((char *)buffer,count);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sread"
      ],
      "called": [
        "uart_stdio_read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write_r": {
      "entrypoint": "0x000004b2",
      "current_name": "_write_r",
      "code": "\n_ssize_t _write_r(_reent *r,int fd,void *data,size_t count)\n\n{\n  int iVar1;\n  size_t count_local;\n  void *data_local;\n  int fd_local;\n  _reent *r_local;\n  \n  iVar1 \u003d uart_stdio_write((char *)data,count);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swrite"
      ],
      "called": [
        "uart_stdio_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close_r": {
      "entrypoint": "0x000004d4",
      "current_name": "_close_r",
      "code": "\nint _close_r(_reent *r,int fd)\n\n{\n  int fd_local;\n  _reent *r_local;\n  \n  r-\u003e_errno \u003d 0x13;\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sclose"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek_r": {
      "entrypoint": "0x000004f2",
      "current_name": "_lseek_r",
      "code": "\n_off_t _lseek_r(_reent *r,int fd,_off_t pos,int dir)\n\n{\n  int dir_local;\n  _off_t pos_local;\n  int fd_local;\n  _reent *r_local;\n  \n  r-\u003e_errno \u003d 0x13;\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sseek",
        "__swrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat_r": {
      "entrypoint": "0x00000514",
      "current_name": "_fstat_r",
      "code": "\nint _fstat_r(_reent *r,int fd,stat *st)\n\n{\n  stat *st_local;\n  int fd_local;\n  _reent *r_local;\n  \n  r-\u003e_errno \u003d 0x13;\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swhatbuf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty_r": {
      "entrypoint": "0x00000534",
      "current_name": "_isatty_r",
      "code": "\nint _isatty_r(_reent *r,int fd)\n\n{\n  int iVar1;\n  int fd_local;\n  _reent *r_local;\n  \n  r-\u003e_errno \u003d 0;\n  if (((fd \u003d\u003d 0) || (fd \u003d\u003d 1)) || (fd \u003d\u003d 2)) {\n    iVar1 \u003d 1;\n  }\n  else {\n    iVar1 \u003d 0;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bitarithm_lsb": {
      "entrypoint": "0x00000566",
      "current_name": "bitarithm_lsb",
      "code": "\nuint bitarithm_lsb(uint v)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  uint uVar5;\n  uint v_local;\n  \n  bVar2 \u003d (byte)v;\n  bVar3 \u003d (byte)(v \u003e\u003e 8);\n  bVar4 \u003d (byte)(v \u003e\u003e 0x10);\n  bVar1 \u003d (byte)(v \u003e\u003e 0x18);\n  uVar5 \u003d LZCOUNT((uint)(byte)((((((((bVar2 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 1 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 2 \u0026 1) \u003c\u003c 1\n                                  | bVar2 \u003e\u003e 3 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 4 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 5 \u0026 1) \u003c\u003c\n                                1 | bVar2 \u003e\u003e 6 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 7) \u003c\u003c 0x18 |\n                  (uint)(byte)((((((((bVar3 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 1 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 2 \u0026 1) \u003c\u003c 1\n                                  | bVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 4 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 5 \u0026 1) \u003c\u003c\n                                1 | bVar3 \u003e\u003e 6 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 7) \u003c\u003c 0x10 |\n                  (uint)(byte)((((((((bVar4 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 1 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 2 \u0026 1) \u003c\u003c 1\n                                  | bVar4 \u003e\u003e 3 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 4 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 5 \u0026 1) \u003c\u003c\n                                1 | bVar4 \u003e\u003e 6 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 7) \u003c\u003c 8 |\n                  (uint)(byte)((((((((bVar1 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 1 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 2 \u0026 1) \u003c\u003c 1\n                                  | bVar1 \u003e\u003e 3 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 4 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 5 \u0026 1) \u003c\u003c\n                                1 | bVar1 \u003e\u003e 6 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 7));\n  if (v \u003d\u003d 0) {\n    uVar5 \u003d 0xffffffff;\n  }\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "sched_run"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "clist_rpush": {
      "entrypoint": "0x0000058e",
      "current_name": "clist_rpush",
      "code": "\nvoid clist_rpush(clist_node_t *list,clist_node_t *new_node)\n\n{\n  clist_node_t *new_node_local;\n  clist_node_t *list_local;\n  \n  if (list-\u003enext \u003d\u003d (list_node *)0x0) {\n    new_node-\u003enext \u003d new_node;\n  }\n  else {\n    new_node-\u003enext \u003d list-\u003enext-\u003enext;\n    list-\u003enext-\u003enext \u003d new_node;\n  }\n  list-\u003enext \u003d new_node;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sched_set_status"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "clist_lpop": {
      "entrypoint": "0x000005ca",
      "current_name": "clist_lpop",
      "code": "\nclist_node_t * clist_lpop(clist_node_t *list)\n\n{\n  list_node *plVar1;\n  clist_node_t *list_local;\n  clist_node_t *first;\n  \n  if (list-\u003enext \u003d\u003d (list_node *)0x0) {\n    plVar1 \u003d (list_node *)0x0;\n  }\n  else {\n    plVar1 \u003d list-\u003enext-\u003enext;\n    if (plVar1 \u003d\u003d list-\u003enext) {\n      list-\u003enext \u003d (list_node *)0x0;\n    }\n    else {\n      list-\u003enext-\u003enext \u003d plVar1-\u003enext;\n    }\n  }\n  return plVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "sched_set_status"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sched_run": {
      "entrypoint": "0x00000610",
      "current_name": "sched_run",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint sched_run(void)\n\n{\n  thread_t *ptVar1;\n  uint uVar2;\n  list_node *plVar3;\n  int iVar4;\n  thread_t *active_thread;\n  int nextrq;\n  clist_node_t *__m____;\n  thread_t *next_thread;\n  \n  ptVar1 \u003d sched_active_thread;\n  sched_context_switch_request \u003d 0;\n  uVar2 \u003d bitarithm_lsb(runqueue_bitcache);\n  plVar3 \u003d (sched_runqueues[uVar2].next)-\u003enext;\n  if (ptVar1 \u003d\u003d (thread_t *)(plVar3 + -2)) {\n    iVar4 \u003d 0;\n  }\n  else {\n    if ((ptVar1 !\u003d (thread_t *)0x0) \u0026\u0026 (ptVar1-\u003estatus \u003d\u003d \u0027\\t\u0027)) {\n      ptVar1-\u003estatus \u003d \u0027\\n\u0027;\n    }\n    *(undefined *)\u0026plVar3[-1].next \u003d 9;\n    sched_active_pid \u003d *(kernel_pid_t *)((int)\u0026plVar3[-1].next + 2);\n    iVar4 \u003d 1;\n    sched_active_thread \u003d (thread_t *)(plVar3 + -2);\n  }\n  return iVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "isr_svc"
      ],
      "called": [
        "bitarithm_lsb"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sched_set_status": {
      "entrypoint": "0x00000698",
      "current_name": "sched_set_status",
      "code": "\nvoid sched_set_status(thread_t *process,uint status)\n\n{\n  uint status_local;\n  thread_t *process_local;\n  \n  if (status \u003c 9) {\n    if ((8 \u003c process-\u003estatus) \u0026\u0026\n       (clist_lpop(sched_runqueues + process-\u003epriority),\n       sched_runqueues[process-\u003epriority].next \u003d\u003d (list_node *)0x0)) {\n      runqueue_bitcache \u003d runqueue_bitcache \u0026 ~(1 \u003c\u003c process-\u003epriority);\n    }\n  }\n  else if (process-\u003estatus \u003c 9) {\n    clist_rpush(sched_runqueues + process-\u003epriority,\u0026process-\u003erq_entry);\n    runqueue_bitcache \u003d runqueue_bitcache | 1 \u003c\u003c process-\u003epriority;\n  }\n  process-\u003estatus \u003d (uint8_t)status;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mutex_unlock",
        "thread_create",
        "_mutex_lock",
        "sched_task_exit"
      ],
      "called": [
        "clist_rpush",
        "clist_lpop"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sched_switch": {
      "entrypoint": "0x00000738",
      "current_name": "sched_switch",
      "code": "\nvoid sched_switch(uint16_t other_prio)\n\n{\n  int iVar1;\n  uint16_t other_prio_local;\n  uint16_t current_prio;\n  thread_t *active_thread;\n  int on_runqueue;\n  \n  if ((sched_active_thread-\u003estatus \u003c 9) || (other_prio \u003c sched_active_thread-\u003epriority)) {\n    iVar1 \u003d irq_is_in();\n    if (iVar1 \u003d\u003d 0) {\n      thread_yield_higher();\n    }\n    else {\n      sched_context_switch_request \u003d 1;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mutex_unlock",
        "thread_create"
      ],
      "called": [
        "thread_yield_higher",
        "irq_is_in"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sched_task_exit": {
      "entrypoint": "0x00000794",
      "current_name": "sched_task_exit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sched_task_exit(void)\n\n{\n  irq_disable();\n  sched_threads[sched_active_pid] \u003d (thread_t *)0x0;\n  sched_num_threads \u003d sched_num_threads + -1;\n  sched_set_status(sched_active_thread,0);\n  sched_active_thread \u003d (thread_t *)0x0;\n                    \n  cpu_switch_context_exit();\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "cpu_switch_context_exit",
        "irq_disable",
        "sched_set_status"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "thread_stack_init": {
      "entrypoint": "0x000007dc",
      "current_name": "thread_stack_init",
      "code": "\nchar * thread_stack_init(thread_task_func_t task_func,void *arg,void *stack_start,int stack_size)\n\n{\n  uint uVar1;\n  int stack_size_local;\n  void *stack_start_local;\n  void *arg_local;\n  thread_task_func_t task_func_local;\n  int i_1;\n  int i;\n  uint32_t *stk;\n  \n  uVar1 \u003d stack_size + (int)stack_start \u0026 0xfffffffc;\n  stk \u003d (uint32_t *)(uVar1 - 4);\n  *stk \u003d 0x77777777;\n  if (((uint)stk \u0026 7) !\u003d 0) {\n    stk \u003d (uint32_t *)(uVar1 - 8);\n    *stk \u003d 0x88888888;\n  }\n  stk[-1] \u003d 0x1000000;\n  stk[-2] \u003d (uint32_t)task_func;\n  stk[-3] \u003d 0x795;\n  stk \u003d stk + -4;\n  *stk \u003d 0;\n  for (i \u003d 3; 0 \u003c i; i \u003d i + -1) {\n    stk \u003d stk + -1;\n    *stk \u003d i;\n  }\n  stk \u003d stk + -1;\n  *stk \u003d (uint32_t)arg;\n  for (i_1 \u003d 0xb; 3 \u003c i_1; i_1 \u003d i_1 + -1) {\n    stk \u003d stk + -1;\n    *stk \u003d i_1;\n  }\n  stk[-1] \u003d 0xfffffffd;\n  return (char *)(stk + -1);\n}\n\n",
      "renaming": {},
      "calling": [
        "thread_create"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "thread_isr_stack_usage": {
      "entrypoint": "0x000008b8",
      "current_name": "thread_isr_stack_usage",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint thread_isr_stack_usage(void)\n\n{\n  ptrdiff_t num_used_words;\n  uint32_t *ptr;\n  \n  for (ptr \u003d (uint32_t *)isr_stack; (*ptr \u003d\u003d 0xe7fee7fe \u0026\u0026 (ptr \u003c \u0026heap_top)); ptr \u003d ptr + 1) {\n  }\n  return ((int)\u0026heap_top - (int)ptr \u003e\u003e 2) \u003c\u003c 2;\n}\n\n",
      "renaming": {},
      "calling": [
        "ps"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "thread_isr_stack_pointer": {
      "entrypoint": "0x00000900",
      "current_name": "thread_isr_stack_pointer",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * thread_isr_stack_pointer(void)\n\n{\n  void *pvVar1;\n  uint32_t result;\n  void *msp;\n  \n  pvVar1 \u003d (void *)getMainStackPointer();\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "ps"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "thread_isr_stack_start": {
      "entrypoint": "0x0000091c",
      "current_name": "thread_isr_stack_start",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * thread_isr_stack_start(void)\n\n{\n  return isr_stack;\n}\n\n",
      "renaming": {},
      "calling": [
        "ps"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cpu_switch_context_exit": {
      "entrypoint": "0x00000930",
      "current_name": "cpu_switch_context_exit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cpu_switch_context_exit(void)\n\n{\n  irq_enable();\n  software_interrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "kernel_init",
        "sched_task_exit"
      ],
      "called": [
        "irq_enable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "thread_yield_higher": {
      "entrypoint": "0x0000093c",
      "current_name": "thread_yield_higher",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid thread_yield_higher(void)\n\n{\n  _DAT_e000ed04 \u003d _DAT_e000ed04 | 0x10000000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "cortexm_isr_end",
        "sched_switch",
        "cortexm_isr_end",
        "_mutex_lock",
        "cortexm_isr_end"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_pendsv": {
      "entrypoint": "0x00000958",
      "current_name": "isr_pendsv",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid isr_pendsv(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  undefined4 unaff_r4;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  undefined4 unaff_r8;\n  undefined4 unaff_r9;\n  undefined4 unaff_r10;\n  undefined4 unaff_r11;\n  undefined4 in_lr;\n  code **ppcVar3;\n  \n  iVar2 \u003d getProcessStackPointer();\n  *(undefined4 *)(iVar2 + -4) \u003d unaff_r11;\n  *(undefined4 *)(iVar2 + -8) \u003d unaff_r10;\n  *(undefined4 *)(iVar2 + -0xc) \u003d unaff_r9;\n  *(undefined4 *)(iVar2 + -0x10) \u003d unaff_r8;\n  *(undefined4 *)(iVar2 + -0x14) \u003d unaff_r7;\n  *(undefined4 *)(iVar2 + -0x18) \u003d unaff_r6;\n  *(undefined4 *)(iVar2 + -0x1c) \u003d unaff_r5;\n  *(undefined4 *)(iVar2 + -0x20) \u003d unaff_r4;\n  *(undefined4 *)(iVar2 + -0x24) \u003d in_lr;\n  sched_active_thread-\u003esp \u003d (char *)(undefined4 *)(iVar2 + -0x24);\n  isr_svc();\n  sched_run();\n  UNRECOVERED_JUMPTABLE \u003d *(code **)sched_active_thread-\u003esp;\n  ppcVar3 \u003d (code **)((int)sched_active_thread-\u003esp + 0x24);\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    setProcessStackPointer(ppcVar3);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(UNRECOVERED_JUMPTABLE,ppcVar3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "isr_svc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_svc": {
      "entrypoint": "0x00000974",
      "current_name": "isr_svc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid isr_svc(void)\n\n{\n  bool bVar1;\n  code *UNRECOVERED_JUMPTABLE;\n  code **ppcVar2;\n  \n  sched_run();\n  UNRECOVERED_JUMPTABLE \u003d *(code **)sched_active_thread-\u003esp;\n  ppcVar2 \u003d (code **)((int)sched_active_thread-\u003esp + 0x24);\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    setProcessStackPointer(ppcVar2);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(UNRECOVERED_JUMPTABLE,ppcVar2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "isr_pendsv"
      ],
      "called": [
        "sched_run"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "context_restore": {
      "entrypoint": "0x00000978",
      "current_name": "context_restore",
      "code": "\nvoid context_restore(void)\n\n{\n  bool bVar1;\n  code *UNRECOVERED_JUMPTABLE;\n  code **ppcVar2;\n  \n  UNRECOVERED_JUMPTABLE \u003d *(code **)sched_active_thread-\u003esp;\n  ppcVar2 \u003d (code **)((int)sched_active_thread-\u003esp + 0x24);\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    setProcessStackPointer(ppcVar2);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00000988. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(UNRECOVERED_JUMPTABLE,ppcVar2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "post_startup": {
      "entrypoint": "0x00000990",
      "current_name": "post_startup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid post_startup(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "reset_handler_default"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "reset_handler_default": {
      "entrypoint": "0x0000099c",
      "current_name": "reset_handler_default",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_handler_default(void)\n\n{\n  uint32_t uStack_18;\n  uint32_t *top;\n  uint32_t *src;\n  uint32_t *dst;\n  \n  top \u003d \u0026uStack_18;\n  src \u003d (uint32_t *)\u0026_etext;\n  pre_startup();\n  dst \u003d (uint32_t *)isr_stack;\n  while (dst \u003c \u0026uStack_18) {\n    *dst \u003d 0xe7fee7fe;\n    dst \u003d dst + 1;\n  }\n  dst \u003d (uint32_t *)\u0026heap_top;\n  while (dst \u003c \u0026sched_num_threads) {\n    *dst \u003d *src;\n    src \u003d src + 1;\n    dst \u003d dst + 1;\n  }\n  dst \u003d (uint32_t *)\u0026sched_num_threads;\n  while (dst \u003c \u0026_sheap) {\n    *dst \u003d 0;\n    dst \u003d dst + 1;\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "board_init",
        "kernel_init",
        "__libc_init_array",
        "pre_startup",
        "post_startup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "nmi_default": {
      "entrypoint": "0x00000a30",
      "current_name": "nmi_default",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid nmi_default(void)\n\n{\n                    \n  core_panic(PANIC_NMI_HANDLER,\"NMI HANDLER\");\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_stack_size_left": {
      "entrypoint": "0x00000a40",
      "current_name": "_stack_size_left",
      "code": "\nint _stack_size_left(uint32_t required)\n\n{\n  uint32_t required_local;\n  uint32_t *sp;\n  \n  return (int)(\u0026stack0xe000ffe8 + -required);\n}\n\n",
      "renaming": {},
      "calling": [
        "hard_fault_handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "hard_fault_default": {
      "entrypoint": "0x00000a64",
      "current_name": "hard_fault_default",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid hard_fault_default(void)\n\n{\n  uint32_t *sp;\n  uint32_t corrupted;\n  uint32_t unaff_r4;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  undefined4 unaff_r8;\n  undefined4 unaff_r9;\n  undefined4 unaff_r10;\n  undefined4 unaff_r11;\n  uint in_lr;\n  \n  if ((\u0026_eram \u003c \u0026stack0x00000000) || (\u0026stack0x00000000 \u003c isr_stack + 0x159)) {\n    corrupted \u003d 1;\n    register0x00000054 \u003d (BADSPACEBASE *)\u0026heap_top;\n  }\n  else {\n    corrupted \u003d 0;\n  }\n  if ((in_lr \u0026 4) \u003d\u003d 0) {\n    sp \u003d (uint32_t *)getMainStackPointer();\n  }\n  else {\n    sp \u003d (uint32_t *)getProcessStackPointer();\n  }\n  *(undefined4 *)((int)register0x00000054 + -4) \u003d unaff_r11;\n  *(undefined4 *)((int)register0x00000054 + -8) \u003d unaff_r10;\n  *(undefined4 *)((int)register0x00000054 + -0xc) \u003d unaff_r9;\n  *(undefined4 *)((int)register0x00000054 + -0x10) \u003d unaff_r8;\n  *(undefined4 *)((int)register0x00000054 + -0x14) \u003d unaff_r7;\n  *(undefined4 *)((int)register0x00000054 + -0x18) \u003d unaff_r6;\n  *(undefined4 *)((int)register0x00000054 + -0x1c) \u003d unaff_r5;\n  *(uint32_t *)((int)register0x00000054 + -0x20) \u003d unaff_r4;\n                    \n  hard_fault_handler(sp,corrupted,in_lr,(uint32_t *)((int)register0x00000054 + -0x20));\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "hard_fault_handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "hard_fault_handler": {
      "entrypoint": "0x00000aa8",
      "current_name": "hard_fault_handler",
      "code": "\n\n\nvoid hard_fault_handler(uint32_t *sp,uint32_t corrupted,uint32_t exc_return,\n                       uint32_t *r4_to_r11_stack)\n\n{\n  uint uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  undefined4 uVar6;\n  int iVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  uint32_t uVar10;\n  uint32_t uVar11;\n  uint32_t uVar12;\n  uint32_t *r4_to_r11_stack_local;\n  uint32_t exc_return_local;\n  uint32_t corrupted_local;\n  uint32_t *sp_local;\n  int stack_left;\n  uint32_t psr;\n  uint32_t lr;\n  uint32_t r12;\n  uint32_t r3;\n  uint32_t r2;\n  uint32_t r1;\n  uint32_t r0;\n  uint32_t afsr;\n  uint32_t dfsr;\n  uint32_t hfsr;\n  uint32_t cfsr;\n  uint32_t mmfar;\n  uint32_t bfar;\n  uint32_t *orig_sp;\n  uint32_t pc;\n  \n  uVar6 \u003d _DAT_e000ed3c;\n  uVar5 \u003d _DAT_e000ed38;\n  uVar4 \u003d _DAT_e000ed34;\n  uVar3 \u003d _DAT_e000ed30;\n  uVar2 \u003d _DAT_e000ed2c;\n  uVar1 \u003d _DAT_e000ed28;\n  pc \u003d 0;\n  if (isr_stack._0_4_ !\u003d -0x18011802) {\n    puts(\"\\nISR stack overflowed\");\n  }\n  if (corrupted \u003d\u003d 0) {\n    uVar8 \u003d *sp;\n    uVar9 \u003d sp[1];\n    uVar10 \u003d sp[2];\n    uVar11 \u003d sp[4];\n    uVar12 \u003d sp[5];\n    pc \u003d sp[6];\n    puts(\"\\nContext before hardfault:\");\n    iprintf(\"   r0: 0x%08lx\\n   r1: 0x%08lx\\n   r2: 0x%08lx\\n   r3: 0x%08lx\\n\",uVar8,uVar9,uVar10);\n    iprintf(\"  r12: 0x%08lx\\n   lr: 0x%08lx\\n   pc: 0x%08lx\\n  psr: 0x%08lx\\n\\n\",uVar11,uVar12,pc);\n  }\n  else {\n    puts(\"Stack pointer corrupted, reset to top of stack\");\n  }\n  puts(\"FSR/FAR:\");\n  iprintf(\" CFSR: 0x%08lx\\n\",uVar1);\n  iprintf(\" HFSR: 0x%08lx\\n\",uVar2);\n  iprintf(\" DFSR: 0x%08lx\\n\",uVar3);\n  iprintf(\" AFSR: 0x%08lx\\n\",uVar6);\n  if ((uVar1 \u0026 0x8000) !\u003d 0) {\n    iprintf(\" BFAR: 0x%08lx\\n\",uVar5);\n  }\n  if ((uVar1 \u0026 0x80) !\u003d 0) {\n    iprintf(\"MMFAR: 0x%08lx\\n\",uVar4);\n  }\n  puts(\"Misc\");\n  iprintf(\"EXC_RET: 0x%08lx\\n\",exc_return);\n  if (corrupted \u003d\u003d 0) {\n    puts(\"Attempting to reconstruct state for debugging...\");\n    iprintf(\"In GDB:\\n  set $pc\u003d0x%lx\\n  frame 0\\n  bt\\n\",pc);\n    iVar7 \u003d _stack_size_left(0x158);\n    if (iVar7 \u003c 0) {\n      iprintf(\"\\nISR stack overflowed by at least %d bytes.\\n\",-iVar7);\n    }\n  }\n  software_bkpt(1);\n                    \n  core_panic(PANIC_HARD_FAULT,\"HARD FAULT HANDLER\");\n}\n\n",
      "renaming": {},
      "calling": [
        "hard_fault_default"
      ],
      "called": [
        "iprintf",
        "_stack_size_left",
        "puts",
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mem_manage_default": {
      "entrypoint": "0x00000c80",
      "current_name": "mem_manage_default",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid mem_manage_default(void)\n\n{\n                    \n  core_panic(PANIC_MEM_MANAGE,\"MEM MANAGE HANDLER\");\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bus_fault_default": {
      "entrypoint": "0x00000c90",
      "current_name": "bus_fault_default",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid bus_fault_default(void)\n\n{\n                    \n  core_panic(PANIC_BUS_FAULT,\"BUS FAULT HANDLER\");\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "usage_fault_default": {
      "entrypoint": "0x00000ca0",
      "current_name": "usage_fault_default",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid usage_fault_default(void)\n\n{\n                    \n  core_panic(PANIC_USAGE_FAULT,\"USAGE FAULT HANDLER\");\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "debug_mon_default": {
      "entrypoint": "0x00000cb0",
      "current_name": "debug_mon_default",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid debug_mon_default(void)\n\n{\n                    \n  core_panic(PANIC_DEBUG_MON,\"DEBUG MON HANDLER\");\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dummy_handler_default": {
      "entrypoint": "0x00000cc0",
      "current_name": "dummy_handler_default",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid dummy_handler_default(void)\n\n{\n                    \n  core_panic(PANIC_DUMMY_HANDLER,\"DUMMY HANDLER\");\n}\n\n",
      "renaming": {},
      "calling": [
        "dummy_handler"
      ],
      "called": [
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "irq_disable": {
      "entrypoint": "0x00000cd0",
      "current_name": "irq_disable",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint irq_disable(void)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint32_t result;\n  uint32_t mask;\n  \n  uVar2 \u003d 0;\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 \u003d isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "kernel_init",
        "mutex_unlock",
        "thread_create",
        "_sbrk_r",
        "_mutex_lock",
        "sched_task_exit",
        "pm_off",
        "kinetis_mcg_init",
        "core_panic"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "irq_enable": {
      "entrypoint": "0x00000cf0",
      "current_name": "irq_enable",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint irq_enable(void)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint32_t result;\n  \n  enableIRQinterrupts();\n  uVar2 \u003d 0;\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 \u003d isIRQinterruptsEnabled();\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "cpu_switch_context_exit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "irq_restore": {
      "entrypoint": "0x00000d0c",
      "current_name": "irq_restore",
      "code": "\nvoid irq_restore(uint state)\n\n{\n  bool bVar1;\n  uint state_local;\n  \n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    enableIRQinterrupts((state \u0026 1) \u003d\u003d 1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mutex_unlock",
        "thread_create",
        "_sbrk_r",
        "_mutex_lock",
        "kinetis_mcg_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "irq_is_in": {
      "entrypoint": "0x00000d2a",
      "current_name": "irq_is_in",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint irq_is_in(void)\n\n{\n  bool bVar1;\n  uint uVar2;\n  uint32_t result;\n  \n  uVar2 \u003d 0;\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 \u003d getCurrentExceptionNumber();\n    uVar2 \u003d uVar2 \u0026 0x1f;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "sched_switch"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bitband_addr": {
      "entrypoint": "0x00001d08",
      "current_name": "bitband_addr",
      "code": "\nvoid * bitband_addr(void *ptr,uintptr_t bit)\n\n{\n  uintptr_t bit_local;\n  void *ptr_local;\n  \n  return (void *)(bit * 4 + ((uint)ptr \u0026 0xf0000000 | ((uint)ptr \u0026 0xfffff) \u003c\u003c 5) + 0x2000000);\n}\n\n",
      "renaming": {},
      "calling": [
        "bit_set32"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bit_clear32": {
      "entrypoint": "0x00000d76",
      "current_name": "bit_clear32",
      "code": "\nvoid bit_clear32(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  uint8_t bit_local;\n  uint32_t *ptr_local;\n  \n  puVar1 \u003d (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "cpu_errata_fixes"
      ],
      "called": [
        "bitband_addr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cpu_errata_fixes": {
      "entrypoint": "0x00000d9c",
      "current_name": "cpu_errata_fixes",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cpu_errata_fixes(void)\n\n{\n  bit_clear32((uint32_t *)0x40048040,\u0027\\0\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pre_startup"
      ],
      "called": [
        "bit_clear32"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pre_startup": {
      "entrypoint": "0x00000db0",
      "current_name": "pre_startup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pre_startup(void)\n\n{\n  wdog_disable();\n  cpu_errata_fixes();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "reset_handler_default"
      ],
      "called": [
        "wdog_disable",
        "cpu_errata_fixes"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dummy_handler": {
      "entrypoint": "0x00000dc0",
      "current_name": "dummy_handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid dummy_handler(void)\n\n{\n  dummy_handler_default();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "dummy_handler_default"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "wdog_disable": {
      "entrypoint": "0x00000dcc",
      "current_name": "wdog_disable",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid wdog_disable(void)\n\n{\n  _DAT_4005200e \u003d 0xd928;\n  _DAT_40052000 \u003d 0xd2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pre_startup"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_stdio_init": {
      "entrypoint": "0x00000df4",
      "current_name": "uart_stdio_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid uart_stdio_init(void)\n\n{\n  uart_init(0,0x1c200,isrpipe_write_one + 1,\u0026uart_stdio_isrpipe);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_init"
      ],
      "called": [
        "uart_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_stdio_read": {
      "entrypoint": "0x00000e14",
      "current_name": "uart_stdio_read",
      "code": "\nint uart_stdio_read(char *buffer,int count)\n\n{\n  int iVar1;\n  int count_local;\n  char *buffer_local;\n  \n  iVar1 \u003d isrpipe_read(\u0026uart_stdio_isrpipe,buffer,count);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_read_r"
      ],
      "called": [
        "isrpipe_read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_stdio_write": {
      "entrypoint": "0x00000e38",
      "current_name": "uart_stdio_write",
      "code": "\nint uart_stdio_write(char *buffer,int len)\n\n{\n  int len_local;\n  char *buffer_local;\n  \n  uart_write(0,(uint8_t *)buffer,len);\n  return len;\n}\n\n",
      "renaming": {},
      "calling": [
        "_write_r"
      ],
      "called": [
        "uart_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pm_off": {
      "entrypoint": "0x00000e58",
      "current_name": "pm_off",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pm_off(void)\n\n{\n  irq_disable();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "core_panic"
      ],
      "called": [
        "irq_disable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "board_init": {
      "entrypoint": "0x00000e64",
      "current_name": "board_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid board_init(void)\n\n{\n  _DAT_40048038 \u003d _DAT_40048038 | 0x200;\n  _DAT_40049048 \u003d _DAT_40049048 \u0026 0xfefff8ff;\n  cpu_init();\n  gpio_init(0x2056,GPIO_OUT);\n  gpio_init(0x511a,GPIO_OUT);\n  gpio_init(0x2055,GPIO_OUT);\n  gpio_set(0x2056);\n  gpio_set(0x511a);\n  gpio_set(0x2055);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "reset_handler_default"
      ],
      "called": [
        "gpio_set",
        "gpio_init",
        "cpu_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cpu_print_last_instruction": {
      "entrypoint": "0x00000ed8",
      "current_name": "cpu_print_last_instruction",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cpu_print_last_instruction(void)\n\n{\n  undefined4 in_lr;\n  uint32_t *lr_ptr;\n  \n  iprintf(\"%p\\n\",in_lr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "core_panic"
      ],
      "called": [
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "panic_arch": {
      "entrypoint": "0x00000ef8",
      "current_name": "panic_arch",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid panic_arch(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "core_panic"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "core_panic": {
      "entrypoint": "0x00000f04",
      "current_name": "core_panic",
      "code": "\nvoid core_panic(core_panic_t crash_code,char *message)\n\n{\n  undefined4 uStack_18;\n  undefined4 uStack_14;\n  char *message_local;\n  core_panic_t crash_code_local;\n  \n  message_local \u003d message;\n  crash_code_local \u003d crash_code;\n  if (crashed \u003d\u003d 0) {\n    crashed \u003d 1;\n    if (crash_code \u003d\u003d PANIC_ASSERT_FAIL) {\n      cpu_print_last_instruction();\n    }\n    iprintf(\"*** RIOT kernel panic:\\n%s\\n\\n\",message_local);\n    ps();\n    iprintf(\"\\n\");\n    iprintf(\"*** halted.\\n\\n\");\n  }\n  irq_disable();\n  panic_arch();\n  uStack_14 \u003d 0xf4d;\n  pm_off();\n  uStack_18 \u003d (int)\u0026uStack_18 + 1;\n  auto_init();\n  iprintf(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "hard_fault_handler",
        "mem_manage_default",
        "cib_init",
        "debug_mon_default",
        "usage_fault_default",
        "fmt_s32_dfp",
        "dummy_handler_default",
        "thread_add_to_list",
        "uart_init",
        "nmi_default",
        "bus_fault_default"
      ],
      "called": [
        "cpu_print_last_instruction",
        "panic_arch",
        "ps",
        "irq_disable",
        "iprintf",
        "pm_off"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main_trampoline": {
      "entrypoint": "0x00000f5c",
      "current_name": "main_trampoline",
      "code": "\nvoid * main_trampoline(void *arg)\n\n{\n  void *arg_local;\n  \n  auto_init();\n  iprintf(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n  return (void *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "auto_init",
        "main",
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "idle_thread": {
      "entrypoint": "0x00000f80",
      "current_name": "idle_thread",
      "code": "\nvoid * idle_thread(void *arg)\n\n{\n  void *arg_local;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kernel_init": {
      "entrypoint": "0x00000f8c",
      "current_name": "kernel_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kernel_init(void)\n\n{\n  irq_disable();\n  thread_create(idle_stack,0x100,\u0027\\x0f\u0027,0xc,idle_thread + 1,(void *)0x0,idle_name);\n  thread_create(main_stack,0x600,\u0027\\a\u0027,0xc,main_trampoline + 1,(void *)0x0,main_name);\n                    \n  cpu_switch_context_exit();\n}\n\n",
      "renaming": {},
      "calling": [
        "reset_handler_default"
      ],
      "called": [
        "cpu_switch_context_exit",
        "irq_disable",
        "thread_create"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cib_init": {
      "entrypoint": "0x00000fec",
      "current_name": "cib_init",
      "code": "\nvoid cib_init(cib_t *cib,uint size)\n\n{\n  uint size_local;\n  cib_t *cib_local;\n  cib_t c;\n  \n  if ((size \u0026 size - 1) !\u003d 0) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  cib-\u003eread_count \u003d 0;\n  cib-\u003ewrite_count \u003d 0;\n  cib-\u003emask \u003d size - 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "thread_create"
      ],
      "called": [
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "thread_add_to_list": {
      "entrypoint": "0x00001034",
      "current_name": "thread_add_to_list",
      "code": "\nvoid thread_add_to_list(list_node_t *list,thread_t *thread)\n\n{\n  thread_t *thread_local;\n  list_node_t *list_local;\n  thread_t *list_entry;\n  clist_node_t *__m____;\n  list_node_t *new_node;\n  uint16_t my_prio;\n  \n  if (thread-\u003estatus \u003c 9) {\n    list_local \u003d list;\n    while ((list_local-\u003enext !\u003d (list_node *)0x0 \u0026\u0026\n           (*(byte *)((int)\u0026list_local-\u003enext[-1].next + 1) \u003c\u003d thread-\u003epriority))) {\n      list_local \u003d list_local-\u003enext;\n    }\n    (thread-\u003erq_entry).next \u003d list_local-\u003enext;\n    list_local-\u003enext \u003d \u0026thread-\u003erq_entry;\n    return;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
      "renaming": {},
      "calling": [
        "_mutex_lock"
      ],
      "called": [
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "thread_measure_stack_free": {
      "entrypoint": "0x000010a0",
      "current_name": "thread_measure_stack_free",
      "code": "\nuintptr_t thread_measure_stack_free(char *stack)\n\n{\n  char *stack_local;\n  uintptr_t space_free;\n  uintptr_t *stackp;\n  \n  for (stackp \u003d (uintptr_t *)stack; (uintptr_t *)*stackp \u003d\u003d stackp; stackp \u003d stackp + 1) {\n  }\n  return (int)stackp - (int)stack;\n}\n\n",
      "renaming": {},
      "calling": [
        "ps"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "thread_create": {
      "entrypoint": "0x000010d4",
      "current_name": "thread_create",
      "code": "\nkernel_pid_t\nthread_create(char *stack,int stacksize,char priority,int flags,thread_task_func_t function,\n             void *arg,char *name)\n\n{\n  uint state_00;\n  char *pcVar1;\n  int iVar2;\n  uint stack_size;\n  thread_t *process;\n  int flags_local;\n  char priority_local;\n  int stacksize_local;\n  char *stack_local;\n  uint state;\n  uintptr_t *stackmax;\n  thread_t *cb;\n  uintptr_t misalignment;\n  int total_stacksize;\n  uintptr_t *stackp;\n  kernel_pid_t i;\n  kernel_pid_t pid;\n  \n  if ((byte)priority \u003c 0x10) {\n    stacksize_local \u003d stacksize;\n    stack_local \u003d stack;\n    if (((uint)stack \u0026 3) !\u003d 0) {\n      iVar2 \u003d 4 - ((uint)stack \u0026 3);\n      stack_local \u003d stack + iVar2;\n      stacksize_local \u003d stacksize - iVar2;\n    }\n    stack_size \u003d stacksize_local - 0x30U \u0026 0xfffffffc;\n    process \u003d (thread_t *)(stack_local + stack_size);\n    if ((flags \u0026 8U) \u003d\u003d 0) {\n      *(char **)stack_local \u003d stack_local;\n    }\n    else {\n      for (stackp \u003d (uintptr_t *)stack_local; stackp \u003c stack_local + stack_size; stackp \u003d stackp + 1\n          ) {\n        *stackp \u003d (uintptr_t)stackp;\n      }\n    }\n    state_00 \u003d irq_disable();\n    pid \u003d 0;\n    for (i \u003d 1; i \u003c 0x21; i \u003d i + 1) {\n      if (sched_threads[i] \u003d\u003d (thread_t *)0x0) {\n        pid \u003d i;\n        break;\n      }\n    }\n    if (pid \u003d\u003d 0) {\n      irq_restore(state_00);\n      pid \u003d -0x8b;\n    }\n    else {\n      sched_threads[pid] \u003d process;\n      process-\u003epid \u003d pid;\n      pcVar1 \u003d thread_stack_init(function,arg,stack_local,stack_size);\n      process-\u003esp \u003d pcVar1;\n      process-\u003estack_start \u003d stack_local;\n      process-\u003estack_size \u003d stacksize;\n      process-\u003ename \u003d name;\n      process-\u003epriority \u003d priority;\n      process-\u003estatus \u003d \u0027\\0\u0027;\n      (process-\u003erq_entry).next \u003d (list_node *)0x0;\n      process-\u003ewait_data \u003d (void *)0x0;\n      (process-\u003emsg_waiters).next \u003d (list_node *)0x0;\n      cib_init(\u0026process-\u003emsg_queue,0);\n      process-\u003emsg_array \u003d (msg_t *)0x0;\n      sched_num_threads \u003d sched_num_threads + 1;\n      if ((flags \u0026 1U) \u003d\u003d 0) {\n        sched_set_status(process,10);\n        if ((flags \u0026 4U) \u003d\u003d 0) {\n          irq_restore(state_00);\n          sched_switch((ushort)(byte)priority);\n          return pid;\n        }\n      }\n      else {\n        sched_set_status(process,1);\n      }\n      irq_restore(state_00);\n    }\n  }\n  else {\n    pid \u003d -0x16;\n  }\n  return pid;\n}\n\n",
      "renaming": {},
      "calling": [
        "kernel_init"
      ],
      "called": [
        "cib_init",
        "sched_switch",
        "irq_disable",
        "sched_set_status",
        "irq_restore",
        "thread_stack_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cpu_init": {
      "entrypoint": "0x00001274",
      "current_name": "cpu_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cpu_init(void)\n\n{\n  cortexm_init();\n  DAT_4007e000 \u003d DAT_4007e000 | 0x28;\n  kinetis_mcg_init();\n  periph_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "board_init"
      ],
      "called": [
        "cortexm_init",
        "periph_init",
        "kinetis_mcg_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mutex_lock": {
      "entrypoint": "0x0000129c",
      "current_name": "mutex_lock",
      "code": "\nvoid mutex_lock(mutex_t *mutex)\n\n{\n  mutex_t *mutex_local;\n  \n  _mutex_lock(mutex,1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "isrpipe_read"
      ],
      "called": [
        "_mutex_lock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isrpipe_write_one": {
      "entrypoint": "0x000012b4",
      "current_name": "isrpipe_write_one",
      "code": "\nint isrpipe_write_one(isrpipe_t *isrpipe,char c)\n\n{\n  int iVar1;\n  char c_local;\n  isrpipe_t *isrpipe_local;\n  int res;\n  \n  iVar1 \u003d tsrb_add_one(\u0026isrpipe-\u003etsrb,c);\n  mutex_unlock(\u0026isrpipe-\u003emutex);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "tsrb_add_one",
        "mutex_unlock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isrpipe_read": {
      "entrypoint": "0x000012e2",
      "current_name": "isrpipe_read",
      "code": "\nint isrpipe_read(isrpipe_t *isrpipe,char *buffer,size_t count)\n\n{\n  int iVar1;\n  size_t count_local;\n  char *buffer_local;\n  isrpipe_t *isrpipe_local;\n  int res;\n  \n  while( true ) {\n    iVar1 \u003d tsrb_get(\u0026isrpipe-\u003etsrb,buffer,count);\n    if (iVar1 !\u003d 0) break;\n    mutex_lock(\u0026isrpipe-\u003emutex);\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_stdio_read"
      ],
      "called": [
        "tsrb_get",
        "mutex_lock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_EnableIRQ": {
      "entrypoint": "0x00002714",
      "current_name": "NVIC_EnableIRQ",
      "code": "\nvoid NVIC_EnableIRQ(IRQn_Type IRQn)\n\n{\n  IRQn_Type IRQn_local;\n  \n  *(int *)(((uint)(int)IRQn \u003e\u003e 5) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (IRQn \u0026 0x1fU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtt_set_alarm"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cortexm_isr_end": {
      "entrypoint": "0x00002798",
      "current_name": "cortexm_isr_end",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cortexm_isr_end(void)\n\n{\n  if (sched_context_switch_request !\u003d 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "isr_rtc"
      ],
      "called": [
        "thread_yield_higher"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bit_set32": {
      "entrypoint": "0x00001d3a",
      "current_name": "bit_set32",
      "code": "\nvoid bit_set32(uint32_t *ptr,uint8_t bit)\n\n{\n  undefined4 *puVar1;\n  uint8_t bit_local;\n  uint32_t *ptr_local;\n  \n  puVar1 \u003d (undefined4 *)bitband_addr(ptr,(uint)bit);\n  *puVar1 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "clk_en"
      ],
      "called": [
        "bitband_addr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_init": {
      "entrypoint": "0x000013b8",
      "current_name": "uart_init",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0000142e) */\n\nint uart_init(uart_t uart,uint32_t baudrate,uart_rx_cb_t rx_cb,void *arg)\n\n{\n  void *arg_local;\n  uart_rx_cb_t rx_cb_local;\n  uint32_t baudrate_local;\n  uart_t uart_local;\n  \n  if (uart \u003d\u003d 0) {\n    config[0].rx_cb \u003d rx_cb;\n    config[0].arg \u003d arg;\n    uart_init_pins(0);\n    bit_set32((uint32_t *)\u0026DAT_40048034,\u0027\\n\u0027);\n    uart_init_uart(0,baudrate);\n    return 0;\n  }\n                    \n  core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_stdio_init"
      ],
      "called": [
        "uart_init_pins",
        "bit_set32",
        "uart_init_uart",
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_init_pins": {
      "entrypoint": "0x00001448",
      "current_name": "uart_init_pins",
      "code": "\nvoid uart_init_pins(uart_t uart)\n\n{\n  uart_t uart_local;\n  \n  if (uart_config[uart].pin_rx !\u003d 0xffff) {\n    gpio_init_port(uart_config[uart].pin_rx,uart_config[uart].pcr_rx);\n  }\n  if (uart_config[uart].pin_tx !\u003d 0xffff) {\n    gpio_init_port(uart_config[uart].pin_tx,uart_config[uart].pcr_tx);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [
        "gpio_init_port"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_init_uart": {
      "entrypoint": "0x000014c4",
      "current_name": "uart_init_uart",
      "code": "\nvoid uart_init_uart(uart_t uart,uint32_t baudrate)\n\n{\n  byte *pbVar1;\n  uint uVar2;\n  uint uVar3;\n  uint32_t baudrate_local;\n  uart_t uart_local;\n  uint8_t txfifo_size;\n  uint8_t brfa;\n  uint16_t ubd;\n  uint32_t clk;\n  UART_Type *dev;\n  \n  pbVar1 \u003d (byte *)uart_config[uart].dev;\n  uVar2 \u003d uart_config[uart].freq;\n  pbVar1[3] \u003d pbVar1[3] \u0026 0xf3;\n  pbVar1[2] \u003d uart_config[uart].mode;\n  uVar3 \u003d uVar2 / (baudrate \u003c\u003c 4);\n  *pbVar1 \u003d (byte)(uVar3 \u003e\u003e 8) \u0026 0x1f;\n  pbVar1[1] \u003d (byte)uVar3;\n  pbVar1[10] \u003d (byte)((uVar2 \u003c\u003c 2) / baudrate + 1 \u003e\u003e 1) \u0026 0x1f;\n  pbVar1[0x10] \u003d pbVar1[0x10] | 0x88;\n  if ((pbVar1[0x10] \u0026 0x70) \u003d\u003d 0) {\n    pbVar1[0x13] \u003d 0;\n  }\n  else {\n    pbVar1[0x13] \u003d (char)(2 \u003c\u003c (pbVar1[0x10] \u003e\u003e 4 \u0026 7)) - 1;\n  }\n  pbVar1[0x15] \u003d 1;\n  pbVar1[0x11] \u003d 0xc0;\n  pbVar1[3] \u003d pbVar1[3] | 0x2c;\n  NVIC_EnableIRQ(uart_config[uart].irqn);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [
        "NVIC_EnableIRQ"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_write": {
      "entrypoint": "0x000015d0",
      "current_name": "uart_write",
      "code": "\nvoid uart_write(uart_t uart,uint8_t *data,size_t len)\n\n{\n  void *pvVar1;\n  size_t len_local;\n  uint8_t *data_local;\n  uart_t uart_local;\n  UART_Type *dev;\n  size_t i;\n  \n  pvVar1 \u003d uart_config[uart].dev;\n  for (i \u003d 0; i \u003c len; i \u003d i + 1) {\n    do {\n    } while (-1 \u003c *(char *)((int)pvVar1 + 4));\n    *(uint8_t *)((int)pvVar1 + 7) \u003d data[i];\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_stdio_write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "irq_handler_uart": {
      "entrypoint": "0x00001628",
      "current_name": "irq_handler_uart",
      "code": "\nvoid irq_handler_uart(uart_t uart)\n\n{\n  uart_t uart_local;\n  uint8_t data;\n  UART_Type *dev;\n  \n  if (((*(byte *)((int)uart_config[uart].dev + 4) \u0026 0x20) !\u003d 0) \u0026\u0026\n     (config[uart].rx_cb !\u003d (uart_rx_cb_t)0x0)) {\n    (*config[uart].rx_cb)(config[uart].arg,*(uint8_t *)((int)uart_config[uart].dev + 7));\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "isr_uart0_rx_tx"
      ],
      "called": [
        "cortexm_isr_end"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_uart0_rx_tx": {
      "entrypoint": "0x00001688",
      "current_name": "isr_uart0_rx_tx",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid isr_uart0_rx_tx(void)\n\n{\n  irq_handler_uart(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "irq_handler_uart"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bit_set8": {
      "entrypoint": "0x000016ec",
      "current_name": "bit_set8",
      "code": "\nvoid bit_set8(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *puVar1;\n  uint8_t bit_local;\n  uint8_t *ptr_local;\n  \n  puVar1 \u003d (undefined *)bitband_addr(ptr,(uint)bit);\n  *puVar1 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_init_mcgirclk",
        "kinetis_mcg_enable_osc",
        "kinetis_mcg_set_blpi",
        "kinetis_mcg_set_pbe",
        "kinetis_mcg_set_blpe"
      ],
      "called": [
        "bitband_addr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bit_clear8": {
      "entrypoint": "0x00001710",
      "current_name": "bit_clear8",
      "code": "\nvoid bit_clear8(uint8_t *ptr,uint8_t bit)\n\n{\n  undefined *puVar1;\n  uint8_t bit_local;\n  uint8_t *ptr_local;\n  \n  puVar1 \u003d (undefined *)bitband_addr(ptr,(uint)bit);\n  *puVar1 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_init_mcgirclk",
        "kinetis_mcg_set_fbe",
        "kinetis_mcg_enable_osc",
        "kinetis_mcg_set_fei",
        "kinetis_mcg_set_fbi",
        "kinetis_mcg_set_safe_mode",
        "kinetis_mcg_disable_pll",
        "kinetis_mcg_set_pbe"
      ],
      "called": [
        "bitband_addr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_disable_pll": {
      "entrypoint": "0x00001734",
      "current_name": "kinetis_mcg_disable_pll",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_disable_pll(void)\n\n{\n  bit_clear8(\u0026DAT_40064005,\u0027\\x06\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_fbe",
        "kinetis_mcg_set_blpi",
        "kinetis_mcg_set_blpe"
      ],
      "called": [
        "bit_clear8"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_fll_factor": {
      "entrypoint": "0x00001748",
      "current_name": "kinetis_mcg_set_fll_factor",
      "code": "\nvoid kinetis_mcg_set_fll_factor(kinetis_mcg_fll_t factor)\n\n{\n  kinetis_mcg_fll_t factor_local;\n  \n  DAT_40064003 \u003d factor | DAT_40064003 \u0026 ~KINETIS_MCG_FLL_FACTOR_2929;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_fbe",
        "kinetis_mcg_set_fee",
        "kinetis_mcg_set_fei",
        "kinetis_mcg_set_fbi",
        "kinetis_mcg_set_safe_mode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_enable_osc": {
      "entrypoint": "0x00001778",
      "current_name": "kinetis_mcg_enable_osc",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_enable_osc(void)\n\n{\n  DAT_40064001 \u003d DAT_40064001 \u0026 0xcf | 0x20;\n  bit_clear8(\u0026DAT_40064001,\u0027\\x02\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_fbe",
        "kinetis_mcg_set_fee"
      ],
      "called": [
        "bit_clear8",
        "bit_set8"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_init_erclk32k": {
      "entrypoint": "0x000017dc",
      "current_name": "kinetis_mcg_init_erclk32k",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_init_erclk32k(void)\n\n{\n  bit_set32((uint32_t *)\u0026DAT_4004803c,\u0027\\x1d\u0027);\n  if ((_DAT_4003d010 \u0026 0x100) \u003d\u003d 0) {\n    _DAT_4003d010 \u003d 0x104;\n  }\n  _DAT_40047000 \u003d _DAT_40047000 \u0026 0xfff3ffff | 0x80000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_init"
      ],
      "called": [
        "bit_set32"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_init_mcgirclk": {
      "entrypoint": "0x0000182c",
      "current_name": "kinetis_mcg_init_mcgirclk",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_init_mcgirclk(void)\n\n{\n  uint8_t tmp;\n  \n  DAT_40064008 \u003d DAT_40064008 \u0026 0xd0;\n  bit_set8(\u0026DAT_40064001,\u0027\\0\u0027);\n  bit_clear8(\u0026DAT_40064000,\u0027\\x01\u0027);\n  bit_clear8(\u0026DAT_40064000,\u0027\\0\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_init"
      ],
      "called": [
        "bit_clear8",
        "bit_set8"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_fei": {
      "entrypoint": "0x000018bc",
      "current_name": "kinetis_mcg_set_fei",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_fei(void)\n\n{\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b | 4;\n  bit_clear8(\u0026DAT_40064001,\u0027\\x01\u0027);\n  do {\n  } while ((DAT_40064006 \u0026 0x10) \u003d\u003d 0);\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 0);\n  current_mode \u003d KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_mode"
      ],
      "called": [
        "bit_clear8",
        "kinetis_mcg_set_fll_factor"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_fee": {
      "entrypoint": "0x0000191c",
      "current_name": "kinetis_mcg_set_fee",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_fee(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 0);\n  current_mode \u003d KINETIS_MCG_MODE_FEE;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_mode"
      ],
      "called": [
        "kinetis_mcg_set_fll_factor",
        "kinetis_mcg_enable_osc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_fbi": {
      "entrypoint": "0x00001960",
      "current_name": "kinetis_mcg_set_fbi",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_fbi(void)\n\n{\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1464);\n  bit_clear8(\u0026DAT_40064001,\u0027\\x01\u0027);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b | 0x44;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 4);\n  do {\n  } while ((DAT_40064006 \u0026 0x10) \u003d\u003d 0);\n  current_mode \u003d KINETIS_MCG_MODE_FBI;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_mode"
      ],
      "called": [
        "bit_clear8",
        "kinetis_mcg_set_fll_factor"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_fbe": {
      "entrypoint": "0x000019c0",
      "current_name": "kinetis_mcg_set_fbe",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_fbe(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_1920);\n  bit_clear8(\u0026DAT_40064001,\u0027\\x01\u0027);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b | 0x80;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 8);\n  kinetis_mcg_disable_pll();\n  current_mode \u003d KINETIS_MCG_MODE_FBE;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_mode"
      ],
      "called": [
        "bit_clear8",
        "kinetis_mcg_set_fll_factor",
        "kinetis_mcg_enable_osc",
        "kinetis_mcg_disable_pll"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_blpi": {
      "entrypoint": "0x00001a18",
      "current_name": "kinetis_mcg_set_blpi",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_blpi(void)\n\n{\n  bit_set8(\u0026DAT_40064001,\u0027\\x01\u0027);\n  kinetis_mcg_disable_pll();\n  current_mode \u003d KINETIS_MCG_MODE_BLPI;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_mode"
      ],
      "called": [
        "bit_set8",
        "kinetis_mcg_disable_pll"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_blpe": {
      "entrypoint": "0x00001a3c",
      "current_name": "kinetis_mcg_set_blpe",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_blpe(void)\n\n{\n  bit_set8(\u0026DAT_40064001,\u0027\\x01\u0027);\n  kinetis_mcg_disable_pll();\n  current_mode \u003d KINETIS_MCG_MODE_BLPE;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_mode"
      ],
      "called": [
        "bit_set8",
        "kinetis_mcg_disable_pll"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_pbe": {
      "entrypoint": "0x00001a60",
      "current_name": "kinetis_mcg_set_pbe",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_pbe(void)\n\n{\n  bit_clear8(\u0026DAT_40064001,\u0027\\x01\u0027);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3f | 0x80;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 8);\n  bit_set8(\u0026DAT_40064005,\u0027\\x06\u0027);\n  do {\n  } while ((DAT_40064006 \u0026 0x20) \u003d\u003d 0);\n  do {\n  } while ((DAT_40064006 \u0026 0x40) \u003d\u003d 0);\n  current_mode \u003d KINETIS_MCG_MODE_PBE;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_mode"
      ],
      "called": [
        "bit_clear8",
        "bit_set8"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_pee": {
      "entrypoint": "0x00001ad4",
      "current_name": "kinetis_mcg_set_pee",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_pee(void)\n\n{\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3f;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 0xc);\n  current_mode \u003d KINETIS_MCG_MODE_PEE;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_set_mode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_mode": {
      "entrypoint": "0x00001b10",
      "current_name": "kinetis_mcg_set_mode",
      "code": "\nint kinetis_mcg_set_mode(kinetis_mcg_mode_t mode)\n\n{\n  int iVar1;\n  kinetis_mcg_mode_t mode_local;\n  \n  if (mode \u003c KINETIS_MCG_MODE_NUMOF) {\n    do {\n      switch(mcg_mode_routing[current_mode][mode]) {\n      case \u0027\\0\u0027:\n        kinetis_mcg_set_fei();\n        break;\n      case \u0027\\x01\u0027:\n        kinetis_mcg_set_fee();\n        break;\n      case \u0027\\x02\u0027:\n        kinetis_mcg_set_fbi();\n        break;\n      case \u0027\\x03\u0027:\n        kinetis_mcg_set_fbe();\n        break;\n      case \u0027\\x04\u0027:\n        kinetis_mcg_set_blpi();\n        break;\n      case \u0027\\x05\u0027:\n        kinetis_mcg_set_blpe();\n        break;\n      case \u0027\\x06\u0027:\n        kinetis_mcg_set_pbe();\n        break;\n      case \u0027\\a\u0027:\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return -1;\n      }\n    } while (mode !\u003d current_mode);\n    iVar1 \u003d 0;\n  }\n  else {\n    iVar1 \u003d -1;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_init"
      ],
      "called": [
        "kinetis_mcg_set_fbe",
        "kinetis_mcg_set_fee",
        "kinetis_mcg_set_fei",
        "kinetis_mcg_set_blpi",
        "kinetis_mcg_set_fbi",
        "kinetis_mcg_set_pbe",
        "kinetis_mcg_set_pee",
        "kinetis_mcg_set_blpe"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_set_safe_mode": {
      "entrypoint": "0x00001bb8",
      "current_name": "kinetis_mcg_set_safe_mode",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_set_safe_mode(void)\n\n{\n  if ((DAT_40064001 \u0026 2) !\u003d 0) {\n    bit_clear8(\u0026DAT_40064001,\u0027\\x01\u0027);\n  }\n  if ((DAT_40064005 \u0026 0x40) !\u003d 0) {\n    if ((DAT_40064000 \u0026 0xc0) \u003d\u003d 0) {\n      DAT_40064000 \u003d DAT_40064000 \u0026 0x3f | 0x80;\n      do {\n      } while ((DAT_40064006 \u0026 0xc) !\u003d 8);\n    }\n    bit_clear8(\u0026DAT_40064005,\u0027\\x06\u0027);\n    do {\n    } while ((DAT_40064006 \u0026 0x20) !\u003d 0);\n  }\n  kinetis_mcg_set_fll_factor(KINETIS_MCG_FLL_FACTOR_640);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b | 4;\n  do {\n  } while ((DAT_40064006 \u0026 0x10) \u003d\u003d 0);\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 0);\n  current_mode \u003d KINETIS_MCG_MODE_FEI;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "kinetis_mcg_init"
      ],
      "called": [
        "bit_clear8",
        "kinetis_mcg_set_fll_factor"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kinetis_mcg_init": {
      "entrypoint": "0x00001c84",
      "current_name": "kinetis_mcg_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid kinetis_mcg_init(void)\n\n{\n  uint state;\n  uint mask;\n  \n  state \u003d irq_disable();\n  kinetis_mcg_set_safe_mode();\n  _DAT_40048044 \u003d 0x220000;\n  DAT_4006400c \u003d 0;\n  DAT_40064000 \u003d DAT_40064000 \u0026 199 | 0x38;\n  DAT_40064004 \u003d 0x13;\n  DAT_40064005 \u003d 0;\n  kinetis_mcg_init_mcgirclk();\n  kinetis_mcg_init_erclk32k();\n  kinetis_mcg_set_mode(KINETIS_MCG_MODE_PEE);\n  irq_restore(state);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "cpu_init"
      ],
      "called": [
        "kinetis_mcg_init_mcgirclk",
        "kinetis_mcg_init_erclk32k",
        "irq_disable",
        "irq_restore",
        "kinetis_mcg_set_safe_mode",
        "kinetis_mcg_set_mode"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "port": {
      "entrypoint": "0x00001d5e",
      "current_name": "port",
      "code": "\nPORT_Type * port(gpio_t pin)\n\n{\n  gpio_t pin_local;\n  \n  return (PORT_Type *)(pin \u0026 0x7000 | 0x40048000);\n}\n\n",
      "renaming": {},
      "calling": [
        "gpio_init_port",
        "gpio_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio": {
      "entrypoint": "0x00001d80",
      "current_name": "gpio",
      "code": "\nGPIO_Type * gpio(gpio_t pin)\n\n{\n  gpio_t pin_local;\n  \n  return (GPIO_Type *)(pin \u0026 0x1c0 | 0x400ff000);\n}\n\n",
      "renaming": {},
      "calling": [
        "gpio_set",
        "gpio_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "port_num": {
      "entrypoint": "0x00001da2",
      "current_name": "port_num",
      "code": "\nint port_num(gpio_t pin)\n\n{\n  gpio_t pin_local;\n  \n  return pin \u003e\u003e 6 \u0026 7;\n}\n\n",
      "renaming": {},
      "calling": [
        "gpio_init_port",
        "clk_en"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pin_num": {
      "entrypoint": "0x00001dc0",
      "current_name": "pin_num",
      "code": "\nint pin_num(gpio_t pin)\n\n{\n  gpio_t pin_local;\n  \n  return pin \u0026 0x3f;\n}\n\n",
      "renaming": {},
      "calling": [
        "gpio_init_port",
        "gpio_set",
        "gpio_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "clk_en": {
      "entrypoint": "0x00001ddc",
      "current_name": "clk_en",
      "code": "\nvoid clk_en(gpio_t pin)\n\n{\n  int iVar1;\n  gpio_t pin_local;\n  \n  iVar1 \u003d port_num(pin);\n  bit_set32((uint32_t *)\u0026DAT_40048038,(char)iVar1 + \u0027\\t\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gpio_init_port"
      ],
      "called": [
        "bit_set32",
        "port_num"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_ctx": {
      "entrypoint": "0x00001e0c",
      "current_name": "get_ctx",
      "code": "\nint get_ctx(int port,int pin)\n\n{\n  int pin_local;\n  int port_local;\n  \n  return isr_map[(pin \u003e\u003e 3) + port * 4] \u003e\u003e ((pin \u0026 7U) \u003c\u003c 2) \u0026 0xf;\n}\n\n",
      "renaming": {},
      "calling": [
        "irq_handler",
        "ctx_clear"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write_map": {
      "entrypoint": "0x00001e44",
      "current_name": "write_map",
      "code": "\nvoid write_map(int port,int pin,int ctx)\n\n{\n  int iVar1;\n  int ctx_local;\n  int pin_local;\n  int port_local;\n  \n  iVar1 \u003d pin \u003e\u003e 3;\n  isr_map[iVar1 + port * 4] \u003d isr_map[iVar1 + port * 4] \u0026 ~(0xf \u003c\u003c ((pin \u0026 7U) \u003c\u003c 2));\n  isr_map[iVar1 + port * 4] \u003d isr_map[iVar1 + port * 4] | ctx \u003c\u003c ((pin \u0026 7U) \u003c\u003c 2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "ctx_clear"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ctx_clear": {
      "entrypoint": "0x00001ec4",
      "current_name": "ctx_clear",
      "code": "\nvoid ctx_clear(int port,int pin)\n\n{\n  int ctx_00;\n  int pin_local;\n  int port_local;\n  int ctx;\n  \n  ctx_00 \u003d get_ctx(port,pin);\n  write_map(port,pin,ctx_00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "gpio_init_port"
      ],
      "called": [
        "get_ctx",
        "write_map"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio_init": {
      "entrypoint": "0x00001eea",
      "current_name": "gpio_init",
      "code": "\nint gpio_init(gpio_t pin,gpio_mode_t mode)\n\n{\n  uint uVar1;\n  GPIO_Type *pGVar2;\n  PORT_Type *pPVar3;\n  int iVar4;\n  gpio_mode_t mode_local;\n  gpio_t pin_local;\n  \n  gpio_init_port(pin,0);\n  if ((char)mode \u003c \u0027\\0\u0027) {\n    uVar1 \u003d pin_num(pin);\n    pGVar2 \u003d gpio(pin);\n    pGVar2-\u003ePDDR \u003d pGVar2-\u003ePDDR | 1 \u003c\u003c (uVar1 \u0026 0xff);\n  }\n  else {\n    uVar1 \u003d pin_num(pin);\n    pGVar2 \u003d gpio(pin);\n    pGVar2-\u003ePDDR \u003d pGVar2-\u003ePDDR \u0026 ~(1 \u003c\u003c (uVar1 \u0026 0xff));\n  }\n  pPVar3 \u003d port(pin);\n  iVar4 \u003d pin_num(pin);\n  pPVar3-\u003ePCR[iVar4] \u003d mode \u0026 0x23 | 0x100;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "board_init"
      ],
      "called": [
        "gpio_init_port",
        "port",
        "pin_num",
        "gpio"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio_init_port": {
      "entrypoint": "0x00001f80",
      "current_name": "gpio_init_port",
      "code": "\nvoid gpio_init_port(gpio_t pin,uint32_t pcr)\n\n{\n  PORT_Type *pPVar1;\n  int iVar2;\n  int pin_00;\n  uint uVar3;\n  uint32_t pcr_local;\n  gpio_t pin_local;\n  uint32_t isr_state;\n  \n  clk_en(pin);\n  pPVar1 \u003d port(pin);\n  iVar2 \u003d pin_num(pin);\n  uVar3 \u003d pPVar1-\u003ePCR[iVar2];\n  pPVar1 \u003d port(pin);\n  iVar2 \u003d pin_num(pin);\n  pPVar1-\u003ePCR[iVar2] \u003d pcr;\n  if ((uVar3 \u0026 0xf0000) !\u003d 0) {\n    iVar2 \u003d port_num(pin);\n    pin_00 \u003d pin_num(pin);\n    ctx_clear(iVar2,pin_00);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init_pins",
        "gpio_init"
      ],
      "called": [
        "port",
        "clk_en",
        "pin_num",
        "ctx_clear",
        "port_num"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gpio_set": {
      "entrypoint": "0x00001ff6",
      "current_name": "gpio_set",
      "code": "\nvoid gpio_set(gpio_t pin)\n\n{\n  uint uVar1;\n  GPIO_Type *pGVar2;\n  gpio_t pin_local;\n  \n  uVar1 \u003d pin_num(pin);\n  pGVar2 \u003d gpio(pin);\n  pGVar2-\u003ePSOR \u003d 1 \u003c\u003c (uVar1 \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "board_init"
      ],
      "called": [
        "pin_num",
        "gpio"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "irq_handler": {
      "entrypoint": "0x00002028",
      "current_name": "irq_handler",
      "code": "\nvoid irq_handler(PORT_Type *port,int port_num)\n\n{\n  int iVar1;\n  uint uVar2;\n  int port_num_local;\n  PORT_Type *port_local;\n  int ctx;\n  uint32_t status;\n  int i;\n  \n  uVar2 \u003d port-\u003eISFR;\n  for (i \u003d 0; i \u003c 0x20; i \u003d i + 1) {\n    if (((uVar2 \u0026 1 \u003c\u003c (i \u0026 0xffU)) !\u003d 0) \u0026\u0026 ((port-\u003ePCR[i] \u0026 0xf0000) !\u003d 0)) {\n      port-\u003eISFR \u003d 1 \u003c\u003c (i \u0026 0xffU);\n      iVar1 \u003d get_ctx(port_num,i);\n      (*isr_ctx[iVar1].cb)(isr_ctx[iVar1].arg);\n    }\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "isr_porta",
        "isr_portc",
        "isr_porte",
        "isr_portb",
        "isr_portd"
      ],
      "called": [
        "cortexm_isr_end",
        "get_ctx"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_porta": {
      "entrypoint": "0x000020b8",
      "current_name": "isr_porta",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid isr_porta(void)\n\n{\n  irq_handler((PORT_Type *)0x40049000,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "irq_handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_portb": {
      "entrypoint": "0x000020cc",
      "current_name": "isr_portb",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid isr_portb(void)\n\n{\n  irq_handler((PORT_Type *)0x4004a000,1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "irq_handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_portc": {
      "entrypoint": "0x000020e0",
      "current_name": "isr_portc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid isr_portc(void)\n\n{\n  irq_handler((PORT_Type *)0x4004b000,2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "irq_handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_portd": {
      "entrypoint": "0x000020f4",
      "current_name": "isr_portd",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid isr_portd(void)\n\n{\n  irq_handler((PORT_Type *)0x4004c000,3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "irq_handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_porte": {
      "entrypoint": "0x00002108",
      "current_name": "isr_porte",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid isr_porte(void)\n\n{\n  irq_handler((PORT_Type *)0x4004d000,4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "irq_handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ps": {
      "entrypoint": "0x0000211c",
      "current_name": "ps",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid ps(void)\n\n{\n  byte bVar1;\n  int iVar2;\n  void *pvVar3;\n  void *pvVar4;\n  uintptr_t uVar5;\n  thread_t *ptVar6;\n  char *pcVar7;\n  char queued_name [2];\n  int stacksz;\n  char *queued;\n  char *sname;\n  int state;\n  thread_t *p;\n  void *isr_sp;\n  void *isr_start;\n  int isr_usage;\n  kernel_pid_t i;\n  int overall_used;\n  int overall_stacksz;\n  \n  queued_name[0] \u003d \u0027_\u0027;\n  queued_name[1] \u003d \u0027Q\u0027;\n  overall_used \u003d 0;\n  iprintf(\"\\tpid | %-21s| %-9sQ | pri | stack  ( used) | base addr  | current     \\n\",\u0026DAT_000070b8,\n          \"state\");\n  iVar2 \u003d thread_isr_stack_usage();\n  pvVar3 \u003d thread_isr_stack_start();\n  pvVar4 \u003d thread_isr_stack_pointer();\n  iprintf(\"\\t  - | isr_stack            | -        - |   - | %6i (%5i) | %10p | %10p\\n\",0x200,iVar2,\n          pvVar3,pvVar4);\n  overall_stacksz \u003d 0x200;\n  if (0 \u003c iVar2) {\n    overall_used \u003d iVar2;\n  }\n  for (i \u003d 1; i \u003c 0x21; i \u003d i + 1) {\n    ptVar6 \u003d sched_threads[i];\n    if (ptVar6 !\u003d (thread_t *)0x0) {\n      bVar1 \u003d ptVar6-\u003estatus;\n      pcVar7 \u003d state_names[bVar1];\n      iVar2 \u003d ptVar6-\u003estack_size;\n      overall_stacksz \u003d iVar2 + overall_stacksz;\n      uVar5 \u003d thread_measure_stack_free(ptVar6-\u003estack_start);\n      iVar2 \u003d iVar2 - uVar5;\n      overall_used \u003d iVar2 + overall_used;\n      iprintf(\"\\t%3hi | %-20s | %-8s %.1s | %3i | %6i (%5i) | %10p | %10p \\n\",(int)ptVar6-\u003epid,\n              ptVar6-\u003ename,pcVar7,queued_name + (8 \u003c bVar1),(uint)ptVar6-\u003epriority,\n              ptVar6-\u003estack_size,iVar2,ptVar6-\u003estack_start,ptVar6-\u003esp);\n    }\n  }\n  iprintf(\"\\t%5s %-21s|%13s%6s %6i (%5i)\\n\",\u0026DAT_00007190,\u0026DAT_00007194,\u0026DAT_00007190,\u0026DAT_00007190,\n          overall_stacksz,overall_used);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_ps_handler",
        "core_panic"
      ],
      "called": [
        "thread_isr_stack_pointer",
        "thread_isr_stack_start",
        "iprintf",
        "thread_measure_stack_free",
        "thread_isr_stack_usage"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "tsrb_empty": {
      "entrypoint": "0x00002270",
      "current_name": "tsrb_empty",
      "code": "\nint tsrb_empty(tsrb_t *rb)\n\n{\n  byte bVar1;\n  uint uVar2;\n  bool bVar3;\n  tsrb_t *rb_local;\n  \n  uVar2 \u003d rb-\u003ewrites;\n  bVar3 \u003d rb-\u003ereads \u003d\u003d uVar2;\n  if (bVar3) {\n    uVar2 \u003d 1;\n  }\n  bVar1 \u003d (byte)uVar2;\n  if (!bVar3) {\n    bVar1 \u003d 0;\n  }\n  return (uint)bVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "tsrb_get"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "tsrb_full": {
      "entrypoint": "0x00002294",
      "current_name": "tsrb_full",
      "code": "\nint tsrb_full(tsrb_t *rb)\n\n{\n  byte bVar1;\n  uint uVar2;\n  bool bVar3;\n  tsrb_t *rb_local;\n  \n  uVar2 \u003d rb-\u003esize;\n  bVar3 \u003d rb-\u003ewrites - rb-\u003ereads \u003d\u003d uVar2;\n  if (bVar3) {\n    uVar2 \u003d 1;\n  }\n  bVar1 \u003d (byte)uVar2;\n  if (!bVar3) {\n    bVar1 \u003d 0;\n  }\n  return (uint)bVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "tsrb_add_one"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_push": {
      "entrypoint": "0x000022be",
      "current_name": "_push",
      "code": "\nvoid _push(tsrb_t *rb,char c)\n\n{\n  uint uVar1;\n  char c_local;\n  tsrb_t *rb_local;\n  \n  uVar1 \u003d rb-\u003ewrites;\n  rb-\u003ewrites \u003d uVar1 + 1;\n  rb-\u003ebuf[uVar1 \u0026 rb-\u003esize - 1] \u003d c;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "tsrb_add_one"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_pop": {
      "entrypoint": "0x000022f0",
      "current_name": "_pop",
      "code": "\nchar _pop(tsrb_t *rb)\n\n{\n  uint uVar1;\n  tsrb_t *rb_local;\n  \n  uVar1 \u003d rb-\u003ereads;\n  rb-\u003ereads \u003d uVar1 + 1;\n  return rb-\u003ebuf[uVar1 \u0026 rb-\u003esize - 1];\n}\n\n",
      "renaming": {},
      "calling": [
        "tsrb_get"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "tsrb_get": {
      "entrypoint": "0x0000231c",
      "current_name": "tsrb_get",
      "code": "\nint tsrb_get(tsrb_t *rb,char *dst,size_t n)\n\n{\n  char cVar1;\n  int iVar2;\n  size_t n_local;\n  char *dst_local;\n  tsrb_t *rb_local;\n  size_t tmp;\n  \n  dst_local \u003d dst;\n  tmp \u003d n;\n  while ((tmp !\u003d 0 \u0026\u0026 (iVar2 \u003d tsrb_empty(rb), iVar2 \u003d\u003d 0))) {\n    cVar1 \u003d _pop(rb);\n    *dst_local \u003d cVar1;\n    tmp \u003d tmp - 1;\n    dst_local \u003d dst_local + 1;\n  }\n  return n - tmp;\n}\n\n",
      "renaming": {},
      "calling": [
        "isrpipe_read"
      ],
      "called": [
        "tsrb_empty",
        "_pop"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "tsrb_add_one": {
      "entrypoint": "0x00002364",
      "current_name": "tsrb_add_one",
      "code": "\nint tsrb_add_one(tsrb_t *rb,char c)\n\n{\n  int iVar1;\n  char c_local;\n  tsrb_t *rb_local;\n  \n  iVar1 \u003d tsrb_full(rb);\n  if (iVar1 \u003d\u003d 0) {\n    _push(rb,c);\n    iVar1 \u003d 0;\n  }\n  else {\n    iVar1 \u003d -1;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "isrpipe_write_one"
      ],
      "called": [
        "_push",
        "tsrb_full"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "periph_init": {
      "entrypoint": "0x00002396",
      "current_name": "periph_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid periph_init(void)\n\n{\n  rtc_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "cpu_init"
      ],
      "called": [
        "rtc_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main": {
      "entrypoint": "0x000023a4",
      "current_name": "main",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint main(void)\n\n{\n  char line_buf [128];\n  \n  startForkserver(0);\n  puts(\"Welcome to RIOT!\");\n                    \n  shell_run((shell_command_t *)0x0,line_buf,0x80);\n}\n\n",
      "renaming": {},
      "calling": [
        "main_trampoline"
      ],
      "called": [
        "startForkserver",
        "shell_run",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "aflCall": {
      "entrypoint": "0x000023c8",
      "current_name": "aflCall",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
      "renaming": {},
      "calling": [
        "startForkserver"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "startForkserver": {
      "entrypoint": "0x000023d0",
      "current_name": "startForkserver",
      "code": "\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  int ticks_local;\n  \n  if (noHyperCall \u003d\u003d 0) {\n    uVar1 \u003d aflCall(1,ticks,0);\n  }\n  else {\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "aflCall"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "auto_init": {
      "entrypoint": "0x00002400",
      "current_name": "auto_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid auto_init(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main_trampoline"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "list_remove_head": {
      "entrypoint": "0x0000240c",
      "current_name": "list_remove_head",
      "code": "\nlist_node_t * list_remove_head(list_node_t *list)\n\n{\n  list_node *plVar1;\n  list_node_t *list_local;\n  list_node_t *head;\n  \n  plVar1 \u003d list-\u003enext;\n  if (plVar1 !\u003d (list_node *)0x0) {\n    list-\u003enext \u003d plVar1-\u003enext;\n  }\n  return plVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "mutex_unlock"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_mutex_lock": {
      "entrypoint": "0x00002434",
      "current_name": "_mutex_lock",
      "code": "\nint _mutex_lock(mutex_t *mutex,int blocking)\n\n{\n  thread_t *thread;\n  uint state;\n  int iVar1;\n  int blocking_local;\n  mutex_t *mutex_local;\n  uint irqstate;\n  thread_t *me;\n  \n  state \u003d irq_disable();\n  thread \u003d sched_active_thread;\n  if ((mutex-\u003equeue).next \u003d\u003d (list_node *)0x0) {\n    (mutex-\u003equeue).next \u003d (list_node *)0xffffffff;\n    irq_restore(state);\n    iVar1 \u003d 1;\n  }\n  else if (blocking \u003d\u003d 0) {\n    irq_restore(state);\n    iVar1 \u003d 0;\n  }\n  else {\n    sched_set_status(sched_active_thread,2);\n    if ((mutex-\u003equeue).next \u003d\u003d (list_node *)0xffffffff) {\n      (mutex-\u003equeue).next \u003d \u0026thread-\u003erq_entry;\n      ((mutex-\u003equeue).next)-\u003enext \u003d (list_node *)0x0;\n    }\n    else {\n      thread_add_to_list(\u0026mutex-\u003equeue,thread);\n    }\n    irq_restore(state);\n    thread_yield_higher();\n    iVar1 \u003d 1;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "mutex_lock"
      ],
      "called": [
        "irq_disable",
        "thread_yield_higher",
        "sched_set_status",
        "irq_restore",
        "thread_add_to_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mutex_unlock": {
      "entrypoint": "0x000024bc",
      "current_name": "mutex_unlock",
      "code": "\nvoid mutex_unlock(mutex_t *mutex)\n\n{\n  byte bVar1;\n  uint state;\n  list_node_t *plVar2;\n  mutex_t *mutex_local;\n  uint16_t process_priority;\n  uint irqstate;\n  clist_node_t *__m____;\n  list_node_t *next;\n  thread_t *process;\n  \n  state \u003d irq_disable();\n  if ((mutex-\u003equeue).next \u003d\u003d (list_node *)0x0) {\n    irq_restore(state);\n  }\n  else if ((mutex-\u003equeue).next \u003d\u003d (list_node *)0xffffffff) {\n    (mutex-\u003equeue).next \u003d (list_node *)0x0;\n    irq_restore(state);\n  }\n  else {\n    plVar2 \u003d list_remove_head(\u0026mutex-\u003equeue);\n    sched_set_status((thread_t *)(plVar2 + -2),10);\n    if ((mutex-\u003equeue).next \u003d\u003d (list_node *)0x0) {\n      (mutex-\u003equeue).next \u003d (list_node *)0xffffffff;\n    }\n    bVar1 \u003d *(byte *)((int)\u0026plVar2[-1].next + 1);\n    irq_restore(state);\n    sched_switch((ushort)bVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "isrpipe_write_one"
      ],
      "called": [
        "list_remove_head",
        "sched_switch",
        "irq_disable",
        "sched_set_status",
        "irq_restore"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_SetPriority": {
      "entrypoint": "0x00002744",
      "current_name": "NVIC_SetPriority",
      "code": "\nvoid NVIC_SetPriority(IRQn_Type IRQn,uint32_t priority)\n\n{\n  uint32_t priority_local;\n  IRQn_Type IRQn_local;\n  \n  if (IRQn \u003c DMA0_IRQn) {\n    (\u0026DAT_e000ed14)[(byte)IRQn \u0026 0xf] \u003d (char)((priority \u0026 0xff) \u003c\u003c 4);\n  }\n  else {\n    *(char *)(IRQn + -0x1fff1c00) \u003d (char)((priority \u0026 0xff) \u003c\u003c 4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtt_set_alarm"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cortexm_init": {
      "entrypoint": "0x0000258c",
      "current_name": "cortexm_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid cortexm_init(void)\n\n{\n  uint i;\n  \n  _DAT_e000ed08 \u003d 0;\n  NVIC_SetPriority(PendSV_IRQn,1);\n  NVIC_SetPriority(SVCall_IRQn,1);\n  for (i \u003d 0; i \u003c 0x66; i \u003d i + 1) {\n    NVIC_SetPriority((IRQn_Type)i,1);\n  }\n  _DAT_e000ed10 \u003d _DAT_e000ed10 | 0x10;\n  _DAT_e000ed14 \u003d _DAT_e000ed14 | 0x200;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "cpu_init"
      ],
      "called": [
        "NVIC_SetPriority"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_init": {
      "entrypoint": "0x000025f4",
      "current_name": "rtc_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid rtc_init(void)\n\n{\n  rtt_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "periph_init"
      ],
      "called": [
        "rtt_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_set_time": {
      "entrypoint": "0x00002600",
      "current_name": "rtc_set_time",
      "code": "\nint rtc_set_time(tm *time)\n\n{\n  uint32_t counter;\n  tm *time_local;\n  time_t t;\n  \n  counter \u003d mktime((tm *)time);\n  rtt_set_counter(counter);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_settime"
      ],
      "called": [
        "rtt_set_counter",
        "mktime"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_get_time": {
      "entrypoint": "0x00002624",
      "current_name": "rtc_get_time",
      "code": "\nint rtc_get_time(tm *time)\n\n{\n  tm *time_local;\n  time_t t;\n  \n  t._0_4_ \u003d rtt_get_counter();\n  t._4_4_ \u003d 0;\n  gmtime_r((time_t *)\u0026t,(tm *)time);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_gettime"
      ],
      "called": [
        "gmtime_r",
        "rtt_get_counter"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_set_alarm": {
      "entrypoint": "0x00002654",
      "current_name": "rtc_set_alarm",
      "code": "\nint rtc_set_alarm(tm *time,rtc_alarm_cb_t cb,void *arg)\n\n{\n  uint32_t alarm;\n  void *arg_local;\n  rtc_alarm_cb_t cb_local;\n  tm *time_local;\n  time_t t;\n  \n  alarm \u003d mktime((tm *)time);\n  rtc_callback.cb \u003d cb;\n  rtt_set_alarm(alarm,rtc_cb + 1,arg);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_setalarm"
      ],
      "called": [
        "rtt_set_alarm",
        "mktime"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_get_alarm": {
      "entrypoint": "0x00002690",
      "current_name": "rtc_get_alarm",
      "code": "\nint rtc_get_alarm(tm *time)\n\n{\n  tm *time_local;\n  time_t t;\n  \n  t._0_4_ \u003d rtt_get_alarm();\n  t._4_4_ \u003d 0;\n  gmtime_r((time_t *)\u0026t,(tm *)time);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_getalarm"
      ],
      "called": [
        "gmtime_r",
        "rtt_get_alarm"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_clear_alarm": {
      "entrypoint": "0x000026c0",
      "current_name": "rtc_clear_alarm",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid rtc_clear_alarm(void)\n\n{\n  rtt_clear_alarm();\n  rtc_callback.cb \u003d (rtc_alarm_cb_t)0x0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_handler"
      ],
      "called": [
        "rtt_clear_alarm"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_poweron": {
      "entrypoint": "0x000026d8",
      "current_name": "rtc_poweron",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid rtc_poweron(void)\n\n{\n  rtt_poweron();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_handler"
      ],
      "called": [
        "rtt_poweron"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_poweroff": {
      "entrypoint": "0x000026e4",
      "current_name": "rtc_poweroff",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid rtc_poweroff(void)\n\n{\n  rtt_poweroff();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_handler"
      ],
      "called": [
        "rtt_poweroff"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtc_cb": {
      "entrypoint": "0x000026f0",
      "current_name": "rtc_cb",
      "code": "\nvoid rtc_cb(void *arg)\n\n{\n  void *arg_local;\n  \n  if (rtc_callback.cb !\u003d (rtc_alarm_cb_t)0x0) {\n    (*rtc_callback.cb)(arg);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtt_init": {
      "entrypoint": "0x000027b0",
      "current_name": "rtt_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid rtt_init(void)\n\n{\n  RTC_Type *rtt;\n  \n  _DAT_4004803c \u003d _DAT_4004803c | 0x20000000;\n  if ((_DAT_4003d014 \u0026 1) !\u003d 0) {\n    _DAT_4003d000 \u003d 0;\n  }\n  _DAT_4003d010 \u003d 0x104;\n  _DAT_4003d008 \u003d 0xffffff42;\n  _DAT_4003d01c \u003d 0;\n  rtt_poweron();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_init"
      ],
      "called": [
        "rtt_poweron"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtt_get_counter": {
      "entrypoint": "0x0000281c",
      "current_name": "rtt_get_counter",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00002840) */\n/* WARNING: Removing unreachable block (ram,0x0000284c) */\n\n/* WARNING: Unknown calling convention */\n\nuint32_t rtt_get_counter(void)\n\n{\n  RTC_Type *rtt;\n  int i;\n  uint32_t t;\n  \n  return _DAT_4003d000;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_get_time"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtt_set_counter": {
      "entrypoint": "0x0000285c",
      "current_name": "rtt_set_counter",
      "code": "\n\n\nvoid rtt_set_counter(uint32_t counter)\n\n{\n  uint32_t counter_local;\n  RTC_Type *rtt;\n  \n  _DAT_4003d000 \u003d counter;\n  _DAT_4003d014 \u003d _DAT_4003d014 \u0026 0xffffffef | 0x10;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_set_time"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtt_set_alarm": {
      "entrypoint": "0x00002894",
      "current_name": "rtt_set_alarm",
      "code": "\n\n\nvoid rtt_set_alarm(uint32_t alarm,rtt_cb_t cb,void *arg)\n\n{\n  void *arg_local;\n  rtt_cb_t cb_local;\n  uint32_t alarm_local;\n  RTC_Type *rtt;\n  \n  _DAT_4003d008 \u003d alarm - 1;\n  _DAT_4003d01c \u003d _DAT_4003d01c \u0026 0xfffffffb | 4;\n  rtt_callback.alarm_cb \u003d cb;\n  rtt_callback.alarm_arg \u003d arg;\n  NVIC_SetPriority(RTC_IRQn,10);\n  NVIC_EnableIRQ(RTC_IRQn);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_set_alarm"
      ],
      "called": [
        "NVIC_EnableIRQ",
        "NVIC_SetPriority"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtt_get_alarm": {
      "entrypoint": "0x000028f0",
      "current_name": "rtt_get_alarm",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t rtt_get_alarm(void)\n\n{\n  RTC_Type *rtt;\n  \n  return _DAT_4003d008 + 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_get_alarm"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtt_clear_alarm": {
      "entrypoint": "0x00002910",
      "current_name": "rtt_clear_alarm",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid rtt_clear_alarm(void)\n\n{\n  RTC_Type *rtt;\n  \n  _DAT_4003d01c \u003d _DAT_4003d01c \u0026 0xfffffffb;\n  _DAT_4003d008 \u003d 0;\n  rtt_callback.alarm_cb \u003d (rtt_cb_t)0x0;\n  rtt_callback.alarm_arg \u003d (void *)0x0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_clear_alarm"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtt_poweron": {
      "entrypoint": "0x0000294c",
      "current_name": "rtt_poweron",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid rtt_poweron(void)\n\n{\n  RTC_Type *rtt;\n  \n  _DAT_4003d014 \u003d _DAT_4003d014 | 0x10;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtt_init",
        "rtc_poweron"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rtt_poweroff": {
      "entrypoint": "0x00002970",
      "current_name": "rtt_poweroff",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid rtt_poweroff(void)\n\n{\n  RTC_Type *rtt;\n  \n  _DAT_4003d014 \u003d _DAT_4003d014 \u0026 0xffffffef;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_poweroff"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isr_rtc": {
      "entrypoint": "0x00002994",
      "current_name": "isr_rtc",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid isr_rtc(void)\n\n{\n  RTC_Type *rtt;\n  \n  if (((_DAT_4003d014 \u0026 4) !\u003d 0) \u0026\u0026 (rtt_callback.alarm_cb !\u003d (rtt_cb_t)0x0)) {\n    _DAT_4003d01c \u003d _DAT_4003d01c \u0026 0xfffffffb;\n    (*rtt_callback.alarm_cb)(rtt_callback.alarm_arg);\n  }\n  if (((_DAT_4003d014 \u0026 2) !\u003d 0) \u0026\u0026 (rtt_callback.overflow_cb !\u003d (rtt_cb_t)0x0)) {\n    (*rtt_callback.overflow_cb)(rtt_callback.overflow_arg);\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "cortexm_isr_end"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_putchar": {
      "entrypoint": "0x00002a00",
      "current_name": "_putchar",
      "code": "\nvoid _putchar(int c)\n\n{\n  int c_local;\n  \n  putchar(c);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "print_prompt",
        "readline"
      ],
      "called": [
        "putchar"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "find_handler": {
      "entrypoint": "0x00002a18",
      "current_name": "find_handler",
      "code": "\nshell_command_handler_t find_handler(shell_command_t *command_list,char *command)\n\n{\n  int iVar1;\n  char *command_local;\n  shell_command_t *command_list_local;\n  shell_command_t *command_lists [2];\n  uint i;\n  shell_command_t *entry;\n  \n  command_lists[0] \u003d command_list;\n  command_lists[1] \u003d (shell_command_t *)\u0026_shell_command_list;\n  i \u003d 0;\n  do {\n    if (1 \u003c i) {\n      return (shell_command_handler_t)0x0;\n    }\n    entry \u003d command_lists[i];\n    if (entry !\u003d (shell_command_t *)0x0) {\n      for (; entry-\u003ename !\u003d (char *)0x0; entry \u003d entry + 1) {\n        iVar1 \u003d strcmp(entry-\u003ename,command);\n        if (iVar1 \u003d\u003d 0) {\n          return entry-\u003ehandler;\n        }\n      }\n    }\n    i \u003d i + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "handle_input_line"
      ],
      "called": [
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print_help": {
      "entrypoint": "0x00002a88",
      "current_name": "print_help",
      "code": "\nvoid print_help(shell_command_t *command_list)\n\n{\n  shell_command_t *command_list_local;\n  shell_command_t *command_lists [2];\n  uint i;\n  shell_command_t *entry;\n  \n  iprintf(\"%-20s %s\\n\",\"Command\",\"Description\");\n  puts(\"---------------------------------------\");\n  command_lists[0] \u003d command_list;\n  command_lists[1] \u003d (shell_command_t *)\u0026_shell_command_list;\n  for (i \u003d 0; i \u003c 2; i \u003d i + 1) {\n    entry \u003d command_lists[i];\n    if (entry !\u003d (shell_command_t *)0x0) {\n      for (; entry-\u003ename !\u003d (char *)0x0; entry \u003d entry + 1) {\n        iprintf(\"%-20s %s\\n\",entry-\u003ename,entry-\u003edesc);\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "handle_input_line"
      ],
      "called": [
        "iprintf",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "handle_input_line": {
      "entrypoint": "0x00002b10",
      "current_name": "handle_input_line",
      "code": "\nvoid handle_input_line(shell_command_t *command_list,char *line)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *line_local;\n  shell_command_t *command_list_local;\n  shell_command_handler_t handler;\n  char___0_ *argv;\n  uint local_34;\n  char quote_char;\n  char *d;\n  char *c;\n  char **arg;\n  uint i;\n  int contains_esc_seq;\n  uint argc;\n  char *pos;\n  \n  argc \u003d 0;\n  contains_esc_seq \u003d 0;\n  pos \u003d line;\n  while( true ) {\n    line_local \u003d line;\n    command_list_local \u003d command_list;\n    if (0x20 \u003c (byte)*pos) {\n      if ((*pos \u003d\u003d \u0027\\\"\u0027) || (*pos \u003d\u003d \u0027\\\u0027\u0027)) {\n        quote_char \u003d *pos;\n        do {\n          pcVar2 \u003d pos + 1;\n          if (*pcVar2 \u003d\u003d \u0027\\0\u0027) {\n            pos \u003d pcVar2;\n            puts(handle_input_line::INCORRECT_QUOTING);\n            return;\n          }\n          if (*pcVar2 \u003d\u003d \u0027\\\\\u0027) {\n            contains_esc_seq \u003d contains_esc_seq + 1;\n            pos \u003d pos + 2;\n            pcVar2 \u003d pos;\n            if (*pos \u003d\u003d \u0027\\0\u0027) {\n              puts(handle_input_line::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          pos \u003d pcVar2;\n        } while (quote_char !\u003d *pos);\n        if (0x20 \u003c (byte)pos[1]) {\n          puts(handle_input_line::INCORRECT_QUOTING);\n          return;\n        }\n      }\n      else {\n        do {\n          if (*pos \u003d\u003d \u0027\\\\\u0027) {\n            contains_esc_seq \u003d contains_esc_seq + 1;\n            pos \u003d pos + 1;\n            if (*pos \u003d\u003d \u0027\\0\u0027) {\n              puts(handle_input_line::INCORRECT_QUOTING);\n              return;\n            }\n          }\n          pos \u003d pos + 1;\n          if (*pos \u003d\u003d 0x22) {\n            puts(handle_input_line::INCORRECT_QUOTING);\n            return;\n          }\n        } while (0x20 \u003c (byte)*pos);\n      }\n      argc \u003d argc + 1;\n    }\n    if (*pos \u003d\u003d \u0027\\0\u0027) break;\n    *pos \u003d \u0027\\0\u0027;\n    pos \u003d pos + 1;\n  }\n  if (argc !\u003d 0) {\n    local_34 \u003d argc;\n    argv \u003d (char___0_ *)((int)\u0026line_local - ((argc + 1) * 4 + 7 \u0026 0xfffffff8));\n    *(char **)((int)argv + argc * 4) \u003d (char *)0x0;\n    pos \u003d line;\n    for (i \u003d 0; arg \u003d (char **)argv, i \u003c argc; i \u003d i + 1) {\n      for (; *pos \u003d\u003d \u0027\\0\u0027; pos \u003d pos + 1) {\n      }\n      if ((*pos \u003d\u003d \u0027\\\"\u0027) || (*pos \u003d\u003d \u0027\\\u0027\u0027)) {\n        pos \u003d pos + 1;\n      }\n      *(char **)((int)argv + i * 4) \u003d pos;\n      for (; *pos !\u003d \u0027\\0\u0027; pos \u003d pos + 1) {\n      }\n    }\n    for (; (contains_esc_seq !\u003d 0 \u0026\u0026 (*arg !\u003d (char *)0x0)); arg \u003d arg + 1) {\n      for (c \u003d *arg; *c !\u003d \u0027\\0\u0027; c \u003d c + 1) {\n        if (*c \u003d\u003d \u0027\\\\\u0027) {\n          for (d \u003d c; *d !\u003d \u0027\\0\u0027; d \u003d d + 1) {\n            *d \u003d d[1];\n          }\n          contains_esc_seq \u003d contains_esc_seq + -1;\n          if (contains_esc_seq \u003d\u003d 0) break;\n        }\n      }\n    }\n    handler \u003d find_handler(command_list,*(char **)argv);\n    if (handler \u003d\u003d (shell_command_handler_t)0x0) {\n      iVar1 \u003d strcmp(\"help\",*(char **)argv);\n      if (iVar1 \u003d\u003d 0) {\n        print_help(command_list_local);\n      }\n      else {\n        iprintf(\"shell: command not found: %s\\n\",*(undefined4 *)argv);\n      }\n    }\n    else {\n      (*handler)(argc,(char **)argv);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "shell_run"
      ],
      "called": [
        "find_handler",
        "strcmp",
        "iprintf",
        "puts",
        "print_help"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "readline": {
      "entrypoint": "0x00002d94",
      "current_name": "readline",
      "code": "\nint readline(char *buf,size_t size)\n\n{\n  int c_00;\n  byte bVar1;\n  bool bVar2;\n  size_t size_local;\n  char *buf_local;\n  int c;\n  char *line_buf_ptr;\n  \n  line_buf_ptr \u003d buf;\n  while( true ) {\n    if ((int)(size - 1) \u003c\u003d (int)line_buf_ptr - (int)buf) {\n      return -1;\n    }\n    c_00 \u003d getchar();\n    if (c_00 \u003c 0) break;\n    if ((c_00 \u003d\u003d 0xd) || (c_00 \u003d\u003d 10)) {\n      *line_buf_ptr \u003d \u0027\\0\u0027;\n      _putchar(0xd);\n      _putchar(10);\n      bVar2 \u003d line_buf_ptr \u003d\u003d buf;\n      if (bVar2) {\n        buf \u003d (char *)0x1;\n      }\n      bVar1 \u003d (byte)buf;\n      if (!bVar2) {\n        bVar1 \u003d 0;\n      }\n      return (uint)bVar1;\n    }\n    if ((c_00 \u003d\u003d 8) || (c_00 \u003d\u003d 0x7f)) {\n      if (line_buf_ptr !\u003d buf) {\n        line_buf_ptr \u003d line_buf_ptr + -1;\n        *line_buf_ptr \u003d \u0027\\0\u0027;\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *line_buf_ptr \u003d (char)c_00;\n      _putchar(c_00);\n      line_buf_ptr \u003d line_buf_ptr + 1;\n    }\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "shell_run"
      ],
      "called": [
        "_putchar",
        "getchar"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print_prompt": {
      "entrypoint": "0x00002e48",
      "current_name": "print_prompt",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid print_prompt(void)\n\n{\n  _putchar(0x3e);\n  _putchar(0x20);\n  fflush(*(FILE **)(_impure_ptr + 8));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "shell_run"
      ],
      "called": [
        "fflush",
        "_putchar"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "shell_run": {
      "entrypoint": "0x00002e6c",
      "current_name": "shell_run",
      "code": "\nvoid shell_run(shell_command_t *shell_commands,char *line_buf,int len)\n\n{\n  int iVar1;\n  int len_local;\n  char *line_buf_local;\n  shell_command_t *shell_commands_local;\n  int res;\n  \n  print_prompt();\n  do {\n    iVar1 \u003d readline(line_buf,len);\n    if (iVar1 \u003d\u003d 0) {\n      handle_input_line(shell_commands,line_buf);\n    }\n    print_prompt();\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "print_prompt",
        "handle_input_line",
        "readline"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_reboot_handler": {
      "entrypoint": "0x00002e9c",
      "current_name": "_reboot_handler",
      "code": "\nint _reboot_handler(int argc,char **argv)\n\n{\n  char **argv_local;\n  int argc_local;\n  \n  pm_reboot();\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "pm_reboot"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_ps_handler": {
      "entrypoint": "0x00002eb4",
      "current_name": "_ps_handler",
      "code": "\nint _ps_handler(int argc,char **argv)\n\n{\n  char **argv_local;\n  int argc_local;\n  \n  ps();\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "ps"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "probe": {
      "entrypoint": "0x00002ecc",
      "current_name": "probe",
      "code": "\nvoid probe(int num,saul_reg_t *dev)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  saul_reg_t *dev_local;\n  int num_local;\n  phydat_t res;\n  int dim;\n  \n  iVar1 \u003d saul_reg_read(dev,\u0026res);\n  if (iVar1 \u003c 1) {\n    iprintf(\"error: failed to read from device #%i\\n\",num);\n  }\n  else {\n    pcVar3 \u003d dev-\u003ename;\n    pcVar2 \u003d saul_class_to_str(dev-\u003edriver-\u003etype);\n    iprintf(\"Reading from #%i (%s|%s)\\n\",num,pcVar3,pcVar2);\n    phydat_dump(\u0026res,(uint8_t)iVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "read",
        "probe_all"
      ],
      "called": [
        "saul_reg_read",
        "phydat_dump",
        "saul_class_to_str",
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "probe_all": {
      "entrypoint": "0x00002f30",
      "current_name": "probe_all",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid probe_all(void)\n\n{\n  int i;\n  saul_reg_t *dev;\n  \n  i \u003d 0;\n  for (dev \u003d saul_reg; dev !\u003d (saul_reg_t *)0x0; dev \u003d dev-\u003enext) {\n    probe(i,dev);\n    puts(\"\");\n    i \u003d i + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "read"
      ],
      "called": [
        "probe",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "list": {
      "entrypoint": "0x00002f74",
      "current_name": "list",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid list(void)\n\n{\n  char *pcVar1;\n  int i;\n  saul_reg_t *dev;\n  \n  dev \u003d saul_reg;\n  i \u003d 0;\n  if (saul_reg \u003d\u003d (saul_reg_t *)0x0) {\n    puts(\"No devices found\");\n  }\n  else {\n    puts(\"ID\\tClass\\t\\tName\");\n  }\n  for (; dev !\u003d (saul_reg_t *)0x0; dev \u003d dev-\u003enext) {\n    pcVar1 \u003d saul_class_to_str(dev-\u003edriver-\u003etype);\n    iprintf(\"#%i\\t%s\\t%s\\n\",i,pcVar1,dev-\u003ename);\n    i \u003d i + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_saul"
      ],
      "called": [
        "saul_class_to_str",
        "iprintf",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read": {
      "entrypoint": "0x00002fe0",
      "current_name": "read",
      "code": "\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t pos;\n  saul_reg_t *dev_00;\n  char **argv_local;\n  int argc_local;\n  saul_reg_t *dev;\n  int num;\n  \n  if (__fd \u003c 3) {\n                    /* WARNING: Load size is inaccurate */\n    pos \u003d iprintf(\"usage: %s %s \u003cdevice id\u003e|all\\n\",*__buf,*(undefined4 *)((int)__buf + 4));\n  }\n  else {\n    pos \u003d strcmp(*(char **)((int)__buf + 8),\"all\");\n    if (pos \u003d\u003d 0) {\n      probe_all();\n    }\n    else {\n      pos \u003d atoi(*(char **)((int)__buf + 8));\n      dev_00 \u003d saul_reg_find_nth(pos);\n      if (dev_00 \u003d\u003d (saul_reg_t *)0x0) {\n        pos \u003d puts(\"error: undefined device id given\");\n      }\n      else {\n        probe(pos,dev_00);\n      }\n    }\n  }\n  return pos;\n}\n\n",
      "renaming": {},
      "calling": [
        "_saul"
      ],
      "called": [
        "strcmp",
        "iprintf",
        "probe",
        "saul_reg_find_nth",
        "atoi",
        "puts",
        "probe_all"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write": {
      "entrypoint": "0x0000305c",
      "current_name": "write",
      "code": "\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  int iVar2;\n  char **argv_local;\n  int argc_local;\n  phydat_t data;\n  int dim;\n  saul_reg_t *dev;\n  int num;\n  int i;\n  \n  if (__fd \u003c 4) {\n                    /* WARNING: Load size is inaccurate */\n    sVar1 \u003d iprintf(\"usage: %s %s \u003cdevice id\u003e \u003cvalue 0\u003e [\u003cvalue 1\u003e [\u003cvalue 2]]\\n\",*__buf,\n                    *(undefined4 *)((int)__buf + 4));\n  }\n  else {\n    num \u003d atoi(*(char **)((int)__buf + 8));\n    dev \u003d saul_reg_find_nth(num);\n    if (dev \u003d\u003d (saul_reg_t *)0x0) {\n      sVar1 \u003d puts(\"error: undefined device given\");\n    }\n    else {\n      memset(\u0026data,0,8);\n      if (5 \u003c __fd) {\n        __fd \u003d 6;\n      }\n      dim \u003d __fd + -3;\n      for (i \u003d 0; i \u003c dim; i \u003d i + 1) {\n        iVar2 \u003d atoi(*(char **)((i + 3) * 4 + (int)__buf));\n        data.val[i] \u003d (int16_t)iVar2;\n      }\n      iprintf(\"Writing to device #%i - %s\\n\",num,dev-\u003ename);\n      phydat_dump(\u0026data,(uint8_t)dim);\n      iVar2 \u003d saul_reg_write(dev,\u0026data);\n      if (iVar2 \u003c 1) {\n        if (iVar2 \u003d\u003d -0x86) {\n          sVar1 \u003d iprintf(\"error: device #%i is not writable\\n\",num);\n        }\n        else {\n          sVar1 \u003d iprintf(\"error: failure to write to device #%i\\n\",num);\n        }\n      }\n      else {\n        sVar1 \u003d iprintf(\"data successfully written to device #%i\\n\",num);\n      }\n    }\n  }\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_saul"
      ],
      "called": [
        "phydat_dump",
        "iprintf",
        "saul_reg_write",
        "memset",
        "saul_reg_find_nth",
        "atoi",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_saul": {
      "entrypoint": "0x0000316c",
      "current_name": "_saul",
      "code": "\nint _saul(int argc,char **argv)\n\n{\n  int iVar1;\n  size_t in_r2;\n  char **argv_local;\n  int argc_local;\n  \n  if (argc \u003c 2) {\n    list();\n  }\n  else {\n    iVar1 \u003d strcmp(argv[1],\"read\");\n    if (iVar1 \u003d\u003d 0) {\n      read(argc,argv,in_r2);\n    }\n    else {\n      iVar1 \u003d strcmp(argv[1],\"write\");\n      if (iVar1 \u003d\u003d 0) {\n        write(argc,argv,in_r2);\n      }\n      else {\n        iprintf(\"usage: %s read|write\\n\",*argv);\n      }\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "list",
        "strcmp",
        "iprintf",
        "read",
        "write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_alarm_handler": {
      "entrypoint": "0x000031e0",
      "current_name": "_alarm_handler",
      "code": "\nvoid _alarm_handler(void *arg)\n\n{\n  void *arg_local;\n  \n  puts(\"The alarm rang\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dow": {
      "entrypoint": "0x000031fc",
      "current_name": "dow",
      "code": "\nint dow(int year,int month,int day)\n\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  int day_local;\n  int month_local;\n  int year_local;\n  \n  iVar2 \u003d month;\n  if (month \u003c 3) {\n    iVar2 \u003d 1;\n  }\n  bVar1 \u003d (byte)iVar2;\n  if (2 \u003c month) {\n    bVar1 \u003d 0;\n  }\n  iVar3 \u003d year - (uint)bVar1;\n  iVar2 \u003d iVar3;\n  if (iVar3 \u003c 0) {\n    iVar2 \u003d iVar3 + 3;\n  }\n  return ((((iVar2 \u003e\u003e 2) + iVar3) - iVar3 / 100) + iVar3 / 400 + dow::t[month + -1] + day) % 7;\n}\n\n",
      "renaming": {},
      "calling": [
        "_parse_time"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_parse_time": {
      "entrypoint": "0x0000328c",
      "current_name": "_parse_time",
      "code": "\nint _parse_time(char **argv,tm *time)\n\n{\n  long lVar1;\n  int iVar2;\n  tm *time_local;\n  char **argv_local;\n  char *end;\n  short i;\n  \n  lVar1 \u003d strtol(*argv,\u0026end,10);\n  i \u003d (short)lVar1;\n  time-\u003etm_year \u003d i + -0x76c;\n  lVar1 \u003d strtol(end + 1,\u0026end,10);\n  i \u003d (short)lVar1;\n  time-\u003etm_mon \u003d i + -1;\n  lVar1 \u003d strtol(end + 1,\u0026end,10);\n  i \u003d (short)lVar1;\n  time-\u003etm_mday \u003d (int)i;\n  lVar1 \u003d strtol(argv[1],\u0026end,10);\n  i \u003d (short)lVar1;\n  time-\u003etm_hour \u003d (int)i;\n  lVar1 \u003d strtol(end + 1,\u0026end,10);\n  i \u003d (short)lVar1;\n  time-\u003etm_min \u003d (int)i;\n  lVar1 \u003d strtol(end + 1,\u0026end,10);\n  i \u003d (short)lVar1;\n  time-\u003etm_sec \u003d (int)i;\n  iVar2 \u003d dow(time-\u003etm_year + 0x76c,time-\u003etm_mon + 1,time-\u003etm_mday);\n  time-\u003etm_wday \u003d iVar2;\n  time-\u003etm_isdst \u003d -1;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_setalarm",
        "_rtc_settime"
      ],
      "called": [
        "strtol",
        "dow"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_print_time": {
      "entrypoint": "0x00003378",
      "current_name": "_print_time",
      "code": "\nint _print_time(tm *time)\n\n{\n  tm *time_local;\n  \n  iprintf(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",time-\u003etm_year + 0x76c,time-\u003etm_mon + 1,time-\u003etm_mday,\n          time-\u003etm_hour,time-\u003etm_min,time-\u003etm_sec);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_getalarm",
        "_rtc_gettime"
      ],
      "called": [
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_rtc_getalarm": {
      "entrypoint": "0x000033c0",
      "current_name": "_rtc_getalarm",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _rtc_getalarm(void)\n\n{\n  int iVar1;\n  tm t;\n  \n  iVar1 \u003d rtc_get_alarm(\u0026t);\n  if (iVar1 !\u003d 0) {\n    puts(\"rtc: error getting alarm\");\n  }\n  else {\n    _print_time(\u0026t);\n  }\n  return (uint)(iVar1 !\u003d 0);\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_handler"
      ],
      "called": [
        "rtc_get_alarm",
        "_print_time",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_rtc_setalarm": {
      "entrypoint": "0x000033f4",
      "current_name": "_rtc_setalarm",
      "code": "\nint _rtc_setalarm(char **argv)\n\n{\n  int iVar1;\n  char **argv_local;\n  tm now;\n  \n  iVar1 \u003d _parse_time(argv,\u0026now);\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d rtc_set_alarm(\u0026now,_alarm_handler + 1,(void *)0x0);\n    if (iVar1 \u003d\u003d -1) {\n      puts(\"rtc: error setting alarm\");\n      iVar1 \u003d 1;\n    }\n    else {\n      iVar1 \u003d 0;\n    }\n  }\n  else {\n    iVar1 \u003d 1;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_handler"
      ],
      "called": [
        "_parse_time",
        "rtc_set_alarm",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_rtc_gettime": {
      "entrypoint": "0x00003444",
      "current_name": "_rtc_gettime",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _rtc_gettime(void)\n\n{\n  int iVar1;\n  tm t;\n  \n  iVar1 \u003d rtc_get_time(\u0026t);\n  if (iVar1 !\u003d 0) {\n    puts(\"rtc: error getting time\");\n  }\n  else {\n    _print_time(\u0026t);\n  }\n  return (uint)(iVar1 !\u003d 0);\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_handler"
      ],
      "called": [
        "_print_time",
        "puts",
        "rtc_get_time"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_rtc_settime": {
      "entrypoint": "0x00003478",
      "current_name": "_rtc_settime",
      "code": "\nint _rtc_settime(char **argv)\n\n{\n  int iVar1;\n  char **argv_local;\n  tm now;\n  \n  iVar1 \u003d _parse_time(argv,\u0026now);\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d rtc_set_time(\u0026now);\n    if (iVar1 \u003d\u003d -1) {\n      puts(\"rtc: error setting time\");\n      iVar1 \u003d 1;\n    }\n    else {\n      iVar1 \u003d 0;\n    }\n  }\n  else {\n    iVar1 \u003d 1;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_handler"
      ],
      "called": [
        "rtc_set_time",
        "_parse_time",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_rtc_usage": {
      "entrypoint": "0x000034c0",
      "current_name": "_rtc_usage",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _rtc_usage(void)\n\n{\n  puts(\"usage: rtc \u003ccommand\u003e [arguments]\");\n  puts(\"commands:\");\n  puts(\"\\tpoweron\\t\\tpower the interface on\");\n  puts(\"\\tpoweroff\\tpower the interface off\");\n  puts(\"\\tclearalarm\\tdeactivate the current alarm\");\n  puts(\"\\tgetalarm\\tprint the currently alarm time\");\n  puts(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  puts(\"\\tgettime\\t\\tprint the current time\");\n  puts(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rtc_handler"
      ],
      "called": [
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_rtc_handler": {
      "entrypoint": "0x00003524",
      "current_name": "_rtc_handler",
      "code": "\nint _rtc_handler(int argc,char **argv)\n\n{\n  int iVar1;\n  char **argv_local;\n  int argc_local;\n  \n  if (argc \u003c 2) {\n    _rtc_usage();\n    iVar1 \u003d 1;\n  }\n  else {\n    iVar1 \u003d strncmp(argv[1],\"poweron\",7);\n    if (iVar1 \u003d\u003d 0) {\n      rtc_poweron();\n    }\n    else {\n      iVar1 \u003d strncmp(argv[1],\"poweroff\",8);\n      if (iVar1 \u003d\u003d 0) {\n        rtc_poweroff();\n      }\n      else {\n        iVar1 \u003d strncmp(argv[1],\"clearalarm\",8);\n        if (iVar1 \u003d\u003d 0) {\n          rtc_clear_alarm();\n        }\n        else {\n          iVar1 \u003d strncmp(argv[1],\"getalarm\",8);\n          if (iVar1 \u003d\u003d 0) {\n            _rtc_getalarm();\n          }\n          else {\n            iVar1 \u003d strncmp(argv[1],\"setalarm\",8);\n            if ((iVar1 \u003d\u003d 0) \u0026\u0026 (argc \u003d\u003d 4)) {\n              _rtc_setalarm(argv + 2);\n            }\n            else {\n              iVar1 \u003d strncmp(argv[1],\"gettime\",7);\n              if (iVar1 \u003d\u003d 0) {\n                _rtc_gettime();\n              }\n              else {\n                iVar1 \u003d strncmp(argv[1],\"settime\",7);\n                if ((iVar1 !\u003d 0) || (argc !\u003d 4)) {\n                  iprintf(\"unknown command or missing parameters: %s\\n\\n\",argv[1]);\n                  _rtc_usage();\n                  return 1;\n                }\n                _rtc_settime(argv + 2);\n              }\n            }\n          }\n        }\n      }\n    }\n    iVar1 \u003d 0;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "rtc_clear_alarm",
        "strncmp",
        "iprintf",
        "rtc_poweroff",
        "_rtc_usage",
        "_rtc_getalarm",
        "_rtc_setalarm",
        "_rtc_settime",
        "rtc_poweron",
        "_rtc_gettime"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "NVIC_SystemReset": {
      "entrypoint": "0x00003658",
      "current_name": "NVIC_SystemReset",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid NVIC_SystemReset(void)\n\n{\n  DataSynchronizationBarrier(0xf);\n  DataSynchronizationBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "pm_reboot"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pm_reboot": {
      "entrypoint": "0x00003688",
      "current_name": "pm_reboot",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pm_reboot(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_reboot_handler"
      ],
      "called": [
        "NVIC_SystemReset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "phydat_dump": {
      "entrypoint": "0x00003694",
      "current_name": "phydat_dump",
      "code": "\nvoid phydat_dump(phydat_t *data,uint8_t dim)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  char cVar3;\n  uint uVar4;\n  bool bVar5;\n  uint8_t dim_local;\n  phydat_t *data_local;\n  char num [8];\n  size_t len;\n  char scale_prefix;\n  uint8_t i;\n  \n  if ((data \u003d\u003d (phydat_t *)0x0) || (3 \u003c dim)) {\n    puts(\"Unable to display data object\");\n  }\n  else {\n    iprintf(\"Data:\");\n    for (i \u003d \u0027\\0\u0027; i \u003c dim; i \u003d i + \u0027\\x01\u0027) {\n      if (data-\u003eunit \u003c 0x14) {\n        uVar4 \u003d 1 \u003c\u003c (uint)data-\u003eunit \u0026 0x8018f;\n        bVar5 \u003d uVar4 !\u003d 0;\n        if (bVar5) {\n          uVar4 \u003d 1;\n        }\n        cVar3 \u003d (char)uVar4;\n        if (!bVar5) {\n          cVar3 \u003d \u0027\\0\u0027;\n        }\n        if (cVar3 \u003d\u003d \u0027\\0\u0027) goto LAB_000036ee;\n        scale_prefix \u003d \u0027\\0\u0027;\n      }\n      else {\nLAB_000036ee:\n        scale_prefix \u003d phydat_prefix_from_scale(data-\u003escale);\n      }\n      iprintf(\"\\t\");\n      if (dim \u003c 2) {\n        iprintf(\"     \");\n      }\n      else {\n        iprintf(\"[%u] \",(uint)i);\n      }\n      if (scale_prefix \u003d\u003d \u0027\\0\u0027) {\n        if (data-\u003escale \u003d\u003d \u0027\\0\u0027) {\n          iprintf(\"%6d\",(int)data-\u003eval[i]);\n        }\n        else if ((data-\u003escale + 4 \u003c 0 \u003d\u003d SCARRY4((int)data-\u003escale,4)) \u0026\u0026 (data-\u003escale \u003c \u0027\\0\u0027)) {\n          sVar1 \u003d fmt_s16_dfp(num,data-\u003eval[i],(int)data-\u003escale);\n          num[sVar1] \u003d \u0027\\0\u0027;\n          iprintf(\"%s\",num);\n        }\n        else {\n          iprintf(\"%iE%i\",(int)data-\u003eval[i],(int)data-\u003escale);\n        }\n      }\n      else {\n        iprintf(\"%6d %c\",(int)data-\u003eval[i],(uint)(byte)scale_prefix);\n      }\n      pcVar2 \u003d phydat_unit_to_str(data-\u003eunit);\n      iprintf(\"%s\\n\",pcVar2);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write",
        "probe"
      ],
      "called": [
        "phydat_unit_to_str",
        "fmt_s16_dfp",
        "iprintf",
        "phydat_prefix_from_scale",
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "phydat_unit_to_str": {
      "entrypoint": "0x00003810",
      "current_name": "phydat_unit_to_str",
      "code": "\nchar * phydat_unit_to_str(uint8_t unit)\n\n{\n  char *pcVar1;\n  uint8_t unit_local;\n  \n  switch(unit) {\n  case \u0027\\x02\u0027:\n    pcVar1 \u003d \u0026DAT_000077ec;\n    break;\n  case \u0027\\x03\u0027:\n    pcVar1 \u003d \u0026DAT_000077f0;\n    break;\n  case \u0027\\x04\u0027:\n    pcVar1 \u003d \"K\";\n    break;\n  case \u0027\\x05\u0027:\n    pcVar1 \u003d \"lx\";\n    break;\n  case \u0027\\x06\u0027:\n    pcVar1 \u003d \"m\";\n    break;\n  case \u0027\\a\u0027:\n    pcVar1 \u003d \"m^2\";\n    break;\n  case \u0027\\b\u0027:\n    pcVar1 \u003d \"m^3\";\n    break;\n  case \u0027\\t\u0027:\n    pcVar1 \u003d \"g\";\n    break;\n  case \u0027\\n\u0027:\n    pcVar1 \u003d \"dps\";\n    break;\n  case \u0027\\v\u0027:\n    pcVar1 \u003d \"G\";\n    break;\n  case \u0027\\f\u0027:\n    pcVar1 \u003d \"A\";\n    break;\n  case \u0027\\r\u0027:\n    pcVar1 \u003d \"V\";\n    break;\n  case \u0027\\x0e\u0027:\n    pcVar1 \u003d \"Gs\";\n    break;\n  case \u0027\\x0f\u0027:\n    pcVar1 \u003d \"Bar\";\n    break;\n  case \u0027\\x10\u0027:\n    pcVar1 \u003d \"Pa\";\n    break;\n  case \u0027\\x11\u0027:\n    pcVar1 \u003d \"cd\";\n    break;\n  default:\n    pcVar1 \u003d \"\";\n    break;\n  case \u0027\\x13\u0027:\n    pcVar1 \u003d \"%\";\n    break;\n  case \u0027\\x15\u0027:\n    pcVar1 \u003d \"ppm\";\n  }\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "phydat_dump"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "phydat_prefix_from_scale": {
      "entrypoint": "0x00003918",
      "current_name": "phydat_prefix_from_scale",
      "code": "\nchar phydat_prefix_from_scale(int8_t scale)\n\n{\n  char cVar1;\n  int8_t scale_local;\n  \n  switch(scale) {\n  case \u0027\\x02\u0027:\n    cVar1 \u003d \u0027h\u0027;\n    break;\n  case \u0027\\x03\u0027:\n    cVar1 \u003d \u0027k\u0027;\n    break;\n  case \u0027\\x06\u0027:\n    cVar1 \u003d \u0027M\u0027;\n    break;\n  case \u0027\\t\u0027:\n    cVar1 \u003d \u0027G\u0027;\n    break;\n  case \u0027\\f\u0027:\n    cVar1 \u003d \u0027T\u0027;\n    break;\n  case \u0027\\x0f\u0027:\n    cVar1 \u003d \u0027P\u0027;\n    break;\n  case -0xf:\n    cVar1 \u003d \u0027f\u0027;\n    break;\n  default:\n    cVar1 \u003d \u0027\\0\u0027;\n    break;\n  case -0xc:\n    cVar1 \u003d \u0027p\u0027;\n    break;\n  case -9:\n    cVar1 \u003d \u0027n\u0027;\n    break;\n  case -6:\n    cVar1 \u003d \u0027u\u0027;\n    break;\n  case -3:\n    cVar1 \u003d \u0027m\u0027;\n  }\n  return cVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "phydat_dump"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "saul_class_to_str": {
      "entrypoint": "0x000039e8",
      "current_name": "saul_class_to_str",
      "code": "\nchar * saul_class_to_str(uint8_t class_id)\n\n{\n  char *pcVar1;\n  uint8_t class_id_local;\n  \n  switch(class_id) {\n  case \u0027\\0\u0027:\n    pcVar1 \u003d \"CLASS_UNDEF\";\n    break;\n  case \u0027@\u0027:\n    pcVar1 \u003d \"ACT_ANY\";\n    break;\n  case \u0027B\u0027:\n    pcVar1 \u003d \"ACT_LED_RGB\";\n    break;\n  case \u0027C\u0027:\n    pcVar1 \u003d \"ACT_SERVO\";\n    break;\n  case \u0027D\u0027:\n    pcVar1 \u003d \"ACT_MOTOR\";\n    break;\n  case \u0027E\u0027:\n    pcVar1 \u003d \"ACT_SWITCH\";\n    break;\n  case \u0027F\u0027:\n    pcVar1 \u003d \"ACT_DIMMER\";\n    break;\n  case 0x80:\n    pcVar1 \u003d \"SENSE_ANY\";\n    break;\n  case 0x81:\n    pcVar1 \u003d \"SENSE_BTN\";\n    break;\n  case 0x82:\n    pcVar1 \u003d \"SENSE_TEMP\";\n    break;\n  case 0x83:\n    pcVar1 \u003d \"SENSE_HUM\";\n    break;\n  case 0x84:\n    pcVar1 \u003d \"SENSE_LIGHT\";\n    break;\n  case 0x85:\n    pcVar1 \u003d \"SENSE_ACCEL\";\n    break;\n  case 0x86:\n    pcVar1 \u003d \"SENSE_MAG\";\n    break;\n  case 0x87:\n    pcVar1 \u003d \"SENSE_GYRO\";\n    break;\n  case 0x88:\n    pcVar1 \u003d \"SENSE_COLOR\";\n    break;\n  case 0x89:\n    pcVar1 \u003d \"SENSE_PRESS\";\n    break;\n  case 0x8a:\n    pcVar1 \u003d \"SENSE_ANALOG\";\n    break;\n  case 0x8b:\n    pcVar1 \u003d \"SENSE_UV\";\n    break;\n  case 0x8c:\n    pcVar1 \u003d \"SENSE_OBJTEMP\";\n    break;\n  case 0x8d:\n    pcVar1 \u003d \"SENSE_PULSE_COUNT\";\n    break;\n  case 0x8e:\n    pcVar1 \u003d \"SENSE_DISTANCE\";\n    break;\n  case 0x8f:\n    pcVar1 \u003d \"SENSE_CO2\";\n    break;\n  default:\n    if (class_id \u003d\u003d 0xff) {\n      return \"CLASS_ANY\";\n    }\n  case \u0027\\x01\u0027:\n  case \u0027\\x02\u0027:\n  case \u0027\\x03\u0027:\n  case \u0027\\x04\u0027:\n  case \u0027\\x05\u0027:\n  case \u0027\\x06\u0027:\n  case \u0027\\a\u0027:\n  case \u0027\\b\u0027:\n  case \u0027\\t\u0027:\n  case \u0027\\n\u0027:\n  case \u0027\\v\u0027:\n  case \u0027\\f\u0027:\n  case \u0027\\r\u0027:\n  case \u0027\\x0e\u0027:\n  case \u0027\\x0f\u0027:\n  case \u0027\\x10\u0027:\n  case \u0027\\x11\u0027:\n  case \u0027\\x12\u0027:\n  case \u0027\\x13\u0027:\n  case \u0027\\x14\u0027:\n  case \u0027\\x15\u0027:\n  case \u0027\\x16\u0027:\n  case \u0027\\x17\u0027:\n  case \u0027\\x18\u0027:\n  case \u0027\\x19\u0027:\n  case \u0027\\x1a\u0027:\n  case \u0027\\x1b\u0027:\n  case \u0027\\x1c\u0027:\n  case \u0027\\x1d\u0027:\n  case \u0027\\x1e\u0027:\n  case \u0027\\x1f\u0027:\n  case \u0027 \u0027:\n  case \u0027!\u0027:\n  case \u0027\\\"\u0027:\n  case \u0027#\u0027:\n  case \u0027$\u0027:\n  case \u0027%\u0027:\n  case \u0027\u0026\u0027:\n  case \u0027\\\u0027\u0027:\n  case \u0027(\u0027:\n  case \u0027)\u0027:\n  case \u0027*\u0027:\n  case \u0027+\u0027:\n  case \u0027,\u0027:\n  case \u0027-\u0027:\n  case \u0027.\u0027:\n  case \u0027/\u0027:\n  case \u00270\u0027:\n  case \u00271\u0027:\n  case \u00272\u0027:\n  case \u00273\u0027:\n  case \u00274\u0027:\n  case \u00275\u0027:\n  case \u00276\u0027:\n  case \u00277\u0027:\n  case \u00278\u0027:\n  case \u00279\u0027:\n  case \u0027:\u0027:\n  case \u0027;\u0027:\n  case \u0027\u003c\u0027:\n  case \u0027\u003d\u0027:\n  case \u0027\u003e\u0027:\n  case \u0027?\u0027:\n  case \u0027A\u0027:\n  case \u0027G\u0027:\n  case \u0027H\u0027:\n  case \u0027I\u0027:\n  case \u0027J\u0027:\n  case \u0027K\u0027:\n  case \u0027L\u0027:\n  case \u0027M\u0027:\n  case \u0027N\u0027:\n  case \u0027O\u0027:\n  case \u0027P\u0027:\n  case \u0027Q\u0027:\n  case \u0027R\u0027:\n  case \u0027S\u0027:\n  case \u0027T\u0027:\n  case \u0027U\u0027:\n  case \u0027V\u0027:\n  case \u0027W\u0027:\n  case \u0027X\u0027:\n  case \u0027Y\u0027:\n  case \u0027Z\u0027:\n  case \u0027[\u0027:\n  case \u0027\\\\\u0027:\n  case \u0027]\u0027:\n  case \u0027^\u0027:\n  case \u0027_\u0027:\n  case \u0027`\u0027:\n  case \u0027a\u0027:\n  case \u0027b\u0027:\n  case \u0027c\u0027:\n  case \u0027d\u0027:\n  case \u0027e\u0027:\n  case \u0027f\u0027:\n  case \u0027g\u0027:\n  case \u0027h\u0027:\n  case \u0027i\u0027:\n  case \u0027j\u0027:\n  case \u0027k\u0027:\n  case \u0027l\u0027:\n  case \u0027m\u0027:\n  case \u0027n\u0027:\n  case \u0027o\u0027:\n  case \u0027p\u0027:\n  case \u0027q\u0027:\n  case \u0027r\u0027:\n  case \u0027s\u0027:\n  case \u0027t\u0027:\n  case \u0027u\u0027:\n  case \u0027v\u0027:\n  case \u0027w\u0027:\n  case \u0027x\u0027:\n  case \u0027y\u0027:\n  case \u0027z\u0027:\n  case \u0027{\u0027:\n  case \u0027|\u0027:\n  case \u0027}\u0027:\n  case \u0027~\u0027:\n  case \u0027\\x7f\u0027:\n    pcVar1 \u003d \"CLASS_UNKNOWN\";\n  }\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "list",
        "probe"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "saul_reg_find_nth": {
      "entrypoint": "0x00003d24",
      "current_name": "saul_reg_find_nth",
      "code": "\nsaul_reg_t * saul_reg_find_nth(int pos)\n\n{\n  int pos_local;\n  int i;\n  saul_reg_t *tmp;\n  \n  i \u003d 0;\n  for (tmp \u003d saul_reg; (i \u003c pos \u0026\u0026 (tmp !\u003d (saul_reg_t *)0x0)); tmp \u003d tmp-\u003enext) {\n    i \u003d i + 1;\n  }\n  return tmp;\n}\n\n",
      "renaming": {},
      "calling": [
        "read",
        "write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "saul_reg_read": {
      "entrypoint": "0x00003d64",
      "current_name": "saul_reg_read",
      "code": "\nint saul_reg_read(saul_reg_t *dev,phydat_t *res)\n\n{\n  int iVar1;\n  phydat_t *res_local;\n  saul_reg_t *dev_local;\n  \n  if (dev \u003d\u003d (saul_reg_t *)0x0) {\n    iVar1 \u003d -0x13;\n  }\n  else {\n    iVar1 \u003d (*dev-\u003edriver-\u003eread)(dev-\u003edev,res);\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "probe"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "saul_reg_write": {
      "entrypoint": "0x00003d94",
      "current_name": "saul_reg_write",
      "code": "\nint saul_reg_write(saul_reg_t *dev,phydat_t *data)\n\n{\n  int iVar1;\n  phydat_t *data_local;\n  saul_reg_t *dev_local;\n  \n  if (dev \u003d\u003d (saul_reg_t *)0x0) {\n    iVar1 \u003d -0x13;\n  }\n  else {\n    iVar1 \u003d (*dev-\u003edriver-\u003ewrite)(dev-\u003edev,data);\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fmt_u32_dec": {
      "entrypoint": "0x00003dc4",
      "current_name": "fmt_u32_dec",
      "code": "\nsize_t fmt_u32_dec(char *out,uint32_t val)\n\n{\n  uint32_t val_local;\n  char *out_local;\n  char *ptr;\n  uint32_t tmp;\n  size_t len;\n  \n  len \u003d 1;\n  if (val \u003c 1000000000) {\n    for (tmp \u003d 10; tmp \u003c\u003d val; tmp \u003d tmp * 10) {\n      len \u003d len + 1;\n    }\n  }\n  else {\n    len \u003d 10;\n  }\n  if (out !\u003d (char *)0x0) {\n    ptr \u003d out + len;\n    val_local \u003d val;\n    do {\n      ptr \u003d ptr + -1;\n      *ptr \u003d (char)(val_local % 10) + \u00270\u0027;\n      val_local \u003d val_local / 10;\n    } while (val_local !\u003d 0);\n  }\n  return len;\n}\n\n",
      "renaming": {},
      "calling": [
        "fmt_s32_dec"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fmt_s32_dec": {
      "entrypoint": "0x00003e58",
      "current_name": "fmt_s32_dec",
      "code": "\nsize_t fmt_s32_dec(char *out,int32_t val)\n\n{\n  size_t sVar1;\n  int32_t val_local;\n  char *out_local;\n  uint negative;\n  \n  val_local \u003d val;\n  out_local \u003d out;\n  if (-(val \u003e\u003e 0x1f) !\u003d 0) {\n    if (out !\u003d (char *)0x0) {\n      out_local \u003d out + 1;\n      *out \u003d \u0027-\u0027;\n    }\n    val_local \u003d -val;\n  }\n  sVar1 \u003d fmt_u32_dec(out_local,val_local);\n  return -(val \u003e\u003e 0x1f) + sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "fmt_s32_dfp"
      ],
      "called": [
        "fmt_u32_dec"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fmt_s16_dfp": {
      "entrypoint": "0x00003e9e",
      "current_name": "fmt_s16_dfp",
      "code": "\nsize_t fmt_s16_dfp(char *out,int16_t val,int fp_digits)\n\n{\n  size_t sVar1;\n  int fp_digits_local;\n  int16_t val_local;\n  char *out_local;\n  \n  sVar1 \u003d fmt_s32_dfp(out,(int)val,fp_digits);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "phydat_dump"
      ],
      "called": [
        "fmt_s32_dfp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fmt_s32_dfp": {
      "entrypoint": "0x00003ec4",
      "current_name": "fmt_s32_dfp",
      "code": "\nsize_t fmt_s32_dfp(char *out,int32_t val,int fp_digits)\n\n{\n  size_t sVar1;\n  uint val_00;\n  int iVar2;\n  int fp_digits_local;\n  int32_t val_local;\n  char *out_local;\n  uint div_len;\n  int32_t abs;\n  uint32_t e;\n  int32_t div;\n  uint pos;\n  \n  if (fp_digits + 7 \u003c 0 !\u003d SCARRY4(fp_digits,7)) {\n                    \n    core_panic(PANIC_ASSERT_FAIL,\"FAILED ASSERTION.\");\n  }\n  pos \u003d 0;\n  if (fp_digits \u003d\u003d 0) {\n    pos \u003d fmt_s32_dec(out,val);\n  }\n  else if (fp_digits \u003c 1) {\n    val_00 \u003d (uint)val / _tenmap[-fp_digits];\n    div \u003d val - _tenmap[-fp_digits] * val_00;\n    if (div \u003c 0) {\n      div \u003d -div;\n    }\n    if ((val_00 \u003d\u003d 0) \u0026\u0026 (val \u003c 0)) {\n      if (out !\u003d (char *)0x0) {\n        *out \u003d \u0027-\u0027;\n      }\n      pos \u003d 1;\n    }\n    if (out \u003d\u003d (char *)0x0) {\n      sVar1 \u003d fmt_s32_dec((char *)0x0,val_00);\n      pos \u003d sVar1 + 1 + pos;\n    }\n    else {\n      sVar1 \u003d fmt_s32_dec(out + pos,val_00);\n      iVar2 \u003d pos + sVar1;\n      pos \u003d iVar2 + 1;\n      out[iVar2] \u003d \u0027.\u0027;\n      sVar1 \u003d fmt_s32_dec(out + pos,div);\n      fmt_lpad(out + pos,sVar1,-fp_digits,\u00270\u0027);\n    }\n    pos \u003d -fp_digits + pos;\n  }\n  else {\n    sVar1 \u003d fmt_s32_dec(out,val);\n    if (out !\u003d (char *)0x0) {\n      memset(out + sVar1,0x30,fp_digits);\n    }\n    pos \u003d fp_digits + sVar1;\n  }\n  return pos;\n}\n\n",
      "renaming": {},
      "calling": [
        "fmt_s16_dfp"
      ],
      "called": [
        "fmt_lpad",
        "memset",
        "fmt_s32_dec",
        "core_panic"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fmt_lpad": {
      "entrypoint": "0x00003ff4",
      "current_name": "fmt_lpad",
      "code": "\nsize_t fmt_lpad(char *out,size_t in_len,size_t pad_len,char pad_char)\n\n{\n  size_t sVar1;\n  char pad_char_local;\n  size_t pad_len_local;\n  size_t in_len_local;\n  char *out_local;\n  size_t n;\n  \n  sVar1 \u003d in_len;\n  if ((in_len \u003c pad_len) \u0026\u0026 (sVar1 \u003d pad_len, out !\u003d (char *)0x0)) {\n    memmove(out + (pad_len - in_len),out,in_len);\n    memset(out,(uint)(byte)pad_char,pad_len - in_len);\n  }\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "fmt_s32_dfp"
      ],
      "called": [
        "memset",
        "memmove"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "atoi": {
      "entrypoint": "0x00004042",
      "current_name": "atoi",
      "code": "\nint atoi(char *__nptr)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d strtol(__nptr,(char **)0x0,10);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "read",
        "write"
      ],
      "called": [
        "strtol"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sflush_r": {
      "entrypoint": "0x0000404c",
      "current_name": "__sflush_r",
      "code": "\nundefined4 __sflush_r(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar3 \u003d (uint)uVar4;\n  if ((int)(uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar1 \u003d param_2[4];\n    if (iVar1 !\u003d 0) {\n      iVar5 \u003d uVar3 \u003c\u003c 0x1e;\n      bVar9 \u003d iVar5 \u003d\u003d 0;\n      iVar7 \u003d *param_2;\n      if (bVar9) {\n        iVar5 \u003d param_2[5];\n      }\n      *param_2 \u003d iVar1;\n      if (!bVar9) {\n        iVar5 \u003d 0;\n      }\n      param_2[2] \u003d iVar5;\n      for (iVar7 \u003d iVar7 - iVar1; 0 \u003c iVar7; iVar7 \u003d iVar7 - iVar5) {\n        iVar5 \u003d (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 \u003c 1) {\n          *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        iVar1 \u003d iVar1 + iVar5;\n      }\n    }\n  }\n  else {\n    if ((param_2[1] \u003c 1) \u0026\u0026 (param_2[0x10] \u003c 1)) {\n      return 0;\n    }\n    pcVar6 \u003d (code *)param_2[0xb];\n    if (pcVar6 \u003d\u003d (code *)0x0) {\n      return 0;\n    }\n    uVar8 \u003d *param_1;\n    *param_1 \u003d 0;\n    if ((uVar4 \u0026 0x1000) \u003d\u003d 0) {\n      iVar1 \u003d (*pcVar6)(param_1,param_2[8],uVar3 \u0026 0x1000,1);\n      if ((iVar1 \u003d\u003d -1) \u0026\u0026 (uVar3 \u003d *param_1, uVar3 !\u003d 0)) {\n        if ((uVar3 \u003d\u003d 0x1d) || (uVar3 \u003d\u003d 0x16)) {\n          *param_1 \u003d uVar8;\n          return 0;\n        }\n        uVar4 \u003d *(ushort *)(param_2 + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      iVar1 \u003d param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1d) \u003c 0) \u0026\u0026\n       (iVar1 \u003d iVar1 - param_2[1], param_2[0xd] !\u003d 0)) {\n      iVar1 \u003d iVar1 - param_2[0x10];\n    }\n    iVar1 \u003d (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 \u003d *(ushort *)(param_2 + 3);\n    if ((iVar1 \u003d\u003d -1) \u0026\u0026\n       ((0x1d \u003c *param_1 || (-1 \u003c (int)((0x20400001U \u003e\u003e (*param_1 \u0026 0xff)) \u003c\u003c 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(param_2 + 3) \u003d uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    param_2[1] \u003d 0;\n    *param_2 \u003d param_2[4];\n    if (((int)((uint)uVar4 \u003c\u003c 0x13) \u003c 0) \u0026\u0026 ((iVar1 !\u003d -1 || (*param_1 \u003d\u003d 0)))) {\n      param_2[0x15] \u003d iVar1;\n    }\n    piVar2 \u003d (int *)param_2[0xd];\n    *param_1 \u003d uVar8;\n    if (piVar2 !\u003d (int *)0x0) {\n      if (piVar2 !\u003d param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] \u003d 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r",
        "__srefill_r"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fflush_r": {
      "entrypoint": "0x00004158",
      "current_name": "_fflush_r",
      "code": "\nundefined4 _fflush_r(int param_1,undefined4 *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_2[4] !\u003d 0) {\n    if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n      __sinit();\n    }\n    if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n      param_2 \u003d *(undefined4 **)(param_1 + 4);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n      param_2 \u003d *(undefined4 **)(param_1 + 8);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n      param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 3) !\u003d 0) {\n      if ((-1 \u003c (int)(param_2[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)*(short *)(param_2 + 3) \u003c\u003c 0x16)) {\n        __retarget_lock_acquire_recursive(param_2[0x16]);\n      }\n      uVar1 \u003d __sflush_r(param_1,param_2);\n      if ((int)(param_2[0x19] \u003c\u003c 0x1f) \u003c 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16) \u003c 0) {\n        return uVar1;\n      }\n      __retarget_lock_release_recursive(param_2[0x16]);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "fflush",
        "__srefill_r",
        "__swbuf_r"
      ],
      "called": [
        "__sinit",
        "__retarget_lock_acquire_recursive",
        "__sflush_r",
        "__retarget_lock_release_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fflush": {
      "entrypoint": "0x000041d0",
      "current_name": "fflush",
      "code": "\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  if (__stream \u003d\u003d (FILE *)0x0) {\n    iVar1 \u003d _fwalk_reent(\u0026impure_data,0x4159);\n    return iVar1;\n  }\n  iVar1 \u003d _fflush_r(_impure_ptr,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "print_prompt",
        "lflush"
      ],
      "called": [
        "_fflush_r",
        "_fwalk_reent"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "std": {
      "entrypoint": "0x000041f4",
      "current_name": "std",
      "code": "\nvoid std(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  *param_1 \u003d 0;\n  param_1[1] \u003d 0;\n  param_1[4] \u003d 0;\n  param_1[5] \u003d 0;\n  param_1[2] \u003d 0;\n  *(undefined2 *)(param_1 + 3) \u003d param_2;\n  param_1[0x19] \u003d 0;\n  *(undefined2 *)((int)param_1 + 0xe) \u003d param_3;\n  param_1[6] \u003d 0;\n  memset(param_1 + 0x17,0,8);\n  param_1[9] \u003d 0x4dc9;\n  param_1[10] \u003d 0x4def;\n  param_1[0xb] \u003d 0x4e27;\n  param_1[8] \u003d param_1;\n  param_1[0xc] \u003d 0x4e4b;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_cleanup_r": {
      "entrypoint": "0x0000423c",
      "current_name": "_cleanup_r",
      "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk_reent(param_1,0x4159);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fwalk_reent"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfmoreglue": {
      "entrypoint": "0x00004248",
      "current_name": "__sfmoreglue",
      "code": "\nundefined4 * __sfmoreglue(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 \u003d (param_2 + -1) * 0x68;\n  puVar1 \u003d (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 !\u003d (undefined4 *)0x0) {\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d param_2;\n    puVar1[2] \u003d puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfp"
      ],
      "called": [
        "memset",
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp_lock_acquire": {
      "entrypoint": "0x00004274",
      "current_name": "__sfp_lock_acquire",
      "code": "\nvoid __sfp_lock_acquire(void)\n\n{\n  __retarget_lock_acquire_recursive(\u0026__lock___sfp_recursive_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfp"
      ],
      "called": [
        "__retarget_lock_acquire_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp_lock_release": {
      "entrypoint": "0x00004280",
      "current_name": "__sfp_lock_release",
      "code": "\nvoid __sfp_lock_release(void)\n\n{\n  __retarget_lock_release_recursive(\u0026__lock___sfp_recursive_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfp"
      ],
      "called": [
        "__retarget_lock_release_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sinit_lock_acquire": {
      "entrypoint": "0x0000428c",
      "current_name": "__sinit_lock_acquire",
      "code": "\nvoid __sinit_lock_acquire(void)\n\n{\n  __retarget_lock_acquire_recursive(\u0026__lock___sinit_recursive_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "__retarget_lock_acquire_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sinit_lock_release": {
      "entrypoint": "0x00004298",
      "current_name": "__sinit_lock_release",
      "code": "\nvoid __sinit_lock_release(void)\n\n{\n  __retarget_lock_release_recursive(\u0026__lock___sinit_recursive_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "__retarget_lock_release_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sinit": {
      "entrypoint": "0x000042a4",
      "current_name": "__sinit",
      "code": "\nvoid __sinit(undefined1 *param_1)\n\n{\n  undefined4 uVar1;\n  undefined1 *puVar2;\n  \n  __sinit_lock_acquire();\n  if (*(int *)(param_1 + 0x18) \u003d\u003d 0) {\n    *(undefined4 *)(param_1 + 0x48) \u003d 0;\n    *(undefined4 *)(param_1 + 0x4c) \u003d 0;\n    *(undefined4 *)(param_1 + 0x50) \u003d 0;\n    puVar2 \u003d \u0026impure_data;\n    *(undefined4 *)(param_1 + 0x28) \u003d 0x423d;\n    if (param_1 \u003d\u003d \u0026impure_data) {\n      puVar2 \u003d (undefined1 *)0x1;\n    }\n    if (param_1 \u003d\u003d \u0026impure_data) {\n      *(undefined1 **)(param_1 + 0x18) \u003d puVar2;\n    }\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 4) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) \u003d uVar1;\n    std(*(undefined4 *)(param_1 + 4),4,0);\n    std(*(undefined4 *)(param_1 + 8),9,1);\n    std(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) \u003d 1;\n  }\n  __sinit_lock_release();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_puts_r",
        "_putc_r",
        "__srefill_r",
        "__sfp",
        "_vfprintf_r",
        "_fflush_r",
        "_getc_r",
        "iprintf",
        "putchar",
        "__swsetup_r",
        "getchar",
        "__srget_r",
        "__swbuf_r"
      ],
      "called": [
        "__sinit_lock_release",
        "__sinit_lock_acquire",
        "std",
        "__sfp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp": {
      "entrypoint": "0x00004314",
      "current_name": "__sfp",
      "code": "\nint * __sfp(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int **ppiVar3;\n  \n  __sfp_lock_acquire();\n  if (DAT_1fff029c \u003d\u003d 0) {\n    __sinit(\u0026impure_data);\n  }\n  ppiVar3 \u003d (int **)\u0026DAT_1fff02cc;\n  do {\n    piVar1 \u003d ppiVar3[1];\n    piVar2 \u003d ppiVar3[2];\n    while (piVar1 \u003d (int *)((int)piVar1 + -1), -1 \u003c (int)piVar1) {\n      if (*(short *)(piVar2 + 3) \u003d\u003d 0) {\n        piVar2[3] \u003d -0xffff;\n        piVar2[0x19] \u003d 0;\n        __retarget_lock_init_recursive(piVar2 + 0x16);\n        __sfp_lock_release();\n        piVar2[1] \u003d 0;\n        piVar2[2] \u003d 0;\n        piVar2[4] \u003d 0;\n        piVar2[5] \u003d 0;\n        *piVar2 \u003d 0;\n        piVar2[6] \u003d 0;\n        memset(piVar2 + 0x17,0,8);\n        piVar2[0xd] \u003d 0;\n        piVar2[0xe] \u003d 0;\n        piVar2[0x12] \u003d 0;\n        piVar2[0x13] \u003d 0;\n        return piVar2;\n      }\n      piVar2 \u003d piVar2 + 0x1a;\n    }\n    if (*ppiVar3 \u003d\u003d (int *)0x0) {\n      piVar1 \u003d (int *)__sfmoreglue(param_1,4);\n      *ppiVar3 \u003d piVar1;\n      if (piVar1 \u003d\u003d (int *)0x0) {\n        __sfp_lock_release();\n        *param_1 \u003d 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar3 \u003d (int **)*ppiVar3;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "__sinit",
        "__sfmoreglue",
        "__sfp_lock_release",
        "__retarget_lock_init_recursive",
        "memset",
        "__sfp_lock_acquire"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fwalk": {
      "entrypoint": "0x000043a0",
      "current_name": "_fwalk",
      "code": "\nuint _fwalk(int param_1,code *param_2)\n\n{\n  uint uVar1;\n  int *piVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  \n  piVar2 \u003d (int *)(param_1 + 0x48);\n  uVar4 \u003d 0;\n  do {\n    iVar5 \u003d piVar2[1];\n    iVar3 \u003d piVar2[2];\n    while (iVar5 \u003d iVar5 + -1, -1 \u003c iVar5) {\n      if ((1 \u003c *(ushort *)(iVar3 + 0xc)) \u0026\u0026 (*(short *)(iVar3 + 0xe) !\u003d -1)) {\n        uVar1 \u003d (*param_2)(iVar3);\n        uVar4 \u003d uVar4 | uVar1;\n      }\n      iVar3 \u003d iVar3 + 0x68;\n    }\n    piVar2 \u003d (int *)*piVar2;\n  } while (piVar2 !\u003d (int *)0x0);\n  return uVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "__srefill_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fwalk_reent": {
      "entrypoint": "0x000043da",
      "current_name": "_fwalk_reent",
      "code": "\nuint _fwalk_reent(int param_1,code *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  \n  piVar3 \u003d (int *)(param_1 + 0x48);\n  uVar5 \u003d 0;\n  do {\n    iVar6 \u003d piVar3[1];\n    iVar4 \u003d piVar3[2];\n    while (iVar6 \u003d iVar6 + -1, -1 \u003c iVar6) {\n      if ((1 \u003c *(ushort *)(iVar4 + 0xc)) \u0026\u0026 (iVar2 \u003d *(short *)(iVar4 + 0xe) + 1, iVar2 !\u003d 0)) {\n        uVar1 \u003d (*param_2)(param_1,iVar4,param_3,iVar2,param_4);\n        uVar5 \u003d uVar5 | uVar1;\n      }\n      iVar4 \u003d iVar4 + 0x68;\n    }\n    piVar3 \u003d (int *)*piVar3;\n  } while (piVar3 !\u003d (int *)0x0);\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "fflush",
        "_cleanup_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getchar": {
      "entrypoint": "0x00004418",
      "current_name": "getchar",
      "code": "\n\n\nint getchar(void)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _impure_ptr;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  iVar1 \u003d _getc_r(iVar1,*(undefined4 *)(iVar1 + 4));\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "readline"
      ],
      "called": [
        "__sinit",
        "_getc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "gmtime_r": {
      "entrypoint": "0x0000443c",
      "current_name": "gmtime_r",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\ntm * gmtime_r(time_t *__timer,tm *__tp)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  time_t tVar7;\n  time_t tVar8;\n  uint uVar9;\n  bool bVar10;\n  \n  tVar7 \u003d *__timer;\n  tVar8 \u003d __timer[1];\n  iVar1 \u003d __aeabi_ldivmod(tVar7,tVar8,0x15180,0);\n  uVar3 \u003d 0x15180;\n  __aeabi_ldivmod(tVar7,tVar8,0x15180,0);\n  bVar10 \u003d (int)uVar3 \u003c 0;\n  if (bVar10) {\n    uVar3 \u003d uVar3 + 0x15180;\n  }\n  if (bVar10) {\n    uVar2 \u003d iVar1 + 0xafa6b;\n  }\n  else {\n    uVar2 \u003d iVar1 + 0xafa6c;\n  }\n  __tp-\u003etm_hour \u003d uVar3 / 0xe10;\n  __tp-\u003etm_min \u003d (uVar3 % 0xe10) / 0x3c;\n  __tp-\u003etm_sec \u003d (uVar3 % 0xe10) % 0x3c;\n  __tp-\u003etm_wday \u003d (uVar2 + 3) % 7;\n  uVar3 \u003d uVar2;\n  if ((int)uVar2 \u003c 0) {\n    uVar3 \u003d uVar2 - 0x23ab0;\n  }\n  uVar2 \u003d (uVar3 / 0x23ab1) * -0x23ab1 + uVar2;\n  uVar4 \u003d ((uVar2 / 0x8eac + uVar2) - uVar2 / 0x5b4) - uVar2 / 0x23ab0;\n  uVar6 \u003d uVar4 / 0x16d;\n  uVar2 \u003d (uVar6 / 100 - uVar4 / 0x5b4) + uVar2 + uVar6 * -0x16d;\n  uVar9 \u003d uVar2 * 5 + 2;\n  uVar4 \u003d uVar9 / 0x99;\n  if (uVar9 \u003c 0x5fa) {\n    iVar1 \u003d 2;\n  }\n  else {\n    iVar1 \u003d -10;\n  }\n  uVar9 \u003d uVar4 + iVar1;\n  iVar1 \u003d (uVar3 / 0x23ab1) * 400 + uVar6;\n  if (uVar9 \u003c 2) {\n    iVar1 \u003d iVar1 + 1;\n  }\n  if (uVar2 \u003c 0x132) {\n    if (((uVar6 \u0026 3) \u003d\u003d 0) \u0026\u0026 (uVar6 !\u003d (uVar6 / 100) * 100)) {\n      uVar3 \u003d 1;\n    }\n    else {\n      uVar3 \u003d (uint)(uVar6 % 400 \u003d\u003d 0);\n    }\n    iVar5 \u003d uVar2 + 0x3b + uVar3;\n  }\n  else {\n    iVar5 \u003d uVar2 - 0x132;\n  }\n  __tp-\u003etm_yday \u003d iVar5;\n  __tp-\u003etm_mday \u003d (uVar2 + 1) - (uVar4 * 0x99 + 2) / 5;\n  __tp-\u003etm_mon \u003d uVar9;\n  __tp-\u003etm_year \u003d iVar1 + -0x76c;\n  __tp-\u003etm_isdst \u003d 0;\n  return __tp;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_get_alarm",
        "rtc_get_time"
      ],
      "called": [
        "__aeabi_ldivmod"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_init_array": {
      "entrypoint": "0x0000459c",
      "current_name": "__libc_init_array",
      "code": "\nvoid __libc_init_array(EVP_PKEY_CTX *param_1)\n\n{\n  code **ppcVar1;\n  int iVar2;\n  \n  ppcVar1 \u003d (code **)\u0026__fini_array_end;\n  for (iVar2 \u003d 0; iVar2 !\u003d 0; iVar2 \u003d iVar2 + 1) {\n    param_1 \u003d (EVP_PKEY_CTX *)(**ppcVar1)();\n    ppcVar1 \u003d ppcVar1 + 1;\n  }\n  _init(param_1);\n  ppcVar1 \u003d (code **)\u0026__fini_array_end;\n  for (iVar2 \u003d 0; iVar2 !\u003d 0; iVar2 \u003d iVar2 + 1) {\n    (**ppcVar1)();\n    ppcVar1 \u003d ppcVar1 + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "reset_handler_default"
      ],
      "called": [
        "_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__retarget_lock_init_recursive": {
      "entrypoint": "0x000045e4",
      "current_name": "__retarget_lock_init_recursive",
      "code": "\nvoid __retarget_lock_init_recursive(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__retarget_lock_acquire": {
      "entrypoint": "0x000045e6",
      "current_name": "__retarget_lock_acquire",
      "code": "\nvoid __retarget_lock_acquire(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__tz_lock"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__retarget_lock_acquire_recursive": {
      "entrypoint": "0x000045e8",
      "current_name": "__retarget_lock_acquire_recursive",
      "code": "\nvoid __retarget_lock_acquire_recursive(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r",
        "__env_lock",
        "_puts_r",
        "_getc_r",
        "__sinit_lock_acquire",
        "__malloc_lock",
        "_putc_r",
        "__sfp_lock_acquire",
        "_vfprintf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__retarget_lock_release": {
      "entrypoint": "0x000045ea",
      "current_name": "__retarget_lock_release",
      "code": "\nvoid __retarget_lock_release(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__tz_unlock"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__retarget_lock_release_recursive": {
      "entrypoint": "0x000045ec",
      "current_name": "__retarget_lock_release_recursive",
      "code": "\nvoid __retarget_lock_release_recursive(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r",
        "_puts_r",
        "_getc_r",
        "__sinit_lock_release",
        "__sfp_lock_release",
        "__env_unlock",
        "_putc_r",
        "__malloc_unlock",
        "_vfprintf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x000045ee",
      "current_name": "memmove",
      "code": "\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar2 \u003d (undefined *)((int)__src + __n);\n  if ((__src \u003c __dest) \u0026\u0026 (__dest \u003c puVar2)) {\n    puVar1 \u003d (undefined *)(__n + (int)__dest);\n    while (puVar1 !\u003d (undefined *)__dest) {\n      puVar2 \u003d puVar2 + -1;\n      puVar1 \u003d puVar1 + -1;\n      *puVar1 \u003d *puVar2;\n    }\n  }\n  else {\n    puVar1 \u003d (undefined *)((int)__dest + -1);\n    for (; (undefined *)__src !\u003d puVar2; __src \u003d (void *)((int)__src + 1)) {\n      puVar1 \u003d puVar1 + 1;\n      *puVar1 \u003d *__src;\n                    /* WARNING: Load size is inaccurate */\n    }\n  }\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "fmt_lpad"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memset": {
      "entrypoint": "0x00004622",
      "current_name": "memset",
      "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 \u003d (undefined *)__s; puVar1 !\u003d (undefined *)(__n + (int)__s); puVar1 \u003d puVar1 + 1) {\n    *puVar1 \u003d (char)__c;\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfmoreglue",
        "fmt_lpad",
        "std",
        "fmt_s32_dfp",
        "write",
        "__sfp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "validate_structure": {
      "entrypoint": "0x00004634",
      "current_name": "validate_structure",
      "code": "\nvoid validate_structure(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  bool bVar5;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 \u003d param_1;\n  local_1c \u003d param_2;\n  uStack_18 \u003d param_3;\n  if (0x3b \u003c *param_1) {\n    div((int)\u0026local_20,*param_1);\n    uVar2 \u003d param_1[1] + (int)local_20;\n    param_1[1] \u003d uVar2;\n    if ((int)local_1c \u003c 0) {\n      uVar2 \u003d uVar2 - 1;\n      *param_1 \u003d local_1c + 0x3c;\n    }\n    else {\n      *param_1 \u003d local_1c;\n    }\n    if ((int)local_1c \u003c 0) {\n      param_1[1] \u003d uVar2;\n    }\n  }\n  if (0x3b \u003c param_1[1]) {\n    div((int)\u0026local_20,param_1[1]);\n    bVar5 \u003d (int)local_1c \u003c 0;\n    uVar3 \u003d param_1[2] + (int)local_20;\n    param_1[2] \u003d uVar3;\n    uVar2 \u003d local_1c;\n    if (bVar5) {\n      uVar2 \u003d local_1c + 0x3c;\n      uVar3 \u003d uVar3 - 1;\n    }\n    if (!bVar5) {\n      param_1[1] \u003d uVar2;\n    }\n    if (bVar5) {\n      param_1[1] \u003d uVar2;\n    }\n    if (bVar5) {\n      param_1[2] \u003d uVar3;\n    }\n  }\n  if (0x17 \u003c param_1[2]) {\n    div((int)\u0026local_20,param_1[2]);\n    bVar5 \u003d (int)local_1c \u003c 0;\n    uVar3 \u003d param_1[3] + (int)local_20;\n    param_1[3] \u003d uVar3;\n    uVar2 \u003d local_1c;\n    if (bVar5) {\n      uVar2 \u003d local_1c + 0x18;\n      uVar3 \u003d uVar3 - 1;\n    }\n    if (!bVar5) {\n      param_1[2] \u003d uVar2;\n    }\n    if (bVar5) {\n      param_1[2] \u003d uVar2;\n    }\n    if (bVar5) {\n      param_1[3] \u003d uVar3;\n    }\n  }\n  if (0xb \u003c param_1[4]) {\n    div((int)\u0026local_20,param_1[4]);\n    bVar5 \u003d (int)local_1c \u003c 0;\n    uVar2 \u003d param_1[5] + (int)local_20;\n    param_1[5] \u003d uVar2;\n    if (bVar5) {\n      local_1c \u003d local_1c + 0xc;\n      uVar2 \u003d uVar2 - 1;\n    }\n    if (!bVar5) {\n      param_1[4] \u003d local_1c;\n    }\n    if (bVar5) {\n      param_1[4] \u003d local_1c;\n    }\n    if (bVar5) {\n      param_1[5] \u003d uVar2;\n    }\n  }\n  uVar2 \u003d param_1[5];\n  if ((uVar2 \u0026 3) \u003d\u003d 0) {\n    if (uVar2 \u003d\u003d (uVar2 / 100) * 100) {\n      if ((uVar2 + 0x76c) % 400 \u003d\u003d 0) {\n        iVar4 \u003d 0x1d;\n      }\n      else {\n        iVar4 \u003d 0x1c;\n      }\n    }\n    else {\n      iVar4 \u003d 0x1d;\n    }\n  }\n  else {\n    iVar4 \u003d 0x1c;\n  }\n  if ((int)param_1[3] \u003c 1) {\n    while ((int)param_1[3] \u003c 1) {\n      uVar2 \u003d param_1[4];\n      param_1[4] \u003d uVar2 - 1;\n      if (uVar2 - 1 \u003d\u003d 0xffffffff) {\n        uVar3 \u003d param_1[5];\n        uVar2 \u003d uVar3 - 1;\n        param_1[4] \u003d 0xb;\n        param_1[5] \u003d uVar2;\n        if ((uVar2 \u0026 3) \u003d\u003d 0) {\n          if (uVar2 \u003d\u003d (uVar2 / 100) * 100) {\n            if ((uVar3 + 0x76b) % 400 \u003d\u003d 0) {\n              iVar4 \u003d 0x1d;\n            }\n            else {\n              iVar4 \u003d 0x1c;\n            }\n          }\n          else {\n            iVar4 \u003d 0x1d;\n          }\n        }\n        else {\n          iVar4 \u003d 0x1c;\n        }\n      }\n      iVar1 \u003d iVar4;\n      if (param_1[4] !\u003d 1) {\n        iVar1 \u003d *(int *)(\u0026DAYS_IN_MONTH + param_1[4] * 4);\n      }\n      param_1[3] \u003d iVar1 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar2 \u003d param_1[4];\n      iVar1 \u003d iVar4;\n      if (uVar2 !\u003d 1) {\n        iVar1 \u003d *(int *)(\u0026DAYS_IN_MONTH + uVar2 * 4);\n      }\n      if ((int)param_1[3] \u003c\u003d iVar1) break;\n      param_1[3] \u003d param_1[3] - iVar1;\n      param_1[4] \u003d uVar2 + 1;\n      if (uVar2 + 1 \u003d\u003d 0xc) {\n        uVar3 \u003d param_1[5];\n        uVar2 \u003d uVar3 + 1;\n        param_1[4] \u003d 0;\n        param_1[5] \u003d uVar2;\n        if ((uVar2 \u0026 3) \u003d\u003d 0) {\n          if (uVar2 % 100 \u003d\u003d 0) {\n            if ((uVar3 + 0x76d) % 400 \u003d\u003d 0) {\n              iVar4 \u003d 0x1d;\n            }\n            else {\n              iVar4 \u003d 0x1c;\n            }\n          }\n          else {\n            iVar4 \u003d 0x1d;\n          }\n        }\n        else {\n          iVar4 \u003d 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mktime"
      ],
      "called": [
        "div"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mktime": {
      "entrypoint": "0x000047e4",
      "current_name": "mktime",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\ntime_t mktime(tm *__tp)\n\n{\n  longlong lVar1;\n  int *piVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  time_t tVar15;\n  bool bVar16;\n  \n  piVar2 \u003d (int *)__gettzinfo();\n  validate_structure(__tp);\n  uVar11 \u003d __tp-\u003etm_year;\n  iVar10 \u003d __tp-\u003etm_mday + -1 + *(int *)(\u0026_DAYS_BEFORE_MONTH + __tp-\u003etm_mon * 4);\n  if (((1 \u003c __tp-\u003etm_mon) \u0026\u0026 ((uVar11 \u0026 3) \u003d\u003d 0)) \u0026\u0026\n     ((uVar11 !\u003d (uVar11 / 100) * 100 || (uVar11 + 0x76c \u003d\u003d ((uVar11 + 0x76c) / 400) * 400)))) {\n    iVar10 \u003d iVar10 + 1;\n  }\n  __tp-\u003etm_yday \u003d iVar10;\n  if (20000 \u003c (int)\u0026DAT_00002710 + uVar11) {\n    return -1;\n  }\n  if ((int)uVar11 \u003c 0x47) {\n    if (uVar11 !\u003d 0x46) {\n      for (uVar8 \u003d 0x45; (int)uVar11 \u003c (int)uVar8; uVar8 \u003d uVar8 - 1) {\n        if ((uVar8 \u0026 3) \u003d\u003d 0) {\n          if (uVar8 \u003d\u003d (uVar8 / 100) * 100) {\n            if ((uVar8 + 0x76c) % 400 \u003d\u003d 0) {\n              iVar6 \u003d 0x16e;\n            }\n            else {\n              iVar6 \u003d 0x16d;\n            }\n          }\n          else {\n            iVar6 \u003d 0x16e;\n          }\n        }\n        else {\n          iVar6 \u003d 0x16d;\n        }\n        iVar10 \u003d iVar10 - iVar6;\n      }\n      if ((uVar8 \u0026 3) \u003d\u003d 0) {\n        if (uVar11 \u003d\u003d (uVar11 / 100) * 100) {\n          iVar6 \u003d 0x16d;\n          if ((uVar11 + 0x76c) % 400 \u003d\u003d 0) {\n            iVar6 \u003d 0x16e;\n          }\n        }\n        else {\n          iVar6 \u003d 0x16e;\n        }\n      }\n      else {\n        iVar6 \u003d 0x16d;\n      }\n      iVar10 \u003d iVar10 - iVar6;\n    }\n  }\n  else {\n    uVar8 \u003d 0x46;\n    do {\n      if ((uVar8 \u0026 3) \u003d\u003d 0) {\n        if (uVar8 % 100 \u003d\u003d 0) {\n          if ((uVar8 + 0x76c) % 400 \u003d\u003d 0) {\n            iVar6 \u003d 0x16e;\n          }\n          else {\n            iVar6 \u003d 0x16d;\n          }\n        }\n        else {\n          iVar6 \u003d 0x16e;\n        }\n      }\n      else {\n        iVar6 \u003d 0x16d;\n      }\n      uVar8 \u003d uVar8 + 1;\n      iVar10 \u003d iVar10 + iVar6;\n    } while (uVar11 !\u003d uVar8);\n  }\n  lVar1 \u003d (longlong)iVar10 * 0x15180 +\n          (longlong)(__tp-\u003etm_hour * 0xe10 + __tp-\u003etm_min * 0x3c + __tp-\u003etm_sec);\n  uVar14 \u003d (uint)lVar1;\n  iVar6 \u003d (int)((ulonglong)lVar1 \u003e\u003e 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  uVar8 \u003d _daylight;\n  if (_daylight \u003d\u003d 0) {\nLAB_00004934:\n    tVar15 \u003d uVar14 + piVar2[10];\n  }\n  else {\n    uVar13 \u003d __tp-\u003etm_isdst;\n    uVar12 \u003d uVar13;\n    if (0 \u003c (int)uVar13) {\n      uVar12 \u003d 1;\n    }\n    if ((piVar2[1] \u003d\u003d __tp-\u003etm_year + 0x76c) || (iVar4 \u003d __tzcalc_limits(), iVar4 !\u003d 0)) {\n      uVar9 \u003d piVar2[0x14];\n      uVar3 \u003d piVar2[0x12];\n      uVar7 \u003d piVar2[10];\n      uVar8 \u003d uVar3 - uVar7;\n      iVar4 \u003d (piVar2[0x13] - ((int)uVar7 \u003e\u003e 0x1f)) - (uint)(uVar3 \u003c uVar7);\n      if (((int)((iVar6 - iVar4) - (uint)(uVar14 \u003c uVar8)) \u003c 0 \u003d\u003d\n           (SBORROW4(iVar6,iVar4) !\u003d SBORROW4(iVar6 - iVar4,(uint)(uVar14 \u003c uVar8)))) \u0026\u0026\n         (iVar5 \u003d (piVar2[0x13] - ((int)uVar9 \u003e\u003e 0x1f)) - (uint)(uVar3 \u003c uVar9),\n         bVar16 \u003d uVar14 \u003c uVar3 - uVar9,\n         (int)((iVar6 - iVar5) - (uint)bVar16) \u003c 0 !\u003d\n         (SBORROW4(iVar6,iVar5) !\u003d SBORROW4(iVar6 - iVar5,(uint)bVar16)))) goto LAB_00004a88;\n      uVar3 \u003d piVar2[8] - uVar9;\n      iVar5 \u003d (piVar2[9] - ((int)uVar9 \u003e\u003e 0x1f)) - (uint)((uint)piVar2[8] \u003c uVar9);\n      if (*piVar2 !\u003d 0) {\n        if ((int)((iVar6 - iVar5) - (uint)(uVar14 \u003c uVar3)) \u003c 0 \u003d\u003d\n            (SBORROW4(iVar6,iVar5) !\u003d SBORROW4(iVar6 - iVar5,(uint)(uVar14 \u003c uVar3))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar8 \u003d 0;\n        if ((int)uVar13 \u003c 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar13 \u003d uVar12 ^ uVar8;\n        uVar12 \u003d uVar8;\n        if (uVar13 \u003d\u003d 1) {\n          if (uVar8 \u003d\u003d 0) {\n            iVar6 \u003d uVar9 - uVar7;\n          }\n          else {\n            iVar6 \u003d uVar7 - uVar9;\n          }\n          iVar4 \u003d __tp-\u003etm_mday;\n          uVar14 \u003d uVar14 + iVar6;\n          __tp-\u003etm_sec \u003d __tp-\u003etm_sec + iVar6;\n          validate_structure(__tp);\n          iVar4 \u003d __tp-\u003etm_mday - iVar4;\n          if (iVar4 !\u003d 0) {\n            if (iVar4 \u003c 2) {\n              if (iVar4 \u003d\u003d -2 || iVar4 + 2 \u003c 0 !\u003d SCARRY4(iVar4,2)) {\n                iVar4 \u003d 1;\n              }\n            }\n            else {\n              iVar4 \u003d -1;\n            }\n            iVar6 \u003d iVar4 + __tp-\u003etm_yday;\n            iVar10 \u003d iVar10 + iVar4;\n            if (iVar6 \u003c 0) {\n              uVar8 \u003d uVar11 - 1;\n              if ((uVar8 \u0026 3) \u003d\u003d 0) {\n                if (uVar8 \u003d\u003d (uVar8 / 100) * 100) {\n                  iVar6 \u003d 0x16d;\n                  if ((uVar11 + 0x76b) % 400 !\u003d 0) {\n                    iVar6 \u003d 0x16c;\n                  }\n                }\n                else {\n                  iVar6 \u003d 0x16d;\n                }\n              }\n              else {\n                iVar6 \u003d 0x16c;\n              }\n            }\n            else {\n              if ((uVar11 \u0026 3) \u003d\u003d 0) {\n                if (uVar11 \u003d\u003d (uVar11 / 100) * 100) {\n                  iVar4 \u003d 0x16d;\n                  if ((uVar11 + 0x76c) % 400 \u003d\u003d 0) {\n                    iVar4 \u003d 0x16e;\n                  }\n                }\n                else {\n                  iVar4 \u003d 0x16e;\n                }\n              }\n              else {\n                iVar4 \u003d 0x16d;\n              }\n              if (iVar4 \u003c\u003d iVar6) {\n                iVar6 \u003d iVar6 - iVar4;\n              }\n            }\n            __tp-\u003etm_yday \u003d iVar6;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar6 - iVar5) - (uint)(uVar14 \u003c uVar3)) \u003c 0 !\u003d\n          (SBORROW4(iVar6,iVar5) !\u003d SBORROW4(iVar6 - iVar5,(uint)(uVar14 \u003c uVar3)))) {\nLAB_0000491e:\n        if ((int)((iVar6 - iVar4) - (uint)(uVar14 \u003c uVar8)) \u003c 0 \u003d\u003d\n            (SBORROW4(iVar6,iVar4) !\u003d SBORROW4(iVar6 - iVar4,(uint)(uVar14 \u003c uVar8))))\n        goto LAB_0000492a;\n      }\n      if (-1 \u003c (int)uVar13) {\n        uVar8 \u003d 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar8 \u003d uVar12;\n      if (uVar12 !\u003d 1) goto LAB_00004934;\n    }\n    tVar15 \u003d uVar14 + piVar2[0x14];\n    uVar8 \u003d 1;\n  }\n  __tz_unlock();\n  __tp-\u003etm_isdst \u003d uVar8;\n  __tp-\u003etm_wday \u003d (iVar10 + 4U) % 7;\n  return tVar15;\n}\n\n",
      "renaming": {},
      "calling": [
        "rtc_set_time",
        "rtc_set_alarm"
      ],
      "called": [
        "__tzcalc_limits",
        "validate_structure",
        "_tzset_unlocked",
        "__gettzinfo",
        "__tz_lock",
        "__tz_unlock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_free_r": {
      "entrypoint": "0x00004b34",
      "current_name": "_free_r",
      "code": "\nvoid _free_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int *piVar1;\n  int **extraout_r1;\n  int **ppiVar2;\n  int **ppiVar3;\n  int **ppiVar4;\n  int **ppiVar5;\n  bool bVar6;\n  \n  if (param_2 \u003d\u003d 0) {\n    return;\n  }\n  ppiVar5 \u003d (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) \u003c 0) {\n    ppiVar5 \u003d (int **)((int)ppiVar5 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  ppiVar3 \u003d (int **)\u0026__malloc_free_list;\n  if (__malloc_free_list \u003d\u003d (int **)0x0) {\n    ppiVar5[1] \u003d (int *)0x0;\n    ppiVar2 \u003d extraout_r1;\n    __malloc_free_list \u003d ppiVar5;\n  }\n  else {\n    ppiVar4 \u003d __malloc_free_list;\n    if (ppiVar5 \u003c __malloc_free_list) {\n      ppiVar2 \u003d (int **)*ppiVar5;\n      ppiVar3 \u003d (int **)((int)ppiVar5 + (int)ppiVar2);\n      bVar6 \u003d __malloc_free_list \u003d\u003d ppiVar3;\n      if (bVar6) {\n        ppiVar3 \u003d (int **)*__malloc_free_list;\n        __malloc_free_list \u003d (int **)__malloc_free_list[1];\n      }\n      ppiVar5[1] \u003d (int *)__malloc_free_list;\n      __malloc_free_list \u003d ppiVar5;\n      if (bVar6) {\n        ppiVar3 \u003d (int **)((int)ppiVar3 + (int)ppiVar2);\n        *ppiVar5 \u003d (int *)ppiVar3;\n      }\n    }\n    else {\n      do {\n        ppiVar3 \u003d ppiVar4;\n        ppiVar4 \u003d (int **)ppiVar3[1];\n        if (ppiVar4 \u003d\u003d (int **)0x0) break;\n      } while (ppiVar4 \u003c\u003d ppiVar5);\n      ppiVar2 \u003d (int **)*ppiVar3;\n      if ((int **)((int)ppiVar3 + (int)ppiVar2) \u003d\u003d ppiVar5) {\n        ppiVar2 \u003d (int **)((int)ppiVar2 + (int)*ppiVar5);\n        *ppiVar3 \u003d (int *)ppiVar2;\n        if (ppiVar4 \u003d\u003d (int **)((int)ppiVar3 + (int)ppiVar2)) {\n          piVar1 \u003d *ppiVar4;\n          ppiVar3[1] \u003d ppiVar4[1];\n          ppiVar2 \u003d (int **)((int)ppiVar2 + (int)piVar1);\n          *ppiVar3 \u003d (int *)ppiVar2;\n        }\n      }\n      else if (ppiVar5 \u003c (int **)((int)ppiVar3 + (int)ppiVar2)) {\n        *param_1 \u003d 0xc;\n      }\n      else {\n        ppiVar2 \u003d (int **)((int)ppiVar5 + (int)*ppiVar5);\n        bVar6 \u003d ppiVar4 \u003d\u003d ppiVar2;\n        if (bVar6) {\n          ppiVar2 \u003d (int **)*ppiVar4;\n          ppiVar4 \u003d (int **)ppiVar4[1];\n        }\n        ppiVar5[1] \u003d (int *)ppiVar4;\n        if (bVar6) {\n          ppiVar2 \u003d (int **)((int)ppiVar2 + (int)*ppiVar5);\n          *ppiVar5 \u003d (int *)ppiVar2;\n        }\n        ppiVar3[1] \u003d (int *)ppiVar5;\n      }\n    }\n  }\n  __malloc_unlock(param_1,ppiVar2,ppiVar3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__ssrefill_r",
        "__swsetup_r",
        "__sflush_r",
        "__srefill_r",
        "free",
        "_realloc_r"
      ],
      "called": [
        "__malloc_lock",
        "__malloc_unlock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_r": {
      "entrypoint": "0x00004bd0",
      "current_name": "_malloc_r",
      "code": "\nuint _malloc_r(_reent *param_1,uint param_2)\n\n{\n  uint *puVar1;\n  void *pvVar2;\n  int iVar3;\n  uint uVar4;\n  uint *puVar5;\n  uint uVar6;\n  \n  uVar6 \u003d (param_2 + 3 \u0026 0xfffffffc) + 8;\n  if (uVar6 \u003c 0xc) {\n    uVar6 \u003d 0xc;\n  }\n  if (((int)uVar6 \u003c 0) || (uVar6 \u003c param_2)) {\n    param_1-\u003e_errno \u003d 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 \u003d __malloc_free_list;\n    for (puVar5 \u003d __malloc_free_list; puVar5 !\u003d (uint *)0x0; puVar5 \u003d (uint *)puVar5[1]) {\n      uVar4 \u003d *puVar5 - uVar6;\n      if (-1 \u003c (int)uVar4) {\n        if (0xb \u003c uVar4) {\n          *puVar5 \u003d uVar4;\n          puVar5 \u003d (uint *)((int)puVar5 + uVar4);\n          goto LAB_00004c34;\n        }\n        if (puVar1 \u003d\u003d puVar5) {\n          __malloc_free_list \u003d (uint *)puVar5[1];\n        }\n        if (puVar1 !\u003d puVar5) {\n          puVar1[1] \u003d (uint)(uint *)puVar5[1];\n        }\n        goto LAB_00004c42;\n      }\n      puVar1 \u003d puVar5;\n    }\n    if (__malloc_sbrk_start \u003d\u003d (void *)0x0) {\n      __malloc_sbrk_start \u003d _sbrk_r(param_1,0);\n    }\n    puVar1 \u003d (uint *)_sbrk_r(param_1,uVar6);\n    if ((puVar1 !\u003d (uint *)0xffffffff) \u0026\u0026\n       ((puVar5 \u003d (uint *)((int)puVar1 + 3U \u0026 0xfffffffc), puVar1 \u003d\u003d puVar5 ||\n        (pvVar2 \u003d _sbrk_r(param_1,(int)puVar5 - (int)puVar1), pvVar2 !\u003d (void *)0xffffffff)))) {\nLAB_00004c34:\n      *puVar5 \u003d uVar6;\nLAB_00004c42:\n      __malloc_unlock(param_1);\n      uVar6 \u003d (int)puVar5 + 0xbU \u0026 0xfffffff8;\n      iVar3 \u003d uVar6 - (int)(puVar5 + 1);\n      if (iVar3 \u003d\u003d 0) {\n        return uVar6;\n      }\n      *(uint *)((int)puVar5 + iVar3) \u003d (int)(puVar5 + 1) - uVar6;\n      return uVar6;\n    }\n    param_1-\u003e_errno \u003d 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfmoreglue",
        "_tzset_unlocked_r",
        "__submore",
        "__smakebuf_r",
        "_realloc_r"
      ],
      "called": [
        "_sbrk_r",
        "__malloc_lock",
        "__malloc_unlock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "iprintf": {
      "entrypoint": "0x00004c84",
      "current_name": "iprintf",
      "code": "\nint iprintf(char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *pcVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 \u003d _impure_ptr;\n  pcVar2 \u003d __format;\n  uStack_c \u003d in_r1;\n  uStack_8 \u003d in_r2;\n  uStack_4 \u003d in_r3;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  iVar1 \u003d _vfprintf_r(iVar1,*(undefined4 *)(iVar1 + 8),__format,\u0026uStack_c,pcVar2,\u0026uStack_c);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "hard_fault_handler",
        "list",
        "_print_time",
        "read",
        "write",
        "_saul",
        "_rtc_handler",
        "cpu_print_last_instruction",
        "main_trampoline",
        "handle_input_line",
        "ps",
        "phydat_dump",
        "probe",
        "print_help",
        "core_panic"
      ],
      "called": [
        "__sinit",
        "_vfprintf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "putchar": {
      "entrypoint": "0x00004cb4",
      "current_name": "putchar",
      "code": "\nint putchar(int __c)\n\n{\n  int iVar1;\n  undefined4 in_r3;\n  \n  iVar1 \u003d _impure_ptr;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  iVar1 \u003d _putc_r(iVar1,__c,*(undefined4 *)(iVar1 + 8),in_r3);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_putchar"
      ],
      "called": [
        "__sinit",
        "_putc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_puts_r": {
      "entrypoint": "0x00004cdc",
      "current_name": "_puts_r",
      "code": "\nundefined4 _puts_r(int param_1,int param_2)\n\n{\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  undefined4 uVar5;\n  char *pcVar6;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  ppcVar4 \u003d *(char ***)(param_1 + 8);\n  if (*(int *)(param_1 + 0x18) \u003d\u003d 0) {\n    __sinit(param_1);\n  }\n  if (ppcVar4 \u003d\u003d (char **)\u0026__sf_fake_stdin) {\n    ppcVar4 \u003d *(char ***)(param_1 + 4);\n  }\n  else if (ppcVar4 \u003d\u003d (char **)\u0026__sf_fake_stdout) {\n    ppcVar4 \u003d *(char ***)(param_1 + 8);\n  }\n  else if (ppcVar4 \u003d\u003d (char **)\u0026__sf_fake_stderr) {\n    ppcVar4 \u003d *(char ***)(param_1 + 0xc);\n  }\n  if ((-1 \u003c (int)ppcVar4[0x19] \u003c\u003c 0x1f) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(ppcVar4 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_acquire_recursive(ppcVar4[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(ppcVar4 + 3) \u003c\u003c 0x1c) \u003c 0) \u0026\u0026 (ppcVar4[4] !\u003d (char *)0x0)) ||\n     (iVar2 \u003d __swsetup_r(param_1,ppcVar4), iVar2 \u003d\u003d 0)) {\n    pcVar6 \u003d (char *)(param_2 + -1);\n    do {\n      while( true ) {\n        pcVar6 \u003d pcVar6 + 1;\n        cVar1 \u003d *pcVar6;\n        pcVar3 \u003d ppcVar4[2] + -1;\n        ppcVar4[2] \u003d pcVar3;\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          if (-1 \u003c (int)pcVar3) {\n            pcVar6 \u003d *ppcVar4;\n            uVar5 \u003d 10;\n            *ppcVar4 \u003d pcVar6 + 1;\n            *pcVar6 \u003d \u0027\\n\u0027;\n            goto LAB_00004d64;\n          }\n          iVar2 \u003d __swbuf_r(param_1,10,ppcVar4);\n          if (iVar2 !\u003d -1) {\n            uVar5 \u003d 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)pcVar3 \u003c 0) \u0026\u0026 (((int)pcVar3 \u003c (int)ppcVar4[6] || (cVar1 \u003d\u003d \u0027\\n\u0027)))) break;\n        pcVar3 \u003d *ppcVar4;\n        *ppcVar4 \u003d pcVar3 + 1;\n        *pcVar3 \u003d cVar1;\n      }\n      iVar2 \u003d __swbuf_r(param_1,cVar1,ppcVar4);\n    } while (iVar2 !\u003d -1);\n  }\nLAB_00004d60:\n  uVar5 \u003d 0xffffffff;\nLAB_00004d64:\n  if ((-1 \u003c (int)ppcVar4[0x19] \u003c\u003c 0x1f) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(ppcVar4 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_release_recursive(ppcVar4[0x16]);\n  }\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "puts"
      ],
      "called": [
        "__sinit",
        "__retarget_lock_acquire_recursive",
        "__swsetup_r",
        "__retarget_lock_release_recursive",
        "__swbuf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "puts": {
      "entrypoint": "0x00004db8",
      "current_name": "puts",
      "code": "\nint puts(char *__s)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _puts_r(_impure_ptr,__s);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "hard_fault_handler",
        "_alarm_handler",
        "list",
        "_rtc_usage",
        "_rtc_getalarm",
        "_rtc_setalarm",
        "read",
        "write",
        "_rtc_settime",
        "_rtc_gettime",
        "handle_input_line",
        "phydat_dump",
        "main",
        "print_help",
        "probe_all"
      ],
      "called": [
        "_puts_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sread": {
      "entrypoint": "0x00004dc8",
      "current_name": "__sread",
      "code": "\nvoid __sread(_reent *param_1,int param_2,void *param_3,size_t param_4)\n\n{\n  _ssize_t _Var1;\n  uint uVar2;\n  bool bVar3;\n  \n  _Var1 \u003d _read_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  bVar3 \u003d -1 \u003c _Var1;\n  if (bVar3) {\n    uVar2 \u003d *(int *)(param_2 + 0x54) + _Var1;\n  }\n  else {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) \u003d (short)uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_read_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__seofread": {
      "entrypoint": "0x00004dea",
      "current_name": "__seofread",
      "code": "\nundefined4 __seofread(void)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swrite": {
      "entrypoint": "0x00004dee",
      "current_name": "__swrite",
      "code": "\nvoid __swrite(_reent *param_1,int param_2,void *param_3,size_t param_4)\n\n{\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x17) \u003c 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_write_r",
        "_lseek_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sseek": {
      "entrypoint": "0x00004e26",
      "current_name": "__sseek",
      "code": "\nvoid __sseek(_reent *param_1,int param_2,_off_t param_3,int param_4)\n\n{\n  _off_t _Var1;\n  ushort uVar2;\n  bool bVar3;\n  \n  _Var1 \u003d _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  bVar3 \u003d _Var1 \u003d\u003d -1;\n  if (bVar3) {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  }\n  else {\n    *(_off_t *)(param_2 + 0x54) \u003d _Var1;\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sclose": {
      "entrypoint": "0x00004e4a",
      "current_name": "__sclose",
      "code": "\nvoid __sclose(_reent *param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_close_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcmp": {
      "entrypoint": "0x00004e52",
      "current_name": "strcmp",
      "code": "\nint strcmp(char *__s1,char *__s2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  do {\n    uVar2 \u003d (uint)(byte)*__s1;\n    bVar1 \u003d *__s2;\n    bVar3 \u003d uVar2 \u003d\u003d 1;\n    if (uVar2 !\u003d 0) {\n      bVar3 \u003d uVar2 \u003d\u003d bVar1;\n    }\n    __s1 \u003d (char *)((byte *)__s1 + 1);\n    __s2 \u003d (char *)((byte *)__s2 + 1);\n  } while (bVar3);\n  return uVar2 - bVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "find_handler",
        "handle_input_line",
        "_tzset_unlocked_r",
        "strcmp",
        "read",
        "_saul"
      ],
      "called": [
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strncmp": {
      "entrypoint": "0x00004e66",
      "current_name": "strncmp",
      "code": "\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  byte *pbVar1;\n  int iVar2;\n  byte *pbVar3;\n  uint uVar4;\n  \n  if (__n \u003d\u003d 0) {\n    iVar2 \u003d 0;\n  }\n  else {\n    pbVar3 \u003d (byte *)(__s2 + -1);\n    pbVar1 \u003d (byte *)__s1;\n    do {\n      uVar4 \u003d (uint)*pbVar1;\n      pbVar3 \u003d pbVar3 + 1;\n      if ((uVar4 !\u003d *pbVar3) || (pbVar1 + 1 \u003d\u003d (byte *)(__s1 + __n))) break;\n      pbVar1 \u003d pbVar1 + 1;\n    } while (uVar4 !\u003d 0);\n    iVar2 \u003d uVar4 - *pbVar3;\n  }\n  return iVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_findenv_r",
        "_rtc_handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_strtol_l.isra.0": {
      "entrypoint": "0x00004e8c",
      "current_name": "_strtol_l.isra.0",
      "code": "\nuint _strtol_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 \u003d param_2;\n  do {\n    pbVar8 \u003d pbVar9;\n    pbVar9 \u003d pbVar8 + 1;\n    uVar2 \u003d (uint)*pbVar8;\n    uVar3 \u003d (byte)(\u0026DAT_00007a99)[uVar2] \u0026 8;\n  } while (((\u0026DAT_00007a99)[uVar2] \u0026 8) !\u003d 0);\n  if (uVar2 \u003d\u003d 0x2d) {\n    uVar2 \u003d (uint)*pbVar9;\n    uVar3 \u003d 1;\n    pbVar9 \u003d pbVar8 + 2;\n  }\n  else if (uVar2 \u003d\u003d 0x2b) {\n    uVar2 \u003d (uint)*pbVar9;\n    pbVar9 \u003d pbVar8 + 2;\n  }\n  if (param_4 \u003d\u003d 0) {\n    if (uVar2 !\u003d 0x30) {\n      param_4 \u003d 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 !\u003d 0x10) || (uVar2 !\u003d 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 \u0026 0xdf) \u003d\u003d 0x58) {\n    uVar2 \u003d (uint)pbVar9[1];\n    param_4 \u003d 0x10;\n    pbVar9 \u003d pbVar9 + 2;\n  }\n  else {\n    uVar2 \u003d 0x30;\n    if (param_4 \u003d\u003d 0) {\n      param_4 \u003d 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 \u003d uVar3 + 0x7fffffff;\n  iVar5 \u003d 0;\n  uVar7 \u003d uVar6 / param_4;\n  uVar1 \u003d 0;\n  do {\n    uVar4 \u003d uVar2 - 0x30;\n    if (9 \u003c uVar4) {\n      if (uVar2 - 0x41 \u003c 0x1a) {\n        uVar4 \u003d uVar2 - 0x37;\n      }\n      else {\n        if (0x19 \u003c uVar2 - 0x61) break;\n        uVar4 \u003d uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 \u003c\u003d (int)uVar4) break;\n    if (iVar5 !\u003d -1) {\n      if ((uVar7 \u003c uVar1) || ((uVar7 \u003d\u003d uVar1 \u0026\u0026 ((int)(uVar6 - param_4 * uVar7) \u003c (int)uVar4)))) {\n        iVar5 \u003d -1;\n      }\n      else {\n        uVar1 \u003d uVar1 * param_4 + uVar4;\n        iVar5 \u003d 1;\n      }\n    }\n    uVar2 \u003d (uint)*pbVar9;\n    pbVar9 \u003d pbVar9 + 1;\n  } while( true );\n  if (iVar5 \u003d\u003d -1) {\n    *param_1 \u003d 0x22;\n    uVar1 \u003d uVar6;\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 !\u003d 0) {\n      uVar1 \u003d -uVar1;\n    }\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 \u003d\u003d 0) goto LAB_00004f64;\n  }\n  param_2 \u003d pbVar9 + -1;\nLAB_00004f64:\n  *param_3 \u003d param_2;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "strtol",
        "_strtol_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_strtol_r": {
      "entrypoint": "0x00004f80",
      "current_name": "_strtol_r",
      "code": "\nuint _strtol_r(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 \u003d param_2;\n  do {\n    pbVar8 \u003d pbVar9;\n    pbVar9 \u003d pbVar8 + 1;\n    uVar2 \u003d (uint)*pbVar8;\n    uVar3 \u003d (byte)(\u0026DAT_00007a99)[uVar2] \u0026 8;\n  } while (((\u0026DAT_00007a99)[uVar2] \u0026 8) !\u003d 0);\n  if (uVar2 \u003d\u003d 0x2d) {\n    uVar2 \u003d (uint)*pbVar9;\n    uVar3 \u003d 1;\n    pbVar9 \u003d pbVar8 + 2;\n  }\n  else if (uVar2 \u003d\u003d 0x2b) {\n    uVar2 \u003d (uint)*pbVar9;\n    pbVar9 \u003d pbVar8 + 2;\n  }\n  if (param_4 \u003d\u003d 0) {\n    if (uVar2 !\u003d 0x30) {\n      param_4 \u003d 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_4 !\u003d 0x10) || (uVar2 !\u003d 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 \u0026 0xdf) \u003d\u003d 0x58) {\n    uVar2 \u003d (uint)pbVar9[1];\n    param_4 \u003d 0x10;\n    pbVar9 \u003d pbVar9 + 2;\n  }\n  else {\n    uVar2 \u003d 0x30;\n    if (param_4 \u003d\u003d 0) {\n      param_4 \u003d 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 \u003d uVar3 + 0x7fffffff;\n  iVar5 \u003d 0;\n  uVar7 \u003d uVar6 / param_4;\n  uVar1 \u003d 0;\n  do {\n    uVar4 \u003d uVar2 - 0x30;\n    if (9 \u003c uVar4) {\n      if (uVar2 - 0x41 \u003c 0x1a) {\n        uVar4 \u003d uVar2 - 0x37;\n      }\n      else {\n        if (0x19 \u003c uVar2 - 0x61) break;\n        uVar4 \u003d uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 \u003c\u003d (int)uVar4) break;\n    if (iVar5 !\u003d -1) {\n      if ((uVar7 \u003c uVar1) || ((uVar7 \u003d\u003d uVar1 \u0026\u0026 ((int)(uVar6 - param_4 * uVar7) \u003c (int)uVar4)))) {\n        iVar5 \u003d -1;\n      }\n      else {\n        uVar1 \u003d uVar1 * param_4 + uVar4;\n        iVar5 \u003d 1;\n      }\n    }\n    uVar2 \u003d (uint)*pbVar9;\n    pbVar9 \u003d pbVar9 + 1;\n  } while( true );\n  if (iVar5 \u003d\u003d -1) {\n    *param_1 \u003d 0x22;\n    uVar1 \u003d uVar6;\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 !\u003d 0) {\n      uVar1 \u003d -uVar1;\n    }\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 \u003d\u003d 0) goto LAB_00004f64;\n  }\n  param_2 \u003d pbVar9 + -1;\nLAB_00004f64:\n  *param_3 \u003d param_2;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_strtol_l.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtol": {
      "entrypoint": "0x00004f84",
      "current_name": "strtol",
      "code": "\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d _strtol_l_isra_0(_impure_ptr,__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_parse_time",
        "atoi"
      ],
      "called": [
        "_strtol_l.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__tzcalc_limits": {
      "entrypoint": "0x00004f98",
      "current_name": "__tzcalc_limits",
      "code": "\nundefined4 __tzcalc_limits(uint param_1)\n\n{\n  uint *puVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  int iVar4;\n  uint *puVar5;\n  int iVar6;\n  uint uVar7;\n  int iVar8;\n  int iVar9;\n  uint uVar10;\n  \n  puVar1 \u003d (uint *)__gettzinfo();\n  if ((int)param_1 \u003c 0x7b2) {\n    uVar2 \u003d 0;\n  }\n  else {\n    iVar6 \u003d (param_1 - 0x7b2) * 0x16d + ((int)(param_1 - 0x7b1) \u003e\u003e 2) +\n            (param_1 - 0x76d) / 0xffffff9c + (param_1 - 0x641) / 400;\n    puVar1[1] \u003d param_1;\n    uVar10 \u003d (uint)(param_1 % 400 \u003d\u003d 0);\n    puVar5 \u003d puVar1;\n    do {\n      uVar3 \u003d puVar5[5];\n      if (*(char *)(puVar5 + 2) \u003d\u003d \u0027J\u0027) {\n        if ((((param_1 \u0026 3) \u003d\u003d 0) \u0026\u0026 (param_1 % 100 !\u003d 0)) || (param_1 % 400 \u003d\u003d 0)) {\n          if ((int)uVar3 \u003c 0x3c) {\n            iVar4 \u003d 0;\n          }\n          else {\n            iVar4 \u003d 1;\n          }\n        }\n        else {\n          iVar4 \u003d 0;\n        }\n        iVar4 \u003d iVar4 + iVar6 + uVar3 + -1;\n      }\n      else if (*(char *)(puVar5 + 2) \u003d\u003d \u0027D\u0027) {\n        iVar4 \u003d iVar6 + uVar3;\n      }\n      else {\n        uVar7 \u003d uVar10;\n        if (((param_1 \u0026 3) \u003d\u003d 0) \u0026\u0026 (param_1 % 100 !\u003d 0)) {\n          uVar7 \u003d 1;\n        }\n        iVar8 \u003d 0;\n        iVar4 \u003d iVar6;\n        while( true ) {\n          iVar8 \u003d iVar8 + 1;\n          if ((int)puVar5[3] \u003c\u003d iVar8) break;\n          iVar4 \u003d iVar4 + *(int *)(\u0026UNK_00007b98 + iVar8 * 4 + uVar7 * 0x30);\n        }\n        iVar9 \u003d uVar3 - (iVar4 + 4U) % 7;\n        if (iVar9 \u003c 0) {\n          iVar9 \u003d iVar9 + 7;\n        }\n        for (iVar9 \u003d (puVar5[4] - 1) * 7 + iVar9;\n            *(int *)(\u0026UNK_00007b98 + iVar8 * 4 + uVar7 * 0x30) \u003c\u003d iVar9; iVar9 \u003d iVar9 + -7) {\n        }\n        iVar4 \u003d iVar4 + iVar9;\n      }\n      uVar3 \u003d puVar5[10] + iVar4 * 0x15180 + puVar5[6];\n      puVar5[8] \u003d uVar3;\n      puVar5[9] \u003d (int)uVar3 \u003e\u003e 0x1f;\n      puVar5 \u003d puVar5 + 10;\n    } while (puVar1 + 0x14 !\u003d puVar5);\n    uVar3 \u003d puVar1[9];\n    uVar10 \u003d puVar1[0x13];\n    *puVar1 \u003d (uint)((int)((uVar3 - uVar10) - (uint)(puVar1[8] \u003c puVar1[0x12])) \u003c 0 !\u003d\n                    (SBORROW4(uVar3,uVar10) !\u003d\n                    SBORROW4(uVar3 - uVar10,(uint)(puVar1[8] \u003c puVar1[0x12]))));\n    uVar2 \u003d 1;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_tzset_unlocked_r",
        "mktime"
      ],
      "called": [
        "__gettzinfo"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__tz_lock": {
      "entrypoint": "0x000050e8",
      "current_name": "__tz_lock",
      "code": "\nvoid __tz_lock(void)\n\n{\n  __retarget_lock_acquire(\u0026__lock___tz_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mktime"
      ],
      "called": [
        "__retarget_lock_acquire"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__tz_unlock": {
      "entrypoint": "0x000050f4",
      "current_name": "__tz_unlock",
      "code": "\nvoid __tz_unlock(void)\n\n{\n  __retarget_lock_release(\u0026__lock___tz_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mktime"
      ],
      "called": [
        "__retarget_lock_release"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_tzset_unlocked": {
      "entrypoint": "0x00005100",
      "current_name": "_tzset_unlocked",
      "code": "\nvoid _tzset_unlocked(void)\n\n{\n  _tzset_unlocked_r(_impure_ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "mktime"
      ],
      "called": [
        "_tzset_unlocked_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_tzset_unlocked_r": {
      "entrypoint": "0x0000510c",
      "current_name": "_tzset_unlocked_r",
      "code": "\nvoid _tzset_unlocked_r(undefined4 param_1)\n\n{\n  int iVar1;\n  char *pcVar2;\n  size_t sVar3;\n  int iVar4;\n  int iVar5;\n  ulong uVar6;\n  undefined uVar7;\n  char *pcVar8;\n  bool bVar9;\n  ushort *puVar10;\n  int *piVar11;\n  ushort *puVar12;\n  int *piVar13;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  iVar1 \u003d __gettzinfo();\n  pcVar2 \u003d (char *)_getenv_r(param_1,\u0026DAT_00007a5c);\n  if (pcVar2 \u003d\u003d (char *)0x0) {\n    _tzname \u003d \u0026DAT_00007a5f;\n    DAT_1fff02e8 \u003d \u0026DAT_00007a5f;\n    _daylight \u003d pcVar2;\n    _timezone \u003d pcVar2;\n    free(prev_tzenv);\n    prev_tzenv \u003d (char *)0x0;\n  }\n  else if ((prev_tzenv \u003d\u003d (char *)0x0) || (iVar4 \u003d strcmp(pcVar2,prev_tzenv), iVar4 !\u003d 0)) {\n    free(prev_tzenv);\n    sVar3 \u003d strlen(pcVar2);\n    prev_tzenv \u003d (char *)_malloc_r(param_1,sVar3 + 1);\n    if (prev_tzenv !\u003d (char *)0x0) {\n      strcpy(prev_tzenv,pcVar2);\n    }\n    if (*pcVar2 \u003d\u003d \u0027:\u0027) {\n      pcVar2 \u003d pcVar2 + 1;\n    }\n    iVar4 \u003d siscanf(pcVar2,\"%10[^0-9,+-]%n\",\u0026__tzname_std,\u0026local_30);\n    if (0 \u003c iVar4) {\n      pcVar8 \u003d pcVar2 + local_30;\n      if (pcVar2[local_30] \u003d\u003d \u0027-\u0027) {\n        pcVar8 \u003d pcVar8 + 1;\n        iVar4 \u003d -1;\n      }\n      else {\n        if (pcVar2[local_30] \u003d\u003d \u0027+\u0027) {\n          pcVar8 \u003d pcVar8 + 1;\n        }\n        iVar4 \u003d 1;\n      }\n      local_3a \u003d 0;\n      local_38 \u003d 0;\n      puVar10 \u003d \u0026local_3a;\n      piVar11 \u003d \u0026local_30;\n      puVar12 \u003d \u0026local_38;\n      piVar13 \u003d \u0026local_30;\n      iVar5 \u003d siscanf(pcVar8,\"%hu%n:%hu%n:%hu%n\",\u0026local_3c,\u0026local_30,\u0026local_3a,\u0026local_30,\u0026local_38,\n                      \u0026local_30);\n      if (0 \u003c iVar5) {\n        *(uint *)(iVar1 + 0x28) \u003d\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar4;\n        _tzname \u003d \u0026__tzname_std;\n        pcVar8 \u003d pcVar8 + local_30;\n        iVar4 \u003d siscanf(pcVar8,\"%10[^0-9,+-]%n\",\u0026__tzname_dst,\u0026local_30,puVar10,piVar11,puVar12,\n                        piVar13);\n        if (iVar4 \u003c 1) {\n          DAT_1fff02e8 \u003d _tzname;\n          _timezone \u003d *(char **)(iVar1 + 0x28);\n          _daylight \u003d (char *)0x0;\n        }\n        else {\n          DAT_1fff02e8 \u003d \u0026__tzname_dst;\n          pcVar2 \u003d pcVar8 + local_30;\n          if (pcVar8[local_30] \u003d\u003d \u0027-\u0027) {\n            pcVar2 \u003d pcVar2 + 1;\n            iVar4 \u003d -1;\n          }\n          else {\n            if (pcVar8[local_30] \u003d\u003d \u0027+\u0027) {\n              pcVar2 \u003d pcVar2 + 1;\n            }\n            iVar4 \u003d 1;\n          }\n          local_3c \u003d 0;\n          local_3a \u003d 0;\n          local_38 \u003d 0;\n          local_30 \u003d 0;\n          iVar5 \u003d siscanf(pcVar2,\"%hu%n:%hu%n:%hu%n\",\u0026local_3c,\u0026local_30,\u0026local_3a,\u0026local_30,\n                          \u0026local_38,\u0026local_30);\n          if (iVar5 \u003c 1) {\n            iVar4 \u003d *(int *)(iVar1 + 0x28) + -0xe10;\n          }\n          else {\n            iVar4 \u003d ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar4;\n          }\n          *(int *)(iVar1 + 0x50) \u003d iVar4;\n          pcVar2 \u003d pcVar2 + local_30;\n          bVar9 \u003d false;\n          iVar4 \u003d iVar1;\n          while( true ) {\n            if (*pcVar2 \u003d\u003d \u0027,\u0027) {\n              pcVar2 \u003d pcVar2 + 1;\n            }\n            if (*pcVar2 \u003d\u003d \u0027M\u0027) {\n              iVar5 \u003d siscanf(pcVar2,\"M%hu%n.%hu%n.%hu%n\",\u0026local_36,\u0026local_30,\u0026local_34,\u0026local_30,\n                              \u0026local_32,\u0026local_30);\n              if (iVar5 !\u003d 3) {\n                return;\n              }\n              if (0xb \u003c local_36 - 1) {\n                return;\n              }\n              if (4 \u003c local_34 - 1) {\n                return;\n              }\n              if (6 \u003c local_32) {\n                return;\n              }\n              *(uint *)(iVar4 + 0xc) \u003d (uint)local_36;\n              *(uint *)(iVar4 + 0x10) \u003d (uint)local_34;\n              *(undefined *)(iVar4 + 8) \u003d 0x4d;\n              *(uint *)(iVar4 + 0x14) \u003d (uint)local_32;\n              pcVar8 \u003d pcVar2 + local_30;\n            }\n            else {\n              if (*pcVar2 \u003d\u003d \u0027J\u0027) {\n                pcVar2 \u003d pcVar2 + 1;\n                uVar7 \u003d 0x4a;\n              }\n              else {\n                uVar7 \u003d 0x44;\n              }\n              uVar6 \u003d strtoul(pcVar2,local_2c,10);\n              local_32 \u003d (ushort)uVar6;\n              pcVar8 \u003d local_2c[0];\n              if (local_2c[0] \u003d\u003d pcVar2) {\n                if (bVar9) {\n                  *(undefined *)(iVar1 + 0x30) \u003d 0x4d;\n                  *(undefined4 *)(iVar1 + 0x34) \u003d 0xb;\n                  *(undefined4 *)(iVar1 + 0x38) \u003d 1;\n                  *(undefined4 *)(iVar1 + 0x3c) \u003d 0;\n                }\n                else {\n                  *(undefined *)(iVar1 + 8) \u003d 0x4d;\n                  *(undefined4 *)(iVar1 + 0xc) \u003d 3;\n                  *(undefined4 *)(iVar1 + 0x10) \u003d 2;\n                  *(undefined4 *)(iVar1 + 0x14) \u003d 0;\n                }\n              }\n              else {\n                *(undefined *)(iVar4 + 8) \u003d uVar7;\n                *(ulong *)(iVar4 + 0x14) \u003d uVar6 \u0026 0xffff;\n              }\n            }\n            local_3c \u003d 2;\n            local_3a \u003d 0;\n            local_38 \u003d 0;\n            local_30 \u003d 0;\n            if (*pcVar8 \u003d\u003d \u0027/\u0027) {\n              siscanf(pcVar8,\"/%hu%n:%hu%n:%hu%n\",\u0026local_3c,\u0026local_30,\u0026local_3a,\u0026local_30,\u0026local_38,\n                      \u0026local_30);\n            }\n            *(uint *)(iVar4 + 0x18) \u003d\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar4 \u003d iVar4 + 0x28;\n            pcVar2 \u003d pcVar8 + local_30;\n            if (bVar9) break;\n            bVar9 \u003d true;\n          }\n          __tzcalc_limits(*(undefined4 *)(iVar1 + 4));\n          _timezone \u003d *(char **)(iVar1 + 0x28);\n          _daylight \u003d (char *)(*(int *)(iVar1 + 0x50) - (int)_timezone);\n          if (_daylight !\u003d (char *)0x0) {\n            _daylight \u003d (char *)0x1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_tzset_unlocked"
      ],
      "called": [
        "__tzcalc_limits",
        "strcmp",
        "siscanf",
        "__gettzinfo",
        "strtoul",
        "strlen",
        "free",
        "_getenv_r",
        "strcpy",
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swbuf_r": {
      "entrypoint": "0x00005404",
      "current_name": "__swbuf_r",
      "code": "\nuint __swbuf_r(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_3 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_3 \u003d *(int **)(param_1 + 4);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026__sf_fake_stdout) {\n    param_3 \u003d *(int **)(param_1 + 8);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026__sf_fake_stderr) {\n    param_3 \u003d *(int **)(param_1 + 0xc);\n  }\n  param_3[2] \u003d param_3[6];\n  uVar2 \u003d (uint)*(ushort *)(param_3 + 3);\n  iVar1 \u003d uVar2 \u003c\u003c 0x1c;\n  if (((iVar1 \u003c 0) \u0026\u0026 (uVar2 \u003d param_3[4], uVar2 !\u003d 0)) ||\n     (iVar1 \u003d __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 \u003d\u003d 0)) {\n    iVar1 \u003d *param_3 - param_3[4];\n    param_2 \u003d param_2 \u0026 0xff;\n    if ((iVar1 \u003c param_3[5]) || (iVar1 \u003d _fflush_r(param_1,param_3), iVar1 \u003d\u003d 0)) {\n      param_3[2] \u003d param_3[2] + -1;\n      puVar3 \u003d (undefined *)*param_3;\n      *param_3 \u003d (int)(puVar3 + 1);\n      *puVar3 \u003d (char)param_2;\n      if (param_3[5] !\u003d iVar1 + 1) {\n        if (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x1f)) {\n          return param_2;\n        }\n        if (param_2 !\u003d 10) {\n          return param_2;\n        }\n      }\n      iVar1 \u003d _fflush_r(param_1,param_3);\n      if (iVar1 \u003d\u003d 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_puts_r",
        "__sfputc_r",
        "_putc_r"
      ],
      "called": [
        "__sinit",
        "_fflush_r",
        "__swsetup_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swsetup_r": {
      "entrypoint": "0x000054a8",
      "current_name": "__swsetup_r",
      "code": "\nuint __swsetup_r(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  ushort uVar3;\n  uint uVar4;\n  uint uVar5;\n  \n  iVar2 \u003d _impure_ptr;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d *(undefined4 **)(iVar2 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(undefined4 **)(iVar2 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(undefined4 **)(iVar2 + 0xc);\n  }\n  uVar4 \u003d (uint)*(ushort *)(param_2 + 3);\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  if (-1 \u003c (int)(uVar4 \u003c\u003c 0x1c)) {\n    if (-1 \u003c (int)(uVar4 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar4 \u003c\u003c 0x1d) \u003c 0) {\n      if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] \u003d 0;\n      }\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xffdb;\n      param_2[1] \u003d 0;\n      *param_2 \u003d param_2[4];\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] \u003d\u003d 0) \u0026\u0026 ((*(ushort *)(param_2 + 3) \u0026 0x280) !\u003d 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar1 \u003d *(ushort *)(param_2 + 3);\n  uVar4 \u003d (uint)uVar1;\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  uVar5 \u003d uVar4 \u0026 1;\n  if ((uVar1 \u0026 1) \u003d\u003d 0) {\n    if (-1 \u003c (int)(uVar4 \u003c\u003c 0x1e)) {\n      uVar5 \u003d param_2[5];\n    }\n    param_2[2] \u003d uVar5;\n  }\n  else {\n    param_2[2] \u003d 0;\n    param_2[6] \u003d -param_2[5];\n  }\n  if (param_2[4] !\u003d 0) {\n    return 0;\n  }\n  if ((uVar1 \u0026 0x80) \u003d\u003d 0) {\n    return uVar4 \u0026 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) \u003d uVar3 | 0x40;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_puts_r",
        "__swbuf_r",
        "_vfprintf_r"
      ],
      "called": [
        "__sinit",
        "_free_r",
        "__smakebuf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "div": {
      "entrypoint": "0x00005584",
      "current_name": "div",
      "code": "\ndiv_t div(int __numer,int __denom)\n\n{\n  uint in_r2;\n  int iVar1;\n  uint uVar2;\n  div_t dVar3;\n  \n  uVar2 \u003d (uint)__denom / in_r2;\n  iVar1 \u003d __denom - in_r2 * uVar2;\n  if (__denom \u003c 0) {\n    if (0 \u003c iVar1) {\n      uVar2 \u003d uVar2 - 1;\n      iVar1 \u003d iVar1 + in_r2;\n    }\n  }\n  else if (iVar1 \u003c 0) {\n    uVar2 \u003d uVar2 + 1;\n    iVar1 \u003d iVar1 - in_r2;\n  }\n  *(uint *)__numer \u003d uVar2;\n  *(int *)(__numer + 4) \u003d iVar1;\n  dVar3.rem \u003d __denom;\n  dVar3.quot \u003d __numer;\n  return dVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "validate_structure"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getc_r": {
      "entrypoint": "0x000055ac",
      "current_name": "_getc_r",
      "code": "\nuint _getc_r(int param_1,byte **param_2)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d (byte **)\u0026__sf_fake_stdin) {\n    param_2 \u003d *(byte ***)(param_1 + 4);\n  }\n  else if (param_2 \u003d\u003d (byte **)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(byte ***)(param_1 + 8);\n  }\n  else if (param_2 \u003d\u003d (byte **)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(byte ***)(param_1 + 0xc);\n  }\n  if ((-1 \u003c (int)param_2[0x19] \u003c\u003c 0x1f) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_acquire_recursive(param_2[0x16]);\n  }\n  pbVar2 \u003d param_2[1];\n  param_2[1] \u003d pbVar2 + -1;\n  if ((int)(pbVar2 + -1) \u003c 0) {\n    uVar1 \u003d __srget_r(param_1,param_2);\n  }\n  else {\n    pbVar2 \u003d *param_2;\n    *param_2 \u003d pbVar2 + 1;\n    uVar1 \u003d (uint)*pbVar2;\n  }\n  if ((-1 \u003c (int)param_2[0x19] \u003c\u003c 0x1f) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_release_recursive(param_2[0x16]);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "getchar"
      ],
      "called": [
        "__sinit",
        "__retarget_lock_acquire_recursive",
        "__retarget_lock_release_recursive",
        "__srget_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_findenv_r": {
      "entrypoint": "0x0000562c",
      "current_name": "_findenv_r",
      "code": "\nchar * _findenv_r(undefined4 param_1,char *param_2,int *param_3)\n\n{\n  char cVar1;\n  char **ppcVar2;\n  int iVar3;\n  char *pcVar4;\n  char **ppcVar5;\n  size_t __n;\n  \n  __env_lock();\n  pcVar4 \u003d param_2;\n  if (environ !\u003d (char **)0x0) {\n    do {\n      cVar1 \u003d *pcVar4;\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        __n \u003d (int)pcVar4 - (int)param_2;\n        ppcVar2 \u003d environ;\n        while( true ) {\n          ppcVar5 \u003d ppcVar2;\n          if (*ppcVar5 \u003d\u003d (char *)0x0) break;\n          iVar3 \u003d strncmp(*ppcVar5,param_2,__n);\n          ppcVar2 \u003d ppcVar5 + 1;\n          if ((iVar3 \u003d\u003d 0) \u0026\u0026 (pcVar4 \u003d *ppcVar5, pcVar4[__n] \u003d\u003d \u0027\u003d\u0027)) {\n            *param_3 \u003d (int)ppcVar5 - (int)environ \u003e\u003e 2;\n            __env_unlock(param_1);\n            return pcVar4 + __n + 1;\n          }\n        }\n        break;\n      }\n      pcVar4 \u003d pcVar4 + 1;\n    } while (cVar1 !\u003d \u0027\u003d\u0027);\n  }\n  __env_unlock(param_1);\n  return (char *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_getenv_r"
      ],
      "called": [
        "__env_lock",
        "strncmp",
        "__env_unlock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getenv_r": {
      "entrypoint": "0x000056a0",
      "current_name": "_getenv_r",
      "code": "\nvoid _getenv_r(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  \n  uStack_c \u003d param_2;\n  uStack_8 \u003d param_3;\n  _findenv_r(param_1,param_2,\u0026uStack_c,param_4,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_tzset_unlocked_r"
      ],
      "called": [
        "_findenv_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__gettzinfo": {
      "entrypoint": "0x000056b0",
      "current_name": "__gettzinfo",
      "code": "\nundefined1 * __gettzinfo(void)\n\n{\n  return \u0026tzinfo;\n}\n\n",
      "renaming": {},
      "calling": [
        "__tzcalc_limits",
        "_tzset_unlocked_r",
        "mktime"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swhatbuf_r": {
      "entrypoint": "0x000056b8",
      "current_name": "__swhatbuf_r",
      "code": "\nundefined4 __swhatbuf_r(_reent *param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  stat sStack_68;\n  \n  if ((*(short *)(param_2 + 0xe) \u003c 0) ||\n     (iVar1 \u003d _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),\u0026sStack_68), iVar1 \u003c 0)) {\n    *param_4 \u003d 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x18) \u003c 0) {\n      uVar2 \u003d 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *param_4 \u003d (uint)((sStack_68.st_mode \u0026 0xf000) \u003d\u003d 0x2000);\n  }\n  uVar2 \u003d 0x400;\nLAB_000056f8:\n  *param_3 \u003d uVar2;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_fstat_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__smakebuf_r": {
      "entrypoint": "0x00005700",
      "current_name": "__smakebuf_r",
      "code": "\nvoid __smakebuf_r(_reent *param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  _reent *local_18;\n  int *local_14;\n  \n  if (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1e)) {\n    local_18 \u003d param_1;\n    local_14 \u003d param_2;\n    uVar1 \u003d __swhatbuf_r(param_1,param_2,\u0026local_18,\u0026local_14);\n    iVar2 \u003d _malloc_r(param_1,local_18);\n    if (iVar2 !\u003d 0) {\n      param_1-\u003e__cleanup \u003d _cleanup_r + 1;\n      *param_2 \u003d iVar2;\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x80;\n      param_2[5] \u003d (int)local_18;\n      param_2[4] \u003d iVar2;\n      if ((local_14 !\u003d (int *)0x0) \u0026\u0026\n         (iVar2 \u003d _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 !\u003d 0)) {\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) \u003d uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) \u003c\u003c 0x16 \u003c 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 2;\n  }\n  *param_2 \u003d (int)param_2 + 0x47;\n  param_2[4] \u003d (int)param_2 + 0x47;\n  param_2[5] \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r",
        "__srefill_r"
      ],
      "called": [
        "_isatty_r",
        "__swhatbuf_r",
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x00005780",
      "current_name": "free",
      "code": "\nvoid free(void *__ptr)\n\n{\n  _free_r(_impure_ptr,__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_tzset_unlocked_r"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_lock": {
      "entrypoint": "0x00005790",
      "current_name": "__malloc_lock",
      "code": "\nvoid __malloc_lock(void)\n\n{\n  __retarget_lock_acquire_recursive(\u0026__lock___malloc_recursive_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_free_r",
        "_malloc_r"
      ],
      "called": [
        "__retarget_lock_acquire_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_unlock": {
      "entrypoint": "0x0000579c",
      "current_name": "__malloc_unlock",
      "code": "\nvoid __malloc_unlock(void)\n\n{\n  __retarget_lock_release_recursive(\u0026__lock___malloc_recursive_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_free_r",
        "_malloc_r"
      ],
      "called": [
        "__retarget_lock_release_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfputc_r": {
      "entrypoint": "0x000057a8",
      "current_name": "__sfputc_r",
      "code": "\nint __sfputc_r(undefined4 param_1,int param_2,undefined4 *param_3)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  \n  iVar1 \u003d param_3[2] + -1;\n  param_3[2] \u003d iVar1;\n  if ((iVar1 \u003c 0) \u0026\u0026 ((iVar1 \u003c (int)param_3[6] || (param_2 \u003d\u003d 10)))) {\n    iVar1 \u003d __swbuf_r();\n    return iVar1;\n  }\n  puVar2 \u003d (undefined *)*param_3;\n  *param_3 \u003d puVar2 + 1;\n  *puVar2 \u003d (char)param_2;\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfputs_r"
      ],
      "called": [
        "__swbuf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfputs_r": {
      "entrypoint": "0x000057d2",
      "current_name": "__sfputs_r",
      "code": "\nint __sfputs_r(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 \u003d param_3 + param_4;\n  iVar3 \u003d param_4;\n  do {\n    if (param_3 \u003d\u003d puVar2) {\n      return 0;\n    }\n    iVar1 \u003d __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 \u003d iVar1 + 1;\n    param_3 \u003d param_3 + 1;\n  } while (param_4 !\u003d 0);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfprintf_r"
      ],
      "called": [
        "__sfputc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_vfprintf_r": {
      "entrypoint": "0x000057f8",
      "current_name": "_vfprintf_r",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x000059f0) */\n\nint _vfprintf_r(int param_1,undefined4 *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  int iVar2;\n  int iVar3;\n  void *pvVar4;\n  int *piVar5;\n  byte *pbVar6;\n  int unaff_r7;\n  byte *pbVar7;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d *(undefined4 **)(param_1 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(undefined4 **)(param_1 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n  }\n  if ((-1 \u003c (int)(param_2[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_acquire_recursive(param_2[0x16]);\n  }\n  if (((-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1c)) || (param_2[4] \u003d\u003d 0)) \u0026\u0026\n     (iVar2 \u003d __swsetup_r(param_1,param_2), iVar2 !\u003d 0)) {\n    if ((-1 \u003c (int)(param_2[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16)))\n    {\n      __retarget_lock_release_recursive(param_2[0x16]);\n    }\n    return -1;\n  }\n  local_74 \u003d 0;\n  local_6f \u003d 0x20;\n  local_6e \u003d 0x30;\n  pbVar7 \u003d param_3;\n  local_8c \u003d param_4;\nLAB_0000588e:\n  pbVar6 \u003d pbVar7;\n  if (*pbVar6 !\u003d 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar7 \u003d pbVar6 + 1;\n  if (*pbVar6 \u003d\u003d 0x25) {\nLAB_0000589a:\n    iVar2 \u003d (int)pbVar6 - (int)param_3;\n    if (iVar2 !\u003d 0) {\n      iVar3 \u003d __sfputs_r(param_1,param_2,param_3,iVar2);\n      if (iVar3 \u003d\u003d -1) {\nLAB_00005a06:\n        if ((-1 \u003c (int)(param_2[0x19] \u003c\u003c 0x1f)) \u0026\u0026\n           (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16))) {\n          __retarget_lock_release_recursive(param_2[0x16]);\n        }\n        if ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x19) \u003c 0) {\n          return -1;\n        }\n        return local_74;\n      }\n      local_74 \u003d local_74 + iVar2;\n    }\n    if (*pbVar6 \u003d\u003d 0) goto LAB_00005a06;\n    local_84 \u003d -1;\n    uStack_80 \u003d 0;\n    local_88 \u003d 0;\n    local_7c \u003d 0;\n    local_45 \u003d 0;\n    local_30 \u003d 0;\n    pbVar7 \u003d pbVar6 + 1;\n    while( true ) {\n      pbVar6 \u003d pbVar7 + 1;\n      pvVar4 \u003d memchr(\"#-0+ \",(uint)*pbVar7,5);\n      if (pvVar4 \u003d\u003d (void *)0x0) break;\n      local_88 \u003d 1 \u003c\u003c ((int)pvVar4 - 0x7bfcU \u0026 0xff) | local_88;\n      pbVar7 \u003d pbVar6;\n    }\n    if ((int)(local_88 \u003c\u003c 0x1b) \u003c 0) {\n      local_45 \u003d 0x20;\n    }\n    if ((int)(local_88 \u003c\u003c 0x1c) \u003c 0) {\n      local_45 \u003d 0x2b;\n    }\n    if (*pbVar7 \u003d\u003d 0x2a) {\n      piVar5 \u003d local_8c + 1;\n      local_7c \u003d *local_8c;\n      local_8c \u003d piVar5;\n      if (local_7c \u003c 0) {\n        local_7c \u003d -local_7c;\n        local_88 \u003d local_88 | 2;\n      }\n    }\n    else {\n      bVar1 \u003d false;\n      iVar2 \u003d local_7c;\n      pbVar6 \u003d pbVar7;\n      while( true ) {\n        if (9 \u003c *pbVar6 - 0x30) break;\n        iVar2 \u003d iVar2 * 10 + (*pbVar6 - 0x30);\n        bVar1 \u003d true;\n        pbVar6 \u003d pbVar6 + 1;\n      }\n      if (bVar1) {\n        local_7c \u003d iVar2;\n      }\n    }\n    if (*pbVar6 \u003d\u003d 0x2e) {\n      if (pbVar6[1] \u003d\u003d 0x2a) {\n        local_84 \u003d *local_8c;\n        if (local_84 \u003c 0) {\n          local_84 \u003d -1;\n        }\n        pbVar6 \u003d pbVar6 + 2;\n        local_8c \u003d local_8c + 1;\n      }\n      else {\n        bVar1 \u003d false;\n        local_84 \u003d 0;\n        iVar2 \u003d 0;\n        while( true ) {\n          pbVar6 \u003d pbVar6 + 1;\n          if (9 \u003c *pbVar6 - 0x30) break;\n          iVar2 \u003d iVar2 * 10 + (*pbVar6 - 0x30);\n          bVar1 \u003d true;\n        }\n        if (bVar1) {\n          local_84 \u003d iVar2;\n        }\n      }\n    }\n    pvVar4 \u003d memchr(\u0026DAT_00007c02,(uint)*pbVar6,3);\n    if (pvVar4 !\u003d (void *)0x0) {\n      local_88 \u003d local_88 | 0x40 \u003c\u003c ((int)pvVar4 - 0x7c02U \u0026 0xff);\n      pbVar6 \u003d pbVar6 + 1;\n    }\n    param_3 \u003d pbVar6 + 1;\n    local_70 \u003d *pbVar6;\n    pvVar4 \u003d memchr(\"efgEFG\",(uint)local_70,6);\n    if (pvVar4 \u003d\u003d (void *)0x0) {\n      unaff_r7 \u003d _printf_i(param_1,\u0026local_88,param_2,0x57d3,\u0026local_8c);\n      if (unaff_r7 \u003d\u003d -1) goto LAB_00005a06;\n    }\n    else {\n      local_8c \u003d (int *)(((int)local_8c + 7U \u0026 0xfffffff8) + 8);\n    }\n    local_74 \u003d local_74 + unaff_r7;\n    pbVar7 \u003d param_3;\n  }\n  goto LAB_0000588e;\n}\n\n",
      "renaming": {},
      "calling": [
        "iprintf"
      ],
      "called": [
        "__sinit",
        "_printf_i",
        "__retarget_lock_acquire_recursive",
        "memchr",
        "__sfputs_r",
        "__swsetup_r",
        "__retarget_lock_release_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_printf_common": {
      "entrypoint": "0x00005a58",
      "current_name": "_printf_common",
      "code": "\nundefined4\n_printf_common(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  bool bVar6;\n  \n  uVar4 \u003d param_2[4];\n  if ((int)param_2[4] \u003c (int)param_2[2]) {\n    uVar4 \u003d param_2[2];\n  }\n  *param_3 \u003d uVar4;\n  if (*(char *)((int)param_2 + 0x43) !\u003d \u0027\\0\u0027) {\n    *param_3 \u003d uVar4 + 1;\n  }\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *param_3 \u003d *param_3 + 2;\n  }\n  if ((*param_2 \u0026 6) \u003d\u003d 0) {\n    for (iVar1 \u003d 0; iVar1 \u003c (int)(param_2[3] - *param_3); iVar1 \u003d iVar1 + 1) {\n      iVar3 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar3 \u003d\u003d -1) goto LAB_00005afc;\n    }\n  }\n  uVar4 \u003d (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar4 !\u003d 0) {\n    uVar4 \u003d 1;\n  }\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *(undefined *)((int)param_2 + uVar4 + 0x43) \u003d 0x30;\n    *(undefined *)((int)param_2 + uVar4 + 0x44) \u003d *(undefined *)((int)param_2 + 0x45);\n    uVar4 \u003d uVar4 + 2;\n  }\n  iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar4);\n  if (iVar1 \u003d\u003d -1) {\nLAB_00005afc:\n    uVar2 \u003d 0xffffffff;\n  }\n  else {\n    uVar4 \u003d param_2[3];\n    bVar6 \u003d (*param_2 \u0026 6) \u003d\u003d 4;\n    if (bVar6) {\n      uVar4 \u003d uVar4 - *param_3;\n    }\n    if (bVar6) {\n      uVar4 \u003d uVar4 \u0026 ~((int)uVar4 \u003e\u003e 0x1f);\n    }\n    else {\n      uVar4 \u003d 0;\n    }\n    if ((int)param_2[4] \u003c (int)param_2[2]) {\n      uVar4 \u003d uVar4 + (param_2[2] - param_2[4]);\n    }\n    for (uVar5 \u003d 0; uVar4 !\u003d uVar5; uVar5 \u003d uVar5 + 1) {\n      iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 \u003d\u003d -1) goto LAB_00005afc;\n    }\n    uVar2 \u003d 0;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_printf_i"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_printf_i": {
      "entrypoint": "0x00005b34",
      "current_name": "_printf_i",
      "code": "\ncode * _printf_i(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  bool bVar1;\n  byte bVar2;\n  int iVar3;\n  code *pcVar4;\n  char *pcVar5;\n  void *pvVar6;\n  int iVar7;\n  char *__s;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  char **ppcVar12;\n  uint uVar13;\n  char *pcVar14;\n  uint *puVar15;\n  undefined4 uVar16;\n  code *local_24;\n  \n  bVar2 \u003d *(byte *)(param_2 + 6);\n  __s \u003d (char *)((int)param_2 + 0x43);\n  puVar15 \u003d param_2;\n  uVar16 \u003d param_3;\n  local_24 \u003d param_4;\n  if (0x78 \u003c bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) \u003d bVar2;\nLAB_00005bdc:\n    __s \u003d (char *)((int)param_2 + 0x42);\n    uVar8 \u003d 1;\nLAB_00005d28:\n    param_2[4] \u003d uVar8;\n    *(undefined *)((int)param_2 + 0x43) \u003d 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 \u003c 99) {\n    if (bVar2 \u003d\u003d 0) goto LAB_00005d06;\n    if (bVar2 \u003d\u003d 0x58) {\n      pcVar5 \u003d \"0123456789ABCDEF\";\n      *(undefined *)((int)param_2 + 0x45) \u003d 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 \u003d **param_5;\n    *param_5 \u003d *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) \u003d (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 \u003d *param_2;\n    puVar9 \u003d *param_5;\n    if ((int)(uVar10 \u003c\u003c 0x18) \u003c 0) {\n      uVar8 \u003d *puVar9;\n      *param_5 \u003d puVar9 + 1;\n    }\n    else {\n      uVar8 \u003d *puVar9;\n      *param_5 \u003d puVar9 + 1;\n      if ((uVar10 \u0026 0x40) !\u003d 0) {\n        uVar8 \u003d (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 \u003c 0) {\n      uVar8 \u003d -uVar8;\n      *(undefined *)((int)param_2 + 0x43) \u003d 0x2d;\n    }\n    pcVar5 \u003d \"0123456789ABCDEF\";\n    uVar10 \u003d 10;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 \u003d (uint **)*param_5;\n    uVar10 \u003d *param_2;\n    uVar8 \u003d param_2[5];\n    *param_5 \u003d (uint *)(ppuVar11 + 1);\n    puVar9 \u003d *ppuVar11;\n    if (((int)(uVar10 \u003c\u003c 0x18) \u003c 0) || (-1 \u003c (int)(uVar10 \u003c\u003c 0x19))) {\n      *puVar9 \u003d uVar8;\n    }\n    else {\n      *(short *)puVar9 \u003d (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] \u003d 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 \u003d *param_5;\n    uVar8 \u003d *param_2;\n    *param_5 \u003d puVar9 + 1;\n    if (((int)(uVar8 \u003c\u003c 0x18) \u003c 0) || (-1 \u003c (int)(uVar8 \u003c\u003c 0x19))) {\n      uVar8 \u003d *puVar9;\n    }\n    else {\n      uVar8 \u003d (uint)*(ushort *)puVar9;\n    }\n    pcVar5 \u003d \"0123456789ABCDEF\";\n    if (bVar2 \u003d\u003d 0x6f) {\n      uVar10 \u003d 8;\n    }\n    else {\n      uVar10 \u003d 10;\n    }\n    break;\n  case 0x70:\n    *param_2 \u003d *param_2 | 0x20;\n  case 0x78:\n    pcVar5 \u003d \"0123456789abcdef\";\n    *(undefined *)((int)param_2 + 0x45) \u003d 0x78;\nLAB_00005ca8:\n    uVar10 \u003d *param_2;\n    uVar8 \u003d **param_5;\n    *param_5 \u003d *param_5 + 1;\n    if ((-1 \u003c (int)(uVar10 \u003c\u003c 0x18)) \u0026\u0026 ((int)(uVar10 \u003c\u003c 0x19) \u003c 0)) {\n      uVar8 \u003d uVar8 \u0026 0xffff;\n    }\n    if ((int)(uVar10 \u003c\u003c 0x1f) \u003c 0) {\n      *param_2 \u003d uVar10 | 0x20;\n    }\n    if (uVar8 \u003d\u003d 0) {\n      *param_2 \u003d *param_2 \u0026 0xffffffdf;\n    }\n    uVar10 \u003d 0x10;\n    break;\n  case 0x73:\n    ppcVar12 \u003d (char **)*param_5;\n    *param_5 \u003d (uint *)(ppcVar12 + 1);\n    __s \u003d *ppcVar12;\n    pvVar6 \u003d memchr(__s,0,param_2[1]);\n    if (pvVar6 !\u003d (void *)0x0) {\n      param_2[1] \u003d (int)pvVar6 - (int)__s;\n    }\n    uVar8 \u003d param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) \u003d 0;\nLAB_00005c36:\n  uVar13 \u003d param_2[1];\n  param_2[2] \u003d uVar13;\n  if (-1 \u003c (int)uVar13) {\n    *param_2 \u003d *param_2 \u0026 0xfffffffb;\n  }\n  pcVar14 \u003d __s;\n  if ((uVar8 !\u003d 0) || (uVar13 !\u003d 0)) {\n    do {\n      pcVar14 \u003d pcVar14 + -1;\n      *pcVar14 \u003d pcVar5[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 \u003d uVar10 \u003c\u003d uVar8;\n      uVar8 \u003d uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 \u003d\u003d 8) \u0026\u0026 ((int)(*param_2 \u003c\u003c 0x1f) \u003c 0)) \u0026\u0026 ((int)param_2[1] \u003c\u003d (int)param_2[4])) {\n    pcVar14[-1] \u003d \u00270\u0027;\n    pcVar14 \u003d pcVar14 + -1;\n  }\n  param_2[4] \u003d (int)__s - (int)pcVar14;\n  __s \u003d pcVar14;\nLAB_00005c84:\n  iVar3 \u003d _printf_common(param_1,param_2,\u0026local_24,param_3,param_4,puVar15,uVar16);\n  if ((iVar3 \u003d\u003d -1) || (iVar3 \u003d (*param_4)(param_1,param_3,__s,param_2[4]), iVar3 \u003d\u003d -1)) {\nLAB_00005c98:\n    pcVar4 \u003d (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 \u003c\u003c 0x1e) \u003c 0) {\n      for (iVar3 \u003d 0; iVar3 \u003c (int)(param_2[3] - (int)local_24); iVar3 \u003d iVar3 + 1) {\n        iVar7 \u003d (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar7 \u003d\u003d -1) goto LAB_00005c98;\n      }\n    }\n    pcVar4 \u003d (code *)param_2[3];\n    if ((int)(code *)param_2[3] \u003c (int)local_24) {\n      pcVar4 \u003d local_24;\n    }\n  }\n  return pcVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfprintf_r"
      ],
      "called": [
        "memchr",
        "_printf_common"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_putc_r": {
      "entrypoint": "0x00005d80",
      "current_name": "_putc_r",
      "code": "\nuint _putc_r(int param_1,uint param_2,undefined4 *param_3)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_3 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_3 \u003d *(undefined4 **)(param_1 + 4);\n  }\n  else if (param_3 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_3 \u003d *(undefined4 **)(param_1 + 8);\n  }\n  else if (param_3 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_3 \u003d *(undefined4 **)(param_1 + 0xc);\n  }\n  if ((-1 \u003c (int)(param_3[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_acquire_recursive(param_3[0x16]);\n  }\n  iVar1 \u003d param_3[2] + -1;\n  param_3[2] \u003d iVar1;\n  if ((iVar1 \u003c 0) \u0026\u0026 ((iVar1 \u003c (int)param_3[6] || ((param_2 \u0026 0xff) \u003d\u003d 10)))) {\n    param_2 \u003d __swbuf_r(param_1,param_2,param_3);\n  }\n  else {\n    puVar2 \u003d (undefined *)*param_3;\n    *param_3 \u003d puVar2 + 1;\n    *puVar2 \u003d (char)param_2;\n    param_2 \u003d param_2 \u0026 0xff;\n  }\n  if ((-1 \u003c (int)(param_3[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_release_recursive(param_3[0x16]);\n  }\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "putchar"
      ],
      "called": [
        "__sinit",
        "__retarget_lock_acquire_recursive",
        "__retarget_lock_release_recursive",
        "__swbuf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__srget_r": {
      "entrypoint": "0x00005e10",
      "current_name": "__srget_r",
      "code": "\nuint __srget_r(int param_1,byte **param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  byte *pbVar3;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d (byte **)\u0026__sf_fake_stdin) {\n    param_2 \u003d *(byte ***)(param_1 + 4);\n  }\n  else if (param_2 \u003d\u003d (byte **)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(byte ***)(param_1 + 8);\n  }\n  else if (param_2 \u003d\u003d (byte **)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(byte ***)(param_1 + 0xc);\n  }\n  iVar1 \u003d __srefill_r(param_1,param_2);\n  if (iVar1 \u003d\u003d 0) {\n    param_2[1] \u003d param_2[1] + -1;\n    pbVar3 \u003d *param_2;\n    *param_2 \u003d pbVar3 + 1;\n    uVar2 \u003d (uint)*pbVar3;\n  }\n  else {\n    uVar2 \u003d 0xffffffff;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_getc_r"
      ],
      "called": [
        "__sinit",
        "__srefill_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "siscanf": {
      "entrypoint": "0x00005e68",
      "current_name": "siscanf",
      "code": "\nint siscanf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *local_80;\n  size_t local_7c;\n  undefined2 local_74;\n  undefined2 local_72;\n  char *local_70;\n  size_t local_6c;\n  undefined4 local_5c;\n  undefined4 local_4c;\n  undefined4 local_38;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  local_74 \u003d 0x204;\n  local_80 \u003d __s;\n  local_70 \u003d __s;\n  uStack_8 \u003d in_r2;\n  uStack_4 \u003d in_r3;\n  local_7c \u003d strlen(__s);\n  local_5c \u003d 0x4deb;\n  local_4c \u003d 0;\n  local_38 \u003d 0;\n  local_72 \u003d 0xffff;\n  local_6c \u003d local_7c;\n  iVar1 \u003d __ssvfiscanf_r(_impure_ptr,\u0026local_80,__format,\u0026uStack_8);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_tzset_unlocked_r"
      ],
      "called": [
        "strlen",
        "__ssvfiscanf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcpy": {
      "entrypoint": "0x00005ebc",
      "current_name": "strcpy",
      "code": "\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char cVar1;\n  char *pcVar2;\n  \n  pcVar2 \u003d __dest;\n  do {\n    cVar1 \u003d *__src;\n    *pcVar2 \u003d cVar1;\n    __src \u003d __src + 1;\n    pcVar2 \u003d pcVar2 + 1;\n  } while (cVar1 !\u003d \u0027\\0\u0027);\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "_tzset_unlocked_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x00005ecc",
      "current_name": "strlen",
      "code": "\nsize_t strlen(char *__s)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 \u003d __s;\n  do {\n    pcVar2 \u003d pcVar3 + 1;\n    cVar1 \u003d *pcVar3;\n    pcVar3 \u003d pcVar2;\n  } while (cVar1 !\u003d \u0027\\0\u0027);\n  return (size_t)(pcVar2 + (-1 - (int)__s));\n}\n\n",
      "renaming": {},
      "calling": [
        "_tzset_unlocked_r",
        "siscanf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_strtoul_l.isra.0": {
      "entrypoint": "0x00005edc",
      "current_name": "_strtoul_l.isra.0",
      "code": "\nuint _strtoul_l_isra_0(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 \u003d param_2;\n  do {\n    pbVar7 \u003d pbVar8;\n    pbVar8 \u003d pbVar7 + 1;\n    uVar2 \u003d (uint)*pbVar7;\n    bVar3 \u003d (\u0026DAT_00007a99)[uVar2] \u0026 8;\n  } while (((\u0026DAT_00007a99)[uVar2] \u0026 8) !\u003d 0);\n  if (uVar2 \u003d\u003d 0x2d) {\n    uVar2 \u003d (uint)*pbVar8;\n    bVar3 \u003d 1;\n    pbVar8 \u003d pbVar7 + 2;\n  }\n  else if (uVar2 \u003d\u003d 0x2b) {\n    uVar2 \u003d (uint)*pbVar8;\n    pbVar8 \u003d pbVar7 + 2;\n  }\n  if (param_4 \u003d\u003d 0) {\n    if (uVar2 !\u003d 0x30) {\n      param_4 \u003d 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 !\u003d 0x10) || (uVar2 !\u003d 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 \u0026 0xdf) \u003d\u003d 0x58) {\n    uVar2 \u003d (uint)pbVar8[1];\n    param_4 \u003d 0x10;\n    pbVar8 \u003d pbVar8 + 2;\n  }\n  else {\n    uVar2 \u003d 0x30;\n    if (param_4 \u003d\u003d 0) {\n      param_4 \u003d 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 \u003d 0;\n  uVar6 \u003d 0xffffffff / param_4;\n  uVar1 \u003d 0;\n  do {\n    uVar5 \u003d uVar2 - 0x30;\n    if (9 \u003c uVar5) {\n      if (uVar2 - 0x41 \u003c 0x1a) {\n        uVar5 \u003d uVar2 - 0x37;\n      }\n      else {\n        if (0x19 \u003c uVar2 - 0x61) break;\n        uVar5 \u003d uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 \u003c\u003d (int)uVar5) break;\n    if (((iVar4 \u003c 0) || (uVar6 \u003c uVar1)) ||\n       ((uVar6 \u003d\u003d uVar1 \u0026\u0026 ((int)~(param_4 * uVar6) \u003c (int)uVar5)))) {\n      iVar4 \u003d -1;\n    }\n    else {\n      uVar1 \u003d uVar1 * param_4 + uVar5;\n      iVar4 \u003d 1;\n    }\n    uVar2 \u003d (uint)*pbVar8;\n    pbVar8 \u003d pbVar8 + 1;\n  } while( true );\n  if (iVar4 \u003c 0) {\n    *param_1 \u003d 0x22;\n    uVar1 \u003d 0xffffffff;\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 !\u003d 0) {\n      uVar1 \u003d -uVar1;\n    }\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 \u003d\u003d 0) goto LAB_00005fb8;\n  }\n  param_2 \u003d pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 \u003d param_2;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_strtoul_r",
        "strtoul"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_strtoul_r": {
      "entrypoint": "0x00005fd4",
      "current_name": "_strtoul_r",
      "code": "\nuint _strtoul_r(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 \u003d param_2;\n  do {\n    pbVar7 \u003d pbVar8;\n    pbVar8 \u003d pbVar7 + 1;\n    uVar2 \u003d (uint)*pbVar7;\n    bVar3 \u003d (\u0026DAT_00007a99)[uVar2] \u0026 8;\n  } while (((\u0026DAT_00007a99)[uVar2] \u0026 8) !\u003d 0);\n  if (uVar2 \u003d\u003d 0x2d) {\n    uVar2 \u003d (uint)*pbVar8;\n    bVar3 \u003d 1;\n    pbVar8 \u003d pbVar7 + 2;\n  }\n  else if (uVar2 \u003d\u003d 0x2b) {\n    uVar2 \u003d (uint)*pbVar8;\n    pbVar8 \u003d pbVar7 + 2;\n  }\n  if (param_4 \u003d\u003d 0) {\n    if (uVar2 !\u003d 0x30) {\n      param_4 \u003d 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 !\u003d 0x10) || (uVar2 !\u003d 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 \u0026 0xdf) \u003d\u003d 0x58) {\n    uVar2 \u003d (uint)pbVar8[1];\n    param_4 \u003d 0x10;\n    pbVar8 \u003d pbVar8 + 2;\n  }\n  else {\n    uVar2 \u003d 0x30;\n    if (param_4 \u003d\u003d 0) {\n      param_4 \u003d 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 \u003d 0;\n  uVar6 \u003d 0xffffffff / param_4;\n  uVar1 \u003d 0;\n  do {\n    uVar5 \u003d uVar2 - 0x30;\n    if (9 \u003c uVar5) {\n      if (uVar2 - 0x41 \u003c 0x1a) {\n        uVar5 \u003d uVar2 - 0x37;\n      }\n      else {\n        if (0x19 \u003c uVar2 - 0x61) break;\n        uVar5 \u003d uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 \u003c\u003d (int)uVar5) break;\n    if (((iVar4 \u003c 0) || (uVar6 \u003c uVar1)) ||\n       ((uVar6 \u003d\u003d uVar1 \u0026\u0026 ((int)~(param_4 * uVar6) \u003c (int)uVar5)))) {\n      iVar4 \u003d -1;\n    }\n    else {\n      uVar1 \u003d uVar1 * param_4 + uVar5;\n      iVar4 \u003d 1;\n    }\n    uVar2 \u003d (uint)*pbVar8;\n    pbVar8 \u003d pbVar8 + 1;\n  } while( true );\n  if (iVar4 \u003c 0) {\n    *param_1 \u003d 0x22;\n    uVar1 \u003d 0xffffffff;\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 !\u003d 0) {\n      uVar1 \u003d -uVar1;\n    }\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 \u003d\u003d 0) goto LAB_00005fb8;\n  }\n  param_2 \u003d pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 \u003d param_2;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_strtoul_l.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtoul": {
      "entrypoint": "0x00005fd8",
      "current_name": "strtoul",
      "code": "\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 \u003d _strtoul_l_isra_0(_impure_ptr,__nptr,__endptr,__base);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_tzset_unlocked_r"
      ],
      "called": [
        "_strtoul_l.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__env_lock": {
      "entrypoint": "0x00005fec",
      "current_name": "__env_lock",
      "code": "\nvoid __env_lock(void)\n\n{\n  __retarget_lock_acquire_recursive(\u0026__lock___env_recursive_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_findenv_r"
      ],
      "called": [
        "__retarget_lock_acquire_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__env_unlock": {
      "entrypoint": "0x00005ff8",
      "current_name": "__env_unlock",
      "code": "\nvoid __env_unlock(void)\n\n{\n  __retarget_lock_release_recursive(\u0026__lock___env_recursive_mutex);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_findenv_r"
      ],
      "called": [
        "__retarget_lock_release_recursive"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memchr": {
      "entrypoint": "0x00006010",
      "current_name": "memchr",
      "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  char cVar4;\n  char cVar5;\n  byte *pbVar6;\n  uint *puVar7;\n  byte *pbVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  bool bVar17;\n  \n  uVar9 \u003d __c \u0026 0xff;\n  if ((int)__n \u003c 0x10) {\njoined_r0x00006070:\n    do {\n      if (__n \u003d\u003d 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 \u003d (uint *)((int)__s + 1);\n      bVar1 \u003d *__s;\n      __n \u003d __n - 1;\n      __s \u003d puVar7;\n    } while (bVar1 !\u003d uVar9);\n  }\n  else {\n    uVar10 \u003d (uint)__s \u0026 7;\n    while( true ) {\n      if (uVar10 \u003d\u003d 0) {\n        uVar10 \u003d uVar9 | uVar9 \u003c\u003c 8;\n        uVar10 \u003d uVar10 | uVar10 \u003c\u003c 0x10;\n        uVar11 \u003d __n \u0026 0xfffffff8;\n        do {\n          puVar7 \u003d (uint *)((int)__s + 8);\n                    /* WARNING: Load size is inaccurate */\n          uVar11 \u003d uVar11 - 8;\n          uVar12 \u003d *__s ^ uVar10;\n          uVar13 \u003d *(uint *)((int)__s + 4) ^ uVar10;\n          cVar2 \u003d -((char)uVar12 \u003d\u003d \u0027\\0\u0027);\n          cVar3 \u003d -((char)(uVar12 \u003e\u003e 8) \u003d\u003d \u0027\\0\u0027);\n          cVar4 \u003d -((char)(uVar12 \u003e\u003e 0x10) \u003d\u003d \u0027\\0\u0027);\n          cVar5 \u003d -((char)(uVar12 \u003e\u003e 0x18) \u003d\u003d \u0027\\0\u0027);\n          uVar12 \u003d CONCAT13(cVar5,CONCAT12(cVar4,CONCAT11(cVar3,cVar2)));\n          bVar14 \u003d (char)uVar13 !\u003d \u0027\\0\u0027;\n          bVar15 \u003d (char)(uVar13 \u003e\u003e 8) !\u003d \u0027\\0\u0027;\n          bVar16 \u003d (char)(uVar13 \u003e\u003e 0x10) !\u003d \u0027\\0\u0027;\n          bVar17 \u003d (char)(uVar13 \u003e\u003e 0x18) !\u003d \u0027\\0\u0027;\n          uVar13 \u003d CONCAT13(bVar17 * cVar5 - !bVar17,\n                            CONCAT12(bVar16 * cVar4 - !bVar16,\n                                     CONCAT11(bVar15 * cVar3 - !bVar15,bVar14 * cVar2 - !bVar14)));\n          if (uVar13 !\u003d 0) {\n            if (uVar12 \u003d\u003d 0) {\n              pbVar8 \u003d (byte *)((int)__s + 5);\n              uVar12 \u003d uVar13;\n            }\n            else {\n              pbVar8 \u003d (byte *)((int)__s + 1);\n            }\n            if ((uVar12 \u0026 1) \u003d\u003d 0) {\n              bVar14 \u003d (uVar12 \u0026 0x100) \u003d\u003d 0;\n              pbVar6 \u003d pbVar8 + 1;\n              if (bVar14) {\n                bVar14 \u003d (uVar12 \u0026 0x18000) \u003d\u003d 0;\n                pbVar6 \u003d pbVar8 + 2;\n              }\n              pbVar8 \u003d pbVar6;\n              if (bVar14) {\n                pbVar8 \u003d pbVar8 + 1;\n              }\n            }\n            return pbVar8 + -1;\n          }\n          __s \u003d puVar7;\n        } while (uVar11 !\u003d 0);\n        __n \u003d __n \u0026 7;\n        goto joined_r0x00006070;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 \u003d (uint *)((int)__s + 1);\n      __n \u003d __n - 1;\n      if (*__s \u003d\u003d uVar9) break;\n      uVar10 \u003d (uint)puVar7 \u0026 7;\n      __s \u003d puVar7;\n      if (__n \u003d\u003d 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)puVar7 + -1);\n}\n\n",
      "renaming": {},
      "calling": [
        "_printf_i",
        "_scanf_i",
        "_vfprintf_r",
        "__ssvfiscanf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x000060b0",
      "current_name": "memcpy",
      "code": "\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  \n  puVar2 \u003d (undefined *)(__n + (int)__src);\n  puVar3 \u003d (undefined *)((int)__dest + -1);\n  if ((undefined *)__src !\u003d puVar2) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      puVar1 \u003d (undefined *)((int)__src + 1);\n      puVar3 \u003d puVar3 + 1;\n      *puVar3 \u003d *__src;\n      __src \u003d puVar1;\n    } while (puVar1 !\u003d puVar2);\n    return __dest;\n  }\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "__submore",
        "_realloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_realloc_r": {
      "entrypoint": "0x000060cc",
      "current_name": "_realloc_r",
      "code": "\nvoid * _realloc_r(undefined4 param_1,void *param_2,uint param_3,undefined4 param_4)\n\n{\n  void *pvVar1;\n  uint uVar2;\n  \n  if (param_2 !\u003d (void *)0x0) {\n    if (param_3 \u003d\u003d 0) {\n      _free_r();\n      pvVar1 \u003d (void *)0x0;\n    }\n    else {\n      uVar2 \u003d _malloc_usable_size_r();\n      pvVar1 \u003d param_2;\n      if ((uVar2 \u003c param_3) \u0026\u0026 (pvVar1 \u003d (void *)_malloc_r(param_1,param_3), pvVar1 !\u003d (void *)0x0))\n      {\n        memcpy(pvVar1,param_2,param_3);\n        _free_r(param_1,param_2);\n      }\n    }\n    return pvVar1;\n  }\n  pvVar1 \u003d (void *)_malloc_r(param_1,param_3,param_3,param_4);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__submore"
      ],
      "called": [
        "_free_r",
        "memcpy",
        "_malloc_usable_size_r",
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sungetc_r": {
      "entrypoint": "0x00006118",
      "current_name": "_sungetc_r",
      "code": "\nuint _sungetc_r(undefined4 param_1,uint param_2,uint *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  if (param_2 \u003d\u003d 0xffffffff) {\nLAB_00006120:\n    param_2 \u003d 0xffffffff;\n  }\n  else {\n    *(ushort *)(param_3 + 3) \u003d *(ushort *)(param_3 + 3) \u0026 0xffdf;\n    uVar2 \u003d param_3[1];\n    param_2 \u003d param_2 \u0026 0xff;\n    if (param_3[0xd] \u003d\u003d 0) {\n      uVar3 \u003d *param_3;\n      if (((param_3[4] !\u003d 0) \u0026\u0026 (param_3[4] \u003c uVar3)) \u0026\u0026 (*(byte *)(uVar3 - 1) \u003d\u003d param_2)) {\n        *param_3 \u003d uVar3 - 1;\n        param_3[1] \u003d uVar2 + 1;\n        return param_2;\n      }\n      param_3[0xf] \u003d uVar3;\n      param_3[0x10] \u003d uVar2;\n      param_3[0xd] \u003d (uint)(param_3 + 0x11);\n      param_3[0xe] \u003d 3;\n      *(undefined *)((int)param_3 + 0x46) \u003d (char)param_2;\n      *param_3 \u003d (uint)(undefined *)((int)param_3 + 0x46);\n      uVar2 \u003d 1;\n    }\n    else {\n      if (((int)param_3[0xe] \u003c\u003d (int)uVar2) \u0026\u0026\n         (iVar1 \u003d __submore(param_1,param_3,uVar2,param_3[0xe],param_4), iVar1 !\u003d 0))\n      goto LAB_00006120;\n      uVar2 \u003d *param_3;\n      *param_3 \u003d uVar2 - 1;\n      *(char *)(uVar2 - 1) \u003d (char)param_2;\n      uVar2 \u003d param_3[1] + 1;\n    }\n    param_3[1] \u003d uVar2;\n  }\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__submore"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ssrefill_r": {
      "entrypoint": "0x00006192",
      "current_name": "__ssrefill_r",
      "code": "\nundefined4 __ssrefill_r(undefined4 param_1,undefined4 *param_2)\n\n{\n  if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n    if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n      _free_r();\n    }\n    param_2[1] \u003d param_2[0x10];\n    param_2[0xd] \u003d 0;\n    if (param_2[0x10] !\u003d 0) {\n      *param_2 \u003d param_2[0xf];\n      return 0;\n    }\n  }\n  *param_2 \u003d param_2[4];\n  param_2[1] \u003d 0;\n  *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x20;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "__ssvfiscanf_r"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ssvfiscanf_r": {
      "entrypoint": "0x000061cc",
      "current_name": "__ssvfiscanf_r",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00006482) */\n\nint __ssvfiscanf_r(undefined4 param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  int iVar1;\n  void *pvVar2;\n  uint uVar3;\n  byte *pbVar4;\n  uint uVar5;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined4 local_30;\n  code *local_2c;\n  \n  local_1a0 \u003d 0;\n  local_19c \u003d 0;\n  local_30 \u003d 0x6119;\n  local_2c \u003d __ssrefill_r + 1;\n  local_2b0 \u003d param_4;\n  local_198 \u003d auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar5 \u003d (uint)*param_3;\n      if (uVar5 \u003d\u003d 0) {\n        return local_1a0;\n      }\n      uVar3 \u003d (byte)(\u0026DAT_00007a99)[uVar5] \u0026 8;\n      pbVar4 \u003d param_3 + 1;\n      if (((\u0026DAT_00007a99)[uVar5] \u0026 8) \u003d\u003d 0) break;\n      while (((param_3 \u003d pbVar4, 0 \u003c (int)param_2[1] ||\n              (iVar1 \u003d (*local_2c)(param_1,param_2), iVar1 \u003d\u003d 0)) \u0026\u0026\n             ((int)((uint)(byte)(\u0026DAT_00007a99)[**param_2] \u003c\u003c 0x1c) \u003c 0))) {\n        local_19c \u003d local_19c + 1;\n        param_2[1] \u003d param_2[1] + -1;\n        *param_2 \u003d *param_2 + 1;\n      }\n    }\n    if (uVar5 \u003d\u003d 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] \u003c 1) \u0026\u0026 (iVar1 \u003d (*local_2c)(param_1,param_2), iVar1 !\u003d 0))\n    goto LAB_00006380;\n    if (**param_2 !\u003d uVar5) {\n      return local_1a0;\n    }\n    *param_2 \u003d *param_2 + 1;\n    local_19c \u003d local_19c + 1;\n    param_2[1] \u003d param_2[1] + -1;\n    param_3 \u003d pbVar4;\n  }\n  local_1a4 \u003d uVar3;\n  local_1ac \u003d uVar3;\n  if (param_3[1] \u003d\u003d 0x2a) {\n    pbVar4 \u003d param_3 + 2;\n    local_1ac \u003d 0x10;\n  }\n  while( true ) {\n    uVar3 \u003d (uint)*pbVar4;\n    if (9 \u003c uVar3 - 0x30) break;\n    pbVar4 \u003d pbVar4 + 1;\n    local_1a4 \u003d (local_1a4 * 10 + uVar3) - 0x30;\n  }\n  pvVar2 \u003d memchr(\u0026DAT_00007c02,uVar3,3);\n  if (pvVar2 !\u003d (void *)0x0) {\n    local_1ac \u003d 1 \u003c\u003c ((int)pvVar2 - 0x7c02U \u0026 0xff) | local_1ac;\n    pbVar4 \u003d pbVar4 + 1;\n  }\n  param_3 \u003d pbVar4 + 1;\n  uVar3 \u003d (uint)*pbVar4;\n  if (uVar3 \u003c 0x79) {\n    if (0x57 \u003c uVar3) {\n      switch(uVar3) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 \u003d (byte *)__sccl(auStack_2ac,param_3);\n        local_1ac \u003d local_1ac | 0x40;\n        local_194 \u003d 1;\n        break;\n      case 99:\n        local_1ac \u003d local_1ac | 0x40;\n        local_194 \u003d 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 \u003d 10;\nLAB_000063a0:\n        if (uVar3 \u003c 0x6f) {\n          local_194 \u003d 3;\n        }\n        else {\n          local_194 \u003d 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 \u003d 5;\n        break;\n      case 0x69:\n        local_1a8 \u003d 0;\n        local_194 \u003d 3;\n        break;\n      case 0x6e:\n        if (-1 \u003c (int)(local_1ac \u003c\u003c 0x1b)) {\n          if ((int)(local_1ac \u003c\u003c 0x1f) \u003c 0) {\n            *(short *)*local_2b0 \u003d (short)local_19c;\n            local_2b0 \u003d local_2b0 + 1;\n          }\n          else {\n            **local_2b0 \u003d local_19c;\n            local_2b0 \u003d local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 \u003d 8;\n        local_194 \u003d 4;\n        break;\n      case 0x70:\n        local_1ac \u003d local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac \u003d local_1ac | 0x200;\n        local_1a8 \u003d 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 \u003d 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] \u003c 1) \u0026\u0026 (iVar1 \u003d (*local_2c)(param_1,param_2), iVar1 !\u003d 0))\n      goto LAB_00006380;\n      if (-1 \u003c (int)(local_1ac \u003c\u003c 0x19)) {\n        while ((int)((uint)(byte)(\u0026DAT_00007a99)[**param_2] \u003c\u003c 0x1c) \u003c 0) {\n          local_19c \u003d local_19c + 1;\n          pbVar4 \u003d param_2[1];\n          param_2[1] \u003d pbVar4 + -1;\n          if ((int)(pbVar4 + -1) \u003c 1) {\n            iVar1 \u003d (*local_2c)(param_1,param_2);\n            if (iVar1 !\u003d 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 \u003d *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 \u003c 3) {\n        iVar1 \u003d _scanf_chars(param_1,\u0026local_1ac,param_2,\u0026local_2b0);\n      }\n      else {\n        if (4 \u003c local_194) goto LAB_000061f6;\n        iVar1 \u003d _scanf_i(param_1,\u0026local_1ac,param_2,\u0026local_2b0);\n      }\n      if (iVar1 \u003d\u003d 1) {\n        return local_1a0;\n      }\n      if (iVar1 \u003d\u003d 2) {\nLAB_00006380:\n        if (local_1a0 \u003d\u003d 0) {\nLAB_00006388:\n          local_1a0 \u003d -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) \u0026 0x40) !\u003d 0) {\n          local_1a0 \u003d -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar4 \u003d param_3;\n    if (uVar3 \u003d\u003d 0x25) goto LAB_00006352;\n    if (uVar3 \u003c 0x26) {\n      if (uVar3 !\u003d 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar3 - 0x45 \u003c 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 \u003d 3;\n  local_1a8 \u003d 10;\n  goto LAB_000063ac;\n}\n\n",
      "renaming": {},
      "calling": [
        "siscanf"
      ],
      "called": [
        "__ssrefill_r",
        "memchr",
        "_scanf_chars",
        "_scanf_i",
        "__sccl"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_scanf_chars": {
      "entrypoint": "0x000064bc",
      "current_name": "_scanf_chars",
      "code": "\nundefined4 _scanf_chars(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  byte **ppbVar3;\n  byte *pbVar4;\n  byte *unaff_r6;\n  byte *pbVar5;\n  int iVar6;\n  \n  if (param_2[2] \u003d\u003d 0) {\n    if (param_2[6] \u003d\u003d 0) {\n      uVar2 \u003d 1;\n    }\n    else {\n      uVar2 \u003d 0xffffffff;\n    }\n    param_2[2] \u003d uVar2;\n  }\n  if (-1 \u003c (int)(*param_2 \u003c\u003c 0x1b)) {\n    ppbVar3 \u003d (byte **)*param_4;\n    *param_4 \u003d ppbVar3 + 1;\n    unaff_r6 \u003d *ppbVar3;\n  }\n  iVar6 \u003d 0;\n  do {\n    uVar2 \u003d param_2[6];\n    if (uVar2 !\u003d 0) {\n      if (uVar2 \u003d\u003d 1) {\n        if (*(char *)(param_2[5] + (uint)**param_3) \u003d\u003d \u0027\\0\u0027) {\n          if (iVar6 \u003d\u003d 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*param_2 \u0026 0x10) \u003d\u003d 0) \u0026\u0026 (param_2[3] \u003d param_2[3] + 1, param_2[6] !\u003d 0)) {\n            *unaff_r6 \u003d 0;\n          }\n          param_2[4] \u003d iVar6 + param_2[4];\n          return 0;\n        }\n      }\n      else if ((uVar2 !\u003d 2) || ((int)((uint)(byte)(\u0026DAT_00007a99)[**param_3] \u003c\u003c 0x1c) \u003c 0))\n      goto LAB_0000654a;\n    }\n    pbVar5 \u003d unaff_r6;\n    if (-1 \u003c (int)(*param_2 \u003c\u003c 0x1b)) {\n      pbVar5 \u003d unaff_r6 + 1;\n      *unaff_r6 \u003d **param_3;\n    }\n    pbVar4 \u003d param_3[1];\n    *param_3 \u003d *param_3 + 1;\n    uVar2 \u003d param_2[2] - 1;\n    param_3[1] \u003d pbVar4 + -1;\n    iVar6 \u003d iVar6 + 1;\n    param_2[2] \u003d uVar2;\n    unaff_r6 \u003d pbVar5;\n    if ((uVar2 \u003d\u003d 0) ||\n       (((int)(pbVar4 + -1) \u003c 1 \u0026\u0026\n        (iVar1 \u003d (*(code *)param_2[0x60])(param_1,param_3,uVar2,(code *)param_2[0x60],param_4),\n        iVar1 !\u003d 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__ssvfiscanf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_scanf_i": {
      "entrypoint": "0x0000656c",
      "current_name": "_scanf_i",
      "code": "\nundefined4 _scanf_i(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  code *pcVar1;\n  void *pvVar2;\n  int iVar3;\n  undefined4 uVar4;\n  uint uVar5;\n  byte *pbVar6;\n  uint uVar7;\n  undefined4 *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  uint *puVar11;\n  int unaff_r9;\n  int iVar12;\n  undefined *local_34 [4];\n  \n  local_34[0] \u003d \u0026DAT_00007c2f;\n  local_34[1] \u003d \u0026DAT_00007c32;\n  local_34[2] \u003d \u0026DAT_00007c35;\n  pcVar1 \u003d _strtol_r;\n  if (param_2[6] !\u003d 3) {\n    pcVar1 \u003d _strtoul_r;\n  }\n  uVar7 \u003d param_2[2];\n  uVar5 \u003d uVar7 - 1;\n  if (0x15c \u003c uVar5) {\n    unaff_r9 \u003d uVar7 - 0x15d;\n    uVar7 \u003d 0x15d;\n  }\n  if (0x15c \u003c uVar5) {\n    param_2[2] \u003d uVar7;\n  }\n  puVar11 \u003d param_2 + 7;\n  if (uVar5 \u003c 0x15d) {\n    unaff_r9 \u003d 0;\n  }\n  *param_2 \u003d *param_2 | 0xd00;\n  iVar12 \u003d 0;\n  puVar10 \u003d puVar11;\n  do {\n    pvVar2 \u003d memchr(local_34[iVar12],(uint)**param_3,2);\n    if (pvVar2 !\u003d (void *)0x0) {\n      if (iVar12 \u003d\u003d 1) {\n        if (param_2[1] \u003d\u003d 0) {\n          param_2[1] \u003d 8;\n          *param_2 \u003d *param_2 | 0x200;\n        }\n        uVar5 \u003d *param_2 \u0026 0xfffffaff;\nLAB_000065f4:\n        *param_2 \u003d uVar5;\n      }\n      else if (iVar12 \u003d\u003d 2) {\n        if ((*param_2 \u0026 0x600) !\u003d 0x200) goto LAB_00006624;\n        param_2[1] \u003d 0x10;\n        uVar5 \u003d *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar5 \u003d param_2[2];\n      param_2[2] \u003d uVar5 - 1;\n      if (uVar5 !\u003d 0) {\n        pbVar6 \u003d *param_3;\n        *param_3 \u003d pbVar6 + 1;\n        puVar9 \u003d (uint *)((int)puVar10 + 1);\n        *(byte *)puVar10 \u003d *pbVar6;\n        pbVar6 \u003d param_3[1];\n        param_3[1] \u003d pbVar6 + -1;\n        puVar10 \u003d puVar9;\n        if (((int)(pbVar6 + -1) \u003c 1) \u0026\u0026\n           (iVar3 \u003d (*(code *)param_2[0x60])(param_1,param_3), iVar3 !\u003d 0)) {\n          iVar12 \u003d 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar12 \u003d iVar12 + 1;\n  } while (iVar12 !\u003d 3);\n  if (param_2[1] \u003d\u003d 0) {\n    param_2[1] \u003d 10;\n  }\n  __sccl(param_2[5],\"01234567]\" + (8 - param_2[1]));\n  iVar12 \u003d 0;\n  while( true ) {\n    puVar9 \u003d puVar10;\n    if (param_2[2] \u003d\u003d 0) break;\n    pbVar6 \u003d *param_3;\n    uVar5 \u003d (uint)*pbVar6;\n    if (*(char *)(param_2[5] + uVar5) \u003d\u003d \u0027\\0\u0027) break;\n    if ((uVar5 \u003d\u003d 0x30) \u0026\u0026 ((int)(*param_2 \u003c\u003c 0x14) \u003c 0)) {\n      iVar12 \u003d iVar12 + 1;\n      if (unaff_r9 !\u003d 0) {\n        unaff_r9 \u003d unaff_r9 + -1;\n        param_2[2] \u003d param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 \u003d *param_2 \u0026 0xfffff6ff;\n      puVar9 \u003d (uint *)((int)puVar10 + 1);\n      *(byte *)puVar10 \u003d *pbVar6;\n    }\n    pbVar6 \u003d param_3[1];\n    param_3[1] \u003d pbVar6 + -1;\n    if ((int)(pbVar6 + -1) \u003c 1) {\n      iVar3 \u003d (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar3 !\u003d 0) break;\n    }\n    else {\n      *param_3 \u003d *param_3 + 1;\n    }\n    param_2[2] \u003d param_2[2] - 1;\n    puVar10 \u003d puVar9;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 \u003c\u003c 0x17) \u003c 0) {\n    if (puVar11 \u003c puVar9) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar9 + -1),param_3);\n      puVar9 \u003d (uint *)((int)puVar9 + -1);\n    }\n    if (puVar9 \u003d\u003d puVar11) {\n      return 1;\n    }\n  }\n  if ((*param_2 \u0026 0x10) \u003d\u003d 0) {\n    *(byte *)puVar9 \u003d 0;\n    uVar4 \u003d (*(pcVar1 + 1))(param_1,puVar11,0,param_2[1]);\n    puVar8 \u003d (undefined4 *)*param_4;\n    uVar5 \u003d *param_2;\n    *param_4 \u003d puVar8 + 1;\n    puVar8 \u003d (undefined4 *)*puVar8;\n    if ((uVar5 \u0026 0x20) \u003d\u003d 0) {\n      if ((int)(uVar5 \u003c\u003c 0x1f) \u003c 0) {\n        *(short *)puVar8 \u003d (short)uVar4;\n      }\n      else {\n        *puVar8 \u003d uVar4;\n      }\n    }\n    else {\n      *puVar8 \u003d uVar4;\n    }\n    param_2[3] \u003d param_2[3] + 1;\n  }\n  param_2[4] \u003d (uint)((int)puVar9 + param_2[4] + (iVar12 - (int)puVar11));\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__ssvfiscanf_r"
      ],
      "called": [
        "memchr",
        "__sccl"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "lflush": {
      "entrypoint": "0x00006754",
      "current_name": "lflush",
      "code": "\nint lflush(FILE *param_1)\n\n{\n  int iVar1;\n  \n  if ((*(ushort *)\u0026param_1-\u003e_IO_read_base \u0026 9) \u003d\u003d 9) {\n    iVar1 \u003d fflush(param_1);\n    return iVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "fflush"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__srefill_r": {
      "entrypoint": "0x00006768",
      "current_name": "__srefill_r",
      "code": "\nundefined4\n__srefill_r(undefined4 *param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  ushort uVar4;\n  uint uVar5;\n  \n  if ((param_1 !\u003d (undefined4 *)0x0) \u0026\u0026 (param_1[6] \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d (undefined4 *)param_1[1];\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d (undefined4 *)param_1[2];\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d (undefined4 *)param_1[3];\n  }\n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  param_2[1] \u003d 0;\n  uVar5 \u003d (uint)*(ushort *)(param_2 + 3);\n  if ((int)(uVar5 \u003c\u003c 0x1a) \u003c 0) {\n    return 0xffffffff;\n  }\n  if ((int)(uVar5 \u003c\u003c 0x1d) \u003c 0) {\n    if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n      if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[1] \u003d param_2[0x10];\n      param_2[0xd] \u003d 0;\n      if (param_2[0x10] !\u003d 0) {\n        *param_2 \u003d param_2[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 \u003c (int)(uVar5 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      uVar4 \u003d uVar4 | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(uVar5 \u003c\u003c 0x1c) \u003c 0) {\n      iVar2 \u003d _fflush_r(param_1,param_2,uVar5 \u003c\u003c 0x1c,uVar5,param_4);\n      if (iVar2 !\u003d 0) {\n        return 0xffffffff;\n      }\n      param_2[2] \u003d 0;\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfff7;\n      param_2[6] \u003d 0;\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 4;\n  }\n  if (param_2[4] \u003d\u003d 0) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar1 \u003d *(undefined2 *)(param_2 + 3);\n  if ((uVar4 \u0026 3) !\u003d 0) {\n    *(undefined2 *)(param_2 + 3) \u003d 1;\n    _fwalk(\u0026impure_data,0x6755);\n    *(undefined2 *)(param_2 + 3) \u003d uVar1;\n    if ((uVar4 \u0026 9) \u003d\u003d 9) {\n      __sflush_r(param_1,param_2);\n    }\n  }\n  uVar3 \u003d param_2[4];\n  *param_2 \u003d uVar3;\n  iVar2 \u003d (*(code *)param_2[9])(param_1,param_2[8],uVar3,param_2[5]);\n  param_2[1] \u003d iVar2;\n  if (0 \u003c iVar2) {\n    return 0;\n  }\n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  if (iVar2 !\u003d 0) {\n    uVar3 \u003d 0;\n  }\n  else {\n    uVar4 \u003d uVar4 | 0x20;\n  }\n  if (iVar2 !\u003d 0) {\n    param_2[1] \u003d uVar3;\n    uVar4 \u003d uVar4 | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(param_2 + 3) \u003d uVar4;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "__srget_r"
      ],
      "called": [
        "__sinit",
        "_free_r",
        "_fflush_r",
        "__sflush_r",
        "_fwalk",
        "__smakebuf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sccl": {
      "entrypoint": "0x0000687c",
      "current_name": "__sccl",
      "code": "\nbyte * __sccl(int param_1,byte *param_2)\n\n{\n  byte *pbVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  bool bVar7;\n  \n  uVar4 \u003d (uint)*param_2;\n  bVar7 \u003d uVar4 \u003d\u003d 0x5e;\n  if (bVar7) {\n    uVar4 \u003d (uint)param_2[1];\n    param_2 \u003d param_2 + 2;\n  }\n  else {\n    param_2 \u003d param_2 + 1;\n  }\n  iVar3 \u003d param_1 + -1;\n  do {\n    iVar3 \u003d iVar3 + 1;\n    *(bool *)iVar3 \u003d bVar7;\n  } while (iVar3 !\u003d param_1 + 0xff);\n  if (uVar4 \u003d\u003d 0) {\n    pbVar1 \u003d param_2 + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      uVar5 \u003d uVar4;\n      *(bool *)(param_1 + uVar5) \u003d !bVar7;\n      param_2 \u003d param_2 + 1;\n      while( true ) {\n        uVar4 \u003d (uint)param_2[-1];\n        if (uVar4 !\u003d 0x2d) break;\n        uVar6 \u003d (uint)*param_2;\n        if ((uVar6 \u003d\u003d 0x5d) || (uVar2 \u003d uVar5, (int)uVar6 \u003c (int)uVar5)) goto LAB_000068aa;\n        do {\n          uVar2 \u003d uVar2 + 1;\n          *(bool *)(param_1 + uVar2) \u003d !bVar7;\n        } while ((int)uVar2 \u003c (int)uVar6);\n        iVar3 \u003d ~uVar5 + uVar6;\n        if ((int)uVar6 \u003c\u003d (int)uVar5) {\n          iVar3 \u003d 0;\n        }\n        uVar5 \u003d uVar5 + 1 + iVar3;\n        param_2 \u003d param_2 + 2;\n      }\n      pbVar1 \u003d param_2;\n    } while ((uVar4 !\u003d 0x5d) \u0026\u0026 (pbVar1 \u003d param_2 + -1, uVar4 !\u003d 0));\n  }\n  return pbVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_scanf_i",
        "__ssvfiscanf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__submore": {
      "entrypoint": "0x000068f0",
      "current_name": "__submore",
      "code": "\nundefined4 __submore(undefined4 param_1,void **param_2)\n\n{\n  void *pvVar1;\n  void *__n;\n  \n  if ((void **)param_2[0xd] \u003d\u003d param_2 + 0x11) {\n    pvVar1 \u003d (void *)_malloc_r(param_1,0x400);\n    if (pvVar1 !\u003d (void *)0x0) {\n      param_2[0xe] \u003d flash_configuration_field;\n      param_2[0xd] \u003d pvVar1;\n      *(undefined *)((int)pvVar1 + 0x3ff) \u003d *(undefined *)((int)param_2 + 0x46);\n      *(undefined *)((int)pvVar1 + 0x3fe) \u003d *(undefined *)((int)param_2 + 0x45);\n      *(undefined *)((int)pvVar1 + 0x3fd) \u003d *(undefined *)(param_2 + 0x11);\n      *param_2 \u003d (void *)((int)pvVar1 + 0x3fd);\n      return 0;\n    }\n  }\n  else {\n    __n \u003d param_2[0xe];\n    pvVar1 \u003d (void *)_realloc_r(param_1,param_2[0xd],(void *)((int)__n \u003c\u003c 1));\n    if (pvVar1 !\u003d (void *)0x0) {\n      memcpy((void *)((int)pvVar1 + (int)__n),pvVar1,(size_t)__n);\n      param_2[0xd] \u003d pvVar1;\n      param_2[0xe] \u003d (void *)((int)__n \u003c\u003c 1);\n      *param_2 \u003d (void *)((int)pvVar1 + (int)__n);\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_sungetc_r"
      ],
      "called": [
        "memcpy",
        "_malloc_r",
        "_realloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_usable_size_r": {
      "entrypoint": "0x00006964",
      "current_name": "_malloc_usable_size_r",
      "code": "\nint _malloc_usable_size_r(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d *(int *)(param_2 + -4) + -4;\n  if (*(int *)(param_2 + -4) \u003c 0) {\n    iVar1 \u003d iVar1 + *(int *)(param_2 + iVar1);\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_realloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_ldivmod": {
      "entrypoint": "0x00006974",
      "current_name": "__aeabi_ldivmod",
      "code": "\nint __aeabi_ldivmod(int param_1,int param_2,int param_3,int param_4)\n\n{\n  int iVar1;\n  undefined local_8 [8];\n  \n  if ((param_4 \u003d\u003d 0) \u0026\u0026 (param_3 \u003d\u003d 0)) {\n    if (param_2 \u003c 0) {\n      param_1 \u003d 0;\n      param_2 \u003d -0x80000000;\n    }\n    else if (param_2 !\u003d 0 || param_1 !\u003d 0) {\n      param_2 \u003d 0x7fffffff;\n      param_1 \u003d -1;\n    }\n    iVar1 \u003d __aeabi_idiv0(param_1,param_2);\n    return iVar1;\n  }\n  if (param_2 \u003c 0) {\n    iVar1 \u003d -param_2 - (uint)(param_1 !\u003d 0);\n    if (param_4 \u003c 0) {\n      iVar1 \u003d __udivmoddi4(-param_1,iVar1,-param_3,-param_4 - (uint)(param_3 !\u003d 0),local_8);\n      return iVar1;\n    }\n    iVar1 \u003d __udivmoddi4(-param_1,iVar1,param_3,param_4,local_8);\n    return -iVar1;\n  }\n  if (param_4 \u003c 0) {\n    iVar1 \u003d __udivmoddi4(param_1,param_2,-param_3,-param_4 - (uint)(param_3 !\u003d 0),local_8);\n    return -iVar1;\n  }\n  iVar1 \u003d __udivmoddi4();\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "gmtime_r"
      ],
      "called": [
        "__aeabi_idiv0",
        "__udivmoddi4"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__udivmoddi4": {
      "entrypoint": "0x00006a14",
      "current_name": "__udivmoddi4",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong __udivmoddi4(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  bool bVar10;\n  ulonglong uVar11;\n  \n  if (param_4 \u003d\u003d 0) {\n    if (param_2 \u003c param_3) {\n      iVar2 \u003d LZCOUNT(param_3);\n      uVar5 \u003d param_3;\n      if (iVar2 !\u003d 0) {\n        uVar5 \u003d param_3 \u003c\u003c iVar2;\n        param_2 \u003d param_1 \u003e\u003e (0x20U - iVar2 \u0026 0xff) | param_2 \u003c\u003c iVar2;\n        param_1 \u003d param_1 \u003c\u003c iVar2;\n      }\n      uVar6 \u003d uVar5 \u003e\u003e 0x10;\n      uVar8 \u003d param_2 / uVar6;\n      uVar3 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar6 * uVar8) * 0x10000;\n      uVar1 \u003d uVar8 * (uVar5 \u0026 0xffff);\n      uVar4 \u003d uVar8;\n      if (uVar3 \u003c\u003d uVar1 \u0026\u0026 uVar1 - uVar3 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar5,uVar3);\n        uVar3 \u003d uVar5 + uVar3;\n        uVar4 \u003d uVar8 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar3 \u003c\u003d uVar1 \u0026\u0026 uVar1 - uVar3 !\u003d 0)) {\n          uVar4 \u003d uVar8 - 2;\n          uVar3 \u003d uVar3 + uVar5;\n        }\n      }\n      uVar8 \u003d (uVar3 - uVar1) / uVar6;\n      uVar6 \u003d param_1 \u0026 0xffff | ((uVar3 - uVar1) - uVar6 * uVar8) * 0x10000;\n      uVar3 \u003d uVar8 * (uVar5 \u0026 0xffff);\n      uVar1 \u003d uVar8;\n      if (uVar6 \u003c\u003d uVar3 \u0026\u0026 uVar3 - uVar6 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar5,uVar6);\n        uVar6 \u003d uVar5 + uVar6;\n        uVar1 \u003d uVar8 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar3 \u0026\u0026 uVar3 - uVar6 !\u003d 0)) {\n          uVar1 \u003d uVar8 - 2;\n          uVar6 \u003d uVar6 + uVar5;\n        }\n      }\n      uVar6 \u003d uVar6 - uVar3;\n      uVar1 \u003d uVar1 | uVar4 \u003c\u003c 0x10;\n      uVar5 \u003d 0;\n    }\n    else {\n      if (param_3 \u003d\u003d 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE \u003d (code *)software_udf(0xff,0x6abc);\n        uVar11 \u003d (*UNRECOVERED_JUMPTABLE)();\n        return uVar11;\n      }\n      iVar2 \u003d LZCOUNT(param_3);\n      if (iVar2 \u003d\u003d 0) {\n        param_2 \u003d param_2 - param_3;\n        uVar9 \u003d param_3 \u003e\u003e 0x10;\n        uVar7 \u003d param_3 \u0026 0xffff;\n        uVar5 \u003d 1;\n        uVar4 \u003d param_3;\n      }\n      else {\n        uVar4 \u003d param_3 \u003c\u003c iVar2;\n        uVar9 \u003d uVar4 \u003e\u003e 0x10;\n        uVar1 \u003d param_2 \u003e\u003e (0x20U - iVar2 \u0026 0xff);\n        uVar5 \u003d param_1 \u003e\u003e (0x20U - iVar2 \u0026 0xff) | param_2 \u003c\u003c iVar2;\n        uVar3 \u003d uVar1 / uVar9;\n        uVar7 \u003d uVar4 \u0026 0xffff;\n        uVar8 \u003d uVar5 \u003e\u003e 0x10 | (uVar1 - uVar9 * uVar3) * 0x10000;\n        uVar6 \u003d uVar3 * uVar7;\n        param_1 \u003d param_1 \u003c\u003c iVar2;\n        uVar1 \u003d uVar3;\n        if (uVar8 \u003c\u003d uVar6 \u0026\u0026 uVar6 - uVar8 !\u003d 0) {\n          bVar10 \u003d CARRY4(uVar4,uVar8);\n          uVar8 \u003d uVar4 + uVar8;\n          uVar1 \u003d uVar3 - 1;\n          if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar8 \u003c\u003d uVar6 \u0026\u0026 uVar6 - uVar8 !\u003d 0)) {\n            uVar1 \u003d uVar3 - 2;\n            uVar8 \u003d uVar8 + uVar4;\n          }\n        }\n        uVar3 \u003d (uVar8 - uVar6) / uVar9;\n        param_2 \u003d uVar5 \u0026 0xffff | ((uVar8 - uVar6) - uVar9 * uVar3) * 0x10000;\n        uVar6 \u003d uVar3 * uVar7;\n        uVar5 \u003d uVar3;\n        if (param_2 \u003c\u003d uVar6 \u0026\u0026 uVar6 - param_2 !\u003d 0) {\n          bVar10 \u003d CARRY4(uVar4,param_2);\n          param_2 \u003d uVar4 + param_2;\n          uVar5 \u003d uVar3 - 1;\n          if ((bVar10 \u003d\u003d false) \u0026\u0026 (param_2 \u003c\u003d uVar6 \u0026\u0026 uVar6 - param_2 !\u003d 0)) {\n            uVar5 \u003d uVar3 - 2;\n            param_2 \u003d param_2 + uVar4;\n          }\n        }\n        param_2 \u003d param_2 - uVar6;\n        uVar5 \u003d uVar5 | uVar1 \u003c\u003c 0x10;\n      }\n      uVar8 \u003d param_2 / uVar9;\n      uVar6 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar9 * uVar8) * 0x10000;\n      uVar1 \u003d uVar7 * uVar8;\n      uVar3 \u003d uVar8;\n      if (uVar6 \u003c\u003d uVar1 \u0026\u0026 uVar1 - uVar6 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar4,uVar6);\n        uVar6 \u003d uVar4 + uVar6;\n        uVar3 \u003d uVar8 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar1 \u0026\u0026 uVar1 - uVar6 !\u003d 0)) {\n          uVar3 \u003d uVar8 - 2;\n          uVar6 \u003d uVar6 + uVar4;\n        }\n      }\n      uVar8 \u003d (uVar6 - uVar1) / uVar9;\n      uVar6 \u003d param_1 \u0026 0xffff | ((uVar6 - uVar1) - uVar9 * uVar8) * 0x10000;\n      uVar7 \u003d uVar7 * uVar8;\n      uVar1 \u003d uVar8;\n      if (uVar6 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar6 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar4,uVar6);\n        uVar6 \u003d uVar4 + uVar6;\n        uVar1 \u003d uVar8 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar6 !\u003d 0)) {\n          uVar1 \u003d uVar8 - 2;\n          uVar6 \u003d uVar6 + uVar4;\n        }\n      }\n      uVar6 \u003d uVar6 - uVar7;\n      uVar1 \u003d uVar1 | uVar3 \u003c\u003c 0x10;\n    }\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d uVar6 \u003e\u003e LZCOUNT(param_3);\n      param_5[1] \u003d 0;\n    }\n  }\n  else if (param_2 \u003c param_4) {\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d param_1;\n      param_5[1] \u003d param_2;\n      return 0;\n    }\n    uVar1 \u003d 0;\n    uVar5 \u003d 0;\n  }\n  else {\n    iVar2 \u003d LZCOUNT(param_4);\n    if (iVar2 !\u003d 0) {\n      uVar7 \u003d 0x20 - iVar2;\n      uVar3 \u003d param_3 \u003e\u003e (uVar7 \u0026 0xff) | param_4 \u003c\u003c iVar2;\n      uVar9 \u003d uVar3 \u003e\u003e 0x10;\n      uVar1 \u003d param_2 \u003e\u003e (uVar7 \u0026 0xff);\n      uVar5 \u003d param_1 \u003e\u003e (uVar7 \u0026 0xff) | param_2 \u003c\u003c iVar2;\n      uVar6 \u003d uVar1 / uVar9;\n      uVar4 \u003d uVar5 \u003e\u003e 0x10 | (uVar1 - uVar9 * uVar6) * 0x10000;\n      uVar8 \u003d uVar6 * (uVar3 \u0026 0xffff);\n      param_1 \u003d param_1 \u003c\u003c iVar2;\n      uVar1 \u003d uVar6;\n      if (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar3,uVar4);\n        uVar4 \u003d uVar3 + uVar4;\n        uVar1 \u003d uVar6 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0)) {\n          uVar1 \u003d uVar6 - 2;\n          uVar4 \u003d uVar4 + uVar3;\n        }\n      }\n      uVar6 \u003d (uVar4 - uVar8) / uVar9;\n      uVar4 \u003d uVar5 \u0026 0xffff | ((uVar4 - uVar8) - uVar9 * uVar6) * 0x10000;\n      uVar8 \u003d uVar6 * (uVar3 \u0026 0xffff);\n      uVar5 \u003d uVar6;\n      if (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar3,uVar4);\n        uVar4 \u003d uVar3 + uVar4;\n        uVar5 \u003d uVar6 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0)) {\n          uVar5 \u003d uVar6 - 2;\n          uVar4 \u003d uVar4 + uVar3;\n        }\n      }\n      uVar5 \u003d uVar5 | uVar1 \u003c\u003c 0x10;\n      uVar11 \u003d (ulonglong)uVar5 * (ulonglong)(param_3 \u003c\u003c iVar2);\n      if (CONCAT44(uVar4 - uVar8,param_1) \u003c uVar11) {\n        uVar11 \u003d uVar11 - CONCAT44(uVar3,param_3 \u003c\u003c iVar2);\n        uVar5 \u003d uVar5 - 1;\n      }\n      if (param_5 !\u003d (uint *)0x0) {\n        uVar1 \u003d ((uVar4 - uVar8) - (int)(uVar11 \u003e\u003e 0x20)) - (uint)(param_1 \u003c (uint)uVar11);\n        *param_5 \u003d uVar1 \u003c\u003c (uVar7 \u0026 0xff) | param_1 - (uint)uVar11 \u003e\u003e iVar2;\n        param_5[1] \u003d uVar1 \u003e\u003e iVar2;\n      }\n      return (ulonglong)uVar5;\n    }\n    if ((param_4 \u003c param_2) || (param_3 \u003c\u003d param_1)) {\n      bVar10 \u003d param_1 \u003c param_3;\n      param_1 \u003d param_1 - param_3;\n      param_2 \u003d (param_2 - param_4) - (uint)bVar10;\n      uVar1 \u003d 1;\n    }\n    else {\n      uVar1 \u003d 0;\n    }\n    uVar5 \u003d 0;\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d param_1;\n      param_5[1] \u003d param_2;\n    }\n  }\n  return CONCAT44(uVar5,uVar1);\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_ldivmod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_idiv0": {
      "entrypoint": "0x00006cd4",
      "current_name": "__aeabi_idiv0",
      "code": "\nvoid __aeabi_idiv0(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_ldivmod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}