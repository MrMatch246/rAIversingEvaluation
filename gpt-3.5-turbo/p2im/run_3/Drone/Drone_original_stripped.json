{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeCompletedFlag_08000110(undefined4 inputValue)\n\n{\n  if ((char)flag == '\\0') {\n    flag._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_completed_flag_08000110",
                "param_1": "inputValue",
                "completed_8672": "flag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_parameters_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenateParameters_08000134(undefined4 firstParameter,undefined4 secondParameter)\n\n{\n  return CONCAT44(secondParameter,firstParameter);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_parameters_08000134",
                "param_1": "firstParameter",
                "param_2": "secondParameter"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "calculate_string_length_08000150",
            "code": "\nsize_t calculateStringLength_08000150(char *string)\n\n{\n  char currentCharacter;\n  char *nextChar;\n  char *currentChar;\n  \n  currentChar = string;\n  do {\n    nextChar = currentChar + 1;\n    currentCharacter = *currentChar;\n    currentChar = nextChar;\n  } while (currentCharacter != '\\0');\n  return (size_t)(nextChar + (-1 - (int)string));\n}\n\n",
            "renaming": {
                "FUN_08000150": "calculate_string_length_08000150",
                "__s": "string",
                "pcVar3": "currentChar",
                "pcVar2": "nextChar",
                "cVar1": "currentCharacter"
            },
            "calling": [
                "serialPrint"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000160": {
            "entrypoint": "0x08000160",
            "current_name": "add_with_bitwise_negation_08000160",
            "code": "\nvoid addWithBitwiseNegation_08000160(undefined4 result,uint input)\n\n{\n  __aeabi_dadd(result,input ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000160": "add_with_bitwise_negation_08000160",
                "param_1": "result",
                "param_2": "input"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000168": {
            "entrypoint": "0x08000168",
            "current_name": "calculate_result_08000168",
            "code": "\nulonglong calculateResult_08000168(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int iVar1;\n  byte carryFlag;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint value1;\n  uint value2;\n  int shift;\n  uint result1;\n  uint result2;\n  uint result3;\n  uint result4;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  value1 = input4 ^ 0x80000000;\n  result1 = input2 << 1;\n  input4 = input4 << 1;\n  condition1 = ((input2 ^ value1) & 0x7fffffff) == 0;\n  condition2 = condition1 && input1 == input3;\n  if (!condition1 || input1 != input3) {\n    condition2 = (result1 | input1) == 0;\n  }\n  if (!condition2) {\n    condition2 = (input4 | input3) == 0;\n  }\n  shift = (int)result1 >> 0x15;\n  if (!condition2) {\n    condition2 = shift == -1;\n  }\n  iVar1 = (int)input4 >> 0x15;\n  if (!condition2) {\n    condition2 = iVar1 == -1;\n  }\n  if (condition2) {\n    if (shift == -1 || iVar1 == -1) {\n      result1 = value1;\n      result3 = input3;\n      if (shift == -1) {\n        result1 = input2;\n        result3 = input1;\n      }\n      if (shift != -1 || iVar1 != -1) {\n        input3 = result3;\n        value1 = result1;\n      }\n      condition2 = (result3 | result1 << 0xc) == 0;\n      if (condition2) {\n        condition2 = (input3 | value1 << 0xc) == 0;\n      }\n      if (condition2) {\n        condition2 = result1 == value1;\n      }\n      if (!condition2) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,result3);\n    }\n    if (((input2 ^ value1) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((result1 | input1) == 0) {\n        input1 = input3;\n        input2 = value1;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != value1) {\n      return 0;\n    }\n    if (result1 >> 0x15 == 0) {\n      condition2 = (input1 & 0x80000000) != 0;\n      value1 = input2 * 2 + (uint)condition2;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)condition2)) {\n        value1 = value1 | 0x80000000;\n      }\n      return CONCAT44(value1,input1 << 1);\n    }\n    if (result1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  result1 = result1 >> 0x15;\n  input4 = input4 >> 0x15;\n  result3 = input4 - result1;\n  condition2 = result3 != 0;\n  if (input4 < result1) {\n    result3 = -result3;\n  }\n  result2 = input1;\n  value2 = input2;\n  if (condition2 && result1 <= input4) {\n    result1 = result1 + result3;\n    result2 = input3;\n    value2 = value1;\n    input3 = input1;\n    value1 = input2;\n  }\n  if (0x36 < result3) {\n    return CONCAT44(value2,result2);\n  }\n  temp2 = value2 & 0xfffff | 0x100000;\n  if ((value2 & 0x80000000) != 0) {\n    condition2 = result2 != 0;\n    result2 = -result2;\n    temp2 = -temp2 - (uint)condition2;\n  }\n  value2 = value1 & 0xfffff | 0x100000;\n  if ((value1 & 0x80000000) != 0) {\n    condition2 = input3 != 0;\n    input3 = -input3;\n    value2 = -value2 - (uint)condition2;\n  }\n  if (result1 == result3) {\n    value2 = value2 ^ 0x100000;\n    if (result1 == 0) {\n      temp2 = temp2 ^ 0x100000;\n      result1 = 1;\n    }\n    else {\n      result3 = result3 - 1;\n    }\n  }\n  value1 = -result3 + 0x20;\n  if ((int)result3 < 0x21) {\n    result4 = input3 << (value1 & 0xff);\n    input3 = input3 >> (result3 & 0xff);\n    temp1 = result2 + input3;\n    temp3 = value2 << (value1 & 0xff);\n    value1 = temp1 + temp3;\n    temp2 = temp2 + CARRY4(result2,input3) + ((int)value2 >> (result3 & 0xff)) +\n            (uint)CARRY4(temp1,temp3);\n  }\n  else {\n    result4 = value2 << (-result3 + 0x40 & 0xff);\n    if (input3 != 0) {\n      result4 = result4 | 2;\n    }\n    value2 = (int)value2 >> (result3 - 0x20 & 0xff);\n    value1 = result2 + value2;\n    temp2 = temp2 + ((int)value2 >> 0x1f) + (uint)CARRY4(result2,value2);\n  }\n  input2 = temp2 & 0x80000000;\n  result3 = temp2;\n  if ((int)temp2 < 0) {\n    condition2 = result4 == 0;\n    result4 = -result4;\n    result3 = -value1;\n    value1 = -(uint)!condition2 - value1;\n    result3 = -(uint)(condition2 <= result3) - temp2;\n  }\n  if (0xfffff < result3) {\n    result2 = result1 - 1;\n    if (0x1fffff < result3) {\n      result2 = result3 & 1;\n      result3 = result3 >> 1;\n      carryFlag = (byte)value1;\n      value1 = (uint)(result2 != 0) << 0x1f | value1 >> 1;\n      result4 = (uint)(carryFlag & 1) << 0x1f | result4 >> 1;\n      result2 = result1;\n      if (0xffbfffff < result1 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    condition2 = 0x7fffffff < result4;\n    if (result4 == 0x80000000) {\n      condition2 = (value1 & 1) != 0;\n    }\n    return CONCAT44(result3 + result2 * 0x100000 + (uint)CARRY4(value1,(uint)condition2) | input2,\n                    value1 + condition2);\n  }\n  condition1 = (result4 & 0x80000000) != 0;\n  result4 = result4 << 1;\n  result2 = value1 * 2;\n  condition2 = CARRY4(value1,value1);\n  value1 = value1 * 2 + (uint)condition1;\n  result3 = result3 * 2 + (uint)(condition2 || CARRY4(result2,(uint)condition1));\n  result2 = result1 - 2;\n  if ((result3 & 0x100000) != 0) goto LAB_08000278;\n  value2 = value1;\n  result1 = result3;\n  if (result3 == 0) {\n    value2 = 0;\n    result1 = value1;\n  }\n  shift = LZCOUNT(result1);\n  if (result3 == 0) {\n    shift = shift + 0x20;\n  }\n  result3 = shift - 0xb;\n  condition3 = SBORROW4(result3,0x20);\n  value1 = shift - 0x2b;\n  condition2 = (int)value1 < 0;\n  condition1 = value1 == 0;\n  if ((int)result3 < 0x20) {\n    condition3 = SCARRY4(value1,0xc);\n    shift = shift + -0x1f;\n    condition2 = shift < 0;\n    condition1 = shift == 0;\n    value1 = result3;\n    if (!condition1 && condition2 == condition3) {\n      value2 = result1 << (result3 & 0xff);\n      result1 = result1 >> (0xcU - shift & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (condition1 || condition2 != condition3) {\n    result4 = 0x20 - value1;\n  }\n  result1 = result1 << (value1 & 0xff);\n  if (condition1 || condition2 != condition3) {\n    result1 = result1 | value2 >> (result4 & 0xff);\n  }\n  if (condition1 || condition2 != condition3) {\n    value2 = value2 << (value1 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)result3 <= (int)result2) {\n    return CONCAT44(result1 + (result2 - result3) * 0x100000 | input2,value2);\n  }\n  value1 = ~(result2 - result3);\n  if ((int)value1 < 0x1f) {\n    shift = value1 - 0x13;\n    if (shift != 0 && shift < 0 == SCARRY4(value1 - 0x1f,0xc)) {\n      return CONCAT44(temp2,value2 >> (0x20 - (0xcU - shift) & 0xff) | result1 << (0xcU - shift & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    value1 = value1 + 1;\n    return CONCAT44(input2 | result1 >> (value1 & 0xff),\n                    value2 >> (value1 & 0xff) | result1 << (0x20 - value1 & 0xff));\n  }\n  return CONCAT44(temp2,result1 >> (value1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000168": "calculate_result_08000168",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "bVar2": "carryFlag",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "uVar6": "value1",
                "uVar7": "value2",
                "iVar8": "shift",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "result3",
                "uVar12": "result4",
                "bVar13": "condition1",
                "bVar14": "condition2",
                "bVar15": "condition3"
            },
            "calling": [
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800016c": {
            "entrypoint": "0x0800016c",
            "current_name": "calculate_integer_division_0800016c",
            "code": "\nulonglong calculate_integer_division_0800016c(uint dividend,uint divisor,uint quotient_high,uint quotient_low)\n\n{\n  int quotient_high_bit;\n  byte carry_bit;\n  uint dividend_lo;\n  uint divisor_lo;\n  uint temp1;\n  int quotient_low_bit;\n  uint temp2;\n  uint temp3;\n  uint res_high;\n  uint res_low;\n  uint carry_flag;\n  uint res_bit_extension;\n  bool is_same_sign;\n  bool is_condition_true;\n  bool overflow_flag;\n  \n  temp2 = divisor << 1;\n  res_high = quotient_low << 1;\n  is_same_sign = ((divisor ^ quotient_low) & 0x7fffffff) == 0;\n  is_condition_true = is_same_sign && dividend == quotient_high;\n  if (!is_same_sign || dividend != quotient_high) {\n    is_condition_true = (temp2 | dividend) == 0;\n  }\n  if (!is_condition_true) {\n    is_condition_true = (res_high | quotient_high) == 0;\n  }\n  quotient_low_bit = (int)temp2 >> 0x15;\n  if (!is_condition_true) {\n    is_condition_true = quotient_low_bit == -1;\n  }\n  quotient_high_bit = (int)res_high >> 0x15;\n  if (!is_condition_true) {\n    is_condition_true = quotient_high_bit == -1;\n  }\n  if (is_condition_true) {\n    if (quotient_low_bit == -1 || quotient_high_bit == -1) {\n      res_high = quotient_low;\n      temp2 = quotient_high;\n      if (quotient_low_bit == -1) {\n        res_high = divisor;\n        temp2 = dividend;\n      }\n      if (quotient_low_bit != -1 || quotient_high_bit != -1) {\n        quotient_high = temp2;\n        quotient_low = res_high;\n      }\n      is_condition_true = (temp2 | res_high << 0xc) == 0;\n      if (is_condition_true) {\n        is_condition_true = (quotient_high | quotient_low << 0xc) == 0;\n      }\n      if (is_condition_true) {\n        is_condition_true = res_high == quotient_low;\n      }\n      if (!is_condition_true) {\n        res_high = res_high | 0x80000;\n      }\n      return CONCAT44(res_high,temp2);\n    }\n    if (((divisor ^ quotient_low) & 0x7fffffff) != 0 || dividend != quotient_high) {\n      if ((temp2 | dividend) == 0) {\n        dividend = quotient_high;\n        divisor = quotient_low;\n      }\n      return CONCAT44(divisor,dividend);\n    }\n    if (divisor != quotient_low) {\n      return 0;\n    }\n    if (temp2 >> 0x15 == 0) {\n      is_condition_true = (dividend & 0x80000000) != 0;\n      res_high = divisor * 2 + (uint)is_condition_true;\n      if (CARRY4(divisor,divisor) || CARRY4(divisor * 2,(uint)is_condition_true)) {\n        res_high = res_high | 0x80000000;\n      }\n      return CONCAT44(res_high,dividend << 1);\n    }\n    if (temp2 < 0xffc00000) {\n      return CONCAT44(divisor + 0x100000,dividend);\n    }\n    divisor = divisor & 0x80000000;\nLAB_080003ac:\n    return (ulonglong)(divisor | 0x7ff00000) << 0x20;\n  }\n  temp2 = temp2 >> 0x15;\n  res_high = res_high >> 0x15;\n  res_low = res_high - temp2;\n  is_condition_true = res_low != 0;\n  if (res_high < temp2) {\n    res_low = -res_low;\n  }\n  temp3 = dividend;\n  temp1 = divisor;\n  if (is_condition_true && temp2 <= res_high) {\n    temp2 = temp2 + res_low;\n    temp3 = quotient_high;\n    temp1 = quotient_low;\n    quotient_high = dividend;\n    quotient_low = divisor;\n  }\n  if (0x36 < res_low) {\n    return CONCAT44(temp1,temp3);\n  }\n  res_high = temp1 & 0xfffff | 0x100000;\n  if ((temp1 & 0x80000000) != 0) {\n    is_condition_true = temp3 != 0;\n    temp3 = -temp3;\n    res_high = -res_high - (uint)is_condition_true;\n  }\n  temp1 = quotient_low & 0xfffff | 0x100000;\n  if ((quotient_low & 0x80000000) != 0) {\n    is_condition_true = quotient_high != 0;\n    quotient_high = -quotient_high;\n    temp1 = -temp1 - (uint)is_condition_true;\n  }\n  if (temp2 == res_low) {\n    temp1 = temp1 ^ 0x100000;\n    if (temp2 == 0) {\n      res_high = res_high ^ 0x100000;\n      temp2 = 1;\n    }\n    else {\n      res_low = res_low - 1;\n    }\n  }\n  res_bit_extension = -res_low + 0x20;\n  if ((int)res_low < 0x21) {\n    carry_flag = quotient_high << (res_bit_extension & 0xff);\n    quotient_high = quotient_high >> (res_low & 0xff);\n    dividend_lo = temp3 + quotient_high;\n    divisor_lo = temp1 << (res_bit_extension & 0xff);\n    res_bit_extension = dividend_lo + divisor_lo;\n    res_high = res_high + CARRY4(temp3,quotient_high) + ((int)temp1 >> (res_low & 0xff)) +\n            (uint)CARRY4(dividend_lo,divisor_lo);\n  }\n  else {\n    carry_flag = temp1 << (-res_low + 0x40 & 0xff);\n    if (quotient_high != 0) {\n      carry_flag = carry_flag | 2;\n    }\n    temp1 = (int)temp1 >> (res_low - 0x20 & 0xff);\n    res_bit_extension = temp3 + temp1;\n    res_high = res_high + ((int)temp1 >> 0x1f) + (uint)CARRY4(temp3,temp1);\n  }\n  divisor = res_high & 0x80000000;\n  res_low = res_high;\n  if ((int)res_high < 0) {\n    is_condition_true = carry_flag == 0;\n    carry_flag = -carry_flag;\n    res_low = -res_bit_extension;\n    res_bit_extension = -(uint)!is_condition_true - res_bit_extension;\n    res_low = -(uint)(is_condition_true <= res_low) - res_high;\n  }\n  if (0xfffff < res_low) {\n    temp3 = temp2 - 1;\n    if (0x1fffff < res_low) {\n      res_high = res_low & 1;\n      res_low = res_low >> 1;\n      carry_bit = (byte)res_bit_extension;\n      res_bit_extension = (uint)(res_high != 0) << 0x1f | res_bit_extension >> 1;\n      carry_flag = (uint)(carry_bit & 1) << 0x1f | carry_flag >> 1;\n      temp3 = temp2;\n      if (0xffbfffff < temp2 * 0x200000) goto LAB_080003ac;\n    }\nLAB_08000278:\n    is_condition_true = 0x7fffffff < carry_flag;\n    if (carry_flag == 0x80000000) {\n      is_condition_true = (res_bit_extension & 1) != 0;\n    }\n    return CONCAT44(res_low + temp3 * 0x100000 + (uint)CARRY4(res_bit_extension,(uint)is_condition_true) | divisor,\n                    res_bit_extension + is_condition_true);\n  }\n  is_same_sign = (carry_flag & 0x80000000) != 0;\n  carry_flag = carry_flag << 1;\n  temp3 = res_bit_extension * 2;\n  is_condition_true = CARRY4(res_bit_extension,res_bit_extension);\n  res_bit_extension = res_bit_extension * 2 + (uint)is_same_sign;\n  res_low = res_low * 2 + (uint)(is_condition_true || CARRY4(temp3,(uint)is_same_sign));\n  temp3 = temp2 - 2;\n  if ((res_low & 0x100000) != 0) goto LAB_08000278;\n  temp1 = res_bit_extension;\n  temp2 = res_low;\n  if (res_low == 0) {\n    temp1 = 0;\n    temp2 = res_bit_extension;\n  }\n  quotient_low_bit = LZCOUNT(temp2);\n  if (res_low == 0) {\n    quotient_low_bit = quotient_low_bit + 0x20;\n  }\n  res_bit_extension = quotient_low_bit - 0xb;\n  overflow_flag = SBORROW4(res_bit_extension,0x20);\n  res_low = quotient_low_bit - 0x2b;\n  is_condition_true = (int)res_low < 0;\n  is_same_sign = res_low == 0;\n  if ((int)res_bit_extension < 0x20) {\n    overflow_flag = SCARRY4(res_low,0xc);\n    quotient_low_bit = quotient_low_bit + -0x1f;\n    is_condition_true = quotient_low_bit < 0;\n    is_same_sign = quotient_low_bit == 0;\n    res_low = res_bit_extension;\n    if (!is_same_sign && is_condition_true == overflow_flag) {\n      temp1 = temp2 << (res_bit_extension & 0xff);\n      temp2 = temp2 >> (0xcU - quotient_low_bit & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (is_same_sign || is_condition_true != overflow_flag) {\n    carry_flag = 0x20 - res_low;\n  }\n  temp2 = temp2 << (res_low & 0xff);\n  if (is_same_sign || is_condition_true != overflow_flag) {\n    temp2 = temp2 | temp1 >> (carry_flag & 0xff);\n  }\n  if (is_same_sign || is_condition_true != overflow_flag) {\n    temp1 = temp1 << (res_low & 0xff);\n  }\nLAB_080002f0:\n  if ((int)res_bit_extension <= (int)temp3) {\n    return CONCAT44(temp2 + (temp3 - res_bit_extension) * 0x100000 | divisor,temp1);\n  }\n  res_low = ~(temp3 - res_bit_extension);\n  if ((int)res_low < 0x1f) {\n    quotient_low_bit = res_low - 0x13;\n    if (quotient_low_bit != 0 && quotient_low_bit < 0 == SCARRY4(res_low - 0x1f,0xc)) {\n      return CONCAT44(res_high,temp1 >> (0x20 - (0xcU - quotient_low_bit) & 0xff) | temp2 << (0xcU - quotient_low_bit & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    res_low = res_low + 1;\n    return CONCAT44(divisor | temp2 >> (res_low & 0xff),\n                    temp1 >> (res_low & 0xff) | temp2 << (0x20 - res_low & 0xff));\n  }\n  return CONCAT44(res_high,temp2 >> (res_low - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800016c": "calculate_integer_division_0800016c",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient_high",
                "param_4": "quotient_low",
                "iVar1": "quotient_high_bit",
                "bVar2": "carry_bit",
                "uVar3": "dividend_lo",
                "uVar4": "divisor_lo",
                "uVar5": "temp1",
                "iVar6": "quotient_low_bit",
                "uVar7": "temp2",
                "uVar8": "temp3",
                "uVar9": "res_high",
                "uVar10": "res_low",
                "uVar11": "carry_flag",
                "uVar12": "res_bit_extension",
                "bVar13": "is_same_sign",
                "bVar14": "is_condition_true",
                "bVar15": "overflow_flag"
            },
            "calling": [
                "scalbn",
                "__ieee754_atan2",
                "rint",
                "atan",
                "__ieee754_sqrt",
                "__ieee754_asin",
                "__aeabi_drsub",
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003e4": {
            "entrypoint": "0x080003e4",
            "current_name": "shift_and_concatenate_080003e4",
            "code": "\nulonglong shift_and_concatenate_080003e4(uint input)\n\n{\n  uint upper;\n  uint shift;\n  int lz_count;\n  uint shift_amount;\n  uint remaining_bits;\n  bool is_negative;\n  bool is_zero;\n  bool carry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  upper = 0;\n  lz_count = LZCOUNT(input);\n  shift_amount = lz_count + 0x15;\n  carry = SBORROW4(shift_amount,0x20);\n  shift = lz_count - 0xb;\n  is_negative = (int)shift < 0;\n  is_zero = shift == 0;\n  if (shift_amount < 0x20) {\n    carry = SCARRY4(shift,0xc);\n    is_negative = false;\n    is_zero = lz_count + 1 == 0;\n    shift = shift_amount;\n    if (!is_zero && carry == false) {\n      upper = input << shift_amount;\n      input = input >> (0xcU - (lz_count + 1) & 0xff);\n      goto shift_left;\n    }\n  }\n  if (is_zero || is_negative != carry) {\n    remaining_bits = 0x20 - shift;\n  }\n  input = input << (shift & 0xff);\n  if (is_zero || is_negative != carry) {\n    input = input | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero || is_negative != carry) {\n    upper = 0 << (shift & 0xff);\n  }\nshift_left:\n  if (shift_amount < 0x433) {\n    return concatenate_64_bits(input + (0x432 - shift_amount) * 0x100000,upper);\n  }\n  shift = ~(0x432 - shift_amount);\n  if (0x1e < (int)shift) {\n    return (ulonglong)(input >> (shift - 0x1f & 0xff));\n  }\n  lz_count = shift - 0x13;\n  if (lz_count == 0 || lz_count < 0 != SCARRY4(shift - 0x1f,0xc)) {\n    shift = shift + 1;\n    return concatenate_64_bits(input >> (shift & 0xff),\n                    upper >> (shift & 0xff) | input << (0x20 - shift & 0xff));\n  }\n  return (ulonglong)(upper >> (0x20 - (0xcU - lz_count) & 0xff) | input << (0xcU - lz_count & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003e4": "shift_and_concatenate_080003e4",
                "param_1": "input",
                "uVar1": "upper",
                "uVar2": "shift",
                "iVar3": "lz_count",
                "uVar4": "shift_amount",
                "in_r12": "remaining_bits",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "carry",
                "LAB_080002f0": "shift_left",
                "CONCAT44": "concatenate_64_bits"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000404": {
            "entrypoint": "0x08000404",
            "current_name": "bit_shift_and_concat_08000404",
            "code": "\nulonglong bitShiftAndConcat_08000404(uint input)\n\n{\n  uint counter;\n  uint absInput;\n  uint shiftAmount;\n  int leadingZeros;\n  uint totalShift;\n  uint signBit;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isCarry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  signBit = input & 0x80000000;\n  absInput = input;\n  if ((int)signBit < 0) {\n    absInput = -input;\n  }\n  counter = 0;\n  leadingZeros = LZCOUNT(absInput);\n  totalShift = leadingZeros + 0x15;\n  isCarry = SBORROW4(totalShift,0x20);\n  shiftAmount = leadingZeros - 0xb;\n  isNegative = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (totalShift < 0x20) {\n    isCarry = SCARRY4(shiftAmount,0xc);\n    isNegative = false;\n    isZero = leadingZeros + 1 == 0;\n    shiftAmount = totalShift;\n    if (!isZero && isCarry == false) {\n      counter = absInput << totalShift;\n      absInput = absInput >> (0xcU - (leadingZeros + 1) & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isZero || isNegative != isCarry) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  absInput = absInput << (shiftAmount & 0xff);\n  if (isZero || isNegative != isCarry) {\n    absInput = absInput | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != isCarry) {\n    counter = 0 << (shiftAmount & 0xff);\n  }\nLAB_080002f0:\n  if (totalShift < 0x433) {\n    return CONCAT44(absInput + (0x432 - totalShift) * 0x100000 | signBit,counter);\n  }\n  shiftAmount = ~(0x432 - totalShift);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(input,absInput >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(signBit | absInput >> (shiftAmount & 0xff),\n                    counter >> (shiftAmount & 0xff) | absInput << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(input,counter >> (0x20 - (0xcU - leadingZeros) & 0xff) | absInput << (0xcU - leadingZeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000404": "bit_shift_and_concat_08000404",
                "param_1": "input",
                "uVar1": "counter",
                "uVar2": "absInput",
                "uVar3": "shiftAmount",
                "iVar4": "leadingZeros",
                "uVar5": "totalShift",
                "uVar6": "signBit",
                "in_r12": "remainingBits",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "isCarry"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000428": {
            "entrypoint": "0x08000428",
            "current_name": "reverse_bytes_08000428",
            "code": "\nulonglong reverse_bytes_08000428(uint input,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint bit31;\n  uint temp;\n  uint result;\n  uint shifted_input;\n  uint doubled_input;\n  int lzcount_result;\n  uint uVar7;\n  uint in_r12;\n  bool bVar8;\n  bool bVar9;\n  bool bVar10;\n  \n  doubled_input = input << 1;\n  bVar9 = doubled_input == 0;\n  bit31 = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shifted_input = (uint)((int)doubled_input >> 3) >> 1;\n  result = bit31 | shifted_input;\n  input = input << 0x1d;\n  if (!bVar9) {\n    param4 = doubled_input & 0xff000000;\n    bVar9 = param4 == 0;\n  }\n  if (!bVar9) {\n    bVar9 = param4 == 0xff000000;\n  }\n  if (!bVar9) {\n    return CONCAT44(result,input) ^ 0x3800000000000000;\n  }\n  if (doubled_input == 0 || param4 == 0xff000000) {\n    return CONCAT44(result,input);\n  }\n  temp = input;\n  doubled_input = shifted_input;\n  if (shifted_input == 0) {\n    temp = 0;\n    doubled_input = input;\n  }\n  lzcount_result = LZCOUNT(doubled_input);\n  if (shifted_input == 0) {\n    lzcount_result = lzcount_result + 0x20;\n  }\n  uVar7 = lzcount_result - 0xb;\n  bVar10 = SBORROW4(uVar7,0x20);\n  shifted_input = lzcount_result - 0x2b;\n  bVar9 = (int)shifted_input < 0;\n  bVar8 = shifted_input == 0;\n  if ((int)uVar7 < 0x20) {\n    bVar10 = SCARRY4(shifted_input,0xc);\n    lzcount_result = lzcount_result + -0x1f;\n    bVar9 = lzcount_result < 0;\n    bVar8 = lzcount_result == 0;\n    shifted_input = uVar7;\n    if (!bVar8 && bVar9 == bVar10) {\n      temp = doubled_input << (uVar7 & 0xff);\n      doubled_input = doubled_input >> (0xcU - lzcount_result & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (bVar8 || bVar9 != bVar10) {\n    in_r12 = 0x20 - shifted_input;\n  }\n  doubled_input = doubled_input << (shifted_input & 0xff);\n  if (bVar8 || bVar9 != bVar10) {\n    doubled_input = doubled_input | temp >> (in_r12 & 0xff);\n  }\n  if (bVar8 || bVar9 != bVar10) {\n    temp = temp << (shifted_input & 0xff);\n  }\nLAB_080002f0:\n  if ((int)uVar7 < 0x381) {\n    return CONCAT44(doubled_input + (0x380 - uVar7) * 0x100000 | bit31,temp);\n  }\n  shifted_input = ~(0x380 - uVar7);\n  if ((int)shifted_input < 0x1f) {\n    lzcount_result = shifted_input - 0x13;\n    if (lzcount_result != 0 && lzcount_result < 0 == SCARRY4(shifted_input - 0x1f,0xc)) {\n      return CONCAT44(result,temp >> (0x20 - (0xcU - lzcount_result) & 0xff) | doubled_input << (0xcU - lzcount_result & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    shifted_input = shifted_input + 1;\n    return CONCAT44(bit31 | doubled_input >> (shifted_input & 0xff),\n                    temp >> (shifted_input & 0xff) | doubled_input << (0x20 - shifted_input & 0xff));\n  }\n  return CONCAT44(result,doubled_input >> (shifted_input - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000428": "reverse_bytes_08000428",
                "param_1": "input",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "bit31",
                "uVar2": "temp",
                "uVar3": "result",
                "uVar4": "shifted_input",
                "uVar5": "doubled_input",
                "iVar6": "lzcount_result"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000464": {
            "entrypoint": "0x08000464",
            "current_name": "calculate_concatenation_08000464",
            "code": "\nulonglong calculateConcatenation_08000464(uint input1,uint input2)\n\n{\n  byte firstBit;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shiftAmount;\n  uint shiftedAmount;\n  int bitCount;\n  uint shiftedInput;\n  bool isNegative;\n  bool carryOccurred;\n  bool isCarry;\n  \n  if ((input1 | input2) == 0) {\n    return constructInteger64(input2,input1);\n  }\n  bitCount = 0x432;\n  shiftedInput = input2 >> 0x16;\n  if (shiftedInput != 0) {\n    bitCount = 3;\n    if (input2 >> 0x19 != 0) {\n      bitCount = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      bitCount = bitCount + 3;\n    }\n    temp3 = bitCount - ((int)input2 >> 0x1f);\n    shiftedInput = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | input2 << (0x20 - temp3 & 0xff);\n    input2 = input2 >> (temp3 & 0xff);\n    bitCount = temp3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      temp3 = input2 & 1;\n      input2 = input2 >> 1;\n      firstBit = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      shiftedInput = (uint)(firstBit & 1) << 0x1f | shiftedInput >> 1;\n      bitCount = bitCount + 1;\n      if (0xffbfffff < (uint)(bitCount * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000278:\n    carryOccurred = 0x7fffffff < shiftedInput;\n    if (shiftedInput == 0x80000000) {\n      carryOccurred = (input1 & 1) != 0;\n    }\n    return constructInteger64(input2 + bitCount * 0x100000 + (uint)checkCarry(input1,(uint)carryOccurred),input1 + carryOccurred\n                   );\n  }\n  isNegative = (shiftedInput & 0x80000000) != 0;\n  shiftedInput = shiftedInput << 1;\n  temp3 = input1 * 2;\n  carryOccurred = checkCarry(input1,input1);\n  input1 = input1 * 2 + (uint)isNegative;\n  input2 = input2 * 2 + (uint)(carryOccurred || checkCarry(temp3,(uint)isNegative));\n  bitCount = bitCount + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_08000278;\n  temp1 = input1;\n  temp3 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  shiftAmount = leadingZeroCount(temp3);\n  if (input2 == 0) {\n    shiftAmount = shiftAmount + 0x20;\n  }\n  shiftedAmount = shiftAmount - 0xb;\n  isCarry = checkSubtractionBorrow(shiftedAmount,0x20);\n  temp2 = shiftAmount - 0x2b;\n  carryOccurred = (int)temp2 < 0;\n  isNegative = temp2 == 0;\n  if ((int)shiftedAmount < 0x20) {\n    isCarry = checkShiftCarry(temp2,0xc);\n    shiftAmount = shiftAmount + -0x1f;\n    carryOccurred = shiftAmount < 0;\n    isNegative = shiftAmount == 0;\n    temp2 = shiftedAmount;\n    if (!isNegative && carryOccurred == isCarry) {\n      temp1 = temp3 << (shiftedAmount & 0xff);\n      temp3 = temp3 >> (0xcU - shiftAmount & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (isNegative || carryOccurred != isCarry) {\n    shiftedInput = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (isNegative || carryOccurred != isCarry) {\n    temp3 = temp3 | temp1 >> (shiftedInput & 0xff);\n  }\n  if (isNegative || carryOccurred != isCarry) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)shiftedAmount <= bitCount) {\n    return constructInteger64(temp3 + (bitCount - shiftedAmount) * 0x100000,temp1);\n  }\n  shiftedInput = ~(bitCount - shiftedAmount);\n  if (0x1e < (int)shiftedInput) {\n    return (ulonglong)(temp3 >> (shiftedInput - 0x1f & 0xff));\n  }\n  bitCount = shiftedInput - 0x13;\n  if (bitCount == 0 || bitCount < 0 != checkShiftCarry(shiftedInput - 0x1f,0xc)) {\n    shiftedInput = shiftedInput + 1;\n    return constructInteger64(temp3 >> (shiftedInput & 0xff),temp1 >> (shiftedInput & 0xff) | temp3 << (0x20 - shiftedInput & 0xff)\n                   );\n  }\n  return (ulonglong)(temp1 >> (0x20 - (0xcU - bitCount) & 0xff) | temp3 << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_08000464": "calculate_concatenation_08000464",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "firstBit",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "shiftAmount",
                "uVar6": "shiftedAmount",
                "iVar7": "bitCount",
                "uVar8": "shiftedInput",
                "bVar9": "isNegative",
                "bVar10": "carryOccurred",
                "bVar11": "isCarry",
                "CONCAT44": "constructInteger64",
                "CARRY4": "checkCarry",
                "LZCOUNT": "leadingZeroCount",
                "SBORROW4": "checkSubtractionBorrow",
                "SCARRY4": "checkShiftCarry"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000474": {
            "entrypoint": "0x08000474",
            "current_name": "calculate_08000474",
            "code": "\nulonglong calculate_08000474(uint input1,uint input2)\n\n{\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift;\n  uint carry2;\n  int count;\n  uint sign;\n  uint remainder;\n  bool shift_carry;\n  bool add_carry;\n  bool subtract_carry;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  sign = input2 & 0x80000000;\n  temp2 = input2;\n  if ((int)sign < 0) {\n    add_carry = input1 != 0;\n    input1 = -input1;\n    temp2 = -input2 - (uint)add_carry;\n  }\n  count = 0x432;\n  remainder = temp2 >> 0x16;\n  if (remainder != 0) {\n    count = 3;\n    if (temp2 >> 0x19 != 0) {\n      count = 6;\n    }\n    if (temp2 >> 0x1c != 0) {\n      count = count + 3;\n    }\n    temp3 = count - ((int)temp2 >> 0x1f);\n    remainder = input1 << (0x20 - temp3 & 0xff);\n    input1 = input1 >> (temp3 & 0xff) | temp2 << (0x20 - temp3 & 0xff);\n    temp2 = temp2 >> (temp3 & 0xff);\n    count = temp3 + 0x432;\n  }\n  if (0xfffff < temp2) {\n    if (0x1fffff < temp2) {\n      temp3 = temp2 & 1;\n      temp2 = temp2 >> 1;\n      carry = (byte)input1;\n      input1 = (uint)(temp3 != 0) << 0x1f | input1 >> 1;\n      remainder = (uint)(carry & 1) << 0x1f | remainder >> 1;\n      count = count + 1;\n      if (0xffbfffff < (uint)(count * 0x200000)) {\n        return (ulonglong)(sign | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000278:\n    add_carry = 0x7fffffff < remainder;\n    if (remainder == 0x80000000) {\n      add_carry = (input1 & 1) != 0;\n    }\n    return CONCAT44(temp2 + count * 0x100000 + (uint)CARRY4(input1,(uint)add_carry) | sign,\n                    input1 + add_carry);\n  }\n  shift_carry = (remainder & 0x80000000) != 0;\n  remainder = remainder << 1;\n  temp3 = input1 * 2;\n  add_carry = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)shift_carry;\n  temp2 = temp2 * 2 + (uint)(add_carry || CARRY4(temp3,(uint)shift_carry));\n  count = count + -1;\n  if ((temp2 & 0x100000) != 0) goto LAB_08000278;\n  temp1 = input1;\n  temp3 = temp2;\n  if (temp2 == 0) {\n    temp1 = 0;\n    temp3 = input1;\n  }\n  shift = LZCOUNT(temp3);\n  if (temp2 == 0) {\n    shift = shift + 0x20;\n  }\n  carry2 = shift - 0xb;\n  subtract_carry = SBORROW4(carry2,0x20);\n  temp2 = shift - 0x2b;\n  add_carry = (int)temp2 < 0;\n  shift_carry = temp2 == 0;\n  if ((int)carry2 < 0x20) {\n    subtract_carry = SCARRY4(temp2,0xc);\n    shift = shift + -0x1f;\n    add_carry = shift < 0;\n    shift_carry = shift == 0;\n    temp2 = carry2;\n    if (!shift_carry && add_carry == subtract_carry) {\n      temp1 = temp3 << (carry2 & 0xff);\n      temp3 = temp3 >> (0xcU - shift & 0xff);\n      goto LAB_080002f0;\n    }\n  }\n  if (shift_carry || add_carry != subtract_carry) {\n    remainder = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (shift_carry || add_carry != subtract_carry) {\n    temp3 = temp3 | temp1 >> (remainder & 0xff);\n  }\n  if (shift_carry || add_carry != subtract_carry) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002f0:\n  if ((int)carry2 <= count) {\n    return CONCAT44(temp3 + (count - carry2) * 0x100000 | sign,temp1);\n  }\n  temp2 = ~(count - carry2);\n  if (0x1e < (int)temp2) {\n    return CONCAT44(input2,temp3 >> (temp2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  count = temp2 - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(temp2 - 0x1f,0xc)) {\n    temp2 = temp2 + 1;\n    return CONCAT44(sign | temp3 >> (temp2 & 0xff),\n                    temp1 >> (temp2 & 0xff) | temp3 << (0x20 - temp2 & 0xff));\n  }\n  return CONCAT44(input2,temp1 >> (0x20 - (0xcU - count) & 0xff) | temp3 << (0xcU - count & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000474": "calculate_08000474",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "carry",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "shift",
                "uVar6": "carry2",
                "iVar7": "count",
                "uVar8": "sign",
                "uVar9": "remainder",
                "bVar10": "shift_carry",
                "bVar11": "add_carry",
                "bVar12": "subtract_carry"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004d0": {
            "entrypoint": "0x080004d0",
            "current_name": "calculate_xor_080004d0",
            "code": "\nulonglong calculate_xor_080004d0(undefined4 input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  ulonglong product_1;\n  longlong product_2;\n  uint result_1;\n  uint result_2;\n  int sum;\n  uint temp_1;\n  uint unaff_r5;\n  uint temp_2;\n  uint temp_3;\n  bool is_zero;\n  bool is_overflow;\n  bool is_sub_overflow;\n  ulonglong concatenated_input;\n  \n  concatenated_input = CONCAT44(input_2,input_1);\n  temp_2 = 0x7ff;\n  result_2 = input_2 >> 0x14 & 0x7ff;\n  is_zero = result_2 == 0;\n  if (!is_zero) {\n    unaff_r5 = input_4 >> 0x14 & 0x7ff;\n    is_zero = unaff_r5 == 0;\n  }\n  if (!is_zero) {\n    is_zero = result_2 == 0x7ff;\n  }\n  if (!is_zero) {\n    is_zero = unaff_r5 == 0x7ff;\n  }\n  if (is_zero) {\n    concatenated_input = calculate_xor_080004d0_080006ac();\n  }\n  result_1 = (uint)(concatenated_input >> 0x20);\n  sum = result_2 + unaff_r5;\n  result_2 = result_1 ^ input_4;\n  result_1 = result_1 & ~(temp_2 << 0x15);\n  input_4 = input_4 & ~(temp_2 << 0x15);\n  is_zero = ((uint)concatenated_input | result_1 << 0xc) == 0;\n  if (!is_zero) {\n    is_zero = (input_3 | input_4 << 0xc) == 0;\n  }\n  result_1 = result_1 | 0x100000;\n  input_4 = input_4 | 0x100000;\n  if (is_zero) {\n    input_3 = (uint)concatenated_input | input_3;\n    input_4 = (result_2 & 0x80000000 | result_1) ^ input_4;\n    result_2 = temp_2 >> 1;\n    is_sub_overflow = SBORROW4(sum,result_2);\n    temp_1 = sum - result_2;\n    is_zero = temp_1 == 0;\n    result_1 = temp_1;\n    if (!is_zero && (int)result_2 <= sum) {\n      is_sub_overflow = SBORROW4(temp_2,temp_1);\n      result_1 = temp_2 - temp_1;\n      is_zero = temp_2 == temp_1;\n    }\n    if (!is_zero && (int)result_1 < 0 == is_sub_overflow) {\n      input_4 = input_4 | temp_1 * 0x100000;\n    }\n    if (!is_zero && (int)result_1 < 0 == is_sub_overflow) {\n      return CONCAT44(input_4,input_3);\n    }\n    input_4 = input_4 | 0x100000;\n    temp_2 = 0;\n    is_sub_overflow = SBORROW4(temp_1,1);\n    temp_1 = temp_1 - 1;\n    is_zero = temp_1 == 0;\n    result_2 = temp_1;\n  }\n  else {\n    product_1 = (concatenated_input & 0xffffffff) * (ulonglong)input_3;\n    concatenated_input = (concatenated_input & 0xffffffff) * (ulonglong)input_4 +\n             (ulonglong)result_1 * (ulonglong)input_3 + (product_1 >> 0x20);\n    temp_3 = (uint)concatenated_input;\n    product_2 = (ulonglong)result_1 * (ulonglong)input_4 + (concatenated_input >> 0x20);\n    temp_2 = (uint)product_2;\n    result_1 = (uint)((ulonglong)product_2 >> 0x20);\n    if ((int)product_1 != 0) {\n      temp_3 = temp_3 | 1;\n    }\n    temp_1 = (sum + -0x3ff) - (uint)(result_1 < 0x200);\n    if (result_1 < 0x200) {\n      is_zero = (temp_3 & 0x80000000) != 0;\n      temp_3 = temp_3 << 1;\n      product_2 = CONCAT44(result_1 * 2 + (uint)(CARRY4(temp_2,temp_2) || CARRY4(temp_2 * 2,(uint)is_zero)),\n                       temp_2 * 2 + (uint)is_zero);\n    }\n    input_4 = result_2 & 0x80000000 | (int)((ulonglong)product_2 >> 0x20) << 0xb | (uint)product_2 >> 0x15;\n    input_3 = (uint)product_2 << 0xb | temp_3 >> 0x15;\n    temp_2 = temp_3 * 0x800;\n    is_overflow = 0xfc < temp_1;\n    is_sub_overflow = SBORROW4(temp_1,0xfd);\n    result_1 = temp_1 - 0xfd;\n    is_zero = result_1 == 0;\n    result_2 = result_1;\n    if (is_overflow && !is_zero) {\n      is_overflow = 0x6ff < result_1;\n      is_sub_overflow = SBORROW4(result_1,0x700);\n      result_2 = temp_1 - 0x7fd;\n      is_zero = result_1 == 0x700;\n    }\n    if (!is_overflow || is_zero) {\n      is_zero = 0x7fffffff < temp_2;\n      if (temp_2 == 0x80000000) {\n        is_zero = (temp_3 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input_4 + temp_1 * 0x100000 + (uint)CARRY4(input_3,(uint)is_zero),input_3 + is_zero\n                     );\n    }\n  }\n  if (!is_zero && (int)result_2 < 0 == is_sub_overflow) {\n    return (ulonglong)(input_4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  is_overflow = SCARRY4(temp_1,0x36);\n  is_zero = (int)(temp_1 + 0x36) < 0;\n  is_sub_overflow = temp_1 == 0xffffffca;\n  if (is_sub_overflow || is_zero != is_overflow) {\n    input_3 = 0;\n  }\n  if (is_sub_overflow || is_zero != is_overflow) {\n    input_4 = input_4 & 0x80000000;\n  }\n  if (is_sub_overflow || is_zero != is_overflow) {\n    return CONCAT44(input_4,input_3);\n  }\n  result_2 = -temp_1;\n  result_1 = result_2 - 0x20;\n  if (0x1f < (int)result_2) {\n    temp_1 = input_3 >> (result_1 & 0xff) | input_4 << (0x20 - result_1 & 0xff);\n    result_2 = (input_4 >> (result_1 & 0xff) & ~((input_4 & 0x80000000) >> (result_1 & 0xff))) -\n            ((int)temp_1 >> 0x1f);\n    if ((temp_2 | input_3 << (0x20 - result_1 & 0xff) | temp_1 << 1) == 0) {\n      result_2 = result_2 & ~(temp_1 >> 0x1f);\n    }\n    return CONCAT44(input_4,result_2) & 0x80000000ffffffff;\n  }\n  sum = result_2 - 0x14;\n  if (sum == 0 || sum < 0 != SCARRY4(result_1,0xc)) {\n    temp_3 = input_3 << (temp_1 + 0x20 & 0xff);\n    result_1 = input_3 >> (result_2 & 0xff) | input_4 << (temp_1 + 0x20 & 0xff);\n    temp_1 = result_1 + -((int)temp_3 >> 0x1f);\n    if ((temp_2 | temp_3 << 1) == 0) {\n      temp_1 = temp_1 & ~(temp_3 >> 0x1f);\n    }\n    return CONCAT44((input_4 & 0x80000000) +\n                    ((input_4 & 0x7fffffff) >> (result_2 & 0xff)) +\n                    (uint)CARRY4(result_1,-((int)temp_3 >> 0x1f)),temp_1);\n  }\n  result_2 = 0xc - sum;\n  temp_1 = input_3 << (result_2 & 0xff);\n  result_2 = input_3 >> (0x20 - result_2 & 0xff) | input_4 << (result_2 & 0xff);\n  result_1 = result_2 + -((int)temp_1 >> 0x1f);\n  if ((temp_2 | temp_1 << 1) == 0) {\n    result_1 = result_1 & ~(temp_1 >> 0x1f);\n  }\n  return CONCAT44((input_4 & 0x80000000) + (uint)CARRY4(result_2,-((int)temp_1 >> 0x1f)),result_1);\n}\n\n",
            "renaming": {
                "FUN_080004d0": "calculate_xor_080004d0",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "product_1",
                "lVar2": "product_2",
                "uVar3": "result_1",
                "uVar4": "result_2",
                "iVar5": "sum",
                "uVar6": "temp_1",
                "uVar7": "temp_2",
                "uVar8": "temp_3",
                "bVar9": "is_zero",
                "bVar10": "is_overflow",
                "bVar11": "is_sub_overflow",
                "uVar12": "concatenated_input"
            },
            "calling": [
                "pow",
                "scalbn",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "MS5611_Update",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_080006ac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006ac": {
            "entrypoint": "0x080006ac",
            "current_name": "calculate_xor_080006ac",
            "code": "\nulonglong calculate_xor_080006ac(uint input_a,uint input_b,uint input_c,uint input_d)\n\n{\n  uint bit_a;\n  uint bit_b;\n  uint result_bit_1;\n  uint result_bit_2;\n  uint mask;\n  bool is_zero;\n  \n  result_bit_1 = mask & input_d >> 0x14;\n  if (bit_b != mask && result_bit_1 != mask) {\n    is_zero = (input_a | input_b << 1) == 0;\n    if (!is_zero) {\n      is_zero = (input_c | input_d << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((input_b ^ input_d) & 0x80000000) << 0x20;\n    }\n    if (bit_b == 0) {\n      result_bit_2 = input_b & 0x80000000;\n      do {\n        bit_a = input_a & 0x80000000;\n        input_a = input_a << 1;\n        input_b = input_b * 2 + (uint)(bit_a != 0);\n      } while ((input_b & 0x100000) == 0);\n      input_b = input_b | result_bit_2;\n      if (result_bit_1 != 0) {\n        return CONCAT44(input_b,input_a);\n      }\n    }\n    do {\n      result_bit_1 = input_c & 0x80000000;\n      input_c = input_c << 1;\n      input_d = input_d * 2 + (uint)(result_bit_1 != 0);\n    } while ((input_d & 0x100000) == 0);\n    return CONCAT44(input_b,input_a);\n  }\n  is_zero = (input_a | input_b << 1) == 0;\n  if (is_zero) {\n    input_b = input_d;\n    input_a = input_c;\n  }\n  if (!is_zero) {\n    is_zero = (input_c | input_d << 1) == 0;\n  }\n  result_bit_2 = input_b;\n  if (((!is_zero) && ((bit_b != mask || ((input_a | input_b << 0xc) == 0)))) &&\n     ((result_bit_1 != mask || (input_a = input_c, result_bit_2 = input_d, (input_c | input_d << 0xc) == 0)))) {\n    return (ulonglong)((input_b ^ input_d) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(result_bit_2,input_a) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006ac": "calculate_xor_080006ac",
                "param_1": "input_a",
                "param_2": "input_b",
                "param_3": "input_c",
                "param_4": "input_d",
                "uVar1": "bit_a",
                "unaff_r4": "bit_b",
                "uVar2": "result_bit_1",
                "uVar3": "result_bit_2",
                "in_r12": "mask",
                "bVar4": "is_zero"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000724": {
            "entrypoint": "0x08000724",
            "current_name": "calculate_floating_point_08000724",
            "code": "\nulonglong calculateFloatingPoint_08000724(undefined4 sign,uint exponentBits,uint mantissaBits1,uint mantissaBits2)\n\n{\n  uint exponent1;\n  uint exponent2;\n  uint mantissa1;\n  uint mantissa2;\n  uint difference;\n  uint carry;\n  uint resultSign;\n  int differenceExponent;\n  uint sumExponent;\n  uint unaff_r5;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  bool check1;\n  bool check2;\n  bool check3;\n  undefined8 reversedBits;\n  \n  reversedBits = CONCAT44(exponentBits,sign);\n  temp4 = 0x7ff;\n  resultSign = exponentBits >> 0x14 & 0x7ff;\n  check1 = resultSign == 0;\n  if (!check1) {\n    unaff_r5 = mantissaBits2 >> 0x14 & 0x7ff;\n    check1 = unaff_r5 == 0;\n  }\n  if (!check1) {\n    check1 = resultSign == 0x7ff;\n  }\n  if (!check1) {\n    check1 = unaff_r5 == 0x7ff;\n  }\n  if (check1) {\n    reversedBits = reverse_bits_08000892();\n  }\n  sumExponent = (uint)((ulonglong)reversedBits >> 0x20);\n  temp2 = (uint)reversedBits;\n  differenceExponent = resultSign - unaff_r5;\n  if ((mantissaBits1 | mantissaBits2 << 0xc) == 0) {\n    resultSign = (sumExponent ^ mantissaBits2) & 0x80000000 | sumExponent & 0xfffff;\n    check3 = SCARRY4(differenceExponent,temp4 >> 1);\n    sumExponent = differenceExponent + (temp4 >> 1);\n    check1 = (int)sumExponent < 0;\n    check2 = sumExponent == 0;\n    if (!check2 && check1 == check3) {\n      check3 = SBORROW4(temp4,sumExponent);\n      check1 = (int)(temp4 - sumExponent) < 0;\n      check2 = temp4 == sumExponent;\n    }\n    if (!check2 && check1 == check3) {\n      resultSign = resultSign | sumExponent * 0x100000;\n    }\n    if (!check2 && check1 == check3) {\n      return CONCAT44(resultSign,temp2);\n    }\n    resultSign = resultSign | 0x100000;\n    temp4 = 0;\n    check2 = SBORROW4(sumExponent,1);\n    sumExponent = sumExponent - 1;\n    check1 = sumExponent == 0;\n    mantissa1 = sumExponent;\n  }\n  else {\n    mantissa1 = (mantissaBits2 << 0xc) >> 4 | 0x10000000 | mantissaBits1 >> 0x18;\n    temp4 = mantissaBits1 << 8;\n    temp1 = (sumExponent << 0xc) >> 4 | 0x10000000 | temp2 >> 0x18;\n    temp2 = temp2 * 0x100;\n    resultSign = (sumExponent ^ mantissaBits2) & 0x80000000;\n    check1 = mantissa1 <= temp1;\n    if (temp1 == mantissa1) {\n      check1 = temp4 <= temp2;\n    }\n    differenceExponent = differenceExponent + (uint)check1;\n    sumExponent = differenceExponent + 0x3fd;\n    if (check1 == false) {\n      mantissa1 = mantissa1 >> 1;\n      temp4 = (uint)((mantissaBits1 >> 0x18 & 1) != 0) << 0x1f | temp4 >> 1;\n    }\n    temp3 = temp2 - temp4;\n    temp1 = (temp1 - mantissa1) - (uint)(temp2 < temp4);\n    mantissa2 = mantissa1 >> 1;\n    exponent1 = (uint)((mantissa1 & 1) != 0) << 0x1f | temp4 >> 1;\n    temp2 = 0x100000;\n    mantissa1 = 0x80000;\n    while( true ) {\n      check1 = exponent1 <= temp3;\n      if (mantissa2 < temp1 || temp1 - mantissa2 < (uint)check1) {\n        temp3 = temp3 - exponent1;\n        temp2 = temp2 | mantissa1;\n        temp1 = (temp1 - mantissa2) - (uint)!check1;\n      }\n      difference = mantissa2 >> 1;\n      exponent1 = (uint)((mantissa2 & 1) != 0) << 0x1f | exponent1 >> 1;\n      check2 = exponent1 <= temp3;\n      check1 = temp1 - difference < (uint)check2;\n      temp4 = temp1;\n      if (difference < temp1 || check1) {\n        temp3 = temp3 - exponent1;\n        temp4 = (temp1 - difference) - (uint)!check2;\n      }\n      if (difference < temp1 || check1) {\n        temp2 = temp2 | mantissa1 >> 1;\n      }\n      temp1 = mantissa2 >> 2;\n      exponent2 = (uint)((difference & 1) != 0) << 0x1f | exponent1 >> 1;\n      check2 = exponent2 <= temp3;\n      check1 = temp4 - temp1 < (uint)check2;\n      difference = temp4;\n      if (temp1 < temp4 || check1) {\n        temp3 = temp3 - exponent2;\n        difference = (temp4 - temp1) - (uint)!check2;\n      }\n      if (temp1 < temp4 || check1) {\n        temp2 = temp2 | mantissa1 >> 2;\n      }\n      carry = mantissa2 >> 3;\n      exponent1 = (uint)((temp1 & 1) != 0) << 0x1f | exponent2 >> 1;\n      check2 = exponent1 <= temp3;\n      check1 = difference - carry < (uint)check2;\n      temp1 = difference;\n      if (carry < difference || check1) {\n        temp3 = temp3 - exponent1;\n        temp1 = (difference - carry) - (uint)!check2;\n      }\n      if (carry < difference || check1) {\n        temp2 = temp2 | mantissa1 >> 3;\n      }\n      temp4 = temp1 | temp3;\n      if (temp4 == 0) break;\n      temp1 = temp1 << 4 | temp3 >> 0x1c;\n      temp3 = temp3 << 4;\n      mantissa2 = mantissa2 & 0xfffffff8 | exponent1 >> 0x1d;\n      exponent1 = (exponent2 >> 1) << 3;\n      mantissa1 = mantissa1 >> 4;\n      if (mantissa1 == 0) {\n        carry = mantissa2;\n        if ((resultSign & 0x100000) != 0) goto LAB_08000842;\n        resultSign = resultSign | temp2;\n        temp2 = 0;\n        mantissa1 = 0x80000000;\n      }\n    }\n    if ((resultSign & 0x100000) == 0) {\n      resultSign = resultSign | temp2;\n      temp2 = 0;\n    }\nLAB_08000842:\n    check3 = 0xfc < sumExponent;\n    check2 = SBORROW4(sumExponent,0xfd);\n    mantissa2 = differenceExponent + 0x300;\n    check1 = mantissa2 == 0;\n    mantissa1 = mantissa2;\n    if (check3 && !check1) {\n      check3 = 0x6ff < mantissa2;\n      check2 = SBORROW4(mantissa2,0x700);\n      mantissa1 = differenceExponent - 0x400;\n      check1 = mantissa2 == 0x700;\n    }\n    if (!check3 || check1) {\n      check1 = carry <= temp1;\n      if (temp1 == carry) {\n        check1 = exponent1 <= temp3;\n      }\n      if (temp1 == carry && temp3 == exponent1) {\n        check1 = (temp2 & 1) != 0;\n      }\n      return CONCAT44(resultSign + sumExponent * 0x100000 + (uint)CARRY4(temp2,(uint)check1),temp2 + check1);\n    }\n  }\n  if (!check1 && (int)mantissa1 < 0 == check2) {\n    return (ulonglong)(resultSign & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  check3 = SCARRY4(sumExponent,0x36);\n  check1 = (int)(sumExponent + 0x36) < 0;\n  check2 = sumExponent == 0xffffffca;\n  if (check2 || check1 != check3) {\n    temp2 = 0;\n  }\n  if (check2 || check1 != check3) {\n    resultSign = resultSign & 0x80000000;\n  }\n  if (check2 || check1 != check3) {\n    return CONCAT44(resultSign,temp2);\n  }\n  mantissa1 = -sumExponent;\n  temp1 = mantissa1 - 0x20;\n  if (0x1f < (int)mantissa1) {\n    mantissa1 = temp2 >> (temp1 & 0xff) | resultSign << (0x20 - temp1 & 0xff);\n    sumExponent = (resultSign >> (temp1 & 0xff) & ~((resultSign & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)mantissa1 >> 0x1f);\n    if ((temp4 | temp2 << (0x20 - temp1 & 0xff) | mantissa1 << 1) == 0) {\n      sumExponent = sumExponent & ~(mantissa1 >> 0x1f);\n    }\n    return CONCAT44(resultSign,sumExponent) & 0x80000000ffffffff;\n  }\n  differenceExponent = mantissa1 - 0x14;\n  if (differenceExponent != 0 && differenceExponent < 0 == SCARRY4(temp1,0xc)) {\n    sumExponent = 0xc - differenceExponent;\n    mantissa1 = temp2 << (sumExponent & 0xff);\n    temp2 = temp2 >> (0x20 - sumExponent & 0xff) | resultSign << (sumExponent & 0xff);\n    sumExponent = temp2 + -((int)mantissa1 >> 0x1f);\n    if ((temp4 | mantissa1 << 1) == 0) {\n      sumExponent = sumExponent & ~(mantissa1 >> 0x1f);\n    }\n    return CONCAT44((resultSign & 0x80000000) + (uint)CARRY4(temp2,-((int)mantissa1 >> 0x1f)),sumExponent);\n  }\n  temp1 = temp2 << (sumExponent + 0x20 & 0xff);\n  temp2 = temp2 >> (mantissa1 & 0xff) | resultSign << (sumExponent + 0x20 & 0xff);\n  sumExponent = temp2 + -((int)temp1 >> 0x1f);\n  if ((temp4 | temp1 << 1) == 0) {\n    sumExponent = sumExponent & ~(temp1 >> 0x1f);\n  }\n  return CONCAT44((resultSign & 0x80000000) +\n                  ((resultSign & 0x7fffffff) >> (mantissa1 & 0xff)) +\n                  (uint)CARRY4(temp2,-((int)temp1 >> 0x1f)),sumExponent);\n}\n\n",
            "renaming": {
                "FUN_08000724": "calculate_floating_point_08000724",
                "param_1": "sign",
                "param_2": "exponentBits",
                "param_3": "mantissaBits1",
                "param_4": "mantissaBits2",
                "uVar1": "exponent1",
                "uVar2": "exponent2",
                "uVar3": "mantissa1",
                "uVar4": "mantissa2",
                "uVar5": "difference",
                "uVar6": "carry",
                "uVar7": "resultSign",
                "iVar8": "differenceExponent",
                "uVar9": "sumExponent",
                "uVar10": "temp1",
                "uVar11": "temp2",
                "uVar12": "temp3",
                "uVar13": "temp4",
                "bVar14": "check1",
                "bVar15": "check2",
                "bVar16": "check3",
                "uVar17": "reversedBits"
            },
            "calling": [
                "pow",
                "__ieee754_atan2",
                "atan",
                "__ieee754_sqrt",
                "MadgwickQuaternionUpdate",
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "FUN_08000892"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000892": {
            "entrypoint": "0x08000892",
            "current_name": "reverse_bits_08000892",
            "code": "\nulonglong reverseBits_08000892(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bitMask1;\n  uint temp1;\n  uint bitMask2;\n  uint temp2;\n  uint constant;\n  bool isZero;\n  \n  bitMask2 = constant & input4 >> 0x14;\n  temp2 = input2;\n  if (temp1 != constant || bitMask2 != constant) {\n    if (temp1 == constant) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, temp2 = input4, bitMask2 != constant)\n         ) {\nreturnCase1:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bitMask2 == constant) {\n      input1 = input3;\n      temp2 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nreturnCase2:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input1 | input2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input3 | input4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (temp1 == 0) {\n          temp2 = input2 & 0x80000000;\n          do {\n            bitMask1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bitMask1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | temp2;\n          if (bitMask2 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          temp2 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(temp2 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto returnCase1;\n      if ((input3 | input4 << 1) != 0) goto returnCase2;\n    }\n  }\n  return CONCAT44(temp2,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_08000892": "reverse_bits_08000892",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bitMask1",
                "unaff_r4": "temp1",
                "uVar2": "bitMask2",
                "uVar3": "temp2",
                "in_r12": "constant",
                "bVar4": "isZero",
                "LAB_08000704": "returnCase1",
                "LAB_080006c8": "returnCase2"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_parameters_080008f4",
            "code": "\nuint check_parameters_080008f4(uint first_parameter,uint second_parameter,uint third_parameter,uint fourth_parameter)\n\n{\n  uint xor_result;\n  bool are_parameters_zero;\n  bool is_condition_met;\n  \n  if (((int)(second_parameter << 1) >> 0x15 == -1 || (int)(fourth_parameter << 1) >> 0x15 == -1) &&\n     ((((int)(second_parameter << 1) >> 0x15 == -1 && ((first_parameter | second_parameter << 0xc) != 0)) ||\n      (((int)(fourth_parameter << 1) >> 0x15 == -1 && ((third_parameter | fourth_parameter << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  are_parameters_zero = (first_parameter | second_parameter << 1) == 0;\n  if (are_parameters_zero) {\n    are_parameters_zero = (third_parameter | fourth_parameter << 1) == 0;\n  }\n  if (!are_parameters_zero) {\n    are_parameters_zero = second_parameter == fourth_parameter;\n  }\n  if (are_parameters_zero) {\n    are_parameters_zero = first_parameter == third_parameter;\n  }\n  if (!are_parameters_zero) {\n    xor_result = second_parameter ^ fourth_parameter;\n    are_parameters_zero = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      are_parameters_zero = second_parameter == fourth_parameter;\n    }\n    is_condition_met = -1 < (int)xor_result && fourth_parameter <= second_parameter;\n    if (are_parameters_zero) {\n      is_condition_met = third_parameter <= first_parameter;\n    }\n    fourth_parameter = (int)fourth_parameter >> 0x1f;\n    if (!is_condition_met) {\n      fourth_parameter = ~fourth_parameter;\n    }\n    return fourth_parameter | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_parameters_080008f4",
                "param_1": "first_parameter",
                "param_2": "second_parameter",
                "param_3": "third_parameter",
                "param_4": "fourth_parameter",
                "uVar1": "xor_result",
                "bVar2": "are_parameters_zero",
                "bVar3": "is_condition_met"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_parameters_080008fc",
            "code": "\nuint check_parameters_080008fc(uint first_param,uint second_param,uint third_param,uint fourth_param)\n\n{\n  uint temp_var1;\n  bool flag1;\n  bool flag2;\n  \n  if (((int)(second_param << 1) >> 0x15 == -1 || (int)(fourth_param << 1) >> 0x15 == -1) &&\n     ((((int)(second_param << 1) >> 0x15 == -1 && ((first_param | second_param << 0xc) != 0)) ||\n      (((int)(fourth_param << 1) >> 0x15 == -1 && ((third_param | fourth_param << 0xc) != 0)))))) {\n    return 1;\n  }\n  flag1 = (first_param | second_param << 1) == 0;\n  if (flag1) {\n    flag1 = (third_param | fourth_param << 1) == 0;\n  }\n  if (!flag1) {\n    flag1 = second_param == fourth_param;\n  }\n  if (flag1) {\n    flag1 = first_param == third_param;\n  }\n  if (!flag1) {\n    temp_var1 = second_param ^ fourth_param;\n    flag1 = temp_var1 == 0;\n    if (-1 < (int)temp_var1) {\n      flag1 = second_param == fourth_param;\n    }\n    flag2 = -1 < (int)temp_var1 && fourth_param <= second_param;\n    if (flag1) {\n      flag2 = third_param <= first_param;\n    }\n    fourth_param = (int)fourth_param >> 0x1f;\n    if (!flag2) {\n      fourth_param = ~fourth_param;\n    }\n    return fourth_param | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_parameters_080008fc",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param",
                "uVar1": "temp_var1",
                "bVar2": "flag1",
                "bVar3": "flag2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000904": {
            "entrypoint": "0x08000904",
            "current_name": "check_conditions_08000904",
            "code": "\nuint check_conditions_08000904(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(input2 << 1) >> 0x15 == -1 || (int)(input4 << 1) >> 0x15 == -1) &&\n     ((((int)(input2 << 1) >> 0x15 == -1 && ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(input4 << 1) >> 0x15 == -1 && ((input3 | input4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input2 == input4;\n  }\n  if (isZero) {\n    isZero = input1 == input3;\n  }\n  if (!isZero) {\n    result = input2 ^ input4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = input2 == input4;\n    }\n    isNegative = -1 < (int)result && input4 <= input2;\n    if (isZero) {\n      isNegative = input3 <= input1;\n    }\n    input4 = (int)input4 >> 0x1f;\n    if (!isNegative) {\n      input4 = ~input4;\n    }\n    return input4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08000904": "check_conditions_08000904",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000980": {
            "entrypoint": "0x08000980",
            "current_name": "compare_floats_08000980",
            "code": "\nvoid compareFloats_08000980(undefined4 resultFlag,undefined4 paramFlag,undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cdcmpeq(float1,float2,resultFlag,paramFlag);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000980": "compare_floats_08000980",
                "param_1": "resultFlag",
                "param_2": "paramFlag",
                "param_3": "float1",
                "param_4": "float2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000990": {
            "entrypoint": "0x08000990",
            "current_name": "perform_operation_08000990",
            "code": "\nundefined4 performOperation_08000990(undefined4 inputValue)\n\n{\n  __nedf2();\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_08000990": "perform_operation_08000990",
                "param_1": "inputValue"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmplt",
                "__aeabi_dcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a0": {
            "entrypoint": "0x080009a0",
            "current_name": "check_cdcmp_result_080009a0",
            "code": "\nbool check_cdcmp_result_080009a0(void)\n\n{\n  char result;\n  \n  __aeabi_cdcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009a0": "check_cdcmp_result_080009a0",
                "in_ZR": "result"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b4": {
            "entrypoint": "0x080009b4",
            "current_name": "check_if_null_080009b4",
            "code": "\nbool check_if_null_080009b4(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009b4": "check_if_null_080009b4",
                "in_CY": "input_character"
            },
            "calling": [
                "pow",
                "sqrt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "check_zero_comparison_080009c8",
            "code": "\nbool check_zero_comparison_080009c8(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009c8": "check_zero_comparison_080009c8",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "check_carry_zero_080009dc",
            "code": "\nbool check_carry_zero_080009dc(void)\n\n{\n  undefined zero_result;\n  undefined carry_flag;\n  \n  __aeabi_cdrcmple();\n  return !(bool)carry_flag || (bool)zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009dc": "check_carry_zero_080009dc",
                "in_ZR": "zero_result",
                "in_CY": "carry_flag"
            },
            "calling": [],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "check_if_char_is_null_080009f0",
            "code": "\nbool check_if_char_is_null_080009f0(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009f0": "check_if_char_is_null_080009f0",
                "in_CY": "input_char"
            },
            "calling": [
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_params_08000a04",
            "code": "\nundefined4 check_params_08000a04(uint param1,int param2,uint param3,int param4)\n\n{\n  if ((((param2 << 1) >> 0x15 != -1) || ((param1 | param2 << 0xc) == 0)) &&\n     (((param4 << 1) >> 0x15 != -1 || ((param3 | param4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_params_08000a04",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a30": {
            "entrypoint": "0x08000a30",
            "current_name": "convert_to_float_08000a30",
            "code": "\nuint convertToFloat_08000a30(uint inputInteger,uint inputInteger2)\n\n{\n  uint result;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  bool isZero;\n  bool lessThanThreshold;\n  \n  temp1 = inputInteger2 * 2;\n  lessThanThreshold = temp1 < 0x70000000;\n  temp2 = temp1 + 0x90000000;\n  result = temp2;\n  if (!lessThanThreshold) {\n    temp3 = temp1 + 0x8fe00000;\n    result = temp3;\n  }\n  isZero = result == 0;\n  if (!lessThanThreshold && temp2 >= 0x200000) {\n    isZero = temp3 == 0x1fc00000;\n  }\n  if (((lessThanThreshold || temp2 < 0x200000) || 0x1fc00000 < temp3) || isZero) {\n    if ((inputInteger2 & 0x40000000) != 0) {\n      if (((int)temp1 >> 0x15 == -1) && ((inputInteger | inputInteger2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return inputInteger2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(temp1 + 0x92e00000) < 0 != SCARRY4(temp2,0x2e00000)) {\n      return inputInteger2 & 0x80000000;\n    }\n    temp1 = 0x18 - (temp1 + 0x92e00000 >> 0x15);\n    result = inputInteger >> (temp1 & 0xff);\n    if (inputInteger << (0x20 - temp1 & 0xff) != 0) {\n      result = result | 1;\n    }\n    temp2 = inputInteger2 & 0x1fffff | 0x100000;\n    inputInteger = result | temp2 << (0x20 - temp1 & 0xff);\n    temp2 = (temp2 >> (temp1 & 0xff)) << 1;\n  }\n  result = (inputInteger2 & 0x80000000 | inputInteger >> 0x1d) + temp2 * 4 + (uint)(0x7fffffff < inputInteger * 8);\n  if (inputInteger * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000a30": "convert_to_float_08000a30",
                "param_1": "inputInteger",
                "param_2": "inputInteger2",
                "uVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "in_r12": "temp3",
                "bVar4": "isZero",
                "bVar5": "lessThanThreshold"
            },
            "calling": [
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad0": {
            "entrypoint": "0x08000ad0",
            "current_name": "convert_to_negative_08000ad0",
            "code": "\nvoid convertToNegative_08000ad0(uint value)\n\n{\n  __addsf3(value ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ad0": "convert_to_negative_08000ad0",
                "param_1": "value"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ad8": {
            "entrypoint": "0x08000ad8",
            "current_name": "calculate_updated_value_08000ad8",
            "code": "\nuint calculate_updated_value_08000ad8(uint input_value_1,uint input_value_2,undefined4 input_value_3,uint input_value_4)\n\n{\n  int shifted_value;\n  int shifted_value_2;\n  uint updated_value_1;\n  uint updated_value_2;\n  uint shifted_input_value;\n  uint shifted_input_value_2;\n  uint difference;\n  bool is_equal;\n  \n  updated_value_1 = input_value_2 ^ 0x80000000;\n  shifted_input_value = input_value_1 << 1;\n  is_equal = shifted_input_value == 0;\n  if (!is_equal) {\n    input_value_4 = input_value_2 << 1;\n    is_equal = input_value_4 == 0;\n  }\n  if (!is_equal) {\n    is_equal = shifted_input_value == input_value_4;\n  }\n  shifted_value = (int)shifted_input_value >> 0x18;\n  if (!is_equal) {\n    is_equal = shifted_value == -1;\n  }\n  if (!is_equal) {\n    is_equal = (int)input_value_4 >> 0x18 == -1;\n  }\n  if (is_equal) {\n    shifted_value_2 = (int)(input_value_2 << 1) >> 0x18;\n    if (shifted_value == -1 || shifted_value_2 == -1) {\n      shifted_input_value = updated_value_1;\n      if (shifted_value == -1) {\n        shifted_input_value = input_value_1;\n      }\n      if (shifted_value != -1 || shifted_value_2 != -1) {\n        updated_value_1 = shifted_input_value;\n      }\n      is_equal = (shifted_input_value & 0x7fffff) == 0;\n      if (is_equal) {\n        is_equal = (updated_value_1 & 0x7fffff) == 0;\n      }\n      if (is_equal) {\n        is_equal = shifted_input_value == updated_value_1;\n      }\n      if (!is_equal) {\n        shifted_input_value = shifted_input_value | 0x400000;\n      }\n      return shifted_input_value;\n    }\n    if (((input_value_1 ^ updated_value_1) & 0x7fffffff) != 0) {\n      if (shifted_input_value == 0) {\n        input_value_1 = updated_value_1;\n      }\n      return input_value_1;\n    }\n    if (input_value_1 != updated_value_1) {\n      return 0;\n    }\n    if ((shifted_input_value & 0xff000000) == 0) {\n      updated_value_1 = input_value_1 << 1;\n      if ((input_value_1 & 0x80000000) != 0) {\n        updated_value_1 = updated_value_1 | 0x80000000;\n      }\n      return updated_value_1;\n    }\n    if (shifted_input_value < 0xfe000000) {\n      return input_value_1 + 0x800000;\n    }\n    input_value_1 = input_value_1 & 0x80000000;\nLAB_08000c12:\n    return input_value_1 | 0x7f800000;\n  }\n  shifted_input_value = shifted_input_value >> 0x18;\n  input_value_4 = input_value_4 >> 0x18;\n  difference = input_value_4 - shifted_input_value;\n  is_equal = difference != 0;\n  shifted_input_value_2 = shifted_input_value;\n  if (is_equal && shifted_input_value <= input_value_4) {\n    shifted_input_value_2 = shifted_input_value + difference;\n  }\n  if (is_equal && shifted_input_value <= input_value_4) {\n    updated_value_1 = updated_value_1 ^ input_value_1;\n  }\n  if (is_equal && shifted_input_value <= input_value_4) {\n    input_value_1 = input_value_1 ^ updated_value_1;\n  }\n  if (is_equal && shifted_input_value <= input_value_4) {\n    updated_value_1 = updated_value_1 ^ input_value_1;\n  }\n  if (input_value_4 < shifted_input_value) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input_value_1;\n  }\n  shifted_input_value = input_value_1 & 0xffffff | 0x800000;\n  if ((input_value_1 & 0x80000000) != 0) {\n    shifted_input_value = -shifted_input_value;\n  }\n  updated_value_2 = updated_value_1 & 0xffffff | 0x800000;\n  if ((updated_value_1 & 0x80000000) != 0) {\n    updated_value_2 = -updated_value_2;\n  }\n  if (shifted_input_value_2 == difference) {\n    updated_value_2 = updated_value_2 ^ 0x800000;\n    if (shifted_input_value_2 == 0) {\n      shifted_input_value = shifted_input_value ^ 0x800000;\n      shifted_input_value_2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shifted_input_value = shifted_input_value + ((int)updated_value_2 >> (difference & 0xff));\n  updated_value_2 = updated_value_2 << (0x20 - difference & 0xff);\n  input_value_1 = shifted_input_value & 0x80000000;\n  if ((int)shifted_input_value < 0) {\n    is_equal = updated_value_2 != 0;\n    updated_value_2 = -updated_value_2;\n    shifted_input_value = -shifted_input_value - (uint)is_equal;\n  }\n  if (shifted_input_value < 0x800000) {\n    updated_value_1 = updated_value_2 & 0x80000000;\n    updated_value_2 = updated_value_2 << 1;\n    shifted_input_value = shifted_input_value * 2 + (uint)(updated_value_1 != 0);\n    updated_value_1 = shifted_input_value_2 - 2;\n    if ((shifted_input_value & 0x800000) == 0) {\n      difference = LZCOUNT(shifted_input_value) - 8;\n      shifted_input_value = shifted_input_value << (difference & 0xff);\n      if ((int)updated_value_1 < (int)difference) {\n        shifted_input_value = shifted_input_value >> (-(updated_value_1 - difference) & 0xff);\n      }\n      else {\n        shifted_input_value = shifted_input_value + (updated_value_1 - difference) * 0x800000;\n      }\n      return shifted_input_value | input_value_1;\n    }\n  }\n  else {\n    updated_value_1 = shifted_input_value_2 - 1;\n    if (0xffffff < shifted_input_value) {\n      updated_value_1 = shifted_input_value & 1;\n      shifted_input_value = shifted_input_value >> 1;\n      updated_value_2 = (uint)(updated_value_1 != 0) << 0x1f | updated_value_2 >> 1;\n      updated_value_1 = shifted_input_value_2;\n      if (0xfd < shifted_input_value_2) goto LAB_08000c12;\n    }\n  }\n  shifted_input_value = shifted_input_value + updated_value_1 * 0x800000 + (uint)(0x7fffffff < updated_value_2);\n  if (updated_value_2 == 0x80000000) {\n    shifted_input_value = shifted_input_value & 0xfffffffe;\n  }\n  return shifted_input_value | input_value_1;\n}\n\n",
            "renaming": {
                "FUN_08000ad8": "calculate_updated_value_08000ad8",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "param_3": "input_value_3",
                "param_4": "input_value_4",
                "iVar1": "shifted_value",
                "iVar2": "shifted_value_2",
                "uVar3": "updated_value_1",
                "uVar4": "updated_value_2",
                "uVar5": "shifted_input_value",
                "uVar6": "shifted_input_value_2",
                "uVar7": "difference",
                "bVar8": "is_equal"
            },
            "calling": [
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "AHRS_GetYaw"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000adc": {
            "entrypoint": "0x08000adc",
            "current_name": "calculate_floating_point_value_08000adc",
            "code": "\nuint calculateFloatingPointValue_08000adc(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  int shiftAmount;\n  int conversionResult;\n  uint fractionalPart1;\n  uint fractionalPart2;\n  uint exponent1;\n  uint exponent2;\n  bool comparisonResult;\n  \n  fractionalPart2 = input1 << 1;\n  comparisonResult = fractionalPart2 == 0;\n  if (!comparisonResult) {\n    input4 = input2 << 1;\n    comparisonResult = input4 == 0;\n  }\n  if (!comparisonResult) {\n    comparisonResult = fractionalPart2 == input4;\n  }\n  shiftAmount = (int)fractionalPart2 >> 0x18;\n  if (!comparisonResult) {\n    comparisonResult = shiftAmount == -1;\n  }\n  if (!comparisonResult) {\n    comparisonResult = (int)input4 >> 0x18 == -1;\n  }\n  if (comparisonResult) {\n    conversionResult = (int)(input2 << 1) >> 0x18;\n    if (shiftAmount == -1 || conversionResult == -1) {\n      fractionalPart2 = input2;\n      if (shiftAmount == -1) {\n        fractionalPart2 = input1;\n      }\n      if (shiftAmount != -1 || conversionResult != -1) {\n        input2 = fractionalPart2;\n      }\n      comparisonResult = (fractionalPart2 & 0x7fffff) == 0;\n      if (comparisonResult) {\n        comparisonResult = (input2 & 0x7fffff) == 0;\n      }\n      if (comparisonResult) {\n        comparisonResult = fractionalPart2 == input2;\n      }\n      if (!comparisonResult) {\n        fractionalPart2 = fractionalPart2 | 0x400000;\n      }\n      return fractionalPart2;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (fractionalPart2 == 0) {\n        input1 = input2;\n      }\n      return input1;\n    }\n    if (input1 != input2) {\n      return 0;\n    }\n    if ((fractionalPart2 & 0xff000000) == 0) {\n      fractionalPart2 = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        fractionalPart2 = fractionalPart2 | 0x80000000;\n      }\n      return fractionalPart2;\n    }\n    if (fractionalPart2 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08000c12:\n    return input1 | 0x7f800000;\n  }\n  fractionalPart2 = fractionalPart2 >> 0x18;\n  input4 = input4 >> 0x18;\n  exponent2 = input4 - fractionalPart2;\n  comparisonResult = exponent2 != 0;\n  exponent1 = fractionalPart2;\n  if (comparisonResult && fractionalPart2 <= input4) {\n    exponent1 = fractionalPart2 + exponent2;\n  }\n  if (comparisonResult && fractionalPart2 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (comparisonResult && fractionalPart2 <= input4) {\n    input1 = input1 ^ input2;\n  }\n  if (comparisonResult && fractionalPart2 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (input4 < fractionalPart2) {\n    exponent2 = -exponent2;\n  }\n  if (0x19 < exponent2) {\n    return input1;\n  }\n  fractionalPart2 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    fractionalPart2 = -fractionalPart2;\n  }\n  fractionalPart1 = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    fractionalPart1 = -fractionalPart1;\n  }\n  if (exponent1 == exponent2) {\n    fractionalPart1 = fractionalPart1 ^ 0x800000;\n    if (exponent1 == 0) {\n      fractionalPart2 = fractionalPart2 ^ 0x800000;\n      exponent1 = 1;\n    }\n    else {\n      exponent2 = exponent2 - 1;\n    }\n  }\n  fractionalPart2 = fractionalPart2 + ((int)fractionalPart1 >> (exponent2 & 0xff));\n  fractionalPart1 = fractionalPart1 << (0x20 - exponent2 & 0xff);\n  input1 = fractionalPart2 & 0x80000000;\n  if ((int)fractionalPart2 < 0) {\n    comparisonResult = fractionalPart1 != 0;\n    fractionalPart1 = -fractionalPart1;\n    fractionalPart2 = -fractionalPart2 - (uint)comparisonResult;\n  }\n  if (fractionalPart2 < 0x800000) {\n    exponent2 = fractionalPart1 & 0x80000000;\n    fractionalPart1 = fractionalPart1 << 1;\n    fractionalPart2 = fractionalPart2 * 2 + (uint)(exponent2 != 0);\n    exponent2 = exponent1 - 2;\n    if ((fractionalPart2 & 0x800000) == 0) {\n      exponent1 = LZCOUNT(fractionalPart2) - 8;\n      fractionalPart2 = fractionalPart2 << (exponent1 & 0xff);\n      if ((int)exponent2 < (int)exponent1) {\n        fractionalPart2 = fractionalPart2 >> (-(exponent2 - exponent1) & 0xff);\n      }\n      else {\n        fractionalPart2 = fractionalPart2 + (exponent2 - exponent1) * 0x800000;\n      }\n      return fractionalPart2 | input1;\n    }\n  }\n  else {\n    exponent2 = exponent1 - 1;\n    if (0xffffff < fractionalPart2) {\n      exponent2 = fractionalPart2 & 1;\n      fractionalPart2 = fractionalPart2 >> 1;\n      fractionalPart1 = (uint)(exponent2 != 0) << 0x1f | fractionalPart1 >> 1;\n      exponent2 = exponent1;\n      if (0xfd < exponent1) goto LAB_08000c12;\n    }\n  }\n  fractionalPart2 = fractionalPart2 + exponent2 * 0x800000 + (uint)(0x7fffffff < fractionalPart1);\n  if (fractionalPart1 == 0x80000000) {\n    fractionalPart2 = fractionalPart2 & 0xfffffffe;\n  }\n  return fractionalPart2 | input1;\n}\n\n",
            "renaming": {
                "FUN_08000adc": "calculate_floating_point_value_08000adc",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftAmount",
                "iVar2": "conversionResult",
                "uVar3": "fractionalPart1",
                "uVar4": "fractionalPart2",
                "uVar5": "exponent1",
                "uVar6": "exponent2",
                "bVar7": "comparisonResult"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "Motor_DistributeSpeed",
                "AK8963_Init",
                "MadgwickQuaternionUpdate",
                "__aeabi_frsub",
                "AHRS_GetYaw",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_hash_08000c3c",
            "code": "\nuint calculateHash_08000c3c(uint input)\n\n{\n  uint numberOfLeadingZeros;\n  uint shiftAmount;\n  int constant1;\n  uint mask;\n  \n  if (input == 0) {\n    return 0;\n  }\n  numberOfLeadingZeros = LZCOUNT(input);\n  shiftAmount = numberOfLeadingZeros - 8;\n  constant1 = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < numberOfLeadingZeros) {\n    mask = 0 << (shiftAmount & 0xff);\n    numberOfLeadingZeros = constant1 + (input << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      numberOfLeadingZeros = numberOfLeadingZeros & 0xfffffffe;\n    }\n    return numberOfLeadingZeros;\n  }\n  shiftAmount = input << numberOfLeadingZeros + 0x18;\n  numberOfLeadingZeros = constant1 + ((input >> (0x20 - (numberOfLeadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    numberOfLeadingZeros = numberOfLeadingZeros & ~(shiftAmount >> 0x1f);\n  }\n  return numberOfLeadingZeros;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_hash_08000c3c",
                "param_1": "input",
                "uVar1": "numberOfLeadingZeros",
                "uVar2": "shiftAmount",
                "iVar3": "constant1",
                "uVar4": "mask"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c44": {
            "entrypoint": "0x08000c44",
            "current_name": "calculate_result_08000c44",
            "code": "\nuint calculate_result_08000c44(uint input_value)\n\n{\n  uint leading_zeros;\n  uint shift_amount;\n  uint sign_bit;\n  int result;\n  \n  sign_bit = input_value & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input_value = -input_value;\n  }\n  if (input_value == 0) {\n    return 0;\n  }\n  leading_zeros = leading_zero_count(input_value);\n  shift_amount = leading_zeros - 8;\n  result = ((sign_bit | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zeros) {\n    leading_zeros = 0 << (shift_amount & 0xff);\n    sign_bit = result + (input_value << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < leading_zeros);\n    if (leading_zeros == 0x80000000) {\n      sign_bit = sign_bit & 0xfffffffe;\n    }\n    return sign_bit;\n  }\n  shift_amount = input_value << leading_zeros + 0x18;\n  sign_bit = result + ((input_value >> (0x20 - (leading_zeros + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    sign_bit = sign_bit & ~(shift_amount >> 0x1f);\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c44": "calculate_result_08000c44",
                "param_1": "input_value",
                "uVar1": "leading_zeros",
                "uVar2": "shift_amount",
                "uVar3": "sign_bit",
                "iVar4": "result",
                "LZCOUNT": "leading_zero_count"
            },
            "calling": [
                "PID_Compute",
                "AK8963_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c60": {
            "entrypoint": "0x08000c60",
            "current_name": "compute_checksum_08000c60",
            "code": "\nuint computeChecksum_08000c60(uint input1,uint input2)\n\n{\n  uint temp1;\n  uint temp2;\n  uint shiftCount;\n  uint mask;\n  int constant;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  temp1 = input1;\n  temp2 = input2;\n  if (input2 == 0) {\n    temp1 = 0;\n    temp2 = input1;\n  }\n  constant = 0x5b000000;\n  if (input2 == 0) {\n    constant = 0x4b000000;\n  }\n  shiftCount = leadingZeroCount(temp2);\n  mask = shiftCount - 8;\n  constant = constant + -0x800000 + mask * -0x800000;\n  if (shiftCount < 8) {\n    mask = temp2 << shiftCount + 0x18;\n    temp2 = constant + ((temp2 >> (0x20 - (shiftCount + 0x18) & 0xff)) - ((int)mask >> 0x1f));\n    if ((temp1 | mask << 1) == 0) {\n      temp2 = temp2 & ~(mask >> 0x1f);\n    }\n    return temp2;\n  }\n  shiftCount = temp1 << (mask & 0xff);\n  temp2 = constant + (temp2 << (mask & 0xff)) +\n          (temp1 >> (0x20 - mask & 0xff)) + (uint)(0x7fffffff < shiftCount);\n  if (shiftCount == 0x80000000) {\n    temp2 = temp2 & 0xfffffffe;\n  }\n  return temp2;\n}\n\n",
            "renaming": {
                "FUN_08000c60": "compute_checksum_08000c60",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "shiftCount",
                "uVar4": "mask",
                "iVar5": "constant",
                "LZCOUNT": "leadingZeroCount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c70": {
            "entrypoint": "0x08000c70",
            "current_name": "calculate_08000c70",
            "code": "\nuint calculate_08000c70(uint input1,uint input2)\n\n{\n  uint result1;\n  uint result2;\n  uint count;\n  uint offset;\n  uint flag;\n  int adjustedOffset;\n  bool isInput1NonZero;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  flag = input2 & 0x80000000;\n  if ((int)flag < 0) {\n    isInput1NonZero = input1 != 0;\n    input1 = -input1;\n    input2 = -input2 - (uint)isInput1NonZero;\n  }\n  result2 = input1;\n  result1 = input2;\n  if (input2 == 0) {\n    result2 = 0;\n    result1 = input1;\n  }\n  flag = flag | 0x5b000000;\n  if (input2 == 0) {\n    flag = flag + 0xf0000000;\n  }\n  count = LZCOUNT(result1);\n  offset = count - 8;\n  adjustedOffset = (flag - 0x800000) + offset * -0x800000;\n  if (count < 8) {\n    offset = result1 << count + 0x18;\n    flag = adjustedOffset + ((result1 >> (0x20 - (count + 0x18) & 0xff)) - ((int)offset >> 0x1f));\n    if ((result2 | offset << 1) == 0) {\n      flag = flag & ~(offset >> 0x1f);\n    }\n    return flag;\n  }\n  count = result2 << (offset & 0xff);\n  flag = adjustedOffset + (result1 << (offset & 0xff)) +\n          (result2 >> (0x20 - offset & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    flag = flag & 0xfffffffe;\n  }\n  return flag;\n}\n\n",
            "renaming": {
                "FUN_08000c70": "calculate_08000c70",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "count",
                "uVar4": "offset",
                "uVar5": "flag",
                "iVar6": "adjustedOffset",
                "bVar7": "isInput1NonZero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cec": {
            "entrypoint": "0x08000cec",
            "current_name": "calculate_floating_point_08000cec",
            "code": "\nuint calculateFloatingPoint_08000cec(uint input1,uint input2,undefined4 parameter3,uint parameter4)\n\n{\n  longlong product;\n  uint result;\n  uint input1SignificantBits;\n  int sumOfSignificantBits;\n  int normalizedSum;\n  uint productLSB;\n  int normalizedSumExponent;\n  uint normalizedSumMantissa;\n  bool isZero;\n  bool carryFlag;\n  \n  input1SignificantBits = input1 >> 0x17 & 0xff;\n  isZero = input1SignificantBits == 0;\n  if (!isZero) {\n    parameter4 = input2 >> 0x17 & 0xff;\n    isZero = parameter4 == 0;\n  }\n  if (!isZero) {\n    isZero = input1SignificantBits == 0xff;\n  }\n  if (!isZero) {\n    isZero = parameter4 == 0xff;\n  }\n  if (isZero) {\n    parameter4 = input2 >> 0x17 & 0xff;\n    if (input1SignificantBits == 0xff || parameter4 == 0xff) {\n      isZero = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        isZero = input2 == 0;\n        result = input1;\n      }\n      if (!isZero) {\n        isZero = input2 == 0x80000000;\n      }\n      normalizedSumMantissa = result;\n      if (((isZero) || ((input1SignificantBits == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((parameter4 == 0xff && (normalizedSumMantissa = input2, (input2 & 0x7fffff) != 0)))) {\n        return normalizedSumMantissa | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_08000e3c;\n    }\n    isZero = (input1 & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (input2 & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    isZero = input1SignificantBits == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input1 = input1 << 1;\n        isZero = (input1 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      input1SignificantBits = input1SignificantBits - 1;\n    }\n    input1 = input1 | result;\n    isZero = parameter4 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input2 = input2 << 1;\n        isZero = (input2 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      parameter4 = parameter4 - 1;\n    }\n    input2 = input2 | result;\n  }\n  sumOfSignificantBits = input1SignificantBits + parameter4;\n  normalizedSumMantissa = input1 ^ input2;\n  input1SignificantBits = input1 << 9;\n  isZero = input1SignificantBits == 0;\n  if (!isZero) {\n    input2 = input2 << 9;\n    isZero = input2 == 0;\n  }\n  if (isZero) {\n    if (input1SignificantBits == 0) {\n      input2 = input2 << 9;\n    }\n    result = normalizedSumMantissa & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    carryFlag = SBORROW4(sumOfSignificantBits,0x7f);\n    normalizedSum = sumOfSignificantBits + -0x7f;\n    isZero = normalizedSum == 0;\n    normalizedSumExponent = normalizedSum;\n    if (!isZero && 0x7e < sumOfSignificantBits) {\n      carryFlag = SBORROW4(0xff,normalizedSum);\n      normalizedSumExponent = 0xff - normalizedSum;\n      isZero = normalizedSum == 0xff;\n    }\n    if (!isZero && normalizedSumExponent < 0 == carryFlag) {\n      result = result | normalizedSum * 0x800000;\n    }\n    if (!isZero && normalizedSumExponent < 0 == carryFlag) {\n      return result;\n    }\n    result = result | 0x800000;\n    productLSB = 0;\n    carryFlag = SBORROW4(normalizedSum,1);\n    normalizedSumMantissa = sumOfSignificantBits - 0x80;\n    isZero = normalizedSumMantissa == 0;\n    input1SignificantBits = normalizedSumMantissa;\n  }\n  else {\n    product = (ulonglong)(input1SignificantBits >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    productLSB = (uint)product;\n    result = (uint)((ulonglong)product >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | productLSB >> 0x1f;\n      productLSB = productLSB << 1;\n    }\n    result = normalizedSumMantissa & 0x80000000 | result;\n    normalizedSumMantissa = (sumOfSignificantBits + -0x7f) - (uint)isZero;\n    carryFlag = SBORROW4(normalizedSumMantissa,0xfd);\n    isZero = normalizedSumMantissa == 0xfd;\n    input1SignificantBits = normalizedSumMantissa - 0xfd;\n    if (normalizedSumMantissa < 0xfe) {\n      result = result + normalizedSumMantissa * 0x800000 + (uint)(0x7fffffff < productLSB);\n      if (productLSB == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)input1SignificantBits < 0 != carryFlag) {\n    isZero = (int)(normalizedSumMantissa + 0x19) < 0;\n    if (normalizedSumMantissa == 0xffffffe7 || isZero != SCARRY4(normalizedSumMantissa,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (normalizedSumMantissa != 0xffffffe7 && isZero == SCARRY4(normalizedSumMantissa,0x19)) {\n      input1SignificantBits = (result << 1) >> (-normalizedSumMantissa & 0xff);\n      normalizedSumMantissa = result << (normalizedSumMantissa + 0x20 & 0xff);\n      input1SignificantBits = ((uint)((result & 0x80000000) != 0) << 0x1f | input1SignificantBits >> 1) + (uint)((byte)input1SignificantBits & 1);\n      if ((productLSB | normalizedSumMantissa << 1) == 0) {\n        input1SignificantBits = input1SignificantBits & ~(normalizedSumMantissa >> 0x1f);\n      }\n      return input1SignificantBits;\n    }\n    return result;\n  }\nLAB_08000e3c:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cec": "calculate_floating_point_08000cec",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "parameter3",
                "param_4": "parameter4",
                "lVar1": "product",
                "uVar2": "result",
                "uVar3": "input1SignificantBits",
                "iVar4": "sumOfSignificantBits",
                "iVar5": "normalizedSum",
                "uVar6": "productLSB",
                "iVar7": "normalizedSumExponent",
                "uVar8": "normalizedSumMantissa",
                "bVar9": "isZero",
                "bVar10": "carryFlag"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "lowPassFilter",
                "AK8963_Init",
                "AHRS_ComputeAngles",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MadgwickQuaternionUpdate",
                "MPU9250_ReadGyroData",
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e54": {
            "entrypoint": "0x08000e54",
            "current_name": "calculate_floating_point_08000e54",
            "code": "\nuint calculateFloatingPoint_08000e54(uint input1,uint input2,undefined4 param3,uint param4)\n\n{\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  uint result;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  temp2 = input1 >> 0x17 & 0xff;\n  condition1 = temp2 == 0;\n  if (!condition1) {\n    param4 = input2 >> 0x17 & 0xff;\n    condition1 = param4 == 0;\n  }\n  if (!condition1) {\n    condition1 = temp2 == 0xff;\n  }\n  if (!condition1) {\n    condition1 = param4 == 0xff;\n  }\n  if (condition1) {\n    param4 = input2 >> 0x17 & 0xff;\n    result = input1;\n    if (temp2 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (result = input2, param4 == 0xff)) {\nLAB_08000e4a:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (param4 == 0xff) {\n        result = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08000e00:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_08000e4a;\n      }\n      condition1 = (input1 & 0x7fffffff) == 0;\n      if (!condition1) {\n        condition1 = (input2 & 0x7fffffff) == 0;\n      }\n      if (!condition1) {\n        condition1 = temp2 == 0;\n        result = input1 & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            input1 = input1 << 1;\n            condition1 = (input1 & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          temp2 = temp2 - 1;\n        }\n        input1 = input1 | result;\n        condition1 = param4 == 0;\n        result = input2 & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            input2 = input2 << 1;\n            condition1 = (input2 & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          param4 = param4 - 1;\n        }\n        input2 = input2 | result;\n        goto LAB_08000e6c;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08000e00;\n        goto LAB_08000e4a;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_08000e6c:\n    temp3 = temp2 - param4;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      condition3 = SCARRY4(temp3,0x7f);\n      temp5 = temp3 + 0x7f;\n      condition1 = temp5 < 0;\n      condition2 = temp5 == 0;\n      if (!condition2 && condition1 == condition3) {\n        condition3 = SBORROW4(0xff,temp5);\n        condition1 = 0xff - temp5 < 0;\n        condition2 = temp5 == 0xff;\n      }\n      if (!condition2 && condition1 == condition3) {\n        input1 = input1 | temp5 * 0x800000;\n      }\n      if (!condition2 && condition1 == condition3) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      temp2 = 0;\n      condition2 = SBORROW4(temp5,1);\n      temp4 = temp3 + 0x7e;\n      condition1 = temp4 == 0;\n      result = temp4;\n    }\n    else {\n      temp1 = (input2 << 9) >> 4 | 0x10000000;\n      temp2 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      condition1 = temp1 <= temp2;\n      if (!condition1) {\n        temp2 = temp2 << 1;\n      }\n      temp4 = temp3 + 0x7d + (uint)condition1;\n      result = 0x800000;\n      do {\n        if (temp1 <= temp2) {\n          temp2 = temp2 - temp1;\n          input1 = input1 | result;\n        }\n        condition1 = temp1 >> 1 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 1);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 1;\n        }\n        condition1 = temp1 >> 2 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 2);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 2;\n        }\n        condition1 = temp1 >> 3 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 3);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 3;\n        }\n        temp2 = temp2 * 0x10;\n        condition1 = temp2 == 0;\n        if (!condition1) {\n          result = result >> 4;\n          condition1 = result == 0;\n        }\n      } while (!condition1);\n      condition2 = SBORROW4(temp4,0xfd);\n      condition1 = temp4 == 0xfd;\n      result = temp4 - 0xfd;\n      if (temp4 < 0xfe) {\n        input1 = input1 + temp4 * 0x800000 + (uint)(temp1 <= temp2);\n        if (temp2 - temp1 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (condition1 || (int)result < 0 != condition2) {\n      condition1 = (int)(temp4 + 0x19) < 0;\n      if (temp4 == 0xffffffe7 || condition1 != SCARRY4(temp4,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (temp4 == 0xffffffe7 || condition1 != SCARRY4(temp4,0x19)) {\n        return input1;\n      }\n      result = (input1 << 1) >> (-temp4 & 0xff);\n      temp4 = input1 << (temp4 + 0x20 & 0xff);\n      result = ((uint)((input1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((temp2 | temp4 << 1) == 0) {\n        result = result & ~(temp4 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e54": "calculate_floating_point_08000e54",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "result",
                "bVar7": "condition1",
                "bVar8": "condition2",
                "bVar9": "condition3"
            },
            "calling": [
                "PID_Compute",
                "AHRS_ComputeAngles",
                "MadgwickQuaternionUpdate",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "calculate_result_08000f8c",
            "code": "\nuint calculate_result_08000f8c(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint double_input_1;\n  uint double_input_2;\n  uint combined_input;\n  bool is_zero;\n  \n  double_input_1 = input_1 * 2;\n  double_input_2 = input_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined_input = double_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_input == 0;\n  if (!is_zero) {\n    combined_input = input_1 ^ input_2;\n    is_zero = combined_input == 0;\n  }\n  is_negative = -1 < (int)combined_input;\n  if (is_negative) {\n    input_1 = double_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && double_input_2 <= double_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || double_input_2 > double_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "calculate_result_08000f8c",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "combined_input",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f94": {
            "entrypoint": "0x08000f94",
            "current_name": "check_overflow_and_bitwise_operations_08000f94",
            "code": "\nuint check_overflow_and_bitwise_operations_08000f94(uint input_1,uint input_2)\n\n{\n  bool is_overflow;\n  uint doubled_input_1;\n  uint doubled_input_2;\n  uint combined_inputs;\n  bool is_combined_zero;\n  \n  doubled_input_1 = input_1 * 2;\n  doubled_input_2 = input_2 * 2;\n  if (((int)doubled_input_1 >> 0x18 == -1 || (int)doubled_input_2 >> 0x18 == -1) &&\n     ((((int)doubled_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)doubled_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_inputs = doubled_input_1 | input_2 & 0x7fffffff;\n  is_combined_zero = combined_inputs == 0;\n  if (!is_combined_zero) {\n    combined_inputs = input_1 ^ input_2;\n    is_combined_zero = combined_inputs == 0;\n  }\n  is_overflow = -1 < (int)combined_inputs;\n  if (is_overflow) {\n    input_1 = doubled_input_1 + input_2 * -2;\n    is_combined_zero = input_1 == 0;\n  }\n  if ((is_overflow && doubled_input_2 <= doubled_input_1) && !is_combined_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_overflow || doubled_input_2 > doubled_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_combined_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f94": "check_overflow_and_bitwise_operations_08000f94",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_overflow",
                "uVar2": "doubled_input_1",
                "uVar3": "doubled_input_2",
                "uVar4": "combined_inputs",
                "bVar5": "is_combined_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f9c": {
            "entrypoint": "0x08000f9c",
            "current_name": "check_overflow_and_sign_08000f9c",
            "code": "\nuint check_overflow_and_sign_08000f9c(uint input_1,uint input_2)\n\n{\n  bool is_positive;\n  uint input_1_times_2;\n  uint input_2_times_2;\n  uint result;\n  bool is_zero;\n  \n  input_1_times_2 = input_1 * 2;\n  input_2_times_2 = input_2 * 2;\n  if (((int)input_1_times_2 >> 0x18 == -1 || (int)input_2_times_2 >> 0x18 == -1) &&\n     ((((int)input_1_times_2 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_times_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  result = input_1_times_2 | input_2 & 0x7fffffff;\n  is_zero = result == 0;\n  if (!is_zero) {\n    result = input_1 ^ input_2;\n    is_zero = result == 0;\n  }\n  is_positive = -1 < (int)result;\n  if (is_positive) {\n    input_1 = input_1_times_2 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_positive && input_2_times_2 <= input_1_times_2) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_positive || input_2_times_2 > input_1_times_2) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f9c": "check_overflow_and_sign_08000f9c",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "input_1_times_2",
                "uVar3": "input_2_times_2",
                "uVar4": "result",
                "bVar1": "is_positive",
                "bVar5": "is_zero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ffc": {
            "entrypoint": "0x08000ffc",
            "current_name": "compare_floats_08000ffc",
            "code": "\nvoid compareFloats_08000ffc(undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cfcmpeq(float2,float1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ffc": "compare_floats_08000ffc",
                "param_1": "float1",
                "param_2": "float2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001004": {
            "entrypoint": "0x08001004",
            "current_name": "concat_params_08001004",
            "code": "\nundefined8 concatParams_08001004(undefined4 src,undefined4 dst)\n\n{\n  __cmpsf2();\n  return CONCAT44(dst,src);\n}\n\n",
            "renaming": {
                "FUN_08001004": "concat_params_08001004",
                "param_1": "src",
                "param_2": "dst"
            },
            "calling": [
                "__aeabi_fcmpeq",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001014": {
            "entrypoint": "0x08001014",
            "current_name": "is_not_null_08001014",
            "code": "\nbool is_not_null_08001014(void)\n\n{\n  char result;\n  \n  __aeabi_cfcmpeq();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001014": "is_not_null_08001014",
                "in_ZR": "result"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001028": {
            "entrypoint": "0x08001028",
            "current_name": "check_if_null_character_08001028",
            "code": "\nbool check_if_null_character_08001028(void)\n\n{\n  char input_character;\n  \n  compare_floats();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001028": "check_if_null_character_08001028",
                "in_CY": "input_character",
                "__aeabi_cfcmpeq": "compare_floats"
            },
            "calling": [
                "PID_Update",
                "PID_Compute",
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800103c": {
            "entrypoint": "0x0800103c",
            "current_name": "compare_floating_point_equality_0800103c",
            "code": "\nbool compareFloatingPointEquality_0800103c(void)\n\n{\n  undefined isZeroFlagSet;\n  undefined isCarryFlagSet;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)isCarryFlagSet || (bool)isZeroFlagSet;\n}\n\n",
            "renaming": {
                "FUN_0800103c": "compare_floating_point_equality_0800103c",
                "in_ZR": "isZeroFlagSet",
                "in_CY": "isCarryFlagSet"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001050": {
            "entrypoint": "0x08001050",
            "current_name": "check_if_carry_flag_clear_08001050",
            "code": "\nbool check_if_carry_flag_clear_08001050(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_flag_set;\n  \n  __aeabi_cfrcmple();\n  return !(bool)is_carry_flag_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_08001050": "check_if_carry_flag_clear_08001050",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_flag_set"
            },
            "calling": [
                "AHRS_GetYaw"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001064": {
            "entrypoint": "0x08001064",
            "current_name": "is_char_null_08001064",
            "code": "\nbool isCharNull_08001064(void)\n\n{\n  char character;\n  \n  __aeabi_cfrcmple();\n  return character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001064": "is_char_null_08001064",
                "in_CY": "character"
            },
            "calling": [
                "PID_Update",
                "PID_Compute"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001078": {
            "entrypoint": "0x08001078",
            "current_name": "convert_unsigned_to_int_08001078",
            "code": "\nuint convertUnsignedToInt_08001078(uint inputNum)\n\n{\n  uint shiftedInput;\n  uint difference;\n  \n  if (inputNum << 1 < 0x7f000000) {\n    return 0;\n  }\n  shiftedInput = (inputNum << 1) >> 0x18;\n  difference = 0x9e - shiftedInput;\n  if (shiftedInput < 0x9f && difference != 0) {\n    shiftedInput = (inputNum << 8 | 0x80000000) >> (difference & 0xff);\n    if ((inputNum & 0x80000000) != 0) {\n      shiftedInput = -shiftedInput;\n    }\n    return shiftedInput;\n  }\n  if ((difference == 0xffffff9f) && ((inputNum & 0x7fffff) != 0)) {\n    return 0;\n  }\n  inputNum = inputNum & 0x80000000;\n  if (inputNum == 0) {\n    inputNum = 0x7fffffff;\n  }\n  return inputNum;\n}\n\n",
            "renaming": {
                "FUN_08001078": "convert_unsigned_to_int_08001078",
                "param_1": "inputNum",
                "uVar1": "shiftedInput",
                "uVar2": "difference"
            },
            "calling": [
                "Motor_DistributeSpeed",
                "AHRS_ComputeAngles",
                "MS5611_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080010c4": {
            "entrypoint": "0x080010c4",
            "current_name": "check_and_convert_080010c4",
            "code": "\nuint checkAndConvert_080010c4(uint inputValue)\n\n{\n  uint shiftAmount;\n  \n  if (((inputValue & 0x80000000) != 0) || (inputValue << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftAmount = 0x9e - ((inputValue << 1) >> 0x18);\n  if (-1 < (int)shiftAmount) {\n    return (inputValue << 8 | 0x80000000) >> (shiftAmount & 0xff);\n  }\n  if ((shiftAmount == 0xffffff9f) && ((inputValue & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080010c4": "check_and_convert_080010c4",
                "param_1": "inputValue",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001104": {
            "entrypoint": "0x08001104",
            "current_name": "configure_system_tick_08001104",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureSystemTick_08001104(uint32_t tickPriority)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_NVIC_SetPriority(SysTick_IRQn,tickPriority,0);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001104": "configure_system_tick_08001104",
                "TickPriority": "tickPriority",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_RCC_GetHCLKFreq",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001128": {
            "entrypoint": "0x08001128",
            "current_name": "initialize_hardware_08001128",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHardwareStatus initializeHardware_08001128(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setInterruptPriorityGrouping(3);\n  initializeTick(0);\n  initializePeripheral();\n  return OperationSuccess;\n}\n\n",
            "renaming": {
                "FUN_08001128": "initialize_hardware_08001128",
                "HAL_StatusTypeDef": "HardwareStatus",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializePeripheral",
                "HAL_OK": "OperationSuccess"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800114c": {
            "entrypoint": "0x0800114c",
            "current_name": "increment_tick_0800114c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid incrementTick_0800114c(void)\n\n{\n  tick = tick + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800114c": "increment_tick_0800114c",
                "uwTick": "tick"
            },
            "calling": [
                "SysTick_Handler",
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800115c": {
            "entrypoint": "0x0800115c",
            "current_name": "get_system_tick_0800115c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_0800115c(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_0800115c": "get_system_tick_0800115c",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Read",
                "HAL_UART_Transmit",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "millis",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "micros",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001168": {
            "entrypoint": "0x08001168",
            "current_name": "FUNC_08001168",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001168(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001168": "FUNC_08001168"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "delay_ms"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "configure_priority_group_08001170",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configurePriorityGroup_08001170(uint32_t priorityGroup)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | 0x5fa0000 | (priorityGroup & 7) << 8;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001170": "configure_priority_group_08001170",
                "PriorityGroup": "priorityGroup"
            },
            "calling": [
                "HAL_Init",
                "HAL_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001194": {
            "entrypoint": "0x08001194",
            "current_name": "configure_interrupt_priority_08001194",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureInterruptPriority_08001194(interruptNumber IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint interruptNum;\n  undefined priorityByte;\n  uint32_t preemptPriorityBits;\n  uint tempVar;\n  uint32_t priorityGroupTemp;\n  uint32_t subPriorityBits;\n  uint tempVar2;\n  \n  interruptNum = (uint)IRQn;\n  subPriorityBits = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - subPriorityBits;\n  tempVar2 = subPriorityBits + 4;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (tempVar2 < 7) {\n    subPriorityBits = 0;\n  }\n  tempVar = (1 << (preemptPriorityBits & 0xff)) - 1;\n  if (6 < tempVar2) {\n    subPriorityBits = subPriorityBits - 3;\n  }\n  priorityByte = (undefined)\n          ((subPriority & (1 << (subPriorityBits & 0xff)) - 1U |\n           (preemptPriority & tempVar) << (subPriorityBits & 0xff)) << 4);\n  if (-1 < (int)interruptNum) {\n    tempVar2 = interruptNum + 0xe000e100;\n  }\n  else {\n    tempVar = 0xe000ed14;\n    tempVar2 = interruptNum & 0xf;\n  }\n  if (-1 < (int)interruptNum) {\n    *(undefined *)(tempVar2 + 0x300) = priorityByte;\n  }\n  else {\n    *(undefined *)(tempVar + tempVar2) = priorityByte;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001194": "configure_interrupt_priority_08001194",
                "IRQn_Type": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "interruptNum",
                "uVar2": "priorityByte",
                "PreemptPriorityBits": "preemptPriorityBits",
                "uVar3": "tempVar",
                "PriorityGroupTmp": "priorityGroupTemp",
                "SubPriorityBits": "subPriorityBits",
                "uVar4": "tempVar2"
            },
            "calling": [
                "HAL_UART_MspInit",
                "HAL_MspInit",
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011fc": {
            "entrypoint": "0x080011fc",
            "current_name": "set_irq_enable_080011fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_IRQ_Enable_080011fc(interrupt_number_Type interrupt_number)\n\n{\n  *(int *)(((uint)(int)interrupt_number >> 5) * 4 + -0x1fff1f00) = 1 << ((int)interrupt_number & 0x1fU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011fc": "set_irq_enable_080011fc",
                "IRQn": "interrupt_number"
            },
            "calling": [
                "HAL_UART_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001214": {
            "entrypoint": "0x08001214",
            "current_name": "initialize_ticks_08001214",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTicks_08001214(uint32_t numberOfTicks)\n\n{\n  if (numberOfTicks - 1 < 0x1000000) {\n    _DAT_e000e014 = numberOfTicks - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001214": "initialize_ticks_08001214",
                "TicksNumb": "numberOfTicks"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001240": {
            "entrypoint": "0x08001240",
            "current_name": "set_clock_source_08001240",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setClockSource_08001240(uint32_t source)\n\n{\n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001240": "set_clock_source_08001240",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001258": {
            "entrypoint": "0x08001258",
            "current_name": "FUNC_08001258",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001258(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001258": "FUNC_08001258"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800125a": {
            "entrypoint": "0x0800125a",
            "current_name": "handle_sys_tick_callback_0800125a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickCallback_0800125a(void)\n\n{\n  performSystemTickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800125a": "handle_sys_tick_callback_0800125a",
                "HAL_SYSTICK_Callback": "performSystemTickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001264": {
            "entrypoint": "0x08001264",
            "current_name": "configure_gpio_08001264",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08001264(GPIO_TypeDef *gpioPort,gpioInitTypeDef *gpioInit)\n\n{\n  uint32_t *configRegister;\n  uint32_t speedValue;\n  uint pinMask;\n  uint modeValue;\n  int gpioIndex;\n  uint pinIndex;\n  uint pinMaskShifted;\n  uint alternativeMode;\n  GPIO_TypeDef *currentGPIO;\n  int bitShift;\n  uint32_t temporaryRegister;\n  \n  speedValue = 0;\n  pinIndex = 0;\n  do {\n    pinMaskShifted = 1 << (pinIndex & 0xff);\n    pinMask = pinMaskShifted & gpioInit->Pin;\n    if (pinMaskShifted == pinMask) {\n      modeValue = gpioInit->Mode;\n      if (modeValue == 0x12) {\n        speedValue = gpioInit->Speed + 0xc;\n      }\n      else if (modeValue < 0x13) {\n        if (modeValue == 2) {\n          speedValue = gpioInit->Speed + 8;\n        }\n        else if (modeValue < 3) {\n          if (modeValue == 0) goto LAB_080013be;\n          if (modeValue == 1) {\n            speedValue = gpioInit->Speed;\n          }\n        }\n        else if (modeValue == 3) {\n          speedValue = 0;\n        }\n        else if (modeValue == 0x11) {\n          speedValue = gpioInit->Speed + 4;\n        }\n      }\n      else {\n        if (modeValue != 0x10210000) {\n          if (modeValue < 0x10210001) {\n            if (modeValue != 0x10110000) {\n              alternativeMode = 0x10120000;\nLAB_080013b8:\n              if (modeValue != alternativeMode) goto LAB_080012a8;\n            }\n          }\n          else if ((modeValue != 0x10310000) && (modeValue != 0x10320000)) {\n            alternativeMode = 0x10220000;\n            goto LAB_080013b8;\n          }\n        }\nLAB_080013be:\n        speedValue = gpioInit->Pull;\n        if (speedValue == 0) {\n          speedValue = 4;\n        }\n        else {\n          if (speedValue == 1) {\n            gpioPort->BSRR = pinMaskShifted;\n          }\n          if (speedValue != 1) {\n            gpioPort->BRR = pinMaskShifted;\n          }\n          speedValue = 8;\n        }\n      }\nLAB_080012a8:\n      if (pinMask < 0x100) {\n        pinMaskShifted = gpioPort->CRL;\n        modeValue = pinIndex << 2;\n        currentGPIO = gpioPort;\n      }\n      else {\n        pinMaskShifted = gpioPort->CRH;\n        modeValue = (pinIndex + 0x3ffffff8) * 4;\n      }\n      if (0xff < pinMask) {\n        currentGPIO = (GPIO_TypeDef *)&gpioPort->CRH;\n      }\n      currentGPIO->CRL = pinMaskShifted & ~(0xf << (modeValue & 0xff)) | speedValue << (modeValue & 0xff);\n      currentGPIO = (GPIO_TypeDef *)gpioInit->Mode;\n      if (((uint)currentGPIO & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        bitShift = (pinIndex & 3) << 2;\n        if (gpioPort == (GPIO_TypeDef *)0x40010800) {\n          gpioIndex = 0;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40010c00) {\n          gpioIndex = 1;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011000) {\n          gpioIndex = 2;\n        }\n        else if (gpioPort == (GPIO_TypeDef *)0x40011400) {\n          gpioIndex = 3;\n        }\n        else {\n          gpioIndex = 4;\n        }\n        *(uint *)((pinIndex & 0xfffffffc) + 0x40010008) =\n             gpioIndex << bitShift | *(uint *)((pinIndex & 0xfffffffc) + 0x40010008) & ~(0xf << bitShift);\n        if (((uint)currentGPIO & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~pinMask;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | pinMask;\n        }\n        if (((uint)currentGPIO & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~pinMask;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | pinMask;\n        }\n        if (((uint)currentGPIO & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~pinMask;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | pinMask;\n        }\n        if (((uint)currentGPIO & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~pinMask;\n        }\n        else {\n          _DAT_4001040c = pinMask | _DAT_4001040c;\n        }\n      }\n    }\n    pinIndex = pinIndex + 1;\n    if (pinIndex == 0x10) {\n      return;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001264": "configure_gpio_08001264",
                "GPIOx": "gpioPort",
                "GPIO_Init": "gpioInit",
                "configregister": "configRegister",
                "uVar1": "speedValue",
                "uVar2": "pinMask",
                "uVar3": "modeValue",
                "iVar4": "gpioIndex",
                "uVar5": "pinIndex",
                "uVar6": "pinMaskShifted",
                "uVar7": "alternativeMode",
                "unaff_r10": "currentGPIO",
                "iVar8": "bitShift",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_UART_MspInit",
                "Peripherals_Init",
                "HAL_I2C_MspInit",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001424": {
            "entrypoint": "0x08001424",
            "current_name": "set_pin_state_08001424",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08001424(GPIO_TypeDef *gpioGroup,uint16_t pinNumber,pinNumberState newState)\n\n{\n  uint32_t pinMask;\n  \n  pinMask = (uint32_t)pinNumber;\n  if (newState == GPIO_PIN_RESET) {\n    pinMask = pinMask << 0x10;\n  }\n  gpioGroup->BSRR = pinMask;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001424": "set_pin_state_08001424",
                "GPIOx": "gpioGroup",
                "GPIO_Pin": "pinNumber",
                "PinState": "newState",
                "uVar1": "pinMask"
            },
            "calling": [
                "Peripherals_Init",
                "toggleLED",
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800142e": {
            "entrypoint": "0x0800142e",
            "current_name": "toggle_gpio_0800142e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid toggleGPIO_0800142e(GPIO_TypeDef *gpioPort,uint16_t pinNumber)\n\n{\n  gpioPort->ODR = (uint)pinNumber ^ gpioPort->ODR;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800142e": "toggle_gpio_0800142e",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001436": {
            "entrypoint": "0x08001436",
            "current_name": "clear_i2_c_flag_08001436",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_Status clearI2CFlag_08001436(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  \n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->statusRegister1 & 0x400) != 0) {\n    i2cInstance->statusRegister1 = i2cInstance->statusRegister1 & 0xfffffbff;\n    i2cHandle->errorCode = 4;\n    i2cHandle->state = HAL_I2C_STATE_READY;\n    i2cHandle->lockState = HAL_UNLOCKED;\n    return HAL_ERROR;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001436": "clear_i2_c_flag_08001436",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "SR1": "statusRegister1",
                "ErrorCode": "errorCode",
                "State": "state",
                "Lock": "lockState",
                "HAL_StatusTypeDef": "HAL_Status"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "wait_for_flag_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForFlag_08001460(I2C_HandleTypeDef *i2cHandle,uint32_t flag,uint32_t timeout)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint status;\n  I2C_TypeDef *i2cInstance;\n  \n  startTime = HAL_GetTick();\n  do {\n    i2cInstance = i2cHandle->Instance;\n    if ((flag << 8) >> 0x18 == 1) {\n      status = i2cInstance->SR1;\n    }\n    else {\n      status = i2cInstance->SR2;\n    }\n    if ((flag & 0xffff & ~status) == 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->SR1 << 0x15) < 0) {\n      i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n      i2cInstance->SR1 = i2cInstance->SR1 & 0xfffffbff;\n      i2cHandle->ErrorCode = 4;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout))));\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001460": "wait_for_flag_08001460",
                "hi2c": "i2cHandle",
                "Flag": "flag",
                "Timeout": "timeout",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "uVar3": "status",
                "pIVar4": "i2cInstance"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014e2": {
            "entrypoint": "0x080014e2",
            "current_name": "check_i2_c_acknowledge_080014e2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef checkI2CAcknowledge_080014e2(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  uint32_t tickStart;\n  \n  startTime = HAL_GetTick();\n  while( true ) {\n    if ((int)(i2cHandle->Instance->SR1 << 0x18) < 0) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080014e2": "check_i2_c_acknowledge_080014e2",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "tickstart": "tickStart"
            },
            "calling": [
                "I2C_RequestMemoryWrite",
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001530": {
            "entrypoint": "0x08001530",
            "current_name": "transmit_data_08001530",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ntransmitData_08001530(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  startTime = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cHandle->Instance->SR1 << 0x1f) < 0) {\n        i2cHandle->Instance->DR = deviceAddress & 0xfe;\n        status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n        if (status == HAL_OK) {\n          status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n          if (status == HAL_OK) {\n            i2cInstance = i2cHandle->Instance;\n            if (memoryAddressSize == 1) {\nLAB_080015ca:\n              i2cInstance->DR = (uint)(byte)memoryAddress;\n              return HAL_OK;\n            }\n            i2cInstance->DR = (uint)(memoryAddress >> 8);\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n            if (status == HAL_OK) {\n              i2cInstance = i2cHandle->Instance;\n              goto LAB_080015ca;\n            }\n          }\n          if (i2cHandle->ErrorCode != 4) {\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->ErrorCode != 4) {\n          return HAL_TIMEOUT;\n        }\n        return HAL_ERROR;\n      }\n    } while (timeout == 0xffffffff);\n    if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08001530": "transmit_data_08001530",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015e8": {
            "entrypoint": "0x080015e8",
            "current_name": "perform_i2_c_device_transfer_080015e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nperformI2CDeviceTransfer_080015e8(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempReg;\n  \n  i2cInstance = i2cHandle->Instance;\n  i2cInstance->CR1 = i2cInstance->CR1 | 0x400;\n  i2cInstance->CR1 = i2cInstance->CR1 | 0x100;\n  startTime = HAL_GetTick();\nLAB_0800160e:\n  while (-1 < (int)(i2cHandle->Instance->SR1 << 0x1f)) {\n    if (timeout != 0xffffffff) goto code_r0x08001658;\n  }\n  i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n  status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n  if (status != HAL_OK) goto LAB_080016ba;\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n  if (status == HAL_OK) {\n    i2cInstance = i2cHandle->Instance;\n    if (memoryAddressSize != 1) {\n      i2cInstance->DR = (uint)(memoryAddress >> 8);\n      status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n      if (status != HAL_OK) goto LAB_08001642;\n      i2cInstance = i2cHandle->Instance;\n    }\n    i2cInstance->DR = (uint)(byte)memoryAddress;\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n    if (status == HAL_OK) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      startTime = HAL_GetTick();\n      do {\n        do {\n          if ((int)(i2cHandle->Instance->SR1 << 0x1f) < 0) {\n            i2cHandle->Instance->DR = (byte)deviceAddress | 1;\n            status = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout);\n            if (status == HAL_OK) {\n              return HAL_OK;\n            }\nLAB_080016ba:\n            if (i2cHandle->ErrorCode != 4) {\n              return HAL_TIMEOUT;\n            }\n            return HAL_ERROR;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (currentTime = HAL_GetTick(), currentTime - startTime <= timeout));\nLAB_0800165a:\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001642:\n  if (i2cHandle->ErrorCode == 4) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\ncode_r0x08001658:\n  if ((timeout == 0) || (currentTime = HAL_GetTick(), timeout < currentTime - startTime)) goto LAB_0800165a;\n  goto LAB_0800160e;\n}\n\n",
            "renaming": {
                "FUN_080015e8": "perform_i2_c_device_transfer_080015e8",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "tmpreg": "tempReg"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016f4": {
            "entrypoint": "0x080016f4",
            "current_name": "wait_for_i2_c_flag_080016f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef waitForI2CFlag_080016f4(I2C_HandleTypeDef *i2cHandle,uint32_t timeout)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  I2C_TypeDef *i2cInstance;\n  \n  startTick = HAL_GetTick();\n  while( true ) {\n    i2cInstance = i2cHandle->Instance;\n    if ((i2cInstance->SR1 & 0x40) != 0) {\n      return HAL_OK;\n    }\n    if ((int)(i2cInstance->SR1 << 0x1b) < 0) break;\n    if ((timeout == 0) || (currentTick = HAL_GetTick(), timeout < currentTick - startTick)) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2cInstance->SR1 = i2cInstance->SR1 & 0xffffffef;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_080016f4": "wait_for_i2_c_flag_080016f4",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "uVar1": "startTick",
                "uVar2": "currentTick",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001754": {
            "entrypoint": "0x08001754",
            "current_name": "initialize_i2_c_08001754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeI2C_08001754(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t pclk1Freq;\n  uint temp;\n  uint timeout;\n  I2C_TypeDef *i2cInstance;\n  uint clockSpeed;\n  uint prescaler;\n  \n  if (i2cHandle != (I2C_HandleTypeDef *)0x0) {\n    if (i2cHandle->State == HAL_I2C_STATE_RESET) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      HAL_I2C_MspInit(i2cHandle);\n    }\n    i2cHandle->State = HAL_I2C_STATE_BUSY;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    clockSpeed = (i2cHandle->Init).ClockSpeed;\n    prescaler = pclk1Freq / 1000000;\n    timeout = temp;\n    if (100000 < clockSpeed) {\n      timeout = 300;\n    }\n    i2cInstance = i2cHandle->Instance;\n    if (100000 < clockSpeed) {\n      timeout = prescaler * timeout;\n    }\n    i2cInstance->CR2 = prescaler;\n    if (100000 < clockSpeed) {\n      prescaler = timeout / 1000;\n    }\n    i2cInstance->TRISE = prescaler + 1;\n    if (clockSpeed < 0x186a1) {\n      pclk1Freq = pclk1Freq / (clockSpeed << 1);\n      if ((pclk1Freq & 0xfff) < 4) {\n        pclk1Freq = 4;\n      }\n    }\n    else {\n      if ((i2cHandle->Init).DutyCycle == 0) {\n        pclk1Freq = pclk1Freq / (clockSpeed * 3) | 0x8000;\n      }\n      else {\n        pclk1Freq = pclk1Freq / (clockSpeed * 0x19) | 0xc000;\n      }\n      if ((pclk1Freq & 0xfff) == 0) {\n        pclk1Freq = 1;\n      }\n    }\n    prescaler = (i2cHandle->Init).NoStretchMode;\n    timeout = (i2cHandle->Init).GeneralCallMode;\n    i2cInstance->CCR = pclk1Freq;\n    i2cInstance->CR1 = timeout | prescaler;\n    i2cInstance->OAR1 = (i2cHandle->Init).AddressingMode | (i2cHandle->Init).OwnAddress1;\n    i2cInstance->OAR2 = (i2cHandle->Init).DualAddressMode | (i2cHandle->Init).OwnAddress2;\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n    i2cHandle->ErrorCode = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001754": "initialize_i2_c_08001754",
                "hi2c": "i2cHandle",
                "uVar1": "pclk1Freq",
                "extraout_r1": "temp",
                "uVar2": "timeout",
                "uVar4": "clockSpeed",
                "uVar5": "prescaler",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001828": {
            "entrypoint": "0x08001828",
            "current_name": "memory_write_with_timeout_08001828",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nmemoryWriteWithTimeout_08001828(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *dataPointer,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t currentTime;\n  I2C_TypeDef *i2cInstance;\n  uint tempVar;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_READY) {\n    if (dataPointer == (uint8_t *)0x0) {\n      return HAL_ERROR;\n    }\n    if (dataSize == 0) {\n      return HAL_ERROR;\n    }\n    startTime = HAL_GetTick();\n    do {\n      i2cInstance = i2cHandle->Instance;\n      if ((~i2cInstance->SR2 & 2) != 0) {\n        if (i2cHandle->Lock == HAL_LOCKED) {\n          return HAL_BUSY;\n        }\n        tempVar = i2cInstance->CR1;\n        i2cHandle->Lock = HAL_LOCKED;\n        i2cInstance->CR1 = tempVar & 0xfffff7ff;\n        i2cHandle->State = HAL_I2C_STATE_BUSY_TX;\n        i2cHandle->Mode = HAL_I2C_MODE_MEM;\n        i2cHandle->ErrorCode = 0;\n        status = I2C_RequestMemoryWrite(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout);\n        if (status != HAL_OK) {\n          i2cHandle->Lock = HAL_UNLOCKED;\n          if (i2cHandle->ErrorCode == 4) {\n            return HAL_ERROR;\n          }\n          return HAL_TIMEOUT;\n        }\n        goto LAB_080018e2;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 0x2711);\n    i2cHandle->Lock = HAL_UNLOCKED;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n  }\n  return HAL_BUSY;\n  while (dataSize != 0) {\nLAB_080018e2:\n    status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n    if (status != HAL_OK) goto LAB_080018ee;\n    i2cInstance = i2cHandle->Instance;\n    i2cInstance->DR = (uint)*dataPointer;\n    if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n      if ((uint16_t)(dataSize - 1) == 0) break;\n      dataSize = dataSize - 2;\n      i2cInstance->DR = (uint)dataPointer[1];\n      dataPointer = dataPointer + 2;\n    }\n    else {\n      dataPointer = dataPointer + 1;\n      dataSize = dataSize - 1;\n    }\n  }\n  status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout);\n  if (status == HAL_OK) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    i2cHandle->Lock = HAL_UNLOCKED;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    return HAL_OK;\n  }\nLAB_080018ee:\n  if (i2cHandle->ErrorCode == 4) {\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    return HAL_ERROR;\n  }\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001828": "memory_write_with_timeout_08001828",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "dataPointer",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "uVar2": "startTime",
                "uVar3": "currentTime",
                "pIVar4": "i2cInstance",
                "uVar5": "tempVar"
            },
            "calling": [
                "I2C_WriteByte"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryWrite",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001938": {
            "entrypoint": "0x08001938",
            "current_name": "read_data_from_i2_c_08001938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nreadDataFromI2C_08001938(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *dataBuffer,uint16_t dataBufferSize,uint32_t timeout)\n\n{\n  uint8_t *pointerVar1;\n  HAL_StatusTypeDef status;\n  uint32_t tickVar1;\n  uint32_t tickVar2;\n  I2C_TypeDef *i2cInstance;\n  uint var6;\n  uint8_t *pointerVar7;\n  bool boolVar8;\n  uint32_t tempReg1;\n  uint32_t tempReg2;\n  uint32_t tempReg3;\n  \n  if (i2cHandle->State != HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (dataBufferSize == 0) {\n    return HAL_ERROR;\n  }\n  tickVar1 = HAL_GetTick();\n  while (i2cInstance = i2cHandle->Instance, (~i2cInstance->SR2 & 2) == 0) {\n    tickVar2 = HAL_GetTick();\n    if (10000 < tickVar2 - tickVar1) {\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      return HAL_BUSY;\n    }\n  }\n  if (i2cHandle->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  var6 = i2cInstance->CR1;\n  i2cHandle->Lock = HAL_LOCKED;\n  i2cInstance->CR1 = var6 & 0xfffff7ff;\n  i2cHandle->State = HAL_I2C_STATE_BUSY_RX;\n  i2cHandle->Mode = HAL_I2C_MODE_MEM;\n  i2cHandle->ErrorCode = 0;\n  status = I2C_RequestMemoryRead(i2cHandle,deviceAddress,memoryAddress,memoryAddressSize,timeout);\n  if (status != HAL_OK) {\n    i2cHandle->Lock = HAL_UNLOCKED;\n    if (i2cHandle->ErrorCode == 4) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  i2cInstance = i2cHandle->Instance;\n  var6 = i2cInstance->CR1;\n  if (dataBufferSize == 1) {\n    i2cInstance->CR1 = var6 & 0xfffffbff;\n    disableIRQinterrupts();\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n    enableIRQinterrupts();\n    status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout);\n    if (status == HAL_OK) {\n      *dataBuffer = (uint8_t)i2cHandle->Instance->DR;\nLAB_08001ab8:\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_OK;\n    }\nLAB_08001a18:\n    if (i2cHandle->ErrorCode != 0x20) {\n      return HAL_ERROR;\n    }\n    return HAL_TIMEOUT;\n  }\n  if (dataBufferSize == 2) {\n    i2cInstance->CR1 = var6 | 0x800;\n    disableIRQinterrupts();\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    enableIRQinterrupts();\n  }\n  else {\n    i2cInstance->CR1 = var6 | 0x400;\n    while (3 < dataBufferSize) {\n      status = I2C_WaitOnRXNEFlagUntiltimeout(i2cHandle,timeout);\n      if (status != HAL_OK) goto LAB_08001a18;\n      *dataBuffer = (uint8_t)i2cHandle->Instance->DR;\n      i2cInstance = i2cHandle->Instance;\n      boolVar8 = (int)(i2cInstance->SR1 << 0x1d) < 0;\n      if (boolVar8) {\n        i2cInstance = (I2C_TypeDef *)i2cInstance->DR;\n        pointerVar7 = dataBuffer + 2;\n        dataBufferSize = dataBufferSize - 2;\n      }\n      else {\n        pointerVar7 = dataBuffer + 1;\n        dataBufferSize = dataBufferSize - 1;\n      }\n      pointerVar1 = dataBuffer + 1;\n      dataBuffer = pointerVar7;\n      if (boolVar8) {\n        *pointerVar1 = (uint8_t)i2cInstance;\n      }\n    }\n    if (dataBufferSize != 2) {\n      tickVar1 = HAL_GetTick();\n      do {\n        i2cInstance = i2cHandle->Instance;\n        do {\n          if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            *dataBuffer = (uint8_t)i2cHandle->Instance->DR;\n            tickVar1 = HAL_GetTick();\n            goto LAB_08001b3a;\n          }\n        } while (timeout == 0xffffffff);\n      } while ((timeout != 0) && (tickVar2 = HAL_GetTick(), tickVar2 - tickVar1 <= timeout));\n      goto LAB_08001afa;\n    }\n  }\n  tickVar1 = HAL_GetTick();\n  do {\n    do {\n      if ((int)(i2cHandle->Instance->SR1 << 0x1d) < 0) {\n        disableIRQinterrupts();\n        i2cInstance = i2cHandle->Instance;\n        i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n        *dataBuffer = (uint8_t)i2cInstance->DR;\n        enableIRQinterrupts();\n        dataBuffer[1] = (uint8_t)i2cHandle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (tickVar2 = HAL_GetTick(), tickVar2 - tickVar1 <= timeout));\nLAB_08001afa:\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\nLAB_08001b3a:\n  do {\n    i2cInstance = i2cHandle->Instance;\n    do {\n      if ((int)(i2cInstance->SR1 << 0x1d) < 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n        dataBuffer[1] = (uint8_t)i2cInstance->DR;\n        enableIRQinterrupts();\n        dataBuffer[2] = (uint8_t)i2cHandle->Instance->DR;\n        goto LAB_08001ab8;\n      }\n    } while (timeout == 0xffffffff);\n  } while ((timeout != 0) && (tickVar2 = HAL_GetTick(), tickVar2 - tickVar1 <= timeout));\n  goto LAB_08001afa;\n}\n\n",
            "renaming": {
                "FUN_08001938": "read_data_from_i2_c_08001938",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "dataBuffer",
                "Size": "dataBufferSize",
                "Timeout": "timeout",
                "puVar1": "pointerVar1",
                "HVar2": "status",
                "uVar3": "tickVar1",
                "uVar4": "tickVar2",
                "pIVar5": "i2cInstance",
                "uVar6": "var6",
                "puVar7": "pointerVar7",
                "bVar8": "boolVar8",
                "tmpreg": "tempReg1",
                "tmpreg_1": "tempReg2",
                "tmpreg_2": "tempReg3"
            },
            "calling": [
                "I2C_ReadByte",
                "I2C_ReadBytes"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b58": {
            "entrypoint": "0x08001b58",
            "current_name": "initialize_rcc_08001b58",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001eec) initialize_RCC_08001b58\n/* WARNING: Removing unreachable block (ram,0x08001ee8) initialize_RCC_08001b58\n\n/* WARNING: Unknown calling convention initialize_RCC_08001b58\n\nHAL_StatusTypeDef initialize_RCC_08001b58(RCC_OscInitTypeDef *RCC_initialization_structure)\n\n{\n  uint32_t temp_var_1;\n  uint32_t temp_var_2;\n  uint temp_var_3;\n  uint32_t temporary_register;\n  \n  if ((int)(RCC_initialization_structure->OscillatorType << 0x1f) < 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((int)(_DAT_40021004 << 0xf) < 0)))) {\n      if (((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) && (RCC_initialization_structure->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      temp_var_1 = RCC_initialization_structure->HSEState;\n      if (temp_var_1 == 0x10000) {\nLAB_08001c1e:\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else {\n        if (temp_var_1 == 0) {\n          _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n          temp_var_1 = HAL_GetTick();\n          while ((int)((_DAT_40021000 >> 0x11) << 0x1f) < 0) {\n            temp_var_2 = HAL_GetTick();\n            if (100 < temp_var_2 - temp_var_1) {\n              return HAL_TIMEOUT;\n            }\n          }\n          goto LAB_08001b64;\n        }\n        if (temp_var_1 == 0x50000) {\n          _DAT_40021000 = _DAT_40021000 | 0x40000;\n          goto LAB_08001c1e;\n        }\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      temp_var_1 = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021000 >> 0x11) << 0x1f)) {\n        temp_var_2 = HAL_GetTick();\n        if (100 < temp_var_2 - temp_var_1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\nLAB_08001b64:\n  if ((int)(RCC_initialization_structure->OscillatorType << 0x1e) < 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && (-1 < (int)(_DAT_40021004 << 0xf))))) {\n      if (((int)((_DAT_40021000 >> 1) << 0x1f) < 0) && (RCC_initialization_structure->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uRam42420000 = RCC_initialization_structure->HSIState;\n      if (uRam42420000 == 0) {\n        temp_var_1 = HAL_GetTick();\n        while ((int)((_DAT_40021000 >> 1) << 0x1f) < 0) {\n          temp_var_2 = HAL_GetTick();\n          if (2 < temp_var_2 - temp_var_1) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_08001b6c;\n      }\n      uRam42420000 = 1;\n      temp_var_1 = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021000 >> 1) << 0x1f)) {\n        temp_var_2 = HAL_GetTick();\n        if (2 < temp_var_2 - temp_var_1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    _DAT_40021000 = RCC_initialization_structure->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n  }\nLAB_08001b6c:\n  if ((int)(RCC_initialization_structure->OscillatorType << 0x1c) < 0) {\n    uRam42420480 = RCC_initialization_structure->LSIState;\n    if (uRam42420480 == 0) {\n      temp_var_1 = HAL_GetTick();\n      while ((int)((_DAT_40021024 >> 1) << 0x1f) < 0) {\n        temp_var_2 = HAL_GetTick();\n        if (2 < temp_var_2 - temp_var_1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uRam42420480 = 1;\n      temp_var_1 = HAL_GetTick();\n      while (-1 < (int)((_DAT_40021024 >> 1) << 0x1f)) {\n        temp_var_2 = HAL_GetTick();\n        if (2 < temp_var_2 - temp_var_1) {\n          return HAL_TIMEOUT;\n        }\n      }\n      HAL_Delay(1);\n    }\n  }\n  if (-1 < (int)(RCC_initialization_structure->OscillatorType << 0x1d)) goto LAB_08001bc2;\n  _DAT_4002101c = _DAT_4002101c | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0x100;\n  temp_var_1 = HAL_GetTick();\n  while (-1 < (int)(_DAT_40007000 << 0x17)) {\n    temp_var_2 = HAL_GetTick();\n    if (100 < temp_var_2 - temp_var_1) {\n      return HAL_TIMEOUT;\n    }\n  }\n  temp_var_1 = RCC_initialization_structure->LSEState;\n  if (temp_var_1 == 1) {\nLAB_08001e1a:\n    _DAT_40021020 = _DAT_40021020 | 1;\n  }\n  else {\n    if (temp_var_1 == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n      temp_var_1 = HAL_GetTick();\n      while ((int)((_DAT_40021020 >> 1) << 0x1f) < 0) {\n        temp_var_2 = HAL_GetTick();\n        if (5000 < temp_var_2 - temp_var_1) {\n          return HAL_TIMEOUT;\n        }\n      }\n      goto LAB_08001bc2;\n    }\n    if (temp_var_1 == 5) {\n      _DAT_40021020 = _DAT_40021020 | 4;\n      goto LAB_08001e1a;\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n  }\n  temp_var_1 = HAL_GetTick();\n  while (-1 < (int)((_DAT_40021020 >> 1) << 0x1f)) {\n    temp_var_2 = HAL_GetTick();\n    if (5000 < temp_var_2 - temp_var_1) {\n      return HAL_TIMEOUT;\n    }\n  }\nLAB_08001bc2:\n  temp_var_1 = (RCC_initialization_structure->PLL).PLLState;\n  if (temp_var_1 == 0) {\n    return HAL_OK;\n  }\n  if ((_DAT_40021004 & 0xc) != 8) {\n    if (temp_var_1 != 2) {\n      uRam42420060 = 0;\n      temp_var_1 = HAL_GetTick();\n      do {\n        if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n          return HAL_OK;\n        }\n        temp_var_2 = HAL_GetTick();\n      } while (temp_var_2 - temp_var_1 < 3);\n      return HAL_TIMEOUT;\n    }\n    uRam42420060 = 0;\n    temp_var_1 = HAL_GetTick();\n    do {\n      if (-1 < (int)((_DAT_40021000 >> 0x19) << 0x1f)) {\n        temp_var_3 = (RCC_initialization_structure->PLL).PLLSource;\n        if (temp_var_3 == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | RCC_initialization_structure->HSEPredivValue;\n        }\n        _DAT_40021004 = temp_var_3 | (RCC_initialization_structure->PLL).PLLMUL | _DAT_40021004 & 0xffc2ffff;\n        uRam42420060 = 1;\n        temp_var_1 = HAL_GetTick();\n        do {\n          if ((int)((_DAT_40021000 >> 0x19) << 0x1f) < 0) {\n            return HAL_OK;\n          }\n          temp_var_2 = HAL_GetTick();\n        } while (temp_var_2 - temp_var_1 < 3);\n        return HAL_TIMEOUT;\n      }\n      temp_var_2 = HAL_GetTick();\n    } while (temp_var_2 - temp_var_1 < 3);\n    return HAL_TIMEOUT;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08001b58": "initialize_rcc_08001b58",
                "RCC_OscInitStruct": "RCC_initialization_structure",
                "uVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "uVar3": "temp_var_3",
                "tmpreg": "temporary_register"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002008": {
            "entrypoint": "0x08002008",
            "current_name": "calculate_clock_frequency_08002008",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateClockFrequency_08002008(void)\n\n{\n  undefined4 tempVar1;\n  uint32_t clockFrequency;\n  undefined4 tempVar2;\n  undefined4 *pointerToPLLMULFactorTable;\n  uint predivFactor;\n  undefined4 *pointerToPredivFactorTable;\n  uint8_t predivFactorTable [2];\n  uint8_t PLLMULFactorTable [16];\n  \n  pointerToPLLMULFactorTable = &DAT_080072f0;\n  pointerToPredivFactorTable = (undefined4 *)PLLMULFactorTable;\n  do {\n    tempVar1 = *pointerToPLLMULFactorTable;\n    tempVar2 = pointerToPLLMULFactorTable[1];\n    pointerToPLLMULFactorTable = pointerToPLLMULFactorTable + 2;\n    *pointerToPredivFactorTable = tempVar1;\n    pointerToPredivFactorTable[1] = tempVar2;\n    pointerToPredivFactorTable = pointerToPredivFactorTable + 2;\n  } while (pointerToPLLMULFactorTable != (undefined4 *)\"../Src/MPU9250.c\");\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 8) {\n    if ((int)(_DAT_40021004 << 0xf) < 0) {\n      predivFactor = 8000000 / predivFactorTable[(_DAT_40021004 & 0x20000) >> 0x11];\n    }\n    else {\n      predivFactor = 4000000;\n    }\n    clockFrequency = predivFactor * PLLMULFactorTable[(_DAT_40021004 & 0x3c0000) >> 0x12];\n  }\n  else {\n    clockFrequency = 8000000;\n  }\n  return clockFrequency;\n}\n\n",
            "renaming": {
                "FUN_08002008": "calculate_clock_frequency_08002008",
                "uVar1": "tempVar1",
                "uVar2": "clockFrequency",
                "uVar3": "tempVar2",
                "puVar4": "pointerToPLLMULFactorTable",
                "uVar5": "predivFactor",
                "puVar6": "pointerToPredivFactorTable",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "PLLMULFactorTable"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800209c": {
            "entrypoint": "0x0800209c",
            "current_name": "initialize_rcc_0800209c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeRCC_0800209c(RCC_ClkInitTypeDef *rccClockConfig,uint32_t flashLatency)\n\n{\n  char tempVar1;\n  char tempVar2;\n  uint32_t sysClockFreq;\n  uint32_t tickValue;\n  uint sysClkSource;\n  \n  if ((flashLatency <= (_DAT_40022000 & 7)) ||\n     (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency, flashLatency == (flashLatency & 7))) {\n    if ((int)(rccClockConfig->ClockType << 0x1e) < 0) {\n      _DAT_40021004 = _DAT_40021004 & 0xffffff0f | rccClockConfig->AHBCLKDivider;\n    }\n    if (-1 < (int)(rccClockConfig->ClockType << 0x1f)) {\nLAB_080020ba:\n      if ((flashLatency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = _DAT_40022000 & 0xfffffff8 | flashLatency, flashLatency != (flashLatency & 7))) {\n        return HAL_ERROR;\n      }\n      if ((rccClockConfig->ClockType & 4) != 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | rccClockConfig->APB1CLKDivider;\n      }\n      if ((int)(rccClockConfig->ClockType << 0x1c) < 0) {\n        _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | rccClockConfig->APB2CLKDivider << 3;\n      }\n      sysClockFreq = HAL_RCC_GetSysClockFreq();\n      SystemCoreClock = sysClockFreq >> \"\"[(_DAT_40021004 & 0xf0) >> 4];\n      HAL_InitTick(0);\n      return HAL_OK;\n    }\n    sysClkSource = rccClockConfig->SYSCLKSource;\n    if (sysClkSource == 1) {\n      tempVar2 = '\\x01';\n      tempVar1 = '\\0';\n    }\n    else {\n      if (sysClkSource == 2) goto LAB_08002176;\n      tempVar2 = '\\0';\n      tempVar1 = '\\x01';\n    }\n    if ((int)((_DAT_40021000 >>\n              (LZCOUNT((uint)(byte)(tempVar1 << 6) << 0x18 | (uint)(byte)(tempVar2 << 6) << 8) & 0x1fU))\n             << 0x1f) < 0) {\nLAB_08002176:\n      _DAT_40021004 = _DAT_40021004 & 0xfffffffc | sysClkSource;\n      sysClockFreq = HAL_GetTick();\n      if (rccClockConfig->SYSCLKSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_080020ba;\n          tickValue = HAL_GetTick();\n        } while (tickValue - sysClockFreq < 0x1389);\n      }\n      else if (rccClockConfig->SYSCLKSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_080020ba;\n          tickValue = HAL_GetTick();\n        } while (tickValue - sysClockFreq < 0x1389);\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_080020ba;\n          tickValue = HAL_GetTick();\n        } while (tickValue - sysClockFreq < 0x1389);\n      }\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_0800209c": "initialize_rcc_0800209c",
                "RCC_ClkInitStruct": "rccClockConfig",
                "FLatency": "flashLatency",
                "cVar1": "tempVar1",
                "cVar2": "tempVar2",
                "uVar3": "sysClockFreq",
                "uVar4": "tickValue",
                "uVar5": "sysClkSource"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002214": {
            "entrypoint": "0x08002214",
            "current_name": "get_system_core_clock_08002214",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08002214(void)\n\n{\n  return currentClockSpeed;\n}\n\n",
            "renaming": {
                "FUN_08002214": "get_system_core_clock_08002214",
                "SystemCoreClock": "currentClockSpeed"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002220": {
            "entrypoint": "0x08002220",
            "current_name": "get_system_clock_frequency_08002220",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemClockFrequency_08002220(void)\n\n{\n  return systemClock >> \"\"[(_DAT_40021004 & 0x700) >> 8];\n}\n\n",
            "renaming": {
                "FUN_08002220": "get_system_clock_frequency_08002220",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002250": {
            "entrypoint": "0x08002250",
            "current_name": "get_adjusted_system_clock_08002250",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedSystemClock_08002250(void)\n\n{\n  return systemClock >> \"\"[(_DAT_40021004 & 0x3800) >> 0xb];\n}\n\n",
            "renaming": {
                "FUN_08002250": "get_adjusted_system_clock_08002250",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002280": {
            "entrypoint": "0x08002280",
            "current_name": "configure_timer_output_08002280",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutput_08002280(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint ocModeValue;\n  \n  timer->CCER = timer->CCER & 0xfffffffe;\n  cr2Value = timer->CR2;\n  ocModeValue = outputConfig->OCMode;\n  ccerValue = timer->CCER & 0xfffffffd | outputConfig->OCPolarity;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xfffffff7 | outputConfig->OCNPolarity) & 0xfffffffb;\n    cr2Value = cr2Value & 0xfffffcff | outputConfig->OCIdleState | outputConfig->OCNIdleState;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffffff8c | ocModeValue;\n  timer->CCR1 = outputConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002280": "configure_timer_output_08002280",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocModeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080022d0": {
            "entrypoint": "0x080022d0",
            "current_name": "configure_timer_output_080022d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutput_080022d0(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t ccerConfig;\n  uint32_t cr2Config;\n  uint ocMode;\n  \n  timer->ccerReg = timer->ccerReg & 0xfffffeff;\n  cr2Config = timer->cr2Reg;\n  ocMode = outputConfig->ocModeValue;\n  ccerConfig = timer->ccerReg & 0xfffffdff | outputConfig->ocPolarity << 8;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerConfig = (ccerConfig & 0xfffff7ff | outputConfig->ocNPolarity << 8) & 0xfffffbff;\n    cr2Config = cr2Config & 0xffffcfff | (outputConfig->ocIdleState | outputConfig->ocNIdleState) << 4;\n  }\n  timer->cr2Reg = cr2Config;\n  timer->ccmr2Reg = timer->ccmr2Reg & 0xffffff8c | ocMode;\n  timer->CCR3 = outputConfig->pulse;\n  timer->ccerReg = ccerConfig;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080022d0": "configure_timer_output_080022d0",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "ccerConfig",
                "uVar2": "cr2Config",
                "uVar3": "ocMode",
                "CCER": "ccerReg",
                "CR2": "cr2Reg",
                "OCMode": "ocModeValue",
                "OCPolarity": "ocPolarity",
                "OCNPolarity": "ocNPolarity",
                "OCIdleState": "ocIdleState",
                "OCNIdleState": "ocNIdleState",
                "CCMR2": "ccmr2Reg",
                "Pulse": "pulse"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002324": {
            "entrypoint": "0x08002324",
            "current_name": "configure_tim_08002324",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTIM_08002324(TIM_TypeDef *timer,TIM_OC_InitTypeDef *config)\n\n{\n  uint32_t cr2Register;\n  uint32_t ocMode;\n  uint32_t ocPolarity;\n  uint32_t ocIdleState;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  cr2Register = timer->CR2;\n  ocMode = config->OCMode;\n  ocPolarity = config->OCPolarity;\n  ocIdleState = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ocIdleState = config->OCIdleState;\n    cr2Register = cr2Register & 0xffffbfff;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    cr2Register = cr2Register | ocIdleState << 6;\n  }\n  timer->CR2 = cr2Register;\n  timer->CCMR2 = timer->CCMR2 & 0xffff8cff | ocMode << 8;\n  timer->CCR4 = config->Pulse;\n  timer->CCER = timer->CCER & 0xffffdfff | ocPolarity << 0xc;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002324": "configure_tim_08002324",
                "TIMx": "timer",
                "OC_Config": "config",
                "uVar1": "cr2Register",
                "uVar2": "ocMode",
                "uVar3": "ocPolarity",
                "uVar4": "ocIdleState"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002368": {
            "entrypoint": "0x08002368",
            "current_name": "initialize_timer_08002368",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08002368(TIM_TypeDef *timer,TIM_Base_InitTypeDef *initConfig)\n\n{\n  uint32_t tempValue;\n  \n  tempValue = timer->CR1;\n  if (((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n       (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) &&\n     (((tempValue = tempValue & 0xffffff8f | initConfig->CounterMode, timer == (TIM_TypeDef *)0x40012c00 ||\n       (timer == (TIM_TypeDef *)0x40000000)) ||\n      ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))))) {\n    tempValue = tempValue & 0xfffffcff | initConfig->ClockDivision;\n  }\n  timer->CR1 = tempValue;\n  timer->ARR = initConfig->Period;\n  timer->PSC = initConfig->Prescaler;\n  tempValue = 0x40012c00;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    tempValue = initConfig->RepetitionCounter;\n  }\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    timer->RCR = tempValue;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002368": "initialize_timer_08002368",
                "TIMx": "timer",
                "Structure": "initConfig",
                "uVar1": "tempValue"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023d0": {
            "entrypoint": "0x080023d0",
            "current_name": "initialize_timer_080023d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeTimer_080023d0(TIM_HandleTypeDef *timer)\n\n{\n  if (timer != (TIM_HandleTypeDef *)0x0) {\n    if (timer->State == timerStateReset) {\n      timer->Lock = timerUnlocked;\n      HAL_TIM_PWM_MspInit(timer);\n    }\n    timer->State = timerStateBusy;\n    setTimerConfig(timer->Instance,&timer->Init);\n    timer->State = timerStateReady;\n    return success;\n  }\n  return error;\n}\n\n",
            "renaming": {
                "FUN_080023d0": "initialize_timer_080023d0",
                "htim": "timer",
                "HAL_TIM_STATE_RESET": "timerStateReset",
                "HAL_UNLOCKED": "timerUnlocked",
                "HAL_TIM_STATE_BUSY": "timerStateBusy",
                "HAL_TIM_STATE_READY": "timerStateReady",
                "TIM_Base_SetConfig": "setTimerConfig",
                "HAL_OK": "success",
                "HAL_ERROR": "error"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_Base_SetConfig",
                "HAL_TIM_PWM_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002404": {
            "entrypoint": "0x08002404",
            "current_name": "configure_timer_output_08002404",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureTimerOutput_08002404(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t ccerValue;\n  uint32_t cr2Value;\n  uint32_t ocModeValue;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  cr2Value = timer->CR2;\n  ocModeValue = outputConfig->OCMode;\n  ccerValue = timer->CCER & 0xffffffdf | outputConfig->OCPolarity << 4;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ccerValue = (ccerValue & 0xffffff7f | outputConfig->OCNPolarity << 4) & 0xffffffbf;\n    cr2Value = cr2Value & 0xfffff3ff | (outputConfig->OCIdleState | outputConfig->OCNIdleState) << 2;\n  }\n  timer->CR2 = cr2Value;\n  timer->CCMR1 = timer->CCMR1 & 0xffff8cff | ocModeValue << 8;\n  timer->CCR2 = outputConfig->Pulse;\n  timer->CCER = ccerValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002404": "configure_timer_output_08002404",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "uVar1": "ccerValue",
                "uVar2": "cr2Value",
                "uVar3": "ocModeValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800245c": {
            "entrypoint": "0x0800245c",
            "current_name": "configure_oc_0800245c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureOC_0800245c(TIM_HandleTypeDef *timer,TIM_OC_InitTypeDef *config,uint32_t channel)\n\n{\n  int extra1;\n  int extra2;\n  int extra3;\n  uint value1;\n  int extra4;\n  int value2;\n  uint32_t value3;\n  TIM_TypeDef *timerInstance;\n  \n  if (timer->Lock == HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  timer->State = HAL_TIM_STATE_BUSY;\n  timer->Lock = HAL_LOCKED;\n  switch(channel) {\n  case 0:\n    TIM_OC1_SetConfig(timer->Instance,config);\n    timerInstance = timer->Instance;\n    value1 = *(uint *)(extra1 + 0x10);\n    timerInstance->CCMR1 = timerInstance->CCMR1 | 8;\n    timerInstance->CCMR1 = timerInstance->CCMR1 & 0xfffffffb;\n    value3 = timerInstance->CCMR1 | value1;\n    break;\n  default:\n    goto switchD_0800247a_caseD_1;\n  case 4:\n    TIM_OC2_SetConfig(timer->Instance,config);\n    timerInstance = timer->Instance;\n    value2 = *(int *)(extra2 + 0x10);\n    timerInstance->CCMR1 = timerInstance->CCMR1 | 0x800;\n    timerInstance->CCMR1 = timerInstance->CCMR1 & 0xfffffbff;\n    value3 = timerInstance->CCMR1 | value2 << 8;\n    break;\n  case 8:\n    TIM_OC3_SetConfig(timer->Instance,config);\n    timerInstance = timer->Instance;\n    value1 = *(uint *)(extra3 + 0x10);\n    timerInstance->CCMR2 = timerInstance->CCMR2 | 8;\n    timerInstance->CCMR2 = timerInstance->CCMR2 & 0xfffffffb;\n    value3 = timerInstance->CCMR2 | value1;\n    goto LAB_080024fa;\n  case 0xc:\n    TIM_OC4_SetConfig(timer->Instance,config);\n    timerInstance = timer->Instance;\n    value2 = *(int *)(extra4 + 0x10);\n    timerInstance->CCMR2 = timerInstance->CCMR2 | 0x800;\n    timerInstance->CCMR2 = timerInstance->CCMR2 & 0xfffffbff;\n    value3 = timerInstance->CCMR2 | value2 << 8;\nLAB_080024fa:\n    timerInstance->CCMR2 = value3;\n    goto switchD_0800247a_caseD_1;\n  }\n  timerInstance->CCMR1 = value3;\nswitchD_0800247a_caseD_1:\n  timer->State = HAL_TIM_STATE_READY;\n  timer->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800245c": "configure_oc_0800245c",
                "htim": "timer",
                "sConfig": "config",
                "Channel": "channel",
                "extraout_r1": "extra1",
                "extraout_r1_00": "extra2",
                "extraout_r1_01": "extra3",
                "extraout_r1_02": "extra4",
                "uVar1": "value1",
                "uVar3": "value3",
                "iVar2": "value2",
                "pTVar4": "timerInstance"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002520": {
            "entrypoint": "0x08002520",
            "current_name": "configure_channel_08002520",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureChannel_08002520(TIM_TypeDef *timer,uint32_t channelNumber,uint32_t channelState)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channelNumber & 0xff));\n  timer->CCER = channelState << (channelNumber & 0xff) | timer->CCER;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002520": "configure_channel_08002520",
                "TIMx": "timer",
                "Channel": "channelNumber",
                "ChannelState": "channelState"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002538": {
            "entrypoint": "0x08002538",
            "current_name": "configure_timer_channel_08002538",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimerChannel_08002538(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  uint32_t updatedValue;\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,1);\n  timerInstance = timerHandle->Instance;\n  updatedValue = 0x40012c00;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    updatedValue = uRam40012c44 | 0x8000;\n  }\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    timerInstance->BDTR = updatedValue;\n  }\n  timerInstance->CR1 = timerInstance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002538": "configure_timer_channel_08002538",
                "htim": "timerHandle",
                "Channel": "channel",
                "uVar1": "updatedValue",
                "pTVar2": "timerInstance"
            },
            "calling": [
                "PWM_Init"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002564": {
            "entrypoint": "0x08002564",
            "current_name": "configure_break_dead_time_08002564",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nconfigureBreakDeadTime_08002564(TIM_HandleTypeDef *timer,TIM_BreakDeadTimeConfigTypeDef *breakDeadTimeConfig)\n\n{\n  HAL_StatusTypeDef status;\n  \n  status = HAL_BUSY;\n  if (timer->Lock != HAL_LOCKED) {\n    timer->State = HAL_TIM_STATE_BUSY;\n    timer->Instance->BDTR =\n         breakDeadTimeConfig->OffStateRunMode | breakDeadTimeConfig->OffStateIDLEMode |\n         breakDeadTimeConfig->LockLevel | breakDeadTimeConfig->DeadTime |\n         breakDeadTimeConfig->BreakState | breakDeadTimeConfig->BreakPolarity |\n         breakDeadTimeConfig->AutomaticOutput;\n    timer->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timer->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002564": "configure_break_dead_time_08002564",
                "htim": "timer",
                "sBreakDeadTimeConfig": "breakDeadTimeConfig",
                "HVar1": "status"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025a4": {
            "entrypoint": "0x080025a4",
            "current_name": "configure_timer_080025a4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureTimer_080025a4(TIM_HandleTypeDef *timerHandle,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  uint masterSlaveMode;\n  HAL_StatusTypeDef status;\n  TIM_TypeDef *timerInstance;\n  uint masterOutputTrigger;\n  \n  status = HAL_BUSY;\n  if (timerHandle->Lock != HAL_LOCKED) {\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerInstance = timerHandle->Instance;\n    masterOutputTrigger = masterConfig->MasterOutputTrigger;\n    masterSlaveMode = masterConfig->MasterSlaveMode;\n    timerInstance->CR2 = timerInstance->CR2 & 0xffffff8f;\n    timerInstance->CR2 = timerInstance->CR2 | masterOutputTrigger;\n    timerInstance->SMCR = timerInstance->SMCR & 0xffffff7f;\n    timerInstance->SMCR = timerInstance->SMCR | masterSlaveMode;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n    timerHandle->Lock = HAL_UNLOCKED;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080025a4": "configure_timer_080025a4",
                "htim": "timerHandle",
                "sMasterConfig": "masterConfig",
                "HVar2": "status",
                "pTVar3": "timerInstance",
                "uVar1": "masterSlaveMode",
                "uVar4": "masterOutputTrigger"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e8": {
            "entrypoint": "0x080025e8",
            "current_name": "configure_usart_080025e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureUSART_080025e8(UART_HandleTypeDef *uartHandler)\n\n{\n  uint32_t pclkFreq;\n  uint32_t tempVar1;\n  uint parity;\n  int baudRateDivisor;\n  uint32_t baudRate;\n  int brrMantissa;\n  USART_TypeDef *usart;\n  \n  usart = uartHandler->Instance;\n  parity = (uartHandler->Init).Parity;\n  usart->CR2 = usart->CR2 & 0xffffcfff | (uartHandler->Init).StopBits;\n  usart->CR1 = (uartHandler->Init).WordLength | parity | (uartHandler->Init).Mode | usart->CR1 & 0xffffe9f3;\n  usart->CR3 = usart->CR3 & 0xfffffcff | (uartHandler->Init).HwFlowCtl;\n  if (usart == (USART_TypeDef *)0x40013800) {\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n    baudRateDivisor = (int)(((ulonglong)(pclkFreq * 0x19) / (ulonglong)((uartHandler->Init).BaudRate << 2)) / 100);\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n    baudRate = (uartHandler->Init).BaudRate;\n    tempVar1 = HAL_RCC_GetPCLK2Freq();\n    brrMantissa = (pclkFreq * 0x19) / (baudRate << 2) +\n            (int)(((ulonglong)(tempVar1 * 0x19) / (ulonglong)((uartHandler->Init).BaudRate << 2)) / 100) *\n            -100;\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n    parity = (pclkFreq * 0x19) / ((uartHandler->Init).BaudRate << 2);\n    pclkFreq = HAL_RCC_GetPCLK2Freq();\n  }\n  else {\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    baudRateDivisor = (int)(((ulonglong)(pclkFreq * 0x19) / (ulonglong)((uartHandler->Init).BaudRate << 2)) / 100);\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    baudRate = (uartHandler->Init).BaudRate;\n    tempVar1 = HAL_RCC_GetPCLK1Freq();\n    brrMantissa = (pclkFreq * 0x19) / (baudRate << 2) +\n            (int)(((ulonglong)(tempVar1 * 0x19) / (ulonglong)((uartHandler->Init).BaudRate << 2)) / 100) *\n            -100;\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n    parity = (pclkFreq * 0x19) / ((uartHandler->Init).BaudRate << 2);\n    pclkFreq = HAL_RCC_GetPCLK1Freq();\n  }\n  usart->BRR = (((parity + (int)(((ulonglong)(pclkFreq * 0x19) /\n                                 (ulonglong)((uartHandler->Init).BaudRate << 2)) / 100) * -100) * 0x10 +\n                 0x32) / 100 & 0xf | (brrMantissa * 0x10 + 0x32U) / 100 & 0xf0) + baudRateDivisor * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080025e8": "configure_usart_080025e8",
                "huart": "uartHandler",
                "uVar1": "pclkFreq",
                "uVar2": "tempVar1",
                "uVar3": "parity",
                "iVar4": "baudRateDivisor",
                "uVar5": "baudRate",
                "iVar6": "brrMantissa",
                "pUVar7": "usart"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002724": {
            "entrypoint": "0x08002724",
            "current_name": "configure_uart_08002724",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHalStatus configureUart_08002724(UartHandle *uartHandle)\n\n{\n  UartInstance *USART_Instance;\n  \n  if (uartHandle != (UartHandle *)0x0) {\n    if (uartHandle->State == HAL_UART_STATE_RESET) {\n      uartHandle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->State = HAL_UART_STATE_BUSY;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    USART_Instance = uartHandle->Instance;\n    USART_Instance->CR2 = USART_Instance->CR2 & 0xffffb7ff;\n    USART_Instance->CR3 = USART_Instance->CR3 & 0xffffffd5;\n    USART_Instance->CR1 = USART_Instance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->State = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002724": "configure_uart_08002724",
                "huart": "uartHandle",
                "pUVar1": "USART_Instance",
                "USART_TypeDef": "UartInstance",
                "UART_HandleTypeDef": "UartHandle",
                "HAL_StatusTypeDef": "HalStatus"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800277c": {
            "entrypoint": "0x0800277c",
            "current_name": "transmit_data_0800277c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ntransmitData_0800277c(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t size,uint32_t timeout)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  HAL_UART_StateTypeDef uartState;\n  USART_TypeDef *uartInstance;\n  uint16_t *temp;\n  \n  if ((uartHandle->State == HAL_UART_STATE_READY) || (uartHandle->State == HAL_UART_STATE_BUSY_RX)) {\n    if ((data == (uint8_t *)0x0) || (size == 0)) {\n      return HAL_ERROR;\n    }\n    if (uartHandle->Lock != HAL_LOCKED) {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->TxXfersize = size;\n      if (uartHandle->State == HAL_UART_STATE_BUSY_RX) {\n        uartState = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uartState = HAL_UART_STATE_BUSY_TX;\n      }\n      uartHandle->TxXferCount = size;\n      uartHandle->State = uartState;\nLAB_080027c4:\n      if (uartHandle->TxXferCount == 0) {\n        uVar1 = HAL_GetTick();\n        do {\n          do {\n            if ((int)(uartHandle->Instance->SR << 0x19) < 0) {\n              if (uartHandle->State == HAL_UART_STATE_BUSY_TX_RX) {\n                uartState = HAL_UART_STATE_BUSY_RX;\n              }\n              else {\n                uartState = HAL_UART_STATE_READY;\n              }\n              uartHandle->State = uartState;\n              uartHandle->Lock = HAL_UNLOCKED;\n              return HAL_OK;\n            }\n          } while (timeout == 0xffffffff);\n        } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n      }\n      else {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          uVar1 = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uartHandle->Instance->SR << 0x18) < 0) {\n                uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n                if ((uartHandle->Init).Parity == 0) {\n                  data = (uint8_t *)((int)data + 2);\n                }\n                else {\nLAB_08002812:\n                  data = (uint8_t *)((int)data + 1);\n                }\n                goto LAB_080027c4;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n        }\n        else {\n          uVar1 = HAL_GetTick();\n          do {\n            do {\n              if ((int)(uartHandle->Instance->SR << 0x18) < 0) {\n                uartHandle->Instance->DR = (uint)*data;\n                goto LAB_08002812;\n              }\n            } while (timeout == 0xffffffff);\n          } while ((timeout != 0) && (uVar2 = HAL_GetTick(), uVar2 - uVar1 <= timeout));\n        }\n      }\n      uartInstance = uartHandle->Instance;\n      uartInstance->CR1 = uartInstance->CR1 & 0xffffff7f;\n      uartInstance->CR1 = uartInstance->CR1 & 0xffffffdf;\n      uartInstance->CR1 = uartInstance->CR1 & 0xfffffeff;\n      uartInstance->CR3 = uartInstance->CR3 & 0xfffffffe;\n      uartHandle->State = HAL_UART_STATE_READY;\n      uartHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_0800277c": "transmit_data_0800277c",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "size",
                "Timeout": "timeout",
                "HVar3": "uartState",
                "pUVar4": "uartInstance",
                "tmp": "temp"
            },
            "calling": [
                "serialWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028a6": {
            "entrypoint": "0x080028a6",
            "current_name": "initialize_uart_transfer_080028a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUARTTransfer_080028a6(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t bufferSize)\n\n{\n  HAL_UART_StateTypeDef uartState;\n  uint tempVar;\n  USART_TypeDef *uartInstance;\n  \n  if ((uartHandle->State == HAL_UART_STATE_READY) || (uartHandle->State == HAL_UART_STATE_BUSY_TX)) {\n    if ((dataBuffer == (uint8_t *)0x0) || (bufferSize == 0)) {\n      return HAL_ERROR;\n    }\n    if (uartHandle->Lock != HAL_LOCKED) {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->RxXferbufferSize = bufferSize;\n      uartHandle->RxXferCount = bufferSize;\n      uartHandle->Lock = HAL_UNLOCKED;\n      if (uartHandle->State == HAL_UART_STATE_BUSY_TX) {\n        uartState = HAL_UART_STATE_BUSY_TX_RX;\n      }\n      else {\n        uartState = HAL_UART_STATE_BUSY_RX;\n      }\n      uartInstance = uartHandle->Instance;\n      uartHandle->State = uartState;\n      tempVar = uartInstance->CR1;\n      uartHandle->pRxBuffPtr = dataBuffer;\n      uartInstance->CR1 = tempVar | 0x100;\n      uartInstance->CR3 = uartInstance->CR3 | 1;\n      uartInstance->CR1 = uartInstance->CR1 | 0x20;\n      return HAL_OK;\n    }\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_080028a6": "initialize_uart_transfer_080028a6",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "bufferSize",
                "HVar1": "uartState",
                "uVar2": "tempVar",
                "pUVar3": "uartInstance"
            },
            "calling": [
                "HAL_UART_RxCpltCallback",
                "serialBegin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800290a": {
            "entrypoint": "0x0800290a",
            "current_name": "FUNC_0800290a",
            "code": "\nvoid FUNC_0800290a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800290a": "FUNC_0800290a"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800290c": {
            "entrypoint": "0x0800290c",
            "current_name": "process_received_data_0800290c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processReceivedData_0800290c(UART_HandleTypeDef *uartHandler)\n\n{\n  uint32_t parity;\n  byte receivedByte;\n  USART_TypeDef *uartInstance;\n  uint16_t remainingBytes;\n  ushort *rxBufferPtr;\n  uint16_t *tempPtr;\n  ushort *newRxBufferPtr;\n  bool isBusy;\n  \n  if ((uartHandler->State & 0xef) != 0x22) {\n    return HAL_BUSY;\n  }\n  parity = (uartHandler->Init).Parity;\n  uartInstance = uartHandler->Instance;\n  rxBufferPtr = (ushort *)uartHandler->pRxBuffPtr;\n  if ((uartHandler->Init).WordLength == 0x1000) {\n    if (parity == 0) {\n      newRxBufferPtr = rxBufferPtr + 1;\n      *rxBufferPtr = (ushort)((uartInstance->DR << 0x17) >> 0x17);\n    }\n    else {\n      newRxBufferPtr = (ushort *)((int)rxBufferPtr + 1);\n      *rxBufferPtr = (ushort)uartInstance->DR & 0xff;\n    }\n    uartHandler->pRxBuffPtr = (uint8_t *)newRxBufferPtr;\n  }\n  else {\n    if (parity == 0) {\n      receivedByte = (byte)uartInstance->DR;\n      uartHandler->pRxBuffPtr = (uint8_t *)((int)rxBufferPtr + 1);\n    }\n    else {\n      parity = uartInstance->DR;\n      uartHandler->pRxBuffPtr = (uint8_t *)((int)rxBufferPtr + 1);\n      receivedByte = (byte)parity & 0x7f;\n    }\n    *(byte *)rxBufferPtr = receivedByte;\n  }\n  remainingBytes = uartHandler->RxXferCount - 1;\n  uartHandler->RxXferCount = remainingBytes;\n  if (remainingBytes == 0) {\n    uartInstance = uartHandler->Instance;\n    uartInstance->CR1 = uartInstance->CR1 & 0xffffffdf;\n    isBusy = uartHandler->State != HAL_UART_STATE_BUSY_TX_RX;\n    if (isBusy) {\n      parity = uartInstance->CR1 & 0xfffffeff;\n    }\n    else {\n      uartInstance = (USART_TypeDef *)0x12;\n      parity = 0x32;\n    }\n    if (isBusy) {\n      uartInstance->CR1 = parity;\n      parity = uartInstance->CR3 & 0xfffffffe;\n    }\n    if (isBusy) {\n      uartInstance->CR3 = parity;\n      uartInstance = (USART_TypeDef *)0x1;\n    }\n    uartHandler->State = (HAL_UART_StateTypeDef)uartInstance;\n    HAL_UART_RxCpltCallback(uartHandler);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800290c": "process_received_data_0800290c",
                "huart": "uartHandler",
                "uVar1": "parity",
                "bVar2": "receivedByte",
                "pUVar3": "uartInstance",
                "uVar4": "remainingBytes",
                "puVar5": "rxBufferPtr",
                "tmp": "tempPtr",
                "puVar6": "newRxBufferPtr",
                "bVar7": "isBusy"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002998": {
            "entrypoint": "0x08002998",
            "current_name": "FUNC_08002998",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002998(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002998": "FUNC_08002998"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800299a": {
            "entrypoint": "0x0800299a",
            "current_name": "handle_uart_interrupt_0800299a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_0800299a(UART_HandleTypeDef *uart_handle)\n\n{\n  uint status_reg;\n  uint32_t status_reg_copy;\n  uint16_t data_reg;\n  uint status;\n  uint32_t interrupt_status;\n  ushort *tx_buffer_ptr;\n  uint16_t *tx_buffer_ptr_tmp;\n  HAL_UART_StateTypeDef uart_state;\n  USART_TypeDef *uart_instance;\n  uint32_t tmp_error;\n  uint32_t tmp_cr3;\n  uint tmp_cr3_copy;\n  bool parity_error;\n  \n  uart_instance = uart_handle->Instance;\n  status = uart_instance->SR;\n  status_reg = uart_instance->CR1;\n  if ((status & 0xf) == 0) {\n    if (((int)(status << 0x1a) < 0) && ((int)(status_reg << 0x1a) < 0)) {\n      UART_Receive_IT(uart_handle);\n      return;\n    }\n  }\n  else {\n    tmp_cr3_copy = uart_instance->CR3 & 1;\n    if ((tmp_cr3_copy != 0) || ((status_reg & 0x120) != 0)) {\n      tmp_error = status << 0x1f;\n      if ((int)tmp_error < 0) {\n        parity_error = (int)(status_reg << 0x17) < 0;\n        if (parity_error) {\n          tmp_error = uart_handle->ErrorCode | 1;\n        }\n        if (parity_error) {\n          uart_handle->ErrorCode = tmp_error;\n        }\n      }\n      if (((int)(status << 0x1d) < 0) && (tmp_cr3_copy != 0)) {\n        uart_handle->ErrorCode = uart_handle->ErrorCode | 2;\n      }\n      if (((int)(status << 0x1e) < 0) && (tmp_cr3_copy != 0)) {\n        uart_handle->ErrorCode = uart_handle->ErrorCode | 4;\n      }\n      if (((int)(status << 0x1c) < 0) && (tmp_cr3_copy != 0)) {\n        uart_handle->ErrorCode = uart_handle->ErrorCode | 8;\n      }\n      if (uart_handle->ErrorCode == 0) {\n        return;\n      }\n      if (((int)(status << 0x1a) < 0) && ((int)(status_reg << 0x1a) < 0)) {\n        UART_Receive_IT(uart_handle);\n      }\n      uart_instance = uart_handle->Instance;\n      if ((-1 < (int)(uart_handle->ErrorCode << 0x1c)) && ((uart_instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handle);\n        uart_handle->ErrorCode = 0;\n        return;\n      }\n      uart_instance->CR1 = uart_instance->CR1 & 0xfffffedf;\n      uart_instance->CR3 = uart_instance->CR3 & 0xfffffffe;\n      uart_handle->State = HAL_UART_STATE_READY;\n      HAL_UART_ErrorCallback(uart_handle);\n      return;\n    }\n  }\n  if (((int)(status << 0x18) < 0) && ((int)(status_reg << 0x18) < 0)) {\n    if ((uart_handle->State & 0xdf) == 0x12) {\n      tx_buffer_ptr = (ushort *)uart_handle->pTxBuffPtr;\n      if ((uart_handle->Init).WordLength == 0x1000) {\n        uart_instance->DR = *tx_buffer_ptr & 0x1ff;\n        if ((uart_handle->Init).Parity == 0) {\n          tx_buffer_ptr = tx_buffer_ptr + 1;\n        }\n        else {\n          tx_buffer_ptr = (ushort *)((int)tx_buffer_ptr + 1);\n        }\n        uart_handle->pTxBuffPtr = (uint8_t *)tx_buffer_ptr;\n      }\n      else {\n        uart_handle->pTxBuffPtr = (byte *)((int)tx_buffer_ptr + 1);\n        uart_instance->DR = (uint)*(byte *)tx_buffer_ptr;\n      }\n      data_reg = uart_handle->TxXferCount - 1;\n      uart_handle->TxXferCount = data_reg;\n      if (data_reg == 0) {\n        uart_instance->CR1 = uart_instance->CR1 & 0xffffff7f;\n        uart_instance->CR1 = uart_instance->CR1 | 0x40;\n        return;\n      }\n    }\n  }\n  else if (((int)(status << 0x19) < 0) && ((int)(status_reg << 0x19) < 0)) {\n    uart_instance->CR1 = uart_instance->CR1 & 0xffffffbf;\n    if (uart_handle->State == HAL_UART_STATE_BUSY_TX_RX) {\n      uart_state = HAL_UART_STATE_BUSY_RX;\n    }\n    else {\n      uart_state = HAL_UART_STATE_READY;\n    }\n    uart_handle->State = uart_state;\n    HAL_UART_TxCpltCallback(uart_handle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800299a": "handle_uart_interrupt_0800299a",
                "huart": "uart_handle",
                "uVar1": "status_reg",
                "cr1its": "status_reg_copy",
                "uVar2": "data_reg",
                "uVar3": "status",
                "isrflags": "interrupt_status",
                "puVar4": "tx_buffer_ptr",
                "tmp": "tx_buffer_ptr_tmp",
                "HVar5": "uart_state",
                "pUVar6": "uart_instance",
                "uVar7": "tmp_error",
                "cr3its": "tmp_cr3",
                "uVar8": "tmp_cr3_copy",
                "bVar9": "parity_error"
            },
            "calling": [
                "USART1_IRQHandler"
            ],
            "called": [
                "HAL_UART_ErrorCallback",
                "HAL_UART_TxCpltCallback",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad0": {
            "entrypoint": "0x08002ad0",
            "current_name": "initialize_mpu9250_08002ad0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMPU9250_08002ad0(void)\n\n{\n  I2C_ReadByte(0xd0,0x75,\"../Src/MPU9250.c\",0x3b);\n  I2C_WriteByte(0xd0,0x6b,0x80,'\\x01');\n  I2C_WriteByte(0xd0,0x6b,'\\x01','\\x01');\n  I2C_WriteByte(0xd0,0x6c,'\\0','\\x01');\n  I2C_WriteByte(0xd0,0x19,'\\0','\\x01');\n  I2C_WriteByte(0xd0,0x1d,'\\x03','\\x01');\n  I2C_WriteByte(0xd0,0x1a,'\\x03','\\x01');\n  I2C_WriteByte(0xd0,0x1b,'\\x10','\\x01');\n  I2C_WriteByte(0xd0,0x1c,'\\b','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ad0": "initialize_mpu9250_08002ad0"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "I2C_WriteByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b48": {
            "entrypoint": "0x08002b48",
            "current_name": "read_accelerometer_data_08002b48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAccelerometerData_08002b48(void)\n\n{\n  undefined4 tempVar3;\n  uint inputValue;\n  int tempVar1;\n  int tempVar2;\n  uint8_t dataBuffer [6];\n  \n  dataBuffer[0] = '\\0';\n  dataBuffer[1] = '\\0';\n  dataBuffer[2] = '\\0';\n  dataBuffer[3] = '\\0';\n  stackVar = inputValue & 0xffff0000;\n  I2C_ReadByteArray(0xd0,0x3b,dataBuffer,6,\"../Src/MPU9250.c\",0x58);\n  accelerationRaw.y = CONCAT11(dataBuffer[2],dataBuffer[3]);\n  accelerationRaw.x = CONCAT11(dataBuffer[0],dataBuffer[1]);\n  accelerationRaw.z = CONCAT11(dataBuffer[4],dataBuffer[5]);\n  tempVar2 = (int)accelerationRaw.y;\n  tempVar1 = (int)accelerationRaw.z;\n  tempVar3 = __floatsisf();\n  tempVar3 = __aeabi_fmul(tempVar3,0x40800000);\n  accelerationData.x = (float)__aeabi_fmul(tempVar3,0x38000000);\n  tempVar3 = __floatsisf(tempVar2);\n  tempVar3 = __aeabi_fmul(tempVar3,0x40800000);\n  accelerationData.y = (float)__aeabi_fmul(tempVar3,0x38000000);\n  tempVar3 = __floatsisf(tempVar1);\n  tempVar3 = __aeabi_fmul(tempVar3,0x40800000);\n  accelerationData.z = (float)__aeabi_fmul(tempVar3,0x38000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002b48": "read_accelerometer_data_08002b48",
                "in_r3": "inputValue",
                "iVar2": "tempVar1",
                "iVar3": "tempVar2",
                "raw_data": "dataBuffer",
                "stack0xffffffec": "stackVar",
                "accelRaw": "accelerationRaw",
                "accelData": "accelerationData",
                "uVar1": "tempVar3"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bf0": {
            "entrypoint": "0x08002bf0",
            "current_name": "read_and_process_gyro_data_08002bf0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndProcessGyroData_08002bf0(void)\n\n{\n  undefined4 gyroScaledData;\n  int gyroRawData_Z;\n  int gyroRawData_Y;\n  uint8_t gyroRawData [6];\n  \n  gyroRawData[0] = '\\0';\n  gyroRawData[1] = '\\0';\n  gyroRawData[2] = '\\0';\n  gyroRawData[3] = '\\0';\n  gyroRawData[4] = '\\0';\n  gyroRawData[5] = '\\0';\n  readI2CByteArray(0xd0,0x43,gyroRawData,6,\"../Src/MPU9250.c\",0x7b);\n  gyroDataRaw.y = CONCAT11(gyroRawData[2],gyroRawData[3]);\n  gyroDataRaw.x = CONCAT11(gyroRawData[0],gyroRawData[1]);\n  gyroDataRaw.z = CONCAT11(gyroRawData[4],gyroRawData[5]);\n  gyroRawData_Y = (int)gyroDataRaw.y;\n  gyroRawData_Z = (int)gyroDataRaw.z;\n  gyroScaledData = __floatsisf();\n  gyroScaledData = __aeabi_fmul(gyroScaledData,0x447a0000);\n  gyroScaledData = __aeabi_fmul(gyroScaledData,0x38000000);\n  processedGyroData.x = (float)__aeabi_fsub(gyroScaledData,gyroBias.x);\n  gyroScaledData = __floatsisf(gyroRawData_Y);\n  gyroScaledData = __aeabi_fmul(gyroScaledData,0x447a0000);\n  gyroScaledData = __aeabi_fmul(gyroScaledData,0x38000000);\n  processedGyroData.y = (float)__aeabi_fsub(gyroScaledData,gyroBias.y);\n  gyroScaledData = __floatsisf(gyroRawData_Z);\n  gyroScaledData = __aeabi_fmul(gyroScaledData,0x447a0000);\n  gyroScaledData = __aeabi_fmul(gyroScaledData,0x38000000);\n  processedGyroData.z = (float)__aeabi_fsub(gyroScaledData,gyroBias.z);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002bf0": "read_and_process_gyro_data_08002bf0",
                "raw_data": "gyroRawData",
                "I2C_ReadByteArray": "readI2CByteArray",
                "gyroRaw": "gyroDataRaw",
                "gyroData": "processedGyroData",
                "iVar2": "gyroRawData_Z",
                "iVar3": "gyroRawData_Y",
                "uVar1": "gyroScaledData"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cb0": {
            "entrypoint": "0x08002cb0",
            "current_name": "calibrate_magnetometer_08002cb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calibrateMagnetometer_08002cb0(void)\n\n{\n  undefined4 result;\n  uint data;\n  uint8_t readings [3];\n  \n  rawData = data;\n  I2C_WriteByte(0xd0,0x37,'\\\"','\\x01');\n  I2C_WriteByte(0xd0,0x6a,'\\x01','\\x01');\n  I2C_ReadByte(0x18,0,\"../Src/MPU9250.c\",0xad);\n  I2C_WriteByte(0x18,0xb,'\\x01','\\x01');\n  I2C_WriteByte(0x18,10,'\\0','\\x01');\n  I2C_WriteByte(0x18,10,'\\x0f','\\x01');\n  I2C_ReadByteArray(0x18,0x10,readings,3,\"../Src/MPU9250.c\",0xb6);\n  result = __floatsisf((rawData & 0xff) - 0x80);\n  result = __aeabi_fmul(result,0x3b800000);\n  magCalib.x = (float)__addsf3(result,0x3f800000);\n  result = __floatsisf((rawData >> 8 & 0xff) - 0x80);\n  result = __aeabi_fmul(result,0x3b800000);\n  magCalib.y = (float)__addsf3(result,0x3f800000);\n  result = __floatsisf(readings[2] - 0x80);\n  result = __aeabi_fmul(result,0x3b800000);\n  magCalib.z = (float)__addsf3(result,0x3f800000);\n  I2C_WriteByte(0x18,10,'\\0','\\x01');\n  I2C_WriteByte(0x18,10,'\\x16','\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002cb0": "calibrate_magnetometer_08002cb0",
                "in_r3": "data",
                "_rawData": "rawData",
                "uVar1": "result",
                "rawData": "readings"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [
                "I2C_ReadByte",
                "__addsf3",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d88": {
            "entrypoint": "0x08002d88",
            "current_name": "read_magnetometer_data_08002d88",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readMagnetometerData_08002d88(void)\n\n{\n  float fVar1;\n  byte byteValue;\n  undefined4 uVar3;\n  undefined4 device;\n  int iVar4;\n  int iVar5;\n  int16_t axisX;\n  undefined axisYh;\n  undefined axisYl;\n  undefined axisZh;\n  undefined axisZl;\n  uint8_t overflow;\n  undefined uStack_21;\n  \n  uStack_21 = (undefined)((uint)device >> 0x18);\n  axisX = 0;\n  axisYh = 0;\n  axisYl = 0;\n  axisZh = 0;\n  axisZl = 0;\n  overflow = '\\0';\n  byteValue = readByteFromI2C(0x18,2,\"../Src/MPU9250.c\",0xd7);\n  if ((int)((uint)byteValue << 0x1f) < 0) {\n    readByteArrayFromI2C(0x18,3,(uint8_t *)&axisX,7,\"../Src/MPU9250.c\",0xda);\n    fVar1 = magneticResolution;\n    if ((int)((uint)overflow << 0x1c) < 0) {\n      i2cErrorsCount = i2cErrorsCount + 1;\n    }\n    else {\n      rawMagnetometerY = CONCAT11(axisYl,axisYh);\n      rawMagnetometerZ = CONCAT11(axisZl,axisZh);\n      iVar5 = (int)rawMagnetometerY;\n      iVar4 = (int)rawMagnetometerZ;\n      rawMagnetometerX = axisX;\n      uVar3 = intToFloat();\n      uVar3 = multiplyFloats(uVar3,fVar1);\n      uVar3 = multiplyFloats(uVar3,calibratedMagnetometerX);\n      uVar3 = subtractFloats(uVar3,magnetometerBiasX);\n      magnetometerDataX = (float)multiplyFloats(uVar3,magnetometerScaleX);\n      uVar3 = intToFloat(iVar5);\n      uVar3 = multiplyFloats(uVar3,fVar1);\n      uVar3 = multiplyFloats(uVar3,calibratedMagnetometerY);\n      uVar3 = subtractFloats(uVar3,magnetometerBiasY);\n      magnetometerDataY = (float)multiplyFloats(uVar3,magnetometerScaleY);\n      uVar3 = intToFloat(iVar4);\n      uVar3 = multiplyFloats(uVar3,fVar1);\n      uVar3 = multiplyFloats(uVar3,calibratedMagnetometerZ);\n      uVar3 = subtractFloats(uVar3,magnetometerBiasZ);\n      magnetometerDataZ = (float)multiplyFloats(uVar3,magnetometerScaleZ);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d88": "read_magnetometer_data_08002d88",
                "in_r3": "device",
                "local_28": "axisX",
                "uStack_26": "axisYh",
                "uStack_25": "axisYl",
                "local_24": "axisZh",
                "local_23": "axisZl",
                "OVF": "overflow",
                "bVar2": "byteValue",
                "I2C_ReadByte": "readByteFromI2C",
                "I2C_ReadByteArray": "readByteArrayFromI2C",
                "mRes": "magneticResolution",
                "msp_txf_status.i2c_errors_count": "i2cErrorsCount",
                "magRaw.y": "rawMagnetometerY",
                "magRaw.z": "rawMagnetometerZ",
                "magRaw.x": "rawMagnetometerX",
                "magCalib.x": "calibratedMagnetometerX",
                "magBias.x": "magnetometerBiasX",
                "magScale.x": "magnetometerScaleX",
                "__floatsisf": "intToFloat",
                "__aeabi_fmul": "multiplyFloats",
                "__aeabi_fsub": "subtractFloats",
                "magData.x": "magnetometerDataX",
                "magCalib.y": "calibratedMagnetometerY",
                "magBias.y": "magnetometerBiasY",
                "magScale.y": "magnetometerScaleY",
                "magData.y": "magnetometerDataY",
                "magCalib.z": "calibratedMagnetometerZ",
                "magBias.z": "magnetometerBiasZ",
                "magScale.z": "magnetometerScaleZ",
                "magData.z": "magnetometerDataZ"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "I2C_ReadByte",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ea0": {
            "entrypoint": "0x08002ea0",
            "current_name": "initialize_sensor_08002ea0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSensor_08002ea0(void)\n\n{\n  initializeMPU9250();\n  initializeAK8963();\n  setMadgwickBeta(0.6);\n  setMadgwickDelta(0.0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ea0": "initialize_sensor_08002ea0",
                "MPU9250_Init": "initializeMPU9250",
                "AK8963_Init": "initializeAK8963",
                "MadgwickSetBeta": "setMadgwickBeta",
                "MadgwickSetDelta": "setMadgwickDelta"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "MPU9250_Init",
                "AK8963_Init",
                "MadgwickSetDelta",
                "MadgwickSetBeta"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ec0": {
            "entrypoint": "0x08002ec0",
            "current_name": "filter_pitch_08002ec0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat filterPitch_08002ec0(void)\n\n{\n  float fVar1;\n  \n  fVar1 = lowPassFilter(filterPitch_08002ec0Parameter,angleData);\n  return fVar1;\n}\n\n",
            "renaming": {
                "FUN_08002ec0": "filter_pitch_08002ec0",
                "&lpf_pitch": "filterPitchParameter",
                "AHRS_Angle[1]": "angleData"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ed4": {
            "entrypoint": "0x08002ed4",
            "current_name": "filter_roll_angle_08002ed4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat filterRollAngle_08002ed4(void)\n\n{\n  float fVar1;\n  \n  fVar1 = lowPassFilter(&rollFilter,rollAngle[0]);\n  return fVar1;\n}\n\n",
            "renaming": {
                "FUN_08002ed4": "filter_roll_angle_08002ed4",
                "lpf_roll": "rollFilter",
                "AHRS_Angle": "rollAngle"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "lowPassFilter"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ee8": {
            "entrypoint": "0x08002ee8",
            "current_name": "calculate_adjusted_angle_08002ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat calculateAdjustedAngle_08002ee8(void)\n\n{\n  int comparisonResult;\n  float angle;\n  float adjustedAngle;\n  \n  adjustedAngle = angleValues[2];\n  comparisonResult = __aeabi_fcmpge(angleValues[2],0xc3340000);\n  if ((comparisonResult != 0) && (comparisonResult = __aeabi_fcmplt(adjustedAngle,0x42b40000), comparisonResult != 0)) {\n    adjustedAngle = (float)__addsf3(adjustedAngle,0x42b40000);\n    return adjustedAngle;\n  }\n  adjustedAngle = (float)__aeabi_fsub(adjustedAngle,0x43870000);\n  return adjustedAngle;\n}\n\n",
            "renaming": {
                "FUN_08002ee8": "calculate_adjusted_angle_08002ee8",
                "AHRS_Angle": "angleValues",
                "iVar1": "comparisonResult",
                "fVar2": "adjustedAngle"
            },
            "calling": [
                "PID_Update",
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_fcmpge",
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f28": {
            "entrypoint": "0x08002f28",
            "current_name": "update_ahrs_data_08002f28",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAHRSData_08002f28(void)\n\n{\n  undefined4 timeDifference;\n  float deltaTime;\n  \n  MPU9250_ReadAccelData();\n  MPU9250_ReadGyroData();\n  AK8963_ReadData();\n  AHRS_timeNow = micros();\n  timeDifference = __floatunsisf(AHRS_timeNow - AHRS_lastUpdate);\n  deltaTime = (float)__aeabi_fdiv(timeDifference,0x447a0000);\n  MadgwickSetDelta(deltaTime);\n  AHRS_lastUpdate = AHRS_timeNow;\n  MadgwickQuaternionUpdate\n            ((float)((int)accelerationData.y + -0x80000000),(float)((int)accelerationData.x + -0x80000000),\n             accelerationData.z,gyroData.y,gyroData.x,(float)((int)gyroData.z + -0x80000000),magneticData.x,\n             magneticData.y,magneticData.z,orientation);\n  txfRawImu.accx = (int16_t)((uint)(int)rawAcceleration.x / 100);\n  txfRawImu.accz = (int16_t)((uint)(int)rawAcceleration.z / 100);\n  txfRawImu.accy = (int16_t)((uint)(int)rawAcceleration.y / 100);\n  txfRawImu.gyrx = rawGyro.x;\n  txfRawImu.gyry = rawGyro.y;\n  txfRawImu.gyrz = rawGyro.z;\n  txfRawImu.magx = rawMagnetic.x;\n  txfRawImu.magy = rawMagnetic.y;\n  txfRawImu.magz = rawMagnetic.z;\n  AHRS_GetRoll();\n  __aeabi_fmul();\n  txfAttitude.angx = __aeabi_f2iz();\n  AHRS_GetPitch();\n  __aeabi_fmul();\n  txfAttitude.angy = __aeabi_f2iz();\n  AHRS_GetYaw();\n  txfAttitude.heading = __aeabi_f2iz();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f28": "update_ahrs_data_08002f28",
                "_deltat": "deltaTime",
                "uVar1": "timeDifference",
                "accelData": "accelerationData",
                "magData": "magneticData",
                "AHRS_Angle": "orientation",
                "msp_txf_raw_imu": "txfRawImu",
                "msp_txf_attitude": "txfAttitude",
                "accelRaw": "rawAcceleration",
                "gyroRaw": "rawGyro",
                "magRaw": "rawMagnetic"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__aeabi_fmul",
                "MPU9250_ReadAccelData",
                "micros",
                "MPU9250_ReadGyroData",
                "AHRS_GetRoll",
                "AHRS_GetPitch",
                "MadgwickQuaternionUpdate",
                "AK8963_ReadData",
                "AHRS_GetYaw",
                "MadgwickSetDelta",
                "__floatunsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003034": {
            "entrypoint": "0x08003034",
            "current_name": "read_ms5611_sensor_data_08003034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t read_MS5611_sensor_data_08003034(void)\n\n{\n  undefined4 buffer_start;\n  uint8_t receive_buffer [3];\n  \n  receive_buffer_start = buffer_start;\n  read_bytes_from_I2C(0xee,0,receive_buffer,3,\"../Src/MS5611.c\",0x8c);\n  return (uint)concatenate_12(receive_buffer[0],concatenate_11(receive_buffer[1],receive_buffer[2]));\n}\n\n",
            "renaming": {
                "FUN_08003034": "read_ms5611_sensor_data_08003034",
                "in_r3": "buffer_start",
                "rxbuf": "receive_buffer",
                "_rxbuf": "receive_buffer_start",
                "I2C_ReadBytes": "read_bytes_from_I2C",
                "CONCAT12": "concatenate_12",
                "CONCAT11": "concatenate_11"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "I2C_ReadBytes"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003068": {
            "entrypoint": "0x08003068",
            "current_name": "get_float_value_08003068",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat get_float_value_08003068(void)\n\n{\n  float float_value;\n  \n  return float_value;\n}\n\n",
            "renaming": {
                "FUN_08003068": "get_float_value_08003068",
                "in_s0": "float_value"
            },
            "calling": [
                "PID_UpdateAltitude"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003078": {
            "entrypoint": "0x08003078",
            "current_name": "calculate_compensated_data_08003078",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateCompensatedData_08003078(void)\n\n{\n  float *pfVar1;\n  longlong lVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined4 uVar6;\n  float fVar7;\n  uint32_t uVar8;\n  undefined4 extraout_r1;\n  uint uVar9;\n  undefined4 unaff_r4;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  float *pfVar13;\n  undefined4 unaff_r5;\n  undefined4 unaff_r6;\n  undefined4 unaff_r7;\n  int iVar14;\n  int32_t TEMP;\n  int iVar15;\n  int iVar16;\n  int32_t dT;\n  bool bVar17;\n  undefined8 uVar18;\n  \n  if ((isTempReady != '\\0') && (isPressureReady != '\\0')) {\n    iVar16 = rawTemperature + (uint)coefficients[5] * -0x100;\n    uVar9 = (uint)((longlong)(int)(uint)coefficients[6] * (longlong)iVar16) >> 0x17 |\n            (int)((ulonglong)((longlong)(int)(uint)coefficients[6] * (longlong)iVar16) >>\n                 0x20) << 9;\n    uVar10 = (uint)((longlong)(int)(uint)coefficients[4] * (longlong)iVar16 >> 7);\n    uVar11 = uVar10 + (uint)coefficients[2] * 0x10000;\n    uVar4 = (uint)((ulonglong)((longlong)(int)(uint)coefficients[3] * (longlong)iVar16) >> 8)\n    ;\n    iVar14 = uVar9 + 2000;\n    uVar5 = uVar4 + (uint)coefficients[1] * 0x8000;\n    bVar17 = (int)uVar9 < 0;\n    if (1999 < iVar14) {\n      uVar9 = 0;\n    }\n    uVar3 = uVar9;\n    if (bVar17 != SBORROW4(iVar14,2000)) {\n      iVar15 = uVar9 * uVar9 * 5;\n      uVar9 = iVar15 >> 2;\n      uVar3 = iVar15 >> 1;\n    }\n    uVar12 = uVar11 - uVar3;\n    lVar2 = (ulonglong)(uVar5 - uVar9) * (ulonglong)rawPressure;\n    iVar15 = rawPressure *\n             ((((int)((longlong)(int)(uint)coefficients[3] * (longlong)iVar16 >> 0x28) +\n               (uint)CARRY4(uVar4,(uint)coefficients[1] * 0x8000)) - ((int)uVar9 >> 0x1f)) -\n             (uint)(uVar5 < uVar9)) + (int)((ulonglong)lVar2 >> 0x20);\n    uVar4 = (uint)lVar2 >> 0x15 | iVar15 * 0x800;\n    uVar6 = __floatsisf(uVar4 - uVar12 >> 0xf |\n                        (((iVar15 >> 0x15) -\n                         ((((int)((longlong)(int)(uint)coefficients[4] * (longlong)iVar16 >>\n                                 0x27) + (uint)CARRY4(uVar10,(uint)coefficients[2] * 0x10000)\n                           ) - ((int)uVar3 >> 0x1f)) - (uint)(uVar11 < uVar3))) -\n                        (uint)(uVar4 < uVar12)) * 0x20000);\n    fVar7 = (float)divide(uVar6,0x42c80000);\n    compensatedPressure = fVar7;\n    uVar6 = __floatsisf(iVar14);\n    compensatedTemperature = (float)divide(uVar6,0x42c80000);\n    divide(fVar7,0x447d5000);\n    uVar6 = convertDouble();\n    power((double)CONCAT44(unaff_r5,unaff_r4),(double)CONCAT44(unaff_r7,unaff_r6));\n    uVar18 = subtract(0,0x3ff00000,uVar6,extraout_r1);\n    multiply((int)uVar18,(int)((ulonglong)uVar18 >> 0x20),0,0x40e5a540);\n    fVar7 = (float)truncate();\n    uVar6 = 0;\n    pfVar13 = altitudeFilter;\n    altitude = fVar7;\n    do {\n      pfVar1 = pfVar13 + 1;\n      *pfVar13 = *pfVar1;\n      uVar6 = __addsf3(uVar6);\n      pfVar13 = pfVar1;\n    } while (pfVar1 != altitudeFilter + 0x13);\n    altitudeFilter[19] = fVar7;\n    uVar6 = __addsf3(uVar6,fVar7);\n    filteredAltitude = (float)divide(uVar6,0x41a00000);\n    iVar14 = convertInteger();\n    altitudeData.est_alt = iVar14 * 100;\n    isTempReady = '\\0';\n    isPressureReady = '\\0';\n    writeI2CByte(0xee,oversamplingRate + 0x50,'\\x01','\\0');\n    tempStartTime = currentTime();\n  }\n  uVar8 = currentTime();\n  if (((10 < uVar8 - tempStartTime) && (isTempReady == '\\0')) && (isPressureReady == '\\0')) {\n    rawTemperature = readAdc();\n    isTempReady = '\\x01';\n    writeI2CByte(0xee,oversamplingRate + 0x40,'\\x01','\\0');\n    pressureStartTime = currentTime();\n  }\n  uVar8 = currentTime();\n  if (((10 < uVar8 - pressureStartTime) && (isTempReady != '\\0')) && (isPressureReady == '\\0')) {\n    rawPressure = readAdc();\n    isPressureReady = '\\x01';\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003078": "calculate_compensated_data_08003078",
                "MS5611_RawTemperature": "rawTemperature",
                "MS5611_Coefficients": "coefficients",
                "MS5611_RawPressure": "rawPressure",
                "TEMP_READY": "isTempReady",
                "PRESSURE_READY": "isPressureReady",
                "MS5611_CompensatedPressure": "compensatedPressure",
                "MS5611_CompensatedTemperature": "compensatedTemperature",
                "MS5611_Altitude": "altitude",
                "alt_filter": "altitudeFilter",
                "MS5611_FilteredAltitude": "filteredAltitude",
                "msp_txf_altitude": "altitudeData",
                "I2C_WriteByte": "writeI2CByte",
                "MS5611_OSR": "oversamplingRate",
                "millis": "currentTime",
                "temp_time": "tempStartTime",
                "pressure_time": "pressureStartTime",
                "MS5611_ReadADC": "readAdc",
                "pow": "power",
                "__subdf3": "subtract",
                "__muldf3": "multiply",
                "__truncdfsf2": "truncate",
                "__aeabi_fdiv": "divide",
                "__aeabi_f2d": "convertDouble",
                "__aeabi_f2iz": "convertInteger"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_f2d",
                "pow",
                "__truncdfsf2",
                "__aeabi_f2iz",
                "__aeabi_fdiv",
                "__addsf3",
                "__floatsisf",
                "__muldf3",
                "millis",
                "MS5611_ReadADC",
                "I2C_WriteByte",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003298": {
            "entrypoint": "0x08003298",
            "current_name": "initialize_ms5611_sensor_08003298",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initialize_MS5611_sensor_08003298(voindexd)\n\n{\n  indexnt index;\n  indexnt iteration;\n  uindexnt8_t received_bytes [2];\n  \n  iteration = 0;\n  write_I2C_byte(0xee,0x1e,'\\x01','\\x01');\n  delay_milliseconds(10);\n  MS5611_oversampling_rate = '\\b';\n  do {\n    received_bytes[0] = '\\0';\n    received_bytes[1] = '\\0';\n    read_I2C_byte_array(0xee,(short)iteration + 0xa0,received_bytes,2,\"../Src/MS5611.c\",0x7c);\n    *(ushort *)((indexnt)MS5611_coefficients + iteration) = concatenate_bytes(received_bytes[0],received_bytes[1]);\n    iteration = iteration + 2;\n  } whindexle (iteration != 0x10);\n  iteration = 0;\n  do {\n    altitude_filter[iteration] = 0.0;\n    iteration = iteration + 1;\n  } whindexle (iteration != 0x14);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003298": "initialize_ms5611_sensor_08003298",
                "rxbuf": "received_bytes",
                "i": "index",
                "iVar1": "iteration",
                "I2C_WriteByte": "write_I2C_byte",
                "delay_ms": "delay_milliseconds",
                "MS5611_OSR": "MS5611_oversampling_rate",
                "I2C_ReadByteArray": "read_I2C_byte_array",
                "MS5611_Coefficients": "MS5611_coefficients",
                "CONCAT11": "concatenate_bytes",
                "alt_filter": "altitude_filter"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "delay_ms",
                "I2C_WriteByte",
                "I2C_ReadByteArray"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003314": {
            "entrypoint": "0x08003314",
            "current_name": "set_beta_08003314",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setBeta_08003314(float beta)\n\n{\n  beta = beta;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003314": "set_beta_08003314",
                "_beta": "beta"
            },
            "calling": [
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003320": {
            "entrypoint": "0x08003320",
            "current_name": "update_delta_time_08003320",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateDeltaTime_08003320(float newDeltaTime)\n\n{\n  deltat = newDeltaTime;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003320": "update_delta_time_08003320",
                "_deltat": "newDeltaTime"
            },
            "calling": [
                "AHRS_ComputeAngles",
                "IMU_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003330": {
            "entrypoint": "0x08003330",
            "current_name": "calculate_euler_angles_08003330",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculateEulerAngles_08003330(float accelerationX,float accelerationY,float accelerationZ,float gyroscopeX,float gyroscopeY,float gyroscopeZ,float magnetometerX,float magnetometerY,float magnetometerZ,\n                 float *yaw)\n\n{\n  float normAccel;\n  float normMag;\n  undefined4 q0Squared;\n  undefined4 q1Squared;\n  float norm;\n  undefined4 quaternionNormInverse;\n  int isAccelValid;\n  undefined4 halfAngleAsinArg1;\n  undefined4 halfAngleAsinArg2;\n  undefined4 gyroDotZ;\n  int twoAccelX;\n  undefined4 twoAccelY;\n  undefined4 twoAccelZ;\n  undefined4 accelCrossMagX;\n  undefined4 accelCrossMagY;\n  undefined4 q3Squared;\n  undefined4 accelDotGyroX;\n  undefined4 accelDotGyroY;\n  undefined4 q2Squared;\n  undefined4 accelNormInv;\n  undefined4 magNormInv;\n  int twoAccelMagMax;\n  float q1mxScaled;\n  undefined4 q2myScaled;\n  float q1myScaled;\n  undefined4 uVar23;\n  float q1mzScaled;\n  undefined4 uVar24;\n  float q2mxScaled;\n  undefined4 uVar25;\n  undefined4 uVar26;\n  undefined4 uVar27;\n  int iVar28;\n  float bxScaled;\n  float bzScaled;\n  float bzScaled;\n  float s1Term;\n  float s2Term;\n  float s3Term;\n  float s4Term;\n  float q0Scaled;\n  float q1Scaled;\n  float q2Scaled;\n  float quaternion1;\n  float quaternion2;\n  float quaternion4;\n  float quaternion3;\n  undefined8 quaternionNormSquared;\n  undefined8 quaternionNorm;\n  undefined4 stackVar;\n  float q3Scaled;\n  float halfPitch;\n  float halfYaw;\n  \n  q2Scaled = q[3];\n  q1Scaled = q[2];\n  q0Scaled = q[0];\n  q3Scaled = q[1];\n  q0Squared = __aeabi_fmul(accelerationX,accelerationX);\n  q1Squared = __aeabi_fmul(accelerationY);\n  q0Squared = __addsf3(q0Squared,q1Squared);\n  q1Squared = __aeabi_fmul(accelerationZ);\n  __addsf3(q0Squared,q1Squared);\n  __aeabi_f2d();\n  sqrt((double)CONCAT44(q3Scaled,stackVar));\n  q0Squared = __truncdfsf2();\n  norm = (float)__aeabi_fcmpeq(q0Squared,0);\n  if (norm == 0.0) {\n    q1Squared = __aeabi_fmul(magnetometerX);\n    quaternionNormInverse = __aeabi_fmul(magnetometerY);\n    q1Squared = __addsf3(q1Squared,quaternionNormInverse);\n    quaternionNormInverse = __aeabi_fmul(magnetometerZ);\n    __addsf3(q1Squared,quaternionNormInverse);\n    __aeabi_f2d();\n    sqrt((double)CONCAT44(q3Scaled,stackVar));\n    q1Squared = __truncdfsf2();\n    isAccelValid = __aeabi_fcmpeq(q1Squared,0);\n    if (isAccelValid == 0) {\n      quaternionNormSquared = __aeabi_f2d(gyroscopeX);\n      __muldf3((int)quaternionNormSquared,(int)((ulonglong)quaternionNormSquared >> 0x20),0xa2529d39,0x3f91df46);\n      quaternionNormInverse = __truncdfsf2();\n      quaternionNormSquared = __aeabi_f2d(gyroscopeY);\n      __muldf3((int)quaternionNormSquared,(int)((ulonglong)quaternionNormSquared >> 0x20),0xa2529d39,0x3f91df46);\n      halfAngleAsinArg1 = __truncdfsf2();\n      quaternionNormSquared = __aeabi_f2d(gyroscopeZ);\n      __muldf3((int)quaternionNormSquared,(int)((ulonglong)quaternionNormSquared >> 0x20),0xa2529d39,0x3f91df46);\n      halfAngleAsinArg2 = __truncdfsf2();\n      isAccelValid = __addsf3(q0Scaled);\n      gyroDotZ = __addsf3(q3Scaled);\n      twoAccelX = __addsf3(q1Scaled,q1Scaled);\n      twoAccelY = __addsf3(q2Scaled,q2Scaled);\n      twoAccelZ = __aeabi_fmul(q0Scaled);\n      accelCrossMagX = __aeabi_fmul(q0Scaled,q3Scaled);\n      accelCrossMagY = __aeabi_fmul(q0Scaled,q1Scaled);\n      q3Squared = __aeabi_fmul(q3Scaled);\n      accelDotGyroX = __aeabi_fmul(q3Scaled,q2Scaled);\n      accelDotGyroY = __aeabi_fmul(q1Scaled,q1Scaled);\n      q2Squared = __aeabi_fmul(q2Scaled,q2Scaled);\n      q0Squared = __aeabi_fdiv(0x3f800000,q0Squared);\n      q1Squared = __aeabi_fdiv(0x3f800000,q1Squared);\n      accelNormInv = __aeabi_fmul(magnetometerX,q1Squared);\n      magNormInv = __aeabi_fmul(magnetometerY,q1Squared);\n      q1Squared = __aeabi_fmul(magnetometerZ,q1Squared);\n      twoAccelMagMax = __aeabi_fmul(isAccelValid,accelNormInv);\n      q2myScaled = __aeabi_fmul(isAccelValid,magNormInv);\n      uVar23 = __aeabi_fmul(isAccelValid,q1Squared);\n      uVar24 = __aeabi_fmul(gyroDotZ,accelNormInv);\n      uVar25 = __aeabi_fmul(twoAccelZ,accelNormInv);\n      uVar26 = __aeabi_fmul(q2Scaled,q2myScaled);\n      uVar25 = __aeabi_fsub(uVar25,uVar26);\n      uVar26 = __aeabi_fmul(q1Scaled,uVar23);\n      uVar25 = __addsf3(uVar25,uVar26);\n      uVar26 = __aeabi_fmul(q3Squared,accelNormInv);\n      uVar25 = __addsf3(uVar25,uVar26);\n      uVar26 = __aeabi_fmul(gyroDotZ,magNormInv);\n      uVar26 = __aeabi_fmul(uVar26,q1Scaled);\n      uVar25 = __addsf3(uVar25,uVar26);\n      uVar26 = __aeabi_fmul(gyroDotZ,q1Squared);\n      uVar26 = __aeabi_fmul(uVar26,q2Scaled);\n      uVar25 = __addsf3(uVar25,uVar26);\n      uVar26 = __aeabi_fmul(accelDotGyroY,accelNormInv);\n      uVar25 = __aeabi_fsub(uVar25,uVar26);\n      uVar26 = __aeabi_fmul(q2Squared,accelNormInv);\n      uVar25 = __aeabi_fsub(uVar25,uVar26);\n      uVar26 = __aeabi_fmul(q2Scaled,twoAccelMagMax);\n      uVar27 = __aeabi_fmul(twoAccelZ,magNormInv);\n      uVar26 = __addsf3(uVar26,uVar27);\n      uVar23 = __aeabi_fmul(q3Scaled,uVar23);\n      uVar23 = __aeabi_fsub(uVar26,uVar23);\n      uVar26 = __aeabi_fmul(q1Scaled,uVar24);\n      uVar23 = __addsf3(uVar23,uVar26);\n      uVar26 = __aeabi_fmul(q3Squared,magNormInv);\n      uVar23 = __aeabi_fsub(uVar23,uVar26);\n      uVar26 = __aeabi_fmul(accelDotGyroY,magNormInv);\n      uVar23 = __addsf3(uVar23,uVar26);\n      uVar26 = __aeabi_fmul(twoAccelX,q1Squared);\n      uVar26 = __aeabi_fmul(uVar26,q2Scaled);\n      uVar23 = __addsf3(uVar23,uVar26);\n      uVar26 = __aeabi_fmul(q2Squared,magNormInv);\n      uVar23 = __aeabi_fsub(uVar23,uVar26);\n      uVar25 = __aeabi_fmul(uVar25,uVar25);\n      uVar23 = __aeabi_fmul(uVar23,uVar23);\n      __addsf3(uVar25,uVar23);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(q3Scaled,stackVar));\n      iVar28 = __truncdfsf2();\n      uVar23 = __aeabi_fmul(twoAccelMagMax + -0x80000000,q1Scaled);\n      q2myScaled = __aeabi_fmul(q3Scaled,q2myScaled);\n      q2myScaled = __addsf3(uVar23,q2myScaled);\n      twoAccelZ = __aeabi_fmul(twoAccelZ,q1Squared);\n      twoAccelZ = __addsf3(q2myScaled,twoAccelZ);\n      q2myScaled = __aeabi_fmul(q2Scaled,uVar24);\n      twoAccelZ = __addsf3(twoAccelZ,q2myScaled);\n      q2myScaled = __aeabi_fmul(q3Squared,q1Squared);\n      twoAccelZ = __aeabi_fsub(twoAccelZ,q2myScaled);\n      q2myScaled = __aeabi_fmul(twoAccelX,magNormInv);\n      q2myScaled = __aeabi_fmul(q2myScaled,q2Scaled);\n      twoAccelZ = __addsf3(twoAccelZ,q2myScaled);\n      q2myScaled = __aeabi_fmul(accelDotGyroY,q1Squared);\n      twoAccelZ = __aeabi_fsub(twoAccelZ,q2myScaled);\n      q2myScaled = __aeabi_fmul(q2Squared,q1Squared);\n      twoAccelZ = __addsf3(twoAccelZ,q2myScaled);\n      bzScaled = (float)__addsf3(twoAccelZ,twoAccelZ);\n      q2myScaled = __addsf3(accelDotGyroX);\n      uVar23 = __aeabi_fmul(q1Scaled,isAccelValid);\n      q2myScaled = __aeabi_fsub(q2myScaled,uVar23);\n      uVar23 = __aeabi_fmul(accelerationX,q0Squared);\n      q2myScaled = __aeabi_fsub(q2myScaled,uVar23);\n      uVar23 = __aeabi_fmul(q2Scaled,twoAccelX);\n      uVar24 = __addsf3(accelCrossMagX);\n      uVar23 = __addsf3(uVar23,uVar24);\n      uVar24 = __aeabi_fmul(accelerationY,q0Squared);\n      uVar23 = __aeabi_fsub(uVar23,uVar24);\n      uVar24 = __aeabi_fmul(q1Scaled,twoAccelZ);\n      uVar25 = __aeabi_fsub(0x3f000000,accelDotGyroY);\n      q2Squared = __aeabi_fsub(uVar25,q2Squared);\n      q2Squared = __aeabi_fmul(q2Squared,iVar28);\n      uVar25 = __aeabi_fsub(accelDotGyroX,accelCrossMagY);\n      uVar25 = __aeabi_fmul(uVar25,twoAccelZ);\n      q2Squared = __addsf3(q2Squared,uVar25);\n      q2Squared = __aeabi_fsub(q2Squared,accelNormInv);\n      accelNormInv = __aeabi_fmul(q3Scaled,twoAccelZ);\n      uVar25 = __aeabi_fmul(q3Scaled,q1Scaled);\n      uVar26 = __aeabi_fmul(q0Scaled,q2Scaled);\n      uVar25 = __aeabi_fsub(uVar25,uVar26);\n      uVar25 = __aeabi_fmul(uVar25,iVar28);\n      uVar26 = __aeabi_fmul(q1Scaled,q2Scaled);\n      accelCrossMagX = __addsf3(uVar26,accelCrossMagX);\n      accelCrossMagX = __aeabi_fmul(accelCrossMagX,twoAccelZ);\n      accelCrossMagX = __addsf3(uVar25,accelCrossMagX);\n      accelCrossMagX = __aeabi_fsub(accelCrossMagX,magNormInv);\n      magNormInv = __aeabi_fmul(q1Scaled,iVar28);\n      uVar25 = __aeabi_fsub(0x3f000000,q3Squared);\n      uVar25 = __aeabi_fsub(uVar25,accelDotGyroY);\n      uVar25 = __aeabi_fmul(uVar25,twoAccelZ);\n      accelCrossMagY = __addsf3(accelCrossMagY,accelDotGyroX);\n      accelCrossMagY = __aeabi_fmul(accelCrossMagY,iVar28);\n      accelCrossMagY = __addsf3(uVar25,accelCrossMagY);\n      q1Squared = __aeabi_fsub(accelCrossMagY,q1Squared);\n      accelCrossMagY = __aeabi_fmul(twoAccelX + -0x80000000,q2myScaled);\n      accelDotGyroX = __aeabi_fmul(gyroDotZ,uVar23);\n      accelCrossMagY = __addsf3(accelCrossMagY,accelDotGyroX);\n      accelDotGyroX = __aeabi_fmul(uVar24,q2Squared);\n      accelCrossMagY = __aeabi_fsub(accelCrossMagY,accelDotGyroX);\n      accelDotGyroX = __aeabi_fmul(q2Scaled,iVar28 + -0x80000000);\n      accelDotGyroX = __addsf3(accelDotGyroX,accelNormInv);\n      accelDotGyroX = __aeabi_fmul(accelDotGyroX,accelCrossMagX);\n      accelCrossMagY = __addsf3(accelCrossMagY,accelDotGyroX);\n      accelDotGyroX = __aeabi_fmul(magNormInv,q1Squared);\n      accelCrossMagY = __addsf3(accelCrossMagY,accelDotGyroX);\n      q3Squared = __addsf3(q3Squared);\n      q3Squared = __aeabi_fsub(0x3f800000,q3Squared);\n      accelDotGyroX = __addsf3(accelDotGyroY);\n      q3Squared = __aeabi_fsub(q3Squared,accelDotGyroX);\n      q0Squared = __aeabi_fmul(accelerationZ,q0Squared);\n      q0Squared = __aeabi_fsub(q3Squared,q0Squared);\n      q3Squared = __aeabi_fmul(q2Scaled,twoAccelZ);\n      twoAccelZ = __aeabi_fmul(q0Scaled,twoAccelZ);\n      accelDotGyroX = __aeabi_fmul(twoAccelY,q2myScaled);\n      accelDotGyroY = __aeabi_fmul(isAccelValid,uVar23);\n      accelDotGyroX = __addsf3(accelDotGyroX,accelDotGyroY);\n      accelDotGyroY = __aeabi_fmul(q3Scaled,0x40800000);\n      accelDotGyroY = __aeabi_fmul(accelDotGyroY,q0Squared);\n      accelDotGyroX = __aeabi_fsub(accelDotGyroX,accelDotGyroY);\n      accelDotGyroY = __aeabi_fmul(q2Squared,q3Squared);\n      accelDotGyroX = __addsf3(accelDotGyroX,accelDotGyroY);\n      accelDotGyroY = __addsf3(magNormInv,twoAccelZ);\n      accelDotGyroY = __aeabi_fmul(accelDotGyroY,accelCrossMagX);\n      accelDotGyroX = __addsf3(accelDotGyroX,accelDotGyroY);\n      accelDotGyroY = __aeabi_fmul(q2Scaled,iVar28);\n      magNormInv = __aeabi_fmul(q3Scaled,bzScaled);\n      accelDotGyroY = __aeabi_fsub(accelDotGyroY,magNormInv);\n      accelDotGyroY = __aeabi_fmul(accelDotGyroY,q1Squared);\n      accelDotGyroX = __addsf3(accelDotGyroX,accelDotGyroY);\n      twoAccelMagMax = __addsf3(iVar28,iVar28);\n      accelDotGyroY = __aeabi_fmul(q3Scaled,iVar28);\n      magNormInv = __aeabi_fmul(isAccelValid + -0x80000000,q2myScaled);\n      twoAccelY = __aeabi_fmul(twoAccelY,uVar23);\n      twoAccelY = __addsf3(magNormInv,twoAccelY);\n      magNormInv = __aeabi_fmul(q1Scaled,0x40800000);\n      q0Squared = __aeabi_fmul(magNormInv,q0Squared);\n      q0Squared = __aeabi_fsub(twoAccelY,q0Squared);\n      twoAccelY = __aeabi_fmul(q1Scaled,twoAccelMagMax + -0x80000000);\n      twoAccelY = __aeabi_fsub(twoAccelY,twoAccelZ);\n      twoAccelY = __aeabi_fmul(twoAccelY,q2Squared);\n      q0Squared = __addsf3(q0Squared,twoAccelY);\n      twoAccelY = __addsf3(q3Squared,accelDotGyroY);\n      twoAccelY = __aeabi_fmul(twoAccelY,accelCrossMagX);\n      q0Squared = __addsf3(q0Squared,twoAccelY);\n      twoAccelY = __aeabi_fmul(q0Scaled,iVar28);\n      twoAccelZ = __aeabi_fmul(q1Scaled,bzScaled);\n      twoAccelY = __aeabi_fsub(twoAccelY,twoAccelZ);\n      twoAccelY = __aeabi_fmul(twoAccelY,q1Squared);\n      q0Squared = __addsf3(q0Squared,twoAccelY);\n      gyroDotZ = __aeabi_fmul(gyroDotZ,q2myScaled);\n      twoAccelY = __aeabi_fmul(twoAccelX,uVar23);\n      gyroDotZ = __addsf3(gyroDotZ,twoAccelY);\n      twoAccelY = __aeabi_fmul(q2Scaled,twoAccelMagMax + -0x80000000);\n      twoAccelY = __addsf3(twoAccelY,accelNormInv);\n      twoAccelY = __aeabi_fmul(twoAccelY,q2Squared);\n      gyroDotZ = __addsf3(gyroDotZ,twoAccelY);\n      twoAccelY = __aeabi_fmul(q0Scaled,iVar28 + -0x80000000);\n      twoAccelY = __addsf3(twoAccelY,uVar24);\n      twoAccelY = __aeabi_fmul(twoAccelY,accelCrossMagX);\n      gyroDotZ = __addsf3(gyroDotZ,twoAccelY);\n      q1Squared = __aeabi_fmul(q1Squared,accelDotGyroY);\n      q1Squared = __addsf3(gyroDotZ,q1Squared);\n      gyroDotZ = __aeabi_fmul(accelCrossMagY);\n      twoAccelY = __aeabi_fmul(accelDotGyroX);\n      gyroDotZ = __addsf3(gyroDotZ,twoAccelY);\n      twoAccelY = __aeabi_fmul(q0Squared,q0Squared);\n      gyroDotZ = __addsf3(gyroDotZ,twoAccelY);\n      twoAccelY = __aeabi_fmul(q1Squared,q1Squared);\n      __addsf3(gyroDotZ,twoAccelY);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(q3Scaled,stackVar));\n      gyroDotZ = __truncdfsf2();\n      gyroDotZ = __aeabi_fdiv(0x3f800000,gyroDotZ);\n      normAccel = beta;\n      twoAccelY = __aeabi_fmul((int)q3Scaled + -0x80000000,quaternionNormInverse);\n      twoAccelZ = __aeabi_fmul(q1Scaled,halfAngleAsinArg1);\n      twoAccelY = __aeabi_fsub(twoAccelY,twoAccelZ);\n      twoAccelZ = __aeabi_fmul(q2Scaled,halfAngleAsinArg2);\n      twoAccelY = __aeabi_fsub(twoAccelY,twoAccelZ);\n      twoAccelY = __aeabi_fmul(twoAccelY,0x3f000000);\n      twoAccelZ = __aeabi_fmul(accelCrossMagY,gyroDotZ);\n      normMag = deltat;\n      twoAccelZ = __aeabi_fmul(twoAccelZ,normAccel);\n      twoAccelY = __aeabi_fsub(twoAccelY,twoAccelZ);\n      twoAccelY = __aeabi_fmul(twoAccelY,normMag);\n      twoAccelY = __addsf3(twoAccelY,q0Scaled);\n      twoAccelZ = __aeabi_fmul(q0Scaled,quaternionNormInverse);\n      accelCrossMagX = __aeabi_fmul(q1Scaled,halfAngleAsinArg2);\n      normMag = deltat;\n      twoAccelZ = __addsf3(twoAccelZ,accelCrossMagX);\n      accelCrossMagX = __aeabi_fmul(q2Scaled,halfAngleAsinArg1);\n      twoAccelZ = __aeabi_fsub(twoAccelZ,accelCrossMagX);\n      twoAccelZ = __aeabi_fmul(twoAccelZ,0x3f000000);\n      accelCrossMagX = __aeabi_fmul(accelDotGyroX,gyroDotZ);\n      accelCrossMagX = __aeabi_fmul(accelCrossMagX,normAccel);\n      twoAccelZ = __aeabi_fsub(twoAccelZ,accelCrossMagX);\n      twoAccelZ = __aeabi_fmul(twoAccelZ,normMag);\n      twoAccelZ = __addsf3(twoAccelZ,q3Scaled);\n      normMag = deltat;\n      accelCrossMagX = __aeabi_fmul(q0Scaled,halfAngleAsinArg1);\n      accelCrossMagY = __aeabi_fmul(q3Scaled,halfAngleAsinArg2);\n      accelCrossMagX = __aeabi_fsub(accelCrossMagX,accelCrossMagY);\n      accelCrossMagY = __aeabi_fmul(q2Scaled,quaternionNormInverse);\n      accelCrossMagX = __addsf3(accelCrossMagX,accelCrossMagY);\n      accelCrossMagX = __aeabi_fmul(accelCrossMagX,0x3f000000);\n      q0Squared = __aeabi_fmul(q0Squared,gyroDotZ);\n      q0Squared = __aeabi_fmul(q0Squared,normAccel);\n      q0Squared = __aeabi_fsub(accelCrossMagX,q0Squared);\n      q0Squared = __aeabi_fmul(q0Squared,normMag);\n      q0Squared = __addsf3(q0Squared,q1Scaled);\n      halfAngleAsinArg2 = __aeabi_fmul(q0Scaled,halfAngleAsinArg2);\n      halfAngleAsinArg1 = __aeabi_fmul(q3Scaled,halfAngleAsinArg1);\n      halfAngleAsinArg1 = __addsf3(halfAngleAsinArg2,halfAngleAsinArg1);\n      quaternionNormInverse = __aeabi_fmul(q1Scaled,quaternionNormInverse);\n      quaternionNormInverse = __aeabi_fsub(halfAngleAsinArg1,quaternionNormInverse);\n      quaternionNormInverse = __aeabi_fmul(quaternionNormInverse,0x3f000000);\n      q1Squared = __aeabi_fmul(q1Squared,gyroDotZ);\n      q1Squared = __aeabi_fmul(q1Squared,normAccel);\n      q0Scaled = deltat;\n      q1Squared = __aeabi_fsub(quaternionNormInverse,q1Squared);\n      q1Squared = __aeabi_fmul(q1Squared,q0Scaled);\n      q1Squared = __addsf3(q1Squared,q2Scaled);\n      quaternionNormInverse = __aeabi_fmul(twoAccelY,twoAccelY);\n      halfAngleAsinArg2 = __aeabi_fmul(twoAccelZ,twoAccelZ);\n      quaternionNormInverse = __addsf3(quaternionNormInverse,halfAngleAsinArg2);\n      halfAngleAsinArg2 = __aeabi_fmul(q0Squared,q0Squared);\n      quaternionNormInverse = __addsf3(quaternionNormInverse,halfAngleAsinArg2);\n      halfAngleAsinArg2 = __aeabi_fmul(q1Squared,q1Squared);\n      __addsf3(quaternionNormInverse,halfAngleAsinArg2);\n      __aeabi_f2d();\n      sqrt((double)CONCAT44(halfAngleAsinArg1,stackVar));\n      quaternionNormInverse = __truncdfsf2();\n      quaternionNormInverse = __aeabi_fdiv(0x3f800000,quaternionNormInverse);\n      q0Scaled = (float)__aeabi_fmul(twoAccelY,quaternionNormInverse);\n      q[0] = q0Scaled;\n      q1Scaled = (float)__aeabi_fmul(twoAccelZ,quaternionNormInverse);\n      q[1] = q1Scaled;\n      q2Scaled = (float)__aeabi_fmul(q0Squared,quaternionNormInverse);\n      q[2] = q2Scaled;\n      q[3] = (float)__aeabi_fmul(q1Squared,quaternionNormInverse);\n      q0Squared = __aeabi_fmul(q1Scaled,q[3]);\n      q1Squared = __aeabi_fmul(q0Scaled,q2Scaled);\n      q0Squared = __aeabi_fsub(q0Squared,q1Squared);\n      __addsf3(q0Squared,q0Squared);\n      __aeabi_f2d();\n      asin((double)CONCAT44(halfAngleAsinArg1,stackVar));\n      quaternionNormSquared = __muldf3();\n      __divdf3((int)quaternionNormSquared,(int)((ulonglong)quaternionNormSquared >> 0x20),0x54442d18,0x400921fb);\n      q0Scaled = (float)__truncdfsf2();\n      *yaw = q0Scaled;\n      q1Scaled = q[1];\n      q0Scaled = q[0];\n      q0Squared = __aeabi_fmul(q[0],q[0]);\n      q1Squared = __aeabi_fmul(q1Scaled,q1Scaled);\n      q0Squared = __aeabi_fsub(q0Squared,q1Squared);\n      q2Scaled = q[2];\n      q1Squared = __aeabi_fmul(q[2],q[2]);\n      q0Squared = __aeabi_fsub(q0Squared,q1Squared);\n      q3Scaled = q[3];\n      q1Squared = __aeabi_fmul(q[3],q[3]);\n      __addsf3(q0Squared,q1Squared);\n      quaternionNormSquared = __aeabi_f2d();\n      q0Squared = __aeabi_fmul(q0Scaled,q1Scaled);\n      q1Squared = __aeabi_fmul(q2Scaled,q3Scaled);\n      q0Squared = __addsf3(q0Squared,q1Squared);\n      __addsf3(q0Squared,q0Squared);\n      quaternionNorm = __aeabi_f2d();\n      quaternionNormSquared = atan2((int)quaternionNorm,(int)((ulonglong)quaternionNorm >> 0x20),(int)quaternionNormSquared,\n                     (int)((ulonglong)quaternionNormSquared >> 0x20));\n      quaternionNormSquared = __muldf3((int)quaternionNormSquared,(int)((ulonglong)quaternionNormSquared >> 0x20),0,0x40668000);\n      __divdf3((int)quaternionNormSquared,(int)((ulonglong)quaternionNormSquared >> 0x20),0x54442d18,0x400921fb);\n      q0Scaled = (float)__truncdfsf2();\n      yaw[1] = q0Scaled;\n      q1Scaled = q[1];\n      q0Scaled = q[0];\n      q0Squared = __aeabi_fmul(q[0],q[0]);\n      q1Squared = __aeabi_fmul(q1Scaled,q1Scaled);\n      q0Squared = __addsf3(q0Squared,q1Squared);\n      q2Scaled = q[2];\n      q1Squared = __aeabi_fmul(q[2],q[2]);\n      q0Squared = __aeabi_fsub(q0Squared,q1Squared);\n      q3Scaled = q[3];\n      q1Squared = __aeabi_fmul(q[3],q[3]);\n      __aeabi_fsub(q0Squared,q1Squared);\n      quaternionNormSquared = __aeabi_f2d();\n      q0Squared = __aeabi_fmul(q1Scaled,q2Scaled);\n      q1Squared = __aeabi_fmul(q0Scaled,q3Scaled);\n      q0Squared = __addsf3(q0Squared,q1Squared);\n      __addsf3(q0Squared,q0Squared);\n      quaternionNorm = __aeabi_f2d();\n      quaternionNormSquared = atan2((int)quaternionNorm,(int)((ulonglong)quaternionNorm >> 0x20),(int)quaternionNormSquared,\n                     (int)((ulonglong)quaternionNormSquared >> 0x20));\n      quaternionNormSquared = __muldf3((int)quaternionNormSquared,(int)((ulonglong)quaternionNormSquared >> 0x20),0,0x40668000);\n      __divdf3((int)quaternionNormSquared,(int)((ulonglong)quaternionNormSquared >> 0x20),0x54442d18,0x400921fb);\n      q0Scaled = (float)__truncdfsf2();\n      yaw[2] = q0Scaled;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003330": "calculate_euler_angles_08003330",
                "ax": "accelerationX",
                "ay": "accelerationY",
                "az": "accelerationZ",
                "gx": "gyroscopeX",
                "gy": "gyroscopeY",
                "gz": "gyroscopeZ",
                "mx": "magnetometerX",
                "my": "magnetometerY",
                "mz": "magnetometerZ",
                "angle": "yaw",
                "fVar1": "normAccel",
                "fVar2": "normMag",
                "uVar3": "q0Squared",
                "uVar4": "q1Squared",
                "uVar5": "quaternionNormInverse",
                "iVar6": "isAccelValid",
                "uVar7": "halfAngleAsinArg1",
                "uVar8": "halfAngleAsinArg2",
                "uVar9": "gyroDotZ",
                "iVar10": "twoAccelX",
                "uVar11": "twoAccelY",
                "uVar12": "twoAccelZ",
                "uVar13": "accelCrossMagX",
                "uVar14": "accelCrossMagY",
                "uVar15": "q3Squared",
                "uVar16": "accelDotGyroX",
                "uVar17": "accelDotGyroY",
                "uVar18": "q2Squared",
                "uVar19": "accelNormInv",
                "uVar20": "magNormInv",
                "iVar21": "twoAccelMagMax",
                "_2q1mx": "q1mxScaled",
                "_2q1my": "q1myScaled",
                "_2q1mz": "q1mzScaled",
                "_2q2mx": "q2mxScaled",
                "uVar22": "q2myScaled",
                "_2bx": "bxScaled",
                "_2bz": "bzScaled",
                "_4bz": "bzScaled",
                "s1": "s1Term",
                "s2": "s2Term",
                "s3": "s3Term",
                "s4": "s4Term",
                "fVar29": "q0Scaled",
                "fVar30": "q1Scaled",
                "fVar31": "q2Scaled",
                "q1": "quaternion1",
                "q2": "quaternion2",
                "q3": "quaternion3",
                "q4": "quaternion4",
                "uVar32": "quaternionNormSquared",
                "uVar33": "quaternionNorm",
                "fVar34": "q3Scaled",
                "hy": "halfPitch",
                "hx": "halfYaw",
                "in_stack_ffffff78": "stackVar"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "__aeabi_f2d",
                "__truncdfsf2",
                "__aeabi_fdiv",
                "__aeabi_fcmpeq",
                "__addsf3",
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_fmul",
                "atan2",
                "sqrt",
                "__divdf3",
                "asin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "execute_software_interrupt_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_software_interrupt_08003eac(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "execute_software_interrupt_08003eac"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eb0": {
            "entrypoint": "0x08003eb0",
            "current_name": "handle_hyper_call_08003eb0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint handleHyperCall_08003eb0(int numberOfTicks)\n\n{\n  uint32_t returnValue;\n  \n  if (noHyperCall == 0) {\n    returnValue = aflCall(1,numberOfTicks,0);\n    return returnValue;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003eb0": "handle_hyper_call_08003eb0",
                "ticks": "numberOfTicks",
                "uVar1": "returnValue"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ec8": {
            "entrypoint": "0x08003ec8",
            "current_name": "insert_data_into_circular_buffer_08003ec8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint insertDataIntoCircularBuffer_08003ec8(CircularBuffer *cb,uint8_t inputData)\n\n{\n  cb->size = cb->size + 1;\n  cb->buffer[cb->tail] = inputData;\n  cb->tail = cb->tail + 1 & 0x7ff;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08003ec8": "insert_data_into_circular_buffer_08003ec8",
                "data": "inputData"
            },
            "calling": [
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ef2": {
            "entrypoint": "0x08003ef2",
            "current_name": "initialize_circular_buffer_08003ef2",
            "code": "\n/* WARNING: Unknown callindexng conventindexon */\n\nvoindexd initializeCircularBuffer_08003ef2(CindexrcularBuffer *cb)\n\n{\n  indexnt index;\n  \n  index = 0;\n  cb->head = 0;\n  cb->taindexl = 0;\n  cb->sindexze = 0;\n  do {\n    cb->buffer[index] = '\\0';\n    index = index + 1;\n  } whindexle (index != 0x800);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ef2": "initialize_circular_buffer_08003ef2",
                "i": "index"
            },
            "calling": [
                "serialFlush"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f0e": {
            "entrypoint": "0x08003f0e",
            "current_name": "update_beta_08003f0e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nfloat updateBeta_08003f0e(LPF *inputData,float currentValue)\n\n{\n  undefined4 subResult;\n  undefined4 mulResult;\n  float beta;\n  float outputValue;\n  \n  beta = inputData->beta;\n  subResult = __aeabi_fsub(0x3f800000,beta);\n  subResult = __aeabi_fmul(subResult,currentValue);\n  mulResult = __aeabi_fmul(beta,inputData->last);\n  beta = (float)__addsf3(mulResult,subResult);\n  inputData->last = beta;\n  return outputValue;\n}\n\n",
            "renaming": {
                "FUN_08003f0e": "update_beta_08003f0e",
                "var": "inputData",
                "current": "currentValue",
                "fVar3": "beta",
                "uVar1": "subResult",
                "uVar2": "mulResult",
                "extraout_s0": "outputValue"
            },
            "calling": [
                "AHRS_GetRoll",
                "AHRS_GetPitch"
            ],
            "called": [
                "__addsf3",
                "__aeabi_fsub",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f3c": {
            "entrypoint": "0x08003f3c",
            "current_name": "set_le_ds_08003f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_LEDs_08003f3c(int is_white_LED_on,int is_red_LED_on,int is_blue_LED_on)\n\n{\n  HAL_GPIO_WritePin((GPIO_type *)0x40011000,0x8000,is_white_LED_on == 0);\n  HAL_GPIO_WritePin((GPIO_type *)0x40011000,0x4000,is_red_LED_on == 0);\n  HAL_GPIO_WritePin((GPIO_type *)0x40011000,0x2000,is_blue_LED_on == 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f3c": "set_le_ds_08003f3c",
                "led_white": "is_white_LED_on",
                "led_red": "is_red_LED_on",
                "led_blue": "is_blue_LED_on",
                "GPIO_TypeDef": "GPIO_type"
            },
            "calling": [
                "PID_Update",
                "LED_StartupSequence"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f7c": {
            "entrypoint": "0x08003f7c",
            "current_name": "blink_led_08003f7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid blinkLED_08003f7c(void)\n\n{\n  int iteration_count;\n  \n  iteration_count = 3;\n  do {\n    toggleLED(1,0,0);\n    delay_ms(100);\n    toggleLED(0,1,0);\n    delay_ms(100);\n    toggleLED(0,0,1);\n    delay_ms(100);\n    iteration_count = iteration_count + -1;\n  } while (iteration_count != 0);\n  toggleLED(1,1,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f7c": "blink_led_08003f7c",
                "iVar1": "iteration_count"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "toggleLED",
                "delay_ms"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fc4": {
            "entrypoint": "0x08003fc4",
            "current_name": "set_pwm_value_08003fc4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_value_08003fc4(int new_pwm_value)\n\n{\n  (pwm_timer_instance)->CCR4 = new_pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fc4": "set_pwm_value_08003fc4",
                "pwm": "new_pwm_value",
                "htim4.Instance": "pwm_timer_instance"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd0": {
            "entrypoint": "0x08003fd0",
            "current_name": "set_pwm_value_08003fd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPwmValue_08003fd0(int pwmValue)\n\n{\n  (htim4.Instance)->CCR3 = pwmValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd0": "set_pwm_value_08003fd0",
                "pwm": "pwmValue"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fdc": {
            "entrypoint": "0x08003fdc",
            "current_name": "update_pwm_value_08003fdc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid update_PWM_value_08003fdc(int new_PWM_value)\n\n{\n  (timer_2.Instance)->CCR2 = new_PWM_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fdc": "update_pwm_value_08003fdc",
                "pwm": "new_PWM_value",
                "htim2": "timer_2"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fe8": {
            "entrypoint": "0x08003fe8",
            "current_name": "set_pwm_08003fe8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pwm_08003fe8(int pwm_value)\n\n{\n  (htim3.Instance)->CCR3 = pwm_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fe8": "set_pwm_08003fe8",
                "pwm": "pwm_value"
            },
            "calling": [
                "Motor_StopAll",
                "Motor_SetSpeed"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff4": {
            "entrypoint": "0x08003ff4",
            "current_name": "start_pwm_timers_08003ff4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid start_PWM_timers_08003ff4(void)\n\n{\n  HAL_TIM_PWM_Start(timer2,4);\n  HAL_TIM_PWM_Start(timer3,8);\n  HAL_TIM_PWM_Start(timer4,8);\n  HAL_TIM_PWM_Start(timer4,0xc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff4": "start_pwm_timers_08003ff4",
                "&htim2": "timer2",
                "&htim3": "timer3",
                "&htim4": "timer4"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_TIM_PWM_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004028": {
            "entrypoint": "0x08004028",
            "current_name": "initialize_peripherals_08004028",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_peripherals_08004028(void)\n\n{\n  initialize_peripherals_08004028();\n  initialize_PWM();\n  run_LED_startup_sequence();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004028": "initialize_peripherals_08004028",
                "Peripherals_Init": "initialize_peripherals",
                "PWM_Init": "initialize_PWM",
                "LED_StartupSequence": "run_LED_startup_sequence"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "Peripherals_Init",
                "LED_StartupSequence",
                "PWM_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800403c": {
            "entrypoint": "0x0800403c",
            "current_name": "write_i2_c_register_with_delay_0800403c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid writeI2CRegisterWithDelay_0800403c(uint16_t deviceAddress,uint16_t registerAddress,uint8_t registerValue,uint8_t delayMode)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t returnValue;\n  uint8_t byteArray [1];\n  \n  byteArray[0] = registerValue;\n  status = HAL_I2C_Mem_Write(&hi2c1,deviceAddress,registerAddress,1,byteArray,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../Src/i2c.c\",0x1b);\n  }\n  if (delayMode != '\\0') {\n    delay_ms(0x32);\n  }\n  returnValueurn;\n}\n\n",
            "renaming": {
                "FUN_0800403c": "write_i2_c_register_with_delay_0800403c",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "register_val": "registerValue",
                "delay_mode": "delayMode",
                "HVar1": "status",
                "ret": "returnValue",
                "byte": "byteArray"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "MS5611_Init",
                "MS5611_Update"
            ],
            "called": [
                "delay_ms",
                "HAL_I2C_Mem_Write",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "read_i2_c_memory_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t readI2CMemory_0800407c(uint16_t deviceAddress,uint16_t registerAddress,char *sourceFile,int lineNumber)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t returnValue;\n  uint8_t data [1];\n  \n  data[0] = '\\0';\n  status = HAL_I2C_Mem_Read(&hi2c1,deviceAddress,registerAddress,1,data,1,200);\n  if (status != HAL_OK) {\n    _Error_Handler(sourceFile,lineNumber);\n  }\n  returnValueurn data[0];\n}\n\n",
            "renaming": {
                "FUN_0800407c": "read_i2_c_memory_0800407c",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "file": "sourceFile",
                "line": "lineNumber",
                "HVar1": "status",
                "ret": "returnValue",
                "byte": "data"
            },
            "calling": [
                "MPU9250_Init",
                "AK8963_Init",
                "AK8963_ReadData",
                "I2C_ReadByteArray"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b8": {
            "entrypoint": "0x080040b8",
            "current_name": "read_i2_c_data_080040b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readI2CData_080040b8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *dataBuffer,uint16_t bufferSize,char *fileName,\n                 int lineNumber)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t returnValue;\n  \n  status = HAL_I2C_Mem_Read(&hi2c1,deviceAddress,registerAddress,1,dataBuffer,bufferSize,200);\n  if (status != HAL_OK) {\n    _Error_Handler(fileName,lineNumber);\n    returnValueurn;\n  }\n  returnValueurn;\n}\n\n",
            "renaming": {
                "FUN_080040b8": "read_i2_c_data_080040b8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "bytes": "dataBuffer",
                "size": "bufferSize",
                "file": "fileName",
                "line": "lineNumber",
                "HVar1": "status",
                "ret": "returnValue"
            },
            "calling": [
                "MS5611_ReadADC"
            ],
            "called": [
                "HAL_I2C_Mem_Read",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "read_and_save_bytes_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndSaveBytes_080040e8(uint16_t deviceAddress,uint16_t registerAddress,uint8_t *byteArray,uint16_t arraySize,\n                 char *fileName,int lineNumber)\n\n{\n  uint8_t readByte;\n  int currentIndex;\n  uint8_t *currentByte;\n  \n  currentByte = byteArray + -1;\n  for (currentIndex = 0; currentIndex < (int)(uint)arraySize; currentIndex = currentIndex + 1) {\n    readByte = I2C_ReadByte(deviceAddress,registerAddress + (short)currentIndex,\"../Src/i2c.c\",0x4c);\n    currentByte = currentByte + 1;\n    *currentByte = readByte;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "read_and_save_bytes_080040e8",
                "device_add": "deviceAddress",
                "register_add": "registerAddress",
                "byte_array": "byteArray",
                "size": "arraySize",
                "file": "fileName",
                "line": "lineNumber",
                "uVar1": "readByte",
                "iVar2": "currentIndex",
                "puVar3": "currentByte"
            },
            "calling": [
                "AK8963_Init",
                "MS5611_Init",
                "MPU9250_ReadAccelData",
                "AK8963_ReadData",
                "MPU9250_ReadGyroData"
            ],
            "called": [
                "I2C_ReadByte"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800411c": {
            "entrypoint": "0x0800411c",
            "current_name": "update_sensors_0800411c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateSensors_0800411c(void)\n\n{\n  uint32_t currentMillis;\n  \n  currentMillis = millis();\n  if (1 < currentMillis - previousMillis1) {\n    previousMillis1 = millis();\n    AHRS_ComputeAngles();\n  }\n  currentMillis = millis();\n  if (2 < currentMillis - previousMillis3) {\n    previousMillis3 = millis();\n    PID_Update();\n  }\n  currentMillis = millis();\n  if (3 < currentMillis - previousMillis2) {\n    previousMillis2 = millis();\n    MSP_SendIdent();\n    MSP_SendStatus();\n    MSP_SendMotor();\n    MSP_SendAttitude();\n    MSP_SendAltitude();\n    MSP_SendRawIMU();\n    MSP_SendPID();\n  }\n  MS5611_Update();\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800411c": "update_sensors_0800411c",
                "uVar1": "currentMillis",
                "last_tick1": "previousMillis1",
                "last_tick3": "previousMillis3",
                "last_tick2": "previousMillis2"
            },
            "calling": [
                "main"
            ],
            "called": [
                "MSP_SendMotor",
                "PID_Update",
                "MSP_SendAttitude",
                "MSP_SendAltitude",
                "MSP_SendStatus",
                "AHRS_ComputeAngles",
                "MSP_SendPID",
                "millis",
                "MSP_SendIdent",
                "MS5611_Update",
                "MSP_SendRawIMU"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004194": {
            "entrypoint": "0x08004194",
            "current_name": "initialize_device_08004194",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDevice_08004194(void)\n\n{\n  Devices_Init();\n  serialBegin();\n  IMU_Init();\n  MS5611_Init();\n  PID_Init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004194": "initialize_device_08004194"
            },
            "calling": [
                "main"
            ],
            "called": [
                "PID_Init",
                "Devices_Init",
                "MS5611_Init",
                "IMU_Init",
                "serialBegin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ae": {
            "entrypoint": "0x080041ae",
            "current_name": "continuous_execution_080041ae",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint continuousExecution_080041ae(void)\n\n{\n  initializeForkserver(0);\n  initializeEnvironment();\n  do {\n    incrementSysTick();\n    executeTasks();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080041ae": "continuous_execution_080041ae",
                "startForkserver": "initializeForkserver",
                "setup": "initializeEnvironment",
                "HAL_IncTick": "incrementSysTick",
                "taskScheduler": "executeTasks"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "taskScheduler",
                "HAL_IncTick",
                "setup"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041c4": {
            "entrypoint": "0x080041c4",
            "current_name": "disable_motors_080041c4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableMotors_080041c4(void)\n\n{\n  setMotor1PWM(0);\n  setMotor2PWM(0);\n  setMotor3PWM(0);\n  setMotor4PWM(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041c4": "disable_motors_080041c4",
                "Motor1_SetPWM": "setMotor1PWM",
                "Motor2_SetPWM": "setMotor2PWM",
                "Motor3_SetPWM": "setMotor3PWM",
                "Motor4_SetPWM": "setMotor4PWM"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041e4": {
            "entrypoint": "0x080041e4",
            "current_name": "limit_and_set_pwm_080041e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid limitAndSetPWM_080041e4(int motor1Power,int motor2Power,int motor3Power,int motor4Power)\n\n{\n  if (999 < motor1Power) {\n    motor1Power = 1000;\n  }\n  if (999 < motor2Power) {\n    motor2Power = 1000;\n  }\n  if (999 < motor3Power) {\n    motor3Power = 1000;\n  }\n  if (999 < motor4Power) {\n    motor4Power = 1000;\n  }\n  pwmValues[2] = motor3Power & ~(motor3Power >> 0x1f);\n  pwmValues[3] = motor4Power & ~(motor4Power >> 0x1f);\n  pwmValues[1] = motor2Power & ~(motor2Power >> 0x1f);\n  pwmValues[0] = motor1Power & ~(motor1Power >> 0x1f);\n  setMotor1PWM(pwmValues[0]);\n  setMotor2PWM(pwmValues[1]);\n  setMotor3PWM(pwmValues[2]);\n  setMotor4PWM(pwmValues[3]);\n  mspTransmitFrameMotor.motor[0] = (short)pwmValues[0] + 1000;\n  mspTransmitFrameMotor.motor[1] = (short)pwmValues[1] + 1000;\n  mspTransmitFrameMotor.motor[2] = (short)pwmValues[2] + 1000;\n  mspTransmitFrameMotor.motor[3] = (short)pwmValues[3] + 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041e4": "limit_and_set_pwm_080041e4",
                "m1": "motor1Power",
                "m2": "motor2Power",
                "m3": "motor3Power",
                "m4": "motor4Power",
                "motor_pwm": "pwmValues",
                "Motor1_SetPWM": "setMotor1PWM",
                "Motor2_SetPWM": "setMotor2PWM",
                "Motor3_SetPWM": "setMotor3PWM",
                "Motor4_SetPWM": "setMotor4PWM",
                "msp_txf_motor": "mspTransmitFrameMotor"
            },
            "calling": [
                "Motor_DistributeSpeed"
            ],
            "called": [
                "Motor4_SetPWM",
                "Motor3_SetPWM",
                "Motor2_SetPWM",
                "Motor1_SetPWM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800426c": {
            "entrypoint": "0x0800426c",
            "current_name": "update_motor_speeds_0800426c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UpdateMotorSpeeds_0800426c(float throttleInput,float pitchInput,float rollInput,float yawInput)\n\n{\n  undefined4 throttleMinusRoll;\n  undefined4 throttlePlusPitch;\n  undefined4 throttleMinusRollPlusYaw;\n  int motor4Speed;\n  int motor3Speed;\n  int motor2Speed;\n  int motor1Speed;\n  \n  throttleMinusRoll = __aeabi_fsub();\n  throttlePlusPitch = __addsf3(throttleInput,pitchInput);\n  throttleMinusRollPlusYaw = __aeabi_fsub(throttleMinusRoll,rollInput);\n  throttleMinusRollPlusYaw = __addsf3(throttleMinusRollPlusYaw,yawInput);\n  __aeabi_fsub(throttleMinusRollPlusYaw,0x447a0000);\n  motor4Speed = __aeabi_f2iz();\n  throttleMinusRollPlusYaw = __aeabi_fsub(throttlePlusPitch,rollInput);\n  throttleMinusRollPlusYaw = __aeabi_fsub(throttleMinusRollPlusYaw,yawInput);\n  __aeabi_fsub(throttleMinusRollPlusYaw,0x447a0000);\n  motor3Speed = __aeabi_f2iz();\n  throttleMinusRoll = __addsf3(throttleMinusRoll,rollInput);\n  throttleMinusRoll = __aeabi_fsub(throttleMinusRoll,yawInput);\n  __aeabi_fsub(throttleMinusRoll,0x447a0000);\n  motor2Speed = __aeabi_f2iz();\n  throttleMinusRoll = __addsf3(rollInput,throttlePlusPitch);\n  throttleMinusRoll = __addsf3(throttleMinusRoll,yawInput);\n  __aeabi_fsub(throttleMinusRoll,0x447a0000);\n  motor1Speed = __aeabi_f2iz();\n  Motor_SetSpeed(motor1Speed,motor2Speed,motor3Speed,motor4Speed);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800426c": "update_motor_speeds_0800426c",
                "throttle": "throttleInput",
                "pitch": "pitchInput",
                "roll": "rollInput",
                "yaw": "yawInput",
                "uVar1": "throttleMinusRoll",
                "uVar2": "throttlePlusPitch",
                "uVar3": "throttleMinusRollPlusYaw",
                "m4": "motor4Speed",
                "m3": "motor3Speed",
                "m2": "motor2Speed",
                "m1": "motor1Speed"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_f2iz",
                "__addsf3",
                "__aeabi_fsub",
                "Motor_SetSpeed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004300": {
            "entrypoint": "0x08004300",
            "current_name": "send_encrypted_data_08004300",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendEncryptedData_08004300(uint8_t encryptionKey,uint8_t *inputData,uint16_t dataLength)\n\n{\n  byte checksum;\n  byte *currentByte;\n  \n  serialPrint(\"$M>\");\n  serialWrite((byte)dataLength);\n  checksum = (byte)dataLength ^ encryptionKey;\n  serialWrite(encryptionKey);\n  for (currentByte = inputData; (int)currentByte - (int)inputData < (int)(uint)dataLength; currentByte = currentByte + 1) {\n    serialWrite(*currentByte);\n    checksum = checksum ^ *currentByte;\n  }\n  serialWrite(checksum);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004300": "send_encrypted_data_08004300",
                "code": "encryptionKey",
                "data": "inputData",
                "data_length": "dataLength",
                "ch": "checksum",
                "pbVar1": "currentByte"
            },
            "calling": [
                "MSP_SendMotor",
                "MSP_SendAttitude",
                "MSP_SendStatus",
                "MSP_SendAltitude",
                "MSP_SendPID",
                "MSP_SendIdent",
                "MSP_SendRawIMU"
            ],
            "called": [
                "serialWrite",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004348": {
            "entrypoint": "0x08004348",
            "current_name": "send_frame_to_msp_08004348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendFrameToMSP_08004348(void)\n\n{\n  uint input;\n  uint8_t buffer [7];\n  undefined4 msp_txf_ident_0;\n  uint in_r1_masked;\n  \n  msp_txf_ident._0_4_ = 0x40003e9;\n  msp_txf_ident.capability._1_2_ = 0;\n  msp_txf_ident.capability._3_1_ = 0;\n  msp_txf_ident_0 = 0x40003e9;\n  in_r1_masked = input & 0xff000000;\n  MSP_SendFrame('d',(uint8_t *)&msp_txf_ident_0,7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004348": "send_frame_to_msp_08004348",
                "in_r1": "input",
                "buff": "buffer",
                "local_10": "msp_txf_ident_0",
                "local_c": "in_r1_masked"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004384": {
            "entrypoint": "0x08004384",
            "current_name": "initialize_transmission_08004384",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTransmission_08004384(void)\n\n{\n  uint inputData;\n  undefined4 transmissionStatus;\n  undefined4 transmissionFlag;\n  uint maskedInputData;\n  \n  msp_txf_status._4_4_ = 0x2a0007;\n  transmissionStatus = msp_txf_status._0_4_;\n  transmissionFlag = 0x2a0007;\n  msp_txf_status.flag._2_2_ = 0;\n  msp_txf_status.current_set = '\\0';\n  maskedInputData = inputData & 0xff000000;\n  MSP_SendFrame('e',(uint8_t *)&transmissionStatus,0xb);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004384": "initialize_transmission_08004384",
                "in_r3": "inputData",
                "local_14": "transmissionStatus",
                "uStack_10": "transmissionFlag",
                "local_c": "maskedInputData"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043bc": {
            "entrypoint": "0x080043bc",
            "current_name": "copy_raw_imu_data_080043bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid copyRawImuData_080043bc(void)\n\n{\n  undefined4 accx;\n  undefined4 accy;\n  undefined4 *destPtr;\n  RawImuStruct *rawImuPtr;\n  uint8_t buffer [18];\n  \n  rawImuPtr = &RawImuData;\n  destPtr = (undefined4 *)buffer;\n  do {\n    accx = *(undefined4 *)rawImuPtr;\n    accy = *(undefined4 *)&rawImuPtr->accz;\n    rawImuPtr = (RawImuStruct *)&rawImuPtr->gyry;\n    *destPtr = accx;\n    destPtr[1] = accy;\n    destPtr = destPtr + 2;\n  } while (rawImuPtr != (RawImuStruct *)&RawImuData.magz);\n  *(int16_t *)destPtr = RawImuData.magz;\n  sendFrame('f',buffer,0x12);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043bc": "copy_raw_imu_data_080043bc",
                "buff": "buffer",
                "pmVar4": "rawImuPtr",
                "puVar3": "destPtr",
                "uVar1": "accx",
                "uVar2": "accy",
                "msp_raw_imu": "RawImuStruct",
                "msp_txf_raw_imu": "RawImuData",
                "MSP_SendFrame": "sendFrame"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043f0": {
            "entrypoint": "0x080043f0",
            "current_name": "send_motor_data_080043f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid send_motor_data_080043f0(void)\n\n{\n  uint8_t buffer [8];\n  undefined4 motor_value_1;\n  undefined4 motor_value_2;\n  \n  motor_value_1 = msp_txf_motor.motor._0_4_;\n  motor_value_2 = msp_txf_motor.motor._4_4_;\n  MSP_SendFrame('h',(uint8_t *)&motor_value_1,8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080043f0": "send_motor_data_080043f0",
                "buff": "buffer",
                "local_10": "motor_value_1",
                "uStack_c": "motor_value_2"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004410": {
            "entrypoint": "0x08004410",
            "current_name": "send_attitude_frame_08004410",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendAttitudeFrame_08004410(void)\n\n{\n  undefined4 inputValue;\n  uint8_t buffer [6];\n  undefined4 attitudeData;\n  undefined4 headingData;\n  \n  attitudeData = msp_txf_attitude._0_4_;\n  headingData = CONCAT22((short)((uint)inputValue >> 0x10),msp_txf_attitude.heading);\n  MSP_SendFrame('l',(uint8_t *)&attitudeData,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004410": "send_attitude_frame_08004410",
                "in_r1": "inputValue",
                "buff": "buffer",
                "local_10": "attitudeData",
                "local_c": "headingData"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004434": {
            "entrypoint": "0x08004434",
            "current_name": "send_altitude_data_08004434",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendAltitudeData_08004434(void)\n\n{\n  undefined4 argument1;\n  uint8_t buffer [6];\n  int32_t estimatedAltitude;\n  undefined4 varioData;\n  \n  estimatedAltitude = msp_txf_altitude.est_alt;\n  varioData = CONCAT22((short)((uint)argument1 >> 0x10),msp_txf_altitude.vario);\n  MSP_SendFrame('m',(uint8_t *)&estimatedAltitude,6);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004434": "send_altitude_data_08004434",
                "in_r1": "argument1",
                "buff": "buffer",
                "local_10": "estimatedAltitude",
                "local_c": "varioData"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004458": {
            "entrypoint": "0x08004458",
            "current_name": "send_frame_with_pid_data_08004458",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sendFrameWithPidData_08004458(void)\n\n{\n  undefined4 *pidDataPtr;\n  undefined4 pitchData;\n  undefined4 *tempPtr;\n  msp_pid *currentPid;\n  msp_pid *nextPid;\n  uint8_t buffer [30];\n  undefined4 pidDataArray [3];\n  undefined2 yawArray [10];\n  \n  pidDataPtr = pidDataArray;\n  nextPid = &msp_txf_pid;\n  do {\n    currentPid = nextPid;\n    tempPtr = pidDataPtr;\n    pitchData = *(undefined4 *)&(currentPid->pitch).i;\n    nextPid = (msp_pid *)&(currentPid->yaw).d;\n    *tempPtr = *(undefined4 *)currentPid;\n    tempPtr[1] = pitchData;\n    pidDataPtr = tempPtr + 2;\n  } while (nextPid != (msp_pid *)&msp_txf_pid.mag);\n  tempPtr[2] = msp_txf_pid._24_4_;\n  *(undefined2 *)(tempPtr + 3) = *(undefined2 *)&currentPid->pos;\n  MSP_SendFrame('p',(uint8_t *)pidDataArray,0x1e);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004458": "send_frame_with_pid_data_08004458",
                "local_30": "pidDataArray",
                "local_24": "yawArray",
                "puVar1": "pidDataPtr",
                "uVar2": "pitchData",
                "puVar3": "tempPtr",
                "pmVar4": "currentPid",
                "pmVar5": "nextPid",
                "buff": "buffer"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "MSP_SendFrame"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004490": {
            "entrypoint": "0x08004490",
            "current_name": "handle_error_08004490",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleError_08004490(char *errorFile,int errorLine)\n\n{\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x4000,GPIO_PIN_SET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x8000,GPIO_PIN_RESET);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40011000,0x2000,GPIO_PIN_RESET);\n  do {\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x4000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x8000);\n    HAL_GPIO_TogglePin((GPIO_TypeDef *)0x40011000,0x2000);\n    serialPrint(\"Error with \");\n    serialPrint(errorFile);\n    serialPrint(\" at errorLine: \");\n    serialInt(errorLine);\n    serialWrite('\\n');\n    delay_ms(500);\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004490": "handle_error_08004490",
                "file": "errorFile",
                "line": "errorLine"
            },
            "calling": [
                "Peripherals_Init",
                "I2C_ReadByte",
                "I2C_ReadBytes",
                "I2C_WriteByte",
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "serialWrite",
                "delay_ms",
                "serialInt",
                "serialPrint",
                "HAL_GPIO_TogglePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004514": {
            "entrypoint": "0x08004514",
            "current_name": "configure_clocks_08004514",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureClocks_08004514(void)\n\n{\n  HAL_StatusTypeDef status;\n  char *errorMessage;\n  uint32_t sysTickFrequency;\n  int errorLine;\n  uint flashLatency;\n  RCC_ClkInitTypeDef rccClkInitStruct;\n  RCC_OscInitTypeDef rccOscInitStruct;\n  \n  rccOscInitStruct.HSIState = 1;\n  rccOscInitStruct.HSICalibrationValue = 0x10;\n  flashLatency = 2;\n  rccOscInitStruct.PLL.PLLSource = 0;\n  rccOscInitStruct.OscillatorType = 2;\n  rccOscInitStruct.PLL.PLLState = 2;\n  rccOscInitStruct.PLL.PLLMUL = 0x380000;\n  status = HAL_RCC_OscConfig(&rccOscInitStruct);\n  errorMessage = (char *)(uint)status;\n  if (errorMessage == (char *)0x0) goto LAB_08004540;\n  errorLine = 0x3c;\n  while( true ) {\n    errorMessage = \"../Src/peripherals.c\";\n    _Error_Handler(\"../Src/peripherals.c\",errorLine);\nLAB_08004540:\n    rccClkInitStruct.ClockType = 0xf;\n    rccClkInitStruct.APB1CLKDivider = 0x400;\n    rccClkInitStruct.SYSCLKSource = flashLatency;\n    rccClkInitStruct.AHBCLKDivider = (uint32_t)errorMessage;\n    rccClkInitStruct.APB2CLKDivider = (uint32_t)errorMessage;\n    status = HAL_RCC_ClockConfig(&rccClkInitStruct,flashLatency);\n    flashLatency = (uint)status;\n    if (flashLatency == 0) break;\n    errorLine = 0x49;\n  }\n  sysTickFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(sysTickFrequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004514": "configure_clocks_08004514",
                "RCC_OscInitStruct": "rccOscInitStruct",
                "FLatency": "flashLatency",
                "RCC_ClkInitStruct": "rccClkInitStruct",
                "HVar1": "status",
                "pcVar2": "errorMessage",
                "uVar3": "sysTickFrequency",
                "line": "errorLine"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_peripherals_0800458c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializePeripherals_0800458c(void)\n\n{\n  HAL_StatusTypeDef status;\n  char *errorHandler;\n  uint result;\n  int currentLine;\n  uint value;\n  uint32_t tempReg;\n  uint32_t tempReg1;\n  uint32_t tempReg2;\n  TIM_MasterConfigTypeDef masterConfig;\n  TIM_OC_InitTypeDef ocConfig;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  initializeHAL();\n  configureSystemClock();\n  value = 2;\n  _DAT_40021018 = _DAT_40021018 | 0x1c;\n  setGPIOPin((GPIO_TypeDef *)0x40011000,0xe000,GPIO_PIN_RESET);\n  setGPIOPin((GPIO_TypeDef *)0x40010800,0x20,GPIO_PIN_RESET);\n  gpioPin.Pin = 0xe000;\n  gpioPin.Mode = 1;\n  gpioPin.Speed = 2;\n  initializeGPIO((GPIO_TypeDef *)0x40011000,&gpioInitStruct);\n  gpioPin.Pin = 0x20;\n  gpioPin.Mode = 1;\n  gpioPin.Speed = 2;\n  initializeGPIO((GPIO_TypeDef *)0x40010800,&gpioInitStruct);\n  i2c.Instance = (I2C_TypeDef *)0x40005400;\n  i2c.Init.ClockSpeed = 400000;\n  i2c.Init.AddressingMode = 0x4000;\n  i2c.Init.DutyCycle = 0;\n  i2c.Init.OwnAddress1 = 0;\n  i2c.Init.DualAddressMode = 0;\n  i2c.Init.OwnAddress2 = 0;\n  i2c.Init.GeneralCallMode = 0;\n  i2c.Init.NoStretchMode = 0;\n  status = initializeI2C(&i2c);\n  errorHandler = (char *)(uint)status;\n  if (errorHandler == (char *)0x0) goto LAB_0800463a;\n  currentLine = 0x6b;\n  while( true ) {\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              while( true ) {\n                while( true ) {\n                  while( true ) {\n                    while( true ) {\n                      while( true ) {\n                        while( true ) {\n                          while( true ) {\n                            while( true ) {\n                              while( true ) {\n                                while( true ) {\n                                  errorHandler = \"../Src/peripherals.c\";\n                                  _Error_Handler(\"../Src/peripherals.c\",currentLine);\nLAB_0800463a:\n                                  uart.Instance = (USART_TypeDef *)0x40013800;\n                                  uart.Init.BaudRate = 0x1c200;\n                                  uart.Init.Mode = 0xc;\n                                  uart.Init.WordLength = (uint32_t)errorHandler;\n                                  uart.Init.StopBits = (uint32_t)errorHandler;\n                                  uart.Init.Parity = (uint32_t)errorHandler;\n                                  uart.Init.HwFlowCtl = (uint32_t)errorHandler;\n                                  uart.Init.OverSampling = (uint32_t)errorHandler;\n                                  status = initializeUART(&uart);\n                                  result = (uint)status;\n                                  if (result == 0) break;\n                                  currentLine = 0x151;\n                                }\n                                timer1.Instance = (TIM_TypeDef *)0x40012c00;\n                                timer1.Init.Period = 1000;\n                                timer1.Init.Prescaler = value;\n                                timer1.Init.CounterMode = result;\n                                timer1.Init.ClockDivision = result;\n                                timer1.Init.RepetitionCounter = result;\n                                status = initializePWMTimer(&timer1);\n                                result = (uint)status;\n                                if (result == 0) break;\n                                currentLine = 0x88;\n                              }\n                              masterConfig.MasterOutputTrigger = result;\n                              masterConfig.MasterSlaveMode = result;\n                              status = configurePWM(&timer1,&masterConfig);\n                              result = (uint)status;\n                              if (result == 0) break;\n                              currentLine = 0x8f;\n                            }\n                            ocConfig.OCMode = 0x60;\n                            ocConfig.Pulse = result;\n                            ocConfig.OCPolarity = result;\n                            ocConfig.OCFastMode = result;\n                            ocConfig.OCIdleState = result;\n                            ocConfig.OCNIdleState = result;\n                            status = HAL_TIM_PWM_ConfigChannel(&timer1,&ocConfig,0xc);\n                            result = (uint)status;\n                            if (result == 0) break;\n                            currentLine = 0x9a;\n                          }\n                          gpioPin.Pin = result;\n                          gpioPin.Mode = result;\n                          gpioInitStruct.Pull = result;\n                          gpioPin.Speed = result;\n                          status = HAL_TIMEx_ConfigBreakDeadTime\n                                            (&timer1,(TIM_BreakDeadTimeConfigTypeDef *)\n                                                    &gpioInitStruct);\n                          result = (uint)status;\n                          if (result == 0) break;\n                          currentLine = 0xa6;\n                        }\n                        postInitializeTimer(&timer1);\n                        timer2.Instance = (TIM_TypeDef *)0x40000000;\n                        timer2.Init.Period = 1000;\n                        timer2.Init.Prescaler = value;\n                        timer2.Init.CounterMode = result;\n                        timer2.Init.ClockDivision = result;\n                        status = initializePWMTimer(&timer2);\n                        result = (uint)status;\n                        if (result == 0) break;\n                        currentLine = 0xc3;\n                      }\n                      ocConfig.OCMode = result;\n                      ocConfig.Pulse = result;\n                      status = configurePWM\n                                        (&timer2,(TIM_MasterConfigTypeDef *)&ocConfig);\n                      result = (uint)status;\n                      if (result == 0) break;\n                      currentLine = 0xca;\n                    }\n                    gpioPin.Pin = 0x60;\n                    gpioPin.Mode = result;\n                    gpioInitStruct.Pull = result;\n                    status = HAL_TIM_PWM_ConfigChannel\n                                      (&timer2,(TIM_OC_InitTypeDef *)&gpioInitStruct,4);\n                    result = (uint)status;\n                    if (result == 0) break;\n                    currentLine = 0xd3;\n                  }\n                  postInitializeTimer(&timer2);\n                  timer3.Init.Period = 1000;\n                  timer3.Instance = (TIM_TypeDef *)0x40000400;\n                  timer3.Init.Prescaler = value;\n                  timer3.Init.CounterMode = result;\n                  timer3.Init.ClockDivision = result;\n                  status = initializePWMTimer(&timer3);\n                  if (status == HAL_OK) break;\n                  currentLine = 0xf0;\n                }\n                ocConfig.OCMode = 0;\n                ocConfig.Pulse = 0;\n                status = configurePWM\n                                  (&timer3,(TIM_MasterConfigTypeDef *)&ocConfig);\n                result = (uint)status;\n                if (result == 0) break;\n                currentLine = 0xf7;\n              }\n              gpioPin.Pin = 0x60;\n              gpioPin.Mode = result;\n              gpioInitStruct.Pull = result;\n              status = HAL_TIM_PWM_ConfigChannel(&timer3,(TIM_OC_InitTypeDef *)&gpioInitStruct,8);\n              if (status == HAL_OK) break;\n              currentLine = 0x100;\n            }\n            status = HAL_TIM_PWM_ConfigChannel(&timer3,(TIM_OC_InitTypeDef *)&gpioInitStruct,0xc);\n            value = (uint)status;\n            if (value == 0) break;\n            currentLine = 0x105;\n          }\n          postInitializeTimer(&timer3);\n          timer4.Instance = (TIM_TypeDef *)0x40000800;\n          timer4.Init.Prescaler = 2;\n          timer4.Init.Period = 1000;\n          timer4.Init.CounterMode = value;\n          timer4.Init.ClockDivision = value;\n          status = initializePWMTimer(&timer4);\n          result = (uint)status;\n          if (result == 0) break;\n          currentLine = 0x122;\n        }\n        ocConfig.OCMode = result;\n        ocConfig.Pulse = result;\n        status = configurePWM(&timer4,(TIM_MasterConfigTypeDef *)&ocConfig);\n        result = (uint)status;\n        if (result == 0) break;\n        currentLine = 0x129;\n      }\n      gpioPin.Pin = 0x60;\n      gpioPin.Mode = result;\n      gpioInitStruct.Pull = result;\n      status = HAL_TIM_PWM_ConfigChannel(&timer4,(TIM_OC_InitTypeDef *)&gpioInitStruct,8);\n      if (status == HAL_OK) break;\n      currentLine = 0x132;\n    }\n    status = HAL_TIM_PWM_ConfigChannel(&timer4,(TIM_OC_InitTypeDef *)&gpioInitStruct,0xc);\n    if (status == HAL_OK) break;\n    currentLine = 0x137;\n  }\n  postInitializeTimer(&timer4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_peripherals_0800458c",
                "HVar1": "status",
                "pcVar2": "errorHandler",
                "uVar3": "result",
                "line": "currentLine",
                "uVar4": "value",
                "tmpreg": "tempReg",
                "tmpreg_1": "tempReg1",
                "tmpreg_2": "tempReg2",
                "sMasterConfig": "masterConfig",
                "sConfigOC": "ocConfig",
                "GPIO_InitStruct": "gpioInitStruct",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock",
                "HAL_GPIO_WritePin": "setGPIOPin",
                "hi2c1": "i2c",
                "HAL_I2C_Init": "initializeI2C",
                "huart1": "uart",
                "HAL_UART_Init": "initializeUART",
                "htim1": "timer1",
                "HAL_TIM_PWM_Init": "initializePWMTimer",
                "HAL_TIMEx_MasterConfigSynchronization": "configurePWM",
                "GPIO_InitStruct.Pin": "gpioPin.Pin",
                "GPIO_InitStruct.Mode": "gpioPin.Mode",
                "GPIO_InitStruct.Speed": "gpioPin.Speed",
                "HAL_GPIO_Init": "initializeGPIO",
                "HAL_TIM_MspPostInit": "postInitializeTimer",
                "htim2": "timer2",
                "htim3": "timer3",
                "htim4": "timer4"
            },
            "calling": [
                "Devices_Init"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_UART_Init",
                "HAL_Init",
                "HAL_GPIO_Init",
                "HAL_I2C_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_ConfigChannel",
                "_Error_Handler",
                "HAL_TIM_PWM_Init",
                "HAL_TIM_MspPostInit",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800483c": {
            "entrypoint": "0x0800483c",
            "current_name": "calculate_pid_output_0800483c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid calculatePIDOutput_0800483c(PIDData *data)\n\n{\n  undefined4 temp1;\n  int comparison;\n  undefined4 temp2;\n  float proportional;\n  float derivative;\n  float integral;\n  \n  proportional = data->input;\n  temp1 = __addsf3(data->set_point,data->offset);\n  proportional = (float)__aeabi_fsub(temp1,proportional);\n  data->error = proportional;\n  if (data->instance == 3) {\n    comparison = __aeabi_fcmpgt(data->error,0);\n    if (comparison == 0) {\n      comparison = __aeabi_fcmplt(data->error,0xc3340000);\n    }\n    else {\n      comparison = __aeabi_fcmpgt(data->error,0x43340000);\n    }\n    if (comparison != 0) {\n      derivative = data->error;\n      temp1 = __aeabi_fmul(data->error,0x43b40000);\n      comparison = __aeabi_fcmpgt(data->error,0);\n      proportional = data->error;\n      if (comparison == 0) {\n        proportional = (float)((int)proportional + -0x80000000);\n      }\n      temp1 = __aeabi_fdiv(temp1,proportional);\n      proportional = (float)__aeabi_fsub(derivative,temp1);\n      data->error = proportional;\n    }\n  }\n  integral = data->con_KI;\n  derivative = data->con_KD;\n  proportional = (float)__aeabi_fmul(data->con_KP,data->error);\n  data->proportional = proportional;\n  proportional = (float)__addsf3(data->error,data->integral);\n  data->integral = proportional;\n  comparison = __aeabi_fcmplt(data->integral,0xc3fa0000);\n  if (comparison == 0) {\n    comparison = __aeabi_fcmpgt(data->integral,0x43fa0000);\n    if (comparison == 0) {\n      proportional = data->integral;\n    }\n    else {\n      proportional = 500.0;\n    }\n  }\n  else {\n    proportional = -500.0;\n  }\n  data->integral = proportional;\n  proportional = (float)__aeabi_fsub(data->input,data->last_input);\n  data->derivative = proportional;\n  proportional = data->proportional;\n  temp1 = __aeabi_fmul(integral,data->integral);\n  temp1 = __addsf3(temp1,proportional);\n  temp2 = __aeabi_fmul(derivative,data->derivative);\n  proportional = (float)__aeabi_fsub(temp1,temp2);\n  data->output = proportional;\n  temp1 = __floatsisf(data->direction);\n  comparison = __aeabi_fcmplt(data->output,0xc3fa0000);\n  if (comparison == 0) {\n    comparison = __aeabi_fcmpgt(data->output,0x43fa0000);\n    if (comparison == 0) {\n      proportional = data->output;\n    }\n    else {\n      proportional = 500.0;\n    }\n  }\n  else {\n    proportional = -500.0;\n  }\n  proportional = (float)__aeabi_fmul(proportional,temp1);\n  data->output = proportional;\n  data->last_input = data->input;\n  data->last_error = data->error;\n  data->last_time = data->time;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800483c": "calculate_pid_output_0800483c",
                "PID_TypeDef": "PIDData",
                "pid": "data",
                "uVar1": "temp1",
                "iVar2": "comparison",
                "uVar3": "temp2",
                "fVar4": "proportional",
                "fVar5": "derivative",
                "fVar6": "integral"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "__aeabi_fdiv",
                "__addsf3",
                "__aeabi_fsub",
                "__floatsisf",
                "__aeabi_fmul",
                "__aeabi_fcmplt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "initialize_pid_parameters_08004978",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePIDParameters_08004978(void)\n\n{\n  pitchPID.direction = 1;\n  rollPID.direction = 1;\n  yawPID.direction = -1;\n  altitudePID.direction = 1;\n  pitchPID.breakpoint = 1500.0;\n  rollPID.breakpoint = 1450.0;\n  yawPID.breakpoint = 2000.0;\n  altitudePID.breakpoint = 0.0;\n  pitchPID.controlled_KP = 4.4;\n  pitchPID.controlled_KI = 0.02;\n  pitchPID.controlled_KD = 280.0;\n  pitchPID.aggressive_KP = 4.5;\n  pitchPID.aggressive_KI = 0.02;\n  pitchPID.aggressive_KD = 360.0;\n  rollPID.controlled_KP = 3.8;\n  rollPID.controlled_KI = 0.02;\n  rollPID.controlled_KD = 260.0;\n  rollPID.aggressive_KP = 3.8;\n  rollPID.aggressive_KI = 0.02;\n  rollPID.aggressive_KD = 320.0;\n  yawPID.controlled_KP = 3.0;\n  yawPID.controlled_KI = 0.01;\n  yawPID.controlled_KD = 280.0;\n  yawPID.aggressive_KP = 0.0;\n  yawPID.aggressive_KI = 0.0;\n  yawPID.aggressive_KD = 0.0;\n  altitudePID.controlled_KP = 10.0;\n  altitudePID.controlled_KI = 0.0;\n  altitudePID.controlled_KD = 0.0;\n  altitudePID.aggressive_KP = 0.0;\n  altitudePID.aggressive_KI = 0.0;\n  altitudePID.aggressive_KD = 0.0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004978": "initialize_pid_parameters_08004978",
                "pid_pitch": "pitchPID",
                "pid_roll": "rollPID",
                "pid_yaw": "yawPID",
                "pid_altitude": "altitudePID",
                "con_KP": "controlled_KP",
                "con_KI": "controlled_KI",
                "con_KD": "controlled_KD",
                "agr_KP": "aggressive_KP",
                "agr_KI": "aggressive_KI",
                "agr_KD": "aggressive_KD"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a30": {
            "entrypoint": "0x08004a30",
            "current_name": "update_altitude_hold_08004a30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateAltitudeHold_08004a30(void)\n\n{\n  if (inputJoystick.ALT_HOLD != '\\0') {\n    if (altitudeFlag == '\\0') {\n      getFilteredAltitude();\n      altitudePIDController.set_point = (float)multiplyFloats();\n      altitudeFlag = '\\x01';\n    }\n    else {\n      getFilteredAltitude();\n      altitudePIDController.currentAltitude = (float)multiplyFloats();\n    }\n  }\n  if (inputJoystick.ALT_HOLD == '\\0') {\n    if (altitudeFlag != '\\0') {\n      altitudeFlag = inputJoystick.ALT_HOLD;\n    }\n    altitudePIDController.targetAltitude = inputJoystick.throttleValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a30": "update_altitude_hold_08004a30",
                "joystick": "inputJoystick",
                "ALT_FLAG": "altitudeFlag",
                "MS5611_GetFilteredAltitude": "getFilteredAltitude",
                "pid_altitude": "altitudePIDController",
                "__aeabi_fmul": "multiplyFloats",
                "input": "currentAltitude",
                "output": "targetAltitude",
                "throttle": "throttleValue"
            },
            "calling": [
                "PID_Update"
            ],
            "called": [
                "MS5611_GetFilteredAltitude",
                "__aeabi_fmul"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "flight_controller_08004a84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid flightController_08004a84(void)\n\n{\n  float pitchInput;\n  int comparisonResult;\n  \n  getPitchAHRS();\n  pitchPID.input = pitchInput;\n  getRollAHRS();\n  rollInput = pitchInput;\n  getYawAHRS();\n  yawPID.input = pitchInput;\n  updateAltitudePID();\n  comparisonResult = compareFloatGreater(pitchPID.input,0);\n  if (comparisonResult == 0) {\n    comparisonResult = compareFloatLess(pitchPID.input,0xc2a00000);\n  }\n  else {\n    comparisonResult = compareFloatGreater(pitchPID.input,0x42a00000);\n  }\n  if (comparisonResult == 0) {\n    comparisonResult = compareFloatGreater(rollInput,0);\n    if (comparisonResult == 0) {\n      comparisonResult = compareFloatLess(rollInput,0xc2a00000);\n    }\n    else {\n      comparisonResult = compareFloatGreater(rollInput,0x42a00000);\n    }\n    if (comparisonResult == 0) {\n      toggleLED(1,1,1);\n      computePID(&pitchPID);\n      computePID(&rollPID);\n      computePID(&yawPID);\n      if (joystick.ALT_HOLD != '\\0') {\n        computeAltitudePID;\n        addFloat(altitudeOutput,0x44bb8000);\n      }\n      altitudeOutput = joystick.throttle;\n      if (joystick.MOTOR_ARM == '\\0') {\n        stopAllMotors();\n      }\n      else {\n        distributeMotorSpeed(joystick.throttle,pitchPID.output,rollPID.output,yawPID.output);\n      }\n      __aeabi_fmul(pitchProportionalConstant,0x437f0000);\n      pitchP = fixFloatUnsignedToInteger();\n      __aeabi_fmul(pitchIntegralConstant,0x437f0000);\n      pitchI = fixFloatUnsignedToInteger();\n      __aeabi_fmul(rollProportionalConstant,0x437f0000);\n      rollP = fixFloatUnsignedToInteger();\n      __aeabi_fmul(rollIntegralConstant,0x437f0000);\n      rollI = fixFloatUnsignedToInteger();\n      __aeabi_fmul(rollDerivativeConstant,0x437f0000);\n      rollD = fixFloatUnsignedToInteger();\n      __aeabi_fmul(yawProportionalConstant,0x437f0000);\n      yawP = fixFloatUnsignedToInteger();\n      __aeabi_fmul(yawIntegralConstant,0x437f0000);\n      yawI = fixFloatUnsignedToInteger();\n      __aeabi_fmul(yawDerivativeConstant,0x437f0000);\n      yawD = fixFloatUnsignedToInteger();\n      __aeabi_fmul(altitudeProportionalConstant,0x437f0000);\n      altitudeP = fixFloatUnsignedToInteger();\n      __aeabi_fmul(altitudeIntegralConstant,0x437f0000);\n      altitudeI = fixFloatUnsignedToInteger();\n      __aeabi_fmul(altitudeDerivativeConstant,0x437f0000);\n      altitudeD = fixFloatUnsignedToInteger();\n      return;\n    }\n  }\n  stopAllMotors();\n  toggleLED(0,1,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "flight_controller_08004a84",
                "in_r0": "pitchInput",
                "iVar1": "comparisonResult",
                "AHRS_GetPitch": "getPitchAHRS",
                "pid_pitch": "pitchPID",
                "AHRS_GetRoll": "getRollAHRS",
                "pid_roll": "rollPID",
                "AHRS_GetYaw": "getYawAHRS",
                "pid_yaw": "yawPID",
                "PID_UpdateAltitude": "updateAltitudePID",
                "__aeabi_fcmpgt": "compareFloatGreater",
                "__aeabi_fcmplt": "compareFloatLess",
                "pid_roll.input": "rollInput",
                "PID_Compute": "computePID",
                "PID_Compute(&pid_altitude)": "computeAltitudePID",
                "__addsf3": "addFloat",
                "pid_altitude.output": "altitudeOutput",
                "Motor_StopAll": "stopAllMotors",
                "Motor_DistributeSpeed": "distributeMotorSpeed",
                "pid_pitch.con_KP": "pitchProportionalConstant",
                "msp_txf_pid.pitch.p": "pitchP",
                "__fixunssfsi": "fixFloatUnsignedToInteger",
                "pid_pitch.con_KI": "pitchIntegralConstant",
                "msp_txf_pid.pitch.i": "pitchI",
                "pid_roll.con_KP": "rollProportionalConstant",
                "msp_txf_pid.roll.p": "rollP",
                "pid_roll.con_KI": "rollIntegralConstant",
                "msp_txf_pid.roll.i": "rollI",
                "pid_roll.con_KD": "rollDerivativeConstant",
                "msp_txf_pid.roll.d": "rollD",
                "pid_yaw.con_KP": "yawProportionalConstant",
                "msp_txf_pid.yaw.p": "yawP",
                "pid_yaw.con_KI": "yawIntegralConstant",
                "msp_txf_pid.yaw.i": "yawI",
                "pid_yaw.con_KD": "yawDerivativeConstant",
                "msp_txf_pid.yaw.d": "yawD",
                "pid_altitude.con_KP": "altitudeProportionalConstant",
                "msp_txf_pid.alt.p": "altitudeP",
                "pid_altitude.con_KI": "altitudeIntegralConstant",
                "msp_txf_pid.alt.i": "altitudeI",
                "pid_altitude.con_KD": "altitudeDerivativeConstant",
                "msp_txf_pid.alt.d": "altitudeD"
            },
            "calling": [
                "taskScheduler"
            ],
            "called": [
                "__aeabi_fcmpgt",
                "Motor_StopAll",
                "__aeabi_fmul",
                "__aeabi_fcmplt",
                "AHRS_GetRoll",
                "PID_Compute",
                "__addsf3",
                "toggleLED",
                "Motor_DistributeSpeed",
                "AHRS_GetPitch",
                "__fixunssfsi",
                "AHRS_GetYaw",
                "PID_UpdateAltitude"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c18": {
            "entrypoint": "0x08004c18",
            "current_name": "transmit_character_08004c18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitCharacter_08004c18(ucharacterar character)\n\n{\n  transmitBuffer[0] = character;\n  transmitUARTData(&huart1,(uint8_t *)transmitBuffer,1,5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c18": "transmit_character_08004c18",
                "ch": "character",
                "tx_buffer": "transmitBuffer",
                "HAL_UART_Transmit": "transmitUARTData"
            },
            "calling": [
                "MSP_SendFrame",
                "serialPrint",
                "_Error_Handler"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "process_uart_data_08004c30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid process_uart_data_08004c30(UART_HandleTypeDef *uart_handle)\n\n{\n  if (uart_handle->Instance == (usart_type *)0x40013800) {\n    write_to_circular_buffer(&circular_buffer,received_data_buffer[0]);\n    initiate_uart_receive_with_interrupt(&uart_handle1,received_data_buffer,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "process_uart_data_08004c30",
                "huart": "uart_handle",
                "USART_TypeDef": "usart_type",
                "CB_Write": "write_to_circular_buffer",
                "rxc": "circular_buffer",
                "rx_buffer": "received_data_buffer",
                "HAL_UART_Receive_IT": "initiate_uart_receive_with_interrupt"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "CB_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c64": {
            "entrypoint": "0x08004c64",
            "current_name": "initialize_communication_subsystem_08004c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeCommunicationSubsystem_08004c64(void)\n\n{\n  CB_Init(&receiveChannel);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c64": "initialize_communication_subsystem_08004c64",
                "rxc": "receiveChannel"
            },
            "calling": [
                "serialBegin"
            ],
            "called": [
                "CB_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c70": {
            "entrypoint": "0x08004c70",
            "current_name": "initialize_serial_communication_08004c70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_08004c70(void)\n\n{\n  flushSerialBuffer();\n  receiveSerialDataInterrupt(serialInterface,receiveBuffer,1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c70": "initialize_serial_communication_08004c70",
                "serialFlush": "flushSerialBuffer",
                "HAL_UART_Receive_IT": "receiveSerialDataInterrupt",
                "&huart1": "serialInterface",
                "rx_buffer": "receiveBuffer"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "serialFlush",
                "HAL_UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8c": {
            "entrypoint": "0x08004c8c",
            "current_name": "print_string_08004c8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printString_08004c8c(char *inputString)\n\n{\n  size_t stringLength;\n  uchar *stringPointer;\n  \n  for (stringPointer = (uchar *)inputString; stringLength = strlen(inputString), (uint)((int)stringPointer - (int)inputString) < stringLength;\n      stringPointer = stringPointer + 1) {\n    serialWrite(*stringPointer);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c8c": "print_string_08004c8c",
                "data": "inputString",
                "sVar1": "stringLength",
                "puVar2": "stringPointer"
            },
            "calling": [
                "MSP_SendFrame",
                "serialInt",
                "_Error_Handler"
            ],
            "called": [
                "strlen",
                "serialWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cac": {
            "entrypoint": "0x08004cac",
            "current_name": "print_integer_value_08004cac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid printIntegerValue_08004cac(int integerValue)\n\n{\n  siprintf(buffer,\"%i\",integerValue);\n  serialPrint(buffer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004cac": "print_integer_value_08004cac",
                "val": "integerValue",
                "tx_buffer": "buffer"
            },
            "calling": [
                "_Error_Handler"
            ],
            "called": [
                "siprintf",
                "serialPrint"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ccc": {
            "entrypoint": "0x08004ccc",
            "current_name": "initialize_interrupts_08004ccc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeInterrupts_08004ccc(void)\n\n{\n  uint32_t temporaryRegister;\n  \n  _DAT_40021018 = _DAT_40021018 | 1;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_NVIC_SetPriority(MemoryManagement_IRQn,0,0);\n  HAL_NVIC_SetPriority(BusFault_IRQn,0,0);\n  HAL_NVIC_SetPriority(UsageFault_IRQn,0,0);\n  HAL_NVIC_SetPriority(SVCall_IRQn,0,0);\n  HAL_NVIC_SetPriority(DebugMonitor_IRQn,0,0);\n  HAL_NVIC_SetPriority(PendSV_IRQn,0,0);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ccc": "initialize_interrupts_08004ccc",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d48": {
            "entrypoint": "0x08004d48",
            "current_name": "initialize_i2_cgpio_08004d48",
            "code": "\n/* WARNING: Variable defined which should be unmapped: gpioInit */\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeI2CGPIO_08004d48(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t temporaryRegister;\n  GPIO_InitTypeDef gpioInit;\n  \n  if (i2cHandle->Instance == (I2C_TypeDef *)0x40005400) {\n    gpioPin = 0xc0;\n    gpioMode = 0x12;\n    gpioSpeed = 3;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010c00,&gpioInit);\n    _DAT_4002101c = _DAT_4002101c | 0x200000;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d48": "initialize_i2_cgpio_08004d48",
                "hi2c": "i2cHandle",
                "tmpreg": "temporaryRegister",
                "GPIO_InitStruct": "gpioInit",
                "GPIO_InitStruct.Pin": "gpioPin",
                "GPIO_InitStruct.Mode": "gpioMode",
                "GPIO_InitStruct.Speed": "gpioSpeed"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d8c": {
            "entrypoint": "0x08004d8c",
            "current_name": "set_timer_instance_flags_08004d8c",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nvoid setTimerInstanceFlags_08004d8c(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_RegisterType *timerInstance;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister_1;\n  uint32_t temporaryRegister_2;\n  uint32_t temporaryRegister_3;\n  \n  timerInstance = timerHandle->Instance;\n  if (timerInstance == (TIM_RegisterType *)0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 | 0x800;\n  }\n  else if (timerInstance == (TIM_RegisterType *)0x40000000) {\n    _DAT_4002101c = _DAT_4002101c | 1;\n  }\n  else if (timerInstance == (TIM_RegisterType *)0x40000400) {\n    _DAT_4002101c = _DAT_4002101c | 2;\n  }\n  else if (timerInstance == (TIM_RegisterType *)0x40000800) {\n    _DAT_4002101c = _DAT_4002101c | 4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d8c": "set_timer_instance_flags_08004d8c",
                "htim_pwm": "timerHandle",
                "TIM_TypeDef": "TIM_RegisterType",
                "pTVar1": "timerInstance",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister_1",
                "tmpreg_2": "temporaryRegister_2",
                "tmpreg_3": "temporaryRegister_3"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e14": {
            "entrypoint": "0x08004e14",
            "current_name": "initialize_gpio_08004e14",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_08004e14(TIM_HandleTypeDef *timerHandle)\n\n{\n  GPIO_TypeDef *gpioPort;\n  TIM_TypeDef *timerInstance;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  timerInstance = timerHandle->Instance;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    gpioInitStruct.Pin = 0x800;\n  }\n  else {\n    if (timerInstance != (TIM_TypeDef *)0x40000000) {\n      if (timerInstance == (TIM_TypeDef *)0x40000400) {\n        gpioInitStruct.Pin = 3;\n      }\n      else {\n        if (timerInstance != (TIM_TypeDef *)0x40000800) {\n          return;\n        }\n        gpioInitStruct.Pin = 0x300;\n      }\n      gpioPort = (GPIO_TypeDef *)0x40010c00;\n      goto LAB_08004e2e;\n    }\n    gpioInitStruct.Pin = 2;\n  }\n  gpioPort = (GPIO_TypeDef *)0x40010800;\nLAB_08004e2e:\n  gpioInitStruct.Speed = 2;\n  gpioInitStruct.Mode = 2;\n  HAL_GPIO_Init(gpioPort,&gpioInitStruct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e14": "initialize_gpio_08004e14",
                "htim": "timerHandle",
                "GPIOx": "gpioPort",
                "pTVar1": "timerInstance",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "Peripherals_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e7c": {
            "entrypoint": "0x08004e7c",
            "current_name": "initialize_uart_08004e7c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initialize_UART_08004e7c(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t temporary_register;\n  GPIO_InitTypeDef gpio_init_struct;\n  \n  if (uart_handle->Instance == (USART_TypeDef *)0x40013800) {\n    _DAT_40021018 = _DAT_40021018 | 0x4000;\n    gpio_init_struct.Pin = 0x200;\n    gpio_init_struct.Mode = 2;\n    gpio_init_struct.Speed = 3;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpio_init_struct);\n    gpio_init_struct.Pin = 0x400;\n    gpio_init_struct.Mode = 0;\n    gpio_init_struct.Pull = 0;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpio_init_struct);\n    HAL_NVIC_SetPriority(USART1_IRQn,0,0);\n    HAL_NVIC_EnableIRQ(USART1_IRQn);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e7c": "initialize_uart_08004e7c",
                "huart": "uart_handle",
                "tmpreg": "temporary_register",
                "GPIO_InitStruct": "gpio_init_struct"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_GPIO_Init",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee4": {
            "entrypoint": "0x08004ee4",
            "current_name": "FUNC_08004ee4",
            "code": "\nvoid FUNC_08004ee4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee4": "FUNC_08004ee4"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee6": {
            "entrypoint": "0x08004ee6",
            "current_name": "run_infinite_loop_08004ee6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid runInfiniteLoop_08004ee6(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee6": "run_infinite_loop_08004ee6"
            },
            "calling": [
                "HardFault_Handler"
            ],
            "called": [
                "HardFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "infinite_loop_08004ee8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004ee8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "infinite_loop_08004ee8"
            },
            "calling": [
                "MemManage_Handler"
            ],
            "called": [
                "MemManage_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eea": {
            "entrypoint": "0x08004eea",
            "current_name": "infinite_loop_08004eea",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004eea(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eea": "infinite_loop_08004eea"
            },
            "calling": [
                "BusFault_Handler"
            ],
            "called": [
                "BusFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eec": {
            "entrypoint": "0x08004eec",
            "current_name": "infinite_loop_08004eec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_08004eec(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004eec": "infinite_loop_08004eec"
            },
            "calling": [
                "UsageFault_Handler"
            ],
            "called": [
                "UsageFault_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004eee": {
            "entrypoint": "0x08004eee",
            "current_name": "FUNC_08004eee",
            "code": "\nvoid FUNC_08004eee(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004eee": "FUNC_08004eee"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef0": {
            "entrypoint": "0x08004ef0",
            "current_name": "FUNC_08004ef0",
            "code": "\nvoid FUNC_08004ef0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef0": "FUNC_08004ef0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef2": {
            "entrypoint": "0x08004ef2",
            "current_name": "FUNC_08004ef2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004ef2(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef2": "FUNC_08004ef2"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "handle_sys_tick_interrupt_08004ef4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08004ef4(void)\n\n{\n  incrementSystemTick();\n  handleSysTickIRQ();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "handle_sys_tick_interrupt_08004ef4",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickIRQ"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f04": {
            "entrypoint": "0x08004f04",
            "current_name": "handle_uart_interrupt_08004f04",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_interrupt_08004f04(void)\n\n{\n  HAL_UART_IRQHandler(uart_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f04": "handle_uart_interrupt_08004f04",
                "&huart1": "uart_handler"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f10": {
            "entrypoint": "0x08004f10",
            "current_name": "initialize_memory_08004f10",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_08004f10(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f10": "initialize_memory_08004f10"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f5c": {
            "entrypoint": "0x08004f5c",
            "current_name": "FUN_08004f5c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetTick(void)\n\n{\n  return uwTick;\n}\n\n",
            "renaming": {},
            "calling": [
                "taskScheduler",
                "MS5611_Update"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "get_uw_tick_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_uwTick_08004f60(void)\n\n{\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "get_uw_tick_08004f60",
                "uwTick": "current_tick"
            },
            "calling": [
                "AHRS_ComputeAngles"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f64": {
            "entrypoint": "0x08004f64",
            "current_name": "FUNC_08004f64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004f64(uint32_t Delay)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f64": "FUNC_08004f64"
            },
            "calling": [
                "LED_StartupSequence",
                "MS5611_Init",
                "I2C_WriteByte",
                "_Error_Handler"
            ],
            "called": [
                "HAL_Delay"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004f68": {
            "entrypoint": "0x08004f68",
            "current_name": "initialize_program_08004f68",
            "code": "\nvoid initializeProgram_08004f68(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8672; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (pointer = &completed_8672; pointer < &_ebss; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8004f9a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08004f9a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f68": "initialize_program_08004f68",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb0": {
            "entrypoint": "0x08004fb0",
            "current_name": "loop_forever_08004fb0",
            "code": "\nvoid loopForever_08004fb0(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004fb0": "loop_forever_08004fb0"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fb4": {
            "entrypoint": "0x08004fb4",
            "current_name": "initialize_crypto_context_08004fb4",
            "code": "\nvoid initializeCryptoContext_08004fb4(EVP_PKEY_CTX *cryptoContext)\n\n{\n  int iterator;\n  \n  for (iterator = 0; iterator != 0; iterator = iterator + 1) {\n    cryptoContext = (EVP_PKEY_CTX *)(*(code *)(&__frame_dummy_init_array_entry)[iterator])();\n  }\n  _init(cryptoContext);\n  for (iterator = 0; iterator != 1; iterator = iterator + 1) {\n    (*(code *)(&__frame_dummy_init_array_entry)[iterator])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004fb4": "initialize_crypto_context_08004fb4",
                "param_1": "cryptoContext",
                "iVar1": "iterator"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ffc": {
            "entrypoint": "0x08004ffc",
            "current_name": "clear_string_and_format_08004ffc",
            "code": "\nint clearStringAndFormat_08004ffc(char *string,char *format,...)\n\n{\n  int result;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *stringPtrArray [2];\n  undefined4 maxStringLength;\n  undefined2 bufferSize;\n  undefined2 maxArraySize;\n  char *currentStringPtr;\n  undefined4 maxArrayLength;\n  char *currentFormatPtr;\n  undefined4 ptrStack_8;\n  undefined4 ptrStack_4;\n  \n  bufferSize = 0x208;\n  maxStringLength = 0x7fffffff;\n  maxArrayLength = 0x7fffffff;\n  maxArraySize = 0xffff;\n  stringPtrArray[0] = string;\n  currentStringPtr = string;\n  currentFormatPtr = format;\n  ptrStack_8 = in_r2;\n  ptrStack_4 = in_r3;\n  result = _svfiprintf_r(_impure_ptr,stringPtrArray,format);\n  *stringPtrArray[0] = '\\0';\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004ffc": "clear_string_and_format_08004ffc",
                "__s": "string",
                "__format": "format",
                "local_78": "stringPtrArray",
                "local_70": "maxStringLength",
                "local_6c": "bufferSize",
                "local_6a": "maxArraySize",
                "local_68": "currentStringPtr",
                "local_64": "maxArrayLength",
                "pcStack_c": "currentFormatPtr",
                "uStack_8": "ptrStack_8",
                "uStack_4": "ptrStack_4",
                "iVar1": "result"
            },
            "calling": [
                "serialInt"
            ],
            "called": [
                "_svfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005044": {
            "entrypoint": "0x08005044",
            "current_name": "copy_and_resize_memory_08005044",
            "code": "\nundefined4 copyAndResizeMemory_08005044(undefined4 *dst,void **params,void *src,void *dstSize)\n\n{\n  void *newMemory;\n  void *currentMemory;\n  size_t offset;\n  \n  currentMemory = params[2];\n  if ((currentMemory <= dstSize) && ((*(ushort *)(params + 3) & 0x480) != 0)) {\n    offset = (int)*params - (int)params[4];\n    currentMemory = (void *)((uint)((int)params[5] * 3) / 2);\n    newMemory = (void *)((int)dstSize + offset + 1);\n    if (currentMemory < newMemory) {\n      currentMemory = newMemory;\n    }\n    if ((int)((uint)*(ushort *)(params + 3) << 0x15) < 0) {\n      newMemory = (void *)allocateMemory(dst,currentMemory);\n      if (newMemory == (void *)0x0) {\nLAB_0800508a:\n        *dst = 0xc;\n        *(ushort *)(params + 3) = *(ushort *)(params + 3) | 0x40;\n        return 0xffffffff;\n      }\n      memcpy(newMemory,params[4],offset);\n      *(ushort *)(params + 3) = *(ushort *)(params + 3) & 0xfb7f | 0x80;\n    }\n    else {\n      newMemory = (void *)reallocateMemory(dst,params[4],currentMemory);\n      if (newMemory == (void *)0x0) {\n        releaseMemory(dst,params[4]);\n        goto LAB_0800508a;\n      }\n    }\n    params[4] = newMemory;\n    *params = (void *)((int)newMemory + offset);\n    params[5] = currentMemory;\n    params[2] = (void *)((int)currentMemory - offset);\n    currentMemory = dstSize;\n  }\n  if (dstSize <= currentMemory) {\n    currentMemory = dstSize;\n  }\n  memmove(*params,src,(size_t)currentMemory);\n  params[2] = (void *)((int)params[2] - (int)currentMemory);\n  *params = (void *)((int)currentMemory + (int)*params);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005044": "copy_and_resize_memory_08005044",
                "param_1": "dst",
                "param_2": "params",
                "param_3": "src",
                "param_4": "dstSize",
                "pvVar1": "newMemory",
                "pvVar2": "currentMemory",
                "__n": "offset",
                "_malloc_r": "allocateMemory",
                "_realloc_r": "reallocateMemory",
                "_free_r": "releaseMemory"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_free_r",
                "memmove",
                "_malloc_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050fc": {
            "entrypoint": "0x080050fc",
            "current_name": "parse_format_string_080050fc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005294) */\n\nint parseFormatString_080050fc(undefined4 *memoryManager,int *formatSpecifier,byte *formatString,int *localVariables)\n\n{\n  bool hasDigits;\n  int accumulator;\n  int returnValue;\n  void *charPtr;\n  int *intPtr;\n  byte *bytePtr1;\n  byte *bytePtr2;\n  int printfReturnValue;\n  int *argumentsStack;\n  uint flags;\n  int precision;\n  undefined4 paddingSize;\n  int fieldWidth;\n  int totalLength;\n  byte conversionSpecifier;\n  undefined paddingChar1;\n  undefined paddingChar2;\n  undefined flagChar;\n  undefined4 unusedVariable;\n  \n  argumentsStack = localVariables;\n  if (((int)((uint)*(ushort *)(formatSpecifier + 3) << 0x18) < 0) && (formatSpecifier[4] == 0)) {\n    accumulator = _malloc_r(memoryManager,0x40);\n    *formatSpecifier = accumulator;\n    formatSpecifier[4] = accumulator;\n    if (accumulator == 0) {\n      *memoryManager = 0xc;\n      return -1;\n    }\n    formatSpecifier[5] = 0x40;\n  }\n  totalLength = 0;\n  paddingChar1 = 0x20;\n  paddingChar2 = 0x30;\n  bytePtr1 = formatString;\nLAB_08005146:\n  bytePtr2 = bytePtr1;\n  if (*bytePtr2 != 0) goto LAB_080051ca;\n  goto LAB_08005150;\nLAB_080051ca:\n  bytePtr1 = bytePtr2 + 1;\n  if (*bytePtr2 != 0x25) goto LAB_08005146;\nLAB_08005150:\n  accumulator = (int)bytePtr2 - (int)formatString;\n  if (accumulator != 0) {\n    returnValue = __ssputs_r(memoryManager,formatSpecifier,formatString,accumulator);\n    if (returnValue == -1) {\nLAB_080052ac:\n      if ((int)((uint)*(ushort *)(formatSpecifier + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalLength;\n    }\n    totalLength = totalLength + accumulator;\n  }\n  if (*bytePtr2 == 0) goto LAB_080052ac;\n  flags = 0;\n  fieldWidth = 0;\n  precision = -1;\n  paddingSize = 0;\n  flagChar = 0;\n  unusedVariable = 0;\n  bytePtr1 = bytePtr2 + 1;\n  while( true ) {\n    charPtr = memchr(&DAT_08007379,(uint)*bytePtr1,5);\n    formatString = bytePtr1 + 1;\n    if (charPtr == (void *)0x0) break;\n    flags = 1 << ((int)charPtr + 0xf7ff8c87U & 0xff) | flags;\n    bytePtr1 = formatString;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    flagChar = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    flagChar = 0x2b;\n  }\n  if (*bytePtr1 == 0x2a) {\n    intPtr = argumentsStack + 1;\n    accumulator = *argumentsStack;\n    argumentsStack = intPtr;\n    if (accumulator < 0) {\n      fieldWidth = -accumulator;\n      flags = flags | 2;\n      goto LAB_080051fc;\n    }\n  }\n  else {\n    hasDigits = false;\n    accumulator = fieldWidth;\n    formatString = bytePtr1;\n    while( true ) {\n      if (9 < *formatString - 0x30) break;\n      accumulator = accumulator * 10 + (*formatString - 0x30);\n      hasDigits = true;\n      formatString = formatString + 1;\n    }\n    if (!hasDigits) goto LAB_080051fc;\n  }\n  fieldWidth = accumulator;\nLAB_080051fc:\n  if (*formatString == 0x2e) {\n    if (formatString[1] == 0x2a) {\n      formatString = formatString + 2;\n      intPtr = argumentsStack + 1;\n      precision = *argumentsStack;\n      argumentsStack = intPtr;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      hasDigits = false;\n      accumulator = 0;\n      precision = 0;\n      while( true ) {\n        formatString = formatString + 1;\n        if (9 < *formatString - 0x30) break;\n        accumulator = accumulator * 10 + (*formatString - 0x30);\n        hasDigits = true;\n      }\n      if (hasDigits) {\n        precision = accumulator;\n      }\n    }\n  }\n  charPtr = memchr(&DAT_0800737f,(uint)*formatString,3);\n  if (charPtr != (void *)0x0) {\n    formatString = formatString + 1;\n    flags = flags | 0x40 << ((int)charPtr + 0xf7ff8c81U & 0xff);\n  }\n  conversionSpecifier = *formatString;\n  formatString = formatString + 1;\n  charPtr = memchr(\"efgEFG\",(uint)conversionSpecifier,6);\n  if (charPtr == (void *)0x0) {\n    printfReturnValue = _printf_i(memoryManager,&flags,formatSpecifier,0x8005045,&argumentsStack);\n    if (printfReturnValue == -1) goto LAB_080052ac;\n  }\n  else {\n    argumentsStack = (int *)(((int)argumentsStack + 7U & 0xfffffff8) + 8);\n  }\n  totalLength = totalLength + printfReturnValue;\n  bytePtr1 = formatString;\n  goto LAB_08005146;\n}\n\n",
            "renaming": {
                "FUN_080050fc": "parse_format_string_080050fc",
                "param_1": "memoryManager",
                "param_2": "formatSpecifier",
                "param_3": "formatString",
                "param_4": "localVariables",
                "bVar1": "hasDigits",
                "iVar2": "accumulator",
                "iVar3": "returnValue",
                "pvVar4": "charPtr",
                "piVar5": "intPtr",
                "pbVar6": "bytePtr1",
                "pbVar7": "bytePtr2",
                "unaff_r9": "printfReturnValue",
                "local_8c": "argumentsStack",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "paddingSize",
                "local_7c": "fieldWidth",
                "local_74": "totalLength",
                "local_70": "conversionSpecifier",
                "local_6f": "paddingChar1",
                "local_6e": "paddingChar2",
                "local_45": "flagChar",
                "local_30": "unusedVariable"
            },
            "calling": [
                "siprintf"
            ],
            "called": [
                "__ssputs_r",
                "memchr",
                "_malloc_r",
                "_printf_i"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052e4": {
            "entrypoint": "0x080052e4",
            "current_name": "expand_and_process_data_080052e4",
            "code": "\nundefined4\nexpandAndProcessData_080052e4(undefined4 inputData,uint *dataArray,uint *outputSize,undefined4 param4,code *processCode)\n\n{\n  int i;\n  int j;\n  uint maxSize;\n  uint uVar4;\n  bool isNotZero;\n  \n  maxSize = dataArray[4];\n  if ((int)dataArray[4] < (int)dataArray[2]) {\n    maxSize = dataArray[2];\n  }\n  *outputSize = maxSize;\n  if (*(char *)((int)dataArray + 0x43) != '\\0') {\n    *outputSize = maxSize + 1;\n  }\n  if ((int)(*dataArray << 0x1a) < 0) {\n    *outputSize = *outputSize + 2;\n  }\n  if ((*dataArray & 6) == 0) {\n    for (i = 0; i < (int)(dataArray[3] - *outputSize); i = i + 1) {\n      j = (*processCode)(inputData,param4,(int)dataArray + 0x19,1);\n      if (j == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxSize = (uint)*(byte *)((int)dataArray + 0x43);\n  if (maxSize != 0) {\n    maxSize = 1;\n  }\n  uVar4 = maxSize;\n  if ((int)(*dataArray << 0x1a) < 0) {\n    *(undefined *)((int)dataArray + maxSize + 0x43) = 0x30;\n    uVar4 = maxSize + 2;\n    *(undefined *)((int)dataArray + maxSize + 0x44) = *(undefined *)((int)dataArray + 0x45);\n  }\n  i = (*processCode)(inputData,param4,(int)dataArray + 0x43,uVar4);\n  if (i != -1) {\n    maxSize = dataArray[3];\n    isNotZero = (*dataArray & 6) != 4;\n    if (isNotZero) {\n      maxSize = 0;\n    }\n    uVar4 = 0;\n    if (!isNotZero) {\n      maxSize = maxSize - *outputSize;\n    }\n    if (!isNotZero) {\n      maxSize = maxSize & ~((int)maxSize >> 0x1f);\n    }\n    if ((int)dataArray[4] < (int)dataArray[2]) {\n      maxSize = maxSize + (dataArray[2] - dataArray[4]);\n    }\n    while( true ) {\n      if (maxSize == uVar4) {\n        return 0;\n      }\n      i = (*processCode)(inputData,param4,(int)dataArray + 0x1a,1);\n      if (i == -1) break;\n      uVar4 = uVar4 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080052e4": "expand_and_process_data_080052e4",
                "param_1": "inputData",
                "param_2": "dataArray",
                "param_3": "outputSize",
                "param_4": "param4",
                "param_5": "processCode",
                "iVar1": "i",
                "iVar2": "j",
                "uVar3": "maxSize",
                "bVar5": "isNotZero"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "format_and_print_080053d4",
            "code": "\nuint format_and_print_080053d4(undefined4 param1,uint *paramArr,undefined4 param3,code *formatFunc,uint **ptrArr)\n\n{\n  byte byteVar;\n  int loopVar;\n  uint *ptrVar;\n  void *ptrVoid;\n  int innerLoopVar;\n  char *charPtr;\n  uint numVar;\n  uint **ptrPtrVar;\n  char **charPtrPtr;\n  uint numVar2;\n  uint numVar3;\n  char *charPtr2;\n  char *stringPtr;\n  uint localArr [2];\n  \n  byteVar = *(byte *)(paramArr + 6);\n  stringPtr = (char *)((int)paramArr + 0x43);\n  if (byteVar != 0x6e) {\n    if (byteVar < 0x6f) {\n      if (byteVar != 99) {\n        if (byteVar < 100) {\n          if (byteVar == 0) goto LAB_0800558e;\n          if (byteVar != 0x58) goto LAB_08005404;\n          *(undefined *)((int)paramArr + 0x45) = 0x58;\n          charPtr = \"0123456789ABCDEF\";\nLAB_0800551e:\n          numVar = *paramArr;\n          ptrVar = *ptrArr;\n          *ptrArr = ptrVar + 1;\n          if (((numVar & 0x80) == 0) && ((int)(numVar << 0x19) < 0)) {\n            numVar2 = (uint)*(ushort *)ptrVar;\n          }\n          else {\n            numVar2 = *ptrVar;\n          }\n          if ((int)(numVar << 0x1f) < 0) {\n            *paramArr = numVar | 0x20;\n          }\n          if (numVar2 == 0) {\n            *paramArr = *paramArr & 0xffffffdf;\n          }\n          numVar = 0x10;\nLAB_080054b4:\n          *(undefined *)((int)paramArr + 0x43) = 0;\n        }\n        else {\n          if ((byteVar != 100) && (byteVar != 0x69)) goto LAB_08005404;\n          numVar2 = *paramArr;\n          ptrVar = *ptrArr;\n          if ((numVar2 & 0x80) == 0) {\n            *ptrArr = ptrVar + 1;\n            if ((numVar2 & 0x40) == 0) goto LAB_08005424;\n            numVar2 = (uint)(short)*(ushort *)ptrVar;\n          }\n          else {\n            *ptrArr = ptrVar + 1;\nLAB_08005424:\n            numVar2 = *ptrVar;\n          }\n          if ((int)numVar2 < 0) {\n            numVar2 = -numVar2;\n            *(undefined *)((int)paramArr + 0x43) = 0x2d;\n          }\n          charPtr = \"0123456789ABCDEF\";\n          numVar = 10;\n        }\n        numVar3 = paramArr[1];\n        paramArr[2] = numVar3;\n        charPtr2 = stringPtr;\n        if ((int)numVar3 < 0) {\n          if (numVar2 != 0) goto LAB_08005552;\nLAB_08005600:\n          *(char *)((int)paramArr + 0x42) = *charPtr;\n          charPtr2 = (char *)((int)paramArr + 0x42);\n        }\n        else {\n          *paramArr = *paramArr & 0xfffffffb;\n          if (numVar2 == 0) {\n            if (numVar3 != 0) goto LAB_08005600;\n          }\n          else {\nLAB_08005552:\n            do {\n              numVar3 = numVar2 / numVar;\n              charPtr2 = charPtr2 + -1;\n              *charPtr2 = charPtr[numVar2 - numVar * numVar3];\n              numVar2 = numVar3;\n            } while (numVar3 != 0);\n          }\n        }\n        if (((numVar == 8) && ((int)(*paramArr << 0x1f) < 0)) && ((int)paramArr[1] <= (int)paramArr[4]))\n        {\n          charPtr2[-1] = '0';\n          charPtr2 = charPtr2 + -1;\n        }\n        paramArr[4] = (int)stringPtr - (int)charPtr2;\n        stringPtr = charPtr2;\n        goto LAB_080054fa;\n      }\n      ptrVar = *ptrArr;\n      *ptrArr = ptrVar + 1;\n      *(char *)((int)paramArr + 0x42) = (char)*ptrVar;\nLAB_08005464:\n      stringPtr = (char *)((int)paramArr + 0x42);\n      numVar2 = 1;\n    }\n    else {\n      if (byteVar != 0x73) {\n        if (byteVar < 0x74) {\n          if (byteVar == 0x6f) {\nLAB_0800548a:\n            numVar2 = *paramArr;\n            ptrVar = *ptrArr;\n            if ((numVar2 & 0x80) == 0) {\n              *ptrArr = ptrVar + 1;\n              if ((numVar2 & 0x40) == 0) goto LAB_08005498;\n              numVar2 = (uint)*(ushort *)ptrVar;\n            }\n            else {\n              *ptrArr = ptrVar + 1;\nLAB_08005498:\n              numVar2 = *ptrVar;\n            }\n            if (byteVar == 0x6f) {\n              numVar = 8;\n            }\n            else {\n              numVar = 10;\n            }\n            charPtr = \"0123456789ABCDEF\";\n            goto LAB_080054b4;\n          }\n          if (byteVar == 0x70) {\n            *paramArr = *paramArr | 0x20;\nLAB_0800544a:\n            charPtr = \"0123456789abcdef\";\n            *(undefined *)((int)paramArr + 0x45) = 0x78;\n            goto LAB_0800551e;\n          }\n        }\n        else {\n          if (byteVar == 0x75) goto LAB_0800548a;\n          if (byteVar == 0x78) goto LAB_0800544a;\n        }\nLAB_08005404:\n        *(byte *)((int)paramArr + 0x42) = byteVar;\n        goto LAB_08005464;\n      }\n      charPtrPtr = (char **)*ptrArr;\n      *ptrArr = (uint *)(charPtrPtr + 1);\n      stringPtr = *charPtrPtr;\n      ptrVoid = memchr(stringPtr,0,paramArr[1]);\n      if (ptrVoid != (void *)0x0) {\n        paramArr[1] = (int)ptrVoid - (int)stringPtr;\n      }\n      numVar2 = paramArr[1];\n    }\n    paramArr[4] = numVar2;\n    *(undefined *)((int)paramArr + 0x43) = 0;\n    goto LAB_080054fa;\n  }\n  numVar2 = *paramArr;\n  ptrPtrVar = (uint **)*ptrArr;\n  numVar = paramArr[5];\n  if ((numVar2 & 0x80) == 0) {\n    *ptrArr = (uint *)(ptrPtrVar + 1);\n    ptrVar = *ptrPtrVar;\n    if ((numVar2 & 0x40) == 0) goto LAB_0800557a;\n    *(short *)ptrVar = (short)numVar;\n  }\n  else {\n    *ptrArr = (uint *)(ptrPtrVar + 1);\n    ptrVar = *ptrPtrVar;\nLAB_0800557a:\n    *ptrVar = numVar;\n  }\nLAB_0800558e:\n  paramArr[4] = 0;\nLAB_080054fa:\n  loopVar = _printf_common(param1,paramArr,localArr,param3,formatFunc);\n  if ((loopVar == -1) || (loopVar = (*formatFunc)(param1,param3,stringPtr,paramArr[4]), loopVar == -1)) {\nLAB_0800550e:\n    numVar2 = 0xffffffff;\n  }\n  else {\n    if ((int)(*paramArr << 0x1e) < 0) {\n      for (loopVar = 0; loopVar < (int)(paramArr[3] - localArr[0]); loopVar = loopVar + 1) {\n        innerLoopVar = (*formatFunc)(param1,param3,(int)paramArr + 0x19,1);\n        if (innerLoopVar == -1) goto LAB_0800550e;\n      }\n    }\n    numVar2 = paramArr[3];\n    if ((int)paramArr[3] < (int)localArr[0]) {\n      numVar2 = localArr[0];\n    }\n  }\n  return numVar2;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "format_and_print_080053d4",
                "param_1": "param1",
                "param_2": "paramArr",
                "param_3": "param3",
                "param_4": "formatFunc",
                "param_5": "ptrArr",
                "bVar1": "byteVar",
                "iVar2": "loopVar",
                "puVar3": "ptrVar",
                "pvVar4": "ptrVoid",
                "iVar5": "innerLoopVar",
                "pcVar6": "charPtr",
                "uVar7": "numVar",
                "ppuVar8": "ptrPtrVar",
                "ppcVar9": "charPtrPtr",
                "uVar10": "numVar2",
                "uVar11": "numVar3",
                "pcVar12": "charPtr2",
                "__s": "stringPtr",
                "local_24": "localArr"
            },
            "calling": [
                "_svfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005614": {
            "entrypoint": "0x08005614",
            "current_name": "find_byte_08005614",
            "code": "\nvoid * find_byte_08005614(void *input,int byte_to_find,size_t size)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  \n  pbVar1 = (byte *)input;\n  do {\n    pbVar2 = pbVar1;\n    if (pbVar2 == (byte *)(size + (int)input)) {\n      return (void *)0x0;\n    }\n    pbVar1 = pbVar2 + 1;\n  } while ((uint)*pbVar2 != (byte_to_find & 0xffU));\n  return pbVar2;\n}\n\n",
            "renaming": {
                "FUN_08005614": "find_byte_08005614",
                "__s": "input",
                "__c": "byte_to_find",
                "__n": "size"
            },
            "calling": [
                "_svfiprintf_r",
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005630": {
            "entrypoint": "0x08005630",
            "current_name": "copy_memory_08005630",
            "code": "\nvoid * copy_memory_08005630(void *destination,void *source,size_t num_bytes)\n\n{\n  undefined *dest_ptr;\n  undefined *src_ptr;\n  \n  src_ptr = (undefined *)((int)destination + -1);\n  dest_ptr = (undefined *)(num_bytes + (int)source);\n  for (; (undefined *)source != dest_ptr; source = (void *)((int)source + 1)) {\n    src_ptr = src_ptr + 1;\n    *src_ptr = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08005630": "copy_memory_08005630",
                "__dest": "destination",
                "__src": "source",
                "__n": "num_bytes",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005646": {
            "entrypoint": "0x08005646",
            "current_name": "copy_memory_08005646",
            "code": "\nvoid * copyMemory_08005646(void *destination,void *source,size_t length)\n\n{\n  undefined *destPointer;\n  int remainingLength;\n  undefined *srcPointer;\n  \n  srcPointer = (undefined *)((int)source + length);\n  if ((source < destination) && (destination < srcPointer)) {\n    destPointer = (undefined *)((int)destination + length);\n    remainingLength = length - (int)srcPointer;\n    while (srcPointer + remainingLength != (undefined *)0x0) {\n      srcPointer = srcPointer + -1;\n      destPointer = destPointer + -1;\n      *destPointer = *srcPointer;\n    }\n    return destination;\n  }\n  destPointer = (undefined *)((int)destination + -1);\n  for (; (undefined *)source != srcPointer; source = (void *)((int)source + 1)) {\n    destPointer = destPointer + 1;\n    *destPointer = *source;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08005646": "copy_memory_08005646",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "destPointer",
                "iVar2": "remainingLength",
                "puVar3": "srcPointer"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800567c": {
            "entrypoint": "0x0800567c",
            "current_name": "allocate_memory_0800567c",
            "code": "\nvoid allocateMemory_0800567c(undefined4 *errorFlag,int size,undefined4 unused,undefined4 unused)\n\n{\n  int **nextFree;\n  int **block;\n  int **currentBlock;\n  int *currentBlockEnd;\n  int **previousBlock;\n  int **allocatedBlock;\n  \n  if (size == 0) {\n    return;\n  }\n  allocatedBlock = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    allocatedBlock = (int **)((int)allocatedBlock + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  currentBlock = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    allocatedBlock[1] = (int *)0x0;\n    block = nextFree;\n    __malloc_free_list = allocatedBlock;\n  }\n  else {\n    currentBlock = __malloc_free_list;\n    if (allocatedBlock < __malloc_free_list) {\n      block = (int **)*allocatedBlock;\n      currentBlock = (int **)((int)allocatedBlock + (int)block);\n      if (__malloc_free_list == currentBlock) {\n        currentBlockEnd = *__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n        currentBlock = (int **)((int)currentBlockEnd + (int)block);\n        *allocatedBlock = (int *)currentBlock;\n      }\n      allocatedBlock[1] = (int *)__malloc_free_list;\n      __malloc_free_list = allocatedBlock;\n    }\n    else {\n      do {\n        previousBlock = currentBlock;\n        currentBlock = (int **)previousBlock[1];\n        if (currentBlock == (int **)0x0) break;\n      } while (currentBlock <= allocatedBlock);\n      block = (int **)*previousBlock;\n      if ((int **)((int)previousBlock + (int)block) == allocatedBlock) {\n        block = (int **)((int)block + (int)*allocatedBlock);\n        *previousBlock = (int *)block;\n        if (currentBlock == (int **)((int)previousBlock + (int)block)) {\n          currentBlockEnd = *currentBlock;\n          currentBlock = (int **)currentBlock[1];\n          block = (int **)((int)block + (int)currentBlockEnd);\n          *previousBlock = (int *)block;\n          previousBlock[1] = (int *)currentBlock;\n        }\n      }\n      else if (allocatedBlock < (int **)((int)previousBlock + (int)block)) {\n        *errorFlag = 0xc;\n      }\n      else {\n        block = (int **)((int)allocatedBlock + (int)*allocatedBlock);\n        if (currentBlock == block) {\n          currentBlockEnd = *currentBlock;\n          currentBlock = (int **)currentBlock[1];\n          block = (int **)((int)currentBlockEnd + (int)*allocatedBlock);\n          *allocatedBlock = (int *)block;\n        }\n        allocatedBlock[1] = (int *)currentBlock;\n        previousBlock[1] = (int *)allocatedBlock;\n      }\n    }\n  }\n  __malloc_unlock(errorFlag,block,currentBlock,unused);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800567c": "allocate_memory_0800567c",
                "param_1": "errorFlag",
                "param_2": "size",
                "param_3": "unused",
                "param_4": "unused",
                "extraout_r1": "nextFree",
                "ppiVar1": "block",
                "ppiVar2": "currentBlock",
                "piVar3": "currentBlockEnd",
                "ppiVar4": "previousBlock",
                "ppiVar5": "allocatedBlock"
            },
            "calling": [
                "__ssputs_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "allocate_memory_08005714",
            "code": "\nuint allocate_memory_08005714(undefined4 *error_code,uint size)\n\n{\n  uint *free_list_ptr;\n  int sbrk_result;\n  uint *current_block;\n  uint block_diff;\n  uint *previous_block;\n  uint allocated_size;\n  \n  allocated_size = (size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < size)) {\n    *error_code = 0xc;\n  }\n  else {\n    __malloc_lock();\n    free_list_ptr = __malloc_free_list;\n    previous_block = __malloc_free_list;\n    while (current_block = free_list_ptr, current_block != (uint *)0x0) {\n      block_diff = *current_block - allocated_size;\n      if (-1 < (int)block_diff) {\n        if (block_diff < 0xc) {\n          if (previous_block == current_block) {\n            free_list_ptr = (uint *)previous_block[1];\n            __malloc_free_list = free_list_ptr;\n          }\n          else {\n            free_list_ptr = (uint *)current_block[1];\n          }\n          if (previous_block != current_block) {\n            previous_block[1] = (uint)free_list_ptr;\n            previous_block = current_block;\n          }\n        }\n        else {\n          *current_block = block_diff;\n          *(uint *)((int)current_block + block_diff) = allocated_size;\n          previous_block = (uint *)((int)current_block + block_diff);\n        }\n        goto LAB_08005778;\n      }\n      previous_block = current_block;\n      free_list_ptr = (uint *)current_block[1];\n    }\n    if (__malloc_sbrk_start == 0) {\n      __malloc_sbrk_start = _sbrk_r(error_code);\n    }\n    free_list_ptr = (uint *)_sbrk_r(error_code,allocated_size);\n    if ((free_list_ptr != (uint *)0xffffffff) &&\n       ((previous_block = (uint *)((int)free_list_ptr + 3U & 0xfffffffc), free_list_ptr == previous_block ||\n        (sbrk_result = _sbrk_r(error_code,(int)previous_block - (int)free_list_ptr), sbrk_result != -1)))) {\n      *previous_block = allocated_size;\nLAB_08005778:\n      __malloc_unlock(error_code);\n      allocated_size = (int)previous_block + 0xbU & 0xfffffff8;\n      sbrk_result = allocated_size - (int)(previous_block + 1);\n      if (sbrk_result != 0) {\n        *(int *)((int)previous_block + sbrk_result) = -sbrk_result;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *error_code = 0xc;\n    __malloc_unlock(error_code);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005714": "allocate_memory_08005714",
                "param_1": "error_code",
                "param_2": "size",
                "puVar1": "free_list_ptr",
                "iVar2": "sbrk_result",
                "puVar3": "current_block",
                "uVar4": "block_diff",
                "puVar5": "previous_block",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__ssputs_r",
                "_svfiprintf_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057d0": {
            "entrypoint": "0x080057d0",
            "current_name": "memory_realloc_or_alloc_080057d0",
            "code": "\nvoid * memory_realloc_or_alloc_080057d0(undefined4 context,void *ptr,uint size,undefined4 extra_param)\n\n{\n  void *new_ptr;\n  uint current_size;\n  \n  if (ptr != (void *)0x0) {\n    if (size == 0) {\n      _free_r();\n      new_ptr = (void *)0x0;\n    }\n    else {\n      current_size = _malloc_usable_size_r();\n      new_ptr = ptr;\n      if ((current_size < size) && (new_ptr = (void *)_malloc_r(context,size), new_ptr != (void *)0x0))\n      {\n        memcpy(new_ptr,ptr,size);\n        _free_r(context,ptr);\n      }\n    }\n    return new_ptr;\n  }\n  new_ptr = (void *)_malloc_r(context,size,size,extra_param);\n  return new_ptr;\n}\n\n",
            "renaming": {
                "FUN_080057d0": "memory_realloc_or_alloc_080057d0",
                "param_1": "context",
                "param_2": "ptr",
                "param_3": "size",
                "param_4": "extra_param",
                "pvVar1": "new_ptr",
                "uVar2": "current_size"
            },
            "calling": [
                "__ssputs_r"
            ],
            "called": [
                "_free_r",
                "_malloc_usable_size_r",
                "_malloc_r",
                "memcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800581c": {
            "entrypoint": "0x0800581c",
            "current_name": "allocate_memory_0800581c",
            "code": "\nvoid allocate_memory_0800581c(int *error_code,intptr_t size)\n\n{\n  void *memory_block;\n  \n  errno = 0;\n  memory_block = _sbrk(size);\n  if ((memory_block == (void *)0xffffffff) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800581c": "allocate_memory_0800581c",
                "param_1": "error_code",
                "param_2": "size",
                "pvVar1": "memory_block"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800583c": {
            "entrypoint": "0x0800583c",
            "current_name": "FUNC_0800583c",
            "code": "\nvoid FUNC_0800583c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583c": "FUNC_0800583c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800583e": {
            "entrypoint": "0x0800583e",
            "current_name": "FUNC_0800583e",
            "code": "\nvoid FUNC_0800583e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800583e": "FUNC_0800583e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005840": {
            "entrypoint": "0x08005840",
            "current_name": "calculate_sum_08005840",
            "code": "\nint calculateSum_08005840(undefined4 input1,int input2)\n\n{\n  int sum;\n  \n  sum = *(int *)(input2 + -4) + -4;\n  if (*(int *)(input2 + -4) < 0) {\n    sum = sum + *(int *)(input2 + sum);\n  }\n  return sum;\n}\n\n",
            "renaming": {
                "FUN_08005840": "calculate_sum_08005840",
                "param_1": "input1",
                "param_2": "input2",
                "iVar1": "sum"
            },
            "calling": [
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005854": {
            "entrypoint": "0x08005854",
            "current_name": "calculate_arc_sine_08005854",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080058d4) */\n\ndouble calculate_arc_sine_08005854(double input_value)\n\n{\n  int comparison_result;\n  undefined4 *error_pointer;\n  double result;\n  double temp1;\n  double temp2;\n  double temp3;\n  double temp4;\n  int parameter1;\n  char *parameter2;\n  \n  result = (double)__ieee754_asin();\n  if ((__fdlib_version != -1) && (comparison_result = __unorddf2(), result = temp1, comparison_result == 0)) {\n    fabs((double)CONCAT44(parameter2,parameter1));\n    comparison_result = __aeabi_dcmpgt();\n    result = temp2;\n    if ((comparison_result != 0) &&\n       ((nan(\"\"), __fdlib_version == '\\x02' ||\n        (comparison_result = matherr((exception *)&stack0xffffffb8), result = temp4, comparison_result == 0)))) {\n      error_pointer = (undefined4 *)__errno();\n      *error_pointer = 0x21;\n      result = temp3;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005854": "calculate_arc_sine_08005854",
                "__x": "input_value",
                "iVar1": "comparison_result",
                "puVar2": "error_pointer",
                "dVar3": "result",
                "extraout_d0": "temp1",
                "extraout_d0_00": "temp2",
                "extraout_d0_01": "temp3",
                "extraout_d0_02": "temp4",
                "in_stack_ffffffb8": "parameter1",
                "in_stack_ffffffbc": "parameter2"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__errno",
                "fabs",
                "matherr",
                "__aeabi_dcmpgt",
                "nan",
                "__ieee754_asin",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058fc": {
            "entrypoint": "0x080058fc",
            "current_name": "FUN_080058fc",
            "code": "\nundefined8 __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  undefined4 uVar1;\n  undefined4 extraout_r1;\n  int extraout_r1_00;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  \n  uVar5 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar5 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar3 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar3 | (-param_1 | param_1) >> 0x1f))) {\n    uVar6 = __aeabi_dadd(param_1,param_2);\n    return uVar6;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    atan(param_5);\n    return CONCAT44(extraout_r1,param_1);\n  }\n  uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((param_1 | uVar3) == 0) {\n    if (uVar2 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (uVar2 != 3) {\n      return CONCAT44(param_2,param_1);\n    }\nLAB_0800613e:\n    uVar6 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((param_3 | uVar5) != 0) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 0x7ff00000) {\n          if (uVar2 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (uVar2 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (uVar2 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (uVar2 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (uVar2 != 3) {\n          if (uVar2 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (uVar3 != 0x7ff00000) {\n        iVar4 = (int)(uVar3 - uVar5) >> 0x14;\n        if (iVar4 < 0x3d) {\n          if (((int)param_4 < 0) && (iVar4 + 0x3c < 0 != SCARRY4(iVar4,0x3c))) {\n            uVar1 = 0;\n            iVar4 = 0;\n          }\n          else {\n            uVar1 = __divdf3(param_1,param_2);\n            fabs((double)CONCAT44(unaff_r4,param_4));\n            atan((double)CONCAT44(unaff_r4,param_4));\n            iVar4 = extraout_r1_00;\n          }\n        }\n        else {\n          uVar1 = 0x54442d18;\n          iVar4 = 0x3ff921fb;\n        }\n        if (uVar2 == 1) {\n          return CONCAT44(iVar4 + -0x80000000,uVar1);\n        }\n        if (uVar2 == 2) {\n          uVar7 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar6 = 0x400921fb54442d18;\n        }\n        else {\n          if (uVar2 == 0) {\n            return CONCAT44(iVar4,uVar1);\n          }\n          uVar6 = __subdf3(uVar1,iVar4,0x33145c07,0x3ca1a626);\n          uVar7 = 0x400921fb54442d18;\n        }\n        uVar6 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),(int)uVar7,\n                         (int)((ulonglong)uVar7 >> 0x20));\n        return uVar6;\n      }\n    }\n    if ((int)param_2 < 0) {\n      uVar6 = 0xbff921fb54442d18;\n    }\n    else {\n      uVar6 = 0x3ff921fb54442d18;\n    }\n  }\n  return uVar6;\n}\n\n",
            "renaming": {},
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005900": {
            "entrypoint": "0x08005900",
            "current_name": "calculate_power_08005900",
            "code": "\ndouble calculatePower_08005900(double base,double exponent)\n\n{\n  char versionFlag;\n  int comparisonResult;\n  int *errorPointer;\n  undefined4 *errnoPointer;\n  int finiteResult;\n  undefined4 extraOutput1;\n  undefined4 extraOutput2;\n  undefined4 extraOutput3;\n  double result;\n  double extraOutput4;\n  double extraOutput5;\n  double extraOutput6;\n  double extraOutput7;\n  double extraOutput8;\n  double extraOutput9;\n  double extraOutput10;\n  double extraOutput11;\n  double extraOutput12;\n  double extraOutput13;\n  double extraOutput14;\n  double extraOutput15;\n  double extraOutput16;\n  double resultDouble;\n  undefined8 mulResult;\n  undefined exceptionInfo [24];\n  undefined8 returnValue;\n  int errorNumber;\n  \n  resultDouble = (double)__ieee754_pow();\n  versionFlag = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return result;\n  }\n  comparisonResult = __unorddf2();\n  if (comparisonResult != 0) {\n    return extraOutput4;\n  }\n  comparisonResult = __unorddf2();\n  if (comparisonResult != 0) {\n    comparisonResult = __aeabi_dcmpeq();\n    if (comparisonResult == 0) {\n      return extraOutput5;\n    }\n    exceptionInfo._0_4_ = 1;\n    exceptionInfo._4_4_ = \"pow\";\n    returnValue = 1.0;\n    errorNumber = 0;\n    if (versionFlag == '\\x02') {\n      return extraOutput5;\n    }\n    goto LAB_08005978;\n  }\n  comparisonResult = __aeabi_dcmpeq();\n  if (comparisonResult == 0) {\n    comparisonResult = finite(resultDouble);\n    if ((comparisonResult == 0) && (finiteResult = finite(resultDouble), finiteResult != 0)) {\n      finiteResult = finite(resultDouble);\n      if (finiteResult == 0) goto LAB_08005b4c;\n      errorNumber = __unorddf2(SUB84(resultDouble,0),(int)((ulonglong)resultDouble >> 0x20));\n      versionFlag = __fdlib_version;\n      if (errorNumber != 0) {\n        exceptionInfo._4_4_ = \"pow\";\n        exceptionInfo._0_4_ = 1;\n        errorNumber = comparisonResult;\n        if (__fdlib_version == '\\0') goto LAB_08005a22;\n        returnValue = (double)__divdf3(0,0,0,0);\n        goto LAB_08005a32;\n      }\n      exceptionInfo._4_4_ = \"pow\";\n      exceptionInfo._0_4_ = 3;\n      if (__fdlib_version != '\\0') {\n        returnValue._0_4_ = 0;\n        returnValue._4_4_ = 0x7ff00000;\n        comparisonResult = __aeabi_dcmplt();\n        if (comparisonResult != 0) {\n          mulResult = __muldf3();\n          extraOutput3 = (int)mulResult;\n          rint(resultDouble);\n          comparisonResult = __aeabi_dcmpeq((int)mulResult,(int)((ulonglong)mulResult >> 0x20),extraOutput3,extraOutput2);\n          if (comparisonResult == 0) {\n            returnValue._0_4_ = 0;\n            returnValue._4_4_ = 0xfff00000;\n          }\n        }\n        goto LAB_08005afa;\n      }\n      returnValue._0_4_ = 0xe0000000;\n      returnValue._4_4_ = 0x47efffff;\n      comparisonResult = __aeabi_dcmplt();\n      if (comparisonResult != 0) {\n        mulResult = __muldf3();\n        extraOutput3 = (int)mulResult;\n        rint(resultDouble);\n        comparisonResult = __aeabi_dcmpeq((int)mulResult,(int)((ulonglong)mulResult >> 0x20),extraOutput3,extraOutput1);\n        if (comparisonResult == 0) {\n          returnValue._0_4_ = 0xe0000000;\n          returnValue._4_4_ = 0xc7efffff;\n        }\n        goto LAB_08005afa;\n      }\nLAB_08005b98:\n      comparisonResult = matherr((exception *)exceptionInfo);\n      resultDouble = extraOutput16;\n      if (comparisonResult != 0) goto LAB_080059d0;\n    }\n    else {\nLAB_08005b4c:\n      comparisonResult = __aeabi_dcmpeq(SUB84(resultDouble,0),(int)((ulonglong)resultDouble >> 0x20),0,0);\n      if (comparisonResult == 0) {\n        return extraOutput13;\n      }\n      comparisonResult = finite(resultDouble);\n      if (comparisonResult == 0) {\n        return extraOutput14;\n      }\n      comparisonResult = finite(resultDouble);\n      if (comparisonResult == 0) {\n        return extraOutput15;\n      }\n      exceptionInfo._0_4_ = 4;\n      exceptionInfo._4_4_ = \"pow\";\n      errorNumber = 0;\n      returnValue._0_4_ = 0;\n      returnValue._4_4_ = 0;\nLAB_08005afa:\n      if (__fdlib_version != '\\x02') goto LAB_08005b98;\n    }\n    errnoPointer = (undefined4 *)__errno();\n    extraOutput3 = 0x22;\n    resultDouble = extraOutput12;\n  }\n  else {\n    comparisonResult = __aeabi_dcmpeq();\n    if (comparisonResult == 0) {\n      comparisonResult = finite(resultDouble);\n      if (comparisonResult == 0) {\n        return extraOutput9;\n      }\n      comparisonResult = __aeabi_dcmplt();\n      if (comparisonResult == 0) {\n        return extraOutput10;\n      }\n      exceptionInfo._0_4_ = 1;\n      exceptionInfo._4_4_ = \"pow\";\n      errorNumber = 0;\n      if (__fdlib_version == '\\0') {\nLAB_08005a22:\n        exceptionInfo._4_4_ = \"pow\";\n        exceptionInfo._0_4_ = 1;\n        returnValue = 0.0;\n        goto LAB_08005978;\n      }\n      returnValue = -INFINITY;\n      errorNumber = 0;\n      versionFlag = __fdlib_version;\nLAB_08005a32:\n      if (versionFlag != '\\x02') goto LAB_08005978;\n    }\n    else {\n      exceptionInfo._0_4_ = 1;\n      exceptionInfo._4_4_ = \"pow\";\n      returnValue = 0.0;\n      errorNumber = 0;\n      if (versionFlag != '\\0') {\n        returnValue = 1.0;\n        resultDouble = extraOutput7;\n        goto LAB_080059d0;\n      }\nLAB_08005978:\n      comparisonResult = matherr((exception *)exceptionInfo);\n      resultDouble = extraOutput6;\n      if (comparisonResult != 0) goto LAB_080059d0;\n    }\n    errnoPointer = (undefined4 *)__errno();\n    extraOutput3 = 0x21;\n    resultDouble = extraOutput11;\n  }\n  *errnoPointer = extraOutput3;\nLAB_080059d0:\n  if (errorNumber != 0) {\n    errorPointer = (int *)__errno();\n    *errorPointer = errorNumber;\n    resultDouble = extraOutput8;\n  }\n  return resultDouble;\n}\n\n",
            "renaming": {
                "FUN_08005900": "calculate_power_08005900",
                "__x": "base",
                "__y": "exponent",
                "cVar1": "versionFlag",
                "iVar2": "comparisonResult",
                "piVar3": "errorPointer",
                "puVar4": "errnoPointer",
                "iVar5": "finiteResult",
                "extraout_r1": "extraOutput1",
                "extraout_r1_00": "extraOutput2",
                "uVar6": "extraOutput3",
                "extraout_d0": "result",
                "extraout_d0_00": "extraOutput4",
                "extraout_d0_01": "extraOutput5",
                "local_50": "exceptionInfo",
                "local_38": "returnValue",
                "local_30": "errorNumber",
                "extraout_d0_02": "extraOutput6",
                "extraout_d0_03": "extraOutput7",
                "extraout_d0_04": "extraOutput8",
                "extraout_d0_05": "extraOutput9",
                "extraout_d0_06": "extraOutput10",
                "extraout_d0_07": "extraOutput11",
                "extraout_d0_08": "extraOutput12",
                "extraout_d0_09": "extraOutput13",
                "extraout_d0_10": "extraOutput14",
                "extraout_d0_11": "extraOutput15",
                "extraout_d0_12": "extraOutput16",
                "dVar7": "resultDouble",
                "uVar8": "mulResult"
            },
            "calling": [
                "MS5611_Update"
            ],
            "called": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__errno",
                "rint",
                "matherr",
                "__muldf3",
                "finite",
                "__ieee754_pow",
                "__unorddf2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bc8": {
            "entrypoint": "0x08005bc8",
            "current_name": "calculate_square_root_08005bc8",
            "code": "\ndouble calculate_square_root_08005bc8(double input_value)\n\n{\n  char fdlib_version;\n  int comparison_result;\n  int *errno_pointer;\n  undefined4 *fdlib_version_pointer;\n  double result;\n  double out_d0;\n  double out_d0_00;\n  double out_d0_01;\n  double out_d0_02;\n  double out_d0_03;\n  undefined exception_message [24];\n  undefined8 temp_value;\n  int unorddf2_result;\n  \n  result = (double)__ieee754_sqrt();\n  fdlib_version = __fdlib_version;\n  if (__fdlib_version == -1) {\n    return result;\n  }\n  unorddf2_result = __unorddf2();\n  if (unorddf2_result != 0) {\n    return out_d0;\n  }\n  comparison_result = __aeabi_dcmplt();\n  if (comparison_result == 0) {\n    return out_d0_00;\n  }\n  exception_message._0_4_ = 1;\n  exception_message._4_4_ = \"sqrt\";\n  if (fdlib_version == '\\0') {\n    temp_value = 0.0;\nLAB_08005c26:\n    comparison_result = matherr((exception *)exception_message);\n    result = out_d0_01;\n    if (comparison_result != 0) goto LAB_08005c2e;\n  }\n  else {\n    temp_value = (double)__divdf3(0,0,0,0);\n    if (fdlib_version != '\\x02') goto LAB_08005c26;\n  }\n  fdlib_version_pointer = (undefined4 *)__errno();\n  *fdlib_version_pointer = 0x21;\n  result = out_d0_03;\nLAB_08005c2e:\n  if (unorddf2_result != 0) {\n    errno_pointer = (int *)__errno();\n    *errno_pointer = unorddf2_result;\n    result = out_d0_02;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005bc8": "calculate_square_root_08005bc8",
                "__x": "input_value",
                "cVar1": "fdlib_version",
                "iVar2": "comparison_result",
                "piVar3": "errno_pointer",
                "puVar4": "fdlib_version_pointer",
                "dVar5": "result",
                "extraout_d0": "out_d0",
                "extraout_d0_00": "out_d0_00",
                "extraout_d0_01": "out_d0_01",
                "extraout_d0_02": "out_d0_02",
                "extraout_d0_03": "out_d0_03",
                "local_50": "exception_message",
                "local_38": "temp_value",
                "local_30": "unorddf2_result"
            },
            "calling": [
                "MadgwickQuaternionUpdate"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__errno",
                "matherr",
                "__ieee754_sqrt",
                "__divdf3",
                "__unorddf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c70": {
            "entrypoint": "0x08005c70",
            "current_name": "calculate_square_root_08005c70",
            "code": "\nundefined8 calculate_square_root_08005c70(uint input_1,uint input_2)\n\n{\n  int comparison_result;\n  undefined4 extra_result;\n  undefined4 temp_1;\n  undefined4 temp_2;\n  undefined4 temp_3;\n  undefined4 temp_4;\n  undefined4 temp_5;\n  undefined4 temp_6;\n  uint positive_input_2;\n  undefined8 result;\n  undefined8 temp_result_1;\n  undefined8 temp_result_2;\n  undefined4 temp_stack;\n  \n  result = CONCAT44(input_2,input_1);\n  positive_input_2 = input_2 & 0x7fffffff;\n  if (positive_input_2 < 0x3ff00000) {\n    if (positive_input_2 < 0x3fe00000) {\n      if (0x3e3fffff < positive_input_2) {\n        temp_result_1 = __muldf3(input_1,input_2,input_1,input_2);\n        temp_6 = (undefined4)((ulonglong)temp_result_1 >> 0x20);\n        temp_5 = (undefined4)temp_result_1;\n        temp_result_1 = __muldf3(temp_5,temp_6,0xdfdf709,0x3f023de1);\n        temp_result_1 = __aeabi_dadd((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0x7501b288,0x3f49efe0);\n        temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),temp_5,temp_6);\n        temp_result_1 = __subdf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0xb5688f3b,0x3fa48228);\n        temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),temp_5,temp_6);\n        temp_result_1 = __aeabi_dadd((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0xe884455,0x3fc9c155);\n        temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),temp_5,temp_6);\n        temp_result_1 = __subdf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0x3eb6f7d,0x3fd4d612);\n        temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),temp_5,temp_6);\n        temp_result_1 = __aeabi_dadd((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0x55555555,0x3fc55555);\n        temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),temp_5,temp_6);\n        temp_result_2 = __muldf3(temp_5,temp_6,0xb12e9282,0x3fb3b8c5);\n        temp_result_2 = __subdf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x1b8d0159,0x3fe6066c);\n        temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_5,temp_6);\n        temp_result_2 = __aeabi_dadd((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x9c598ac8,0x40002ae5);\n        temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_5,temp_6);\n        temp_result_2 = __subdf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0x1c8a2d4b,0x40033a27);\n        temp_result_2 = __muldf3((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),temp_5,temp_6);\n        temp_result_2 = __aeabi_dadd((int)temp_result_2,(int)((ulonglong)temp_result_2 >> 0x20),0,0x3ff00000);\n        temp_result_1 = __divdf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),(int)temp_result_2,\n                          (int)((ulonglong)temp_result_2 >> 0x20));\n        temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),input_1,input_2);\n        goto LAB_08005cba;\n      }\n      temp_result_1 = __aeabi_dadd(input_1,input_2,0x8800759c,0x7e37e43c);\n      comparison_result = __aeabi_dcmpgt((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0,0x3ff00000);\n      if (comparison_result != 0) {\n        return result;\n      }\n    }\n    fabs((double)CONCAT44(input_2,temp_stack));\n    result = __subdf3(0,0x3ff00000,input_1,extra_result);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x3fe00000);\n    temp_1 = (undefined4)((ulonglong)result >> 0x20);\n    temp_5 = (undefined4)result;\n    result = __muldf3(temp_5,temp_1,0xdfdf709,0x3f023de1);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x7501b288,0x3f49efe0);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp_5,temp_1);\n    result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0xb5688f3b,0x3fa48228);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp_5,temp_1);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0xe884455,0x3fc9c155);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp_5,temp_1);\n    result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x3eb6f7d,0x3fd4d612);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp_5,temp_1);\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x55555555,0x3fc55555);\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp_5,temp_1);\n    temp_2 = (undefined4)((ulonglong)result >> 0x20);\n    temp_result_1 = __muldf3(temp_5,temp_1,0xb12e9282,0x3fb3b8c5);\n    temp_result_1 = __subdf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0x1b8d0159,0x3fe6066c);\n    temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),temp_5,temp_1);\n    temp_result_1 = __aeabi_dadd((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0x9c598ac8,0x40002ae5);\n    temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),temp_5,temp_1);\n    temp_result_1 = __subdf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0x1c8a2d4b,0x40033a27);\n    temp_result_1 = __muldf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),temp_5,temp_1);\n    temp_result_1 = __aeabi_dadd((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),0,0x3ff00000);\n    temp_3 = (undefined4)((ulonglong)temp_result_1 >> 0x20);\n    temp_result_2 = __ieee754_sqrt(temp_5,temp_1);\n    temp_4 = (undefined4)((ulonglong)temp_result_2 >> 0x20);\n    temp_6 = (undefined4)temp_result_2;\n    if (positive_input_2 < 0x3fef3333) {\n      result = __divdf3((int)result,temp_2,(int)temp_result_1,temp_3);\n      temp_result_1 = __aeabi_dadd(temp_6,temp_4,temp_6,temp_4);\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),(int)temp_result_1,\n                       (int)((ulonglong)temp_result_1 >> 0x20));\n      temp_result_1 = __muldf3(0,temp_4,0,temp_4);\n      temp_result_1 = __subdf3(temp_5,temp_1,(int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20));\n      temp_result_2 = __aeabi_dadd(temp_6,temp_4,0,temp_4);\n      temp_result_1 = __divdf3((int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20),(int)temp_result_2,\n                        (int)((ulonglong)temp_result_2 >> 0x20));\n      temp_5 = (undefined4)((ulonglong)temp_result_1 >> 0x20);\n      temp_result_1 = __aeabi_dadd((int)temp_result_1,temp_5,(int)temp_result_1,temp_5);\n      temp_result_1 = __subdf3(0x33145c07,0x3c91a626,(int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20));\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)temp_result_1,\n                       (int)((ulonglong)temp_result_1 >> 0x20));\n      temp_result_1 = __aeabi_dadd(0,temp_4,0,temp_4);\n      temp_result_1 = __subdf3(0x54442d18,0x3fe921fb,(int)temp_result_1,(int)((ulonglong)temp_result_1 >> 0x20));\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)temp_result_1,\n                       (int)((ulonglong)temp_result_1 >> 0x20));\n      temp_5 = 0x3fe921fb;\n    }\n    else {\n      result = __divdf3((int)result,temp_2,(int)temp_result_1,temp_3);\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp_6,temp_4);\n      result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),temp_6,temp_4);\n      temp_5 = (undefined4)((ulonglong)result >> 0x20);\n      result = __aeabi_dadd((int)result,temp_5,(int)result,temp_5);\n      result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x33145c07,0x3c91a626);\n      temp_5 = 0x3ff921fb;\n    }\n    result = __subdf3(0x54442d18,temp_5,(int)result,(int)((ulonglong)result >> 0x20));\n    if ((int)input_2 < 1) {\n      result = CONCAT44((int)((ulonglong)result >> 0x20) + -0x80000000,(int)result);\n    }\n  }\n  else {\n    if ((positive_input_2 + 0xc0100000 | input_1) != 0) {\n      result = __subdf3(input_1,input_2,input_1,input_2);\n      temp_5 = (undefined4)((ulonglong)result >> 0x20);\n      result = __divdf3((int)result,temp_5,(int)result,temp_5);\n      return result;\n    }\n    result = __muldf3(input_1,input_2,0x54442d18,0x3ff921fb);\n    temp_result_1 = __muldf3(input_1,input_2,0x33145c07,0x3c91a626);\nLAB_08005cba:\n    result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),(int)temp_result_1,\n                         (int)((ulonglong)temp_result_1 >> 0x20));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005c70": "calculate_square_root_08005c70",
                "param_1": "input_1",
                "param_2": "input_2",
                "iVar1": "comparison_result",
                "extraout_r1": "extra_result",
                "uVar2": "temp_1",
                "uVar3": "temp_2",
                "uVar4": "temp_3",
                "uVar5": "temp_4",
                "uVar6": "temp_5",
                "uVar7": "temp_6",
                "uVar8": "positive_input_2",
                "uVar9": "result",
                "uVar10": "temp_result_1",
                "uVar11": "temp_result_2",
                "in_stack_ffffffc8": "temp_stack"
            },
            "calling": [
                "asin"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006070": {
            "entrypoint": "0x08006070",
            "current_name": "calculate_result_08006070",
            "code": "\nundefined8 calculate_result_08006070(uint input_1,uint input_2,uint input_3,uint input_4,double input_5)\n\n{\n  undefined4 result_1;\n  undefined4 result_2;\n  int result_3;\n  undefined4 result_4;\n  uint result_5;\n  uint result_6;\n  int result_7;\n  uint result_8;\n  undefined8 final_result_1;\n  undefined8 final_result_2;\n  \n  result_8 = input_4 & 0x7fffffff;\n  if ((0x7ff00000 < (result_8 | (-input_3 | input_3) >> 0x1f)) ||\n     (result_6 = input_2 & 0x7fffffff, 0x7ff00000 < (result_6 | (-input_1 | input_1) >> 0x1f))) {\n    final_result_1 = __aeabi_dadd(input_1,input_2);\n    return final_result_1;\n  }\n  if ((input_4 + 0xc0100000 | input_3) == 0) {\n    atan(input_5);\n    return CONCAT44(result_2,input_1);\n  }\n  result_5 = (int)input_4 >> 0x1e & 2U | input_2 >> 0x1f;\n  if ((input_1 | result_6) == 0) {\n    if (result_5 == 2) {\n      return 0x400921fb54442d18;\n    }\n    if (result_5 != 3) {\n      return CONCAT44(input_2,input_1);\n    }\nLAB_0800613e:\n    final_result_1 = 0xc00921fb54442d18;\n  }\n  else {\n    if ((input_3 | result_8) != 0) {\n      if (result_8 == 0x7ff00000) {\n        if (result_6 == 0x7ff00000) {\n          if (result_5 == 2) {\n            return 0x4002d97c7f3321d2;\n          }\n          if (result_5 == 3) {\n            return 0xc002d97c7f3321d2;\n          }\n          if (result_5 != 1) {\n            return 0x3fe921fb54442d18;\n          }\n          return 0xbfe921fb54442d18;\n        }\n        if (result_5 == 2) {\n          return 0x400921fb54442d18;\n        }\n        if (result_5 != 3) {\n          if (result_5 != 1) {\n            return 0;\n          }\n          return 0x8000000000000000;\n        }\n        goto LAB_0800613e;\n      }\n      if (result_6 != 0x7ff00000) {\n        result_7 = (int)(result_6 - result_8) >> 0x14;\n        if (result_7 < 0x3d) {\n          if (((int)input_4 < 0) && (result_7 + 0x3c < 0 != SCARRY4(result_7,0x3c))) {\n            result_1 = 0;\n            result_7 = 0;\n          }\n          else {\n            result_1 = __divdf3(input_1,input_2);\n            fabs((double)CONCAT44(result_4,input_4));\n            atan((double)CONCAT44(result_4,input_4));\n            result_7 = result_3;\n          }\n        }\n        else {\n          result_1 = 0x54442d18;\n          result_7 = 0x3ff921fb;\n        }\n        if (result_5 == 1) {\n          return CONCAT44(result_7 + -0x80000000,result_1);\n        }\n        if (result_5 == 2) {\n          final_result_2 = __subdf3(result_1,result_7,0x33145c07,0x3ca1a626);\n          final_result_1 = 0x400921fb54442d18;\n        }\n        else {\n          if (result_5 == 0) {\n            return CONCAT44(result_7,result_1);\n          }\n          final_result_1 = __subdf3(result_1,result_7,0x33145c07,0x3ca1a626);\n          final_result_2 = 0x400921fb54442d18;\n        }\n        final_result_1 = __subdf3((int)final_result_1,(int)((ulonglong)final_result_1 >> 0x20),(int)final_result_2,\n                         (int)((ulonglong)final_result_2 >> 0x20));\n        return final_result_1;\n      }\n    }\n    if ((int)input_2 < 0) {\n      final_result_1 = 0xbff921fb54442d18;\n    }\n    else {\n      final_result_1 = 0x3ff921fb54442d18;\n    }\n  }\n  return final_result_1;\n}\n\n",
            "renaming": {
                "FUN_08006070": "calculate_result_08006070",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "param_5": "input_5",
                "uVar1": "result_1",
                "extraout_r1": "result_2",
                "extraout_r1_00": "result_3",
                "unaff_r4": "result_4",
                "uVar2": "result_5",
                "uVar3": "result_6",
                "iVar4": "result_7",
                "uVar5": "result_8",
                "uVar6": "final_result_1",
                "uVar7": "final_result_2"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006228": {
            "entrypoint": "0x08006228",
            "current_name": "convert_floating_point_to_decimal_08006228",
            "code": "\nvoid convertFloatingPointToDecimal_08006228(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint isOddFraction;\n  undefined4 ignore;\n  uint ignore;\n  undefined4 result1;\n  undefined4 ignore;\n  undefined4 ignore;\n  uint ignore;\n  undefined4 ignore;\n  undefined4 result2;\n  int exponentDiff;\n  uint signBit;\n  int index;\n  undefined4 dpLow;\n  uint normalizedInput2;\n  undefined4 result3;\n  uint normalizedInput4;\n  undefined4 result4;\n  undefined4 result5;\n  undefined8 result6;\n  undefined8 result7;\n  undefined8 result8;\n  undefined8 result9;\n  longlong subtractResult;\n  ulonglong absInput1;\n  undefined8 subtractResult2;\n  undefined4 normalizedInput3;\n  undefined4 ignore;\n  undefined4 dividendLow;\n  undefined4 dividendHigh;\n  int shiftAmount;\n  \n  normalizedInput4 = input4 & 0x7fffffff;\n  if ((normalizedInput4 | input3) == 0) {\n    return;\n  }\n  normalizedInput2 = input2 & 0x7fffffff;\n  if (normalizedInput2 < 0x7ff00001) {\n    if (normalizedInput2 == 0x7ff00000) {\n      if (input1 == 0) {\n        if (0x7ff00000 < normalizedInput4) goto LAB_08006278;\nLAB_08006262:\n        if ((normalizedInput4 != 0x7ff00000) || (input3 == 0)) {\n          if (-1 < (int)input2) goto LAB_0800632a;\n          if (normalizedInput4 < 0x43400000) {\n            if (normalizedInput4 < 0x3ff00000) {\nLAB_0800632a:\n              isOddFraction = 0;\n              goto LAB_080062ba;\n            }\n            exponentDiff = ((int)normalizedInput4 >> 0x14) + -0x3ff;\n            if (0x14 < exponentDiff) {\n              isOddFraction = input3 >> (0x34U - exponentDiff & 0xff);\n              if (input3 == isOddFraction << (0x34U - exponentDiff & 0xff)) {\n                isOddFraction = 2 - (isOddFraction & 1);\n                goto LAB_080062ba;\n              }\n              goto LAB_0800632a;\n            }\n            if (input3 == 0) {\n              isOddFraction = (int)normalizedInput4 >> (0x14U - exponentDiff & 0xff);\n              if (normalizedInput4 == isOddFraction << (0x14U - exponentDiff & 0xff)) {\n                isOddFraction = 2 - (isOddFraction & 1);\n              }\n              else {\n                isOddFraction = 0;\n              }\n              goto LAB_0800630c;\n            }\n            isOddFraction = 0;\n          }\n          else {\n            isOddFraction = 2;\nLAB_080062ba:\n            if (input3 == 0) {\n              if (normalizedInput4 == 0x7ff00000) {\n                return;\n              }\nLAB_0800630c:\n              if (normalizedInput4 == 0x3ff00000) {\n                if (-1 < (int)input4) {\n                  return;\n                }\n                result6 = 0x3ff0000000000000;\n                result7 = CONCAT44(input2,input1);\n                goto LAB_08006320;\n              }\n              if (input4 == 0x40000000) goto LAB_0800634a;\n              if ((input4 == 0x3fe00000) && (-1 < (int)input2)) {\n                __ieee754_sqrt(input1,input2);\n                return;\n              }\n            }\n          }\n          signBit = input1;\n          fabs((double)CONCAT44(ignore,isOddFraction));\n          absInput1 = CONCAT44(input2,signBit) & 0x7fffffffffffffff;\n          if ((input1 == 0) && ((normalizedInput2 == 0 || ((input2 & 0x3fffffff) == 0x3ff00000)))) {\n            if ((int)input4 < 0) {\n              __divdf3(0,0x3ff00000,signBit,ignore);\n            }\n            if (-1 < (int)input2) {\n              return;\n            }\n            if ((isOddFraction | normalizedInput2 + 0xc0100000) != 0) {\n              return;\n            }\n          }\n          else {\n            signBit = 0xffffffff - ((int)input2 >> 0x1f);\n            if ((isOddFraction | signBit) != 0) {\n              if (normalizedInput4 < 0x41e00001) {\n                shiftAmount = 0;\n                if (normalizedInput2 < 0x100000) {\n                  absInput1 = __muldf3();\n                  shiftAmount = -0x35;\n                }\n                normalizedInput4 = (uint)(absInput1 >> 0x20);\n                shiftAmount = ((int)normalizedInput4 >> 0x14) + -0x3ff + shiftAmount;\n                normalizedInput4 = normalizedInput4 & 0xfffff;\n                normalizedInput2 = normalizedInput4 | 0x3ff00000;\n                if (normalizedInput4 < 0x3988f) {\nLAB_08006628:\n                  exponentDiff = 0;\n                }\n                else {\n                  if (0xbb679 < normalizedInput4) {\n                    normalizedInput2 = normalizedInput2 - 0x100000;\n                    shiftAmount = shiftAmount + 1;\n                    goto LAB_08006628;\n                  }\n                  exponentDiff = 1;\n                }\n                index = exponentDiff * 8;\n                dpLow = (&bp)[exponentDiff * 2];\n                normalizedInput3 = (&DAT_080073c4)[exponentDiff * 2];\n                result6 = __subdf3();\n                result4 = (undefined4)((ulonglong)result6 >> 0x20);\n                result7 = __aeabi_dadd((int)absInput1,normalizedInput2,dpLow,normalizedInput3);\n                result7 = __divdf3(0,0x3ff00000,(int)result7,(int)((ulonglong)result7 >> 0x20));\n                result5 = (undefined4)((ulonglong)result7 >> 0x20);\n                result8 = __muldf3((int)result6,result4,(int)result7,result5);\n                result1 = (undefined4)((ulonglong)result8 >> 0x20);\n                result3 = (undefined4)result8;\n                result8 = __muldf3(0,result1);\n                result6 = __subdf3((int)result6,result4,(int)result8,(int)((ulonglong)result8 >> 0x20));\n                result8 = __subdf3(0,((int)normalizedInput2 >> 1 | 0x20000000U) + 0x80000 + exponentDiff * 0x40000,\n                                  dpLow,normalizedInput3);\n                result8 = __subdf3((int)absInput1,normalizedInput2,(int)result8,(int)((ulonglong)result8 >> 0x20));\n                result8 = __muldf3((int)result8,(int)((ulonglong)result8 >> 0x20),0,result1);\n                result6 = __subdf3((int)result6,(int)((ulonglong)result6 >> 0x20),(int)result8,\n                                  (int)((ulonglong)result8 >> 0x20));\n                result6 = __muldf3((int)result6,(int)((ulonglong)result6 >> 0x20),(int)result7,result5);\n                result5 = (undefined4)((ulonglong)result6 >> 0x20);\n                result7 = __muldf3(result3,result1);\n                dpLow = (undefined4)((ulonglong)result7 >> 0x20);\n                result4 = (undefined4)result7;\n                result7 = __muldf3(result4,dpLow,0x4a454eef,0x3fca7e28);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),0x93c9db65,\n                                      0x3fcd864a);\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result4,dpLow);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),0xa91d4101,\n                                      0x3fd17460);\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result4,dpLow);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),0x518f264d,\n                                      0x3fd55555);\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result4,dpLow);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),0xdb6fabff,\n                                      0x3fdb6db6);\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result4,dpLow);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),0x33333303,\n                                      0x3fe33333);\n                result8 = __muldf3(result4,dpLow,result4,dpLow);\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result8,\n                                  (int)((ulonglong)result8 >> 0x20));\n                result8 = __aeabi_dadd(result3,result1,0,result1);\n                result8 = __muldf3((int)result8,(int)((ulonglong)result8 >> 0x20),(int)result6,result5);\n                result7 = __aeabi_dadd((int)result8,(int)((ulonglong)result8 >> 0x20),(int)result7,\n                                      (int)((ulonglong)result7 >> 0x20));\n                result4 = (undefined4)((ulonglong)result7 >> 0x20);\n                result8 = __muldf3(0,result1,0,result1);\n                dpLow = (undefined4)((ulonglong)result8 >> 0x20);\n                result9 = __aeabi_dadd((int)result8,dpLow,0,0x40080000);\n                __aeabi_dadd((int)result9,(int)((ulonglong)result9 >> 0x20),(int)result7,result4);\n                result9 = __muldf3(0,result1,0,ignore);\n                normalizedInput3 = (undefined4)((ulonglong)result9 >> 0x20);\n                subtractResult2 = __subdf3(0,ignore,0,0x40080000);\n                result8 = __subdf3((int)subtractResult2,(int)((ulonglong)subtractResult2 >> 0x20),(int)result8,dpLow);\n                result7 = __subdf3((int)result7,result4,(int)result8,(int)((ulonglong)result8 >> 0x20));\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result3,result1);\n                result6 = __muldf3((int)result6,result5,0,ignore);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result6,\n                                      (int)((ulonglong)result6 >> 0x20));\n                result3 = (undefined4)((ulonglong)result7 >> 0x20);\n                __aeabi_dadd((int)result9,normalizedInput3,(int)result7,result3);\n                result6 = __muldf3(0,ignore,0xe0000000,0x3feec709);\n                result8 = __subdf3(0,ignore,(int)result9,normalizedInput3);\n                result7 = __subdf3((int)result7,result3,(int)result8,(int)((ulonglong)result8 >> 0x20));\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),0xdc3a03fd,0x3feec709\n                                 );\n                result8 = __muldf3(0,ignore,0x145b01f5,0xbe3e2fe0);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result8,\n                                      (int)((ulonglong)result8 >> 0x20));\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),\n                                      *(undefined4 *)(&dp_l + index),\n                                      *(undefined4 *)(&DAT_080073e4 + index));\n                result8 = __aeabi_i2d(shiftAmount);\n                result3 = (undefined4)((ulonglong)result8 >> 0x20);\n                result4 = *(undefined4 *)(&dp_h + index);\n                result5 = *(undefined4 *)(&DAT_080073d4 + index);\n                result9 = __aeabi_dadd((int)result6,(int)((ulonglong)result6 >> 0x20),(int)result7,\n                                      (int)((ulonglong)result7 >> 0x20));\n                result9 = __aeabi_dadd((int)result9,(int)((ulonglong)result9 >> 0x20),result4,result5);\n                __aeabi_dadd((int)result9,(int)((ulonglong)result9 >> 0x20),(int)result8,result3);\n                result8 = __subdf3(0,ignore,(int)result8,result3);\n                subtractResult = __subdf3((int)result8,(int)((ulonglong)result8 >> 0x20),result4,result5);\n                normalizedInput4 = ignore;\n              }\n              else {\n                if (0x43f00000 < normalizedInput4) {\n                  if (0x3fefffff < normalizedInput2) {\nLAB_08006418:\n                    if ((int)input4 < 1) {\n                      return;\n                    }\n                    goto LAB_0800634a;\n                  }\nLAB_080063fa:\n                  if (-1 < (int)input4) {\n                    return;\n                  }\n                  goto LAB_0800634a;\n                }\n                if (normalizedInput2 < 0x3fefffff) goto LAB_080063fa;\n                if (0x3ff00000 < normalizedInput2) goto LAB_08006418;\n                result6 = __subdf3();\n                result4 = (undefined4)((ulonglong)result6 >> 0x20);\n                result3 = (undefined4)result6;\n                result6 = __muldf3(result3,result4,0x60000000,0x3ff71547);\n                result7 = __muldf3(result3,result4,0xf85ddf44,0x3e54ae0b);\n                result8 = __muldf3(result3,result4,0,0x3fd00000);\n                result8 = __subdf3(0x55555555,0x3fd55555,(int)result8,(int)((ulonglong)result8 >> 0x20)\n                                 );\n                result8 = __muldf3((int)result8,(int)((ulonglong)result8 >> 0x20),result3,result4);\n                result8 = __subdf3(0,0x3fe00000,(int)result8,(int)((ulonglong)result8 >> 0x20));\n                result9 = __muldf3(result3,result4,result3,result4);\n                result8 = __muldf3((int)result8,(int)((ulonglong)result8 >> 0x20),(int)result9,\n                                  (int)((ulonglong)result9 >> 0x20));\n                result8 = __muldf3((int)result8,(int)((ulonglong)result8 >> 0x20),0x652b82fe,0x3ff71547\n                                 );\n                result7 = __subdf3((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result8,\n                                  (int)((ulonglong)result8 >> 0x20));\n                __aeabi_dadd((int)result6,(int)((ulonglong)result6 >> 0x20),(int)result7,\n                             (int)((ulonglong)result7 >> 0x20));\n                subtractResult = (ulonglong)ignore << 0x20;\n                normalizedInput4 = ignore;\n              }\n              result6 = __subdf3((int)subtractResult,(int)((ulonglong)subtractResult >> 0x20),(int)result6,\n                                (int)((ulonglong)result6 >> 0x20));\n              result6 = __subdf3((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result6,\n                                (int)((ulonglong)result6 >> 0x20));\n              if ((isOddFraction - 1 | signBit) == 0) {\n                result3 = 0xbff00000;\n              }\n              else {\n                result3 = 0x3ff00000;\n              }\n              normalizedInput3 = 0;\n              result7 = __subdf3(input3,input4,0,input4);\n              result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),0,normalizedInput4);\n              result6 = __muldf3((int)result6,(int)((ulonglong)result6 >> 0x20),input3,input4);\n              result6 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result6,\n                                    (int)((ulonglong)result6 >> 0x20));\n              result1 = (undefined4)((ulonglong)result6 >> 0x20);\n              result4 = (undefined4)result6;\n              result6 = __muldf3(0,normalizedInput4,0,input4);\n              dpLow = (undefined4)((ulonglong)result6 >> 0x20);\n              result5 = (undefined4)result6;\n              subtractResult = __aeabi_dadd(result4,result1,result5,dpLow);\n              normalizedInput2 = (uint)((ulonglong)subtractResult >> 0x20);\n              normalizedInput4 = (uint)subtractResult;\n              if (0x408fffffffffffff < subtractResult) {\n                if ((normalizedInput2 + 0xbf700000 | normalizedInput4) == 0) {\n                  result7 = __aeabi_dadd(result4,result1,0x652b82fe,0x3c971547);\n                  result8 = __subdf3(normalizedInput4,normalizedInput2,result5,dpLow);\n                  exponentDiff = __aeabi_dcmpgt((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result8,\n                                         (int)((ulonglong)result8 >> 0x20));\n                  if (exponentDiff == 0) goto LAB_08006968;\n                }\n                __muldf3(normalizedInput3,result3,0x8800759c,0x7e37e43c);\n                goto LAB_0800634a;\n              }\n              if ((normalizedInput2 & 0x7fffffff) < 0x4090cc00) {\nLAB_08006968:\n                if ((normalizedInput2 & 0x7fffffff) < 0x3fe00001) {\n                  exponentDiff = 0;\n                }\n                else {\n                  normalizedInput2 = (0x100000 >> (((int)(normalizedInput2 & 0x7fffffff) >> 0x14) - 0x3feU & 0xff)) +\n                          normalizedInput2;\n                  normalizedInput4 = (normalizedInput2 * 2 >> 0x15) - 0x3ff;\n                  exponentDiff = (int)(normalizedInput2 & 0xfffff | 0x100000) >> (0x14 - normalizedInput4 & 0xff);\n                  if (subtractResult < 0) {\n                    exponentDiff = -exponentDiff;\n                  }\n                  result6 = __subdf3(result5,dpLow,0,normalizedInput2 & ~(0xfffff >> (normalizedInput4 & 0xff)));\n                }\n                dividendHigh = (undefined4)((ulonglong)result6 >> 0x20);\n                dividendLow = (undefined4)result6;\n                __aeabi_dadd(dividendLow,dividendHigh,result4,result1);\n                result6 = __muldf3(0,ignore,0,0x3fe62e43);\n                result5 = (undefined4)((ulonglong)result6 >> 0x20);\n                result7 = __subdf3(0,ignore,dividendLow,dividendHigh);\n                result7 = __subdf3(result4,result1,(int)result7,(int)((ulonglong)result7 >> 0x20));\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),0xfefa39ef,0x3fe62e42\n                                 );\n                result8 = __muldf3(0,ignore,0xca86c39,0xbe205c61);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result8,\n                                      (int)((ulonglong)result8 >> 0x20));\n                result1 = (undefined4)((ulonglong)result7 >> 0x20);\n                result8 = __aeabi_dadd((int)result6,result5,(int)result7,result1);\n                dpLow = (undefined4)((ulonglong)result8 >> 0x20);\n                result4 = (undefined4)result8;\n                result6 = __subdf3(result4,dpLow,(int)result6,result5);\n                result6 = __subdf3((int)result7,result1,(int)result6,(int)((ulonglong)result6 >> 0x20));\n                result1 = (undefined4)((ulonglong)result6 >> 0x20);\n                result7 = __muldf3(result4,dpLow,result4,dpLow);\n                result2 = (undefined4)((ulonglong)result7 >> 0x20);\n                result5 = (undefined4)result7;\n                result7 = __muldf3(result5,result2,0x72bea4d0,0x3e663769);\n                result7 = __subdf3((int)result7,(int)((ulonglong)result7 >> 0x20),0xc5d26bf1,0x3ebbbd41\n                                 );\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result5,result2);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),0xaf25de2c,\n                                      0x3f11566a);\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result5,result2);\n                result7 = __subdf3((int)result7,(int)((ulonglong)result7 >> 0x20),0x16bebd93,0x3f66c16c\n                                 );\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result5,result2);\n                result7 = __aeabi_dadd((int)result7,(int)((ulonglong)result7 >> 0x20),0x5555553e,\n                                      0x3fc55555);\n                result7 = __muldf3((int)result7,(int)((ulonglong)result7 >> 0x20),result5,result2);\n                result7 = __subdf3(result4,dpLow,(int)result7,(int)((ulonglong)result7 >> 0x20));\n                result5 = (undefined4)((ulonglong)result7 >> 0x20);\n                result8 = __muldf3(result4,dpLow,(int)result7,result5);\n                result7 = __subdf3((int)result7,result5,0,0x40000000);\n                result7 = __divdf3((int)result8,(int)((ulonglong)result8 >> 0x20),(int)result7,\n                                  (int)((ulonglong)result7 >> 0x20));\n                result8 = __muldf3(result4,dpLow,(int)result6,result1);\n                result6 = __aeabi_dadd((int)result8,(int)((ulonglong)result8 >> 0x20),(int)result6,result1\n                                     );\n                result6 = __subdf3((int)result7,(int)((ulonglong)result7 >> 0x20),(int)result6,\n                                  (int)((ulonglong)result6 >> 0x20));\n                result6 = __subdf3((int)result6,(int)((ulonglong)result6 >> 0x20),result4,dpLow);\n                result6 = __subdf3(0,0x3ff00000,(int)result6,(int)((ulonglong)result6 >> 0x20));\n                if ((int)((ulonglong)result6 >> 0x20) + exponentDiff * 0x100000 < 0x100000) {\n                  scalbn((double)CONCAT44(result3,normalizedInput3),(int)result6);\n                }\n              }\n              else {\n                if ((normalizedInput2 + 0x3f6f3400 | normalizedInput4) == 0) {\n                  result7 = __subdf3(normalizedInput4,normalizedInput2,result5,dpLow);\n                  exponentDiff = __aeabi_dcmple(result4,result1,(int)result7,(int)((ulonglong)result7 >> 0x20));\n                  if (exponentDiff == 0) goto LAB_08006968;\n                }\n                __muldf3(normalizedInput3,result3,0xc2f8f359,0x1a56e1f);\n              }\nLAB_0800634a:\n              __muldf3();\n              return;\n            }\n          }\n          result6 = __subdf3();\n          result7 = result6;\nLAB_08006320:\n          __divdf3((int)result6,(int)((ulonglong)result6 >> 0x20),(int)result7,\n                   (int)((ulonglong)result7 >> 0x20));\n          return;\n        }\n      }\n    }\n    else if (normalizedInput4 < 0x7ff00001) goto LAB_08006262;\n  }\n  if ((normalizedInput2 + 0xc0100000 | input1) == 0) {\n    return;\n  }\nLAB_08006278:\n  nan(\"\");\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006228": "convert_floating_point_to_decimal_08006228",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "isOddFraction",
                "extraout_r1": "ignore",
                "extraout_r1_00": "ignore",
                "uVar2": "result1",
                "extraout_r1_01": "ignore",
                "extraout_r1_02": "ignore",
                "extraout_r1_03": "ignore",
                "extraout_r1_04": "ignore",
                "uVar3": "result2",
                "iVar4": "exponentDiff",
                "uVar5": "signBit",
                "iVar6": "index",
                "uVar7": "dpLow",
                "uVar8": "normalizedInput2",
                "uVar9": "result3",
                "uVar10": "normalizedInput4",
                "uVar11": "result4",
                "uVar12": "result5",
                "uVar13": "result6",
                "uVar14": "result7",
                "uVar15": "result8",
                "uVar16": "result9",
                "lVar17": "subtractResult",
                "uVar18": "absInput1",
                "uVar19": "subtractResult2",
                "uVar20": "normalizedInput3",
                "in_stack_ffffff94": "ignore",
                "local_68": "dividendLow",
                "local_64": "dividendHigh",
                "local_54": "shiftAmount"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_i2d",
                "scalbn",
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__ieee754_sqrt",
                "__muldf3",
                "__aeabi_dcmple",
                "nan",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c0c": {
            "entrypoint": "0x08006c0c",
            "current_name": "calculate_floating_point_product_08006c0c",
            "code": "\nundefined8 calculateFloatingPointProduct_08006c0c(uint operand1,uint operand2)\n\n{\n  undefined4 resultVar1;\n  uint resultVar2;\n  int shiftCount;\n  int loopCount;\n  uint tempVar1;\n  uint tempVar2;\n  int sumVar1;\n  uint sumVar2;\n  uint tempVar3;\n  int loopCount2;\n  uint tempVar4;\n  undefined8 finalResult;\n  \n  if ((~operand2 & 0x7ff00000) == 0) {\n    finalResult = __muldf3(operand1,operand2,operand1,operand2);\n    finalResult = __aeabi_dadd(operand1,operand2,(int)finalResult,(int)((ulonglong)finalResult >> 0x20));\n    return finalResult;\n  }\n  if ((int)operand2 < 1) {\n    if ((operand2 & 0x7fffffff | operand1) == 0) {\n      return CONCAT44(operand2,operand1);\n    }\n    if (operand2 != 0) {\n      finalResult = __subdf3(operand1,operand2,operand1,operand2);\n      resultVar1 = (undefined4)((ulonglong)finalResult >> 0x20);\n      finalResult = __divdf3((int)finalResult,resultVar1,(int)finalResult,resultVar1);\n      return finalResult;\n    }\n  }\n  shiftCount = (int)operand2 >> 0x14;\n  if (shiftCount == 0) {\n    while (operand2 == 0) {\n      shiftCount = shiftCount + -0x15;\n      operand2 = operand1 >> 0xb;\n      operand1 = operand1 << 0x15;\n    }\n    resultVar2 = 0;\n    for (; -1 < (int)(operand2 << 0xb); operand2 = operand2 << 1) {\n      resultVar2 = resultVar2 + 1;\n    }\n    shiftCount = shiftCount - (resultVar2 - 1);\n    operand2 = operand2 | operand1 >> (0x20 - resultVar2 & 0xff);\n    operand1 = operand1 << (resultVar2 & 0xff);\n  }\n  sumVar1 = 0;\n  resultVar2 = operand2 & 0xfffff | 0x100000;\n  if ((shiftCount + -0x3ff) * -0x80000000 < 0) {\n    resultVar2 = resultVar2 * 2 - ((int)operand1 >> 0x1f);\n    operand1 = operand1 << 1;\n  }\n  resultVar2 = resultVar2 * 2 - ((int)operand1 >> 0x1f);\n  loopCount = 0x16;\n  tempVar1 = 0;\n  sumVar2 = 0x200000;\n  operand1 = operand1 << 1;\n  do {\n    loopCount2 = tempVar1 + sumVar2;\n    if (loopCount2 <= (int)resultVar2) {\n      resultVar2 = resultVar2 - loopCount2;\n      tempVar1 = loopCount2 + sumVar2;\n      sumVar1 = sumVar1 + sumVar2;\n    }\n    loopCount = loopCount + -1;\n    resultVar2 = resultVar2 * 2 - ((int)operand1 >> 0x1f);\n    sumVar2 = sumVar2 >> 1;\n    operand1 = operand1 << 1;\n  } while (loopCount != 0);\n  loopCount2 = 0x20;\n  tempVar3 = 0x80000000;\n  sumVar2 = 0;\n  loopCount = 0;\n  do {\n    tempVar4 = tempVar3 + loopCount;\n    tempVar2 = tempVar1;\n    if (((int)tempVar1 < (int)resultVar2) || ((resultVar2 == tempVar1 && (tempVar4 <= operand1)))) {\n      loopCount = tempVar4 + tempVar3;\n      if (((int)tempVar4 < 0) && (-1 < loopCount)) {\n        tempVar2 = tempVar1 + 1;\n      }\n      resultVar2 = resultVar2 - tempVar1;\n      if (operand1 < tempVar4) {\n        resultVar2 = resultVar2 - 1;\n      }\n      operand1 = operand1 - tempVar4;\n      sumVar2 = sumVar2 + tempVar3;\n    }\n    resultVar2 = resultVar2 * 2 - ((int)operand1 >> 0x1f);\n    loopCount2 = loopCount2 + -1;\n    operand1 = operand1 << 1;\n    tempVar3 = tempVar3 >> 1;\n    tempVar1 = tempVar2;\n  } while (loopCount2 != 0);\n  if ((operand1 | resultVar2) != 0) {\n    if (sumVar2 == 0xffffffff) {\n      sumVar1 = sumVar1 + 1;\n      sumVar2 = 0;\n    }\n    else {\n      sumVar2 = sumVar2 + 1 & 0xfffffffe;\n    }\n  }\n  sumVar2 = sumVar2 >> 1;\n  if (sumVar1 << 0x1f < 0) {\n    sumVar2 = sumVar2 | 0x80000000;\n  }\n  return CONCAT44((sumVar1 >> 1) + 0x3fe00000 + (shiftCount + -0x3ff >> 1) * 0x100000,sumVar2);\n}\n\n",
            "renaming": {
                "FUN_08006c0c": "calculate_floating_point_product_08006c0c",
                "param_1": "operand1",
                "param_2": "operand2",
                "uVar1": "resultVar1",
                "uVar2": "resultVar2",
                "iVar3": "shiftCount",
                "iVar4": "loopCount",
                "uVar5": "tempVar1",
                "uVar6": "tempVar2",
                "iVar7": "sumVar1",
                "uVar8": "sumVar2",
                "uVar9": "tempVar3",
                "iVar10": "loopCount2",
                "uVar11": "tempVar4",
                "uVar12": "finalResult"
            },
            "calling": [
                "__ieee754_asin",
                "sqrt",
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d68": {
            "entrypoint": "0x08006d68",
            "current_name": "calculate_square_root_08006d68",
            "code": "\ndouble calculateSquareRoot_08006d68(double input)\n\n{\n  int integerPart;\n  int comparisonResult;\n  undefined4 tempVar2;\n  undefined4 tempVar3;\n  uint fractionalPart;\n  undefined4 extraTempVar1;\n  undefined4 tempVar4;\n  undefined4 tempVar5;\n  undefined4 extraTempVar2;\n  undefined4 extraTempVar3;\n  undefined4 tempVar6;\n  undefined4 tempVar7;\n  uint absFractionalPart;\n  double result;\n  double extraTempVar4;\n  undefined8 tempVar9;\n  undefined8 tempVar10;\n  \n  tempVar10 = CONCAT44(fractionalPart,integerPart);\n  absFractionalPart = fractionalPart & 0x7fffffff;\n  if (absFractionalPart < 0x44100000) {\n    if (absFractionalPart < 0x3fdc0000) {\n      if (absFractionalPart < 0x3e200000) {\n        tempVar9 = __aeabi_dadd(integerPart,fractionalPart,0x8800759c,0x7e37e43c);\n        comparisonResult = __aeabi_dcmpgt((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),0,0x3ff00000);\n        if (comparisonResult != 0) {\n          return extraTempVar4;\n        }\n      }\n      comparisonResult = -1;\n    }\n    else {\n      fabs((double)CONCAT44(extraTempVar3,extraTempVar2));\n      if (absFractionalPart < 0x3ff30000) {\n        if (absFractionalPart < 0x3fe60000) {\n          tempVar10 = __aeabi_dadd();\n          tempVar10 = __subdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0,0x3ff00000);\n          tempVar9 = __aeabi_dadd(integerPart,extraTempVar1,0,0x40000000);\n          tempVar10 = __divdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),(int)tempVar9,\n                            (int)((ulonglong)tempVar9 >> 0x20));\n          comparisonResult = 0;\n        }\n        else {\n          tempVar10 = __subdf3();\n          tempVar9 = __aeabi_dadd(integerPart,extraTempVar1,0,0x3ff00000);\n          tempVar10 = __divdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),(int)tempVar9,\n                            (int)((ulonglong)tempVar9 >> 0x20));\n          comparisonResult = 1;\n        }\n      }\n      else if (absFractionalPart < 0x40038000) {\n        tempVar10 = __subdf3();\n        tempVar9 = __muldf3(integerPart,extraTempVar1,0,0x3ff80000);\n        tempVar9 = __aeabi_dadd((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),0,0x3ff00000);\n        tempVar10 = __divdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),(int)tempVar9,\n                          (int)((ulonglong)tempVar9 >> 0x20));\n        comparisonResult = 2;\n      }\n      else {\n        tempVar10 = __divdf3(0,0xbff00000,integerPart,extraTempVar1);\n        comparisonResult = 3;\n      }\n    }\n    tempVar7 = (undefined4)((ulonglong)tempVar10 >> 0x20);\n    tempVar6 = (undefined4)tempVar10;\n    tempVar10 = __muldf3(tempVar6,tempVar7,tempVar6,tempVar7);\n    tempVar4 = (undefined4)((ulonglong)tempVar10 >> 0x20);\n    tempVar2 = (undefined4)tempVar10;\n    tempVar10 = __muldf3(tempVar2,tempVar4,tempVar2,tempVar4);\n    tempVar5 = (undefined4)((ulonglong)tempVar10 >> 0x20);\n    tempVar3 = (undefined4)tempVar10;\n    tempVar10 = __muldf3(tempVar3,tempVar5,0xe322da11,0x3f90ad3a);\n    tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x24760deb,0x3fa97b4b);\n    tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar3,tempVar5);\n    tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0xa0d03d51,0x3fb10d66);\n    tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar3,tempVar5);\n    tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0xc54c206e,0x3fb745cd);\n    tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar3,tempVar5);\n    tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x920083ff,0x3fc24924);\n    tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar3,tempVar5);\n    tempVar10 = __aeabi_dadd((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),0x5555550d,0x3fd55555);\n    tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar2,tempVar4);\n    tempVar2 = (undefined4)((ulonglong)tempVar10 >> 0x20);\n    tempVar9 = __muldf3(tempVar3,tempVar5,0x2c6a6c2f,0xbfa2b444);\n    tempVar9 = __subdf3((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),0x52defd9a,0x3fadde2d);\n    tempVar9 = __muldf3((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),tempVar3,tempVar5);\n    tempVar9 = __subdf3((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    tempVar9 = __muldf3((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),tempVar3,tempVar5);\n    tempVar9 = __subdf3((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),0xfe231671,0x3fbc71c6);\n    tempVar9 = __muldf3((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),tempVar3,tempVar5);\n    tempVar9 = __subdf3((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),0x9998ebc4,0x3fc99999);\n    tempVar9 = __muldf3((int)tempVar9,(int)((ulonglong)tempVar9 >> 0x20),tempVar3,tempVar5);\n    tempVar3 = (undefined4)((ulonglong)tempVar9 >> 0x20);\n    if (comparisonResult == -1) {\n      tempVar10 = __aeabi_dadd((int)tempVar10,tempVar2,(int)tempVar9,tempVar3);\n      tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar7);\n      result = (double)__subdf3(tempVar6,tempVar7,(int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20));\n    }\n    else {\n      tempVar10 = __aeabi_dadd((int)tempVar10,tempVar2,(int)tempVar9,tempVar3);\n      tempVar10 = __muldf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar7);\n      comparisonResult = comparisonResult * 8;\n      tempVar10 = __subdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),\n                        *(undefined4 *)(&atanlo + comparisonResult),*(undefined4 *)(&UNK_08007414 + comparisonResult));\n      tempVar10 = __subdf3((int)tempVar10,(int)((ulonglong)tempVar10 >> 0x20),tempVar6,tempVar7);\n      result = (double)__subdf3(*(undefined4 *)(&atanhi + comparisonResult),\n                               *(undefined4 *)(&UNK_080073f4 + comparisonResult),(int)tempVar10,\n                               (int)((ulonglong)tempVar10 >> 0x20));\n    }\n  }\n  else if ((0x7ff00000 < absFractionalPart) || ((absFractionalPart == 0x7ff00000 && (integerPart != 0)))) {\n    result = (double)__aeabi_dadd();\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006d68": "calculate_square_root_08006d68",
                "__x": "input",
                "in_r0": "integerPart",
                "iVar1": "comparisonResult",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "in_r1": "fractionalPart",
                "extraout_r1": "extraTempVar1",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "in_r3": "extraTempVar2",
                "unaff_r4": "extraTempVar3",
                "uVar6": "tempVar6",
                "uVar7": "tempVar7",
                "uVar8": "absFractionalPart",
                "in_d0": "result",
                "extraout_d0": "extraTempVar4",
                "uVar9": "tempVar9",
                "uVar10": "tempVar10"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "fabs",
                "__aeabi_dadd",
                "__aeabi_dcmpgt",
                "__muldf3",
                "__divdf3",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800708c": {
            "entrypoint": "0x0800708c",
            "current_name": "calculate_double_value_0800708c",
            "code": "\ndouble calculate_double_value_0800708c(double input_value)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800708c": "calculate_double_value_0800708c",
                "__x": "input_value",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_atan2",
                "atan",
                "__ieee754_asin",
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007092": {
            "entrypoint": "0x08007092",
            "current_name": "calculate_shifted_value_08007092",
            "code": "\nint calculate_shifted_value_08007092(double input_value)\n\n{\n  uint bitwise_or_result;\n  \n  return (bitwise_or_result | 0x80000000) + 0x100000 >> 0x1f;\n}\n\n",
            "renaming": {
                "FUN_08007092": "calculate_shifted_value_08007092",
                "__value": "input_value",
                "in_r1": "bitwise_or_result"
            },
            "calling": [
                "pow"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800709e": {
            "entrypoint": "0x0800709e",
            "current_name": "handle_exception_0800709e",
            "code": "\nint handle_exception_0800709e(exception *exception_obj)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800709e": "handle_exception_0800709e",
                "__exc": "exception_obj"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070a4": {
            "entrypoint": "0x080070a4",
            "current_name": "calculate_tagb_080070a4",
            "code": "\ndouble calculateTagb_080070a4(char *tagb)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_080070a4": "calculate_tagb_080070a4",
                "__tagb": "tagb",
                "in_d0": "result"
            },
            "calling": [
                "__ieee754_pow",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080070b0": {
            "entrypoint": "0x080070b0",
            "current_name": "calculate_inverse_square_root_080070b0",
            "code": "\ndouble calculate_inverse_square_root_080070b0(double input_value)\n\n{\n  int iVar1;\n  uint lower_word;\n  uint upper_word;\n  undefined4 temp_variable_1;\n  undefined4 temp_variable_2;\n  uint exponent_difference;\n  uint exponent_shifted;\n  double result;\n  double final_result;\n  undefined8 temp_variable_3;\n  \n  exponent_shifted = (upper_word << 1) >> 0x15;\n  exponent_difference = exponent_shifted - 0x3ff;\n  iVar1 = (int)upper_word >> 0x1f;\n  if ((int)exponent_difference < 0x14) {\n    if ((int)exponent_difference < 0) {\n      if ((upper_word & 0x7fffffff | lower_word) == 0) {\n        return result;\n      }\n      exponent_difference = upper_word & 0xfffff | lower_word;\n      iVar1 = iVar1 * -8;\n      temp_variable_1 = *(undefined4 *)(&TWO52 + iVar1);\n      temp_variable_2 = *(undefined4 *)(&DAT_08007434 + iVar1);\n      temp_variable_3 = __aeabi_dadd(lower_word,(-exponent_difference | exponent_difference) >> 0xc & 0x80000 | upper_word & 0xfffe0000,temp_variable_1,temp_variable_2)\n      ;\n      final_result = (double)__subdf3((int)temp_variable_3,(int)((ulonglong)temp_variable_3 >> 0x20),temp_variable_1,temp_variable_2);\n      return final_result;\n    }\n    exponent_shifted = 0xfffff >> (exponent_difference & 0xff);\n    if ((upper_word & exponent_shifted | lower_word) == 0) {\n      return result;\n    }\n    exponent_shifted = exponent_shifted >> 1;\n    lower_word = upper_word & exponent_shifted | lower_word;\n    if (lower_word != 0) {\n      if (exponent_difference == 0x13) {\n        lower_word = 0x80000000;\n      }\n      else {\n        lower_word = 0;\n      }\n      upper_word = 0x40000 >> (exponent_difference & 0xff) | upper_word & ~exponent_shifted;\n    }\n  }\n  else {\n    if (0x33 < (int)exponent_difference) {\n      if (exponent_difference != 0x400) {\n        return result;\n      }\n      final_result = (double)__aeabi_dadd();\n      return final_result;\n    }\n    exponent_shifted = exponent_shifted - 0x413;\n    exponent_difference = 0xffffffff >> (exponent_shifted & 0xff);\n    if ((lower_word & exponent_difference) == 0) {\n      return result;\n    }\n    exponent_difference = exponent_difference >> 1;\n    if ((lower_word & exponent_difference) != 0) {\n      lower_word = 0x40000000 >> (exponent_shifted & 0xff) | lower_word & ~exponent_difference;\n    }\n  }\n  iVar1 = iVar1 * -8;\n  temp_variable_1 = *(undefined4 *)(&TWO52 + iVar1);\n  temp_variable_2 = *(undefined4 *)(&DAT_08007434 + iVar1);\n  temp_variable_3 = __aeabi_dadd(lower_word,upper_word,temp_variable_1,temp_variable_2);\n  final_result = (double)__subdf3((int)temp_variable_3,(int)((ulonglong)temp_variable_3 >> 0x20),temp_variable_1,temp_variable_2);\n  return final_result;\n}\n\n",
            "renaming": {
                "FUN_080070b0": "calculate_inverse_square_root_080070b0",
                "__x": "input_value",
                "in_r0": "lower_word",
                "in_r1": "upper_word",
                "uVar2": "temp_variable_1",
                "uVar3": "temp_variable_2",
                "uVar4": "exponent_difference",
                "uVar5": "exponent_shifted",
                "in_d0": "result",
                "dVar6": "final_result",
                "uVar7": "temp_variable_3"
            },
            "calling": [
                "pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080071c0": {
            "entrypoint": "0x080071c0",
            "current_name": "calculate_exponential_080071c0",
            "code": "\ndouble calculateExponential_080071c0(double base,int exponent)\n\n{\n  uint shiftedBits;\n  int extraShiftedBits;\n  int powerOffset;\n  uint shiftedBitsResult;\n  int totalExponent;\n  undefined4 in_r3;\n  undefined4 sign1;\n  undefined4 sign2;\n  undefined4 sign3;\n  double result;\n  double finalResult;\n  \n  shiftedBitsResult = (shiftedBits << 1) >> 0x15;\n  if (shiftedBitsResult == 0) {\n    if ((shiftedBits & 0x7fffffff | exponent) == 0) {\n      return result;\n    }\n    result = (double)__muldf3(exponent,shiftedBits,0,0x43500000);\n    if (powerOffset < -50000) goto LAB_0800722e;\n    shiftedBitsResult = ((uint)(extraShiftedBits << 1) >> 0x15) - 0x36;\n  }\n  else if (shiftedBitsResult == 0x7ff) {\n    finalResult = (double)__aeabi_dadd(exponent,shiftedBits,exponent);\n    return finalResult;\n  }\n  totalExponent = shiftedBitsResult + powerOffset;\n  if (totalExponent < 0x7ff) {\n    if (0 < totalExponent) {\n      return result;\n    }\n    if (totalExponent + 0x35 < 0 == SCARRY4(totalExponent,0x35)) goto LAB_0800722e;\n    if (powerOffset < 0xc351) {\n      copysign((double)CONCAT44(sign1,in_r3),(double)CONCAT44(sign3,sign2));\n      goto LAB_0800722e;\n    }\n  }\n  copysign((double)CONCAT44(sign1,in_r3),(double)CONCAT44(sign3,sign2));\nLAB_0800722e:\n  finalResult = (double)__muldf3();\n  return finalResult;\n}\n\n",
            "renaming": {
                "FUN_080071c0": "calculate_exponential_080071c0",
                "__x": "base",
                "__n": "exponent",
                "in_r1": "shiftedBits",
                "extraout_r1": "extraShiftedBits",
                "in_r2": "powerOffset",
                "uVar1": "shiftedBitsResult",
                "iVar2": "totalExponent",
                "in_d0": "result",
                "dVar3": "finalResult",
                "unaff_r4": "sign1",
                "unaff_r5": "sign2",
                "unaff_r6": "sign3"
            },
            "calling": [
                "__ieee754_pow"
            ],
            "called": [
                "__aeabi_dadd",
                "__muldf3",
                "copysign"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800729c": {
            "entrypoint": "0x0800729c",
            "current_name": "calculate_distance_0800729c",
            "code": "\ndouble calculate_distance_0800729c(double point1_x,double point1_y)\n\n{\n  double distance;\n  \n  return distance;\n}\n\n",
            "renaming": {
                "FUN_0800729c": "calculate_distance_0800729c",
                "__x": "point1_x",
                "__y": "point1_y",
                "in_d0": "distance"
            },
            "calling": [
                "scalbn"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072ac": {
            "entrypoint": "0x080072ac",
            "current_name": "get_impure_ptr_080072ac",
            "code": "\nundefined4 get_impure_ptr_080072ac(void)\n\n{\n  return impure_ptr;\n}\n\n",
            "renaming": {
                "FUN_080072ac": "get_impure_ptr_080072ac",
                "_impure_ptr": "impure_ptr"
            },
            "calling": [
                "pow",
                "sqrt",
                "asin"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072b8": {
            "entrypoint": "0x080072b8",
            "current_name": "allocate_memory_080072b8",
            "code": "\nvoid * allocateMemory_080072b8(intptr_t memorySize)\n\n{\n  undefined *oldHeapEnd;\n  \n  if (currentHeapEnd == (undefined *)0x0) {\n    currentHeapEnd = &endOfBss;\n  }\n  oldHeapEnd = currentHeapEnd;\n  currentHeapEnd = currentHeapEnd + memorySize;\n  return oldHeapEnd;\n}\n\n",
            "renaming": {
                "FUN_080072b8": "allocate_memory_080072b8",
                "__delta": "memorySize",
                "puVar1": "oldHeapEnd",
                "heap_end_4116": "currentHeapEnd",
                "_ebss": "endOfBss"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072d4": {
            "entrypoint": "0x080072d4",
            "current_name": "extracted_key_ctx_080072d4",
            "code": "\nint extractedKeyCTX_080072d4(EVP_PKEY_CTX *pKeyContext)\n\n{\n  return (int)pKeyContext;\n}\n\n",
            "renaming": {
                "FUN_080072d4": "extracted_key_ctx_080072d4",
                "ctx": "pKeyContext"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080072e0": {
            "entrypoint": "0x080072e0",
            "current_name": "FUNC_080072e0",
            "code": "\nvoid FUNC_080072e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080072e0": "FUNC_080072e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 169492,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000160",
            "FUN_08000168",
            "FUN_0800016c",
            "FUN_080003e4",
            "FUN_08000404",
            "FUN_08000428",
            "FUN_08000464",
            "FUN_08000474",
            "FUN_080006ac",
            "FUN_08000892",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000904",
            "FUN_08000980",
            "FUN_08000990",
            "FUN_080009a0",
            "FUN_080009b4",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a30",
            "FUN_08000ad0",
            "FUN_08000ad8",
            "FUN_08000adc",
            "FUN_08000c3c",
            "FUN_08000c44",
            "FUN_08000c60",
            "FUN_08000c70",
            "FUN_08000cec",
            "FUN_08000e54",
            "FUN_08000f8c",
            "FUN_08000f94",
            "FUN_08000f9c",
            "FUN_08000ffc",
            "FUN_08001004",
            "FUN_08001014",
            "FUN_08001028",
            "FUN_0800103c",
            "FUN_08001050",
            "FUN_08001064",
            "FUN_08001078",
            "FUN_080010c4",
            "FUN_08001104",
            "FUN_08001128",
            "FUN_0800114c",
            "FUN_0800115c",
            "FUN_08001170",
            "FUN_08001194",
            "FUN_080011fc",
            "FUN_08001214",
            "FUN_08001240",
            "FUN_0800125a",
            "FUN_08001264",
            "FUN_08001424",
            "FUN_0800142e",
            "FUN_08001436",
            "FUN_08001460",
            "FUN_080014e2",
            "FUN_08001530",
            "FUN_080015e8",
            "FUN_080016f4",
            "FUN_08001754",
            "FUN_08001828",
            "FUN_08001938",
            "FUN_08001b58",
            "FUN_08002008",
            "FUN_0800209c",
            "FUN_08002214",
            "FUN_08002220",
            "FUN_08002250",
            "FUN_08002280",
            "FUN_080022d0",
            "FUN_08002324",
            "FUN_08002368",
            "FUN_080023d0",
            "FUN_08002404",
            "FUN_0800245c",
            "FUN_08002520",
            "FUN_08002538",
            "FUN_08002564",
            "FUN_080025a4",
            "FUN_080025e8",
            "FUN_08002724",
            "FUN_0800277c",
            "FUN_080028a6",
            "FUN_0800290c",
            "FUN_0800299a",
            "FUN_08002ad0",
            "FUN_08002b48",
            "FUN_08002bf0",
            "FUN_08002cb0",
            "FUN_08002d88",
            "FUN_08002ea0",
            "FUN_08002ec0",
            "FUN_08002ed4",
            "FUN_08002ee8",
            "FUN_08002f28",
            "FUN_08003034",
            "FUN_08003068",
            "FUN_08003078",
            "FUN_08003298",
            "FUN_08003314",
            "FUN_08003320",
            "FUN_08003330",
            "FUN_08003eac",
            "FUN_08003eb0",
            "FUN_08003ec8",
            "FUN_08003ef2",
            "FUN_08003f0e",
            "FUN_08003f3c",
            "FUN_08003f7c",
            "FUN_08003fc4",
            "FUN_08003fd0",
            "FUN_08003fdc",
            "FUN_08003fe8",
            "FUN_08003ff4",
            "FUN_08004028",
            "FUN_0800403c",
            "FUN_0800407c",
            "FUN_080040b8",
            "FUN_080040e8",
            "FUN_0800411c",
            "FUN_08004194",
            "FUN_080041ae",
            "FUN_080041c4",
            "FUN_080041e4",
            "FUN_0800426c",
            "FUN_08004300",
            "FUN_08004348",
            "FUN_08004384",
            "FUN_080043bc",
            "FUN_080043f0",
            "FUN_08004410",
            "FUN_08004434",
            "FUN_08004458",
            "FUN_08004490",
            "FUN_08004514",
            "FUN_0800458c",
            "FUN_0800483c",
            "FUN_08004978",
            "FUN_08004a30",
            "FUN_08004a84",
            "FUN_08004c18",
            "FUN_08004c30",
            "FUN_08004c64",
            "FUN_08004c70",
            "FUN_08004c8c",
            "FUN_08004cac",
            "FUN_08004ccc",
            "FUN_08004d48",
            "FUN_08004d8c",
            "FUN_08004e14",
            "FUN_08004e7c",
            "FUN_08004ee6",
            "FUN_08004ee8",
            "FUN_08004eea",
            "FUN_08004eec",
            "FUN_08004ef4",
            "FUN_08004f04",
            "FUN_08004f10",
            "FUN_08004f60",
            "FUN_08004f68",
            "FUN_08004fb0",
            "FUN_08004fb4",
            "FUN_08004ffc",
            "FUN_08005044",
            "FUN_080050fc",
            "FUN_080052e4",
            "FUN_080053d4",
            "FUN_08005614",
            "FUN_08005630",
            "FUN_08005646",
            "FUN_0800567c",
            "FUN_08005714",
            "FUN_080057d0",
            "FUN_0800581c",
            "FUN_08005840",
            "FUN_08005854",
            "FUN_08005900",
            "FUN_08005bc8",
            "FUN_08005c70",
            "FUN_08006070",
            "FUN_08006228",
            "FUN_08006c0c",
            "FUN_08006d68",
            "FUN_0800708c",
            "FUN_08007092",
            "FUN_0800709e",
            "FUN_080070a4",
            "FUN_080070b0",
            "FUN_080071c0",
            "FUN_0800729c",
            "FUN_080072ac",
            "FUN_080072b8",
            "FUN_080072d4"
        ],
        [
            "FUN_080004d0",
            "FUN_08000724"
        ]
    ],
    "locked_functions": []
}