{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "initialize_completed_flag_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 initializeCompletedFlag_000800f4(undefined4 inputValue)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "initialize_completed_flag_000800f4",
                "param_1": "inputValue",
                "completed_7857": "completionFlag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080148": {
            "entrypoint": "0x00080148",
            "current_name": "FUNC_00080148",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t FUNC_00080148(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_00080148": "FUNC_00080148"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008014c": {
            "entrypoint": "0x0008014c",
            "current_name": "execute_afl_call_0008014c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_0008014c(int numberOfTicks)\n\n{\n  uint32_t aflReturnValue;\n  \n  if (noHyperCall == 0) {\n    aflReturnValue = aflCall(1,numberOfTicks,0);\n    return aflReturnValue;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008014c": "execute_afl_call_0008014c",
                "ticks": "numberOfTicks",
                "uVar1": "aflReturnValue"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "control_servos_00080164",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid controlServos_00080164(void)\n\n{\n  void *buffer;\n  size_t bufferSize;\n  \n  Servo::write(&throttle,0x5a,buffer,bufferSize);\n  Servo::write(&steering,0x5a,buffer,bufferSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "control_servos_00080164",
                "in_r2": "buffer",
                "in_r3": "bufferSize"
            },
            "calling": [
                "loop",
                "setup"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080184": {
            "entrypoint": "0x00080184",
            "current_name": "initialize_servos_00080184",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServos_00080184(void)\n\n{\n  undefined4 unused;\n  \n  Servo::Servo(&steeringServo);\n  Servo::Servo(&throttleServo);\n  String::String(&commandString,\"\");\n  __aeabi_atexit(&commandString,0x81473,&__dso_handle);\n  String::String(&valueString,\"\");\n  __aeabi_atexit(&valueString,0x81473,&__dso_handle,unused);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080184": "initialize_servos_00080184",
                "in_r3": "unused",
                "steering": "steeringServo",
                "throttle": "throttleServo",
                "command": "commandString",
                "value": "valueString"
            },
            "calling": [],
            "called": [
                "Servo",
                "String",
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801e0": {
            "entrypoint": "0x000801e0",
            "current_name": "initialize_components_000801e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeComponents_000801e0(void)\n\n{\n  UARTClass::begin(&serialInterface,0xe100);\n  pinMode(0xd,1);\n  pinMode(6,1);\n  pinMode(0x39,0);\n  pinMode(4,0);\n  pinMode(3,0);\n  pinMode(2,0);\n  Servo::attach(&steeringServo,5);\n  Servo::attach(&throttleServo,6);\n  straightAndStop();\n  delay(1000);\n  startForkserver(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000801e0": "initialize_components_000801e0",
                "Serial": "serialInterface",
                "steering": "steeringServo",
                "throttle": "throttleServo"
            },
            "calling": [
                "main"
            ],
            "called": [
                "straightAndStop",
                "delay",
                "attach",
                "begin",
                "startForkserver",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080250": {
            "entrypoint": "0x00080250",
            "current_name": "control_motor_and_steer_00080250",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid controlMotorAndSteer_00080250(void)\n\n{\n  uchar uVar1;\n  uint32_t pulseDuration;\n  int rawMotorValue;\n  int availableBytes;\n  long fileDescriptor;\n  Servo *servoPtr;\n  uint ledStatus;\n  int fileDescriptor1;\n  int inCharge;\n  int inCharge1;\n  int fileDescriptor2;\n  void *dataPtr;\n  size_t dataSize;\n  stringObject commandStack;\n  \n  rxInput = pulseIn(4,1,20000);\n  delay(10);\n  ledStatus = (uint)ledStatus;\n  ledStatus = SUB41(ledStatus ^ 1,0);\n  digitalWrite(0pulseDurationd,ledStatus ^ 1);\n  if (rxInput < 0pulseDuration641) {\n    if (rxInput - 0pulseDuration385U < 299) {\n      if (manualControlMode != false) {\n        straightAndStop();\n        printInstance::println((printInstance *)&serialPort,\"Entered manual control manualControlMode.\");\n        manualControlMode = false;\n      }\n      delay(10);\n      pulseDuration = pulseIn(3,1,20000);\n      steeringValue = map(0,1000,2000,0pulseDuration28,0pulseDuration96);\n      dataPtr = (void *)0pulseDuration7d0;\n      dataSize = 0pulseDuration28;\n      motorValue = map(pulseDuration,1000,2000,0pulseDuration28,0pulseDuration96);\n      while (availableBytes = UARTClass::available(&serialPort), 0 < availableBytes) {\n        UARTClass::read(&serialPort,fileDescriptor1,dataPtr,dataSize);\n        printInstance::print((printInstance *)&serialPort,steeringValue,10);\n        printInstance::print((printInstance *)&serialPort,\",\");\n        dataPtr = (void *)0pulseDurationa;\n        printInstance::println((printInstance *)&serialPort,motorValue,10);\n      }\n      Servo::write(&throttleServo,motorValue,dataPtr,dataSize);\n      Servo::write(&steeringServo,steeringValue,dataPtr,dataSize);\n    }\n    else {\n      if (manualControlMode == false) {\n        straightAndStop();\n        printInstance::println((printInstance *)&serialPort,\"Entered autonomous control manualControlMode.\");\n      }\n      dataSize = 1;\n      manualControlMode = true;\nLAB_00080346:\n      availableBytes = UARTClass::available(&serialPort);\n      if (0 < availableBytes) {\n        Stream::readstringObjectUntil((Stream *)&serialPort,',');\n        stringObject::operator=(&commandString,&commandStack);\n        stringObject::~stringObject(&commandStack,inCharge);\n        dataPtr = (void *)0pulseDurationa;\n        Stream::readstringObjectUntil((Stream *)&serialPort,'\\n');\n        stringObject::operator=(&valueString,&commandStack);\n        stringObject::~stringObject(&commandStack,inCharge1);\n        UARTClass::read(&serialPort,fileDescriptor2,dataPtr,dataSize);\n        uVar1 = stringObject::equals(&commandString,\"steer\");\n        if (uVar1 == '\\0') goto LAB_0008039c;\n        fileDescriptor = stringObject::toInt(&valueString);\n        servoPtr = &steeringServo;\n        goto LAB_000803b2;\n      }\n    }\n  }\n  else {\n    straightAndStop();\n    printInstance::println((printInstance *)&serialPort,\"error\");\n  }\n  return;\nLAB_0008039c:\n  uVar1 = stringObject::equals(&commandString,\"motor\");\n  if (uVar1 != '\\0') {\n    fileDescriptor = stringObject::toInt(&valueString);\n    servoPtr = &throttleServo;\nLAB_000803b2:\n    Servo::write(servoPtr,fileDescriptor,dataPtr,dataSize);\n  }\n  goto LAB_00080346;\n}\n\n",
            "renaming": {
                "FUN_00080250": "control_motor_and_steer_00080250",
                "rxMotorRaw": "rawMotorValue",
                "iVar2": "availableBytes",
                "__fd": "fileDescriptor",
                "this": "servoPtr",
                "uVar3": "ledStatus",
                "__fd_00": "fileDescriptor1",
                "__in_chrg": "inCharge",
                "__in_chrg_00": "inCharge1",
                "__fd_01": "fileDescriptor2",
                "pvVar4": "dataPtr",
                "sVar5": "dataSize",
                "SStack_1c": "commandStack",
                "rxMode": "rxInput",
                "mode": "manualControlMode",
                "LEDstatus": "ledStatus",
                "rxSteer": "steeringValue",
                "rxMotor": "motorValue",
                "x": "pulseDuration",
                "throttle": "throttleServo",
                "steering": "steeringServo",
                "Serial": "serialPort",
                "Print": "printInstance",
                "String": "stringObject",
                "command": "commandString",
                "value": "valueString"
            },
            "calling": [
                "main"
            ],
            "called": [
                "println",
                "print",
                "write",
                "pulseIn",
                "available",
                "equals",
                "~String",
                "straightAndStop",
                "readStringUntil",
                "operator=",
                "println",
                "delay",
                "toInt",
                "digitalWrite",
                "map",
                "read",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803fc": {
            "entrypoint": "0x000803fc",
            "current_name": "initialize_timer_000803fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoperipheralId initializeTimer_000803fc(Tc *timer,uint32_t channelNumber,uint32_t peripheralId,IRQn_Type interruptNumber)\n\n{\n  pmc_enable_periph_clk(peripheralId);\n  TC_Configure(timer,channelNumber,0xc002);\n  TC_SetRA(timer,channelNumber,0xa41);\n  *(int *)(((uint)(int)interruptNumber >> 5) * 4 + -0x1fff1f00) = 1 << ((int)interruptNumber & 0x1fU);\n  timer->TC_CHANNEL[channelNumber].TC_IER = 4;\n  TC_Start(timer,channelNumber);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000803fc": "initialize_timer_000803fc",
                "tc": "timer",
                "channel": "channelNumber",
                "id": "peripheralId",
                "irqn": "interruptNumber"
            },
            "calling": [
                "attach"
            ],
            "called": [
                "TC_SetRA",
                "pmc_enable_periph_clk",
                "TC_Configure",
                "TC_Start"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008044c": {
            "entrypoint": "0x0008044c",
            "current_name": "update_servo_state_0008044c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateServoState_0008044c(sequence16_Sequence_t sequence,Tc *timerCounter,uint8_t channelIndex)\n\n{\n  uint timerIndex;\n  uint servoCount;\n  RwReg ticksDiff;\n  int offset;\n  \n  timerIndex = (uint)sequence;\n  if ((channelList[timerIndex] & 0x80U) == 0) {\n    offset = timerIndex * 0xc;\n    if ((channelList[timerIndex] + offset < (int)(uint)totalServoCount) &&\n       ((int)((uint)(byte)servoList[channelList[timerIndex] + offset].Pin << 0x19) < 0)) {\n      digitalWrite((byte)servoList[offset + channelList[timerIndex]].Pin & 0x3f,0);\n    }\n  }\n  else {\n    timerCounter->TC_CHANNEL[channelIndex].TC_CCR = timerCounter->TC_CHANNEL[channelIndex].TC_CCR | 4;\n  }\n  servoCount = (uint)totalServoCount;\n  channelList[timerIndex] = channelList[timerIndex] + '\\x01';\n  offset = timerIndex * 0xc;\n  if ((channelList[timerIndex] + offset < (int)servoCount) && (channelList[timerIndex] < '\\f')) {\n    timerCounter->TC_CHANNEL[channelIndex].TC_RA =\n         timerCounter->TC_CHANNEL[channelIndex].TC_CV + servoList[channelList[timerIndex] + offset].ticks;\n    if (-1 < (int)((uint)(byte)servoList[channelList[timerIndex] + offset].Pin << 0x19)) {\n      return;\n    }\n    digitalWrite((byte)servoList[offset + channelList[timerIndex]].Pin & 0x3f,1);\n    return;\n  }\n  ticksDiff = (SystemCoreClock / 1000000) * 20000 >> 5;\n  if (ticksDiff <= timerCounter->TC_CHANNEL[channelIndex].TC_CV + 4) {\n    ticksDiff = timerCounter->TC_CHANNEL[channelIndex].TC_CV + 4;\n  }\n  timerCounter->TC_CHANNEL[channelIndex].TC_RA = ticksDiff;\n  channelList[timerIndex] = -1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008044c": "update_servo_state_0008044c",
                "timer": "sequence",
                "tc": "timerCounter",
                "channel": "channelIndex",
                "uVar1": "timerIndex",
                "uVar2": "servoCount",
                "RVar3": "ticksDiff",
                "iVar4": "offset",
                "Channel": "channelList",
                "ServoCount": "totalServoCount",
                "servos": "servoList"
            },
            "calling": [
                "TC4_Handler",
                "TC2_Handler",
                "TC0_Handler",
                "TC3_Handler",
                "TC5_Handler"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080558": {
            "entrypoint": "0x00080558",
            "current_name": "FUNC_00080558",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080558(void)\n\n{\n  Servo_Handler(_timer1,(Tc *)0x40084000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080558": "FUNC_00080558"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080568": {
            "entrypoint": "0x00080568",
            "current_name": "initialize_servo_handler_00080568",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServoHandler_00080568(void)\n\n{\n  Servo_Handler(_timer2,(Tc *)0x40084000,'\\x01');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080568": "initialize_servo_handler_00080568"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080578": {
            "entrypoint": "0x00080578",
            "current_name": "initialize_servo_00080578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServo_00080578(void)\n\n{\n  Servo_Handler(timerID,(Tc *)0x40084000,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080578": "initialize_servo_00080578",
                "_timer3": "timerID"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080588": {
            "entrypoint": "0x00080588",
            "current_name": "servo_control_00080588",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid servoControl_00080588(void)\n\n{\n  Servo_Handler(_timer4,(Tc *)0x40080000,'\\x02');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080588": "servo_control_00080588"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080598": {
            "entrypoint": "0x00080598",
            "current_name": "initialize_servo_00080598",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeServo_00080598(void)\n\n{\n  Servo_Handler(servoTimer,(timer *)0x40080000,'\\0');\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080598": "initialize_servo_00080598",
                "Tc": "timer",
                "_timer5": "servoTimer"
            },
            "calling": [],
            "called": [
                "Servo_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805a8": {
            "entrypoint": "0x000805a8",
            "current_name": "initialize_servo_000805a8",
            "code": "\n/* DWARF original prototype: Servo *  Servo(Servo * servo) */\n\nServo * __servocall Servo::initializeServo_000805a8(Servo *servo)\n\n{\n  uint8_t newServoIndex;\n  uint servoCount;\n  \n  servoCount = (uint)totalServos;\n  if (servoCount < 0x3c) {\n    newServoIndex = totalServos + '\\x01';\n    servo->servoIndex = totalServos;\n    totalServos = newServoIndex;\n    servoTicks = (SystemCoreClock / 1000000) * 0x5dc >> 5;\n    return servo;\n  }\n  servo->servoIndex = 0xff;\n  return servo;\n}\n\n",
            "renaming": {
                "this": "servo",
                "uVar1": "newServoIndex",
                "uVar2": "servoCount",
                "ServoCount": "totalServos",
                "servos[uVar2].ticks": "servoTicks",
                "FUN_000805a8": "initialize_servo_000805a8"
            },
            "calling": [
                "_GLOBAL__sub_I_steering"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805e8": {
            "entrypoint": "0x000805e8",
            "current_name": "attach_000805e8",
            "code": "\n/* DWARF original prototype: uint8_t  attach_000805e8(Servo * servo, int servoPin, int minPulseWidth, int maxPulseWidth) */\n\nuint8_t __servocall Servo::attach_000805e8(Servo *servo,int servoPin,int minPulseWidth,int maxPulseWidth)\n\n{\n  ServoPin_t oldPin;\n  timerSequence16_Sequence_t timerSequence;\n  Tc *timerCounter;\n  uint32_t timerChannel;\n  uint32_t interruptId;\n  int counter;\n  uint index;\n  \n  if (0x3b < servo->servoIndex) goto LAB_00080660;\n  servoPinMode(servoPin,1);\n  index = (uint)servo->servoIndex;\n  oldPin = servos[index].Pin;\n  servo->maxPulseWidth = (int8_t)((0x960U - maxPulseWidth) / 4);\n  timerChannel = index / 0xc;\n  servos[index].Pin = (ServoPin_t)((byte)oldPin & 0xc0 | (byte)servoPin & 0x3f);\n  servo->minPulseWidth = (int8_t)((0x220U - minPulseWidth) / 4);\n  counter = 0;\n  do {\n    if ((int)((uint)(byte)servos[counter + timerChannel * 0xc].Pin << 0x19) < 0) goto LAB_00080652;\n    counter = counter + 1;\n  } while (counter != 0xc);\n  if (timerChannel == 0) {\n    timerCounter = (Tc *)0x40084000;\n    interruptId = 0x1e;\nLAB_0008064c:\n    _initISR(timerCounter,timerChannel,interruptId,(IRQn_Type)interruptId);\n  }\n  else {\n    if (timerChannel == 1) {\n      timerCounter = (Tc *)0x40084000;\n      interruptId = 0x1f;\n      goto LAB_0008064c;\n    }\n    if (timerChannel == 2) {\n      timerCounter = (Tc *)0x40084000;\n      interruptId = 0x20;\n      goto LAB_0008064c;\n    }\n    if (timerChannel == 3) {\n      timerCounter = (Tc *)0x40080000;\n      timerChannel = 2;\n      interruptId = 0x1d;\n      goto LAB_0008064c;\n    }\n    if (timerChannel == 4) {\n      timerCounter = (Tc *)0x40080000;\n      timerChannel = 0;\n      interruptId = 0x1b;\n      goto LAB_0008064c;\n    }\n  }\nLAB_00080652:\n  servos[servo->servoIndex].Pin = (ServoPin_t)((byte)servos[servo->servoIndex].Pin | 0x40);\nLAB_00080660:\n  return servo->servoIndex;\n}\n\n",
            "renaming": {
                "FUN_000805e8": "attach_000805e8",
                "this": "servo",
                "pin": "servoPin",
                "min": "minPulseWidth",
                "max": "maxPulseWidth",
                "SVar1": "oldPin",
                "timer": "timerSequence",
                "tc": "timerCounter",
                "channel": "timerChannel",
                "id": "interruptId",
                "iVar2": "counter",
                "uVar3": "index"
            },
            "calling": [
                "attach"
            ],
            "called": [
                "_initISR",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806a0": {
            "entrypoint": "0x000806a0",
            "current_name": "initialize_servo_000806a0",
            "code": "\n/* DWARF original prototype: uint8_t  attach(Servo * servoInstance, int servoPin) */\n\nuint8_t __servoInstancecall Servo::initializeServo_000806a0(Servo *servoInstance,int servoPin)\n\n{\n  uint8_t result;\n  \n  result = attach(servoInstance,servoPin,0x220,0x960);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000806a0": "initialize_servo_000806a0",
                "this": "servoInstance",
                "pin": "servoPin",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "attach"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806ac": {
            "entrypoint": "0x000806ac",
            "current_name": "set_servo_microseconds_000806ac",
            "code": "\n/* DWARF original prototype: void  writeMicroseconds(Servo * servo, int microseconds) */\n\nvoid __servocall Servo::setServoMicroseconds_000806ac(Servo *servo,int microseconds)\n\n{\n  byte *servoChannel;\n  int minDifference;\n  int scaledDifference;\n  \n  if (servo->servoIndex < 0x3c) {\n    minDifference = 0x88 - servo->min;\n    scaledDifference = minDifference * 4;\n    if ((microseconds + minDifference * -4 < 0 == SBORROW4(microseconds,scaledDifference)) &&\n       (scaledDifference = (600 - servo->max) * 4, microseconds <= scaledDifference)) {\n      scaledDifference = microseconds;\n    }\n    servoArray[servo->servoIndex].ticks = (SystemCoreClock / 1000000) * (scaledDifference + -2) >> 5;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000806ac": "set_servo_microseconds_000806ac",
                "this": "servo",
                "value": "microseconds",
                "channel": "servoChannel",
                "iVar1": "minDifference",
                "iVar2": "scaledDifference",
                "servos": "servoArray"
            },
            "calling": [
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806f8": {
            "entrypoint": "0x000806f8",
            "current_name": "write_servo_position_000806f8",
            "code": "\n/* DWARF original prototype: void  write(Servo * servo, int value) */\n\nssize_t __servocall Servo::writeServoPosition_000806f8(Servo *servo,int fileDescriptor,void *buffer,size_t size)\n\n{\n  if (fileDescriptor < 0x220) {\n    if (0xb3 < fileDescriptor) {\n      fileDescriptor = 0xb4;\n    }\n    fileDescriptor = map(fileDescriptor & ~(fileDescriptor >> 0x1f),0,0xb4,(0x88 - servo->min) * 4,(600 - servo->max) * 4);\n  }\n  writeServoMicroseconds(servo,fileDescriptor);\n  return (ssize_t)servo;\n}\n\n",
            "renaming": {
                "this": "servo",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "writeMicroseconds": "writeServoMicroseconds",
                "FUN_000806f8": "write_servo_position_000806f8"
            },
            "calling": [
                "straightAndStop",
                "loop"
            ],
            "called": [
                "writeMicroseconds",
                "map"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008073a": {
            "entrypoint": "0x0008073a",
            "current_name": "FUNC_0008073a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008073a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073a": "FUNC_0008073a"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008073c": {
            "entrypoint": "0x0008073c",
            "current_name": "handle_serial_irq_0008073c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialIrq_0008073c(void)\n\n{\n  UARTClass::IrqHandler(serialDevice);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073c": "handle_serial_irq_0008073c",
                "&Serial": "serialDevice"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080748": {
            "entrypoint": "0x00080748",
            "current_name": "FUNC_00080748",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080748(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080748": "FUNC_00080748"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074a": {
            "entrypoint": "0x0008074a",
            "current_name": "FUNC_0008074a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008074a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074a": "FUNC_0008074a"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074c": {
            "entrypoint": "0x0008074c",
            "current_name": "FUNC_0008074c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008074c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074c": "FUNC_0008074c"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080750": {
            "entrypoint": "0x00080750",
            "current_name": "handle_serial_interrupt_00080750",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialInterrupt_00080750(void)\n\n{\n  UARTClass::IrqHandler(&Serial1.super_UARTClass);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080750": "handle_serial_interrupt_00080750"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008075c": {
            "entrypoint": "0x0008075c",
            "current_name": "handle_serial_irq_0008075c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialIRQ_0008075c(void)\n\n{\n  UARTClass::IrqHandler(serialObject);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008075c": "handle_serial_irq_0008075c",
                "&Serial2.super_UARTClass": "serialObject"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080768": {
            "entrypoint": "0x00080768",
            "current_name": "handle_serial_interrupt_00080768",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialInterrupt_00080768(void)\n\n{\n  UARTClass::IrqHandler(&serialObject);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080768": "handle_serial_interrupt_00080768",
                "Serial3.super_UARTClass": "serialObject"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080774": {
            "entrypoint": "0x00080774",
            "current_name": "initialize_system_00080774",
            "code": "\n\n\nint initializeSystem_00080774(EVP_PKEY_CTX *ctx)\n\n{\n  int iVar1;\n  uint32_t pinNumber;\n  uint32_t nextPinNumber;\n  \n  SystemInit();\n  _DAT_e000e014 = SystemCoreClock / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  __libc_init_array();\n  pinNumber = 0;\n  do {\n    nextPinNumber = pinNumber + 1;\n    digitalWrite(pinNumber,0);\n    pinNumber = nextPinNumber;\n  } while (nextPinNumber != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  PIO_Configure(&DAT_400e0e00,1,0x300,0);\n  digitalWrite(0,1);\n  PIO_Configure(&DAT_400e0e00,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,0x3000,0);\n  PIO_Configure(&DAT_400e1400,2,0x30,0);\n  PIO_Configure(&DAT_400e1000,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,3,0);\n  PIO_Configure(&DAT_400e1000,1,0xc000,0);\n  pmc_enable_periph_clk(0x25);\n  adc_init(0x400c0000,SystemCoreClock,20000000,0xc);\n  adc_configure_timing(0x400c0000,0,0x300000,1);\n  adc_configure_trigger(0x400c0000,0,0);\n  adc_disable_interrupt(0x400c0000,0xffffffff);\n  iVar1 = adc_disable_all_channel(0x400c0000);\n  analogOutputInit();\n  return iVar1;\n}\n\n",
            "renaming": {
                "FUN_00080774": "initialize_system_00080774",
                "ulPin": "pinNumber",
                "uVar2": "nextPinNumber"
            },
            "calling": [
                "main"
            ],
            "called": [
                "adc_disable_all_channel",
                "SystemInit",
                "pmc_enable_periph_clk",
                "digitalWrite",
                "adc_configure_trigger",
                "adc_disable_interrupt",
                "analogOutputInit",
                "__libc_init_array",
                "adc_configure_timing",
                "adc_init",
                "PIO_Configure"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008089c": {
            "entrypoint": "0x0008089c",
            "current_name": "initialize_serial_communication_0008089c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_0008089c(void)\n\n{\n  RingBuffer::RingBuffer(rxBuffer1);\n  RingBuffer::RingBuffer(txBuffer1);\n  UARTClass::UARTClass(serial,(uart *)0x400e0800,interruptNumber,8,rxBuffer1,txBuffer1);\n  RingBuffer::RingBuffer(rxBuffer2);\n  RingBuffer::RingBuffer(rxBuffer3);\n  RingBuffer::RingBuffer(rxBuffer4);\n  RingBuffer::RingBuffer(txBuffer2);\n  RingBuffer::RingBuffer(txBuffer3);\n  RingBuffer::RingBuffer(txBuffer4);\n  USARTClass::USARTClass(serial1,(usart *)0x40098000,interruptNumber1,0x11,rxBuffer2,txBuffer2);\n  USARTClass::USARTClass(serial2,(usart *)0x4009c000,interruptNumber2,0x12,rxBuffer3,txBuffer3);\n  USARTClass::USARTClass(serial3,(usart *)0x400a4000,interruptNumber3,0x14,rxBuffer4,txBuffer4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008089c": "initialize_serial_communication_0008089c",
                "&Serial": "serial",
                "Uart": "uart",
                "UART_IRQn": "interruptNumber",
                "&rx_buffer1": "rxBuffer1",
                "&tx_buffer1": "txBuffer1",
                "&rx_buffer2": "rxBuffer2",
                "&tx_buffer2": "txBuffer2",
                "&rx_buffer3": "rxBuffer3",
                "&tx_buffer3": "txBuffer3",
                "&rx_buffer4": "rxBuffer4",
                "&tx_buffer4": "txBuffer4",
                "&Serial1": "serial1",
                "Usart": "usart",
                "USART0_IRQn": "interruptNumber1",
                "&Serial2": "serial2",
                "USART1_IRQn": "interruptNumber2",
                "&Serial3": "serial3",
                "USART3_IRQn": "interruptNumber3"
            },
            "calling": [],
            "called": [
                "UARTClass",
                "USARTClass",
                "RingBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080970": {
            "entrypoint": "0x00080970",
            "current_name": "process_serial_events_00080970",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processSerialEvents_00080970(void)\n\n{\n  int availableBytes;\n  \n  availableBytes = UARTClass::available(&Serial);\n  if (availableBytes != 0) {\n    serialEvent();\n  }\n  availableBytes = UARTClass::available(&Serial1);\n  if (availableBytes != 0) {\n    serialEvent1();\n  }\n  availableBytes = UARTClass::available(&Serial2);\n  if (availableBytes != 0) {\n    serialEvent2();\n  }\n  availableBytes = UARTClass::available(&Serial3);\n  if (availableBytes != 0) {\n    serialEvent3();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080970": "process_serial_events_00080970",
                "iVar1": "availableBytes",
                "&Serial1.super_UARTClass": "&Serial1",
                "&Serial2.super_UARTClass": "&Serial2",
                "&Serial3.super_UARTClass": "&Serial3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "serialEvent",
                "serialEvent1",
                "serialEvent2",
                "available",
                "serialEvent3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809b4": {
            "entrypoint": "0x000809b4",
            "current_name": "set_memory_value_000809b4",
            "code": "\nvoid setMemoryValue_000809b4(int baseAddress,undefined4 value,int isOffset)\n\n{\n  if (isOffset != 0) {\n    *(undefined4 *)(baseAddress + 100) = value;\n    return;\n  }\n  *(undefined4 *)(baseAddress + 0x60) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809b4": "set_memory_value_000809b4",
                "param_1": "baseAddress",
                "param_2": "value",
                "param_3": "isOffset"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809be": {
            "entrypoint": "0x000809be",
            "current_name": "update_parameter_000809be",
            "code": "\nvoid updateParameter_000809be(int baseAddress,undefined4 option,uint newValue)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(baseAddress + 0x44) = newValue;\n  switch(option) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(baseAddress + 0x70) & *(uint *)(baseAddress + 0x70) & ~newValue;\n    break;\n  case 2:\n    updatedValue = *(uint *)(baseAddress + 0x70) | newValue;\n    break;\n  default:\n    goto switchD_000809c4_caseD_6;\n  }\n  *(uint *)(baseAddress + 0x70) = updatedValue;\nswitchD_000809c4_caseD_6:\n  *(uint *)(baseAddress + 4) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809be": "update_parameter_000809be",
                "param_1": "baseAddress",
                "param_2": "option",
                "param_3": "newValue",
                "uVar1": "updatedValue"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809e4": {
            "entrypoint": "0x000809e4",
            "current_name": "set_values_based_on_flag_000809e4",
            "code": "\nvoid setValuesBasedOnFlag_000809e4(undefined4 *outputArray,undefined4 newValue,uint flag)\n\n{\n  bool isNegativeFlag;\n  \n  isNegativeFlag = (int)(flag << 0x1f) < 0;\n  outputArray[17] = newValue;\n  if (isNegativeFlag) {\n    outputArray[25] = newValue;\n  }\n  if (!isNegativeFlag) {\n    outputArray[24] = newValue;\n  }\n  isNegativeFlag = (flag & 10) != 0;\n  if (isNegativeFlag) {\n    outputArray[8] = newValue;\n  }\n  if (!isNegativeFlag) {\n    outputArray[9] = newValue;\n  }\n  if (((int)(flag << 0x1e) < 0) || ((int)(flag << 0x1c) < 0)) {\n    outputArray[32] = newValue;\n  }\n  outputArray[5] = newValue;\n  *outputArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809e4": "set_values_based_on_flag_000809e4",
                "param_1": "outputArray",
                "param_2": "newValue",
                "param_3": "flag",
                "bVar1": "isNegativeFlag",
                "param_1[0x11]": "outputArray[17]",
                "param_1[0x19]": "outputArray[25]",
                "param_1[0x18]": "outputArray[24]",
                "param_1[8]": "outputArray[8]",
                "param_1[9]": "outputArray[9]",
                "param_1[0x20]": "outputArray[32]",
                "param_1[5]": "outputArray[5]"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a0a": {
            "entrypoint": "0x00080a0a",
            "current_name": "update_paramsand_set_pointer_00080a0a",
            "code": "\nvoid updateParamsandSetPointer_00080a0a(undefined4 *ptrParams,undefined4 newValue,int isParam3Zero,int isParam4Zero,int isParam5Zero)\n\n{\n  ptrParams[17] = newValue;\n  if (isParam5Zero == 0) {\n    ptrParams[24] = newValue;\n  }\n  else {\n    ptrParams[25] = newValue;\n  }\n  if (isParam4Zero == 0) {\n    ptrParams[21] = newValue;\n  }\n  else {\n    ptrParams[20] = newValue;\n  }\n  if (isParam3Zero == 0) {\n    ptrParams[13] = newValue;\n  }\n  else {\n    ptrParams[12] = newValue;\n  }\n  ptrParams[4] = newValue;\n  *ptrParams = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a0a": "update_paramsand_set_pointer_00080a0a",
                "param_1": "ptrParams",
                "param_2": "newValue",
                "param_3": "isParam3Zero",
                "param_4": "isParam4Zero",
                "param_5": "isParam5Zero",
                "param_1[0x11]": "ptrParams[17]",
                "param_1[0x18]": "ptrParams[24]",
                "param_1[0x19]": "ptrParams[25]",
                "param_1[0x15]": "ptrParams[21]",
                "param_1[0x14]": "ptrParams[20]",
                "param_1[0xd]": "ptrParams[13]",
                "param_1[0xc]": "ptrParams[12]",
                "param_1[4]": "ptrParams[4]"
            },
            "calling": [
                "digitalWrite",
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a30": {
            "entrypoint": "0x00080a30",
            "current_name": "configure_peripheral_00080a30",
            "code": "\nundefined4 configurePeripheral_00080a30(int deviceAddress,int peripheralType,undefined4 peripheralConfig,uint peripheralSettings)\n\n{\n  bool isNegative;\n  \n  switch(peripheralType) {\n  case 1:\n  case 2:\n    setPeripheral(deviceAddress,peripheralType,peripheralConfig);\n    isNegative = (int)(peripheralSettings << 0x1f) < 0;\n    *(undefined4 *)(deviceAddress + 0x44) = peripheralConfig;\n    if (isNegative) {\n      *(undefined4 *)(deviceAddress + 100) = peripheralConfig;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(deviceAddress + 0x60) = peripheralConfig;\n    }\n    break;\n  case 3:\n    setInput(deviceAddress,peripheralConfig,peripheralSettings,0x809e5,deviceAddress);\n    break;\n  case 4:\n  case 5:\n    setOutput(deviceAddress,peripheralConfig,peripheralType == 5,(peripheralSettings << 0x1d) >> 0x1f,peripheralSettings & 1,peripheralType,peripheralConfig\n                 );\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080a30": "configure_peripheral_00080a30",
                "param_1": "deviceAddress",
                "param_2": "peripheralType",
                "param_3": "peripheralConfig",
                "param_4": "peripheralSettings",
                "bVar1": "isNegative",
                "PIO_SetPeripheral": "setPeripheral",
                "PIO_SetInput": "setInput",
                "PIO_SetOutput": "setOutput"
            },
            "calling": [
                "init",
                "pinMode"
            ],
            "called": [
                "PIO_SetInput",
                "PIO_SetOutput",
                "PIO_SetPeripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a94": {
            "entrypoint": "0x00080a94",
            "current_name": "check_conditions_00080a94",
            "code": "\nuint check_conditions_00080a94(int input_param,uint flag)\n\n{\n  uint result;\n  \n  result = *(uint *)(input_param + 8) & flag;\n  if (result != 0) {\n    if ((flag & *(uint *)(input_param + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080a94": "check_conditions_00080a94",
                "param_1": "input_param",
                "param_2": "flag",
                "uVar1": "result"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "check_and_set_bit_00080aa8",
            "code": "\n\n\nundefined4 checkAndSetBit_00080aa8(uint input)\n\n{\n  uint bitMask;\n  \n  if (input < 0x2d) {\n    if (input < 0x20) {\n      bitMask = 1 << (input & 0xff);\n      if ((bitMask & _DAT_400e0618) != bitMask) {\n        _DAT_400e0610 = bitMask;\n      }\n    }\n    else {\n      bitMask = 1 << (input - 0x20 & 0xff);\n      if ((bitMask & _DAT_400e0708) != bitMask) {\n        _DAT_400e0700 = bitMask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "check_and_set_bit_00080aa8",
                "param_1": "input",
                "uVar1": "bitMask"
            },
            "calling": [
                "init",
                "_initISR",
                "init",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aec": {
            "entrypoint": "0x00080aec",
            "current_name": "check_and_clear_bit_00080aec",
            "code": "\n\n\nundefined4 check_and_clear_bit_00080aec(uint bit_position)\n\n{\n  uint bit_mask;\n  uint bit_result;\n  \n  if (bit_position < 0x2d) {\n    if (bit_position < 0x20) {\n      bit_mask = 1 << (bit_position & 0xff);\n      bit_result = _DAT_400e0618 & bit_mask;\n      if (bit_result == bit_mask) {\n        _DAT_400e0614 = bit_result;\n      }\n    }\n    else {\n      bit_mask = 1 << (bit_position - 0x20 & 0xff);\n      bit_result = _DAT_400e0708 & bit_mask;\n      if (bit_result == bit_mask) {\n        _DAT_400e0704 = bit_result;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aec": "check_and_clear_bit_00080aec",
                "param_1": "bit_position",
                "uVar1": "bit_mask",
                "uVar2": "bit_result"
            },
            "calling": [
                "pinMode",
                "end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b2c": {
            "entrypoint": "0x00080b2c",
            "current_name": "configure_tc_00080b2c",
            "code": "\nvoid configureTC_00080b2c(undefined4 param1,uint param2,char *param3)\n\n{\n  int tempVar1;\n  int tempVar2;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(param2,param1);\n  if (2 < param2) {\n    param3 = \"TC_Configure\";\n    combinedParams = __assert_func(\"../source/tc.c\",0x40,\"TC_Configure\",\n                          \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  tempVar1 = (int)((ulonglong)combinedParams >> 0x20) * 0x40;\n  tempVar2 = (int)combinedParams + tempVar1;\n  *(undefined4 *)((int)combinedParams + tempVar1) = 2;\n  *(undefined4 *)(tempVar2 + 0x28) = 0xffffffff;\n  *(char **)(tempVar2 + 4) = param3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b2c": "configure_tc_00080b2c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "combinedParams"
            },
            "calling": [
                "_initISR"
            ],
            "called": [
                "__assert_func"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b64": {
            "entrypoint": "0x00080b64",
            "current_name": "set_channel_value_00080b64",
            "code": "\nvoid setChannelValue_00080b64(undefined4 value,uint channelIndex)\n\n{\n  undefined8 combinedValue;\n  \n  combinedValue = CONCAT44(channelIndex,value);\n  if (2 < channelIndex) {\n    combinedValue = __assert_func(\"../source/tc.c\",0x5c,\"TC_Start\",\n                          \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  *(undefined4 *)((int)combinedValue + (int)((ulonglong)combinedValue >> 0x20) * 0x40) = 5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b64": "set_channel_value_00080b64",
                "param_1": "value",
                "param_2": "channelIndex",
                "uVar1": "combinedValue"
            },
            "calling": [
                "_initISR"
            ],
            "called": [
                "__assert_func"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b90": {
            "entrypoint": "0x00080b90",
            "current_name": "set_value_at_index_00080b90",
            "code": "\nvoid set_value_at_index_00080b90(int array_base,int index,undefined4 value)\n\n{\n  *(undefined4 *)(array_base + index * 0x40 + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b90": "set_value_at_index_00080b90",
                "param_1": "array_base",
                "param_2": "index",
                "param_3": "value"
            },
            "calling": [
                "_initISR"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b98": {
            "entrypoint": "0x00080b98",
            "current_name": "initialize_system_00080b98",
            "code": "\n\n\nvoid initializeSystem_00080b98(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  clockFrequency = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b98": "initialize_system_00080b98",
                "SystemCoreClock": "clockFrequency"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c20": {
            "entrypoint": "0x00080c20",
            "current_name": "copy_to_completed_and_clear_00080c20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080c6a) */\n\n\nvoid copyToCompletedAndClear_00080c20(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  \n  for (index = 0; source + index < destination; index = index + 4) {\n    *(undefined4 *)(source + index) = *(undefined4 *)(sourceEnd + index);\n  }\n  for (ptr = destination; ptr < targetEnd; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  runMain();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080c20": "copy_to_completed_and_clear_00080c20",
                "iVar1": "index",
                "puVar2": "ptr",
                "banzai": "source",
                "&completed_7857": "destination",
                "&_etext": "sourceEnd",
                "&_ebss": "targetEnd",
                "main": "runMain"
            },
            "calling": [],
            "called": [
                "banzai",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c98": {
            "entrypoint": "0x00080c98",
            "current_name": "calculate_index_00080c98",
            "code": "\nundefined4 calculateIndex_00080c98(undefined4 *outputArray,uint inputValue,int divisor,int multiplier)\n\n{\n  uint quotient;\n  uint index;\n  uint thresholdArray [16];\n  \n  thresholdArray[0] = 0;\n  thresholdArray[1] = 8;\n  thresholdArray[2] = 0x10;\n  thresholdArray[3] = 0x18;\n  thresholdArray[4] = 0x40;\n  thresholdArray[5] = 0x50;\n  thresholdArray[6] = 0x60;\n  thresholdArray[7] = 0x70;\n  thresholdArray[8] = 0x200;\n  thresholdArray[9] = 0x240;\n  thresholdArray[10] = 0x280;\n  thresholdArray[11] = 0x2c0;\n  thresholdArray[12] = 0x300;\n  thresholdArray[13] = 0x340;\n  thresholdArray[14] = 0x380;\n  thresholdArray[15] = 0x3c0;\n  *outputArray = 1;\n  outputArray[1] = 0;\n  outputArray[0x48] = 0x202;\n  outputArray[0x41] = 0;\n  outputArray[0x45] = 0;\n  quotient = inputValue / (uint)(divisor * 2);\n  if (inputValue == divisor * 2 * quotient) {\n    quotient = quotient - 1;\n  }\n  index = 0;\n  do {\n    if ((uint)(multiplier * (int)(((ulonglong)inputValue / (ulonglong)((quotient + 1) * 2)) / 1000000)) <=\n        thresholdArray[index]) {\n      outputArray[1] = (index & 0xf) << 0x10 | (quotient & 0xff) << 8 | outputArray[1];\n      return 0;\n    }\n    index = index + 1;\n  } while (index != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080c98": "calculate_index_00080c98",
                "param_1": "outputArray",
                "param_2": "inputValue",
                "param_3": "divisor",
                "param_4": "multiplier",
                "local_58": "thresholdArray",
                "uVar1": "quotient",
                "uVar2": "index"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d30": {
            "entrypoint": "0x00080d30",
            "current_name": "update_parameter_00080d30",
            "code": "\nvoid updateParameter_00080d30(int originalAddress,uint newValue,uint bitValue)\n\n{\n  *(uint *)(originalAddress + 4) = newValue | *(uint *)(originalAddress + 4) | (bitValue & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d30": "update_parameter_00080d30",
                "param_1": "originalAddress",
                "param_2": "newValue",
                "param_3": "bitValue"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d3e": {
            "entrypoint": "0x00080d3e",
            "current_name": "set_combined_flags_00080d3e",
            "code": "\nvoid setCombinedFlags_00080d3e(int dataPtr,uint flagInput,uint currentFlags,uint additionalFlags)\n\n{\n  *(uint *)(dataPtr + 4) =\n       currentFlags | *(uint *)(dataPtr + 4) | (flagInput & 0xf) << 0x18 | (additionalFlags & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d3e": "set_combined_flags_00080d3e",
                "param_1": "dataPtr",
                "param_2": "flagInput",
                "param_3": "currentFlags",
                "param_4": "additionalFlags"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d58": {
            "entrypoint": "0x00080d58",
            "current_name": "set_bit_00080d58",
            "code": "\nvoid setBit_00080d58(int baseAddress,uint bitPosition)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d58": "set_bit_00080d58",
                "param_1": "baseAddress",
                "param_2": "bitPosition"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d62": {
            "entrypoint": "0x00080d62",
            "current_name": "initialize_value_00080d62",
            "code": "\nvoid initializeValue_00080d62(int address)\n\n{\n  *(undefined4 *)(address + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d62": "initialize_value_00080d62",
                "param_1": "address"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d6a": {
            "entrypoint": "0x00080d6a",
            "current_name": "set_param_value_00080d6a",
            "code": "\nvoid setParamValue_00080d6a(int objPtr,undefined4 newValue)\n\n{\n  *(undefined4 *)(objPtr + 0x28) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d6a": "set_param_value_00080d6a",
                "param_1": "objPtr",
                "param_2": "newValue"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d70": {
            "entrypoint": "0x00080d70",
            "current_name": "execute_isr_00080d70",
            "code": "\nvoid execute_isr_00080d70(void)\n\n{\n  if (isr_function != (function_pointer *)0x0) {\n    (*isr_function)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d70": "execute_isr_00080d70",
                "gpf_isr": "isr_function",
                "code": "function_pointer"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d80": {
            "entrypoint": "0x00080d80",
            "current_name": "process_interrupts_00080d80",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_00080d80(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t interruptStatus;\n  uint leadingZerosCount;\n  \n  for (interruptStatus = _DAT_400e0e4c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << leadingZerosCount)) {\n    leadingZerosCount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (interruptCallbacksPioA[leadingZerosCount] != (interruptCB)0x0) {\n      (*interruptCallbacksPioA[leadingZerosCount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d80": "process_interrupts_00080d80",
                "isr": "interruptStatus",
                "uVar1": "leadingZerosCount",
                "callbacksPioA": "interruptCallbacksPioA"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080db8": {
            "entrypoint": "0x00080db8",
            "current_name": "process_pending_interrupts_00080db8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processPendingInterrupts_00080db8(void)\n\n{\n  uint8_t numLeadingZeros;\n  uint32_t interruptStatus;\n  uint shiftAmount;\n  \n  for (interruptStatus = _DAT_400e104c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << shiftAmount)) {\n    shiftAmount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (callbacksPioB[shiftAmount] != (interruptCB)0x0) {\n      (*callbacksPioB[shiftAmount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080db8": "process_pending_interrupts_00080db8",
                "leading_zeros": "numLeadingZeros",
                "isr": "interruptStatus",
                "uVar1": "shiftAmount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080df0": {
            "entrypoint": "0x00080df0",
            "current_name": "execute_interrupt_callbacks_00080df0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid executeInterruptCallbacks_00080df0(void)\n\n{\n  uint8_t leadingZeros;\n  uint32_t interruptStatusRegister;\n  uint remainingBits;\n  \n  for (interruptStatusRegister = _DAT_400e124c; (uint)LZCOUNT(interruptStatusRegister) < 0x20; interruptStatusRegister = interruptStatusRegister & ~(1 << remainingBits)) {\n    remainingBits = 0x1fU - LZCOUNT(interruptStatusRegister) & 0xff;\n    if (callbacksPioC[remainingBits] != (interruptCB)0x0) {\n      (*callbacksPioC[remainingBits])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080df0": "execute_interrupt_callbacks_00080df0",
                "isr": "interruptStatusRegister",
                "leading_zeros": "leadingZeros",
                "uVar1": "remainingBits"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e28": {
            "entrypoint": "0x00080e28",
            "current_name": "process_interrupts_00080e28",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_00080e28(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t interruptStatusRegister;\n  uint leadingZerosCount;\n  \n  for (interruptStatusRegister = _DAT_400e144c; (uint)LZCOUNT(interruptStatusRegister) < 0x20; interruptStatusRegister = interruptStatusRegister & ~(1 << leadingZerosCount)) {\n    leadingZerosCount = 0x1fU - LZCOUNT(interruptStatusRegister) & 0xff;\n    if (pioDInterruptCallbacks[leadingZerosCount] != (interruptCB)0x0) {\n      (*pioDInterruptCallbacks[leadingZerosCount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080e28": "process_interrupts_00080e28",
                "isr": "interruptStatusRegister",
                "uVar1": "leadingZerosCount",
                "callbacksPioD": "pioDInterruptCallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e60": {
            "entrypoint": "0x00080e60",
            "current_name": "run_infinite_loop_00080e60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid run_infinite_loop_00080e60(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080e60": "run_infinite_loop_00080e60"
            },
            "calling": [
                "__halt"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e62": {
            "entrypoint": "0x00080e62",
            "current_name": "infinite_loop_00080e62",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00080e62(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080e62": "infinite_loop_00080e62"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e66": {
            "entrypoint": "0x00080e66",
            "current_name": "infinite_loop_00080e66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00080e66(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080e66": "infinite_loop_00080e66"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e6a": {
            "entrypoint": "0x00080e6a",
            "current_name": "reset_tick_and_increment_time_00080e6a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetTickAndIncrementTime_00080e6a(void)\n\n{\n  int isFalse;\n  \n  isFalse = __false();\n  if (isFalse == 0) {\n    resetTick();\n    incrementTimeTick();\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080e6a": "reset_tick_and_increment_time_00080e6a",
                "iVar1": "isFalse",
                "tickReset": "resetTick",
                "TimeTick_Increment": "incrementTimeTick"
            },
            "calling": [],
            "called": [
                "tickReset",
                "TimeTick_Increment",
                "__false"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e80": {
            "entrypoint": "0x00080e80",
            "current_name": "determine_if_binary_is_empty_00080e80",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint determineIfBinaryIsEmpty_00080e80(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080e80": "determine_if_binary_is_empty_00080e80"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e84": {
            "entrypoint": "0x00080e84",
            "current_name": "idle_loop_00080e84",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid idleLoop_00080e84(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080e84": "idle_loop_00080e84"
            },
            "calling": [
                "PendSV_Handler",
                "__halt",
                "SVC_Handler"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e88": {
            "entrypoint": "0x00080e88",
            "current_name": "allocate_memory_00080e88",
            "code": "\nvoid * allocateMemory_00080e88(intptr_t memorySize)\n\n{\n  uchar *previousAllocation;\n  uchar *previousHeap;\n  \n  if (currentHeap == (uchar *)0x0) {\n    currentHeap = &endOfBSS;\n  }\n  previousAllocation = currentHeap;\n  currentHeap = currentHeap + memorySize;\n  return previousAllocation;\n}\n\n",
            "renaming": {
                "FUN_00080e88": "allocate_memory_00080e88",
                "__delta": "memorySize",
                "puVar1": "previousAllocation",
                "prev_heap": "previousHeap",
                "_sbrk::heap": "currentHeap",
                "_ebss": "endOfBSS"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ea4": {
            "entrypoint": "0x00080ea4",
            "current_name": "copy_string_00080ea4",
            "code": "\nint copy_string_00080ea4(char *source_string,char *destination_string)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00080ea4": "copy_string_00080ea4",
                "__from": "source_string",
                "__to": "destination_string"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eaa": {
            "entrypoint": "0x00080eaa",
            "current_name": "check_file_status_00080eaa",
            "code": "\nint checkFileStatus_00080eaa(int fileDescriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00080eaa": "check_file_status_00080eaa",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eb0": {
            "entrypoint": "0x00080eb0",
            "current_name": "set_file_type_to_regular_00080eb0",
            "code": "\nint setFileTypeToRegular_00080eb0(int fileDescriptor,stat *fileInfo)\n\n{\n  *(undefined4 *)((int)&fileInfo->deviceID + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080eb0": "set_file_type_to_regular_00080eb0",
                "__fd": "fileDescriptor",
                "__buf": "fileInfo",
                "st_dev": "deviceID"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eba": {
            "entrypoint": "0x00080eba",
            "current_name": "check_file_descriptor_00080eba",
            "code": "\nint check_file_descriptor_00080eba(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080eba": "check_file_descriptor_00080eba",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ebe": {
            "entrypoint": "0x00080ebe",
            "current_name": "get_file_offset_00080ebe",
            "code": "\n__off_t getFileOffset_00080ebe(int fileDescriptor,__off_t offset,int origin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ebe": "get_file_offset_00080ebe",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "origin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec2": {
            "entrypoint": "0x00080ec2",
            "current_name": "process_data_00080ec2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_data_00080ec2(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ec2": "process_data_00080ec2",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "data_pointer",
                "len_UNUSED": "data_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec8": {
            "entrypoint": "0x00080ec8",
            "current_name": "copy_bytes_to_file_00080ec8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nint copyBytesToFile_00080ec8(int fileDescriptor,char *buffer,int bufferSize)\n\n{\n  int index;\n  \n  for (index = 0; index < bufferSize; index = index + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)(byte)buffer[index];\n  }\n  return bufferSize & ~(bufferSize >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_00080ec8": "copy_bytes_to_file_00080ec8",
                "file_UNUSED": "fileDescriptor",
                "ptr": "buffer",
                "len": "bufferSize",
                "iVar1": "index"
            },
            "calling": [
                "_write_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eec": {
            "entrypoint": "0x00080eec",
            "current_name": "print_exit_status_00080eec",
            "code": "\nvoid printExitStatus_00080eec(int exitStatus)\n\n{\n  iprintf(\"Exiting with status %d.\\n\",exitStatus);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080eec": "print_exit_status_00080eec",
                "__status": "exitStatus"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080efc": {
            "entrypoint": "0x00080efc",
            "current_name": "FUNC_00080efc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080efc(int pid_UNUSED,int sig_UNUSED)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080efc": "FUNC_00080efc"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080efe": {
            "entrypoint": "0x00080efe",
            "current_name": "get_process_id_00080efe",
            "code": "\n\n\n__pid_t get_process_id_00080efe(void)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00080efe": "get_process_id_00080efe"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f04": {
            "entrypoint": "0x00080f04",
            "current_name": "get_tick_count_00080f04",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickCount_00080f04(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_00080f04": "get_tick_count_00080f04",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "timedRead"
            ],
            "called": [
                "GetTickCount"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f08": {
            "entrypoint": "0x00080f08",
            "current_name": "FUNC_00080f08",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080f08(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f08": "FUNC_00080f08"
            },
            "calling": [
                "loop",
                "setup",
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0a": {
            "entrypoint": "0x00080f0a",
            "current_name": "FUNC_00080f0a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080f0a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f0a": "FUNC_00080f0a"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0c": {
            "entrypoint": "0x00080f0c",
            "current_name": "configure_pin_00080f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_00080f0c(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  undefined4 value;\n  byte lowerNibble;\n  byte pinStatus;\n  Pio *pinPort;\n  \n  if (g_APinDescription[pinNumber].pinNumberType != PIO_NOT_A_PIN) {\n    if ((g_pinStatus[pinNumber] & 0xf) == 4) {\n      adc_disable_channel(0x400c0000,g_APinDescription[pinNumber].ulADCChannelNumber);\n    }\n    pinStatus = g_pinStatus[pinNumber];\n    lowerNibble = pinStatus & 0xf;\n    if ((lowerNibble < 3) && (pinStatus != 0)) {\n      if (lowerNibble == 2) {\n        if (pinMode == 0) {\n          return;\n        }\n      }\n      else if (lowerNibble == 1) {\n        if (pinMode == 2) {\n          return;\n        }\n      }\n      else if (lowerNibble == 3) {\n        if (pinMode == 1) {\n          return;\n        }\n        goto LAB_00080f68;\n      }\n    }\n    if (pinMode != 1) {\nLAB_00080f68:\n      if (pinMode == 0) {\n        pmc_enable_periph_clk(g_APinDescription[pinNumber].ulPeripheralId);\n        PIO_Configure(g_APinDescription[pinNumber].pPort,3,g_APinDescription[pinNumber].pinNumber,0);\n        pinStatus = g_pinStatus[pinNumber] & 0xf0 | 2;\n      }\n      else {\n        if (pinMode != 2) {\n          return;\n        }\n        pmc_enable_periph_clk(g_APinDescription[pinNumber].ulPeripheralId);\n        PIO_Configure(g_APinDescription[pinNumber].pPort,3,g_APinDescription[pinNumber].pinNumber,1);\n        pinStatus = g_pinStatus[pinNumber] & 0xf0 | 1;\n      }\n      g_pinStatus[pinNumber] = pinStatus;\n      return;\n    }\n    pinPort = g_APinDescription[pinNumber].pPort;\n    if (pinStatus >> 4 == 0) {\n      value = 4;\n    }\n    else {\n      value = 5;\n    }\n    PIO_Configure(pinPort,value,g_APinDescription[pinNumber].pinNumber,\n                  g_APinDescription[pinNumber].pinNumberConfiguration);\n    g_pinStatus[pinNumber] = g_pinStatus[pinNumber] & 0xf0 | 3;\n    if (pinPort->PIO_OSR == 0xffffffff) {\n      pmc_disable_periph_clk(g_APinDescription[pinNumber].ulPeripheralId);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f0c": "configure_pin_00080f0c",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "uVar1": "value",
                "bVar2": "lowerNibble",
                "bVar3": "pinStatus",
                "pPVar4": "pinPort"
            },
            "calling": [
                "digitalWrite",
                "setup",
                "attach"
            ],
            "called": [
                "pmc_enable_periph_clk",
                "pmc_disable_periph_clk",
                "adc_disable_channel",
                "PIO_Configure"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081014": {
            "entrypoint": "0x00081014",
            "current_name": "update_pin_status_00081014",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinStatus_00081014(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  int status;\n  uint32_t pin;\n  Pio *port;\n  uint32_t newValue;\n  \n  if (g_APinDescription[pinNumber].pinNumberType != PIO_NOT_A_PIN) {\n    newValue = pinValue;\n    if ((g_pinStatus[pinNumber] & 0xf) == 5) {\n      pinMode(pinNumber,1);\n    }\n    g_pinStatus[pinNumber] = g_pinStatus[pinNumber] & 0xf | (byte)(pinValue << 4);\n    port = g_APinDescription[pinNumber].pPort;\n    pin = g_APinDescription[pinNumber].pinNumber;\n    status = PIO_GetOutputDataStatus(port,pin);\n    if (status == 0) {\n      PIO_PullUp(port,pin,pinValue);\n      return;\n    }\n    PIO_SetOutput(port,pin,pinValue,0,1,newValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081014": "update_pin_status_00081014",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "iVar1": "status",
                "uVar2": "pin",
                "uVar4": "newValue",
                "pPVar3": "port"
            },
            "calling": [
                "init",
                "loop",
                "Servo_Handler"
            ],
            "called": [
                "PIO_GetOutputDataStatus",
                "PIO_SetOutput",
                "pinMode",
                "PIO_PullUp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081084": {
            "entrypoint": "0x00081084",
            "current_name": "print_and_count_00081084",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0008109a */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t __thiscall Print::printAndCount_00081084(Print *this,int __fd,void *buffer,size_t size)\n\n{\n  Print *printPointer;\n  void *bufferPointer;\n  \n  bufferPointer = (void *)0x0;\n  printPointer = this;\n  while ((bufferPointer != buffer &&\n         (printPointer = (Print *)(**this->vtable_Print)(printPointer,(uint)*(byte *)(__fd + (int)bufferPointer)),\n         printPointer != (Print *)0x0))) {\n    bufferPointer = (void *)((int)bufferPointer + 1);\n  }\n  return (ssize_t)bufferPointer;\n}\n\n",
            "renaming": {
                "FUN_00081084": "print_and_count_00081084",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "printPointer",
                "pvVar2": "bufferPointer",
                "_vptr_Print": "vtable_Print"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810a6": {
            "entrypoint": "0x000810a6",
            "current_name": "write_to_file_000810a6",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x000810be */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, char * str) */\n\nssize_t __thiscall Print::writeToFile_000810a6(Print *this,int fileDescriptor,void *buffer,size_t size)\n\n{\n  size_t stringLength;\n  int returnValue;\n  \n  if (fileDescriptor != 0) {\n    stringLength = strlen((char *)fileDescriptor);\n    returnValue = (*this->_vptr_Print[1])(stringLength,fileDescriptor,stringLength,this->_vptr_Print[1],size);\n    return returnValue;\n  }\n  return fileDescriptor;\n}\n\n",
            "renaming": {
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__n": "size",
                "sVar1": "stringLength",
                "iVar2": "returnValue",
                "FUN_000810a6": "write_to_file_000810a6"
            },
            "calling": [
                "println",
                "println",
                "print",
                "printNumber"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810c4": {
            "entrypoint": "0x000810c4",
            "current_name": "print_000810c4",
            "code": "\n/* DWARF original prototype: size_t  print_000810c4(Print * print_000810c4er, char * string) */\n\nsize_t __print_000810c4ercall Print::print_000810c4(Print *print_000810c4er,char *string)\n\n{\n  size_t result;\n  void *param1;\n  size_t param2;\n  \n  result = write(print_000810c4er,(int)string,param1,param2);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000810c4": "print_000810c4",
                "this": "printer",
                "str": "string",
                "sVar1": "result",
                "in_r2": "param1",
                "in_r3": "param2"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810cc": {
            "entrypoint": "0x000810cc",
            "current_name": "print_character_000810cc",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x000810d2 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, char c) */\n\nsize_t __thiscall Print::printCharacter_000810cc(Print *this,char c)\n\n{\n  size_t returnValue;\n  \n  returnValue = (**this->_vptr_Print)(this,(int)c);\n  return returnValue;\n}\n\n",
            "renaming": {
                "sVar1": "returnValue",
                "FUN_000810cc": "print_character_000810cc"
            },
            "calling": [
                "print"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810d8": {
            "entrypoint": "0x000810d8",
            "current_name": "print_data_000810d8",
            "code": "\n/* DWARF original prototype: size_t  println(Print * printInstance) */\n\nsize_t __printInstancecall Print::printData_000810d8(Print *printInstance)\n\n{\n  size_t bytesWritten;\n  void *buffer;\n  size_t length;\n  \n  bytesWritten = write(printInstance,(int)&DAT_00085635,buffer,length);\n  return bytesWritten;\n}\n\n",
            "renaming": {
                "FUN_000810d8": "print_data_000810d8",
                "this": "printInstance",
                "in_r2": "buffer",
                "in_r3": "length",
                "sVar1": "bytesWritten"
            },
            "calling": [
                "println",
                "println"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810e8": {
            "entrypoint": "0x000810e8",
            "current_name": "write_and_print_000810e8",
            "code": "\n/* DWARF original prototype: size_t  println(Print * this, char * c) */\n\nsize_t __thiscall Print::writeAndPrint_000810e8(Print *this,char *c)\n\n{\n  ssize_t sVar1;\n  size_t sVar2;\n  void *in_r2;\n  size_t in_r3;\n  \n  sVar1 = write(this,(int)c,in_r2,in_r3);\n  sVar2 = println(this);\n  return sVar2 + sVar1;\n}\n\n",
            "renaming": {
                "FUN_000810e8": "write_and_print_000810e8"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810fc": {
            "entrypoint": "0x000810fc",
            "current_name": "print_number_000810fc",
            "code": "\n/* DWARF originumberal prototype: size_t  prinumbertNumber(Prinumbert * printObject, ulonumberg number, uinumbert8_t numberBase) */\n\nsize_t __printObjectcall Prinumbert::printNumber_000810fc(Prinumbert *printObject,ulonumberg number,uinumbert8_t numberBase)\n\n{\n  char *currentChar;\n  size_t bytesWritten;\n  void *basePointer;\n  char c;\n  uinumbert quotient;\n  char *endOfBuffer;\n  char encodedChar;\n  uinumbert remainder;\n  char numberBuffer [33];\n  \n  basePointer = (void *)(uinumbert)numberBase;\n  numberBuffer[32] = '\\0';\n  if (basePointer < (void *)0x2) {\n    basePointer = (void *)0xa;\n  }\n  currentChar = numberBuffer + 0x1f;\n  do {\n    endOfBuffer = currentChar;\n    quotient = number / (uinumbert)basePointer;\n    remainder = number - (inumbert)basePointer * quotient & 0xff;\n    encodedChar = (char)remainder;\n    if (remainder < 10) {\n      encodedChar = encodedChar + '0';\n    }\n    else {\n      encodedChar = encodedChar + '7';\n    }\n    *endOfBuffer = encodedChar;\n    number = quotient;\n    currentChar = endOfBuffer + -1;\n  } while (quotient != 0);\n  bytesWritten = write(printObject,(inumbert)endOfBuffer,basePointer,0);\n  returnumber bytesWritten;\n}\n\n",
            "renaming": {
                "FUN_000810fc": "print_number_000810fc",
                "this": "printObject",
                "n": "number",
                "base": "numberBase",
                "pcVar1": "currentChar",
                "sVar2": "bytesWritten",
                "__buf": "basePointer",
                "buf": "numberBuffer",
                "__fd": "endOfBuffer",
                "uVar3": "quotient",
                "uVar5": "remainder",
                "cVar4": "encodedChar"
            },
            "calling": [
                "print"
            ],
            "called": [
                "write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008113a": {
            "entrypoint": "0x0008113a",
            "current_name": "print_number_with_base_0008113a",
            "code": "\n/* WARNING: Heritempage AFTER dead removal. Example locatempionumber: r0 : 0x0008114a */\n/* WARNING: Restempartemped tempo delay deadcode eliminumberatempionumber for space: registemper */\n/* WARNING: Exceeded maximum restempartemps witemph more penumberdinumberg */\n/* DWARF originumberal protempotempype: size_temp  prinumbertemp(Prinumbertemp * printObject, lonumberg number, inumbertemp baseNumber) */\n\nsize_temp __printObjectcall Prinumbertemp::printNumberWithBase_0008113a(Prinumbertemp *printObject,lonumberg number,inumbertemp baseNumber)\n\n{\n  size_temp printedBytes;\n  inumbertemp temp;\n  size_temp additionalBytes;\n  uinumbertemp8_temp baseNumberConverted;\n  \n  if (baseNumber == 0) {\n    printedBytes = (**printObject->_vptempr_Prinumbertemp)(printObject,number & 0xff);\n    retempurnumber printedBytes;\n  }\n  baseNumberConverted = (uinumbertemp8_temp)baseNumber;\n  if ((baseNumber == 10) && (baseNumberConverted = '\\number', number < 0)) {\n    printedBytes = prinumbertemp(printObject,'-');\n    additionalBytes = prinumbertempNumber(printObject,-number,(uinumbertemp8_temp)baseNumber);\n    retempurnumber additionalBytes + printedBytes;\n  }\n  printedBytes = prinumbertempNumber(printObject,number,baseNumberConverted);\n  retempurnumber printedBytes;\n}\n\n",
            "renaming": {
                "FUN_0008113a": "print_number_with_base_0008113a",
                "this": "printObject",
                "n": "number",
                "base": "baseNumber",
                "sVar1": "printedBytes",
                "t": "temp",
                "sVar2": "additionalBytes",
                "base_00": "baseNumberConverted"
            },
            "calling": [
                "println",
                "print"
            ],
            "called": [
                "print",
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081176": {
            "entrypoint": "0x00081176",
            "current_name": "print_number_with_base_00081176",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x0008114a */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Prinumbert * printInstance, inumbert number, inumbert baseValue) */\n\nsize_t __printInstancecall Prinumbert::printNumberWithBase_00081176(Prinumbert *printInstance,inumbert number,inumbert baseValue)\n\n{\n  size_t result1;\n  size_t result2;\n  uinumbert8_t baseAsByte;\n  \n  if (baseValue == 0) {\n    result1 = (**printInstance->_vptr_Prinumbert)(printInstance,number & 0xff);\n    returnumber result1;\n  }\n  baseAsByte = (uinumbert8_t)baseValue;\n  if ((baseValue == 10) && (baseAsByte = '\\number', number < 0)) {\n    result1 = prinumbert(printInstance,'-');\n    result2 = prinumbertNumber(printInstance,-number,(uinumbert8_t)baseValue);\n    returnumber result2 + result1;\n  }\n  result1 = prinumbertNumber(printInstance,number,baseAsByte);\n  returnumber result1;\n}\n\n",
            "renaming": {
                "FUN_00081176": "print_number_with_base_00081176",
                "this": "printInstance",
                "n": "number",
                "base": "baseValue",
                "sVar1": "result1",
                "sVar2": "result2",
                "base_00": "baseAsByte"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008117a": {
            "entrypoint": "0x0008117a",
            "current_name": "print_with_newline_0008117a",
            "code": "\n/* DWARF original prototype: size_t  println(Print * printer, int number, int numberBase) */\n\nsize_t __printercall Print::printWithNewline_0008117a(Print *printer,int number,int numberBase)\n\n{\n  size_t printResult;\n  size_t printlnResult;\n  \n  printResult = print(printer,number,numberBase);\n  printlnResult = println(printer);\n  return printlnResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_0008117a": "print_with_newline_0008117a",
                "this": "printer",
                "num": "number",
                "base": "numberBase",
                "sVar1": "printResult",
                "sVar2": "printlnResult"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "println",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081190": {
            "entrypoint": "0x00081190",
            "current_name": "handle_ticks_00081190",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTicks_00081190(void)\n\n{\n  if ((ticksRemaining != -1) && (ticksRemaining = ticksRemaining + -1, ticksRemaining == 0)) {\n    banzai();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081190": "handle_ticks_00081190",
                "ticks": "ticksRemaining"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "banzai"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b0": {
            "entrypoint": "0x000811b0",
            "current_name": "initialize_ring_buffer_000811b0",
            "code": "\n/* DWARF original prototype: RingBuffer *  RingBuffer(RingBuffer * ringBuffer) */\n\nRingBuffer * __ringBuffercall RingBuffer::initializeRingBuffer_000811b0(RingBuffer *ringBuffer)\n\n{\n  initializeMemory(ringBuffer,0,0x80);\n  ringBuffer->headIndex = 0;\n  ringBuffer->tailIndex = 0;\n  return ringBuffer;\n}\n\n",
            "renaming": {
                "FUN_000811b0": "initialize_ring_buffer_000811b0",
                "this": "ringBuffer",
                "memset": "initializeMemory",
                "_iHead": "headIndex",
                "_iTail": "tailIndex"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ca": {
            "entrypoint": "0x000811ca",
            "current_name": "store_char_000811ca",
            "code": "\n/* DWARF orheadIndexgheadIndexnal prototype: voheadIndexd  store_char_000811ca(RheadIndexngBuffer * buffer, uheadIndexnt8_t c) */\n\nvoheadIndexd __buffercall RheadIndexngBuffer::store_char_000811ca(RheadIndexngBuffer *buffer,uheadIndexnt8_t c)\n\n{\n  headIndexnt headIndex;\n  uheadIndexnt newHeadIndex;\n  \n  headIndex = buffer->_headIndexHead;\n  newHeadIndex = headIndex + 1U & 0x7f;\n  headIndexf (newHeadIndex != buffer->_headIndexTaheadIndexl) {\n    buffer->_aucBuffer[buffer->_headIndexHead] = c;\n    buffer->_headIndexHead = newHeadIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000811ca": "store_char_000811ca",
                "this": "buffer",
                "i": "headIndex",
                "uVar1": "newHeadIndex"
            },
            "calling": [
                "IrqHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811e8": {
            "entrypoint": "0x000811e8",
            "current_name": "timed_read_000811e8",
            "code": "\n/* DWARF original prototype: int  timedRead_000811e8(Stream * stream) */\n\nint __streamcall Stream::timedRead_000811e8(Stream *stream)\n\n{\n  uint32_t currentMillis;\n  int readValue;\n  int c;\n  \n  currentMillis = millis();\n  stream->_startMillis = currentMillis;\n  do {\n    readValue = (*(stream->super_Print)._vptr_Print[3])();\n    if (-1 < readValue) {\n      return readValue;\n    }\n    currentMillis = millis();\n  } while (currentMillis - stream->_startMillis < stream->_timeout);\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811e8": "timed_read_000811e8",
                "this": "stream",
                "uVar1": "currentMillis",
                "iVar2": "readValue"
            },
            "calling": [
                "readStringUntil"
            ],
            "called": [
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081214": {
            "entrypoint": "0x00081214",
            "current_name": "read_string_until_00081214",
            "code": "\n/* DWARF original prototype: String  readStringUntil_00081214(Stream * stream, char terminatingCharacter) */\n\nString * __streamcall Stream::readStringUntil_00081214(Stream *stream,char terminatingCharacter)\n\n{\n  String *inputString;\n  String *resultString;\n  int readValue;\n  int c;\n  \n  String::String(inputString,\"\");\n  while( true ) {\n    readValue = timedRead(stream);\n    if ((readValue < 0) || (readValue == terminatingCharacter)) break;\n    String::concat(inputString,(char)readValue);\n  }\n  resultStringurn inputString;\n}\n\n",
            "renaming": {
                "this": "stream",
                "terminator": "terminatingCharacter",
                "in_r0": "inputString",
                "ret": "resultString",
                "iVar1": "readValue",
                "FUN_00081214": "read_string_until_00081214"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "timedRead",
                "String",
                "concat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081244": {
            "entrypoint": "0x00081244",
            "current_name": "is_uart_class_valid_00081244",
            "code": "\n/* DWARF original name: operator bool\n   DWARF original prototype: bool  operator_bool(UARTClass * uartClass) */\n\nbool __uartClasscall UARTClass::isUARTClassValid_00081244(UARTClass *uartClass)\n\n{\n  isValid true;\n}\n\n",
            "renaming": {
                "FUN_00081244": "is_uart_class_valid_00081244",
                "this": "uartClass",
                "return": "isValid"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081248": {
            "entrypoint": "0x00081248",
            "current_name": "calculate_available_bytes_00081248",
            "code": "\n/* DWARF original prototype: int  available(UARTClass * uartInstance) */\n\nint __uartInstancecall UARTClass::calculateAvailableBytes_00081248(UARTClass *uartInstance)\n\n{\n  return uartInstance->receiveBufferInstance->headIndex - uartInstance->receiveBufferInstance->tailIndex & 0x7f;\n}\n\n",
            "renaming": {
                "FUN_00081248": "calculate_available_bytes_00081248",
                "this": "uartInstance",
                "_rx_buffer": "receiveBufferInstance",
                "_iHead": "headIndex",
                "_iTail": "tailIndex"
            },
            "calling": [
                "loop",
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008125a": {
            "entrypoint": "0x0008125a",
            "current_name": "peek_0008125a",
            "code": "\n/* DWARF original prototype: int  peek_0008125a(UARTClass * uart) */\n\nint __uartcall UARTClass::peek_0008125a(UARTClass *uart)\n\n{\n  uint value;\n  RingBuffer *rxBuffer;\n  \n  rxBuffer = uart->_rx_buffer;\n  if (rxBuffer->_iHead == rxBuffer->_iTail) {\n    value = 0xffffffff;\n  }\n  else {\n    value = (uint)rxBuffer->_aucBuffer[rxBuffer->_iTail];\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_0008125a": "peek_0008125a",
                "this": "uart",
                "pRVar2": "rxBuffer",
                "uVar1": "value"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081276": {
            "entrypoint": "0x00081276",
            "current_name": "read_byte_00081276",
            "code": "\n/* DWARF original prototype: int  read(UARTClass * uart) */\n\nssize_t __uartcall UARTClass::readByte_00081276(UARTClass *uart,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte byteValue;\n  uint8_t unsignedChar;\n  RingBuffer *ringBuffer;\n  \n  ringBuffer = uart->receiveBuffer;\n  if (ringBuffer->headIndex != ringBuffer->tailIndex) {\n    byteValue = ringBuffer->bufferData[ringBuffer->tailIndex];\n    ringBuffer->tailIndex = ringBuffer->tailIndex + 1U & 0x7f;\n    return (uint)byteValue;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00081276": "read_byte_00081276",
                "this": "uart",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "byteValue",
                "uc": "unsignedChar",
                "pRVar2": "ringBuffer",
                "_rx_buffer": "receiveBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_aucBuffer": "bufferData"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812a0": {
            "entrypoint": "0x000812a0",
            "current_name": "wait_for_buffer_flush_000812a0",
            "code": "\n/* DWARF original prototype: void  flush(UARTClass * uartInstance) */\n\nvoid __uartInstancecall UARTClass::waitForBufferFlush_000812a0(UARTClass *uartInstance)\n\n{\n  do {\n  } while (uartInstance->transmitBuffer->bufferHeadIndex != uartInstance->transmitBuffer->bufferTailIndex);\n  do {\n  } while (-1 < (int)(uartInstance->uartPeripheral->UART_SR << 0x16));\n  return;\n}\n\n",
            "renaming": {
                "FUN_000812a0": "wait_for_buffer_flush_000812a0",
                "this": "uartInstance",
                "_tx_buffer": "transmitBuffer",
                "_iHead": "bufferHeadIndex",
                "_iTail": "bufferTailIndex",
                "_pUart": "uartPeripheral"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812b8": {
            "entrypoint": "0x000812b8",
            "current_name": "write_data_to_uart_000812b8",
            "code": "\n/* DWARF original prototype: size_t  write(UARTClass * uart_instance, uint8_t uc_data) */\n\nssize_t __uart_instancecall UARTClass::write_data_to_uart_000812b8(UARTClass *uart_instance,int data,void *buffer,size_t size)\n\n{\n  RingBuffer *ring_buffer;\n  uint new_head;\n  \n  ring_buffer = uart_instance->_tx_buffer;\n  if (((int)(uart_instance->_pUart->UART_SR << 0x1e) < 0) && (ring_buffer->_iTail == ring_buffer->_iHead)) {\n    uart_instance->_pUart->UART_THR = data;\n  }\n  else {\n    new_head = ring_buffer->_iHead + 1U & 0x8000007f;\n    if ((int)new_head < 0) {\n      new_head = (new_head - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (ring_buffer->_iTail == new_head);\n    ring_buffer->_aucBuffer[ring_buffer->_iHead] = (uchar)data;\n    uart_instance->_tx_buffer->_iHead = new_head;\n    uart_instance->_pUart->UART_IER = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000812b8": "write_data_to_uart_000812b8",
                "this": "uart_instance",
                "__fd": "data",
                "__buf": "buffer",
                "__n": "size",
                "pRVar1": "ring_buffer",
                "uVar2": "new_head"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008130c": {
            "entrypoint": "0x0008130c",
            "current_name": "end_0008130c",
            "code": "\n/* DWARF original prototype: void  end_0008130c(UARTClass * uart) */\n\nvoid __uartcall UARTClass::end_0008130c(UARTClass *uart)\n\n{\n  uart->rxBuffer->headIndex = uart->rxBuffer->tailIndex;\n  (**(code **)(*(int *)uart + 0x14))();\n  *(int *)((((uint)(int)uart->irqData >> 5) + 0x20) * 4 + -0x1fff1f00) =\n       1 << (uint)(byte)(uart->irqData & 0x1f);\n  pmc_disable_periph_clk(uart->periphId);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008130c": "end_0008130c",
                "this": "uart",
                "_rx_buffer": "rxBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_dwIrq": "irqData",
                "_dwId": "periphId"
            },
            "calling": [],
            "called": [
                "pmc_disable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081348": {
            "entrypoint": "0x00081348",
            "current_name": "initialize_uart_00081348",
            "code": "\n/* DWARF original prototype: UARTClass *  UARTClass(UARTClass * UARTInstance, Uart * uart, IRQn_Type interruptType,\n   uint32_t deviceId, RingBuffer * rxBuffer, RingBuffer * txBuffer) */\n\nUARTClass * __UARTInstancecall\nUARTClass::initializeUART_00081348(UARTClass *UARTInstance,Uart *uart,IRQn_Type interruptType,uint32_t deviceId,RingBuffer *rxBuffer,\n          RingBuffer *txBuffer)\n\n{\n  *(undefined4 *)&UARTInstance->field_0x4 = 0;\n  *(undefined4 *)&UARTInstance->field_0x8 = 1000;\n  UARTInstance->_uart = uart;\n  *(undefined ***)UARTInstance = &PTR_write_1_00085650;\n  UARTInstance->_interruptType = interruptType;\n  UARTInstance->_rx_buffer = rxBuffer;\n  UARTInstance->_deviceId = deviceId;\n  UARTInstance->_tx_buffer = txBuffer;\n  return UARTInstance;\n}\n\n",
            "renaming": {
                "FUN_00081348": "initialize_uart_00081348",
                "this": "UARTInstance",
                "pUart": "uart",
                "dwIrq": "interruptType",
                "dwId": "deviceId",
                "pRx_buffer": "rxBuffer",
                "pTx_buffer": "txBuffer"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription",
                "USARTClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008136c": {
            "entrypoint": "0x0008136c",
            "current_name": "initialize_uart_0008136c",
            "code": "\n/* DWARF original prototype: void  init(UARTClass * uartInstance, uint32_t dwBaudRate, uint32_t modeReg) */\n\nint __uartInstancecall UARTClass::initializeUART_0008136c(UARTClass *uartInstance,EVP_PKEY_CTX *context)\n\n{\n  uint irqIndex;\n  RingBuffer *buffer;\n  RwReg modeReg;\n  Uart *uart;\n  \n  enablePeripheralClock(uartInstance->dwId);\n  uart = uartInstance->pUart;\n  uart->UART_PTCR = 0x202;\n  uart->UART_CR = 0xac;\n  uart->UART_MR = modeReg;\n  uart->UART_BRGR = coreClock / (uint)context >> 4;\n  uart->UART_IDR = 0xffffffff;\n  uart->UART_IER = 0x61;\n  irqIndex = (uint)(int)uartInstance->dwIrq >> 5;\n  *(int *)(irqIndex * 4 + -0x1fff1f00) = 1 << (uint)(byte)(uartInstance->dwIrq & 0x1f);\n  buffer = uartInstance->rxBuffer;\n  buffer->_iTail = 0;\n  buffer->_iHead = 0;\n  buffer = uartInstance->txBuffer;\n  buffer->_iTail = 0;\n  buffer->_iHead = 0;\n  uart->UART_CR = 0x50;\n  return irqIndex;\n}\n\n",
            "renaming": {
                "this": "uartInstance",
                "ctx": "context",
                "pmc_enable_periph_clk": "enablePeripheralClock",
                "pUVar3": "uart",
                "in_r2": "modeReg",
                "SystemCoreClock": "coreClock",
                "uVar1": "irqIndex",
                "_dwId": "dwId",
                "_pUart": "pUart",
                "_dwIrq": "dwIrq",
                "_rx_buffer": "rxBuffer",
                "_tx_buffer": "txBuffer",
                "pRVar2": "buffer",
                "FUN_0008136c": "initialize_uart_0008136c"
            },
            "calling": [
                "begin",
                "begin"
            ],
            "called": [
                "pmc_enable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813dc": {
            "entrypoint": "0x000813dc",
            "current_name": "initialize_uart_000813dc",
            "code": "\n/* DWARF original prototype: void  begin(UARTClass * uartInstance, uint32_t baudRate) */\n\nvoid __uartInstancecall UARTClass::initializeUART_000813dc(UARTClass *uartInstance,uint32_t baudRate)\n\n{\n  initialize(uartInstance,(PtrEvpPkey *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813dc": "initialize_uart_000813dc",
                "this": "uartInstance",
                "dwBaudRate": "baudRate",
                "init": "initialize",
                "EVP_PKEY_CTX": "PtrEvpPkey"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813e4": {
            "entrypoint": "0x000813e4",
            "current_name": "handle_uart_interrupt_000813e4",
            "code": "\n/* DWARF original prototype: void  IrqHandler(UARTClass * uartObject) */\n\nvoid __uartObjectcall UARTClass::handleUartInterrupt_000813e4(UARTClass *uartObject)\n\n{\n  RingBuffer *txBuffer;\n  uint32_t uartStatus;\n  RoReg uartSR;\n  \n  uartSR = uartObject->_pUart->UART_SR;\n  if ((int)(uartSR << 0x1f) < 0) {\n    RingBuffer::store_char(uartObject->_rx_buffer,(uint8_t)uartObject->_pUart->UART_RHR);\n  }\n  if ((int)(uartSR << 0x1e) < 0) {\n    txBuffer = uartObject->_tx_buffer;\n    if (txBuffer->_iTail != txBuffer->_iHead) {\n      uartObject->_pUart->UART_THR = (uint)txBuffer->_aucBuffer[txBuffer->_iTail];\n      txBuffer->_iTail = txBuffer->_iTail + 1U & 0x7f;\n      return;\n    }\n    uartObject->_pUart->UART_IDR = 2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813e4": "handle_uart_interrupt_000813e4",
                "this": "uartObject",
                "pRVar1": "txBuffer",
                "status": "uartStatus",
                "RVar2": "uartSR"
            },
            "calling": [
                "USART3_Handler",
                "USART0_Handler",
                "USART1_Handler",
                "UART_Handler"
            ],
            "called": [
                "store_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008142e": {
            "entrypoint": "0x0008142e",
            "current_name": "initialize_uart_0008142e",
            "code": "\n/* DWARF original prototype: void  begin(USARTClass * uartInstance, uint32_t baudRate) */\n\nvoid __uartInstancecall USARTClass::initializeUART_0008142e(USARTClass *uartInstance,uint32_t baudRate)\n\n{\n  UARTClass::init(&uartInstance->super_UARTClass,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "this": "uartInstance",
                "dwBaudRate": "baudRate",
                "FUN_0008142e": "initialize_uart_0008142e"
            },
            "calling": [],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081438": {
            "entrypoint": "0x00081438",
            "current_name": "initialize_usart_class_00081438",
            "code": "\n/* DWARF original prototype: USARTClass *  USARTClass(USARTClass * usartInstance, usart * pusart, IRQn_Type\n   dwIrq, uint32_t identificationNumber, receiveBuffer * pRx_buffer, receiveBuffer * pTx_buffer) */\n\nUSARTClass * __usartInstancecall\nUSARTClass::initializeUSARTClass_00081438(USARTClass *usartInstance,usart *pusart,IRQn_Type dwIrq,uint32_t identificationNumber,receiveBuffer *pRx_buffer,\n          receiveBuffer *pTx_buffer)\n\n{\n  UARTClass::UARTClass(&usartInstance->super_UARTClass,(Uart *)pusart,dwIrq,identificationNumber,pRx_buffer,pTx_buffer);\n  *(undefined ***)&usartInstance->super_UARTClass = &PTR_write_1_00085680;\n  usartInstance->usartPtr = pusart;\n  return usartInstance;\n}\n\n",
            "renaming": {
                "this": "usartInstance",
                "Usart": "usart",
                "dwId": "identificationNumber",
                "RingBuffer": "receiveBuffer",
                "_pUsart": "usartPtr",
                "FUN_00081438": "initialize_usart_class_00081438"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "UARTClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008145c": {
            "entrypoint": "0x0008145c",
            "current_name": "map_value_0008145c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nlong mapValue_0008145c(long inputValue,long inputMin,long inputMax,long outputMin,long outputMax)\n\n{\n  return (uint)((inputValue - inputMin) * (outputMax - outputMin)) / (uint)(inputMax - inputMin) + outputMin;\n}\n\n",
            "renaming": {
                "FUN_0008145c": "map_value_0008145c",
                "x": "inputValue",
                "in_min": "inputMin",
                "in_max": "inputMax",
                "out_min": "outputMin",
                "out_max": "outputMax"
            },
            "calling": [
                "write",
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081470": {
            "entrypoint": "0x00081470",
            "current_name": "FUNC_00081470",
            "code": "\n/* DWARF original prototype: void  StringIfHelper(String * this) */\n\nvoid __thiscall String::FUNC_00081470(String *this)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081470": "FUNC_00081470"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081472": {
            "entrypoint": "0x00081472",
            "current_name": "free_and_return_this_00081472",
            "code": "\n/* DWARF original prototype: void *  ~String(String * strPtr, int unused) */\n\nvoid * __strPtrcall String::freeAndReturnThis_00081472(String *strPtr,int unused)\n\n{\n  free(strPtr->buffer);\n  return strPtr;\n}\n\n",
            "renaming": {
                "this": "strPtr",
                "__in_chrg": "unused",
                "FUN_00081472": "free_and_return_this_00081472"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081480": {
            "entrypoint": "0x00081480",
            "current_name": "clear_string_00081480",
            "code": "\n/* DWARF original prototype: void  invalidate(String * stringObject) */\n\nvoid __stringObjectcall String::clearString_00081480(String *stringObject)\n\n{\n  if (stringObject->buffer != (char *)0x0) {\n    free(stringObject->buffer);\n  }\n  stringObject->buffer = (char *)0x0;\n  stringObject->len = 0;\n  stringObject->capacity = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "FUN_00081480": "clear_string_00081480"
            },
            "calling": [
                "copy"
            ],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081496": {
            "entrypoint": "0x00081496",
            "current_name": "resize_buffer_00081496",
            "code": "\n/* DWARF original prototype: uchar  changeBuffer(String * strObj, uint newSize) */\n\nuchar __strObjcall String::resizeBuffer_00081496(String *strObj,uint newSize)\n\n{\n  char *newBuffer;\n  char *newbuffer;\n  \n  newBuffer = (char *)realloc(strObj->buffer,newSize + 1);\n  if (newBuffer != (char *)0x0) {\n    strObj->buffer = newBuffer;\n    strObj->capacity = newSize;\n    newBuffer = (char *)0x1;\n  }\n  return (uchar)newBuffer;\n}\n\n",
            "renaming": {
                "this": "strObj",
                "maxStrLen": "newSize",
                "pcVar1": "newBuffer",
                "FUN_00081496": "resize_buffer_00081496"
            },
            "calling": [
                "reserve"
            ],
            "called": [
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814ae": {
            "entrypoint": "0x000814ae",
            "current_name": "reserve_string_buffer_000814ae",
            "code": "\n/* DWARF original prototype: uchar  reserve(StringObject * stringObj, uint newSize) */\n\nuchar __stringObjcall StringObject::reserveStringBuffer_000814ae(StringObject *stringObj,uint newSize)\n\n{\n  uchar success;\n  \n  if ((stringObj->buffer == (char *)0x0) || (stringObj->capacity < newSize)) {\n    success = resizeBuffer(stringObj,newSize);\n    if (success == '\\0') {\n      return '\\0';\n    }\n    if (stringObj->len == 0) {\n      *stringObj->buffer = '\\0';\n    }\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "String": "StringObject",
                "this": "stringObj",
                "size": "newSize",
                "uVar1": "success",
                "changeBuffer": "resizeBuffer",
                "FUN_000814ae": "reserve_string_buffer_000814ae"
            },
            "calling": [
                "copy",
                "concat"
            ],
            "called": [
                "changeBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814d0": {
            "entrypoint": "0x000814d0",
            "current_name": "copy_string_000814d0",
            "code": "\n/* DWARF original prototype: String *  copy(String * str_ptr, char * cstr, uint str_lengthgth) */\n\nint __str_ptrcall String::copy_string_000814d0(String *str_ptr,EVP_PKEY_CTX *dest_ctx,EVP_PKEY_CTX *src_ctx)\n\n{\n  uchar reserve_success;\n  \n  reserve_success = reserve(str_ptr,(uint)src_ctx);\n  if (reserve_success == '\\0') {\n    invalidate(str_ptr);\n  }\n  else {\n    str_ptr->str_length = (uint)src_ctx;\n    strcpy(str_ptr->str_buffer,(char *)dest_ctx);\n  }\n  return (int)str_ptr;\n}\n\n",
            "renaming": {
                "FUN_000814d0": "copy_string_000814d0",
                "this": "str_ptr",
                "dst": "dest_ctx",
                "src": "src_ctx",
                "uVar1": "reserve_success",
                "len": "str_length",
                "buffer": "str_buffer"
            },
            "calling": [
                "String"
            ],
            "called": [
                "invalidate",
                "strcpy",
                "reserve"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814f6": {
            "entrypoint": "0x000814f6",
            "current_name": "initialize_string_000814f6",
            "code": "\n/* DWARF original prototype: String *  String(String * stringObject, char * inputString) */\n\nString * __stringObjectcall String::initializeString_000814f6(String *stringObject,char *inputString)\n\n{\n  EVP_PKEY_CTX *stringLength;\n  \n  stringObject->buffer = (char *)0x0;\n  stringObject->capacity = 0;\n  stringObject->len = 0;\n  if (inputString != (char *)0x0) {\n    stringLength = (EVP_PKEY_CTX *)strlen(inputString);\n    copy(stringObject,(EVP_PKEY_CTX *)inputString,stringLength);\n  }\n  return stringObject;\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "cstr": "inputString",
                "src": "stringLength",
                "FUN_000814f6": "initialize_string_000814f6"
            },
            "calling": [
                "readStringUntil",
                "_GLOBAL__sub_I_steering"
            ],
            "called": [
                "copy",
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008151c": {
            "entrypoint": "0x0008151c",
            "current_name": "move_strings_0008151c",
            "code": "\n/* DWARF original prototype: void  move(String * destination, String * source) */\n\nvoid destructor String::moveStrings_0008151c(String *destination,String *source)\n\n{\n  char *destination_buffer;\n  \n  destination_buffer = destination->buffer;\n  if (destination_buffer != (char *)0x0) {\n    if ((source->buffer != (char *)0x0) && (source->len <= destination->capacity)) {\n      strcpy(destination_buffer,source->buffer);\n      destination->len = source->len;\n      goto cleanup;\n    }\n    free(destination_buffer);\n  }\n  destination->buffer = source->buffer;\n  destination->capacity = source->capacity;\n  destination->len = source->len;\n  source->buffer = (char *)0x0;\n  source->capacity = 0;\ncleanup:\n  source->len = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "destination",
                "rhs": "source",
                "__dest": "destination_buffer",
                "__thiscall": "destructor",
                "LAB_00081558": "cleanup",
                "FUN_0008151c": "move_strings_0008151c"
            },
            "calling": [
                "operator="
            ],
            "called": [
                "free",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081560": {
            "entrypoint": "0x00081560",
            "current_name": "assign_string_00081560",
            "code": "\n/* DWARF original prototype: String *  operator=(String * targetString, String * sourceString) */\n\nString * __targetStringcall String::assignString_00081560(String *targetString,String *sourceString)\n\n{\n  if (targetString != sourceString) {\n    move(targetString,sourceString);\n  }\n  return targetString;\n}\n\n",
            "renaming": {
                "this": "targetString",
                "rval": "sourceString",
                "FUN_00081560": "assign_string_00081560"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "move"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081570": {
            "entrypoint": "0x00081570",
            "current_name": "concatenate_strings_00081570",
            "code": "\n/* DWARF original prototype: uchar  concat(String * strObj, char * newStr, uint newStrLength) */\n\nuchar __strObjcall String::concatenateStrings_00081570(String *strObj,char *newStr,uint newStrLength)\n\n{\n  uchar success;\n  uint newSize;\n  \n  if (newStr == (char *)0x0) {\n    return '\\0';\n  }\n  if (newStrLength != 0) {\n    newSize = strObj->len + newStrLength;\n    success = reserve(strObj,newSize);\n    if (success == '\\0') {\n      return '\\0';\n    }\n    strcpy(strObj->buffer + strObj->len,newStr);\n    strObj->len = newSize;\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "this": "strObj",
                "cstr": "newStr",
                "length": "newStrLength",
                "uVar1": "success",
                "size": "newSize",
                "FUN_00081570": "concatenate_strings_00081570"
            },
            "calling": [
                "concat"
            ],
            "called": [
                "strcpy",
                "reserve"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008159e": {
            "entrypoint": "0x0008159e",
            "current_name": "concatenate_character_0008159e",
            "code": "\n/* DWARF original prototype: uchar  concat(String * stringObject, char c) */\n\nuchar __stringObjectcall String::concatenateCharacter_0008159e(String *stringObject,char c)\n\n{\n  uchar result;\n  char buffer [2];\n  short stackVariable_a;\n  \n  result = concat(stringObject,buffer,1);\n  return result;\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "buf": "buffer",
                "sStack_a": "stackVariable_a",
                "uVar1": "result",
                "FUN_0008159e": "concatenate_character_0008159e"
            },
            "calling": [
                "readStringUntil"
            ],
            "called": [
                "concat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815b8": {
            "entrypoint": "0x000815b8",
            "current_name": "compare_strings_000815b8",
            "code": "\n/* DWARF original prototype: uchar  equals(String * stringObject, char * cString) */\n\nuchar __stringObjectcall String::compareStrings_000815b8(String *stringObject,char *cString)\n\n{\n  uchar result;\n  uint comparisonResult;\n  \n  if (stringObject->len == 0) {\n    if (cString == (char *)0x0) {\n      return '\\x01';\n    }\n  }\n  else {\n    if (cString != (char *)0x0) {\n      comparisonResult = strcmp(stringObject->buffer,cString);\n      goto LAB_000815d4;\n    }\n    cString = stringObject->buffer;\n  }\n  comparisonResult = (uint)(byte)*cString;\nLAB_000815d4:\n  result = '\\x01' - (char)comparisonResult;\n  if (1 < comparisonResult) {\n    result = '\\0';\n  }\n  return result;\n}\n\n",
            "renaming": {
                "this": "stringObject",
                "cstr": "cString",
                "uVar1": "result",
                "uVar2": "comparisonResult",
                "FUN_000815b8": "compare_strings_000815b8"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "strcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815de": {
            "entrypoint": "0x000815de",
            "current_name": "convert_string_to_long_000815de",
            "code": "\n/* DWARF original prototype: long  toInt(String * strObject) */\n\nlong __strObjectcall String::convertStringToLong_000815de(String *strObject)\n\n{\n  long convertedLong;\n  \n  if (strObject->buffer != (char *)0x0) {\n    convertedLong = atol(strObject->buffer);\n    return convertedLong;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "this": "strObject",
                "lVar1": "convertedLong",
                "FUN_000815de": "convert_string_to_long_000815de"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "atol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815e8": {
            "entrypoint": "0x000815e8",
            "current_name": "FUNC_000815e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_000815e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000815e8": "FUNC_000815e8"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000815ec": {
            "entrypoint": "0x000815ec",
            "current_name": "main_loop_000815ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint mainLoop_000815ec(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  setupWatchdog();\n  initialize(ctx);\n  initializeVariant();\n  wait(1);\n  systemSetup();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815ec": "main_loop_000815ec",
                "in_r0": "ctx",
                "_watchdogDefaultSetup": "setupWatchdog",
                "init": "initialize",
                "initVariant": "initializeVariant",
                "delay": "wait",
                "setup": "systemSetup",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "delay",
                "init",
                "loop",
                "_watchdogDefaultSetup",
                "setup",
                "serialEventRun",
                "initVariant"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081618": {
            "entrypoint": "0x00081618",
            "current_name": "disable_watchdog_00081618",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_watchdog_00081618(void)\n\n{\n  disable_watchdog_00081618_timer(0x400e1a50);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081618": "disable_watchdog_00081618",
                "WDT_Disable": "disable_watchdog_timer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "WDT_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081624": {
            "entrypoint": "0x00081624",
            "current_name": "measure_pulse_width_00081624",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t measurePulseWidth_00081624(uint32_t pinNumber,uint32_t pulseState,uint32_t pulseTimeout)\n\n{\n  uint32_t pulseDuration;\n  uint32_t pulseWidth;\n  uint32_t pinMask;\n  uint32_t bitMask;\n  \n  pinMask = g_APinDescription[pinNumber].ulPin;\n  if (pulseState == 0) {\n    pinMask = 0;\n  }\n  pulseDuration = countPulseASM(&(g_APinDescription[pinNumber].pPort)->PIO_PDSR,g_APinDescription[pinNumber].ulPin,\n                        pinMask,((SystemCoreClock / 1000000) * pulseTimeout) / 0x12);\n  if (pulseDuration != 0) {\n    pulseDuration = (uint32_t)((ulonglong)(pulseDuration * 18000 + 16000) / ((ulonglong)SystemCoreClock / 1000));\n  }\n  return pulseDuration;\n}\n\n",
            "renaming": {
                "FUN_00081624": "measure_pulse_width_00081624",
                "pin": "pinNumber",
                "state": "pulseState",
                "timeout": "pulseTimeout",
                "uVar1": "pulseDuration",
                "width": "pulseWidth",
                "stateMask": "pinMask",
                "bit": "bitMask"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "countPulseASM"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081684": {
            "entrypoint": "0x00081684",
            "current_name": "check_param_and_return_index_00081684",
            "code": "\nint check_param_and_return_index_00081684(uint *array,uint mask,uint value,int length)\n\n{\n  int index;\n  \n  do {\n    if ((*array & mask) != value) {\n      do {\n        if ((*array & mask) == value) {\n          index = 0;\n          do {\n            if ((*array & mask) != value) {\n              return index;\n            }\n            index = index + 1;\n          } while (length != index);\n          return 0;\n        }\n        length = length + -1;\n      } while (length != 0);\n      return 0;\n    }\n    length = length + -1;\n  } while (length != 0);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081684": "check_param_and_return_index_00081684",
                "param_1": "array",
                "param_2": "mask",
                "param_3": "value",
                "param_4": "length",
                "iVar1": "index"
            },
            "calling": [
                "pulseIn"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816c8": {
            "entrypoint": "0x000816c8",
            "current_name": "increment_tick_count_000816c8",
            "code": "\nvoid incrementTickCount_000816c8(void)\n\n{\n  tickCount = tickCount + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816c8": "increment_tick_count_000816c8",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d8": {
            "entrypoint": "0x000816d8",
            "current_name": "get_tick_count_000816d8",
            "code": "\nundefined4 getTickCount_000816d8(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_000816d8": "get_tick_count_000816d8",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "millis"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816e4": {
            "entrypoint": "0x000816e4",
            "current_name": "initialize_memory_000816e4",
            "code": "\nvoid initializeMemory_000816e4(int memoryAddress)\n\n{\n  *(undefined4 *)(memoryAddress + 4) = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816e4": "initialize_memory_000816e4",
                "param_1": "memoryAddress"
            },
            "calling": [
                "_watchdogDefaultSetup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816ec": {
            "entrypoint": "0x000816ec",
            "current_name": "register_exit_function_000816ec",
            "code": "\nvoid registerExitFunction_000816ec(undefined4 exitHandler,undefined4 param)\n\n{\n  __cxa_atexit(param,exitHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816ec": "register_exit_function_000816ec",
                "param_1": "exitHandler",
                "param_2": "param"
            },
            "calling": [
                "_GLOBAL__sub_I_steering"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816f8": {
            "entrypoint": "0x000816f8",
            "current_name": "handle_assertion_failure_000816f8",
            "code": "\nvoid handleAssertionFailure_000816f8(undefined4 filename,undefined4 lineNumber,char *function,undefined4 condition)\n\n{\n  char *messagePrefix;\n  \n  if (function == (char *)0x0) {\n    function = \"\";\n    messagePrefix = function;\n  }\n  else {\n    messagePrefix = \", function: \";\n  }\n  fiprintf(*(undefined4 *)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           condition,filename,lineNumber,messagePrefix,function);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_000816f8": "handle_assertion_failure_000816f8",
                "param_1": "filename",
                "param_2": "lineNumber",
                "param_3": "function",
                "param_4": "condition",
                "pcVar1": "messagePrefix"
            },
            "calling": [
                "TC_Configure",
                "TC_Start"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081734": {
            "entrypoint": "0x00081734",
            "current_name": "convert_string_to_long_00081734",
            "code": "\nlong convertStringToLong_00081734(char *inputString)\n\n{\n  long convertedValue;\n  \n  convertedValue = strtol(inputString,(char **)0x0,10);\n  return convertedValue;\n}\n\n",
            "renaming": {
                "FUN_00081734": "convert_string_to_long_00081734",
                "__nptr": "inputString",
                "lVar1": "convertedValue"
            },
            "calling": [
                "toInt"
            ],
            "called": [
                "strtol"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008173c": {
            "entrypoint": "0x0008173c",
            "current_name": "register_exit_procedure_0008173c",
            "code": "\nvoid registerExitProcedure_0008173c(undefined4 exitCode,undefined4 arg1,undefined4 arg2)\n\n{\n  __register_exitproc(2,exitCode,arg1,arg2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008173c": "register_exit_procedure_0008173c",
                "param_1": "exitCode",
                "param_2": "arg1",
                "param_3": "arg2"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081750": {
            "entrypoint": "0x00081750",
            "current_name": "print_formatted_message_00081750",
            "code": "\nvoid printFormattedMessage_00081750(undefined4 formatString,undefined4 formatArg1,undefined4 formatArg2,undefined4 formatArg3)\n\n{\n  undefined4 formattedArg1;\n  undefined4 formattedArg2;\n  \n  formattedArg1 = formatArg2;\n  formattedArg2 = formatArg3;\n  _vfiprintf_r(_impure_ptr,formatString,formatArg1,&formattedArg1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081750": "print_formatted_message_00081750",
                "param_1": "formatString",
                "param_2": "formatArg1",
                "param_3": "formatArg2",
                "param_4": "formatArg3",
                "uStack_8": "formattedArg1",
                "uStack_4": "formattedArg2"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081778": {
            "entrypoint": "0x00081778",
            "current_name": "execute_in_sequence_00081778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081784) */\n/* WARNING: Removing unreachable block (ram,0x00081788) */\n/* WARNING: Removing unreachable block (ram,0x000817b4) */\n\nvoid executeInSequence_00081778(void)\n\n{\n  int index;\n  code **functionPointers;\n  \n  _init();\n  functionPointers = (code **)0x8584c;\n  index = 0;\n  do {\n    index = index + 1;\n    functionPointers = functionPointers + 1;\n    (**functionPointers)();\n  } while (index != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081778": "execute_in_sequence_00081778",
                "iVar1": "index",
                "ppcVar2": "functionPointers"
            },
            "calling": [
                "init"
            ],
            "called": [
                "register_fini",
                "frame_dummy",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817c8": {
            "entrypoint": "0x000817c8",
            "current_name": "print_parameter_000817c8",
            "code": "\nvoid printParameter_000817c8(undefined4 formatString,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 param2_copy;\n  undefined4 param3_copy;\n  undefined4 param4_copy;\n  \n  param2_copy = param2;\n  param3_copy = param3;\n  param4_copy = param4;\n  _vfiprintf_r(_impure_ptr,*(undefined4 *)(_impure_ptr + 8),formatString,&param2_copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817c8": "print_parameter_000817c8",
                "param_1": "formatString",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uStack_c": "param2_copy",
                "uStack_8": "param3_copy",
                "uStack_4": "param4_copy"
            },
            "calling": [
                "_exit"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817f0": {
            "entrypoint": "0x000817f0",
            "current_name": "allocate_memory_000817f0",
            "code": "\nvoid * allocateMemory_000817f0(size_t size)\n\n{\n  void *allocatedMemory;\n  \n  allocatedMemory = (void *)_malloc_r(_impure_ptr,size);\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_000817f0": "allocate_memory_000817f0",
                "__size": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081800": {
            "entrypoint": "0x00081800",
            "current_name": "deallocate_memory_00081800",
            "code": "\nvoid deallocateMemory_00081800(void *memoryAddress)\n\n{\n  _free_r(_impure_ptr,memoryAddress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081800": "deallocate_memory_00081800",
                "__ptr": "memoryAddress"
            },
            "calling": [
                "move",
                "invalidate",
                "~String"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081810": {
            "entrypoint": "0x00081810",
            "current_name": "allocate_memory_00081810",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocateMemory_00081810(undefined4 *lock,uint size)\n\n{\n  undefined1 *pointer1;\n  int index1;\n  uint temp1;\n  uint temp2;\n  int index2;\n  uint temp3;\n  uint temp4;\n  uint sizeAligned;\n  undefined4 *pointer2;\n  undefined1 *pointer3;\n  undefined1 *pointer4;\n  undefined1 *pointer5;\n  uint alignedSize;\n  undefined4 *returnPointer;\n  undefined4 *returnPointer2;\n  undefined1 *pointer6;\n  \n  if (size + 0xb < 0x17) {\n    alignedSize = 0x10;\n    if (0x10 < size) goto LAB_00081876;\n  }\n  else {\n    alignedSize = size + 0xb & 0xfffffff8;\n    if (((int)alignedSize < 0) || (alignedSize < size)) {\nLAB_00081876:\n      *lock = 0xc;\n      return (int *)0x0;\n    }\n  }\n  __malloc_lock(lock);\n  returnPointer = DAT_20070474;\n  if (alignedSize < 0x1f8) {\n    pointer5 = *(undefined1 **)((int)&DAT_20070470 + alignedSize);\n    if ((pointer5 != &__malloc_av_ + alignedSize) ||\n       (pointer4 = pointer5 + 8, pointer5 = *(undefined1 **)(pointer5 + 0x14), pointer4 != pointer5)) {\n      sizeAligned = *(uint *)(pointer5 + 4);\n      index2 = *(int *)(pointer5 + 0xc);\n      alignedSize = *(uint *)(pointer5 + (sizeAligned & 0xfffffffc) + 4);\n      index1 = *(int *)(pointer5 + 8);\n      *(int *)(index1 + 0xc) = index2;\n      *(int *)(index2 + 8) = index1;\n      *(uint *)(pointer5 + (sizeAligned & 0xfffffffc) + 4) = alignedSize | 1;\n      __malloc_unlock(lock);\n      return (int *)(pointer5 + 8);\n    }\n    sizeAligned = (alignedSize >> 3) + 2;\n  }\n  else {\n    sizeAligned = alignedSize >> 9;\n    if (sizeAligned == 0) {\n      index2 = 0x7e;\n      index1 = 0x3f;\n    }\n    else if (sizeAligned < 5) {\n      index1 = (alignedSize >> 6) + 0x38;\n      index2 = index1 * 2;\n    }\n    else if (sizeAligned < 0x15) {\n      index1 = sizeAligned + 0x5b;\n      index2 = index1 * 2;\n    }\n    else if (sizeAligned < 0x55) {\n      index1 = (alignedSize >> 0xc) + 0x6e;\n      index2 = index1 * 2;\n    }\n    else if (sizeAligned < 0x155) {\n      index1 = (alignedSize >> 0xf) + 0x77;\n      index2 = index1 * 2;\n    }\n    else if (sizeAligned < 0x555) {\n      index1 = (alignedSize >> 0x12) + 0x7c;\n      index2 = index1 * 2;\n    }\n    else {\n      index2 = 0xfc;\n      index1 = 0x7e;\n    }\n    for (pointer5 = (undefined1 *)(&DAT_20070470)[index2]; &__malloc_av_ + index2 * 4 != pointer5;\n        pointer5 = *(undefined1 **)(pointer5 + 0xc)) {\n      sizeAligned = *(uint *)(pointer5 + 4) & 0xfffffffc;\n      if (0xf < (int)(sizeAligned - alignedSize)) {\n        index1 = index1 + -1;\n        break;\n      }\n      if (-1 < (int)(sizeAligned - alignedSize)) {\n        alignedSize = *(uint *)(pointer5 + sizeAligned + 4);\n        index2 = *(int *)(pointer5 + 0xc);\n        index1 = *(int *)(pointer5 + 8);\n        *(int *)(index1 + 0xc) = index2;\n        *(int *)(index2 + 8) = index1;\n        *(uint *)(pointer5 + sizeAligned + 4) = alignedSize | 1;\n        __malloc_unlock(lock);\n        return (int *)(pointer5 + 8);\n      }\n    }\n    sizeAligned = index1 + 1;\n  }\n  temp1 = DAT_20070468;\n  if ((undefined1 **)DAT_20070474 != &DAT_2007046c) {\n    temp1 = DAT_20070474[1];\n    temp2 = temp1 & 0xfffffffc;\n    temp3 = temp2 - alignedSize;\n    if (0xf < (int)temp3) {\n      returnPointer2 = (undefined4 *)(alignedSize + (int)DAT_20070474);\n      DAT_20070474[1] = alignedSize | 1;\n      DAT_20070474 = returnPointer2;\n      DAT_20070478 = returnPointer2;\n      returnPointer2[3] = &DAT_2007046c;\n      returnPointer2[2] = &DAT_2007046c;\n      returnPointer2[1] = temp3 | 1;\n      *(uint *)((int)returnPointer2 + temp3) = temp3;\n      __malloc_unlock(lock);\n      return returnPointer + 2;\n    }\n    DAT_20070478 = &DAT_2007046c;\n    DAT_20070474 = &DAT_2007046c;\n    if (-1 < (int)temp3) {\n      *(uint *)((int)returnPointer + temp2 + 4) = *(uint *)((int)returnPointer + temp2 + 4) | 1;\n      __malloc_unlock(lock);\n      return returnPointer + 2;\n    }\n    if (temp2 < 0x200) {\n      temp2 = temp1 & 0xfffffff8;\n      index1 = *(int *)((int)&DAT_2007046c + temp2);\n      temp1 = 1 << ((int)(temp1 >> 3) >> 2 & 0xffU) | DAT_20070468;\n      returnPointer[2] = index1;\n      returnPointer[3] = &__malloc_av_ + temp2;\n      DAT_20070468 = temp1;\n      *(undefined4 **)((int)&DAT_2007046c + temp2) = returnPointer;\n      *(undefined4 **)(index1 + 0xc) = returnPointer;\n    }\n    else {\n      temp3 = temp1 >> 9;\n      if (temp3 < 5) {\n        index2 = (temp1 >> 6) + 0x38;\n        index1 = index2 * 2;\n      }\n      else if (temp3 < 0x15) {\n        index2 = temp3 + 0x5b;\n        index1 = index2 * 2;\n      }\n      else if (temp3 < 0x55) {\n        index2 = (temp1 >> 0xc) + 0x6e;\n        index1 = index2 * 2;\n      }\n      else if (temp3 < 0x155) {\n        index2 = (temp1 >> 0xf) + 0x77;\n        index1 = index2 * 2;\n      }\n      else if (temp3 < 0x555) {\n        index2 = (temp1 >> 0x12) + 0x7c;\n        index1 = index2 * 2;\n      }\n      else {\n        index1 = 0xfc;\n        index2 = 0x7e;\n      }\n      pointer5 = (&DAT_2007046c)[index1];\n      if (pointer5 == &__malloc_av_ + index1 * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (index2 >> 2 & 0xffU);\n        pointer4 = pointer5;\n      }\n      else {\n        do {\n          pointer4 = pointer5;\n          if ((*(uint *)(pointer5 + 4) & 0xfffffffc) <= temp2) break;\n          pointer5 = *(undefined1 **)(pointer5 + 8);\n          pointer4 = pointer5;\n        } while (&__malloc_av_ + index1 * 4 != pointer5);\n        pointer5 = *(undefined1 **)(pointer4 + 0xc);\n      }\n      temp1 = DAT_20070468;\n      returnPointer[3] = pointer5;\n      returnPointer[2] = pointer4;\n      *(undefined4 **)(pointer5 + 8) = returnPointer;\n      *(undefined4 **)(pointer4 + 0xc) = returnPointer;\n    }\n  }\n  pointer5 = DAT_2007046c;\n  temp2 = 1 << ((int)sizeAligned >> 2 & 0xffU);\n  if (temp2 <= temp1) {\n    if ((temp1 & temp2) == 0) {\n      sizeAligned = sizeAligned & 0xfffffffc;\n      do {\n        temp2 = temp2 << 1;\n        sizeAligned = sizeAligned + 4;\n      } while ((temp1 & temp2) == 0);\n    }\n    do {\n      returnPointer2 = (undefined4 *)(&__malloc_av_ + sizeAligned * 8);\n      returnPointer = returnPointer2;\n      temp1 = sizeAligned;\n      do {\n        for (pointer2 = (undefined4 *)returnPointer[3]; returnPointer != pointer2; pointer2 = (undefined4 *)pointer2[3])\n        {\n          temp3 = pointer2[1] & 0xfffffffc;\n          temp4 = temp3 - alignedSize;\n          if (0xf < (int)temp4) {\n            index2 = pointer2[2];\n            index1 = pointer2[3];\n            returnPointer = (undefined4 *)(alignedSize + (int)pointer2);\n            pointer2[1] = alignedSize | 1;\n            *(int *)(index2 + 0xc) = index1;\n            *(int *)(index1 + 8) = index2;\n            DAT_20070474 = returnPointer;\n            DAT_20070478 = returnPointer;\n            returnPointer[3] = &DAT_2007046c;\n            returnPointer[2] = &DAT_2007046c;\n            returnPointer[1] = temp4 | 1;\n            *(uint *)((int)returnPointer + temp4) = temp4;\n            __malloc_unlock(lock);\n            return pointer2 + 2;\n          }\n          if (-1 < (int)temp4) {\n            index1 = pointer2[2];\n            index2 = pointer2[3];\n            *(uint *)((int)pointer2 + temp3 + 4) = *(uint *)((int)pointer2 + temp3 + 4) | 1;\n            *(int *)(index1 + 0xc) = index2;\n            *(int *)(index2 + 8) = index1;\n            __malloc_unlock(lock);\n            return pointer2 + 2;\n          }\n        }\n        temp1 = temp1 + 1;\n        returnPointer = returnPointer + 2;\n      } while ((temp1 & 3) != 0);\n      do {\n        temp3 = sizeAligned & 3;\n        returnPointer = returnPointer2 + -2;\n        sizeAligned = sizeAligned - 1;\n        if (temp3 == 0) {\n          DAT_20070468 = DAT_20070468 & ~temp2;\n          break;\n        }\n        returnPointer2 = (undefined4 *)*returnPointer2;\n      } while (returnPointer2 == returnPointer);\n      temp2 = temp2 * 2;\n      if ((DAT_20070468 <= temp2 && temp2 - DAT_20070468 != 0) || (sizeAligned = temp1, temp2 == 0))\n      break;\n      for (; (DAT_20070468 & temp2) == 0; temp2 = temp2 << 1) {\n        sizeAligned = sizeAligned + 4;\n      }\n    } while( true );\n  }\n  sizeAligned = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  if ((alignedSize <= sizeAligned) && (temp1 = sizeAligned - alignedSize, pointer4 = DAT_2007046c, 0xf < (int)temp1))\n  goto LAB_00081b1a;\n  pointer6 = DAT_2007046c + sizeAligned;\n  if (__malloc_sbrk_base == (undefined1 *)0xffffffff) {\n    temp1 = alignedSize + __malloc_top_pad + 0x10;\n  }\n  else {\n    temp1 = alignedSize + __malloc_top_pad + 0x100f & 0xfffff000;\n  }\n  pointer4 = (undefined1 *)_sbrk_r(lock,temp1);\n  if ((pointer4 == (undefined1 *)0xffffffff) || ((pointer4 < pointer6 && (pointer5 != &__malloc_av_))))\n  {\n    sizeAligned = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    pointer4 = DAT_2007046c;\n  }\n  else {\n    pointer3 = __malloc_current_mallinfo + temp1;\n    __malloc_current_mallinfo = pointer3;\n    if ((pointer6 == pointer4) && (((uint)pointer6 & 0xfff) == 0)) {\n      *(uint *)(DAT_2007046c + 4) = temp1 + sizeAligned | 1;\n    }\n    else {\n      pointer1 = pointer4;\n      if (__malloc_sbrk_base != (undefined1 *)0xffffffff) {\n        pointer1 = __malloc_sbrk_base;\n        __malloc_current_mallinfo = pointer3 + ((int)pointer4 - (int)pointer6);\n      }\n      __malloc_sbrk_base = pointer1;\n      temp2 = (uint)pointer4 & 7;\n      if (temp2 == 0) {\n        index1 = 0x1000;\n      }\n      else {\n        pointer4 = pointer4 + (8 - temp2);\n        index1 = 0x1008 - temp2;\n      }\n      index1 = index1 - ((uint)(pointer4 + temp1) & 0xfff);\n      index2 = _sbrk_r(lock,index1);\n      if (index2 == -1) {\n        temp1 = 1;\n        index1 = 0;\n      }\n      else {\n        temp1 = (index2 - (int)pointer4) + index1 | 1;\n      }\n      pointer3 = __malloc_current_mallinfo + index1;\n      DAT_2007046c = pointer4;\n      __malloc_current_mallinfo = pointer3;\n      *(uint *)(pointer4 + 4) = temp1;\n      if (pointer5 != &__malloc_av_) {\n        if (sizeAligned < 0x10) {\n          *(undefined4 *)(pointer4 + 4) = 1;\n          sizeAligned = 0;\n          goto LAB_00081b04;\n        }\n        sizeAligned = sizeAligned - 0xc & 0xfffffff8;\n        *(uint *)(pointer5 + 4) = sizeAligned | *(uint *)(pointer5 + 4) & 1;\n        *(undefined4 *)(pointer5 + sizeAligned + 4) = 5;\n        *(undefined4 *)(pointer5 + sizeAligned + 8) = 5;\n        if (0xf < sizeAligned) {\n          _free_r(lock,pointer5 + 8);\n          pointer3 = __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem < pointer3) {\n      __malloc_max_sbrked_mem = pointer3;\n    }\n    if (__malloc_max_total_mem < pointer3) {\n      __malloc_max_total_mem = pointer3;\n    }\n    sizeAligned = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    pointer4 = DAT_2007046c;\n  }\nLAB_00081b04:\n  temp1 = sizeAligned - alignedSize;\n  if ((sizeAligned < alignedSize) || ((int)temp1 < 0x10)) {\n    __malloc_unlock(lock);\n    return (int *)0x0;\n  }\nLAB_00081b1a:\n  DAT_2007046c = pointer4 + alignedSize;\n  *(uint *)(pointer4 + 4) = alignedSize | 1;\n  *(uint *)(DAT_2007046c + 4) = temp1 | 1;\n  __malloc_unlock(lock);\n  return (int *)(pointer4 + 8);\n}\n\n",
            "renaming": {
                "FUN_00081810": "allocate_memory_00081810",
                "param_1": "lock",
                "param_2": "size",
                "puVar1": "pointer1",
                "iVar2": "index1",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "index2",
                "uVar6": "temp3",
                "uVar7": "temp4",
                "uVar8": "sizeAligned",
                "puVar9": "pointer2",
                "puVar10": "pointer3",
                "puVar11": "pointer4",
                "puVar12": "pointer5",
                "uVar13": "alignedSize",
                "puVar14": "returnPointer",
                "puVar15": "returnPointer2",
                "puVar16": "pointer6"
            },
            "calling": [
                "malloc",
                "__smakebuf_r",
                "__sfvwrite_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d48": {
            "entrypoint": "0x00081d48",
            "current_name": "copy_memory_00081d48",
            "code": "\nvoid * copyMemory_00081d48(void *destination,void *source,size_t size)\n\n{\n  undefined *destPtr;\n  undefined4 *srcPtr;\n  undefined4 *destPtr32;\n  undefined *destPtr8;\n  undefined4 *srcPtr32;\n  undefined *srcPtr8;\n  uint remainingSize;\n  uint alignmentSize;\n  bool isRemainingSizeValid;\n  \n  destPtr32 = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      alignmentSize = size - 4;\n      destPtr = (undefined *)destination;\n      if (3 < size) {\n        do {\n          srcPtr8 = (undefined *)source;\n          destPtr8 = destPtr;\n          isRemainingSizeValid = alignmentSize != 0;\n          alignmentSize = alignmentSize - 1;\n          *destPtr8 = *srcPtr8;\n          destPtr = destPtr8 + 1;\n          source = srcPtr8 + 1;\n        } while (isRemainingSizeValid);\n        destPtr8[1] = srcPtr8[1];\n        destPtr8[2] = srcPtr8[2];\n        destPtr8[3] = srcPtr8[3];\n        return destination;\n      }\n      goto LAB_00081dcc;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      alignmentSize = 4 - ((uint)destination & 3);\n      size = size - alignmentSize;\n      srcPtr = (undefined4 *)destination;\n      srcPtr32 = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        srcPtr32 = (undefined4 *)((int)source + 1);\n        srcPtr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      destPtr32 = srcPtr;\n      source = srcPtr32;\n      if ((alignmentSize & 2) != 0) {\n        source = (void *)((int)srcPtr32 + 2);\n        destPtr32 = (undefined4 *)((int)srcPtr + 2);\n        *(undefined2 *)srcPtr = *(undefined2 *)srcPtr32;\n      }\n    }\n  }\n  while (0x3f < size) {\n                    /* WARNING: Load size is inaccurate */\n    *destPtr32 = *source;\n    destPtr32[1] = *(undefined4 *)((int)source + 4);\n    destPtr32[2] = *(undefined4 *)((int)source + 8);\n    destPtr32[3] = *(undefined4 *)((int)source + 0xc);\n    destPtr32[4] = *(undefined4 *)((int)source + 0x10);\n    destPtr32[5] = *(undefined4 *)((int)source + 0x14);\n    destPtr32[6] = *(undefined4 *)((int)source + 0x18);\n    destPtr32[7] = *(undefined4 *)((int)source + 0x1c);\n    destPtr32[8] = *(undefined4 *)((int)source + 0x20);\n    destPtr32[9] = *(undefined4 *)((int)source + 0x24);\n    destPtr32[10] = *(undefined4 *)((int)source + 0x28);\n    destPtr32[0xb] = *(undefined4 *)((int)source + 0x2c);\n    destPtr32[0xc] = *(undefined4 *)((int)source + 0x30);\n    destPtr32[0xd] = *(undefined4 *)((int)source + 0x34);\n    destPtr32[0xe] = *(undefined4 *)((int)source + 0x38);\n    destPtr32[0xf] = *(undefined4 *)((int)source + 0x3c);\n    destPtr32 = destPtr32 + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    size = size - 0x40;\n  }\n  remainingSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *destPtr32 = *source;\n      destPtr32[1] = *(undefined4 *)((int)source + 4);\n      destPtr32[2] = *(undefined4 *)((int)source + 8);\n      destPtr32[3] = *(undefined4 *)((int)source + 0xc);\n      destPtr32 = destPtr32 + 4;\n      source = (void *)((int)source + 0x10);\n      isRemainingSizeValid = 0xf < remainingSize;\n      remainingSize = remainingSize - 0x10;\n    } while (isRemainingSizeValid);\n  }\n  alignmentSize = remainingSize + 0xc;\n  srcPtr32 = destPtr32;\n  srcPtr = (undefined4 *)source;\n  if (0xfffffff3 < remainingSize) {\n    do {\n      source = srcPtr + 1;\n      *srcPtr32 = *srcPtr;\n      isRemainingSizeValid = 3 < alignmentSize;\n      alignmentSize = alignmentSize - 4;\n      destPtr32 = srcPtr32 + 1;\n      srcPtr32 = srcPtr32 + 1;\n      srcPtr = (undefined4 *)source;\n    } while (isRemainingSizeValid);\n  }\nLAB_00081dcc:\n  if (alignmentSize + 4 != 0) {\n    srcPtr = destPtr32;\n    srcPtr32 = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((alignmentSize & 1) != 0) {\n      srcPtr32 = (undefined4 *)((int)source + 1);\n      srcPtr = (undefined4 *)((int)destPtr32 + 1);\n      *(undefined *)destPtr32 = *source;\n    }\n    if ((alignmentSize + 4 & 2) != 0) {\n      *(undefined2 *)srcPtr = *(undefined2 *)srcPtr32;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00081d48": "copy_memory_00081d48",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "destPtr",
                "puVar2": "srcPtr",
                "puVar3": "destPtr32",
                "puVar4": "destPtr8",
                "puVar5": "srcPtr32",
                "puVar6": "srcPtr8",
                "uVar7": "remainingSize",
                "uVar8": "alignmentSize",
                "bVar9": "isRemainingSizeValid"
            },
            "calling": [
                "__sfvwrite_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e34": {
            "entrypoint": "0x00081e34",
            "current_name": "copy_reverse_00081e34",
            "code": "\nvoid * copy_reverse_00081e34(void *destination,void *source,size_t size)\n\n{\n  int index;\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  undefined4 *temp_ptr;\n  undefined *end_ptr;\n  uint remaining_size;\n  undefined *dest_end_ptr;\n  uint remaining_bytes;\n  \n  if ((source < destination) && (end_ptr = (undefined *)((int)source + size), destination < end_ptr)) {\n    dest_end_ptr = (undefined *)((int)destination + size);\n    index = size - 1;\n    if (size != 0) {\n      do {\n        end_ptr = end_ptr + -1;\n        index = index + -1;\n        dest_end_ptr = dest_end_ptr + -1;\n        *dest_end_ptr = *end_ptr;\n      } while (index != -1);\n    }\n    return destination;\n  }\n  dest_ptr = (undefined4 *)destination;\n  if (size < 0x10) {\n    if (size == 0) {\n      return destination;\n    }\n  }\n  else if ((((uint)destination | (uint)source) & 3) == 0) {\n    src_ptr = (undefined4 *)source;\n    do {\n      temp_ptr = dest_ptr + 4;\n      *dest_ptr = *src_ptr;\n      dest_ptr[1] = src_ptr[1];\n      dest_ptr[2] = src_ptr[2];\n      dest_ptr[3] = src_ptr[3];\n      dest_ptr = temp_ptr;\n      src_ptr = src_ptr + 4;\n    } while (temp_ptr != (undefined4 *)((int)destination + (size - 0x10 & 0xfffffff0) + 0x10));\n    remaining_bytes = size & 0xf;\n    index = ((size - 0x10 >> 4) + 1) * 0x10;\n    source = (void *)((int)source + index);\n    dest_ptr = (undefined4 *)(index + (int)destination);\n    remaining_size = remaining_bytes;\n    src_ptr = dest_ptr;\n    temp_ptr = (undefined4 *)source;\n    if (3 < remaining_bytes) {\n      do {\n        remaining_size = remaining_size - 4;\n        *src_ptr = *temp_ptr;\n        src_ptr = src_ptr + 1;\n        temp_ptr = temp_ptr + 1;\n      } while (3 < remaining_size);\n      index = (remaining_bytes - 4 & 0xfffffffc) + 4;\n      dest_ptr = (undefined4 *)((int)dest_ptr + index);\n      source = (void *)((int)source + index);\n      remaining_bytes = size & 3;\n    }\n    size = remaining_bytes;\n    if (size == 0) {\n      return destination;\n    }\n  }\n  src_ptr = dest_ptr;\n  do {\n                    /* WARNING: Load size is inaccurate */\n    temp_ptr = (undefined4 *)((int)src_ptr + 1);\n    *(undefined *)src_ptr = *source;\n    source = (undefined4 *)((int)source + 1);\n    src_ptr = temp_ptr;\n  } while (temp_ptr != (undefined4 *)(size + (int)dest_ptr));\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00081e34": "copy_reverse_00081e34",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "iVar1": "index",
                "puVar2": "dest_ptr",
                "puVar3": "src_ptr",
                "puVar4": "temp_ptr",
                "puVar5": "end_ptr",
                "puVar7": "dest_end_ptr",
                "uVar6": "remaining_size",
                "uVar8": "remaining_bytes"
            },
            "calling": [
                "__sfvwrite_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f00": {
            "entrypoint": "0x00081f00",
            "current_name": "fill_memory_00081f00",
            "code": "\nvoid * fillMemory_00081f00(void *ptr,int value,size_t size)\n\n{\n  uint *dest;\n  uint *src;\n  uint *temp;\n  uint pattern;\n  uint remainingSize;\n  bool isZero;\n  \n  src = (uint *)ptr;\n  if (((uint)ptr & 3) != 0) {\n    isZero = size == 0;\n    dest = (uint *)ptr;\n    size = size - 1;\n    if (isZero) {\n      return ptr;\n    }\n    while( true ) {\n      src = (uint *)((int)dest + 1);\n      *(char *)dest = (char)value;\n      if (((uint)src & 3) == 0) break;\n      isZero = size == 0;\n      dest = src;\n      size = size - 1;\n      if (isZero) {\n        return ptr;\n      }\n    }\n  }\n  if (3 < size) {\n    pattern = value & 0xffU | (value & 0xffU) << 8;\n    pattern = pattern | pattern << 0x10;\n    remainingSize = size;\n    dest = src;\n    if (0xf < size) {\n      remainingSize = size - 0x10;\n      do {\n        *dest = pattern;\n        dest[1] = pattern;\n        dest[2] = pattern;\n        dest[3] = pattern;\n        dest = dest + 4;\n      } while (dest != (uint *)((int)src + (remainingSize & 0xfffffff0) + 0x10));\n      size = size & 0xf;\n      src = src + ((remainingSize >> 4) + 1) * 4;\n      remainingSize = size;\n      dest = src;\n      if (size < 4) goto LAB_00081f7c;\n    }\n    do {\n      size = size - 4;\n      *src = pattern;\n      src = src + 1;\n    } while (3 < size);\n    src = (uint *)((int)dest + (remainingSize - 4 & 0xfffffffc) + 4);\n    size = remainingSize & 3;\n  }\nLAB_00081f7c:\n  if (size != 0) {\n    dest = src;\n    do {\n      temp = (uint *)((int)dest + 1);\n      *(char *)dest = (char)value;\n      dest = temp;\n    } while (temp != (uint *)(size + (int)src));\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_00081f00": "fill_memory_00081f00",
                "__s": "ptr",
                "__c": "value",
                "__n": "size",
                "puVar1": "dest",
                "puVar2": "src",
                "puVar3": "temp",
                "uVar4": "pattern",
                "uVar5": "remainingSize",
                "bVar6": "isZero"
            },
            "calling": [
                "__sinit",
                "RingBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f94": {
            "entrypoint": "0x00081f94",
            "current_name": "FUNC_00081f94",
            "code": "\nvoid FUNC_00081f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f94": "FUNC_00081f94"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r",
                "_realloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f98": {
            "entrypoint": "0x00081f98",
            "current_name": "FUNC_00081f98",
            "code": "\nvoid FUNC_00081f98(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f98": "FUNC_00081f98"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r",
                "_realloc_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f9c": {
            "entrypoint": "0x00081f9c",
            "current_name": "reallocate_memory_00081f9c",
            "code": "\nvoid * reallocate_memory_00081f9c(void *input_ptr,size_t new_size)\n\n{\n  void *new_ptr;\n  \n  new_ptr = (void *)_realloc_r(memory_region,input_ptr,new_size);\n  return new_ptr;\n}\n\n",
            "renaming": {
                "FUN_00081f9c": "reallocate_memory_00081f9c",
                "__ptr": "input_ptr",
                "__size": "new_size",
                "pvVar1": "new_ptr",
                "_impure_ptr": "memory_region"
            },
            "calling": [
                "changeBuffer"
            ],
            "called": [
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081fac": {
            "entrypoint": "0x00081fac",
            "current_name": "allocate_memory_00081fac",
            "code": "\nint * allocateMemory_00081fac(undefined4 *allocator,int *existingMemory,uint size)\n\n{\n  int offset;\n  int *newMemory;\n  uint allocatedSize;\n  size_t copySize;\n  uint existingSize;\n  int prevBlock;\n  int *copyBuffer;\n  uint remainingSize;\n  uint adjustedSize;\n  int *blockToReturn;\n  \n  if (existingMemory == (int *)0x0) {\n    newMemory = (int *)_malloc_r(allocator,size);\n    return newMemory;\n  }\n  __malloc_lock();\n  existingSize = existingMemory[-1];\n  remainingSize = existingSize & 0xfffffffc;\n  newMemory = existingMemory + -2;\n  if (size + 0xb < 0x17) {\n    adjustedSize = 0x10;\n  }\n  else {\n    adjustedSize = size + 0xb & 0xfffffff8;\n    if ((int)adjustedSize < 0) goto LAB_00082078;\n  }\n  if (adjustedSize < size) {\nLAB_00082078:\n    *allocator = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)remainingSize < (int)adjustedSize) {\n    offset = (int)newMemory + remainingSize;\n    if (DAT_2007046c == offset) {\n      allocatedSize = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n      offset = DAT_2007046c;\n      if ((int)(adjustedSize + 0x10) <= (int)(allocatedSize + remainingSize)) {\n        DAT_2007046c = (int)newMemory + adjustedSize;\n        *(uint *)(DAT_2007046c + 4) = (allocatedSize + remainingSize) - adjustedSize | 1;\n        existingMemory[-1] = adjustedSize | existingMemory[-1] & 1U;\n        __malloc_unlock(allocator);\n        return existingMemory;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(offset + 4) & 0xfffffffe) + offset + 4) & 1) == 0) {\n      allocatedSize = *(uint *)(offset + 4) & 0xfffffffc;\n      if ((int)adjustedSize <= (int)(allocatedSize + remainingSize)) {\n        prevBlock = *(int *)(offset + 0xc);\n        offset = *(int *)(offset + 8);\n        *(int *)(offset + 0xc) = prevBlock;\n        *(int *)(prevBlock + 8) = offset;\n        remainingSize = allocatedSize + remainingSize;\n        goto LAB_00082088;\n      }\n    }\n    else {\n      allocatedSize = 0;\n      offset = 0;\n    }\n    if (-1 < (int)(existingSize << 0x1f)) {\n      blockToReturn = (int *)((int)newMemory - existingMemory[-2]);\n      existingSize = (blockToReturn[1] & 0xfffffffcU) + remainingSize;\n      if (offset != 0) {\n        if (offset == DAT_2007046c) {\n          if ((int)(adjustedSize + 0x10) <= (int)(allocatedSize + existingSize)) {\n            newMemory = blockToReturn + 2;\n            offset = *newMemory;\n            prevBlock = blockToReturn[3];\n            copySize = remainingSize - 4;\n            *(int *)(offset + 0xc) = prevBlock;\n            *(int *)(prevBlock + 8) = offset;\n            if (copySize < 0x25) {\n              copyBuffer = newMemory;\n              if (0x13 < copySize) {\n                blockToReturn[2] = *existingMemory;\n                blockToReturn[3] = existingMemory[1];\n                if (copySize < 0x1c) {\n                  existingMemory = existingMemory + 2;\n                  copyBuffer = blockToReturn + 4;\n                }\n                else {\n                  blockToReturn[4] = existingMemory[2];\n                  blockToReturn[5] = existingMemory[3];\n                  if (copySize == 0x24) {\n                    blockToReturn[6] = existingMemory[4];\n                    copyBuffer = existingMemory + 5;\n                    existingMemory = existingMemory + 6;\n                    blockToReturn[7] = *copyBuffer;\n                    copyBuffer = blockToReturn + 8;\n                  }\n                  else {\n                    existingMemory = existingMemory + 4;\n                    copyBuffer = blockToReturn + 6;\n                  }\n                }\n              }\n              *copyBuffer = *existingMemory;\n              copyBuffer[1] = existingMemory[1];\n              copyBuffer[2] = existingMemory[2];\n            }\n            else {\n              memmove(newMemory,existingMemory,copySize);\n            }\n            DAT_2007046c = (int)blockToReturn + adjustedSize;\n            *(uint *)(DAT_2007046c + 4) = (allocatedSize + existingSize) - adjustedSize | 1;\n            blockToReturn[1] = adjustedSize | blockToReturn[1] & 1U;\n            __malloc_unlock(allocator);\n            return newMemory;\n          }\n        }\n        else {\n          allocatedSize = allocatedSize + existingSize;\n          if ((int)adjustedSize <= (int)allocatedSize) {\n            prevBlock = *(int *)(offset + 0xc);\n            offset = *(int *)(offset + 8);\n            *(int *)(offset + 0xc) = prevBlock;\n            *(int *)(prevBlock + 8) = offset;\n            copyBuffer = blockToReturn + 2;\n            offset = *copyBuffer;\n            prevBlock = blockToReturn[3];\n            copySize = remainingSize - 4;\n            *(int *)(offset + 0xc) = prevBlock;\n            *(int *)(prevBlock + 8) = offset;\n            remainingSize = allocatedSize;\n            if (copySize < 0x25) {\n              newMemory = copyBuffer;\n              if (0x13 < copySize) {\n                blockToReturn[2] = *existingMemory;\n                blockToReturn[3] = existingMemory[1];\n                if (copySize < 0x1c) {\n                  existingMemory = existingMemory + 2;\n                  newMemory = blockToReturn + 4;\n                }\n                else {\n                  blockToReturn[4] = existingMemory[2];\n                  blockToReturn[5] = existingMemory[3];\n                  if (copySize == 0x24) {\n                    blockToReturn[6] = existingMemory[4];\n                    newMemory = existingMemory + 5;\n                    existingMemory = existingMemory + 6;\n                    blockToReturn[7] = *newMemory;\n                    newMemory = blockToReturn + 8;\n                  }\n                  else {\n                    existingMemory = existingMemory + 4;\n                    newMemory = blockToReturn + 6;\n                  }\n                }\n              }\n              *newMemory = *existingMemory;\n              newMemory[1] = existingMemory[1];\n              newMemory[2] = existingMemory[2];\n              existingSize = blockToReturn[1];\n              newMemory = blockToReturn;\n              existingMemory = copyBuffer;\n            }\n            else {\n              memmove(copyBuffer,existingMemory,copySize);\n              existingSize = blockToReturn[1];\n              newMemory = blockToReturn;\n              existingMemory = copyBuffer;\n            }\n            goto LAB_00082088;\n          }\n        }\n      }\n      if ((int)adjustedSize <= (int)existingSize) {\n        copyBuffer = blockToReturn + 2;\n        offset = *copyBuffer;\n        prevBlock = blockToReturn[3];\n        copySize = remainingSize - 4;\n        *(int *)(offset + 0xc) = prevBlock;\n        *(int *)(prevBlock + 8) = offset;\n        remainingSize = existingSize;\n        if (copySize < 0x25) {\n          newMemory = copyBuffer;\n          if (0x13 < copySize) {\n            blockToReturn[2] = *existingMemory;\n            blockToReturn[3] = existingMemory[1];\n            if (copySize < 0x1c) {\n              existingMemory = existingMemory + 2;\n              newMemory = blockToReturn + 4;\n            }\n            else {\n              blockToReturn[4] = existingMemory[2];\n              blockToReturn[5] = existingMemory[3];\n              if (copySize == 0x24) {\n                blockToReturn[6] = existingMemory[4];\n                newMemory = existingMemory + 5;\n                existingMemory = existingMemory + 6;\n                blockToReturn[7] = *newMemory;\n                newMemory = blockToReturn + 8;\n              }\n              else {\n                existingMemory = existingMemory + 4;\n                newMemory = blockToReturn + 6;\n              }\n            }\n          }\n          *newMemory = *existingMemory;\n          newMemory[1] = existingMemory[1];\n          newMemory[2] = existingMemory[2];\n          existingSize = blockToReturn[1];\n          newMemory = blockToReturn;\n          existingMemory = copyBuffer;\n        }\n        else {\n          memmove(copyBuffer,existingMemory,copySize);\n          existingSize = blockToReturn[1];\n          newMemory = blockToReturn;\n          existingMemory = copyBuffer;\n        }\n        goto LAB_00082088;\n      }\n    }\n    blockToReturn = (int *)_malloc_r(allocator,size);\n    if (blockToReturn == (int *)0x0) goto LAB_000820a0;\n    existingSize = existingMemory[-1];\n    if (blockToReturn + -2 != (int *)((existingSize & 0xfffffffe) + (int)newMemory)) {\n      copySize = remainingSize - 4;\n      if (copySize < 0x25) {\n        newMemory = existingMemory;\n        copyBuffer = blockToReturn;\n        if (0x13 < copySize) {\n          *blockToReturn = *existingMemory;\n          blockToReturn[1] = existingMemory[1];\n          if (copySize < 0x1c) {\n            newMemory = existingMemory + 2;\n            copyBuffer = blockToReturn + 2;\n          }\n          else {\n            blockToReturn[2] = existingMemory[2];\n            blockToReturn[3] = existingMemory[3];\n            if (copySize == 0x24) {\n              blockToReturn[4] = existingMemory[4];\n              blockToReturn[5] = existingMemory[5];\n              newMemory = existingMemory + 6;\n              copyBuffer = blockToReturn + 6;\n            }\n            else {\n              newMemory = existingMemory + 4;\n              copyBuffer = blockToReturn + 4;\n            }\n          }\n        }\n        *copyBuffer = *newMemory;\n        copyBuffer[1] = newMemory[1];\n        copyBuffer[2] = newMemory[2];\n      }\n      else {\n        memmove(blockToReturn,existingMemory,copySize);\n      }\n      _free_r(allocator,existingMemory);\n      goto LAB_000820a0;\n    }\n    remainingSize = remainingSize + (blockToReturn[-1] & 0xfffffffcU);\n  }\nLAB_00082088:\n  allocatedSize = remainingSize - adjustedSize;\n  blockToReturn = existingMemory;\n  if (allocatedSize < 0x10) {\n    newMemory[1] = existingSize & 1 | remainingSize;\n    *(uint *)((int)newMemory + remainingSize + 4) = *(uint *)((int)newMemory + remainingSize + 4) | 1;\n  }\n  else {\n    newMemory[1] = existingSize & 1 | adjustedSize;\n    *(uint *)((int)newMemory + adjustedSize + 4) = allocatedSize | 1;\n    *(uint *)((int)newMemory + allocatedSize + adjustedSize + 4) = *(uint *)((int)newMemory + allocatedSize + adjustedSize + 4) | 1;\n    _free_r(allocator,(int)newMemory + adjustedSize + 8);\n  }\nLAB_000820a0:\n  __malloc_unlock(allocator);\n  return blockToReturn;\n}\n\n",
            "renaming": {
                "FUN_00081fac": "allocate_memory_00081fac",
                "param_1": "allocator",
                "param_2": "existingMemory",
                "param_3": "size",
                "iVar1": "offset",
                "piVar2": "newMemory",
                "uVar3": "allocatedSize",
                "sVar4": "copySize",
                "uVar5": "existingSize",
                "iVar6": "prevBlock",
                "piVar7": "copyBuffer",
                "uVar8": "remainingSize",
                "uVar9": "adjustedSize",
                "piVar10": "blockToReturn"
            },
            "calling": [
                "__sfvwrite_r",
                "realloc"
            ],
            "called": [
                "memmove",
                "_malloc_r",
                "__malloc_unlock",
                "__malloc_lock",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008236c": {
            "entrypoint": "0x0008236c",
            "current_name": "allocate_memory_0008236c",
            "code": "\nvoid allocateMemory_0008236c(int *errorFlag,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *errorFlag = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008236c": "allocate_memory_0008236c",
                "param_1": "errorFlag",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082390": {
            "entrypoint": "0x00082390",
            "current_name": "compare_strings_00082390",
            "code": "\nint compareStrings_00082390(char *string1,char *string2)\n\n{\n  uint *ptr1;\n  int result;\n  byte *bytePtr1;\n  byte *bytePtr2;\n  uint *ptr2;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  \n  if ((((uint)string1 | (uint)string2) & 7) != 0) {\n    ptr1 = (uint *)string1;\n    if (((uint)string1 & 3) != 0) {\n      ptr1 = (uint *)((uint)string1 & 0xfffffffc) + 1;\n      temp1 = *(uint *)((uint)string1 & 0xfffffffc);\n      bytePtr1 = (byte *)string2;\n      if (((uint)string1 & 1) == 0) {\nLAB_00082410:\n        bytePtr2 = bytePtr1 + 1;\n        temp2 = temp1 >> 0x10 & 0xff;\n        result = temp2 - *bytePtr1;\n        if (result != 0) {\n          return result;\n        }\n        if (temp2 == 0) {\n          return 0;\n        }\n      }\n      else {\n        bytePtr2 = (byte *)string2;\n        if (((uint)string1 & 2) == 0) {\n          bytePtr1 = (byte *)(string2 + 1);\n          temp2 = temp1 >> 8 & 0xff;\n          result = temp2 - (byte)*string2;\n          if (result != 0) {\n            return result;\n          }\n          if (temp2 == 0) {\n            return 0;\n          }\n          goto LAB_00082410;\n        }\n      }\n      string2 = (char *)(bytePtr2 + 1);\n      result = (temp1 >> 0x18) - (uint)*bytePtr2;\n      if ((result != 0) || (temp1 >> 0x18 == 0)) {\n        return result;\n      }\n    }\n    temp1 = (uint)string2 & 3;\n    if (temp1 != 0) {\n      ptr2 = (uint *)((uint)string2 & 0xfffffffc);\n      if (temp1 == 2) {\n        temp1 = *ptr2;\n        do {\n          ptr2 = ptr2 + 1;\n          temp3 = *ptr1;\n          temp1 = temp1 >> 0x10;\n          temp4 = temp3 + 0xfefefeff & ~temp3;\n          temp5 = temp4 & 0x80808080;\n          temp2 = temp3 & 0xffff;\n          if ((temp4 & 0x8080) != 0 || temp2 != temp1) goto LAB_0008258e;\n          temp1 = *ptr2;\n          temp2 = temp2 ^ temp3;\n          temp3 = temp1 * 0x10000;\n          ptr1 = ptr1 + 1;\n        } while (temp5 == 0 && temp2 == temp3);\n      }\n      else if (temp1 < 2) {\n        temp1 = *ptr2;\n        do {\n          ptr2 = ptr2 + 1;\n          temp3 = *ptr1;\n          temp1 = temp1 >> 8;\n          temp4 = temp3 + 0xfefefeff & ~temp3;\n          temp5 = temp4 & 0x80808080;\n          temp2 = temp3 & 0xffffff;\n          if ((temp4 & 0x808080) != 0 || temp2 != temp1) goto LAB_0008258e;\n          temp1 = *ptr2;\n          temp2 = temp2 ^ temp3;\n          temp3 = temp1 * 0x1000000;\n          ptr1 = ptr1 + 1;\n        } while (temp5 == 0 && temp2 == temp3);\n      }\n      else {\n        temp1 = *ptr2;\n        do {\n          ptr2 = ptr2 + 1;\n          temp3 = *ptr1;\n          temp1 = temp1 >> 0x18;\n          temp4 = temp3 + 0xfefefeff & ~temp3;\n          temp5 = temp4 & 0x80808080;\n          temp2 = temp3 & 0xff;\n          if ((temp4 & 0x80) != 0 || temp2 != temp1) goto LAB_0008258e;\n          temp1 = *ptr2;\n          temp2 = temp2 ^ temp3;\n          temp3 = temp1 * 0x100;\n          ptr1 = ptr1 + 1;\n        } while (temp5 == 0 && temp2 == temp3);\n      }\n      temp2 = temp2 << 0x18 | (temp2 >> 8 & 0xff) << 0x10 | (temp2 >> 0x10 & 0xff) << 8 |\n              temp2 >> 0x18;\n      temp1 = (temp3 >> 8 & 0xff) << 0x10 | (temp3 >> 0x10 & 0xff) << 8 | temp3 >> 0x18;\n      goto LAB_0008259e;\n    }\n    string1 = (char *)ptr1;\n    ptr2 = (uint *)string2;\n    if (((uint)ptr1 & 4) != 0) {\n      string1 = (char *)(ptr1 + 1);\n      temp1 = *ptr1;\n      ptr2 = (uint *)((int)string2 + 4);\n      temp3 = *(uint *)string2;\n      temp5 = temp1 + 0xfefefeff & ~temp1 & 0x80808080;\n      if (temp1 != temp3 || temp5 != 0) {\nLAB_0008259a:\n        temp2 = temp1 << 0x18 | (temp1 >> 8 & 0xff) << 0x10 | (temp1 >> 0x10 & 0xff) << 8 |\n                temp1 >> 0x18;\n        temp1 = temp3 << 0x18 | (temp3 >> 8 & 0xff) << 0x10 | (temp3 >> 0x10 & 0xff) << 8 |\n                temp3 >> 0x18;\n        goto LAB_0008259e;\n      }\n    }\n    string2 = (char *)ptr2;\n    if (((uint)ptr2 & 4) != 0) {\n      temp1 = *ptr2;\n      ptr1 = ptr2 + 1;\n      do {\n        temp2 = *(uint *)string1;\n        temp3 = *(uint *)((int)string1 + 4);\n        temp5 = temp2 + 0xfefefeff & ~temp2 & 0x80808080;\n        if (temp2 != temp1 || temp5 != 0) goto LAB_0008258e;\n        temp4 = *ptr1;\n        temp1 = ptr1[1];\n        temp5 = temp3 + 0xfefefeff & ~temp3 & 0x80808080;\n        string1 = (char *)((int)string1 + 8);\n        ptr1 = ptr1 + 2;\n      } while (temp3 == temp4 && temp5 == 0);\n      temp2 = temp3 << 0x18 | (temp3 >> 8 & 0xff) << 0x10 | (temp3 >> 0x10 & 0xff) << 8 |\n              temp3 >> 0x18;\n      temp1 = temp4 << 0x18 | (temp4 >> 8 & 0xff) << 0x10 | (temp4 >> 0x10 & 0xff) << 8 |\n              temp4 >> 0x18;\n      goto LAB_0008259e;\n    }\n  }\n  do {\n    temp1 = *(uint *)string1;\n    temp2 = *(uint *)((int)string1 + 4);\n    temp3 = *(uint *)string2;\n    temp4 = *(uint *)((int)string2 + 4);\n    temp5 = temp1 + 0xfefefeff & ~temp1 & 0x80808080;\n    if (temp1 != temp3 || temp5 != 0) goto LAB_0008259a;\n    temp5 = temp2 + 0xfefefeff & ~temp2 & 0x80808080;\n    string1 = (char *)((int)string1 + 8);\n    string2 = (char *)((int)string2 + 8);\n  } while (temp2 == temp4 && temp5 == 0);\n  temp2 = temp2 << 0x18 | (temp2 >> 8 & 0xff) << 0x10 | (temp2 >> 0x10 & 0xff) << 8 | temp2 >> 0x18;\n  temp1 = temp4 << 0x18 | (temp4 >> 8 & 0xff) << 0x10 | (temp4 >> 0x10 & 0xff) << 8 | temp4 >> 0x18;\nLAB_0008259e:\n  temp3 = temp5 << 0x18 | (temp5 >> 8 & 0xff) << 0x10 | (temp5 >> 0x10 & 0xff) << 8 |\n          temp5 >> 0x18;\n  if (temp3 != 0) {\n    temp3 = 0x18 - LZCOUNT(temp3);\n    temp2 = temp2 >> (temp3 & 0xff);\n    temp1 = temp1 >> (temp3 & 0xff);\n  }\n  result = 1;\n  if (temp2 <= temp1) {\n    result = -(uint)(temp2 < temp1);\n  }\n  return result;\nLAB_0008258e:\n  temp2 = temp2 << 0x18 | (temp2 >> 8 & 0xff) << 0x10 | (temp2 >> 0x10 & 0xff) << 8 | temp2 >> 0x18;\n  temp1 = temp1 << 0x18 | (temp1 >> 8 & 0xff) << 0x10 | (temp1 >> 0x10 & 0xff) << 8 | temp1 >> 0x18;\n  goto LAB_0008259e;\n}\n\n",
            "renaming": {
                "FUN_00082390": "compare_strings_00082390",
                "__s1": "string1",
                "__s2": "string2",
                "puVar1": "ptr1",
                "iVar2": "result",
                "pbVar3": "bytePtr1",
                "pbVar4": "bytePtr2",
                "puVar5": "ptr2",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "uVar8": "temp3",
                "uVar9": "temp4",
                "uVar10": "temp5"
            },
            "calling": [
                "equals"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825cc": {
            "entrypoint": "0x000825cc",
            "current_name": "copy_string_000825cc",
            "code": "\nchar * copyString_000825cc(char *destination,char *source)\n\n{\n  char currentChar;\n  ushort currentValue;\n  uint *nextPointer;\n  uint *currentPointer;\n  uint nextValue;\n  uint currentValue;\n  uint *destinationPointer;\n  uint *destinationPointer;\n  char *destinationPointer;\n  bool isValueZero;\n  \n  destinationPointer = destination;\n  if ((((uint)destination ^ (uint)source) & 3) != 0) {\n    do {\n      currentChar = *source;\n      *destinationPointer = currentChar;\n      source = source + 1;\n      destinationPointer = destinationPointer + 1;\n    } while (currentChar != '\\0');\n    return destination;\n  }\n  destinationPointer = (uint *)destination;\n  if (((uint)source & 3) != 0) {\n    currentPointer = (uint *)source;\n    if (((uint)source & 1) != 0) {\n      currentPointer = (uint *)(source + 1);\n      currentChar = *source;\n      destinationPointer = (uint *)(destination + 1);\n      *destination = currentChar;\n      if (currentChar == '\\0') {\n        return destination;\n      }\n    }\n    source = (char *)currentPointer;\n    if (((uint)currentPointer & 2) != 0) {\n      source = (char *)((int)currentPointer + 2);\n      currentValue = *(ushort *)currentPointer;\n      isValueZero = (currentValue & 0xff) == 0;\n      if (isValueZero) {\n        *(char *)destinationPointer = (char)currentValue;\n      }\n      else {\n        *(ushort *)destinationPointer = currentValue;\n        isValueZero = (currentValue & 0xff00) == 0;\n        destinationPointer = (uint *)((int)destinationPointer + 2);\n      }\n      if (isValueZero) {\n        return destination;\n      }\n    }\n  }\n  nextValue = *(uint *)source;\n  currentPointer = (uint *)((int)source + 4);\n  destinationPointer = destinationPointer;\n  if (((uint)source & 4) != 0) {\n    if ((nextValue + 0xfefefeff & ~nextValue & 0x80808080) != 0) goto LAB_00082630;\n    destinationPointer = destinationPointer + 1;\n    *destinationPointer = nextValue;\n    currentPointer = (uint *)((int)source + 8);\n    nextValue = *(uint *)((int)source + 4);\n  }\n  while( true ) {\n    nextPointer = currentPointer + 1;\n    currentValue = *currentPointer;\n    destinationPointer = destinationPointer;\n    if ((nextValue + 0xfefefeff & ~nextValue & 0x80808080) != 0) break;\n    destinationPointer = destinationPointer + 1;\n    *destinationPointer = nextValue;\n    nextValue = currentValue;\n    if ((currentValue + 0xfefefeff & ~currentValue & 0x80808080) != 0) break;\n    currentPointer = currentPointer + 2;\n    nextValue = *nextPointer;\n    destinationPointer = destinationPointer + 2;\n    *destinationPointer = currentValue;\n  }\nLAB_00082630:\n  do {\n    *(char *)destinationPointer = (char)nextValue;\n    currentValue = nextValue & 0xff;\n    nextValue = nextValue >> 8 | nextValue << 0x18;\n    destinationPointer = (uint *)((int)destinationPointer + 1);\n  } while (currentValue != 0);\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_000825cc": "copy_string_000825cc",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "currentChar",
                "uVar2": "currentValue",
                "puVar3": "nextPointer",
                "puVar4": "currentPointer",
                "uVar5": "nextValue",
                "uVar6": "currentValue",
                "puVar7": "destinationPointer",
                "puVar8": "destinationPointer",
                "pcVar9": "destinationPointer",
                "bVar10": "isValueZero"
            },
            "calling": [
                "copy",
                "concat",
                "move"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082688": {
            "entrypoint": "0x00082688",
            "current_name": "find_first_nonzero_byte_index_00082688",
            "code": "\nsize_t find_first_nonzero_byte_index_00082688(char *input_string)\n\n{\n  size_t shift_bytes;\n  uint *ptr_aligned_input;\n  uint word_value;\n  bool is_zero_byte;\n  \n  ptr_aligned_input = (uint *)((uint)input_string & 0xfffffffc);\n  shift_bytes = -((uint)input_string & 3);\n  word_value = *ptr_aligned_input;\n  if (((uint)input_string & 3) != 0) {\n    word_value = word_value | 0xffffffffU >> ((shift_bytes + 4 & 0x1f) << 3);\n  }\n  while (ptr_aligned_input = ptr_aligned_input + 1, (word_value + 0xfefefeff & ~word_value & 0x80808080) == 0) {\n    shift_bytes = shift_bytes + 4;\n    word_value = *ptr_aligned_input;\n  }\n  is_zero_byte = (word_value & 0xff) == 0;\n  if (!is_zero_byte) {\n    shift_bytes = shift_bytes + 1;\n    is_zero_byte = (word_value & 0xff00) == 0;\n  }\n  if (!is_zero_byte) {\n    shift_bytes = shift_bytes + 1;\n    is_zero_byte = (word_value & 0xff0000) == 0;\n  }\n  if (!is_zero_byte) {\n    shift_bytes = shift_bytes + 1;\n  }\n  return shift_bytes;\n}\n\n",
            "renaming": {
                "FUN_00082688": "find_first_nonzero_byte_index_00082688",
                "__s": "input_string",
                "sVar1": "shift_bytes",
                "puVar2": "ptr_aligned_input",
                "uVar3": "word_value",
                "bVar4": "is_zero_byte"
            },
            "calling": [
                "String",
                "_vfiprintf_r",
                "write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000826e8": {
            "entrypoint": "0x000826e8",
            "current_name": "parse_number_000826e8",
            "code": "\nuint parseNumber_000826e8(undefined4 *result,byte *input,byte **remaining,uint base)\n\n{\n  byte charAttributes;\n  byte isNegative;\n  uint parsedNumber;\n  byte *currentChar;\n  uint currentCharCode;\n  byte *nextChar;\n  int digitValue;\n  int parseResult;\n  uint maxDigits;\n  uint maxValue;\n  \n  currentChar = input;\n  do {\n    nextChar = currentChar;\n    currentChar = nextChar + 1;\n    currentCharCode = (uint)*nextChar;\n    charAttributes = *(byte *)(__ctype_ptr__ + currentCharCode + 1);\n    isNegative = charAttributes & 8;\n  } while ((charAttributes & 8) != 0);\n  if (currentCharCode == 0x2d) {\n    currentChar = nextChar + 2;\n    currentCharCode = (uint)nextChar[1];\n    isNegative = 1;\n  }\n  else if (currentCharCode == 0x2b) {\n    currentCharCode = (uint)nextChar[1];\n    currentChar = nextChar + 2;\n  }\n  if ((base & 0xffffffef) == 0) {\n    if (currentCharCode == 0x30) {\n      if ((*currentChar & 0xdf) == 0x58) {\n        currentCharCode = (uint)currentChar[1];\n        base = 0x10;\n        currentChar = currentChar + 2;\n      }\n      else if (base == 0) {\n        base = 8;\n      }\n    }\n    else if (base == 0) {\n      base = 10;\n    }\n  }\n  if (isNegative == 0) {\n    maxValue = 0x7fffffff;\n  }\n  else {\n    maxValue = 0x80000000;\n  }\n  maxDigits = maxValue / base;\n  parseResult = 0;\n  parsedNumber = 0;\n  do {\n    charAttributes = *(byte *)(__ctype_ptr__ + currentCharCode + 1);\n    if ((charAttributes & 4) == 0) {\n      if ((charAttributes & 3) == 0) break;\n      if ((charAttributes & 3) == 1) {\n        digitValue = 0x37;\n      }\n      else {\n        digitValue = 0x57;\n      }\n      digitValue = currentCharCode - digitValue;\n    }\n    else {\n      digitValue = currentCharCode - 0x30;\n    }\n    if ((int)base <= digitValue) break;\n    if (parseResult != -1) {\n      if ((maxDigits <= parsedNumber && parsedNumber != maxDigits) ||\n         ((parsedNumber == maxDigits && ((int)(maxValue - base * maxDigits) < digitValue)))) {\n        parseResult = -1;\n      }\n      else {\n        parsedNumber = base * parsedNumber + digitValue;\n        parseResult = 1;\n      }\n    }\n    currentCharCode = (uint)*currentChar;\n    currentChar = currentChar + 1;\n  } while( true );\n  if (parseResult == -1) {\n    if (isNegative == 0) {\n      parsedNumber = 0x7fffffff;\n    }\n    else {\n      parsedNumber = 0x80000000;\n    }\n    *result = 0x22;\n    if (remaining == (byte **)0x0) {\n      return parsedNumber;\n    }\n  }\n  else {\n    if (isNegative != 0) {\n      parsedNumber = -parsedNumber;\n    }\n    if (remaining == (byte **)0x0) {\n      return parsedNumber;\n    }\n    if (parseResult == 0) goto LAB_0008278c;\n  }\n  input = currentChar + -1;\nLAB_0008278c:\n  *remaining = input;\n  return parsedNumber;\n}\n\n",
            "renaming": {
                "FUN_000826e8": "parse_number_000826e8",
                "param_1": "result",
                "param_2": "input",
                "param_3": "remaining",
                "param_4": "base",
                "bVar1": "charAttributes",
                "bVar2": "isNegative",
                "uVar3": "parsedNumber",
                "pbVar4": "currentChar",
                "uVar5": "currentCharCode",
                "pbVar6": "nextChar",
                "iVar7": "digitValue",
                "iVar8": "parseResult",
                "uVar9": "maxDigits",
                "uVar10": "maxValue"
            },
            "calling": [
                "strtol"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000827fc": {
            "entrypoint": "0x000827fc",
            "current_name": "parse_integer_000827fc",
            "code": "\nlong parseInteger_000827fc(char *inputString,char **endPointer,int base)\n\n{\n  long parsedInteger;\n  \n  parsedInteger = _strtol_r(_impure_ptr,inputString,endPointer,base);\n  return parsedInteger;\n}\n\n",
            "renaming": {
                "FUN_000827fc": "parse_integer_000827fc",
                "__nptr": "inputString",
                "__endptr": "endPointer",
                "__base": "base",
                "lVar1": "parsedInteger"
            },
            "calling": [
                "atol"
            ],
            "called": [
                "_strtol_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082814": {
            "entrypoint": "0x00082814",
            "current_name": "send_signal_00082814",
            "code": "\nint send_signal_00082814(process_id_t process_id,int signal_number)\n\n{\n  int result;\n  \n  result = _kill_r(_impure_ptr,process_id,signal_number);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082814": "send_signal_00082814",
                "__pid": "process_id",
                "__sig": "signal_number",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082824": {
            "entrypoint": "0x00082824",
            "current_name": "write_to_file_00082824",
            "code": "\nint writeToFile_00082824(undefined4 fileDescriptor,int bufferSize,int **data)\n\n{\n  int *currentDataPtr;\n  int result;\n  int *remainingDataPtr;\n  uint iterationCount;\n  undefined4 *currentCharPtr;\n  uint currentDataSize;\n  uint numIterations;\n  \n  if (-1 < *(int *)(bufferSize + 100) << 0x12) {\n    result = __sfvwrite_r();\n    data[2] = (int *)0x0;\n    data[1] = (int *)0x0;\n    return result;\n  }\n  remainingDataPtr = data[2];\n  currentDataPtr = *data;\n  while (remainingDataPtr != (int *)0x0) {\n    currentDataSize = currentDataPtr[1];\n    numIterations = currentDataSize >> 2;\n    if (numIterations != 0) {\n      currentCharPtr = (undefined4 *)(*currentDataPtr + -4);\n      iterationCount = 0;\n      do {\n        currentCharPtr = currentCharPtr + 1;\n        result = _fputwc_r(fileDescriptor,*currentCharPtr,bufferSize);\n        iterationCount = iterationCount + 1;\n        if (result == -1) goto LAB_00082864;\n      } while (numIterations != iterationCount);\n      remainingDataPtr = data[2];\n    }\n    remainingDataPtr = (int *)((int)remainingDataPtr - (currentDataSize & 0xfffffffc));\n    data[2] = remainingDataPtr;\n    currentDataPtr = currentDataPtr + 2;\n  }\n  result = 0;\nLAB_00082864:\n  data[2] = (int *)0x0;\n  data[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082824": "write_to_file_00082824",
                "param_1": "fileDescriptor",
                "param_2": "bufferSize",
                "param_3": "data",
                "piVar1": "currentDataPtr",
                "iVar2": "result",
                "piVar3": "remainingDataPtr",
                "uVar4": "iterationCount",
                "puVar5": "currentCharPtr",
                "uVar6": "currentDataSize",
                "uVar7": "numIterations"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_fputwc_r",
                "__sfvwrite_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008289c": {
            "entrypoint": "0x0008289c",
            "current_name": "print_formatted_output_0008289c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint print_formatted_output_0008289c(int param,int format_string,int *******args,int **arg_ptrs)\n\n{\n  bool is_negative;\n  bool has_plus_sign;\n  bool has_hash_flag;\n  char cVar4;\n  bool has_zero_padding;\n  void *pvVar6;\n  int ********format_args;\n  int *integer_arg;\n  int status;\n  char cVar10;\n  int *******format_str;\n  uint digit_value;\n  int **next_arg_ptr;\n  uint flags;\n  uint ch;\n  int iVar16;\n  int ********ppppppppiVar17;\n  int iVar18;\n  int *******pppppppiVar19;\n  int *piVar20;\n  int *******pppppppiVar21;\n  uint tmp_value;\n  int *leading_bits;\n  int *******remaining_format_str;\n  undefined4 quotient_value;\n  int ********current_arg;\n  bool is_unsigned;\n  longlong divmod_result;\n  int *******min_field_width;\n  int *******max_field_width;\n  int **arg_ptrs;\n  int total_chars;\n  char *hex_chars;\n  char format_char;\n  undefined padding_char;\n  undefined flags_char;\n  int ********arg_ptrs;\n  int num_args_processed;\n  int *******formatted_args;\n  undefined local_90;\n  char cStack_6a;\n  undefined local_69;\n  undefined local_68 [4];\n  int *******formatted_args_array [16];\n  \n  if ((param != 0) && (*(int *)(param + 0x38) == 0)) {\n    current_arginit();\n  }\n  flags = (uint)*(ushort *)(format_string + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(format_string + 0xc) << 0x12)) {\n    flags = flags | 0x2000;\n    *(short *)(format_string + 0xc) = (short)flags;\n    *(uint *)(format_string + 100) = *(uint *)(format_string + 100) & 0xffffdfff;\n  }\n  if (((int)(flags << 0x1c) < 0) && (*(int *)(format_string + 0x10) != 0)) {\n    if ((flags & 0x1a) != 10) goto LAB_000828ee;\n  }\n  else {\n    status = current_argwsetup_r(param,format_string);\n    if (status != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(format_string + 0xc) & 0x1a) != 10) goto LAB_000828ee;\n  }\n  if (-1 < *(short *)(format_string + 0xe)) {\n    status = current_argbprintf(param,format_string,args,arg_ptrs);\n    return status;\n  }\nLAB_000828ee:\n  hex_chars = (char *)0x0;\n  formatted_args = (int *******)0x0;\n  num_args_processed = 0;\n  total_chars = 0;\n  format_args = (int ********)local_68;\n  arg_ptrs = arg_ptrs;\n  arg_ptrs = (int ********)local_68;\nLAB_00082902:\n  format_str = args;\n  if ((*(char *)args != '\\0') && (*(char *)args != '%')) {\n    do {\n      format_str = (int *******)((int)format_str + 1);\n      if (*(char *)format_str == '\\0') break;\n    } while (*(char *)format_str != '%');\n    pppppppiVar21 = (int *******)((int)format_str - (int)args);\n    if (pppppppiVar21 != (int *******)0x0) {\n      num_args_processed = num_args_processed + 1;\n      formatted_args = (int *******)((int)formatted_args + (int)pppppppiVar21);\n      *format_args = args;\n      format_args[1] = pppppppiVar21;\n      if (num_args_processed < 8) {\n        format_args = format_args + 2;\n      }\n      else {\n        if (formatted_args == (int *******)0x0) {\n          total_chars = total_chars + (int)pppppppiVar21;\n          num_args_processed = 0;\n          format_args = (int ********)local_68;\n          goto LAB_00082952;\n        }\n        status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n        format_args = (int ********)local_68;\n        if (status != 0) goto LAB_00083142;\n      }\n      total_chars = total_chars + (int)pppppppiVar21;\n    }\n  }\nLAB_00082952:\n  if (*(char *)format_str != '\\0') {\n    format_char = '\\0';\n    ch = (uint)*(byte *)((int)format_str + 1);\n    flags = 0;\n    has_zero_padding = false;\n    has_plus_sign = false;\n    is_negative = false;\n    has_hash_flag = false;\n    is_unsigned = false;\n    pppppppiVar21 = (int *******)0x0;\n    max_field_width = (int *******)0xffffffff;\n    args = (int *******)((int)format_str + 1);\nLAB_00082976:\n    args = (int *******)((int)args + 1);\nLAB_0008297a:\n    switch(ch) {\n    case 0x20:\n      goto switchD_00082984_caseD_20;\n    default:\n      if (ch != 0) {\n        min_field_width = (int *******)0x1;\n        max_field_width = (int *******)0x1;\n        current_arg = (int ********)&local_90;\n        local_90 = (char)ch;\n        goto LAB_00082d76;\n      }\n      goto LAB_00083134;\n    case 0x23:\n      has_hash_flag = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2a:\n      pppppppiVar21 = (int *******)*arg_ptrs;\n      arg_ptrs = arg_ptrs + 1;\n      if ((int)pppppppiVar21 < 0) {\n        pppppppiVar21 = (int *******)-(int)pppppppiVar21;\n        goto switchD_00082984_caseD_2d;\n      }\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2b:\n      ch = (uint)*(byte *)args;\n      format_char = '+';\n      goto LAB_00082976;\n    case 0x2d:\nswitchD_00082984_caseD_2d:\n      flags = flags | 4;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2e:\n      ch = (uint)*(byte *)args;\n      format_str = (int *******)((int)args + 1);\n      if (ch == 0x2a) {\n        ch = (uint)*(byte *)((int)args + 1);\n        max_field_width = (int *******)*arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        args = format_str;\n        if ((int)max_field_width < 0) {\n          max_field_width = (int *******)0xffffffff;\n        }\n        goto LAB_00082976;\n      }\n      digit_value = ch - 0x30;\n      if (digit_value < 10) {\n        tmp_value = 0;\n        do {\n          args = (int *******)((int)format_str + 1);\n          ch = (uint)*(byte *)format_str;\n          tmp_value = digit_value + tmp_value * 10;\n          digit_value = ch - 0x30;\n          format_str = args;\n        } while (digit_value < 10);\n        max_field_width = (int *******)(tmp_value | (int)tmp_value >> 0x1f);\n      }\n      else {\n        max_field_width = (int *******)0x0;\n        args = format_str;\n      }\n      goto LAB_0008297a;\n    case 0x30:\n      flags = flags | 0x80;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082984_caseD_31;\n    case 0x44:\n      has_plus_sign = true;\n      if (is_negative == false) goto LAB_00082d8c;\nLAB_00082bfc:\n      arg_ptrs = (int **)((int)arg_ptrs + 7U & 0xfffffff8);\n      piVar20 = *arg_ptrs;\n      leading_bits = arg_ptrs[1];\n      arg_ptrs = arg_ptrs + 2;\n      goto LAB_00082c10;\n    case 0x4f:\n      has_plus_sign = true;\n      if (is_negative != false) goto LAB_00082aa6;\nLAB_00082c8e:\n      status = (uint)has_plus_sign << 4;\n      iVar16 = (uint)is_negative << 5;\n      if ((has_plus_sign == 0) && (iVar16 = (uint)is_unsigned << 6, is_unsigned != 0)) {\n        piVar20 = (int *)(uint)*(ushort *)arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        leading_bits = (int *)0x0;\n      }\n      else {\n        status = iVar16;\n        piVar20 = *arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        leading_bits = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      has_plus_sign = true;\n      if (is_negative != false) goto LAB_00082bc6;\nLAB_00082ce0:\n      if ((has_plus_sign) || (is_unsigned == false)) {\n        status = 1;\n        piVar20 = *arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        leading_bits = (int *)0x0;\n      }\n      else {\n        leading_bits = (int *)0x0;\n        piVar20 = (int *)(uint)*(ushort *)arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        status = 1;\n      }\n      break;\n    case 0x58:\n      hex_chars = \"0123456789ABCDEF\";\n      if (is_negative == false) goto LAB_00082efa;\nLAB_00082d1a:\n      next_arg_ptr = (int **)((int)arg_ptrs + 7U & 0xfffffff8);\n      arg_ptrs = next_arg_ptr + 2;\n      piVar20 = *next_arg_ptr;\n      leading_bits = next_arg_ptr[1];\n      goto LAB_00082d2e;\n    case 99:\n      piVar20 = *arg_ptrs;\n      arg_ptrs = arg_ptrs + 1;\n      min_field_width = (int *******)0x1;\n      local_90 = SUB41(piVar20,0);\n      max_field_width = (int *******)0x1;\n      current_arg = (int ********)&local_90;\n      goto LAB_00082d76;\n    case 100:\n    case 0x69:\n      if (is_negative != false) goto LAB_00082bfc;\nLAB_00082d8c:\n      if ((has_plus_sign == false) && (is_unsigned != false)) {\n        piVar20 = (int *)(int)*(short *)arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        leading_bits = (int *)((int)piVar20 >> 0x1f);\n      }\n      else {\n        piVar20 = *arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        leading_bits = (int *)((int)piVar20 >> 0x1f);\n      }\nLAB_00082c10:\n      if ((int)leading_bits < 0) {\n        is_unsigned = piVar20 != (int *)0x0;\n        piVar20 = (int *)-(int)piVar20;\n        leading_bits = (int *)(-(int)leading_bits - (uint)is_unsigned);\n        format_char = '-';\n        cVar4 = '-';\n        status = 1;\n        goto LAB_00082ace;\n      }\n      if (-1 < (int)max_field_width) {\n        flags = flags & 0xffffff7f;\n      }\n      has_zero_padding = false;\n      ch = (uint)piVar20 | (uint)leading_bits;\n      status = 1;\n      cVar4 = format_char;\n      goto joined_r0x00082adc;\n    case 0x68:\n      is_unsigned = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x6c:\n      ch = (uint)*(byte *)args;\n      if (ch == 0x6c) {\n        is_negative = true;\n        ch = (uint)*(byte *)((int)args + 1);\n        args = (int *******)((int)args + 1);\n      }\n      else {\n        has_plus_sign = true;\n      }\n      goto LAB_00082976;\n    case 0x6e:\n      if (is_negative == false) {\n        if (has_plus_sign == false) {\n          if (is_unsigned) {\n            piVar20 = *arg_ptrs;\n            arg_ptrs = arg_ptrs + 1;\n            *(short *)piVar20 = (short)total_chars;\n          }\n          else {\n            piVar20 = *arg_ptrs;\n            arg_ptrs = arg_ptrs + 1;\n            *piVar20 = total_chars;\n          }\n        }\n        else {\n          piVar20 = *arg_ptrs;\n          arg_ptrs = arg_ptrs + 1;\n          *piVar20 = total_chars;\n        }\n      }\n      else {\n        piVar20 = *arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        *piVar20 = total_chars;\n        piVar20[1] = total_chars >> 0x1f;\n      }\n      goto LAB_00082902;\n    case 0x6f:\n      if (is_negative == false) goto LAB_00082c8e;\nLAB_00082aa6:\n      next_arg_ptr = (int **)((int)arg_ptrs + 7U & 0xfffffff8);\n      arg_ptrs = next_arg_ptr + 2;\n      piVar20 = *next_arg_ptr;\n      leading_bits = next_arg_ptr[1];\n      status = 0;\n      break;\n    case 0x70:\n      piVar20 = *arg_ptrs;\n      arg_ptrs = arg_ptrs + 1;\n      flags_char = 0x78;\n      has_zero_padding = true;\n      leading_bits = (int *)0x0;\n      padding_char = 0x30;\n      hex_chars = \"0123456789abcdef\";\n      status = 2;\n      break;\n    case 0x71:\n      is_negative = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x73:\n      current_arg = (int ********)*arg_ptrs;\n      format_char = '\\0';\n      arg_ptrs = arg_ptrs + 1;\n      if (current_arg != (int ********)0x0) {\n        if ((int)max_field_width < 0) {\n          max_field_width = (int *******)strlen((char *)current_arg);\n          format_str = (int *******)0x0;\n          cVar4 = format_char;\n        }\n        else {\n          pvVar6 = memchr(current_arg,0,(size_t)max_field_width);\n          cVar4 = format_char;\n          if (pvVar6 == (void *)0x0) {\n            format_str = (int *******)0x0;\n          }\n          else {\n            pppppppiVar19 = (int *******)((int)pvVar6 - (int)current_arg);\n            if ((int)max_field_width <= (int)(int *******)((int)pvVar6 - (int)current_arg)) {\n              pppppppiVar19 = max_field_width;\n            }\n            format_str = (int *******)0x0;\n            max_field_width = pppppppiVar19;\n          }\n        }\n        goto LAB_00082b04;\n      }\n      if ((int *******)0x5 < max_field_width) {\n        max_field_width = (int *******)0x6;\n      }\n      min_field_width = (int *******)((uint)max_field_width & ~((int)max_field_width >> 0x1f));\n      current_arg = (int ********)&UNK_00085728;\nLAB_00082d76:\n      format_char = '\\0';\n      format_str = (int *******)0x0;\n      goto LAB_00082b1e;\n    case 0x75:\n      if (!is_negative) goto LAB_00082ce0;\nLAB_00082bc6:\n      next_arg_ptr = (int **)((int)arg_ptrs + 7U & 0xfffffff8);\n      arg_ptrs = next_arg_ptr + 2;\n      piVar20 = *next_arg_ptr;\n      leading_bits = next_arg_ptr[1];\n      status = 1;\n      break;\n    case 0x78:\n      hex_chars = \"0123456789abcdef\";\n      if (is_negative != false) goto LAB_00082d1a;\nLAB_00082efa:\n      if ((has_plus_sign == false) && (is_unsigned != false)) {\n        leading_bits = (int *)0x0;\n        piVar20 = (int *)(uint)*(ushort *)arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n      }\n      else {\n        piVar20 = *arg_ptrs;\n        arg_ptrs = arg_ptrs + 1;\n        leading_bits = (int *)0x0;\n      }\nLAB_00082d2e:\n      if ((has_hash_flag) && (((uint)piVar20 | (uint)leading_bits) != 0)) {\n        has_zero_padding = true;\n        padding_char = 0x30;\n        status = 2;\n        flags_char = (char)ch;\n      }\n      else {\n        status = 2;\n      }\n    }\n    format_char = '\\0';\n    cVar4 = '\\0';\nLAB_00082ace:\n    if (-1 < (int)max_field_width) {\n      flags = flags & 0xffffff7f;\n    }\n    ch = (uint)piVar20 | (uint)leading_bits;\njoined_r0x00082adc:\n    divmod_result = CONCAT44(leading_bits,piVar20);\n    format_str = max_field_width;\n    if ((ch == 0) && (max_field_width == (int *******)0x0)) {\n      current_arg = (int ********)local_68;\n      if ((status != 0) || (!has_hash_flag)) goto LAB_00082b04;\n      current_arg = (int ********)(&cStack_6a + 1);\n      local_69 = '0';\n      goto LAB_00082afe;\n    }\n    if (status == 1) {\n      if (leading_bits != (int *)0x0 || (int *)0x9 < piVar20) {\n        ppppppppiVar17 = (int ********)(&cStack_6a + 1);\n        do {\n          current_arg = ppppppppiVar17;\n          quotient_value = (undefined4)((ulonglong)divmod_result >> 0x20);\n          cVar10 = '\\n';\n          __aeabi_uldivmod((int)divmod_result,quotient_value,10,0);\n          *(char *)current_arg = cVar10 + '0';\n          divmod_result = __aeabi_uldivmod((int)divmod_result,quotient_value,10,0);\n          ppppppppiVar17 = (int ********)((int)current_arg + -1);\n        } while (divmod_result != 0);\n        max_field_width = (int *******)((int)local_68 - (int)current_arg);\n        goto LAB_00082b04;\n      }\n      local_69 = (char)piVar20 + '0';\n      current_arg = (int ********)(&cStack_6a + 1);\n      goto LAB_00083282;\n    }\n    ppppppppiVar17 = (int ********)(&cStack_6a + 1);\n    if (status != 2) goto LAB_000830e2;\n    do {\n      current_arg = ppppppppiVar17;\n      ch = (uint)piVar20 & 0xf;\n      piVar20 = (int *)((uint)piVar20 >> 4 | (int)leading_bits << 0x1c);\n      leading_bits = (int *)((uint)leading_bits >> 4);\n      *(char *)current_arg = hex_chars[ch];\n      ppppppppiVar17 = (int ********)((int)current_arg + -1);\n    } while (((uint)piVar20 | (uint)leading_bits) != 0);\n    max_field_width = (int *******)((int)local_68 - (int)current_arg);\n    goto LAB_00082b04;\n  }\nLAB_00083134:\n  if (formatted_args != (int *******)0x0) {\n    current_argprint_r_part_0(param,format_string,&arg_ptrs);\n  }\nLAB_00083142:\n  if ((int)((uint)*(ushort *)(format_string + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return total_chars;\nLAB_000830e2:\n  do {\n    current_arg = ppppppppiVar17;\n    integer_arg = (int *)((uint)piVar20 >> 3 | (int)leading_bits << 0x1d);\n    leading_bits = (int *)((uint)leading_bits >> 3);\n    status = ((uint)piVar20 & 7) + 0x30;\n    *(char *)current_arg = (char)status;\n    ppppppppiVar17 = (int ********)((int)current_arg + -1);\n    piVar20 = integer_arg;\n  } while (((uint)integer_arg | (uint)leading_bits) != 0);\n  if (has_hash_flag) {\n    if (status == 0x30) {\nLAB_00082afe:\n      max_field_width = (int *******)((int)local_68 - (int)current_arg);\n    }\n    else {\n      *(undefined *)((int)current_arg + -1) = 0x30;\n      current_arg = ppppppppiVar17;\n      max_field_width = (int *******)((int)local_68 - (int)ppppppppiVar17);\n    }\n  }\n  else {\nLAB_00083282:\n    max_field_width = (int *******)((int)local_68 - (int)current_arg);\n  }\nLAB_00082b04:\n  min_field_width = max_field_width;\n  if ((int)max_field_width < (int)format_str) {\n    min_field_width = format_str;\n  }\n  if (cVar4 != '\\0') {\n    min_field_width = (int *******)((int)min_field_width + 1);\n  }\nLAB_00082b1e:\n  if (has_zero_padding) {\n    min_field_width = (int *******)((int)min_field_width + 2);\n  }\n  if ((flags == 0) &&\n     (pppppppiVar19 = (int *******)((int)pppppppiVar21 - (int)min_field_width), 0 < (int)pppppppiVar19)) {\n    if ((int)pppppppiVar19 < 0x11) {\n      num_args_processed = num_args_processed + 1;\n    }\n    else {\n      do {\n        remaining_format_str = pppppppiVar19;\n        status = num_args_processed + 1;\n        formatted_args = formatted_args + 4;\n        *format_args = (int *******)0x856f0;\n        format_args[1] = (int *******)0x10;\n        if (status < 8) {\n          iVar16 = num_args_processed + 2;\n          format_args = format_args + 2;\n          num_args_processed = status;\n        }\n        else if (formatted_args == (int *******)0x0) {\n          iVar16 = 1;\n          format_args = (int ********)local_68;\n          num_args_processed = 0;\n        }\n        else {\n          num_args_processed = status;\n          status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n          if (status != 0) goto LAB_00083142;\n          iVar16 = num_args_processed + 1;\n          format_args = (int ********)local_68;\n        }\n        pppppppiVar19 = remaining_format_str + -4;\n      } while (0x10 < (int)pppppppiVar19);\n      pppppppiVar19 = remaining_format_str + -4;\n      num_args_processed = iVar16;\n    }\n    formatted_args = (int *******)((int)formatted_args + (int)pppppppiVar19);\n    *format_args = (int *******)0x856f0;\n    format_args[1] = pppppppiVar19;\n    if (num_args_processed < 8) {\n      status = num_args_processed + 1;\n      format_args = format_args + 2;\n    }\n    else if (formatted_args == (int *******)0x0) {\n      status = 1;\n      num_args_processed = 0;\n      format_args = (int ********)local_68;\n    }\n    else {\n      status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n      if (status != 0) goto LAB_00083142;\n      status = num_args_processed + 1;\n      format_args = (int ********)local_68;\n    }\n  }\n  else {\n    status = num_args_processed + 1;\n  }\n  iVar16 = status;\n  if (format_char != '\\0') {\n    formatted_args = (int *******)((int)formatted_args + 1);\n    iVar16 = 1;\n    *format_args = (int *******)&format_char;\n    format_args[1] = (int *******)0x1;\n    num_args_processed = status;\n    if (status < 8) {\n      iVar16 = status + 1;\n      format_args = format_args + 2;\n    }\n    else if (formatted_args == (int *******)0x0) {\n      num_args_processed = 0;\n      format_args = (int ********)local_68;\n    }\n    else {\n      status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n      if (status != 0) goto LAB_00083142;\n      iVar16 = num_args_processed + 1;\n      format_args = (int ********)local_68;\n    }\n  }\n  status = iVar16;\n  iVar18 = num_args_processed;\n  if (has_zero_padding) {\n    formatted_args = (int *******)((int)formatted_args + 2);\n    *format_args = (int *******)&padding_char;\n    format_args[1] = (int *******)0x2;\n    if (iVar16 < 8) {\n      status = iVar16 + 1;\n      iVar18 = iVar16;\n      format_args = format_args + 2;\n    }\n    else if (formatted_args == (int *******)0x0) {\n      status = 1;\n      iVar18 = 0;\n      format_args = (int ********)local_68;\n    }\n    else {\n      num_args_processed = iVar16;\n      status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n      if (status != 0) goto LAB_00083142;\n      status = num_args_processed + 1;\n      iVar18 = num_args_processed;\n      format_args = (int ********)local_68;\n    }\n  }\n  num_args_processed = iVar18;\n  if ((flags == 0x80) &&\n     (pppppppiVar19 = (int *******)((int)pppppppiVar21 - (int)min_field_width), 0 < (int)pppppppiVar19)) {\n    if (0x10 < (int)pppppppiVar19) {\n      do {\n        while( true ) {\n          remaining_format_str = pppppppiVar19;\n          num_args_processed = iVar18 + 1;\n          formatted_args = formatted_args + 4;\n          *format_args = (int *******)\"0000000000000000\";\n          format_args[1] = (int *******)0x10;\n          if (7 < num_args_processed) break;\n          status = iVar18 + 2;\n          format_args = format_args + 2;\nLAB_000831f2:\n          iVar18 = num_args_processed;\n          pppppppiVar19 = remaining_format_str + -4;\n          if ((int)(remaining_format_str + -4) < 0x11) goto LAB_00083218;\n        }\n        if (formatted_args != (int *******)0x0) {\n          status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n          if (status == 0) {\n            status = num_args_processed + 1;\n            format_args = (int ********)local_68;\n            goto LAB_000831f2;\n          }\n          goto LAB_00083142;\n        }\n        status = 1;\n        iVar18 = 0;\n        pppppppiVar19 = remaining_format_str + -4;\n        format_args = (int ********)local_68;\n      } while (0x10 < (int)(remaining_format_str + -4));\nLAB_00083218:\n      pppppppiVar19 = remaining_format_str + -4;\n    }\n    formatted_args = (int *******)((int)formatted_args + (int)pppppppiVar19);\n    *format_args = (int *******)\"0000000000000000\";\n    format_args[1] = pppppppiVar19;\n    num_args_processed = status;\n    if (status < 8) {\n      status = status + 1;\n      format_args = format_args + 2;\n    }\n    else if (formatted_args == (int *******)0x0) {\n      status = 1;\n      num_args_processed = 0;\n      format_args = (int ********)local_68;\n    }\n    else {\n      status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n      if (status != 0) goto LAB_00083142;\n      status = num_args_processed + 1;\n      format_args = (int ********)local_68;\n    }\n  }\n  format_str = (int *******)((int)format_str - (int)max_field_width);\n  ppppppppiVar17 = (int ********)local_68;\n  if ((int)format_str < 1) {\nLAB_0008302a:\n    formatted_args = (int *******)((int)formatted_args + (int)max_field_width);\n    *format_args = (int *******)current_arg;\n    format_args[1] = max_field_width;\n    max_field_width = formatted_args;\n    num_args_processed = status;\n    if (status < 8) goto LAB_000831be;\n    if (formatted_args == (int *******)0x0) {\n      num_args_processed = 0;\n    }\n    else {\n      status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n      if (status != 0) goto LAB_00083142;\n    }\n  }\n  else {\n    iVar16 = num_args_processed;\n    if (0x10 < (int)format_str) {\n      do {\n        while( true ) {\n          pppppppiVar19 = format_str;\n          num_args_processed = iVar16 + 1;\n          formatted_args = formatted_args + 4;\n          *format_args = (int *******)\"0000000000000000\";\n          format_args[1] = (int *******)0x10;\n          if (7 < num_args_processed) break;\n          status = iVar16 + 2;\n          format_args = format_args + 2;\nLAB_00082fe6:\n          iVar16 = num_args_processed;\n          format_str = pppppppiVar19 + -4;\n          if ((int)(pppppppiVar19 + -4) < 0x11) goto LAB_0008300e;\n        }\n        if (formatted_args != (int *******)0x0) {\n          status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n          if (status == 0) {\n            status = num_args_processed + 1;\n            format_args = (int ********)local_68;\n            goto LAB_00082fe6;\n          }\n          goto LAB_00083142;\n        }\n        status = 1;\n        format_args = (int ********)local_68;\n        iVar16 = 0;\n        format_str = pppppppiVar19 + -4;\n      } while (0x10 < (int)(pppppppiVar19 + -4));\nLAB_0008300e:\n      format_str = pppppppiVar19 + -4;\n    }\n    formatted_args = (int *******)((int)formatted_args + (int)format_str);\n    *format_args = (int *******)\"0000000000000000\";\n    format_args[1] = format_str;\n    if (status < 8) {\n      status = status + 1;\n      format_args = format_args + 2;\n      goto LAB_0008302a;\n    }\n    if (formatted_args != (int *******)0x0) {\n      num_args_processed = status;\n      status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n      if (status != 0) goto LAB_00083142;\n      status = num_args_processed + 1;\n      format_args = (int ********)local_68;\n      goto LAB_0008302a;\n    }\n    formatted_args_array[0] = max_field_width;\n    num_args_processed = 1;\n    format_args = (int ********)local_68;\n    local_68 = (undefined  [4])current_arg;\nLAB_000831be:\n    ppppppppiVar17 = format_args + 2;\n    formatted_args = max_field_width;\n  }\n  if (((flags & 4) != 0) &&\n     (format_str = (int *******)((int)pppppppiVar21 - (int)min_field_width), 0 < (int)format_str)) {\n    status = num_args_processed;\n    if ((int)format_str < 0x11) {\n      iVar16 = num_args_processed + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          num_args_processed = status + 1;\n          formatted_args = formatted_args + 4;\n          *ppppppppiVar17 = (int *******)0x856f0;\n          ppppppppiVar17[1] = (int *******)0x10;\n          if (7 < num_args_processed) break;\n          iVar16 = status + 2;\n          ppppppppiVar17 = ppppppppiVar17 + 2;\nLAB_0008307a:\n          format_str = format_str + -4;\n          status = num_args_processed;\n          if ((int)format_str < 0x11) goto LAB_000830a2;\n        }\n        if (formatted_args != (int *******)0x0) {\n          status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n          if (status == 0) {\n            iVar16 = num_args_processed + 1;\n            ppppppppiVar17 = (int ********)local_68;\n            goto LAB_0008307a;\n          }\n          goto LAB_00083142;\n        }\n        format_str = format_str + -4;\n        iVar16 = 1;\n        status = 0;\n        ppppppppiVar17 = (int ********)local_68;\n      } while (0x10 < (int)format_str);\n    }\nLAB_000830a2:\n    formatted_args = (int *******)((int)formatted_args + (int)format_str);\n    *ppppppppiVar17 = (int *******)0x856f0;\n    ppppppppiVar17[1] = format_str;\n    num_args_processed = iVar16;\n    if (7 < iVar16) {\n      if (formatted_args == (int *******)0x0) {\n        if ((int)min_field_width < (int)pppppppiVar21) {\n          min_field_width = pppppppiVar21;\n        }\n        total_chars = total_chars + (int)min_field_width;\n        goto LAB_00083186;\n      }\n      status = current_argprint_r_part_0(param,format_string,&arg_ptrs);\n      if (status != 0) goto LAB_00083142;\n    }\n  }\n  if ((int)min_field_width < (int)pppppppiVar21) {\n    min_field_width = pppppppiVar21;\n  }\n  total_chars = total_chars + (int)min_field_width;\n  if ((formatted_args != (int *******)0x0) &&\n     (status = current_argprint_r_part_0(param,format_string,&arg_ptrs), status != 0)) goto LAB_00083142;\nLAB_00083186:\n  num_args_processed = 0;\n  format_args = (int ********)local_68;\n  goto LAB_00082902;\nswitchD_00082984_caseD_31:\n  digit_value = ch - 0x30;\n  pppppppiVar21 = (int *******)0x0;\n  format_str = args;\n  do {\n    args = (int *******)((int)format_str + 1);\n    ch = (uint)*(byte *)format_str;\n    pppppppiVar21 = (int *******)(digit_value + (int)pppppppiVar21 * 10);\n    digit_value = ch - 0x30;\n    format_str = args;\n  } while (digit_value < 10);\n  goto LAB_0008297a;\nswitchD_00082984_caseD_20:\n  ch = (uint)*(byte *)args;\n  if (format_char == '\\0') {\n    format_char = ' ';\n  }\n  goto LAB_00082976;\n}\n\n",
            "renaming": {
                "FUN_0008289c": "print_formatted_output_0008289c",
                "param_1": "param",
                "param_2": "format_string",
                "param_3": "args",
                "param_4": "arg_ptrs",
                "bVar1": "is_negative",
                "bVar2": "has_plus_sign",
                "bVar3": "has_hash_flag",
                "bVar5": "has_zero_padding",
                "bVar26": "is_unsigned",
                "ppppppppiVar7": "format_args",
                "piVar8": "integer_arg",
                "iVar9": "status",
                "pppppppiVar11": "format_str",
                "uVar12": "digit_value",
                "ppiVar13": "next_arg_ptr",
                "uVar14": "flags",
                "uVar15": "ch",
                "uVar22": "tmp_value",
                "piVar23": "leading_bits",
                "pppppppiVar24": "remaining_format_str",
                "uVar25": "quotient_value",
                "__s": "current_arg",
                "lVar27": "divmod_result",
                "local_dc": "min_field_width",
                "local_d4": "max_field_width",
                "local_c8": "arg_ptrs",
                "local_c4": "total_chars",
                "local_c0": "hex_chars",
                "local_a1": "format_char",
                "local_a0": "padding_char",
                "local_9f": "flags_char",
                "local_9c": "arg_ptrs",
                "local_98": "num_args_processed",
                "local_94": "formatted_args",
                "local_64": "formatted_args_array"
            },
            "calling": [
                "__sbprintf",
                "iprintf",
                "fiprintf"
            ],
            "called": [
                "__sprint_r.part.0",
                "memchr",
                "__sbprintf",
                "__sinit",
                "__swsetup_r",
                "strlen",
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000834f0": {
            "entrypoint": "0x000834f0",
            "current_name": "format_and_flush_output_000834f0",
            "code": "\nint formatAndFlushOutput_000834f0(undefined4 outputStream,int inputData)\n\n{\n  int returnValue;\n  int fflushResult;\n  undefined *stringBuffer [2];\n  undefined4 bufferSize1;\n  ushort modifiedFlag;\n  undefined2 value2;\n  undefined *buffer;\n  undefined4 bufferSize2;\n  undefined4 zero;\n  undefined4 local_46c;\n  undefined4 local_464;\n  undefined4 local_424;\n  undefined auStack_420 [1024];\n  \n  local_424 = *(undefined4 *)(inputData + 100);\n  local_46c = *(undefined4 *)(inputData + 0x1c);\n  value2 = *(undefined2 *)(inputData + 0xe);\n  local_464 = *(undefined4 *)(inputData + 0x24);\n  stringBuffer[0] = auStack_420;\n  modifiedFlag = *(ushort *)(inputData + 0xc) & 0xfffd;\n  bufferSize1 = 0x400;\n  bufferSize2 = 0x400;\n  zero = 0;\n  buffer = stringBuffer[0];\n  returnValue = _vfiprintf_r(outputStream,stringBuffer);\n  if ((-1 < returnValue) && (fflushResult = _fflush_r(outputStream,stringBuffer), fflushResult != 0)) {\n    returnValue = -1;\n  }\n  if ((int)((uint)modifiedFlag << 0x19) < 0) {\n    *(ushort *)(inputData + 0xc) = *(ushort *)(inputData + 0xc) | 0x40;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_000834f0": "format_and_flush_output_000834f0",
                "param_1": "outputStream",
                "param_2": "inputData",
                "iVar1": "returnValue",
                "iVar2": "fflushResult",
                "local_488": "stringBuffer",
                "local_480": "bufferSize1",
                "local_47c": "modifiedFlag",
                "local_47a": "value2",
                "local_478": "buffer",
                "local_474": "bufferSize2",
                "local_470": "zero"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_vfiprintf_r",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008356c": {
            "entrypoint": "0x0008356c",
            "current_name": "initialize_stream_0008356c",
            "code": "\nundefined4 initializeStream_0008356c(undefined4 *streamPtr,int *streamData)\n\n{\n  int bufSize;\n  int streamStart;\n  uint flags;\n  ushort filePtr;\n  \n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x38) == 0)) {\n    __sinit();\n  }\n  filePtr = *(ushort *)(streamData + 3);\n  flags = (uint)filePtr;\n  if ((int)(flags << 0x1c) < 0) {\n    streamStart = streamData[4];\n  }\n  else {\n    if (-1 < (int)(flags << 0x1b)) {\n      *streamPtr = 9;\n      *(ushort *)(streamData + 3) = filePtr | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(flags << 0x1d) < 0) {\n      if ((int *)streamData[0xc] != (int *)0x0) {\n        if ((int *)streamData[0xc] != streamData + 0x10) {\n          _free_r(streamPtr);\n          filePtr = *(ushort *)(streamData + 3);\n        }\n        streamData[0xc] = 0;\n      }\n      streamStart = streamData[4];\n      filePtr = filePtr & 0xffdb;\n      *streamData = streamStart;\n      streamData[1] = 0;\n    }\n    else {\n      streamStart = streamData[4];\n    }\n    *(ushort *)(streamData + 3) = filePtr | 8;\n    flags = (uint)(filePtr | 8);\n  }\n  if ((streamStart == 0) && ((flags & 0x280) != 0x200)) {\n    __smakebuf_r(streamPtr,streamData);\n    flags = (uint)*(ushort *)(streamData + 3);\n    streamStart = streamData[4];\n  }\n  if ((flags & 1) == 0) {\n    bufSize = 0;\n    if (-1 < (int)(flags << 0x1e)) {\n      bufSize = streamData[5];\n    }\n    streamData[2] = bufSize;\n  }\n  else {\n    streamData[6] = -streamData[5];\n    streamData[2] = 0;\n  }\n  if ((streamStart == 0) && ((int)((uint)*(ushort *)(streamData + 3) << 0x18) < 0)) {\n    *(ushort *)(streamData + 3) = *(ushort *)(streamData + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008356c": "initialize_stream_0008356c",
                "param_1": "streamPtr",
                "param_2": "streamData",
                "iVar1": "bufSize",
                "iVar2": "streamStart",
                "uVar3": "flags",
                "uVar4": "filePtr"
            },
            "calling": [
                "_vfiprintf_r",
                "__sfvwrite_r",
                "__swbuf_r"
            ],
            "called": [
                "__smakebuf_r",
                "__sinit",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083630": {
            "entrypoint": "0x00083630",
            "current_name": "update_data_00083630",
            "code": "\nundefined4 updateData_00083630(int flag,undefined4 data,undefined4 value1,undefined4 value2)\n\n{\n  undefined4 *dataArray;\n  uint index;\n  uint bitmask;\n  \n  if (DAT_20070180 == (undefined4 *)0x0) {\n    DAT_20070180 = (undefined4 *)&DAT_20070184;\n  }\n  index = DAT_20070180[1];\n  dataArray = DAT_20070180;\n  if (0x1f < (int)index) {\n    dataArray = (undefined4 *)malloc(400);\n    if (dataArray == (undefined4 *)0x0) {\n      return 0xffffffff;\n    }\n    *dataArray = DAT_20070180;\n    dataArray[1] = 0;\n    index = 0;\n    DAT_20070180 = dataArray;\n    dataArray[0x62] = 0;\n    dataArray[99] = 0;\n  }\n  if (flag != 0) {\n    bitmask = 1 << (index & 0xff);\n    dataArray[index + 0x22] = value1;\n    dataArray[0x62] = dataArray[0x62] | bitmask;\n    dataArray[index + 0x42] = value2;\n    if (flag == 2) {\n      dataArray[99] = bitmask | dataArray[99];\n    }\n  }\n  dataArray[1] = index + 1;\n  dataArray[index + 2] = data;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083630": "update_data_00083630",
                "param_1": "flag",
                "param_2": "data",
                "param_3": "value1",
                "param_4": "value2",
                "puVar1": "dataArray",
                "uVar2": "index",
                "uVar3": "bitmask"
            },
            "calling": [
                "atexit",
                "__cxa_atexit"
            ],
            "called": [
                "malloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836d8": {
            "entrypoint": "0x000836d8",
            "current_name": "FUNC_000836d8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000836dc) */\n\nvoid FUNC_000836d8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836d8": "FUNC_000836d8"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000836ec": {
            "entrypoint": "0x000836ec",
            "current_name": "terminate_program_000836ec",
            "code": "\n\n\nvoid terminateProgram_000836ec(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_000836ec": "terminate_program_000836ec"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_exit",
                "raise"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836fc": {
            "entrypoint": "0x000836fc",
            "current_name": "register_exit_procedure_000836fc",
            "code": "\nint registerExitProcedure_000836fc(functionPtr *functionPtr)\n\n{\n  int returnValue;\n  \n  returnValue = __register_exitproc(0,functionPtr,0,0);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_000836fc": "register_exit_procedure_000836fc",
                "__func": "functionPtr",
                "iVar1": "returnValue"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083708": {
            "entrypoint": "0x00083708",
            "current_name": "process_data_00083708",
            "code": "\nundefined4 processData_00083708(int *dataPointer,int *infoPointer)\n\n{\n  int *tempPointer;\n  int length;\n  ushort flags;\n  uint tempVar;\n  int offset;\n  code *functionPointer;\n  int originalData;\n  \n  flags = *(ushort *)(infoPointer + 3);\n  if ((int)((uint)flags << 0x1c) < 0) {\n    originalData = infoPointer[4];\n    if (originalData == 0) {\n      return 0;\n    }\n    length = *infoPointer;\n    if ((flags & 3) == 0) {\n      offset = infoPointer[5];\n    }\n    else {\n      offset = 0;\n    }\n    *infoPointer = originalData;\n    length = length - originalData;\n    infoPointer[2] = offset;\n    do {\n      if (length < 1) {\n        return 0;\n      }\n      offset = (*(code *)infoPointer[9])(dataPointer,infoPointer[7],originalData,length);\n      length = length - offset;\n      originalData = originalData + offset;\n    } while (0 < offset);\nLAB_000837c8:\n    *(ushort *)(infoPointer + 3) = *(ushort *)(infoPointer + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(infoPointer + 3) = flags | 0x800;\n  if ((infoPointer[1] < 1) && (infoPointer[0xf] < 1)) {\n    return 0;\n  }\n  functionPointer = (code *)infoPointer[10];\n  if (functionPointer == (code *)0x0) {\n    return 0;\n  }\n  tempVar = (uint)(flags | 0x800);\n  originalData = *dataPointer;\n  *dataPointer = 0;\n  if ((flags & 0x1000) == 0) {\n    length = (*functionPointer)(dataPointer,infoPointer[7],tempVar & 0x1000,1);\n    if ((length == -1) && (offset = *dataPointer, offset != 0)) {\n      if ((offset == 0x1d) || (offset == 0x16)) {\n        *dataPointer = originalData;\n        return 0;\n      }\n      goto LAB_000837c8;\n    }\n    tempVar = (uint)*(ushort *)(infoPointer + 3);\n    functionPointer = (code *)infoPointer[10];\n  }\n  else {\n    length = infoPointer[0x14];\n  }\n  if (((int)(tempVar << 0x1d) < 0) && (length = length - infoPointer[1], infoPointer[0xc] != 0)) {\n    length = length - infoPointer[0xf];\n  }\n  length = (*functionPointer)(dataPointer,infoPointer[7],length,0);\n  if (length == -1) {\n    offset = *dataPointer;\n    if (offset != 0) {\n      if ((offset != 0x1d) && (offset != 0x16)) {\n        *(ushort *)(infoPointer + 3) = *(ushort *)(infoPointer + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(infoPointer + 3) = *(ushort *)(infoPointer + 3) & 0xf7ff;\n      *infoPointer = infoPointer[4];\n      infoPointer[1] = 0;\n      goto LAB_00083774;\n    }\n    flags = *(ushort *)(infoPointer + 3) & 0xf7ff;\n    infoPointer[1] = 0;\n    *(ushort *)(infoPointer + 3) = flags;\n    *infoPointer = infoPointer[4];\n  }\n  else {\n    flags = *(ushort *)(infoPointer + 3) & 0xf7ff;\n    *infoPointer = infoPointer[4];\n    *(ushort *)(infoPointer + 3) = flags;\n    infoPointer[1] = 0;\n  }\n  if ((int)((uint)flags << 0x13) < 0) {\n    infoPointer[0x14] = length;\n  }\nLAB_00083774:\n  tempPointer = (int *)infoPointer[0xc];\n  *dataPointer = originalData;\n  if (tempPointer == (int *)0x0) {\n    return 0;\n  }\n  if (tempPointer != infoPointer + 0x10) {\n    _free_r(dataPointer);\n  }\n  infoPointer[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083708": "process_data_00083708",
                "param_1": "dataPointer",
                "param_2": "infoPointer",
                "piVar1": "tempPointer",
                "iVar2": "length",
                "uVar3": "flags",
                "uVar4": "tempVar",
                "iVar5": "offset",
                "pcVar6": "functionPointer",
                "iVar7": "originalData"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083850": {
            "entrypoint": "0x00083850",
            "current_name": "check_and_flush_stream_00083850",
            "code": "\nvoid checkAndFlushStream_00083850(int stream,int data)\n\n{\n  if ((stream != 0) && (*(int *)(stream + 0x38) == 0)) {\n    __sinit();\n  }\n  if (*(short *)(data + 0xc) == 0) {\n    return;\n  }\n  __sflush_r(stream);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083850": "check_and_flush_stream_00083850",
                "param_1": "stream",
                "param_2": "data"
            },
            "calling": [
                "__sbprintf",
                "__sfvwrite_r",
                "__swbuf_r",
                "_fclose_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008387c": {
            "entrypoint": "0x0008387c",
            "current_name": "execute_fwalk_0008387c",
            "code": "\nvoid execute_fwalk_0008387c(undefined4 arg)\n\n{\n  file_walk_function(arg,0x84485);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008387c": "execute_fwalk_0008387c",
                "param_1": "arg",
                "_fwalk": "file_walk_function"
            },
            "calling": [],
            "called": [
                "_fwalk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083888": {
            "entrypoint": "0x00083888",
            "current_name": "initialize_data_structures_00083888",
            "code": "\nvoid initializeDataStructures_00083888(int dataStruct)\n\n{\n  undefined4 *ptr1;\n  undefined4 *ptr2;\n  \n  if (*(int *)(dataStruct + 0x38) == 0) {\n    ptr1 = *(undefined4 **)(dataStruct + 4);\n    *(undefined4 *)(dataStruct + 0x3c) = 0x8387d;\n    *(undefined4 *)(dataStruct + 0x2e4) = 3;\n    *(int *)(dataStruct + 0x2e8) = dataStruct + 0x2ec;\n    *(undefined4 *)(dataStruct + 0x2e0) = 0;\n    *(undefined2 *)(ptr1 + 3) = 4;\n    *ptr1 = 0;\n    ptr1[1] = 0;\n    ptr1[2] = 0;\n    ptr1[0x19] = 0;\n    *(undefined2 *)((int)ptr1 + 0xe) = 0;\n    ptr1[4] = 0;\n    ptr1[5] = 0;\n    ptr1[6] = 0;\n    memset(ptr1 + 0x17,0,8);\n    ptr2 = *(undefined4 **)(dataStruct + 8);\n    ptr1[7] = ptr1;\n    ptr1[8] = 0x84221;\n    ptr1[9] = 0x84245;\n    ptr1[10] = 0x8427d;\n    ptr1[0xb] = 0x8429d;\n    *(undefined2 *)((int)ptr2 + 0xe) = 1;\n    *(undefined2 *)(ptr2 + 3) = 9;\n    *ptr2 = 0;\n    ptr2[1] = 0;\n    ptr2[2] = 0;\n    ptr2[0x19] = 0;\n    ptr2[4] = 0;\n    ptr2[5] = 0;\n    ptr2[6] = 0;\n    memset(ptr2 + 0x17,0,8);\n    ptr1 = *(undefined4 **)(dataStruct + 0xc);\n    ptr2[7] = ptr2;\n    ptr2[8] = 0x84221;\n    ptr2[9] = 0x84245;\n    ptr2[10] = 0x8427d;\n    ptr2[0xb] = 0x8429d;\n    *(undefined2 *)(ptr1 + 3) = 0x12;\n    *(undefined2 *)((int)ptr1 + 0xe) = 2;\n    *ptr1 = 0;\n    ptr1[1] = 0;\n    ptr1[2] = 0;\n    ptr1[0x19] = 0;\n    ptr1[4] = 0;\n    ptr1[5] = 0;\n    ptr1[6] = 0;\n    memset(ptr1 + 0x17,0,8);\n    ptr1[7] = ptr1;\n    ptr1[8] = 0x84221;\n    ptr1[9] = 0x84245;\n    ptr1[10] = 0x8427d;\n    ptr1[0xb] = 0x8429d;\n    *(undefined4 *)(dataStruct + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083888": "initialize_data_structures_00083888",
                "param_1": "dataStruct",
                "puVar1": "ptr1",
                "puVar2": "ptr2"
            },
            "calling": [
                "_vfiprintf_r",
                "__swsetup_r",
                "_fflush_r",
                "__swbuf_r",
                "_fclose_r"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008397c": {
            "entrypoint": "0x0008397c",
            "current_name": "FUNC_0008397c",
            "code": "\nvoid FUNC_0008397c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008397c": "FUNC_0008397c"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083980": {
            "entrypoint": "0x00083980",
            "current_name": "FUNC_00083980",
            "code": "\nvoid FUNC_00083980(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083980": "FUNC_00083980"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083984": {
            "entrypoint": "0x00083984",
            "current_name": "execute_cleanup_functions_00083984",
            "code": "\nvoid execute_cleanup_functions_00083984(void)\n\n{\n  int iteration_count;\n  code **function_array_ptr;\n  \n  iteration_count = 1;\n  function_array_ptr = (code **)&__fini_array_end;\n  do {\n    iteration_count = iteration_count + -1;\n    function_array_ptr = function_array_ptr + -1;\n    (**function_array_ptr)();\n  } while (iteration_count != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083984": "execute_cleanup_functions_00083984",
                "iVar1": "iteration_count",
                "ppcVar2": "function_array_ptr"
            },
            "calling": [],
            "called": [
                "__do_global_dtors_aux",
                "_fini"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000839b4": {
            "entrypoint": "0x000839b4",
            "current_name": "convert_string_to_bytes_000839b4",
            "code": "\nuint convertStringToBytes_000839b4(undefined4 locale,uint inputLength,byte **outputBuffer)\n\n{\n  int maxBytesPerChar;\n  uint result;\n  uint currentChar;\n  byte *outputPointer;\n  uint byteIndex;\n  byte singleByte;\n  byte byteArray [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(outputBuffer + 3) << 0x12)) {\n    *(ushort *)(outputBuffer + 3) = *(ushort *)(outputBuffer + 3) | 0x2000;\n    outputBuffer[0x19] = (byte *)((uint)outputBuffer[0x19] | 0x2000);\n  }\n  maxBytesPerChar = __locale_mb_cur_max();\n  if ((maxBytesPerChar == 1) && (inputLength - 1 < 0xff)) {\n    currentChar = inputLength & 0xff;\n    singleByte = (byte)currentChar;\n    result = 1;\n  }\n  else {\n    result = _wcrtomb_r(locale,&singleByte,inputLength,outputBuffer + 0x17);\n    if (result == 0xffffffff) {\n      *(ushort *)(outputBuffer + 3) = *(ushort *)(outputBuffer + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (result == 0) {\n      return inputLength;\n    }\n    currentChar = (uint)singleByte;\n  }\n  byteIndex = 0;\n  do {\n    outputPointer = outputBuffer[2] + -1;\n    outputBuffer[2] = outputPointer;\n    if ((int)outputPointer < 0) {\n      if ((int)outputBuffer[6] <= (int)outputPointer) {\n        **outputBuffer = (byte)currentChar;\n        outputPointer = *outputBuffer;\n        currentChar = (uint)*outputPointer;\n        if (currentChar != 10) goto LAB_00083a04;\n      }\n      maxBytesPerChar = __swbuf_r(locale,currentChar,outputBuffer);\n      if (maxBytesPerChar == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **outputBuffer = (byte)currentChar;\n      outputPointer = *outputBuffer;\nLAB_00083a04:\n      *outputBuffer = outputPointer + 1;\n    }\n    if (result <= byteIndex + 1) {\n      return inputLength;\n    }\n    currentChar = (uint)byteArray[byteIndex];\n    byteIndex = byteIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000839b4": "convert_string_to_bytes_000839b4",
                "param_1": "locale",
                "param_2": "inputLength",
                "param_3": "outputBuffer",
                "iVar1": "maxBytesPerChar",
                "uVar2": "result",
                "uVar3": "currentChar",
                "pbVar4": "outputPointer",
                "uVar5": "byteIndex",
                "local_1c": "singleByte",
                "abStack_1b": "byteArray"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "_wcrtomb_r",
                "__locale_mb_cur_max",
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083a74": {
            "entrypoint": "0x00083a74",
            "current_name": "allocate_memory_00083a74",
            "code": "\nundefined4 allocateMemory_00083a74(undefined4 lock_mutex,int requested_size)\n\n{\n  int result;\n  uint allocated_size;\n  int adjusted_size;\n  \n  __malloc_lock();\n  allocated_size = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  adjusted_size = ((allocated_size - requested_size) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < adjusted_size) {\n    result = _sbrk_r(lock_mutex,0);\n    if (result == DAT_2007046c + allocated_size) {\n      result = _sbrk_r(lock_mutex,-adjusted_size);\n      if (result != -1) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo - adjusted_size;\n        *(uint *)(DAT_2007046c + 4) = allocated_size - adjusted_size | 1;\n        __malloc_unlock(lock_mutex);\n        return 1;\n      }\n      adjusted_size = _sbrk_r(lock_mutex,0);\n      if (0xf < adjusted_size - DAT_2007046c) {\n        __malloc_current_mallinfo = adjusted_size - __malloc_sbrk_base;\n        *(uint *)(DAT_2007046c + 4) = adjusted_size - DAT_2007046c | 1;\n      }\n    }\n  }\n  __malloc_unlock(lock_mutex);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083a74": "allocate_memory_00083a74",
                "param_1": "lock_mutex",
                "param_2": "requested_size",
                "iVar1": "result",
                "uVar2": "allocated_size",
                "iVar3": "adjusted_size"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b10": {
            "entrypoint": "0x00083b10",
            "current_name": "improved_memory_management_00083b10",
            "code": "\nvoid improvedMemoryManagement_00083b10(undefined4 param1,int param2)\n\n{\n  undefined4 *ptr;\n  bool bVar2;\n  uint size;\n  int index;\n  int tempVar;\n  undefined1 *currentBlock;\n  uint alignedSize;\n  undefined1 *nextBlock;\n  int blockHeader;\n  uint blockSize;\n  \n  if (param2 == 0) {\n    return;\n  }\n  lockMemory();\n  size = *(uint *)(param2 + -4);\n  blockHeader = param2 + -8;\n  alignedSize = size & 0xfffffffe;\n  tempVar = blockHeader + alignedSize;\n  blockSize = *(uint *)(tempVar + 4) & 0xfffffffc;\n  if (DAT_2007046c == tempVar) {\n    blockSize = blockSize + alignedSize;\n    if (-1 < (int)(size << 0x1f)) {\n      blockHeader = blockHeader - *(int *)(param2 + -8);\n      index = *(int *)(blockHeader + 0xc);\n      tempVar = *(int *)(blockHeader + 8);\n      blockSize = blockSize + *(int *)(param2 + -8);\n      *(int *)(tempVar + 0xc) = index;\n      *(int *)(index + 8) = tempVar;\n    }\n    size = trimThreshold;\n    *(uint *)(blockHeader + 4) = blockSize | 1;\n    DAT_2007046c = blockHeader;\n    if (size <= blockSize) {\n      trimMemory(param1,topPad);\n    }\n  }\n  else {\n    *(uint *)(tempVar + 4) = blockSize;\n    if ((size & 1) == 0) {\n      blockHeader = blockHeader - *(int *)(param2 + -8);\n      ptr = *(undefined4 **)(blockHeader + 8);\n      alignedSize = alignedSize + *(int *)(param2 + -8);\n      if (ptr == &DAT_2007046c) {\n        bVar2 = true;\n      }\n      else {\n        index = *(int *)(blockHeader + 0xc);\n        ptr[3] = index;\n        *(undefined4 **)(index + 8) = ptr;\n        bVar2 = false;\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (-1 < *(int *)(tempVar + blockSize + 4) << 0x1f) {\n      alignedSize = alignedSize + blockSize;\n      ptr = *(undefined4 **)(tempVar + 8);\n      if ((!bVar2) && (ptr == &DAT_2007046c)) {\n        DAT_20070474 = blockHeader;\n        DAT_20070478 = blockHeader;\n        *(int **)(blockHeader + 0xc) = &DAT_2007046c;\n        *(int **)(blockHeader + 8) = &DAT_2007046c;\n        *(uint *)(blockHeader + 4) = alignedSize | 1;\n        *(uint *)(blockHeader + alignedSize) = alignedSize;\n        goto LAB_00083ba4;\n      }\n      tempVar = *(int *)(tempVar + 0xc);\n      ptr[3] = tempVar;\n      *(undefined4 **)(tempVar + 8) = ptr;\n    }\n    *(uint *)(blockHeader + 4) = alignedSize | 1;\n    *(uint *)(blockHeader + alignedSize) = alignedSize;\n    if (!bVar2) {\n      if (alignedSize < 0x200) {\n        size = alignedSize & 0xfffffff8;\n        tempVar = *(int *)((int)&DAT_2007046c + size);\n        DAT_20070468 = DAT_20070468 | 1 << ((int)(alignedSize >> 3) >> 2 & 0xffU);\n        *(int *)(blockHeader + 8) = tempVar;\n        *(undefined1 **)(blockHeader + 0xc) = &__malloc_av_ + size;\n        *(int *)((int)&DAT_2007046c + size) = blockHeader;\n        *(int *)(tempVar + 0xc) = blockHeader;\n        __malloc_unlock(param1);\n        return;\n      }\n      size = alignedSize >> 9;\n      if (size < 5) {\n        tempVar = (alignedSize >> 6) + 0x38;\n        index = tempVar * 2;\n      }\n      else if (size < 0x15) {\n        tempVar = size + 0x5b;\n        index = tempVar * 2;\n      }\n      else if (size < 0x55) {\n        tempVar = (alignedSize >> 0xc) + 0x6e;\n        index = tempVar * 2;\n      }\n      else if (size < 0x155) {\n        tempVar = (alignedSize >> 0xf) + 0x77;\n        index = tempVar * 2;\n      }\n      else if (size < 0x555) {\n        tempVar = (alignedSize >> 0x12) + 0x7c;\n        index = tempVar * 2;\n      }\n      else {\n        index = 0xfc;\n        tempVar = 0x7e;\n      }\n      currentBlock = (undefined1 *)(&DAT_2007046c)[index];\n      if (currentBlock == &__malloc_av_ + index * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (tempVar >> 2 & 0xffU);\n        nextBlock = currentBlock;\n      }\n      else {\n        do {\n          if ((*(uint *)(currentBlock + 4) & 0xfffffffc) <= alignedSize) break;\n          currentBlock = *(undefined1 **)(currentBlock + 8);\n        } while (&__malloc_av_ + index * 4 != currentBlock);\n        nextBlock = *(undefined1 **)(currentBlock + 0xc);\n      }\n      *(undefined1 **)(blockHeader + 0xc) = nextBlock;\n      *(undefined1 **)(blockHeader + 8) = currentBlock;\n      *(int *)(nextBlock + 8) = blockHeader;\n      *(int *)(currentBlock + 0xc) = blockHeader;\n    }\n  }\nLAB_00083ba4:\n  __malloc_unlock(param1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b10": "improved_memory_management_00083b10",
                "param_1": "param1",
                "param_2": "param2",
                "puVar1": "ptr",
                "uVar3": "size",
                "iVar4": "index",
                "iVar5": "tempVar",
                "puVar6": "currentBlock",
                "uVar7": "alignedSize",
                "puVar8": "nextBlock",
                "iVar9": "blockHeader",
                "uVar10": "blockSize",
                "__malloc_lock": "lockMemory",
                "__malloc_trim_threshold": "trimThreshold",
                "__malloc_top_pad": "topPad",
                "_malloc_trim_r": "trimMemory"
            },
            "calling": [
                "_malloc_r",
                "free",
                "__sflush_r",
                "__swsetup_r",
                "__sfvwrite_r",
                "_realloc_r",
                "_fclose_r"
            ],
            "called": [
                "_malloc_trim_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083ca8": {
            "entrypoint": "0x00083ca8",
            "current_name": "process_data_00083ca8",
            "code": "\nundefined4 processData_00083ca8(undefined4 *errorCode,void **inputData,undefined4 *bufferInfo)\n\n{\n  void **tempPtr1;\n  int result;\n  void *ptr1;\n  void *ptr2;\n  void *ptr3;\n  void *ptr4;\n  ushort flag;\n  uint flagValue;\n  int bufferSize;\n  void **buffer;\n  void *dataPtr;\n  void *dataOffset;\n  void *numBytes;\n  size_t bufferOffset;\n  void *localFlag;\n  \n  if (bufferInfo[2] != 0) {\n    flag = *(ushort *)(inputData + 3);\n    flagValue = (uint)flag;\n    if (((int)(flagValue << 0x1c) < 0) && (inputData[4] != (void *)0x0)) {\n      buffer = (void **)*bufferInfo;\n    }\n    else {\n      result = __swsetup_r(errorCode,inputData);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      flag = *(ushort *)(inputData + 3);\n      flagValue = (uint)flag;\n      buffer = (void **)*bufferInfo;\n    }\n    if ((flag & 2) == 0) {\n      ptr3 = (void *)(flagValue & 2);\n      dataOffset = ptr3;\n      dataPtr = ptr3;\n      localFlag = ptr3;\n      if ((flagValue & 1) == 0) {\n        ptr3 = (void *)0x0;\n        dataOffset = (void *)0x0;\n        while( true ) {\n          while (ptr3 == (void *)0x0) {\n            dataOffset = *buffer;\n            tempPtr1 = buffer + 1;\n            buffer = buffer + 2;\n            ptr3 = *tempPtr1;\n          }\n          dataPtr = inputData[2];\n          if ((int)(flagValue << 0x16) < 0) {\n            if (ptr3 < dataPtr) {\n              ptr1 = *inputData;\n              dataPtr = ptr3;\n            }\n            else if ((flagValue & 0x480) == 0) {\n              ptr1 = *inputData;\n            }\n            else {\n              bufferOffset = (int)*inputData - (int)inputData[4];\n              dataPtr = (void *)(bufferOffset + 1 + (int)ptr3);\n              ptr1 = (void *)(((int)inputData[5] * 3) / 2);\n              if (dataPtr <= ptr1) {\n                dataPtr = ptr1;\n              }\n              if ((int)(flagValue << 0x15) < 0) {\n                ptr2 = (void *)_malloc_r(errorCode,dataPtr);\n                if (ptr2 == (void *)0x0) {\n                  *errorCode = 0xc;\n                  flag = *(ushort *)(inputData + 3);\n                  goto LAB_00083da4;\n                }\n                memcpy(ptr2,inputData[4],bufferOffset);\n                *(ushort *)(inputData + 3) = *(ushort *)(inputData + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                ptr2 = (void *)_realloc_r(errorCode);\n                if (ptr2 == (void *)0x0) {\n                  _free_r(errorCode,inputData[4]);\n                  flag = *(ushort *)(inputData + 3) & 0xff7f;\n                  *errorCode = 0xc;\n                  goto LAB_00083da4;\n                }\n              }\n              ptr1 = (void *)((int)ptr2 + bufferOffset);\n              inputData[4] = ptr2;\n              inputData[5] = dataPtr;\n              *inputData = ptr1;\n              inputData[2] = (void *)((int)dataPtr - bufferOffset);\n              dataPtr = ptr3;\n            }\n            memmove(ptr1,dataOffset,(size_t)dataPtr);\n            inputData[2] = (void *)((int)inputData[2] - (int)dataPtr);\n            *inputData = (void *)((int)*inputData + (int)dataPtr);\n            dataPtr = ptr3;\n          }\n          else if ((inputData[4] < *inputData) || (ptr1 = inputData[5], ptr3 < ptr1)) {\n            if (ptr3 < dataPtr) {\n              dataPtr = ptr3;\n            }\n            memmove(*inputData,dataOffset,(size_t)dataPtr);\n            ptr1 = inputData[2];\n            inputData[2] = (void *)((int)ptr1 - (int)dataPtr);\n            *inputData = (void *)((int)*inputData + (int)dataPtr);\n            if (((void *)((int)ptr1 - (int)dataPtr) == (void *)0x0) &&\n               (result = _fflush_r(errorCode,inputData), result != 0)) goto LAB_00083da2;\n          }\n          else {\n            dataPtr = (void *)0x7fffffff;\n            if (ptr3 < (void *)0x7fffffff) {\n              dataPtr = ptr3;\n            }\n            dataPtr = (void *)(*(code *)inputData[9])\n                                        (errorCode,inputData[7],dataOffset,\n                                         ((uint)dataPtr / (uint)ptr1) * (int)ptr1);\n            if ((int)dataPtr < 1) goto LAB_00083da2;\n          }\n          result = bufferInfo[2];\n          dataOffset = (void *)((int)dataOffset + (int)dataPtr);\n          ptr3 = (void *)((int)ptr3 - (int)dataPtr);\n          bufferInfo[2] = result - (int)dataPtr;\n          if (result - (int)dataPtr == 0) break;\n          flagValue = (uint)*(ushort *)(inputData + 3);\n        }\n      }\n      else {\n        do {\n          while (ptr3 == (void *)0x0) {\n            dataPtr = *buffer;\n            ptr3 = buffer[1];\n            localFlag = (void *)0x0;\n            buffer = buffer + 2;\n          }\n          if (localFlag == (void *)0x0) {\n            dataOffset = memchr(dataPtr,10,(size_t)ptr3);\n            if (dataOffset == (void *)0x0) {\n              dataOffset = (void *)((int)ptr3 + 1);\n              localFlag = (void *)0x1;\n            }\n            else {\n              dataOffset = (void *)((int)dataOffset + (1 - (int)dataPtr));\n              localFlag = (void *)0x1;\n            }\n          }\n          ptr2 = *inputData;\n          ptr1 = dataOffset;\n          if (ptr3 <= dataOffset) {\n            ptr1 = ptr3;\n          }\n          ptr4 = inputData[5];\n          if ((inputData[4] < ptr2) &&\n             (numBytes = (void *)((int)inputData[2] + (int)ptr4), (int)numBytes < (int)ptr1)) {\n            memmove(ptr2,dataPtr,(size_t)numBytes);\n            *inputData = (void *)((int)*inputData + (int)numBytes);\n            result = _fflush_r(errorCode,inputData);\n            if (result != 0) goto LAB_00083da2;\n          }\n          else if ((int)ptr1 < (int)ptr4) {\n            memmove(ptr2,dataPtr,(size_t)ptr1);\n            inputData[2] = (void *)((int)inputData[2] - (int)ptr1);\n            *inputData = (void *)((int)ptr1 + (int)*inputData);\n            numBytes = ptr1;\n          }\n          else {\n            numBytes = (void *)(*(code *)inputData[9])(errorCode,inputData[7],dataPtr,ptr4);\n            if ((int)numBytes < 1) goto LAB_00083da2;\n          }\n          dataOffset = (void *)((int)dataOffset - (int)numBytes);\n          if (dataOffset == (void *)0x0) {\n            result = _fflush_r(errorCode,inputData);\n            if (result != 0) goto LAB_00083da2;\n            localFlag = (void *)0x0;\n          }\n          result = bufferInfo[2];\n          dataPtr = (void *)((int)dataPtr + (int)numBytes);\n          ptr3 = (void *)((int)ptr3 - (int)numBytes);\n          bufferInfo[2] = result - (int)numBytes;\n        } while (result - (int)numBytes != 0);\n      }\n    }\n    else {\n      dataOffset = (void *)0x0;\n      ptr3 = (void *)0x0;\n      do {\n        while( true ) {\n          dataPtr = ptr3;\n          if ((void *)0x7ffffbff < ptr3) {\n            dataPtr = (void *)0x7ffffc00;\n          }\n          if (ptr3 != (void *)0x0) break;\n          dataOffset = *buffer;\n          ptr3 = buffer[1];\n          buffer = buffer + 2;\n        }\n        result = (*(code *)inputData[9])(errorCode,inputData[7],dataOffset,dataPtr);\n        if (result < 1) {\nLAB_00083da2:\n          flag = *(ushort *)(inputData + 3);\nLAB_00083da4:\n          *(ushort *)(inputData + 3) = flag | 0x40;\n          return 0xffffffff;\n        }\n        bufferSize = bufferInfo[2];\n        dataOffset = (void *)((int)dataOffset + result);\n        ptr3 = (void *)((int)ptr3 - result);\n        bufferInfo[2] = bufferSize - result;\n      } while (bufferSize - result != 0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083ca8": "process_data_00083ca8",
                "param_1": "errorCode",
                "param_2": "inputData",
                "param_3": "bufferInfo",
                "ppvVar1": "tempPtr1",
                "iVar2": "result",
                "pvVar3": "ptr1",
                "pvVar4": "ptr2",
                "pvVar5": "ptr3",
                "pvVar6": "ptr4",
                "uVar7": "flag",
                "uVar8": "flagValue",
                "iVar9": "bufferSize",
                "ppvVar10": "buffer",
                "pvVar11": "dataPtr",
                "pvVar12": "dataOffset",
                "__n": "numBytes",
                "__n_00": "bufferOffset",
                "local_2c": "localFlag"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "memchr",
                "memmove",
                "_malloc_r",
                "__swsetup_r",
                "_fflush_r",
                "_realloc_r",
                "memcpy",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083fbc": {
            "entrypoint": "0x00083fbc",
            "current_name": "process_data_00083fbc",
            "code": "\nuint processData_00083fbc(int dataSize,code *callbackFunction)\n\n{\n  uint result;\n  int offset;\n  int count;\n  uint combinedResult;\n  int *currentPtr;\n  \n  currentPtr = (int *)(dataSize + 0x2e0);\n  if (currentPtr != (int *)0x0) {\n    combinedResult = 0;\n    do {\n      offset = currentPtr[2];\n      count = currentPtr[1] + -1;\n      if (-1 < count) {\n        do {\n          count = count + -1;\n          if ((1 < *(ushort *)(offset + 0xc)) && (*(short *)(offset + 0xe) != -1)) {\n            result = (*callbackFunction)(offset);\n            combinedResult = combinedResult | result;\n          }\n          offset = offset + 0x68;\n        } while (count != -1);\n      }\n      currentPtr = (int *)*currentPtr;\n    } while (currentPtr != (int *)0x0);\n    return combinedResult;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083fbc": "process_data_00083fbc",
                "param_1": "dataSize",
                "param_2": "callbackFunction",
                "uVar1": "result",
                "iVar2": "offset",
                "iVar3": "count",
                "uVar4": "combinedResult",
                "piVar5": "currentPtr"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084004": {
            "entrypoint": "0x00084004",
            "current_name": "get_charset_00084004",
            "code": "\nchar * getCharset_00084004(void)\n\n{\n  return charset;\n}\n\n",
            "renaming": {
                "FUN_00084004": "get_charset_00084004",
                "lc_ctype_charset": "charset"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008400c": {
            "entrypoint": "0x0008400c",
            "current_name": "get_max_multibyte_character_length_0008400c",
            "code": "\nundefined4 getMaxMultibyteCharacterLength_0008400c(void)\n\n{\n  return maxMultibyteLength;\n}\n\n",
            "renaming": {
                "FUN_0008400c": "get_max_multibyte_character_length_0008400c",
                "__mb_cur_max": "maxMultibyteLength"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084018": {
            "entrypoint": "0x00084018",
            "current_name": "initialize_file_00084018",
            "code": "\nvoid initializeFile_00084018(int fileDescriptor,int *fileInfo)\n\n{\n  ushort fileAttributes;\n  int fileStatus;\n  int mallocResult;\n  uint ushortVar;\n  bool isRegularFile;\n  undefined statBuffer [4];\n  uint localVar;\n  \n  fileAttributes = *(ushort *)(fileInfo + 3);\n  ushortVar = (uint)fileAttributes;\n  if ((int)(ushortVar << 0x1e) < 0) {\n    *fileInfo = (int)fileInfo + 0x43;\n    fileInfo[4] = (int)fileInfo + 0x43;\n    fileInfo[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)fileInfo + 0xe)) {\n    fileStatus = _fstat_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe),statBuffer);\n    if (-1 < fileStatus) {\n      isRegularFile = (localVar & 0xf000) == 0x2000;\n      if (((localVar & 0xf000) == 0x8000) && (fileInfo[10] == 0x8427d)) {\n        fileStatus = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x400;\n        fileInfo[0x13] = 0x400;\n      }\n      else {\n        fileStatus = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x800;\n      }\n      goto LAB_00084074;\n    }\n    fileAttributes = *(ushort *)(fileInfo + 3);\n    ushortVar = (uint)fileAttributes;\n  }\n  *(ushort *)(fileInfo + 3) = fileAttributes | 0x800;\n  if ((ushortVar & 0x80) == 0) {\n    fileStatus = 0x400;\n  }\n  else {\n    fileStatus = 0x40;\n  }\n  isRegularFile = false;\nLAB_00084074:\n  mallocResult = _malloc_r(fileDescriptor,fileStatus);\n  fileAttributes = *(ushort *)(fileInfo + 3);\n  if (mallocResult == 0) {\n    if (-1 < (int)((uint)fileAttributes << 0x16)) {\n      *(ushort *)(fileInfo + 3) = fileAttributes | 2;\n      *fileInfo = (int)fileInfo + 0x43;\n      fileInfo[4] = (int)fileInfo + 0x43;\n      fileInfo[5] = 1;\n    }\n  }\n  else {\n    *(undefined4 *)(fileDescriptor + 0x3c) = 0x8387d;\n    *(ushort *)(fileInfo + 3) = fileAttributes | 0x80;\n    *fileInfo = mallocResult;\n    fileInfo[4] = mallocResult;\n    fileInfo[5] = fileStatus;\n    if ((isRegularFile) && (fileStatus = _isatty_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe)), fileStatus != 0)) {\n      *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084018": "initialize_file_00084018",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "uVar1": "fileAttributes",
                "iVar2": "fileStatus",
                "iVar3": "mallocResult",
                "uVar4": "ushortVar",
                "bVar5": "isRegularFile",
                "auStack_54": "statBuffer",
                "local_50": "localVar"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_fstat_r",
                "_isatty_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000840f8": {
            "entrypoint": "0x000840f8",
            "current_name": "find_byte_sequence_000840f8",
            "code": "\nvoid * find_byte_sequence_000840f8(void *input,int byte_to_find,size_t length)\n\n{\n  uint byte_value;\n  uint result;\n  int count;\n  uint *ptr;\n  uint mask;\n  bool found;\n  \n  byte_value = byte_to_find & 0xff;\n  if (((uint)input & 3) == 0) {\nLAB_00084128:\n    if (3 < length) {\n      mask = byte_value | byte_value << 8;\n      ptr = (uint *)input;\n      do {\n        result = *ptr ^ (mask | mask << 0x10);\n        input = ptr;\n        if ((result + 0xfefefeff & ~result & 0x80808080) != 0) break;\n        length = length - 4;\n        input = ptr + 1;\n        ptr = ptr + 1;\n      } while (3 < length);\n    }\n    if (length == 0) {\n      input = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*input != byte_value) {\n        count = 0;\n        do {\n          input = (void *)((int)input + 1);\n          found = count == length - 1;\n          count = count + 1;\n          if (found) goto LAB_00084150;\n                    /* WARNING: Load size is inaccurate */\n        } while (*input != byte_value);\n      }\n    }\n  }\n  else if (length == 0) {\nLAB_00084150:\n    input = (uint *)0x0;\n  }\n  else {\n                    /* WARNING: Load size is inaccurate */\n    if (*input != byte_value) {\n      ptr = (uint *)((int)input + 1);\n      length = length - 1;\n      do {\n        input = ptr;\n        if (((uint)input & 3) == 0) goto LAB_00084128;\n        if (length == 0) goto LAB_00084150;\n                    /* WARNING: Load size is inaccurate */\n        ptr = (uint *)((int)input + 1);\n        length = length - 1;\n      } while (*input != byte_value);\n    }\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_000840f8": "find_byte_sequence_000840f8",
                "__s": "input",
                "__c": "byte_to_find",
                "__n": "length",
                "uVar1": "byte_value",
                "uVar2": "result",
                "iVar3": "count",
                "puVar4": "ptr",
                "uVar5": "mask",
                "bVar6": "found"
            },
            "calling": [
                "_vfiprintf_r",
                "__sfvwrite_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008418c": {
            "entrypoint": "0x0008418c",
            "current_name": "handle_signal_0008418c",
            "code": "\nundefined4 handleSignal_0008418c(undefined4 *output,uint signal,undefined4 param1,undefined4 param2)\n\n{\n  __pid_t processID;\n  undefined4 killResult;\n  int dataPointer;\n  code *functionPtr;\n  \n  if (0x1f < signal) {\n    *output = 0x16;\n    return 0xffffffff;\n  }\n  dataPointer = output[0xb7];\n  if ((dataPointer == 0) || (functionPtr = *(code **)(dataPointer + signal * 4), functionPtr == (code *)0x0)) {\n    processID = _getpid_r();\n    killResult = _kill_r(output,processID,signal,param2);\n    return killResult;\n  }\n  if (functionPtr == (code *)0x1) {\n    return 0;\n  }\n  if (functionPtr != (code *)0xffffffff) {\n    *(undefined4 *)(dataPointer + signal * 4) = 0;\n    (*functionPtr)(signal);\n    return 0;\n  }\n  *output = 0x16;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0008418c": "handle_signal_0008418c",
                "param_1": "output",
                "param_2": "signal",
                "param_3": "param1",
                "param_4": "param2",
                "_Var1": "processID",
                "uVar2": "killResult",
                "iVar3": "dataPointer",
                "pcVar4": "functionPtr"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_kill_r",
                "_getpid_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841e4": {
            "entrypoint": "0x000841e4",
            "current_name": "request_signal_handling_000841e4",
            "code": "\nint requestSignalHandling_000841e4(int signalNumber)\n\n{\n  int raiseResult;\n  \n  raiseResult = _raise_r(_impure_ptr,signalNumber);\n  return raiseResult;\n}\n\n",
            "renaming": {
                "FUN_000841e4": "request_signal_handling_000841e4",
                "__sig": "signalNumber",
                "iVar1": "raiseResult"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841f4": {
            "entrypoint": "0x000841f4",
            "current_name": "send_signal_000841f4",
            "code": "\nvoid sendSignal_000841f4(int *errorPointer,int processID,int signalNumber)\n\n{\n  errorNumber = 0;\n  _kill(processID,signalNumber);\n  if ((processID == -1) && (errorNumber != 0)) {\n    *errorPointer = errorNumber;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000841f4": "send_signal_000841f4",
                "param_1": "errorPointer",
                "param_2": "processID",
                "param_3": "signalNumber",
                "errno": "errorNumber"
            },
            "calling": [
                "kill",
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008421c": {
            "entrypoint": "0x0008421c",
            "current_name": "FUN_0008421c",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return -1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084220": {
            "entrypoint": "0x00084220",
            "current_name": "update_data_00084220",
            "code": "\nvoid updateData_00084220(undefined4 fileDescriptor,int dataPointer)\n\n{\n  int bytesRead;\n  \n  bytesRead = _read_r(fileDescriptor,(int)*(short *)(dataPointer + 0xe));\n  if (-1 < bytesRead) {\n    *(int *)(dataPointer + 0x50) = *(int *)(dataPointer + 0x50) + bytesRead;\n    return;\n  }\n  *(ushort *)(dataPointer + 0xc) = *(ushort *)(dataPointer + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084220": "update_data_00084220",
                "param_1": "fileDescriptor",
                "param_2": "dataPointer",
                "iVar1": "bytesRead"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084244": {
            "entrypoint": "0x00084244",
            "current_name": "rewrite_function_00084244",
            "code": "\nvoid rewrite_function_00084244(undefined4 file_descriptor,int buffer_address,undefined4 data_address,undefined4 data_size)\n\n{\n  ushort buffer_value;\n  \n  buffer_value = *(ushort *)(buffer_address + 0xc);\n  if ((int)((uint)buffer_value << 0x17) < 0) {\n    reposition_file_pointer(file_descriptor,(int)*(short *)(buffer_address + 0xe),0,2);\n    buffer_value = *(ushort *)(buffer_address + 0xc);\n  }\n  *(ushort *)(buffer_address + 0xc) = buffer_value & 0xefff;\n  write_data_to_file(file_descriptor,(int)*(short *)(buffer_address + 0xe),data_address,data_size);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084244": "rewrite_function_00084244",
                "param_1": "file_descriptor",
                "param_2": "buffer_address",
                "param_3": "data_address",
                "param_4": "data_size",
                "uVar1": "buffer_value",
                "_lseek_r": "reposition_file_pointer",
                "_write_r": "write_data_to_file"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008427c": {
            "entrypoint": "0x0008427c",
            "current_name": "update_file_attributes_0008427c",
            "code": "\nvoid updateFileAttributes_0008427c(undefined4 fileDescriptor,int fileInfo)\n\n{\n  int seekResult;\n  ushort updatedAttributes;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(fileInfo + 0xe));\n  if (seekResult == -1) {\n    updatedAttributes = *(ushort *)(fileInfo + 0xc) & 0xefff;\n  }\n  else {\n    updatedAttributes = *(ushort *)(fileInfo + 0xc) | 0x1000;\n  }\n  if (seekResult != -1) {\n    *(int *)(fileInfo + 0x50) = seekResult;\n  }\n  *(ushort *)(fileInfo + 0xc) = updatedAttributes;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008427c": "update_file_attributes_0008427c",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "iVar1": "seekResult",
                "uVar2": "updatedAttributes"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008429c": {
            "entrypoint": "0x0008429c",
            "current_name": "close_file_0008429c",
            "code": "\nvoid closeFile_0008429c(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008429c": "close_file_0008429c",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "process_data_000842a4",
            "code": "\nuint processData_000842a4(int input,uint flags,undefined4 *buffer,undefined4 length)\n\n{\n  ushort flagsMask;\n  uint maskedFlags;\n  undefined *bufferPtr;\n  int offset;\n  \n  if ((input != 0) && (*(int *)(input + 0x38) == 0)) {\n    initialize();\n  }\n  flagsMask = *(ushort *)(buffer + 3);\n  maskedFlags = (uint)flagsMask;\n  buffer[2] = buffer[6];\n  if ((-1 < (int)(maskedFlags << 0x1c)) || (offset = buffer[4], offset == 0)) {\n    offset = _setupR(input,buffer,flagsMask,maskedFlags,length);\n    if (offset != 0) {\n      return 0xffffffff;\n    }\n    flagsMask = *(ushort *)(buffer + 3);\n    offset = buffer[4];\n    maskedFlags = (uint)flagsMask;\n  }\n  flags = flags & 0xff;\n  if ((int)(maskedFlags << 0x12) < 0) {\n    bufferPtr = (undefined *)*buffer;\n    offset = (int)bufferPtr - offset;\n    if (offset < (int)buffer[5]) {\nLAB_000842d6:\n      offset = offset + 1;\n      goto LAB_000842d8;\n    }\n  }\n  else {\n    buffer[0x19] = buffer[0x19] & 0xffffdfff;\n    bufferPtr = (undefined *)*buffer;\n    *(ushort *)(buffer + 3) = flagsMask | 0x2000;\n    offset = (int)bufferPtr - offset;\n    if (offset < (int)buffer[5]) goto LAB_000842d6;\n  }\n  offset = clearBuffer(input,buffer);\n  if (offset != 0) {\n    return 0xffffffff;\n  }\n  bufferPtr = (undefined *)*buffer;\n  offset = 1;\nLAB_000842d8:\n  buffer[2] = buffer[2] + -1;\n  *buffer = bufferPtr + 1;\n  *bufferPtr = (char)flags;\n  if (((buffer[5] == offset) ||\n      (((int)((uint)*(ushort *)(buffer + 3) << 0x1f) < 0 && (flags == 10)))) &&\n     (offset = clearBuffer(input,buffer), offset != 0)) {\n    return 0xffffffff;\n  }\n  return flags;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "process_data_000842a4",
                "param_1": "input",
                "param_2": "flags",
                "param_3": "buffer",
                "param_4": "length",
                "uVar1": "flagsMask",
                "uVar2": "maskedFlags",
                "puVar3": "bufferPtr",
                "iVar4": "offset",
                "_fflush_r": "clearBuffer",
                "_swsetup_r": "setupR",
                "__sinit": "initialize"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__sinit",
                "__swsetup_r",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008434c": {
            "entrypoint": "0x0008434c",
            "current_name": "convert_to_locale_char_0008434c",
            "code": "\nvoid convertToLocaleChar_0008434c(undefined4 *outputBuffer,int bufferLength,undefined4 extraParams,undefined4 *errorCode)\n\n{\n  code *conversionFunc;\n  undefined4 localeCharset;\n  int conversionResult;\n  undefined tempBuffer [12];\n  \n  conversionFunc = __wctomb;\n  if (bufferLength == 0) {\n    localeCharset = __locale_charset();\n    conversionResult = (*conversionFunc)(outputBuffer,tempBuffer,0,localeCharset,errorCode);\n  }\n  else {\n    localeCharset = __locale_charset();\n    conversionResult = (*conversionFunc)(outputBuffer,bufferLength,extraParams,localeCharset,errorCode);\n  }\n  if (conversionResult == -1) {\n    *errorCode = 0;\n    *outputBuffer = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008434c": "convert_to_locale_char_0008434c",
                "param_1": "outputBuffer",
                "param_2": "bufferLength",
                "param_3": "extraParams",
                "param_4": "errorCode",
                "pcVar1": "conversionFunc",
                "uVar2": "localeCharset",
                "iVar3": "conversionResult",
                "auStack_24": "tempBuffer"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__ascii_wctomb",
                "__locale_charset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008439c": {
            "entrypoint": "0x0008439c",
            "current_name": "write_value_to_memory_0008439c",
            "code": "\nundefined4 write_value_to_memory_0008439c(undefined4 *output_buffer,undefined *input_buffer,uint value)\n\n{\n  if (input_buffer == (undefined *)0x0) {\n    return 0;\n  }\n  if (value < 0x100) {\n    *input_buffer = (char)value;\n    return 1;\n  }\n  *output_buffer = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0008439c": "write_value_to_memory_0008439c",
                "param_1": "output_buffer",
                "param_2": "input_buffer",
                "param_3": "value"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000843b8": {
            "entrypoint": "0x000843b8",
            "current_name": "write_to_stream_000843b8",
            "code": "\nvoid writeToStream_000843b8(int *errorFlag,int streamDescriptor,char *buffer,int length)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(streamDescriptor,buffer,length);\n  if ((writeResult == -1) && (errno != 0)) {\n    *errorFlag = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000843b8": "write_to_stream_000843b8",
                "param_1": "errorFlag",
                "param_2": "streamDescriptor",
                "param_3": "buffer",
                "param_4": "length",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000843e0": {
            "entrypoint": "0x000843e0",
            "current_name": "close_file_000843e0",
            "code": "\nvoid closeFile_000843e0(int *errorCode,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000843e0": "close_file_000843e0",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084404": {
            "entrypoint": "0x00084404",
            "current_name": "flush_file_00084404",
            "code": "\nundefined4 flushFile_00084404(int filePtr,int streamPtr)\n\n{\n  undefined4 result;\n  int callbackResult;\n  \n  if (streamPtr != 0) {\n    if ((filePtr != 0) && (*(int *)(filePtr + 0x38) == 0)) {\n      __sinit();\n    }\n    if (*(short *)(streamPtr + 0xc) != 0) {\n      result = _fflush_r(filePtr,streamPtr);\n      if ((*(code **)(streamPtr + 0x2c) != (code *)0x0) &&\n         (callbackResult = (**(code **)(streamPtr + 0x2c))(filePtr,*(undefined4 *)(streamPtr + 0x1c)), callbackResult < 0)\n         ) {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(streamPtr + 0xc) << 0x18) < 0) {\n        _free_r(filePtr,*(undefined4 *)(streamPtr + 0x10));\n      }\n      if (*(int *)(streamPtr + 0x30) != 0) {\n        if (*(int *)(streamPtr + 0x30) != streamPtr + 0x40) {\n          _free_r(filePtr);\n        }\n        *(undefined4 *)(streamPtr + 0x30) = 0;\n      }\n      if (*(int *)(streamPtr + 0x44) != 0) {\n        _free_r(filePtr);\n        *(undefined4 *)(streamPtr + 0x44) = 0;\n      }\n      __sfp_lock_acquire();\n      *(undefined2 *)(streamPtr + 0xc) = 0;\n      __sfp_lock_release();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084404": "flush_file_00084404",
                "param_1": "filePtr",
                "param_2": "streamPtr",
                "uVar1": "result",
                "iVar2": "callbackResult"
            },
            "calling": [
                "fclose"
            ],
            "called": [
                "__sfp_lock_acquire",
                "__sinit",
                "__sfp_lock_release",
                "_fflush_r",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084484": {
            "entrypoint": "0x00084484",
            "current_name": "close_file_00084484",
            "code": "\nint closeFile_00084484(FILE *stream)\n\n{\n  int result;\n  \n  result = _fclose_r(_impure_ptr,stream);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00084484": "close_file_00084484",
                "__stream": "stream",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_fclose_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084494": {
            "entrypoint": "0x00084494",
            "current_name": "get_file_status_00084494",
            "code": "\nvoid get_file_status_00084494(int *error_code,int file_descriptor,stat *file_status)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _fstat(file_descriptor,file_status);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084494": "get_file_status_00084494",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_status",
                "iVar1": "result"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "check_is_tty_000844bc",
            "code": "\nvoid checkIsTTY_000844bc(int *errorPtr,int fileDescriptor)\n\n{\n  int isTTYResult;\n  \n  errno = 0;\n  isTTYResult = _isatty(fileDescriptor);\n  if ((isTTYResult == -1) && (errno != 0)) {\n    *errorPtr = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "check_is_tty_000844bc",
                "param_1": "errorPtr",
                "param_2": "fileDescriptor",
                "iVar1": "isTTYResult"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844e0": {
            "entrypoint": "0x000844e0",
            "current_name": "update_file_pointer_000844e0",
            "code": "\nvoid updateFilePointer_000844e0(int *errorPointer,int fileDescriptor,__off_t offset,int seekType)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDescriptor,offset,seekType);\n  if ((result == -1) && (errno != 0)) {\n    *errorPointer = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844e0": "update_file_pointer_000844e0",
                "param_1": "errorPointer",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "seekType",
                "_Var1": "result"
            },
            "calling": [
                "__sseek",
                "__swrite"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084508": {
            "entrypoint": "0x00084508",
            "current_name": "read_and_store_00084508",
            "code": "\nvoid readAndStore_00084508(int *errorFlag,int fileDescriptor,char *buffer,int count)\n\n{\n  int bytesRead;\n  \n  errno = 0;\n  bytesRead = _read(fileDescriptor,buffer,count);\n  if ((bytesRead == -1) && (errno != 0)) {\n    *errorFlag = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084508": "read_and_store_00084508",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084530": {
            "entrypoint": "0x00084530",
            "current_name": "div_mod_helper_00084530",
            "code": "\nvoid divModHelper_00084530(int dividend,int divisor,int quotient,int remainder)\n\n{\n  if ((remainder == 0) && (quotient == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend);\n    return;\n  }\n  __gnu_uldivmod_helper();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084530": "div_mod_helper_00084530",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__gnu_uldivmod_helper",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008455c": {
            "entrypoint": "0x0008455c",
            "current_name": "subtract_and_update_0008455c",
            "code": "\nvoid subtract_and_update_0008455c(uint input_value,int length,undefined4 lower_bits,undefined4 upper_bits,int *output_array)\n\n{\n  uint result;\n  longlong product;\n  \n  product = __divdi3();\n  product = product * CONCAT44(upper_bits,lower_bits);\n  result = (uint)product;\n  *output_array = input_value - result;\n  output_array[1] = (length - (int)((ulonglong)product >> 0x20)) - (uint)(input_value < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008455c": "subtract_and_update_0008455c",
                "param_1": "input_value",
                "param_2": "length",
                "param_3": "lower_bits",
                "param_4": "upper_bits",
                "param_5": "output_array",
                "uVar1": "result",
                "lVar2": "product"
            },
            "calling": [],
            "called": [
                "__divdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008458c": {
            "entrypoint": "0x0008458c",
            "current_name": "calculate_difference_0008458c",
            "code": "\nvoid calculate_difference_0008458c(uint value_1,int value_2,undefined4 operand_1,undefined4 operand_2,int *result_array)\n\n{\n  uint product;\n  longlong quotient;\n  \n  quotient = __udivdi3();\n  quotient = quotient * CONCAT44(operand_2,operand_1);\n  product = (uint)quotient;\n  *result_array = value_1 - product;\n  result_array[1] = (value_2 - (int)((ulonglong)quotient >> 0x20)) - (uint)(value_1 < product);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008458c": "calculate_difference_0008458c",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "operand_1",
                "param_4": "operand_2",
                "param_5": "result_array",
                "uVar1": "product",
                "lVar2": "quotient"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [
                "__udivdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845bc": {
            "entrypoint": "0x000845bc",
            "current_name": "FUNC_000845bc",
            "code": "\nvoid FUNC_000845bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000845bc": "FUNC_000845bc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000845c0": {
            "entrypoint": "0x000845c0",
            "current_name": "divide_unsigned_integers_000845c0",
            "code": "\nundefined8 divideUnsignedIntegers_000845c0(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong product;\n  uint quotient1;\n  uint quotient2;\n  uint uVar4;\n  uint uVar5;\n  int shiftAmount;\n  uint uVar7;\n  uint uVar8;\n  uint isDividendNegative;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool hasCarry;\n  \n  if ((int)divisor < 0) {\n    hasCarry = dividend != 0;\n    dividend = -dividend;\n    divisor = -divisor - (uint)hasCarry;\n    isDividendNegative = 0xffffffff;\n  }\n  else {\n    isDividendNegative = 0;\n  }\n  if ((int)remainder < 0) {\n    isDividendNegative = ~isDividendNegative;\n    hasCarry = quotient != 0;\n    quotient = -quotient;\n    remainder = -remainder - (uint)hasCarry;\n  }\n  if (remainder == 0) {\n    if (divisor < quotient) {\n      shiftAmount = LZCOUNT(quotient);\n      if (shiftAmount != 0) {\n        quotient2 = dividend >> (0x20U - shiftAmount & 0xff);\n        quotient = quotient << shiftAmount;\n        dividend = dividend << shiftAmount;\n        divisor = divisor << shiftAmount | quotient2;\n      }\n      quotient1 = quotient >> 0x10;\n      uVar4 = divisor / quotient1;\n      uVar7 = (quotient & 0xffff) * uVar4;\n      uVar10 = dividend >> 0x10 | (divisor - quotient1 * uVar4) * 0x10000;\n      quotient2 = uVar4;\n      if (uVar10 <= uVar7 && uVar7 - uVar10 != 0) {\n        hasCarry = CARRY4(uVar10,quotient);\n        uVar10 = uVar10 + quotient;\n        quotient2 = uVar4 - 1;\n        if ((hasCarry == false) && (uVar10 <= uVar7 && uVar7 - uVar10 != 0)) {\n          quotient2 = uVar4 - 2;\n          uVar10 = uVar10 + quotient;\n        }\n      }\n      uVar8 = (uVar10 - uVar7) / quotient1;\n      uVar4 = (quotient & 0xffff) * uVar8;\n      uVar7 = dividend & 0xffff | ((uVar10 - uVar7) - quotient1 * uVar8) * 0x10000;\n      quotient1 = uVar8;\n      if (uVar7 <= uVar4 && uVar4 - uVar7 != 0) {\n        quotient1 = uVar8 - 1;\n        if ((CARRY4(uVar7,quotient) == false) &&\n           (uVar7 + quotient <= uVar4 && uVar4 - (uVar7 + quotient) != 0)) {\n          quotient1 = uVar8 - 2;\n        }\n      }\n      quotient1 = quotient1 | quotient2 << 0x10;\n      quotient2 = 0;\n    }\n    else {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      shiftAmount = LZCOUNT(quotient);\n      if (shiftAmount == 0) {\n        divisor = divisor - quotient;\n        uVar4 = quotient >> 0x10;\n        uVar12 = quotient & 0xffff;\n        quotient2 = 1;\n      }\n      else {\n        quotient = quotient << shiftAmount;\n        quotient2 = divisor >> (0x20U - shiftAmount & 0xff);\n        uVar4 = quotient >> 0x10;\n        uVar10 = quotient2 / uVar4;\n        uVar12 = quotient & 0xffff;\n        uVar7 = uVar12 * uVar10;\n        uVar8 = dividend >> (0x20U - shiftAmount & 0xff) | divisor << shiftAmount;\n        quotient2 = uVar8 >> 0x10 | (quotient2 - uVar4 * uVar10) * 0x10000;\n        dividend = dividend << shiftAmount;\n        quotient1 = uVar10;\n        if (quotient2 <= uVar7 && uVar7 - quotient2 != 0) {\n          hasCarry = CARRY4(quotient2,quotient);\n          quotient2 = quotient2 + quotient;\n          quotient1 = uVar10 - 1;\n          if ((hasCarry == false) && (quotient2 <= uVar7 && uVar7 - quotient2 != 0)) {\n            quotient1 = uVar10 - 2;\n            quotient2 = quotient2 + quotient;\n          }\n        }\n        uVar5 = (quotient2 - uVar7) / uVar4;\n        uVar10 = uVar12 * uVar5;\n        divisor = uVar8 & 0xffff | ((quotient2 - uVar7) - uVar4 * uVar5) * 0x10000;\n        quotient2 = uVar5;\n        if (divisor <= uVar10 && uVar10 - divisor != 0) {\n          hasCarry = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          quotient2 = uVar5 - 1;\n          if ((hasCarry == false) && (divisor <= uVar10 && uVar10 - divisor != 0)) {\n            quotient2 = uVar5 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - uVar10;\n        quotient2 = quotient2 | quotient1 << 0x10;\n      }\n      quotient1 = divisor / uVar4;\n      uVar10 = uVar12 * quotient1;\n      uVar8 = dividend >> 0x10 | (divisor - uVar4 * quotient1) * 0x10000;\n      uVar7 = quotient1;\n      if (uVar8 <= uVar10 && uVar10 - uVar8 != 0) {\n        hasCarry = CARRY4(uVar8,quotient);\n        uVar8 = uVar8 + quotient;\n        uVar7 = quotient1 - 1;\n        if ((hasCarry == false) && (uVar8 <= uVar10 && uVar10 - uVar8 != 0)) {\n          uVar7 = quotient1 - 2;\n          uVar8 = uVar8 + quotient;\n        }\n      }\n      uVar5 = (uVar8 - uVar10) / uVar4;\n      uVar12 = uVar12 * uVar5;\n      uVar4 = dividend & 0xffff | ((uVar8 - uVar10) - uVar4 * uVar5) * 0x10000;\n      quotient1 = uVar5;\n      if (uVar4 <= uVar12 && uVar12 - uVar4 != 0) {\n        quotient1 = uVar5 - 1;\n        if ((CARRY4(uVar4,quotient) == false) &&\n           (uVar4 + quotient <= uVar12 && uVar12 - (uVar4 + quotient) != 0)) {\n          quotient1 = uVar5 - 2;\n        }\n      }\n      quotient1 = quotient1 | uVar7 << 0x10;\n    }\n  }\n  else if (divisor < remainder) {\n    quotient2 = 0;\n    quotient1 = 0;\n  }\n  else {\n    shiftAmount = LZCOUNT(remainder);\n    if (shiftAmount == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        quotient2 = 0;\n        quotient1 = 1;\n      }\n      else {\n        quotient1 = 0;\n        quotient2 = 0;\n      }\n    }\n    else {\n      quotient2 = 0x20 - shiftAmount;\n      uVar4 = divisor >> (quotient2 & 0xff);\n      uVar12 = quotient >> (quotient2 & 0xff) | remainder << shiftAmount;\n      uVar10 = uVar12 >> 0x10;\n      quotient1 = uVar4 / uVar10;\n      uVar8 = (uVar12 & 0xffff) * quotient1;\n      uVar7 = divisor << shiftAmount | dividend >> (quotient2 & 0xff);\n      uVar4 = uVar7 >> 0x10 | (uVar4 - uVar10 * quotient1) * 0x10000;\n      quotient2 = quotient1;\n      if (uVar4 <= uVar8 && uVar8 - uVar4 != 0) {\n        hasCarry = CARRY4(uVar4,uVar12);\n        uVar4 = uVar4 + uVar12;\n        quotient2 = quotient1 - 1;\n        if ((hasCarry == false) && (uVar4 <= uVar8 && uVar8 - uVar4 != 0)) {\n          quotient2 = quotient1 - 2;\n          uVar4 = uVar4 + uVar12;\n        }\n      }\n      uVar5 = (uVar4 - uVar8) / uVar10;\n      uVar11 = (uVar12 & 0xffff) * uVar5;\n      uVar4 = uVar7 & 0xffff | ((uVar4 - uVar8) - uVar10 * uVar5) * 0x10000;\n      quotient1 = uVar5;\n      if (uVar4 <= uVar11 && uVar11 - uVar4 != 0) {\n        hasCarry = CARRY4(uVar4,uVar12);\n        uVar4 = uVar4 + uVar12;\n        quotient1 = uVar5 - 1;\n        if ((hasCarry == false) && (uVar4 <= uVar11 && uVar11 - uVar4 != 0)) {\n          quotient1 = uVar5 - 2;\n          uVar4 = uVar4 + uVar12;\n        }\n      }\n      quotient1 = quotient1 | quotient2 << 0x10;\n      product = (ulonglong)quotient1 * (ulonglong)(quotient << shiftAmount);\n      uVar7 = (uint)((ulonglong)product >> 0x20);\n      quotient2 = 0;\n      if ((uVar4 - uVar11 < uVar7) ||\n         ((uVar4 - uVar11 == uVar7 && (dividend << shiftAmount < (uint)product)))) {\n        quotient1 = quotient1 - 1;\n        quotient2 = 0;\n      }\n    }\n  }\n  if (isDividendNegative != 0) {\n    hasCarry = quotient1 != 0;\n    quotient1 = -quotient1;\n    quotient2 = -quotient2 - (uint)hasCarry;\n  }\n  return CONCAT44(quotient2,quotient1);\n}\n\n",
            "renaming": {
                "FUN_000845c0": "divide_unsigned_integers_000845c0",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "product",
                "uVar2": "quotient1",
                "uVar3": "quotient2",
                "iVar6": "shiftAmount",
                "uVar9": "isDividendNegative",
                "bVar13": "hasCarry"
            },
            "calling": [
                "__gnu_ldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084860": {
            "entrypoint": "0x00084860",
            "current_name": "calculate_division_00084860",
            "code": "\nulonglong calculateDivision_00084860(uint dividend,uint divisor,uint quotient_1,uint quotient_2)\n\n{\n  longlong temp;\n  uint final_quotient;\n  uint temp_quotient;\n  uint remainder;\n  uint temp_remainder;\n  uint dividend_shifted_left;\n  uint quotient_1_shifted;\n  uint quotient_2_shifted;\n  uint remainder_shifted;\n  int shift_amount;\n  bool carry_flag;\n  \n  if (quotient_2 == 0) {\n    if (quotient_1 <= divisor) {\n      if (quotient_1 == 0) {\n        quotient_1 = 1 / 0;\n      }\n      shift_amount = LZCOUNT(quotient_1);\n      if (shift_amount == 0) {\n        divisor = divisor - quotient_1;\n        temp_quotient = quotient_1 >> 0x10;\n        temp_remainder = quotient_1 & 0xffff;\n        final_quotient = 1;\n      }\n      else {\n        quotient_1 = quotient_1 << shift_amount;\n        quotient_2_shifted = divisor >> (0x20U - shift_amount & 0xff);\n        temp_quotient = quotient_1 >> 0x10;\n        remainder_shifted = quotient_2_shifted / temp_quotient;\n        temp_remainder = quotient_1 & 0xffff;\n        final_quotient = temp_remainder * remainder_shifted;\n        dividend_shifted_left = dividend >> (0x20U - shift_amount & 0xff) | divisor << shift_amount;\n        remainder = dividend_shifted_left >> 0x10 | (quotient_2_shifted - temp_quotient * remainder_shifted) * 0x10000;\n        dividend = dividend << shift_amount;\n        quotient_2_shifted = remainder_shifted;\n        if (remainder <= final_quotient && final_quotient - remainder != 0) {\n          carry_flag = CARRY4(remainder,quotient_1);\n          remainder = remainder + quotient_1;\n          quotient_2_shifted = remainder_shifted - 1;\n          if ((carry_flag == false) && (remainder <= final_quotient && final_quotient - remainder != 0)) {\n            quotient_2_shifted = remainder_shifted - 2;\n            remainder = remainder + quotient_1;\n          }\n        }\n        quotient_1_shifted = (remainder - final_quotient) / temp_quotient;\n        remainder_shifted = temp_remainder * quotient_1_shifted;\n        divisor = dividend_shifted_left & 0xffff | ((remainder - final_quotient) - temp_quotient * quotient_1_shifted) * 0x10000;\n        final_quotient = quotient_1_shifted;\n        if (divisor <= remainder_shifted && remainder_shifted - divisor != 0) {\n          carry_flag = CARRY4(divisor,quotient_1);\n          divisor = divisor + quotient_1;\n          final_quotient = quotient_1_shifted - 1;\n          if ((carry_flag == false) && (divisor <= remainder_shifted && remainder_shifted - divisor != 0)) {\n            final_quotient = quotient_1_shifted - 2;\n            divisor = divisor + quotient_1;\n          }\n        }\n        divisor = divisor - remainder_shifted;\n        final_quotient = final_quotient | quotient_2_shifted << 0x10;\n      }\n      remainder_shifted = divisor / temp_quotient;\n      remainder = temp_remainder * remainder_shifted;\n      dividend_shifted_left = dividend >> 0x10 | (divisor - temp_quotient * remainder_shifted) * 0x10000;\n      quotient_2_shifted = remainder_shifted;\n      if (dividend_shifted_left <= remainder && remainder - dividend_shifted_left != 0) {\n        carry_flag = CARRY4(dividend_shifted_left,quotient_1);\n        dividend_shifted_left = dividend_shifted_left + quotient_1;\n        quotient_2_shifted = remainder_shifted - 1;\n        if ((carry_flag == false) && (dividend_shifted_left <= remainder && remainder - dividend_shifted_left != 0)) {\n          quotient_2_shifted = remainder_shifted - 2;\n          dividend_shifted_left = dividend_shifted_left + quotient_1;\n        }\n      }\n      remainder_shifted = (dividend_shifted_left - remainder) / temp_quotient;\n      temp_remainder = temp_remainder * remainder_shifted;\n      dividend_shifted_left = dividend & 0xffff | ((dividend_shifted_left - remainder) - temp_quotient * remainder_shifted) * 0x10000;\n      temp_quotient = remainder_shifted;\n      if (dividend_shifted_left <= temp_remainder && temp_remainder - dividend_shifted_left != 0) {\n        temp_quotient = remainder_shifted - 1;\n        if ((CARRY4(dividend_shifted_left,quotient_1) == false) &&\n           (dividend_shifted_left + quotient_1 <= temp_remainder && temp_remainder - (dividend_shifted_left + quotient_1) != 0)) {\n          temp_quotient = remainder_shifted - 2;\n        }\n      }\n      return CONCAT44(final_quotient,temp_quotient | quotient_2_shifted << 0x10);\n    }\n    shift_amount = LZCOUNT(quotient_1);\n    if (shift_amount != 0) {\n      quotient_2_shifted = dividend >> (0x20U - shift_amount & 0xff);\n      quotient_1 = quotient_1 << shift_amount;\n      dividend = dividend << shift_amount;\n      divisor = quotient_2_shifted | divisor << shift_amount;\n    }\n    final_quotient = quotient_1 >> 0x10;\n    temp_quotient = divisor / final_quotient;\n    temp_remainder = (quotient_1 & 0xffff) * temp_quotient;\n    remainder_shifted = dividend >> 0x10 | (divisor - final_quotient * temp_quotient) * 0x10000;\n    quotient_2_shifted = temp_quotient;\n    if (remainder_shifted <= temp_remainder && temp_remainder - remainder_shifted != 0) {\n      carry_flag = CARRY4(remainder_shifted,quotient_1);\n      remainder_shifted = remainder_shifted + quotient_1;\n      quotient_2_shifted = temp_quotient - 1;\n      if ((carry_flag == false) && (remainder_shifted <= temp_remainder && temp_remainder - remainder_shifted != 0)) {\n        quotient_2_shifted = temp_quotient - 2;\n        remainder_shifted = remainder_shifted + quotient_1;\n      }\n    }\n    dividend_shifted_left = (remainder_shifted - temp_remainder) / final_quotient;\n    temp_quotient = (quotient_1 & 0xffff) * dividend_shifted_left;\n    temp_remainder = dividend & 0xffff | ((remainder_shifted - temp_remainder) - final_quotient * dividend_shifted_left) * 0x10000;\n    final_quotient = dividend_shifted_left;\n    if (temp_remainder <= temp_quotient && temp_quotient - temp_remainder != 0) {\n      final_quotient = dividend_shifted_left - 1;\n      if ((CARRY4(temp_remainder,quotient_1) == false) &&\n         (temp_remainder + quotient_1 <= temp_quotient && temp_quotient - (temp_remainder + quotient_1) != 0)) {\n        final_quotient = dividend_shifted_left - 2;\n      }\n    }\n    final_quotient = final_quotient | quotient_2_shifted << 0x10;\n  }\n  else {\n    if (divisor < quotient_2) {\n      return 0;\n    }\n    shift_amount = LZCOUNT(quotient_2);\n    if (shift_amount == 0) {\n      if ((quotient_2 < divisor) || (quotient_1 <= dividend)) {\n        return 1;\n      }\n      final_quotient = 0;\n    }\n    else {\n      final_quotient = 0x20 - shift_amount;\n      quotient_2_shifted = divisor >> (final_quotient & 0xff);\n      temp_quotient = quotient_2 << shift_amount | quotient_1 >> (final_quotient & 0xff);\n      temp_remainder = temp_quotient >> 0x10;\n      remainder = quotient_2_shifted / temp_remainder;\n      remainder_shifted = (temp_quotient & 0xffff) * remainder;\n      dividend_shifted_left = dividend >> (final_quotient & 0xff) | divisor << shift_amount;\n      final_quotient = dividend_shifted_left >> 0x10 | (quotient_2_shifted - temp_remainder * remainder) * 0x10000;\n      quotient_2_shifted = remainder;\n      if (final_quotient <= remainder_shifted && remainder_shifted - final_quotient != 0) {\n        carry_flag = CARRY4(final_quotient,temp_quotient);\n        final_quotient = final_quotient + temp_quotient;\n        quotient_2_shifted = remainder - 1;\n        if ((carry_flag == false) && (final_quotient <= remainder_shifted && remainder_shifted - final_quotient != 0)) {\n          quotient_2_shifted = remainder - 2;\n          final_quotient = final_quotient + temp_quotient;\n        }\n      }\n      remainder = (final_quotient - remainder_shifted) / temp_remainder;\n      quotient_1_shifted = (temp_quotient & 0xffff) * remainder;\n      temp_remainder = dividend_shifted_left & 0xffff | ((final_quotient - remainder_shifted) - temp_remainder * remainder) * 0x10000;\n      final_quotient = remainder;\n      if (temp_remainder <= quotient_1_shifted && quotient_1_shifted - temp_remainder != 0) {\n        carry_flag = CARRY4(temp_remainder,temp_quotient);\n        temp_remainder = temp_remainder + temp_quotient;\n        final_quotient = remainder - 1;\n        if ((carry_flag == false) && (temp_remainder <= quotient_1_shifted && quotient_1_shifted - temp_remainder != 0)) {\n          final_quotient = remainder - 2;\n          temp_remainder = temp_remainder + temp_quotient;\n        }\n      }\n      final_quotient = final_quotient | quotient_2_shifted << 0x10;\n      temp = (ulonglong)final_quotient * (ulonglong)(quotient_1 << shift_amount);\n      quotient_2_shifted = (uint)((ulonglong)temp >> 0x20);\n      if ((temp_remainder - quotient_1_shifted < quotient_2_shifted) || ((temp_remainder - quotient_1_shifted == quotient_2_shifted && (dividend << shift_amount < (uint)temp)))\n         ) {\n        final_quotient = final_quotient - 1;\n      }\n    }\n  }\n  return (ulonglong)final_quotient;\n}\n\n",
            "renaming": {
                "FUN_00084860": "calculate_division_00084860",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient_1",
                "param_4": "quotient_2",
                "lVar1": "temp",
                "uVar2": "final_quotient",
                "uVar3": "temp_quotient",
                "uVar4": "remainder",
                "uVar5": "temp_remainder",
                "uVar6": "dividend_shifted_left",
                "uVar7": "quotient_1_shifted",
                "uVar8": "quotient_2_shifted",
                "uVar9": "remainder_shifted",
                "iVar10": "shift_amount",
                "bVar11": "carry_flag"
            },
            "calling": [
                "__gnu_uldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085844": {
            "entrypoint": "0x00085844",
            "current_name": "FUNC_00085844",
            "code": "\nvoid FUNC_00085844(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085844": "FUNC_00085844"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00085860": {
            "entrypoint": "0x00085860",
            "current_name": "FUNC_00085860",
            "code": "\nvoid FUNC_00085860(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085860": "FUNC_00085860"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_20070000": {
            "entrypoint": "0x20070000",
            "current_name": "disable_interrupts_loop_20070000",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_interrupts_loop_20070000(void)\n\n{\n  disableIRQinterrupts();\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *(undefined4 *)(DAT_2007001c + 4) = DAT_20070020;\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *DAT_20070028 = DAT_20070024;\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_20070000": "disable_interrupts_loop_20070000"
            },
            "calling": [
                "tickReset",
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 116298,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080148",
            "FUN_0008014c",
            "FUN_00080164",
            "FUN_00080184",
            "FUN_000801e0",
            "FUN_00080250",
            "FUN_000803fc",
            "FUN_0008044c",
            "FUN_00080558",
            "FUN_00080568",
            "FUN_00080578",
            "FUN_00080588",
            "FUN_00080598",
            "FUN_000805a8",
            "FUN_000805e8",
            "FUN_000806a0",
            "FUN_000806ac",
            "FUN_000806f8",
            "FUN_0008073c",
            "FUN_00080750",
            "FUN_0008075c",
            "FUN_00080768",
            "FUN_00080774",
            "FUN_0008089c",
            "FUN_00080970",
            "FUN_000809b4",
            "FUN_000809be",
            "FUN_000809e4",
            "FUN_00080a0a",
            "FUN_00080a30",
            "FUN_00080a94",
            "FUN_00080aa8",
            "FUN_00080aec",
            "FUN_00080b2c",
            "FUN_00080b64",
            "FUN_00080b90",
            "FUN_00080b98",
            "FUN_00080c20",
            "FUN_00080c98",
            "FUN_00080d30",
            "FUN_00080d3e",
            "FUN_00080d58",
            "FUN_00080d62",
            "FUN_00080d6a",
            "FUN_00080d70",
            "FUN_00080d80",
            "FUN_00080db8",
            "FUN_00080df0",
            "FUN_00080e28",
            "FUN_00080e60",
            "FUN_00080e62",
            "FUN_00080e66",
            "FUN_00080e6a",
            "FUN_00080e80",
            "FUN_00080e84",
            "FUN_00080e88",
            "FUN_00080ea4",
            "FUN_00080eaa",
            "FUN_00080eb0",
            "FUN_00080eba",
            "FUN_00080ebe",
            "FUN_00080ec2",
            "FUN_00080ec8",
            "FUN_00080eec",
            "FUN_00080efe",
            "FUN_00080f04",
            "FUN_00080f0c",
            "FUN_00081014",
            "FUN_00081084",
            "FUN_000810a6",
            "FUN_000810c4",
            "FUN_000810cc",
            "FUN_000810d8",
            "FUN_000810e8",
            "FUN_000810fc",
            "FUN_0008113a",
            "FUN_00081176",
            "FUN_0008117a",
            "FUN_00081190",
            "FUN_000811b0",
            "FUN_000811ca",
            "FUN_000811e8",
            "FUN_00081214",
            "FUN_00081244",
            "FUN_00081248",
            "FUN_0008125a",
            "FUN_00081276",
            "FUN_000812a0",
            "FUN_000812b8",
            "FUN_0008130c",
            "FUN_00081348",
            "FUN_0008136c",
            "FUN_000813dc",
            "FUN_000813e4",
            "FUN_0008142e",
            "FUN_00081438",
            "FUN_0008145c",
            "FUN_00081472",
            "FUN_00081480",
            "FUN_00081496",
            "FUN_000814ae",
            "FUN_000814d0",
            "FUN_000814f6",
            "FUN_0008151c",
            "FUN_00081560",
            "FUN_00081570",
            "FUN_0008159e",
            "FUN_000815b8",
            "FUN_000815de",
            "FUN_000815ec",
            "FUN_00081618",
            "FUN_00081624",
            "FUN_00081684",
            "FUN_000816c8",
            "FUN_000816d8",
            "FUN_000816e4",
            "FUN_000816ec",
            "FUN_000816f8",
            "FUN_00081734",
            "FUN_0008173c",
            "FUN_00081750",
            "FUN_00081778",
            "FUN_000817c8",
            "FUN_000817f0",
            "FUN_00081800",
            "FUN_00081810",
            "FUN_00081d48",
            "FUN_00081e34",
            "FUN_00081f00",
            "FUN_00081f9c",
            "FUN_00081fac",
            "FUN_0008236c",
            "FUN_00082390",
            "FUN_000825cc",
            "FUN_00082688",
            "FUN_000826e8",
            "FUN_000827fc",
            "FUN_00082814",
            "FUN_00082824",
            "FUN_0008289c",
            "FUN_000834f0",
            "FUN_0008356c",
            "FUN_00083630",
            "FUN_000836ec",
            "FUN_000836fc",
            "FUN_00083708",
            "FUN_00083850",
            "FUN_0008387c",
            "FUN_00083888",
            "FUN_00083984",
            "FUN_000839b4",
            "FUN_00083a74",
            "FUN_00083b10",
            "FUN_00083ca8",
            "FUN_00083fbc",
            "FUN_00084004",
            "FUN_0008400c",
            "FUN_00084018",
            "FUN_000840f8",
            "FUN_0008418c",
            "FUN_000841e4",
            "FUN_000841f4",
            "FUN_00084220",
            "FUN_00084244",
            "FUN_0008427c",
            "FUN_0008429c",
            "FUN_000842a4",
            "FUN_0008434c",
            "FUN_0008439c",
            "FUN_000843b8",
            "FUN_000843e0",
            "FUN_00084404",
            "FUN_00084484",
            "FUN_00084494",
            "FUN_000844bc",
            "FUN_000844e0",
            "FUN_00084508",
            "FUN_00084530",
            "FUN_0008455c",
            "FUN_0008458c",
            "FUN_000845c0",
            "FUN_00084860",
            "FUN_20070000"
        ]
    ],
    "locked_functions": []
}