{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "initialize_flag_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 initializeFlag_000800f4(undefined4 inputParam)\n\n{\n  if ((char)DAT_200708a0 == '\\0') {\n    DAT_200708a0._0_1_ = '\\x01';\n  }\n  return inputParam;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "initialize_flag_000800f4",
                "param_1": "inputParam"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "initialize_data_00080164",
            "code": "\nvoid initializeData_00080164(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  FUN_000806f8(&DAT_200708e8,0x5a);\n  FUN_000806f8(&DAT_200708d4,0x5a,arg3,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "initialize_data_00080164",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000806f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801e0": {
            "entrypoint": "0x000801e0",
            "current_name": "initialize_system_000801e0",
            "code": "\nundefined8 initialize_system_000801e0(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  FUN_000813dc(&DAT_20070be8,0xe100,param3,param4,param4);\n  FUN_00080f0c(0xd,1);\n  FUN_00080f0c(6,1);\n  FUN_00080f0c(0x39,0);\n  FUN_00080f0c(4,0);\n  FUN_00080f0c(3,0);\n  FUN_00080f0c(2,0);\n  FUN_000806a0(&DAT_200708d4,5);\n  FUN_000806a0(&DAT_200708e8,6);\n  FUN_00080164();\n  FUNC_00080f08(1000);\n  if (DAT_200708bc == 0) {\n    software_interrupt(0x3f);\n    return 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000801e0": "initialize_system_000801e0",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_000806a0",
                "FUN_00080f0c",
                "FUN_00080f08",
                "FUN_00080164",
                "FUN_000813dc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080250": {
            "entrypoint": "0x00080250",
            "current_name": "control_mode_handler_00080250",
            "code": "\nvoid controlModeHandler_00080250(void)\n\n{\n  undefined4 result;\n  int count;\n  undefined *buffer;\n  undefined auxiliaryStack [12];\n  \n  DAT_200708c0 = FUN_00081624(4,1,20000);\n  FUNC_00080f08(10);\n  DAT_200708c4 = DAT_200708c4 ^ 1;\n  FUN_00081014(0xd);\n  if (DAT_200708c0 < 0x641) {\n    if (DAT_200708c0 - 0x385U < 299) {\n      if (DAT_200708eb != '\\0') {\n        FUN_00080164();\n        FUN_000810e8(&DAT_20070be8,\"Entered manual control mode.\");\n        DAT_200708eb = '\\0';\n      }\n      FUNC_00080f08(10);\n      result = FUN_00081624(3,1,20000);\n      DAT_200708d8 = FUN_0008145c(0,1000,2000,0x28,0x96);\n      DAT_200708ec = FUN_0008145c(result,1000,2000,0x28,0x96);\n      while (count = FUN_00081248(&DAT_20070be8), 0 < count) {\n        FUN_00081276(&DAT_20070be8);\n        thunk_FUN_0008113a(&DAT_20070be8,DAT_200708d8,10);\n        FUN_000810c4(&DAT_20070be8,&DAT_00084b13);\n        FUN_0008117a(&DAT_20070be8,DAT_200708ec,10);\n      }\n      FUN_000806f8(&DAT_200708e8,DAT_200708ec);\n      FUN_000806f8(&DAT_200708d4,DAT_200708d8);\n    }\n    else {\n      if (DAT_200708eb == '\\0') {\n        FUN_00080164();\n        FUN_000810e8(&DAT_20070be8,\"Entered autonomous control mode.\");\n      }\n      DAT_200708eb = '\\x01';\nLAB_00080346:\n      count = FUN_00081248(&DAT_20070be8);\n      if (0 < count) {\n        FUN_00081214(auxiliaryStack,&DAT_20070be8,0x2c);\n        FUN_00081560(&DAT_200708dc,auxiliaryStack);\n        FUN_00081472(auxiliaryStack);\n        FUN_00081214(auxiliaryStack,&DAT_20070be8,10);\n        FUN_00081560(&DAT_200708c8,auxiliaryStack);\n        FUN_00081472(auxiliaryStack);\n        FUN_00081276(&DAT_20070be8);\n        count = FUN_000815b8(&DAT_200708dc,\"steer\");\n        if (count == 0) goto LAB_0008039c;\n        result = FUN_000815de(&DAT_200708c8);\n        buffer = &DAT_200708d4;\n        goto LAB_000803b2;\n      }\n    }\n  }\n  else {\n    FUN_00080164();\n    FUN_000810e8(&DAT_20070be8,\"error\");\n  }\n  return;\nLAB_0008039c:\n  count = FUN_000815b8(&DAT_200708dc,\"motor\");\n  if (count != 0) {\n    result = FUN_000815de(&DAT_200708c8);\n    buffer = &DAT_200708e8;\nLAB_000803b2:\n    FUN_000806f8(buffer,result);\n  }\n  goto LAB_00080346;\n}\n\n",
            "renaming": {
                "FUN_00080250": "control_mode_handler_00080250",
                "uVar1": "result",
                "iVar2": "count",
                "puVar3": "buffer",
                "auStack_1c": "auxiliaryStack"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_000810c4",
                "FUN_00081472",
                "FUN_000815b8",
                "FUN_00081248",
                "FUN_000806f8",
                "FUN_00081214",
                "FUN_00080164",
                "FUN_000810e8",
                "FUN_00080f08",
                "FUN_00081276",
                "FUN_00081560",
                "FUN_00081014",
                "FUN_00081624",
                "thunk_FUN_0008113a",
                "FUN_000815de",
                "FUN_0008117a",
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803fc": {
            "entrypoint": "0x000803fc",
            "current_name": "initialize_tc_000803fc",
            "code": "\nvoid initializeTC_000803fc(int channel,uint index,undefined4 param,uint flag)\n\n{\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined8 combinedValue;\n  \n  combinedValue = CONCAT44(index,channel);\n  FUN_00080aa8(param);\n  FUN_00080b2c(channel,index,0xc002);\n  FUN_00080b90(channel,index,0xa41);\n  *(int *)((flag >> 5) * 4 + -0x1fff1f00) = 1 << (flag & 0x1f);\n  *(undefined4 *)(channel + index * 0x40 + 0x24) = 4;\n  if (2 < index) {\n    combinedValue = FUN_000816f8(\"../source/tc.c\",0x5c,\"TC_Start\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\",\n                         constant1,constant2);\n  }\n  *(undefined4 *)((int)combinedValue + (int)((ulonglong)combinedValue >> 0x20) * 0x40) = 5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000803fc": "initialize_tc_000803fc",
                "param_1": "channel",
                "param_2": "index",
                "param_3": "param",
                "param_4": "flag",
                "unaff_r4": "constant1",
                "in_lr": "constant2",
                "uVar1": "combinedValue"
            },
            "calling": [
                "FUN_000806a0"
            ],
            "called": [
                "FUN_00080b90",
                "FUN_00080b2c",
                "FUN_00080aa8",
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008044c": {
            "entrypoint": "0x0008044c",
            "current_name": "update_data_0008044c",
            "code": "\nvoid updateData_0008044c(int index,int data,int offset)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  offset = offset * 0x40;\n  if (((&DAT_200708f1)[index] & 0x80) == 0) {\n    iVar2 = index * 0xc;\n    if (((char)(&DAT_200708f1)[index] + iVar2 < (int)(uint)DAT_200708f0) &&\n       ((int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + iVar2) * 8] << 0x19) < 0\n       )) {\n      FUN_00081014((&DAT_200708f8)[(iVar2 + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,0);\n    }\n  }\n  else {\n    *(uint *)(data + offset) = *(uint *)(data + offset) | 4;\n  }\n  uVar1 = (uint)DAT_200708f0;\n  (&DAT_200708f1)[index] = (&DAT_200708f1)[index] + '\\x01';\n  iVar2 = index * 0xc;\n  if (((char)(&DAT_200708f1)[index] + iVar2 < (int)uVar1) &&\n     ((char)(&DAT_200708f1)[index] < '\\f')) {\n    *(int *)(data + offset + 0x14) =\n         *(int *)(data + offset + 0x10) +\n         *(int *)(&DAT_200708fc + ((char)(&DAT_200708f1)[index] + iVar2) * 8);\n    if (-1 < (int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + iVar2) * 8] << 0x19\n                  )) {\n      return;\n    }\n    FUN_00081014((&DAT_200708f8)[(iVar2 + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,1);\n    return;\n  }\n  data = data + offset;\n  uVar1 = (elfRelArray[6].r_offset / 1000000) * 20000 >> 5;\n  if (uVar1 <= *(int *)(data + 0x10) + 4U) {\n    uVar1 = *(int *)(data + 0x10) + 4;\n  }\n  *(uint *)(data + 0x14) = uVar1;\n  (&DAT_200708f1)[index] = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008044c": "update_data_0008044c",
                "param_1": "index",
                "param_2": "data",
                "param_3": "offset",
                "Elf32_Rel_ARRAY_20070000": "elfRelArray"
            },
            "calling": [],
            "called": [
                "FUN_00081014"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805a8": {
            "entrypoint": "0x000805a8",
            "current_name": "extract_rel_offset_000805a8",
            "code": "\nvoid extract_rel_offset_000805a8(byte *output_buffer)\n\n{\n  char new_value;\n  uint counter;\n  \n  counter = (uint)DAT_200708f0;\n  if (counter < 0x3c) {\n    new_value = DAT_200708f0 + 1;\n    *output_buffer = DAT_200708f0;\n    DAT_200708f0 = new_value;\n    *(uint *)(&DAT_200708fc + counter * 8) =\n         (rel_array[6].r_offset / 1000000) * 0x5dc >> 5;\n    return;\n  }\n  *output_buffer = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000805a8": "extract_rel_offset_000805a8",
                "param_1": "output_buffer",
                "uVar2": "counter",
                "cVar1": "new_value",
                "Elf32_Rel_ARRAY_20070000": "rel_array"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806a0": {
            "entrypoint": "0x000806a0",
            "current_name": "decode_function_000806a0",
            "code": "\nbyte decodeFunction_000806a0(byte *param_1,undefined4 param2)\n\n{\n  byte byteValue;\n  undefined4 address1;\n  uint divisionResult;\n  undefined4 valueToUpdate;\n  int loopCounter;\n  uint valueToUpdate2;\n  \n  if (0x3b < *param_1) goto LAB_00080660;\n  FUN_00080f0c(param2,1,0x220,*param_1,0x960);\n  valueToUpdate2 = (uint)*param_1;\n  byteValue = (&DAT_200708f8)[valueToUpdate2 * 8];\n  param_1[2] = 0;\n  divisionResult = valueToUpdate2 / 0xc;\n  (&DAT_200708f8)[valueToUpdate2 * 8] = byteValue & 0xc0 | (byte)param2 & 0x3f;\n  param_1[1] = 0;\n  loopCounter = 0;\n  do {\n    if ((int)((uint)(byte)(&DAT_200708f8)[(loopCounter + divisionResult * 0xc) * 8] << 0x19) < 0)\n    goto LAB_00080652;\n    loopCounter = loopCounter + 1;\n  } while (loopCounter != 0xc);\n  if (divisionResult == 0) {\n    address1 = 0x40084000;\n    valueToUpdate = 0x1e;\nLAB_0008064c:\n    FUN_000803fc(address1,divisionResult,valueToUpdate,valueToUpdate);\n  }\n  else {\n    if (divisionResult == 1) {\n      address1 = 0x40084000;\n      valueToUpdate = 0x1f;\n      goto LAB_0008064c;\n    }\n    if (divisionResult == 2) {\n      address1 = 0x40084000;\n      valueToUpdate = 0x20;\n      goto LAB_0008064c;\n    }\n    if (divisionResult == 3) {\n      address1 = 0x40080000;\n      divisionResult = 2;\n      valueToUpdate = 0x1d;\n      goto LAB_0008064c;\n    }\n    if (divisionResult == 4) {\n      address1 = 0x40080000;\n      divisionResult = 0;\n      valueToUpdate = 0x1b;\n      goto LAB_0008064c;\n    }\n  }\nLAB_00080652:\n  (&DAT_200708f8)[(uint)*param_1 * 8] = (&DAT_200708f8)[(uint)*param_1 * 8] | 0x40;\nLAB_00080660:\n  return *param_1;\n}\n\n",
            "renaming": {
                "FUN_000806a0": "decode_function_000806a0",
                "param_2": "param2",
                "bVar1": "byteValue",
                "uVar2": "address1",
                "uVar3": "divisionResult",
                "uVar4": "valueToUpdate",
                "iVar5": "loopCounter",
                "uVar6": "valueToUpdate2"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000803fc",
                "FUN_00080f0c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806f8": {
            "entrypoint": "0x000806f8",
            "current_name": "process_data_000806f8",
            "code": "\nvoid processData_000806f8(byte *data,uint size)\n\n{\n  uint adjustedSize;\n  \n  if ((int)size < 0x220) {\n    adjustedSize = size;\n    if (0xb3 < (int)size) {\n      adjustedSize = 0xb4;\n    }\n    size = FUN_0008145c(adjustedSize & ~((int)adjustedSize >> 0x1f),0,0xb4,(0x88 - (char)data[1]) * 4,\n                           (600 - (char)data[2]) * 4,size);\n  }\n  if (*data < 0x3c) {\n    adjustedSize = (0x88 - (char)data[1]) * 4;\n    if (((int)(size + (0x88 - (char)data[1]) * -4) < 0 == SBORROW4(size,adjustedSize)) &&\n       (adjustedSize = (600 - (char)data[2]) * 4, (int)size <= (int)adjustedSize)) {\n      adjustedSize = size;\n    }\n    *(uint *)(&DAT_200708fc + (uint)*data * 8) =\n         (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * (adjustedSize - 2) >> 5;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000806f8": "process_data_000806f8",
                "param_1": "data",
                "param_2": "size",
                "uVar1": "adjustedSize"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080164"
            ],
            "called": [
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008073a": {
            "entrypoint": "0x0008073a",
            "current_name": "FUNC_0008073a",
            "code": "\nvoid FUNC_0008073a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073a": "FUNC_0008073a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080748": {
            "entrypoint": "0x00080748",
            "current_name": "FUNC_00080748",
            "code": "\nvoid FUNC_00080748(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080748": "FUNC_00080748"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074a": {
            "entrypoint": "0x0008074a",
            "current_name": "FUNC_0008074a",
            "code": "\nvoid FUNC_0008074a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074a": "FUNC_0008074a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074c": {
            "entrypoint": "0x0008074c",
            "current_name": "FUNC_0008074c",
            "code": "\nvoid FUNC_0008074c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074c": "FUNC_0008074c"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080774": {
            "entrypoint": "0x00080774",
            "current_name": "initialize_system_00080774",
            "code": "\n\n\nvoid initializeSystem_00080774(void)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  FUN_00080b98();\n  _DAT_e000e014 = elfArray[6].r_offset / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  FUN_00081778();\n  iVar1 = 0;\n  do {\n    iVar2 = iVar1 + 1;\n    FUN_00081014(iVar1,0);\n    iVar1 = iVar2;\n  } while (iVar2 != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  FUN_00080a30(0x400e0e00,1,0x300,0);\n  FUN_00081014(0,1);\n  FUN_00080a30(0x400e0e00,1,0xc00,0);\n  FUN_00080a30(0x400e0e00,1,0x3000,0);\n  FUN_00080a30(0x400e1400,2,0x30,0);\n  FUN_00080a30(0x400e1000,1,0xc00,0);\n  FUN_00080a30(0x400e0e00,1,3,0);\n  FUN_00080a30(0x400e1000,1,0xc000,0);\n  FUN_00080aa8(0x25);\n  FUN_00080c98(0x400c0000,elfArray[6].r_offset,20000000,0xc);\n  FUN_00080d3e(0x400c0000,0,0x300000,1);\n  FUN_00080d30(0x400c0000,0,0);\n  FUN_00080d6a(0x400c0000,0xffffffff);\n  FUN_00080d62(0x400c0000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080774": "initialize_system_00080774",
                "Elf32_Rel_ARRAY_20070000": "elfArray"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_00080d3e",
                "FUN_00081778",
                "FUN_00081014",
                "FUN_00080c98",
                "FUN_00080b98",
                "FUN_00080a30",
                "FUN_00080d30",
                "FUN_00080aa8",
                "FUN_00080d6a",
                "FUN_00080d62"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008089c": {
            "entrypoint": "0x0008089c",
            "current_name": "initialize_components_0008089c",
            "code": "\nvoid initializeComponents_0008089c(undefined4 param1,undefined4 param2,undefined4 param3)\n\n{\n  FUN_000811b0(&DAT_20070c0c);\n  FUN_000811b0(&DAT_20070b60);\n  FUN_00081348(&DAT_20070be8,0x400e0800,8,8,&DAT_20070c0c,&DAT_20070b60,param3);\n  FUN_000811b0(&DAT_20070e6c);\n  FUN_000811b0(&DAT_20070ef4);\n  FUN_000811b0(&DAT_20070f7c);\n  FUN_000811b0(&DAT_20070ad8);\n  FUN_000811b0(&DAT_20070d0c);\n  FUN_000811b0(&DAT_20070d94);\n  FUN_00081438(&DAT_20070c94,0x40098000,0x11,0x11,&DAT_20070e6c,&DAT_20070ad8);\n  FUN_00081438(&DAT_20070cbc,0x4009c000,0x12,0x12,&DAT_20070ef4,&DAT_20070d0c);\n  FUN_00081438(&DAT_20070ce4,0x400a4000,0x14,0x14,&DAT_20070f7c,&DAT_20070d94);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008089c": "initialize_components_0008089c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3"
            },
            "calling": [],
            "called": [
                "FUN_000811b0",
                "FUN_00081348",
                "FUN_00081438"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080970": {
            "entrypoint": "0x00080970",
            "current_name": "check_and_execute_functions_00080970",
            "code": "\nvoid checkAndExecuteFunctions_00080970(void)\n\n{\n  int result;\n  \n  result = FUN_00081248(&DAT_20070be8);\n  if (result != 0) {\n    FUNC_0008073a();\n  }\n  result = FUN_00081248(&DAT_20070c94);\n  if (result != 0) {\n    FUNC_00080748();\n  }\n  result = FUN_00081248(&DAT_20070cbc);\n  if (result != 0) {\n    FUNC_0008074a();\n  }\n  result = FUN_00081248(&DAT_20070ce4);\n  if (result != 0) {\n    FUNC_0008074c();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080970": "check_and_execute_functions_00080970",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_0008074a",
                "FUN_0008073a",
                "FUN_00081248",
                "FUN_00080748",
                "FUN_0008074c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809be": {
            "entrypoint": "0x000809be",
            "current_name": "update_param_values_000809be",
            "code": "\nvoid updateParamValues_000809be(int baseAddress,undefined4 actionType,uint newValue)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(baseAddress + 0x44) = newValue;\n  switch(actionType) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(baseAddress + 0x70) & *(uint *)(baseAddress + 0x70) & ~newValue;\n    break;\n  case 2:\n    updatedValue = *(uint *)(baseAddress + 0x70) | newValue;\n    break;\n  default:\n    goto switchD_000809c4_caseD_6;\n  }\n  *(uint *)(baseAddress + 0x70) = updatedValue;\nswitchD_000809c4_caseD_6:\n  *(uint *)(baseAddress + 4) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809be": "update_param_values_000809be",
                "param_1": "baseAddress",
                "param_2": "actionType",
                "param_3": "newValue",
                "uVar1": "updatedValue"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809e4": {
            "entrypoint": "0x000809e4",
            "current_name": "update_parameter_values_000809e4",
            "code": "\nvoid updateParameterValues_000809e4(undefined4 *outputArray,undefined4 newValue,uint bitmask)\n\n{\n  bool isNegativeBitShift;\n  \n  isNegativeBitShift = (int)(bitmask << 0x1f) < 0;\n  outputArray[0x11] = newValue;\n  if (isNegativeBitShift) {\n    outputArray[0x19] = newValue;\n  }\n  if (!isNegativeBitShift) {\n    outputArray[0x18] = newValue;\n  }\n  isNegativeBitShift = (bitmask & 10) != 0;\n  if (isNegativeBitShift) {\n    outputArray[8] = newValue;\n  }\n  if (!isNegativeBitShift) {\n    outputArray[9] = newValue;\n  }\n  if (((int)(bitmask << 0x1e) < 0) || ((int)(bitmask << 0x1c) < 0)) {\n    outputArray[0x20] = newValue;\n  }\n  outputArray[5] = newValue;\n  *outputArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809e4": "update_parameter_values_000809e4",
                "param_1": "outputArray",
                "param_2": "newValue",
                "param_3": "bitmask",
                "bVar1": "isNegativeBitShift"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a0a": {
            "entrypoint": "0x00080a0a",
            "current_name": "update_values_00080a0a",
            "code": "\nvoid updateValues_00080a0a(undefined4 *outputArray,undefined4 newValue,int condition1,int condition2,int condition3)\n\n{\n  outputArray[0x11] = newValue;\n  if (condition3 == 0) {\n    outputArray[0x18] = newValue;\n  }\n  else {\n    outputArray[0x19] = newValue;\n  }\n  if (condition2 == 0) {\n    outputArray[0x15] = newValue;\n  }\n  else {\n    outputArray[0x14] = newValue;\n  }\n  if (condition1 == 0) {\n    outputArray[0xd] = newValue;\n  }\n  else {\n    outputArray[0xc] = newValue;\n  }\n  outputArray[4] = newValue;\n  *outputArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a0a": "update_values_00080a0a",
                "param_1": "outputArray",
                "param_2": "newValue",
                "param_3": "condition1",
                "param_4": "condition2",
                "param_5": "condition3"
            },
            "calling": [
                "FUN_00081014",
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a30": {
            "entrypoint": "0x00080a30",
            "current_name": "update_data_00080a30",
            "code": "\nundefined4 updateData_00080a30(int data,int type,undefined4 value,uint flag)\n\n{\n  bool isNegative;\n  \n  switch(type) {\n  case 1:\n  case 2:\n    FUN_000809be(data,type,value);\n    isNegative = (int)(flag << 0x1f) < 0;\n    *(undefined4 *)(data + 0x44) = value;\n    if (isNegative) {\n      *(undefined4 *)(data + 100) = value;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(data + 0x60) = value;\n    }\n    break;\n  case 3:\n    FUN_000809e4(data,value,flag,0x809e5,data);\n    break;\n  case 4:\n  case 5:\n    FUN_00080a0a(data,value,type == 5,(flag << 0x1d) >> 0x1f,flag & 1,type,value)\n    ;\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080a30": "update_data_00080a30",
                "param_1": "data",
                "param_2": "type",
                "param_3": "value",
                "param_4": "flag",
                "bVar1": "isNegative"
            },
            "calling": [
                "FUN_00080f0c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080a0a",
                "FUN_000809e4",
                "FUN_000809be"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a94": {
            "entrypoint": "0x00080a94",
            "current_name": "check_bitwise_conditions_00080a94",
            "code": "\nuint check_bitwise_conditions_00080a94(int input_value,uint bit_mask)\n\n{\n  uint result;\n  \n  result = *(uint *)(input_value + 8) & bit_mask;\n  if (result != 0) {\n    if ((bit_mask & *(uint *)(input_value + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080a94": "check_bitwise_conditions_00080a94",
                "param_1": "input_value",
                "param_2": "bit_mask",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00081014"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "update_bitmask_00080aa8",
            "code": "\n\n\nundefined4 updateBitmask_00080aa8(uint input)\n\n{\n  uint mask;\n  \n  if (input < 0x2d) {\n    if (input < 0x20) {\n      mask = 1 << (input & 0xff);\n      if ((mask & _DAT_400e0618) != mask) {\n        _DAT_400e0610 = mask;\n      }\n    }\n    else {\n      mask = 1 << (input - 0x20 & 0xff);\n      if ((mask & _DAT_400e0708) != mask) {\n        _DAT_400e0700 = mask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "update_bitmask_00080aa8",
                "param_1": "input",
                "uVar1": "mask"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080f0c",
                "FUN_00080774",
                "FUN_000813dc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b2c": {
            "entrypoint": "0x00080b2c",
            "current_name": "update_tc_configure_00080b2c",
            "code": "\nvoid updateTCConfigure_00080b2c(undefined4 param1,uint param2,char *param3)\n\n{\n  int offset;\n  int address;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(param2,param1);\n  if (2 < param2) {\n    param3 = \"TC_Configure\";\n    combinedParams = FUN_000816f8(\"../source/tc.c\",0x40,\"TC_Configure\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  offset = (int)((ulonglong)combinedParams >> 0x20) * 0x40;\n  address = (int)combinedParams + offset;\n  *(undefined4 *)((int)combinedParams + offset) = 2;\n  *(undefined4 *)(address + 0x28) = 0xffffffff;\n  *(char **)(address + 4) = param3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b2c": "update_tc_configure_00080b2c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "uVar3": "combinedParams",
                "iVar1": "offset",
                "iVar2": "address"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b90": {
            "entrypoint": "0x00080b90",
            "current_name": "set_element_value_00080b90",
            "code": "\nvoid setElementValue_00080b90(int mapBase,int elementIndex,undefined4 newValue)\n\n{\n  *(undefined4 *)(mapBase + elementIndex * 0x40 + 0x14) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b90": "set_element_value_00080b90",
                "param_1": "mapBase",
                "param_2": "elementIndex",
                "param_3": "newValue"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b98": {
            "entrypoint": "0x00080b98",
            "current_name": "initialize_memory_00080b98",
            "code": "\n\n\nvoid initializeMemory_00080b98(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  elfRelArray[6].r_offset = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b98": "initialize_memory_00080b98",
                "Elf32_Rel_ARRAY_20070000": "elfRelArray"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x00080c20",
            "current_name": "entry",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080c6a) */\n\n\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  for (iVar1 = 0; (undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) < &DAT_200708a0\n      ; iVar1 = iVar1 + 4) {\n    *(undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) =\n         *(undefined4 *)(&DAT_00085878 + iVar1);\n  }\n  for (puVar2 = &DAT_200708a0; puVar2 < (undefined4 *)0x20071248; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  FUN_000815ec();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_000815ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c98": {
            "entrypoint": "0x00080c98",
            "current_name": "find_threshold_value_00080c98",
            "code": "\nundefined4 find_threshold_value_00080c98(undefined4 *output_array,uint input_value,int subtraction_value,int multiplication_value)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint threshold_values [16];\n  \n  threshold_values[0] = 0;\n  threshold_values[1] = 8;\n  threshold_values[2] = 0x10;\n  threshold_values[3] = 0x18;\n  threshold_values[4] = 0x40;\n  threshold_values[5] = 0x50;\n  threshold_values[6] = 0x60;\n  threshold_values[7] = 0x70;\n  threshold_values[8] = 0x200;\n  threshold_values[9] = 0x240;\n  threshold_values[10] = 0x280;\n  threshold_values[11] = 0x2c0;\n  threshold_values[12] = 0x300;\n  threshold_values[13] = 0x340;\n  threshold_values[14] = 0x380;\n  threshold_values[15] = 0x3c0;\n  *output_array = 1;\n  output_array[1] = 0;\n  output_array[0x48] = 0x202;\n  output_array[0x41] = 0;\n  output_array[0x45] = 0;\n  uVar1 = input_value / (uint)(subtraction_value * 2);\n  if (input_value == subtraction_value * 2 * uVar1) {\n    uVar1 = uVar1 - 1;\n  }\n  uVar2 = 0;\n  do {\n    if ((uint)(multiplication_value * (int)(((ulonglong)input_value / (ulonglong)((uVar1 + 1) * 2)) / 1000000)) <=\n        threshold_values[uVar2]) {\n      output_array[1] = (uVar2 & 0xf) << 0x10 | (uVar1 & 0xff) << 8 | output_array[1];\n      return 0;\n    }\n    uVar2 = uVar2 + 1;\n  } while (uVar2 != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080c98": "find_threshold_value_00080c98",
                "param_1": "output_array",
                "param_2": "input_value",
                "param_3": "subtraction_value",
                "param_4": "multiplication_value",
                "local_58": "threshold_values"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d30": {
            "entrypoint": "0x00080d30",
            "current_name": "update_parameter_flags_00080d30",
            "code": "\nvoid updateParameterFlags_00080d30(int paramAddress,uint valueToUpdate,uint bitValue)\n\n{\n  *(uint *)(paramAddress + 4) = valueToUpdate | *(uint *)(paramAddress + 4) | (bitValue & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d30": "update_parameter_flags_00080d30",
                "param_1": "paramAddress",
                "param_2": "valueToUpdate",
                "param_3": "bitValue"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d3e": {
            "entrypoint": "0x00080d3e",
            "current_name": "update_parameters_00080d3e",
            "code": "\nvoid updateParameters_00080d3e(int valueAddress,uint bitmask1,uint bitmask2,uint bitmask3)\n\n{\n  *(uint *)(valueAddress + 4) =\n       bitmask2 | *(uint *)(valueAddress + 4) | (bitmask1 & 0xf) << 0x18 | (bitmask3 & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d3e": "update_parameters_00080d3e",
                "param_1": "valueAddress",
                "param_2": "bitmask1",
                "param_3": "bitmask2",
                "param_4": "bitmask3"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d58": {
            "entrypoint": "0x00080d58",
            "current_name": "set_bit_00080d58",
            "code": "\nvoid setBit_00080d58(int baseAddress,uint bitIndex)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (bitIndex & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d58": "set_bit_00080d58",
                "param_1": "baseAddress",
                "param_2": "bitIndex"
            },
            "calling": [
                "FUN_00080f0c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d62": {
            "entrypoint": "0x00080d62",
            "current_name": "set_memory_value_00080d62",
            "code": "\nvoid setMemoryValue_00080d62(int memoryAddress)\n\n{\n  *(undefined4 *)(memoryAddress + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d62": "set_memory_value_00080d62",
                "param_1": "memoryAddress"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d6a": {
            "entrypoint": "0x00080d6a",
            "current_name": "set_param_00080d6a",
            "code": "\nvoid setParam_00080d6a(int baseAddress,undefined4 newValue)\n\n{\n  *(undefined4 *)(baseAddress + 0x28) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d6a": "set_param_00080d6a",
                "param_1": "baseAddress",
                "param_2": "newValue"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e80": {
            "entrypoint": "0x00080e80",
            "current_name": "initialize_function_00080e80",
            "code": "\nundefined4 initializeFunction_00080e80(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080e80": "initialize_function_00080e80"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e88": {
            "entrypoint": "0x00080e88",
            "current_name": "add_with_previous_value_00080e88",
            "code": "\nint addWithPreviousValue_00080e88(int inputValue)\n\n{\n  int previousValue;\n  \n  if (DAT_20071208 == 0) {\n    DAT_20071208 = 0x20071248;\n  }\n  previousValue = DAT_20071208;\n  DAT_20071208 = inputValue + DAT_20071208;\n  return previousValue;\n}\n\n",
            "renaming": {
                "FUN_00080e88": "add_with_previous_value_00080e88",
                "param_1": "inputValue",
                "iVar1": "previousValue"
            },
            "calling": [
                "FUN_0008236c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eaa": {
            "entrypoint": "0x00080eaa",
            "current_name": "get_default_value_00080eaa",
            "code": "\nundefined4 get_default_value_00080eaa(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080eaa": "get_default_value_00080eaa"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eb0": {
            "entrypoint": "0x00080eb0",
            "current_name": "initialize_memory_block_00080eb0",
            "code": "\nundefined4 initializeMemoryBlock_00080eb0(undefined4 baseAddress,int memoryBlockAddress)\n\n{\n  *(undefined4 *)(memoryBlockAddress + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080eb0": "initialize_memory_block_00080eb0",
                "param_1": "baseAddress",
                "param_2": "memoryBlockAddress"
            },
            "calling": [
                "FUN_00084494"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eba": {
            "entrypoint": "0x00080eba",
            "current_name": "is_one_00080eba",
            "code": "\nbool is_one_00080eba(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080eba": "is_one_00080eba",
                "undefined4": "bool"
            },
            "calling": [
                "FUN_000844bc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ebe": {
            "entrypoint": "0x00080ebe",
            "current_name": "get_return_value_00080ebe",
            "code": "\nundefined4 getReturnValue_00080ebe(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ebe": "get_return_value_00080ebe"
            },
            "calling": [
                "FUN_000844e0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec2": {
            "entrypoint": "0x00080ec2",
            "current_name": "get_zero_00080ec2",
            "code": "\nundefined4 getZero_00080ec2(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ec2": "get_zero_00080ec2"
            },
            "calling": [
                "FUN_00084508"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec8": {
            "entrypoint": "0x00080ec8",
            "current_name": "copy_bytes_00080ec8",
            "code": "\n\n\nuint copyBytes_00080ec8(undefined4 destination,int source,uint numBytes)\n\n{\n  int i;\n  \n  for (i = 0; i < (int)numBytes; i = i + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)*(byte *)(source + i);\n  }\n  return numBytes & ~((int)numBytes >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_00080ec8": "copy_bytes_00080ec8",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "numBytes",
                "iVar1": "i"
            },
            "calling": [
                "FUN_00084244"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eec": {
            "entrypoint": "0x00080eec",
            "current_name": "exit_with_status_00080eec",
            "code": "\nvoid exitWithStatus_00080eec(undefined4 status,undefined4 unused1,undefined4 message,undefined4 unused2)\n\n{\n  FUN_000817c8(\"Exiting with status %d.\\n\",status,message,unused2,unused2);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080eec": "exit_with_status_00080eec",
                "param_1": "status",
                "param_2": "unused1",
                "param_3": "message",
                "param_4": "unused2"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_000817c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080efc": {
            "entrypoint": "0x00080efc",
            "current_name": "FUNC_00080efc",
            "code": "\nvoid FUNC_00080efc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080efc": "FUNC_00080efc"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080efe": {
            "entrypoint": "0x00080efe",
            "current_name": "get_default_value_00080efe",
            "code": "\nuint32_t get_default_value_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080efe": "get_default_value_00080efe",
                "undefined4": "uint32_t"
            },
            "calling": [
                "thunk_FUN_00080efe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_000816d8": {
            "entrypoint": "0x00080f04",
            "current_name": "get_global_variable_thunk_000816d8",
            "code": "\nundefined4 get_GLOBAL_VARIABLE_thunk_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "thunk_FUN_000816d8": "get_global_variable_thunk_000816d8"
            },
            "calling": [
                "FUN_000811e8"
            ],
            "called": [
                "FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f08": {
            "entrypoint": "0x00080f08",
            "current_name": "FUNC_00080f08",
            "code": "\nvoid FUNC_00080f08(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f08": "FUNC_00080f08"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0",
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0c": {
            "entrypoint": "0x00080f0c",
            "current_name": "check_and_update_parameter_00080f0c",
            "code": "\n\n\nint checkAndUpdateParameter_00080f0c(int inputValue1,int inputValue2)\n\n{\n  int returnValue;\n  uint bitmask1;\n  undefined4 actionCode;\n  uint bitmask2;\n  byte lowerNibble;\n  byte originalValue;\n  int index;\n  int var8;\n  \n  returnValue = inputValue1;\n  if ((&DAT_00084b50)[inputValue1 * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[inputValue1] & 0xf) == 4) {\n      returnValue = FUN_00080d58(0x400c0000,(&DAT_00084b5d)[inputValue1 * 0x1c]);\n    }\n    originalValue = (&DAT_20070e1c)[inputValue1];\n    lowerNibble = originalValue & 0xf;\n    if ((lowerNibble < 3) && (originalValue != 0)) {\n      if (lowerNibble == 2) {\n        if (inputValue2 == 0) {\n          return returnValue;\n        }\n      }\n      else if (lowerNibble == 1) {\n        if (inputValue2 == 2) {\n          return returnValue;\n        }\n      }\n      else if (lowerNibble == 3) {\n        if (inputValue2 == 1) {\n          return returnValue;\n        }\n        goto LAB_00080f68;\n      }\n    }\n    if (inputValue2 != 1) {\nLAB_00080f68:\n      if (inputValue2 == 0) {\n        returnValue = inputValue1 * 0x1c;\n        FUN_00080aa8(*(undefined4 *)(&DAT_00084b4c + returnValue));\n        returnValue = FUN_00080a30(*(undefined4 *)(&DAT_00084b44 + returnValue),3,\n                             *(undefined4 *)(&DAT_00084b48 + returnValue),0);\n        originalValue = (&DAT_20070e1c)[inputValue1] & 0xf0 | 2;\n      }\n      else {\n        if (inputValue2 != 2) {\n          return returnValue;\n        }\n        returnValue = inputValue1 * 0x1c;\n        FUN_00080aa8(*(undefined4 *)(&DAT_00084b4c + returnValue));\n        returnValue = FUN_00080a30(*(undefined4 *)(&DAT_00084b44 + returnValue),3,\n                             *(undefined4 *)(&DAT_00084b48 + returnValue),1);\n        originalValue = (&DAT_20070e1c)[inputValue1] & 0xf0 | 1;\n      }\n      (&DAT_20070e1c)[inputValue1] = originalValue;\n      return returnValue;\n    }\n    index = inputValue1 * 0x1c;\n    var8 = *(int *)(&DAT_00084b44 + index);\n    if (originalValue >> 4 == 0) {\n      actionCode = 4;\n    }\n    else {\n      actionCode = 5;\n    }\n    returnValue = FUN_00080a30(var8,actionCode,*(undefined4 *)(&DAT_00084b48 + index),\n                         *(undefined4 *)(&DAT_00084b54 + index));\n    (&DAT_20070e1c)[inputValue1] = (&DAT_20070e1c)[inputValue1] & 0xf0 | 3;\n    if (*(int *)(var8 + 0x18) == -1) {\n      bitmask1 = *(uint *)(&DAT_00084b4c + index);\n      if (0x2c < bitmask1) {\n        return 1;\n      }\n      if (bitmask1 < 0x20) {\n        bitmask1 = 1 << (bitmask1 & 0xff);\n        bitmask2 = _DAT_400e0618 & bitmask1;\n        if (bitmask2 == bitmask1) {\n          _DAT_400e0614 = bitmask2;\n        }\n      }\n      else {\n        bitmask1 = 1 << (bitmask1 - 0x20 & 0xff);\n        bitmask2 = _DAT_400e0708 & bitmask1;\n        if (bitmask2 == bitmask1) {\n          _DAT_400e0704 = bitmask2;\n        }\n      }\n      return 0;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00080f0c": "check_and_update_parameter_00080f0c",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "iVar1": "returnValue",
                "uVar2": "bitmask1",
                "uVar3": "actionCode",
                "uVar4": "bitmask2",
                "bVar5": "lowerNibble",
                "bVar6": "originalValue",
                "iVar7": "index",
                "iVar8": "var8"
            },
            "calling": [
                "FUN_00081014",
                "FUN_000806a0",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080a30",
                "FUN_00080aa8",
                "FUN_00080d58"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081014": {
            "entrypoint": "0x00081014",
            "current_name": "update_data_00081014",
            "code": "\nvoid updateData_00081014(int index,int value,undefined4 param)\n\n{\n  int result;\n  undefined4 newValue;\n  int dataPointer;\n  \n  if ((&DAT_00084b50)[index * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[index] & 0xf) == 5) {\n      FUN_00080f0c(index,1,param,5,index,value,param);\n    }\n    (&DAT_20070e1c)[index] = (&DAT_20070e1c)[index] & 0xf | (byte)(value << 4);\n    dataPointer = *(int *)(&DAT_00084b44 + index * 0x1c);\n    newValue = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n    result = FUN_00080a94(dataPointer,newValue);\n    if (result == 0) {\n      if (value != 0) {\n        *(undefined4 *)(dataPointer + 100) = newValue;\n        return;\n      }\n      *(undefined4 *)(dataPointer + 0x60) = newValue;\n      return;\n    }\n    FUN_00080a0a(dataPointer,newValue,value,0,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081014": "update_data_00081014",
                "param_1": "index",
                "param_2": "value",
                "param_3": "param",
                "iVar1": "result",
                "uVar2": "newValue",
                "iVar3": "dataPointer"
            },
            "calling": [
                "FUN_00080250",
                "FUN_0008044c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080a0a",
                "FUN_00080f0c",
                "FUN_00080a94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810a6": {
            "entrypoint": "0x000810a6",
            "current_name": "execute_function_000810a6",
            "code": "\nvoid executeFunction_000810a6(int *functionPointer,int size,undefined4 value1,undefined4 value2)\n\n{\n  undefined4 result;\n  \n  if (size != 0) {\n    result = FUN_00082688(size);\n    (**(code **)(*functionPointer + 4))(functionPointer,size,result,*(code **)(*functionPointer + 4),value2);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810a6": "execute_function_000810a6",
                "param_1": "functionPointer",
                "param_2": "size",
                "param_3": "value1",
                "param_4": "value2",
                "uVar1": "result"
            },
            "calling": [
                "FUN_000810c4",
                "FUN_000810d8",
                "FUN_000810fc",
                "FUN_000810e8"
            ],
            "called": [
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810c4": {
            "entrypoint": "0x000810c4",
            "current_name": "execute_startup_function_000810c4",
            "code": "\nvoid execute_startup_function_000810c4(void)\n\n{\n  FUN_000810a6();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810c4": "execute_startup_function_000810c4"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810cc": {
            "entrypoint": "0x000810cc",
            "current_name": "execute_function_000810cc",
            "code": "\nvoid executeFunction_000810cc(undefined4 *functionPointer)\n\n{\n  (**(code **)*functionPointer)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810cc": "execute_function_000810cc",
                "param_1": "functionPointer"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810d8": {
            "entrypoint": "0x000810d8",
            "current_name": "initialize_function_000810d8",
            "code": "\nvoid initializeFunction_000810d8(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  FUN_000810a6(param1,&DAT_00085635,param3,param4,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810d8": "initialize_function_000810d8",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4"
            },
            "calling": [
                "FUN_0008117a",
                "FUN_000810e8"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810e8": {
            "entrypoint": "0x000810e8",
            "current_name": "calculate_sum_000810e8",
            "code": "\nint calculateSum_000810e8(undefined4 inputValue)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = FUN_000810a6();\n  result2 = FUN_000810d8(inputValue);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_000810e8": "calculate_sum_000810e8",
                "param_1": "inputValue",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6",
                "FUN_000810d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810fc": {
            "entrypoint": "0x000810fc",
            "current_name": "convert_and_print_number_000810fc",
            "code": "\nvoid convertAndPrintNumber_000810fc(undefined4 outputStream,uint number,uint base)\n\n{\n  char *currentChar;\n  uint quotient;\n  char *previousChar;\n  char convertedChar;\n  uint remainder;\n  char convertedNumber [5];\n  \n  convertedNumber[1] = 0;\n  if (base < 2) {\n    base = 10;\n  }\n  currentChar = convertedNumber;\n  do {\n    previousChar = currentChar;\n    quotient = number / base;\n    remainder = number - base * quotient & 0xff;\n    convertedChar = (char)remainder;\n    if (remainder < 10) {\n      convertedChar = convertedChar + '0';\n    }\n    else {\n      convertedChar = convertedChar + '7';\n    }\n    *previousChar = convertedChar;\n    number = quotient;\n    currentChar = previousChar + -1;\n  } while (quotient != 0);\n  FUN_000810a6(outputStream,previousChar);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810fc": "convert_and_print_number_000810fc",
                "param_1": "outputStream",
                "param_2": "number",
                "param_3": "base",
                "pcVar1": "currentChar",
                "uVar2": "quotient",
                "pcVar3": "previousChar",
                "cVar4": "convertedChar",
                "uVar5": "remainder",
                "local_15": "convertedNumber"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008113a": {
            "entrypoint": "0x0008113a",
            "current_name": "parse_number_0008113a",
            "code": "\nint parseNumber_0008113a(undefined4 *paramPtr,uint input,uint base,undefined4 param4)\n\n{\n  int result;\n  int tempVar;\n  \n  if (base == 0) {\n    result = (**(code **)*paramPtr)(paramPtr,input & 0xff);\n    return result;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)input < 0) {\n      result = FUN_000810cc(paramPtr,0x2d);\n      tempVar = FUN_000810fc(paramPtr,-input,10);\n      return tempVar + result;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  result = FUN_000810fc(paramPtr,input,base,param4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0008113a": "parse_number_0008113a",
                "param_1": "paramPtr",
                "param_2": "input",
                "param_3": "base",
                "param_4": "param4",
                "iVar1": "result",
                "iVar2": "tempVar"
            },
            "calling": [
                "thunk_FUN_0008113a",
                "FUN_0008117a"
            ],
            "called": [
                "FUN_000810cc",
                "FUN_000810fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_0008113a": {
            "entrypoint": "0x00081176",
            "current_name": "process_data_thunk_0008113a",
            "code": "\nint process_data_thunk_0008113a(undefined4 *data_ptr,uint value,uint base,undefined4 param)\n\n{\n  int result;\n  int negative_value;\n  \n  if (base == 0) {\n    result = (**(code **)*data_ptr)(data_ptr,value & 0xff);\n    return result;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)value < 0) {\n      result = FUN_000810cc(data_ptr,0x2d);\n      negative_value = FUN_000810fc(data_ptr,-value,10);\n      return negative_value + result;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  result = FUN_000810fc(data_ptr,value,base,param);\n  return result;\n}\n\n",
            "renaming": {
                "thunk_FUN_0008113a": "process_data_thunk_0008113a",
                "param_1": "data_ptr",
                "param_2": "value",
                "param_3": "base",
                "param_4": "param",
                "iVar1": "result",
                "iVar2": "negative_value"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008117a": {
            "entrypoint": "0x0008117a",
            "current_name": "calculate_sum_0008117a",
            "code": "\nint calculateSum_0008117a(undefined4 inputParam)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = FUN_0008113a();\n  result2 = FUN_000810d8(inputParam);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_0008117a": "calculate_sum_0008117a",
                "param_1": "inputParam",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810d8",
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081190": {
            "entrypoint": "0x00081190",
            "current_name": "handle_elf_relocation_00081190",
            "code": "\nvoid handleElfRelocation_00081190(void)\n\n{\n  if ((relInfo != 0xffffffff) &&\n     (relInfo = relInfo - 1,\n     relInfo == 0)) {\n    (*(code *)((int)&relArray[0].r_offset + 1))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081190": "handle_elf_relocation_00081190",
                "Elf32_Rel_ARRAY_20070000": "relArray",
                "Elf32_Rel_ARRAY_20070000[6].r_info": "relInfo"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b0": {
            "entrypoint": "0x000811b0",
            "current_name": "initialize_memory_000811b0",
            "code": "\nint initializeMemory_000811b0(int memoryPointer)\n\n{\n  FUN_00081f00(memoryPointer,0,0x80);\n  *(undefined4 *)(memoryPointer + 0x80) = 0;\n  *(undefined4 *)(memoryPointer + 0x84) = 0;\n  return memoryPointer;\n}\n\n",
            "renaming": {
                "FUN_000811b0": "initialize_memory_000811b0",
                "param_1": "memoryPointer"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ca": {
            "entrypoint": "0x000811ca",
            "current_name": "update_param_and_check_boundary_000811ca",
            "code": "\nvoid updateParamAndCheckBoundary_000811ca(int paramPtr,undefined newValue)\n\n{\n  uint updatedIndex;\n  \n  updatedIndex = *(int *)(paramPtr + 0x80) + 1U & 0x7f;\n  if (updatedIndex != *(uint *)(paramPtr + 0x84)) {\n    *(undefined *)(paramPtr + *(int *)(paramPtr + 0x80)) = newValue;\n    *(uint *)(paramPtr + 0x80) = updatedIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000811ca": "update_param_and_check_boundary_000811ca",
                "param_1": "paramPtr",
                "param_2": "newValue",
                "uVar1": "updatedIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811e8": {
            "entrypoint": "0x000811e8",
            "current_name": "process_data_000811e8",
            "code": "\nint process_data_000811e8(int *data_array)\n\n{\n  int result;\n  \n  result = thunk_FUN_000816d8();\n  data_array[3] = result;\n  do {\n    result = (**(code **)(*data_array + 0xc))(data_array);\n    if (-1 < result) {\n      return result;\n    }\n    result = thunk_FUN_000816d8();\n  } while ((uint)(result - data_array[3]) < (uint)data_array[2]);\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811e8": "process_data_000811e8",
                "param_1": "data_array",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "thunk_FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081214": {
            "entrypoint": "0x00081214",
            "current_name": "process_data_00081214",
            "code": "\nvoid processData_00081214(undefined4 arg1,undefined4 arg2,uint targetValue)\n\n{\n  uint returnValue;\n  \n  FUN_000814f6(arg1,&DAT_00085637);\n  while ((returnValue = FUN_000811e8(arg2), -1 < (int)returnValue && (returnValue != targetValue))) {\n    FUN_0008159e(arg1,returnValue & 0xff);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081214": "process_data_00081214",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "targetValue",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008159e",
                "FUN_000811e8",
                "FUN_000814f6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081248": {
            "entrypoint": "0x00081248",
            "current_name": "calculate_difference_00081248",
            "code": "\nuint calculateDifference_00081248(int inputValue)\n\n{\n  return *(int *)(*(int *)(inputValue + 0x10) + 0x80) - *(int *)(*(int *)(inputValue + 0x10) + 0x84) &\n         0x7f;\n}\n\n",
            "renaming": {
                "FUN_00081248": "calculate_difference_00081248",
                "param_1": "inputValue"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080970"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081276": {
            "entrypoint": "0x00081276",
            "current_name": "extract_byte_from_buffer_00081276",
            "code": "\nuint extractByteFromBuffer_00081276(int buffer_ptr)\n\n{\n  byte extracted_byte;\n  int buffer_info_ptr;\n  \n  buffer_info_ptr = *(int *)(buffer_ptr + 0x10);\n  if (*(int *)(buffer_info_ptr + 0x80) != *(int *)(buffer_info_ptr + 0x84)) {\n    extracted_byte = *(byte *)(buffer_info_ptr + *(int *)(buffer_info_ptr + 0x84));\n    *(uint *)(buffer_info_ptr + 0x84) = *(int *)(buffer_info_ptr + 0x84) + 1U & 0x7f;\n    return (uint)extracted_byte;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00081276": "extract_byte_from_buffer_00081276",
                "param_1": "buffer_ptr",
                "bVar1": "extracted_byte",
                "iVar2": "buffer_info_ptr"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812b8": {
            "entrypoint": "0x000812b8",
            "current_name": "update_data_000812b8",
            "code": "\nundefined4 updateData_000812b8(int dataPtr,undefined4 newValue)\n\n{\n  int structurePtr;\n  uint nextIndex;\n  \n  structurePtr = *(int *)(dataPtr + 0x14);\n  if ((*(int *)(*(int *)(dataPtr + 0x18) + 0x14) << 0x1e < 0) &&\n     (*(int *)(structurePtr + 0x84) == *(int *)(structurePtr + 0x80))) {\n    *(undefined4 *)(*(int *)(dataPtr + 0x18) + 0x1c) = newValue;\n  }\n  else {\n    nextIndex = *(int *)(structurePtr + 0x80) + 1U & 0x8000007f;\n    if ((int)nextIndex < 0) {\n      nextIndex = (nextIndex - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (*(uint *)(structurePtr + 0x84) == nextIndex);\n    *(char *)(structurePtr + *(int *)(structurePtr + 0x80)) = (char)newValue;\n    *(uint *)(*(int *)(dataPtr + 0x14) + 0x80) = nextIndex;\n    *(undefined4 *)(*(int *)(dataPtr + 0x18) + 8) = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000812b8": "update_data_000812b8",
                "param_1": "dataPtr",
                "param_2": "newValue",
                "iVar1": "structurePtr",
                "uVar2": "nextIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081348": {
            "entrypoint": "0x00081348",
            "current_name": "initialize_function_00081348",
            "code": "\nvoid initializeFunction_00081348(undefined4 *outputArray,undefined4 inputValue,undefined flag,undefined4 param4,\n                 undefined4 param5,undefined4 param6)\n\n{\n  outputArray[1] = 0;\n  outputArray[2] = 1000;\n  outputArray[6] = inputValue;\n  *outputArray = &PTR_FUN_000812b8_1_00085650;\n  *(undefined *)(outputArray + 7) = flag;\n  outputArray[4] = param5;\n  outputArray[8] = param4;\n  outputArray[5] = param6;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081348": "initialize_function_00081348",
                "param_1": "outputArray",
                "param_2": "inputValue",
                "param_3": "flag",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6"
            },
            "calling": [
                "FUN_00081438",
                "FUN_0008089c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813dc": {
            "entrypoint": "0x000813dc",
            "current_name": "initialize_function_000813dc",
            "code": "\nvoid initializeFunction_000813dc(int param1,uint param2)\n\n{\n  int localVar1;\n  undefined4 *localVar2;\n  \n  FUN_00080aa8(*(undefined4 *)(param1 + 0x20));\n  localVar2 = *(undefined4 **)(param1 + 0x18);\n  localVar2[0x48] = 0x202;\n  *localVar2 = 0xac;\n  localVar2[1] = 0x800;\n  localVar2[8] = Elf32_Rel_ARRAY_20070000[6].r_offset / param2 >> 4;\n  localVar2[3] = 0xffffffff;\n  localVar2[2] = 0x61;\n  *(int *)(((uint)(int)(char)*(byte *)(param1 + 0x1c) >> 5) * 4 + -0x1fff1f00) =\n       1 << (uint)(*(byte *)(param1 + 0x1c) & 0x1f);\n  localVar1 = *(int *)(param1 + 0x10);\n  *(undefined4 *)(localVar1 + 0x84) = 0;\n  *(undefined4 *)(localVar1 + 0x80) = 0;\n  localVar1 = *(int *)(param1 + 0x14);\n  *(undefined4 *)(localVar1 + 0x84) = 0;\n  *(undefined4 *)(localVar1 + 0x80) = 0;\n  *localVar2 = 0x50;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813dc": "initialize_function_000813dc",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "localVar1",
                "puVar2": "localVar2"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080aa8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081438": {
            "entrypoint": "0x00081438",
            "current_name": "initialize_function_00081438",
            "code": "\nundefined4 * initializeFunction_00081438(undefined4 *outputArray,undefined4 inputValue)\n\n{\n  FUN_00081348();\n  *outputArray = &PTR_FUN_000812b8_1_00085680;\n  outputArray[9] = inputValue;\n  return outputArray;\n}\n\n",
            "renaming": {
                "FUN_00081438": "initialize_function_00081438",
                "param_1": "outputArray",
                "param_2": "inputValue"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081348"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008145c": {
            "entrypoint": "0x0008145c",
            "current_name": "calculate_interpolation_0008145c",
            "code": "\nint calculateInterpolation_0008145c(int startValue,int startRange,int endRange,int startOutput,int endOutput)\n\n{\n  return (uint)((startValue - startRange) * (endOutput - startOutput)) / (uint)(endRange - startRange) + startOutput;\n}\n\n",
            "renaming": {
                "FUN_0008145c": "calculate_interpolation_0008145c",
                "param_1": "startValue",
                "param_2": "startRange",
                "param_3": "endRange",
                "param_4": "startOutput",
                "param_5": "endOutput"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000806f8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081472": {
            "entrypoint": "0x00081472",
            "current_name": "initialize_pointer_00081472",
            "code": "\nundefined4 * initializePointer_00081472(undefined4 *pointer)\n\n{\n  FUN_00081800(*pointer);\n  return pointer;\n}\n\n",
            "renaming": {
                "FUN_00081472": "initialize_pointer_00081472",
                "param_1": "pointer"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081480": {
            "entrypoint": "0x00081480",
            "current_name": "reset_params_00081480",
            "code": "\nvoid resetParams_00081480(int *params)\n\n{\n  if (*params != 0) {\n    FUN_00081800();\n  }\n  *params = 0;\n  params[2] = 0;\n  params[1] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081480": "reset_params_00081480",
                "param_1": "params",
                "param_1[2]": "params[2]",
                "param_1[1]": "params[1]"
            },
            "calling": [
                "FUN_000814d0"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081496": {
            "entrypoint": "0x00081496",
            "current_name": "update_parameter_value_00081496",
            "code": "\nint updateParameterValue_00081496(int *parameterList,int newValue,undefined4 oldValue,undefined4 anotherValue)\n\n{\n  int result;\n  \n  result = FUN_00081f9c(*parameterList,newValue + 1,oldValue,anotherValue,anotherValue);\n  if (result != 0) {\n    *parameterList = result;\n    nextParameter = newValue;\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081496": "update_parameter_value_00081496",
                "param_1": "parameterList",
                "param_2": "newValue",
                "param_3": "oldValue",
                "param_4": "anotherValue",
                "iVar1": "result",
                "param_1[1]": "nextParameter"
            },
            "calling": [
                "FUN_000814ae"
            ],
            "called": [
                "FUN_00081f9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814ae": {
            "entrypoint": "0x000814ae",
            "current_name": "check_and_set_zero_000814ae",
            "code": "\nundefined4 checkAndSetZero_000814ae(int *array,uint limit)\n\n{\n  int returnValue;\n  \n  if ((*array == 0) || ((uint)array[1] < limit)) {\n    returnValue = FUN_00081496(array);\n    if (returnValue == 0) {\n      return 0;\n    }\n    if (array[2] == 0) {\n      *(undefined *)*array = 0;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000814ae": "check_and_set_zero_000814ae",
                "param_1": "array",
                "param_2": "limit",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [
                "FUN_00081496"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814d0": {
            "entrypoint": "0x000814d0",
            "current_name": "validate_and_process_data_000814d0",
            "code": "\nundefined4 * validateAndProcessData_000814d0(undefined4 *inputBuffer,undefined4 value1,undefined4 value2)\n\n{\n  int result;\n  \n  result = FUN_000814ae(inputBuffer,value2);\n  if (result == 0) {\n    FUN_00081480(inputBuffer);\n  }\n  else {\n    inputBuffer[2] = value2;\n    FUN_000825cc(*inputBuffer,value1);\n  }\n  return inputBuffer;\n}\n\n",
            "renaming": {
                "FUN_000814d0": "validate_and_process_data_000814d0",
                "param_1": "inputBuffer",
                "param_2": "value1",
                "param_3": "value2",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814f6"
            ],
            "called": [
                "FUN_00081480",
                "FUN_000814ae",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814f6": {
            "entrypoint": "0x000814f6",
            "current_name": "initialize_and_process_000814f6",
            "code": "\nundefined4 * initializeAndProcess_000814f6(undefined4 *outputArray,int inputValue)\n\n{\n  undefined4 returnValue;\n  \n  *outputArray = 0;\n  outputArray[1] = 0;\n  outputArray[2] = 0;\n  if (inputValue != 0) {\n    returnValue = FUN_00082688(inputValue);\n    FUN_000814d0(outputArray,inputValue,returnValue);\n  }\n  return outputArray;\n}\n\n",
            "renaming": {
                "FUN_000814f6": "initialize_and_process_000814f6",
                "param_1": "outputArray",
                "param_2": "inputValue",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_000814d0",
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008151c": {
            "entrypoint": "0x0008151c",
            "current_name": "update_param_0008151c",
            "code": "\nvoid updateParam_0008151c(int *targetParam,int *sourceParam)\n\n{\n  if (*targetParam != 0) {\n    if ((*sourceParam != 0) && ((uint)sourceParam[2] <= (uint)targetParam[1])) {\n      FUN_000825cc();\n      targetParam[2] = sourceParam[2];\n      goto LAB_00081558;\n    }\n    FUN_00081800();\n  }\n  *targetParam = *sourceParam;\n  targetParam[1] = sourceParam[1];\n  targetParam[2] = sourceParam[2];\n  *sourceParam = 0;\n  sourceParam[1] = 0;\nLAB_00081558:\n  sourceParam[2] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008151c": "update_param_0008151c",
                "param_1": "targetParam",
                "param_2": "sourceParam",
                "param_2[2]": "sourceParam[2]",
                "param_1[1]": "targetParam[1]",
                "param_1[2]": "targetParam[2]",
                "param_2[1]": "sourceParam[1]"
            },
            "calling": [
                "FUN_00081560"
            ],
            "called": [
                "FUN_00081800",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081560": {
            "entrypoint": "0x00081560",
            "current_name": "check_and_call_function_00081560",
            "code": "\nint check_and_call_function_00081560(int input_value_1,int input_value_2)\n\n{\n  if (input_value_1 != input_value_2) {\n    FUN_0008151c();\n  }\n  return input_value_1;\n}\n\n",
            "renaming": {
                "FUN_00081560": "check_and_call_function_00081560",
                "param_1": "input_value_1",
                "param_2": "input_value_2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008151c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081570": {
            "entrypoint": "0x00081570",
            "current_name": "update_list_element_00081570",
            "code": "\nundefined4 updateListElement_00081570(int *list,int length,int offset)\n\n{\n  int result;\n  int element;\n  \n  element = list[2];\n  if (length == 0) {\n    return 0;\n  }\n  if (offset != 0) {\n    result = FUN_000814ae(list,element + offset);\n    if (result == 0) {\n      return 0;\n    }\n    FUN_000825cc(*list + list[2],length);\n    list[2] = element + offset;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00081570": "update_list_element_00081570",
                "param_1": "list",
                "param_2": "length",
                "param_3": "offset",
                "iVar1": "result",
                "iVar2": "element"
            },
            "calling": [
                "FUN_0008159e"
            ],
            "called": [
                "FUN_000814ae",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008159e": {
            "entrypoint": "0x0008159e",
            "current_name": "initialize_function_0008159e",
            "code": "\nvoid initializeFunction_0008159e(undefined4 inputParam1,undefined4 inputParam2,undefined4 inputParam3)\n\n{\n  undefined4 localVariable1;\n  undefined4 localVariable2;\n  \n  localVariable2 = inputParam3;\n  FUN_00081570(inputParam1,&localVariable1,1,0,inputParam1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008159e": "initialize_function_0008159e",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "param_3": "inputParam3",
                "local_c": "localVariable1",
                "uStack_8": "localVariable2"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_00081570"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815b8": {
            "entrypoint": "0x000815b8",
            "current_name": "check_value_validity_000815b8",
            "code": "\nint checkValueValidity_000815b8(byte **pointerToData,byte *valueToCheck)\n\n{\n  uint dataValue;\n  int isValid;\n  \n  if (pointerToData[2] == (byte *)0x0) {\n    if (valueToCheck == (byte *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    if (valueToCheck != (byte *)0x0) {\n      dataValue = FUN_00082390(*pointerToData);\n      goto LAB_000815d4;\n    }\n    valueToCheck = *pointerToData;\n  }\n  dataValue = (uint)*valueToCheck;\nLAB_000815d4:\n  isValid = 1 - dataValue;\n  if (1 < dataValue) {\n    isValid = 0;\n  }\n  return isValid;\n}\n\n",
            "renaming": {
                "FUN_000815b8": "check_value_validity_000815b8",
                "param_1": "pointerToData",
                "param_2": "valueToCheck",
                "uVar1": "dataValue",
                "iVar2": "isValid"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00082390"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815de": {
            "entrypoint": "0x000815de",
            "current_name": "parse_integer_000815de",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000827e8) */\n/* WARNING: Removing unreachable block (ram,0x000827a8) */\n/* WARNING: Removing unreachable block (ram,0x000827a0) */\n/* WARNING: Removing unreachable block (ram,0x000827da) */\n/* WARNING: Removing unreachable block (ram,0x000827ec) */\n/* WARNING: Removing unreachable block (ram,0x000827e4) */\n/* WARNING: Removing unreachable block (ram,0x000827a4) */\n/* WARNING: Removing unreachable block (ram,0x0008278a) */\n/* WARNING: Removing unreachable block (ram,0x000827c8) */\n/* WARNING: Removing unreachable block (ram,0x0008278c) */\n\nuint parseInteger_000815de(byte **input)\n\n{\n  byte currentByte;\n  byte isNegative;\n  uint result;\n  byte *currentBytePtr;\n  uint currentByteValue;\n  byte *nextBytePtr;\n  int digit;\n  int state;\n  uint maxDivisor;\n  uint minValue;\n  \n  currentBytePtr = *input;\n  if (*input == (byte *)0x0) {\n    return 0;\n  }\n  do {\n    nextBytePtr = currentBytePtr;\n    currentBytePtr = nextBytePtr + 1;\n    currentByteValue = (uint)*nextBytePtr;\n    currentByte = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + currentByteValue + 1);\n    isNegative = currentByte & 8;\n  } while ((currentByte & 8) != 0);\n  if (currentByteValue == 0x2d) {\n    currentBytePtr = nextBytePtr + 2;\n    currentByteValue = (uint)nextBytePtr[1];\n    isNegative = 1;\n  }\n  else if (currentByteValue == 0x2b) {\n    currentByteValue = (uint)nextBytePtr[1];\n    currentBytePtr = nextBytePtr + 2;\n  }\n  if (isNegative == 0) {\n    minValue = 0x7fffffff;\n  }\n  else {\n    minValue = 0x80000000;\n  }\n  maxDivisor = minValue / 10;\n  state = 0;\n  result = 0;\n  do {\n    currentByte = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + currentByteValue + 1);\n    if ((currentByte & 4) == 0) {\n      if ((currentByte & 3) == 0) {\nLAB_0008277e:\n        if (state == -1) {\n          if (isNegative == 0) {\n            result = 0x7fffffff;\n          }\n          else {\n            result = 0x80000000;\n          }\n          *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x22;\n        }\n        else if (isNegative != 0) {\n          result = -result;\n        }\n        return result;\n      }\n      if ((currentByte & 3) == 1) {\n        digit = 0x37;\n      }\n      else {\n        digit = 0x57;\n      }\n      digit = currentByteValue - digit;\n    }\n    else {\n      digit = currentByteValue - 0x30;\n    }\n    if (9 < digit) goto LAB_0008277e;\n    if (state != -1) {\n      if ((maxDivisor <= result && result != maxDivisor) || ((result == maxDivisor && ((int)(minValue % 10) < digit))))\n      {\n        state = -1;\n      }\n      else {\n        result = result * 10 + digit;\n        state = 1;\n      }\n    }\n    currentByteValue = (uint)*currentBytePtr;\n    currentBytePtr = currentBytePtr + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815de": "parse_integer_000815de",
                "param_1": "input",
                "bVar1": "currentByte",
                "bVar2": "isNegative",
                "uVar3": "result",
                "pbVar4": "currentBytePtr",
                "uVar5": "currentByteValue",
                "pbVar6": "nextBytePtr",
                "iVar7": "digit",
                "iVar8": "state",
                "uVar9": "maxDivisor",
                "uVar10": "minValue"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815e8": {
            "entrypoint": "0x000815e8",
            "current_name": "FUNC_000815e8",
            "code": "\nvoid FUNC_000815e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000815e8": "FUNC_000815e8"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000815ec": {
            "entrypoint": "0x000815ec",
            "current_name": "initialize_system_000815ec",
            "code": "\nvoid initializeSystem_000815ec(void)\n\n{\n  FUN_00081618();\n  FUN_00080774();\n  FUNC_000815e8();\n  FUNC_00080f08(1);\n  FUN_000801e0();\n  do {\n    FUN_00080250();\n    FUN_00080970();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815ec": "initialize_system_000815ec"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_00080250",
                "FUN_00080970",
                "FUN_000801e0",
                "FUN_000815e8",
                "FUN_00081618",
                "FUN_00080f08",
                "FUN_00080774"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081618": {
            "entrypoint": "0x00081618",
            "current_name": "initialize_device_00081618",
            "code": "\n\n\nvoid initializeDevice_00081618(void)\n\n{\n  _DAT_400e1a54 = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081618": "initialize_device_00081618"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081624": {
            "entrypoint": "0x00081624",
            "current_name": "calculate_result_00081624",
            "code": "\nint calculateResult_00081624(int index,int flag,int multiplier,undefined4 param)\n\n{\n  int result;\n  undefined4 value;\n  \n  value = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n  if (flag == 0) {\n    value = 0;\n  }\n  result = FUN_00081684(*(int *)(&DAT_00084b44 + index * 0x1c) + 0x3c,\n                       *(undefined4 *)(&DAT_00084b48 + index * 0x1c),value,\n                       ((array[6].r_offset / 1000000) * multiplier) / 0x12,param);\n  if (result != 0) {\n    result = (int)((ulonglong)(result * 18000 + 16000) /\n                 ((ulonglong)array[6].r_offset / 1000));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081624": "calculate_result_00081624",
                "param_1": "index",
                "param_2": "flag",
                "param_3": "multiplier",
                "param_4": "param",
                "iVar1": "result",
                "uVar2": "value",
                "Elf32_Rel_ARRAY_20070000": "array"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081684"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081684": {
            "entrypoint": "0x00081684",
            "current_name": "check_param_sequence_00081684",
            "code": "\nint check_param_sequence_00081684(uint *sequence,uint mask,uint expected_value,int sequence_length)\n\n{\n  int matching_count;\n  \n  do {\n    if ((*sequence & mask) != expected_value) {\n      do {\n        if ((*sequence & mask) == expected_value) {\n          matching_count = 0;\n          do {\n            if ((*sequence & mask) != expected_value) {\n              return matching_count;\n            }\n            matching_count = matching_count + 1;\n          } while (sequence_length != matching_count);\n          return 0;\n        }\n        sequence_length = sequence_length + -1;\n      } while (sequence_length != 0);\n      return 0;\n    }\n    sequence_length = sequence_length + -1;\n  } while (sequence_length != 0);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081684": "check_param_sequence_00081684",
                "param_1": "sequence",
                "param_2": "mask",
                "param_3": "expected_value",
                "param_4": "sequence_length",
                "iVar1": "matching_count"
            },
            "calling": [
                "FUN_00081624"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d8": {
            "entrypoint": "0x000816d8",
            "current_name": "get_global_data_000816d8",
            "code": "\nundefined4 getGlobalData_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "FUN_000816d8": "get_global_data_000816d8"
            },
            "calling": [
                "thunk_FUN_000816d8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816ec": {
            "entrypoint": "0x000816ec",
            "current_name": "update_params_and_jump_000816ec",
            "code": "\nvoid updateParamsAndJump_000816ec(dword newValue1,dword newValue2,dword newValue3)\n\n{\n  dword *arrayPtr;\n  uint index;\n  uint bitMask;\n  code *jumpTable;\n  \n  if (relocTable[48].r_offset == 0) {\n    relocTable[48].r_offset = 0x20070184;\n  }\n  index = *(uint *)(relocTable[48].r_offset + 4);\n  arrayPtr = (dword *)relocTable[48].r_offset;\n  if (0x1f < (int)index) {\n    arrayPtr = (dword *)FUN_000817f0(400);\n    if (arrayPtr == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTable)(0xffffffff);\n      return;\n    }\n    *arrayPtr = relocTable[48].r_offset;\n    arrayPtr[1] = 0;\n    index = 0;\n    relocTable[48].r_offset = (dword)arrayPtr;\n    arrayPtr[0x62] = 0;\n    arrayPtr[99] = 0;\n  }\n  bitMask = 1 << (index & 0xff);\n  arrayPtr[index + 0x22] = newValue1;\n  arrayPtr[0x62] = arrayPtr[0x62] | bitMask;\n  arrayPtr[index + 0x42] = newValue3;\n  arrayPtr[99] = bitMask | arrayPtr[99];\n  arrayPtr[1] = index + 1;\n  arrayPtr[index + 2] = newValue2;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816ec": "update_params_and_jump_000816ec",
                "param_1": "newValue1",
                "param_2": "newValue2",
                "param_3": "newValue3",
                "pdVar1": "arrayPtr",
                "uVar2": "index",
                "uVar3": "bitMask",
                "UNRECOVERED_JUMPTABLE_00": "jumpTable",
                "Elf32_Rel_ARRAY_20070000": "relocTable"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816f8": {
            "entrypoint": "0x000816f8",
            "current_name": "assertion_failed_function_000816f8",
            "code": "\nvoid assertionFailedFunction_000816f8(undefined4 message,undefined4 file,char *line,undefined4 function)\n\n{\n  undefined4 assertion;\n  undefined4 temp;\n  char *str;\n  undefined8 result;\n  \n  assertion = *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0xc);\n  if (line == (char *)0x0) goto LAB_0008171c;\n  temp = function;\n  str = \", function: \";\n  do {\n    function = message;\n    FUNC_00081750(assertion,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",temp,message,file,\n                 str,line);\n    result = FUN_000836ec();\n    file = (undefined4)((ulonglong)result >> 0x20);\n    assertion = (undefined4)result;\nLAB_0008171c:\n    line = \"\";\n    temp = function;\n    str = line;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000816f8": "assertion_failed_function_000816f8",
                "param_1": "message",
                "param_2": "file",
                "param_3": "line",
                "param_4": "function",
                "uVar1": "assertion",
                "uVar2": "temp",
                "pcVar3": "str",
                "uVar4": "result"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080b2c"
            ],
            "called": [
                "FUN_00081750",
                "FUN_000836ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081750": {
            "entrypoint": "0x00081750",
            "current_name": "FUNC_00081750",
            "code": "\nvoid FUNC_00081750(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 = param_3;\n  uStack_4 = param_4;\n  FUN_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,param_1,param_2,&uStack_8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081750": "FUNC_00081750"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081778": {
            "entrypoint": "0x00081778",
            "current_name": "execute_multiple_functions_00081778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081784) */\n/* WARNING: Removing unreachable block (ram,0x00081788) */\n/* WARNING: Removing unreachable block (ram,0x000817b4) */\n\nvoid executeMultipleFunctions_00081778(void)\n\n{\n  int counter;\n  code **functionPointers;\n  \n  FUNC_00085844();\n  functionPointers = (code **)0x8584c;\n  counter = 0;\n  do {\n    counter = counter + 1;\n    functionPointers = functionPointers + 1;\n    (**functionPointers)();\n  } while (counter != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081778": "execute_multiple_functions_00081778",
                "iVar1": "counter",
                "ppcVar2": "functionPointers"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080118",
                "FUN_00085844",
                "FUN_000836d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817c8": {
            "entrypoint": "0x000817c8",
            "current_name": "process_data_000817c8",
            "code": "\nvoid processData_000817c8(undefined4 data1,undefined4 data2,undefined4 data3,undefined4 data4)\n\n{\n  undefined4 processedData1;\n  undefined4 processedData2;\n  undefined4 processedData3;\n  \n  processedData1 = data2;\n  processedData2 = data3;\n  processedData3 = data4;\n  FUN_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,\n               *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 8),data1,&processedData1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817c8": "process_data_000817c8",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "param_4": "data4",
                "uStack_c": "processedData1",
                "uStack_8": "processedData2",
                "uStack_4": "processedData3"
            },
            "calling": [
                "FUN_00080eec"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817f0": {
            "entrypoint": "0x000817f0",
            "current_name": "execute_relocation_000817f0",
            "code": "\nvoid executeRelocation_000817f0(undefined4 inputParam)\n\n{\n  FUN_00081810(relArray[140].r_offset,inputParam);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817f0": "execute_relocation_000817f0",
                "param_1": "inputParam",
                "Elf32_Rel_ARRAY_20070000": "relArray"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00081810"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081800": {
            "entrypoint": "0x00081800",
            "current_name": "execute_relocation_00081800",
            "code": "\nvoid executeRelocation_00081800(undefined4 inputParam)\n\n{\n  FUN_00083b10(relocationOffset,inputParam);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081800": "execute_relocation_00081800",
                "param_1": "inputParam",
                "Elf32_Rel_ARRAY_20070000[140].r_offset": "relocationOffset"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_00081472",
                "FUN_00081480"
            ],
            "called": [
                "FUN_00083b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081810": {
            "entrypoint": "0x00081810",
            "current_name": "process_data_00081810",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * processData_00081810(undefined4 *output,uint size)\n\n{\n  dword tempVar1;\n  int tempVar2;\n  uint flags;\n  uint offset;\n  int index1;\n  uint diff1;\n  dword pointer1;\n  uint flags2;\n  int index2;\n  undefined *ptr1;\n  dword pointer2;\n  dword pointer3;\n  int index3;\n  dword *ptr2;\n  uint var1;\n  undefined *ptr3;\n  dword *ppointer4;\n  uint uVar18;\n  \n  if (size + 0xb < 0x17) {\n    var1 = 0x10;\n    if (0x10 < size) goto LAB_00081876;\n  }\n  else {\n    var1 = size + 0xb & 0xfffffff8;\n    if (((int)var1 < 0) || (var1 < size)) {\nLAB_00081876:\n      *output = 0xc;\n      return (int *)0x0;\n    }\n  }\n  FUNC_00081f94(output);\n  tempVar1 = Elf32_Rel_ARRAY_20070000[142].r_info;\n  if (var1 < 0x1f8) {\n    index3 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8e].r_offset + var1);\n    if ((index3 != var1 + 0x20070464) ||\n       (tempVar2 = index3 + 8, index3 = *(int *)(index3 + 0x14), tempVar2 != index3)) {\n      index1 = *(int *)(index3 + 0xc);\n      index2 = (*(uint *)(index3 + 4) & 0xfffffffc) + index3;\n      var1 = *(uint *)(index2 + 4);\n      tempVar2 = *(int *)(index3 + 8);\n      *(int *)(tempVar2 + 0xc) = index1;\n      *(int *)(index1 + 8) = tempVar2;\n      *(uint *)(index2 + 4) = var1 | 1;\n      FUNC_00081f98(output);\n      return (int *)(index3 + 8);\n    }\n    uVar18 = (var1 >> 3) + 2;\n  }\n  else {\n    uVar18 = var1 >> 9;\n    if (uVar18 == 0) {\n      tempVar2 = 0x7e;\n      index3 = 0x3f;\n    }\n    else if (uVar18 < 5) {\n      index3 = (var1 >> 6) + 0x38;\n      tempVar2 = index3 * 2;\n    }\n    else if (uVar18 < 0x15) {\n      index3 = uVar18 + 0x5b;\n      tempVar2 = index3 * 2;\n    }\n    else if (uVar18 < 0x55) {\n      index3 = (var1 >> 0xc) + 0x6e;\n      tempVar2 = index3 * 2;\n    }\n    else if (uVar18 < 0x155) {\n      index3 = (var1 >> 0xf) + 0x77;\n      tempVar2 = index3 * 2;\n    }\n    else if (uVar18 < 0x555) {\n      index3 = (var1 >> 0x12) + 0x7c;\n      tempVar2 = index3 * 2;\n    }\n    else {\n      tempVar2 = 0xfc;\n      index3 = 0x7e;\n    }\n    for (pointer1 = (&Elf32_Rel_ARRAY_20070000[0x8e].r_offset)[tempVar2]; tempVar2 * 4 + 0x20070464U != pointer1\n        ; pointer1 = *(dword *)(pointer1 + 0xc)) {\n      uVar18 = *(uint *)(pointer1 + 4) & 0xfffffffc;\n      index1 = uVar18 - var1;\n      if (0xf < index1) {\n        index3 = index3 + -1;\n        break;\n      }\n      if (-1 < index1) {\n        tempVar2 = uVar18 + pointer1;\n        var1 = *(uint *)(tempVar2 + 4);\n        index1 = *(int *)(pointer1 + 0xc);\n        index3 = *(int *)(pointer1 + 8);\n        *(int *)(index3 + 0xc) = index1;\n        *(int *)(index1 + 8) = index3;\n        *(uint *)(tempVar2 + 4) = var1 | 1;\n        FUNC_00081f98(output);\n        return (int *)(pointer1 + 8);\n      }\n    }\n    uVar18 = index3 + 1;\n  }\n  pointer1 = Elf32_Rel_ARRAY_20070000[141].r_offset;\n  if (Elf32_Rel_ARRAY_20070000[142].r_info != 0x2007046c) {\n    flags = *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4);\n    offset = flags & 0xfffffffc;\n    diff1 = offset - var1;\n    if (0xf < (int)diff1) {\n      pointer1 = var1 + Elf32_Rel_ARRAY_20070000[142].r_info;\n      *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4) = var1 | 1;\n      Elf32_Rel_ARRAY_20070000[142].r_info = pointer1;\n      Elf32_Rel_ARRAY_20070000[143].r_offset = pointer1;\n      *(undefined4 *)(pointer1 + 0xc) = 0x2007046c;\n      *(undefined4 *)(pointer1 + 8) = 0x2007046c;\n      *(uint *)(pointer1 + 4) = diff1 | 1;\n      *(uint *)(pointer1 + diff1) = diff1;\n      FUNC_00081f98(output);\n      return (int *)(tempVar1 + 8);\n    }\n    Elf32_Rel_ARRAY_20070000[143].r_offset = 0x2007046c;\n    Elf32_Rel_ARRAY_20070000[142].r_info = 0x2007046c;\n    if (-1 < (int)diff1) {\n      *(uint *)(offset + tempVar1 + 4) = *(uint *)(offset + tempVar1 + 4) | 1;\n      FUNC_00081f98(output);\n      return (int *)(tempVar1 + 8);\n    }\n    if (offset < 0x200) {\n      offset = flags & 0xfffffff8;\n      index3 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + offset);\n      pointer1 = 1 << ((int)(flags >> 3) >> 2 & 0xffU) | Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(int *)(tempVar1 + 8) = index3;\n      *(uint *)(tempVar1 + 0xc) = offset + 0x20070464;\n      Elf32_Rel_ARRAY_20070000[141].r_offset = pointer1;\n      *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + offset) = tempVar1;\n      *(dword *)(index3 + 0xc) = tempVar1;\n    }\n    else {\n      diff1 = flags >> 9;\n      if (diff1 < 5) {\n        tempVar2 = (flags >> 6) + 0x38;\n        index3 = tempVar2 * 2;\n      }\n      else if (diff1 < 0x15) {\n        tempVar2 = diff1 + 0x5b;\n        index3 = tempVar2 * 2;\n      }\n      else if (diff1 < 0x55) {\n        tempVar2 = (flags >> 0xc) + 0x6e;\n        index3 = tempVar2 * 2;\n      }\n      else if (diff1 < 0x155) {\n        tempVar2 = (flags >> 0xf) + 0x77;\n        index3 = tempVar2 * 2;\n      }\n      else if (diff1 < 0x555) {\n        tempVar2 = (flags >> 0x12) + 0x7c;\n        index3 = tempVar2 * 2;\n      }\n      else {\n        index3 = 0xfc;\n        tempVar2 = 0x7e;\n      }\n      pointer1 = index3 * 4 + 0x20070464;\n      pointer2 = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[index3];\n      if (pointer2 == pointer1) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (tempVar2 >> 2 & 0xffU);\n        pointer3 = pointer2;\n      }\n      else {\n        do {\n          pointer3 = pointer2;\n          if ((*(uint *)(pointer2 + 4) & 0xfffffffc) <= offset) break;\n          pointer2 = *(dword *)(pointer2 + 8);\n          pointer3 = pointer2;\n        } while (pointer1 != pointer2);\n        pointer2 = *(dword *)(pointer3 + 0xc);\n      }\n      pointer1 = Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(dword *)(tempVar1 + 0xc) = pointer2;\n      *(dword *)(tempVar1 + 8) = pointer3;\n      *(dword *)(pointer2 + 8) = tempVar1;\n      *(dword *)(pointer3 + 0xc) = tempVar1;\n    }\n  }\n  tempVar1 = Elf32_Rel_ARRAY_20070000[141].r_info;\n  flags = 1 << ((int)uVar18 >> 2 & 0xffU);\n  if (flags <= pointer1) {\n    if ((pointer1 & flags) == 0) {\n      uVar18 = uVar18 & 0xfffffffc;\n      do {\n        flags = flags << 1;\n        uVar18 = uVar18 + 4;\n      } while ((pointer1 & flags) == 0);\n    }\n    do {\n      ppointer4 = &Elf32_Rel_ARRAY_20070000[uVar18 + 0x8c].r_info;\n      ptr2 = ppointer4;\n      offset = uVar18;\n      do {\n        for (ptr1 = (undefined *)ptr2[3]; ptr2 != (dword *)ptr1;\n            ptr1 = *(undefined **)(ptr1 + 0xc)) {\n          diff1 = *(uint *)(ptr1 + 4) & 0xfffffffc;\n          flags2 = diff1 - var1;\n          if (0xf < (int)flags2) {\n            tempVar2 = *(int *)(ptr1 + 8);\n            index3 = *(int *)(ptr1 + 0xc);\n            ptr3 = ptr1 + var1;\n            *(uint *)(ptr1 + 4) = var1 | 1;\n            *(int *)(tempVar2 + 0xc) = index3;\n            *(int *)(index3 + 8) = tempVar2;\n            Elf32_Rel_ARRAY_20070000[142].r_info = (dword)ptr3;\n            Elf32_Rel_ARRAY_20070000[143].r_offset = (dword)ptr3;\n            *(undefined4 *)(ptr3 + 0xc) = 0x2007046c;\n            *(undefined4 *)(ptr3 + 8) = 0x2007046c;\n            *(uint *)(ptr3 + 4) = flags2 | 1;\n            *(uint *)(ptr3 + flags2) = flags2;\n            FUNC_00081f98(output);\n            return (int *)(ptr1 + 8);\n          }\n          if (-1 < (int)flags2) {\n            index3 = *(int *)(ptr1 + 8);\n            tempVar2 = *(int *)(ptr1 + 0xc);\n            *(uint *)(ptr1 + diff1 + 4) = *(uint *)(ptr1 + diff1 + 4) | 1;\n            *(int *)(index3 + 0xc) = tempVar2;\n            *(int *)(tempVar2 + 8) = index3;\n            FUNC_00081f98(output);\n            return (int *)(ptr1 + 8);\n          }\n        }\n        offset = offset + 1;\n        ptr2 = ptr2 + 2;\n      } while ((offset & 3) != 0);\n      do {\n        diff1 = uVar18 & 3;\n        ptr1 = (undefined *)(ppointer4 + -2);\n        uVar18 = uVar18 - 1;\n        if (diff1 == 0) {\n          Elf32_Rel_ARRAY_20070000[141].r_offset = Elf32_Rel_ARRAY_20070000[141].r_offset & ~flags;\n          break;\n        }\n        ppointer4 = (dword *)*ppointer4;\n      } while (ppointer4 == (dword *)ptr1);\n      flags = flags * 2;\n      if ((Elf32_Rel_ARRAY_20070000[141].r_offset <= flags &&\n           flags - Elf32_Rel_ARRAY_20070000[141].r_offset != 0) || (uVar18 = offset, flags == 0))\n      break;\n      for (; (Elf32_Rel_ARRAY_20070000[141].r_offset & flags) == 0; flags = flags << 1) {\n        uVar18 = uVar18 + 4;\n      }\n    } while( true );\n  }\n  uVar18 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  if ((var1 <= uVar18) &&\n     (flags = uVar18 - var1, pointer1 = Elf32_Rel_ARRAY_20070000[141].r_info, 0xf < (int)flags))\n  goto LAB_00081b1a;\n  flags = Elf32_Rel_ARRAY_20070000[141].r_info + uVar18;\n  if (Elf32_Rel_ARRAY_20070000[270].r_offset == 0xffffffff) {\n    offset = var1 + DAT_20071218 + 0x10;\n  }\n  else {\n    offset = var1 + DAT_20071218 + 0x100f & 0xfffff000;\n  }\n  pointer1 = FUN_0008236c(output,offset);\n  if ((pointer1 == 0xffffffff) || ((pointer1 < flags && (tempVar1 != 0x20070464)))) {\n    uVar18 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    pointer1 = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\n  else {\n    diff1 = DAT_2007121c + offset;\n    DAT_2007121c = diff1;\n    if ((flags == pointer1) && ((flags & 0xfff) == 0)) {\n      *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = offset + uVar18 | 1;\n    }\n    else {\n      pointer2 = pointer1;\n      if (Elf32_Rel_ARRAY_20070000[270].r_offset != 0xffffffff) {\n        pointer2 = Elf32_Rel_ARRAY_20070000[270].r_offset;\n        DAT_2007121c = diff1 + (pointer1 - flags);\n      }\n      Elf32_Rel_ARRAY_20070000[270].r_offset = pointer2;\n      flags = pointer1 & 7;\n      if (flags == 0) {\n        index3 = 0x1000;\n      }\n      else {\n        pointer1 = pointer1 + (8 - flags);\n        index3 = 0x1008 - flags;\n      }\n      index3 = index3 - (offset + pointer1 & 0xfff);\n      tempVar2 = FUN_0008236c(output,index3);\n      if (tempVar2 == -1) {\n        flags = 1;\n        index3 = 0;\n      }\n      else {\n        flags = (tempVar2 - pointer1) + index3 | 1;\n      }\n      diff1 = DAT_2007121c + index3;\n      Elf32_Rel_ARRAY_20070000[141].r_info = pointer1;\n      DAT_2007121c = diff1;\n      *(uint *)(pointer1 + 4) = flags;\n      if (tempVar1 != 0x20070464) {\n        if (uVar18 < 0x10) {\n          *(undefined4 *)(pointer1 + 4) = 1;\n          uVar18 = 0;\n          goto LAB_00081b04;\n        }\n        uVar18 = uVar18 - 0xc & 0xfffffff8;\n        *(uint *)(tempVar1 + 4) = uVar18 | *(uint *)(tempVar1 + 4) & 1;\n        *(undefined4 *)(tempVar1 + uVar18 + 4) = 5;\n        *(undefined4 *)(tempVar1 + uVar18 + 8) = 5;\n        if (0xf < uVar18) {\n          FUN_00083b10(output,tempVar1 + 8);\n          diff1 = DAT_2007121c;\n        }\n      }\n    }\n    if (DAT_20071214 < diff1) {\n      DAT_20071214 = diff1;\n    }\n    if (DAT_20071210 < diff1) {\n      DAT_20071210 = diff1;\n    }\n    uVar18 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    pointer1 = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\nLAB_00081b04:\n  flags = uVar18 - var1;\n  if ((uVar18 < var1) || ((int)flags < 0x10)) {\n    FUNC_00081f98(output);\n    return (int *)0x0;\n  }\nLAB_00081b1a:\n  Elf32_Rel_ARRAY_20070000[141].r_info = var1 + pointer1;\n  *(uint *)(pointer1 + 4) = var1 | 1;\n  *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = flags | 1;\n  FUNC_00081f98(output);\n  return (int *)(pointer1 + 8);\n}\n\n",
            "renaming": {
                "FUN_00081810": "process_data_00081810",
                "param_1": "output",
                "param_2": "size",
                "dVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "flags",
                "uVar4": "offset",
                "iVar5": "index1",
                "uVar6": "diff1",
                "dVar7": "pointer1",
                "uVar8": "flags2",
                "iVar9": "index2",
                "puVar10": "ptr1",
                "dVar11": "pointer2",
                "dVar12": "pointer3",
                "iVar13": "index3",
                "pdVar14": "ptr2",
                "uVar15": "var1",
                "puVar16": "ptr3",
                "dVar17": "pointer4"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00084018",
                "FUN_00083ca8",
                "FUN_000817f0"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_0008236c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d48": {
            "entrypoint": "0x00081d48",
            "current_name": "copy_memory_00081d48",
            "code": "\nundefined4 * copyMemory_00081d48(undefined4 *destination,undefined4 *source,uint length)\n\n{\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  undefined4 *destEnd;\n  uint remaining;\n  uint repeated;\n  bool bVar6;\n  \n  srcPtr = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (length < 8) {\n      repeated = length - 4;\n      if (3 < length) {\n        do {\n          destPtr = source;\n          destEnd = srcPtr;\n          bVar6 = repeated != 0;\n          repeated = repeated - 1;\n          *(undefined *)destEnd = *(undefined *)destPtr;\n          srcPtr = (undefined4 *)((int)destEnd + 1);\n          source = (undefined4 *)((int)destPtr + 1);\n        } while (bVar6);\n        *(undefined *)(undefined4 *)((int)destEnd + 1) =\n             *(undefined *)(undefined4 *)((int)destPtr + 1);\n        *(undefined *)((int)destEnd + 2) = *(undefined *)((int)destPtr + 2);\n        *(undefined *)((int)destEnd + 3) = *(undefined *)((int)destPtr + 3);\n        return destination;\n      }\n      goto LAB_00081dcc;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      repeated = 4 - ((uint)destination & 3);\n      length = length - repeated;\n      destPtr = destination;\n      destEnd = source;\n      if (((uint)destination & 1) != 0) {\n        destEnd = (undefined4 *)((int)source + 1);\n        destPtr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      srcPtr = destPtr;\n      source = destEnd;\n      if ((repeated & 2) != 0) {\n        source = (undefined4 *)((int)destEnd + 2);\n        srcPtr = (undefined4 *)((int)destPtr + 2);\n        *(undefined2 *)destPtr = *(undefined2 *)destEnd;\n      }\n    }\n  }\n  while (0x3f < length) {\n    *srcPtr = *source;\n    srcPtr[1] = source[1];\n    srcPtr[2] = source[2];\n    srcPtr[3] = source[3];\n    srcPtr[4] = source[4];\n    srcPtr[5] = source[5];\n    srcPtr[6] = source[6];\n    srcPtr[7] = source[7];\n    srcPtr[8] = source[8];\n    srcPtr[9] = source[9];\n    srcPtr[10] = source[10];\n    srcPtr[0xb] = source[0xb];\n    srcPtr[0xc] = source[0xc];\n    srcPtr[0xd] = source[0xd];\n    srcPtr[0xe] = source[0xe];\n    srcPtr[0xf] = source[0xf];\n    srcPtr = srcPtr + 0x10;\n    source = source + 0x10;\n    length = length - 0x40;\n  }\n  remaining = length - 0x10;\n  if (0xffffffcf < length - 0x40) {\n    do {\n      *srcPtr = *source;\n      srcPtr[1] = source[1];\n      srcPtr[2] = source[2];\n      srcPtr[3] = source[3];\n      srcPtr = srcPtr + 4;\n      source = source + 4;\n      bVar6 = 0xf < remaining;\n      remaining = remaining - 0x10;\n    } while (bVar6);\n  }\n  repeated = remaining + 0xc;\n  destEnd = srcPtr;\n  destPtr = source;\n  if (0xfffffff3 < remaining) {\n    do {\n      source = destPtr + 1;\n      *destEnd = *destPtr;\n      bVar6 = 3 < repeated;\n      repeated = repeated - 4;\n      srcPtr = destEnd + 1;\n      destEnd = destEnd + 1;\n      destPtr = source;\n    } while (bVar6);\n  }\nLAB_00081dcc:\n  if (repeated + 4 != 0) {\n    destPtr = srcPtr;\n    destEnd = source;\n    if ((repeated & 1) != 0) {\n      destEnd = (undefined4 *)((int)source + 1);\n      destPtr = (undefined4 *)((int)srcPtr + 1);\n      *(undefined *)srcPtr = *(undefined *)source;\n    }\n    if ((repeated + 4 & 2) != 0) {\n      *(undefined2 *)destPtr = *(undefined2 *)destEnd;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00081d48": "copy_memory_00081d48",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "puVar1": "destPtr",
                "puVar2": "srcPtr",
                "puVar3": "destEnd",
                "uVar4": "remaining",
                "uVar5": "repeated"
            },
            "calling": [
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e34": {
            "entrypoint": "0x00081e34",
            "current_name": "copy_memory_00081e34",
            "code": "\nvoid copyMemory_00081e34(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  int index;\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  undefined4 *tmpPtr;\n  uint remainSize;\n  undefined *tmpChar;\n  uint remainder;\n  \n  if ((src < dest) && (tmpPtr = (undefined4 *)((int)src + size), dest < tmpPtr)) {\n    tmpChar = (undefined *)((int)dest + size);\n    index = size - 1;\n    if (size != 0) {\n      do {\n        tmpPtr = (undefined4 *)((int)tmpPtr + -1);\n        index = index + -1;\n        tmpChar = tmpChar + -1;\n        *tmpChar = *(undefined *)tmpPtr;\n      } while (index != -1);\n    }\n    return;\n  }\n  if (size < 0x10) {\n    if (size == 0) {\n      return;\n    }\n  }\n  else if ((((uint)dest | (uint)src) & 3) == 0) {\n    tmpPtr = dest;\n    srcPtr = src;\n    do {\n      destPtr = tmpPtr + 4;\n      *tmpPtr = *srcPtr;\n      tmpPtr[1] = srcPtr[1];\n      tmpPtr[2] = srcPtr[2];\n      tmpPtr[3] = srcPtr[3];\n      tmpPtr = destPtr;\n      srcPtr = srcPtr + 4;\n    } while (destPtr != (undefined4 *)((int)dest + (size - 0x10 & 0xfffffff0) + 0x10));\n    index = (size - 0x10 >> 4) + 1;\n    remainder = size & 0xf;\n    src = src + index * 4;\n    dest = dest + index * 4;\n    remainSize = remainder;\n    tmpPtr = dest;\n    srcPtr = src;\n    if (3 < remainder) {\n      do {\n        remainSize = remainSize - 4;\n        *tmpPtr = *srcPtr;\n        tmpPtr = tmpPtr + 1;\n        srcPtr = srcPtr + 1;\n      } while (3 < remainSize);\n      index = (remainder - 4 & 0xfffffffc) + 4;\n      dest = (undefined4 *)((int)dest + index);\n      src = (undefined4 *)((int)src + index);\n      remainder = size & 3;\n    }\n    size = remainder;\n    if (size == 0) {\n      return;\n    }\n  }\n  tmpPtr = dest;\n  do {\n    srcPtr = (undefined4 *)((int)tmpPtr + 1);\n    *(undefined *)tmpPtr = *(undefined *)src;\n    src = (undefined4 *)((int)src + 1);\n    tmpPtr = srcPtr;\n  } while (srcPtr != (undefined4 *)(size + (int)dest));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081e34": "copy_memory_00081e34",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "iVar1": "index",
                "puVar2": "destPtr",
                "puVar3": "srcPtr",
                "puVar4": "tmpPtr",
                "uVar5": "remainSize",
                "puVar6": "tmpChar",
                "uVar7": "remainder"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f00": {
            "entrypoint": "0x00081f00",
            "current_name": "fill_buffer_with_data_00081f00",
            "code": "\nvoid fillBufferWithData_00081f00(undefined4 *buffer,undefined data,uint size)\n\n{\n  undefined4 *current;\n  undefined4 *next;\n  undefined4 dataPattern;\n  uint remainingSize;\n  bool isZero;\n  \n  if (((uint)buffer & 3) != 0) {\n    isZero = size == 0;\n    current = buffer;\n    size = size - 1;\n    if (isZero) {\n      return;\n    }\n    while( true ) {\n      buffer = (undefined4 *)((int)current + 1);\n      *(undefined *)current = data;\n      if (((uint)buffer & 3) == 0) break;\n      isZero = size == 0;\n      current = buffer;\n      size = size - 1;\n      if (isZero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    dataPattern = CONCAT22(CONCAT11(data,data),CONCAT11(data,data));\n    remainingSize = size;\n    current = buffer;\n    if (0xf < size) {\n      remainingSize = size - 0x10;\n      do {\n        *current = dataPattern;\n        current[1] = dataPattern;\n        current[2] = dataPattern;\n        current[3] = dataPattern;\n        current = current + 4;\n      } while (current != (undefined4 *)((int)buffer + (remainingSize & 0xfffffff0) + 0x10));\n      size = size & 0xf;\n      buffer = buffer + ((remainingSize >> 4) + 1) * 4;\n      remainingSize = size;\n      current = buffer;\n      if (size < 4) goto LAB_00081f7c;\n    }\n    do {\n      size = size - 4;\n      *buffer = dataPattern;\n      buffer = buffer + 1;\n    } while (3 < size);\n    buffer = (undefined4 *)((int)current + (remainingSize - 4 & 0xfffffffc) + 4);\n    size = remainingSize & 3;\n  }\nLAB_00081f7c:\n  if (size != 0) {\n    current = buffer;\n    do {\n      next = (undefined4 *)((int)current + 1);\n      *(undefined *)current = data;\n      current = next;\n    } while (next != (undefined4 *)(size + (int)buffer));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f00": "fill_buffer_with_data_00081f00",
                "param_1": "buffer",
                "param_2": "data",
                "param_3": "size",
                "puVar1": "current",
                "puVar2": "next",
                "uVar3": "dataPattern",
                "uVar4": "remainingSize",
                "bVar5": "isZero"
            },
            "calling": [
                "FUN_000811b0",
                "FUN_00083888"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f94": {
            "entrypoint": "0x00081f94",
            "current_name": "FUNC_00081f94",
            "code": "\nvoid FUNC_00081f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f94": "FUNC_00081f94"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00083b10",
                "FUN_00081810",
                "FUN_00083a74"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f98": {
            "entrypoint": "0x00081f98",
            "current_name": "FUNC_00081f98",
            "code": "\nvoid FUNC_00081f98(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f98": "FUNC_00081f98"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00081810",
                "FUN_00083b10",
                "FUN_00083a74"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f9c": {
            "entrypoint": "0x00081f9c",
            "current_name": "apply_relocation_00081f9c",
            "code": "\nvoid applyRelocation_00081f9c(undefined4 offset,undefined4 param1)\n\n{\n  FUN_00081fac(relocationEntries[140].relOffset,offset,param1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f9c": "apply_relocation_00081f9c",
                "param_1": "offset",
                "param_2": "param1",
                "Elf32_Rel_ARRAY_20070000": "relocationEntries",
                "r_offset": "relOffset"
            },
            "calling": [
                "FUN_00081496"
            ],
            "called": [
                "FUN_00081fac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081fac": {
            "entrypoint": "0x00081fac",
            "current_name": "allocate_memory_00081fac",
            "code": "\nint * allocateMemory_00081fac(undefined4 *outputPointer,int *inputPointer,uint inputSize)\n\n{\n  dword temp;\n  int *resultPointer;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  int *tempPointer;\n  uint temp6;\n  uint temp7;\n  int *tempPointer2;\n  \n  if (inputPointer == (int *)0x0) {\n    resultPointer = (int *)FUN_00081810(outputPointer,inputSize);\n    return resultPointer;\n  }\n  FUNC_00081f94();\n  temp4 = inputPointer[-1];\n  temp6 = temp4 & 0xfffffffc;\n  resultPointer = inputPointer + -2;\n  if (inputSize + 0xb < 0x17) {\n    temp7 = 0x10;\n  }\n  else {\n    temp7 = inputSize + 0xb & 0xfffffff8;\n    if ((int)temp7 < 0) goto LAB_00082078;\n  }\n  if (temp7 < inputSize) {\nLAB_00082078:\n    *outputPointer = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)temp6 < (int)temp7) {\n    temp = (int)resultPointer + temp6;\n    if (Elf32_Rel_ARRAY_20070000[141].r_info == temp) {\n      temp2 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n      temp = Elf32_Rel_ARRAY_20070000[141].r_info;\n      if ((int)(temp7 + 0x10) <= (int)(temp2 + temp6)) {\n        Elf32_Rel_ARRAY_20070000[141].r_info = (int)resultPointer + temp7;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (temp2 + temp6) - temp7 | 1;\n        inputPointer[-1] = temp7 | inputPointer[-1] & 1U;\n        FUNC_00081f98(outputPointer);\n        return inputPointer;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(temp + 4) & 0xfffffffe) + temp + 4) & 1) == 0) {\n      temp2 = *(uint *)(temp + 4) & 0xfffffffc;\n      if ((int)temp7 <= (int)(temp2 + temp6)) {\n        temp5 = *(int *)(temp + 0xc);\n        temp3 = *(int *)(temp + 8);\n        *(int *)(temp3 + 0xc) = temp5;\n        *(int *)(temp5 + 8) = temp3;\n        temp6 = temp2 + temp6;\n        goto LAB_00082088;\n      }\n    }\n    else {\n      temp2 = 0;\n      temp = 0;\n    }\n    if (-1 < (int)(temp4 << 0x1f)) {\n      tempPointer2 = (int *)((int)resultPointer - inputPointer[-2]);\n      temp4 = (tempPointer2[1] & 0xfffffffcU) + temp6;\n      if (temp != 0) {\n        if (temp == Elf32_Rel_ARRAY_20070000[141].r_info) {\n          if ((int)(temp7 + 0x10) <= (int)(temp2 + temp4)) {\n            resultPointer = tempPointer2 + 2;\n            temp3 = *resultPointer;\n            temp5 = tempPointer2[3];\n            temp6 = temp6 - 4;\n            *(int *)(temp3 + 0xc) = temp5;\n            *(int *)(temp5 + 8) = temp3;\n            if (temp6 < 0x25) {\n              tempPointer = resultPointer;\n              if (0x13 < temp6) {\n                tempPointer2[2] = *inputPointer;\n                tempPointer2[3] = inputPointer[1];\n                if (temp6 < 0x1c) {\n                  inputPointer = inputPointer + 2;\n                  tempPointer = tempPointer2 + 4;\n                }\n                else {\n                  tempPointer2[4] = inputPointer[2];\n                  tempPointer2[5] = inputPointer[3];\n                  if (temp6 == 0x24) {\n                    tempPointer2[6] = inputPointer[4];\n                    tempPointer = inputPointer + 5;\n                    inputPointer = inputPointer + 6;\n                    tempPointer2[7] = *tempPointer;\n                    tempPointer = tempPointer2 + 8;\n                  }\n                  else {\n                    inputPointer = inputPointer + 4;\n                    tempPointer = tempPointer2 + 6;\n                  }\n                }\n              }\n              *tempPointer = *inputPointer;\n              tempPointer[1] = inputPointer[1];\n              tempPointer[2] = inputPointer[2];\n            }\n            else {\n              FUN_00081e34(resultPointer,inputPointer);\n            }\n            Elf32_Rel_ARRAY_20070000[141].r_info = (int)tempPointer2 + temp7;\n            *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (temp2 + temp4) - temp7 | 1;\n            tempPointer2[1] = temp7 | tempPointer2[1] & 1U;\n            FUNC_00081f98(outputPointer);\n            return resultPointer;\n          }\n        }\n        else {\n          temp2 = temp2 + temp4;\n          if ((int)temp7 <= (int)temp2) {\n            temp5 = *(int *)(temp + 0xc);\n            temp3 = *(int *)(temp + 8);\n            *(int *)(temp3 + 0xc) = temp5;\n            *(int *)(temp5 + 8) = temp3;\n            tempPointer = tempPointer2 + 2;\n            temp3 = *tempPointer;\n            temp5 = tempPointer2[3];\n            temp4 = temp6 - 4;\n            *(int *)(temp3 + 0xc) = temp5;\n            *(int *)(temp5 + 8) = temp3;\n            temp6 = temp2;\n            if (temp4 < 0x25) {\n              resultPointer = tempPointer;\n              if (0x13 < temp4) {\n                tempPointer2[2] = *inputPointer;\n                tempPointer2[3] = inputPointer[1];\n                if (temp4 < 0x1c) {\n                  inputPointer = inputPointer + 2;\n                  resultPointer = tempPointer2 + 4;\n                }\n                else {\n                  tempPointer2[4] = inputPointer[2];\n                  tempPointer2[5] = inputPointer[3];\n                  if (temp4 == 0x24) {\n                    tempPointer2[6] = inputPointer[4];\n                    resultPointer = inputPointer + 5;\n                    inputPointer = inputPointer + 6;\n                    tempPointer2[7] = *resultPointer;\n                    resultPointer = tempPointer2 + 8;\n                  }\n                  else {\n                    inputPointer = inputPointer + 4;\n                    resultPointer = tempPointer2 + 6;\n                  }\n                }\n              }\n              *resultPointer = *inputPointer;\n              resultPointer[1] = inputPointer[1];\n              resultPointer[2] = inputPointer[2];\n              temp4 = tempPointer2[1];\n              resultPointer = tempPointer2;\n              inputPointer = tempPointer;\n            }\n            else {\n              FUN_00081e34(tempPointer,inputPointer);\n              temp4 = tempPointer2[1];\n              resultPointer = tempPointer2;\n              inputPointer = tempPointer;\n            }\n            goto LAB_00082088;\n          }\n        }\n      }\n      if ((int)temp7 <= (int)temp4) {\n        tempPointer = tempPointer2 + 2;\n        temp3 = *tempPointer;\n        temp5 = tempPointer2[3];\n        temp2 = temp6 - 4;\n        *(int *)(temp3 + 0xc) = temp5;\n        *(int *)(temp5 + 8) = temp3;\n        temp6 = temp4;\n        if (temp2 < 0x25) {\n          resultPointer = tempPointer;\n          if (0x13 < temp2) {\n            tempPointer2[2] = *inputPointer;\n            tempPointer2[3] = inputPointer[1];\n            if (temp2 < 0x1c) {\n              inputPointer = inputPointer + 2;\n              resultPointer = tempPointer2 + 4;\n            }\n            else {\n              tempPointer2[4] = inputPointer[2];\n              tempPointer2[5] = inputPointer[3];\n              if (temp2 == 0x24) {\n                tempPointer2[6] = inputPointer[4];\n                resultPointer = inputPointer + 5;\n                inputPointer = inputPointer + 6;\n                tempPointer2[7] = *resultPointer;\n                resultPointer = tempPointer2 + 8;\n              }\n              else {\n                inputPointer = inputPointer + 4;\n                resultPointer = tempPointer2 + 6;\n              }\n            }\n          }\n          *resultPointer = *inputPointer;\n          resultPointer[1] = inputPointer[1];\n          resultPointer[2] = inputPointer[2];\n          temp4 = tempPointer2[1];\n          resultPointer = tempPointer2;\n          inputPointer = tempPointer;\n        }\n        else {\n          FUN_00081e34(tempPointer,inputPointer);\n          temp4 = tempPointer2[1];\n          resultPointer = tempPointer2;\n          inputPointer = tempPointer;\n        }\n        goto LAB_00082088;\n      }\n    }\n    tempPointer2 = (int *)FUN_00081810(outputPointer,inputSize);\n    if (tempPointer2 == (int *)0x0) goto LAB_000820a0;\n    temp4 = inputPointer[-1];\n    if (tempPointer2 + -2 != (int *)((temp4 & 0xfffffffe) + (int)resultPointer)) {\n      temp6 = temp6 - 4;\n      if (temp6 < 0x25) {\n        resultPointer = inputPointer;\n        tempPointer = tempPointer2;\n        if (0x13 < temp6) {\n          *tempPointer2 = *inputPointer;\n          tempPointer2[1] = inputPointer[1];\n          if (temp6 < 0x1c) {\n            resultPointer = inputPointer + 2;\n            tempPointer = tempPointer2 + 2;\n          }\n          else {\n            tempPointer2[2] = inputPointer[2];\n            tempPointer2[3] = inputPointer[3];\n            if (temp6 == 0x24) {\n              tempPointer2[4] = inputPointer[4];\n              tempPointer2[5] = inputPointer[5];\n              resultPointer = inputPointer + 6;\n              tempPointer = tempPointer2 + 6;\n            }\n            else {\n              resultPointer = inputPointer + 4;\n              tempPointer = tempPointer2 + 4;\n            }\n          }\n        }\n        *tempPointer = *resultPointer;\n        tempPointer[1] = resultPointer[1];\n        tempPointer[2] = resultPointer[2];\n      }\n      else {\n        FUN_00081e34(tempPointer2,inputPointer);\n      }\n      FUN_00083b10(outputPointer,inputPointer);\n      goto LAB_000820a0;\n    }\n    temp6 = temp6 + (tempPointer2[-1] & 0xfffffffcU);\n  }\nLAB_00082088:\n  temp2 = temp6 - temp7;\n  tempPointer2 = inputPointer;\n  if (temp2 < 0x10) {\n    resultPointer[1] = temp4 & 1 | temp6;\n    *(uint *)((int)resultPointer + temp6 + 4) = *(uint *)((int)resultPointer + temp6 + 4) | 1;\n  }\n  else {\n    resultPointer[1] = temp4 & 1 | temp7;\n    *(uint *)((int)resultPointer + temp7 + 4) = temp2 | 1;\n    *(uint *)((int)resultPointer + temp2 + temp7 + 4) = *(uint *)((int)resultPointer + temp2 + temp7 + 4) | 1;\n    FUN_00083b10(outputPointer,(int)resultPointer + temp7 + 8);\n  }\nLAB_000820a0:\n  FUNC_00081f98(outputPointer);\n  return tempPointer2;\n}\n\n",
            "renaming": {
                "FUN_00081fac": "allocate_memory_00081fac",
                "param_1": "outputPointer",
                "param_2": "inputPointer",
                "param_3": "inputSize",
                "dVar1": "temp",
                "piVar2": "resultPointer",
                "uVar3": "temp2",
                "iVar4": "temp3",
                "uVar5": "temp4",
                "iVar6": "temp5",
                "piVar7": "tempPointer",
                "uVar8": "temp6",
                "uVar9": "temp7",
                "piVar10": "tempPointer2"
            },
            "calling": [
                "FUN_00081f9c",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00081810",
                "FUN_00083b10",
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_00081e34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008236c": {
            "entrypoint": "0x0008236c",
            "current_name": "check_error_and_update_param_0008236c",
            "code": "\nvoid checkErrorAndUpdateParam_0008236c(int *result,undefined4 inputValue)\n\n{\n  int error;\n  \n  DAT_20071244 = 0;\n  error = FUN_00080e88(inputValue);\n  if ((error == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008236c": "check_error_and_update_param_0008236c",
                "param_1": "result",
                "param_2": "inputValue",
                "iVar1": "error"
            },
            "calling": [
                "FUN_00081810",
                "FUN_00083a74"
            ],
            "called": [
                "FUN_00080e88"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082390": {
            "entrypoint": "0x00082390",
            "current_name": "compare_uint_arrays_00082390",
            "code": "\nint compareUintArrays_00082390(uint *array1,uint *array2)\n\n{\n  uint *ptr1;\n  int result;\n  uint *ptr2;\n  uint *ptr3;\n  uint var1;\n  uint var2;\n  uint var3;\n  uint var4;\n  uint var5;\n  \n  if ((((uint)array1 | (uint)array2) & 7) != 0) {\n    ptr1 = array1;\n    if (((uint)array1 & 3) != 0) {\n      ptr1 = (uint *)((uint)array1 & 0xfffffffc) + 1;\n      var1 = *(uint *)((uint)array1 & 0xfffffffc);\n      ptr2 = array2;\n      if (((uint)array1 & 1) == 0) {\nLAB_00082410:\n        ptr3 = (uint *)((int)ptr2 + 1);\n        var2 = var1 >> 0x10 & 0xff;\n        result = var2 - *(byte *)ptr2;\n        if (result != 0) {\n          return result;\n        }\n        if (var2 == 0) {\n          return 0;\n        }\n      }\n      else {\n        ptr3 = array2;\n        if (((uint)array1 & 2) == 0) {\n          ptr2 = (uint *)((int)array2 + 1);\n          var2 = var1 >> 8 & 0xff;\n          result = var2 - *(byte *)array2;\n          if (result != 0) {\n            return result;\n          }\n          if (var2 == 0) {\n            return 0;\n          }\n          goto LAB_00082410;\n        }\n      }\n      array2 = (uint *)((int)ptr3 + 1);\n      result = (var1 >> 0x18) - (uint)*(byte *)ptr3;\n      if ((result != 0) || (var1 >> 0x18 == 0)) {\n        return result;\n      }\n    }\n    var1 = (uint)array2 & 3;\n    if (var1 != 0) {\n      array2 = (uint *)((uint)array2 & 0xfffffffc);\n      if (var1 == 2) {\n        var1 = *array2;\n        do {\n          array2 = array2 + 1;\n          var3 = *ptr1;\n          var1 = var1 >> 0x10;\n          var4 = var3 + 0xfefefeff & ~var3;\n          var5 = var4 & 0x80808080;\n          var2 = var3 & 0xffff;\n          if ((var4 & 0x8080) != 0 || var2 != var1) goto LAB_0008258e;\n          var1 = *array2;\n          var2 = var2 ^ var3;\n          var3 = var1 * 0x10000;\n          ptr1 = ptr1 + 1;\n        } while (var5 == 0 && var2 == var3);\n      }\n      else if (var1 < 2) {\n        var1 = *array2;\n        do {\n          array2 = array2 + 1;\n          var3 = *ptr1;\n          var1 = var1 >> 8;\n          var4 = var3 + 0xfefefeff & ~var3;\n          var5 = var4 & 0x80808080;\n          var2 = var3 & 0xffffff;\n          if ((var4 & 0x808080) != 0 || var2 != var1) goto LAB_0008258e;\n          var1 = *array2;\n          var2 = var2 ^ var3;\n          var3 = var1 * 0x1000000;\n          ptr1 = ptr1 + 1;\n        } while (var5 == 0 && var2 == var3);\n      }\n      else {\n        var1 = *array2;\n        do {\n          array2 = array2 + 1;\n          var3 = *ptr1;\n          var1 = var1 >> 0x18;\n          var4 = var3 + 0xfefefeff & ~var3;\n          var5 = var4 & 0x80808080;\n          var2 = var3 & 0xff;\n          if ((var4 & 0x80) != 0 || var2 != var1) goto LAB_0008258e;\n          var1 = *array2;\n          var2 = var2 ^ var3;\n          var3 = var1 * 0x100;\n          ptr1 = ptr1 + 1;\n        } while (var5 == 0 && var2 == var3);\n      }\n      var2 = var2 << 0x18 | (var2 >> 8 & 0xff) << 0x10 | (var2 >> 0x10 & 0xff) << 8 |\n              var2 >> 0x18;\n      var1 = (var3 >> 8 & 0xff) << 0x10 | (var3 >> 0x10 & 0xff) << 8 | var3 >> 0x18;\n      goto LAB_0008259e;\n    }\n    array1 = ptr1;\n    ptr2 = array2;\n    if (((uint)ptr1 & 4) != 0) {\n      array1 = ptr1 + 1;\n      var1 = *ptr1;\n      ptr2 = array2 + 1;\n      var3 = *array2;\n      var5 = var1 + 0xfefefeff & ~var1 & 0x80808080;\n      if (var1 != var3 || var5 != 0) {\nLAB_0008259a:\n        var2 = var1 << 0x18 | (var1 >> 8 & 0xff) << 0x10 | (var1 >> 0x10 & 0xff) << 8 |\n                var1 >> 0x18;\n        var1 = var3 << 0x18 | (var3 >> 8 & 0xff) << 0x10 | (var3 >> 0x10 & 0xff) << 8 |\n                var3 >> 0x18;\n        goto LAB_0008259e;\n      }\n    }\n    array2 = ptr2;\n    if (((uint)ptr2 & 4) != 0) {\n      var1 = *ptr2;\n      ptr1 = ptr2 + 1;\n      do {\n        var2 = *array1;\n        var3 = array1[1];\n        var5 = var2 + 0xfefefeff & ~var2 & 0x80808080;\n        if (var2 != var1 || var5 != 0) goto LAB_0008258e;\n        var4 = *ptr1;\n        var1 = ptr1[1];\n        var5 = var3 + 0xfefefeff & ~var3 & 0x80808080;\n        array1 = array1 + 2;\n        ptr1 = ptr1 + 2;\n      } while (var3 == var4 && var5 == 0);\n      var2 = var3 << 0x18 | (var3 >> 8 & 0xff) << 0x10 | (var3 >> 0x10 & 0xff) << 8 |\n              var3 >> 0x18;\n      var1 = var4 << 0x18 | (var4 >> 8 & 0xff) << 0x10 | (var4 >> 0x10 & 0xff) << 8 |\n              var4 >> 0x18;\n      goto LAB_0008259e;\n    }\n  }\n  do {\n    var1 = *array1;\n    var2 = array1[1];\n    var3 = *array2;\n    var4 = array2[1];\n    var5 = var1 + 0xfefefeff & ~var1 & 0x80808080;\n    if (var1 != var3 || var5 != 0) goto LAB_0008259a;\n    var5 = var2 + 0xfefefeff & ~var2 & 0x80808080;\n    array1 = array1 + 2;\n    array2 = array2 + 2;\n  } while (var2 == var4 && var5 == 0);\n  var2 = var2 << 0x18 | (var2 >> 8 & 0xff) << 0x10 | (var2 >> 0x10 & 0xff) << 8 | var2 >> 0x18;\n  var1 = var4 << 0x18 | (var4 >> 8 & 0xff) << 0x10 | (var4 >> 0x10 & 0xff) << 8 | var4 >> 0x18;\nLAB_0008259e:\n  var3 = var5 << 0x18 | (var5 >> 8 & 0xff) << 0x10 | (var5 >> 0x10 & 0xff) << 8 | var5 >> 0x18;\n  if (var3 != 0) {\n    var3 = 0x18 - LZCOUNT(var3);\n    var2 = var2 >> (var3 & 0xff);\n    var1 = var1 >> (var3 & 0xff);\n  }\n  result = 1;\n  if (var2 <= var1) {\n    result = -(uint)(var2 < var1);\n  }\n  return result;\nLAB_0008258e:\n  var2 = var2 << 0x18 | (var2 >> 8 & 0xff) << 0x10 | (var2 >> 0x10 & 0xff) << 8 | var2 >> 0x18;\n  var1 = var1 << 0x18 | (var1 >> 8 & 0xff) << 0x10 | (var1 >> 0x10 & 0xff) << 8 | var1 >> 0x18;\n  goto LAB_0008259e;\n}\n\n",
            "renaming": {
                "FUN_00082390": "compare_uint_arrays_00082390",
                "param_1": "array1",
                "param_2": "array2",
                "puVar1": "ptr1",
                "iVar2": "result",
                "puVar3": "ptr2",
                "puVar4": "ptr3",
                "uVar5": "var1",
                "uVar6": "var2",
                "uVar7": "var3",
                "uVar8": "var4",
                "uVar9": "var5"
            },
            "calling": [
                "FUN_000815b8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825cc": {
            "entrypoint": "0x000825cc",
            "current_name": "copy_string_000825cc",
            "code": "\nvoid copy_string_000825cc(uint *destination,uint *source)\n\n{\n  char current_char;\n  ushort current_short;\n  uint *next_source;\n  uint *next_destination;\n  uint current_uint;\n  uint current_byte;\n  uint *next_destination;\n  bool byte_check;\n  \n  if ((((uint)destination ^ (uint)source) & 3) != 0) {\n    do {\n      current_char = *(char *)source;\n      *(char *)destination = current_char;\n      source = (uint *)((int)source + 1);\n      destination = (uint *)((int)destination + 1);\n    } while (current_char != '\\0');\n    return;\n  }\n  if (((uint)source & 3) != 0) {\n    next_destination = source;\n    if (((uint)source & 1) != 0) {\n      next_destination = (uint *)((int)source + 1);\n      current_char = *(char *)source;\n      *(char *)destination = current_char;\n      destination = (uint *)((int)destination + 1);\n      if (current_char == '\\0') {\n        return;\n      }\n    }\n    source = next_destination;\n    if (((uint)next_destination & 2) != 0) {\n      source = (uint *)((int)next_destination + 2);\n      current_short = *(ushort *)next_destination;\n      byte_check = (current_short & 0xff) == 0;\n      if (byte_check) {\n        *(char *)destination = (char)current_short;\n      }\n      else {\n        *(ushort *)destination = current_short;\n        byte_check = (current_short & 0xff00) == 0;\n        destination = (uint *)((int)destination + 2);\n      }\n      if (byte_check) {\n        return;\n      }\n    }\n  }\n  current_uint = *source;\n  next_destination = source + 1;\n  next_destination = destination;\n  if (((uint)source & 4) != 0) {\n    if ((current_uint + 0xfefefeff & ~current_uint & 0x80808080) != 0) goto LAB_00082630;\n    next_destination = destination + 1;\n    *destination = current_uint;\n    next_destination = source + 2;\n    current_uint = source[1];\n  }\n  while( true ) {\n    next_source = next_destination + 1;\n    current_byte = *next_destination;\n    destination = next_destination;\n    if ((current_uint + 0xfefefeff & ~current_uint & 0x80808080) != 0) break;\n    destination = next_destination + 1;\n    *next_destination = current_uint;\n    current_uint = current_byte;\n    if ((current_byte + 0xfefefeff & ~current_byte & 0x80808080) != 0) break;\n    next_destination = next_destination + 2;\n    current_uint = *next_source;\n    next_destination = next_destination + 2;\n    *destination = current_byte;\n  }\nLAB_00082630:\n  do {\n    *(char *)destination = (char)current_uint;\n    current_byte = current_uint & 0xff;\n    current_uint = current_uint >> 8 | current_uint << 0x18;\n    destination = (uint *)((int)destination + 1);\n  } while (current_byte != 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000825cc": "copy_string_000825cc",
                "param_1": "destination",
                "param_2": "source",
                "cVar1": "current_char",
                "uVar2": "current_short",
                "puVar3": "next_source",
                "puVar4": "next_destination",
                "uVar5": "current_uint",
                "uVar6": "current_byte",
                "puVar7": "next_destination",
                "bVar8": "byte_check"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082688": {
            "entrypoint": "0x00082688",
            "current_name": "count_leading_zeros_00082688",
            "code": "\nint countLeadingZeros_00082688(uint input)\n\n{\n  int leadingZeros;\n  uint *ptr;\n  uint value;\n  bool zeroFlag;\n  \n  ptr = (uint *)(input & 0xfffffffc);\n  leadingZeros = -(input & 3);\n  value = *ptr;\n  if ((input & 3) != 0) {\n    value = value | 0xffffffffU >> ((leadingZeros + 4U & 0x1f) << 3);\n  }\n  while (ptr = ptr + 1, (value + 0xfefefeff & ~value & 0x80808080) == 0) {\n    leadingZeros = leadingZeros + 4;\n    value = *ptr;\n  }\n  zeroFlag = (value & 0xff) == 0;\n  if (!zeroFlag) {\n    leadingZeros = leadingZeros + 1;\n    zeroFlag = (value & 0xff00) == 0;\n  }\n  if (!zeroFlag) {\n    leadingZeros = leadingZeros + 1;\n    zeroFlag = (value & 0xff0000) == 0;\n  }\n  if (!zeroFlag) {\n    leadingZeros = leadingZeros + 1;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_00082688": "count_leading_zeros_00082688",
                "param_1": "input",
                "iVar1": "leadingZeros",
                "puVar2": "ptr",
                "uVar3": "value",
                "bVar4": "zeroFlag"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_000814f6",
                "FUN_000810a6"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082824": {
            "entrypoint": "0x00082824",
            "current_name": "process_data_00082824",
            "code": "\nint processData_00082824(undefined4 status,int offset,int **data)\n\n{\n  int *currentData;\n  int result;\n  int *dataEnd;\n  uint counter;\n  undefined4 *currentValue;\n  uint value;\n  uint shiftedValue;\n  \n  if (-1 < *(int *)(offset + 100) << 0x12) {\n    result = FUN_00083ca8();\n    data[2] = (int *)0x0;\n    data[1] = (int *)0x0;\n    return result;\n  }\n  dataEnd = data[2];\n  currentData = *data;\n  while (dataEnd != (int *)0x0) {\n    value = currentData[1];\n    shiftedValue = value >> 2;\n    if (shiftedValue != 0) {\n      currentValue = (undefined4 *)(*currentData + -4);\n      counter = 0;\n      do {\n        currentValue = currentValue + 1;\n        result = FUN_000839b4(status,*currentValue,offset);\n        counter = counter + 1;\n        if (result == -1) goto LAB_00082864;\n      } while (shiftedValue != counter);\n      dataEnd = data[2];\n    }\n    dataEnd = (int *)((int)dataEnd - (value & 0xfffffffc));\n    data[2] = dataEnd;\n    currentData = currentData + 2;\n  }\n  result = 0;\nLAB_00082864:\n  data[2] = (int *)0x0;\n  data[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082824": "process_data_00082824",
                "param_1": "status",
                "param_2": "offset",
                "param_3": "data",
                "piVar1": "currentData",
                "iVar2": "result",
                "piVar3": "dataEnd",
                "uVar4": "counter",
                "puVar5": "currentValue",
                "uVar6": "value",
                "uVar7": "shiftedValue"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_00083ca8",
                "FUN_000839b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008289c": {
            "entrypoint": "0x0008289c",
            "current_name": "process_input_0008289c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint processInput_0008289c(int input1,int input2,int *******input3,int **input4)\n\n{\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  char cVar4;\n  bool condition4;\n  int ********var1;\n  int *var2;\n  int var3;\n  char var4;\n  int *******var5;\n  uint var6;\n  int **var7;\n  uint var8;\n  uint var9;\n  int var10;\n  int ********var11;\n  int var12;\n  int *******var13;\n  int *var14;\n  int *******var15;\n  uint var16;\n  int *var17;\n  int *******var18;\n  undefined4 var19;\n  int ********var20;\n  bool condition5;\n  longlong var21;\n  int *******localVariable2;\n  int *******local_d4;\n  int **localVariable3;\n  int localVariable4;\n  char *localVariable5;\n  char localVariable6;\n  undefined localVariable7;\n  undefined localVariable8;\n  int ********localVariable9;\n  int localVariable10;\n  int *******localVariable11;\n  undefined localVariable12;\n  char localVariable13;\n  undefined localVariable14;\n  undefined localVariable15 [4];\n  int *******localVariable16 [16];\n  \n  if ((input1 != 0) && (*(int *)(input1 + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  var8 = (uint)*(ushort *)(input2 + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(input2 + 0xc) << 0x12)) {\n    var8 = var8 | 0x2000;\n    *(short *)(input2 + 0xc) = (short)var8;\n    *(uint *)(input2 + 100) = *(uint *)(input2 + 100) & 0xffffdfff;\n  }\n  if (((int)(var8 << 0x1c) < 0) && (*(int *)(input2 + 0x10) != 0)) {\n    if ((var8 & 0x1a) != 10) goto LAB_000828ee;\n  }\n  else {\n    var3 = FUN_0008356c(input1,input2);\n    if (var3 != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(input2 + 0xc) & 0x1a) != 10) goto LAB_000828ee;\n  }\n  if (-1 < *(short *)(input2 + 0xe)) {\n    var3 = FUN_000834f0(input1,input2,input3,input4);\n    return var3;\n  }\nLAB_000828ee:\n  localVariable5 = (char *)0x0;\n  localVariable11 = (int *******)0x0;\n  localVariable10 = 0;\n  localVariable4 = 0;\n  var1 = (int ********)localVariable15;\n  localVariable3 = input4;\n  localVariable9 = (int ********)localVariable15;\nLAB_00082902:\n  var5 = input3;\n  if ((*(char *)input3 != '\\0') && (*(char *)input3 != '%')) {\n    do {\n      var5 = (int *******)((int)var5 + 1);\n      if (*(char *)var5 == '\\0') break;\n    } while (*(char *)var5 != '%');\n    var15 = (int *******)((int)var5 - (int)input3);\n    if (var15 != (int *******)0x0) {\n      localVariable10 = localVariable10 + 1;\n      localVariable11 = (int *******)((int)localVariable11 + (int)var15);\n      *var1 = input3;\n      var1[1] = var15;\n      if (localVariable10 < 8) {\n        var1 = var1 + 2;\n      }\n      else {\n        if (localVariable11 == (int *******)0x0) {\n          localVariable4 = localVariable4 + (int)var15;\n          localVariable10 = 0;\n          var1 = (int ********)localVariable15;\n          goto LAB_00082952;\n        }\n        var3 = FUN_00082824(input1,input2,&localVariable9);\n        var1 = (int ********)localVariable15;\n        if (var3 != 0) goto LAB_00083142;\n      }\n      localVariable4 = localVariable4 + (int)var15;\n    }\n  }\nLAB_00082952:\n  if (*(char *)var5 != '\\0') {\n    localVariable6 = '\\0';\n    var9 = (uint)*(byte *)((int)var5 + 1);\n    var8 = 0;\n    condition4 = false;\n    condition2 = false;\n    condition1 = false;\n    condition3 = false;\n    condition5 = false;\n    var15 = (int *******)0x0;\n    local_d4 = (int *******)0xffffffff;\n    input3 = (int *******)((int)var5 + 1);\nLAB_00082976:\n    input3 = (int *******)((int)input3 + 1);\nLAB_0008297a:\n    switch(var9) {\n    case 0x20:\n      goto switchD_00082984_caseD_20;\n    default:\n      if (var9 != 0) {\n        localVariable2 = (int *******)0x1;\n        local_d4 = (int *******)0x1;\n        var20 = (int ********)&localVariable12;\n        localVariable12 = (char)var9;\n        goto LAB_00082d76;\n      }\n      goto LAB_00083134;\n    case 0x23:\n      condition3 = true;\n      var9 = (uint)*(byte *)input3;\n      goto LAB_00082976;\n    case 0x2a:\n      var15 = (int *******)*localVariable3;\n      localVariable3 = localVariable3 + 1;\n      if ((int)var15 < 0) {\n        var15 = (int *******)-(int)var15;\n        goto switchD_00082984_caseD_2d;\n      }\n      var9 = (uint)*(byte *)input3;\n      goto LAB_00082976;\n    case 0x2b:\n      var9 = (uint)*(byte *)input3;\n      localVariable6 = '+';\n      goto LAB_00082976;\n    case 0x2d:\nswitchD_00082984_caseD_2d:\n      var8 = var8 | 4;\n      var9 = (uint)*(byte *)input3;\n      goto LAB_00082976;\n    case 0x2e:\n      var9 = (uint)*(byte *)input3;\n      var5 = (int *******)((int)input3 + 1);\n      if (var9 == 0x2a) {\n        var9 = (uint)*(byte *)((int)input3 + 1);\n        local_d4 = (int *******)*localVariable3;\n        localVariable3 = localVariable3 + 1;\n        input3 = var5;\n        if ((int)local_d4 < 0) {\n          local_d4 = (int *******)0xffffffff;\n        }\n        goto LAB_00082976;\n      }\n      var6 = var9 - 0x30;\n      if (var6 < 10) {\n        var16 = 0;\n        do {\n          input3 = (int *******)((int)var5 + 1);\n          var9 = (uint)*(byte *)var5;\n          var16 = var6 + var16 * 10;\n          var6 = var9 - 0x30;\n          var5 = input3;\n        } while (var6 < 10);\n        local_d4 = (int *******)(var16 | (int)var16 >> 0x1f);\n      }\n      else {\n        local_d4 = (int *******)0x0;\n        input3 = var5;\n      }\n      goto LAB_0008297a;\n    case 0x30:\n      var8 = var8 | 0x80;\n      var9 = (uint)*(byte *)input3;\n      goto LAB_00082976;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082984_caseD_31;\n    case 0x44:\n      condition2 = true;\n      if (condition1 == false) goto LAB_00082d8c;\nLAB_00082bfc:\n      localVariable3 = (int **)((int)localVariable3 + 7U & 0xfffffff8);\n      var14 = *localVariable3;\n      var17 = localVariable3[1];\n      localVariable3 = localVariable3 + 2;\n      goto LAB_00082c10;\n    case 0x4f:\n      condition2 = true;\n      if (condition1 != false) goto LAB_00082aa6;\nLAB_00082c8e:\n      var3 = (uint)condition2 << 4;\n      var10 = (uint)condition1 << 5;\n      if ((condition2 == 0) && (var10 = (uint)condition5 << 6, condition5 != 0)) {\n        var14 = (int *)(uint)*(ushort *)localVariable3;\n        localVariable3 = localVariable3 + 1;\n        var17 = (int *)0x0;\n      }\n      else {\n        var3 = var10;\n        var14 = *localVariable3;\n        localVariable3 = localVariable3 + 1;\n        var17 = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      condition2 = true;\n      if (condition1 != false) goto LAB_00082bc6;\nLAB_00082ce0:\n      if ((condition2) || (condition5 == false)) {\n        var3 = 1;\n        var14 = *localVariable3;\n        localVariable3 = localVariable3 + 1;\n        var17 = (int *)0x0;\n      }\n      else {\n        var17 = (int *)0x0;\n        var14 = (int *)(uint)*(ushort *)localVariable3;\n        localVariable3 = localVariable3 + 1;\n        var3 = 1;\n      }\n      break;\n    case 0x58:\n      localVariable5 = \"0123456789ABCDEF\";\n      if (condition1 == false) goto LAB_00082efa;\nLAB_00082d1a:\n      var7 = (int **)((int)localVariable3 + 7U & 0xfffffff8);\n      localVariable3 = var7 + 2;\n      var14 = *var7;\n      var17 = var7[1];\n      goto LAB_00082d2e;\n    case 99:\n      var14 = *localVariable3;\n      localVariable3 = localVariable3 + 1;\n      localVariable2 = (int *******)0x1;\n      localVariable12 = SUB41(var14,0);\n      local_d4 = (int *******)0x1;\n      var20 = (int ********)&localVariable12;\n      goto LAB_00082d76;\n    case 100:\n    case 0x69:\n      if (condition1 != false) goto LAB_00082bfc;\nLAB_00082d8c:\n      if ((condition2 == false) && (condition5 != false)) {\n        var14 = (int *)(int)*(short *)localVariable3;\n        localVariable3 = localVariable3 + 1;\n        var17 = (int *)((int)var14 >> 0x1f);\n      }\n      else {\n        var14 = *localVariable3;\n        localVariable3 = localVariable3 + 1;\n        var17 = (int *)((int)var14 >> 0x1f);\n      }\nLAB_00082c10:\n      if ((int)var17 < 0) {\n        condition5 = var14 != (int *)0x0;\n        var14 = (int *)-(int)var14;\n        var17 = (int *)(-(int)var17 - (uint)condition5);\n        localVariable6 = '-';\n        cVar4 = '-';\n        var3 = 1;\n        goto LAB_00082ace;\n      }\n      if (-1 < (int)local_d4) {\n        var8 = var8 & 0xffffff7f;\n      }\n      condition4 = false;\n      var9 = (uint)var14 | (uint)var17;\n      var3 = 1;\n      cVar4 = localVariable6;\n      goto joined_r0x00082adc;\n    case 0x68:\n      condition5 = true;\n      var9 = (uint)*(byte *)input3;\n      goto LAB_00082976;\n    case 0x6c:\n      var9 = (uint)*(byte *)input3;\n      if (var9 == 0x6c) {\n        condition1 = true;\n        var9 = (uint)*(byte *)((int)input3 + 1);\n        input3 = (int *******)((int)input3 + 1);\n      }\n      else {\n        condition2 = true;\n      }\n      goto LAB_00082976;\n    case 0x6e:\n      if (condition1 == false) {\n        if (condition2 == false) {\n          if (condition5) {\n            var14 = *localVariable3;\n            localVariable3 = localVariable3 + 1;\n            *(short *)var14 = (short)localVariable4;\n          }\n          else {\n            var14 = *localVariable3;\n            localVariable3 = localVariable3 + 1;\n            *var14 = localVariable4;\n          }\n        }\n        else {\n          var14 = *localVariable3;\n          localVariable3 = localVariable3 + 1;\n          *var14 = localVariable4;\n        }\n      }\n      else {\n        var14 = *localVariable3;\n        localVariable3 = localVariable3 + 1;\n        *var14 = localVariable4;\n        var14[1] = localVariable4 >> 0x1f;\n      }\n      goto LAB_00082902;\n    case 0x6f:\n      if (condition1 == false) goto LAB_00082c8e;\nLAB_00082aa6:\n      var7 = (int **)((int)localVariable3 + 7U & 0xfffffff8);\n      localVariable3 = var7 + 2;\n      var14 = *var7;\n      var17 = var7[1];\n      var3 = 0;\n      break;\n    case 0x70:\n      var14 = *localVariable3;\n      localVariable3 = localVariable3 + 1;\n      localVariable8 = 0x78;\n      condition4 = true;\n      var17 = (int *)0x0;\n      localVariable7 = 0x30;\n      localVariable5 = \"0123456789abcdef\";\n      var3 = 2;\n      break;\n    case 0x71:\n      condition1 = true;\n      var9 = (uint)*(byte *)input3;\n      goto LAB_00082976;\n    case 0x73:\n      var20 = (int ********)*localVariable3;\n      localVariable6 = '\\0';\n      localVariable3 = localVariable3 + 1;\n      if (var20 != (int ********)0x0) {\n        if ((int)local_d4 < 0) {\n          local_d4 = (int *******)FUN_00082688(var20);\n          var5 = (int *******)0x0;\n          cVar4 = localVariable6;\n        }\n        else {\n          var3 = FUN_000840f8(var20,0,local_d4);\n          cVar4 = localVariable6;\n          if (var3 == 0) {\n            var5 = (int *******)0x0;\n          }\n          else {\n            var13 = (int *******)(var3 - (int)var20);\n            if ((int)local_d4 <= (int)(int *******)(var3 - (int)var20)) {\n              var13 = local_d4;\n            }\n            var5 = (int *******)0x0;\n            local_d4 = var13;\n          }\n        }\n        goto LAB_00082b04;\n      }\n      if ((int *******)0x5 < local_d4) {\n        local_d4 = (int *******)0x6;\n      }\n      localVariable2 = (int *******)((uint)local_d4 & ~((int)local_d4 >> 0x1f));\n      var20 = (int ********)&UNK_00085728;\nLAB_00082d76:\n      localVariable6 = '\\0';\n      var5 = (int *******)0x0;\n      goto LAB_00082b1e;\n    case 0x75:\n      if (!condition1) goto LAB_00082ce0;\nLAB_00082bc6:\n      var7 = (int **)((int)localVariable3 + 7U & 0xfffffff8);\n      localVariable3 = var7 + 2;\n      var14 = *var7;\n      var17 = var7[1];\n      var3 = 1;\n      break;\n    case 0x78:\n      localVariable5 = \"0123456789abcdef\";\n      if (condition1 != false) goto LAB_00082d1a;\nLAB_00082efa:\n      if ((condition2 == false) && (condition5 != false)) {\n        var17 = (int *)0x0;\n        var14 = (int *)(uint)*(ushort *)localVariable3;\n        localVariable3 = localVariable3 + 1;\n      }\n      else {\n        var14 = *localVariable3;\n        localVariable3 = localVariable3 + 1;\n        var17 = (int *)0x0;\n      }\nLAB_00082d2e:\n      if ((condition3) && (((uint)var14 | (uint)var17) != 0)) {\n        condition4 = true;\n        localVariable7 = 0x30;\n        var3 = 2;\n        localVariable8 = (char)var9;\n      }\n      else {\n        var3 = 2;\n      }\n    }\n    localVariable6 = '\\0';\n    cVar4 = '\\0';\nLAB_00082ace:\n    if (-1 < (int)local_d4) {\n      var8 = var8 & 0xffffff7f;\n    }\n    var9 = (uint)var14 | (uint)var17;\njoined_r0x00082adc:\n    var21 = CONCAT44(var17,var14);\n    var5 = local_d4;\n    if ((var9 == 0) && (local_d4 == (int *******)0x0)) {\n      var20 = (int ********)localVariable15;\n      if ((var3 != 0) || (!condition3)) goto LAB_00082b04;\n      var20 = (int ********)(&localVariable13 + 1);\n      localVariable14 = '0';\n      goto LAB_00082afe;\n    }\n    if (var3 == 1) {\n      if (var17 != (int *)0x0 || (int *)0x9 < var14) {\n        var11 = (int ********)(&localVariable13 + 1);\n        do {\n          var20 = var11;\n          var19 = (undefined4)((ulonglong)var21 >> 0x20);\n          var4 = '\\n';\n          FUN_00084530((int)var21,var19,10,0);\n          *(char *)var20 = var4 + '0';\n          var21 = FUN_00084530((int)var21,var19,10,0);\n          var11 = (int ********)((int)var20 + -1);\n        } while (var21 != 0);\n        local_d4 = (int *******)((int)localVariable15 - (int)var20);\n        goto LAB_00082b04;\n      }\n      localVariable14 = (char)var14 + '0';\n      var20 = (int ********)(&localVariable13 + 1);\n      goto LAB_00083282;\n    }\n    var11 = (int ********)(&localVariable13 + 1);\n    if (var3 != 2) goto LAB_000830e2;\n    do {\n      var20 = var11;\n      var9 = (uint)var14 & 0xf;\n      var14 = (int *)((uint)var14 >> 4 | (int)var17 << 0x1c);\n      var17 = (int *)((uint)var17 >> 4);\n      *(char *)var20 = localVariable5[var9];\n      var11 = (int ********)((int)var20 + -1);\n    } while (((uint)var14 | (uint)var17) != 0);\n    local_d4 = (int *******)((int)localVariable15 - (int)var20);\n    goto LAB_00082b04;\n  }\nLAB_00083134:\n  if (localVariable11 != (int *******)0x0) {\n    FUN_00082824(input1,input2,&localVariable9);\n  }\nLAB_00083142:\n  if ((int)((uint)*(ushort *)(input2 + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return localVariable4;\nLAB_000830e2:\n  do {\n    var20 = var11;\n    var2 = (int *)((uint)var14 >> 3 | (int)var17 << 0x1d);\n    var17 = (int *)((uint)var17 >> 3);\n    var3 = ((uint)var14 & 7) + 0x30;\n    *(char *)var20 = (char)var3;\n    var11 = (int ********)((int)var20 + -1);\n    var14 = var2;\n  } while (((uint)var2 | (uint)var17) != 0);\n  if (condition3) {\n    if (var3 == 0x30) {\nLAB_00082afe:\n      local_d4 = (int *******)((int)localVariable15 - (int)var20);\n    }\n    else {\n      *(undefined *)((int)var20 + -1) = 0x30;\n      var20 = var11;\n      local_d4 = (int *******)((int)localVariable15 - (int)var11);\n    }\n  }\n  else {\nLAB_00083282:\n    local_d4 = (int *******)((int)localVariable15 - (int)var20);\n  }\nLAB_00082b04:\n  localVariable2 = local_d4;\n  if ((int)local_d4 < (int)var5) {\n    localVariable2 = var5;\n  }\n  if (cVar4 != '\\0') {\n    localVariable2 = (int *******)((int)localVariable2 + 1);\n  }\nLAB_00082b1e:\n  if (condition4) {\n    localVariable2 = (int *******)((int)localVariable2 + 2);\n  }\n  if ((var8 == 0) &&\n     (var13 = (int *******)((int)var15 - (int)localVariable2), 0 < (int)var13)) {\n    if ((int)var13 < 0x11) {\n      localVariable10 = localVariable10 + 1;\n    }\n    else {\n      do {\n        var18 = var13;\n        var3 = localVariable10 + 1;\n        localVariable11 = localVariable11 + 4;\n        *var1 = (int *******)0x856f0;\n        var1[1] = (int *******)0x10;\n        if (var3 < 8) {\n          var10 = localVariable10 + 2;\n          var1 = var1 + 2;\n          localVariable10 = var3;\n        }\n        else if (localVariable11 == (int *******)0x0) {\n          var10 = 1;\n          var1 = (int ********)localVariable15;\n          localVariable10 = 0;\n        }\n        else {\n          localVariable10 = var3;\n          var3 = FUN_00082824(input1,input2,&localVariable9);\n          if (var3 != 0) goto LAB_00083142;\n          var10 = localVariable10 + 1;\n          var1 = (int ********)localVariable15;\n        }\n        var13 = var18 + -4;\n      } while (0x10 < (int)var13);\n      var13 = var18 + -4;\n      localVariable10 = var10;\n    }\n    localVariable11 = (int *******)((int)localVariable11 + (int)var13);\n    *var1 = (int *******)0x856f0;\n    var1[1] = var13;\n    if (localVariable10 < 8) {\n      var3 = localVariable10 + 1;\n      var1 = var1 + 2;\n    }\n    else if (localVariable11 == (int *******)0x0) {\n      var3 = 1;\n      localVariable10 = 0;\n      var1 = (int ********)localVariable15;\n    }\n    else {\n      var3 = FUN_00082824(input1,input2,&localVariable9);\n      if (var3 != 0) goto LAB_00083142;\n      var3 = localVariable10 + 1;\n      var1 = (int ********)localVariable15;\n    }\n  }\n  else {\n    var3 = localVariable10 + 1;\n  }\n  var10 = var3;\n  if (localVariable6 != '\\0') {\n    localVariable11 = (int *******)((int)localVariable11 + 1);\n    var10 = 1;\n    *var1 = (int *******)&localVariable6;\n    var1[1] = (int *******)0x1;\n    localVariable10 = var3;\n    if (var3 < 8) {\n      var10 = var3 + 1;\n      var1 = var1 + 2;\n    }\n    else if (localVariable11 == (int *******)0x0) {\n      localVariable10 = 0;\n      var1 = (int ********)localVariable15;\n    }\n    else {\n      var3 = FUN_00082824(input1,input2,&localVariable9);\n      if (var3 != 0) goto LAB_00083142;\n      var10 = localVariable10 + 1;\n      var1 = (int ********)localVariable15;\n    }\n  }\n  var3 = var10;\n  var12 = localVariable10;\n  if (condition4) {\n    localVariable11 = (int *******)((int)localVariable11 + 2);\n    *var1 = (int *******)&localVariable7;\n    var1[1] = (int *******)0x2;\n    if (var10 < 8) {\n      var3 = var10 + 1;\n      var12 = var10;\n      var1 = var1 + 2;\n    }\n    else if (localVariable11 == (int *******)0x0) {\n      var3 = 1;\n      var12 = 0;\n      var1 = (int ********)localVariable15;\n    }\n    else {\n      localVariable10 = var10;\n      var3 = FUN_00082824(input1,input2,&localVariable9);\n      if (var3 != 0) goto LAB_00083142;\n      var3 = localVariable10 + 1;\n      var12 = localVariable10;\n      var1 = (int ********)localVariable15;\n    }\n  }\n  localVariable10 = var12;\n  if ((var8 == 0x80) &&\n     (var13 = (int *******)((int)var15 - (int)localVariable2), 0 < (int)var13)) {\n    if (0x10 < (int)var13) {\n      do {\n        while( true ) {\n          var18 = var13;\n          localVariable10 = var12 + 1;\n          localVariable11 = localVariable11 + 4;\n          *var1 = (int *******)\"0000000000000000\";\n          var1[1] = (int *******)0x10;\n          if (7 < localVariable10) break;\n          var3 = var12 + 2;\n          var1 = var1 + 2;\nLAB_000831f2:\n          var12 = localVariable10;\n          var13 = var18 + -4;\n          if ((int)(var18 + -4) < 0x11) goto LAB_00083218;\n        }\n        if (localVariable11 != (int *******)0x0) {\n          var3 = FUN_00082824(input1,input2,&localVariable9);\n          if (var3 == 0) {\n            var3 = localVariable10 + 1;\n            var1 = (int ********)localVariable15;\n            goto LAB_000831f2;\n          }\n          goto LAB_00083142;\n        }\n        var3 = 1;\n        var12 = 0;\n        var13 = var18 + -4;\n        var1 = (int ********)localVariable15;\n      } while (0x10 < (int)(var18 + -4));\nLAB_00083218:\n      var13 = var18 + -4;\n    }\n    localVariable11 = (int *******)((int)localVariable11 + (int)var13);\n    *var1 = (int *******)\"0000000000000000\";\n    var1[1] = var13;\n    localVariable10 = var3;\n    if (var3 < 8) {\n      var3 = var3 + 1;\n      var1 = var1 + 2;\n    }\n    else if (localVariable11 == (int *******)0x0) {\n      var3 = 1;\n      localVariable10 = 0;\n      var1 = (int ********)localVariable15;\n    }\n    else {\n      var3 = FUN_00082824(input1,input2,&localVariable9);\n      if (var3 != 0) goto LAB_00083142;\n      var3 = localVariable10 + 1;\n      var1 = (int ********)localVariable15;\n    }\n  }\n  var5 = (int *******)((int)var5 - (int)local_d4);\n  var11 = (int ********)localVariable15;\n  if ((int)var5 < 1) {\nLAB_0008302a:\n    localVariable11 = (int *******)((int)localVariable11 + (int)local_d4);\n    *var1 = (int *******)var20;\n    var1[1] = local_d4;\n    local_d4 = localVariable11;\n    localVariable10 = var3;\n    if (var3 < 8) goto LAB_000831be;\n    if (localVariable11 == (int *******)0x0) {\n      localVariable10 = 0;\n    }\n    else {\n      var3 = FUN_00082824(input1,input2,&localVariable9);\n      if (var3 != 0) goto LAB_00083142;\n    }\n  }\n  else {\n    var10 = localVariable10;\n    if (0x10 < (int)var5) {\n      do {\n        while( true ) {\n          var13 = var5;\n          localVariable10 = var10 + 1;\n          localVariable11 = localVariable11 + 4;\n          *var1 = (int *******)\"0000000000000000\";\n          var1[1] = (int *******)0x10;\n          if (7 < localVariable10) break;\n          var3 = var10 + 2;\n          var1 = var1 + 2;\nLAB_00082fe6:\n          var10 = localVariable10;\n          var5 = var13 + -4;\n          if ((int)(var13 + -4) < 0x11) goto LAB_0008300e;\n        }\n        if (localVariable11 != (int *******)0x0) {\n          var3 = FUN_00082824(input1,input2,&localVariable9);\n          if (var3 == 0) {\n            var3 = localVariable10 + 1;\n            var1 = (int ********)localVariable15;\n            goto LAB_00082fe6;\n          }\n          goto LAB_00083142;\n        }\n        var3 = 1;\n        var1 = (int ********)localVariable15;\n        var10 = 0;\n        var5 = var13 + -4;\n      } while (0x10 < (int)(var13 + -4));\nLAB_0008300e:\n      var5 = var13 + -4;\n    }\n    localVariable11 = (int *******)((int)localVariable11 + (int)var5);\n    *var1 = (int *******)\"0000000000000000\";\n    var1[1] = var5;\n    if (var3 < 8) {\n      var3 = var3 + 1;\n      var1 = var1 + 2;\n      goto LAB_0008302a;\n    }\n    if (localVariable11 != (int *******)0x0) {\n      localVariable10 = var3;\n      var3 = FUN_00082824(input1,input2,&localVariable9);\n      if (var3 != 0) goto LAB_00083142;\n      var3 = localVariable10 + 1;\n      var1 = (int ********)localVariable15;\n      goto LAB_0008302a;\n    }\n    localVariable16[0] = local_d4;\n    localVariable10 = 1;\n    var1 = (int ********)localVariable15;\n    localVariable15 = (undefined  [4])var20;\nLAB_000831be:\n    var11 = var1 + 2;\n    localVariable11 = local_d4;\n  }\n  if (((var8 & 4) != 0) &&\n     (var5 = (int *******)((int)var15 - (int)localVariable2), 0 < (int)var5)) {\n    var3 = localVariable10;\n    if ((int)var5 < 0x11) {\n      var10 = localVariable10 + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          localVariable10 = var3 + 1;\n          localVariable11 = localVariable11 + 4;\n          *var11 = (int *******)0x856f0;\n          var11[1] = (int *******)0x10;\n          if (7 < localVariable10) break;\n          var10 = var3 + 2;\n          var11 = var11 + 2;\nLAB_0008307a:\n          var5 = var5 + -4;\n          var3 = localVariable10;\n          if ((int)var5 < 0x11) goto LAB_000830a2;\n        }\n        if (localVariable11 != (int *******)0x0) {\n          var3 = FUN_00082824(input1,input2,&localVariable9);\n          if (var3 == 0) {\n            var10 = localVariable10 + 1;\n            var11 = (int ********)localVariable15;\n            goto LAB_0008307a;\n          }\n          goto LAB_00083142;\n        }\n        var5 = var5 + -4;\n        var10 = 1;\n        var3 = 0;\n        var11 = (int ********)localVariable15;\n      } while (0x10 < (int)var5);\n    }\nLAB_000830a2:\n    localVariable11 = (int *******)((int)localVariable11 + (int)var5);\n    *var11 = (int *******)0x856f0;\n    var11[1] = var5;\n    localVariable10 = var10;\n    if (7 < var10) {\n      if (localVariable11 == (int *******)0x0) {\n        if ((int)localVariable2 < (int)var15) {\n          localVariable2 = var15;\n        }\n        localVariable4 = localVariable4 + (int)localVariable2;\n        goto LAB_00083186;\n      }\n      var3 = FUN_00082824(input1,input2,&localVariable9);\n      if (var3 != 0) goto LAB_00083142;\n    }\n  }\n  if ((int)localVariable2 < (int)var15) {\n    localVariable2 = var15;\n  }\n  localVariable4 = localVariable4 + (int)localVariable2;\n  if ((localVariable11 != (int *******)0x0) &&\n     (var3 = FUN_00082824(input1,input2,&localVariable9), var3 != 0)) goto LAB_00083142;\nLAB_00083186:\n  localVariable10 = 0;\n  var1 = (int ********)localVariable15;\n  goto LAB_00082902;\nswitchD_00082984_caseD_31:\n  var6 = var9 - 0x30;\n  var15 = (int *******)0x0;\n  var5 = input3;\n  do {\n    input3 = (int *******)((int)var5 + 1);\n    var9 = (uint)*(byte *)var5;\n    var15 = (int *******)(var6 + (int)var15 * 10);\n    var6 = var9 - 0x30;\n    var5 = input3;\n  } while (var6 < 10);\n  goto LAB_0008297a;\nswitchD_00082984_caseD_20:\n  var9 = (uint)*(byte *)input3;\n  if (localVariable6 == '\\0') {\n    localVariable6 = ' ';\n  }\n  goto LAB_00082976;\n}\n\n",
            "renaming": {
                "FUN_0008289c": "process_input_0008289c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "bVar1": "condition1",
                "bVar2": "condition2",
                "bVar3": "condition3",
                "bVar5": "condition4",
                "ppppppppiVar6": "var1",
                "piVar7": "var2",
                "iVar8": "var3",
                "cVar9": "var4",
                "pppppppiVar10": "var5",
                "uVar11": "var6",
                "ppiVar12": "var7",
                "uVar13": "var8",
                "uVar14": "var9",
                "iVar15": "var10",
                "ppppppppiVar16": "var11",
                "iVar17": "var12",
                "pppppppiVar18": "var13",
                "piVar19": "var14",
                "pppppppiVar20": "var15",
                "uVar21": "var16",
                "piVar22": "var17",
                "pppppppiVar23": "var18",
                "uVar24": "var19",
                "ppppppppiVar25": "var20",
                "bVar26": "condition5",
                "lVar27": "var21",
                "local_dc": "localVariable2",
                "local_c8": "localVariable3",
                "local_c4": "localVariable4",
                "local_c0": "localVariable5",
                "local_a1": "localVariable6",
                "local_a0": "localVariable7",
                "local_9f": "localVariable8",
                "local_9c": "localVariable9",
                "local_98": "localVariable10",
                "local_94": "localVariable11",
                "local_90": "localVariable12",
                "cStack_6a": "localVariable13",
                "local_69": "localVariable14",
                "local_68": "localVariable15",
                "local_64": "localVariable16"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00081750",
                "FUN_000817c8"
            ],
            "called": [
                "FUN_000834f0",
                "FUN_00082824",
                "FUN_0008356c",
                "FUN_000840f8",
                "FUN_00084530",
                "FUN_00082688",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000834f0": {
            "entrypoint": "0x000834f0",
            "current_name": "parse_data_record_000834f0",
            "code": "\nint parseDataRecord_000834f0(undefined4 inputBuffer,int dataRecord)\n\n{\n  int result;\n  int checkResult;\n  undefined *stackBuffer [2];\n  undefined4 stackSize;\n  ushort flags;\n  undefined2 value;\n  undefined *buffer;\n  undefined4 size1;\n  undefined4 size2;\n  undefined4 offset;\n  undefined4 flags2;\n  undefined4 temp;\n  undefined tempBuffer [1024];\n  \n  temp = *(undefined4 *)(dataRecord + 100);\n  offset = *(undefined4 *)(dataRecord + 0x1c);\n  value = *(undefined2 *)(dataRecord + 0xe);\n  flags2 = *(undefined4 *)(dataRecord + 0x24);\n  stackBuffer[0] = tempBuffer;\n  flags = *(ushort *)(dataRecord + 0xc) & 0xfffd;\n  stackSize = 0x400;\n  size1 = 0x400;\n  size2 = 0;\n  buffer = stackBuffer[0];\n  result = FUN_0008289c(inputBuffer,stackBuffer);\n  if ((-1 < result) && (checkResult = FUN_00083850(inputBuffer,stackBuffer), checkResult != 0)) {\n    result = -1;\n  }\n  if ((int)((uint)flags << 0x19) < 0) {\n    *(ushort *)(dataRecord + 0xc) = *(ushort *)(dataRecord + 0xc) | 0x40;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000834f0": "parse_data_record_000834f0",
                "param_1": "inputBuffer",
                "param_2": "dataRecord",
                "iVar1": "result",
                "iVar2": "checkResult",
                "local_488": "stackBuffer",
                "local_480": "stackSize",
                "local_47c": "flags",
                "local_47a": "value",
                "local_478": "buffer",
                "local_474": "size1",
                "local_470": "size2",
                "local_46c": "offset",
                "local_464": "flags2",
                "local_424": "temp",
                "auStack_420": "tempBuffer"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008289c",
                "FUN_00083850"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008356c": {
            "entrypoint": "0x0008356c",
            "current_name": "process_data_0008356c",
            "code": "\nundefined4 process_data_0008356c(undefined4 *output_buffer,int *input_buffer)\n\n{\n  int var1;\n  int var2;\n  uint temp;\n  ushort temp2;\n  \n  if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  temp2 = *(ushort *)(input_buffer + 3);\n  temp = (uint)temp2;\n  if ((int)(temp << 0x1c) < 0) {\n    var2 = input_buffer[4];\n  }\n  else {\n    if (-1 < (int)(temp << 0x1b)) {\n      *output_buffer = 9;\n      *(ushort *)(input_buffer + 3) = temp2 | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(temp << 0x1d) < 0) {\n      if ((int *)input_buffer[0xc] != (int *)0x0) {\n        if ((int *)input_buffer[0xc] != input_buffer + 0x10) {\n          FUN_00083b10(output_buffer);\n          temp2 = *(ushort *)(input_buffer + 3);\n        }\n        input_buffer[0xc] = 0;\n      }\n      var2 = input_buffer[4];\n      temp2 = temp2 & 0xffdb;\n      *input_buffer = var2;\n      input_buffer[1] = 0;\n    }\n    else {\n      var2 = input_buffer[4];\n    }\n    *(ushort *)(input_buffer + 3) = temp2 | 8;\n    temp = (uint)(temp2 | 8);\n  }\n  if ((var2 == 0) && ((temp & 0x280) != 0x200)) {\n    FUN_00084018(output_buffer,input_buffer);\n    temp = (uint)*(ushort *)(input_buffer + 3);\n    var2 = input_buffer[4];\n  }\n  if ((temp & 1) == 0) {\n    var1 = 0;\n    if (-1 < (int)(temp << 0x1e)) {\n      var1 = input_buffer[5];\n    }\n    input_buffer[2] = var1;\n  }\n  else {\n    input_buffer[6] = -input_buffer[5];\n    input_buffer[2] = 0;\n  }\n  if ((var2 == 0) && ((int)((uint)*(ushort *)(input_buffer + 3) << 0x18) < 0)) {\n    *(ushort *)(input_buffer + 3) = *(ushort *)(input_buffer + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008356c": "process_data_0008356c",
                "param_1": "output_buffer",
                "param_2": "input_buffer",
                "iVar1": "var1",
                "iVar2": "var2",
                "uVar3": "temp",
                "uVar4": "temp2"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_000842a4",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00084018",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836d8": {
            "entrypoint": "0x000836d8",
            "current_name": "FUNC_000836d8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x00083630) */\n/* WARNING: Removing unreachable block (ram,0x000836c4) */\n/* WARNING: Removing unreachable block (ram,0x00083642) */\n/* WARNING: Removing unreachable block (ram,0x00083648) */\n/* WARNING: Removing unreachable block (ram,0x00083654) */\n/* WARNING: Removing unreachable block (ram,0x0008366e) */\n/* WARNING: Removing unreachable block (ram,0x0008364c) */\n/* WARNING: Removing unreachable block (ram,0x00083686) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n/* WARNING: Removing unreachable block (ram,0x00083688) */\n\nvoid FUNC_000836d8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836d8": "FUNC_000836d8"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000836ec": {
            "entrypoint": "0x000836ec",
            "current_name": "initialize_relocation_table_000836ec",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n\nvoid initializeRelocationTable_000836ec(void)\n\n{\n  dword *relocationTable;\n  dword result;\n  int index;\n  code *JUMPTABLE_00;\n  \n  FUN_000841e4(6);\n  JUMPTABLE_00 = (code *)0x836fb;\n  result = FUN_00080eec(1);\n  if (Elf32_Rel_ARRAY_20070000[48].r_offset == 0) {\n    Elf32_Rel_ARRAY_20070000[48].r_offset = 0x20070184;\n  }\n  index = *(int *)(Elf32_Rel_ARRAY_20070000[48].r_offset + 4);\n  relocationTable = (dword *)Elf32_Rel_ARRAY_20070000[48].r_offset;\n  if (0x1f < index) {\n    relocationTable = (dword *)FUN_000817f0(400);\n    if (relocationTable == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*JUMPTABLE_00)(0xffffffff);\n      return;\n    }\n    *relocationTable = Elf32_Rel_ARRAY_20070000[48].r_offset;\n    relocationTable[1] = 0;\n    index = 0;\n    Elf32_Rel_ARRAY_20070000[48].r_offset = (dword)relocationTable;\n    relocationTable[0x62] = 0;\n    relocationTable[99] = 0;\n  }\n  relocationTable[1] = index + 1;\n  relocationTable[index + 2] = result;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*JUMPTABLE_00)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836ec": "initialize_relocation_table_000836ec",
                "pdVar1": "relocationTable",
                "dVar2": "result",
                "iVar3": "index",
                "UNRECOVERED_JUMPTABLE_00": "JUMPTABLE_00"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_000841e4",
                "FUN_00080eec",
                "FUN_000817f0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083850": {
            "entrypoint": "0x00083850",
            "current_name": "process_data_00083850",
            "code": "\nundefined4 processData_00083850(int *dataBuffer,int *infoBuffer)\n\n{\n  int *tempPtr;\n  int length;\n  ushort infoFlags;\n  uint infoFlagsTmp;\n  int tempVar;\n  code *callback;\n  undefined4 result;\n  int tempVar2;\n  \n  if ((dataBuffer != (int *)0x0) && (dataBuffer[0xe] == 0)) {\n    FUN_00083888();\n  }\n  if (*(short *)(infoBuffer + 3) == 0) {\n    return 0;\n  }\n  infoFlags = *(ushort *)(infoBuffer + 3);\n  if ((int)((uint)infoFlags << 0x1c) < 0) {\n    tempVar2 = infoBuffer[4];\n    if (tempVar2 == 0) {\n      return 0;\n    }\n    length = *infoBuffer;\n    if ((infoFlags & 3) == 0) {\n      tempVar = infoBuffer[5];\n    }\n    else {\n      tempVar = 0;\n    }\n    *infoBuffer = tempVar2;\n    length = length - tempVar2;\n    infoBuffer[2] = tempVar;\n    do {\n      if (length < 1) {\n        return 0;\n      }\n      tempVar = (*(code *)infoBuffer[9])(dataBuffer,infoBuffer[7],tempVar2,length,result);\n      length = length - tempVar;\n      tempVar2 = tempVar2 + tempVar;\n    } while (0 < tempVar);\nLAB_000837c8:\n    *(ushort *)(infoBuffer + 3) = *(ushort *)(infoBuffer + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(infoBuffer + 3) = infoFlags | 0x800;\n  if ((infoBuffer[1] < 1) && (infoBuffer[0xf] < 1)) {\n    return 0;\n  }\n  callback = (code *)infoBuffer[10];\n  if (callback == (code *)0x0) {\n    return 0;\n  }\n  infoFlagsTmp = (uint)(infoFlags | 0x800);\n  tempVar2 = *dataBuffer;\n  *dataBuffer = 0;\n  if ((infoFlags & 0x1000) == 0) {\n    length = (*callback)(dataBuffer,infoBuffer[7],infoFlagsTmp & 0x1000,1);\n    if ((length == -1) && (tempVar = *dataBuffer, tempVar != 0)) {\n      if ((tempVar == 0x1d) || (tempVar == 0x16)) {\n        *dataBuffer = tempVar2;\n        return 0;\n      }\n      goto LAB_000837c8;\n    }\n    infoFlagsTmp = (uint)*(ushort *)(infoBuffer + 3);\n    callback = (code *)infoBuffer[10];\n  }\n  else {\n    length = infoBuffer[0x14];\n  }\n  if (((int)(infoFlagsTmp << 0x1d) < 0) && (length = length - infoBuffer[1], infoBuffer[0xc] != 0)) {\n    length = length - infoBuffer[0xf];\n  }\n  length = (*callback)(dataBuffer,infoBuffer[7],length,0);\n  if (length == -1) {\n    tempVar = *dataBuffer;\n    if (tempVar != 0) {\n      if ((tempVar != 0x1d) && (tempVar != 0x16)) {\n        *(ushort *)(infoBuffer + 3) = *(ushort *)(infoBuffer + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(infoBuffer + 3) = *(ushort *)(infoBuffer + 3) & 0xf7ff;\n      *infoBuffer = infoBuffer[4];\n      infoBuffer[1] = 0;\n      goto LAB_00083774;\n    }\n    infoFlags = *(ushort *)(infoBuffer + 3) & 0xf7ff;\n    infoBuffer[1] = 0;\n    *(ushort *)(infoBuffer + 3) = infoFlags;\n    *infoBuffer = infoBuffer[4];\n  }\n  else {\n    infoFlags = *(ushort *)(infoBuffer + 3) & 0xf7ff;\n    *infoBuffer = infoBuffer[4];\n    *(ushort *)(infoBuffer + 3) = infoFlags;\n    infoBuffer[1] = 0;\n  }\n  if ((int)((uint)infoFlags << 0x13) < 0) {\n    infoBuffer[0x14] = length;\n  }\nLAB_00083774:\n  tempPtr = (int *)infoBuffer[0xc];\n  *dataBuffer = tempVar2;\n  if (tempPtr == (int *)0x0) {\n    return 0;\n  }\n  if (tempPtr != infoBuffer + 0x10) {\n    FUN_00083b10(dataBuffer);\n  }\n  infoBuffer[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083850": "process_data_00083850",
                "param_1": "dataBuffer",
                "param_2": "infoBuffer",
                "piVar1": "tempPtr",
                "iVar2": "length",
                "uVar3": "infoFlags",
                "uVar4": "infoFlagsTmp",
                "iVar5": "tempVar",
                "pcVar6": "callback",
                "unaff_r4": "result",
                "iVar7": "tempVar2"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00084484",
                "FUN_000842a4",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083888": {
            "entrypoint": "0x00083888",
            "current_name": "initialize_data_structures_00083888",
            "code": "\nvoid initializeDataStructures_00083888(int dataStructuresPtr)\n\n{\n  undefined4 *firstDataStructurePtr;\n  undefined4 *secondDataStructurePtr;\n  \n  if (*(int *)(dataStructuresPtr + 0x38) == 0) {\n    firstDataStructurePtr = *(undefined4 **)(dataStructuresPtr + 4);\n    *(undefined **)(dataStructuresPtr + 0x3c) = &label1;\n    *(undefined4 *)(dataStructuresPtr + 0x2e4) = 3;\n    *(int *)(dataStructuresPtr + 0x2e8) = dataStructuresPtr + 0x2ec;\n    *(undefined4 *)(dataStructuresPtr + 0x2e0) = 0;\n    *(undefined2 *)(firstDataStructurePtr + 3) = 4;\n    *firstDataStructurePtr = 0;\n    firstDataStructurePtr[1] = 0;\n    firstDataStructurePtr[2] = 0;\n    firstDataStructurePtr[0x19] = 0;\n    *(undefined2 *)((int)firstDataStructurePtr + 0xe) = 0;\n    firstDataStructurePtr[4] = 0;\n    firstDataStructurePtr[5] = 0;\n    firstDataStructurePtr[6] = 0;\n    FUN_00081f00(firstDataStructurePtr + 0x17,0,8);\n    secondDataStructurePtr = *(undefined4 **)(dataStructuresPtr + 8);\n    firstDataStructurePtr[7] = firstDataStructurePtr;\n    firstDataStructurePtr[8] = 0x84221;\n    firstDataStructurePtr[9] = 0x84245;\n    firstDataStructurePtr[10] = 0x8427d;\n    firstDataStructurePtr[0xb] = &label2;\n    *(undefined2 *)((int)secondDataStructurePtr + 0xe) = 1;\n    *(undefined2 *)(secondDataStructurePtr + 3) = 9;\n    *secondDataStructurePtr = 0;\n    secondDataStructurePtr[1] = 0;\n    secondDataStructurePtr[2] = 0;\n    secondDataStructurePtr[0x19] = 0;\n    secondDataStructurePtr[4] = 0;\n    secondDataStructurePtr[5] = 0;\n    secondDataStructurePtr[6] = 0;\n    FUN_00081f00(secondDataStructurePtr + 0x17,0,8);\n    firstDataStructurePtr = *(undefined4 **)(dataStructuresPtr + 0xc);\n    secondDataStructurePtr[7] = secondDataStructurePtr;\n    secondDataStructurePtr[8] = 0x84221;\n    secondDataStructurePtr[9] = 0x84245;\n    secondDataStructurePtr[10] = 0x8427d;\n    secondDataStructurePtr[0xb] = &label2;\n    *(undefined2 *)(firstDataStructurePtr + 3) = 0x12;\n    *(undefined2 *)((int)firstDataStructurePtr + 0xe) = 2;\n    *firstDataStructurePtr = 0;\n    firstDataStructurePtr[1] = 0;\n    firstDataStructurePtr[2] = 0;\n    firstDataStructurePtr[0x19] = 0;\n    firstDataStructurePtr[4] = 0;\n    firstDataStructurePtr[5] = 0;\n    firstDataStructurePtr[6] = 0;\n    FUN_00081f00(firstDataStructurePtr + 0x17,0,8);\n    firstDataStructurePtr[7] = firstDataStructurePtr;\n    firstDataStructurePtr[8] = 0x84221;\n    firstDataStructurePtr[9] = 0x84245;\n    firstDataStructurePtr[10] = 0x8427d;\n    firstDataStructurePtr[0xb] = &label2;\n    *(undefined4 *)(dataStructuresPtr + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083888": "initialize_data_structures_00083888",
                "param_1": "dataStructuresPtr",
                "puVar1": "firstDataStructurePtr",
                "puVar2": "secondDataStructurePtr",
                "&LAB_0008387c_1": "&label1",
                "&LAB_0008429c_1": "&label2"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00084484",
                "FUN_000842a4"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008397c": {
            "entrypoint": "0x0008397c",
            "current_name": "FUNC_0008397c",
            "code": "\nvoid FUNC_0008397c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008397c": "FUNC_0008397c"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083980": {
            "entrypoint": "0x00083980",
            "current_name": "FUNC_00083980",
            "code": "\nvoid FUNC_00083980(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083980": "FUNC_00083980"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000839b4": {
            "entrypoint": "0x000839b4",
            "current_name": "process_data_000839b4",
            "code": "\nuint processData_000839b4(undefined4 status,uint length,byte **dataBuffer)\n\n{\n  int result;\n  uint isSuccess;\n  uint currentByte;\n  byte *currentData;\n  uint iteration;\n  byte tempByte;\n  byte tempBuffer [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(dataBuffer + 3) << 0x12)) {\n    *(ushort *)(dataBuffer + 3) = *(ushort *)(dataBuffer + 3) | 0x2000;\n    dataBuffer[0x19] = (byte *)((uint)dataBuffer[0x19] | 0x2000);\n  }\n  result = FUN_0008400c();\n  if ((result == 1) && (length - 1 < 0xff)) {\n    currentByte = length & 0xff;\n    tempByte = (byte)currentByte;\n    isSuccess = 1;\n  }\n  else {\n    isSuccess = FUN_0008434c(status,&tempByte,length,dataBuffer + 0x17);\n    if (isSuccess == 0xffffffff) {\n      *(ushort *)(dataBuffer + 3) = *(ushort *)(dataBuffer + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (isSuccess == 0) {\n      return length;\n    }\n    currentByte = (uint)tempByte;\n  }\n  iteration = 0;\n  do {\n    currentData = dataBuffer[2] + -1;\n    dataBuffer[2] = currentData;\n    if ((int)currentData < 0) {\n      if ((int)dataBuffer[6] <= (int)currentData) {\n        **dataBuffer = (byte)currentByte;\n        currentData = *dataBuffer;\n        currentByte = (uint)*currentData;\n        if (currentByte != 10) goto LAB_00083a04;\n      }\n      result = FUN_000842a4(status,currentByte,dataBuffer);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **dataBuffer = (byte)currentByte;\n      currentData = *dataBuffer;\nLAB_00083a04:\n      *dataBuffer = currentData + 1;\n    }\n    if (isSuccess <= iteration + 1) {\n      return length;\n    }\n    currentByte = (uint)tempBuffer[iteration];\n    iteration = iteration + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000839b4": "process_data_000839b4",
                "param_1": "status",
                "param_2": "length",
                "param_3": "dataBuffer",
                "iVar1": "result",
                "uVar2": "isSuccess",
                "uVar3": "currentByte",
                "pbVar4": "currentData",
                "uVar5": "iteration",
                "local_1c": "tempByte",
                "abStack_1b": "tempBuffer"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_0008434c",
                "FUN_0008400c",
                "FUN_000842a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083a74": {
            "entrypoint": "0x00083a74",
            "current_name": "relocate_memory_block_00083a74",
            "code": "\nundefined4 relocateMemoryBlock_00083a74(undefined4 param,int size)\n\n{\n  int result;\n  uint relInfo;\n  int newAddress;\n  \n  FUNC_00081f94();\n  relInfo = *(uint *)(relArray[141].r_info + 4) & 0xfffffffc;\n  newAddress = ((relInfo - size) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < newAddress) {\n    result = FUN_0008236c(param,0);\n    if (result == relArray[141].r_info + relInfo) {\n      result = FUN_0008236c(param,-newAddress);\n      if (result != -1) {\n        DAT_2007121c = DAT_2007121c - newAddress;\n        *(uint *)(relArray[141].r_info + 4) = relInfo - newAddress | 1;\n        FUNC_00081f98(param);\n        return 1;\n      }\n      newAddress = FUN_0008236c(param,0);\n      if (0xf < (int)(newAddress - relArray[141].r_info)) {\n        DAT_2007121c = newAddress - relArray[270].r_offset;\n        *(dword *)(relArray[141].r_info + 4) =\n             newAddress - relArray[141].r_info | 1;\n      }\n    }\n  }\n  FUNC_00081f98(param);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083a74": "relocate_memory_block_00083a74",
                "param_1": "param",
                "param_2": "size",
                "iVar1": "result",
                "uVar2": "relInfo",
                "iVar3": "newAddress",
                "Elf32_Rel_ARRAY_20070000": "relArray"
            },
            "calling": [
                "FUN_00083b10"
            ],
            "called": [
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_0008236c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b10": {
            "entrypoint": "0x00083b10",
            "current_name": "process_relocations_00083b10",
            "code": "\nvoid processRelocations_00083b10(undefined4 param1,int param2)\n\n{\n  int index1;\n  bool isVar2True;\n  uint value1;\n  dword address1;\n  int index2;\n  uint value2;\n  dword address2;\n  uint value3;\n  dword address3;\n  \n  if (param2 == 0) {\n    return;\n  }\n  FUNC_00081f94();\n  value1 = *(uint *)(param2 + -4);\n  address2 = param2 - 8;\n  value2 = value1 & 0xfffffffe;\n  address1 = address2 + value2;\n  value3 = *(uint *)(address1 + 4) & 0xfffffffc;\n  if (Elf32_Rel_ARRAY_20070000[141].r_info == address1) {\n    value3 = value3 + value2;\n    if (-1 < (int)(value1 << 0x1f)) {\n      address2 = address2 - *(int *)(param2 + -8);\n      index2 = *(int *)(address2 + 0xc);\n      index1 = *(int *)(address2 + 8);\n      value3 = value3 + *(int *)(param2 + -8);\n      *(int *)(index1 + 0xc) = index2;\n      *(int *)(index2 + 8) = index1;\n    }\n    address1 = Elf32_Rel_ARRAY_20070000[269].r_info;\n    *(uint *)(address2 + 4) = value3 | 1;\n    Elf32_Rel_ARRAY_20070000[141].r_info = address2;\n    if (address1 <= value3) {\n      FUN_00083a74(param1,DAT_20071218);\n    }\n  }\n  else {\n    *(uint *)(address1 + 4) = value3;\n    if ((value1 & 1) == 0) {\n      address2 = address2 - *(int *)(param2 + -8);\n      index1 = *(int *)(address2 + 8);\n      value2 = value2 + *(int *)(param2 + -8);\n      if (index1 == 0x2007046c) {\n        isVar2True = true;\n      }\n      else {\n        index2 = *(int *)(address2 + 0xc);\n        *(int *)(index1 + 0xc) = index2;\n        *(int *)(index2 + 8) = index1;\n        isVar2True = false;\n      }\n    }\n    else {\n      isVar2True = false;\n    }\n    if (-1 < *(int *)(address1 + value3 + 4) << 0x1f) {\n      value2 = value2 + value3;\n      index1 = *(int *)(address1 + 8);\n      if ((!isVar2True) && (index1 == 0x2007046c)) {\n        Elf32_Rel_ARRAY_20070000[142].r_info = address2;\n        Elf32_Rel_ARRAY_20070000[143].r_offset = address2;\n        *(undefined4 *)(address2 + 0xc) = 0x2007046c;\n        *(undefined4 *)(address2 + 8) = 0x2007046c;\n        *(uint *)(address2 + 4) = value2 | 1;\n        *(uint *)(address2 + value2) = value2;\n        goto LAB_00083ba4;\n      }\n      index2 = *(int *)(address1 + 0xc);\n      *(int *)(index1 + 0xc) = index2;\n      *(int *)(index2 + 8) = index1;\n    }\n    *(uint *)(address2 + 4) = value2 | 1;\n    *(uint *)(address2 + value2) = value2;\n    if (!isVar2True) {\n      if (value2 < 0x200) {\n        value1 = value2 & 0xfffffff8;\n        index1 = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + value1);\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << ((int)(value2 >> 3) >> 2 & 0xffU);\n        *(int *)(address2 + 8) = index1;\n        *(uint *)(address2 + 0xc) = value1 + 0x20070464;\n        *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + value1) = address2;\n        *(dword *)(index1 + 0xc) = address2;\n        FUNC_00081f98(param1);\n        return;\n      }\n      value1 = value2 >> 9;\n      if (value1 < 5) {\n        index1 = (value2 >> 6) + 0x38;\n        index2 = index1 * 2;\n      }\n      else if (value1 < 0x15) {\n        index1 = value1 + 0x5b;\n        index2 = index1 * 2;\n      }\n      else if (value1 < 0x55) {\n        index1 = (value2 >> 0xc) + 0x6e;\n        index2 = index1 * 2;\n      }\n      else if (value1 < 0x155) {\n        index1 = (value2 >> 0xf) + 0x77;\n        index2 = index1 * 2;\n      }\n      else if (value1 < 0x555) {\n        index1 = (value2 >> 0x12) + 0x7c;\n        index2 = index1 * 2;\n      }\n      else {\n        index2 = 0xfc;\n        index1 = 0x7e;\n      }\n      address3 = index2 * 4 + 0x20070464;\n      address1 = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[index2];\n      if (address1 == address3) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (index1 >> 2 & 0xffU);\n        address3 = address1;\n      }\n      else {\n        do {\n          if ((*(uint *)(address1 + 4) & 0xfffffffc) <= value2) break;\n          address1 = *(dword *)(address1 + 8);\n        } while (address3 != address1);\n        address3 = *(dword *)(address1 + 0xc);\n      }\n      *(dword *)(address2 + 0xc) = address3;\n      *(dword *)(address2 + 8) = address1;\n      *(dword *)(address3 + 8) = address2;\n      *(dword *)(address1 + 0xc) = address2;\n    }\n  }\nLAB_00083ba4:\n  FUNC_00081f98(param1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b10": "process_relocations_00083b10",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "index1",
                "bVar2": "isVar2True",
                "uVar3": "value1",
                "dVar4": "address1",
                "iVar5": "index2",
                "uVar6": "value2",
                "dVar7": "address2",
                "uVar8": "value3",
                "dVar9": "address3"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00081800",
                "FUN_00081810",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00084484",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_00083a74"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083ca8": {
            "entrypoint": "0x00083ca8",
            "current_name": "process_data_00083ca8",
            "code": "\nundefined4 processData_00083ca8(undefined4 *output_list,uint *input_data,uint **input_list)\n\n{\n  int result;\n  uint temp1;\n  uint temp2;\n  ushort flag;\n  uint value;\n  uint *ptr1;\n  uint *ptr2;\n  uint count;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  \n  if (input_list[2] != (uint *)0x0) {\n    flag = *(ushort *)(input_data + 3);\n    value = (uint)flag;\n    if (((int)(value << 0x1c) < 0) && (input_data[4] != 0)) {\n      ptr2 = *input_list;\n    }\n    else {\n      result = FUN_0008356c(output_list,input_data);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      flag = *(ushort *)(input_data + 3);\n      value = (uint)flag;\n      ptr2 = *input_list;\n    }\n    if ((flag & 2) == 0) {\n      temp1 = value & 2;\n      temp4 = temp1;\n      count = temp1;\n      temp6 = temp1;\n      if ((value & 1) == 0) {\n        temp1 = 0;\n        temp4 = 0;\n        while( true ) {\n          while (temp1 == 0) {\n            temp4 = *ptr2;\n            ptr1 = ptr2 + 1;\n            ptr2 = ptr2 + 2;\n            temp1 = *ptr1;\n          }\n          count = input_data[2];\n          if ((int)(value << 0x16) < 0) {\n            if (temp1 < count) {\n              value = *input_data;\n              count = temp1;\n            }\n            else if ((value & 0x480) == 0) {\n              value = *input_data;\n            }\n            else {\n              result = *input_data - input_data[4];\n              count = result + 1 + temp1;\n              temp3 = (int)(input_data[5] * 3) / 2;\n              if (count <= temp3) {\n                count = temp3;\n              }\n              if ((int)(value << 0x15) < 0) {\n                temp3 = FUN_00081810(output_list,count);\n                if (temp3 == 0) {\n                  *output_list = 0xc;\n                  flag = *(ushort *)(input_data + 3);\n                  goto LAB_00083da4;\n                }\n                FUN_00081d48(temp3,input_data[4],result);\n                *(ushort *)(input_data + 3) = *(ushort *)(input_data + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                temp3 = FUN_00081fac(output_list);\n                if (temp3 == 0) {\n                  FUN_00083b10(output_list,input_data[4]);\n                  flag = *(ushort *)(input_data + 3) & 0xff7f;\n                  *output_list = 0xc;\n                  goto LAB_00083da4;\n                }\n              }\n              value = temp3 + result;\n              input_data[4] = temp3;\n              input_data[5] = count;\n              *input_data = value;\n              input_data[2] = count - result;\n              count = temp1;\n            }\n            FUN_00081e34(value,temp4,count);\n            input_data[2] = input_data[2] - count;\n            *input_data = *input_data + count;\n            count = temp1;\n          }\n          else if ((input_data[4] < *input_data) || (value = input_data[5], temp1 < value)) {\n            if (temp1 < count) {\n              count = temp1;\n            }\n            FUN_00081e34(*input_data,temp4,count);\n            value = input_data[2];\n            input_data[2] = value - count;\n            *input_data = *input_data + count;\n            if ((value - count == 0) && (result = FUN_00083850(output_list,input_data), result != 0))\n            goto LAB_00083da2;\n          }\n          else {\n            count = 0x7fffffff;\n            if (temp1 < 0x7fffffff) {\n              count = temp1;\n            }\n            count = (*(code *)input_data[9])(output_list,input_data[7],temp4,(count / value) * value);\n            if ((int)count < 1) goto LAB_00083da2;\n          }\n          ptr1 = input_list[2];\n          temp4 = temp4 + count;\n          temp1 = temp1 - count;\n          input_list[2] = (uint *)((int)ptr1 - count);\n          if ((uint *)((int)ptr1 - count) == (uint *)0x0) break;\n          value = (uint)*(ushort *)(input_data + 3);\n        }\n      }\n      else {\n        do {\n          while (temp1 == 0) {\n            count = *ptr2;\n            temp1 = ptr2[1];\n            temp6 = 0;\n            ptr2 = ptr2 + 2;\n          }\n          if (temp6 == 0) {\n            result = FUN_000840f8(count,10,temp1);\n            if (result == 0) {\n              temp4 = temp1 + 1;\n              temp6 = 1;\n            }\n            else {\n              temp4 = (result + 1) - count;\n              temp6 = 1;\n            }\n          }\n          temp3 = *input_data;\n          value = temp4;\n          if (temp1 <= temp4) {\n            value = temp1;\n          }\n          temp2 = input_data[5];\n          if ((input_data[4] < temp3) && (temp5 = input_data[2] + temp2, (int)temp5 < (int)value)) {\n            FUN_00081e34(temp3,count,temp5);\n            *input_data = *input_data + temp5;\n            result = FUN_00083850(output_list,input_data);\n            if (result != 0) goto LAB_00083da2;\n          }\n          else if ((int)value < (int)temp2) {\n            FUN_00081e34(temp3,count,value);\n            input_data[2] = input_data[2] - value;\n            *input_data = value + *input_data;\n            temp5 = value;\n          }\n          else {\n            temp5 = (*(code *)input_data[9])(output_list,input_data[7],count,temp2);\n            if ((int)temp5 < 1) goto LAB_00083da2;\n          }\n          temp4 = temp4 - temp5;\n          if (temp4 == 0) {\n            result = FUN_00083850(output_list,input_data);\n            if (result != 0) goto LAB_00083da2;\n            temp6 = 0;\n          }\n          ptr1 = input_list[2];\n          count = count + temp5;\n          temp1 = temp1 - temp5;\n          input_list[2] = (uint *)((int)ptr1 - temp5);\n        } while ((uint *)((int)ptr1 - temp5) != (uint *)0x0);\n      }\n    }\n    else {\n      temp1 = 0;\n      value = 0;\n      do {\n        while( true ) {\n          temp4 = value;\n          if (0x7ffffbff < value) {\n            temp4 = 0x7ffffc00;\n          }\n          if (value != 0) break;\n          temp1 = *ptr2;\n          value = ptr2[1];\n          ptr2 = ptr2 + 2;\n        }\n        result = (*(code *)input_data[9])(output_list,input_data[7],temp1,temp4);\n        if (result < 1) {\nLAB_00083da2:\n          flag = *(ushort *)(input_data + 3);\nLAB_00083da4:\n          *(ushort *)(input_data + 3) = flag | 0x40;\n          return 0xffffffff;\n        }\n        ptr1 = input_list[2];\n        temp1 = temp1 + result;\n        value = value - result;\n        input_list[2] = (uint *)((int)ptr1 - result);\n      } while ((uint *)((int)ptr1 - result) != (uint *)0x0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083ca8": "process_data_00083ca8",
                "param_1": "output_list",
                "param_2": "input_data",
                "param_3": "input_list",
                "iVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "flag",
                "uVar5": "value",
                "puVar6": "ptr1",
                "puVar7": "ptr2",
                "uVar8": "count",
                "uVar9": "temp3",
                "uVar10": "temp4",
                "uVar11": "temp5",
                "local_2c": "temp6"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_00081d48",
                "FUN_00081fac",
                "FUN_00083b10",
                "FUN_00081810",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_000840f8",
                "FUN_00081e34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084004": {
            "entrypoint": "0x00084004",
            "current_name": "get_memory_address_00084004",
            "code": "\nuint32_t getMemoryAddress_00084004(void)\n\n{\n  return 0x20070878;\n}\n\n",
            "renaming": {
                "FUN_00084004": "get_memory_address_00084004",
                "undefined4": "uint32_t"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008400c": {
            "entrypoint": "0x0008400c",
            "current_name": "get_r_offset_value_0008400c",
            "code": "\ndword get_r_offset_value_0008400c(void)\n\n{\n  return rel_arrayindex.r_offset;\n}\n\n",
            "renaming": {
                "FUN_0008400c": "get_r_offset_value_0008400c",
                "Elf32_Rel_ARRAY_20070000": "rel_array",
                "[275]": "index"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084018": {
            "entrypoint": "0x00084018",
            "current_name": "check_and_process_data_00084018",
            "code": "\nvoid checkAndProcessData_00084018(int input,int *data)\n\n{\n  ushort dataValue;\n  int resultCode1;\n  int resultCode2;\n  uint dataValueUnsigned;\n  bool conditionMet;\n  undefined stackData [4];\n  uint localVariable;\n  \n  dataValue = *(ushort *)(data + 3);\n  dataValueUnsigned = (uint)dataValue;\n  if ((int)(dataValueUnsigned << 0x1e) < 0) {\n    *data = (int)data + 0x43;\n    data[4] = (int)data + 0x43;\n    data[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)data + 0xe)) {\n    resultCode1 = FUN_00084494(input,(int)*(short *)((int)data + 0xe),stackData);\n    if (-1 < resultCode1) {\n      conditionMet = (localVariable & 0xf000) == 0x2000;\n      if (((localVariable & 0xf000) == 0x8000) && (data[10] == 0x8427d)) {\n        resultCode1 = 0x400;\n        *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x400;\n        data[0x13] = 0x400;\n      }\n      else {\n        resultCode1 = 0x400;\n        *(ushort *)(data + 3) = *(ushort *)(data + 3) | 0x800;\n      }\n      goto processResult;\n    }\n    dataValue = *(ushort *)(data + 3);\n    dataValueUnsigned = (uint)dataValue;\n  }\n  *(ushort *)(data + 3) = dataValue | 0x800;\n  if ((dataValueUnsigned & 0x80) == 0) {\n    resultCode1 = 0x400;\n  }\n  else {\n    resultCode1 = 0x40;\n  }\n  conditionMet = false;\nprocessResult:\n  resultCode2 = FUN_00081810(input,resultCode1);\n  dataValue = *(ushort *)(data + 3);\n  if (resultCode2 == 0) {\n    if (-1 < (int)((uint)dataValue << 0x16)) {\n      *(ushort *)(data + 3) = dataValue | 2;\n      *data = (int)data + 0x43;\n      data[4] = (int)data + 0x43;\n      data[5] = 1;\n    }\n  }\n  else {\n    *(undefined **)(input + 0x3c) = &errorHandler;\n    *(ushort *)(data + 3) = dataValue | 0x80;\n    *data = resultCode2;\n    data[4] = resultCode2;\n    data[5] = resultCode1;\n    if ((conditionMet) && (resultCode1 = FUN_000844bc(input,(int)*(short *)((int)data + 0xe)), resultCode1 != 0))\n    {\n      *(ushort *)(data + 3) = *(ushort *)(data + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084018": "check_and_process_data_00084018",
                "param_1": "input",
                "param_2": "data",
                "uVar1": "dataValue",
                "iVar2": "resultCode1",
                "iVar3": "resultCode2",
                "uVar4": "dataValueUnsigned",
                "bVar5": "conditionMet",
                "auStack_54": "stackData",
                "local_50": "localVariable",
                "LAB_00084074": "processResult",
                "LAB_0008387c_1": "errorHandler"
            },
            "calling": [
                "FUN_0008356c"
            ],
            "called": [
                "FUN_00081810",
                "FUN_00084494",
                "FUN_000844bc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000840f8": {
            "entrypoint": "0x000840f8",
            "current_name": "search_character_000840f8",
            "code": "\nuint * search_character_000840f8(uint *input_array,char search_value,uint array_length)\n\n{\n  uint xor_result;\n  int iterator;\n  uint *current_ptr;\n  bool is_last_iteration;\n  \n  if (((uint)input_array & 3) == 0) {\nLAB_00084128:\n    if (3 < array_length) {\n      current_ptr = input_array;\n      do {\n        xor_result = *current_ptr ^ CONCAT22(CONCAT11(search_value,search_value),CONCAT11(search_value,search_value));\n        input_array = current_ptr;\n        if ((xor_result + 0xfefefeff & ~xor_result & 0x80808080) != 0) break;\n        array_length = array_length - 4;\n        input_array = current_ptr + 1;\n        current_ptr = current_ptr + 1;\n      } while (3 < array_length);\n    }\n    if (array_length == 0) {\n      input_array = (uint *)0x0;\n    }\n    else if (*(char *)input_array != search_value) {\n      iterator = 0;\n      do {\n        input_array = (uint *)((int)input_array + 1);\n        is_last_iteration = iterator == array_length - 1;\n        iterator = iterator + 1;\n        if (is_last_iteration) goto LAB_00084150;\n      } while (*(char *)input_array != search_value);\n    }\n  }\n  else if (array_length == 0) {\nLAB_00084150:\n    input_array = (uint *)0x0;\n  }\n  else if (*(char *)input_array != search_value) {\n    current_ptr = (uint *)((int)input_array + 1);\n    array_length = array_length - 1;\n    do {\n      input_array = current_ptr;\n      if (((uint)input_array & 3) == 0) goto LAB_00084128;\n      if (array_length == 0) goto LAB_00084150;\n      current_ptr = (uint *)((int)input_array + 1);\n      array_length = array_length - 1;\n    } while (*(char *)input_array != search_value);\n  }\n  return input_array;\n}\n\n",
            "renaming": {
                "FUN_000840f8": "search_character_000840f8",
                "param_1": "input_array",
                "param_2": "search_value",
                "param_3": "array_length",
                "uVar1": "xor_result",
                "iVar2": "iterator",
                "puVar3": "current_ptr",
                "bVar4": "is_last_iteration"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841e4": {
            "entrypoint": "0x000841e4",
            "current_name": "process_relocation_000841e4",
            "code": "\nint processRelocation_000841e4(uint index)\n\n{\n  dword relocationOffset;\n  undefined4 thunkResult;\n  int functionPointer;\n  code *function;\n  undefined4 unaff_r4;\n  undefined4 unaff_r5;\n  undefined4 in_lr;\n  undefined4 uVar5;\n  \n  relocationOffset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  uVar5 = 0x20070460;\n  if (0x1f < index) {\n    *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n    return -1;\n  }\n  functionPointer = *(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x2dc);\n  if ((functionPointer == 0) || (function = *(code **)(functionPointer + index * 4), function == (code *)0x0)) {\n    thunkResult = thunk_FUN_00080efe(Elf32_Rel_ARRAY_20070000[140].r_offset);\n    DAT_20071244 = 0;\n    functionPointer = FUNC_00080efc(thunkResult,index,index,0,uVar5,unaff_r4,unaff_r5,in_lr);\n    if ((functionPointer == -1) && (DAT_20071244 != 0)) {\n      *(int *)relocationOffset = DAT_20071244;\n      return -1;\n    }\n    return functionPointer;\n  }\n  if (function == (code *)0x1) {\n    return 0;\n  }\n  if (function != (code *)0xffffffff) {\n    *(undefined4 *)(functionPointer + index * 4) = 0;\n    (*function)(index);\n    return 0;\n  }\n  *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000841e4": "process_relocation_000841e4",
                "param_1": "index",
                "dVar1": "relocationOffset",
                "uVar2": "thunkResult",
                "iVar3": "functionPointer",
                "pcVar4": "function"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00080efc",
                "thunk_FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_00080efe": {
            "entrypoint": "0x0008421c",
            "current_name": "get_error_code_thunk_00080efe",
            "code": "\nuint32_t getErrorCode_thunk_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "thunk_FUN_00080efe": "get_error_code_thunk_00080efe",
                "undefined4": "uint32_t"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [
                "FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084220": {
            "entrypoint": "0x00084220",
            "current_name": "update_variable_based_on_return_value_00084220",
            "code": "\nvoid updateVariableBasedOnReturnValue_00084220(undefined4 param1,int param2)\n\n{\n  int returnValue;\n  \n  returnValue = FUN_00084508(param1,(int)*(short *)(param2 + 0xe));\n  if (-1 < returnValue) {\n    *(int *)(param2 + 0x50) = *(int *)(param2 + 0x50) + returnValue;\n    return;\n  }\n  *(ushort *)(param2 + 0xc) = *(ushort *)(param2 + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084220": "update_variable_based_on_return_value_00084220",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "returnValue"
            },
            "calling": [],
            "called": [
                "FUN_00084508"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084244": {
            "entrypoint": "0x00084244",
            "current_name": "update_data_and_check_error_00084244",
            "code": "\nvoid updateDataAndCheckError_00084244(int *outputArray,int inputPointer,undefined4 value1,undefined4 value2)\n\n{\n  int returnValue;\n  ushort extractedValue;\n  undefined4 tempVar1;\n  undefined4 tempVar2;\n  undefined4 tempVar3;\n  undefined4 tempVar4;\n  \n  extractedValue = *(ushort *)(inputPointer + 0xc);\n  if ((int)((uint)extractedValue << 0x17) < 0) {\n    FUN_000844e0(outputArray,(int)*(short *)(inputPointer + 0xe),0,2);\n    extractedValue = *(ushort *)(inputPointer + 0xc);\n  }\n  *(ushort *)(inputPointer + 0xc) = extractedValue & 0xefff;\n  DAT_20071244 = 0;\n  returnValue = FUN_00080ec8((int)*(short *)(inputPointer + 0xe),value1,value2,value2,tempVar1,tempVar2,\n                       tempVar3,tempVar4);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *outputArray = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084244": "update_data_and_check_error_00084244",
                "param_1": "outputArray",
                "param_2": "inputPointer",
                "param_3": "value1",
                "param_4": "value2",
                "iVar1": "returnValue",
                "uVar2": "extractedValue",
                "unaff_r4": "tempVar1",
                "unaff_r5": "tempVar2",
                "unaff_r6": "tempVar3",
                "in_lr": "tempVar4"
            },
            "calling": [],
            "called": [
                "FUN_00080ec8",
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008427c": {
            "entrypoint": "0x0008427c",
            "current_name": "update_parameter_status_0008427c",
            "code": "\nvoid updateParameterStatus_0008427c(undefined4 context,int dataBlock)\n\n{\n  int result;\n  ushort newStatus;\n  \n  result = FUN_000844e0(context,(int)*(short *)(dataBlock + 0xe));\n  if (result == -1) {\n    newStatus = *(ushort *)(dataBlock + 0xc) & 0xefff;\n  }\n  else {\n    newStatus = *(ushort *)(dataBlock + 0xc) | 0x1000;\n  }\n  if (result != -1) {\n    *(int *)(dataBlock + 0x50) = result;\n  }\n  *(ushort *)(dataBlock + 0xc) = newStatus;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008427c": "update_parameter_status_0008427c",
                "param_1": "context",
                "param_2": "dataBlock",
                "iVar1": "result",
                "uVar2": "newStatus"
            },
            "calling": [],
            "called": [
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "process_data_000842a4",
            "code": "\nuint processData_000842a4(int data,uint value,undefined4 *buffer,undefined4 length)\n\n{\n  ushort header;\n  uint headerValue;\n  undefined *bufferPtr;\n  int offset;\n  \n  if ((data != 0) && (*(int *)(data + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  header = *(ushort *)(buffer + 3);\n  headerValue = (uint)header;\n  buffer[2] = buffer[6];\n  if ((-1 < (int)(headerValue << 0x1c)) || (offset = buffer[4], offset == 0)) {\n    offset = FUN_0008356c(data,buffer,header,headerValue,length);\n    if (offset != 0) {\n      return 0xffffffff;\n    }\n    header = *(ushort *)(buffer + 3);\n    offset = buffer[4];\n    headerValue = (uint)header;\n  }\n  value = value & 0xff;\n  if ((int)(headerValue << 0x12) < 0) {\n    bufferPtr = (undefined *)*buffer;\n    offset = (int)bufferPtr - offset;\n    if (offset < (int)buffer[5]) {\nLAB_000842d6:\n      offset = offset + 1;\n      goto LAB_000842d8;\n    }\n  }\n  else {\n    buffer[0x19] = buffer[0x19] & 0xffffdfff;\n    bufferPtr = (undefined *)*buffer;\n    *(ushort *)(buffer + 3) = header | 0x2000;\n    offset = (int)bufferPtr - offset;\n    if (offset < (int)buffer[5]) goto LAB_000842d6;\n  }\n  offset = FUN_00083850(data,buffer);\n  if (offset != 0) {\n    return 0xffffffff;\n  }\n  bufferPtr = (undefined *)*buffer;\n  offset = 1;\nLAB_000842d8:\n  buffer[2] = buffer[2] + -1;\n  *buffer = bufferPtr + 1;\n  *bufferPtr = (char)value;\n  if (((buffer[5] == offset) ||\n      (((int)((uint)*(ushort *)(buffer + 3) << 0x1f) < 0 && (value == 10)))) &&\n     (offset = FUN_00083850(data,buffer), offset != 0)) {\n    return 0xffffffff;\n  }\n  return value;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "process_data_000842a4",
                "param_1": "data",
                "param_2": "value",
                "param_3": "buffer",
                "param_4": "length",
                "uVar1": "header",
                "uVar2": "headerValue",
                "puVar3": "bufferPtr",
                "iVar4": "offset"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008434c": {
            "entrypoint": "0x0008434c",
            "current_name": "execute_relocation_0008434c",
            "code": "\nvoid executeRelocation_0008434c(undefined4 *result,int numInputs,undefined4 input,undefined4 *status)\n\n{\n  dword relocationInfo;\n  undefined4 auxiliaryVar;\n  int resultValue;\n  undefined temporaryStorage [12];\n  \n  relocationInfo = Elf32_Rel_ARRAY_20070000[275].r_info;\n  if (numInputs == 0) {\n    auxiliaryVar = FUN_00084004();\n    resultValue = (*(code *)relocationInfo)(result,temporaryStorage,0,auxiliaryVar,status);\n  }\n  else {\n    auxiliaryVar = FUN_00084004();\n    resultValue = (*(code *)relocationInfo)(result,numInputs,input,auxiliaryVar,status);\n  }\n  if (resultValue == -1) {\n    *status = 0;\n    *result = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008434c": "execute_relocation_0008434c",
                "param_1": "result",
                "param_2": "numInputs",
                "param_3": "input",
                "param_4": "status",
                "dVar1": "relocationInfo",
                "uVar2": "auxiliaryVar",
                "iVar3": "resultValue",
                "auStack_24": "temporaryStorage"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008439c",
                "FUN_00084004"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008439c": {
            "entrypoint": "0x0008439c",
            "current_name": "copy_byte_to_memory_0008439c",
            "code": "\nundefined4 copy_byte_to_memory_0008439c(undefined4 *destination,undefined *source,uint value)\n\n{\n  if (source == (undefined *)0x0) {\n    return 0;\n  }\n  if (value < 0x100) {\n    *source = (char)value;\n    return 1;\n  }\n  *destination = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0008439c": "copy_byte_to_memory_0008439c",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "value"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084484": {
            "entrypoint": "0x00084484",
            "current_name": "validate_and_process_data_00084484",
            "code": "\nundefined4 validate_and_process_data_00084484(int data_ptr)\n\n{\n  dword offset;\n  undefined4 result;\n  int status;\n  \n  offset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  if (data_ptr != 0) {\n    if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n       (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n      FUN_00083888();\n    }\n    if (*(short *)(data_ptr + 0xc) != 0) {\n      result = FUN_00083850(offset,data_ptr);\n      if ((*(code **)(data_ptr + 0x2c) != (code *)0x0) &&\n         (status = (**(code **)(data_ptr + 0x2c))(offset,*(undefined4 *)(data_ptr + 0x1c)), status < 0))\n      {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(data_ptr + 0xc) << 0x18) < 0) {\n        FUN_00083b10(offset,*(undefined4 *)(data_ptr + 0x10));\n      }\n      if (*(int *)(data_ptr + 0x30) != 0) {\n        if (*(int *)(data_ptr + 0x30) != data_ptr + 0x40) {\n          FUN_00083b10(offset);\n        }\n        *(undefined4 *)(data_ptr + 0x30) = 0;\n      }\n      if (*(int *)(data_ptr + 0x44) != 0) {\n        FUN_00083b10(offset);\n        *(undefined4 *)(data_ptr + 0x44) = 0;\n      }\n      FUNC_0008397c();\n      *(undefined2 *)(data_ptr + 0xc) = 0;\n      FUNC_00083980();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084484": "validate_and_process_data_00084484",
                "param_1": "data_ptr",
                "dVar1": "offset",
                "uVar2": "result",
                "iVar3": "status"
            },
            "calling": [],
            "called": [
                "FUN_00083b10",
                "FUN_00083850",
                "FUN_00083980",
                "FUN_0008397c",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084494": {
            "entrypoint": "0x00084494",
            "current_name": "check_and_assign_value_00084494",
            "code": "\nvoid checkAndAssignValue_00084494(int *output,undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  int returnValue;\n  \n  DAT_20071244 = 0;\n  returnValue = FUN_00080eb0(input1,input2,input2,0,input3);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *output = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084494": "check_and_assign_value_00084494",
                "param_1": "output",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eb0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "check_and_assign_value_000844bc",
            "code": "\nvoid checkAndAssignValue_000844bc(int *result,undefined4 inputValue)\n\n{\n  int checkResult;\n  \n  DAT_20071244 = 0;\n  checkResult = FUN_00080eba(inputValue);\n  if ((checkResult == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "check_and_assign_value_000844bc",
                "param_1": "result",
                "param_2": "inputValue",
                "iVar1": "checkResult"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844e0": {
            "entrypoint": "0x000844e0",
            "current_name": "extract_binary_value_000844e0",
            "code": "\nvoid extractBinaryValue_000844e0(int *output,undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  int result;\n  \n  DAT_20071244 = 0;\n  result = FUN_00080ebe(input1,input2,input3);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *output = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844e0": "extract_binary_value_000844e0",
                "param_1": "output",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3",
                "iVar1": "result"
            },
            "calling": [
                "FUN_0008427c",
                "FUN_00084244"
            ],
            "called": [
                "FUN_00080ebe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084508": {
            "entrypoint": "0x00084508",
            "current_name": "check_error_and_assign_00084508",
            "code": "\nvoid checkErrorAndAssign_00084508(int *result,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  int returnValue;\n  \n  DAT_20071244 = 0;\n  returnValue = FUN_00080ec2(arg1,arg2,arg3);\n  if ((returnValue == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084508": "check_error_and_assign_00084508",
                "param_1": "result",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_00084220"
            ],
            "called": [
                "FUN_00080ec2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084530": {
            "entrypoint": "0x00084530",
            "current_name": "check_params_00084530",
            "code": "\nint checkParams_00084530(int inputParam1,int inputParam2,int inputParam3,int inputParam4)\n\n{\n  int result;\n  \n  if ((inputParam4 == 0) && (inputParam3 == 0)) {\n    if (inputParam2 != 0 || inputParam1 != 0) {\n      inputParam1 = -1;\n    }\n    return inputParam1;\n  }\n  result = FUN_0008458c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00084530": "check_params_00084530",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "param_3": "inputParam3",
                "param_4": "inputParam4",
                "iVar1": "result"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008458c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008455c": {
            "entrypoint": "0x0008455c",
            "current_name": "subtract_and_assign_0008455c",
            "code": "\nvoid subtractAndAssign_0008455c(uint input,int param2,undefined4 param3,undefined4 param4,int *output)\n\n{\n  uint result;\n  longlong temp;\n  \n  temp = FUN_000845c0();\n  temp = temp * CONCAT44(param4,param3);\n  result = (uint)temp;\n  *output = input - result;\n  output[1] = (param2 - (int)((ulonglong)temp >> 0x20)) - (uint)(input < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008455c": "subtract_and_assign_0008455c",
                "param_1": "input",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "output",
                "uVar1": "result",
                "lVar2": "temp"
            },
            "calling": [],
            "called": [
                "FUN_000845c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008458c": {
            "entrypoint": "0x0008458c",
            "current_name": "calculate_difference_0008458c",
            "code": "\nvoid calculateDifference_0008458c(uint inputValue,int param2,undefined4 param3,undefined4 param4,int *resultArray)\n\n{\n  uint calculationResult;\n  longlong multiplicationResult;\n  \n  multiplicationResult = FUN_00084860();\n  multiplicationResult = multiplicationResult * CONCAT44(param4,param3);\n  calculationResult = (uint)multiplicationResult;\n  *resultArray = inputValue - calculationResult;\n  resultArray[1] = (param2 - (int)((ulonglong)multiplicationResult >> 0x20)) - (uint)(inputValue < calculationResult);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008458c": "calculate_difference_0008458c",
                "param_1": "inputValue",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "resultArray",
                "uVar1": "calculationResult",
                "lVar2": "multiplicationResult"
            },
            "calling": [
                "FUN_00084530"
            ],
            "called": [
                "FUN_00084860"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845c0": {
            "entrypoint": "0x000845c0",
            "current_name": "divide_with_carry_000845c0",
            "code": "\nundefined8 divideWithCarry_000845c0(uint dividend,uint dividend_high,uint divisor,uint divisor_high)\n\n{\n  longlong quotient;\n  uint quotient_low;\n  uint quotient_high;\n  uint temp1;\n  uint temp2;\n  int iVar6;\n  uint temp3;\n  uint temp4;\n  uint negate_dividend_high;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  bool carry;\n  \n  if ((int)dividend_high < 0) {\n    carry = dividend != 0;\n    dividend = -dividend;\n    dividend_high = -dividend_high - (uint)carry;\n    negate_dividend_high = 0xffffffff;\n  }\n  else {\n    negate_dividend_high = 0;\n  }\n  if ((int)divisor_high < 0) {\n    negate_dividend_high = ~negate_dividend_high;\n    carry = divisor != 0;\n    divisor = -divisor;\n    divisor_high = -divisor_high - (uint)carry;\n  }\n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      iVar6 = LZCOUNT(divisor);\n      if (iVar6 != 0) {\n        quotient_high = dividend >> (0x20U - iVar6 & 0xff);\n        divisor = divisor << iVar6;\n        dividend = dividend << iVar6;\n        dividend_high = dividend_high << iVar6 | quotient_high;\n      }\n      quotient_low = divisor >> 0x10;\n      temp1 = dividend_high / quotient_low;\n      temp3 = (divisor & 0xffff) * temp1;\n      temp5 = dividend >> 0x10 | (dividend_high - quotient_low * temp1) * 0x10000;\n      quotient_high = temp1;\n      if (temp5 <= temp3 && temp3 - temp5 != 0) {\n        carry = CARRY4(temp5,divisor);\n        temp5 = temp5 + divisor;\n        quotient_high = temp1 - 1;\n        if ((carry == false) && (temp5 <= temp3 && temp3 - temp5 != 0)) {\n          quotient_high = temp1 - 2;\n          temp5 = temp5 + divisor;\n        }\n      }\n      temp4 = (temp5 - temp3) / quotient_low;\n      temp1 = (divisor & 0xffff) * temp4;\n      temp3 = dividend & 0xffff | ((temp5 - temp3) - quotient_low * temp4) * 0x10000;\n      quotient_low = temp4;\n      if (temp3 <= temp1 && temp1 - temp3 != 0) {\n        quotient_low = temp4 - 1;\n        if ((CARRY4(temp3,divisor) == false) &&\n           (temp3 + divisor <= temp1 && temp1 - (temp3 + divisor) != 0)) {\n          quotient_low = temp4 - 2;\n        }\n      }\n      quotient_low = quotient_low | quotient_high << 0x10;\n      quotient_high = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      iVar6 = LZCOUNT(divisor);\n      if (iVar6 == 0) {\n        dividend_high = dividend_high - divisor;\n        temp1 = divisor >> 0x10;\n        temp7 = divisor & 0xffff;\n        quotient_high = 1;\n      }\n      else {\n        divisor = divisor << iVar6;\n        quotient_high = dividend_high >> (0x20U - iVar6 & 0xff);\n        temp1 = divisor >> 0x10;\n        temp5 = quotient_high / temp1;\n        temp7 = divisor & 0xffff;\n        temp3 = temp7 * temp5;\n        temp4 = dividend >> (0x20U - iVar6 & 0xff) | dividend_high << iVar6;\n        quotient_high = temp4 >> 0x10 | (quotient_high - temp1 * temp5) * 0x10000;\n        dividend = dividend << iVar6;\n        quotient_low = temp5;\n        if (quotient_high <= temp3 && temp3 - quotient_high != 0) {\n          carry = CARRY4(quotient_high,divisor);\n          quotient_high = quotient_high + divisor;\n          quotient_low = temp5 - 1;\n          if ((carry == false) && (quotient_high <= temp3 && temp3 - quotient_high != 0)) {\n            quotient_low = temp5 - 2;\n            quotient_high = quotient_high + divisor;\n          }\n        }\n        temp2 = (quotient_high - temp3) / temp1;\n        temp5 = temp7 * temp2;\n        dividend_high = temp4 & 0xffff | ((quotient_high - temp3) - temp1 * temp2) * 0x10000;\n        quotient_high = temp2;\n        if (dividend_high <= temp5 && temp5 - dividend_high != 0) {\n          carry = CARRY4(dividend_high,divisor);\n          dividend_high = dividend_high + divisor;\n          quotient_high = temp2 - 1;\n          if ((carry == false) && (dividend_high <= temp5 && temp5 - dividend_high != 0)) {\n            quotient_high = temp2 - 2;\n            dividend_high = dividend_high + divisor;\n          }\n        }\n        dividend_high = dividend_high - temp5;\n        quotient_high = quotient_high | quotient_low << 0x10;\n      }\n      quotient_low = dividend_high / temp1;\n      temp5 = temp7 * quotient_low;\n      temp4 = dividend >> 0x10 | (dividend_high - temp1 * quotient_low) * 0x10000;\n      temp3 = quotient_low;\n      if (temp4 <= temp5 && temp5 - temp4 != 0) {\n        carry = CARRY4(temp4,divisor);\n        temp4 = temp4 + divisor;\n        temp3 = quotient_low - 1;\n        if ((carry == false) && (temp4 <= temp5 && temp5 - temp4 != 0)) {\n          temp3 = quotient_low - 2;\n          temp4 = temp4 + divisor;\n        }\n      }\n      temp2 = (temp4 - temp5) / temp1;\n      temp7 = temp7 * temp2;\n      temp1 = dividend & 0xffff | ((temp4 - temp5) - temp1 * temp2) * 0x10000;\n      quotient_low = temp2;\n      if (temp1 <= temp7 && temp7 - temp1 != 0) {\n        quotient_low = temp2 - 1;\n        if ((CARRY4(temp1,divisor) == false) &&\n           (temp1 + divisor <= temp7 && temp7 - (temp1 + divisor) != 0)) {\n          quotient_low = temp2 - 2;\n        }\n      }\n      quotient_low = quotient_low | temp3 << 0x10;\n    }\n  }\n  else if (dividend_high < divisor_high) {\n    quotient_high = 0;\n    quotient_low = 0;\n  }\n  else {\n    iVar6 = LZCOUNT(divisor_high);\n    if (iVar6 == 0) {\n      if ((divisor_high < dividend_high) || (divisor <= dividend)) {\n        quotient_high = 0;\n        quotient_low = 1;\n      }\n      else {\n        quotient_low = 0;\n        quotient_high = 0;\n      }\n    }\n    else {\n      quotient_high = 0x20 - iVar6;\n      temp1 = dividend_high >> (quotient_high & 0xff);\n      temp7 = divisor >> (quotient_high & 0xff) | divisor_high << iVar6;\n      temp5 = temp7 >> 0x10;\n      quotient_low = temp1 / temp5;\n      temp4 = (temp7 & 0xffff) * quotient_low;\n      temp3 = dividend_high << iVar6 | dividend >> (quotient_high & 0xff);\n      temp1 = temp3 >> 0x10 | (temp1 - temp5 * quotient_low) * 0x10000;\n      quotient_high = quotient_low;\n      if (temp1 <= temp4 && temp4 - temp1 != 0) {\n        carry = CARRY4(temp1,temp7);\n        temp1 = temp1 + temp7;\n        quotient_high = quotient_low - 1;\n        if ((carry == false) && (temp1 <= temp4 && temp4 - temp1 != 0)) {\n          quotient_high = quotient_low - 2;\n          temp1 = temp1 + temp7;\n        }\n      }\n      temp2 = (temp1 - temp4) / temp5;\n      temp6 = (temp7 & 0xffff) * temp2;\n      temp1 = temp3 & 0xffff | ((temp1 - temp4) - temp5 * temp2) * 0x10000;\n      quotient_low = temp2;\n      if (temp1 <= temp6 && temp6 - temp1 != 0) {\n        carry = CARRY4(temp1,temp7);\n        temp1 = temp1 + temp7;\n        quotient_low = temp2 - 1;\n        if ((carry == false) && (temp1 <= temp6 && temp6 - temp1 != 0)) {\n          quotient_low = temp2 - 2;\n          temp1 = temp1 + temp7;\n        }\n      }\n      quotient_low = quotient_low | quotient_high << 0x10;\n      quotient = (ulonglong)quotient_low * (ulonglong)(divisor << iVar6);\n      temp3 = (uint)((ulonglong)quotient >> 0x20);\n      quotient_high = 0;\n      if ((temp1 - temp6 < temp3) ||\n         ((temp1 - temp6 == temp3 && (dividend << iVar6 < (uint)quotient)))) {\n        quotient_low = quotient_low - 1;\n        quotient_high = 0;\n      }\n    }\n  }\n  if (negate_dividend_high != 0) {\n    carry = quotient_low != 0;\n    quotient_low = -quotient_low;\n    quotient_high = -quotient_high - (uint)carry;\n  }\n  return CONCAT44(quotient_high,quotient_low);\n}\n\n",
            "renaming": {
                "FUN_000845c0": "divide_with_carry_000845c0",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "lVar1": "quotient",
                "uVar2": "quotient_low",
                "uVar3": "quotient_high",
                "uVar4": "temp1",
                "uVar5": "temp2",
                "uVar7": "temp3",
                "uVar8": "temp4",
                "uVar9": "negate_dividend_high",
                "uVar10": "temp5",
                "uVar11": "temp6",
                "uVar12": "temp7",
                "bVar13": "carry"
            },
            "calling": [
                "FUN_0008455c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084860": {
            "entrypoint": "0x00084860",
            "current_name": "perform_division_00084860",
            "code": "\nulonglong performDivision_00084860(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong product;\n  uint partialQuotient;\n  uint quotientDivisor;\n  uint quotientDividend;\n  uint partialProduct;\n  uint dividendHigh;\n  uint divisorHigh;\n  uint tempValue1;\n  uint tempValue2;\n  int shiftAmount;\n  bool isCarry;\n  \n  if (remainder == 0) {\n    if (quotient <= divisor) {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      shiftAmount = LZCOUNT(quotient);\n      if (shiftAmount == 0) {\n        divisor = divisor - quotient;\n        quotientDivisor = quotient >> 0x10;\n        partialProduct = quotient & 0xffff;\n        partialQuotient = 1;\n      }\n      else {\n        quotient = quotient << shiftAmount;\n        tempValue1 = divisor >> (0x20U - shiftAmount & 0xff);\n        quotientDivisor = quotient >> 0x10;\n        tempValue2 = tempValue1 / quotientDivisor;\n        partialProduct = quotient & 0xffff;\n        partialQuotient = partialProduct * tempValue2;\n        dividendHigh = dividend >> (0x20U - shiftAmount & 0xff) | divisor << shiftAmount;\n        quotientDividend = dividendHigh >> 0x10 | (tempValue1 - quotientDivisor * tempValue2) * 0x10000;\n        dividend = dividend << shiftAmount;\n        tempValue1 = tempValue2;\n        if (quotientDividend <= partialQuotient && partialQuotient - quotientDividend != 0) {\n          isCarry = CARRY4(quotientDividend,quotient);\n          quotientDividend = quotientDividend + quotient;\n          tempValue1 = tempValue2 - 1;\n          if ((isCarry == false) && (quotientDividend <= partialQuotient && partialQuotient - quotientDividend != 0)) {\n            tempValue1 = tempValue2 - 2;\n            quotientDividend = quotientDividend + quotient;\n          }\n        }\n        divisorHigh = (quotientDividend - partialQuotient) / quotientDivisor;\n        tempValue2 = partialProduct * divisorHigh;\n        divisor = dividendHigh & 0xffff | ((quotientDividend - partialQuotient) - quotientDivisor * divisorHigh) * 0x10000;\n        partialQuotient = divisorHigh;\n        if (divisor <= tempValue2 && tempValue2 - divisor != 0) {\n          isCarry = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          partialQuotient = divisorHigh - 1;\n          if ((isCarry == false) && (divisor <= tempValue2 && tempValue2 - divisor != 0)) {\n            partialQuotient = divisorHigh - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - tempValue2;\n        partialQuotient = partialQuotient | tempValue1 << 0x10;\n      }\n      tempValue2 = divisor / quotientDivisor;\n      quotientDividend = partialProduct * tempValue2;\n      dividendHigh = dividend >> 0x10 | (divisor - quotientDivisor * tempValue2) * 0x10000;\n      tempValue1 = tempValue2;\n      if (dividendHigh <= quotientDividend && quotientDividend - dividendHigh != 0) {\n        isCarry = CARRY4(dividendHigh,quotient);\n        dividendHigh = dividendHigh + quotient;\n        tempValue1 = tempValue2 - 1;\n        if ((isCarry == false) && (dividendHigh <= quotientDividend && quotientDividend - dividendHigh != 0)) {\n          tempValue1 = tempValue2 - 2;\n          dividendHigh = dividendHigh + quotient;\n        }\n      }\n      tempValue2 = (dividendHigh - quotientDividend) / quotientDivisor;\n      partialProduct = partialProduct * tempValue2;\n      dividendHigh = dividend & 0xffff | ((dividendHigh - quotientDividend) - quotientDivisor * tempValue2) * 0x10000;\n      quotientDivisor = tempValue2;\n      if (dividendHigh <= partialProduct && partialProduct - dividendHigh != 0) {\n        quotientDivisor = tempValue2 - 1;\n        if ((CARRY4(dividendHigh,quotient) == false) &&\n           (dividendHigh + quotient <= partialProduct && partialProduct - (dividendHigh + quotient) != 0)) {\n          quotientDivisor = tempValue2 - 2;\n        }\n      }\n      return CONCAT44(partialQuotient,quotientDivisor | tempValue1 << 0x10);\n    }\n    shiftAmount = LZCOUNT(quotient);\n    if (shiftAmount != 0) {\n      tempValue1 = dividend >> (0x20U - shiftAmount & 0xff);\n      quotient = quotient << shiftAmount;\n      dividend = dividend << shiftAmount;\n      divisor = tempValue1 | divisor << shiftAmount;\n    }\n    partialQuotient = quotient >> 0x10;\n    quotientDivisor = divisor / partialQuotient;\n    partialProduct = (quotient & 0xffff) * quotientDivisor;\n    tempValue2 = dividend >> 0x10 | (divisor - partialQuotient * quotientDivisor) * 0x10000;\n    tempValue1 = quotientDivisor;\n    if (tempValue2 <= partialProduct && partialProduct - tempValue2 != 0) {\n      isCarry = CARRY4(tempValue2,quotient);\n      tempValue2 = tempValue2 + quotient;\n      tempValue1 = quotientDivisor - 1;\n      if ((isCarry == false) && (tempValue2 <= partialProduct && partialProduct - tempValue2 != 0)) {\n        tempValue1 = quotientDivisor - 2;\n        tempValue2 = tempValue2 + quotient;\n      }\n    }\n    dividendHigh = (tempValue2 - partialProduct) / partialQuotient;\n    quotientDivisor = (quotient & 0xffff) * dividendHigh;\n    partialProduct = dividend & 0xffff | ((tempValue2 - partialProduct) - partialQuotient * dividendHigh) * 0x10000;\n    partialQuotient = dividendHigh;\n    if (partialProduct <= quotientDivisor && quotientDivisor - partialProduct != 0) {\n      partialQuotient = dividendHigh - 1;\n      if ((CARRY4(partialProduct,quotient) == false) &&\n         (partialProduct + quotient <= quotientDivisor && quotientDivisor - (partialProduct + quotient) != 0)) {\n        partialQuotient = dividendHigh - 2;\n      }\n    }\n    partialQuotient = partialQuotient | tempValue1 << 0x10;\n  }\n  else {\n    if (divisor < remainder) {\n      return 0;\n    }\n    shiftAmount = LZCOUNT(remainder);\n    if (shiftAmount == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        return 1;\n      }\n      partialQuotient = 0;\n    }\n    else {\n      partialQuotient = 0x20 - shiftAmount;\n      tempValue1 = divisor >> (partialQuotient & 0xff);\n      quotientDivisor = remainder << shiftAmount | quotient >> (partialQuotient & 0xff);\n      partialProduct = quotientDivisor >> 0x10;\n      quotientDividend = tempValue1 / partialProduct;\n      tempValue2 = (quotientDivisor & 0xffff) * quotientDividend;\n      dividendHigh = dividend >> (partialQuotient & 0xff) | divisor << shiftAmount;\n      partialQuotient = dividendHigh >> 0x10 | (tempValue1 - partialProduct * quotientDividend) * 0x10000;\n      tempValue1 = quotientDividend;\n      if (partialQuotient <= tempValue2 && tempValue2 - partialQuotient != 0) {\n        isCarry = CARRY4(partialQuotient,quotientDivisor);\n        partialQuotient = partialQuotient + quotientDivisor;\n        tempValue1 = quotientDividend - 1;\n        if ((isCarry == false) && (partialQuotient <= tempValue2 && tempValue2 - partialQuotient != 0)) {\n          tempValue1 = quotientDividend - 2;\n          partialQuotient = partialQuotient + quotientDivisor;\n        }\n      }\n      quotientDividend = (partialQuotient - tempValue2) / partialProduct;\n      divisorHigh = (quotientDivisor & 0xffff) * quotientDividend;\n      partialProduct = dividendHigh & 0xffff | ((partialQuotient - tempValue2) - partialProduct * quotientDividend) * 0x10000;\n      partialQuotient = quotientDividend;\n      if (partialProduct <= divisorHigh && divisorHigh - partialProduct != 0) {\n        isCarry = CARRY4(partialProduct,quotientDivisor);\n        partialProduct = partialProduct + quotientDivisor;\n        partialQuotient = quotientDividend - 1;\n        if ((isCarry == false) && (partialProduct <= divisorHigh && divisorHigh - partialProduct != 0)) {\n          partialQuotient = quotientDividend - 2;\n          partialProduct = partialProduct + quotientDivisor;\n        }\n      }\n      partialQuotient = partialQuotient | tempValue1 << 0x10;\n      product = (ulonglong)partialQuotient * (ulonglong)(quotient << shiftAmount);\n      tempValue1 = (uint)((ulonglong)product >> 0x20);\n      if ((partialProduct - divisorHigh < tempValue1) || ((partialProduct - divisorHigh == tempValue1 && (dividend << shiftAmount < (uint)product)))\n         ) {\n        partialQuotient = partialQuotient - 1;\n      }\n    }\n  }\n  return (ulonglong)partialQuotient;\n}\n\n",
            "renaming": {
                "FUN_00084860": "perform_division_00084860",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "product",
                "uVar2": "partialQuotient",
                "uVar3": "quotientDivisor",
                "uVar4": "quotientDividend",
                "uVar5": "partialProduct",
                "uVar6": "dividendHigh",
                "uVar7": "divisorHigh",
                "uVar8": "tempValue1",
                "uVar9": "tempValue2",
                "iVar10": "shiftAmount",
                "bVar11": "isCarry"
            },
            "calling": [
                "FUN_0008458c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085844": {
            "entrypoint": "0x00085844",
            "current_name": "FUNC_00085844",
            "code": "\nvoid FUNC_00085844(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085844": "FUNC_00085844"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 104443,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080164",
            "FUN_000801e0",
            "FUN_00080250",
            "FUN_000803fc",
            "FUN_0008044c",
            "FUN_000805a8",
            "FUN_000806a0",
            "FUN_000806f8",
            "FUN_00080774",
            "FUN_0008089c",
            "FUN_00080970",
            "FUN_000809be",
            "FUN_000809e4",
            "FUN_00080a0a",
            "FUN_00080a30",
            "FUN_00080a94",
            "FUN_00080aa8",
            "FUN_00080b2c",
            "FUN_00080b90",
            "FUN_00080b98",
            "FUN_00080c98",
            "FUN_00080d30",
            "FUN_00080d3e",
            "FUN_00080d58",
            "FUN_00080d62",
            "FUN_00080d6a",
            "FUN_00080e80",
            "FUN_00080e88",
            "FUN_00080eaa",
            "FUN_00080eb0",
            "FUN_00080eba",
            "FUN_00080ebe",
            "FUN_00080ec2",
            "FUN_00080ec8",
            "FUN_00080eec",
            "FUN_00080efe",
            "thunk_FUN_000816d8",
            "FUN_00080f0c",
            "FUN_00081014",
            "FUN_000810a6",
            "FUN_000810c4",
            "FUN_000810cc",
            "FUN_000810d8",
            "FUN_000810e8",
            "FUN_000810fc",
            "FUN_0008113a",
            "thunk_FUN_0008113a",
            "FUN_0008117a",
            "FUN_00081190",
            "FUN_000811b0",
            "FUN_000811ca",
            "FUN_000811e8",
            "FUN_00081214",
            "FUN_00081248",
            "FUN_00081276",
            "FUN_000812b8",
            "FUN_00081348",
            "FUN_000813dc",
            "FUN_00081438",
            "FUN_0008145c",
            "FUN_00081472",
            "FUN_00081480",
            "FUN_00081496",
            "FUN_000814ae",
            "FUN_000814d0",
            "FUN_000814f6",
            "FUN_0008151c",
            "FUN_00081560",
            "FUN_00081570",
            "FUN_0008159e",
            "FUN_000815b8",
            "FUN_000815de",
            "FUN_000815ec",
            "FUN_00081618",
            "FUN_00081624",
            "FUN_00081684",
            "FUN_000816d8",
            "FUN_000816ec",
            "FUN_000816f8",
            "FUN_00081750",
            "FUN_00081778",
            "FUN_000817c8",
            "FUN_000817f0",
            "FUN_00081800",
            "FUN_00081810",
            "FUN_00081d48",
            "FUN_00081e34",
            "FUN_00081f00",
            "FUN_00081f9c",
            "FUN_00081fac",
            "FUN_0008236c",
            "FUN_00082390",
            "FUN_000825cc",
            "FUN_00082688",
            "FUN_00082824",
            "FUN_0008289c",
            "FUN_000834f0",
            "FUN_0008356c",
            "FUN_000836ec",
            "FUN_00083850",
            "FUN_00083888",
            "FUN_000839b4",
            "FUN_00083a74",
            "FUN_00083b10",
            "FUN_00083ca8",
            "FUN_00084004",
            "FUN_0008400c",
            "FUN_00084018",
            "FUN_000840f8",
            "FUN_000841e4",
            "thunk_FUN_00080efe",
            "FUN_00084220",
            "FUN_00084244",
            "FUN_0008427c",
            "FUN_000842a4",
            "FUN_0008434c",
            "FUN_0008439c",
            "FUN_00084484",
            "FUN_00084494",
            "FUN_000844bc",
            "FUN_000844e0",
            "FUN_00084508",
            "FUN_00084530",
            "FUN_0008455c",
            "FUN_0008458c",
            "FUN_000845c0",
            "FUN_00084860"
        ]
    ],
    "locked_functions": []
}