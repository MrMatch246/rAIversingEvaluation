{
    "functions": {
        "FUN_080001ac": {
            "entrypoint": "0x080001ac",
            "current_name": "set_completed_flag_080001ac",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b8) */\n\nundefined4 set_completed_flag_080001ac(undefined4 input_value)\n\n{\n  if ((char)completion_flag == '\\0') {\n    completion_flag._0_1_ = '\\x01';\n  }\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_080001ac": "set_completed_flag_080001ac",
                "param_1": "input_value",
                "completed_8667": "completion_flag"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080001d0": {
            "entrypoint": "0x080001d0",
            "current_name": "FUNC_080001d0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080001d4) */\n/* WARNING: Removing unreachable block (ram,0x080001ee) */\n/* WARNING: Removing unreachable block (ram,0x080001e4) */\n/* WARNING: Removing unreachable block (ram,0x08000200) */\n/* WARNING: Removing unreachable block (ram,0x080001f4) */\n\nvoid FUNC_080001d0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080001d0": "FUNC_080001d0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000218": {
            "entrypoint": "0x08000218",
            "current_name": "calculate_string_length_08000218",
            "code": "\nsize_t calculateStringLength_08000218(char *str)\n\n{\n  char currentChar;\n  char *nextCharPtr;\n  char *currentCharPtr;\n  \n  currentCharPtr = str;\n  do {\n    nextCharPtr = currentCharPtr + 1;\n    currentChar = *currentCharPtr;\n    currentCharPtr = nextCharPtr;\n  } while (currentChar != '\\0');\n  return (size_t)(nextCharPtr + (-1 - (int)str));\n}\n\n",
            "renaming": {
                "FUN_08000218": "calculate_string_length_08000218",
                "__s": "str",
                "cVar1": "currentChar",
                "pcVar2": "nextCharPtr",
                "pcVar3": "currentCharPtr"
            },
            "calling": [
                "printNumber"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000230": {
            "entrypoint": "0x08000230",
            "current_name": "find_byte_in_memory_08000230",
            "code": "\nvoid * find_byte_in_memory_08000230(void *buffer,int target_byte,size_t buffer_size)\n\n{\n  byte current_byte;\n  char condition1;\n  char condition2;\n  char condition3;\n  char condition4;\n  byte *next_byte;\n  uint *buffer_ptr;\n  byte *result;\n  uint target_byte_unsigned;\n  uint alignment_offset;\n  uint aligned_buffer_size;\n  uint compare_result1;\n  uint compare_result2;\n  bool compare_bit1;\n  bool compare_bit2;\n  bool compare_bit3;\n  bool compare_bit4;\n  \n  target_byte_unsigned = target_byte & 0xff;\n  if ((int)buffer_size < 0x10) {\njoined_r0x08000290:\n    do {\n      if (buffer_size == 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      buffer_ptr = (uint *)((int)buffer + 1);\n      current_byte = *buffer;\n      buffer_size = buffer_size - 1;\n      buffer = buffer_ptr;\n    } while (current_byte != target_byte_unsigned);\n  }\n  else {\n    alignment_offset = (uint)buffer & 7;\n    while( true ) {\n      if (alignment_offset == 0) {\n        alignment_offset = target_byte_unsigned | target_byte_unsigned << 8;\n        alignment_offset = alignment_offset | alignment_offset << 0x10;\n        aligned_buffer_size = buffer_size & 0xfffffff8;\n        do {\n          buffer_ptr = (uint *)((int)buffer + 8);\n                    /* WARNING: Load size is inaccurate */\n          aligned_buffer_size = aligned_buffer_size - 8;\n          compare_result1 = *buffer ^ alignment_offset;\n          compare_result2 = *(uint *)((int)buffer + 4) ^ alignment_offset;\n          condition1 = -((char)compare_result1 == '\\0');\n          condition2 = -((char)(compare_result1 >> 8) == '\\0');\n          condition3 = -((char)(compare_result1 >> 0x10) == '\\0');\n          condition4 = -((char)(compare_result1 >> 0x18) == '\\0');\n          compare_result1 = CONCAT13(condition4,CONCAT12(condition3,CONCAT11(condition2,condition1)));\n          compare_bit1 = (char)compare_result2 != '\\0';\n          compare_bit2 = (char)(compare_result2 >> 8) != '\\0';\n          compare_bit3 = (char)(compare_result2 >> 0x10) != '\\0';\n          compare_bit4 = (char)(compare_result2 >> 0x18) != '\\0';\n          compare_result2 = CONCAT13(compare_bit4 * condition4 - !compare_bit4,\n                            CONCAT12(compare_bit3 * condition3 - !compare_bit3,\n                                     CONCAT11(compare_bit2 * condition2 - !compare_bit2,compare_bit1 * condition1 - !compare_bit1)));\n          if (compare_result2 != 0) {\n            if (compare_result1 == 0) {\n              result = (byte *)((int)buffer + 5);\n              compare_result1 = compare_result2;\n            }\n            else {\n              result = (byte *)((int)buffer + 1);\n            }\n            if ((compare_result1 & 1) == 0) {\n              compare_bit1 = (compare_result1 & 0x100) == 0;\n              next_byte = result + 1;\n              if (compare_bit1) {\n                compare_bit1 = (compare_result1 & 0x18000) == 0;\n                next_byte = result + 2;\n              }\n              result = next_byte;\n              if (compare_bit1) {\n                result = result + 1;\n              }\n            }\n            return result + -1;\n          }\n          buffer = buffer_ptr;\n        } while (aligned_buffer_size != 0);\n        buffer_size = buffer_size & 7;\n        goto joined_r0x08000290;\n      }\n                    /* WARNING: Load size is inaccurate */\n      buffer_ptr = (uint *)((int)buffer + 1);\n      buffer_size = buffer_size - 1;\n      if (*buffer == target_byte_unsigned) break;\n      alignment_offset = (uint)buffer_ptr & 7;\n      buffer = buffer_ptr;\n      if (buffer_size == 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)buffer_ptr + -1);\n}\n\n",
            "renaming": {
                "FUN_08000230": "find_byte_in_memory_08000230",
                "__s": "buffer",
                "__c": "target_byte",
                "__n": "buffer_size",
                "bVar1": "current_byte",
                "cVar2": "condition1",
                "cVar3": "condition2",
                "cVar4": "condition3",
                "cVar5": "condition4",
                "pbVar6": "next_byte",
                "puVar7": "buffer_ptr",
                "pbVar8": "result",
                "uVar9": "target_byte_unsigned",
                "uVar10": "alignment_offset",
                "uVar11": "aligned_buffer_size",
                "uVar12": "compare_result1",
                "uVar13": "compare_result2",
                "bVar14": "compare_bit1",
                "bVar15": "compare_bit2",
                "bVar16": "compare_bit3",
                "bVar17": "compare_bit4"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080002d0": {
            "entrypoint": "0x080002d0",
            "current_name": "divide_or_throw_error_080002d0",
            "code": "\nvoid divideOrThrowError_080002d0(int dividend,int divisor,int quotient,int remainder)\n\n{\n  if ((remainder == 0) && (quotient == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    throwDivisionByZeroError(dividend,divisor);\n    return;\n  }\n  performUnsignedDivision();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080002d0": "divide_or_throw_error_080002d0",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "__aeabi_idiv0": "throwDivisionByZeroError",
                "__udivmoddi4": "performUnsignedDivision"
            },
            "calling": [
                "HAL_RCC_GetSysClockFreq"
            ],
            "called": [
                "__aeabi_idiv0",
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000300": {
            "entrypoint": "0x08000300",
            "current_name": "calculate_larger_divisor_08000300",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong calculate_larger_divisor_08000300(uint dividend,uint dividend_upper,uint divisor,uint divisor_upper,uint *quotient)\n\n{\n  ulonglong result;\n  uint tmp_var1;\n  uint tmp_var2;\n  uint tmp_var3;\n  uint tmp_var4;\n  uint tmp_var5;\n  uint tmp_var6;\n  uint tmp_var7;\n  uint tmp_var8;\n  int shift_count;\n  bool carry_flag;\n  \n  if (divisor_upper == 0) {\n    if (dividend_upper < divisor) {\n      shift_count = LZCOUNT(divisor);\n      if (shift_count != 0) {\n        divisor = divisor << shift_count;\n        dividend_upper = dividend >> (0x20U - shift_count & 0xff) | dividend_upper << shift_count;\n        dividend = dividend << shift_count;\n      }\n      tmp_var7 = divisor >> 0x10;\n      tmp_var5 = dividend_upper / tmp_var7;\n      tmp_var4 = dividend >> 0x10 | (dividend_upper - tmp_var7 * tmp_var5) * 0x10000;\n      tmp_var3 = tmp_var5 * (divisor & 0xffff);\n      tmp_var2 = tmp_var5;\n      if (tmp_var4 <= tmp_var3 && tmp_var3 - tmp_var4 != 0) {\n        carry_flag = CARRY4(tmp_var4,divisor);\n        tmp_var4 = tmp_var4 + divisor;\n        tmp_var2 = tmp_var5 - 1;\n        if ((carry_flag == false) && (tmp_var4 <= tmp_var3 && tmp_var3 - tmp_var4 != 0)) {\n          tmp_var2 = tmp_var5 - 2;\n          tmp_var4 = tmp_var4 + divisor;\n        }\n      }\n      tmp_var5 = (tmp_var4 - tmp_var3) / tmp_var7;\n      tmp_var4 = dividend & 0xffff | ((tmp_var4 - tmp_var3) - tmp_var7 * tmp_var5) * 0x10000;\n      tmp_var7 = tmp_var5 * (divisor & 0xffff);\n      tmp_var3 = tmp_var5;\n      if (tmp_var4 <= tmp_var7 && tmp_var7 - tmp_var4 != 0) {\n        carry_flag = CARRY4(tmp_var4,divisor);\n        tmp_var4 = tmp_var4 + divisor;\n        tmp_var3 = tmp_var5 - 1;\n        if ((carry_flag == false) && (tmp_var4 <= tmp_var7 && tmp_var7 - tmp_var4 != 0)) {\n          tmp_var3 = tmp_var5 - 2;\n          tmp_var4 = tmp_var4 + divisor;\n        }\n      }\n      tmp_var4 = tmp_var4 - tmp_var7;\n      tmp_var3 = tmp_var3 | tmp_var2 << 0x10;\n      tmp_var2 = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      shift_count = LZCOUNT(divisor);\n      if (shift_count == 0) {\n        dividend_upper = dividend_upper - divisor;\n        tmp_var4 = divisor >> 0x10;\n        tmp_var8 = divisor & 0xffff;\n        tmp_var2 = 1;\n      }\n      else {\n        divisor = divisor << shift_count;\n        tmp_var4 = divisor >> 0x10;\n        tmp_var3 = dividend_upper >> (0x20U - shift_count & 0xff);\n        tmp_var6 = dividend >> (0x20U - shift_count & 0xff) | dividend_upper << shift_count;\n        tmp_var2 = tmp_var3 / tmp_var4;\n        tmp_var8 = divisor & 0xffff;\n        tmp_var7 = tmp_var6 >> 0x10 | (tmp_var3 - tmp_var4 * tmp_var2) * 0x10000;\n        tmp_var5 = tmp_var2 * tmp_var8;\n        dividend = dividend << shift_count;\n        tmp_var3 = tmp_var2;\n        if (tmp_var7 <= tmp_var5 && tmp_var5 - tmp_var7 != 0) {\n          carry_flag = CARRY4(tmp_var7,divisor);\n          tmp_var7 = tmp_var7 + divisor;\n          tmp_var3 = tmp_var2 - 1;\n          if ((carry_flag == false) && (tmp_var7 <= tmp_var5 && tmp_var5 - tmp_var7 != 0)) {\n            tmp_var3 = tmp_var2 - 2;\n            tmp_var7 = tmp_var7 + divisor;\n          }\n        }\n        tmp_var1 = (tmp_var7 - tmp_var5) / tmp_var4;\n        dividend_upper = tmp_var6 & 0xffff | ((tmp_var7 - tmp_var5) - tmp_var4 * tmp_var1) * 0x10000;\n        tmp_var5 = tmp_var1 * tmp_var8;\n        tmp_var2 = tmp_var1;\n        if (dividend_upper <= tmp_var5 && tmp_var5 - dividend_upper != 0) {\n          carry_flag = CARRY4(dividend_upper,divisor);\n          dividend_upper = dividend_upper + divisor;\n          tmp_var2 = tmp_var1 - 1;\n          if ((carry_flag == false) && (dividend_upper <= tmp_var5 && tmp_var5 - dividend_upper != 0)) {\n            tmp_var2 = tmp_var1 - 2;\n            dividend_upper = dividend_upper + divisor;\n          }\n        }\n        dividend_upper = dividend_upper - tmp_var5;\n        tmp_var2 = tmp_var2 | tmp_var3 << 0x10;\n      }\n      tmp_var6 = dividend_upper / tmp_var4;\n      tmp_var7 = dividend >> 0x10 | (dividend_upper - tmp_var4 * tmp_var6) * 0x10000;\n      tmp_var3 = tmp_var8 * tmp_var6;\n      tmp_var5 = tmp_var6;\n      if (tmp_var7 <= tmp_var3 && tmp_var3 - tmp_var7 != 0) {\n        carry_flag = CARRY4(tmp_var7,divisor);\n        tmp_var7 = tmp_var7 + divisor;\n        tmp_var5 = tmp_var6 - 1;\n        if ((carry_flag == false) && (tmp_var7 <= tmp_var3 && tmp_var3 - tmp_var7 != 0)) {\n          tmp_var5 = tmp_var6 - 2;\n          tmp_var7 = tmp_var7 + divisor;\n        }\n      }\n      tmp_var6 = (tmp_var7 - tmp_var3) / tmp_var4;\n      tmp_var4 = dividend & 0xffff | ((tmp_var7 - tmp_var3) - tmp_var4 * tmp_var6) * 0x10000;\n      tmp_var8 = tmp_var8 * tmp_var6;\n      tmp_var3 = tmp_var6;\n      if (tmp_var4 <= tmp_var8 && tmp_var8 - tmp_var4 != 0) {\n        carry_flag = CARRY4(tmp_var4,divisor);\n        tmp_var4 = tmp_var4 + divisor;\n        tmp_var3 = tmp_var6 - 1;\n        if ((carry_flag == false) && (tmp_var4 <= tmp_var8 && tmp_var8 - tmp_var4 != 0)) {\n          tmp_var3 = tmp_var6 - 2;\n          tmp_var4 = tmp_var4 + divisor;\n        }\n      }\n      tmp_var4 = tmp_var4 - tmp_var8;\n      tmp_var3 = tmp_var3 | tmp_var5 << 0x10;\n    }\n    if (quotient != (uint *)0x0) {\n      *quotient = tmp_var4 >> shift_count;\n      quotient[1] = 0;\n      return CONCAT44(tmp_var2,tmp_var3);\n    }\n  }\n  else if (dividend_upper < divisor_upper) {\n    if (quotient != (uint *)0x0) {\n      *quotient = dividend;\n      quotient[1] = dividend_upper;\n      return 0;\n    }\n    tmp_var3 = 0;\n    tmp_var2 = 0;\n  }\n  else {\n    shift_count = LZCOUNT(divisor_upper);\n    if (shift_count != 0) {\n      tmp_var7 = 0x20 - shift_count;\n      tmp_var2 = divisor >> (tmp_var7 & 0xff) | divisor_upper << shift_count;\n      tmp_var8 = tmp_var2 >> 0x10;\n      tmp_var3 = dividend_upper >> (tmp_var7 & 0xff);\n      tmp_var1 = dividend >> (tmp_var7 & 0xff) | dividend_upper << shift_count;\n      tmp_var6 = tmp_var3 / tmp_var8;\n      tmp_var5 = tmp_var1 >> 0x10 | (tmp_var3 - tmp_var8 * tmp_var6) * 0x10000;\n      tmp_var4 = tmp_var6 * (tmp_var2 & 0xffff);\n      dividend = dividend << shift_count;\n      tmp_var3 = tmp_var6;\n      if (tmp_var5 <= tmp_var4 && tmp_var4 - tmp_var5 != 0) {\n        carry_flag = CARRY4(tmp_var5,tmp_var2);\n        tmp_var5 = tmp_var5 + tmp_var2;\n        tmp_var3 = tmp_var6 - 1;\n        if ((carry_flag == false) && (tmp_var5 <= tmp_var4 && tmp_var4 - tmp_var5 != 0)) {\n          tmp_var3 = tmp_var6 - 2;\n          tmp_var5 = tmp_var5 + tmp_var2;\n        }\n      }\n      tmp_var6 = (tmp_var5 - tmp_var4) / tmp_var8;\n      tmp_var5 = tmp_var1 & 0xffff | ((tmp_var5 - tmp_var4) - tmp_var8 * tmp_var6) * 0x10000;\n      tmp_var8 = tmp_var6 * (tmp_var2 & 0xffff);\n      tmp_var4 = tmp_var6;\n      if (tmp_var5 <= tmp_var8 && tmp_var8 - tmp_var5 != 0) {\n        carry_flag = CARRY4(tmp_var5,tmp_var2);\n        tmp_var5 = tmp_var5 + tmp_var2;\n        tmp_var4 = tmp_var6 - 1;\n        if ((carry_flag == false) && (tmp_var5 <= tmp_var8 && tmp_var8 - tmp_var5 != 0)) {\n          tmp_var4 = tmp_var6 - 2;\n          tmp_var5 = tmp_var5 + tmp_var2;\n        }\n      }\n      tmp_var4 = tmp_var4 | tmp_var3 << 0x10;\n      result = (ulonglong)tmp_var4 * (ulonglong)(divisor << shift_count);\n      if (CONCAT44(tmp_var5 - tmp_var8,dividend) < result) {\n        result = result - CONCAT44(tmp_var2,divisor << shift_count);\n        tmp_var4 = tmp_var4 - 1;\n      }\n      if (quotient != (uint *)0x0) {\n        tmp_var3 = ((tmp_var5 - tmp_var8) - (int)(result >> 0x20)) - (uint)(dividend < (uint)result);\n        *quotient = tmp_var3 << (tmp_var7 & 0xff) | dividend - (uint)result >> shift_count;\n        quotient[1] = tmp_var3 >> shift_count;\n      }\n      return (ulonglong)tmp_var4;\n    }\n    if ((divisor_upper < dividend_upper) || (divisor <= dividend)) {\n      carry_flag = dividend < divisor;\n      dividend = dividend - divisor;\n      dividend_upper = (dividend_upper - divisor_upper) - (uint)carry_flag;\n      tmp_var3 = 1;\n    }\n    else {\n      tmp_var3 = 0;\n    }\n    tmp_var2 = 0;\n    if (quotient != (uint *)0x0) {\n      *quotient = dividend;\n      quotient[1] = dividend_upper;\n      return (ulonglong)tmp_var3;\n    }\n  }\n  return CONCAT44(tmp_var2,tmp_var3);\n}\n\n",
            "renaming": {
                "FUN_08000300": "calculate_larger_divisor_08000300",
                "param_1": "dividend",
                "param_2": "dividend_upper",
                "param_3": "divisor",
                "param_4": "divisor_upper",
                "param_5": "quotient",
                "uVar1": "result",
                "uVar2": "tmp_var1",
                "uVar3": "tmp_var2",
                "uVar4": "tmp_var3",
                "uVar5": "tmp_var4",
                "uVar6": "tmp_var5",
                "uVar7": "tmp_var6",
                "uVar8": "tmp_var7",
                "uVar9": "tmp_var8",
                "iVar10": "shift_count",
                "bVar11": "carry_flag"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005dc": {
            "entrypoint": "0x080005dc",
            "current_name": "FUNC_080005dc",
            "code": "\nvoid FUNC_080005dc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080005dc": "FUNC_080005dc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080005e0": {
            "entrypoint": "0x080005e0",
            "current_name": "retrieve_info_080005e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t retrieve_info_080005e0(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  interrupt_handler(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_080005e0": "retrieve_info_080005e0",
                "software_interrupt": "interrupt_handler"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080005e4": {
            "entrypoint": "0x080005e4",
            "current_name": "call_afl_with_ticks_080005e4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint call_afl_with_ticks_080005e4(int ticks)\n\n{\n  uint32_t result;\n  \n  if (no_hyper_call != 0) {\n    return 0;\n  }\n  result = aflCall(1,ticks,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080005e4": "call_afl_with_ticks_080005e4",
                "noHyperCall": "no_hyper_call",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000600": {
            "entrypoint": "0x08000600",
            "current_name": "initialize_modbus_08000600",
            "code": "\n/* DWARF original prototype: void  begin(Modbus * modbus, long baudRate) */\n\nvoid __modbuscall Modbus::initializeModbus_08000600(Modbus *modbus,long baudRate)\n\n{\n  uint8_t serialNumber;\n  int printResult;\n  \n  serialNumber = modbus->serialTag;\n  if (serialNumber == '\\x02') {\n    modbus->serialPort = &defaultSerialPort;\n  }\n  else if (serialNumber == '\\x03') {\n    modbus->serialPort = &defaultSerialPort;\n  }\n  else if (serialNumber == '\\x01') {\n    modbus->serialPort = &defaultSerialPort;\n  }\n  else {\n    modbus->serialPort = &defaultSerialPort;\n  }\n  initializeSerialPort(modbus->serialPort,baudRate,'\\x06');\n  if (1 < modbus->txEnablePin) {\n    setPinMode((uint)modbus->txEnablePin,1);\n    writeDigitalPin((uint)modbus->txEnablePin,0);\n  }\n  do {\n    printResult = (*(modbus->serialPort->super_Stream).super_Print._vptr_Print[3])();\n  } while (-1 < printResult);\n  modbus->bufferSize = '\\0';\n  modbus->lastReceived = '\\0';\n  modbus->errorCount = 0;\n  modbus->outgoingCount = 0;\n  modbus->incomingCount = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "modbus",
                "u32speed": "baudRate",
                "uVar1": "serialNumber",
                "iVar2": "printResult",
                "port": "serialPort",
                "u8serno": "serialTag",
                "Serial3": "defaultSerialPort",
                "HardwareSerial::begin": "initializeSerialPort",
                "u8txenpin": "txEnablePin",
                "pinMode": "setPinMode",
                "digitalWrite": "writeDigitalPin",
                "u8BufferSize": "bufferSize",
                "u8lastRec": "lastReceived",
                "u16errCnt": "errorCount",
                "u16OutCnt": "outgoingCount",
                "u16InCnt": "incomingCount",
                "FUN_08000600": "initialize_modbus_08000600"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "begin",
                "pinMode",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800066c": {
            "entrypoint": "0x0800066c",
            "current_name": "initialize_modbus_0800066c",
            "code": "\n/* DWARF original prototype: void  init(Modbus * modbusInstance, uint8_t u8id, uint8_t u8serno, uint8_t\n   u8txenpin) */\n\nint __modbusInstancecall Modbus::initializeModbus_0800066c(Modbus *modbusInstance,EVP_PKEY_CTX *cryptoContext)\n\n{\n  int inputValue;\n  uint8_t inputPin;\n  \n  modbusInstance->u8id = (uint8_t)cryptoContext;\n  if (3 < inputValue) {\n    inputValue = 0;\n  }\n  modbusInstance->u8serno = (uint8_t)inputValue;\n  modbusInstance->u8txenpin = inputPin;\n  modbusInstance->u16timeOut = 1000;\n  return (int)modbusInstance;\n}\n\n",
            "renaming": {
                "FUN_0800066c": "initialize_modbus_0800066c",
                "this": "modbusInstance",
                "ctx": "cryptoContext",
                "in_r2": "inputValue",
                "in_r3": "inputPin"
            },
            "calling": [
                "Modbus"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000682": {
            "entrypoint": "0x08000682",
            "current_name": "initialize_modbus_controller_08000682",
            "code": "\n/* DWARF original prototype: ModbusController *  ModbusController(ModbusController * controller, unsignedInt8_t deviceID, unsignedInt8_t serialNumber, unsignedInt8_t\n   transmitEnablePin) */\n\nModbusController * __controllercall\nModbusController::initializeModbusController_08000682(ModbusController *controller,unsignedInt8_t deviceID,unsignedInt8_t serialNumber,unsignedInt8_t transmitEnablePin)\n\n{\n  initialize(controller,(encryptionContext *)(unsignedInt)deviceID);\n  return controller;\n}\n\n",
            "renaming": {
                "Modbus": "ModbusController",
                "FUN_08000682": "initialize_modbus_controller_08000682",
                "this": "controller",
                "u8id": "deviceID",
                "u8serno": "serialNumber",
                "u8txenpin": "transmitEnablePin",
                "init": "initialize",
                "EVP_PKEY_CTX": "encryptionContext",
                "uint": "unsignedInt"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000690": {
            "entrypoint": "0x08000690",
            "current_name": "initialize_modbus_08000690",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbus_08000690(int init_param,int priority)\n\n{\n  if (init_param != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    createModbusInstance(&modbusSlave,'\\x01','\\0','\\0');\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000690": "initialize_modbus_08000690",
                "__initialize_p": "init_param",
                "__priority": "priority",
                "Modbus::Modbus": "createModbusInstance",
                "slave": "modbusSlave"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "Modbus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006b4": {
            "entrypoint": "0x080006b4",
            "current_name": "get_rx_buffer_080006b4",
            "code": "\n/* DWARF original prototype: int8_t  getRxBuffer_080006b4(Modbus * modbusInstance) */\n\nint8_t __modbusInstancecall Modbus::getRxBuffer_080006b4(Modbus *modbusInstance)\n\n{\n  bool bufferOverflow;\n  int receivedByte;\n  byte bufferIndex;\n  \n  if (1 < modbusInstance->txEnablePin) {\n    toggleTxEnablePin((uint)modbusInstance->txEnablePin,0);\n  }\n  modbusInstance->bufferSize = '\\0';\n  if (modbusInstance->serialNumber < 4) {\n    bufferOverflow = false;\n    while (receivedByte = (*(modbusInstance->modbusPort->super_Stream).super_Print._vptr_Print[2])(), receivedByte != 0) {\n      bufferIndex = modbusInstance->bufferSize;\n      receivedByte = (*(modbusInstance->modbusPort->super_Stream).super_Print._vptr_Print[3])();\n      modbusInstance->abuffer[bufferIndex] = (uint8_t)receivedByte;\n      bufferIndex = modbusInstance->bufferSize + 1;\n      modbusInstance->bufferSize = bufferIndex;\n      if (0x3f < bufferIndex) {\n        bufferOverflow = true;\n      }\n    }\n  }\n  else {\n    bufferOverflow = false;\n  }\n  modbusInstance->inputCount = modbusInstance->inputCount + 1;\n  if (bufferOverflow) {\n    modbusInstance->errorCount = modbusInstance->errorCount + 1;\n    return -3;\n  }\n  return modbusInstance->bufferSize;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "bVar1": "bufferOverflow",
                "iVar2": "receivedByte",
                "bVar3": "bufferIndex",
                "u8txenpin": "txEnablePin",
                "digitalWrite": "toggleTxEnablePin",
                "u8BufferSize": "bufferSize",
                "u8serno": "serialNumber",
                "port": "modbusPort",
                "u8Buffer": "buffer",
                "u16InCnt": "inputCount",
                "u16errCnt": "errorCount",
                "FUN_080006b4": "get_rx_buffer_080006b4"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000728": {
            "entrypoint": "0x08000728",
            "current_name": "calculate_crc_08000728",
            "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * modbusObject, uint8_t length) */\n\nuint16_t __modbusObjectcall Modbus::calculateCRC_08000728(Modbus *modbusObject,uint8_t length)\n\n{\n  uchar counter;\n  uint crc;\n  uint unusedFlag;\n  uint bit;\n  uint index;\n  \n  crc = 0xffff;\n  for (index = 0; index < length; index = index + 1 & 0xff) {\n    crc = crc ^ modbusObject->au8Buffer[index];\n    for (counter = 1; counter < 9; counter = counter + 1) {\n      bit = crc & 1;\n      crc = crc >> 1;\n      if (bit != 0) {\n        crc = crc ^ 0xa001;\n      }\n    }\n  }\n  return (ushort)(crc << 8) | (ushort)(crc >> 8);\n}\n\n",
            "renaming": {
                "this": "modbusObject",
                "u8length": "length",
                "j": "counter",
                "uVar1": "crc",
                "flag": "unusedFlag",
                "uVar2": "bit",
                "uVar3": "index",
                "FUN_08000728": "calculate_crc_08000728"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800076c": {
            "entrypoint": "0x0800076c",
            "current_name": "send_tx_buffer_0800076c",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080007ec */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendTxBuffer_0800076c(ModbusObject * modbusObj) */\n\nvoid __modbusObjcall ModbusObject::sendTxBuffer_0800076c(ModbusObject *modbusObj)\n\n{\n  byte bufferLength;\n  uint16_t crcValue;\n  uint16_t calculatedCRC;\n  int printResult;\n  uint32_t currentTime;\n  uint newBufferLength;\n  \n  bufferLength = modbusObj->u8BufferSize;\n  crcValue = calcCRC(modbusObj,bufferLength);\n  modbusObj->au8Buffer[bufferLength] = (uint8_t)(crcValue >> 8);\n  newBufferLength = bufferLength + 1 & 0xff;\n  modbusObj->au8Buffer[newBufferLength] = (uint8_t)crcValue;\n  modbusObj->u8BufferSize = (char)newBufferLength + '\\x01';\n  if (1 < modbusObj->u8txenpin) {\n    digitalWrite((uint)modbusObj->u8txenpin,1);\n  }\n  if (modbusObj->u8serno < 4) {\n    (*(modbusObj->port->super_Stream).super_Print._vptr_Print[1])\n              (modbusObj->port,modbusObj->au8Buffer,(uint)modbusObj->u8BufferSize);\n  }\n  if (1 < modbusObj->u8txenpin) {\n    digitalWrite((uint)modbusObj->u8txenpin,0);\n  }\n  if (modbusObj->u8serno < 4) {\n    do {\n      printResult = (*(modbusObj->port->super_Stream).super_Print._vptr_Print[3])();\n    } while (-1 < printResult);\n  }\n  modbusObj->u8BufferSize = '\\0';\n  currentTime = millis();\n  modbusObj->u32timeOut = currentTime + modbusObj->u16timeOut;\n  modbusObj->u16OutCnt = modbusObj->u16OutCnt + 1;\n  return;\n}\n\n",
            "renaming": {
                "Modbus": "ModbusObject",
                "this": "modbusObj",
                "u8length": "bufferLength",
                "uVar1": "crcValue",
                "u16crc": "calculatedCRC",
                "iVar2": "printResult",
                "uVar3": "currentTime",
                "uVar4": "newBufferLength",
                "FUN_0800076c": "send_tx_buffer_0800076c"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "poll",
                "process_FC16"
            ],
            "called": [
                "calcCRC",
                "digitalWrite",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080007f0": {
            "entrypoint": "0x080007f0",
            "current_name": "validate_request_080007f0",
            "code": "\n/* DWARF original prototype: uint8_t  validateRequest_080007f0(modbusInstance * this) */\n\nuint8_t __thiscall modbusInstance::validateRequest_080007f0(modbusInstance *this)\n\n{\n  bool found;\n  uint16_t startAddress;\n  uint16_t endAddress;\n  uint counter;\n  uint8_t registerSize;\n  \n  counter = 0;\n  do {\n    if (7 < counter) {\n      found = false;\nLAB_0800080a:\n      if (!found) {\n        this->u16errCnt = this->u16errCnt + 1;\n        return '\\x01';\n      }\n      switch(this->au8Buffer[1]) {\n      case '\\x01':\n      case '\\x02':\n      case '\\x0f':\n        goto switchD_08000816_caseD_1;\n      case '\\x03':\n      case '\\x04':\n      case '\\x10':\n        startAddress = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n        endAddress = makeWord(this->au8Buffer[4],this->au8Buffer[5]);\n        if (this->registerSizeize < (byte)((char)endAddress + (char)startAddress)) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x05':\n        startAddress = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n        if ((uint)this->registerSizeize < ((uint)startAddress << 0x14) >> 0x18) {\n          return '\\x02';\n        }\n        return '\\0';\n      case '\\x06':\n        startAddress = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n        if (this->registerSizeize < (byte)startAddress) {\n          return '\\x02';\n        }\n        return '\\0';\n      default:\n        return '\\0';\n      }\n    }\n    if (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[counter] == this->au8Buffer[1]) {\n      found = true;\n      goto LAB_0800080a;\n    }\n    counter = counter + 1 & 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  startAddress = makeWord(this->au8Buffer[2],this->au8Buffer[3]);\n  endAddress = makeWord(this->au8Buffer[4],this->au8Buffer[5]);\n  if ((uint)this->registerSizeize <\n      ((((uint)startAddress << 0xc) >> 0x10) + (((uint)endAddress << 0xc) >> 0x10) & 0xff)) {\n    return '\\x02';\n  }\n  return '\\0';\n}\n\n",
            "renaming": {
                "FUN_080007f0": "validate_request_080007f0",
                "Modbus": "modbusInstance",
                "bVar1": "found",
                "uVar2": "startAddress",
                "uVar3": "endAddress",
                "uVar4": "counter",
                "u8regs": "registerSize"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008cc": {
            "entrypoint": "0x080008cc",
            "current_name": "build_exception_packet_080008cc",
            "code": "\n/* DWARF original prototype: void  buildException(Modbus * modbus_instance, uint8_t exception_code) */\n\nvoid __modbus_instancecall Modbus::build_exception_packet_080008cc(Modbus *modbus_instance,uint8_t exception_code)\n\n{\n  byte buffer_byte;\n  uint8_t function_code;\n  \n  buffer_byte = modbus_instance->au8Buffer[1];\n  modbus_instance->au8Buffer[0] = modbus_instance->u8id;\n  modbus_instance->au8Buffer[1] = buffer_byte ^ 0x80;\n  modbus_instance->au8Buffer[2] = exception_code;\n  modbus_instance->u8BufferSize = '\\x03';\n  return;\n}\n\n",
            "renaming": {
                "this": "modbus_instance",
                "u8exception": "exception_code",
                "bVar1": "buffer_byte",
                "u8func": "function_code",
                "FUN_080008cc": "build_exception_packet_080008cc"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008e2": {
            "entrypoint": "0x080008e2",
            "current_name": "convert_coils_to_bytes_080008e2",
            "code": "\n/* DWARF original prototype: int8_t  process_FC1(Modbus * modbusInstance, uint16_t * coilRegisters, uint8_t numCoils) */\n\nint8_t __modbusInstancecall Modbus::convertCoilsToBytes_080008e2(Modbus *modbusInstance,uint16_t *coilRegisters,uint8_t numCoils)\n\n{\n  uint16_t startRegister;\n  uint16_t numBits;\n  uint16_t currentCoil;\n  uint loopIndex;\n  uint bitIndex;\n  uint8_t numBytes;\n  uint8_t numBytes;\n  uint8_t bufferSize;\n  uint16_t startCoil;\n  \n  startRegister = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  numBits = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  numBytes = (uint8_t)(((uint)numBits << 0x15) >> 0x18);\n  if ((numBits & 7) != 0) {\n    numBytes = numBytes + '\\x01';\n  }\n  modbusInstance->au8Buffer[2] = numBytes;\n  modbusInstance->u8BufferSize = '\\x03';\n  bitIndex = 0;\n  for (loopIndex = 0; loopIndex < numBits; loopIndex = loopIndex + 1 & 0xffff) {\n    if (((int)(uint)coilRegisters[(loopIndex + startRegister) * 0x100000 >> 0x18] >> (loopIndex + startRegister & 0xf) & 1U) == 0) {\n      modbusInstance->au8Buffer[modbusInstance->u8BufferSize] =\n           modbusInstance->au8Buffer[modbusInstance->u8BufferSize] & ~(byte)(1 << bitIndex);\n    }\n    else {\n      modbusInstance->au8Buffer[modbusInstance->u8BufferSize] = modbusInstance->au8Buffer[modbusInstance->u8BufferSize] | (byte)(1 << bitIndex)\n      ;\n    }\n    bitIndex = bitIndex + 1 & 0xff;\n    if (7 < bitIndex) {\n      modbusInstance->u8BufferSize = modbusInstance->u8BufferSize + '\\x01';\n      bitIndex = 0;\n    }\n  }\n  if ((numBits & 7) != 0) {\n    modbusInstance->u8BufferSize = modbusInstance->u8BufferSize + '\\x01';\n  }\n  numBytes = modbusInstance->u8BufferSize;\n  sendTxBuffer(modbusInstance);\n  return numBytes + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "coilRegisters",
                "u8size": "numCoils",
                "uVar1": "startRegister",
                "uVar2": "numBits",
                "u16Coilno": "currentCoil",
                "uVar3": "loopIndex",
                "uVar4": "bitIndex",
                "uVar5": "numBytes",
                "u8bytesno": "numBytes",
                "u8CopyBufferSize": "bufferSize",
                "u16StartCoil": "startCoil",
                "FUN_080008e2": "convert_coils_to_bytes_080008e2"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "process_fc3_08000998",
            "code": "\n/* DWARF orloop_variablegloop_variablenal prototype: loop_variablent8_t  process_FC3_08000998(Modbus * modbus, uloop_variablent16_t * registers, uloop_variablent8_t register_size) */\n\nloop_variablent8_t __modbuscall Modbus::process_FC3_08000998(Modbus *modbus,uloop_variablent16_t *registers,uloop_variablent8_t register_size)\n\n{\n  byte byte_variable;\n  uloop_variablent8_t temp_variable;\n  uloop_variablent8_t register_count;\n  uloop_variablent16_t start_address;\n  uloop_variablent16_t num_registers;\n  uloop_variablent loop_counter;\n  uloop_variablent next_index;\n  uloop_variablent8_t buffer_size;\n  uloop_variablent8_t start_address;\n  uloop_variablent8_t loop_variable;\n  \n  start_address = makeWord(modbus->au8Buffer[2],modbus->au8Buffer[3]);\n  num_registers = makeWord(modbus->au8Buffer[4],modbus->au8Buffer[5]);\n  modbus->au8Buffer[2] = (byte)num_registers << 1;\n  modbus->u8BufferSloop_variableze = '\\x03';\n  for (loop_counter = (uloop_variablent)(byte)start_address; loop_counter < (uloop_variablent)(byte)start_address + (uloop_variablent)(byte)num_registers;\n      loop_counter = loop_counter + 1 & 0xff) {\n    byte_variable = modbus->u8BufferSloop_variableze;\n    modbus->au8Buffer[byte_variable] = (uloop_variablent8_t)(registers[loop_counter] >> 8);\n    next_index = byte_variable + 1 & 0xff;\n    temp_variable = (uloop_variablent8_t)next_index;\n    modbus->u8BufferSloop_variableze = temp_variable;\n    modbus->au8Buffer[next_index] = *(uloop_variablent8_t *)(registers + loop_counter);\n    modbus->u8BufferSloop_variableze = temp_variable + '\\x01';\n  }\n  temp_variable = modbus->u8BufferSloop_variableze;\n  sendTxBuffer(modbus);\n  return temp_variable + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbus",
                "regs": "registers",
                "u8size": "register_size",
                "bVar1": "byte_variable",
                "uVar2": "temp_variable",
                "u8regsno": "register_count",
                "uVar3": "start_address",
                "uVar4": "num_registers",
                "uVar5": "loop_counter",
                "uVar6": "next_index",
                "u8CopyBufferSize": "buffer_size",
                "u8StartAdd": "start_address",
                "i": "loop_variable",
                "FUN_08000998": "process_fc3_08000998"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a00": {
            "entrypoint": "0x08000a00",
            "current_name": "update_coil_status_08000a00",
            "code": "\n/* DWARF original prototype: int8_t  process_FC5(Modbus * modbusInstance, uint16_t * coilRegisters, uint8_t registerSize) */\n\nint8_t __modbusInstancecall Modbus::updateCoilStatus_08000a00(Modbus *modbusInstance,uint16_t *coilRegisters,uint8_t registerSize)\n\n{\n  uint8_t currentBit;\n  uint16_t bufferValue;\n  uint16_t coilValue;\n  uint lowerNibble;\n  uint8_t currentRegister;\n  uint shiftedValue;\n  \n  bufferValue = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  shiftedValue = ((uint)bufferValue << 0x14) >> 0x18;\n  lowerNibble = bufferValue & 0xf;\n  if (modbusInstance->au8Buffer[4] == 0xff) {\n    coilRegisters[shiftedValue] = (ushort)(1 << lowerNibble) | coilRegisters[shiftedValue];\n  }\n  else {\n    coilRegisters[shiftedValue] = coilRegisters[shiftedValue] & ~(ushort)(1 << lowerNibble);\n  }\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "coilRegisters",
                "u8size": "registerSize",
                "u8currentBit": "currentBit",
                "uVar1": "bufferValue",
                "u16coil": "coilValue",
                "uVar2": "lowerNibble",
                "u8currentRegister": "currentRegister",
                "uVar3": "shiftedValue",
                "FUN_08000a00": "update_coil_status_08000a00"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a4e": {
            "entrypoint": "0x08000a4e",
            "current_name": "update_registers_08000a4e",
            "code": "\n/* DWARF original prototype: int8_t  process_FC6(Modbus * modbusInstance, uint16_t * registerArray, uint8_t arraySize) */\n\nint8_t __modbusInstancecall Modbus::updateRegisters_08000a4e(Modbus *modbusInstance,uint16_t *registerArray,uint8_t arraySize)\n\n{\n  uint16_t highByte;\n  uint16_t lowByte;\n  uint16_t newValue;\n  uint8_t registerAddress;\n  \n  highByte = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  lowByte = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  registerArray[(byte)highByte] = lowByte;\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registerArray",
                "u8size": "arraySize",
                "uVar1": "highByte",
                "uVar2": "lowByte",
                "u16val": "newValue",
                "u8add": "registerAddress",
                "FUN_08000a4e": "update_registers_08000a4e"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a7a": {
            "entrypoint": "0x08000a7a",
            "current_name": "reverse_coil_bits_08000a7a",
            "code": "\n/* DWARF original prototype: int8_t  process_FC15(Modbus * modbusInstance, uint16_t * registers, uint8_t sizeOfRegisters) */\n\nint8_t __modbusInstancecall Modbus::reverseCoilBits_08000a7a(Modbus *modbusInstance,uint16_t *registers,uint8_t sizeOfRegisters)\n\n{\n  uint16_t startRegisterValue;\n  uint16_t numCoils;\n  uint16_t currentCoil;\n  uint iterator;\n  uint bitIterator;\n  uint8_t currentBit;\n  uint bitOffset;\n  uint16_t startCoil;\n  uint8_t currentRegister;\n  uint registerIndex;\n  uint bufferIndex;\n  \n  startRegisterValue = makeWord(modbusInstance->au8Buffer[2],modbusInstance->au8Buffer[3]);\n  numCoils = makeWord(modbusInstance->au8Buffer[4],modbusInstance->au8Buffer[5]);\n  bitIterator = 0;\n  bufferIndex = 7;\n  for (iterator = 0; iterator < numCoils; iterator = iterator + 1 & 0xffff) {\n    registerIndex = (iterator + startRegisterValue) * 0x100000 >> 0x18;\n    bitOffset = iterator + startRegisterValue & 0xf;\n    if (((int)(uint)modbusInstance->au8Buffer[bufferIndex] >> bitIterator & 1U) == 0) {\n      registers[registerIndex] = registers[registerIndex] & ~(ushort)(1 << bitOffset);\n    }\n    else {\n      registers[registerIndex] = (ushort)(1 << bitOffset) | registers[registerIndex];\n    }\n    bitIterator = bitIterator + 1 & 0xff;\n    if (7 < bitIterator) {\n      bufferIndex = bufferIndex + 1 & 0xff;\n      bitIterator = 0;\n    }\n  }\n  modbusInstance->u8BufferSize = '\\x06';\n  sendTxBuffer(modbusInstance);\n  return '\\b';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "regs": "registers",
                "u8size": "sizeOfRegisters",
                "uVar1": "startRegisterValue",
                "uVar2": "numCoils",
                "u16Coilno": "currentCoil",
                "uVar3": "iterator",
                "uVar4": "bitIterator",
                "u8currentBit": "currentBit",
                "uVar5": "bitOffset",
                "u16StartCoil": "startCoil",
                "u8currentRegister": "currentRegister",
                "uVar6": "registerIndex",
                "uVar7": "bufferIndex",
                "FUN_08000a7a": "reverse_coil_bits_08000a7a"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b04": {
            "entrypoint": "0x08000b04",
            "current_name": "process_fc16_08000b04",
            "code": "\n/* DWARF orindexgindexnal prototype: indexnt8_t  process_FC16_08000b04(Modbus * modbus_instance, uindexnt16_t * registers, uindexnt8_t num_registers) */\n\nindexnt8_t __modbus_instancecall Modbus::process_FC16_08000b04(Modbus *modbus_instance,uindexnt16_t *registers,uindexnt8_t num_registers)\n\n{\n  byte buffer_index_3;\n  byte buffer_index_5;\n  uindexnt8_t buffer_size;\n  uindexnt16_t value;\n  uindexnt16_t temp_value;\n  uindexnt8_t copy_buffer_size;\n  uindexnt8_t index;\n  uindexnt loop_counter;\n  uindexnt8_t registers_number;\n  uindexnt8_t starting_address;\n  \n  buffer_index_3 = modbus_instance->au8Buffer[3];\n  buffer_index_5 = modbus_instance->au8Buffer[5];\n  modbus_instance->au8Buffer[4] = '\\0';\n  modbus_instance->au8Buffer[5] = buffer_index_5;\n  modbus_instance->u8BufferSindexze = '\\x06';\n  for (loop_counter = 0; loop_counter < buffer_index_5; loop_counter = loop_counter + 1 & 0xff) {\n    value = makeWord(modbus_instance->au8Buffer[loop_counter * 2 + 7],modbus_instance->au8Buffer[loop_counter * 2 + 8]);\n    registers[buffer_index_3 + loop_counter] = value;\n  }\n  buffer_size = modbus_instance->u8BufferSindexze;\n  sendTxBuffer(modbus_instance);\n  return buffer_size + '\\x02';\n}\n\n",
            "renaming": {
                "this": "modbus_instance",
                "regs": "registers",
                "u8size": "num_registers",
                "bVar1": "buffer_index_3",
                "bVar2": "buffer_index_5",
                "uVar3": "buffer_size",
                "uVar4": "value",
                "temp": "temp_value",
                "u8CopyBufferSize": "copy_buffer_size",
                "i": "index",
                "uVar5": "loop_counter",
                "u8regsno": "registers_number",
                "u8StartAdd": "starting_address",
                "FUN_08000b04": "process_fc16_08000b04"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "sendTxBuffer",
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b54": {
            "entrypoint": "0x08000b54",
            "current_name": "execute_modbus_poll_08000b54",
            "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * this, uint16_t * regs, uint8_t registerSize) */\n\nint this Modbus::executeModbusPoll_08000b54(Modbus *this,pollfd *pollFileDescriptors,nfds_t numberOfFileDescriptors,int timeout)\n\n{\n  uint8_t registerSize;\n  uint8_t receivedData;\n  int8_t resultState;\n  uint8_t exceptionCode;\n  int8_t processResult;\n  uint receivedByte;\n  uint32_t currentMillis;\n  uint8_t currentByte;\n  uint receivedDataLength;\n  int returnValue;\n  \n  this->au16regs = (uint16_t *)pollFileDescriptors;\n  registerSize = (uint8_t)numberOfFileDescriptors;\n  this->u8regsize = registerSize;\n  if (this->u8serno < 4) {\n    receivedByte = (*(this->port->super_Stream).super_Print._vptr_Print[2])();\n    receivedDataLength = receivedByte & 0xff;\n  }\n  if (receivedDataLength == 0) {\n    returnValue = 0;\n  }\n  else if ((int)receivedDataLength < 8) {\n    returnValue = 0;\n  }\n  else {\n    receivedData = getRxBuffer(this);\n    returnValue = (int)(char)receivedData;\n    this->u8lastError = receivedData;\n    if (this->au8Buffer[0] == this->u8id) {\n      receivedData = validateRequest(this);\n      if (receivedData == '\\0') {\n        currentMillis = millis();\n        this->u32timeOut = this->u16timeOut + currentMillis;\n        this->u8lastError = '\\0';\n        switch(this->au8Buffer[1]) {\n        case '\\x01':\n        case '\\x02':\n          processResult = process_FC1(this,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)processResult;\n          break;\n        case '\\x03':\n        case '\\x04':\n          processResult = process_FC3(this,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)processResult;\n          break;\n        case '\\x05':\n          processResult = process_FC5(this,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)processResult;\n          break;\n        case '\\x06':\n          processResult = process_FC6(this,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)processResult;\n          break;\n        case '\\x0f':\n          processResult = process_FC15(this,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)processResult;\n          break;\n        case '\\x10':\n          processResult = process_FC16(this,(uint16_t *)pollFileDescriptors,registerSize);\n          returnValue = (int)processResult;\n        }\n      }\n      else {\n        if (receivedData != 0xff) {\n          buildException(this,receivedData);\n          sendTxBuffer(this);\n        }\n        this->u8lastError = receivedData;\n        returnValue = (int)(char)receivedData;\n      }\n    }\n    else {\n      returnValue = 0;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08000b54": "execute_modbus_poll_08000b54",
                "__thiscall": "this",
                "__fds": "pollFileDescriptors",
                "__nfds": "numberOfFileDescriptors",
                "__timeout": "timeout",
                "u8size": "registerSize",
                "uVar1": "receivedData",
                "i8state": "resultState",
                "u8exception": "exceptionCode",
                "iVar2": "processResult",
                "uVar3": "receivedByte",
                "uVar4": "currentMillis",
                "u8current": "currentByte",
                "unaff_r5": "receivedDataLength",
                "iVar5": "returnValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "sendTxBuffer",
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC6",
                "process_FC5",
                "getRxBuffer",
                "validateRequest",
                "buildException",
                "process_FC16",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c4c": {
            "entrypoint": "0x08000c4c",
            "current_name": "initialize_modbus_slave_08000c4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeModbusSlave_08000c4c(void)\n\n{\n  startForkServer(0);\n  ModbusBegin(&slave,0x4b00);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c4c": "initialize_modbus_slave_08000c4c",
                "startForkserver": "startForkServer",
                "Modbus::begin": "ModbusBegin"
            },
            "calling": [
                "main"
            ],
            "called": [
                "startForkserver",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c64": {
            "entrypoint": "0x08000c64",
            "current_name": "poll_modbus_slave_08000c64",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pollModbusSlave_08000c64(void)\n\n{\n  int modbusSlaveAddress;\n  \n  Modbus::poll(&modbusSlave,(pollfd *)pollData,0x10,modbusSlaveAddress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c64": "poll_modbus_slave_08000c64",
                "in_r3": "modbusSlaveAddress",
                "slave": "modbusSlave",
                "au16data": "pollData"
            },
            "calling": [
                "main"
            ],
            "called": [
                "poll"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c7c": {
            "entrypoint": "0x08000c7c",
            "current_name": "perform_static_initialization_08000c7c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid perform_static_initialization_08000c7c(void)\n\n{\n  initialize_and_destroy(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c7c": "perform_static_initialization_08000c7c",
                "__static_initialization_and_destruction_0": "initialize_and_destroy"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c8c": {
            "entrypoint": "0x08000c8c",
            "current_name": "initialize_system_clock_08000c8c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSystemClock_08000c8c(void)\n\n{\n  uint32_t hclkFreq;\n  uint32_t tmpReg;\n  uint32_t tmpReg1;\n  RCC_OscInitTypeDef rccOscInitStruct;\n  RCC_ClkInitTypeDef rccClkInitStruct;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_40007000 = _DAT_40007000 | 0xc000;\n  rccOscInitStruct.OscillatorType = 1;\n  rccOscInitStruct.HSEState = 0x50000;\n  rccOscInitStruct.PLL.PLLState = 2;\n  rccOscInitStruct.PLL.PLLSource = 0x400000;\n  rccOscInitStruct.PLL.PLLM = 8;\n  rccOscInitStruct.PLL.PLLN = 0x150;\n  rccOscInitStruct.PLL.PLLP = 2;\n  rccOscInitStruct.PLL.PLLQ = 7;\n  HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)&rccOscInitStruct);\n  HAL_PWREx_EnableOverDrive();\n  rccClkInitStruct.ClockType = 0xf;\n  rccClkInitStruct.SYSCLKSource = 2;\n  rccClkInitStruct.AHBCLKDivider = 0;\n  rccClkInitStruct.APB1CLKDivider = 0x1400;\n  rccClkInitStruct.APB2CLKDivider = 0x1000;\n  HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)&rccClkInitStruct,5);\n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFreq / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000c8c": "initialize_system_clock_08000c8c",
                "RCC_OscInitStruct": "rccOscInitStruct",
                "RCC_ClkInitStruct": "rccClkInitStruct",
                "uVar1": "hclkFreq",
                "tmpreg": "tmpReg",
                "tmpreg_1": "tmpReg1"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_PWREx_EnableOverDrive",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_OscConfig",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d3c": {
            "entrypoint": "0x08000d3c",
            "current_name": "initialize_system_08000d3c",
            "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid initializeSystem_08000d3c(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8667; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&_sidata + index);\n  }\n  for (ptr = &completed_8667; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d3c": "initialize_system_08000d3c",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "SystemInit",
                "__libc_init_array"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8c": {
            "entrypoint": "0x08000d8c",
            "current_name": "infinite_loop_08000d8c",
            "code": "\nvoid infiniteLoop_08000d8c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08000d8c": "infinite_loop_08000d8c"
            },
            "calling": [
                "CAN2_SCE_IRQHandler"
            ],
            "called": [
                "CAN2_SCE_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d8e": {
            "entrypoint": "0x08000d8e",
            "current_name": "initialize_hardware_config_08000d8e",
            "code": "\nint initializeHardwareConfig_08000d8e(EVP_PKEY_CTX *context)\n\n{\n  hw_config_init();\n  return (int)context;\n}\n\n",
            "renaming": {
                "FUN_08000d8e": "initialize_hardware_config_08000d8e",
                "ctx": "context"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000d96": {
            "entrypoint": "0x08000d96",
            "current_name": "FUNC_08000d96",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000d96(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000d96": "FUNC_08000d96"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000d98": {
            "entrypoint": "0x08000d98",
            "current_name": "configure_sys_tick_08000d98",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureSysTick_08000d98(uint32_t priority)\n\n{\n  uint32_t configResult;\n  \n  configResult = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (configResult != 0) {\n    return HAL_ERROR;\n  }\n  if (0xf < priority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,priority,0);\n  uwTickPrio = priority;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000d98": "configure_sys_tick_08000d98",
                "TickPriority": "priority",
                "uVar1": "configResult"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000de4": {
            "entrypoint": "0x08000de4",
            "current_name": "initialize_hardware_08000de4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeHardware_08000de4(void)\n\n{\n  _DAT_40023c00 = _DAT_40023c00 | 0x700;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializePeripheral();\n  return SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08000de4": "initialize_hardware_08000de4",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializePeripheral",
                "HAL_OK": "SUCCESS"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick",
                "HAL_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e18": {
            "entrypoint": "0x08000e18",
            "current_name": "update_tick_08000e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTick_08000e18(void)\n\n{\n  currentTick = tickFrequency + currentTick;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e18": "update_tick_08000e18",
                "uwTick": "currentTick",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e30": {
            "entrypoint": "0x08000e30",
            "current_name": "get_system_tick_08000e30",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemTick_08000e30(void)\n\n{\n  return systemTick;\n}\n\n",
            "renaming": {
                "FUN_08000e30": "get_system_tick_08000e30",
                "uwTick": "systemTick"
            },
            "calling": [
                "HAL_PWREx_EnableOverDrive",
                "UART_WaitOnFlagUntilTimeout",
                "uart_debug_write",
                "GetCurrentMilli",
                "HAL_RCC_OscConfig",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e3c": {
            "entrypoint": "0x08000e3c",
            "current_name": "set_priority_group_08000e3c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setPriorityGroup_08000e3c(uint32_t priorityGroup)\n\n{\n  uint32_t registerValue;\n  \n  _DAT_e000ed0c = (priorityGroup & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e3c": "set_priority_group_08000e3c",
                "PriorityGroup": "priorityGroup",
                "reg_value": "registerValue"
            },
            "calling": [
                "premain",
                "HAL_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e60": {
            "entrypoint": "0x08000e60",
            "current_name": "set_priority_08000e60",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid setPriority_08000e60(IRQn IRQn,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint irqNumber;\n  uint priorityGroup;\n  uint32_t priorityGroupTmp;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  \n  irqNumber = (uint)IRQn;\n  priorityGroup = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  preemptPriorityBits = 7 - priorityGroup;\n  if (3 < preemptPriorityBits) {\n    preemptPriorityBits = 4;\n  }\n  if (priorityGroup + 4 < 7) {\n    subPriorityBits = 0;\n  }\n  else {\n    subPriorityBits = priorityGroup - 3;\n  }\n  priorityGroup = (preemptPriority & (1 << (preemptPriorityBits & 0xff)) - 1U) << (subPriorityBits & 0xff) |\n          (1 << (subPriorityBits & 0xff)) - 1U & subPriority;\n  if ((int)irqNumber < 0) {\n    *(char *)((irqNumber & 0xf) + 0xe000ed14) = (char)(priorityGroup << 4);\n  }\n  else {\n    *(char *)(irqNumber + 0xe000e400) = (char)(priorityGroup << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000e60": "set_priority_08000e60",
                "IRQn_Type_conflict": "IRQn",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "irqNumber",
                "uVar2": "priorityGroup",
                "PriorityGroupTmp": "priorityGroupTmp",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback",
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ec4": {
            "entrypoint": "0x08000ec4",
            "current_name": "set_ir_qn_flag_08000ec4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQnFlag_08000ec4(IRQn IRQn)\n\n{\n  uint irqValue;\n  \n  irqValue = (uint)IRQn;\n  if (-1 < (int)irqValue) {\n    *(int *)((irqValue >> 5) * 4 + -0x1fff1f00) = 1 << (irqValue & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ec4": "set_ir_qn_flag_08000ec4",
                "IRQn_Type_conflict": "IRQn",
                "uVar1": "irqValue"
            },
            "calling": [
                "uart_attach_tx_callback",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ee0": {
            "entrypoint": "0x08000ee0",
            "current_name": "initialize_ticks_08000ee0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t initializeTicks_08000ee0(uint32_t ticksNumber)\n\n{\n  if (ticksNumber - 1 < 0x1000000) {\n    _DAT_e000e014 = ticksNumber - 1;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000ee0": "initialize_ticks_08000ee0",
                "TicksNumb": "ticksNumber"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_InitTick"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f0c": {
            "entrypoint": "0x08000f0c",
            "current_name": "set_irq_enabled_08000f0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setIRQEnabled_08000f0c(interrupt_Type_conflict interrupt)\n\n{\n  uint interruptMask;\n  \n  interruptMask = (uint)interrupt;\n  if (-1 < (int)interruptMask) {\n    *(int *)(((interruptMask >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (interruptMask & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f0c": "set_irq_enabled_08000f0c",
                "IRQn": "interrupt",
                "uVar1": "interruptMask"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f2c": {
            "entrypoint": "0x08000f2c",
            "current_name": "update_clk_source_08000f2c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid updateCLKSource_08000f2c(uint32_t source)\n\n{\n  if (source != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f2c": "update_clk_source_08000f2c",
                "CLKSource": "source"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4c": {
            "entrypoint": "0x08000f4c",
            "current_name": "FUNC_08000f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08000f4c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4c": "FUNC_08000f4c"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08000f4e": {
            "entrypoint": "0x08000f4e",
            "current_name": "handle_sys_tick_interrupt_08000f4e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSysTickInterrupt_08000f4e(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000f4e": "handle_sys_tick_interrupt_08000f4e"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f56": {
            "entrypoint": "0x08000f56",
            "current_name": "initialize_dac_08000f56",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus initializeDAC_08000f56(DAC_HandleTypeDef *hdac)\n\n{\n  if (hdac != (DAC_HandleTypeDef *)0x0) {\n    hdac->State = BUSY;\n    deinitializeDAC_08000f56(hdac);\n    hdac->ErrorCode = 0;\n    hdac->State = RESET;\n    hdac->Lock = UNLOCKED;\n    return OK;\n  }\n  return ERROR;\n}\n\n",
            "renaming": {
                "FUN_08000f56": "initialize_dac_08000f56",
                "HAL_StatusTypeDef": "Status",
                "HAL_DAC_STATE_BUSY": "BUSY",
                "HAL_DAC_STATE_RESET": "RESET",
                "HAL_UNLOCKED": "UNLOCKED",
                "HAL_OK": "OK",
                "HAL_ERROR": "ERROR",
                "HAL_DAC_MspDeInit": "deinitializeDAC"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "HAL_DAC_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f72": {
            "entrypoint": "0x08000f72",
            "current_name": "disable_channel_08000f72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableChannel_08000f72(DAC_HandleTypeDef *dacHandle,uint32_t channel)\n\n{\n  dacHandle->Instance->controlRegister = dacHandle->Instance->controlRegister & ~(1 << (channel & 0xff));\n  dacHandle->currentState = HAL_DAC_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000f72": "disable_channel_08000f72",
                "hdac": "dacHandle",
                "Channel": "channel",
                "CR": "controlRegister",
                "State": "currentState"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f8c": {
            "entrypoint": "0x08000f8c",
            "current_name": "disable_dma_08000f8c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableDMA_08000f8c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  if (dmaHandle->State != HAL_DMA_STATE_BUSY) {\n    dmaHandle->ErrorCode = 0x80;\n    return HAL_ERROR;\n  }\n  dmaHandle->State = HAL_DMA_STATE_ABORT;\n  dmaHandle->Instance->CR = dmaHandle->Instance->CR & 0xfffffffe;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08000f8c": "disable_dma_08000f8c",
                "hdma": "dmaHandle"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fb4": {
            "entrypoint": "0x08000fb4",
            "current_name": "configure_gpio_08000fb4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid configureGPIO_08000fb4(GPIO_TypeDef *port,configTypeDef *config)\n\n{\n  uint temp1;\n  uint temp2;\n  uint iterator;\n  uint mask;\n  uint temp3;\n  uint32_t temp4;\n  int portIndex;\n  uint temp5;\n  int shift;\n  uint32_t temporaryRegister;\n  \n  for (iterator = 0; iterator < 0x10; iterator = iterator + 1) {\n    temp2 = 1 << (iterator & 0xff);\n    mask = temp2 & config->Pin;\n    temp1 = _DAT_40013c0c;\n    if (temp2 == mask) {\n      if ((config->Mode == 2) || (config->Mode == 0x12)) {\n        shift = (iterator & 7) << 2;\n        port->AFR[iterator >> 3] =\n             port->AFR[iterator >> 3] & ~(0xf << shift) | config->Alternate << shift;\n      }\n      temp5 = iterator << 1;\n      temp1 = ~(3 << (temp5 & 0xff));\n      port->MODER = port->MODER & temp1 | (config->Mode & 3) << (temp5 & 0xff);\n      temp4 = config->Mode;\n      if (((temp4 - 1 < 2) || (temp4 == 0x11)) || (temp4 == 0x12)) {\n        port->OSPEEDR = port->OSPEEDR & temp1 | config->Speed << (temp5 & 0xff);\n        port->OTYPER =\n             port->OTYPER & ~temp2 | ((config->Mode << 0x1b) >> 0x1f) << (iterator & 0xff);\n      }\n      port->PUPDR = temp1 & port->PUPDR | config->Pull << (temp5 & 0xff);\n      temp1 = _DAT_40013c0c;\n      if ((config->Mode & 0x10000000) != 0) {\n        _DAT_40023844 = _DAT_40023844 | 0x4000;\n        shift = (iterator & 3) << 2;\n        if (port == (GPIO_TypeDef *)0x40020000) {\n          portIndex = 0;\n        }\n        else if (port == (GPIO_TypeDef *)0x40020400) {\n          portIndex = 1;\n        }\n        else if (port == (GPIO_TypeDef *)0x40020800) {\n          portIndex = 2;\n        }\n        else if (port == (GPIO_TypeDef *)0x40020c00) {\n          portIndex = 3;\n        }\n        else if (port == (GPIO_TypeDef *)0x40021000) {\n          portIndex = 4;\n        }\n        else if (port == (GPIO_TypeDef *)0x40021400) {\n          portIndex = 5;\n        }\n        else if (port == (GPIO_TypeDef *)0x40021800) {\n          portIndex = 6;\n        }\n        else if (port == (GPIO_TypeDef *)0x40021c00) {\n          portIndex = 7;\n        }\n        else if (port == (GPIO_TypeDef *)0x40022000) {\n          portIndex = 8;\n        }\n        else if (port == (GPIO_TypeDef *)0x40022400) {\n          portIndex = 9;\n        }\n        else {\n          portIndex = 10;\n        }\n        *(uint *)(((iterator >> 2) + 2) * 4 + 0x40013800) =\n             *(uint *)(((iterator >> 2) + 2) * 4 + 0x40013800) & ~(0xf << shift) | portIndex << shift;\n        temp1 = ~mask;\n        temp2 = _DAT_40013c00 & temp1;\n        if ((config->Mode & 0x10000) != 0) {\n          temp2 = mask | _DAT_40013c00;\n        }\n        temp5 = temp1 & _DAT_40013c04;\n        if ((config->Mode & 0x20000) != 0) {\n          temp5 = mask | _DAT_40013c04;\n        }\n        temp3 = temp1 & _DAT_40013c08;\n        if ((config->Mode & 0x100000) != 0) {\n          temp3 = mask | _DAT_40013c08;\n        }\n        _DAT_40013c00 = temp2;\n        _DAT_40013c04 = temp5;\n        _DAT_40013c08 = temp3;\n        temp1 = temp1 & _DAT_40013c0c;\n        if ((config->Mode & 0x200000) != 0) {\n          temp1 = mask | _DAT_40013c0c;\n        }\n      }\n    }\n    _DAT_40013c0c = temp1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fb4": "configure_gpio_08000fb4",
                "GPIOx": "port",
                "GPIO_Init": "config",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "iterator",
                "uVar4": "mask",
                "uVar5": "temp3",
                "uVar6": "temp4",
                "iVar7": "portIndex",
                "uVar8": "temp5",
                "iVar9": "shift",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001198": {
            "entrypoint": "0x08001198",
            "current_name": "set_pin_state_08001198",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_08001198(GPIO_TypeDef *gpioPort,uint16_t pinNumber,pinNumberState pinState)\n\n{\n  if (pinState == GPIO_PIN_RESET) {\n    gpioPort->BSRR = (uint)pinNumber << 0x10;\n    return;\n  }\n  gpioPort->BSRR = (uint)pinNumber;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001198": "set_pin_state_08001198",
                "GPIOx": "gpioPort",
                "GPIO_Pin": "pinNumber",
                "PinState": "pinState"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011a4": {
            "entrypoint": "0x080011a4",
            "current_name": "handle_gpio_pin_change_080011a4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_Pin_change_080011a4(uint16_t pin)\n\n{\n  if ((_DAT_40013c14 & pin) != 0) {\n    _DAT_40013c14 = (uint)pin;\n    HAL_GPIO_EXTI_Callback(pin);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011a4": "handle_gpio_pin_change_080011a4",
                "GPIO_Pin": "pin"
            },
            "calling": [
                "EXTI15_10_IRQHandler",
                "EXTI1_IRQHandler",
                "EXTI3_IRQHandler",
                "EXTI9_5_IRQHandler",
                "EXTI0_IRQHandler",
                "EXTI2_IRQHandler",
                "EXTI4_IRQHandler"
            ],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011c0": {
            "entrypoint": "0x080011c0",
            "current_name": "set_device_address_080011c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setDeviceAddress_080011c0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  if (i2cHandle->mode == MemoryMode) {\n    if (i2cHandle->eventCount == 0) {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if ((i2cHandle->i2cInit).addressingMode == 0x4000) {\n    if (i2cHandle->i2cState == BusyTransmitState) {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xfe;\n    }\n    else {\n      i2cHandle->i2cInstance->dataRegister = i2cHandle->deviceAddress & 0xff | 1;\n    }\n  }\n  else if (i2cHandle->eventCount == 0) {\n    i2cHandle->i2cInstance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (i2cHandle->eventCount == 1) {\n    i2cHandle->i2cInstance->dataRegister = (i2cHandle->deviceAddress << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080011c0": "set_device_address_080011c0",
                "hi2c": "i2cHandle",
                "Mode": "mode",
                "EventCount": "eventCount",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "Devaddress": "deviceAddress",
                "Init": "i2cInit",
                "AddressingMode": "addressingMode",
                "State": "i2cState",
                "HAL_I2C_MODE_MEM": "MemoryMode",
                "HAL_I2C_STATE_BUSY_TX": "BusyTransmitState"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800124a": {
            "entrypoint": "0x0800124a",
            "current_name": "set_device_address_0800124a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef setDeviceAddress_0800124a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2cHandle->Instance->dataRegister = i2cHandle->Devaddress & 0xff;\n  return operationSuccess;\n}\n\n",
            "renaming": {
                "FUN_0800124a": "set_device_address_0800124a",
                "hi2c": "i2cHandle",
                "DR": "dataRegister",
                "HAL_OK": "operationSuccess"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001256": {
            "entrypoint": "0x08001256",
            "current_name": "handle_i2_c_events_08001256",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CEvents_08001256(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t tempVar1;\n  I2C_TypeDef *i2cInstance;\n  uint32_t previousState;\n  uint32_t temporaryRegister;\n  uint32_t temporaryRegister1;\n  uint32_t temporaryRegister2;\n  uint32_t temporaryRegister3;\n  uint32_t temporaryRegister4;\n  uint32_t temporaryRegister5;\n  uint32_t temporaryRegister6;\n  uint32_t temporaryRegister7;\n  uint32_t temporaryRegister8;\n  uint32_t temporaryRegister9;\n  \n  tempVar1 = i2cHandle->XferOptions;\n  if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) &&\n     ((i2cHandle->EventCount != 0 || (i2cHandle->Mode != HAL_I2C_MODE_MEM)))) {\n    if ((i2cHandle->EventCount == 0) && ((i2cHandle->Init).AddressingMode == 0xc000)) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n      i2cHandle->EventCount = i2cHandle->EventCount + 1;\n    }\n    else {\n      if (i2cHandle->XferCount == 0) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      else if (i2cHandle->XferCount == 1) {\n        if (tempVar1 == 0xffff0000) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cInstance = i2cHandle->Instance;\n          if ((i2cInstance->CR2 & 0x800) == 0) {\n            i2cInstance->CR1 = i2cInstance->CR1 | 0x200;\n          }\n          else {\n            i2cInstance->CR1 = i2cInstance->CR1 & 0xfffffbff;\n          }\n        }\n        else if (((tempVar1 == 4) || (tempVar1 == 8)) || (i2cHandle->PreviousState == 0x12)) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        }\n        else if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n        }\n      }\n      else if (i2cHandle->XferCount == 2) {\n        if (i2cHandle->XferOptions == 2) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        }\n        else {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x800;\n        }\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      else {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n        i2cInstance = i2cHandle->Instance;\n        if ((i2cInstance->CR2 & 0x800) != 0) {\n          i2cInstance->CR2 = i2cInstance->CR2 | 0x1000;\n        }\n      }\n      i2cHandle->EventCount = 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001256": "handle_i2_c_events_08001256",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar1": "tempVar1",
                "pIVar2": "i2cInstance",
                "Prev_State": "previousState",
                "tmpreg": "temporaryRegister",
                "tmpreg_1": "temporaryRegister1",
                "tmpreg_2": "temporaryRegister2",
                "tmpreg_3": "temporaryRegister3",
                "tmpreg_4": "temporaryRegister4",
                "tmpreg_5": "temporaryRegister5",
                "tmpreg_6": "temporaryRegister6",
                "tmpreg_7": "temporaryRegister7",
                "tmpreg_8": "temporaryRegister8",
                "tmpreg_9": "temporaryRegister9"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001420": {
            "entrypoint": "0x08001420",
            "current_name": "send_byte_via_i2c_08001420",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef send_byte_via_i2c_08001420(I2C_HandleTypeDef *hi2c_struct)\n\n{\n  byte *buffer_ptr;\n  \n  if (hi2c_struct->transfer_count != 0) {\n    buffer_ptr = hi2c_struct->buffer_pointer;\n    hi2c_struct->buffer_pointer = buffer_ptr + 1;\n    hi2c_struct->i2c_instance->data_register = (uint)*buffer_ptr;\n    hi2c_struct->transfer_count = hi2c_struct->transfer_count - 1;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001420": "send_byte_via_i2c_08001420",
                "hi2c": "hi2c_struct",
                "pbVar1": "buffer_ptr",
                "pBuffPtr": "buffer_pointer",
                "Instance": "i2c_instance",
                "DR": "data_register",
                "XferCount": "transfer_count"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001440": {
            "entrypoint": "0x08001440",
            "current_name": "read_byte_from_i2_c_08001440",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef readByteFromI2C_08001440(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *bufferPointer;\n  \n  if (i2cHandle->transferCount != 0) {\n    bufferPointer = i2cHandle->dataBufferPointer;\n    i2cHandle->dataBufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_Status_Success;\n}\n\n",
            "renaming": {
                "FUN_08001440": "read_byte_from_i2_c_08001440",
                "hi2c": "i2cHandle",
                "puVar1": "bufferPointer",
                "XferCount": "transferCount",
                "pBuffPtr": "dataBufferPointer",
                "Instance": "i2cInstance",
                "DR": "dataRegister",
                "HAL_OK": "HAL_Status_Success"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001460": {
            "entrypoint": "0x08001460",
            "current_name": "slave_transfer_08001460",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nslaveTransfer_08001460(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t tempRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_TX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001460": "slave_transfer_08001460",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "listen_and_receive_data_080014ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nlistenAndReceiveData_080014ec(I2C_HandleTypeDef *i2cHandle,uint8_t *data,uint16_t size,uint32_t transferOptions)\n\n{\n  HAL_StatusTypeDef status;\n  I2C_TypeDef *i2cInstance;\n  uint32_t temporaryRegister;\n  \n  if (i2cHandle->State == HAL_I2C_STATE_LISTEN) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (size == 0) {\n      status = HAL_ERROR;\n    }\n    else if (i2cHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      i2cHandle->Lock = HAL_LOCKED;\n      i2cInstance = i2cHandle->Instance;\n      if ((i2cInstance->CR1 & 1) == 0) {\n        i2cInstance->CR1 = i2cInstance->CR1 | 1;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n      i2cHandle->State = HAL_I2C_STATE_BUSY_RX_LISTEN;\n      i2cHandle->Mode = HAL_I2C_MODE_SLAVE;\n      status = HAL_OK;\n      i2cHandle->ErrorCode = 0;\n      i2cHandle->pBuffPtr = data;\n      i2cHandle->XferCount = size;\n      i2cHandle->transferOptions = transferOptions;\n      i2cHandle->Xfersize = i2cHandle->XferCount;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 | 0x700;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "listen_and_receive_data_080014ec",
                "hi2c": "i2cHandle",
                "pData": "data",
                "Size": "size",
                "XferOptions": "transferOptions",
                "HVar1": "status",
                "pIVar2": "i2cInstance",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001578": {
            "entrypoint": "0x08001578",
            "current_name": "initialize_i2_c_08001578",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeI2C_08001578(I2CHandler *i2cHandler)\n\n{\n  I2C *i2cInstance;\n  \n  if (i2cHandler->State != Ready) {\n    return Busy;\n  }\n  i2cHandler->State = Listen;\n  i2cInstance = i2cHandler->Instance;\n  if ((i2cInstance->CR1 & 1) == 0) {\n    i2cInstance->CR1 = i2cInstance->CR1 | 1;\n  }\n  i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x400;\n  i2cHandler->Instance->CR2 = i2cHandler->Instance->CR2 | 0x300;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001578": "initialize_i2_c_08001578",
                "hi2c": "i2cHandler",
                "pIVar1": "i2cInstance",
                "HAL_I2C_STATE_READY": "Ready",
                "HAL_BUSY": "Busy",
                "HAL_I2C_STATE_LISTEN": "Listen",
                "I2C_TypeDef": "I2C",
                "I2C_HandleTypeDef": "I2CHandler"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b6": {
            "entrypoint": "0x080015b6",
            "current_name": "FUNC_080015b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b6(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b6": "FUNC_080015b6"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015b8": {
            "entrypoint": "0x080015b8",
            "current_name": "FUNC_080015b8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015b8(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b8": "FUNC_080015b8"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015ba": {
            "entrypoint": "0x080015ba",
            "current_name": "FUNC_080015ba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080015ba(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015ba": "FUNC_080015ba"
            },
            "calling": [
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_AF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080015bc": {
            "entrypoint": "0x080015bc",
            "current_name": "send_data_via_i2_c_080015bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef sendDataViaI2C_080015bc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2CState currentState;\n  byte *bufferPointer;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    i2cHandle->Instance->DR = (uint)*bufferPointer;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x21;\n      i2cHandle->State = HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n    }\n    return SUCCESS;\n  }\n  return SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_080015bc": "send_data_via_i2_c_080015bc",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pbVar2": "bufferPointer",
                "HAL_I2C_StateTypeDef": "I2CState",
                "HAL_I2C_STATE_BUSY_TX_LISTEN": "I2C_STATE_BUSY_TX_LISTEN",
                "HAL_OK": "SUCCESS"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800160c": {
            "entrypoint": "0x0800160c",
            "current_name": "FUNC_0800160c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800160c(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800160c": "FUNC_0800160c"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_SlaveReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800160e": {
            "entrypoint": "0x0800160e",
            "current_name": "transfer_one_byte_0800160e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transferOneByte_0800160e(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2CState currentState;\n  uint8_t *bufferPointer;\n  \n  currentState = i2cHandle->State;\n  if (i2cHandle->XferCount != 0) {\n    bufferPointer = i2cHandle->pBuffPtr;\n    i2cHandle->pBuffPtr = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->Instance->DR;\n    i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    if ((i2cHandle->XferCount == 0) && (currentState == I2C_BUSY_RX_LISTEN)) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n      i2cHandle->PreviousState = 0x22;\n      i2cHandle->State = I2C_STATE_LISTEN;\n      I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800160e": "transfer_one_byte_0800160e",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "puVar2": "bufferPointer",
                "HAL_I2C_StateTypeDef": "I2CState",
                "HAL_I2C_STATE_BUSY_RX_LISTEN": "I2C_BUSY_RX_LISTEN",
                "HAL_I2C_STATE_LISTEN": "I2C_STATE_LISTEN",
                "HAL_I2C_SlaveRxCpltCallback": "I2C_SlaveRxCpltCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800165a": {
            "entrypoint": "0x0800165a",
            "current_name": "handle_i2_c_event_0800165a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CEvent_0800165a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint16_t matchCode;\n  \n  if ((i2cHandle->instance->statusRegister2 & 0x80) == 0) {\n    matchCode = *(uint16_t *)&(i2cHandle->initialization).ownAddress1;\n  }\n  else {\n    matchCode = *(uint16_t *)&(i2cHandle->initialization).ownAddress2;\n  }\n  HAL_I2C_AddrCallback(i2cHandle,(i2cHandle->instance->statusRegister2 & 4) == 0,matchCode);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800165a": "handle_i2_c_event_0800165a",
                "hi2c": "i2cHandle",
                "AddrMatchCode": "matchCode",
                "Instance": "instance",
                "SR2": "statusRegister2",
                "Init": "initialization",
                "OwnAddress1": "ownAddress1",
                "OwnAddress2": "ownAddress2"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001684": {
            "entrypoint": "0x08001684",
            "current_name": "handle_i2_c_state_08001684",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CState_08001684(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t currentTransferOptions;\n  uint32_t currentState;\n  \n  if (((i2cHandle->XferOptions == 4) || (i2cHandle->XferOptions == 8)) &&\n     (i2cHandle->State == HAL_I2C_STATE_LISTEN)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  else if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0x21;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n    i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(i2cHandle);\n  }\n  else {\n    i2cHandle->Instance->SR1 = 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001684": "handle_i2_c_state_08001684",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "currentTransferOptions",
                "CurrentState": "currentState"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001718": {
            "entrypoint": "0x08001718",
            "current_name": "FUNC_08001718",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001718(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001718": "FUNC_08001718"
            },
            "calling": [
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800171a": {
            "entrypoint": "0x0800171a",
            "current_name": "perform_i2_c_transfer_0800171a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nStatus performI2CTransfer_0800171a(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2CState currentState;\n  uint32_t currentI2CState;\n  byte *currentByte;\n  uint32_t currentTransferOptions;\n  uint32_t xferOptions;\n  \n  currentState = i2cHandle->State;\n  xferOptions = i2cHandle->XferOptions;\n  if ((i2cHandle->XferSize == 0) && (currentState == BUSY_TX)) {\n    if ((xferOptions == 4) || ((xferOptions == 8 || (xferOptions == 0xffff0000)))) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = READY;\n      if (i2cHandle->Mode == MEM_MODE) {\n        i2cHandle->Mode = NONE_MODE;\n        memTxCompleteCallback(i2cHandle);\n      }\n      else {\n        i2cHandle->Mode = NONE_MODE;\n        masterTxCompleteCallback(i2cHandle);\n      }\n    }\n    else {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n      i2cHandle->PreviousState = 0x11;\n      i2cHandle->Mode = NONE_MODE;\n      i2cHandle->State = READY;\n      masterTxCompleteCallback(i2cHandle);\n    }\n  }\n  else if ((currentState == BUSY_TX) ||\n          ((i2cHandle->Mode == MEM_MODE && (currentState == BUSY_RX)))) {\n    if (i2cHandle->XferCount == 0) {\n      i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffffbff;\n    }\n    else if (i2cHandle->Mode == MEM_MODE) {\n      if (i2cHandle->EventCount == 0) {\n        if (i2cHandle->MemaddSize == 1) {\n          i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n          i2cHandle->EventCount = i2cHandle->EventCount + 2;\n        }\n        else {\n          i2cHandle->Instance->DR = (i2cHandle->Memaddress << 0x10) >> 0x18;\n          i2cHandle->EventCount = i2cHandle->EventCount + 1;\n        }\n      }\n      else if (i2cHandle->EventCount == 1) {\n        i2cHandle->Instance->DR = i2cHandle->Memaddress & 0xff;\n        i2cHandle->EventCount = i2cHandle->EventCount + 1;\n      }\n      else if (i2cHandle->EventCount == 2) {\n        if (i2cHandle->State == BUSY_RX) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n        }\n        else if (i2cHandle->State == BUSY_TX) {\n          currentByte = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = currentByte + 1;\n          i2cHandle->Instance->DR = (uint)*currentByte;\n          i2cHandle->XferCount = i2cHandle->XferCount - 1;\n        }\n      }\n    }\n    else {\n      currentByte = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = currentByte + 1;\n      i2cHandle->Instance->DR = (uint)*currentByte;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return OK;\n}\n\n",
            "renaming": {
                "FUN_0800171a": "perform_i2_c_transfer_0800171a",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "CurrentState": "currentI2CState",
                "pbVar2": "currentByte",
                "CurrentXferOptions": "currentTransferOptions",
                "uVar3": "xferOptions",
                "HAL_StatusTypeDef": "Status",
                "HAL_I2C_StateTypeDef": "I2CState",
                "HAL_I2C_MODE_MEM": "MEM_MODE",
                "HAL_I2C_MODE_NONE": "NONE_MODE",
                "HAL_I2C_STATE_BUSY_TX": "BUSY_TX",
                "HAL_I2C_STATE_BUSY_RX": "BUSY_RX",
                "HAL_I2C_STATE_READY": "READY",
                "HAL_OK": "OK",
                "HAL_I2C_MemTxCpltCallback": "memTxCompleteCallback",
                "HAL_I2C_MasterTxCpltCallback": "masterTxCompleteCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001864": {
            "entrypoint": "0x08001864",
            "current_name": "handle_i2_c_interrupt_08001864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CInterrupt_08001864(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t transferOptions;\n  uint32_t currentTransferOptions;\n  byte *bufferPointer;\n  \n  transferOptions = i2cHandle->XferOptions;\n  if (i2cHandle->State == HAL_I2C_STATE_BUSY_TX) {\n    if (i2cHandle->XferCount == 0) {\n      if (((transferOptions == 4) || (transferOptions == 8)) || (transferOptions == 0xffff0000)) {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        i2cHandle->PreviousState = 0;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        if (i2cHandle->Mode == HAL_I2C_MODE_MEM) {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(i2cHandle);\n        }\n        else {\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(i2cHandle);\n        }\n      }\n      else {\n        i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n        i2cHandle->PreviousState = 0x11;\n        i2cHandle->Mode = HAL_I2C_MODE_NONE;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(i2cHandle);\n      }\n    }\n    else {\n      bufferPointer = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = bufferPointer + 1;\n      i2cHandle->Instance->DR = (uint)*bufferPointer;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001864": "handle_i2_c_interrupt_08001864",
                "hi2c": "i2cHandle",
                "uVar1": "transferOptions",
                "CurrentXferOptions": "currentTransferOptions",
                "pbVar2": "bufferPointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemTxCpltCallback",
                "HAL_I2C_MasterTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001902": {
            "entrypoint": "0x08001902",
            "current_name": "FUNC_08001902",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001902(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001902": "FUNC_08001902"
            },
            "calling": [
                "I2C_MasterReceive_BTF",
                "I2C_MasterReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001904": {
            "entrypoint": "0x08001904",
            "current_name": "handle_i2_c_rx_transfer_08001904",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CRxTransfer_08001904(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint8_t *bufferPtr;\n  \n  if (i2cHandle->currentState == HAL_I2C_STATE_BUSY_RECEIVE) {\n    if (i2cHandle->transferCount < 4) {\n      if (i2cHandle->transferCount < 2) {\n        i2cHandle->i2cInstance->controlReg1 = i2cHandle->i2cInstance->controlReg1 & 0xfffffbff;\n        i2cHandle->i2cInstance->controlReg2 = i2cHandle->i2cInstance->controlReg2 & 0xfffff8ff;\n        bufferPtr = i2cHandle->dataBufferPtr;\n        i2cHandle->dataBufferPtr = bufferPtr + 1;\n        *bufferPtr = (uint8_t)i2cHandle->i2cInstance->DR;\n        i2cHandle->transferCount = i2cHandle->transferCount - 1;\n        i2cHandle->currentState = HAL_I2C_STATE_IDLE;\n        i2cHandle->PreviouscurrentState = 0;\n        if (i2cHandle->i2cMode == HAL_I2C_MODE_MEMORY) {\n          i2cHandle->i2cMode = HAL_I2C_MODE_NORMAL;\n          handleI2CMemRxCplt(i2cHandle);\n        }\n        else {\n          i2cHandle->i2cMode = HAL_I2C_MODE_NORMAL;\n          handleI2CMasterRxCplt(i2cHandle);\n        }\n      }\n    }\n    else {\n      bufferPtr = i2cHandle->dataBufferPtr;\n      i2cHandle->dataBufferPtr = bufferPtr + 1;\n      *bufferPtr = (uint8_t)i2cHandle->i2cInstance->DR;\n      i2cHandle->transferCount = i2cHandle->transferCount - 1;\n      if (i2cHandle->transferCount == 3) {\n        i2cHandle->i2cInstance->controlReg2 = i2cHandle->i2cInstance->controlReg2 & 0xfffffbff;\n      }\n    }\n  }\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08001904": "handle_i2_c_rx_transfer_08001904",
                "hi2c": "i2cHandle",
                "puVar1": "bufferPtr",
                "State": "currentState",
                "XferCount": "transferCount",
                "Instance": "i2cInstance",
                "CR1": "controlReg1",
                "CR2": "controlReg2",
                "pBuffPtr": "dataBufferPtr",
                "Mode": "i2cMode",
                "HAL_I2C_STATE_BUSY_RX": "HAL_I2C_STATE_BUSY_RECEIVE",
                "HAL_I2C_STATE_READY": "HAL_I2C_STATE_IDLE",
                "HAL_I2C_MODE_MEM": "HAL_I2C_MODE_MEMORY",
                "HAL_I2C_MODE_NONE": "HAL_I2C_MODE_NORMAL",
                "HAL_OK": "HAL_SUCCESS",
                "HAL_I2C_MemRxCpltCallback": "handleI2CMemRxCplt",
                "HAL_I2C_MasterRxCpltCallback": "handleI2CMasterRxCplt"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019a0": {
            "entrypoint": "0x080019a0",
            "current_name": "handle_i2_c_data_transfer_080019a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef handleI2CDataTransfer_080019a0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  uint32_t xferOptions;\n  uint8_t *bufferPointer;\n  \n  if (i2cHandle->transferCount == 4) {\n    i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n    bufferPointer = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  else if (i2cHandle->transferCount == 3) {\n    i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffbff;\n    i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n    bufferPointer = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  else if (i2cHandle->transferCount == 2) {\n    if (i2cHandle->transferOptions - 1 < 2) {\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 & 0xfffffbff;\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x100;\n    }\n    else {\n      i2cHandle->i2cInstance->controlRegister1 = i2cHandle->i2cInstance->controlRegister1 | 0x200;\n    }\n    bufferPointer = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    bufferPointer = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n    i2cHandle->i2cInstance->controlRegister2 = i2cHandle->i2cInstance->controlRegister2 & 0xfffffcff;\n    i2cHandle->currentState = I2C_STATE_READY;\n    i2cHandle->previousState = 0;\n    if (i2cHandle->operationMode == I2C_MODE_MEM) {\n      i2cHandle->operationMode = I2C_MODE_NONE;\n      I2C_MemReceiveCompleteCallback(i2cHandle);\n    }\n    else {\n      i2cHandle->operationMode = I2C_MODE_NONE;\n      I2C_MasterReceiveCompleteCallback(i2cHandle);\n    }\n  }\n  else {\n    bufferPointer = i2cHandle->bufferPointer;\n    i2cHandle->bufferPointer = bufferPointer + 1;\n    *bufferPointer = (uint8_t)i2cHandle->i2cInstance->dataRegister;\n    i2cHandle->transferCount = i2cHandle->transferCount - 1;\n  }\n  return HAL_Status_OK;\n}\n\n",
            "renaming": {
                "FUN_080019a0": "handle_i2_c_data_transfer_080019a0",
                "hi2c": "i2cHandle",
                "CurrentXferOptions": "xferOptions",
                "puVar1": "bufferPointer",
                "Instance": "i2cInstance",
                "CR2": "controlRegister2",
                "pBuffPtr": "bufferPointer",
                "XferCount": "transferCount",
                "DR": "dataRegister",
                "CR1": "controlRegister1",
                "XferOptions": "transferOptions",
                "State": "currentState",
                "PreviousState": "previousState",
                "Mode": "operationMode",
                "HAL_OK": "HAL_Status_OK",
                "HAL_I2C_STATE_READY": "I2C_STATE_READY",
                "HAL_I2C_MODE_MEM": "I2C_MODE_MEM",
                "HAL_I2C_MODE_NONE": "I2C_MODE_NONE",
                "HAL_I2C_MasterRxCpltCallback": "I2C_MasterReceiveCompleteCallback",
                "HAL_I2C_MemRxCpltCallback": "I2C_MemReceiveCompleteCallback"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MemRxCpltCallback",
                "HAL_I2C_MasterRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001aac": {
            "entrypoint": "0x08001aac",
            "current_name": "FUNC_08001aac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08001aac(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001aac": "FUNC_08001aac"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "handle_i2_c_state_08001ab0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CState_08001ab0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_StatusTypeDef status;\n  uint8_t *dataPtr;\n  I2C_TypeDef *i2cInstance;\n  \n  if (i2cHandle->State - 0x29 < 2) {\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((i2cHandle->State != HAL_I2C_STATE_ABORT) && ((i2cHandle->Instance->CR2 & 0x800) == 0)) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n    }\n    i2cHandle->PreviousState = 0;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  }\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffff7ff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) == 0) {\n    if (i2cHandle->State == HAL_I2C_STATE_ABORT) {\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->ErrorCode = 0;\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cInstance->DR;\n      }\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(i2cHandle);\n    }\n    else {\n      if ((i2cInstance->SR1 & 0x40) != 0) {\n        dataPtr = i2cHandle->pBuffPtr;\n        i2cHandle->pBuffPtr = dataPtr + 1;\n        *dataPtr = (uint8_t)i2cInstance->DR;\n      }\n      HAL_I2C_ErrorCallback(i2cHandle);\n    }\n  }\n  else {\n    i2cInstance->CR2 = i2cInstance->CR2 & 0xfffff7ff;\n    if (i2cHandle->hdmatx->State == HAL_DMA_STATE_READY) {\n      i2cHandle->hdmarx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmarx);\n      if (status != HAL_OK) {\n        if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n          dataPtr = i2cHandle->pBuffPtr;\n          i2cHandle->pBuffPtr = dataPtr + 1;\n          *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n        }\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmarx->XferAbortCallback)(i2cHandle->hdmarx);\n      }\n    }\n    else {\n      i2cHandle->hdmatx->XferAbortCallback = I2C_DMAAbort + 1;\n      status = HAL_DMA_Abort_IT(i2cHandle->hdmatx);\n      if (status != HAL_OK) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffffe;\n        i2cHandle->State = HAL_I2C_STATE_READY;\n        (*i2cHandle->hdmatx->XferAbortCallback)(i2cHandle->hdmatx);\n      }\n    }\n  }\n  if ((i2cHandle->State == HAL_I2C_STATE_LISTEN) && ((i2cHandle->ErrorCode & 4) != 0)) {\n    i2cHandle->XferOptions = 0xffff0000;\n    i2cHandle->PreviousState = 0;\n    i2cHandle->State = HAL_I2C_STATE_READY;\n    i2cHandle->Mode = HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "handle_i2_c_state_08001ab0",
                "hi2c": "i2cHandle",
                "HVar1": "status",
                "puVar2": "dataPtr",
                "pIVar3": "i2cInstance"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001bfc": {
            "entrypoint": "0x08001bfc",
            "current_name": "process_i2_c_data_08001bfc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef processI2CData_08001bfc(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef currentState;\n  I2C_TypeDef *i2cInstance;\n  uint8_t *dataPtr;\n  uint32_t currentStateValue;\n  uint32_t temporaryRegister;\n  \n  currentState = i2cHandle->State;\n  i2cHandle->Instance->CR2 = i2cHandle->Instance->CR2 & 0xfffff8ff;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 1;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 & 0xfffffbff;\n  i2cInstance = i2cHandle->Instance;\n  if ((i2cInstance->CR2 & 0x800) != 0) {\n    if ((i2cHandle->State == HAL_I2C_STATE_BUSY_RX) || (i2cHandle->State == HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmarx->Instance->NDTR;\n    }\n    else {\n      i2cHandle->XferCount = (uint16_t)i2cHandle->hdmatx->Instance->NDTR;\n    }\n  }\n  if (i2cHandle->XferCount != 0) {\n    if ((i2cInstance->SR1 & 4) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cInstance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x40) != 0) {\n      dataPtr = i2cHandle->pBuffPtr;\n      i2cHandle->pBuffPtr = dataPtr + 1;\n      *dataPtr = (uint8_t)i2cHandle->Instance->DR;\n      i2cHandle->XferCount = i2cHandle->XferCount - 1;\n    }\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n  }\n  if (i2cHandle->ErrorCode == 0) {\n    if (((currentState == HAL_I2C_STATE_LISTEN) || (currentState == HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (currentState == HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      i2cHandle->XferOptions = 0xffff0000;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(i2cHandle);\n    }\n    else if ((i2cHandle->PreviousState == 0x22) || (currentState == HAL_I2C_STATE_BUSY_RX)) {\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Mode = HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(i2cHandle);\n    }\n  }\n  else {\n    I2C_ITError(i2cHandle);\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08001bfc": "process_i2_c_data_08001bfc",
                "hi2c": "i2cHandle",
                "HVar1": "currentState",
                "pIVar2": "i2cInstance",
                "puVar3": "dataPtr",
                "CurrentState": "currentStateValue",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001d00": {
            "entrypoint": "0x08001d00",
            "current_name": "process_i2_c_events_08001d00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processI2CEvents_08001d00(I2C_HandleTypeDef *i2cHandle)\n\n{\n  I2C_TypeDef *i2cInstance;\n  uint32_t currentMode;\n  uint statusRegister1;\n  uint32_t statusRegister1ITFlags;\n  uint controlRegister2;\n  uint32_t interruptSources;\n  uint statusRegister2;\n  uint32_t sr2itflags;\n  \n  i2cInstance = i2cHandle->Instance;\n  statusRegister2 = i2cInstance->SR2;\n  statusRegister1 = i2cInstance->SR1;\n  controlRegister2 = i2cInstance->CR2;\n  if ((i2cHandle->Mode == HAL_I2C_MODE_MASTER) || (i2cHandle->Mode == HAL_I2C_MODE_MEM)) {\n    if (((statusRegister1 & 0x10001) == 0) || ((controlRegister2 & 0x200) == 0)) {\n      if (((statusRegister1 & 0x10008) == 0) || ((controlRegister2 & 0x200) == 0)) {\n        if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n          I2C_Master_ADDR(i2cHandle);\n        }\n      }\n      else {\n        I2C_Master_ADD10(i2cHandle);\n      }\n    }\n    else {\n      I2C_Master_SB(i2cHandle);\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterReceive_BTF(i2cHandle);\n        return;\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_MasterTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_MasterTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  else {\n    if (((statusRegister1 & 0x10002) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_ADDR(i2cHandle);\n      return;\n    }\n    if (((statusRegister1 & 0x10010) != 0) && ((controlRegister2 & 0x200) != 0)) {\n      I2C_Slave_STOPF(i2cHandle);\n      return;\n    }\n    if ((statusRegister2 & 0x100004) == 0) {\n      if ((((statusRegister1 & 0x10040) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveReceive_RXNE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveReceive_BTF(i2cHandle);\n      }\n    }\n    else {\n      if ((((statusRegister1 & 0x10080) != 0) && ((controlRegister2 & 0x400) != 0)) && ((statusRegister1 & 0x10004) == 0)) {\n        I2C_SlaveTransmit_TXE(i2cHandle);\n        return;\n      }\n      if (((statusRegister1 & 0x10004) != 0) && ((controlRegister2 & 0x200) != 0)) {\n        I2C_SlaveTransmit_BTF(i2cHandle);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001d00": "process_i2_c_events_08001d00",
                "hi2c": "i2cHandle",
                "pIVar1": "i2cInstance",
                "CurrentMode": "currentMode",
                "uVar2": "statusRegister1",
                "sr1itflags": "statusRegister1ITFlags",
                "uVar3": "controlRegister2",
                "itsources": "interruptSources",
                "uVar4": "statusRegister2"
            },
            "calling": [
                "I2C2_EV_IRQHandler",
                "I2C1_EV_IRQHandler",
                "I2C3_EV_IRQHandler"
            ],
            "called": [
                "I2C_Slave_STOPF",
                "I2C_MasterReceive_BTF",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_ADD10",
                "I2C_Master_SB",
                "I2C_MasterTransmit_TXE",
                "I2C_Master_ADDR",
                "I2C_SlaveReceive_BTF",
                "I2C_SlaveTransmit_TXE",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterReceive_RXNE",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e68": {
            "entrypoint": "0x08001e68",
            "current_name": "handle_i2_c_events_08001e68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08001e68(I2C_HandleTypeDef *i2cHandle)\n\n{\n  HAL_I2C_StateTypeDef i2cState;\n  I2C_TypeDef *i2cInstance;\n  uint32_t interruptFlags;\n  uint sr1Value;\n  uint32_t itsources;\n  uint cr2Value;\n  \n  i2cInstance = i2cHandle->Instance;\n  sr1Value = i2cInstance->SR1;\n  cr2Value = i2cInstance->CR2;\n  if (((sr1Value & 0x10100) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 1;\n    i2cInstance->SR1 = 0xfffffeff;\n  }\n  if (((sr1Value & 0x10200) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 2;\n    i2cHandle->Instance->SR1 = 0xfffffdff;\n  }\n  if (((sr1Value & 0x10400) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cState = i2cHandle->State;\n    if (((i2cHandle->Mode == HAL_I2C_MODE_SLAVE) && (i2cHandle->XferCount == 0)) &&\n       (((i2cState == HAL_I2C_STATE_BUSY_TX || (i2cState == HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((i2cState == HAL_I2C_STATE_LISTEN && (i2cHandle->PreviousState == 0x21)))))) {\n      I2C_Slave_AF(i2cHandle);\n    }\n    else {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 4;\n      if (i2cHandle->Mode == HAL_I2C_MODE_MASTER) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      }\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n    }\n  }\n  if (((sr1Value & 0x10800) != 0) && ((cr2Value & 0x100) != 0)) {\n    i2cHandle->ErrorCode = i2cHandle->ErrorCode | 8;\n    i2cHandle->Instance->SR1 = 0xfffff7ff;\n  }\n  if (i2cHandle->ErrorCode != 0) {\n    I2C_ITError(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001e68": "handle_i2_c_events_08001e68",
                "hi2c": "i2cHandle",
                "HVar1": "i2cState",
                "pIVar2": "i2cInstance",
                "sr1itflags": "interruptFlags",
                "uVar3": "sr1Value",
                "uVar4": "cr2Value"
            },
            "calling": [
                "I2C3_ER_IRQHandler",
                "I2C2_ER_IRQHandler",
                "I2C1_ER_IRQHandler"
            ],
            "called": [
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f3c": {
            "entrypoint": "0x08001f3c",
            "current_name": "reset_i2_c_08001f3c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetI2C_08001f3c(DMA_HandleTypeDef *dmaHandle)\n\n{\n  I2C_HandleTypeDef *i2cHandleParent;\n  I2C_HandleTypeDef *i2cHandle;\n  \n  i2cHandleParent = (I2C_HandleTypeDef *)dmaHandle->Parent;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffbff;\n  i2cHandleParent->XferCount = 0;\n  i2cHandleParent->dmaHandletx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  i2cHandleParent->dmaHandlerx->XferAbortCallback = (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (i2cHandleParent->State != HAL_I2C_STATE_ABORT) {\n    i2cHandleParent->State = HAL_I2C_STATE_READY;\n    i2cHandleParent->Mode = HAL_I2C_MODE_NONE;\n    i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n    handleI2CError(i2cHandleParent);\n    return;\n  }\n  i2cHandleParent->State = HAL_I2C_STATE_READY;\n  i2cHandleParent->Mode = HAL_I2C_MODE_NONE;\n  i2cHandleParent->ErrorCode = 0;\n  i2cHandleParent->Instance->CR1 = i2cHandleParent->Instance->CR1 & 0xfffffffe;\n  handleI2CAbortComplete(i2cHandleParent);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001f3c": "reset_i2_c_08001f3c",
                "hdma": "dmaHandle",
                "hi2c_00": "i2cHandleParent",
                "hi2c": "i2cHandle",
                "HAL_I2C_ErrorCallback": "handleI2CError",
                "HAL_I2C_AbortCpltCallback": "handleI2CAbortComplete"
            },
            "calling": [],
            "called": [
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f9c": {
            "entrypoint": "0x08001f9c",
            "current_name": "check_timeout_08001f9c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nstatus checkTimeout_08001f9c(void)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t tmpreg;\n  \n  _DAT_40023840 = _DAT_40023840 | 0x10000000;\n  _DAT_420e0040 = 1;\n  uVar1 = getCurrentTick();\n  do {\n    if ((_DAT_40007004 & 0x10000) != 0) {\n      _DAT_420e0044 = 1;\n      uVar1 = getCurrentTick();\n      do {\n        if ((_DAT_40007004 & 0x20000) != 0) {\n          return HAL_OK;\n        }\n        uVar2 = getCurrentTick();\n      } while (uVar2 - uVar1 < 0x3e9);\n      return HAL_TIMEOUT;\n    }\n    uVar2 = getCurrentTick();\n  } while (uVar2 - uVar1 < 0x3e9);\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08001f9c": "check_timeout_08001f9c",
                "HAL_GetTick": "getCurrentTick",
                "HAL_StatusTypeDef": "status"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800201c": {
            "entrypoint": "0x0800201c",
            "current_name": "rcc_configure_oscillators_0800201c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef rcc_configure_oscillators_0800201c(RCC_OscInitTypeDef_conflict *osc_init_conf)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t start_time;\n  uint32_t current_time;\n  uint32_t tick_start;\n  bool is_osc_disabled;\n  uint32_t temporary_register;\n  \n  if (osc_init_conf == (RCC_OscInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if ((osc_init_conf->OscillatorType & 1) != 0) {\n    if (((_DAT_40023808 & 0xc) == 4) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) != 0)))) {\n      if (((_DAT_40023800 & 0x20000) != 0) && (osc_init_conf->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (osc_init_conf->HSEState == 0x10000) {\n        _DAT_40023800 = _DAT_40023800 | 0x10000;\n      }\n      else if (osc_init_conf->HSEState == 0x50000) {\n        _DAT_40023800 = _DAT_40023800 | 0x50000;\n      }\n      else {\n        _DAT_40023800 = _DAT_40023800 & 0xfffaffff;\n      }\n      if (osc_init_conf->HSEState == 0) {\n        start_time = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) != 0) {\n          current_time = HAL_GetTick();\n          if (100 < current_time - start_time) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        start_time = HAL_GetTick();\n        while ((_DAT_40023800 & 0x20000) == 0) {\n          current_time = HAL_GetTick();\n          if (100 < current_time - start_time) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((osc_init_conf->OscillatorType & 2) != 0) {\n    if (((_DAT_40023808 & 0xc) == 0) ||\n       (((_DAT_40023808 & 0xc) == 8 && ((_DAT_40023804 & 0x400000) == 0)))) {\n      if (((_DAT_40023800 & 2) != 0) && (osc_init_conf->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | osc_init_conf->HSICalibrationValue << 3;\n    }\n    else if (osc_init_conf->HSIState == 0) {\n      _DAT_42470000 = 0;\n      start_time = HAL_GetTick();\n      while ((_DAT_40023800 & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 = 1;\n      start_time = HAL_GetTick();\n      while ((_DAT_40023800 & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 = _DAT_40023800 & 0xffffff07 | osc_init_conf->HSICalibrationValue << 3;\n    }\n  }\n  if ((osc_init_conf->OscillatorType & 8) != 0) {\n    if (osc_init_conf->LSIState == 0) {\n      _DAT_42470e80 = 0;\n      start_time = HAL_GetTick();\n      while ((_DAT_40023874 & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 = 1;\n      start_time = HAL_GetTick();\n      while ((_DAT_40023874 & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((osc_init_conf->OscillatorType & 4) != 0) {\n    is_osc_disabled = (_DAT_40023840 & 0x10000000) == 0;\n    if (is_osc_disabled) {\n      _DAT_40023840 = _DAT_40023840 | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      start_time = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        current_time = HAL_GetTick();\n        if (2 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (osc_init_conf->LSEState == 1) {\n      _DAT_40023870 = _DAT_40023870 | 1;\n    }\n    else if (osc_init_conf->LSEState == 5) {\n      _DAT_40023870 = _DAT_40023870 | 5;\n    }\n    else {\n      _DAT_40023870 = _DAT_40023870 & 0xfffffffa;\n    }\n    if (osc_init_conf->LSEState == 0) {\n      start_time = HAL_GetTick();\n      while ((_DAT_40023870 & 2) != 0) {\n        current_time = HAL_GetTick();\n        if (5000 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      start_time = HAL_GetTick();\n      while ((_DAT_40023870 & 2) == 0) {\n        current_time = HAL_GetTick();\n        if (5000 < current_time - start_time) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (is_osc_disabled) {\n      _DAT_40023840 = _DAT_40023840 & 0xefffffff;\n    }\n  }\n  start_time = (osc_init_conf->PLL).PLLState;\n  if (start_time == 0) {\n    status = HAL_OK;\n  }\n  else if ((_DAT_40023808 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if (start_time == 2) {\n    _DAT_42470060 = 0;\n    start_time = HAL_GetTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        _DAT_40023804 =\n             (osc_init_conf->PLL).PLLSource | (osc_init_conf->PLL).PLLM |\n             (osc_init_conf->PLL).PLLN << 6 |\n             (((osc_init_conf->PLL).PLLP >> 1) - 1) * 0x10000 |\n             (osc_init_conf->PLL).PLLQ << 0x18;\n        _DAT_42470060 = 1;\n        start_time = HAL_GetTick();\n        do {\n          if ((_DAT_40023800 & 0x2000000) != 0) {\n            return HAL_OK;\n          }\n          current_time = HAL_GetTick();\n        } while (current_time - start_time < 3);\n        return HAL_TIMEOUT;\n      }\n      current_time = HAL_GetTick();\n    } while (current_time - start_time < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42470060 = 0;\n    start_time = HAL_GetTick();\n    do {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_OK;\n      }\n      current_time = HAL_GetTick();\n    } while (current_time - start_time < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800201c": "rcc_configure_oscillators_0800201c",
                "RCC_OscInitStruct": "osc_init_conf",
                "HVar1": "status",
                "uVar2": "start_time",
                "uVar3": "current_time",
                "tickstart": "tick_start",
                "bVar4": "is_osc_disabled",
                "tmpreg": "temporary_register"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080023b4": {
            "entrypoint": "0x080023b4",
            "current_name": "calculate_clock_frequency_080023b4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculate_clock_frequency_080023b4(void)\n\n{\n  uint clock_frequency;\n  \n  if ((_DAT_40023808 & 0xc) == 4) {\n    return 8000000;\n  }\n  if ((_DAT_40023808 & 0xc) != 8) {\n    return 16000000;\n  }\n  if ((_DAT_40023804 & 0x400000) == 0) {\n    clock_frequency = (_DAT_40023804 << 0x11) >> 0x17;\n    clock_frequency = __aeabi_uldivmod(clock_frequency * 16000000,\n                             (((uint)(clock_frequency * 0x20 < clock_frequency) * -0x3f -\n                              (uint)(clock_frequency * 0x7c0 < clock_frequency * 0x1f)) * 8 +\n                             (uint)CARRY4(clock_frequency * 0x3d08,clock_frequency)) * 0x400 | clock_frequency * 0x3d09 >> 0x16,\n                             _DAT_40023804 & 0x3f,0);\n  }\n  else {\n    clock_frequency = (_DAT_40023804 << 0x11) >> 0x17;\n    clock_frequency = __aeabi_uldivmod(clock_frequency * 8000000,\n                             (((uint)(clock_frequency * 0x20 < clock_frequency) * -0x3f -\n                              (uint)(clock_frequency * 0x7c0 < clock_frequency * 0x1f)) * 8 +\n                             (uint)CARRY4(clock_frequency * 0x3d08,clock_frequency)) * 0x200,_DAT_40023804 & 0x3f,0);\n  }\n  return clock_frequency / ((((_DAT_40023804 << 0xe) >> 0x1e) + 1) * 2);\n}\n\n",
            "renaming": {
                "FUN_080023b4": "calculate_clock_frequency_080023b4",
                "uVar1": "clock_frequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002488": {
            "entrypoint": "0x08002488",
            "current_name": "configure_clocks_08002488",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef configureClocks_08002488(RCC_ClkInitTypeDef_conflict *clockInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t value1;\n  uint32_t value2;\n  uint value3;\n  uint32_t tickStart;\n  \n  if (clockInitStruct == (RCC_ClkInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if (((_DAT_40023c00 & 0xf) < flashLatency) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency), flashLatency != (flashLatency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((clockInitStruct->ClockType & 2) != 0) {\n    if ((clockInitStruct->ClockType & 4) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0x1c00;\n    }\n    if ((clockInitStruct->ClockType & 8) != 0) {\n      _DAT_40023808 = _DAT_40023808 | 0xe000;\n    }\n    _DAT_40023808 = _DAT_40023808 & 0xffffff0f | clockInitStruct->AHBCLKDivider;\n  }\n  if ((clockInitStruct->ClockType & 1) != 0) {\n    value3 = clockInitStruct->SYSCLKSource;\n    if (value3 == 1) {\n      if ((_DAT_40023800 & 0x20000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if (value3 - 2 < 2) {\n      if ((_DAT_40023800 & 0x2000000) == 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((_DAT_40023800 & 2) == 0) {\n      return HAL_ERROR;\n    }\n    _DAT_40023808 = value3 | _DAT_40023808 & 0xfffffffc;\n    value1 = HAL_GetTick();\n    while ((_DAT_40023808 & 0xc) != clockInitStruct->SYSCLKSource * 4) {\n      value2 = HAL_GetTick();\n      if (5000 < value2 - value1) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  if ((flashLatency < (_DAT_40023c00 & 0xf)) &&\n     (_DAT_40023c00 = CONCAT31(DAT_40023c00_1,(char)flashLatency), flashLatency != (flashLatency & 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((clockInitStruct->ClockType & 4) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffffe3ff | clockInitStruct->APB1CLKDivider;\n  }\n  if ((clockInitStruct->ClockType & 8) != 0) {\n    _DAT_40023808 = _DAT_40023808 & 0xffff1fff | clockInitStruct->APB2CLKDivider << 3;\n  }\n  value1 = HAL_RCC_GetSysClockFreq();\n  SystemCoreClock = value1 >> \"\"[(_DAT_40023808 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002488": "configure_clocks_08002488",
                "RCC_ClkInitStruct": "clockInitStruct",
                "FLatency": "flashLatency",
                "uVar1": "value1",
                "uVar2": "value2",
                "uVar3": "value3",
                "tickstart": "tickStart"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025e0": {
            "entrypoint": "0x080025e0",
            "current_name": "get_system_core_clock_080025e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_080025e0(void)\n\n{\n  return systemClock;\n}\n\n",
            "renaming": {
                "FUN_080025e0": "get_system_core_clock_080025e0",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "SystemClock_Config",
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080025ec": {
            "entrypoint": "0x080025ec",
            "current_name": "get_adjusted_hclk_freq_080025ec",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_080025ec(void)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = getHCLKFreq();\n  return hclkFreq >> \"\"[(uint)(_DAT_40023808 << 0x13) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_080025ec": "get_adjusted_hclk_freq_080025ec",
                "uVar1": "hclkFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800260c": {
            "entrypoint": "0x0800260c",
            "current_name": "get_adjusted_hclk_freq_0800260c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_0800260c(void)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> \"\"[(uint)(_DAT_40023808 << 0x10) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_0800260c": "get_adjusted_hclk_freq_0800260c",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800262c": {
            "entrypoint": "0x0800262c",
            "current_name": "handle_alarm_events_0800262c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid handleAlarmEvents_0800262c(RTC_HandleTypeDef *rtcHandle)\n\n{\n  if (((rtcHandle->Instance->interruptStatusRegister & 0x100) != 0) && ((rtcHandle->Instance->controlRegister & 0x1000) != 0)) {\n    handleAlarmACallback(rtcHandle);\n    rtcHandle->Instance->interruptStatusRegister = rtcHandle->Instance->interruptStatusRegister & 0xff | 0xfffffe7f;\n  }\n  if (((rtcHandle->Instance->interruptStatusRegister & 0x200) != 0) && ((rtcHandle->Instance->controlRegister & 0x2000) != 0)) {\n    handleAlarmBCallback(rtcHandle);\n    rtcHandle->Instance->interruptStatusRegister = rtcHandle->Instance->interruptStatusRegister & 0xff | 0xfffffd7f;\n  }\n  _DAT_40013c14 = 0x20000;\n  rtcHandle->State = HAL_RTC_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800262c": "handle_alarm_events_0800262c",
                "hrtc": "rtcHandle",
                "ISR": "interruptStatusRegister",
                "CR": "controlRegister",
                "HAL_RTC_AlarmAEventCallback": "handleAlarmACallback",
                "HAL_RTCEx_AlarmBEventCallback": "handleAlarmBCallback"
            },
            "calling": [
                "RTC_Alarm_IRQHandler"
            ],
            "called": [
                "HAL_RTC_AlarmAEventCallback",
                "HAL_RTCEx_AlarmBEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800268c": {
            "entrypoint": "0x0800268c",
            "current_name": "FUNC_0800268c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800268c(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800268c": "FUNC_0800268c"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800268e": {
            "entrypoint": "0x0800268e",
            "current_name": "reset_timer_0800268e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef resetTimer_0800268e(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timerHandle->State = HAL_TIM_STATE_BUSY;\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(timerHandle);\n  timerHandle->State = HAL_TIM_STATE_RESET;\n  timerHandle->Lock = HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800268e": "reset_timer_0800268e",
                "htim": "timerHandle",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080026c8": {
            "entrypoint": "0x080026c8",
            "current_name": "FUNC_080026c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026c8(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026c8": "FUNC_080026c8"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ca": {
            "entrypoint": "0x080026ca",
            "current_name": "FUNC_080026ca",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026ca(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ca": "FUNC_080026ca"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026cc": {
            "entrypoint": "0x080026cc",
            "current_name": "FUNC_080026cc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080026cc(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026cc": "FUNC_080026cc"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080026ce": {
            "entrypoint": "0x080026ce",
            "current_name": "handle_timer_interrupts_080026ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupts_080026ce(TIM_HandleTypeDef *timer)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 2) != 0) && ((timerInstance->DIER & 2) != 0)) {\n    timerInstance->SR = 0xfffffffd;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timer->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 4) != 0) && ((timerInstance->DIER & 4) != 0)) {\n    timerInstance->SR = 0xfffffffb;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timer->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 8) != 0) && ((timerInstance->DIER & 8) != 0)) {\n    timerInstance->SR = 0xfffffff7;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timer->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 0x10) != 0) && ((timerInstance->DIER & 0x10) != 0)) {\n    timerInstance->SR = 0xffffffef;\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timer->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    timer->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 1) != 0) && ((timerInstance->DIER & 1) != 0)) {\n    timerInstance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timer);\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 0x80) != 0) && ((timerInstance->DIER & 0x80) != 0)) {\n    timerInstance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timer);\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 0x40) != 0) && ((timerInstance->DIER & 0x40) != 0)) {\n    timerInstance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timer);\n  }\n  timerInstance = timer->Instance;\n  if (((timerInstance->SR & 0x20) != 0) && ((timerInstance->DIER & 0x20) != 0)) {\n    timerInstance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timer);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080026ce": "handle_timer_interrupts_080026ce",
                "htim": "timer",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "TIM3_IRQHandler",
                "TIM5_IRQHandler",
                "TIM1_UP_TIM10_IRQHandler",
                "TIM2_IRQHandler",
                "TIM6_DAC_IRQHandler",
                "TIM8_UP_TIM13_IRQHandler",
                "TIM4_IRQHandler",
                "TIM1_BRK_TIM9_IRQHandler",
                "TIM8_BRK_TIM12_IRQHandler",
                "TIM8_TRG_COM_TIM14_IRQHandler",
                "TIM7_IRQHandler",
                "TIM1_TRG_COM_TIM11_IRQHandler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIMEx_BreakCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "update_timer_channel_state_08002848",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTimerChannelState_08002848(TIM_TypeDef *timer,uint32_t channel,uint32_t state)\n\n{\n  timer->CCER = timer->CCER & ~(1 << (channel & 0xff));\n  timer->CCER = timer->CCER | state << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002848": "update_timer_channel_state_08002848",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelState": "state"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002864": {
            "entrypoint": "0x08002864",
            "current_name": "disable_channel_and_control_08002864",
            "code": "\n/* WARNING: Unknown calling convention */\n\nTIM_StatusTypeDef disableChannelAndControl_08002864(TIM_HandleTypeDef *timerHandle,uint32_t channelNumber)\n\n{\n  bool isSpecificTimer;\n  TIM_TypeDef *timer;\n  \n  TIM_CCxchannelNumberCmd(timerHandle->Instance,channelNumber,0);\n  timer = timerHandle->Instance;\n  if (timer == (TIM_TypeDef *)0x40010000) {\n    isSpecificTimer = true;\n  }\n  else if (timer == (TIM_TypeDef *)0x40010400) {\n    isSpecificTimer = true;\n  }\n  else {\n    isSpecificTimer = false;\n  }\n  if (((isSpecificTimer) && ((timer->CCER & 0x1111) == 0)) && ((timer->CCER & 0x444) == 0)) {\n    timer->BDTR = timer->BDTR & 0xffff7fff;\n  }\n  timer = timerHandle->Instance;\n  if (((timer->CCER & 0x1111) == 0) && ((timer->CCER & 0x444) == 0)) {\n    timer->CR1 = timer->CR1 & 0xfffffffe;\n  }\n  timerHandle->State = HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002864": "disable_channel_and_control_08002864",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "bVar1": "isSpecificTimer",
                "pTVar2": "timer",
                "HAL_StatusTypeDef": "TIM_StatusTypeDef"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d4": {
            "entrypoint": "0x080028d4",
            "current_name": "update_tim_channel_state_080028d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTIMChannelState_080028d4(TIM_TypeDef *timer,uint32_t channel,uint32_t newState)\n\n{\n  timer->CCER = timer->CCER & ~(4 << (channel & 0xff));\n  timer->CCER = timer->CCER | newState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080028d4": "update_tim_channel_state_080028d4",
                "TIMx": "timer",
                "Channel": "channel",
                "ChannelNState": "newState"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028f0": {
            "entrypoint": "0x080028f0",
            "current_name": "disable_timer_channel_080028f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef disableTimerChannel_080028f0(TIM_HandleTypeDef *timerHandle,uint32_t channelNumber)\n\n{\n  TIM_TypeDef *timerInstance;\n  \n  TIM_CCxNchannelNumberCmd(timerHandle->Instance,channelNumber,0);\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->BDTR = timerInstance->BDTR & 0xffff7fff;\n  }\n  timerInstance = timerHandle->Instance;\n  if (((timerInstance->CCER & 0x1111) == 0) && ((timerInstance->CCER & 0x444) == 0)) {\n    timerInstance->CR1 = timerInstance->CR1 & 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080028f0": "disable_timer_channel_080028f0",
                "htim": "timerHandle",
                "Channel": "channelNumber",
                "pTVar1": "timerInstance"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800293c": {
            "entrypoint": "0x0800293c",
            "current_name": "FUNC_0800293c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293c(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293c": "FUNC_0800293c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800293e": {
            "entrypoint": "0x0800293e",
            "current_name": "FUNC_0800293e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0800293e(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800293e": "FUNC_0800293e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002940": {
            "entrypoint": "0x08002940",
            "current_name": "reset_uart_instance_08002940",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_uart_instance_08002940(UART_HandleTypeDef *uart_handle)\n\n{\n  uart_handle->uart_instance->control_register_1 = uart_handle->uart_instance->control_register_1 & 0xfffffedf;\n  uart_handle->uart_instance->control_register_3 = uart_handle->uart_instance->control_register_3 & 0xfffffffe;\n  uart_handle->receive_state = HAL_UART_STATE_READY;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002940": "reset_uart_instance_08002940",
                "huart": "uart_handle",
                "Instance": "uart_instance",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "RxState": "receive_state"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800295c": {
            "entrypoint": "0x0800295c",
            "current_name": "transmit_data_0800295c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef transmitData_0800295c(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t remainingBytes;\n  byte *txDataPtr;\n  uint16_t *tmpPtr;\n  \n  if (uartHandle->gState != HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    uartHandle->Instance->DR = *(ushort *)uartHandle->pTxBuffPtr & 0x1ff;\n    if ((uartHandle->Init).Parity == 0) {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 2;\n    }\n    else {\n      uartHandle->pTxBuffPtr = uartHandle->pTxBuffPtr + 1;\n    }\n  }\n  else {\n    txDataPtr = uartHandle->pTxBuffPtr;\n    uartHandle->pTxBuffPtr = txDataPtr + 1;\n    uartHandle->Instance->DR = (uint)*txDataPtr;\n  }\n  remainingBytes = uartHandle->TxXferCount - 1;\n  uartHandle->TxXferCount = remainingBytes;\n  if (remainingBytes == 0) {\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffff7f;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800295c": "transmit_data_0800295c",
                "huart": "uartHandle",
                "uVar1": "remainingBytes",
                "pbVar2": "txDataPtr",
                "tmp": "tmpPtr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080029c8": {
            "entrypoint": "0x080029c8",
            "current_name": "configure_uart_080029c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configureUART_080029c8(uartHandler *handler)\n\n{\n  uint32_t pclk1Freq1;\n  uint32_t pclk1Freq2;\n  uint32_t pclk1Freq3;\n  uint32_t pclk2Freq1;\n  uint32_t pclk2Freq2;\n  uint32_t pclk2Freq3;\n  uint32_t pclkFreq1;\n  uint32_t pclkFreq2;\n  uint32_t pclkFreq3;\n  uartTypeDef *pUartInstance;\n  \n  handler->instance->controlRegister2 = handler->instance->controlRegister2 & 0xffffcfff | (handler->initParams).stopBits;\n  handler->instance->controlRegister1 =\n       handler->instance->controlRegister1 & 0xffff69f3 |\n       (handler->initParams).wordLength | (handler->initParams).parity | (handler->initParams).mode |\n       (handler->initParams).overSampling;\n  handler->instance->controlRegister3 = handler->instance->controlRegister3 & 0xfffffcff | (handler->initParams).hwFlowCtl;\n  if ((handler->initParams).overSampling == 0x8000) {\n    pUartInstance = handler->instance;\n    if ((pUartInstance != (uartTypeDef *)0x40011000) && (pUartInstance != (uartTypeDef *)0x40011400)) {\n      pclk1Freq1 = getPCLK1Frequency();\n      pclk2Freq3 = (handler->initParams).baudRate;\n      pclk1Freq2 = getPCLK1Frequency();\n      pclkFreq1 = (handler->initParams).baudRate;\n      pclk1Freq3 = getPCLK1Frequency();\n      pclkFreq2 = (handler->initParams).baudRate;\n      pclk2Freq1 = getPCLK1Frequency();\n      pclkFreq3 = (handler->initParams).baudRate;\n      pclk2Freq2 = getPCLK1Frequency();\n      pUartInstance->BRR = ((uint)((int)((ulonglong)\n                                   (((pclk2Freq1 * 0x19) / (pclkFreq3 << 1) +\n                                    (int)(((ulonglong)(pclk2Freq2 * 0x19) /\n                                          (ulonglong)((handler->initParams).baudRate << 1)) / 100) * -100) *\n                                    8 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                     ((((pclk1Freq2 * 0x19) / (pclkFreq1 << 1) +\n                       (int)(((ulonglong)(pclk1Freq3 * 0x19) / (ulonglong)(pclkFreq2 << 1)) / 100) * -100) *\n                       8 + 0x32) / 100 & 0xf8) * 2 +\n                     (int)(((ulonglong)(pclk1Freq1 * 0x19) / (ulonglong)(pclk2Freq3 << 1)) / 100) * 0x10;\n      return;\n    }\n    pclk1Freq1 = getPCLK2Frequency();\n    pclk2Freq3 = (handler->initParams).baudRate;\n    pclk1Freq2 = getPCLK2Frequency();\n    pclkFreq1 = (handler->initParams).baudRate;\n    pclk1Freq3 = getPCLK2Frequency();\n    pclkFreq2 = (handler->initParams).baudRate;\n    pclk2Freq1 = getPCLK2Frequency();\n    pclkFreq3 = (handler->initParams).baudRate;\n    pclk2Freq2 = getPCLK2Frequency();\n    pUartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclk2Freq1 * 0x19) / (pclkFreq3 << 1) +\n                                  (int)(((ulonglong)(pclk2Freq2 * 0x19) /\n                                        (ulonglong)((handler->initParams).baudRate << 1)) / 100) * -100) * 8\n                                 + 0x32) * 0x51eb851f >> 0x20) << 0x18) >> 0x1d) +\n                   ((((pclk1Freq2 * 0x19) / (pclkFreq1 << 1) +\n                     (int)(((ulonglong)(pclk1Freq3 * 0x19) / (ulonglong)(pclkFreq2 << 1)) / 100) * -100) * 8\n                    + 0x32) / 100 & 0xf8) * 2 +\n                   (int)(((ulonglong)(pclk1Freq1 * 0x19) / (ulonglong)(pclk2Freq3 << 1)) / 100) * 0x10;\n    return;\n  }\n  pUartInstance = handler->instance;\n  if ((pUartInstance != (uartTypeDef *)0x40011000) && (pUartInstance != (uartTypeDef *)0x40011400)) {\n    pclk1Freq1 = getPCLK1Frequency();\n    pclk2Freq3 = (handler->initParams).baudRate;\n    pclk1Freq2 = getPCLK1Frequency();\n    pclkFreq1 = (handler->initParams).baudRate;\n    pclk1Freq3 = getPCLK1Frequency();\n    pclkFreq2 = (handler->initParams).baudRate;\n    pclk2Freq1 = getPCLK1Frequency();\n    pclkFreq3 = (handler->initParams).baudRate;\n    pclk2Freq2 = getPCLK1Frequency();\n    pUartInstance->BRR = ((uint)((int)((ulonglong)\n                                 (((pclk2Freq1 * 0x19) / (pclkFreq3 << 2) +\n                                  (int)(((ulonglong)(pclk2Freq2 * 0x19) /\n                                        (ulonglong)((handler->initParams).baudRate << 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                   ((((pclk1Freq2 * 0x19) / (pclkFreq1 << 2) +\n                     (int)(((ulonglong)(pclk1Freq3 * 0x19) / (ulonglong)(pclkFreq2 << 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 & 0xf0) +\n                   (int)(((ulonglong)(pclk1Freq1 * 0x19) / (ulonglong)(pclk2Freq3 << 2)) / 100) * 0x10;\n    return;\n  }\n  pclk1Freq1 = getPCLK2Frequency();\n  pclk2Freq3 = (handler->initParams).baudRate;\n  pclk1Freq2 = getPCLK2Frequency();\n  pclkFreq1 = (handler->initParams).baudRate;\n  pclk1Freq3 = getPCLK2Frequency();\n  pclkFreq2 = (handler->initParams).baudRate;\n  pclk2Freq1 = getPCLK2Frequency();\n  pclkFreq3 = (handler->initParams).baudRate;\n  pclk2Freq2 = getPCLK2Frequency();\n  pUartInstance->BRR = ((uint)((int)((ulonglong)\n                               (((pclk2Freq1 * 0x19) / (pclkFreq3 << 2) +\n                                (int)(((ulonglong)(pclk2Freq2 * 0x19) /\n                                      (ulonglong)((handler->initParams).baudRate << 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((pclk1Freq2 * 0x19) / (pclkFreq1 << 2) +\n                   (int)(((ulonglong)(pclk1Freq3 * 0x19) / (ulonglong)(pclkFreq2 << 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(pclk1Freq1 * 0x19) / (ulonglong)(pclk2Freq3 << 2)) / 100) * 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080029c8": "configure_uart_080029c8",
                "UART_HandleTypeDef": "uartHandler",
                "USART_TypeDef": "uartTypeDef",
                "huart": "handler",
                "CR1": "controlRegister1",
                "CR2": "controlRegister2",
                "CR3": "controlRegister3",
                "Instance": "instance",
                "Init": "initParams",
                "StopBits": "stopBits",
                "WordLength": "wordLength",
                "Parity": "parity",
                "Mode": "mode",
                "OverSampling": "overSampling",
                "HwFlowCtl": "hwFlowCtl",
                "BaudRate": "baudRate",
                "HAL_RCC_GetPCLK1Freq": "getPCLK1Frequency",
                "HAL_RCC_GetPCLK2Freq": "getPCLK2Frequency",
                "uVar1": "pclk1Freq1",
                "uVar2": "pclk1Freq2",
                "uVar3": "pclk1Freq3",
                "uVar4": "pclk2Freq1",
                "uVar5": "pclk2Freq2",
                "uVar6": "pclk2Freq3",
                "uVar7": "pclkFreq1",
                "uVar8": "pclkFreq2",
                "uVar9": "pclkFreq3",
                "pUVar10": "pUartInstance"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d0c": {
            "entrypoint": "0x08002d0c",
            "current_name": "check_flag_status_08002d0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_desiredFlagStatusTypeDef\ncheckFlagStatus_08002d0c(UART_HandleTypeDef *uartHandler,uint32_t flagToCheck,flagToCheckdesiredFlagStatus desiredFlagStatus,uint32_t startTicks,\n            uint32_t timeoutDuration)\n\n{\n  uint32_t currentTime;\n  \n  do {\n    if (((flagToCheck & ~uartHandler->Instance->SR) == 0) != (bool)desiredFlagStatus) {\n      return HAL_OK;\n    }\n  } while ((timeoutDuration == 0xffffffff) ||\n          ((timeoutDuration != 0 && (currentTime = HAL_GetTick(), currentTime - startTicks <= timeoutDuration))));\n  uartHandler->Instance->CR1 = uartHandler->Instance->CR1 & 0xfffffe5f;\n  uartHandler->Instance->CR3 = uartHandler->Instance->CR3 & 0xfffffffe;\n  uartHandler->gState = HAL_UART_STATE_READY;\n  uartHandler->RxState = HAL_UART_STATE_READY;\n  uartHandler->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002d0c": "check_flag_status_08002d0c",
                "huart": "uartHandler",
                "Flag": "flagToCheck",
                "Status": "desiredFlagStatus",
                "Tickstart": "startTicks",
                "Timeout": "timeoutDuration",
                "uVar1": "currentTime"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d70": {
            "entrypoint": "0x08002d70",
            "current_name": "FUNC_08002d70",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d70(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d70": "FUNC_08002d70"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d72": {
            "entrypoint": "0x08002d72",
            "current_name": "initialize_uart_08002d72",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUart_08002d72(UART_HandleTypeDef *uartHandle)\n\n{\n  if (uartHandle != (UART_HandleTypeDef *)0x0) {\n    if (uartHandle->gState == HAL_UART_STATE_RESET) {\n      uartHandle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->gState = HAL_UART_STATE_BUSY;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffb7ff;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xffffffd5;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_READY;\n    uartHandle->RxState = HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002d72": "initialize_uart_08002d72",
                "huart": "uartHandle"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002dd0": {
            "entrypoint": "0x08002dd0",
            "current_name": "transmit_data_08002dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\ntransmitData_08002dd0(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickstart;\n  uint16_t *tmp;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if (data == (uint8_t *)0x0) {\n      status = HAL_ERROR;\n    }\n    else if (dataSize == 0) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      tickstart = HAL_GetTick();\n      uartHandle->TxXferdataSize = dataSize;\n      uartHandle->TxXferCount = dataSize;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickstart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)data & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            data = (uint8_t *)((int)data + 2);\n          }\n          else {\n            data = (uint8_t *)((int)data + 1);\n          }\n        }\n        else {\n          status = UART_WaitOnFlagUntiltimeout(uartHandle,0x80,RESET,tickstart,timeout);\n          if (status != HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*data;\n          data = (uint8_t *)((int)data + 1);\n        }\n      }\n      status = UART_WaitOnFlagUntiltimeout(uartHandle,0x40,RESET,tickstart,timeout);\n      if (status == HAL_OK) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002dd0": "transmit_data_08002dd0",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickstart"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002eb2": {
            "entrypoint": "0x08002eb2",
            "current_name": "initialize_uart_transfer_08002eb2",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUARTTransfer_08002eb2(UART_HandleTypeDef *uartHandle,uint8_t *dataPtr,uint16_t dataSize)\n\n{\n  if (uartHandle->gState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataPtr == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (dataSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pTxBuffPtr = dataPtr;\n    uartHandle->TxXferdataSize = dataSize;\n    uartHandle->TxXferCount = dataSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002eb2": "initialize_uart_transfer_08002eb2",
                "huart": "uartHandle",
                "pData": "dataPtr",
                "Size": "dataSize"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efa": {
            "entrypoint": "0x08002efa",
            "current_name": "initialize_uart_reception_08002efa",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUARTReception_08002efa(UART_HandleTypeDef *uartHandle,uint8_t *dataBuffer,uint16_t dataSize)\n\n{\n  if (uartHandle->RxState != HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (dataBuffer == (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (dataSize == 0) {\n    return HAL_ERROR;\n  }\n  if (uartHandle->Lock != HAL_LOCKED) {\n    uartHandle->pRxBuffPtr = dataBuffer;\n    uartHandle->RxXferdataSize = dataSize;\n    uartHandle->RxXferCount = dataSize;\n    uartHandle->ErrorCode = 0;\n    uartHandle->RxState = HAL_UART_STATE_BUSY_RX;\n    uartHandle->Lock = HAL_UNLOCKED;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 | 1;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x120;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
            "renaming": {
                "FUN_08002efa": "initialize_uart_reception_08002efa",
                "huart": "uartHandle",
                "pData": "dataBuffer",
                "Size": "dataSize"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f4c": {
            "entrypoint": "0x08002f4c",
            "current_name": "initialize_uart_08002f4c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeUART_08002f4c(UART_HandleTypeDef *huart)\n\n{\n  huart->Instance->CR1 = huart->Instance->CR1 & 0xffffffbf;\n  huart->gState = UART_READY;\n  transmissionCompleteCallback(huart);\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_08002f4c": "initialize_uart_08002f4c",
                "HAL_UART_STATE_READY": "UART_READY",
                "HAL_UART_TxCpltCallback": "transmissionCompleteCallback",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f66": {
            "entrypoint": "0x08002f66",
            "current_name": "receive_data_08002f66",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef receiveData_08002f66(UART_HandleTypeDef *uartHandle)\n\n{\n  uint16_t *tmpBuffer;\n  byte *bytePtr;\n  uint16_t rxBytesRemaining;\n  uint8_t *bytePtr2;\n  \n  if (uartHandle->RxState != HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((uartHandle->Init).WordLength == 0x1000) {\n    if ((uartHandle->Init).Parity == 0) {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)((uartHandle->Instance->DR << 0x17) >> 0x17);\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)uartHandle->pRxBuffPtr = (ushort)uartHandle->Instance->DR & 0xff;\n      uartHandle->pRxBuffPtr = uartHandle->pRxBuffPtr + 1;\n    }\n  }\n  else if ((uartHandle->Init).Parity == 0) {\n    bytePtr2 = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = bytePtr2 + 1;\n    *bytePtr2 = (uint8_t)uartHandle->Instance->DR;\n  }\n  else {\n    bytePtr = uartHandle->pRxBuffPtr;\n    uartHandle->pRxBuffPtr = bytePtr + 1;\n    *bytePtr = (byte)uartHandle->Instance->DR & 0x7f;\n  }\n  rxBytesRemaining = uartHandle->RxXferCount - 1;\n  uartHandle->RxXferCount = rxBytesRemaining;\n  if (rxBytesRemaining != 0) {\n    return HAL_OK;\n  }\n  uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffedf;\n  uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n  uartHandle->RxState = HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(uartHandle);\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_08002f66": "receive_data_08002f66",
                "huart": "uartHandle",
                "tmp": "tmpBuffer",
                "pbVar1": "bytePtr",
                "uVar2": "rxBytesRemaining",
                "puVar3": "bytePtr2"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ffc": {
            "entrypoint": "0x08002ffc",
            "current_name": "handle_uart_08002ffc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_08002ffc(UART_HandleTypeDef *uart_handler)\n\n{\n  HAL_StatusTypeDef status;\n  uint cr1its;\n  uint32_t cr1its;\n  USART_TypeDef *uart_instance;\n  uint32_t cr3its;\n  uint cr3its;\n  uint isrflags;\n  uint32_t isrflags;\n  \n  uart_instance = uart_handler->Instance;\n  isrflags = uart_instance->SR;\n  cr1its = uart_instance->CR1;\n  if ((((isrflags & 0xf) == 0) && ((isrflags & 0x20) != 0)) && ((cr1its & 0x20) != 0)) {\n    UART_Receive_IT(uart_handler);\n    return;\n  }\n  if (((isrflags & 0xf) == 0) || ((cr3its = uart_instance->CR3 & 1, cr3its == 0 && ((cr1its & 0x120) == 0)))) {\n    if (((isrflags & 0x80) != 0) && ((cr1its & 0x80) != 0)) {\n      UART_Transmit_IT(uart_handler);\n      return;\n    }\n    if (((isrflags & 0x40) != 0) && ((cr1its & 0x40) != 0)) {\n      UART_EndTransmit_IT(uart_handler);\n    }\n  }\n  else {\n    if (((isrflags & 1) != 0) && ((cr1its & 0x100) != 0)) {\n      uart_handler->ErrorCode = uart_handler->ErrorCode | 1;\n    }\n    if (((isrflags & 4) != 0) && (cr3its != 0)) {\n      uart_handler->ErrorCode = uart_handler->ErrorCode | 2;\n    }\n    if (((isrflags & 2) != 0) && (cr3its != 0)) {\n      uart_handler->ErrorCode = uart_handler->ErrorCode | 4;\n    }\n    if (((isrflags & 8) != 0) && (cr3its != 0)) {\n      uart_handler->ErrorCode = uart_handler->ErrorCode | 8;\n    }\n    if (uart_handler->ErrorCode != 0) {\n      if (((isrflags & 0x20) != 0) && ((cr1its & 0x20) != 0)) {\n        UART_Receive_IT(uart_handler);\n      }\n      if (((uart_handler->ErrorCode & 8) == 0) && ((uart_handler->Instance->CR3 & 0x40) == 0)) {\n        HAL_UART_ErrorCallback(uart_handler);\n        uart_handler->ErrorCode = 0;\n        return;\n      }\n      UART_EndRxTransfer(uart_handler);\n      uart_instance = uart_handler->Instance;\n      if ((uart_instance->CR3 & 0x40) == 0) {\n        HAL_UART_ErrorCallback(uart_handler);\n        return;\n      }\n      uart_instance->CR3 = uart_instance->CR3 & 0xffffffbf;\n      if (uart_handler->hdmarx == (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(uart_handler);\n        return;\n      }\n      uart_handler->hdmarx->XferAbortCallback = UART_DMAAbortOnError + 1;\n      status = HAL_DMA_Abort_IT(uart_handler->hdmarx);\n      if (status != HAL_OK) {\n        (*uart_handler->hdmarx->XferAbortCallback)(uart_handler->hdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ffc": "handle_uart_08002ffc",
                "huart": "uart_handler",
                "HVar1": "status",
                "uVar2": "cr1its",
                "uVar4": "cr3its",
                "uVar5": "isrflags",
                "pUVar3": "uart_instance"
            },
            "calling": [
                "USART3_IRQHandler",
                "USART6_IRQHandler",
                "UART7_IRQHandler",
                "UART4_IRQHandler",
                "UART8_IRQHandler",
                "USART1_IRQHandler",
                "USART2_IRQHandler",
                "UART5_IRQHandler"
            ],
            "called": [
                "UART_Receive_IT",
                "UART_Transmit_IT",
                "UART_EndRxTransfer",
                "UART_EndTransmit_IT",
                "HAL_UART_ErrorCallback",
                "HAL_DMA_Abort_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800311c": {
            "entrypoint": "0x0800311c",
            "current_name": "reset_uart_error_callback_0800311c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_UART_Error_Callback_0800311c(DMA_HandleTypeDef *dma_handle)\n\n{\n  UART_HandleTypeDef *parent_uart_handle;\n  UART_HandleTypeDef *current_uart_handle;\n  \n  parent_uart_handle = (UART_HandleTypeDef *)dma_handle->Parent;\n  parent_uart_handle->RxXferCount = 0;\n  parent_uart_handle->TxXferCount = 0;\n  HAL_UART_ErrorCallback(parent_uart_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800311c": "reset_uart_error_callback_0800311c",
                "hdma": "dma_handle",
                "huart_00": "parent_uart_handle",
                "huart": "current_uart_handle"
            },
            "calling": [],
            "called": [
                "HAL_UART_ErrorCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800312c": {
            "entrypoint": "0x0800312c",
            "current_name": "combine_uart_rx_and_g_state_0800312c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef combineUartRxAndGState_0800312c(UART_HandleTypeDef *UART_handle)\n\n{\n  return UART_handle->receiveState | UART_handle->globalState;\n}\n\n",
            "renaming": {
                "FUN_0800312c": "combine_uart_rx_and_g_state_0800312c",
                "huart": "UART_handle",
                "RxState": "receiveState",
                "gState": "globalState"
            },
            "calling": [
                "serial_tx_active",
                "serial_rx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003138": {
            "entrypoint": "0x08003138",
            "current_name": "get_pin_status_08003138",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool getPinStatus_08003138(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint32_t pinIndex;\n  \n  pinIndex = pinMap[(uint)((int)pinName << 0x18) >> 0x1c];\n  return (_Bool)((byte)(pinIndex >> ((int)pinName & 0xfU)) & 1);\n}\n\n",
            "renaming": {
                "FUN_08003138": "get_pin_status_08003138",
                "pin": "pinName",
                "map": "pinMap",
                "index": "pinIndex"
            },
            "calling": [
                "pinMode",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800314e": {
            "entrypoint": "0x0800314e",
            "current_name": "set_pin_bit_0800314e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinBit_0800314e(PinName_conflict pinName,uint32_t *pinMap)\n\n{\n  uint bitShift;\n  uint32_t index;\n  \n  bitShift = (uint)((int)pinName << 0x18) >> 0x1c;\n  pinMap[bitShift] = pinMap[bitShift] | 1 << ((int)pinName & 0xfU);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800314e": "set_pin_bit_0800314e",
                "pin": "pinName",
                "map": "pinMap",
                "uVar1": "bitShift"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "update_pin_map_0800316c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updatePinMap_0800316c(pinName pin,uint32_t *pinMap)\n\n{\n  uint shiftedPin;\n  uint32_t pinIndex;\n  \n  shiftedPin = (uint)((int)pin << 0x18) >> 0x1c;\n  pinMap[shiftedPin] = pinMap[shiftedPin] & ~(1 << ((int)pin & 0xfU));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "update_pin_map_0800316c",
                "PinName_conflict": "pinName",
                "map": "pinMap",
                "uVar1": "shiftedPin",
                "index": "pinIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800318c": {
            "entrypoint": "0x0800318c",
            "current_name": "get_gpio_from_port_index_0800318c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nGPIOType * getGPIOFromPortIndex_0800318c(uint32_t index)\n\n{\n  switch(index) {\n  case 0:\n    return (GPIOType *)0x40020000;\n  case 1:\n    return (GPIOType *)0x40020400;\n  case 2:\n    return (GPIOType *)0x40020800;\n  case 3:\n    return (GPIOType *)0x40020c00;\n  case 4:\n    return (GPIOType *)0x40021000;\n  case 5:\n    return (GPIOType *)0x40021400;\n  case 6:\n    return (GPIOType *)0x40021800;\n  case 7:\n    return (GPIOType *)0x40021c00;\n  case 8:\n    return (GPIOType *)0x40022000;\n  case 9:\n    return (GPIOType *)0x40022400;\n  case 10:\n    return (GPIOType *)0x40022800;\n  default:\n    return (GPIOType *)0x0;\n  }\n}\n\n",
            "renaming": {
                "FUN_0800318c": "get_gpio_from_port_index_0800318c",
                "port_idx": "index",
                "GPIO_TypeDef": "GPIOType"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080031fc": {
            "entrypoint": "0x080031fc",
            "current_name": "get_gpio_port_080031fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * get_GPIO_port_080031fc(uint32_t port_index)\n\n{\n  GPIO_TypeDef *GPIO_Port;\n  uint32_t temp_register;\n  uint32_t temp_register_1;\n  uint32_t temp_register_2;\n  uint32_t temp_register_3;\n  uint32_t temp_register_4;\n  uint32_t temp_register_5;\n  uint32_t temp_register_6;\n  uint32_t temp_register_7;\n  uint32_t temp_register_8;\n  uint32_t temp_register_9;\n  uint32_t temp_register_10;\n  \n  switch(port_index) {\n  case 0:\n    _DAT_40023830 = _DAT_40023830 | 1;\n    GPIO_Port = (GPIO_TypeDef *)0x40020000;\n    break;\n  case 1:\n    _DAT_40023830 = _DAT_40023830 | 2;\n    GPIO_Port = (GPIO_TypeDef *)0x40020400;\n    break;\n  case 2:\n    _DAT_40023830 = _DAT_40023830 | 4;\n    GPIO_Port = (GPIO_TypeDef *)0x40020800;\n    break;\n  case 3:\n    _DAT_40023830 = _DAT_40023830 | 8;\n    GPIO_Port = (GPIO_TypeDef *)0x40020c00;\n    break;\n  case 4:\n    _DAT_40023830 = _DAT_40023830 | 0x10;\n    GPIO_Port = (GPIO_TypeDef *)0x40021000;\n    break;\n  case 5:\n    _DAT_40023830 = _DAT_40023830 | 0x20;\n    GPIO_Port = (GPIO_TypeDef *)0x40021400;\n    break;\n  case 6:\n    _DAT_40023830 = _DAT_40023830 | 0x40;\n    GPIO_Port = (GPIO_TypeDef *)0x40021800;\n    break;\n  case 7:\n    _DAT_40023830 = _DAT_40023830 | 0x80;\n    GPIO_Port = (GPIO_TypeDef *)0x40021c00;\n    break;\n  case 8:\n    _DAT_40023830 = _DAT_40023830 | 0x100;\n    GPIO_Port = (GPIO_TypeDef *)0x40022000;\n    break;\n  case 9:\n    _DAT_40023830 = _DAT_40023830 | 0x200;\n    GPIO_Port = (GPIO_TypeDef *)0x40022400;\n    break;\n  case 10:\n    _DAT_40023830 = _DAT_40023830 | 0x400;\n    GPIO_Port = (GPIO_TypeDef *)0x40022800;\n    break;\n  default:\n    GPIO_Port = (GPIO_TypeDef *)0x0;\n  }\n  return GPIO_Port;\n}\n\n",
            "renaming": {
                "FUN_080031fc": "get_gpio_port_080031fc",
                "port_idx": "port_index",
                "pGVar1": "GPIO_Port",
                "tmpreg": "temp_register",
                "tmpreg_1": "temp_register_1",
                "tmpreg_2": "temp_register_2",
                "tmpreg_3": "temp_register_3",
                "tmpreg_4": "temp_register_4",
                "tmpreg_5": "temp_register_5",
                "tmpreg_6": "temp_register_6",
                "tmpreg_7": "temp_register_7",
                "tmpreg_8": "temp_register_8",
                "tmpreg_9": "temp_register_9",
                "tmpreg_10": "temp_register_10"
            },
            "calling": [
                "digital_io_init",
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003380": {
            "entrypoint": "0x08003380",
            "current_name": "get_pin_function_08003380",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinFunction_08003380(pin pin)\n\n{\n  uint32_t pinFunction;\n  uint32_t shiftedFunction;\n  \n  pinFunction = pinmap_shiftedFunction(pin,(PinMap_conflict *)&PinMap_DAC);\n  shiftedFunction = pinFunction << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (shiftedFunction != 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n",
            "renaming": {
                "FUN_08003380": "get_pin_function_08003380",
                "PinName_conflict": "pin",
                "uVar1": "pinFunction",
                "function": "shiftedFunction"
            },
            "calling": [
                "dac_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800339c": {
            "entrypoint": "0x0800339c",
            "current_name": "get_pin_function_0800339c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getPinFunction_0800339c(PinName_conflict pinName)\n\n{\n  uint32_t mappedFunction;\n  uint32_t shiftedFunction;\n  \n  mappedFunction = pinNamemap_shiftedFunction(pinName,(PinMap_conflict *)&PinMap_PWM);\n  shiftedFunction = mappedFunction << 0xc;\n  shiftedFunction = shiftedFunction >> 0x1b;\n  if (shiftedFunction == 3) {\n    return 8;\n  }\n  if (shiftedFunction != 4) {\n    if (shiftedFunction != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_0800339c": "get_pin_function_0800339c",
                "pin": "pinName",
                "uVar1": "mappedFunction",
                "function": "shiftedFunction"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033c8": {
            "entrypoint": "0x080033c8",
            "current_name": "clear_dac_interrupt_flag_080033c8",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid clear_DAC_interrupt_flag_080033c8(DAC_HandleTypeDef *dac_handle)\n\n{\n  _DAT_40023840 = _DAT_40023840 & 0xdfffffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033c8": "clear_dac_interrupt_flag_080033c8",
                "hdac": "dac_handle"
            },
            "calling": [
                "HAL_DAC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033d8": {
            "entrypoint": "0x080033d8",
            "current_name": "stop_and_de_init_dac_080033d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopAndDeInitDAC_080033d8(pin pin)\n\n{\n  uint32_t dacChannel;\n  uint32_t dacdacChannel;\n  DacHandle DacHandle;\n  \n  DacHandle.Instance = (DAC_TypeDef *)getPeripheral(pin,(PinMap_DAC *)&PinMap_DAC);\n  if ((DacHandle.Instance != (DAC_TypeDef *)0x0) &&\n     ((dacChannel = getDacChannel(pin), dacChannel == 0 || (dacChannel == 0x10)))) {\n    stopDAC(&DacHandle,dacChannel);\n    deInitDAC(&DacHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033d8": "stop_and_de_init_dac_080033d8",
                "PinName_conflict": "pin",
                "Channel": "dacChannel",
                "DAC_HandleTypeDef": "DacHandle",
                "pinmap_peripheral": "getPeripheral",
                "PinMap_conflict": "PinMap_DAC",
                "get_dac_channel": "getDacChannel",
                "HAL_DAC_Stop": "stopDAC",
                "HAL_DAC_DeInit": "deInitDAC"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_DAC_Stop",
                "get_dac_channel",
                "HAL_DAC_DeInit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800340c": {
            "entrypoint": "0x0800340c",
            "current_name": "disable_timer_clock_0800340c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disable_timer_clock_0800340c(TIM_HandleTypeDef *timer_handle)\n\n{\n  disable_clock(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800340c": "disable_timer_clock_0800340c",
                "htim": "timer_handle",
                "timer_disable_clock": "disable_clock"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003414": {
            "entrypoint": "0x08003414",
            "current_name": "stop_pwm_08003414",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid stopPWM_08003414(PinName_conflict pinName)\n\n{\n  uint32_t pwmChannel;\n  uint32_t timerChannel;\n  uint32_t pinFunction;\n  TIM_HandleTypeDef timerHandle;\n  \n  timerHandle.Instance = (TIM_TypeDef *)pinNamemap_peripheral(pinName,(PinMap_conflict *)&PinMap_PWM);\n  if ((timerHandle.Instance != (TIM_TypeDef *)0x0) &&\n     ((((pwmChannel = get_pwm_channel(pinName), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    pinFunction = pinNamemap_function(pinName,(PinMap_conflict *)&PinMap_PWM);\n    if ((pinFunction & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(&timerHandle,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(&timerHandle,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(&timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003414": "stop_pwm_08003414",
                "pin": "pinName",
                "Channel": "pwmChannel",
                "timChannel": "timerChannel",
                "uVar1": "pinFunction",
                "timHandle": "timerHandle"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "pinmap_function",
                "HAL_TIM_PWM_Stop",
                "get_pwm_channel",
                "HAL_TIM_PWM_DeInit",
                "pinmap_peripheral",
                "HAL_TIMEx_PWMN_Stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800346c": {
            "entrypoint": "0x0800346c",
            "current_name": "get_current_tick_0800346c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_0800346c(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_0800346c": "get_current_tick_0800346c",
                "uVar1": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003474": {
            "entrypoint": "0x08003474",
            "current_name": "FUNC_08003474",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08003474(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003474": "FUNC_08003474"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003476": {
            "entrypoint": "0x08003476",
            "current_name": "handle_system_tick_08003476",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSystemTick_08003476(void)\n\n{\n  incrementSystemTick();\n  handleSysTickIRQ();\n  handleNoOsSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003476": "handle_system_tick_08003476",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickIRQ",
                "noOsSystickHandler": "handleNoOsSysTick"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003486": {
            "entrypoint": "0x08003486",
            "current_name": "configure_pin_08003486",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08003486(pin pin,uint32_t pinMode,uint32_t pinPull)\n\n{\n  GPIO_TypeDef *gpioPort;\n  GPIO_TypeDef *gpioPort;\n  GPIO_InitTypeDef gpioConfig;\n  \n  gpioPort = setGPIOPortClock((uint)((int)pin << 0x18) >> 0x1c);\n  gpioConfig.Pin = 1 << ((int)pin & 0xfU) & 0xffff;\n  gpioConfig.Speed = 2;\n  gpioConfig.Mode = pinMode;\n  gpioConfig.Pull = pinPull;\n  initializeGPIO(gpioPort,&gpioConfig);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003486": "configure_pin_08003486",
                "PinName_conflict": "pin",
                "mode": "pinMode",
                "pull": "pinPull",
                "GPIOx": "gpioPort",
                "port": "gpioPort",
                "GPIO_InitStructure": "gpioConfig",
                "set_GPIO_Port_Clock": "setGPIOPortClock",
                "GPIO_InitStructure.Pin": "gpioConfig.Pin",
                "GPIO_InitStructure.Speed": "gpioConfig.Speed",
                "GPIO_InitStructure.Mode": "gpioConfig.Mode",
                "GPIO_InitStructure.Pull": "gpioConfig.Pull",
                "HAL_GPIO_Init": "initializeGPIO"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_GPIO_Init",
                "set_GPIO_Port_Clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034b6": {
            "entrypoint": "0x080034b6",
            "current_name": "set_pin_state_080034b6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinState_080034b6(GPIO_TypeDef *gpioPort,uint32_t pinNumber,uint32_t pinState)\n\n{\n  if (pinState == 0) {\n    HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(gpioPort,(uint16_t)pinNumber,GPIO_PIN_SET);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034b6": "set_pin_state_080034b6",
                "port": "gpioPort",
                "pin": "pinNumber",
                "val": "pinState"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034ce": {
            "entrypoint": "0x080034ce",
            "current_name": "initialize_hardware_080034ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeHardware_080034ce(void)\n\n{\n  initializeHAL();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080034ce": "initialize_hardware_080034ce",
                "HAL_Init": "initializeHAL",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "init"
            ],
            "called": [
                "SystemClock_Config",
                "HAL_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034da": {
            "entrypoint": "0x080034da",
            "current_name": "find_peripheral_080034da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * findPeripheral_080034da(targetPin pin,pinMap *currentPinMap)\n\n{\n  while( true ) {\n    if (currentPinMap->pin == NotConnected) {\n      return (void *)0x0;\n    }\n    if (currentPinMap->pin == pin) break;\n    currentPinMap = currentPinMap + 1;\n  }\n  return currentPinMap->foundPeripheral;\n}\n\n",
            "renaming": {
                "FUN_080034da": "find_peripheral_080034da",
                "PinName_conflict": "targetPin",
                "PinMap_conflict": "pinMap",
                "map": "currentPinMap",
                "NC": "NotConnected",
                "peripheral": "foundPeripheral"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080034f4": {
            "entrypoint": "0x080034f4",
            "current_name": "find_peripheral_for_pin_080034f4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * find_peripheral_for_pin_080034f4(PinName_conflict pin_number,PinMap_conflict *pin_map)\n\n{\n  void *peripheral_address;\n  \n  if (pin_number != NC) {\n    peripheral_address = pin_numberpin_map_find_peripheral(pin_number,pin_map);\n    return peripheral_address;\n  }\n  return (void *)0x0;\n}\n\n",
            "renaming": {
                "FUN_080034f4": "find_peripheral_for_pin_080034f4",
                "pin": "pin_number",
                "map": "pin_map",
                "pvVar1": "peripheral_address"
            },
            "calling": [
                "uart_debug_write",
                "uart_debug_init",
                "dac_stop",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003506": {
            "entrypoint": "0x08003506",
            "current_name": "find_pin_by_peripheral_08003506",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict findPinByPeripheral_08003506(void *targetPeripheral,PinMap_conflict *pinMap)\n\n{\n  while( true ) {\n    if (pinMap->targetPeripheral == (void *)0x0) {\n      return NC;\n    }\n    if (pinMap->targetPeripheral == targetPeripheral) break;\n    pinMap = pinMap + 1;\n  }\n  return pinMap->pin;\n}\n\n",
            "renaming": {
                "FUN_08003506": "find_pin_by_peripheral_08003506",
                "peripheral": "targetPeripheral",
                "map": "pinMap"
            },
            "calling": [
                "pinmap_find_pin",
                "pinmap_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800351e": {
            "entrypoint": "0x0800351e",
            "current_name": "find_pinname_from_peripheral_0800351e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict find_pinname_from_peripheral_0800351e(void *peripheral,PinMap_conflict *pinmap)\n\n{\n  PinName_conflict pinname;\n  \n  if (peripheral != (void *)0x0) {\n    pinname = pinpinmap_find_pin(peripheral,pinmap);\n    return pinname;\n  }\n  return NoConnection;\n}\n\n",
            "renaming": {
                "FUN_0800351e": "find_pinname_from_peripheral_0800351e",
                "map": "pinmap",
                "PVar1": "pinname",
                "NC": "NoConnection"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800352e": {
            "entrypoint": "0x0800352e",
            "current_name": "find_pin_function_0800352e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t findPinFunction_0800352e(pinToFind pinToCompare,pinMapArray *currentPinMap)\n\n{\n  while( true ) {\n    if (currentPinMap->pinToCompare == NoConnection) {\n      return 0xffffffff;\n    }\n    if (currentPinMap->pinToCompare == pinToCompare) break;\n    currentPinMap = currentPinMap + 1;\n  }\n  return currentPinMap->function;\n}\n\n",
            "renaming": {
                "FUN_0800352e": "find_pin_function_0800352e",
                "PinName_conflict": "pinToFind",
                "PinMap_conflict": "pinMapArray",
                "map": "currentPinMap",
                "NC": "NoConnection",
                "pin": "pinToCompare"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800354a": {
            "entrypoint": "0x0800354a",
            "current_name": "find_pin_function_0800354a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t find_pin_function_0800354a(PinName_conflict pin_name,PinMap_conflict *pin_map)\n\n{\n  uint32_t result;\n  \n  if (pin_name == NC) {\n    return 0xffffffff;\n  }\n  result = pin_namepin_map_find_function(pin_name,pin_map);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800354a": "find_pin_function_0800354a",
                "pin": "pin_name",
                "map": "pin_map",
                "uVar1": "result"
            },
            "calling": [
                "get_dac_channel",
                "get_pwm_channel",
                "uart_init",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800355e": {
            "entrypoint": "0x0800355e",
            "current_name": "pin_is_valid_0800355e",
            "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pinIsValid_0800355e(PinName_conflict pinName,PinMap_conflict *pinMap)\n\n{\n  if (pinName == NotConnected) {\n    return false;\n  }\n  while( true ) {\n    if (pinMap->pinName == NotConnected) {\n      return false;\n    }\n    if (pinName == pinMap->pinName) break;\n    pinMap = pinMap + 1;\n  }\n  return true;\n}\n\n",
            "renaming": {
                "FUN_0800355e": "pin_is_valid_0800355e",
                "pin": "pinName",
                "map": "pinMap",
                "NC": "NotConnected"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003582": {
            "entrypoint": "0x08003582",
            "current_name": "merge_pointers_08003582",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * merge_pointers_08003582(void *a,void *b)\n\n{\n  if (a != b) {\n    if (a == (void *)0x0) {\n      return b;\n    }\n    if (b == (void *)0x0) {\n      return a;\n    }\n    a = (void *)0x0;\n  }\n  return a;\n}\n\n",
            "renaming": {
                "FUN_08003582": "merge_pointers_08003582"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003594": {
            "entrypoint": "0x08003594",
            "current_name": "execute_rtc_user_callback_08003594",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid executeRTCUserCallback_08003594(RTC_HandleTypeDef *RTC_handler)\n\n{\n  if (userCallback != (callbackFunctionPtr)0x0) {\n    (*userCallback)(callbackData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003594": "execute_rtc_user_callback_08003594",
                "hrtc": "RTC_handler",
                "RTCUserCallback": "userCallback",
                "voidCallbackPtr": "callbackFunctionPtr",
                "callbackUserData": "callbackData"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035ac": {
            "entrypoint": "0x080035ac",
            "current_name": "handle_rtc_alarm_080035ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleRTCAlarm_080035ac(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(rtcHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035ac": "handle_rtc_alarm_080035ac",
                "&RtcHandle": "rtcHandle"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035bc": {
            "entrypoint": "0x080035bc",
            "current_name": "initialize_memory_registers_080035bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemoryRegisters_080035bc(void)\n\n{\n  _DAT_40023808 = 0;\n  _DAT_40023804 = 0x24003010;\n  _DAT_40023800 = _DAT_40023800 & 0xfef2ffff | 1;\n  _DAT_4002380c = 0;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035bc": "initialize_memory_registers_080035bc"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fc": {
            "entrypoint": "0x080035fc",
            "current_name": "modify_tim_type_def_080035fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid modify_TIM_TypeDef_080035fc(TIM_HandleTypeDef *timer_handle)\n\n{\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40010000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffe;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40000000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffe;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffd;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40000800) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffffb;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40000c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffff7;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40001000) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffef;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40001400) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffdf;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40010400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffffffd;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40014000) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffeffff;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40014400) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffdffff;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40014800) {\n    _DAT_40023844 = _DAT_40023844 & 0xfffbffff;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40001800) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffffbf;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40001c00) {\n    _DAT_40023840 = _DAT_40023840 & 0xffffff7f;\n  }\n  if (timer_handle->Instance == (TIM_TypeDef *)0x40002000) {\n    _DAT_40023840 = _DAT_40023840 & 0xfffffeff;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fc": "modify_tim_type_def_080035fc",
                "htim": "timer_handle"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003750": {
            "entrypoint": "0x08003750",
            "current_name": "get_stimer_08003750",
            "code": "\n/* WARNING: Unknown calling convention */\n\ns_timer * get_stimer_08003750(TIM_HandleTypeDef *timer_handle)\n\n{\n  return (s_timer *)&timer_handle[-1].lock;\n}\n\n",
            "renaming": {
                "FUN_08003750": "get_stimer_08003750",
                "htim": "timer_handle",
                "stimer_t": "s_timer",
                "Lock": "lock"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003754": {
            "entrypoint": "0x08003754",
            "current_name": "handle_timer_interrupt_08003754",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003754(TIM_HandleTypeDef *timerHandle)\n\n{\n  stimer_t *timerObj;\n  stimer_t *timerObj2;\n  \n  timerObj = get_timer_timerObj2(timerHandle);\n  if ((timerObj->irqHandleOC != (_func_void_stimer_t_ptr_uint32_t *)0x0) &&\n     (timerHandle->Channel == HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*timerObj->irqHandleOC)(timerObj,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003754": "handle_timer_interrupt_08003754",
                "htim": "timerHandle",
                "psVar1": "timerObj",
                "obj": "timerObj2"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800376e": {
            "entrypoint": "0x0800376e",
            "current_name": "handle_timer_interrupt_0800376e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_0800376e(TIM_HandleTypeDef *timer_handle)\n\n{\n  stimer_t *timer_object;\n  stimer_t *timer_object;\n  \n  timer_object = get_timer_timer_object(timer_handle);\n  if (timer_object->timer_interrupt_handler != (_func_void_stimer_t_ptr *)0x0) {\n    (*timer_object->timer_interrupt_handler)(timer_object);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800376e": "handle_timer_interrupt_0800376e",
                "htim": "timer_handle",
                "psVar1": "timer_object",
                "obj": "timer_object",
                "irqHandle": "timer_interrupt_handler"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800377c": {
            "entrypoint": "0x0800377c",
            "current_name": "handle_timers_0800377c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimers_0800377c(void)\n\n{\n  if (timerHandles[0] != (TIM_HandleTypeDef *)0x0) {\n    handleTimerInterrupt(timerHandles[0]);\n  }\n  if (timerHandles[9] != (TIM_HandleTypeDef *)0x0) {\n    handleTimerInterrupt(timerHandles[9]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800377c": "handle_timers_0800377c",
                "timer_handles": "timerHandles",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003798": {
            "entrypoint": "0x08003798",
            "current_name": "handle_tim_interrupt_08003798",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimInterrupt_08003798(void)\n\n{\n  if (timers[1] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timers[1]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003798": "handle_tim_interrupt_08003798",
                "timer_handles": "timers"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037ac": {
            "entrypoint": "0x080037ac",
            "current_name": "handle_timer_interrupt_080037ac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_080037ac(void)\n\n{\n  if (timerHandles[2] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037ac": "handle_timer_interrupt_080037ac",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037c0": {
            "entrypoint": "0x080037c0",
            "current_name": "handle_timer_interrupt_080037c0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_timer_interrupt_080037c0(void)\n\n{\n  if (timer_handles[3] != (timer_handle *)0x0) {\n    handle_timer_irq(timer_handles[3]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037c0": "handle_timer_interrupt_080037c0",
                "TIM_HandleTypeDef": "timer_handle",
                "HAL_TIM_IRQHandler": "handle_timer_irq"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037d4": {
            "entrypoint": "0x080037d4",
            "current_name": "handle_timer4_interrupt_080037d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimer4Interrupt_080037d4(void)\n\n{\n  if (timerHandle4 != (TimerHandleStruct *)0x0) {\n    HAL_TIM_IRQHandler(timerHandle4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037d4": "handle_timer4_interrupt_080037d4",
                "timer_handles[4]": "timerHandle4",
                "TIM_HandleTypeDef": "TimerHandleStruct"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037e8": {
            "entrypoint": "0x080037e8",
            "current_name": "handle_fifth_timer_080037e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleFifthTimer_080037e8(void)\n\n{\n  if (timerHandles[5] != (TimerHandle *)0x0) {\n    handleTimerInterrupt(timerHandles[5]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037e8": "handle_fifth_timer_080037e8",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimerHandle",
                "HAL_TIM_IRQHandler": "handleTimerInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080037fc": {
            "entrypoint": "0x080037fc",
            "current_name": "handle_interrupt_080037fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleInterrupt_080037fc(void)\n\n{\n  if (timerArray[6] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerArray[6]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080037fc": "handle_interrupt_080037fc",
                "timer_handles": "timerArray",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003810": {
            "entrypoint": "0x08003810",
            "current_name": "handle_timers_08003810",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimers_08003810(void)\n\n{\n  if (timerHandles[7] != (TimHandle *)0x0) {\n    handleTimInterrupt(timerHandles[7]);\n  }\n  if (timerHandles[12] != (TimHandle *)0x0) {\n    handleTimInterrupt(timerHandles[12]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003810": "handle_timers_08003810",
                "timer_handles": "timerHandles",
                "TIM_HandleTypeDef": "TimHandle",
                "HAL_TIM_IRQHandler": "handleTimInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800382c": {
            "entrypoint": "0x0800382c",
            "current_name": "handle_timer_interrupt_0800382c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_0800382c(void)\n\n{\n  if (timerHandles[8] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[8]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800382c": "handle_timer_interrupt_0800382c",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003840": {
            "entrypoint": "0x08003840",
            "current_name": "handle_timer_interrupt_08003840",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003840(void)\n\n{\n  if (timerHandles[10] != (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timerHandles[10]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003840": "handle_timer_interrupt_08003840",
                "timer_handles": "timerHandles"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003854": {
            "entrypoint": "0x08003854",
            "current_name": "handle_timer_interrupt_08003854",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimerInterrupt_08003854(void)\n\n{\n  if (timerHandlers[11] != (TimerHandle *)0x0) {\n    HAL_TIM_IRQHandler(timerHandlers[11]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003854": "handle_timer_interrupt_08003854",
                "timer_handles": "timerHandlers",
                "TIM_HandleTypeDef": "TimerHandle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003868": {
            "entrypoint": "0x08003868",
            "current_name": "handle_tim13_interrupt_08003868",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_TIM13_interrupt_08003868(void)\n\n{\n  if (timer_handle_TIM13 != (TIM_handle_struct *)0x0) {\n    HAL_TIM_IRQHandler(timer_handle_TIM13);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003868": "handle_tim13_interrupt_08003868",
                "timer_handles[13]": "timer_handle_TIM13",
                "TIM_HandleTypeDef": "TIM_handle_struct"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800387c": {
            "entrypoint": "0x0800387c",
            "current_name": "get_i2_c_struct_ptr_0800387c",
            "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t * getI2CStructPtr_0800387c(I2C_HandleTypeDef *i2cHandle)\n\n{\n  return (i2c_t *)&i2cHandle[-1].eventCount;\n}\n\n",
            "renaming": {
                "FUN_0800387c": "get_i2_c_struct_ptr_0800387c",
                "hi2c": "i2cHandle",
                "EventCount": "eventCount"
            },
            "calling": [
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003880": {
            "entrypoint": "0x08003880",
            "current_name": "handle_i2_c_transfer_08003880",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CTransfer_08003880(I2C_HandleTypeDef *i2cHandle,uint8_t direction,uint16_t addressCode)\n\n{\n  i2c_t *i2cObj;\n  i2c_t *i2cObject;\n  \n  i2cObj = get_i2c_i2cObject(i2cHandle);\n  if ((uint)addressCode == (i2cHandle->Init).OwnAddress1) {\n    if (direction == '\\0') {\n      i2cObj->i2cTxRxBufferSize = '\\0';\n      i2cObj->slaveMode = '\\0';\n      if (i2cObj->i2c_onSlaveTransmit != (_func_void *)0x0) {\n        (*i2cObj->i2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (i2cHandle,i2cObj->i2cTxRxBuffer,(ushort)i2cObj->i2cTxRxBufferSize,8);\n      return;\n    }\n    i2cObj->slaveMode = '\\x01';\n    HAL_I2C_Slave_Sequential_Receive_IT(i2cHandle,i2cObj->i2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003880": "handle_i2_c_transfer_08003880",
                "hi2c": "i2cHandle",
                "TransferDirection": "direction",
                "AddrMatchCode": "addressCode",
                "piVar1": "i2cObj",
                "obj": "i2cObject"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080038d0": {
            "entrypoint": "0x080038d0",
            "current_name": "enable_slave_receive_080038d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableSlaveReceive_080038d0(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject;\n  uint remainingDataSize;\n  \n  i2cObject = get_i2c_i2cObject(i2cHandle);\n  if (((i2cObject->i2c_onSlaveReceive != (_func_void_uint8_t_ptr_int *)0x0) &&\n      (i2cObject->slaveMode == '\\x01')) &&\n     (remainingDataSize = 0x20 - *(byte *)&(i2cObject->handle).XferSize & 0xff, remainingDataSize != 0)) {\n    (*i2cObject->i2c_onSlaveReceive)(i2cObject->i2cTxRxBuffer,remainingDataSize);\n  }\n  HAL_I2C_EnableListen_IT(i2cHandle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080038d0": "enable_slave_receive_080038d0",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject",
                "uVar2": "remainingDataSize"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_ITError",
                "I2C_Slave_AF"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003900": {
            "entrypoint": "0x08003900",
            "current_name": "enable_listen_interrupt_08003900",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableListenInterrupt_08003900(I2C_HandleTypeDef *i2cHandle)\n\n{\n  i2c_t *i2cObject;\n  i2c_t *i2cObject;\n  \n  i2cObject = get_i2c_i2cObject(i2cHandle);\n  if (i2cObject->isMasterMode == '\\0') {\n    HAL_I2C_EnableListen_IT(i2cHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003900": "enable_listen_interrupt_08003900",
                "hi2c": "i2cHandle",
                "piVar1": "i2cObject",
                "obj": "i2cObject",
                "isMaster": "isMasterMode"
            },
            "calling": [
                "I2C_ITError",
                "I2C_DMAAbort"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003918": {
            "entrypoint": "0x08003918",
            "current_name": "handle_i2_c_events_08003918",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvents_08003918(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2cHandles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003918": "handle_i2_c_events_08003918",
                "i2c_handles": "i2cHandles"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003928": {
            "entrypoint": "0x08003928",
            "current_name": "handle_i2_c_error_interrupt_08003928",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08003928(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003928": "handle_i2_c_error_interrupt_08003928"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003938": {
            "entrypoint": "0x08003938",
            "current_name": "handle_i2_c_event_08003938",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08003938(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2cErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003938": "handle_i2_c_event_08003938",
                "I2C2_ER_IRQHandler::handle": "i2cErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003948": {
            "entrypoint": "0x08003948",
            "current_name": "handle_i2_c_error_interrupt_08003948",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CErrorInterrupt_08003948(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c2ErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003948": "handle_i2_c_error_interrupt_08003948",
                "I2C2_ER_IRQHandler::handle": "i2c2ErrorHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003958": {
            "entrypoint": "0x08003958",
            "current_name": "handle_i2_c_event_08003958",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2CEvent_08003958(void)\n\n{\n  HAL_I2C_EV_IRQHandler(eventHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003958": "handle_i2_c_event_08003958",
                "I2C3_ER_IRQHandler::handle": "eventHandler"
            },
            "calling": [],
            "called": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003968": {
            "entrypoint": "0x08003968",
            "current_name": "handle_i2_c3_errors_08003968",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleI2C3Errors_08003968(void)\n\n{\n  handleI2CError(I2C3ErrorHandler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003968": "handle_i2_c3_errors_08003968",
                "I2C3_ER_IRQHandler::handle": "I2C3ErrorHandler",
                "HAL_I2C_ER_IRQHandler": "handleI2CError"
            },
            "calling": [],
            "called": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003978": {
            "entrypoint": "0x08003978",
            "current_name": "initialize_serial_port_08003978",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialPort_08003978(serial_t *serialPort)\n\n{\n  void *a;\n  USART_TypeDef *txUart;\n  void *b;\n  USART_TypeDef *rxUart;\n  USART_TypeDef *selectedUart;\n  GPIO_TypeDef *selectedGpio;\n  GPIO_TypeDef *gpioPort;\n  uint32_t pinFunction;\n  UART_HandleTypeDef *huart;\n  uint32_t tempRegister;\n  uint32_t tempRegister1;\n  uint32_t tempRegister2;\n  uint32_t tempRegister3;\n  uint32_t tempRegister4;\n  uint32_t tempRegister5;\n  uint32_t tempRegister6;\n  uint32_t tempRegister7;\n  GPIO_InitTypeDef gpioInitStruct;\n  \n  if (serialPort != (serial_t *)0x0) {\n    a = pinmap_peripheral(serialPort->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n    b = pinmap_peripheral(serialPort->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n    if ((b == (void *)0x0) || (a == (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      selectedUart = (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      serialPort->uart = selectedUart;\n      if (selectedUart == (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (selectedUart == (USART_TypeDef *)0x40011000) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffef;\n          _DAT_40023844 = _DAT_40023844 | 0x10;\n          serialPort->index = '\\0';\n          serialPort->irq = USART1_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40004400) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffdffff;\n          _DAT_40023840 = _DAT_40023840 | 0x20000;\n          serialPort->index = '\\x01';\n          serialPort->irq = USART2_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40004800) {\n          _DAT_40023820 = _DAT_40023820 & 0xfffbffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000;\n          serialPort->index = '\\x02';\n          serialPort->irq = USART3_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40004c00) {\n          _DAT_40023820 = _DAT_40023820 & 0xfff7ffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000;\n          serialPort->index = '\\x03';\n          serialPort->irq = UART4_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40005000) {\n          _DAT_40023820 = _DAT_40023820 & 0xffefffff;\n          _DAT_40023840 = _DAT_40023840 | 0x100000;\n          serialPort->index = '\\x04';\n          serialPort->irq = UART5_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40011400) {\n          _DAT_40023824 = _DAT_40023824 & 0xffffffdf;\n          _DAT_40023844 = _DAT_40023844 | 0x20;\n          serialPort->index = '\\x05';\n          serialPort->irq = USART6_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40007800) {\n          _DAT_40023820 = _DAT_40023820 & 0xbfffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x40000000;\n          serialPort->index = '\\x06';\n          serialPort->irq = UART7_IRQn;\n        }\n        else if (selectedUart == (USART_TypeDef *)0x40007c00) {\n          _DAT_40023820 = _DAT_40023820 & 0x7fffffff;\n          _DAT_40023840 = _DAT_40023840 | 0x80000000;\n          serialPort->index = '\\a';\n          serialPort->irq = UART8_IRQn;\n        }\n        selectedGpio = set_GPIO_Port_Clock((uint)((int)serialPort->pin_rx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialPort->pin_rx,(PinMap_conflict *)&PinMap_UART_RX);\n        gpioInitStruct.Pin = 1 << (serialPort->pin_rx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        gpioInitStruct.Alternate = (pinFunction << 0x11) >> 0x19;\n        gpioInitStruct.Speed = 3;\n        HAL_GPIO_Init(selectedGpio,&gpioInitStruct);\n        selectedGpio = set_GPIO_Port_Clock((uint)((int)serialPort->pin_tx << 0x18) >> 0x1c);\n        pinFunction = pinmap_function(serialPort->pin_tx,(PinMap_conflict *)&PinMap_UART_TX);\n        gpioInitStruct.Pin = 1 << (serialPort->pin_tx & 0xfU) & 0xffff;\n        gpioInitStruct.Mode = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitStruct.Pull = (pinFunction << 0x1a) >> 0x1e;\n        HAL_GPIO_Init(selectedGpio,&gpioInitStruct);\n        uart_handlers[serialPort->index] = &serialPort->handle;\n        (serialPort->handle).Instance = serialPort->uart;\n        (serialPort->handle).Init.BaudRate = serialPort->baudrate;\n        (serialPort->handle).Init.WordLength = serialPort->databits;\n        (serialPort->handle).Init.StopBits = serialPort->stopbits;\n        (serialPort->handle).Init.Parity = serialPort->parity;\n        (serialPort->handle).Init.Mode = 0xc;\n        (serialPort->handle).Init.HwFlowCtl = 0;\n        (serialPort->handle).Init.OverSampling = 0;\n        HAL_UART_Init(&serialPort->handle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003978": "initialize_serial_port_08003978",
                "obj": "serialPort",
                "uart_tx": "txUart",
                "uart_rx": "rxUart",
                "pUVar1": "selectedUart",
                "pGVar2": "selectedGpio",
                "port": "gpioPort",
                "uVar3": "pinFunction",
                "tmpreg": "tempRegister",
                "tmpreg_1": "tempRegister1",
                "tmpreg_2": "tempRegister2",
                "tmpreg_3": "tempRegister3",
                "tmpreg_4": "tempRegister4",
                "tmpreg_5": "tempRegister5",
                "tmpreg_6": "tempRegister6",
                "tmpreg_7": "tempRegister7",
                "GPIO_InitStruct": "gpioInitStruct"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_function",
                "HAL_UART_Init",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "iprintf",
                "set_GPIO_Port_Clock",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003cc8": {
            "entrypoint": "0x08003cc8",
            "current_name": "initialize_serial_debug_08003cc8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_serial_debug_08003cc8(void)\n\n{\n  void *peripheral;\n  \n  peripheral = pinmap_peripheral(PD_8,(PinMapConflict *)&PinMap_UART_TX);\n  if (peripheral != (void *)0x0) {\n    peripheral = pinmap_peripheral(PD_8,(PinMapConflict *)&PinMap_UART_TX);\n    debug_info.receive_pin = pinmap_pin(peripheral,(PinMapConflict *)&PinMap_UART_RX);\n    debug_info.transmit_pin = PD_8;\n    debug_info.baud_rate = 0x2580;\n    debug_info.parity_bit = 0;\n    debug_info.data_bits = 0;\n    debug_info.stop_bits = 0;\n    initialize_uart(&debug_info);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003cc8": "initialize_serial_debug_08003cc8",
                "pvVar1": "peripheral",
                "PinMap_conflict": "PinMapConflict",
                "serial_debug": "debug_info",
                "pin_rx": "receive_pin",
                "pin_tx": "transmit_pin",
                "baudrate": "baud_rate",
                "parity": "parity_bit",
                "databits": "data_bits",
                "stopbits": "stop_bits",
                "uart_init": "initialize_uart"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "pinmap_pin",
                "uart_init",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d18": {
            "entrypoint": "0x08003d18",
            "current_name": "transmit_data_08003d18",
            "code": "\n/* WARNING: Unknown calling convention */\n\ndataSize_t transmitData_08003d18(uint8_t *dataBuffer,uint32_t dataSize)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t startTime;\n  uint32_t tickStart;\n  void *peripheral;\n  USART_TypeDef *usart;\n  uint32_t currentTime;\n  uint index;\n  \n  startTime = HAL_GetTick();\n  peripheral = pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX);\n  if (peripheral == (void *)0x0) {\n    return 0;\n  }\n  index = 0;\n  while ((index < 10 &&\n         ((uart_handlers[index] == (UART_HandleTypeDef *)0x0 ||\n          (usart = (USART_TypeDef *)pinmap_peripheral(PD_8,(PinMap_conflict *)&PinMap_UART_TX),\n          uart_handlers[index]->Instance != usart))))) {\n    index = index + 1 & 0xff;\n  }\n  if (9 < index) {\n    if ((9 < serial_debug.index) && (uart_debug_init(), 9 < serial_debug.index)) {\n      return 0;\n    }\n    index = (uint)serial_debug.index;\n  }\n  do {\n    status = HAL_UART_Transmit(uart_handlers[index],dataBuffer,(uint16_t)dataSize,1000);\n    if (status == HAL_OK) {\n      return dataSize;\n    }\n    currentTime = HAL_GetTick();\n  } while (currentTime - startTime < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003d18": "transmit_data_08003d18",
                "data": "dataBuffer",
                "size": "dataSize",
                "HVar1": "status",
                "uVar2": "startTime",
                "tickstart": "tickStart",
                "pvVar3": "peripheral",
                "pUVar4": "usart",
                "uVar5": "currentTime",
                "uVar6": "index"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "uart_debug_init",
                "HAL_UART_Transmit",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003dd0": {
            "entrypoint": "0x08003dd0",
            "current_name": "check_uart_state_08003dd0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003dd0(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(array_of_uart_handlers[serial_object->index]);\n  return (uart_state & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_08003dd0": "check_uart_state_08003dd0",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "array_of_uart_handlers"
            },
            "calling": [
                "uart_getc",
                "uart_attach_rx_callback"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003df4": {
            "entrypoint": "0x08003df4",
            "current_name": "check_uart_state_08003df4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t check_uart_state_08003df4(serial_t *serial_object)\n\n{\n  HAL_UART_StateTypeDef uart_state;\n  \n  uart_state = HAL_UART_GetState(handlers_array[serial_object->index]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_08003df4": "check_uart_state_08003df4",
                "obj": "serial_object",
                "HVar1": "uart_state",
                "uart_handlers": "handlers_array"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e18": {
            "entrypoint": "0x08003e18",
            "current_name": "handle_serial_data_08003e18",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint handleSerialData_08003e18(serial_t *serialObj,uchar *c)\n\n{\n  uint8_t isRxActive;\n  \n  if (serialObj == (serial_t *)0x0) {\n    return -1;\n  }\n  isRxActive = serial_rx_active(serialObj);\n  if (isRxActive == '\\0') {\n    *c = serialObj->recv;\n    HAL_UART_Receive_IT(uart_handlers[serialObj->index],&serialObj->recv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08003e18": "handle_serial_data_08003e18",
                "obj": "serialObj",
                "uVar1": "isRxActive"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e54": {
            "entrypoint": "0x08003e54",
            "current_name": "initialize_serial_08003e54",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerial_08003e54(serial_t *serialObject,_func_void_serial_t_ptr *serialCallback)\n\n{\n  byte index;\n  uint8_t rxActive;\n  \n  if (serialObject != (serial_t *)0x0) {\n    rxActive = serial_rx_active(serialObject);\n    if (rxActive == '\\0') {\n      index = serialObject->index;\n      receiveCallback[index] = serialCallback;\n      receiveCallbackObject[index] = serialObject;\n      setPriority(serialObject->irq,0,1);\n      enableIRQ(serialObject->irq);\n      receiveInterrupt(uart_handlers[serialObject->index],&serialObject->recv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e54": "initialize_serial_08003e54",
                "obj": "serialObject",
                "callback": "serialCallback",
                "bVar1": "index",
                "uVar2": "rxActive",
                "rx_callback": "receiveCallback",
                "rx_callback_obj": "receiveCallbackObject",
                "HAL_NVIC_SetPriority": "setPriority",
                "HAL_NVIC_EnableIRQ": "enableIRQ",
                "HAL_UART_Receive_IT": "receiveInterrupt"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003eac": {
            "entrypoint": "0x08003eac",
            "current_name": "transmit_serial_data_08003eac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitSerialData_08003eac(serial_t *serialObject,_func_int_serial_t_ptr *callbackFunction)\n\n{\n  byte indexValue;\n  \n  if (serialObject != (serial_t *)0x0) {\n    indexValue = serialObject->index;\n    tx_callbackFunction[indexValue] = callbackFunction;\n    tx_callbackFunction_serialObject[indexValue] = serialObject;\n    HAL_NVIC_SetPriority(serialObject->irq,0,2);\n    HAL_NVIC_EnableIRQ(serialObject->irq);\n    HAL_UART_Transmit_IT(uart_handlers[serialObject->index],serialObject->tx_buff + serialObject->tx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003eac": "transmit_serial_data_08003eac",
                "obj": "serialObject",
                "callback": "callbackFunction",
                "bVar1": "indexValue"
            },
            "calling": [
                "write"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Transmit_IT",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f00": {
            "entrypoint": "0x08003f00",
            "current_name": "find_uart_handler_index_08003f00",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t find_uart_handler_index_08003f00(UART_HandleTypeDef *uart_handler)\n\n{\n  uint index;\n  \n  if (uart_handler == (UART_HandleTypeDef *)0x0) {\n    index = 10;\n  }\n  else {\n    index = 0;\n    while( true ) {\n      if (9 < index) {\n        return (uint8_t)index;\n      }\n      if (uart_handler == uart_handlers[index]) break;\n      index = index + 1 & 0xff;\n    }\n  }\n  return (uint8_t)index;\n}\n\n",
            "renaming": {
                "FUN_08003f00": "find_uart_handler_index_08003f00",
                "huart": "uart_handler",
                "uVar1": "index"
            },
            "calling": [
                "HAL_UART_TxCpltCallback",
                "HAL_UART_RxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f24": {
            "entrypoint": "0x08003f24",
            "current_name": "handle_uart_receive_08003f24",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_uart_receive_08003f24(UART_HandleTypeDef *uart_handle)\n\n{\n  byte index_value;\n  uint8_t index;\n  uint converted_index;\n  \n  index_value = uart_index(uart_handle);\n  converted_index = (uint)index_value;\n  if (converted_index < 10) {\n    (*rx_callback[converted_index])(rx_callback_obj[converted_index]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f24": "handle_uart_receive_08003f24",
                "huart": "uart_handle",
                "bVar1": "index_value",
                "uVar2": "converted_index"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f48": {
            "entrypoint": "0x08003f48",
            "current_name": "transmit_and_handle_errors_08003f48",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid transmitAndHandleErrors_08003f48(UART_HandleTypeDef *uartHandle)\n\n{\n  byte uartIndex;\n  uint8_t loopIndex;\n  int returnValue;\n  serial_t *serialObj;\n  serial_t *callbackObj;\n  uint callbackIndex;\n  \n  uartIndex = uart_loopIndex(uartHandle);\n  callbackIndex = (uint)uartIndex;\n  callbackObj = tx_callback_serialObj[callbackIndex];\n  if ((callbackIndex < 10) && (returnValue = (*tx_callback[callbackIndex])(callbackObj), returnValue != -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[callbackObj->loopIndex],callbackObj->tx_buff + callbackObj->tx_tail,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f48": "transmit_and_handle_errors_08003f48",
                "huart": "uartHandle",
                "bVar1": "uartIndex",
                "index": "loopIndex",
                "iVar3": "returnValue",
                "obj": "serialObj",
                "psVar4": "callbackObj",
                "uVar2": "callbackIndex"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "HAL_UART_Transmit_IT",
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f94": {
            "entrypoint": "0x08003f94",
            "current_name": "initialize_uart_08003f94",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_uart_08003f94(UART_HandleTypeDef *uart_handle)\n\n{\n  uint32_t temporary_value;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f94": "initialize_uart_08003f94",
                "huart": "uart_handle",
                "tmpval": "temporary_value"
            },
            "calling": [
                "UART_DMAAbortOnError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fd4": {
            "entrypoint": "0x08003fd4",
            "current_name": "handle_uart_interrupt_08003fd4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_08003fd4(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART1_interrupt);\n  HAL_UART_IRQHandler(UART_handlers[0]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fd4": "handle_uart_interrupt_08003fd4",
                "USART1_IRQn": "UART1_interrupt",
                "uart_handlers": "UART_handlers"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003fec": {
            "entrypoint": "0x08003fec",
            "current_name": "handle_uart2_interrupt_08003fec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART2_interrupt_08003fec(void)\n\n{\n  clear_pending_interrupt(UART2_interrupt);\n  UART_interrupt_handler(UART_interrupt_handlers[1]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003fec": "handle_uart2_interrupt_08003fec",
                "USART2_IRQn": "UART2_interrupt",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_interrupt",
                "HAL_UART_IRQHandler": "UART_interrupt_handler",
                "uart_handlers": "UART_interrupt_handlers"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004004": {
            "entrypoint": "0x08004004",
            "current_name": "handle_usart3_interrupt_08004004",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_USART3_interrupt_08004004(void)\n\n{\n  clear_pending_IRQ(IRQ_USART3);\n  if (uart_handles[2] != (UART_HandleTypeDef *)0x0) {\n    handle_UART_IRQ(uart_handles[2]);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004004": "handle_usart3_interrupt_08004004",
                "uart_handlers": "uart_handles",
                "USART3_IRQn": "IRQ_USART3",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800401c": {
            "entrypoint": "0x0800401c",
            "current_name": "handle_uart_interrupt_0800401c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART_interrupt_0800401c(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(uart4_interrupt);\n  HAL_UART_IRQHandler(uart_handler_3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800401c": "handle_uart_interrupt_0800401c",
                "UART4_IRQn": "uart4_interrupt",
                "uart_handlers[3]": "uart_handler_3"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004034": {
            "entrypoint": "0x08004034",
            "current_name": "handle_uart5_interrupt_08004034",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART5_interrupt_08004034(void)\n\n{\n  clear_pending_UART5_interrupt(UART5_interrupt_number);\n  handle_UART_irq(UART5_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004034": "handle_uart5_interrupt_08004034",
                "UART5_IRQn": "UART5_interrupt_number",
                "uart_handlers[4]": "UART5_handler",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_UART5_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_irq"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800404c": {
            "entrypoint": "0x0800404c",
            "current_name": "handle_uart6_ir_qn_0800404c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART6_IRQn_0800404c(void)\n\n{\n  clear_pending_IRQ(IRQn_UART6);\n  handle_UART_IRQ(uart_handlers[5]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800404c": "handle_uart6_ir_qn_0800404c",
                "USART6_IRQn": "IRQn_UART6",
                "HAL_NVIC_ClearPendingIRQ": "clear_pending_IRQ",
                "HAL_UART_IRQHandler": "handle_UART_IRQ"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004064": {
            "entrypoint": "0x08004064",
            "current_name": "handle_uart7_interrupt_08004064",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART7_interrupt_08004064(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART7_Interrupt);\n  HAL_UART_IRQHandler(uart_event_handlers[6]);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004064": "handle_uart7_interrupt_08004064",
                "UART7_IRQn": "UART7_Interrupt",
                "uart_handlers": "uart_event_handlers"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_ClearPendingIRQ",
                "HAL_UART_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800407c": {
            "entrypoint": "0x0800407c",
            "current_name": "handle_uart8_interrupt_0800407c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_UART8_interrupt_0800407c(void)\n\n{\n  clear_interrupt(interrupt_source);\n  handle_UART_interrupt(UART_handler);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800407c": "handle_uart8_interrupt_0800407c",
                "UART8_IRQn": "interrupt_source",
                "uart_handlers[7]": "UART_handler",
                "HAL_NVIC_ClearPendingIRQ": "clear_interrupt",
                "HAL_UART_IRQHandler": "handle_UART_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_UART_IRQHandler",
                "HAL_NVIC_ClearPendingIRQ"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004094": {
            "entrypoint": "0x08004094",
            "current_name": "expand_heap_memory_08004094",
            "code": "\nvoid * expandHeapMemory_08004094(intptr_t delta)\n\n{\n  char *previousHeapEnd;\n  char *previousHeapEnd;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &_ebss;\n  }\n  previousHeapEnd = _sbrk::heap_end;\n  if (_sbrk::heap_end + delta <= &stack0x00000000) {\n    _sbrk::heap_end = _sbrk::heap_end + delta;\n    return previousHeapEnd;\n  }\n  errno = 0xc;\n  return (void *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004094": "expand_heap_memory_08004094",
                "__delta": "delta",
                "pcVar1": "previousHeapEnd",
                "prev_heap_end": "previousHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d0": {
            "entrypoint": "0x080040d0",
            "current_name": "check_file_descriptor_080040d0",
            "code": "\nint check_file_descriptor_080040d0(int file_descriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040d0": "check_file_descriptor_080040d0",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040d6": {
            "entrypoint": "0x080040d6",
            "current_name": "set_device_flag_080040d6",
            "code": "\nint setDeviceFlag_080040d6(int fileDescriptor,stat *fileStats)\n\n{\n  *(undefined4 *)((int)&fileStats->deviceNumber + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040d6": "set_device_flag_080040d6",
                "__fd": "fileDescriptor",
                "__buf": "fileStats",
                "st_dev": "deviceNumber"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e0": {
            "entrypoint": "0x080040e0",
            "current_name": "check_connection_080040e0",
            "code": "\nint check_connection_080040e0(int file_descriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080040e0": "check_connection_080040e0",
                "__fd": "file_descriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e4": {
            "entrypoint": "0x080040e4",
            "current_name": "get_file_offset_080040e4",
            "code": "\n__off_t get_file_offset_080040e4(int file_descriptor,__off_t offset,int seek_mode)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e4": "get_file_offset_080040e4",
                "__fd": "file_descriptor",
                "__offset": "offset",
                "__whence": "seek_mode"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040e8": {
            "entrypoint": "0x080040e8",
            "current_name": "process_file_080040e8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_file_080040e8(int file_descriptor,char *buffer,int buffer_length)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040e8": "process_file_080040e8",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "buffer",
                "len_UNUSED": "buffer_length"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040ec": {
            "entrypoint": "0x080040ec",
            "current_name": "write_to_uart_080040ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint write_to_uart_080040ec(int file_descriptor,char *data_pointer,int data_length)\n\n{\n  size_t write_result;\n  \n  write_result = uart_debug_write((uint8_t *)data_pointer,data_length);\n  return write_result;\n}\n\n",
            "renaming": {
                "FUN_080040ec": "write_to_uart_080040ec",
                "file_UNUSED": "file_descriptor",
                "ptr": "data_pointer",
                "len": "data_length",
                "sVar1": "write_result"
            },
            "calling": [
                "_write_r"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040f8": {
            "entrypoint": "0x080040f8",
            "current_name": "run_infinite_loop_080040f8",
            "code": "\nvoid runInfiniteLoop_080040f8(int status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080040f8": "run_infinite_loop_080040f8",
                "__status": "status"
            },
            "calling": [
                "abort",
                "_exit"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040fc": {
            "entrypoint": "0x080040fc",
            "current_name": "set_errno_and_return_080040fc",
            "code": "\nint setErrnoAndReturn_080040fc(pid_t pid,int signal)\n\n{\n  errno = 0x16;\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_080040fc": "set_errno_and_return_080040fc",
                "__pid": "pid",
                "__sig": "signal"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800410c": {
            "entrypoint": "0x0800410c",
            "current_name": "get_process_id_0800410c",
            "code": "\n\n\nprocess_id get_process_id_0800410c(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800410c": "get_process_id_0800410c",
                "__pid_t": "process_id"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "configure_pin_08004110",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_08004110(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  _Bool isConfigured;\n  PinName pin;\n  \n  if (pinNumber < 0x60) {\n    pin = *(PinName *)(&digitalPinArray + pinNumber * 2);\n  }\n  else {\n    pin = NotConnected;\n  }\n  if (pin != NotConnected) {\n    isConfigured = isPinConfigured(pin,outputPinConfig);\n    if (isConfigured) {\n      isConfigured = pinin_in_pininmapin(pin,(PinMap *)&DACPinMap);\n      if (isConfigured) {\n        stopDAC(pin);\n      }\n      else {\n        isConfigured = pinin_in_pininmapin(pin,(PinMap *)&PWMPinMap);\n        if (isConfigured) {\n          stopPWM(pin);\n        }\n      }\n      resetPinConfigured(pin,outputPinConfig);\n    }\n    switch(pinMode) {\n    case 0:\n      initializeDigitalIO(pin,0,0);\n      break;\n    case 1:\n      initializeDigitalIO(pin,1,0);\n      break;\n    case 2:\n      initializeDigitalIO(pin,0,1);\n      break;\n    case 3:\n      initializeDigitalIO(pin,0,2);\n    }\n    setPinConfigured(pin,digitalPinConfig);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "configure_pin_08004110",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "_Var1": "isConfigured",
                "p": "pin",
                "digitalPin": "digitalPinArray",
                "PinName_conflict": "PinName",
                "NC": "NotConnected",
                "is_pin_configured": "isPinConfigured",
                "g_anOutputPinConfigured": "outputPinConfig",
                "PinMap_conflict": "PinMap",
                "PinMap_DAC": "DACPinMap",
                "dac_stop": "stopDAC",
                "PinMap_PWM": "PWMPinMap",
                "pwm_stop": "stopPWM",
                "reset_pin_configured": "resetPinConfigured",
                "digital_io_init": "initializeDigitalIO",
                "set_pin_configured": "setPinConfigured",
                "g_digPinConfigured": "digitalPinConfig"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "pin_in_pinmap",
                "reset_pin_configured",
                "digital_io_init",
                "set_pin_configured",
                "dac_stop",
                "is_pin_configured",
                "pwm_stop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041bc": {
            "entrypoint": "0x080041bc",
            "current_name": "configure_pin_080041bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_080041bc(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  _Bool isConfigured;\n  GPIO_TypinNameConflicteDef *gpioPort;\n  PinName_conflict pinNameConflict;\n  uint configuredPin;\n  \n  if (pinNumber < 0x60) {\n    configuredPin = (uint)*(short *)(&digitalPin + pinNumber * 2);\n  }\n  else {\n    configuredPin = 0xffffffff;\n  }\n  if ((configuredPin != 0xffffffff) &&\n     (isConfigured = is_pinNameConflictin_configured((PinName_conflict)configuredPin,g_digPinConfigured), isConfigured)) {\n    gpioPort = get_GPIO_Port((configuredPin << 0x18) >> 0x1c);\n    digital_io_write(gpioPort,1 << (configuredPin & 0xf) & 0xffff,pinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041bc": "configure_pin_080041bc",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "_Var1": "isConfigured",
                "port": "gpioPort",
                "p": "pinNameConflict",
                "uVar2": "configuredPin"
            },
            "calling": [
                "sendTxBuffer",
                "getRxBuffer",
                "begin"
            ],
            "called": [
                "digital_io_write",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "get_current_milliseconds_08004204",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_milliseconds_08004204(void)\n\n{\n  uint32_t current_milliseconds;\n  \n  current_milliseconds = GetCurrentMilli();\n  return current_milliseconds;\n}\n\n",
            "renaming": {
                "FUN_08004204": "get_current_milliseconds_08004204",
                "uVar1": "current_milliseconds"
            },
            "calling": [
                "sendTxBuffer",
                "poll"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800420c": {
            "entrypoint": "0x0800420c",
            "current_name": "update_tail_and_check_0800420c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::updateTailAndCheck_0800420c(serial_t_conflict *serialObject)\n\n{\n  ushort newTailValue;\n  uint16_t maskedTailValue;\n  int updatedTail;\n  \n  updatedTail = serialObject->tx_tail + 1;\n  newTailValue = (ushort)updatedTail;\n  maskedTailValue = newTailValue & 0x7f;\n  if (updatedTail == 0) {\n    maskedTailValue = -(-newTailValue & 0x7f);\n  }\n  serialObject->tx_tail = maskedTailValue;\n  if (serialObject->tx_head != serialObject->tx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_0800420c": "update_tail_and_check_0800420c",
                "obj": "serialObject",
                "iVar3": "updatedTail",
                "uVar1": "newTailValue",
                "uVar2": "maskedTailValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004240": {
            "entrypoint": "0x08004240",
            "current_name": "calculate_available_rx_bytes_08004240",
            "code": "\n/* DWARF original prototype: int  available(HardwareSerial * serialObject) */\n\nint __serialObjectcall HardwareSerial::calculateAvailableRxBytes_08004240(HardwareSerial *serialObject)\n\n{\n  return ((serialObject->_serial).rx_head + 0x40) - (uint)(serialObject->_serial).rx_tail & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_08004240": "calculate_available_rx_bytes_08004240",
                "this": "serialObject"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004254": {
            "entrypoint": "0x08004254",
            "current_name": "peek_08004254",
            "code": "\n/* DWARF original prototype: int  peek_08004254(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::peek_08004254(HardwareSerial *this)\n\n{\n  uint uVar1;\n  \n  uVar1 = (uint)(this->_serial).rx_tail;\n  if ((this->_serial).rx_head != uVar1) {\n    return (uint)(this->_serial).rx_buff[uVar1];\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_08004254": "peek_08004254"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004270": {
            "entrypoint": "0x08004270",
            "current_name": "read_serial_data_08004270",
            "code": "\n/* DWARF original prototype: int  read(HardwareSerial * serialInstance) */\n\nssize_t __serialInstancecall\nHardwareSerial::readSerialData_08004270(HardwareSerial *serialInstance,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  byte receivedByte;\n  ushort tailIndex;\n  uchar c;\n  \n  tailIndex = (serialInstance->_serial).rx_tail;\n  if ((uint)(serialInstance->_serial).rx_head != (uint)tailIndex) {\n    receivedByte = (serialInstance->_serial).rx_buff[tailIndex];\n    (serialInstance->_serial).rx_tail = tailIndex + 1 & 0x3f;\n    return (uint)receivedByte;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "this": "serialInstance",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "bVar1": "receivedByte",
                "uVar2": "tailIndex",
                "FUN_08004270": "read_serial_data_08004270"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004298": {
            "entrypoint": "0x08004298",
            "current_name": "flush_serial_08004298",
            "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * serialObject) */\n\nvoid __serialObjectcall HardwareSerial::flushSerial_08004298(HardwareSerial *serialObject)\n\n{\n  if (serialObject->isDataWritten != false) {\n    do {\n    } while ((serialObject->serialData).transmitHead != (serialObject->serialData).transmitTail);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004298": "flush_serial_08004298",
                "this": "serialObject",
                "_written": "isDataWritten",
                "_serial": "serialData",
                "tx_head": "transmitHead",
                "tx_tail": "transmitTail"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042ac": {
            "entrypoint": "0x080042ac",
            "current_name": "process_serial_data_080042ac",
            "code": "\n/* WARNING: Unknown callbufferIndexng conventbufferIndexon */\n\nvobufferIndexd HardwareSerbufferIndexal::processSerialData_080042ac(serbufferIndexal_t_conflbufferIndexct *serialObject)\n\n{\n  bufferIndexnt returnValue;\n  rx_buffer_bufferIndexndex_t bufferIndex;\n  ushort newHead;\n  uchar c;\n  \n  returnValue = uart_getc((serbufferIndexal_t *)serialObject,&c);\n  bufferIndexf ((returnValue == 0) && (newHead = serialObject->rx_head + 1 & 0x3f, newHead != serialObject->rx_tabufferIndexl)) {\n    serialObject->rx_buff[serialObject->rx_head] = c;\n    serialObject->rx_head = newHead;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080042ac": "process_serial_data_080042ac",
                "obj": "serialObject",
                "iVar1": "returnValue",
                "i": "bufferIndex",
                "uVar2": "newHead"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042e8": {
            "entrypoint": "0x080042e8",
            "current_name": "write_to_serial_080042e8",
            "code": "\n/* DWARF orbuffer_indexgbuffer_indexnal prototype: sbuffer_indexze_t  wrbuffer_indexte(HardwareSerbuffer_indexal * serial_object, ubuffer_indexnt8_t c) */\n\nssbuffer_indexze_t __serial_objectcall\nHardwareSerbuffer_indexal::write_to_serial_080042e8(HardwareSerbuffer_indexal *serial_object,buffer_indexnt file_descriptor,vobuffer_indexd *buffer,sbuffer_indexze_t buffer_size)\n\n{\n  byte temp_byte_1;\n  ubuffer_indexnt8_t temp_byte_2;\n  byte temp_byte_3;\n  buffer_indexnt temp_int_1;\n  ubuffer_indexnt temp_uint_1;\n  tx_buffer_buffer_indexndex_t buffer_index;\n  \n  serial_object->_wrbuffer_indextten = true;\n  temp_uint_1 = (ubuffer_indexnt)(serial_object->_serbuffer_indexal).tx_head;\n  temp_int_1 = temp_uint_1 + 1;\n  temp_byte_1 = (byte)temp_int_1;\n  temp_byte_3 = temp_byte_1 & 0x7f;\n  buffer_indexf (temp_int_1 == 0) {\n    temp_byte_3 = -(-temp_byte_1 & 0x7f);\n  }\n  do {\n  } whbuffer_indexle ((serial_object->_serbuffer_indexal).tx_tabuffer_indexl == (ushort)temp_byte_3);\n  (serial_object->_serbuffer_indexal).tx_buff[temp_uint_1] = (ubuffer_indexnt8_t)file_descriptor;\n  (serial_object->_serbuffer_indexal).tx_head = (ushort)temp_byte_3;\n  temp_byte_2 = serbuffer_indexal_tx_actbuffer_indexve((serbuffer_indexal_t *)&serial_object->_serbuffer_indexal);\n  buffer_indexf (temp_byte_2 == '\\0') {\n    uart_attach_tx_callback((serbuffer_indexal_t *)&serial_object->_serbuffer_indexal,_tx_complete_buffer_indexrq + 1);\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "this": "serial_object",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_size",
                "bVar1": "temp_byte_1",
                "uVar2": "temp_byte_2",
                "bVar3": "temp_byte_3",
                "iVar4": "temp_int_1",
                "uVar5": "temp_uint_1",
                "i": "buffer_index",
                "FUN_080042e8": "write_to_serial_080042e8"
            },
            "calling": [],
            "called": [
                "uart_attach_tx_callback",
                "serial_tx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004338": {
            "entrypoint": "0x08004338",
            "current_name": "FUNC_08004338",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800433e) */\n/* WARNING: Removing unreachable block (ram,0x08004350) */\n/* WARNING: Removing unreachable block (ram,0x08004346) */\n/* WARNING: Removing unreachable block (ram,0x08004358) */\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004338(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004338": "FUNC_08004338"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004364": {
            "entrypoint": "0x08004364",
            "current_name": "initialize_serial_08004364",
            "code": "\n/* DWARF original prototype: void  init(HardwareSerial * serialInstance) */\n\nint __serialInstancecall HardwareSerial::initializeSerial_08004364(HardwareSerial *serialInstance,EVP_PKEY_CTX *encryptionContext)\n\n{\n  (serialInstance->_serial).rx_buff = serialInstance->_rx_buffer;\n  (serialInstance->_serial).rx_head = 0;\n  (serialInstance->_serial).rx_tail = 0;\n  (serialInstance->_serial).tx_buff = serialInstance->_tx_buffer;\n  (serialInstance->_serial).tx_head = 0;\n  (serialInstance->_serial).tx_tail = 0;\n  return (int)serialInstance;\n}\n\n",
            "renaming": {
                "FUN_08004364": "initialize_serial_08004364",
                "this": "serialInstance",
                "ctx": "encryptionContext"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004388": {
            "entrypoint": "0x08004388",
            "current_name": "configure_serial_port_08004388",
            "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * serialPort, ulong baudrate, byte config) */\n\nvoid __serialPortcall HardwareSerial::configureSerialPort_08004388(HardwareSerial *serialPort,ulong baudrate,byte config)\n\n{\n  byte configMask;\n  int numBits;\n  \n  (serialPort->_serial).baudraterate = baudrate;\n  serialPort->_config = config;\n  configMask = config & 7;\n  if (configMask == 4) {\n    numBits = 7;\n  }\n  else if (configMask == 6) {\n    numBits = 8;\n  }\n  else if (configMask == 2) {\n    numBits = 6;\n  }\n  else {\n    numBits = 0;\n  }\n  if ((config & 0x30) == 0x30) {\n    (serialPort->_serial).parity = 0x600;\n    numBits = numBits + 1;\n  }\n  else if ((config & 0x20) == 0) {\n    (serialPort->_serial).parity = 0;\n  }\n  else {\n    (serialPort->_serial).parity = 0x400;\n    numBits = numBits + 1;\n  }\n  if ((config & 8) == 0) {\n    (serialPort->_serial).stopbits = 0;\n  }\n  else {\n    (serialPort->_serial).stopbits = 0x2000;\n  }\n  if (numBits == 8) {\n    (serialPort->_serial).databits = 0;\n  }\n  else if (numBits == 9) {\n    (serialPort->_serial).databits = 0x1000;\n  }\n  else {\n    numBits = 0;\n  }\n  if (numBits != 0) {\n    uart_init((serial_t *)&serialPort->_serial);\n    uart_attach_rx_callback((serial_t *)&serialPort->_serial,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  assertFunction(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n}\n\n",
            "renaming": {
                "this": "serialPort",
                "baud": "baudrate",
                "bVar1": "configMask",
                "iVar2": "numBits",
                "__assert_func": "assertFunction",
                "FUN_08004388": "configure_serial_port_08004388"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "uart_attach_rx_callback",
                "__assert_func",
                "uart_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004444": {
            "entrypoint": "0x08004444",
            "current_name": "set_rx_pin_08004444",
            "code": "\n/* DWARF original prototype: void  setRx(HardwareSerial * serialInstance, uint32_t pinIndex) */\n\nvoid __serialInstancecall HardwareSerial::setRxPin_08004444(HardwareSerial *serialInstance,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x60) {\n    pinName = *(PinName *)(&pinArray + pinIndex * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  (serialInstance->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "this": "serialInstance",
                "_rx": "pinIndex",
                "PVar1": "pinName",
                "digitalPin": "pinArray",
                "FUN_08004444": "set_rx_pin_08004444"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004460": {
            "entrypoint": "0x08004460",
            "current_name": "set_tx_pin_08004460",
            "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * serialInstance, uint32_t pinIndex) */\n\nvoid __serialInstancecall HardwareSerial::setTxPin_08004460(HardwareSerial *serialInstance,uint32_t pinIndex)\n\n{\n  PinName pinName;\n  \n  if (pinIndex < 0x60) {\n    pinName = *(PinName *)(&digitalPin + pinIndex * 2);\n  }\n  else {\n    pinName = NC;\n  }\n  (serialInstance->_serial).pinpinIndex = pinName;\n  return;\n}\n\n",
            "renaming": {
                "this": "serialInstance",
                "_tx": "pinIndex",
                "PVar1": "pinName",
                "FUN_08004460": "set_tx_pin_08004460"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800447c": {
            "entrypoint": "0x0800447c",
            "current_name": "initialize_hardware_serial_0800447c",
            "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * serialInstance, void *\n   peripheralDevice) */\n\nHardwareSerial * __serialInstancecall HardwareSerial::initializeHardwareSerial_0800447c(HardwareSerial *serialInstance,void *peripheralDevice)\n\n{\n  PinName_conflict rxPin;\n  EVP_PKEY_CTX *ctx1;\n  EVP_PKEY_CTX *ctx2;\n  EVP_PKEY_CTX *ctx3;\n  \n  (serialInstance->super_Stream).super_Print.write_error = 0;\n  (serialInstance->super_Stream)._timeout = 1000;\n  (serialInstance->super_Stream).super_Print._vptr_Print = (_func_int_varargs **)&PTR_write_1_08005ed4;\n  if (serialInstance == &Serial3) {\n    setRx(&Serial3,0x4c);\n    setTx(&Serial3,0x4d);\n    ctx2 = ctx3;\n  }\n  else {\n    rxPin = pinmap_pin(peripheralDevice,(PinMap_conflict *)&PinMap_UART_RX);\n    (serialInstance->_serial).pin_rx = rxPin;\n    rxPin = pinmap_pin(peripheralDevice,(PinMap_conflict *)&PinMap_UART_TX);\n    (serialInstance->_serial).pin_tx = rxPin;\n    ctx2 = ctx1;\n  }\n  init(serialInstance,ctx2);\n  return serialInstance;\n}\n\n",
            "renaming": {
                "FUN_0800447c": "initialize_hardware_serial_0800447c",
                "this": "serialInstance",
                "peripheral": "peripheralDevice",
                "PVar1": "rxPin",
                "extraout_r1": "ctx1",
                "ctx": "ctx2",
                "extraout_r1_00": "ctx3"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "pinmap_pin",
                "init",
                "setTx",
                "setRx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044d8": {
            "entrypoint": "0x080044d8",
            "current_name": "initialize_serial_080044d8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerial_080044d8(int shouldInitialize,int priority)\n\n{\n  if (shouldInitialize != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    initializeHardwareSerial(serialPort,(void *)0x40004800);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044d8": "initialize_serial_080044d8",
                "__initialize_p": "shouldInitialize",
                "__priority": "priority",
                "HardwareSerial::HardwareSerial": "initializeHardwareSerial",
                "&Serial3": "serialPort"
            },
            "calling": [
                "_GLOBAL__sub_I_Serial3"
            ],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080044fc": {
            "entrypoint": "0x080044fc",
            "current_name": "initialize_static_data_080044fc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_data_080044fc(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080044fc": "initialize_static_data_080044fc"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800450a": {
            "entrypoint": "0x0800450a",
            "current_name": "print_ip_address_0800450a",
            "code": "\n/* DWARF original printerrototyprintere: size_t  printerrintTo(IPAddress * ipAddress, Print * printer) */\n\nsize_t __ipAddresscall IPAddress::printIPAddress_0800450a(IPAddress *ipAddress,Print *printer)\n\n{\n  size_t segmentLength;\n  size_t dotLength;\n  int index;\n  int totalLength;\n  \n  totalLength = 0;\n  for (index = 0; index < 3; index = index + 1) {\n    segmentLength = Print::printerrint(printer,(ipAddress->_address).bytes[index],10);\n    dotLength = Print::printerrint(printer,'.');\n    totalLength = totalLength + segmentLength + dotLength;\n  }\n  segmentLength = Print::printerrint(printer,(ipAddress->_address).bytes[3],10);\n  return segmentLength + totalLength;\n}\n\n",
            "renaming": {
                "FUN_0800450a": "print_ip_address_0800450a",
                "this": "ipAddress",
                "p": "printer",
                "iVar4": "totalLength",
                "iVar3": "index",
                "sVar1": "segmentLength",
                "sVar2": "dotLength"
            },
            "calling": [],
            "called": [
                "print",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004544": {
            "entrypoint": "0x08004544",
            "current_name": "initialize_ip_address_08004544",
            "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * ipAddress, uint8_t octet1, uint8_t\n   octet2, uint8_t octet3, uint8_t octet4) */\n\nIPAddress * __ipAddresscall\nIPAddress::initializeIPAddress_08004544(IPAddress *ipAddress,uint8_t octet1,uint8_t octet2,uint8_t octet3,\n          uint8_t octet4)\n\n{\n  (ipAddress->printableObj).printableVptr = (_func_int_varargs **)&DAT_08005f28;\n  (ipAddress->addressObj).addressBytes[0] = octet1;\n  (ipAddress->addressObj).addressBytes[1] = octet2;\n  (ipAddress->addressObj).addressBytes[2] = octet3;\n  (ipAddress->addressObj).addressBytes[3] = octet4;\n  return ipAddress;\n}\n\n",
            "renaming": {
                "this": "ipAddress",
                "first_octet": "octet1",
                "second_octet": "octet2",
                "third_octet": "octet3",
                "fourth_octet": "octet4",
                "super_Printable": "printableObj",
                "_vptr_Printable": "printableVptr",
                "_address": "addressObj",
                "bytes": "addressBytes",
                "FUN_08004544": "initialize_ip_address_08004544"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004560": {
            "entrypoint": "0x08004560",
            "current_name": "FUNC_08004560",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004560(int __initialize_p,int __priority)\n\n{\n  if ((__initialize_p == 1) && (__priority == 0xffff)) {\n    IPAddress::IPAddress(&INADDR_NONE,'\\0','\\0','\\0','\\0');\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004560": "FUNC_08004560"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN9IPAddressC2Ev"
            ],
            "called": [
                "IPAddress"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800458c": {
            "entrypoint": "0x0800458c",
            "current_name": "initialize_static_variables_0800458c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_variables_0800458c(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800458c": "initialize_static_variables_0800458c"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800459a": {
            "entrypoint": "0x0800459a",
            "current_name": "write_data_0800459a",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045ae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t print Print::write_data_0800459a(Print *this,int file_descriptor,void *buffer,size_t size)\n\n{\n  Print *ptr_print;\n  int count;\n  \n  count = 0;\n  ptr_print = this;\n  while( true ) {\n    if (buffer == (void *)0x0) {\n      return count;\n    }\n    ptr_print = (Print *)(**this->_vptr_Print)(ptr_print,(uint)*(byte *)file_descriptor,buffer,*this->_vptr_Print,size)\n    ;\n    if (ptr_print == (Print *)0x0) break;\n    count = count + 1;\n    file_descriptor = (int)(file_descriptor + 1);\n    buffer = (void *)((int)buffer + -1);\n  }\n  return count;\n}\n\n",
            "renaming": {
                "FUN_0800459a": "write_data_0800459a",
                "__thiscall": "print",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "pPVar1": "ptr_print",
                "iVar2": "count"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045be": {
            "entrypoint": "0x080045be",
            "current_name": "print_character_080045be",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045c4 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * instance, char c) */\n\nsize_t __instancecall Print::printCharacter_080045be(Print *instance,char c)\n\n{\n  size_t result;\n  \n  result = (**instance->_vptr_Print)(instance,(int)c);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080045be": "print_character_080045be",
                "this": "instance",
                "sVar1": "result"
            },
            "calling": [
                "printTo"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045c8": {
            "entrypoint": "0x080045c8",
            "current_name": "print_number_080045c8",
            "code": "\n/* WARNING: Heritage AFTER dead reremainderoval. Exaremainderple locationumber: r0 : 0x08004618 */\n/* WARNING: Restarted to delay deadcode eliremainderinumberationumber for space: register */\n/* WARNING: Exceeded remainderaxiremainderuremainder restarts with remainderore penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbertNuremainderber(Prinumbert * printer, ulonumberg number, uinumbert8_t base) */\n\nsize_t __printercall Prinumbert::printNumber_080045c8(Prinumbert *printer,ulonumberg number,uinumbert8_t base)\n\n{\n  char charValue;\n  char c;\n  size_t size1;\n  size_t size2;\n  ulonumberg remainder;\n  uinumbert tempVar1;\n  uinumbert tempVar2;\n  uinumbert tempVar3;\n  char *buffer;\n  char charBuffer [33];\n  \n  tempVar2 = (uinumbert)base;\n  charBuffer[32] = '\\0';\n  if (tempVar2 < 2) {\n    tempVar2 = 10;\n  }\n  buffer = charBuffer + 0x20;\n  remainder = number;\n  do {\n    tempVar3 = remainder / tempVar2;\n    tempVar1 = (remainder & 0xff) - ((inumbert)(short)tempVar3 * (inumbert)(short)tempVar2 & 0xffU) & 0xff;\n    buffer = buffer + -1;\n    charValue = (char)tempVar1;\n    if (tempVar1 < 10) {\n      charValue = charValue + '0';\n    }\n    else {\n      charValue = charValue + '7';\n    }\n    *buffer = charValue;\n    remainder = tempVar3;\n  } while (tempVar3 != 0);\n  if (buffer == (char *)0x0) {\n    size2 = 0;\n  }\n  else {\n    size1 = strlenumber(buffer);\n    size2 = (*printer->_vptr_Prinumbert[1])(size1,buffer,size1);\n  }\n  returnumber size2;\n}\n\n",
            "renaming": {
                "FUN_080045c8": "print_number_080045c8",
                "this": "printer",
                "n": "number",
                "cVar1": "charValue",
                "sVar2": "size1",
                "sVar3": "size2",
                "m": "remainder",
                "uVar4": "tempVar1",
                "uVar5": "tempVar2",
                "uVar6": "tempVar3",
                "__s": "buffer",
                "buf": "charBuffer"
            },
            "calling": [
                "print"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004622": {
            "entrypoint": "0x08004622",
            "current_name": "print_number_or_vptr_call_08004622",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example locationumber: r0 : 0x08004634 */\n/* WARNING: Restarted to delay deadcode eliminumberationumber for space: register */\n/* WARNING: Exceeded maximum restarts with more penumberdinumberg */\n/* DWARF originumberal prototype: size_t  prinumbert(Printer * printer, ulonumberg number, inumbert numberBase) */\n\nsize_t __printercall Printer::printNumberOrVptrCall_08004622(Printer *printer,ulonumberg number,inumbert numberBase)\n\n{\n  size_t result;\n  \n  if (numberBase != 0) {\n    result = prinumbertNumber(printer,number,(uinumbert8_t)numberBase);\n    returnumber result;\n  }\n  result = (**printer->_vptr_Printer)(printer,number & 0xff);\n  returnumber result;\n}\n\n",
            "renaming": {
                "Print": "Printer",
                "this": "printer",
                "n": "number",
                "base": "numberBase",
                "sVar1": "result",
                "FUN_08004622": "print_number_or_vptr_call_08004622"
            },
            "calling": [
                "print"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004638": {
            "entrypoint": "0x08004638",
            "current_name": "print_converted_value_08004638",
            "code": "\n/* DWARF original prototype: size_t  print(Print * printInstance, uchar b, int numberBase) */\n\nsize_t __printInstancecall Print::printConvertedValue_08004638(Print *printInstance,uchar b,int numberBase)\n\n{\n  size_t returnValue;\n  \n  returnValue = print(printInstance,(uint)b,numberBase);\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004638": "print_converted_value_08004638",
                "this": "printInstance",
                "base": "numberBase",
                "sVar1": "returnValue"
            },
            "calling": [
                "printTo"
            ],
            "called": [
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004640": {
            "entrypoint": "0x08004640",
            "current_name": "concatenate_bytes_08004640",
            "code": "\n/* WARNING: Unknown calow_bytelow_byteing convention */\n\nuint16_t concatenate_bytes_08004640(uint8_t high_byte,uint8_t low_byte)\n\n{\n  return CONCAT11(high_byte,low_byte);\n}\n\n",
            "renaming": {
                "FUN_08004640": "concatenate_bytes_08004640",
                "h": "high_byte",
                "l": "low_byte"
            },
            "calling": [
                "process_FC1",
                "process_FC3",
                "process_FC15",
                "process_FC5",
                "process_FC6",
                "validateRequest",
                "process_FC16"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004646": {
            "entrypoint": "0x08004646",
            "current_name": "FUNC_08004646",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08004646(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004646": "FUNC_08004646"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004648": {
            "entrypoint": "0x08004648",
            "current_name": "initialize_password_context_08004648",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializePasswordContext_08004648(void)\n\n{\n  EVP_PKEY_CTX *passwordContext;\n  \n  passwordContext = (EVP_PKEY_CTX *)0x3;\n  setInterruptPriorityGrouping(3);\n  initialize(passwordContext);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004648": "initialize_password_context_08004648",
                "ctx": "passwordContext",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGrouping",
                "init": "initialize"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004658": {
            "entrypoint": "0x08004658",
            "current_name": "run_program_08004658",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint runProgram_08004658(void)\n\n{\n  initializeVariant();\n  configureSystem();\n  do {\n    executeLoop();\n    handleSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004658": "run_program_08004658",
                "initVariant": "initializeVariant",
                "setup": "configureSystem",
                "loop": "executeLoop",
                "serialEventRun": "handleSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "setup",
                "initVariant",
                "loop",
                "serialEventRun"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004678": {
            "entrypoint": "0x08004678",
            "current_name": "calculate_number_of_bits_08004678",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t calculateNumberOfBits_08004678(uint16_t inputValue)\n\n{\n  uint calculatedValue;\n  uint8_t numberOfBits;\n  \n  numberOfBits = '\\0';\n  for (calculatedValue = (uint)inputValue; calculatedValue != 1; calculatedValue = calculatedValue >> 1) {\n    numberOfBits = numberOfBits + '\\x01';\n  }\n  return numberOfBits;\n}\n\n",
            "renaming": {
                "FUN_08004678": "calculate_number_of_bits_08004678",
                "pin": "inputValue",
                "uVar1": "calculatedValue",
                "uVar2": "numberOfBits"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800468c": {
            "entrypoint": "0x0800468c",
            "current_name": "cleanup_interrupt_handlers_0800468c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid cleanupInterruptHandlers_0800468c(void *handlerList)\n\n{\n  gpio_irq_conf_str *currentNode;\n  _Manager_type manager;\n  gpio_irq_conf_str *nextNode;\n  \n  currentNode = (gpio_irq_conf_str *)&__malloc_free_list;\n  while (nextNode = currentNode, nextNode != gpio_irq_conf) {\n    manager = nextNode[-1].callback.super__Function_base._M_manager;\n    currentNode = nextNode + -1;\n    if (manager != (_Manager_type)0x0) {\n      (*manager)((_Any_data *)&nextNode[-1].callback,(_Any_data *)&nextNode[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800468c": "cleanup_interrupt_handlers_0800468c",
                "param_1": "handlerList",
                "pgVar1": "currentNode",
                "p_Var2": "manager",
                "pgVar3": "nextNode"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b4": {
            "entrypoint": "0x080046b4",
            "current_name": "initialize_gpio_irq_080046b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_gpio_irq_080046b4(int is_initialized,int priority)\n\n{\n  if (is_initialized != 1) {\n    return;\n  }\n  if (priority == 0xffff) {\n    gpio_irq_config[0].irqnb = ExternalInterrupt0_IRQn;\n    gpio_irq_config[0].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[1].irqnb = ExternalInterrupt1_IRQn;\n    gpio_irq_config[1].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[2].irqnb = ExternalInterrupt2_IRQn;\n    gpio_irq_config[2].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[3].irqnb = ExternalInterrupt3_IRQn;\n    gpio_irq_config[3].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[4].irqnb = ExternalInterrupt4_IRQn;\n    gpio_irq_config[4].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[5].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_config[5].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[6].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_config[6].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[7].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_config[7].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[8].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_config[8].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[9].irqnb = ExternalInterrupt9_5_IRQn;\n    gpio_irq_config[9].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[10].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_config[10].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[11].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_config[11].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[12].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_config[12].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[13].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_config[13].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[14].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_config[14].callback_manager = (_Manager_type)0x0;\n    gpio_irq_config[15].irqnb = ExternalInterrupt15_10_IRQn;\n    gpio_irq_config[15].callback_manager = (_Manager_type)0x0;\n    register_atexit_handler(0,0x800468d,0x20000000);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b4": "initialize_gpio_irq_080046b4",
                "__initialize_p": "is_initialized",
                "__priority": "priority",
                "gpio_irq_conf": "gpio_irq_config",
                "EXTI0_IRQn": "ExternalInterrupt0_IRQn",
                "EXTI1_IRQn": "ExternalInterrupt1_IRQn",
                "EXTI2_IRQn": "ExternalInterrupt2_IRQn",
                "EXTI3_IRQn": "ExternalInterrupt3_IRQn",
                "EXTI4_IRQn": "ExternalInterrupt4_IRQn",
                "EXTI9_5_IRQn": "ExternalInterrupt9_5_IRQn",
                "EXTI15_10_IRQn": "ExternalInterrupt15_10_IRQn",
                "callback.super__Function_base._M_manager": "callback_manager",
                "__aeabi_atexit": "register_atexit_handler"
            },
            "calling": [
                "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
            ],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004760": {
            "entrypoint": "0x08004760",
            "current_name": "handle_external_interrupt_08004760",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08004760(void)\n\n{\n  handleGPIOExternalInterrupt(1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004760": "handle_external_interrupt_08004760",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800476a": {
            "entrypoint": "0x0800476a",
            "current_name": "handle_external_interrupt_0800476a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_external_interrupt_0800476a(void)\n\n{\n  handle_gpio_external_interrupt(2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800476a": "handle_external_interrupt_0800476a",
                "HAL_GPIO_EXTI_IRQHandler": "handle_gpio_external_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004774": {
            "entrypoint": "0x08004774",
            "current_name": "handle_external_interrupt_08004774",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_08004774(void)\n\n{\n  handleGpioExternalInterrupt(4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004774": "handle_external_interrupt_08004774",
                "HAL_GPIO_EXTI_IRQHandler": "handleGpioExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800477e": {
            "entrypoint": "0x0800477e",
            "current_name": "handle_external_interrupt_0800477e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExternalInterrupt_0800477e(void)\n\n{\n  handleGPIOExternalInterrupt(8);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800477e": "handle_external_interrupt_0800477e",
                "HAL_GPIO_EXTI_IRQHandler": "handleGPIOExternalInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004788": {
            "entrypoint": "0x08004788",
            "current_name": "handle_gpio_exti_irq_08004788",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_GPIO_EXTI_IRQ_08004788(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(0x10);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004788": "handle_gpio_exti_irq_08004788"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004792": {
            "entrypoint": "0x08004792",
            "current_name": "handle_ext_interrupts_08004792",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleExtInterrupts_08004792(void)\n\n{\n  uint counter;\n  \n  for (counter = 0x20; counter < 0x201; counter = counter << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)counter);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004792": "handle_ext_interrupts_08004792",
                "uVar1": "counter"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047a8": {
            "entrypoint": "0x080047a8",
            "current_name": "handle_exti_interrupts_080047a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_exti_interrupts_080047a8(void)\n\n{\n  uint step_size;\n  \n  for (step_size = 0x400; step_size < 0x8001; step_size = step_size << 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)step_size);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047a8": "handle_exti_interrupts_080047a8",
                "uVar1": "step_size"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047c0": {
            "entrypoint": "0x080047c0",
            "current_name": "invoke_function_080047c0",
            "code": "\n/* DWARF original prototype: invokeFunction_080047c0  operator()(function<invokeFunction_080047c0()> * functionPtr) */\n\ninvokeFunction_080047c0 __functionPtrcall std::function<invokeFunction_080047c0()>::invoke_function_080047c0(function<invokeFunction_080047c0()> *functionPtr)\n\n{\n  if ((functionPtr->base).manager != (_Manager_type)0x0) {\n    (*functionPtr->invoker)((data *)functionPtr);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
            "renaming": {
                "this": "functionPtr",
                "super__Function_base": "base",
                "_M_manager": "manager",
                "_M_invoker": "invoker",
                "_Any_data": "data",
                "void": "invokeFunction",
                "FUN_080047c0": "invoke_function_080047c0"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047d0": {
            "entrypoint": "0x080047d0",
            "current_name": "handle_gpio_interrupt_080047d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleGPIOInterrupt_080047d0(uint16_t pinNumber)\n\n{\n  byte pinId;\n  uint8_t interruptId;\n  \n  pinId = get_pin_id(pinNumber);\n  if (gpio_irq_conf[pinId].callback.super__Function_base._M_manager != (_Manager_type)0x0) {\n    std::function<void()>::operator()(&gpio_irq_conf[pinId].callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047d0": "handle_gpio_interrupt_080047d0",
                "GPIO_Pin": "pinNumber",
                "bVar1": "pinId",
                "irq_id": "interruptId"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "get_pin_id",
                "operator()"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f0": {
            "entrypoint": "0x080047f0",
            "current_name": "initialize_static_resources_080047f0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_static_resources_080047f0(void)\n\n{\n  initialize_static_resources_080047f0(1,0xffff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047f0": "initialize_static_resources_080047f0",
                "__static_initialization_and_destruction_0": "initialize_static_resources"
            },
            "calling": [],
            "called": [
                "__static_initialization_and_destruction_0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047fe": {
            "entrypoint": "0x080047fe",
            "current_name": "register_exit_handler_080047fe",
            "code": "\nvoid registerExitHandler_080047fe(undefined4 handlerFunction,undefined4 handlerObject)\n\n{\n  __cxa_atexit(handlerObject,handlerFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080047fe": "register_exit_handler_080047fe",
                "param_1": "handlerFunction",
                "param_2": "handlerObject"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004808": {
            "entrypoint": "0x08004808",
            "current_name": "print_assertion_error_08004808",
            "code": "\nvoid printAssertionError_08004808(undefined4 assertion,undefined4 file,char *function,undefined4 line)\n\n{\n  char *commaOrFunction;\n  \n  if (function == (char *)0x0) {\n    function = \"\";\n    commaOrFunction = function;\n  }\n  else {\n    commaOrFunction = \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           line,assertion,file,commaOrFunction,function,line);\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08004808": "print_assertion_error_08004808",
                "param_1": "assertion",
                "param_2": "file",
                "param_3": "function",
                "param_4": "line",
                "pcVar1": "commaOrFunction"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004844": {
            "entrypoint": "0x08004844",
            "current_name": "shift_param_to64_bits_08004844",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800484c) */\n\nlonglong shiftParamTo64Bits_08004844(undefined4 param,uint value)\n\n{\n  return (unsigned_long_long)value << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08004844": "shift_param_to64_bits_08004844",
                "param_1": "param",
                "param_2": "value",
                "ulonglong": "unsigned_long_long"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004860": {
            "entrypoint": "0x08004860",
            "current_name": "print_to_file_08004860",
            "code": "\nint printToFile_08004860(FILE *file,char *format,...)\n\n{\n  int result;\n  undefined4 param_1;\n  undefined4 param_2;\n  undefined4 param_3;\n  undefined4 param_4;\n  \n  param_3 = param_1;\n  param_4 = param_2;\n  result = _vfiprintf_r(impure_ptr,file,format,&param_3,file,&param_3);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004860": "print_to_file_08004860",
                "__stream": "file",
                "__format": "format",
                "iVar1": "result",
                "in_r2": "param_1",
                "in_r3": "param_2",
                "uStack_8": "param_3",
                "uStack_4": "param_4",
                "_impure_ptr": "impure_ptr"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "initialize_pre_init_arrays_08004884",
            "code": "\nvoid initializePreInitArrays_08004884(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&__preinit_array_end)[index])();\n  }\n  _init();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&__preinit_array_end)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004884": "initialize_pre_init_arrays_08004884",
                "iVar1": "index"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "premain",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048cc": {
            "entrypoint": "0x080048cc",
            "current_name": "memset_080048cc",
            "code": "\nvoid * memset_080048cc(void *destination,int value,size_t size)\n\n{\n  undefined *current_byte;\n  \n  for (current_byte = (undefined *)destination; current_byte != (undefined *)(size + (int)destination); current_byte = current_byte + 1) {\n    *current_byte = (char)value;\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_080048cc": "memset_080048cc",
                "__s": "destination",
                "__c": "value",
                "__n": "size",
                "puVar1": "current_byte"
            },
            "calling": [
                "__sfmoreglue",
                "std.isra.0",
                "__sfp"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080048dc": {
            "entrypoint": "0x080048dc",
            "current_name": "free_memory_block_080048dc",
            "code": "\nvoid free_memory_block_080048dc(undefined4 *result,int block_size,undefined4 param_3,undefined4 param_4)\n\n{\n  int *current_block;\n  int **next_block;\n  int **list_head;\n  int **current_node;\n  int **previous_node;\n  int **new_node;\n  bool is_found;\n  \n  if (block_size == 0) {\n    return;\n  }\n  new_node = (int **)(block_size + -4);\n  if (*(int *)(block_size + -4) < 0) {\n    new_node = (int **)((int)new_node + *(int *)(block_size + -4));\n  }\n  __malloc_lock();\n  current_node = (int **)&__malloc_free_list;\n  if (__malloc_free_list == (int **)0x0) {\n    new_node[1] = (int *)0x0;\n    list_head = next_block;\n    __malloc_free_list = new_node;\n  }\n  else {\n    current_node = __malloc_free_list;\n    if (new_node < __malloc_free_list) {\n      list_head = (int **)*new_node;\n      current_node = (int **)((int)new_node + (int)list_head);\n      is_found = __malloc_free_list == current_node;\n      if (is_found) {\n        current_node = (int **)*__malloc_free_list;\n        __malloc_free_list = (int **)__malloc_free_list[1];\n      }\n      new_node[1] = (int *)__malloc_free_list;\n      __malloc_free_list = new_node;\n      if (is_found) {\n        current_node = (int **)((int)current_node + (int)list_head);\n        *new_node = (int *)current_node;\n      }\n    }\n    else {\n      do {\n        previous_node = current_node;\n        current_node = (int **)previous_node[1];\n        if (current_node == (int **)0x0) break;\n      } while (current_node <= new_node);\n      list_head = (int **)*previous_node;\n      if ((int **)((int)previous_node + (int)list_head) == new_node) {\n        list_head = (int **)((int)list_head + (int)*new_node);\n        *previous_node = (int *)list_head;\n        if (current_node == (int **)((int)previous_node + (int)list_head)) {\n          current_block = *current_node;\n          current_node = (int **)current_node[1];\n          previous_node[1] = (int *)current_node;\n          list_head = (int **)((int)list_head + (int)current_block);\n          *previous_node = (int *)list_head;\n        }\n      }\n      else if (new_node < (int **)((int)previous_node + (int)list_head)) {\n        *result = 0xc;\n      }\n      else {\n        list_head = (int **)((int)new_node + (int)*new_node);\n        is_found = current_node == list_head;\n        if (is_found) {\n          list_head = (int **)*current_node;\n          current_node = (int **)current_node[1];\n        }\n        new_node[1] = (int *)current_node;\n        if (is_found) {\n          list_head = (int **)((int)list_head + (int)*new_node);\n          *new_node = (int *)list_head;\n        }\n        previous_node[1] = (int *)new_node;\n      }\n    }\n  }\n  __malloc_unlock(result,list_head,current_node,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080048dc": "free_memory_block_080048dc",
                "param_1": "result",
                "param_2": "block_size",
                "piVar1": "current_block",
                "extraout_r1": "next_block",
                "ppiVar2": "list_head",
                "ppiVar3": "current_node",
                "ppiVar4": "previous_node",
                "ppiVar5": "new_node",
                "bVar6": "is_found"
            },
            "calling": [
                "__sflush_r",
                "__swsetup_r"
            ],
            "called": [
                "__malloc_lock",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004978": {
            "entrypoint": "0x08004978",
            "current_name": "allocate_memory_08004978",
            "code": "\nuint allocate_memory_08004978(undefined4 *size_ptr,uint size)\n\n{\n  uint *current_block;\n  int difference;\n  uint *previous_block;\n  uint block_difference;\n  uint *previous_block_next;\n  uint alloc_size;\n  \n  alloc_size = (size + 3 & 0xfffffffc) + 8;\n  if (alloc_size < 0xc) {\n    alloc_size = 0xc;\n  }\n  if (((int)alloc_size < 0) || (alloc_size < size)) {\n    *size_ptr = 0xc;\n  }\n  else {\n    lock_memory();\n    current_block = free_list;\n    previous_block_next = free_list;\n    while (previous_block = current_block, previous_block != (uint *)0x0) {\n      block_difference = *previous_block - alloc_size;\n      if (-1 < (int)block_difference) {\n        if (block_difference < 0xc) {\n          if (previous_block_next == previous_block) {\n            current_block = (uint *)previous_block_next[1];\n          }\n          else {\n            current_block = (uint *)previous_block[1];\n          }\n          if (previous_block_next != previous_block) {\n            previous_block_next[1] = (uint)current_block;\n            previous_block_next = previous_block;\n            current_block = free_list;\n          }\n        }\n        else {\n          *previous_block = block_difference;\n          *(uint *)((int)previous_block + block_difference) = alloc_size;\n          previous_block_next = (uint *)((int)previous_block + block_difference);\n          current_block = free_list;\n        }\n        goto LAB_080049dc;\n      }\n      previous_block_next = previous_block;\n      current_block = (uint *)previous_block[1];\n    }\n    if (sbrk_start == 0) {\n      sbrk_start = sbrk(size_ptr);\n    }\n    current_block = (uint *)sbrk(size_ptr,alloc_size);\n    if ((current_block != (uint *)0xffffffff) &&\n       ((previous_block_next = (uint *)((int)current_block + 3U & 0xfffffffc), current_block == previous_block_next ||\n        (difference = sbrk(size_ptr,(int)previous_block_next - (int)current_block), difference != -1)))) {\n      *previous_block_next = alloc_size;\n      current_block = free_list;\nLAB_080049dc:\n      free_list = current_block;\n      unlock_memory(size_ptr);\n      alloc_size = (int)previous_block_next + 0xbU & 0xfffffff8;\n      difference = alloc_size - (int)(previous_block_next + 1);\n      if (difference != 0) {\n        *(int *)((int)previous_block_next + difference) = -difference;\n        return alloc_size;\n      }\n      return alloc_size;\n    }\n    *size_ptr = 0xc;\n    unlock_memory(size_ptr);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004978": "allocate_memory_08004978",
                "param_1": "size_ptr",
                "param_2": "size",
                "puVar1": "current_block",
                "iVar2": "difference",
                "puVar3": "previous_block",
                "uVar4": "block_difference",
                "puVar5": "previous_block_next",
                "uVar6": "alloc_size",
                "__malloc_lock": "lock_memory",
                "__malloc_free_list": "free_list",
                "__malloc_sbrk_start": "sbrk_start",
                "_sbrk_r": "sbrk",
                "__malloc_unlock": "unlock_memory"
            },
            "calling": [
                "__sfmoreglue",
                "__smakebuf_r"
            ],
            "called": [
                "__malloc_lock",
                "_sbrk_r",
                "__malloc_unlock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a34": {
            "entrypoint": "0x08004a34",
            "current_name": "write_char_to_stream_08004a34",
            "code": "\nuint writeCharToStream_08004a34(undefined4 stream,byte character,byte **streamBuffer)\n\n{\n  uint result;\n  byte *bufferPtr;\n  \n  bufferPtr = streamBuffer[2] + -1;\n  streamBuffer[2] = bufferPtr;\n  if (((int)bufferPtr < 0) && (((int)bufferPtr < (int)streamBuffer[6] || (character == 10)))) {\n    result = __swbuf_r();\n    return result;\n  }\n  bufferPtr = *streamBuffer;\n  *streamBuffer = bufferPtr + 1;\n  *bufferPtr = character;\n  return (uint)character;\n}\n\n",
            "renaming": {
                "FUN_08004a34": "write_char_to_stream_08004a34",
                "param_1": "stream",
                "param_2": "character",
                "param_3": "streamBuffer",
                "uVar1": "result",
                "pbVar2": "bufferPtr"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "__swbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a60": {
            "entrypoint": "0x08004a60",
            "current_name": "write_to_file_08004a60",
            "code": "\nint writeToFile_08004a60(undefined4 file,undefined4 mode,undefined *data,int size)\n\n{\n  int result;\n  undefined *endPointer;\n  int currentSize;\n  \n  endPointer = data + size;\n  currentSize = size;\n  do {\n    if (data == endPointer) {\n      return 0;\n    }\n    result = __sfputc_r(file,*data,mode,size,currentSize);\n    size = result + 1;\n    data = data + 1;\n  } while (size != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004a60": "write_to_file_08004a60",
                "param_1": "file",
                "param_2": "mode",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "result",
                "puVar2": "endPointer",
                "iVar3": "currentSize"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a84": {
            "entrypoint": "0x08004a84",
            "current_name": "print_formatted_08004a84",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08004c58) */\n\nint print_formatted_08004a84(int stream,undefined4 *format_str,byte *format_args,int *args_count)\n\n{\n  bool bVar1;\n  int write_result;\n  void *format_symbol;\n  int *arg_ptr;\n  byte *curr_char;\n  byte *start_char;\n  int arg_index;\n  int value;\n  int *arg_ptr_stack;\n  uint flags;\n  int precision;\n  undefined4 length_modifier;\n  int width;\n  int total_written;\n  byte conversion_specifier;\n  undefined space_flag;\n  undefined plus_flag;\n  undefined zero_flag;\n  undefined4 tmp_buffer;\n  \n  arg_ptr_stack = args_count;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format_str == &__sf_fake_stdin) {\n    format_str = *(undefined4 **)(stream + 4);\n  }\n  else if (format_str == (undefined4 *)&__sf_fake_stdout) {\n    format_str = *(undefined4 **)(stream + 8);\n  }\n  else if (format_str == (undefined4 *)&__sf_fake_stderr) {\n    format_str = *(undefined4 **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format_str + 3) << 0x1c)) || (format_str[4] == 0)) &&\n     (value = __swsetup_r(stream,format_str), value != 0)) {\n    return -1;\n  }\n  total_written = 0;\n  space_flag = 0x20;\n  plus_flag = 0x30;\n  curr_char = format_args;\nLAB_08004ac6:\n  start_char = curr_char;\n  if (*start_char != 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  curr_char = start_char + 1;\n  if (*start_char != 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  value = (int)start_char - (int)format_args;\n  if (value != 0) {\n    write_result = __sfputs_r(stream,format_str,format_args,value);\n    if (write_result == -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(format_str + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return total_written;\n    }\n    total_written = total_written + value;\n  }\n  if (*start_char == 0) goto LAB_08004c70;\n  flags = 0;\n  width = 0;\n  precision = -1;\n  length_modifier = 0;\n  zero_flag = 0;\n  tmp_buffer = 0;\n  curr_char = start_char + 1;\n  while( true ) {\n    format_symbol = memchr(\"#-0+ \",(uint)*curr_char,5);\n    format_args = curr_char + 1;\n    if (format_symbol == (void *)0x0) break;\n    flags = 1 << ((int)format_symbol + 0xf7ffa094U & 0xff) | flags;\n    curr_char = format_args;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    zero_flag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    zero_flag = 0x2b;\n  }\n  if (*curr_char == 0x2a) {\n    arg_ptr = arg_ptr_stack + 1;\n    value = *arg_ptr_stack;\n    arg_ptr_stack = arg_ptr;\n    if (value < 0) {\n      width = -value;\n      flags = flags | 2;\n      goto LAB_08004bae;\n    }\n  }\n  else {\n    bVar1 = false;\n    value = width;\n    format_args = curr_char;\n    while( true ) {\n      if (9 < *format_args - 0x30) break;\n      value = value * 10 + (*format_args - 0x30);\n      bVar1 = true;\n      format_args = format_args + 1;\n    }\n    if (!bVar1) goto LAB_08004bae;\n  }\n  width = value;\nLAB_08004bae:\n  if (*format_args == 0x2e) {\n    if (format_args[1] == 0x2a) {\n      precision = *arg_ptr_stack;\n      if (precision < 0) {\n        precision = -1;\n      }\n      format_args = format_args + 2;\n      arg_ptr_stack = arg_ptr_stack + 1;\n    }\n    else {\n      bVar1 = false;\n      precision = 0;\n      value = 0;\n      while( true ) {\n        format_args = format_args + 1;\n        if (9 < *format_args - 0x30) break;\n        value = value * 10 + (*format_args - 0x30);\n        bVar1 = true;\n      }\n      if (bVar1) {\n        precision = value;\n      }\n    }\n  }\n  format_symbol = memchr(&DAT_08005f72,(uint)*format_args,3);\n  if (format_symbol != (void *)0x0) {\n    flags = flags | 0x40 << ((int)format_symbol + 0xf7ffa08eU & 0xff);\n    format_args = format_args + 1;\n  }\n  conversion_specifier = *format_args;\n  format_args = format_args + 1;\n  format_symbol = memchr(\"efgEFG\",(uint)conversion_specifier,6);\n  if (format_symbol == (void *)0x0) {\n    arg_index = _printf_i(stream,&flags,format_str,0x8004a61,&arg_ptr_stack);\n    if (arg_index == -1) goto LAB_08004c70;\n  }\n  else {\n    arg_ptr_stack = (int *)(((int)arg_ptr_stack + 7U & 0xfffffff8) + 8);\n  }\n  total_written = total_written + arg_index;\n  curr_char = format_args;\n  goto LAB_08004ac6;\n}\n\n",
            "renaming": {
                "FUN_08004a84": "print_formatted_08004a84",
                "param_1": "stream",
                "param_2": "format_str",
                "param_3": "format_args",
                "param_4": "args_count",
                "iVar2": "write_result",
                "pvVar3": "format_symbol",
                "piVar4": "arg_ptr",
                "pbVar5": "curr_char",
                "pbVar6": "start_char",
                "unaff_r9": "arg_index",
                "iVar7": "value",
                "local_8c": "arg_ptr_stack",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "length_modifier",
                "local_7c": "width",
                "local_74": "total_written",
                "local_70": "conversion_specifier",
                "local_6f": "space_flag",
                "local_6e": "plus_flag",
                "local_45": "zero_flag",
                "local_30": "tmp_buffer"
            },
            "calling": [
                "fiprintf",
                "iprintf"
            ],
            "called": [
                "_printf_i",
                "__sinit",
                "memchr",
                "__swsetup_r",
                "__sfputs_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb0": {
            "entrypoint": "0x08004cb0",
            "current_name": "process_data_08004cb0",
            "code": "\nundefined4\nprocessData_08004cb0(undefined4 inputData,uint *data,uint *outputSize,undefined4 param_4,code *callbackFunc)\n\n{\n  int index;\n  int result;\n  uint tempVar1;\n  uint tempVar2;\n  bool condition;\n  \n  tempVar1 = data[4];\n  if ((int)data[4] < (int)data[2]) {\n    tempVar1 = data[2];\n  }\n  *outputSize = tempVar1;\n  if (*(char *)((int)data + 0x43) != '\\0') {\n    *outputSize = tempVar1 + 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *outputSize = *outputSize + 2;\n  }\n  if ((*data & 6) == 0) {\n    for (index = 0; index < (int)(data[3] - *outputSize); index = index + 1) {\n      result = (*callbackFunc)(inputData,param_4,(int)data + 0x19,1);\n      if (result == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  tempVar1 = (uint)*(byte *)((int)data + 0x43);\n  if (tempVar1 != 0) {\n    tempVar1 = 1;\n  }\n  if ((int)(*data << 0x1a) < 0) {\n    *(undefined *)((int)data + tempVar1 + 0x43) = 0x30;\n    *(undefined *)((int)data + tempVar1 + 0x44) = *(undefined *)((int)data + 0x45);\n    tempVar1 = tempVar1 + 2;\n  }\n  index = (*callbackFunc)(inputData,param_4,(int)data + 0x43,tempVar1);\n  if (index != -1) {\n    tempVar1 = data[3];\n    condition = (*data & 6) == 4;\n    if (condition) {\n      tempVar1 = tempVar1 - *outputSize;\n    }\n    if (condition) {\n      tempVar1 = tempVar1 & ~((int)tempVar1 >> 0x1f);\n    }\n    else {\n      tempVar1 = 0;\n    }\n    if ((int)data[4] < (int)data[2]) {\n      tempVar1 = tempVar1 + (data[2] - data[4]);\n    }\n    tempVar2 = 0;\n    while( true ) {\n      if (tempVar1 == tempVar2) {\n        return 0;\n      }\n      index = (*callbackFunc)(inputData,param_4,(int)data + 0x1a,1);\n      if (index == -1) break;\n      tempVar2 = tempVar2 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004cb0": "process_data_08004cb0",
                "param_1": "inputData",
                "param_2": "data",
                "param_3": "outputSize",
                "param_5": "callbackFunc",
                "iVar1": "index",
                "iVar2": "result",
                "uVar3": "tempVar1",
                "uVar4": "tempVar2",
                "bVar5": "condition"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d9c": {
            "entrypoint": "0x08004d9c",
            "current_name": "print_formatted_output_08004d9c",
            "code": "\nuint print_formatted_output_08004d9c(undefined4 message,uint *format_string,undefined4 num_args,code *output_function,uint **arg_pointers)\n\n{\n  byte byte_val;\n  int result;\n  uint *arg_ptr;\n  void *found_null;\n  int write_result;\n  char *hex_char_list;\n  uint arg_value;\n  uint **pparg_ptr;\n  char **ppcstr_ptr;\n  uint arg_length;\n  uint arg_sign;\n  char *output_ptr;\n  char *output_str;\n  uint local_vars [2];\n  \n  byte_val = *(byte *)(format_string + 6);\n  output_str = (char *)((int)format_string + 0x43);\n  if (byte_val != 0x6e) {\n    if (byte_val < 0x6f) {\n      if (byte_val != 99) {\n        if (byte_val < 100) {\n          if (byte_val == 0) goto LAB_08004f56;\n          if (byte_val != 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)format_string + 0x45) = 0x58;\n          hex_char_list = \"0123456789ABCDEF\";\nLAB_08004ee6:\n          arg_value = *format_string;\n          arg_ptr = *arg_pointers;\n          *arg_pointers = arg_ptr + 1;\n          if (((arg_value & 0x80) == 0) && ((int)(arg_value << 0x19) < 0)) {\n            arg_length = (uint)*(ushort *)arg_ptr;\n          }\n          else {\n            arg_length = *arg_ptr;\n          }\n          if ((int)(arg_value << 0x1f) < 0) {\n            *format_string = arg_value | 0x20;\n          }\n          if (arg_length == 0) {\n            *format_string = *format_string & 0xffffffdf;\n          }\n          arg_value = 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)format_string + 0x43) = 0;\n        }\n        else {\n          if ((byte_val != 100) && (byte_val != 0x69)) goto LAB_08004dcc;\n          arg_length = *format_string;\n          arg_ptr = *arg_pointers;\n          if ((arg_length & 0x80) == 0) {\n            *arg_pointers = arg_ptr + 1;\n            if ((arg_length & 0x40) == 0) goto LAB_08004dec;\n            arg_length = (uint)(short)*(ushort *)arg_ptr;\n          }\n          else {\n            *arg_pointers = arg_ptr + 1;\nLAB_08004dec:\n            arg_length = *arg_ptr;\n          }\n          if ((int)arg_length < 0) {\n            arg_length = -arg_length;\n            *(undefined *)((int)format_string + 0x43) = 0x2d;\n          }\n          hex_char_list = \"0123456789ABCDEF\";\n          arg_value = 10;\n        }\n        arg_sign = format_string[1];\n        format_string[2] = arg_sign;\n        output_ptr = output_str;\n        if ((int)arg_sign < 0) {\n          if (arg_length != 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(char *)((int)format_string + 0x42) = *hex_char_list;\n          output_ptr = (char *)((int)format_string + 0x42);\n        }\n        else {\n          *format_string = *format_string & 0xfffffffb;\n          if (arg_length == 0) {\n            if (arg_sign != 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              arg_sign = arg_length / arg_value;\n              output_ptr = output_ptr + -1;\n              *output_ptr = hex_char_list[arg_length - arg_value * arg_sign];\n              arg_length = arg_sign;\n            } while (arg_sign != 0);\n          }\n        }\n        if (((arg_value == 8) && ((int)(*format_string << 0x1f) < 0)) && ((int)format_string[1] <= (int)format_string[4]))\n        {\n          output_ptr[-1] = '0';\n          output_ptr = output_ptr + -1;\n        }\n        format_string[4] = (int)output_str - (int)output_ptr;\n        output_str = output_ptr;\n        goto LAB_08004ec2;\n      }\n      arg_ptr = *arg_pointers;\n      *arg_pointers = arg_ptr + 1;\n      *(char *)((int)format_string + 0x42) = (char)*arg_ptr;\nLAB_08004e2c:\n      output_str = (char *)((int)format_string + 0x42);\n      arg_length = 1;\n    }\n    else {\n      if (byte_val != 0x73) {\n        if (byte_val < 0x74) {\n          if (byte_val == 0x6f) {\nLAB_08004e52:\n            arg_length = *format_string;\n            arg_ptr = *arg_pointers;\n            if ((arg_length & 0x80) == 0) {\n              *arg_pointers = arg_ptr + 1;\n              if ((arg_length & 0x40) == 0) goto LAB_08004e60;\n              arg_length = (uint)*(ushort *)arg_ptr;\n            }\n            else {\n              *arg_pointers = arg_ptr + 1;\nLAB_08004e60:\n              arg_length = *arg_ptr;\n            }\n            hex_char_list = \"0123456789ABCDEF\";\n            if (byte_val == 0x6f) {\n              arg_value = 8;\n            }\n            else {\n              arg_value = 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (byte_val == 0x70) {\n            *format_string = *format_string | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)format_string + 0x45) = 0x78;\n            hex_char_list = \"0123456789abcdef\";\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (byte_val == 0x75) goto LAB_08004e52;\n          if (byte_val == 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)format_string + 0x42) = byte_val;\n        goto LAB_08004e2c;\n      }\n      ppcstr_ptr = (char **)*arg_pointers;\n      *arg_pointers = (uint *)(ppcstr_ptr + 1);\n      output_str = *ppcstr_ptr;\n      found_null = memchr(output_str,0,format_string[1]);\n      if (found_null != (void *)0x0) {\n        format_string[1] = (int)found_null - (int)output_str;\n      }\n      arg_length = format_string[1];\n    }\n    format_string[4] = arg_length;\n    *(undefined *)((int)format_string + 0x43) = 0;\n    goto LAB_08004ec2;\n  }\n  arg_length = *format_string;\n  pparg_ptr = (uint **)*arg_pointers;\n  arg_value = format_string[5];\n  if ((arg_length & 0x80) == 0) {\n    *arg_pointers = (uint *)(pparg_ptr + 1);\n    arg_ptr = *pparg_ptr;\n    if ((arg_length & 0x40) == 0) goto LAB_08004f42;\n    *(short *)arg_ptr = (short)arg_value;\n  }\n  else {\n    *arg_pointers = (uint *)(pparg_ptr + 1);\n    arg_ptr = *pparg_ptr;\nLAB_08004f42:\n    *arg_ptr = arg_value;\n  }\nLAB_08004f56:\n  format_string[4] = 0;\nLAB_08004ec2:\n  result = _printf_common(message,format_string,local_vars,num_args,output_function);\n  if ((result == -1) || (result = (*output_function)(message,num_args,output_str,format_string[4]), result == -1)) {\nLAB_08004ed6:\n    arg_length = 0xffffffff;\n  }\n  else {\n    if ((int)(*format_string << 0x1e) < 0) {\n      for (result = 0; result < (int)(format_string[3] - local_vars[0]); result = result + 1) {\n        write_result = (*output_function)(message,num_args,(int)format_string + 0x19,1);\n        if (write_result == -1) goto LAB_08004ed6;\n      }\n    }\n    arg_length = format_string[3];\n    if ((int)format_string[3] < (int)local_vars[0]) {\n      arg_length = local_vars[0];\n    }\n  }\n  return arg_length;\n}\n\n",
            "renaming": {
                "FUN_08004d9c": "print_formatted_output_08004d9c",
                "param_1": "message",
                "param_2": "format_string",
                "param_3": "num_args",
                "param_4": "output_function",
                "param_5": "arg_pointers",
                "bVar1": "byte_val",
                "iVar2": "result",
                "puVar3": "arg_ptr",
                "pvVar4": "found_null",
                "iVar5": "write_result",
                "pcVar6": "hex_char_list",
                "uVar7": "arg_value",
                "ppuVar8": "pparg_ptr",
                "ppcVar9": "ppcstr_ptr",
                "uVar10": "arg_length",
                "uVar11": "arg_sign",
                "pcVar12": "output_ptr",
                "__s": "output_str",
                "local_24": "local_vars"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_printf_common",
                "memchr"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004fdc": {
            "entrypoint": "0x08004fdc",
            "current_name": "print_formatted_output_08004fdc",
            "code": "\nint printFormattedOutput_08004fdc(char *formatString,...)\n\n{\n  int impurePointer;\n  undefined4 register1;\n  undefined4 register2;\n  undefined4 register3;\n  char *formatPointer;\n  undefined4 register_c;\n  undefined4 register_8;\n  undefined4 register_4;\n  \n  impurePointer = _impure_ptr;\n  formatPointer = formatString;\n  register_c = register1;\n  register_8 = register2;\n  register_4 = register3;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  impurePointer = _vfiprintf_r(impurePointer,*(undefined4 *)(impurePointer + 8),formatString,&register_c,formatPointer,&register_c);\n  return impurePointer;\n}\n\n",
            "renaming": {
                "FUN_08004fdc": "print_formatted_output_08004fdc",
                "__format": "formatString",
                "iVar1": "impurePointer",
                "in_r1": "register1",
                "in_r2": "register2",
                "in_r3": "register3",
                "pcVar2": "formatPointer",
                "uStack_c": "register_c",
                "uStack_8": "register_8",
                "uStack_4": "register_4"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "__sinit",
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800500c": {
            "entrypoint": "0x0800500c",
            "current_name": "allocate_memory_0800500c",
            "code": "\nvoid allocate_memory_0800500c(int *error_code,intptr_t size_to_allocate)\n\n{\n  void *allocated_memory;\n  \n  error_number = 0;\n  allocated_memory = system_break(size_to_allocate);\n  if ((allocated_memory == (void *)0xffffffff) && (error_number != 0)) {\n    *error_code = error_number;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800500c": "allocate_memory_0800500c",
                "param_1": "error_code",
                "param_2": "size_to_allocate",
                "pvVar1": "allocated_memory",
                "_sbrk": "system_break",
                "errno": "error_number"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800502c": {
            "entrypoint": "0x0800502c",
            "current_name": "process_buffer_0800502c",
            "code": "\nuint processBuffer_0800502c(int buffer,uint size,int *stream,undefined4 mode)\n\n{\n  int tempVar1;\n  uint tempVar2;\n  undefined *tempVar3;\n  \n  if ((buffer != 0) && (*(int *)(buffer + 0x18) == 0)) {\n    __sinit();\n  }\n  if (stream == &__sf_fake_stdin) {\n    stream = *(int **)(buffer + 4);\n  }\n  else if (stream == (int *)&__sf_fake_stdout) {\n    stream = *(int **)(buffer + 8);\n  }\n  else if (stream == (int *)&__sf_fake_stderr) {\n    stream = *(int **)(buffer + 0xc);\n  }\n  stream[2] = stream[6];\n  tempVar2 = (uint)*(ushort *)(stream + 3);\n  tempVar1 = tempVar2 << 0x1c;\n  if (((tempVar1 < 0) && (tempVar2 = stream[4], tempVar2 != 0)) ||\n     (tempVar1 = __swsetup_r(buffer,stream,tempVar1,tempVar2,mode), tempVar1 == 0)) {\n    tempVar1 = *stream - stream[4];\n    size = size & 0xff;\n    if ((tempVar1 < stream[5]) || (tempVar1 = _fflush_r(buffer,stream), tempVar1 == 0)) {\n      stream[2] = stream[2] + -1;\n      tempVar3 = (undefined *)*stream;\n      *stream = (int)(tempVar3 + 1);\n      *tempVar3 = (char)size;\n      if (tempVar1 + 1 != stream[5]) {\n        if (-1 < (int)((uint)*(ushort *)(stream + 3) << 0x1f)) {\n          return size;\n        }\n        if (size != 10) {\n          return size;\n        }\n      }\n      tempVar1 = _fflush_r(buffer,stream);\n      if (tempVar1 == 0) {\n        return size;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800502c": "process_buffer_0800502c",
                "param_1": "buffer",
                "param_2": "size",
                "param_3": "stream",
                "param_4": "mode",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "puVar3": "tempVar3"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit",
                "_fflush_r",
                "__swsetup_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080050d0": {
            "entrypoint": "0x080050d0",
            "current_name": "process_file_080050d0",
            "code": "\nuint processFile_080050d0(undefined4 *outputErrorCode,undefined4 *inputFile)\n\n{\n  int impurePtr;\n  uint result;\n  ushort flags;\n  \n  impurePtr = _impure_ptr;\n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x18) == 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (inputFile == &__sf_fake_stdin) {\n    inputFile = *(undefined4 **)(impurePtr + 4);\n  }\n  else if (inputFile == (undefined4 *)&__sf_fake_stdout) {\n    inputFile = *(undefined4 **)(impurePtr + 8);\n  }\n  else if (inputFile == (undefined4 *)&__sf_fake_stderr) {\n    inputFile = *(undefined4 **)(impurePtr + 0xc);\n  }\n  flags = *(ushort *)(inputFile + 3);\n  result = (uint)flags;\n  if (-1 < (int)(result << 0x1c)) {\n    if (-1 < (int)(result << 0x1b)) {\n      *outputErrorCode = 9;\n      goto LAB_08005100;\n    }\n    if ((int)(result << 0x1d) < 0) {\n      if ((undefined4 *)inputFile[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)inputFile[0xd] != inputFile + 0x11) {\n          _free_r(outputErrorCode);\n        }\n        inputFile[0xd] = 0;\n      }\n      *(ushort *)(inputFile + 3) = *(ushort *)(inputFile + 3) & 0xffdb;\n      inputFile[1] = 0;\n      *inputFile = inputFile[4];\n    }\n    *(ushort *)(inputFile + 3) = *(ushort *)(inputFile + 3) | 8;\n  }\n  if ((inputFile[4] == 0) && ((*(ushort *)(inputFile + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(outputErrorCode,inputFile);\n  }\n  flags = *(ushort *)(inputFile + 3);\n  result = flags & 1;\n  if ((flags & 1) == 0) {\n    if (-1 < (int)((uint)flags << 0x1e)) {\n      result = inputFile[5];\n    }\n    inputFile[2] = result;\n  }\n  else {\n    inputFile[2] = 0;\n    inputFile[6] = -inputFile[5];\n  }\n  if (inputFile[4] == 0) {\n    flags = *(ushort *)(inputFile + 3);\n    result = (int)(short)flags & 0x80;\n    if (result != 0) {\nLAB_08005100:\n      *(ushort *)(inputFile + 3) = flags | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080050d0": "process_file_080050d0",
                "param_1": "outputErrorCode",
                "param_2": "inputFile",
                "iVar1": "impurePtr",
                "uVar2": "result",
                "uVar3": "flags"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r"
            ],
            "called": [
                "__sinit",
                "_free_r",
                "__smakebuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051ac": {
            "entrypoint": "0x080051ac",
            "current_name": "halt_and_exit_080051ac",
            "code": "\n\n\nvoid haltAndExit_080051ac(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
            "renaming": {
                "FUN_080051ac": "halt_and_exit_080051ac"
            },
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "called": [
                "raise",
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080051bc": {
            "entrypoint": "0x080051bc",
            "current_name": "process_data_080051bc",
            "code": "\nundefined4 processData_080051bc(uint *dataPointer,int *paramArray)\n\n{\n  int status;\n  int *tempPointer;\n  uint ushortValue;\n  ushort ushortFlag;\n  int tempVar1;\n  code *functionPointer;\n  int tempVar2;\n  uint tempVar3;\n  bool boolFlag;\n  \n  ushortFlag = *(ushort *)(paramArray + 3);\n  ushortValue = (uint)ushortFlag;\n  if ((int)(ushortValue << 0x1c) < 0) {\n    status = paramArray[4];\n    if (status != 0) {\n      tempVar1 = ushortValue << 0x1e;\n      boolFlag = tempVar1 == 0;\n      tempVar2 = *paramArray;\n      if (boolFlag) {\n        tempVar1 = paramArray[5];\n      }\n      *paramArray = status;\n      if (!boolFlag) {\n        tempVar1 = 0;\n      }\n      paramArray[2] = tempVar1;\n      for (tempVar2 = tempVar2 - status; 0 < tempVar2; tempVar2 = tempVar2 - tempVar1) {\n        tempVar1 = (*(code *)paramArray[10])(dataPointer,paramArray[8],status,tempVar2);\n        if (tempVar1 < 1) {\n          ushortFlag = *(ushort *)(paramArray + 3);\n          goto LAB_080052b2;\n        }\n        status = status + tempVar1;\n      }\n    }\n  }\n  else if (((0 < paramArray[1]) || (0 < paramArray[0x10])) &&\n          (functionPointer = (code *)paramArray[0xb], functionPointer != (code *)0x0)) {\n    tempVar3 = *dataPointer;\n    *dataPointer = 0;\n    if ((ushortFlag & 0x1000) == 0) {\n      status = (*functionPointer)(dataPointer,paramArray[8],ushortValue & 0x1000,1);\n      if ((status == -1) && (ushortValue = *dataPointer, ushortValue != 0)) {\n        if ((ushortValue != 0x1d) && (ushortValue != 0x16)) {\n          *(ushort *)(paramArray + 3) = *(ushort *)(paramArray + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *dataPointer = tempVar3;\n        return 0;\n      }\n    }\n    else {\n      status = paramArray[0x15];\n    }\n    if (((int)((uint)*(ushort *)(paramArray + 3) << 0x1d) < 0) &&\n       (status = status - paramArray[1], paramArray[0xd] != 0)) {\n      status = status - paramArray[0x10];\n    }\n    status = (*(code *)paramArray[0xb])(dataPointer,paramArray[8],status,0);\n    ushortFlag = *(ushort *)(paramArray + 3);\n    if ((status == -1) &&\n       ((0x1d < *dataPointer || (-1 < (int)((0x20400001U >> (*dataPointer & 0xff)) << 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(paramArray + 3) = ushortFlag | 0x40;\n      return 0xffffffff;\n    }\n    paramArray[1] = 0;\n    *paramArray = paramArray[4];\n    if (((int)((uint)ushortFlag << 0x13) < 0) && ((status != -1 || (*dataPointer == 0)))) {\n      paramArray[0x15] = status;\n    }\n    tempPointer = (int *)paramArray[0xd];\n    *dataPointer = tempVar3;\n    if (tempPointer != (int *)0x0) {\n      if (tempPointer != paramArray + 0x11) {\n        _free_r(dataPointer);\n      }\n      paramArray[0xd] = 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080051bc": "process_data_080051bc",
                "param_1": "dataPointer",
                "param_2": "paramArray",
                "iVar1": "status",
                "piVar2": "tempPointer",
                "uVar3": "ushortValue",
                "uVar4": "ushortFlag",
                "iVar5": "tempVar1",
                "pcVar6": "functionPointer",
                "iVar7": "tempVar2",
                "uVar8": "tempVar3",
                "bVar9": "boolFlag"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052cc": {
            "entrypoint": "0x080052cc",
            "current_name": "check_and_flush_io_080052cc",
            "code": "\nundefined4 check_and_flush_io_080052cc(int buffer_ptr,undefined4 *stream_ptr,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 result;\n  \n  if (stream_ptr[4] != 0) {\n    if ((buffer_ptr != 0) && (*(int *)(buffer_ptr + 0x18) == 0)) {\n      __sinit();\n    }\n    if (stream_ptr == &stdin_ptr) {\n      stream_ptr = *(undefined4 **)(buffer_ptr + 4);\n    }\n    else if (stream_ptr == (undefined4 *)&stdout_ptr) {\n      stream_ptr = *(undefined4 **)(buffer_ptr + 8);\n    }\n    else if (stream_ptr == (undefined4 *)&stderr_ptr) {\n      stream_ptr = *(undefined4 **)(buffer_ptr + 0xc);\n    }\n    if (*(short *)(stream_ptr + 3) != 0) {\n      result = __sflush_r(buffer_ptr,stream_ptr,param_3,param_4);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080052cc": "check_and_flush_io_080052cc",
                "param_1": "buffer_ptr",
                "param_2": "stream_ptr",
                "uVar1": "result",
                "__sf_fake_stdin": "stdin_ptr",
                "__sf_fake_stdout": "stdout_ptr",
                "__sf_fake_stderr": "stderr_ptr"
            },
            "calling": [
                "__swbuf_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005320": {
            "entrypoint": "0x08005320",
            "current_name": "initialize_file_walk_08005320",
            "code": "\nvoid initializeFileWalk_08005320(undefined4 reent)\n\n{\n  fileWalkReent(reent,0x80052cd);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005320": "initialize_file_walk_08005320",
                "param_1": "reent",
                "_fwalk_reent": "fileWalkReent"
            },
            "calling": [],
            "called": [
                "_fwalk_reent"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800532c": {
            "entrypoint": "0x0800532c",
            "current_name": "initialize_parameters_0800532c",
            "code": "\nvoid initializeParameters_0800532c(undefined4 *parameters,undefined2 value1,undefined2 value2)\n\n{\n  *parameters = 0;\n  parameters[1] = 0;\n  parameters[2] = 0;\n  *(undefined2 *)(parameters + 3) = value1;\n  parameters[0x19] = 0;\n  *(undefined2 *)((int)parameters + 0xe) = value2;\n  parameters[4] = 0;\n  parameters[5] = 0;\n  parameters[6] = 0;\n  memset(parameters + 0x17,0,8);\n  parameters[9] = 0x8005609;\n  parameters[10] = 0x800562b;\n  parameters[0xb] = 0x8005663;\n  parameters[8] = parameters;\n  parameters[0xc] = 0x8005687;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800532c": "initialize_parameters_0800532c",
                "param_1": "parameters",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005374": {
            "entrypoint": "0x08005374",
            "current_name": "allocate_memory_block_08005374",
            "code": "\nundefined4 * allocateMemoryBlock_08005374(undefined4 blockSize,int numBlocks)\n\n{\n  undefined4 *memoryBlock;\n  int totalSize;\n  \n  totalSize = (numBlocks + -1) * 0x68;\n  memoryBlock = (undefined4 *)_malloc_r(blockSize,totalSize + 0x74);\n  if (memoryBlock != (undefined4 *)0x0) {\n    *memoryBlock = 0;\n    memoryBlock[1] = numBlocks;\n    memoryBlock[2] = memoryBlock + 3;\n    memset(memoryBlock + 3,0,totalSize + 0x68);\n  }\n  return memoryBlock;\n}\n\n",
            "renaming": {
                "FUN_08005374": "allocate_memory_block_08005374",
                "param_1": "blockSize",
                "param_2": "numBlocks",
                "puVar1": "memoryBlock",
                "iVar2": "totalSize"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053a0": {
            "entrypoint": "0x080053a0",
            "current_name": "initialize_data_080053a0",
            "code": "\nvoid initializeData_080053a0(undefined1 *dataPtr)\n\n{\n  undefined4 result;\n  undefined1 *impureDataPtr;\n  \n  if (*(int *)(dataPtr + 0x18) == 0) {\n    *(undefined4 *)(dataPtr + 0x48) = 0;\n    *(undefined4 *)(dataPtr + 0x4c) = 0;\n    *(undefined4 *)(dataPtr + 0x50) = 0;\n    impureDataPtr = &impure_data;\n    *(undefined4 *)(dataPtr + 0x28) = 0x8005321;\n    if (dataPtr == &impure_data) {\n      impureDataPtr = (undefined1 *)0x1;\n    }\n    if (dataPtr == &impure_data) {\n      *(undefined1 **)(dataPtr + 0x18) = impureDataPtr;\n    }\n    result = __sfp();\n    *(undefined4 *)(dataPtr + 4) = result;\n    result = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 8) = result;\n    result = __sfp(dataPtr);\n    *(undefined4 *)(dataPtr + 0xc) = result;\n    std_isra_0(*(undefined4 *)(dataPtr + 4),4,0);\n    std_isra_0(*(undefined4 *)(dataPtr + 8),9,1);\n    std_isra_0(*(undefined4 *)(dataPtr + 0xc),0x12,2);\n    *(undefined4 *)(dataPtr + 0x18) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053a0": "initialize_data_080053a0",
                "param_1": "dataPtr",
                "uVar1": "result",
                "puVar2": "impureDataPtr"
            },
            "calling": [
                "__swbuf_r",
                "_vfiprintf_r",
                "iprintf",
                "_fflush_r",
                "__swsetup_r",
                "__sfp"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005400": {
            "entrypoint": "0x08005400",
            "current_name": "initialize_data_08005400",
            "code": "\nint * initializeData_08005400(undefined4 *ptr_init)\n\n{\n  int *currentDataPtr;\n  int *tempDataPtr;\n  int **dataListPtr;\n  \n  if (DAT_200000bc == 0) {\n    initData(&impure_data);\n  }\n  dataListPtr = (int **)&DAT_200000ec;\n  do {\n    tempDataPtr = dataListPtr[2];\n    currentDataPtr = dataListPtr[1];\n    while (currentDataPtr = (int *)((int)currentDataPtr + -1), -1 < (int)currentDataPtr) {\n      if (*(short *)(tempDataPtr + 3) == 0) {\n        *(undefined2 *)((int)tempDataPtr + 0xe) = 0xffff;\n        *(undefined2 *)(tempDataPtr + 3) = 1;\n        tempDataPtr[0x19] = 0;\n        *tempDataPtr = 0;\n        tempDataPtr[2] = 0;\n        tempDataPtr[1] = 0;\n        tempDataPtr[4] = 0;\n        tempDataPtr[5] = 0;\n        tempDataPtr[6] = 0;\n        clearMemory(tempDataPtr + 0x17,0,8);\n        tempDataPtr[0xd] = 0;\n        tempDataPtr[0xe] = 0;\n        tempDataPtr[0x12] = 0;\n        tempDataPtr[0x13] = 0;\n        return tempDataPtr;\n      }\n      tempDataPtr = tempDataPtr + 0x1a;\n    }\n    if (*dataListPtr == (int *)0x0) {\n      currentDataPtr = (int *)allocateMemory(ptr_init,4);\n      *dataListPtr = currentDataPtr;\n      if (currentDataPtr == (int *)0x0) {\n        *ptr_init = 0xc;\n        return (int *)0x0;\n      }\n    }\n    dataListPtr = (int **)*dataListPtr;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005400": "initialize_data_08005400",
                "param_1": "ptr_init",
                "piVar1": "currentDataPtr",
                "piVar2": "tempDataPtr",
                "ppiVar3": "dataListPtr",
                "__sinit": "initData",
                "memset": "clearMemory",
                "__sfmoreglue": "allocateMemory"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "__sfmoreglue",
                "__sinit",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005478": {
            "entrypoint": "0x08005478",
            "current_name": "process_data_08005478",
            "code": "\nuint processData_08005478(int baseAddress,code *callbackFunc,undefined4 param3,undefined4 param4)\n\n{\n  uint result;\n  int count;\n  int *ptr;\n  int dataAddress;\n  uint combinedResult;\n  int innerCount;\n  \n  combinedResult = 0;\n  for (ptr = (int *)(baseAddress + 0x48); ptr != (int *)0x0; ptr = (int *)*ptr) {\n    dataAddress = ptr[2];\n    innerCount = ptr[1];\n    while (innerCount = innerCount + -1, -1 < innerCount) {\n      if ((1 < *(ushort *)(dataAddress + 0xc)) && (count = *(short *)(dataAddress + 0xe) + 1, count != 0)) {\n        result = (*callbackFunc)(baseAddress,dataAddress,param3,count,param4);\n        combinedResult = combinedResult | result;\n      }\n      dataAddress = dataAddress + 0x68;\n    }\n  }\n  return combinedResult;\n}\n\n",
            "renaming": {
                "FUN_08005478": "process_data_08005478",
                "param_1": "baseAddress",
                "param_2": "callbackFunc",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result",
                "iVar2": "count",
                "piVar3": "ptr",
                "iVar4": "dataAddress",
                "uVar5": "combinedResult",
                "iVar6": "innerCount"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b4": {
            "entrypoint": "0x080054b4",
            "current_name": "check_file_permission_080054b4",
            "code": "\nundefined4 check_file_permission_080054b4(undefined4 file_descriptor,int file_info,undefined4 *permission_result,uint *is_executable)\n\n{\n  int fstat_result;\n  undefined4 permission_flag;\n  undefined stack_variable_1 [4];\n  uint file_mode;\n  \n  if ((*(short *)(file_info + 0xe) < 0) ||\n     (fstat_result = _fstat_r(file_descriptor,(int)*(short *)(file_info + 0xe),stack_variable_1), fstat_result < 0)) {\n    *is_executable = 0;\n    if ((int)((uint)*(ushort *)(file_info + 0xc) << 0x18) < 0) {\n      permission_flag = 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *is_executable = (uint)((file_mode & 0xf000) == 0x2000);\n  }\n  permission_flag = 0x400;\nLAB_080054f4:\n  *permission_result = permission_flag;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080054b4": "check_file_permission_080054b4",
                "param_1": "file_descriptor",
                "param_2": "file_info",
                "param_3": "permission_result",
                "param_4": "is_executable",
                "iVar1": "fstat_result",
                "uVar2": "permission_flag",
                "auStack_4c": "stack_variable_1",
                "local_48": "file_mode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054fc": {
            "entrypoint": "0x080054fc",
            "current_name": "process_buffer_080054fc",
            "code": "\nvoid process_buffer_080054fc(int buffer_size,int *buffer_ptr)\n\n{\n  ushort result;\n  int allocated_memory;\n  int local_buffer_size;\n  int *local_buffer_ptr;\n  \n  if (-1 < (int)((uint)*(ushort *)(buffer_ptr + 3) << 0x1e)) {\n    local_buffer_size = buffer_size;\n    local_buffer_ptr = buffer_ptr;\n    result = __swhatbuf_r(buffer_size,buffer_ptr,&local_buffer_size,&local_buffer_ptr);\n    allocated_memory = _malloc_r(buffer_size,local_buffer_size);\n    if (allocated_memory != 0) {\n      *(undefined4 *)(buffer_size + 0x28) = 0x8005321;\n      *buffer_ptr = allocated_memory;\n      *(ushort *)(buffer_ptr + 3) = *(ushort *)(buffer_ptr + 3) | 0x80;\n      buffer_ptr[5] = local_buffer_size;\n      buffer_ptr[4] = allocated_memory;\n      if ((local_buffer_ptr != (int *)0x0) &&\n         (allocated_memory = _isatty_r(buffer_size,(int)*(short *)((int)buffer_ptr + 0xe)), allocated_memory != 0)) {\n        *(ushort *)(buffer_ptr + 3) = *(ushort *)(buffer_ptr + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(buffer_ptr + 3) = result | *(ushort *)(buffer_ptr + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(buffer_ptr + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(buffer_ptr + 3) = *(ushort *)(buffer_ptr + 3) & 0xfffc | 2;\n  }\n  *buffer_ptr = (int)buffer_ptr + 0x47;\n  buffer_ptr[4] = (int)buffer_ptr + 0x47;\n  buffer_ptr[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080054fc": "process_buffer_080054fc",
                "param_1": "buffer_size",
                "param_2": "buffer_ptr",
                "uVar1": "result",
                "iVar2": "allocated_memory",
                "local_18": "local_buffer_size",
                "local_14": "local_buffer_ptr"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "__swhatbuf_r",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800557c": {
            "entrypoint": "0x0800557c",
            "current_name": "FUNC_0800557c",
            "code": "\nvoid FUNC_0800557c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557c": "FUNC_0800557c"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800557e": {
            "entrypoint": "0x0800557e",
            "current_name": "FUNC_0800557e",
            "code": "\nvoid FUNC_0800557e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800557e": "FUNC_0800557e"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005580": {
            "entrypoint": "0x08005580",
            "current_name": "execute_process_08005580",
            "code": "\nundefined4 executeProcess_08005580(undefined4 *output_status,uint process_id,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t pid;\n  undefined4 result;\n  int process_list;\n  code *process_code;\n  \n  if (0x1f < process_id) {\n    *output_status = 0x16;\n    return 0xffffffff;\n  }\n  process_list = output_status[0x11];\n  if ((process_list != 0) && (process_code = *(code **)(process_list + process_id * 4), process_code != (code *)0x0)) {\n    if (process_code != (code *)0x1) {\n      if (process_code == (code *)0xffffffff) {\n        *output_status = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(process_list + process_id * 4) = 0;\n      (*process_code)(process_id);\n    }\n    return 0;\n  }\n  pid = _getpid_r();\n  result = _kill_r(output_status,pid,process_id,param_4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005580": "execute_process_08005580",
                "param_1": "output_status",
                "param_2": "process_id",
                "_Var1": "pid",
                "uVar2": "result",
                "iVar3": "process_list",
                "pcVar4": "process_code"
            },
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid_r",
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055d0": {
            "entrypoint": "0x080055d0",
            "current_name": "handle_signal_080055d0",
            "code": "\nint handle_signal_080055d0(int signal)\n\n{\n  int result;\n  \n  result = _raise_r(_impure_ptr,signal);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080055d0": "handle_signal_080055d0",
                "__sig": "signal",
                "iVar1": "result"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_raise_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "kill_process_080055e0",
            "code": "\nvoid kill_process_080055e0(int *error_code_ptr,__pid_t pid,int signal)\n\n{\n  int kill_result;\n  \n  errno = 0;\n  kill_result = _kill(pid,signal);\n  if ((kill_result == -1) && (errno != 0)) {\n    *error_code_ptr = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "kill_process_080055e0",
                "param_1": "error_code_ptr",
                "param_2": "pid",
                "param_3": "signal",
                "iVar1": "kill_result"
            },
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "FUN_08005604",
            "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "_raise_r"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005608": {
            "entrypoint": "0x08005608",
            "current_name": "update_data_08005608",
            "code": "\nvoid updateData_08005608(undefined4 fileDescriptor,int dataPtr)\n\n{\n  int bytesRead;\n  uint updatedValue;\n  bool isPositiveRead;\n  \n  bytesRead = _read_r(fileDescriptor,(int)*(short *)(dataPtr + 0xe));\n  isPositiveRead = -1 < bytesRead;\n  if (isPositiveRead) {\n    updatedValue = *(int *)(dataPtr + 0x54) + bytesRead;\n  }\n  else {\n    updatedValue = *(ushort *)(dataPtr + 0xc) & 0xffffefff;\n  }\n  if (isPositiveRead) {\n    *(uint *)(dataPtr + 0x54) = updatedValue;\n  }\n  if (!isPositiveRead) {\n    *(short *)(dataPtr + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005608": "update_data_08005608",
                "param_1": "fileDescriptor",
                "param_2": "dataPtr",
                "iVar1": "bytesRead",
                "uVar2": "updatedValue",
                "bVar3": "isPositiveRead"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800562a": {
            "entrypoint": "0x0800562a",
            "current_name": "write_to_file_0800562a",
            "code": "\nvoid writeToFile_0800562a(undefined4 fileDescriptor,int bufferPointer,undefined4 dataPointer,undefined4 dataSize)\n\n{\n  if ((int)((uint)*(unsignedShort *)(bufferPointer + 0xc) << 0x17) < 0) {\n    repositionFilePointer(fileDescriptor,(int)*(short *)(bufferPointer + 0xe),0,2);\n  }\n  *(unsignedShort *)(bufferPointer + 0xc) = *(unsignedShort *)(bufferPointer + 0xc) & 0xefff;\n  writeToBuffer(fileDescriptor,(int)*(short *)(bufferPointer + 0xe),dataPointer,dataSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800562a": "write_to_file_0800562a",
                "param_1": "fileDescriptor",
                "param_2": "bufferPointer",
                "param_3": "dataPointer",
                "param_4": "dataSize",
                "ushort": "unsignedShort",
                "_lseek_r": "repositionFilePointer",
                "_write_r": "writeToBuffer"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005662": {
            "entrypoint": "0x08005662",
            "current_name": "process_file_08005662",
            "code": "\nvoid processFile_08005662(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  int seekResult;\n  ushort updatedFlags;\n  bool isSeekError;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  isSeekError = seekResult == -1;\n  if (isSeekError) {\n    updatedFlags = *(ushort *)(bufferAddress + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(bufferAddress + 0x54) = seekResult;\n    updatedFlags = *(ushort *)(bufferAddress + 0xc) | 0x1000;\n  }\n  if (isSeekError) {\n    *(ushort *)(bufferAddress + 0xc) = updatedFlags;\n  }\n  if (!isSeekError) {\n    *(ushort *)(bufferAddress + 0xc) = updatedFlags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005662": "process_file_08005662",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "iVar1": "seekResult",
                "uVar2": "updatedFlags",
                "bVar3": "isSeekError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005686": {
            "entrypoint": "0x08005686",
            "current_name": "close_file_descriptor_08005686",
            "code": "\nvoid closeFileDescriptor_08005686(undefined4 fileDescriptor,int pointerToData)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(pointerToData + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005686": "close_file_descriptor_08005686",
                "param_1": "fileDescriptor",
                "param_2": "pointerToData"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005690": {
            "entrypoint": "0x08005690",
            "current_name": "write_to_stream_08005690",
            "code": "\nvoid writeToStream_08005690(int *error,int stream,char *data,int size)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(stream,data,size);\n  if ((writeResult == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005690": "write_to_stream_08005690",
                "param_1": "error",
                "param_2": "stream",
                "param_3": "data",
                "param_4": "size",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056b4": {
            "entrypoint": "0x080056b4",
            "current_name": "close_file_with_error_handling_080056b4",
            "code": "\nvoid closeFileWithErrorHandling_080056b4(int *error,int fileDescriptor)\n\n{\n  int result;\n  \n  errno = 0;\n  result = _close(fileDescriptor);\n  if ((result == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056b4": "close_file_with_error_handling_080056b4",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "iVar1": "result"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "get_file_status_080056d4",
            "code": "\nvoid get_file_status_080056d4(int *error_code,int file_descriptor,stat *file_status)\n\n{\n  int status_code;\n  \n  error_number = 0;\n  status_code = _fstat(file_descriptor,file_status);\n  if ((status_code == -1) && (error_number != 0)) {\n    *error_code = error_number;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056d4": "get_file_status_080056d4",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_status",
                "errno": "error_number",
                "iVar1": "status_code"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "check_terminal_status_080056f8",
            "code": "\nvoid checkTerminalStatus_080056f8(int *errorFlag,int fileDescriptor)\n\n{\n  int isTerminal;\n  \n  errorNumber = 0;\n  isTerminal = _isatty(fileDescriptor);\n  if ((isTerminal == -1) && (errorNumber != 0)) {\n    *errorFlag = errorNumber;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "check_terminal_status_080056f8",
                "param_1": "errorFlag",
                "param_2": "fileDescriptor",
                "iVar1": "isTerminal",
                "errno": "errorNumber"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005718": {
            "entrypoint": "0x08005718",
            "current_name": "file_seek_08005718",
            "code": "\nvoid file_seek_08005718(int *error_code,int file_descriptor,__off_t offset,int whence)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(file_descriptor,offset,whence);\n  if ((result == -1) && (errno != 0)) {\n    *error_code = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005718": "file_seek_08005718",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "read_file_0800573c",
            "code": "\nvoid readFile_0800573c(int *error,int fileDescriptor,char *buffer,int size)\n\n{\n  int readResult;\n  \n  errno = 0;\n  readResult = _read(fileDescriptor,buffer,size);\n  if ((readResult == -1) && (errno != 0)) {\n    *error = errno;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800573c": "read_file_0800573c",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "size",
                "iVar1": "readResult"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005760": {
            "entrypoint": "0x08005760",
            "current_name": "abort_bad_function_call_08005760",
            "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::abort_bad_function_call_08005760(void)\n\n{\n                    \n  abort();\n}\n\n",
            "renaming": {
                "FUN_08005760": "abort_bad_function_call_08005760"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005768": {
            "entrypoint": "0x08005768",
            "current_name": "initialize_locale_info_08005768",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeLocaleInfo_08005768(void)\n\n{\n  if (-1 < moneypunct<char,false>::id << 0x1f) {\n    moneypunct<char,false>::id = 1;\n  }\n  if (-1 < moneypunct<char,true>::id << 0x1f) {\n    moneypunct<char,true>::id = 1;\n  }\n  if (-1 < money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < numpunct<char>::id << 0x1f) {\n    numpunct<char>::id = 1;\n  }\n  if (-1 < num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    num_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __timepunct<char>::id << 0x1f) {\n    __timepunct<char>::id = 1;\n  }\n  if (-1 < time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f) {\n    time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < messages<char>::id << 0x1f) {\n    messages<char>::id = 1;\n  }\n  if (-1 < collate<char>::id << 0x1f) {\n    collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005768": "initialize_locale_info_08005768"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800582c": {
            "entrypoint": "0x0800582c",
            "current_name": "initialize_system_wide_locale_settings_0800582c",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeSystemWideLocaleSettings_0800582c(void)\n\n{\n  if (-1 < moneypunct<wchar_t,false>::id << 0x1f) {\n    moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < moneypunct<wchar_t,true>::id << 0x1f) {\n    moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id <<\n           0x1f) {\n    money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < numpunct<wchar_t>::id << 0x1f) {\n    numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f)\n  {\n    num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __timepunct<wchar_t>::id << 0x1f) {\n    __timepunct<wchar_t>::id = 1;\n  }\n  if (-1 < time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id << 0x1f\n     ) {\n    time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < messages<wchar_t>::id << 0x1f) {\n    messages<wchar_t>::id = 1;\n  }\n  if (-1 < collate<wchar_t>::id << 0x1f) {\n    collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800582c": "initialize_system_wide_locale_settings_0800582c"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058f0": {
            "entrypoint": "0x080058f0",
            "current_name": "initialize_locale_080058f0",
            "code": "\n/* std::ctype_byname<wchar_t>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<wchar_t>::initializeLocale_080058f0(void)\n\n{\n  if (-1 < __cxx11::moneypunct<wchar_t,false>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<wchar_t,true>::id << 0x1f) {\n    __cxx11::moneypunct<wchar_t,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::money_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<wchar_t>::id << 0x1f) {\n    __cxx11::numpunct<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::\n           id << 0x1f) {\n    __cxx11::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<wchar_t>::id << 0x1f) {\n    __cxx11::messages<wchar_t>::id = 1;\n  }\n  if (-1 < __cxx11::collate<wchar_t>::id << 0x1f) {\n    __cxx11::collate<wchar_t>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058f0": "initialize_locale_080058f0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005974": {
            "entrypoint": "0x08005974",
            "current_name": "initialize_c_type_08005974",
            "code": "\n/* std::ctype_byname<char>::ctype_byname(std::__cxx11::basic_string<char, std::char_traits<char>,\n   std::allocator<char> > const&, unsigned int) */\n\nvoid std::ctype_byname<char>::initializeCType_08005974(void)\n\n{\n  if (-1 < __cxx11::moneypunct<char,false>::id << 0x1f) {\n    __cxx11::moneypunct<char,false>::id = 1;\n  }\n  if (-1 < __cxx11::moneypunct<char,true>::id << 0x1f) {\n    __cxx11::moneypunct<char,true>::id = 1;\n  }\n  if (-1 < __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id <<\n           0x1f) {\n    __cxx11::money_put<char,std::ostreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::numpunct<char>::id << 0x1f) {\n    __cxx11::numpunct<char>::id = 1;\n  }\n  if (-1 < __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id << 0x1f\n     ) {\n    __cxx11::time_get<char,std::istreambuf_iterator<char,std::char_traits<char>>>::id = 1;\n  }\n  if (-1 < __cxx11::messages<char>::id << 0x1f) {\n    __cxx11::messages<char>::id = 1;\n  }\n  if (-1 < __cxx11::collate<char>::id << 0x1f) {\n    __cxx11::collate<char>::id = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005974": "initialize_c_type_08005974"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f8": {
            "entrypoint": "0x080059f8",
            "current_name": "FUNC_080059f8",
            "code": "\nvoid FUNC_080059f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080059f8": "FUNC_080059f8"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a04": {
            "entrypoint": "0x08005a04",
            "current_name": "FUNC_08005a04",
            "code": "\nvoid FUNC_08005a04(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a04": "FUNC_08005a04"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 141695,
    "layers": [
        [
            "FUN_080001ac",
            "FUN_08000218",
            "FUN_08000230",
            "FUN_080002d0",
            "FUN_08000300",
            "FUN_080005e0",
            "FUN_080005e4",
            "FUN_08000600",
            "FUN_0800066c",
            "FUN_08000682",
            "FUN_08000690",
            "FUN_080006b4",
            "FUN_08000728",
            "FUN_0800076c",
            "FUN_080007f0",
            "FUN_080008cc",
            "FUN_080008e2",
            "FUN_08000998",
            "FUN_08000a00",
            "FUN_08000a4e",
            "FUN_08000a7a",
            "FUN_08000b04",
            "FUN_08000b54",
            "FUN_08000c4c",
            "FUN_08000c64",
            "FUN_08000c7c",
            "FUN_08000c8c",
            "FUN_08000d3c",
            "FUN_08000d8c",
            "FUN_08000d8e",
            "FUN_08000d98",
            "FUN_08000de4",
            "FUN_08000e18",
            "FUN_08000e30",
            "FUN_08000e3c",
            "FUN_08000e60",
            "FUN_08000ec4",
            "FUN_08000ee0",
            "FUN_08000f0c",
            "FUN_08000f2c",
            "FUN_08000f4e",
            "FUN_08000f56",
            "FUN_08000f72",
            "FUN_08000f8c",
            "FUN_08000fb4",
            "FUN_08001198",
            "FUN_080011a4",
            "FUN_080011c0",
            "FUN_0800124a",
            "FUN_08001256",
            "FUN_08001420",
            "FUN_08001440",
            "FUN_08001460",
            "FUN_080014ec",
            "FUN_08001578",
            "FUN_080015bc",
            "FUN_0800160e",
            "FUN_0800165a",
            "FUN_08001684",
            "FUN_0800171a",
            "FUN_08001864",
            "FUN_08001904",
            "FUN_080019a0",
            "FUN_08001ab0",
            "FUN_08001bfc",
            "FUN_08001d00",
            "FUN_08001e68",
            "FUN_08001f3c",
            "FUN_08001f9c",
            "FUN_0800201c",
            "FUN_080023b4",
            "FUN_08002488",
            "FUN_080025e0",
            "FUN_080025ec",
            "FUN_0800260c",
            "FUN_0800262c",
            "FUN_0800268e",
            "FUN_080026ce",
            "FUN_08002848",
            "FUN_08002864",
            "FUN_080028d4",
            "FUN_080028f0",
            "FUN_08002940",
            "FUN_0800295c",
            "FUN_080029c8",
            "FUN_08002d0c",
            "FUN_08002d72",
            "FUN_08002dd0",
            "FUN_08002eb2",
            "FUN_08002efa",
            "FUN_08002f4c",
            "FUN_08002f66",
            "FUN_08002ffc",
            "FUN_0800311c",
            "FUN_0800312c",
            "FUN_08003138",
            "FUN_0800314e",
            "FUN_0800316c",
            "FUN_0800318c",
            "FUN_080031fc",
            "FUN_08003380",
            "FUN_0800339c",
            "FUN_080033c8",
            "FUN_080033d8",
            "FUN_0800340c",
            "FUN_08003414",
            "FUN_0800346c",
            "FUN_08003476",
            "FUN_08003486",
            "FUN_080034b6",
            "FUN_080034ce",
            "FUN_080034da",
            "FUN_080034f4",
            "FUN_08003506",
            "FUN_0800351e",
            "FUN_0800352e",
            "FUN_0800354a",
            "FUN_0800355e",
            "FUN_08003582",
            "FUN_08003594",
            "FUN_080035ac",
            "FUN_080035bc",
            "FUN_080035fc",
            "FUN_08003750",
            "FUN_08003754",
            "FUN_0800376e",
            "FUN_0800377c",
            "FUN_08003798",
            "FUN_080037ac",
            "FUN_080037c0",
            "FUN_080037d4",
            "FUN_080037e8",
            "FUN_080037fc",
            "FUN_08003810",
            "FUN_0800382c",
            "FUN_08003840",
            "FUN_08003854",
            "FUN_08003868",
            "FUN_0800387c",
            "FUN_08003880",
            "FUN_080038d0",
            "FUN_08003900",
            "FUN_08003918",
            "FUN_08003928",
            "FUN_08003938",
            "FUN_08003948",
            "FUN_08003958",
            "FUN_08003968",
            "FUN_08003978",
            "FUN_08003cc8",
            "FUN_08003d18",
            "FUN_08003dd0",
            "FUN_08003df4",
            "FUN_08003e18",
            "FUN_08003e54",
            "FUN_08003eac",
            "FUN_08003f00",
            "FUN_08003f24",
            "FUN_08003f48",
            "FUN_08003f94",
            "FUN_08003fd4",
            "FUN_08003fec",
            "FUN_08004004",
            "FUN_0800401c",
            "FUN_08004034",
            "FUN_0800404c",
            "FUN_08004064",
            "FUN_0800407c",
            "FUN_08004094",
            "FUN_080040d0",
            "FUN_080040d6",
            "FUN_080040e0",
            "FUN_080040e4",
            "FUN_080040e8",
            "FUN_080040ec",
            "FUN_080040f8",
            "FUN_080040fc",
            "FUN_0800410c",
            "FUN_08004110",
            "FUN_080041bc",
            "FUN_08004204",
            "FUN_0800420c",
            "FUN_08004240",
            "FUN_08004254",
            "FUN_08004270",
            "FUN_08004298",
            "FUN_080042ac",
            "FUN_080042e8",
            "FUN_08004364",
            "FUN_08004388",
            "FUN_08004444",
            "FUN_08004460",
            "FUN_0800447c",
            "FUN_080044d8",
            "FUN_080044fc",
            "FUN_0800450a",
            "FUN_08004544",
            "FUN_08004560",
            "FUN_0800458c",
            "FUN_0800459a",
            "FUN_080045be",
            "FUN_080045c8",
            "FUN_08004622",
            "FUN_08004638",
            "FUN_08004640",
            "FUN_08004648",
            "FUN_08004658",
            "FUN_08004678",
            "FUN_0800468c",
            "FUN_080046b4",
            "FUN_08004760",
            "FUN_0800476a",
            "FUN_08004774",
            "FUN_0800477e",
            "FUN_08004788",
            "FUN_08004792",
            "FUN_080047a8",
            "FUN_080047c0",
            "FUN_080047d0",
            "FUN_080047f0",
            "FUN_080047fe",
            "FUN_08004808",
            "FUN_08004844",
            "FUN_08004860",
            "FUN_08004884",
            "FUN_080048cc",
            "FUN_080048dc",
            "FUN_08004978",
            "FUN_08004a34",
            "FUN_08004a60",
            "FUN_08004a84",
            "FUN_08004cb0",
            "FUN_08004d9c",
            "FUN_08004fdc",
            "FUN_0800500c",
            "FUN_0800502c",
            "FUN_080050d0",
            "FUN_080051ac",
            "FUN_080051bc",
            "FUN_080052cc",
            "FUN_08005320",
            "FUN_0800532c",
            "FUN_08005374",
            "FUN_080053a0",
            "FUN_08005400",
            "FUN_08005478",
            "FUN_080054b4",
            "FUN_080054fc",
            "FUN_08005580",
            "FUN_080055d0",
            "FUN_080055e0",
            "FUN_08005608",
            "FUN_0800562a",
            "FUN_08005662",
            "FUN_08005686",
            "FUN_08005690",
            "FUN_080056b4",
            "FUN_080056d4",
            "FUN_080056f8",
            "FUN_08005718",
            "FUN_0800573c",
            "FUN_08005760",
            "FUN_08005768",
            "FUN_0800582c",
            "FUN_080058f0",
            "FUN_08005974"
        ]
    ],
    "locked_functions": []
}