{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_completed_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeCompletedFlag_08000110(undefined4 input)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_completed_flag_08000110",
                "param_1": "input",
                "completed_8655": "completionFlag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_uint32_to_uint64_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_uint32_to_uint64_08000134(undefined4 lower_32_bits,undefined4 upper_32_bits)\n\n{\n  return CONCAT44(upper_32_bits,lower_32_bits);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_uint32_to_uint64_08000134",
                "param_1": "lower_32_bits",
                "param_2": "upper_32_bits"
            },
            "calling": [
                "__libc_init_array",
                "__libc_fini_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000150": {
            "entrypoint": "0x08000150",
            "current_name": "add_unsigned_with_xor_08000150",
            "code": "\nvoid addUnsignedWithXor_08000150(undefined4 result,uint value)\n\n{\n  addition(result,value ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000150": "add_unsigned_with_xor_08000150",
                "param_1": "result",
                "param_2": "value",
                "__aeabi_dadd": "addition"
            },
            "calling": [],
            "called": [
                "__aeabi_dadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "calculate_result_08000158",
            "code": "\nulonglong calculateResult_08000158(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int bitShift1;\n  byte carryBit;\n  uint sum1;\n  uint tempVar1;\n  uint sum2;\n  uint tempVar2;\n  uint tempVar3;\n  int bitShift2;\n  uint result1;\n  uint tempVar4;\n  uint result2;\n  uint carryBit2;\n  bool isEqual;\n  bool check;\n  bool isNegative;\n  \n  tempVar2 = input4 ^ 0x80000000;\n  result1 = input2 << 1;\n  input4 = input4 << 1;\n  isEqual = ((input2 ^ tempVar2) & 0x7fffffff) == 0;\n  check = isEqual && input1 == input3;\n  if (!isEqual || input1 != input3) {\n    check = (result1 | input1) == 0;\n  }\n  if (!check) {\n    check = (input4 | input3) == 0;\n  }\n  bitShift2 = (int)result1 >> 0x15;\n  if (!check) {\n    check = bitShift2 == -1;\n  }\n  bitShift1 = (int)input4 >> 0x15;\n  if (!check) {\n    check = bitShift1 == -1;\n  }\n  if (check) {\n    if (bitShift2 == -1 || bitShift1 == -1) {\n      result1 = tempVar2;\n      result2 = input3;\n      if (bitShift2 == -1) {\n        result1 = input2;\n        result2 = input1;\n      }\n      if (bitShift2 != -1 || bitShift1 != -1) {\n        input3 = result2;\n        tempVar2 = result1;\n      }\n      check = (result2 | result1 << 0xc) == 0;\n      if (check) {\n        check = (input3 | tempVar2 << 0xc) == 0;\n      }\n      if (check) {\n        check = result1 == tempVar2;\n      }\n      if (!check) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,result2);\n    }\n    if (((input2 ^ tempVar2) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((result1 | input1) == 0) {\n        input1 = input3;\n        input2 = tempVar2;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != tempVar2) {\n      return 0;\n    }\n    if (result1 >> 0x15 == 0) {\n      check = (input1 & 0x80000000) != 0;\n      tempVar2 = input2 * 2 + (uint)check;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)check)) {\n        tempVar2 = tempVar2 | 0x80000000;\n      }\n      return CONCAT44(tempVar2,input1 << 1);\n    }\n    if (result1 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  result1 = result1 >> 0x15;\n  input4 = input4 >> 0x15;\n  result2 = input4 - result1;\n  check = result2 != 0;\n  if (input4 < result1) {\n    result2 = -result2;\n  }\n  tempVar4 = input1;\n  tempVar3 = input2;\n  if (check && result1 <= input4) {\n    result1 = result1 + result2;\n    tempVar4 = input3;\n    tempVar3 = tempVar2;\n    input3 = input1;\n    tempVar2 = input2;\n  }\n  if (0x36 < result2) {\n    return CONCAT44(tempVar3,tempVar4);\n  }\n  tempVar1 = tempVar3 & 0xfffff | 0x100000;\n  if ((tempVar3 & 0x80000000) != 0) {\n    check = tempVar4 != 0;\n    tempVar4 = -tempVar4;\n    tempVar1 = -tempVar1 - (uint)check;\n  }\n  tempVar3 = tempVar2 & 0xfffff | 0x100000;\n  if ((tempVar2 & 0x80000000) != 0) {\n    check = input3 != 0;\n    input3 = -input3;\n    tempVar3 = -tempVar3 - (uint)check;\n  }\n  if (result1 == result2) {\n    tempVar3 = tempVar3 ^ 0x100000;\n    if (result1 == 0) {\n      tempVar1 = tempVar1 ^ 0x100000;\n      result1 = 1;\n    }\n    else {\n      result2 = result2 - 1;\n    }\n  }\n  tempVar2 = -result2 + 0x20;\n  if ((int)result2 < 0x21) {\n    carryBit2 = input3 << (tempVar2 & 0xff);\n    input3 = input3 >> (result2 & 0xff);\n    sum1 = tempVar4 + input3;\n    sum2 = tempVar3 << (tempVar2 & 0xff);\n    tempVar2 = sum1 + sum2;\n    tempVar1 = tempVar1 + CARRY4(tempVar4,input3) + ((int)tempVar3 >> (result2 & 0xff)) +\n            (uint)CARRY4(sum1,sum2);\n  }\n  else {\n    carryBit2 = tempVar3 << (-result2 + 0x40 & 0xff);\n    if (input3 != 0) {\n      carryBit2 = carryBit2 | 2;\n    }\n    tempVar3 = (int)tempVar3 >> (result2 - 0x20 & 0xff);\n    tempVar2 = tempVar4 + tempVar3;\n    tempVar1 = tempVar1 + ((int)tempVar3 >> 0x1f) + (uint)CARRY4(tempVar4,tempVar3);\n  }\n  input2 = tempVar1 & 0x80000000;\n  result2 = tempVar1;\n  if ((int)tempVar1 < 0) {\n    check = carryBit2 == 0;\n    carryBit2 = -carryBit2;\n    result2 = -tempVar2;\n    tempVar2 = -(uint)!check - tempVar2;\n    result2 = -(uint)(check <= result2) - tempVar1;\n  }\n  if (0xfffff < result2) {\n    tempVar4 = result1 - 1;\n    if (0x1fffff < result2) {\n      tempVar4 = result2 & 1;\n      result2 = result2 >> 1;\n      carryBit = (byte)tempVar2;\n      tempVar2 = (uint)(tempVar4 != 0) << 0x1f | tempVar2 >> 1;\n      carryBit2 = (uint)(carryBit & 1) << 0x1f | carryBit2 >> 1;\n      tempVar4 = result1;\n      if (0xffbfffff < result1 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    check = 0x7fffffff < carryBit2;\n    if (carryBit2 == 0x80000000) {\n      check = (tempVar2 & 1) != 0;\n    }\n    return CONCAT44(result2 + tempVar4 * 0x100000 + (uint)CARRY4(tempVar2,(uint)check) | input2,\n                    tempVar2 + check);\n  }\n  isEqual = (carryBit2 & 0x80000000) != 0;\n  carryBit2 = carryBit2 << 1;\n  tempVar4 = tempVar2 * 2;\n  check = CARRY4(tempVar2,tempVar2);\n  tempVar2 = tempVar2 * 2 + (uint)isEqual;\n  result2 = result2 * 2 + (uint)(check || CARRY4(tempVar4,(uint)isEqual));\n  tempVar4 = result1 - 2;\n  if ((result2 & 0x100000) != 0) goto LAB_08000268;\n  tempVar3 = tempVar2;\n  result1 = result2;\n  if (result2 == 0) {\n    tempVar3 = 0;\n    result1 = tempVar2;\n  }\n  bitShift2 = LZCOUNT(result1);\n  if (result2 == 0) {\n    bitShift2 = bitShift2 + 0x20;\n  }\n  result2 = bitShift2 - 0xb;\n  isNegative = SBORROW4(result2,0x20);\n  tempVar2 = bitShift2 - 0x2b;\n  check = (int)tempVar2 < 0;\n  isEqual = tempVar2 == 0;\n  if ((int)result2 < 0x20) {\n    isNegative = SCARRY4(tempVar2,0xc);\n    bitShift2 = bitShift2 + -0x1f;\n    check = bitShift2 < 0;\n    isEqual = bitShift2 == 0;\n    tempVar2 = result2;\n    if (!isEqual && check == isNegative) {\n      tempVar3 = result1 << (result2 & 0xff);\n      result1 = result1 >> (0xcU - bitShift2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isEqual || check != isNegative) {\n    carryBit2 = 0x20 - tempVar2;\n  }\n  result1 = result1 << (tempVar2 & 0xff);\n  if (isEqual || check != isNegative) {\n    result1 = result1 | tempVar3 >> (carryBit2 & 0xff);\n  }\n  if (isEqual || check != isNegative) {\n    tempVar3 = tempVar3 << (tempVar2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result2 <= (int)tempVar4) {\n    return CONCAT44(result1 + (tempVar4 - result2) * 0x100000 | input2,tempVar3);\n  }\n  tempVar2 = ~(tempVar4 - result2);\n  if ((int)tempVar2 < 0x1f) {\n    bitShift2 = tempVar2 - 0x13;\n    if (bitShift2 != 0 && bitShift2 < 0 == SCARRY4(tempVar2 - 0x1f,0xc)) {\n      return CONCAT44(tempVar1,tempVar3 >> (0x20 - (0xcU - bitShift2) & 0xff) | result1 << (0xcU - bitShift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    tempVar2 = tempVar2 + 1;\n    return CONCAT44(input2 | result1 >> (tempVar2 & 0xff),\n                    tempVar3 >> (tempVar2 & 0xff) | result1 << (0x20 - tempVar2 & 0xff));\n  }\n  return CONCAT44(tempVar1,result1 >> (tempVar2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "calculate_result_08000158",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "bitShift1",
                "bVar2": "carryBit",
                "uVar3": "sum1",
                "uVar4": "tempVar1",
                "uVar5": "sum2",
                "uVar6": "tempVar2",
                "uVar7": "tempVar3",
                "iVar8": "bitShift2",
                "uVar9": "result1",
                "uVar10": "tempVar4",
                "uVar11": "result2",
                "uVar12": "carryBit2",
                "bVar13": "isEqual",
                "bVar14": "check",
                "bVar15": "isNegative"
            },
            "calling": [
                "_svfprintf_r",
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_sum_0800015c",
            "code": "\nulonglong calculateSum_0800015c(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shiftedInput2;\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shiftedInput4;\n  uint shiftedInput2;\n  uint shiftedInput4;\n  uint result1;\n  uint result2;\n  uint temp4;\n  uint temp5;\n  bool isEqual;\n  bool isZero;\n  bool isNegative;\n  \n  shiftedInput2 = input2 << 1;\n  result1 = input4 << 1;\n  isEqual = ((input2 ^ input4) & 0x7fffffff) == 0;\n  isZero = isEqual && input1 == input3;\n  if (!isEqual || input1 != input3) {\n    isZero = (shiftedInput2 | input1) == 0;\n  }\n  if (!isZero) {\n    isZero = (result1 | input3) == 0;\n  }\n  shiftedInput4 = (int)shiftedInput2 >> 0x15;\n  if (!isZero) {\n    isZero = shiftedInput4 == -1;\n  }\n  shiftedInput2 = (int)result1 >> 0x15;\n  if (!isZero) {\n    isZero = shiftedInput2 == -1;\n  }\n  if (isZero) {\n    if (shiftedInput4 == -1 || shiftedInput2 == -1) {\n      result1 = input4;\n      shiftedInput2 = input3;\n      if (shiftedInput4 == -1) {\n        result1 = input2;\n        shiftedInput2 = input1;\n      }\n      if (shiftedInput4 != -1 || shiftedInput2 != -1) {\n        input3 = shiftedInput2;\n        input4 = result1;\n      }\n      isZero = (shiftedInput2 | result1 << 0xc) == 0;\n      if (isZero) {\n        isZero = (input3 | input4 << 0xc) == 0;\n      }\n      if (isZero) {\n        isZero = result1 == input4;\n      }\n      if (!isZero) {\n        result1 = result1 | 0x80000;\n      }\n      return CONCAT44(result1,shiftedInput2);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((shiftedInput2 | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (shiftedInput2 >> 0x15 == 0) {\n      isZero = (input1 & 0x80000000) != 0;\n      result1 = input2 * 2 + (uint)isZero;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)isZero)) {\n        result1 = result1 | 0x80000000;\n      }\n      return CONCAT44(result1,input1 << 1);\n    }\n    if (shiftedInput2 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  shiftedInput2 = shiftedInput2 >> 0x15;\n  result1 = result1 >> 0x15;\n  result2 = result1 - shiftedInput2;\n  isZero = result2 != 0;\n  if (result1 < shiftedInput2) {\n    result2 = -result2;\n  }\n  shiftedInput4 = input1;\n  temp3 = input2;\n  if (isZero && shiftedInput2 <= result1) {\n    shiftedInput2 = shiftedInput2 + result2;\n    shiftedInput4 = input3;\n    temp3 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < result2) {\n    return CONCAT44(temp3,shiftedInput4);\n  }\n  result1 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    isZero = shiftedInput4 != 0;\n    shiftedInput4 = -shiftedInput4;\n    result1 = -result1 - (uint)isZero;\n  }\n  temp3 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    isZero = input3 != 0;\n    input3 = -input3;\n    temp3 = -temp3 - (uint)isZero;\n  }\n  if (shiftedInput2 == result2) {\n    temp3 = temp3 ^ 0x100000;\n    if (shiftedInput2 == 0) {\n      result1 = result1 ^ 0x100000;\n      shiftedInput2 = 1;\n    }\n    else {\n      result2 = result2 - 1;\n    }\n  }\n  temp5 = -result2 + 0x20;\n  if ((int)result2 < 0x21) {\n    temp4 = input3 << (temp5 & 0xff);\n    input3 = input3 >> (result2 & 0xff);\n    temp1 = shiftedInput4 + input3;\n    temp2 = temp3 << (temp5 & 0xff);\n    temp5 = temp1 + temp2;\n    result1 = result1 + CARRY4(shiftedInput4,input3) + ((int)temp3 >> (result2 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    temp4 = temp3 << (-result2 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp4 = temp4 | 2;\n    }\n    temp3 = (int)temp3 >> (result2 - 0x20 & 0xff);\n    temp5 = shiftedInput4 + temp3;\n    result1 = result1 + ((int)temp3 >> 0x1f) + (uint)CARRY4(shiftedInput4,temp3);\n  }\n  input2 = result1 & 0x80000000;\n  result2 = result1;\n  if ((int)result1 < 0) {\n    isZero = temp4 == 0;\n    temp4 = -temp4;\n    result2 = -temp5;\n    temp5 = -(uint)!isZero - temp5;\n    result2 = -(uint)(isZero <= result2) - result1;\n  }\n  if (0xfffff < result2) {\n    shiftedInput4 = shiftedInput2 - 1;\n    if (0x1fffff < result2) {\n      result1 = result2 & 1;\n      result2 = result2 >> 1;\n      carry = (byte)temp5;\n      temp5 = (uint)(result1 != 0) << 0x1f | temp5 >> 1;\n      temp4 = (uint)(carry & 1) << 0x1f | temp4 >> 1;\n      shiftedInput4 = shiftedInput2;\n      if (0xffbfffff < shiftedInput2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    isZero = 0x7fffffff < temp4;\n    if (temp4 == 0x80000000) {\n      isZero = (temp5 & 1) != 0;\n    }\n    return CONCAT44(result2 + shiftedInput4 * 0x100000 + (uint)CARRY4(temp5,(uint)isZero) | input2,\n                    temp5 + isZero);\n  }\n  isEqual = (temp4 & 0x80000000) != 0;\n  temp4 = temp4 << 1;\n  shiftedInput4 = temp5 * 2;\n  isZero = CARRY4(temp5,temp5);\n  temp5 = temp5 * 2 + (uint)isEqual;\n  result2 = result2 * 2 + (uint)(isZero || CARRY4(shiftedInput4,(uint)isEqual));\n  shiftedInput4 = shiftedInput2 - 2;\n  if ((result2 & 0x100000) != 0) goto LAB_08000268;\n  temp3 = temp5;\n  shiftedInput2 = result2;\n  if (result2 == 0) {\n    temp3 = 0;\n    shiftedInput2 = temp5;\n  }\n  shiftedInput4 = LZCOUNT(shiftedInput2);\n  if (result2 == 0) {\n    shiftedInput4 = shiftedInput4 + 0x20;\n  }\n  temp5 = shiftedInput4 - 0xb;\n  isNegative = SBORROW4(temp5,0x20);\n  result2 = shiftedInput4 - 0x2b;\n  isZero = (int)result2 < 0;\n  isEqual = result2 == 0;\n  if ((int)temp5 < 0x20) {\n    isNegative = SCARRY4(result2,0xc);\n    shiftedInput4 = shiftedInput4 + -0x1f;\n    isZero = shiftedInput4 < 0;\n    isEqual = shiftedInput4 == 0;\n    result2 = temp5;\n    if (!isEqual && isZero == isNegative) {\n      temp3 = shiftedInput2 << (temp5 & 0xff);\n      shiftedInput2 = shiftedInput2 >> (0xcU - shiftedInput4 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isEqual || isZero != isNegative) {\n    temp4 = 0x20 - result2;\n  }\n  shiftedInput2 = shiftedInput2 << (result2 & 0xff);\n  if (isEqual || isZero != isNegative) {\n    shiftedInput2 = shiftedInput2 | temp3 >> (temp4 & 0xff);\n  }\n  if (isEqual || isZero != isNegative) {\n    temp3 = temp3 << (result2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp5 <= (int)shiftedInput4) {\n    return CONCAT44(shiftedInput2 + (shiftedInput4 - temp5) * 0x100000 | input2,temp3);\n  }\n  result2 = ~(shiftedInput4 - temp5);\n  if ((int)result2 < 0x1f) {\n    shiftedInput4 = result2 - 0x13;\n    if (shiftedInput4 != 0 && shiftedInput4 < 0 == SCARRY4(result2 - 0x1f,0xc)) {\n      return CONCAT44(result1,temp3 >> (0x20 - (0xcU - shiftedInput4) & 0xff) | shiftedInput2 << (0xcU - shiftedInput4 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result2 = result2 + 1;\n    return CONCAT44(input2 | shiftedInput2 >> (result2 & 0xff),\n                    temp3 >> (result2 & 0xff) | shiftedInput2 << (0x20 - result2 & 0xff));\n  }\n  return CONCAT44(result1,shiftedInput2 >> (result2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_sum_0800015c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedInput2",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shiftedInput4",
                "uVar7": "shiftedInput2",
                "uVar8": "shiftedInput4",
                "uVar9": "result1",
                "uVar10": "result2",
                "uVar11": "temp4",
                "uVar12": "temp5",
                "bVar13": "isEqual",
                "bVar14": "isZero",
                "bVar15": "isNegative"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "__aeabi_drsub",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "shift_and_concat_080003d4",
            "code": "\nulonglong shiftAndConcat_080003d4(uint input)\n\n{\n  uint result_1;\n  uint result_2;\n  int bitCount;\n  uint shiftAmt;\n  uint reserved;\n  bool lessThanZero;\n  bool equalToZero;\n  bool borrowFlag;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result_1 = 0;\n  bitCount = LZCOUNT(input);\n  shiftAmt = bitCount + 0x15;\n  borrowFlag = SBORROW4(shiftAmt,0x20);\n  result_2 = bitCount - 0xb;\n  lessThanZero = (int)result_2 < 0;\n  equalToZero = result_2 == 0;\n  if (shiftAmt < 0x20) {\n    borrowFlag = SCARRY4(result_2,0xc);\n    lessThanZero = false;\n    equalToZero = bitCount + 1 == 0;\n    result_2 = shiftAmt;\n    if (!equalToZero && borrowFlag == false) {\n      result_1 = input << shiftAmt;\n      input = input >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (equalToZero || lessThanZero != borrowFlag) {\n    reserved = 0x20 - result_2;\n  }\n  input = input << (result_2 & 0xff);\n  if (equalToZero || lessThanZero != borrowFlag) {\n    input = input | 0U >> (reserved & 0xff);\n  }\n  if (equalToZero || lessThanZero != borrowFlag) {\n    result_1 = 0 << (result_2 & 0xff);\n  }\nLAB_080002e0:\n  if (shiftAmt < 0x433) {\n    return CONCAT44(input + (0x432 - shiftAmt) * 0x100000,result_1);\n  }\n  result_2 = ~(0x432 - shiftAmt);\n  if (0x1e < (int)result_2) {\n    return (ulonglong)(input >> (result_2 - 0x1f & 0xff));\n  }\n  bitCount = result_2 - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(result_2 - 0x1f,0xc)) {\n    result_2 = result_2 + 1;\n    return CONCAT44(input >> (result_2 & 0xff),\n                    result_1 >> (result_2 & 0xff) | input << (0x20 - result_2 & 0xff));\n  }\n  return (ulonglong)(result_1 >> (0x20 - (0xcU - bitCount) & 0xff) | input << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "shift_and_concat_080003d4",
                "param_1": "input",
                "uVar1": "result_1",
                "uVar2": "result_2",
                "iVar3": "bitCount",
                "uVar4": "shiftAmt",
                "in_r12": "reserved",
                "bVar5": "lessThanZero",
                "bVar6": "equalToZero",
                "bVar7": "borrowFlag"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "bitwise_shift_080003f4",
            "code": "\nulonglong bitwiseShift_080003f4(uint input)\n\n{\n  uint output1;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint shiftCount;\n  uint bitSign;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool overflow;\n  \n  if (input == 0) {\n    return 0;\n  }\n  bitSign = input & 0x80000000;\n  temp1 = input;\n  if ((int)bitSign < 0) {\n    temp1 = -input;\n  }\n  output1 = 0;\n  temp3 = LZCOUNT(temp1);\n  shiftCount = temp3 + 0x15;\n  overflow = SBORROW4(shiftCount,0x20);\n  temp2 = temp3 - 0xb;\n  isNegative = (int)temp2 < 0;\n  isZero = temp2 == 0;\n  if (shiftCount < 0x20) {\n    overflow = SCARRY4(temp2,0xc);\n    isNegative = false;\n    isZero = temp3 + 1 == 0;\n    temp2 = shiftCount;\n    if (!isZero && overflow == false) {\n      output1 = temp1 << shiftCount;\n      temp1 = temp1 >> (0xcU - (temp3 + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZero || isNegative != overflow) {\n    remainingBits = 0x20 - temp2;\n  }\n  temp1 = temp1 << (temp2 & 0xff);\n  if (isZero || isNegative != overflow) {\n    temp1 = temp1 | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != overflow) {\n    output1 = 0 << (temp2 & 0xff);\n  }\nLAB_080002e0:\n  if (shiftCount < 0x433) {\n    return CONCAT44(temp1 + (0x432 - shiftCount) * 0x100000 | bitSign,output1);\n  }\n  temp2 = ~(0x432 - shiftCount);\n  if (0x1e < (int)temp2) {\n    return CONCAT44(input,temp1 >> (temp2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  temp3 = temp2 - 0x13;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp2 - 0x1f,0xc)) {\n    temp2 = temp2 + 1;\n    return CONCAT44(bitSign | temp1 >> (temp2 & 0xff),\n                    output1 >> (temp2 & 0xff) | temp1 << (0x20 - temp2 & 0xff));\n  }\n  return CONCAT44(input,output1 >> (0x20 - (0xcU - temp3) & 0xff) | temp1 << (0xcU - temp3 & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "bitwise_shift_080003f4",
                "param_1": "input",
                "uVar1": "output1",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "iVar4": "temp3",
                "uVar5": "shiftCount",
                "uVar6": "bitSign",
                "in_r12": "remainingBits",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "overflow"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "reverse_bits_08000418",
            "code": "\nulonglong reverseBits_08000418(uint inputNumber,undefined4 unusedParam1,undefined4 unusedParam2,uint unusedParam3)\n\n{\n  uint msbMask;\n  uint result;\n  uint finalResult;\n  uint shiftedNumber;\n  uint doubledNumber;\n  int bitsLength;\n  uint count;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool isNegative2;\n  \n  doubledNumber = inputNumber << 1;\n  isZero = doubledNumber == 0;\n  msbMask = (uint)((inputNumber & 0x80000000) != 0) << 0x1f;\n  shiftedNumber = (uint)((int)doubledNumber >> 3) >> 1;\n  finalResult = msbMask | shiftedNumber;\n  inputNumber = inputNumber << 0x1d;\n  if (!isZero) {\n    unusedParam3 = doubledNumber & 0xff000000;\n    isZero = unusedParam3 == 0;\n  }\n  if (!isZero) {\n    isZero = unusedParam3 == 0xff000000;\n  }\n  if (!isZero) {\n    return CONCAT44(finalResult,inputNumber) ^ 0x3800000000000000;\n  }\n  if ((doubledNumber & 0xffffff) == 0) {\n    return CONCAT44(finalResult,inputNumber);\n  }\n  if (unusedParam3 == 0xff000000) {\n    return CONCAT44(finalResult,inputNumber) | 0x8000000000000;\n  }\n  result = inputNumber;\n  doubledNumber = shiftedNumber;\n  if (shiftedNumber == 0) {\n    result = 0;\n    doubledNumber = inputNumber;\n  }\n  bitsLength = LZCOUNT(doubledNumber);\n  if (shiftedNumber == 0) {\n    bitsLength = bitsLength + 0x20;\n  }\n  count = bitsLength - 0xb;\n  isNegative2 = SBORROW4(count,0x20);\n  shiftedNumber = bitsLength - 0x2b;\n  isZero = (int)shiftedNumber < 0;\n  isNegative = shiftedNumber == 0;\n  if ((int)count < 0x20) {\n    isNegative2 = SCARRY4(shiftedNumber,0xc);\n    bitsLength = bitsLength + -0x1f;\n    isZero = bitsLength < 0;\n    isNegative = bitsLength == 0;\n    shiftedNumber = count;\n    if (!isNegative && isZero == isNegative2) {\n      result = doubledNumber << (count & 0xff);\n      doubledNumber = doubledNumber >> (0xcU - bitsLength & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isNegative || isZero != isNegative2) {\n    remainingBits = 0x20 - shiftedNumber;\n  }\n  doubledNumber = doubledNumber << (shiftedNumber & 0xff);\n  if (isNegative || isZero != isNegative2) {\n    doubledNumber = doubledNumber | result >> (remainingBits & 0xff);\n  }\n  if (isNegative || isZero != isNegative2) {\n    result = result << (shiftedNumber & 0xff);\n  }\nLAB_080002e0:\n  if ((int)count < 0x381) {\n    return CONCAT44(doubledNumber + (0x380 - count) * 0x100000 | msbMask,result);\n  }\n  shiftedNumber = ~(0x380 - count);\n  if (0x1e < (int)shiftedNumber) {\n    return CONCAT44(finalResult,doubledNumber >> (shiftedNumber - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  bitsLength = shiftedNumber - 0x13;\n  if (bitsLength == 0 || bitsLength < 0 != SCARRY4(shiftedNumber - 0x1f,0xc)) {\n    shiftedNumber = shiftedNumber + 1;\n    return CONCAT44(msbMask | doubledNumber >> (shiftedNumber & 0xff),\n                    result >> (shiftedNumber & 0xff) | doubledNumber << (0x20 - shiftedNumber & 0xff));\n  }\n  return CONCAT44(finalResult,result >> (0x20 - (0xcU - bitsLength) & 0xff) | doubledNumber << (0xcU - bitsLength & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "reverse_bits_08000418",
                "param_1": "inputNumber",
                "param_2": "unusedParam1",
                "param_3": "unusedParam2",
                "param_4": "unusedParam3",
                "uVar1": "msbMask",
                "uVar2": "result",
                "uVar3": "finalResult",
                "uVar4": "shiftedNumber",
                "uVar5": "doubledNumber",
                "uVar7": "count",
                "in_r12": "remainingBits",
                "bVar8": "isNegative",
                "bVar9": "isZero",
                "bVar10": "isNegative2",
                "iVar6": "bitsLength"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800045c": {
            "entrypoint": "0x0800045c",
            "current_name": "calculate_0800045c",
            "code": "\nulonglong calculate_0800045c(uint input1,uint input2)\n\n{\n  byte byteValue;\n  uint tempValue1;\n  uint tempValue2;\n  uint tempValue3;\n  int count;\n  uint shiftAmount;\n  int shiftCount;\n  uint uVar8;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  if ((input1 | input2) == 0) {\n    return CONCAT44(input2,input1);\n  }\n  shiftCount = 0x432;\n  uVar8 = input2 >> 0x16;\n  if (uVar8 != 0) {\n    shiftCount = 3;\n    if (input2 >> 0x19 != 0) {\n      shiftCount = 6;\n    }\n    if (input2 >> 0x1c != 0) {\n      shiftCount = shiftCount + 3;\n    }\n    tempValue3 = shiftCount - ((int)input2 >> 0x1f);\n    uVar8 = input1 << (0x20 - tempValue3 & 0xff);\n    input1 = input1 >> (tempValue3 & 0xff) | input2 << (0x20 - tempValue3 & 0xff);\n    input2 = input2 >> (tempValue3 & 0xff);\n    shiftCount = tempValue3 + 0x432;\n  }\n  if (0xfffff < input2) {\n    if (0x1fffff < input2) {\n      tempValue3 = input2 & 1;\n      input2 = input2 >> 1;\n      byteValue = (byte)input1;\n      input1 = (uint)(tempValue3 != 0) << 0x1f | input1 >> 1;\n      uVar8 = (uint)(byteValue & 1) << 0x1f | uVar8 >> 1;\n      shiftCount = shiftCount + 1;\n      if (0xffbfffff < (uint)(shiftCount * 0x200000)) {\n        return 0x7ff0000000000000;\n      }\n    }\nLAB_08000268:\n    flag2 = 0x7fffffff < uVar8;\n    if (uVar8 == 0x80000000) {\n      flag2 = (input1 & 1) != 0;\n    }\n    return CONCAT44(input2 + shiftCount * 0x100000 + (uint)CARRY4(input1,(uint)flag2),input1 + flag2\n                   );\n  }\n  flag1 = (uVar8 & 0x80000000) != 0;\n  uVar8 = uVar8 << 1;\n  tempValue3 = input1 * 2;\n  flag2 = CARRY4(input1,input1);\n  input1 = input1 * 2 + (uint)flag1;\n  input2 = input2 * 2 + (uint)(flag2 || CARRY4(tempValue3,(uint)flag1));\n  shiftCount = shiftCount + -1;\n  if ((input2 & 0x100000) != 0) goto LAB_08000268;\n  tempValue1 = input1;\n  tempValue3 = input2;\n  if (input2 == 0) {\n    tempValue1 = 0;\n    tempValue3 = input1;\n  }\n  count = LZCOUNT(tempValue3);\n  if (input2 == 0) {\n    count = count + 0x20;\n  }\n  shiftAmount = count - 0xb;\n  flag3 = SBORROW4(shiftAmount,0x20);\n  tempValue2 = count - 0x2b;\n  flag2 = (int)tempValue2 < 0;\n  flag1 = tempValue2 == 0;\n  if ((int)shiftAmount < 0x20) {\n    flag3 = SCARRY4(tempValue2,0xc);\n    count = count + -0x1f;\n    flag2 = count < 0;\n    flag1 = count == 0;\n    tempValue2 = shiftAmount;\n    if (!flag1 && flag2 == flag3) {\n      tempValue1 = tempValue3 << (shiftAmount & 0xff);\n      tempValue3 = tempValue3 >> (0xcU - count & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (flag1 || flag2 != flag3) {\n    uVar8 = 0x20 - tempValue2;\n  }\n  tempValue3 = tempValue3 << (tempValue2 & 0xff);\n  if (flag1 || flag2 != flag3) {\n    tempValue3 = tempValue3 | tempValue1 >> (uVar8 & 0xff);\n  }\n  if (flag1 || flag2 != flag3) {\n    tempValue1 = tempValue1 << (tempValue2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftAmount <= shiftCount) {\n    return CONCAT44(tempValue3 + (shiftCount - shiftAmount) * 0x100000,tempValue1);\n  }\n  uVar8 = ~(shiftCount - shiftAmount);\n  if (0x1e < (int)uVar8) {\n    return (ulonglong)(tempValue3 >> (uVar8 - 0x1f & 0xff));\n  }\n  shiftCount = uVar8 - 0x13;\n  if (shiftCount == 0 || shiftCount < 0 != SCARRY4(uVar8 - 0x1f,0xc)) {\n    uVar8 = uVar8 + 1;\n    return CONCAT44(tempValue3 >> (uVar8 & 0xff),tempValue1 >> (uVar8 & 0xff) | tempValue3 << (0x20 - uVar8 & 0xff)\n                   );\n  }\n  return (ulonglong)(tempValue1 >> (0x20 - (0xcU - shiftCount) & 0xff) | tempValue3 << (0xcU - shiftCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800045c": "calculate_0800045c",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "byteValue",
                "uVar2": "tempValue1",
                "uVar3": "tempValue2",
                "uVar4": "tempValue3",
                "iVar5": "count",
                "uVar6": "shiftAmount",
                "iVar7": "shiftCount",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800046c": {
            "entrypoint": "0x0800046c",
            "current_name": "calculate_sum_0800046c",
            "code": "\nulonglong calculate_sum_0800046c(uint num1,uint num2)\n\n{\n  byte carry;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shift;\n  uint mask;\n  int count;\n  uint sign;\n  uint temp4;\n  bool overflow;\n  bool conditional_var1;\n  bool conditional_var2;\n  \n  if ((num1 | num2) == 0) {\n    return CONCAT44(num2,num1);\n  }\n  sign = num2 & 0x80000000;\n  temp2 = num2;\n  if ((int)sign < 0) {\n    conditional_var1 = num1 != 0;\n    num1 = -num1;\n    temp2 = -num2 - (uint)conditional_var1;\n  }\n  count = 0x432;\n  temp4 = temp2 >> 0x16;\n  if (temp4 != 0) {\n    count = 3;\n    if (temp2 >> 0x19 != 0) {\n      count = 6;\n    }\n    if (temp2 >> 0x1c != 0) {\n      count = count + 3;\n    }\n    temp3 = count - ((int)temp2 >> 0x1f);\n    temp4 = num1 << (0x20 - temp3 & 0xff);\n    num1 = num1 >> (temp3 & 0xff) | temp2 << (0x20 - temp3 & 0xff);\n    temp2 = temp2 >> (temp3 & 0xff);\n    count = temp3 + 0x432;\n  }\n  if (0xfffff < temp2) {\n    if (0x1fffff < temp2) {\n      temp3 = temp2 & 1;\n      temp2 = temp2 >> 1;\n      carry = (byte)num1;\n      num1 = (uint)(temp3 != 0) << 0x1f | num1 >> 1;\n      temp4 = (uint)(carry & 1) << 0x1f | temp4 >> 1;\n      count = count + 1;\n      if (0xffbfffff < (uint)(count * 0x200000)) {\n        return (ulonglong)(sign | 0x7ff00000) << 0x20;\n      }\n    }\nLAB_08000268:\n    conditional_var1 = 0x7fffffff < temp4;\n    if (temp4 == 0x80000000) {\n      conditional_var1 = (num1 & 1) != 0;\n    }\n    return CONCAT44(temp2 + count * 0x100000 + (uint)CARRY4(num1,(uint)conditional_var1) | sign,\n                    num1 + conditional_var1);\n  }\n  overflow = (temp4 & 0x80000000) != 0;\n  temp4 = temp4 << 1;\n  temp3 = num1 * 2;\n  conditional_var1 = CARRY4(num1,num1);\n  num1 = num1 * 2 + (uint)overflow;\n  temp2 = temp2 * 2 + (uint)(conditional_var1 || CARRY4(temp3,(uint)overflow));\n  count = count + -1;\n  if ((temp2 & 0x100000) != 0) goto LAB_08000268;\n  temp1 = num1;\n  temp3 = temp2;\n  if (temp2 == 0) {\n    temp1 = 0;\n    temp3 = num1;\n  }\n  shift = LZCOUNT(temp3);\n  if (temp2 == 0) {\n    shift = shift + 0x20;\n  }\n  mask = shift - 0xb;\n  conditional_var2 = SBORROW4(mask,0x20);\n  temp2 = shift - 0x2b;\n  conditional_var1 = (int)temp2 < 0;\n  overflow = temp2 == 0;\n  if ((int)mask < 0x20) {\n    conditional_var2 = SCARRY4(temp2,0xc);\n    shift = shift + -0x1f;\n    conditional_var1 = shift < 0;\n    overflow = shift == 0;\n    temp2 = mask;\n    if (!overflow && conditional_var1 == conditional_var2) {\n      temp1 = temp3 << (mask & 0xff);\n      temp3 = temp3 >> (0xcU - shift & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (overflow || conditional_var1 != conditional_var2) {\n    temp4 = 0x20 - temp2;\n  }\n  temp3 = temp3 << (temp2 & 0xff);\n  if (overflow || conditional_var1 != conditional_var2) {\n    temp3 = temp3 | temp1 >> (temp4 & 0xff);\n  }\n  if (overflow || conditional_var1 != conditional_var2) {\n    temp1 = temp1 << (temp2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)mask <= count) {\n    return CONCAT44(temp3 + (count - mask) * 0x100000 | sign,temp1);\n  }\n  temp2 = ~(count - mask);\n  if (0x1e < (int)temp2) {\n    return CONCAT44(num2,temp3 >> (temp2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  count = temp2 - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(temp2 - 0x1f,0xc)) {\n    temp2 = temp2 + 1;\n    return CONCAT44(sign | temp3 >> (temp2 & 0xff),\n                    temp1 >> (temp2 & 0xff) | temp3 << (0x20 - temp2 & 0xff));\n  }\n  return CONCAT44(num2,temp1 >> (0x20 - (0xcU - count) & 0xff) | temp3 << (0xcU - count & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800046c": "calculate_sum_0800046c",
                "param_1": "num1",
                "param_2": "num2",
                "bVar1": "carry",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "iVar5": "shift",
                "uVar6": "mask",
                "iVar7": "count",
                "uVar8": "sign",
                "uVar9": "temp4",
                "bVar10": "overflow",
                "bVar11": "conditional_var1",
                "bVar12": "conditional_var2"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_080004c8",
            "code": "\nulonglong calculate_080004c8(undefined4 input1,uint input2,uint input3,uint input4)\n\n{\n  ulonglong result;\n  longlong temp;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  ulonglong temp8;\n  \n  temp8 = CONCAT44(input2,input1);\n  temp6 = 0x7ff;\n  temp2 = input2 >> 0x14 & 0x7ff;\n  flag1 = temp2 == 0;\n  if (!flag1) {\n    temp5 = input4 >> 0x14 & 0x7ff;\n    flag1 = temp5 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp2 == 0x7ff;\n  }\n  if (!flag1) {\n    flag1 = temp5 == 0x7ff;\n  }\n  if (flag1) {\n    temp8 = calculate_080004c8_result_080006a4();\n  }\n  temp1 = (uint)(temp8 >> 0x20);\n  temp3 = temp2 + temp5;\n  temp2 = temp1 ^ input4;\n  temp1 = temp1 & ~(temp6 << 0x15);\n  input4 = input4 & ~(temp6 << 0x15);\n  flag1 = ((uint)temp8 | temp1 << 0xc) == 0;\n  if (!flag1) {\n    flag1 = (input3 | input4 << 0xc) == 0;\n  }\n  temp1 = temp1 | 0x100000;\n  input4 = input4 | 0x100000;\n  if (flag1) {\n    input3 = (uint)temp8 | input3;\n    input4 = (temp2 & 0x80000000 | temp1) ^ input4;\n    temp2 = temp6 >> 1;\n    flag3 = SBORROW4(temp3,temp2);\n    temp4 = temp3 - temp2;\n    flag1 = temp4 == 0;\n    temp1 = temp4;\n    if (!flag1 && (int)temp2 <= temp3) {\n      flag3 = SBORROW4(temp6,temp4);\n      temp1 = temp6 - temp4;\n      flag1 = temp6 == temp4;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      input4 = input4 | temp4 * 0x100000;\n    }\n    if (!flag1 && (int)temp1 < 0 == flag3) {\n      return CONCAT44(input4,input3);\n    }\n    input4 = input4 | 0x100000;\n    temp6 = 0;\n    flag3 = SBORROW4(temp4,1);\n    temp4 = temp4 - 1;\n    flag1 = temp4 == 0;\n    temp2 = temp4;\n  }\n  else {\n    result = (temp8 & 0xffffffff) * (ulonglong)input3;\n    temp8 = (temp8 & 0xffffffff) * (ulonglong)input4 +\n             (ulonglong)temp1 * (ulonglong)input3 + (result >> 0x20);\n    temp7 = (uint)temp8;\n    temp = (ulonglong)temp1 * (ulonglong)input4 + (temp8 >> 0x20);\n    temp6 = (uint)temp;\n    temp1 = (uint)((ulonglong)temp >> 0x20);\n    if ((int)result != 0) {\n      temp7 = temp7 | 1;\n    }\n    temp4 = (temp3 + -0x3ff) - (uint)(temp1 < 0x200);\n    if (temp1 < 0x200) {\n      flag1 = (temp7 & 0x80000000) != 0;\n      temp7 = temp7 << 1;\n      temp = CONCAT44(temp1 * 2 + (uint)(CARRY4(temp6,temp6) || CARRY4(temp6 * 2,(uint)flag1)),\n                       temp6 * 2 + (uint)flag1);\n    }\n    input4 = temp2 & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    input3 = (uint)temp << 0xb | temp7 >> 0x15;\n    temp6 = temp7 * 0x800;\n    flag2 = 0xfc < temp4;\n    flag3 = SBORROW4(temp4,0xfd);\n    temp1 = temp4 - 0xfd;\n    flag1 = temp1 == 0;\n    temp2 = temp1;\n    if (flag2 && !flag1) {\n      flag2 = 0x6ff < temp1;\n      flag3 = SBORROW4(temp1,0x700);\n      temp2 = temp4 - 0x7fd;\n      flag1 = temp1 == 0x700;\n    }\n    if (!flag2 || flag1) {\n      flag1 = 0x7fffffff < temp6;\n      if (temp6 == 0x80000000) {\n        flag1 = (temp7 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(input4 + temp4 * 0x100000 + (uint)CARRY4(input3,(uint)flag1),input3 + flag1\n                     );\n    }\n  }\n  if (!flag1 && (int)temp2 < 0 == flag3) {\n    return (ulonglong)(input4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  flag2 = SCARRY4(temp4,0x36);\n  flag1 = (int)(temp4 + 0x36) < 0;\n  flag3 = temp4 == 0xffffffca;\n  if (flag3 || flag1 != flag2) {\n    input3 = 0;\n  }\n  if (flag3 || flag1 != flag2) {\n    input4 = input4 & 0x80000000;\n  }\n  if (flag3 || flag1 != flag2) {\n    return CONCAT44(input4,input3);\n  }\n  temp2 = -temp4;\n  temp1 = temp2 - 0x20;\n  if (0x1f < (int)temp2) {\n    temp4 = input3 >> (temp1 & 0xff) | input4 << (0x20 - temp1 & 0xff);\n    temp2 = (input4 >> (temp1 & 0xff) & ~((input4 & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)temp4 >> 0x1f);\n    if ((temp6 | input3 << (0x20 - temp1 & 0xff) | temp4 << 1) == 0) {\n      temp2 = temp2 & ~(temp4 >> 0x1f);\n    }\n    return CONCAT44(input4,temp2) & 0x80000000ffffffff;\n  }\n  temp3 = temp2 - 0x14;\n  if (temp3 == 0 || temp3 < 0 != SCARRY4(temp1,0xc)) {\n    temp7 = input3 << (temp4 + 0x20 & 0xff);\n    temp1 = input3 >> (temp2 & 0xff) | input4 << (temp4 + 0x20 & 0xff);\n    temp4 = temp1 + -((int)temp7 >> 0x1f);\n    if ((temp6 | temp7 << 1) == 0) {\n      temp4 = temp4 & ~(temp7 >> 0x1f);\n    }\n    return CONCAT44((input4 & 0x80000000) +\n                    ((input4 & 0x7fffffff) >> (temp2 & 0xff)) +\n                    (uint)CARRY4(temp1,-((int)temp7 >> 0x1f)),temp4);\n  }\n  temp2 = 0xc - temp3;\n  temp4 = input3 << (temp2 & 0xff);\n  temp2 = input3 >> (0x20 - temp2 & 0xff) | input4 << (temp2 & 0xff);\n  temp1 = temp2 + -((int)temp4 >> 0x1f);\n  if ((temp6 | temp4 << 1) == 0) {\n    temp1 = temp1 & ~(temp4 >> 0x1f);\n  }\n  return CONCAT44((input4 & 0x80000000) + (uint)CARRY4(temp2,-((int)temp4 >> 0x1f)),temp1);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_080004c8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "lVar2": "temp",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "temp3",
                "uVar6": "temp4",
                "unaff_r5": "temp5",
                "uVar7": "temp6",
                "uVar8": "temp7",
                "bVar9": "flag1",
                "bVar10": "flag2",
                "bVar11": "flag3",
                "uVar12": "temp8"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "_svfprintf_r",
                "atan",
                "_dtoa_r",
                "frexp",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "calculate_result_080006a4",
            "code": "\nulonglong calculate_result_080006a4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp2;\n  uint temp3;\n  uint temp5;\n  bool isZero;\n  \n  temp2 = temp5 & input4 >> 0x14;\n  if (temp2 != temp5 && temp2 != temp5) {\n    isZero = (input1 | input2 << 1) == 0;\n    if (!isZero) {\n      isZero = (input3 | input4 << 1) == 0;\n    }\n    if (isZero) {\n      return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (temp2 == 0) {\n      temp3 = input2 & 0x80000000;\n      do {\n        temp1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(temp1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | temp3;\n      if (temp2 != 0) {\n        return concatenate(input2,input1);\n      }\n    }\n    do {\n      temp2 = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(temp2 != 0);\n    } while ((input4 & 0x100000) == 0);\n    return concatenate(input2,input1);\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  temp3 = input2;\n  if (((!isZero) && ((temp2 != temp5 || ((input1 | input2 << 0xc) == 0)))) &&\n     ((temp2 != temp5 || (input1 = input3, temp3 = input4, (input3 | input4 << 0xc) == 0)))) {\n    return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return concatenate(temp3,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "calculate_result_080006a4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "unaff_r4": "temp2",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "in_r12": "temp5",
                "bVar4": "isZero",
                "CONCAT44": "concatenate"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_double_precision_value_0800071c",
            "code": "\nulonglong calculate_double_precision_value_0800071c(undefined4 param1,uint param2,uint param3,uint param4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  int temp8;\n  uint temp9;\n  uint temp10;\n  uint temp11;\n  uint temp12;\n  uint temp13;\n  uint temp14;\n  bool bool1;\n  bool bool2;\n  bool bool3;\n  undefined8 retval;\n  \n  retval = CONCAT44(param2,param1);\n  temp14 = 0x7ff;\n  temp7 = param2 >> 0x14 & 0x7ff;\n  bool1 = temp7 == 0;\n  if (!bool1) {\n    temp10 = param4 >> 0x14 & 0x7ff;\n    bool1 = temp10 == 0;\n  }\n  if (!bool1) {\n    bool1 = temp7 == 0x7ff;\n  }\n  if (!bool1) {\n    bool1 = temp10 == 0x7ff;\n  }\n  if (bool1) {\n    retval = calculate_double_precision_value_0800071c_0800088a();\n  }\n  temp9 = (uint)((ulonglong)retval >> 0x20);\n  temp12 = (uint)retval;\n  temp8 = temp7 - temp10;\n  if ((param3 | param4 << 0xc) == 0) {\n    temp7 = (temp9 ^ param4) & 0x80000000 | temp9 & 0xfffff;\n    bool3 = SCARRY4(temp8,temp14 >> 1);\n    temp9 = temp8 + (temp14 >> 1);\n    bool1 = (int)temp9 < 0;\n    bool2 = temp9 == 0;\n    if (!bool2 && bool1 == bool3) {\n      bool3 = SBORROW4(temp14,temp9);\n      bool1 = (int)(temp14 - temp9) < 0;\n      bool2 = temp14 == temp9;\n    }\n    if (!bool2 && bool1 == bool3) {\n      temp7 = temp7 | temp9 * 0x100000;\n    }\n    if (!bool2 && bool1 == bool3) {\n      return CONCAT44(temp7,temp12);\n    }\n    temp7 = temp7 | 0x100000;\n    temp14 = 0;\n    bool2 = SBORROW4(temp9,1);\n    temp9 = temp9 - 1;\n    bool1 = temp9 == 0;\n    temp3 = temp9;\n  }\n  else {\n    temp3 = (param4 << 0xc) >> 4 | 0x10000000 | param3 >> 0x18;\n    temp14 = param3 << 8;\n    temp11 = (temp9 << 0xc) >> 4 | 0x10000000 | temp12 >> 0x18;\n    temp12 = temp12 * 0x100;\n    temp7 = (temp9 ^ param4) & 0x80000000;\n    bool1 = temp3 <= temp11;\n    if (temp11 == temp3) {\n      bool1 = temp14 <= temp12;\n    }\n    temp8 = temp8 + (uint)bool1;\n    temp9 = temp8 + 0x3fd;\n    if (bool1 == false) {\n      temp3 = temp3 >> 1;\n      temp14 = (uint)((param3 >> 0x18 & 1) != 0) << 0x1f | temp14 >> 1;\n    }\n    temp13 = temp12 - temp14;\n    temp11 = (temp11 - temp3) - (uint)(temp12 < temp14);\n    temp4 = temp3 >> 1;\n    temp1 = (uint)((temp3 & 1) != 0) << 0x1f | temp14 >> 1;\n    temp12 = 0x100000;\n    temp3 = 0x80000;\n    while( true ) {\n      bool1 = temp1 <= temp13;\n      if (temp4 < temp11 || temp11 - temp4 < (uint)bool1) {\n        temp13 = temp13 - temp1;\n        temp12 = temp12 | temp3;\n        temp11 = (temp11 - temp4) - (uint)!bool1;\n      }\n      temp5 = temp4 >> 1;\n      temp1 = (uint)((temp4 & 1) != 0) << 0x1f | temp1 >> 1;\n      bool2 = temp1 <= temp13;\n      bool1 = temp11 - temp5 < (uint)bool2;\n      temp14 = temp11;\n      if (temp5 < temp11 || bool1) {\n        temp13 = temp13 - temp1;\n        temp14 = (temp11 - temp5) - (uint)!bool2;\n      }\n      if (temp5 < temp11 || bool1) {\n        temp12 = temp12 | temp3 >> 1;\n      }\n      temp11 = temp4 >> 2;\n      temp2 = (uint)((temp5 & 1) != 0) << 0x1f | temp1 >> 1;\n      bool2 = temp2 <= temp13;\n      bool1 = temp14 - temp11 < (uint)bool2;\n      temp5 = temp14;\n      if (temp11 < temp14 || bool1) {\n        temp13 = temp13 - temp2;\n        temp5 = (temp14 - temp11) - (uint)!bool2;\n      }\n      if (temp11 < temp14 || bool1) {\n        temp12 = temp12 | temp3 >> 2;\n      }\n      temp6 = temp4 >> 3;\n      temp1 = (uint)((temp11 & 1) != 0) << 0x1f | temp2 >> 1;\n      bool2 = temp1 <= temp13;\n      bool1 = temp5 - temp6 < (uint)bool2;\n      temp11 = temp5;\n      if (temp6 < temp5 || bool1) {\n        temp13 = temp13 - temp1;\n        temp11 = (temp5 - temp6) - (uint)!bool2;\n      }\n      if (temp6 < temp5 || bool1) {\n        temp12 = temp12 | temp3 >> 3;\n      }\n      temp14 = temp11 | temp13;\n      if (temp14 == 0) break;\n      temp11 = temp11 << 4 | temp13 >> 0x1c;\n      temp13 = temp13 << 4;\n      temp4 = temp4 & 0xfffffff8 | temp1 >> 0x1d;\n      temp1 = (temp2 >> 1) << 3;\n      temp3 = temp3 >> 4;\n      if (temp3 == 0) {\n        temp6 = temp4;\n        if ((temp7 & 0x100000) != 0) goto LAB_0800083a;\n        temp7 = temp7 | temp12;\n        temp12 = 0;\n        temp3 = 0x80000000;\n      }\n    }\n    if ((temp7 & 0x100000) == 0) {\n      temp7 = temp7 | temp12;\n      temp12 = 0;\n    }\nLAB_0800083a:\n    bool3 = 0xfc < temp9;\n    bool2 = SBORROW4(temp9,0xfd);\n    temp4 = temp8 + 0x300;\n    bool1 = temp4 == 0;\n    temp3 = temp4;\n    if (bool3 && !bool1) {\n      bool3 = 0x6ff < temp4;\n      bool2 = SBORROW4(temp4,0x700);\n      temp3 = temp8 - 0x400;\n      bool1 = temp4 == 0x700;\n    }\n    if (!bool3 || bool1) {\n      bool1 = temp6 <= temp11;\n      if (temp11 == temp6) {\n        bool1 = temp1 <= temp13;\n      }\n      if (temp11 == temp6 && temp13 == temp1) {\n        bool1 = (temp12 & 1) != 0;\n      }\n      return CONCAT44(temp7 + temp9 * 0x100000 + (uint)CARRY4(temp12,(uint)bool1),temp12 + bool1);\n    }\n  }\n  if (!bool1 && (int)temp3 < 0 == bool2) {\n    return (ulonglong)(temp7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  bool3 = SCARRY4(temp9,0x36);\n  bool1 = (int)(temp9 + 0x36) < 0;\n  bool2 = temp9 == 0xffffffca;\n  if (bool2 || bool1 != bool3) {\n    temp12 = 0;\n  }\n  if (bool2 || bool1 != bool3) {\n    temp7 = temp7 & 0x80000000;\n  }\n  if (bool2 || bool1 != bool3) {\n    return CONCAT44(temp7,temp12);\n  }\n  temp3 = -temp9;\n  temp11 = temp3 - 0x20;\n  if (0x1f < (int)temp3) {\n    temp3 = temp12 >> (temp11 & 0xff) | temp7 << (0x20 - temp11 & 0xff);\n    temp9 = (temp7 >> (temp11 & 0xff) & ~((temp7 & 0x80000000) >> (temp11 & 0xff))) -\n            ((int)temp3 >> 0x1f);\n    if ((temp14 | temp12 << (0x20 - temp11 & 0xff) | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44(temp7,temp9) & 0x80000000ffffffff;\n  }\n  temp8 = temp3 - 0x14;\n  if (temp8 != 0 && temp8 < 0 == SCARRY4(temp11,0xc)) {\n    temp9 = 0xc - temp8;\n    temp3 = temp12 << (temp9 & 0xff);\n    temp12 = temp12 >> (0x20 - temp9 & 0xff) | temp7 << (temp9 & 0xff);\n    temp9 = temp12 + -((int)temp3 >> 0x1f);\n    if ((temp14 | temp3 << 1) == 0) {\n      temp9 = temp9 & ~(temp3 >> 0x1f);\n    }\n    return CONCAT44((temp7 & 0x80000000) + (uint)CARRY4(temp12,-((int)temp3 >> 0x1f)),temp9);\n  }\n  temp11 = temp12 << (temp9 + 0x20 & 0xff);\n  temp12 = temp12 >> (temp3 & 0xff) | temp7 << (temp9 + 0x20 & 0xff);\n  temp9 = temp12 + -((int)temp11 >> 0x1f);\n  if ((temp14 | temp11 << 1) == 0) {\n    temp9 = temp9 & ~(temp11 >> 0x1f);\n  }\n  return CONCAT44((temp7 & 0x80000000) +\n                  ((temp7 & 0x7fffffff) >> (temp3 & 0xff)) +\n                  (uint)CARRY4(temp12,-((int)temp11 >> 0x1f)),temp9);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_double_precision_value_0800071c",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6",
                "uVar7": "temp7",
                "iVar8": "temp8",
                "uVar9": "temp9",
                "unaff_r5": "temp10",
                "uVar10": "temp11",
                "uVar11": "temp12",
                "uVar12": "temp13",
                "uVar13": "temp14",
                "bVar14": "bool1",
                "bVar15": "bool2",
                "bVar16": "bool3",
                "uVar17": "retval"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "calculate_double_precision_value_0800088a",
            "code": "\nulonglong calculate_double_precision_value_0800088a(uint input_unsigned_integer_1,uint input_unsigned_integer_2,uint input_unsigned_integer_3,uint input_unsigned_integer_4)\n\n{\n  uint bit_check_1;\n  uint bit_check_2;\n  uint shifted_value_1;\n  uint modified_input_unsigned_integer_2;\n  uint input_parameter_5;\n  bool is_zero;\n  \n  shifted_value_1 = input_parameter_5 & input_unsigned_integer_4 >> 0x14;\n  modified_input_unsigned_integer_2 = input_unsigned_integer_2;\n  if (bit_check_2 != input_parameter_5 || shifted_value_1 != input_parameter_5) {\n    if (bit_check_2 == input_parameter_5) {\n      if (((input_unsigned_integer_1 | input_unsigned_integer_2 << 0xc) == 0) && (input_unsigned_integer_1 = input_unsigned_integer_3, modified_input_unsigned_integer_2 = input_unsigned_integer_4, shifted_value_1 != input_parameter_5)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input_unsigned_integer_2 ^ input_unsigned_integer_4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (shifted_value_1 == input_parameter_5) {\n      input_unsigned_integer_1 = input_unsigned_integer_3;\n      modified_input_unsigned_integer_2 = input_unsigned_integer_4;\n      if ((input_unsigned_integer_3 | input_unsigned_integer_4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input_unsigned_integer_2 ^ input_unsigned_integer_4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      is_zero = (input_unsigned_integer_1 | input_unsigned_integer_2 << 1) == 0;\n      if (!is_zero) {\n        is_zero = (input_unsigned_integer_3 | input_unsigned_integer_4 << 1) == 0;\n      }\n      if (!is_zero) {\n        if (bit_check_2 == 0) {\n          modified_input_unsigned_integer_2 = input_unsigned_integer_2 & 0x80000000;\n          do {\n            bit_check_1 = input_unsigned_integer_1 & 0x80000000;\n            input_unsigned_integer_1 = input_unsigned_integer_1 << 1;\n            input_unsigned_integer_2 = input_unsigned_integer_2 * 2 + (uint)(bit_check_1 != 0);\n          } while ((input_unsigned_integer_2 & 0x100000) == 0);\n          input_unsigned_integer_2 = input_unsigned_integer_2 | modified_input_unsigned_integer_2;\n          if (shifted_value_1 != 0) {\n            return CONCAT44(input_unsigned_integer_2,input_unsigned_integer_1);\n          }\n        }\n        do {\n          modified_input_unsigned_integer_2 = input_unsigned_integer_3 & 0x80000000;\n          input_unsigned_integer_3 = input_unsigned_integer_3 << 1;\n          input_unsigned_integer_4 = input_unsigned_integer_4 * 2 + (uint)(modified_input_unsigned_integer_2 != 0);\n        } while ((input_unsigned_integer_4 & 0x100000) == 0);\n        return CONCAT44(input_unsigned_integer_2,input_unsigned_integer_1);\n      }\n      if ((input_unsigned_integer_1 | input_unsigned_integer_2 << 1) != 0) goto LAB_080006fc;\n      if ((input_unsigned_integer_3 | input_unsigned_integer_4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(modified_input_unsigned_integer_2,input_unsigned_integer_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "calculate_double_precision_value_0800088a",
                "param_1": "input_unsigned_integer_1",
                "param_2": "input_unsigned_integer_2",
                "param_3": "input_unsigned_integer_3",
                "param_4": "input_unsigned_integer_4",
                "uVar1": "bit_check_1",
                "unaff_r4": "bit_check_2",
                "uVar2": "shifted_value_1",
                "uVar3": "modified_input_unsigned_integer_2",
                "in_r12": "input_parameter_5",
                "bVar4": "is_zero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ec": {
            "entrypoint": "0x080008ec",
            "current_name": "compare_params_and_return_result_080008ec",
            "code": "\nuint compare_params_and_return_result_080008ec(uint first_param,uint second_param,uint third_param,uint fourth_param)\n\n{\n  uint xor_result;\n  bool is_zero;\n  bool is_negative;\n  \n  if (((int)(second_param << 1) >> 0x15 == -1 || (int)(fourth_param << 1) >> 0x15 == -1) &&\n     ((((int)(second_param << 1) >> 0x15 == -1 && ((first_param | second_param << 0xc) != 0)) ||\n      (((int)(fourth_param << 1) >> 0x15 == -1 && ((third_param | fourth_param << 0xc) != 0)))))) {\n    return 0xffffffff;\n  }\n  is_zero = (first_param | second_param << 1) == 0;\n  if (is_zero) {\n    is_zero = (third_param | fourth_param << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = second_param == fourth_param;\n  }\n  if (is_zero) {\n    is_zero = first_param == third_param;\n  }\n  if (!is_zero) {\n    xor_result = second_param ^ fourth_param;\n    is_zero = xor_result == 0;\n    if (-1 < (int)xor_result) {\n      is_zero = second_param == fourth_param;\n    }\n    is_negative = -1 < (int)xor_result && fourth_param <= second_param;\n    if (is_zero) {\n      is_negative = third_param <= first_param;\n    }\n    fourth_param = (int)fourth_param >> 0x1f;\n    if (!is_negative) {\n      fourth_param = ~fourth_param;\n    }\n    return fourth_param | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008ec": "compare_params_and_return_result_080008ec",
                "param_1": "first_param",
                "param_2": "second_param",
                "param_3": "third_param",
                "param_4": "fourth_param",
                "uVar1": "xor_result",
                "bVar2": "is_zero",
                "bVar3": "is_negative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008f4": {
            "entrypoint": "0x080008f4",
            "current_name": "check_parameters_080008f4",
            "code": "\nuint checkParameters_080008f4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(input2 << 1) >> 0x15 == -1 || (int)(input4 << 1) >> 0x15 == -1) &&\n     ((((int)(input2 << 1) >> 0x15 == -1 && ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(input4 << 1) >> 0x15 == -1 && ((input3 | input4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input1 | input2 << 1) == 0;\n  if (isZero) {\n    isZero = (input3 | input4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input2 == input4;\n  }\n  if (isZero) {\n    isZero = input1 == input3;\n  }\n  if (!isZero) {\n    result = input2 ^ input4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = input2 == input4;\n    }\n    isNegative = -1 < (int)result && input4 <= input2;\n    if (isZero) {\n      isNegative = input3 <= input1;\n    }\n    input4 = (int)input4 >> 0x1f;\n    if (!isNegative) {\n      input4 = ~input4;\n    }\n    return input4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008f4": "check_parameters_080008f4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_equality_080008fc",
            "code": "\nuint checkEquality_080008fc(uint value_1,uint value_2,uint value_3,uint value_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isNegative;\n  \n  if (((int)(value_2 << 1) >> 0x15 == -1 || (int)(value_4 << 1) >> 0x15 == -1) &&\n     ((((int)(value_2 << 1) >> 0x15 == -1 && ((value_1 | value_2 << 0xc) != 0)) ||\n      (((int)(value_4 << 1) >> 0x15 == -1 && ((value_3 | value_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (value_1 | value_2 << 1) == 0;\n  if (isZero) {\n    isZero = (value_3 | value_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = value_2 == value_4;\n  }\n  if (isZero) {\n    isZero = value_1 == value_3;\n  }\n  if (!isZero) {\n    result = value_2 ^ value_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = value_2 == value_4;\n    }\n    isNegative = -1 < (int)result && value_4 <= value_2;\n    if (isZero) {\n      isNegative = value_3 <= value_1;\n    }\n    value_4 = (int)value_4 >> 0x1f;\n    if (!isNegative) {\n      value_4 = ~value_4;\n    }\n    return value_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_equality_080008fc",
                "param_1": "value_1",
                "param_2": "value_2",
                "param_3": "value_3",
                "param_4": "value_4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isNegative"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_floating_point_values_08000978",
            "code": "\nvoid compareFloatingPointValues_08000978(undefined4 value1,undefined4 value2,undefined4 compareValue1,undefined4 compareValue2)\n\n{\n  __aeabi_cdcmpeq(compareValue1,compareValue2,value1,value2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_floating_point_values_08000978",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "compareValue1",
                "param_4": "compareValue2"
            },
            "calling": [
                "__aeabi_dcmpgt",
                "__aeabi_dcmpge"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "float_conversion_08000988",
            "code": "\nundefined4 float_conversion_08000988(undefined4 input_value)\n\n{\n  __nedf2();\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_08000988": "float_conversion_08000988",
                "param_1": "input_value"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_cdrcmple",
                "__aeabi_dcmple",
                "__aeabi_dcmplt"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_if_not_equal_to_zero_08000998",
            "code": "\nbool check_if_not_equal_to_zero_08000998(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdcmpeq();\n  return input_char != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_if_not_equal_to_zero_08000998",
                "in_ZR": "input_char"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_if_zero_080009ac",
            "code": "\nbool check_if_zero_080009ac(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_if_zero_080009ac",
                "in_CY": "input_char"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_equality_or_zero_080009c0",
            "code": "\nbool check_equality_or_zero_080009c0(void)\n\n{\n  undefined is_zero;\n  undefined is_equal;\n  \n  __aeabi_cdcmpeq();\n  return !(bool)is_equal || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_equality_or_zero_080009c0",
                "in_ZR": "is_zero",
                "in_CY": "is_equal"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "check_condition_080009d4",
            "code": "\nbool check_condition_080009d4(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "check_condition_080009d4",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "check_if_char_is_null_080009e8",
            "code": "\nbool checkIfCharIsNull_080009e8(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdrcmple();\n  return inputChar == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "check_if_char_is_null_080009e8",
                "in_CY": "inputChar"
            },
            "calling": [
                "_svfprintf_r",
                "atan",
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_floating_point_080009fc",
            "code": "\nuint calculateFloatingPoint_080009fc(uint number1,uint number2)\n\n{\n  uint result;\n  uint multipliedValue;\n  uint adjustedValue;\n  uint tempValue;\n  bool isZero;\n  bool isLessThanThreshold;\n  \n  multipliedValue = number2 * 2;\n  isLessThanThreshold = multipliedValue < 0x70000000;\n  adjustedValue = multipliedValue + 0x90000000;\n  result = adjustedValue;\n  if (!isLessThanThreshold) {\n    tempValue = multipliedValue + 0x8fe00000;\n    result = tempValue;\n  }\n  isZero = result == 0;\n  if (!isLessThanThreshold && adjustedValue >= 0x200000) {\n    isZero = tempValue == 0x1fc00000;\n  }\n  if (((isLessThanThreshold || adjustedValue < 0x200000) || 0x1fc00000 < tempValue) || isZero) {\n    if ((number2 & 0x40000000) != 0) {\n      if (((int)multipliedValue >> 0x15 == -1) && ((number1 | number2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return number2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(multipliedValue + 0x92e00000) < 0 != SCARRY4(adjustedValue,0x2e00000)) {\n      return number2 & 0x80000000;\n    }\n    multipliedValue = 0x18 - (multipliedValue + 0x92e00000 >> 0x15);\n    result = number1 >> (multipliedValue & 0xff);\n    if (number1 << (0x20 - multipliedValue & 0xff) != 0) {\n      result = result | 1;\n    }\n    adjustedValue = number2 & 0x1fffff | 0x100000;\n    number1 = result | adjustedValue << (0x20 - multipliedValue & 0xff);\n    adjustedValue = (adjustedValue >> (multipliedValue & 0xff)) << 1;\n  }\n  result = (number2 & 0x80000000 | number1 >> 0x1d) + adjustedValue * 4 + (uint)(0x7fffffff < number1 * 8);\n  if (number1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_floating_point_080009fc",
                "param_1": "number1",
                "param_2": "number2",
                "uVar1": "result",
                "uVar2": "multipliedValue",
                "uVar3": "adjustedValue",
                "in_r12": "tempValue",
                "bVar4": "isZero",
                "bVar5": "isLessThanThreshold"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a9c": {
            "entrypoint": "0x08000a9c",
            "current_name": "remove_sign_bit_08000a9c",
            "code": "\nvoid removeSignBit_08000a9c(uint inputValue)\n\n{\n  __addsf3(inputValue ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000a9c": "remove_sign_bit_08000a9c",
                "param_1": "inputValue"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_float_bits_08000aa4",
            "code": "\nuint calculate_float_bits_08000aa4(uint float_input,uint bits_input,undefined4 undefined_value,uint bits_output)\n\n{\n  int shift_value;\n  int shift_value_2;\n  uint float_xor;\n  uint temporary_value;\n  uint float_left_shift;\n  uint shift_counter;\n  uint shift_difference;\n  bool boolean_value;\n  \n  float_xor = bits_input ^ 0x80000000;\n  float_left_shift = float_input << 1;\n  boolean_value = float_left_shift == 0;\n  if (!boolean_value) {\n    bits_output = bits_input << 1;\n    boolean_value = bits_output == 0;\n  }\n  if (!boolean_value) {\n    boolean_value = float_left_shift == bits_output;\n  }\n  shift_value = (int)float_left_shift >> 0x18;\n  if (!boolean_value) {\n    boolean_value = shift_value == -1;\n  }\n  if (!boolean_value) {\n    boolean_value = (int)bits_output >> 0x18 == -1;\n  }\n  if (boolean_value) {\n    shift_value_2 = (int)(bits_input << 1) >> 0x18;\n    if (shift_value == -1 || shift_value_2 == -1) {\n      float_left_shift = float_xor;\n      if (shift_value == -1) {\n        float_left_shift = float_input;\n      }\n      if (shift_value != -1 || shift_value_2 != -1) {\n        float_xor = float_left_shift;\n      }\n      boolean_value = (float_left_shift & 0x7fffff) == 0;\n      if (boolean_value) {\n        boolean_value = (float_xor & 0x7fffff) == 0;\n      }\n      if (boolean_value) {\n        boolean_value = float_left_shift == float_xor;\n      }\n      if (!boolean_value) {\n        float_left_shift = float_left_shift | 0x400000;\n      }\n      return float_left_shift;\n    }\n    if (((float_input ^ float_xor) & 0x7fffffff) != 0) {\n      if (float_left_shift == 0) {\n        float_input = float_xor;\n      }\n      return float_input;\n    }\n    if (float_input != float_xor) {\n      return 0;\n    }\n    if ((float_left_shift & 0xff000000) == 0) {\n      float_xor = float_input << 1;\n      if ((float_input & 0x80000000) != 0) {\n        float_xor = float_xor | 0x80000000;\n      }\n      return float_xor;\n    }\n    if (float_left_shift < 0xfe000000) {\n      return float_input + 0x800000;\n    }\n    float_input = float_input & 0x80000000;\nLAB_08000bde:\n    return float_input | 0x7f800000;\n  }\n  float_left_shift = float_left_shift >> 0x18;\n  bits_output = bits_output >> 0x18;\n  shift_difference = bits_output - float_left_shift;\n  boolean_value = shift_difference != 0;\n  shift_counter = float_left_shift;\n  if (boolean_value && float_left_shift <= bits_output) {\n    shift_counter = float_left_shift + shift_difference;\n  }\n  if (boolean_value && float_left_shift <= bits_output) {\n    float_xor = float_xor ^ float_input;\n  }\n  if (boolean_value && float_left_shift <= bits_output) {\n    float_input = float_input ^ float_xor;\n  }\n  if (boolean_value && float_left_shift <= bits_output) {\n    float_xor = float_xor ^ float_input;\n  }\n  if (bits_output < float_left_shift) {\n    shift_difference = -shift_difference;\n  }\n  if (0x19 < shift_difference) {\n    return float_input;\n  }\n  float_left_shift = float_input & 0xffffff | 0x800000;\n  if ((float_input & 0x80000000) != 0) {\n    float_left_shift = -float_left_shift;\n  }\n  temporary_value = float_xor & 0xffffff | 0x800000;\n  if ((float_xor & 0x80000000) != 0) {\n    temporary_value = -temporary_value;\n  }\n  if (shift_counter == shift_difference) {\n    temporary_value = temporary_value ^ 0x800000;\n    if (shift_counter == 0) {\n      float_left_shift = float_left_shift ^ 0x800000;\n      shift_counter = 1;\n    }\n    else {\n      shift_difference = shift_difference - 1;\n    }\n  }\n  float_left_shift = float_left_shift + ((int)temporary_value >> (shift_difference & 0xff));\n  temporary_value = temporary_value << (0x20 - shift_difference & 0xff);\n  float_input = float_left_shift & 0x80000000;\n  if ((int)float_left_shift < 0) {\n    boolean_value = temporary_value != 0;\n    temporary_value = -temporary_value;\n    float_left_shift = -float_left_shift - (uint)boolean_value;\n  }\n  if (float_left_shift < 0x800000) {\n    float_xor = temporary_value & 0x80000000;\n    temporary_value = temporary_value << 1;\n    float_left_shift = float_left_shift * 2 + (uint)(float_xor != 0);\n    float_xor = shift_counter - 2;\n    if ((float_left_shift & 0x800000) == 0) {\n      shift_difference = leading_zeros_count(float_left_shift) - 8;\n      float_left_shift = float_left_shift << (shift_difference & 0xff);\n      if ((int)float_xor < (int)shift_difference) {\n        float_left_shift = float_left_shift >> (-(float_xor - shift_difference) & 0xff);\n      }\n      else {\n        float_left_shift = float_left_shift + (float_xor - shift_difference) * 0x800000;\n      }\n      return float_left_shift | float_input;\n    }\n  }\n  else {\n    float_xor = shift_counter - 1;\n    if (0xffffff < float_left_shift) {\n      float_xor = float_left_shift & 1;\n      float_left_shift = float_left_shift >> 1;\n      temporary_value = (uint)(float_xor != 0) << 0x1f | temporary_value >> 1;\n      float_xor = shift_counter;\n      if (0xfd < shift_counter) goto LAB_08000bde;\n    }\n  }\n  float_left_shift = float_left_shift + float_xor * 0x800000 + (uint)(0x7fffffff < temporary_value);\n  if (temporary_value == 0x80000000) {\n    float_left_shift = float_left_shift & 0xfffffffe;\n  }\n  return float_left_shift | float_input;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_float_bits_08000aa4",
                "param_1": "float_input",
                "param_2": "bits_input",
                "param_3": "undefined_value",
                "param_4": "bits_output",
                "iVar1": "shift_value",
                "iVar2": "shift_value_2",
                "uVar3": "float_xor",
                "uVar4": "temporary_value",
                "uVar5": "float_left_shift",
                "uVar6": "shift_counter",
                "uVar7": "shift_difference",
                "bVar8": "boolean_value",
                "LZCOUNT": "leading_zeros_count"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_floating_point_08000aa8",
            "code": "\nuint calculateFloatingPoint_08000aa8(uint input1,uint input2,undefined4 constant1,uint constant2)\n\n{\n  int shift1;\n  int shift2;\n  uint normalizedInput1;\n  uint normalizedInput2;\n  uint temp1;\n  uint temp2;\n  bool isEqual;\n  \n  normalizedInput2 = input1 << 1;\n  isEqual = normalizedInput2 == 0;\n  if (!isEqual) {\n    constant2 = input2 << 1;\n    isEqual = constant2 == 0;\n  }\n  if (!isEqual) {\n    isEqual = normalizedInput2 == constant2;\n  }\n  shift1 = (int)normalizedInput2 >> 0x18;\n  if (!isEqual) {\n    isEqual = shift1 == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)constant2 >> 0x18 == -1;\n  }\n  if (isEqual) {\n    shift2 = (int)(input2 << 1) >> 0x18;\n    if (shift1 == -1 || shift2 == -1) {\n      normalizedInput2 = input2;\n      if (shift1 == -1) {\n        normalizedInput2 = input1;\n      }\n      if (shift1 != -1 || shift2 != -1) {\n        input2 = normalizedInput2;\n      }\n      isEqual = (normalizedInput2 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (input2 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = normalizedInput2 == input2;\n      }\n      if (!isEqual) {\n        normalizedInput2 = normalizedInput2 | 0x400000;\n      }\n      return normalizedInput2;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (normalizedInput2 == 0) {\n        input1 = input2;\n      }\n      return input1;\n    }\n    if (input1 != input2) {\n      return 0;\n    }\n    if ((normalizedInput2 & 0xff000000) == 0) {\n      normalizedInput2 = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        normalizedInput2 = normalizedInput2 | 0x80000000;\n      }\n      return normalizedInput2;\n    }\n    if (normalizedInput2 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08000bde:\n    return input1 | 0x7f800000;\n  }\n  normalizedInput2 = normalizedInput2 >> 0x18;\n  constant2 = constant2 >> 0x18;\n  temp2 = constant2 - normalizedInput2;\n  isEqual = temp2 != 0;\n  temp1 = normalizedInput2;\n  if (isEqual && normalizedInput2 <= constant2) {\n    temp1 = normalizedInput2 + temp2;\n  }\n  if (isEqual && normalizedInput2 <= constant2) {\n    input2 = input2 ^ input1;\n  }\n  if (isEqual && normalizedInput2 <= constant2) {\n    input1 = input1 ^ input2;\n  }\n  if (isEqual && normalizedInput2 <= constant2) {\n    input2 = input2 ^ input1;\n  }\n  if (constant2 < normalizedInput2) {\n    temp2 = -temp2;\n  }\n  if (0x19 < temp2) {\n    return input1;\n  }\n  normalizedInput2 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    normalizedInput2 = -normalizedInput2;\n  }\n  normalizedInput1 = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    normalizedInput1 = -normalizedInput1;\n  }\n  if (temp1 == temp2) {\n    normalizedInput1 = normalizedInput1 ^ 0x800000;\n    if (temp1 == 0) {\n      normalizedInput2 = normalizedInput2 ^ 0x800000;\n      temp1 = 1;\n    }\n    else {\n      temp2 = temp2 - 1;\n    }\n  }\n  normalizedInput2 = normalizedInput2 + ((int)normalizedInput1 >> (temp2 & 0xff));\n  normalizedInput1 = normalizedInput1 << (0x20 - temp2 & 0xff);\n  input1 = normalizedInput2 & 0x80000000;\n  if ((int)normalizedInput2 < 0) {\n    isEqual = normalizedInput1 != 0;\n    normalizedInput1 = -normalizedInput1;\n    normalizedInput2 = -normalizedInput2 - (uint)isEqual;\n  }\n  if (normalizedInput2 < 0x800000) {\n    temp2 = normalizedInput1 & 0x80000000;\n    normalizedInput1 = normalizedInput1 << 1;\n    normalizedInput2 = normalizedInput2 * 2 + (uint)(temp2 != 0);\n    temp2 = temp1 - 2;\n    if ((normalizedInput2 & 0x800000) == 0) {\n      temp1 = leadingZeroCount(normalizedInput2) - 8;\n      normalizedInput2 = normalizedInput2 << (temp1 & 0xff);\n      if ((int)temp2 < (int)temp1) {\n        normalizedInput2 = normalizedInput2 >> (-(temp2 - temp1) & 0xff);\n      }\n      else {\n        normalizedInput2 = normalizedInput2 + (temp2 - temp1) * 0x800000;\n      }\n      return normalizedInput2 | input1;\n    }\n  }\n  else {\n    temp2 = temp1 - 1;\n    if (0xffffff < normalizedInput2) {\n      temp2 = normalizedInput2 & 1;\n      normalizedInput2 = normalizedInput2 >> 1;\n      normalizedInput1 = (uint)(temp2 != 0) << 0x1f | normalizedInput1 >> 1;\n      temp2 = temp1;\n      if (0xfd < temp1) goto LAB_08000bde;\n    }\n  }\n  normalizedInput2 = normalizedInput2 + temp2 * 0x800000 + (uint)(0x7fffffff < normalizedInput1);\n  if (normalizedInput1 == 0x80000000) {\n    normalizedInput2 = normalizedInput2 & 0xfffffffe;\n  }\n  return normalizedInput2 | input1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_floating_point_08000aa8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "constant1",
                "param_4": "constant2",
                "iVar1": "shift1",
                "iVar2": "shift2",
                "uVar3": "normalizedInput1",
                "uVar4": "normalizedInput2",
                "uVar5": "temp1",
                "uVar6": "temp2",
                "bVar7": "isEqual",
                "LZCOUNT": "leadingZeroCount"
            },
            "calling": [
                "__aeabi_frsub",
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_checksum_08000c08",
            "code": "\nuint calculateChecksum_08000c08(uint inputValue)\n\n{\n  uint leadingZerosCount;\n  uint shiftCount;\n  int magicNumber;\n  uint tempValue;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZerosCount = LZCOUNT(inputValue);\n  shiftCount = leadingZerosCount - 8;\n  magicNumber = shiftCount * -0x800000 + 0x4a800000;\n  if (7 < leadingZerosCount) {\n    tempValue = 0 << (shiftCount & 0xff);\n    leadingZerosCount = magicNumber + (inputValue << (shiftCount & 0xff)) +\n            (0U >> (0x20 - shiftCount & 0xff)) + (uint)(0x7fffffff < tempValue);\n    if (tempValue == 0x80000000) {\n      leadingZerosCount = leadingZerosCount & 0xfffffffe;\n    }\n    return leadingZerosCount;\n  }\n  shiftCount = inputValue << leadingZerosCount + 0x18;\n  leadingZerosCount = magicNumber + ((inputValue >> (0x20 - (leadingZerosCount + 0x18) & 0xff)) - ((int)shiftCount >> 0x1f));\n  if ((shiftCount & 0x7fffffff) == 0) {\n    leadingZerosCount = leadingZerosCount & ~(shiftCount >> 0x1f);\n  }\n  return leadingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_checksum_08000c08",
                "param_1": "inputValue",
                "uVar1": "leadingZerosCount",
                "uVar2": "shiftCount",
                "iVar3": "magicNumber",
                "uVar4": "tempValue"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "calculate_modified_value_08000c10",
            "code": "\nuint calculateModifiedValue_08000c10(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  uint isNegative;\n  int adjustedValue;\n  \n  isNegative = inputValue & 0x80000000;\n  if ((int)isNegative < 0) {\n    inputValue = -inputValue;\n  }\n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftAmount = leadingZeros - 8;\n  adjustedValue = ((isNegative | 0x4b000000) - 0x800000) + shiftAmount * -0x800000;\n  if (7 < leadingZeros) {\n    leadingZeros = 0 << (shiftAmount & 0xff);\n    isNegative = adjustedValue + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeros);\n    if (leadingZeros == 0x80000000) {\n      isNegative = isNegative & 0xfffffffe;\n    }\n    return isNegative;\n  }\n  shiftAmount = inputValue << leadingZeros + 0x18;\n  isNegative = adjustedValue + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    isNegative = isNegative & ~(shiftAmount >> 0x1f);\n  }\n  return isNegative;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "calculate_modified_value_08000c10",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "uVar3": "isNegative",
                "iVar4": "adjustedValue"
            },
            "calling": [
                "mpu6050_update",
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c2c": {
            "entrypoint": "0x08000c2c",
            "current_name": "apply_bitwise_operations_08000c2c",
            "code": "\nuint applyBitwiseOperations_08000c2c(uint input1,uint input2)\n\n{\n  uint tempInput1;\n  uint tempInput2;\n  uint shiftCount;\n  uint shiftAmount;\n  int constant;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  tempInput1 = input1;\n  tempInput2 = input2;\n  if (input2 == 0) {\n    tempInput1 = 0;\n    tempInput2 = input1;\n  }\n  constant = 0x5b000000;\n  if (input2 == 0) {\n    constant = 0x4b000000;\n  }\n  shiftCount = getLeadingZeroesCount(tempInput2);\n  shiftAmount = shiftCount - 8;\n  constant = constant + -0x800000 + shiftAmount * -0x800000;\n  if (shiftCount < 8) {\n    shiftAmount = tempInput2 << shiftCount + 0x18;\n    tempInput2 = constant + ((tempInput2 >> (0x20 - (shiftCount + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n    if ((tempInput1 | shiftAmount << 1) == 0) {\n      tempInput2 = tempInput2 & ~(shiftAmount >> 0x1f);\n    }\n    return tempInput2;\n  }\n  shiftCount = tempInput1 << (shiftAmount & 0xff);\n  tempInput2 = constant + (tempInput2 << (shiftAmount & 0xff)) +\n          (tempInput1 >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < shiftCount);\n  if (shiftCount == 0x80000000) {\n    tempInput2 = tempInput2 & 0xfffffffe;\n  }\n  return tempInput2;\n}\n\n",
            "renaming": {
                "FUN_08000c2c": "apply_bitwise_operations_08000c2c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "tempInput1",
                "uVar2": "tempInput2",
                "uVar3": "shiftCount",
                "uVar4": "shiftAmount",
                "iVar5": "constant",
                "LZCOUNT": "getLeadingZeroesCount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c3c": {
            "entrypoint": "0x08000c3c",
            "current_name": "calculate_result_08000c3c",
            "code": "\nuint calculateResult_08000c3c(uint input1,uint input2)\n\n{\n  uint result1;\n  uint result2;\n  uint count;\n  uint shift;\n  uint mask;\n  int offset;\n  bool isNegative;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  mask = input2 & 0x80000000;\n  if ((int)mask < 0) {\n    isNegative = input1 != 0;\n    input1 = -input1;\n    input2 = -input2 - (uint)isNegative;\n  }\n  result2 = input1;\n  result1 = input2;\n  if (input2 == 0) {\n    result2 = 0;\n    result1 = input1;\n  }\n  mask = mask | 0x5b000000;\n  if (input2 == 0) {\n    mask = mask + 0xf0000000;\n  }\n  count = LZCOUNT(result1);\n  shift = count - 8;\n  offset = (mask - 0x800000) + shift * -0x800000;\n  if (count < 8) {\n    shift = result1 << count + 0x18;\n    mask = offset + ((result1 >> (0x20 - (count + 0x18) & 0xff)) - ((int)shift >> 0x1f));\n    if ((result2 | shift << 1) == 0) {\n      mask = mask & ~(shift >> 0x1f);\n    }\n    return mask;\n  }\n  count = result2 << (shift & 0xff);\n  mask = offset + (result1 << (shift & 0xff)) +\n          (result2 >> (0x20 - shift & 0xff)) + (uint)(0x7fffffff < count);\n  if (count == 0x80000000) {\n    mask = mask & 0xfffffffe;\n  }\n  return mask;\n}\n\n",
            "renaming": {
                "FUN_08000c3c": "calculate_result_08000c3c",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "count",
                "uVar4": "shift",
                "uVar5": "mask",
                "iVar6": "offset",
                "bVar7": "isNegative"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_float_08000cb8",
            "code": "\nuint calculateFloat_08000cb8(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  longlong result;\n  uint result32;\n  uint shiftCount1;\n  int sum;\n  int difference;\n  uint product;\n  int difference2;\n  uint tempResult;\n  bool isZero;\n  bool carry;\n  \n  shiftCount1 = input1 >> 0x17 & 0xff;\n  isZero = shiftCount1 == 0;\n  if (!isZero) {\n    input4 = input2 >> 0x17 & 0xff;\n    isZero = input4 == 0;\n  }\n  if (!isZero) {\n    isZero = shiftCount1 == 0xff;\n  }\n  if (!isZero) {\n    isZero = input4 == 0xff;\n  }\n  if (isZero) {\n    input4 = input2 >> 0x17 & 0xff;\n    if (shiftCount1 == 0xff || input4 == 0xff) {\n      isZero = input1 == 0 || input1 == 0x80000000;\n      result32 = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        isZero = input2 == 0;\n        result32 = input1;\n      }\n      if (!isZero) {\n        isZero = input2 == 0x80000000;\n      }\n      tempResult = result32;\n      if (((isZero) || ((shiftCount1 == 0xff && ((result32 & 0x7fffff) != 0)))) ||\n         ((input4 == 0xff && (tempResult = input2, (input2 & 0x7fffff) != 0)))) {\n        return tempResult | 0x7fc00000;\n      }\n      result32 = result32 ^ input2;\n      goto LAB_08000e08;\n    }\n    isZero = (input1 & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (input2 & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    isZero = shiftCount1 == 0;\n    result32 = input1 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input1 = input1 << 1;\n        isZero = (input1 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      shiftCount1 = shiftCount1 - 1;\n    }\n    input1 = input1 | result32;\n    isZero = input4 == 0;\n    result32 = input2 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        input2 = input2 << 1;\n        isZero = (input2 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      input4 = input4 - 1;\n    }\n    input2 = input2 | result32;\n  }\n  sum = shiftCount1 + input4;\n  tempResult = input1 ^ input2;\n  shiftCount1 = input1 << 9;\n  isZero = shiftCount1 == 0;\n  if (!isZero) {\n    input2 = input2 << 9;\n    isZero = input2 == 0;\n  }\n  if (isZero) {\n    if (shiftCount1 == 0) {\n      input2 = input2 << 9;\n    }\n    result32 = tempResult & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    carry = subtractWithBorrow(sum,0x7f);\n    difference = sum + -0x7f;\n    isZero = difference == 0;\n    difference2 = difference;\n    if (!isZero && 0x7e < sum) {\n      carry = subtractWithBorrow(0xff,difference);\n      difference2 = 0xff - difference;\n      isZero = difference == 0xff;\n    }\n    if (!isZero && difference2 < 0 == carry) {\n      result32 = result32 | difference * 0x800000;\n    }\n    if (!isZero && difference2 < 0 == carry) {\n      return result32;\n    }\n    result32 = result32 | 0x800000;\n    product = 0;\n    carry = subtractWithBorrow(difference,1);\n    tempResult = sum - 0x80;\n    isZero = tempResult == 0;\n    shiftCount1 = tempResult;\n  }\n  else {\n    result = (ulonglong)(shiftCount1 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    product = (uint)result;\n    result32 = (uint)((ulonglong)result >> 0x20);\n    isZero = result32 < 0x800000;\n    if (isZero) {\n      result32 = result32 << 1;\n    }\n    if (isZero) {\n      result32 = result32 | product >> 0x1f;\n      product = product << 1;\n    }\n    result32 = tempResult & 0x80000000 | result32;\n    tempResult = (sum + -0x7f) - (uint)isZero;\n    carry = subtractWithBorrow(tempResult,0xfd);\n    isZero = tempResult == 0xfd;\n    shiftCount1 = tempResult - 0xfd;\n    if (tempResult < 0xfe) {\n      result32 = result32 + tempResult * 0x800000 + (uint)(0x7fffffff < product);\n      if (product == 0x80000000) {\n        result32 = result32 & 0xfffffffe;\n      }\n      return result32;\n    }\n  }\n  if (isZero || (int)shiftCount1 < 0 != carry) {\n    isZero = (int)(tempResult + 0x19) < 0;\n    if (tempResult == 0xffffffe7 || isZero != subtractWithCarry(tempResult,0x19)) {\n      result32 = result32 & 0x80000000;\n    }\n    if (tempResult != 0xffffffe7 && isZero == subtractWithCarry(tempResult,0x19)) {\n      shiftCount1 = (result32 << 1) >> (-tempResult & 0xff);\n      tempResult = result32 << (tempResult + 0x20 & 0xff);\n      shiftCount1 = ((uint)((result32 & 0x80000000) != 0) << 0x1f | shiftCount1 >> 1) + (uint)((byte)shiftCount1 & 1);\n      if ((product | tempResult << 1) == 0) {\n        shiftCount1 = shiftCount1 & ~(tempResult >> 0x1f);\n      }\n      return shiftCount1;\n    }\n    return result32;\n  }\nLAB_08000e08:\n  return result32 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_float_08000cb8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "lVar1": "result",
                "uVar2": "result32",
                "uVar3": "shiftCount1",
                "iVar4": "sum",
                "iVar5": "difference",
                "uVar6": "product",
                "iVar7": "difference2",
                "uVar8": "tempResult",
                "bVar9": "isZero",
                "bVar10": "carry",
                "SBORROW4": "subtractWithBorrow",
                "SCARRY4": "subtractWithCarry"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "calculate_float_08000e20",
            "code": "\nuint calculate_float_08000e20(uint float1,uint float2,undefined4 param3,uint float3)\n\n{\n  uint bit_result;\n  uint exponent1;\n  int exponent_diff;\n  uint exponent2;\n  int adjusted_exponent;\n  uint result;\n  bool condition;\n  bool condition2;\n  bool carry_flag;\n  \n  exponent1 = float1 >> 0x17 & 0xff;\n  condition = exponent1 == 0;\n  if (!condition) {\n    float3 = float2 >> 0x17 & 0xff;\n    condition = float3 == 0;\n  }\n  if (!condition) {\n    condition = exponent1 == 0xff;\n  }\n  if (!condition) {\n    condition = float3 == 0xff;\n  }\n  if (condition) {\n    float3 = float2 >> 0x17 & 0xff;\n    result = float1;\n    if (exponent1 == 0xff) {\n      if (((float1 & 0x7fffff) != 0) || (result = float2, float3 == 0xff)) {\nLAB_08000e16:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (float3 == 0xff) {\n        result = float2;\n        if ((float2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (float1 ^ float2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      condition = (float1 & 0x7fffffff) == 0;\n      if (!condition) {\n        condition = (float2 & 0x7fffffff) == 0;\n      }\n      if (!condition) {\n        condition = exponent1 == 0;\n        result = float1 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float1 = float1 << 1;\n            condition = (float1 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          exponent1 = exponent1 - 1;\n        }\n        float1 = float1 | result;\n        condition = float3 == 0;\n        result = float2 & 0x80000000;\n        while( true ) {\n          if (condition) {\n            float2 = float2 << 1;\n            condition = (float2 & 0x800000) == 0;\n          }\n          if (!condition) break;\n          float3 = float3 - 1;\n        }\n        float2 = float2 | result;\n        goto LAB_08000e38;\n      }\n      if ((float1 & 0x7fffffff) == 0) {\n        if ((float2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    float1 = float1 ^ float2;\n  }\n  else {\nLAB_08000e38:\n    exponent_diff = exponent1 - float3;\n    if (float2 << 9 == 0) {\n      float1 = (float1 ^ float2) & 0x80000000 | float1 & 0x7fffff;\n      carry_flag = SCARRY4(exponent_diff,0x7f);\n      adjusted_exponent = exponent_diff + 0x7f;\n      condition = adjusted_exponent < 0;\n      condition2 = adjusted_exponent == 0;\n      if (!condition2 && condition == carry_flag) {\n        carry_flag = SBORROW4(0xff,adjusted_exponent);\n        condition = 0xff - adjusted_exponent < 0;\n        condition2 = adjusted_exponent == 0xff;\n      }\n      if (!condition2 && condition == carry_flag) {\n        float1 = float1 | adjusted_exponent * 0x800000;\n      }\n      if (!condition2 && condition == carry_flag) {\n        return float1;\n      }\n      float1 = float1 | 0x800000;\n      exponent1 = 0;\n      condition2 = SBORROW4(adjusted_exponent,1);\n      exponent2 = exponent_diff + 0x7e;\n      condition = exponent2 == 0;\n      result = exponent2;\n    }\n    else {\n      bit_result = (float2 << 9) >> 4 | 0x10000000;\n      exponent1 = (float1 << 9) >> 4 | 0x10000000;\n      float1 = (float1 ^ float2) & 0x80000000;\n      condition = bit_result <= exponent1;\n      if (!condition) {\n        exponent1 = exponent1 << 1;\n      }\n      exponent2 = exponent_diff + 0x7d + (uint)condition;\n      result = 0x800000;\n      do {\n        if (bit_result <= exponent1) {\n          exponent1 = exponent1 - bit_result;\n          float1 = float1 | result;\n        }\n        condition = bit_result >> 1 <= exponent1;\n        if (condition) {\n          exponent1 = exponent1 - (bit_result >> 1);\n        }\n        if (condition) {\n          float1 = float1 | result >> 1;\n        }\n        condition = bit_result >> 2 <= exponent1;\n        if (condition) {\n          exponent1 = exponent1 - (bit_result >> 2);\n        }\n        if (condition) {\n          float1 = float1 | result >> 2;\n        }\n        condition = bit_result >> 3 <= exponent1;\n        if (condition) {\n          exponent1 = exponent1 - (bit_result >> 3);\n        }\n        if (condition) {\n          float1 = float1 | result >> 3;\n        }\n        exponent1 = exponent1 * 0x10;\n        condition = exponent1 == 0;\n        if (!condition) {\n          result = result >> 4;\n          condition = result == 0;\n        }\n      } while (!condition);\n      condition2 = SBORROW4(exponent2,0xfd);\n      condition = exponent2 == 0xfd;\n      result = exponent2 - 0xfd;\n      if (exponent2 < 0xfe) {\n        float1 = float1 + exponent2 * 0x800000 + (uint)(bit_result <= exponent1);\n        if (exponent1 - bit_result == 0) {\n          float1 = float1 & 0xfffffffe;\n        }\n        return float1;\n      }\n    }\n    if (condition || (int)result < 0 != condition2) {\n      condition = (int)(exponent2 + 0x19) < 0;\n      if (exponent2 == 0xffffffe7 || condition != SCARRY4(exponent2,0x19)) {\n        float1 = float1 & 0x80000000;\n      }\n      if (exponent2 == 0xffffffe7 || condition != SCARRY4(exponent2,0x19)) {\n        return float1;\n      }\n      result = (float1 << 1) >> (-exponent2 & 0xff);\n      exponent2 = float1 << (exponent2 + 0x20 & 0xff);\n      result = ((uint)((float1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((exponent1 | exponent2 << 1) == 0) {\n        result = result & ~(exponent2 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return float1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "calculate_float_08000e20",
                "param_1": "float1",
                "param_2": "float2",
                "param_3": "param3",
                "param_4": "float3",
                "uVar1": "bit_result",
                "uVar2": "exponent1",
                "iVar3": "exponent_diff",
                "uVar4": "exponent2",
                "iVar5": "adjusted_exponent",
                "uVar6": "result",
                "bVar7": "condition",
                "bVar8": "condition2",
                "bVar9": "carry_flag"
            },
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f58": {
            "entrypoint": "0x08000f58",
            "current_name": "calculate_xor_shift_08000f58",
            "code": "\nuint calculate_xor_shift_08000f58(uint input_a,uint input_b)\n\n{\n  bool is_negative;\n  uint product_a;\n  uint product_b;\n  uint combined;\n  bool is_zero;\n  \n  product_a = input_a * 2;\n  product_b = input_b * 2;\n  if (((int)product_a >> 0x18 == -1 || (int)product_b >> 0x18 == -1) &&\n     ((((int)product_a >> 0x18 == -1 && ((input_a & 0x7fffff) != 0)) ||\n      (((int)product_b >> 0x18 == -1 && ((input_b & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined = product_a | input_b & 0x7fffffff;\n  is_zero = combined == 0;\n  if (!is_zero) {\n    combined = input_a ^ input_b;\n    is_zero = combined == 0;\n  }\n  is_negative = -1 < (int)combined;\n  if (is_negative) {\n    input_a = product_a + input_b * -2;\n    is_zero = input_a == 0;\n  }\n  if ((is_negative && product_b <= product_a) && !is_zero) {\n    input_a = (int)input_b >> 0x1f;\n  }\n  if (!is_negative || product_b > product_a) {\n    input_a = ~((int)input_b >> 0x1f);\n  }\n  if (!is_zero) {\n    input_a = input_a | 1;\n  }\n  return input_a;\n}\n\n",
            "renaming": {
                "FUN_08000f58": "calculate_xor_shift_08000f58",
                "param_1": "input_a",
                "param_2": "input_b",
                "uVar2": "product_a",
                "uVar3": "product_b",
                "uVar4": "combined",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f60": {
            "entrypoint": "0x08000f60",
            "current_name": "validate_numbers_08000f60",
            "code": "\nuint validate_numbers_08000f60(uint input_1,uint input_2)\n\n{\n  bool is_negative;\n  uint double_input_1;\n  uint double_input_2;\n  uint combined_double_inputs;\n  bool is_zero;\n  \n  double_input_1 = input_1 * 2;\n  double_input_2 = input_2 * 2;\n  if (((int)double_input_1 >> 0x18 == -1 || (int)double_input_2 >> 0x18 == -1) &&\n     ((((int)double_input_1 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)double_input_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    result 1;\n  }\n  combined_double_inputs = double_input_1 | input_2 & 0x7fffffff;\n  is_zero = combined_double_inputs == 0;\n  if (!is_zero) {\n    combined_double_inputs = input_1 ^ input_2;\n    is_zero = combined_double_inputs == 0;\n  }\n  is_negative = -1 < (int)combined_double_inputs;\n  if (is_negative) {\n    input_1 = double_input_1 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_negative && double_input_2 <= double_input_1) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative || double_input_2 > double_input_1) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  result input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f60": "validate_numbers_08000f60",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "double_input_1",
                "uVar3": "double_input_2",
                "uVar4": "combined_double_inputs",
                "bVar1": "is_negative",
                "bVar5": "is_zero",
                "return": "result"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "check_overflow_and_sign_08000f68",
            "code": "\nuint checkOverflowAndSign_08000f68(uint input1,uint input2)\n\n{\n  bool isOverflow;\n  uint input1Times2;\n  uint input2Times2;\n  uint result;\n  bool isResultZero;\n  \n  input1Times2 = input1 * 2;\n  input2Times2 = input2 * 2;\n  if (((int)input1Times2 >> 0x18 == -1 || (int)input2Times2 >> 0x18 == -1) &&\n     ((((int)input1Times2 >> 0x18 == -1 && ((input1 & 0x7fffff) != 0)) ||\n      (((int)input2Times2 >> 0x18 == -1 && ((input2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  result = input1Times2 | input2 & 0x7fffffff;\n  isResultZero = result == 0;\n  if (!isResultZero) {\n    result = input1 ^ input2;\n    isResultZero = result == 0;\n  }\n  isOverflow = -1 < (int)result;\n  if (isOverflow) {\n    input1 = input1Times2 + input2 * -2;\n    isResultZero = input1 == 0;\n  }\n  if ((isOverflow && input2Times2 <= input1Times2) && !isResultZero) {\n    input1 = (int)input2 >> 0x1f;\n  }\n  if (!isOverflow || input2Times2 > input1Times2) {\n    input1 = ~((int)input2 >> 0x1f);\n  }\n  if (!isResultZero) {\n    input1 = input1 | 1;\n  }\n  return input1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "check_overflow_and_sign_08000f68",
                "param_1": "input1",
                "param_2": "input2",
                "bVar1": "isOverflow",
                "uVar2": "input1Times2",
                "uVar3": "input2Times2",
                "uVar4": "result",
                "bVar5": "isResultZero"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "compare_floating_point_values_08000fc8",
            "code": "\nvoid compareFloatingPointValues_08000fc8(undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cfcmpeq(value2,value1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "compare_floating_point_values_08000fc8",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "combine_float_and_int_08000fd0",
            "code": "\nundefined8 combineFloatAndInt_08000fd0(undefined4 floatParam,undefined4 intParam)\n\n{\n  __cmpsf2();\n  return CONCAT44(intParam,floatParam);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "combine_float_and_int_08000fd0",
                "param_1": "floatParam",
                "param_2": "intParam"
            },
            "calling": [
                "__aeabi_fcmplt",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmpeq"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fe0": {
            "entrypoint": "0x08000fe0",
            "current_name": "check_comparison_08000fe0",
            "code": "\nbool check_comparison_08000fe0(void)\n\n{\n  char comparison_result;\n  \n  __aeabi_cfcmpeq();\n  return comparison_result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000fe0": "check_comparison_08000fe0",
                "in_ZR": "comparison_result"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "check_if_char_is_null_08000ff4",
            "code": "\nbool check_if_char_is_null_08000ff4(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "check_if_char_is_null_08000ff4",
                "in_CY": "input_char"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001008": {
            "entrypoint": "0x08001008",
            "current_name": "check_zero_comparison_08001008",
            "code": "\nbool check_zero_comparison_08001008(void)\n\n{\n  undefined is_zero;\n  undefined is_equal;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)is_equal || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_08001008": "check_zero_comparison_08001008",
                "in_ZR": "is_zero",
                "in_CY": "is_equal"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800101c": {
            "entrypoint": "0x0800101c",
            "current_name": "is_less_than_or_equal_0800101c",
            "code": "\nbool isLessThanOrEqual_0800101c(void)\n\n{\n  undefined zeroFlag;\n  undefined carryFlag;\n  \n  __aeabi_cfrcmple();\n  return !(bool)carryFlag || (bool)zeroFlag;\n}\n\n",
            "renaming": {
                "FUN_0800101c": "is_less_than_or_equal_0800101c",
                "in_ZR": "zeroFlag",
                "in_CY": "carryFlag"
            },
            "calling": [],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "is_string_empty_08001030",
            "code": "\nbool is_string_empty_08001030(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "is_string_empty_08001030",
                "in_CY": "input_char"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "decode_unsigned_integer_08001044",
            "code": "\nuint decodeUnsignedInteger_08001044(uint input)\n\n{\n  uint result;\n  \n  if (((input & 0x80000000) != 0) || (input << 1 < 0x7f000000)) {\n    return 0;\n  }\n  result = 0x9e - ((input << 1) >> 0x18);\n  if (-1 < (int)result) {\n    return (input << 8 | 0x80000000) >> (result & 0xff);\n  }\n  if ((result == 0xffffff9f) && ((input & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "decode_unsigned_integer_08001044",
                "param_1": "input",
                "uVar1": "result"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nvoid * copyMemory_08001084(void *destination,void *source,size_t length)\n\n{\n  undefined *destPtr;\n  undefined4 *destPtrTemp;\n  undefined4 *destPtrIter;\n  undefined *srcPtr;\n  undefined4 *srcPtrTemp;\n  undefined *srcPtrIter;\n  uint remainingLength;\n  uint remainingBytes;\n  bool isRemaining;\n  \n  destPtrIter = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (length < 8) {\n      remainingBytes = length - 4;\n      destPtr = (undefined *)destination;\n      if (3 < length) {\n        do {\n          srcPtrIter = (undefined *)source;\n          srcPtr = destPtr;\n          isRemaining = remainingBytes != 0;\n          remainingBytes = remainingBytes - 1;\n          *srcPtr = *srcPtrIter;\n          destPtr = srcPtr + 1;\n          source = srcPtrIter + 1;\n        } while (isRemaining);\n        srcPtr[1] = srcPtrIter[1];\n        srcPtr[2] = srcPtrIter[2];\n        srcPtr[3] = srcPtrIter[3];\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      remainingBytes = 4 - ((uint)destination & 3);\n      length = length - remainingBytes;\n      destPtrTemp = (undefined4 *)destination;\n      srcPtrTemp = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        srcPtrTemp = (undefined4 *)((int)source + 1);\n        destPtrTemp = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      destPtrIter = destPtrTemp;\n      source = srcPtrTemp;\n      if ((remainingBytes & 2) != 0) {\n        source = (void *)((int)srcPtrTemp + 2);\n        destPtrIter = (undefined4 *)((int)destPtrTemp + 2);\n        *(undefined2 *)destPtrTemp = *(undefined2 *)srcPtrTemp;\n      }\n    }\n  }\n  while (0x3f < length) {\n                    /* WARNING: Load size is inaccurate */\n    *destPtrIter = *source;\n    destPtrIter[1] = *(undefined4 *)((int)source + 4);\n    destPtrIter[2] = *(undefined4 *)((int)source + 8);\n    destPtrIter[3] = *(undefined4 *)((int)source + 0xc);\n    destPtrIter[4] = *(undefined4 *)((int)source + 0x10);\n    destPtrIter[5] = *(undefined4 *)((int)source + 0x14);\n    destPtrIter[6] = *(undefined4 *)((int)source + 0x18);\n    destPtrIter[7] = *(undefined4 *)((int)source + 0x1c);\n    destPtrIter[8] = *(undefined4 *)((int)source + 0x20);\n    destPtrIter[9] = *(undefined4 *)((int)source + 0x24);\n    destPtrIter[10] = *(undefined4 *)((int)source + 0x28);\n    destPtrIter[0xb] = *(undefined4 *)((int)source + 0x2c);\n    destPtrIter[0xc] = *(undefined4 *)((int)source + 0x30);\n    destPtrIter[0xd] = *(undefined4 *)((int)source + 0x34);\n    destPtrIter[0xe] = *(undefined4 *)((int)source + 0x38);\n    destPtrIter[0xf] = *(undefined4 *)((int)source + 0x3c);\n    destPtrIter = destPtrIter + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    length = length - 0x40;\n  }\n  remainingLength = length - 0x10;\n  if (0xffffffcf < length - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *destPtrIter = *source;\n      destPtrIter[1] = *(undefined4 *)((int)source + 4);\n      destPtrIter[2] = *(undefined4 *)((int)source + 8);\n      destPtrIter[3] = *(undefined4 *)((int)source + 0xc);\n      destPtrIter = destPtrIter + 4;\n      source = (void *)((int)source + 0x10);\n      isRemaining = 0xf < remainingLength;\n      remainingLength = remainingLength - 0x10;\n    } while (isRemaining);\n  }\n  remainingBytes = remainingLength + 0xc;\n  srcPtrTemp = destPtrIter;\n  destPtrTemp = (undefined4 *)source;\n  if (0xfffffff3 < remainingLength) {\n    do {\n      source = destPtrTemp + 1;\n      *srcPtrTemp = *destPtrTemp;\n      isRemaining = 3 < remainingBytes;\n      remainingBytes = remainingBytes - 4;\n      destPtrIter = srcPtrTemp + 1;\n      srcPtrTemp = srcPtrTemp + 1;\n      destPtrTemp = (undefined4 *)source;\n    } while (isRemaining);\n  }\nLAB_08001108:\n  if (remainingBytes + 4 != 0) {\n    destPtrTemp = destPtrIter;\n    srcPtrTemp = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((remainingBytes & 1) != 0) {\n      srcPtrTemp = (undefined4 *)((int)source + 1);\n      destPtrTemp = (undefined4 *)((int)destPtrIter + 1);\n      *(undefined *)destPtrIter = *source;\n    }\n    if ((remainingBytes + 4 & 2) != 0) {\n      *(undefined2 *)destPtrTemp = *(undefined2 *)srcPtrTemp;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "destPtr",
                "puVar2": "destPtrTemp",
                "puVar3": "destPtrIter",
                "puVar4": "srcPtr",
                "puVar5": "srcPtrTemp",
                "puVar6": "srcPtrIter",
                "uVar7": "remainingLength",
                "uVar8": "remainingBytes",
                "bVar9": "isRemaining"
            },
            "calling": [
                "__ssprint_r",
                "_dtoa_r",
                "__multadd"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_parameters_08001170",
            "code": "\nundefined4 check_parameters_08001170(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_parameters_08001170",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_unsigned_division_0800119c",
            "code": "\nuint calculateUnsignedDivision_0800119c(uint dividend,uint divisor)\n\n{\n  uint quotient;\n  int shiftedDivisor;\n  uint remainder;\n  \n  shiftedDivisor = divisor * 2 + 0x200000;\n  if (divisor * 2 < 0xffe00000) {\n    if (-1 < shiftedDivisor) {\n      return 0;\n    }\n    quotient = shiftedDivisor >> 0x15;\n    remainder = -quotient - 0x3e1;\n    if (quotient < 0xfffffc20 && remainder != 0) {\n      quotient = (divisor << 0xb | 0x80000000 | dividend >> 0x15) >> (remainder & 0xff);\n      if ((divisor & 0x80000000) != 0) {\n        quotient = -quotient;\n      }\n      return quotient;\n    }\n  }\n  else if ((dividend | divisor << 0xc) != 0) {\n    return 0;\n  }\n  divisor = divisor & 0x80000000;\n  if (divisor == 0) {\n    divisor = 0x7fffffff;\n  }\n  return divisor;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_unsigned_division_0800119c",
                "param_1": "dividend",
                "param_2": "divisor",
                "iVar2": "shiftedDivisor",
                "uVar1": "quotient",
                "uVar3": "remainder"
            },
            "calling": [
                "_svfprintf_r",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "calculate_division_or_modulus_080011ec",
            "code": "\nvoid calculateDivisionOrModulus_080011ec(int dividend,int divisor,int quotient,int remainder)\n\n{\n  if ((remainder == 0) && (quotient == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      divisor = -1;\n      dividend = -1;\n    }\n    __aeabi_idiv0(dividend,divisor);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "calculate_division_or_modulus_080011ec",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__udivmoddi4",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_quotient_and_remainder_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculateQuotientAndRemainder_0800121c(uint dividend,uint dividend_lower,uint divisor,uint divisor_lower,uint *remainder)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  ulonglong partial_quotient;\n  uint divisor_quotient;\n  uint temp_quotient;\n  uint dividend_remainder;\n  int shift_count;\n  uint quotient;\n  uint dividend_upper;\n  uint partial_remainder;\n  uint *puVar9;\n  uint divisor_quotient2;\n  uint product1;\n  uint product2;\n  bool carry_flag;\n  undefined8 result;\n  \n  if (divisor_lower == 0) {\n    if (dividend_lower < divisor) {\n      shift_count = LZCOUNT(divisor);\n      dividend_upper = divisor;\n      if (shift_count != 0) {\n        dividend_upper = divisor << shift_count;\n        dividend_lower = dividend >> (0x20U - shift_count & 0xff) | dividend_lower << shift_count;\n        dividend = dividend << shift_count;\n      }\n      product1 = dividend_upper >> 0x10;\n      partial_remainder = dividend_lower / product1;\n      divisor_quotient2 = partial_remainder * (dividend_upper & 0xffff);\n      quotient = dividend >> 0x10 | (dividend_lower - product1 * partial_remainder) * 0x10000;\n      temp_quotient = partial_remainder;\n      if (quotient <= divisor_quotient2 && divisor_quotient2 - quotient != 0) {\n        carry_flag = CARRY4(dividend_upper,quotient);\n        quotient = dividend_upper + quotient;\n        temp_quotient = partial_remainder - 1;\n        if ((carry_flag == false) && (quotient <= divisor_quotient2 && divisor_quotient2 - quotient != 0)) {\n          temp_quotient = partial_remainder - 2;\n          quotient = quotient + dividend_upper;\n        }\n      }\n      divisor_quotient = (quotient - divisor_quotient2) / product1;\n      dividend_remainder = divisor_quotient * (dividend_upper & 0xffff);\n      partial_remainder = dividend & 0xffff | ((quotient - divisor_quotient2) - product1 * divisor_quotient) * 0x10000;\n      quotient = divisor_quotient;\n      if (partial_remainder <= dividend_remainder && dividend_remainder - partial_remainder != 0) {\n        carry_flag = CARRY4(dividend_upper,partial_remainder);\n        partial_remainder = dividend_upper + partial_remainder;\n        quotient = divisor_quotient - 1;\n        if ((carry_flag == false) && (partial_remainder <= dividend_remainder && dividend_remainder - partial_remainder != 0)) {\n          quotient = divisor_quotient - 2;\n          partial_remainder = partial_remainder + dividend_upper;\n        }\n      }\n      quotient = quotient | temp_quotient << 0x10;\n      puVar9 = (uint *)0x0;\n      partial_remainder = partial_remainder - dividend_remainder;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x8001302);\n        result = (*UNRECOVERED_JUMPTABLE)();\n        return result;\n      }\n      shift_count = LZCOUNT(divisor);\n      if (shift_count == 0) {\n        puVar9 = (uint *)0x1;\n        dividend_lower = dividend_lower - divisor;\n        product1 = divisor >> 0x10;\n        divisor_quotient = divisor & 0xffff;\n        dividend_upper = divisor;\n      }\n      else {\n        dividend_upper = divisor << shift_count;\n        quotient = dividend_lower >> (0x20U - shift_count & 0xff);\n        product1 = dividend_upper >> 0x10;\n        divisor_quotient2 = quotient / product1;\n        divisor_quotient = dividend_upper & 0xffff;\n        dividend_remainder = divisor_quotient2 * divisor_quotient;\n        partial_remainder = dividend >> (0x20U - shift_count & 0xff) | dividend_lower << shift_count;\n        temp_quotient = partial_remainder >> 0x10 | (quotient - product1 * divisor_quotient2) * 0x10000;\n        dividend = dividend << shift_count;\n        quotient = divisor_quotient2;\n        if (temp_quotient <= dividend_remainder && dividend_remainder - temp_quotient != 0) {\n          carry_flag = CARRY4(dividend_upper,temp_quotient);\n          temp_quotient = dividend_upper + temp_quotient;\n          quotient = divisor_quotient2 - 1;\n          if ((carry_flag == false) && (temp_quotient <= dividend_remainder && dividend_remainder - temp_quotient != 0)) {\n            quotient = divisor_quotient2 - 2;\n            temp_quotient = temp_quotient + dividend_upper;\n          }\n        }\n        divisor_quotient2 = (temp_quotient - dividend_remainder) / product1;\n        product2 = divisor_quotient2 * divisor_quotient;\n        dividend_lower = partial_remainder & 0xffff | ((temp_quotient - dividend_remainder) - product1 * divisor_quotient2) * 0x10000;\n        temp_quotient = divisor_quotient2;\n        if (dividend_lower <= product2 && product2 - dividend_lower != 0) {\n          carry_flag = CARRY4(dividend_upper,dividend_lower);\n          dividend_lower = dividend_upper + dividend_lower;\n          temp_quotient = divisor_quotient2 - 1;\n          if ((carry_flag == false) && (dividend_lower <= product2 && product2 - dividend_lower != 0)) {\n            temp_quotient = divisor_quotient2 - 2;\n            dividend_lower = dividend_lower + dividend_upper;\n          }\n        }\n        dividend_lower = dividend_lower - product2;\n        puVar9 = (uint *)(temp_quotient | quotient << 0x10);\n      }\n      divisor_quotient2 = dividend_lower / product1;\n      quotient = divisor_quotient * divisor_quotient2;\n      partial_remainder = dividend >> 0x10 | (dividend_lower - product1 * divisor_quotient2) * 0x10000;\n      temp_quotient = divisor_quotient2;\n      if (partial_remainder <= quotient && quotient - partial_remainder != 0) {\n        carry_flag = CARRY4(dividend_upper,partial_remainder);\n        partial_remainder = dividend_upper + partial_remainder;\n        temp_quotient = divisor_quotient2 - 1;\n        if ((carry_flag == false) && (partial_remainder <= quotient && quotient - partial_remainder != 0)) {\n          temp_quotient = divisor_quotient2 - 2;\n          partial_remainder = partial_remainder + dividend_upper;\n        }\n      }\n      divisor_quotient2 = (partial_remainder - quotient) / product1;\n      divisor_quotient = divisor_quotient * divisor_quotient2;\n      partial_remainder = dividend & 0xffff | ((partial_remainder - quotient) - product1 * divisor_quotient2) * 0x10000;\n      quotient = divisor_quotient2;\n      if (partial_remainder <= divisor_quotient && divisor_quotient - partial_remainder != 0) {\n        carry_flag = CARRY4(dividend_upper,partial_remainder);\n        partial_remainder = dividend_upper + partial_remainder;\n        quotient = divisor_quotient2 - 1;\n        if ((carry_flag == false) && (partial_remainder <= divisor_quotient && divisor_quotient - partial_remainder != 0)) {\n          quotient = divisor_quotient2 - 2;\n          partial_remainder = partial_remainder + dividend_upper;\n        }\n      }\n      partial_remainder = partial_remainder - divisor_quotient;\n      quotient = quotient | temp_quotient << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = partial_remainder >> LZCOUNT(divisor);\n      remainder[1] = 0;\n    }\n  }\n  else {\n    puVar9 = remainder;\n    if (dividend_lower < divisor_lower) {\n      if (remainder != (uint *)0x0) {\n        *remainder = dividend;\n        remainder[1] = dividend_lower;\n        return 0;\n      }\n      quotient = 0;\n    }\n    else {\n      shift_count = LZCOUNT(divisor_lower);\n      if (shift_count == 0) {\n        if ((divisor_lower < dividend_lower) || (divisor <= dividend)) {\n          carry_flag = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_lower = (dividend_lower - divisor_lower) - (uint)carry_flag;\n          quotient = 1;\n        }\n        else {\n          quotient = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (remainder != (uint *)0x0) {\n          *remainder = dividend;\n          remainder[1] = dividend_lower;\n        }\n      }\n      else {\n        partial_remainder = 0x20 - shift_count;\n        divisor_quotient = divisor >> (partial_remainder & 0xff) | divisor_lower << shift_count;\n        dividend_upper = dividend_lower >> (partial_remainder & 0xff);\n        dividend_remainder = divisor_quotient >> 0x10;\n        divisor_quotient2 = dividend_upper / dividend_remainder;\n        product1 = divisor_quotient2 * (divisor_quotient & 0xffff);\n        quotient = dividend_lower << shift_count | dividend >> (partial_remainder & 0xff);\n        temp_quotient = quotient >> 0x10 | (dividend_upper - dividend_remainder * divisor_quotient2) * 0x10000;\n        dividend = dividend << shift_count;\n        dividend_upper = divisor_quotient2;\n        if (temp_quotient <= product1 && product1 - temp_quotient != 0) {\n          carry_flag = CARRY4(divisor_quotient,temp_quotient);\n          temp_quotient = divisor_quotient + temp_quotient;\n          dividend_upper = divisor_quotient2 - 1;\n          if ((carry_flag == false) && (temp_quotient <= product1 && product1 - temp_quotient != 0)) {\n            dividend_upper = divisor_quotient2 - 2;\n            temp_quotient = temp_quotient + divisor_quotient;\n          }\n        }\n        divisor_quotient2 = (temp_quotient - product1) / dividend_remainder;\n        product2 = divisor_quotient2 * (divisor_quotient & 0xffff);\n        temp_quotient = quotient & 0xffff | ((temp_quotient - product1) - dividend_remainder * divisor_quotient2) * 0x10000;\n        quotient = divisor_quotient2;\n        if (temp_quotient <= product2 && product2 - temp_quotient != 0) {\n          carry_flag = CARRY4(divisor_quotient,temp_quotient);\n          temp_quotient = divisor_quotient + temp_quotient;\n          quotient = divisor_quotient2 - 1;\n          if ((carry_flag == false) && (temp_quotient <= product2 && product2 - temp_quotient != 0)) {\n            quotient = divisor_quotient2 - 2;\n            temp_quotient = temp_quotient + divisor_quotient;\n          }\n        }\n        quotient = quotient | dividend_upper << 0x10;\n        partial_quotient = (ulonglong)quotient * (ulonglong)(divisor << shift_count);\n        if (CONCAT44(temp_quotient - product2,dividend) < partial_quotient) {\n          quotient = quotient - 1;\n          partial_quotient = partial_quotient - CONCAT44(divisor_quotient,divisor << shift_count);\n        }\n        if (remainder != (uint *)0x0) {\n          dividend_upper = ((temp_quotient - product2) - (int)(partial_quotient >> 0x20)) - (uint)(dividend < (uint)partial_quotient);\n          *remainder = dividend_upper << (partial_remainder & 0xff) | dividend - (uint)partial_quotient >> shift_count;\n          remainder[1] = dividend_upper >> shift_count;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,quotient);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_quotient_and_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_lower",
                "param_3": "divisor",
                "param_4": "divisor_lower",
                "param_5": "remainder",
                "uVar1": "partial_quotient",
                "uVar2": "divisor_quotient",
                "uVar3": "temp_quotient",
                "uVar4": "dividend_remainder",
                "iVar5": "shift_count",
                "uVar6": "quotient",
                "uVar7": "dividend_upper",
                "uVar8": "partial_remainder",
                "uVar10": "divisor_quotient2",
                "uVar11": "product1",
                "uVar12": "product2",
                "bVar13": "carry_flag",
                "uVar14": "result"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ec": {
            "entrypoint": "0x080014ec",
            "current_name": "FUNC_080014ec",
            "code": "\nvoid FUNC_080014ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080014ec": "FUNC_080014ec"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_hardware_080014f0",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef initializeHardware_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setInterruptPriorityGroup(3);\n  initializeSystemTick(0xf);\n  initializePeriph();\n  return HAL_SUCCESS;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_hardware_080014f0",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGroup",
                "HAL_InitTick": "initializeSystemTick",
                "HAL_MspInit": "initializePeriph",
                "HAL_OK": "HAL_SUCCESS"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_MspInit",
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "configure_sys_tick_0800151c",
            "code": "\nHAL_StatusTypeDef configureSysTick_0800151c(uint32_t tickPriority)\n\n{\n  uint32_t systickConfigStatus;\n  HAL_StatusTypeDef status;\n  uint32_t localTickPriority;\n  \n  systickConfigStatus = HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (systickConfigStatus == 0) {\n    if (tickPriority < 0x10) {\n      HAL_NVIC_SetPriority(SysTick_IRQn,tickPriority,0);\n      status = HAL_OK;\n      uwTickPrio = tickPriority;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  else {\n    status = HAL_ERROR;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "configure_sys_tick_0800151c",
                "TickPriority": "tickPriority",
                "uVar1": "systickConfigStatus",
                "HVar2": "status",
                "TickPriority_local": "localTickPriority"
            },
            "calling": [
                "HAL_Init",
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "update_tick_value_0800157c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid updateTickValue_0800157c(void)\n\n{\n  currentTickValue = currentTickValue + tickFrequency;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "update_tick_value_0800157c",
                "uwTick": "currentTickValue",
                "uwTickFreq": "tickFrequency"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_uw_tick_080015a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_uwTick_080015a0(void)\n\n{\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_uw_tick_080015a0",
                "uwTick": "current_tick"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_I2C_Mem_Read",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_RCC_OscConfig",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryWrite",
                "_get_ms_tick",
                "HAL_UART_Transmit",
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "set_priority_group_080015b4",
            "code": "\n\n\nvoid setPriorityGroup_080015b4(uint32_t newPriorityGroup)\n\n{\n  uint32_t localPriorityGroup;\n  uint32_t registerValue;\n  uint32_t temporaryPriorityGroup;\n  \n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (newPriorityGroup & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "set_priority_group_080015b4",
                "PriorityGroup": "newPriorityGroup",
                "PriorityGroup_local": "localPriorityGroup",
                "reg_value": "registerValue",
                "PriorityGroupTmp": "temporaryPriorityGroup"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "extract_bits_from_register_080015fc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t extract_bits_from_register_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "extract_bits_from_register_080015fc"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "set_interrupt_priority_08001618",
            "code": "\nvoid setInterruptPriority_08001618(interruptNumber_Type interruptNumber,uint32_t interruptPriority)\n\n{\n  uint32_t localPriority;\n  interruptNumber_Type localInterruptNumber;\n  \n  if (interruptNumber < WWDG_interruptNumber) {\n    *(char *)(((byte)interruptNumber & 0xf) + 0xe000ed14) = (char)((interruptPriority & 0xff) << 4);\n  }\n  else {\n    *(char *)(interruptNumber + -0x1fff1c00) = (char)((interruptPriority & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "set_interrupt_priority_08001618",
                "IRQn": "interruptNumber",
                "priority": "interruptPriority",
                "priority_local": "localPriority",
                "IRQn_local": "localInterruptNumber"
            },
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "map_priority_0800166c",
            "code": "\nuint32_t mapPriority_0800166c(uint32_t priorityGroup,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint groupSelectionMask;\n  uint numBitsToShift;\n  uint32_t localSubPriority;\n  uint32_t localPreemptPriority;\n  uint32_t localPriorityGroup;\n  uint32_t subPriorityBits;\n  uint32_t preemptPriorityBits;\n  uint32_t priorityGroupTmp;\n  \n  groupSelectionMask = priorityGroup & 7;\n  numBitsToShift = 7 - groupSelectionMask;\n  if (3 < numBitsToShift) {\n    numBitsToShift = 4;\n  }\n  if (groupSelectionMask + 4 < 7) {\n    groupSelectionMask = 0;\n  }\n  else {\n    groupSelectionMask = groupSelectionMask - 3;\n  }\n  return subPriority & ~(-1 << (groupSelectionMask & 0xff)) |\n         (~(-1 << (numBitsToShift & 0xff)) & preemptPriority) << (groupSelectionMask & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "map_priority_0800166c",
                "PriorityGroup": "priorityGroup",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "SubPriority_local": "localSubPriority",
                "PreemptPriority_local": "localPreemptPriority",
                "PriorityGroup_local": "localPriorityGroup",
                "SubPriorityBits": "subPriorityBits",
                "PreemptPriorityBits": "preemptPriorityBits",
                "PriorityGroupTmp": "priorityGroupTmp",
                "uVar1": "groupSelectionMask",
                "uVar2": "numBitsToShift"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "validate_ticks_080016d0",
            "code": "\n\n\nuint32_t validate_ticks_080016d0(uint32_t ticks_param)\n\n{\n  bool is_valid;\n  uint32_t local_ticks;\n  \n  is_valid = ticks_param - 1 < 0x1000000;\n  if (is_valid) {\n    _DAT_e000e014 = ticks_param - 1;\n    NVIC_SetPriority(SysTick_IRQn,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return (uint)!is_valid;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "validate_ticks_080016d0",
                "ticks": "ticks_param",
                "bVar1": "is_valid",
                "ticks_local": "local_ticks"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_nvic_priority_grouping_08001714",
            "code": "\nvoid setNVICPriorityGrouping_08001714(uint32_t priorityGroup)\n\n{\n  uint32_t priorityGroup_local;\n  \n  NVIC_SetpriorityGrouping(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_nvic_priority_grouping_08001714",
                "PriorityGroup": "priorityGroup"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_interrupt_priority_0800172a",
            "code": "\nvoid setInterruptPriority_0800172a(interruptNumber_Type interruptNumber,uint32_t preemptPriority,uint32_t subPriority)\n\n{\n  uint32_t priorityGroup;\n  uint32_t subPriorityLocal;\n  uint32_t preemptPriorityLocal;\n  interruptNumber_Type interruptNumberLocal;\n  uint32_t priorityGrouping;\n  \n  priorityGroup = NVIC_GetPriorityGrouping();\n  priorityGroup = NVIC_EncodePriority(priorityGroup,preemptPriority,subPriority);\n  NVIC_SetPriority(interruptNumber,priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_interrupt_priority_0800172a",
                "IRQn": "interruptNumber",
                "PreemptPriority": "preemptPriority",
                "SubPriority": "subPriority",
                "uVar1": "priorityGroup",
                "SubPriority_local": "subPriorityLocal",
                "PreemptPriority_local": "preemptPriorityLocal",
                "IRQn_local": "interruptNumberLocal",
                "prioritygroup": "priorityGrouping"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "NVIC_EncodePriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "initialize_sys_tick_08001762",
            "code": "\nuint32_t initializeSysTick_08001762(uint32_t ticksNumber)\n\n{\n  uint32_t configStatus;\n  uint32_t localTicksNumber;\n  \n  configStatus = SysTick_Config(ticksNumber);\n  return configStatus;\n}\n\n",
            "renaming": {
                "FUN_08001762": "initialize_sys_tick_08001762",
                "TicksNumb": "ticksNumber",
                "uVar1": "configStatus",
                "TicksNumb_local": "localTicksNumber"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_clk_source_0800177c",
            "code": "\n\n\nvoid setCLKSource_0800177c(uint32_t source)\n\n{\n  uint32_t localSource;\n  \n  if (source == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_clk_source_0800177c",
                "CLKSource": "source",
                "CLKSource_local": "localSource"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "handle_tim_period_elapsed_080017b4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleTimPeriodElapsed_080017b4(void)\n\n{\n  HAL_TIM_PeriodElapsedCallback((timHandle *)0x0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "handle_tim_period_elapsed_080017b4",
                "TIM_HandleTypeDef": "timHandle"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "initialize_gpio_080017c4",
            "code": "\n\n\nvoid initialize_GPIO_080017c4(GPIO_type *GPIO_port,GPIO_Init_type *GPIO_config)\n\n{\n  uint bit_mask;\n  uint pin_match;\n  uint mode;\n  GPIO_type *pGPIO;\n  int port_index;\n  GPIO_Init_type *GPIO_Init_temp;\n  GPIO_type *GPIO_port_temp;\n  uint32_t tmp_register;\n  uint32_t *config_register;\n  uint32_t register_offset;\n  uint32_t temporary;\n  uint32_t current_io;\n  uint32_t io_position;\n  uint32_t configuration;\n  uint32_t current_position;\n  \n  configuration = 0;\n  current_position = 0;\n  do {\n    if (0xf < current_position) {\n      return;\n    }\n    bit_mask = 1 << (current_position & 0xff);\n    pin_match = GPIO_config->Pin & bit_mask;\n    if (pin_match == bit_mask) {\n      mode = GPIO_config->Mode;\n      if (mode == 0x12) {\n        configuration = GPIO_config->Speed + 0xc;\n      }\n      else if (mode < 0x13) {\n        if (mode == 2) {\n          configuration = GPIO_config->Speed + 8;\n        }\n        else if (mode < 3) {\n          if (mode == 0) goto LAB_08001882;\n          if (mode == 1) {\n            configuration = GPIO_config->Speed;\n          }\n        }\n        else if (mode == 3) {\n          configuration = 0;\n        }\n        else if (mode == 0x11) {\n          configuration = GPIO_config->Speed + 4;\n        }\n      }\n      else if (mode == 0x10210000) {\nLAB_08001882:\n        if (GPIO_config->Pull == 0) {\n          configuration = 4;\n        }\n        else if (GPIO_config->Pull == 1) {\n          configuration = 8;\n          GPIO_port->BSRR = bit_mask;\n        }\n        else {\n          configuration = 8;\n          GPIO_port->BRR = bit_mask;\n        }\n      }\n      else if (mode < 0x10210001) {\n        if ((mode == 0x10110000) || (mode == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((mode == 0x10310000) || (mode == 0x10320000)) || (mode == 0x10220000))\n      goto LAB_08001882;\n      if (pin_match < 0x100) {\n        bit_mask = current_position << 2;\n        pGPIO = GPIO_port;\n      }\n      else {\n        pGPIO = (GPIO_type *)&GPIO_port->CRH;\n        bit_mask = (current_position - 8) * 4;\n      }\n      pGPIO->CRL = pGPIO->CRL & ~(0xf << (bit_mask & 0xff)) | configuration << (bit_mask & 0xff);\n      if ((GPIO_config->Mode & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (GPIO_port == (GPIO_type *)0x40010800) {\n          port_index = 0;\n        }\n        else if (GPIO_port == (GPIO_type *)0x40010c00) {\n          port_index = 1;\n        }\n        else if (GPIO_port == (GPIO_type *)0x40011000) {\n          port_index = 2;\n        }\n        else if (GPIO_port == (GPIO_type *)0x40011400) {\n          port_index = 3;\n        }\n        else {\n          port_index = 4;\n        }\n        *(uint *)(((current_position >> 2) + 2) * 4 + 0x40010000) =\n             port_index << ((current_position & 3) << 2) |\n             ~(0xf << ((current_position & 3) << 2)) & *(uint *)(((current_position >> 2) + 2) * 4 + 0x40010000);\n        if ((GPIO_config->Mode & 0x10000) == 0) {\n          _DAT_40010400 = ~pin_match & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = pin_match | _DAT_40010400;\n        }\n        if ((GPIO_config->Mode & 0x20000) == 0) {\n          _DAT_40010404 = ~pin_match & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = pin_match | _DAT_40010404;\n        }\n        if ((GPIO_config->Mode & 0x100000) == 0) {\n          _DAT_40010408 = ~pin_match & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = pin_match | _DAT_40010408;\n        }\n        if ((GPIO_config->Mode & 0x200000) == 0) {\n          _DAT_4001040c = ~pin_match & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = pin_match | _DAT_4001040c;\n        }\n      }\n    }\n    current_position = current_position + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "initialize_gpio_080017c4",
                "GPIO_TypeDef": "GPIO_type",
                "GPIO_InitTypeDef": "GPIO_Init_type",
                "GPIOx": "GPIO_port",
                "GPIO_Init": "GPIO_config",
                "uVar1": "bit_mask",
                "uVar2": "pin_match",
                "uVar3": "mode",
                "pGVar4": "pGPIO",
                "iVar5": "port_index",
                "GPIO_Init_local": "GPIO_Init_temp",
                "GPIOx_local": "GPIO_port_temp",
                "tmpreg": "tmp_register",
                "configregister": "config_register",
                "registeroffset": "register_offset",
                "temp": "temporary",
                "iocurrent": "current_io",
                "ioposition": "io_position",
                "config": "configuration",
                "position": "current_position"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "set_pin_state_08001a80",
            "code": "\nvoid setPinState_08001a80(GPIO_TypeDef *Port,uint16_t Pin,PinState State)\n\n{\n  PinState localState;\n  uint16_t localPin;\n  GPIO_TypeDef *localPort;\n  \n  if (State == GPIO_PIN_RESET) {\n    Port->BSRR = (uint)Pin << 0x10;\n  }\n  else {\n    Port->BSRR = (uint)Pin;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "set_pin_state_08001a80",
                "GPIOx": "Port",
                "GPIO_Pin": "Pin",
                "PinState": "State",
                "PinState_local": "localState",
                "GPIO_Pin_local": "localPin",
                "GPIOx_local": "localPort"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_i2_c_08001ab0",
            "code": "\nHAL_StatusTypeDef initializeI2C_08001ab0(I2C_HandleTypeDef *i2cHandler)\n\n{\n  uint32_t pclk1Freq;\n  char isFreqValid;\n  HAL_StatusTypeDef status;\n  uint32_t pclk1FreqThreshold;\n  uint riseTime;\n  bool isDutyCycleValid;\n  I2C_HandleTypeDef *localI2CHandler;\n  uint32_t pclk1;\n  uint32_t freqrange;\n  \n  if (i2cHandler == (I2C_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (i2cHandler->State == HAL_I2C_STATE_RESET) {\n      i2cHandler->Lock = HAL_UNLOCKED;\n      HAL_I2C_MspInit(i2cHandler);\n    }\n    i2cHandler->State = HAL_I2C_STATE_BUSY;\n    i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffffffe;\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    if ((i2cHandler->Init).ClockSpeed < 0x186a1) {\n      pclk1FreqThreshold = pclk1Freq;\n      if (pclk1Freq < 2000000) {\n        pclk1FreqThreshold = 1;\n      }\n      isFreqValid = (char)pclk1FreqThreshold;\n      if (1999999 < pclk1Freq) {\n        isFreqValid = '\\0';\n      }\n    }\n    else {\n      pclk1FreqThreshold = pclk1Freq;\n      if (pclk1Freq < 4000000) {\n        pclk1FreqThreshold = 1;\n      }\n      isFreqValid = (char)pclk1FreqThreshold;\n      if (3999999 < pclk1Freq) {\n        isFreqValid = '\\0';\n      }\n    }\n    if (isFreqValid == '\\0') {\n      riseTime = pclk1Freq / 1000000;\n      i2cHandler->Instance->CR2 = riseTime;\n      if (100000 < (i2cHandler->Init).ClockSpeed) {\n        riseTime = (riseTime * 300) / 1000;\n      }\n      i2cHandler->Instance->TRISE = riseTime + 1;\n      if ((i2cHandler->Init).ClockSpeed < 0x186a1) {\n        pclk1Freq = (pclk1Freq - 1) / ((i2cHandler->Init).ClockSpeed << 1) + 1 & 0xfff;\n        if (pclk1Freq < 4) {\n          pclk1Freq = 4;\n        }\n      }\n      else {\n        if ((i2cHandler->Init).DutyCycle == 0) {\n          riseTime = (pclk1Freq - 1) / ((i2cHandler->Init).ClockSpeed * 3) + 1 & 0xfff;\n          isDutyCycleValid = riseTime == 0;\n          if (isDutyCycleValid) {\n            riseTime = 1;\n          }\n          isFreqValid = (char)riseTime;\n          if (!isDutyCycleValid) {\n            isFreqValid = '\\0';\n          }\n        }\n        else {\n          riseTime = (pclk1Freq - 1) / ((i2cHandler->Init).ClockSpeed * 0x19) + 1 & 0xfff;\n          isDutyCycleValid = riseTime == 0;\n          if (isDutyCycleValid) {\n            riseTime = 1;\n          }\n          isFreqValid = (char)riseTime;\n          if (!isDutyCycleValid) {\n            isFreqValid = '\\0';\n          }\n        }\n        if (isFreqValid == '\\0') {\n          if ((i2cHandler->Init).DutyCycle == 0) {\n            pclk1Freq = (pclk1Freq - 1) / ((i2cHandler->Init).ClockSpeed * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclk1Freq = (pclk1Freq - 1) / ((i2cHandler->Init).ClockSpeed * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclk1Freq = 1;\n        }\n      }\n      i2cHandler->Instance->CCR = pclk1Freq;\n      i2cHandler->Instance->CR1 = (i2cHandler->Init).NoStretchMode | (i2cHandler->Init).GeneralCallMode;\n      i2cHandler->Instance->OAR1 = (i2cHandler->Init).OwnAddress1 | (i2cHandler->Init).AddressingMode;\n      i2cHandler->Instance->OAR2 = (i2cHandler->Init).OwnAddress2 | (i2cHandler->Init).DualAddressMode;\n      i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 1;\n      i2cHandler->ErrorCode = 0;\n      i2cHandler->State = HAL_I2C_STATE_READY;\n      i2cHandler->PreviousState = 0;\n      i2cHandler->Mode = HAL_I2C_MODE_NONE;\n      status = HAL_OK;\n    }\n    else {\n      status = HAL_ERROR;\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_i2_c_08001ab0",
                "hi2c": "i2cHandler",
                "uVar1": "pclk1Freq",
                "cVar2": "isFreqValid",
                "HVar3": "status",
                "uVar4": "pclk1FreqThreshold",
                "uVar5": "riseTime",
                "bVar6": "isDutyCycleValid",
                "hi2c_local": "localI2CHandler"
            },
            "calling": [
                "MX_I2C1_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_I2C_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "initialize_i2c_08001cb8",
            "code": "\nvoid initialize_i2c_08001cb8(I2C_HandleTypeDef *i2c_handle)\n\n{\n  I2C_HandleTypeDef *i2c_handle_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "initialize_i2c_08001cb8",
                "hi2c": "i2c_handle"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "write_memory_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nHAL_StatusTypeDef\nwriteMemory_08001ccc(I2C_HandleTypeDef *i2cHandler,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tickStart;\n  uint32_t currentTick;\n  int loopVar;\n  byte *bufferPtr;\n  uint16_t localMemoryAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandler;\n  uint32_t localTickStart;\n  \n  tickStart = HAL_GetTick();\n  if (i2cHandler->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((~i2cHandler->Instance->SR2 & 2) != 0) {\n        loopVar = 0;\n        goto LAB_08001d9c;\n      }\n      currentTick = HAL_GetTick();\n    } while (currentTick - tickStart < 0x1a);\n    i2cHandler->PreviousState = 0;\n    i2cHandler->State = HAL_I2C_STATE_READY;\n    i2cHandler->Mode = HAL_I2C_MODE_NONE;\n    i2cHandler->Lock = HAL_UNLOCKED;\n    loopVar = 3;\nLAB_08001d9c:\n    if (loopVar == 0) {\n      if (i2cHandler->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        i2cHandler->Lock = HAL_LOCKED;\n        if ((i2cHandler->Instance->CR1 & 1) != 1) {\n          i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 1;\n        }\n        i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 & 0xfffff7ff;\n        i2cHandler->State = HAL_I2C_STATE_BUSY_TX;\n        i2cHandler->Mode = HAL_I2C_MODE_MEM;\n        i2cHandler->ErrorCode = 0;\n        i2cHandler->pBuffPtr = data;\n        i2cHandler->XferCount = dataSize;\n        i2cHandler->XferOptions = 0xffff0000;\n        i2cHandler->XferdataSize = i2cHandler->XferCount;\n        status = I2C_RequestMemoryWrite(i2cHandler,deviceAddress,memoryAddress,memoryAddressSize,timeout,tickStart);\n        if (status == HAL_OK) {\n          while (i2cHandler->XferdataSize != 0) {\n            status = I2C_WaitOnTXEFlagUntiltimeout(i2cHandler,timeout,tickStart);\n            if (status != HAL_OK) {\n              if (i2cHandler->ErrorCode == 4) {\n                i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x200;\n                return HAL_ERROR;\n              }\n              return HAL_TIMEOUT;\n            }\n            bufferPtr = i2cHandler->pBuffPtr;\n            i2cHandler->pBuffPtr = bufferPtr + 1;\n            i2cHandler->Instance->DR = (uint)*bufferPtr;\n            i2cHandler->XferdataSize = i2cHandler->XferdataSize - 1;\n            i2cHandler->XferCount = i2cHandler->XferCount - 1;\n            if (((i2cHandler->Instance->SR1 & 4) == 4) && (i2cHandler->XferdataSize != 0)) {\n              bufferPtr = i2cHandler->pBuffPtr;\n              i2cHandler->pBuffPtr = bufferPtr + 1;\n              i2cHandler->Instance->DR = (uint)*bufferPtr;\n              i2cHandler->XferdataSize = i2cHandler->XferdataSize - 1;\n              i2cHandler->XferCount = i2cHandler->XferCount - 1;\n            }\n          }\n          status = I2C_WaitOnBTFFlagUntiltimeout(i2cHandler,timeout,tickStart);\n          if (status == HAL_OK) {\n            i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x200;\n            i2cHandler->State = HAL_I2C_STATE_READY;\n            i2cHandler->Mode = HAL_I2C_MODE_NONE;\n            i2cHandler->Lock = HAL_UNLOCKED;\n            status = HAL_OK;\n          }\n          else if (i2cHandler->ErrorCode == 4) {\n            i2cHandler->Instance->CR1 = i2cHandler->Instance->CR1 | 0x200;\n            status = HAL_ERROR;\n          }\n          else {\n            status = HAL_TIMEOUT;\n          }\n        }\n        else if (i2cHandler->ErrorCode == 4) {\n          i2cHandler->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          i2cHandler->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "write_memory_08001ccc",
                "hi2c": "i2cHandler",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tickStart",
                "uVar2": "currentTick",
                "iVar3": "loopVar",
                "pbVar4": "bufferPtr",
                "MemAddSize_local": "localMemoryAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandler",
                "tickstart": "localTickStart"
            },
            "calling": [
                "_i2c_write_reg"
            ],
            "called": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_RequestMemoryWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "read_memory_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nHAL_StatusTypeDef\nreadMemory_08001f6c(I2C_HandleTypeDef *I2C_handle,uint16_t Device_address,uint16_t Memory_address,uint16_t Memory_address_size,\n            uint8_t *data_pointer,uint16_t data_size,uint32_t timeout)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t tick_start;\n  uint32_t tick_current;\n  int result;\n  uint8_t *buffer_pointer;\n  uint16_t local_memory_address_size;\n  uint16_t local_memory_address;\n  uint16_t local_device_address;\n  I2C_HandleTypeDef *local_I2C_handle;\n  uint32_t tmp_register_3;\n  uint32_t tmp_register_2;\n  uint32_t tmp_register_1;\n  uint32_t tmp_register;\n  uint32_t tick_start;\n  \n  tick_start = HAL_GetTick();\n  if (I2C_handle->State == HAL_I2C_STATE_READY) {\n    do {\n      if ((~I2C_handle->Instance->SR2 & 2) != 0) {\n        result = 0;\n        goto LAB_08002040;\n      }\n      tick_current = HAL_GetTick();\n    } while (tick_current - tick_start < 0x1a);\n    I2C_handle->PreviousState = 0;\n    I2C_handle->State = HAL_I2C_STATE_READY;\n    I2C_handle->Mode = HAL_I2C_MODE_NONE;\n    I2C_handle->Lock = HAL_UNLOCKED;\n    result = 3;\nLAB_08002040:\n    if (result == 0) {\n      if (I2C_handle->Lock == HAL_LOCKED) {\n        status = HAL_BUSY;\n      }\n      else {\n        I2C_handle->Lock = HAL_LOCKED;\n        if ((I2C_handle->Instance->CR1 & 1) != 1) {\n          I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 1;\n        }\n        I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 & 0xfffff7ff;\n        I2C_handle->State = HAL_I2C_STATE_BUSY_RX;\n        I2C_handle->Mode = HAL_I2C_MODE_MEM;\n        I2C_handle->ErrorCode = 0;\n        I2C_handle->pBuffPtr = data_pointer;\n        I2C_handle->XferCount = data_size;\n        I2C_handle->XferOptions = 0xffff0000;\n        I2C_handle->Xferdata_size = I2C_handle->XferCount;\n        status = I2C_RequestMemoryRead(I2C_handle,Device_address,Memory_address,Memory_address_size,timeout,tick_start);\n        if (status == HAL_OK) {\n          if (I2C_handle->Xferdata_size == 0) {\n            I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x200;\n          }\n          else if (I2C_handle->Xferdata_size == 1) {\n            I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 & 0xfffffbff;\n            disableIRQinterrupts();\n            I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (I2C_handle->Xferdata_size == 2) {\n            I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x800;\n            disableIRQinterrupts();\n            I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x400;\n          }\n          while (I2C_handle->Xferdata_size != 0) {\n            if (I2C_handle->Xferdata_size < 4) {\n              if (I2C_handle->Xferdata_size == 1) {\n                status = I2C_WaitOnRXNEFlagUntiltimeout(I2C_handle,timeout,tick_start);\n                if (status != HAL_OK) {\n                  if (I2C_handle->ErrorCode == 0x20) {\n                    return HAL_TIMEOUT;\n                  }\n                  return HAL_ERROR;\n                }\n                tick_current = I2C_handle->Instance->DR;\n                buffer_pointer = I2C_handle->pBuffPtr;\n                I2C_handle->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)tick_current;\n                I2C_handle->Xferdata_size = I2C_handle->Xferdata_size - 1;\n                I2C_handle->XferCount = I2C_handle->XferCount - 1;\n              }\n              else if (I2C_handle->Xferdata_size == 2) {\n                do {\n                  if ((~I2C_handle->Instance->SR1 & 4) == 0) {\n                    result = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tick_current = HAL_GetTick(), tick_current - tick_start <= timeout))));\n                I2C_handle->PreviousState = 0;\n                I2C_handle->State = HAL_I2C_STATE_READY;\n                I2C_handle->Mode = HAL_I2C_MODE_NONE;\n                I2C_handle->Lock = HAL_UNLOCKED;\n                result = 3;\nLAB_080022fa:\n                if (result != 0) {\n                  return HAL_TIMEOUT;\n                }\n                disableIRQinterrupts();\n                I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x200;\n                tick_current = I2C_handle->Instance->DR;\n                buffer_pointer = I2C_handle->pBuffPtr;\n                I2C_handle->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)tick_current;\n                I2C_handle->Xferdata_size = I2C_handle->Xferdata_size - 1;\n                I2C_handle->XferCount = I2C_handle->XferCount - 1;\n                enableIRQinterrupts();\n                tick_current = I2C_handle->Instance->DR;\n                buffer_pointer = I2C_handle->pBuffPtr;\n                I2C_handle->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)tick_current;\n                I2C_handle->Xferdata_size = I2C_handle->Xferdata_size - 1;\n                I2C_handle->XferCount = I2C_handle->XferCount - 1;\n              }\n              else {\n                do {\n                  if ((~I2C_handle->Instance->SR1 & 4) == 0) {\n                    result = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tick_current = HAL_GetTick(), tick_current - tick_start <= timeout))));\n                I2C_handle->PreviousState = 0;\n                I2C_handle->State = HAL_I2C_STATE_READY;\n                I2C_handle->Mode = HAL_I2C_MODE_NONE;\n                I2C_handle->Lock = HAL_UNLOCKED;\n                result = 3;\nLAB_08002418:\n                if (result != 0) {\n                  return HAL_TIMEOUT;\n                }\n                I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 & 0xfffffbff;\n                disableIRQinterrupts();\n                tick_current = I2C_handle->Instance->DR;\n                buffer_pointer = I2C_handle->pBuffPtr;\n                I2C_handle->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)tick_current;\n                I2C_handle->Xferdata_size = I2C_handle->Xferdata_size - 1;\n                I2C_handle->XferCount = I2C_handle->XferCount - 1;\n                do {\n                  if ((~I2C_handle->Instance->SR1 & 4) == 0) {\n                    result = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (tick_current = HAL_GetTick(), tick_current - tick_start <= timeout))));\n                I2C_handle->PreviousState = 0;\n                I2C_handle->State = HAL_I2C_STATE_READY;\n                I2C_handle->Mode = HAL_I2C_MODE_NONE;\n                I2C_handle->Lock = HAL_UNLOCKED;\n                result = 3;\nLAB_0800250a:\n                if (result != 0) {\n                  return HAL_TIMEOUT;\n                }\n                I2C_handle->Instance->CR1 = I2C_handle->Instance->CR1 | 0x200;\n                tick_current = I2C_handle->Instance->DR;\n                buffer_pointer = I2C_handle->pBuffPtr;\n                I2C_handle->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)tick_current;\n                I2C_handle->Xferdata_size = I2C_handle->Xferdata_size - 1;\n                I2C_handle->XferCount = I2C_handle->XferCount - 1;\n                enableIRQinterrupts();\n                tick_current = I2C_handle->Instance->DR;\n                buffer_pointer = I2C_handle->pBuffPtr;\n                I2C_handle->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)tick_current;\n                I2C_handle->Xferdata_size = I2C_handle->Xferdata_size - 1;\n                I2C_handle->XferCount = I2C_handle->XferCount - 1;\n              }\n            }\n            else {\n              status = I2C_WaitOnRXNEFlagUntiltimeout(I2C_handle,timeout,tick_start);\n              if (status != HAL_OK) {\n                if (I2C_handle->ErrorCode == 0x20) {\n                  return HAL_TIMEOUT;\n                }\n                return HAL_ERROR;\n              }\n              tick_current = I2C_handle->Instance->DR;\n              buffer_pointer = I2C_handle->pBuffPtr;\n              I2C_handle->pBuffPtr = buffer_pointer + 1;\n              *buffer_pointer = (uint8_t)tick_current;\n              I2C_handle->Xferdata_size = I2C_handle->Xferdata_size - 1;\n              I2C_handle->XferCount = I2C_handle->XferCount - 1;\n              if ((I2C_handle->Instance->SR1 & 4) == 4) {\n                tick_current = I2C_handle->Instance->DR;\n                buffer_pointer = I2C_handle->pBuffPtr;\n                I2C_handle->pBuffPtr = buffer_pointer + 1;\n                *buffer_pointer = (uint8_t)tick_current;\n                I2C_handle->Xferdata_size = I2C_handle->Xferdata_size - 1;\n                I2C_handle->XferCount = I2C_handle->XferCount - 1;\n              }\n            }\n          }\n          I2C_handle->State = HAL_I2C_STATE_READY;\n          I2C_handle->Mode = HAL_I2C_MODE_NONE;\n          I2C_handle->Lock = HAL_UNLOCKED;\n          status = HAL_OK;\n        }\n        else if (I2C_handle->ErrorCode == 4) {\n          I2C_handle->Lock = HAL_UNLOCKED;\n          status = HAL_ERROR;\n        }\n        else {\n          I2C_handle->Lock = HAL_UNLOCKED;\n          status = HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      status = HAL_BUSY;\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "read_memory_08001f6c",
                "hi2c": "I2C_handle",
                "DevAddress": "Device_address",
                "MemAddress": "Memory_address",
                "MemAddSize": "Memory_address_size",
                "pData": "data_pointer",
                "Size": "data_size",
                "Timeout": "timeout",
                "HVar1": "status",
                "Tickstart": "tick_start",
                "uVar2": "tick_current",
                "iVar3": "result",
                "puVar4": "buffer_pointer",
                "MemAddSize_local": "local_memory_address_size",
                "MemAddress_local": "local_memory_address",
                "DevAddress_local": "local_device_address",
                "hi2c_local": "local_I2C_handle",
                "tmpreg_3": "tmp_register_3",
                "tmpreg_2": "tmp_register_2",
                "tmpreg_1": "tmp_register_1",
                "tmpreg": "tmp_register",
                "tickstart": "tick_start"
            },
            "calling": [
                "_i2c_read_reg"
            ],
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "write_data_to_i2_c_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nHAL_StatusTypeDef\nwriteDataToI2C_08002640(I2C_HandleTypeDef *hi2c,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  int loopCounter;\n  uint16_t localMemoryAddressSize;\n  uint16_t localMemoryAddress;\n  uint16_t localDeviceAddress;\n  I2C_HandleTypeDef *localI2CHandle;\n  uint32_t tempRegister;\n  \n  hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x100;\n  do {\n    if ((~hi2c->Instance->SR1 & 1) == 0) {\n      loopCounter = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - tickStart <= timeout))));\n  hi2c->PreviousState = 0;\n  hi2c->State = HAL_I2C_STATE_READY;\n  hi2c->Mode = HAL_I2C_MODE_NONE;\n  hi2c->Lock = HAL_UNLOCKED;\n  loopCounter = 3;\nLAB_0800270a:\n  if (loopCounter == 0) {\n    hi2c->Instance->DR = (byte)deviceAddress & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntiltimeout(hi2c,0x10002,timeout,tickStart);\n    if (status == HAL_OK) {\n      status = I2C_WaitOnTXEFlagUntiltimeout(hi2c,timeout,tickStart);\n      if (status == HAL_OK) {\n        if (memoryAddressSize == 1) {\n          hi2c->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        else {\n          hi2c->Instance->DR = (uint)(byte)(memoryAddress >> 8);\n          status = I2C_WaitOnTXEFlagUntiltimeout(hi2c,timeout,tickStart);\n          if (status != HAL_OK) {\n            if (hi2c->ErrorCode == 4) {\n              hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          hi2c->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        status = HAL_OK;\n      }\n      else if (hi2c->ErrorCode == 4) {\n        hi2c->Instance->CR1 = hi2c->Instance->CR1 | 0x200;\n        status = HAL_ERROR;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n    else if (hi2c->ErrorCode == 4) {\n      status = HAL_ERROR;\n    }\n    else {\n      status = HAL_TIMEOUT;\n    }\n  }\n  else {\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002640": "write_data_to_i2_c_08002640",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "iVar3": "loopCounter",
                "MemAddSize_local": "localMemoryAddressSize",
                "MemAddress_local": "localMemoryAddress",
                "DevAddress_local": "localDeviceAddress",
                "hi2c_local": "localI2CHandle",
                "tmpreg": "tempRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "read_from_i2_c_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nHAL_StatusTypeDef\nreadFromI2C_080027f4(I2C_HandleTypeDef *i2cHandle,uint16_t deviceAddress,uint16_t memoryAddress,uint16_t memoryAddressSize,\n            uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef halStatus;\n  uint32_t tickDiff;\n  int loopCounter;\n  uint16_t memoryAddressSize_local;\n  uint16_t memoryAddress_local;\n  uint16_t deviceAddress_local;\n  I2C_HandleTypeDef *i2cHandle_local;\n  uint32_t temporaryRegister;\n  \n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x400;\n  i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n  do {\n    if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n      loopCounter = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tickDiff = HAL_GetTick(), tickDiff - tickStart <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Mode = HAL_I2C_MODE_NONE;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  loopCounter = 3;\nLAB_080028d2:\n  if (loopCounter == 0) {\n    i2cHandle->Instance->DR = (byte)deviceAddress & 0xfe;\n    halStatus = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n    if (halStatus == HAL_OK) {\n      halStatus = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n      if (halStatus == HAL_OK) {\n        if (memoryAddressSize == 1) {\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        else {\n          i2cHandle->Instance->DR = (uint)(byte)(memoryAddress >> 8);\n          halStatus = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n          if (halStatus != HAL_OK) {\n            if (i2cHandle->ErrorCode == 4) {\n              i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n              return HAL_ERROR;\n            }\n            return HAL_TIMEOUT;\n          }\n          i2cHandle->Instance->DR = (uint)(byte)memoryAddress;\n        }\n        halStatus = I2C_WaitOnTXEFlagUntiltimeout(i2cHandle,timeout,tickStart);\n        if (halStatus == HAL_OK) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x100;\n          do {\n            if ((~i2cHandle->Instance->SR1 & 1) == 0) {\n              loopCounter = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (tickDiff = HAL_GetTick(), tickDiff - tickStart <= timeout))));\n          i2cHandle->PreviousState = 0;\n          i2cHandle->State = HAL_I2C_STATE_READY;\n          i2cHandle->Mode = HAL_I2C_MODE_NONE;\n          i2cHandle->Lock = HAL_UNLOCKED;\n          loopCounter = 3;\nLAB_08002a90:\n          if (loopCounter == 0) {\n            i2cHandle->Instance->DR = (uint)(byte)((byte)deviceAddress | 1);\n            halStatus = I2C_WaitOnMasterAddressFlagUntiltimeout(i2cHandle,0x10002,timeout,tickStart);\n            if (halStatus == HAL_OK) {\n              halStatus = HAL_OK;\n            }\n            else if (i2cHandle->ErrorCode == 4) {\n              halStatus = HAL_ERROR;\n            }\n            else {\n              halStatus = HAL_TIMEOUT;\n            }\n          }\n          else {\n            halStatus = HAL_TIMEOUT;\n          }\n        }\n        else if (i2cHandle->ErrorCode == 4) {\n          i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n          halStatus = HAL_ERROR;\n        }\n        else {\n          halStatus = HAL_TIMEOUT;\n        }\n      }\n      else if (i2cHandle->ErrorCode == 4) {\n        i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n        halStatus = HAL_ERROR;\n      }\n      else {\n        halStatus = HAL_TIMEOUT;\n      }\n    }\n    else if (i2cHandle->ErrorCode == 4) {\n      halStatus = HAL_ERROR;\n    }\n    else {\n      halStatus = HAL_TIMEOUT;\n    }\n  }\n  else {\n    halStatus = HAL_TIMEOUT;\n  }\n  return halStatus;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "read_from_i2_c_080027f4",
                "hi2c": "i2cHandle",
                "DevAddress": "deviceAddress",
                "MemAddress": "memoryAddress",
                "MemAddSize": "memoryAddressSize",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "halStatus",
                "uVar2": "tickDiff",
                "iVar3": "loopCounter",
                "MemAddSize_local": "memoryAddressSize_local",
                "MemAddress_local": "memoryAddress_local",
                "DevAddress_local": "deviceAddress_local",
                "hi2c_local": "i2cHandle_local",
                "tmpreg": "temporaryRegister"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_i2_c_status_08002ad8",
            "code": "\nHAL_StatusTypeDef\ncheckI2CStatus_08002ad8(I2C_HandleTypeDef *i2cHandle,uint32_t statusFlag,uint32_t timeout,uint32_t startTick)\n\n{\n  uint32_t tickDiff;\n  char isError;\n  uint tempFlag;\n  bool isNotZero;\n  uint32_t localStartTick;\n  uint32_t localTimeout;\n  uint32_t localFlag;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  do {\n    if ((statusFlag >> 0x10 & 0xff) == 1) {\n      tempFlag = statusFlag & ~i2cHandle->Instance->SR1 & 0xffff;\n      isNotZero = tempFlag != 0;\n      if (isNotZero) {\n        tempFlag = 1;\n      }\n      isError = (char)tempFlag;\n      if (!isNotZero) {\n        isError = '\\0';\n      }\n    }\n    else {\n      tempFlag = statusFlag & ~i2cHandle->Instance->SR2 & 0xffff;\n      isNotZero = tempFlag != 0;\n      if (isNotZero) {\n        tempFlag = 1;\n      }\n      isError = (char)tempFlag;\n      if (!isNotZero) {\n        isError = '\\0';\n      }\n    }\n    if (isError == '\\0') {\n      return HAL_OK;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x400) == 0x400) {\n      i2cHandle->Instance->CR1 = i2cHandle->Instance->CR1 | 0x200;\n      i2cHandle->Instance->SR1 = 0xfffffbff;\n      i2cHandle->ErrorCode = 4;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_ERROR;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (tickDiff = HAL_GetTick(), tickDiff - startTick <= timeout))));\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_i2_c_status_08002ad8",
                "hi2c": "i2cHandle",
                "Flag": "statusFlag",
                "Timeout": "timeout",
                "Tickstart": "startTick",
                "uVar1": "tickDiff",
                "cVar2": "isError",
                "uVar3": "tempFlag",
                "bVar4": "isNotZero",
                "Tickstart_local": "localStartTick",
                "Timeout_local": "localTimeout",
                "Flag_local": "localFlag",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_i2_c_status_08002bb4",
            "code": "\nHAL_StatusTypeDef check_I2C_status_08002bb4(I2C_HandleTypeDef *i2c_handle,uint32_t timeout,uint32_t tick_start)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t current_tick;\n  uint32_t local_tick_start;\n  uint32_t local_timeout;\n  I2C_HandleTypeDef *local_i2c_handle;\n  \n  while( true ) {\n    if ((i2c_handle->Instance->SR1 & 0x80) == 0x80) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2c_handle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (current_tick = HAL_GetTick(), timeout < current_tick - tick_start)))) {\n      i2c_handle->ErrorCode = i2c_handle->ErrorCode | 0x20;\n      i2c_handle->PreviousState = 0;\n      i2c_handle->State = HAL_I2C_STATE_READY;\n      i2c_handle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_i2_c_status_08002bb4",
                "hi2c": "i2c_handle",
                "Timeout": "timeout",
                "Tickstart": "tick_start",
                "HVar1": "status",
                "uVar2": "current_tick",
                "Tickstart_local": "local_tick_start",
                "Timeout_local": "local_timeout",
                "hi2c_local": "local_i2c_handle"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_i2_c_acknowledge_08002c2e",
            "code": "\nHAL_StatusTypeDef checkI2CAcknowledge_08002c2e(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickStart)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t currentTick;\n  uint32_t localTickStart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 4) == 4) {\n      return HAL_OK;\n    }\n    status = I2C_IsAcknowledgeFailed(i2cHandle);\n    if (status != HAL_OK) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (currentTick = HAL_GetTick(), timeout < currentTick - tickStart)))) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->PreviousState = 0;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_i2_c_acknowledge_08002c2e",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickStart",
                "HVar1": "status",
                "uVar2": "currentTick",
                "Tickstart_local": "localTickStart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "HAL_GetTick",
                "I2C_IsAcknowledgeFailed"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "wait_for_sr1_flag_08002ca8",
            "code": "\nHAL_StatusTypeDef waitForSR1Flag_08002ca8(I2C_HandleTypeDef *i2cHandle,uint32_t timeout,uint32_t tickstart)\n\n{\n  uint32_t currentTick;\n  uint32_t localTickstart;\n  uint32_t localTimeout;\n  I2C_HandleTypeDef *localI2CHandle;\n  \n  while( true ) {\n    if ((i2cHandle->Instance->SR1 & 0x40) == 0x40) {\n      return HAL_OK;\n    }\n    if ((i2cHandle->Instance->SR1 & 0x10) == 0x10) break;\n    if ((timeout == 0) || (currentTick = HAL_GetTick(), timeout < currentTick - tickstart)) {\n      i2cHandle->ErrorCode = i2cHandle->ErrorCode | 0x20;\n      i2cHandle->State = HAL_I2C_STATE_READY;\n      i2cHandle->Lock = HAL_UNLOCKED;\n      return HAL_TIMEOUT;\n    }\n  }\n  i2cHandle->Instance->SR1 = 0xffffffef;\n  i2cHandle->ErrorCode = 0;\n  i2cHandle->PreviousState = 0;\n  i2cHandle->State = HAL_I2C_STATE_READY;\n  i2cHandle->Lock = HAL_UNLOCKED;\n  return HAL_ERROR;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "wait_for_sr1_flag_08002ca8",
                "hi2c": "i2cHandle",
                "Timeout": "timeout",
                "Tickstart": "tickstart",
                "Tickstart_local": "localTickstart",
                "Timeout_local": "localTimeout",
                "hi2c_local": "localI2CHandle",
                "uVar1": "currentTick"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_i2c_error_08002d3c",
            "code": "\nHAL_StatusTypeDef check_i2c_error_08002d3c(I2C_HandleTypeDef *i2c_handler)\n\n{\n  bool is_error;\n  I2C_HandleTypeDef *local_i2c_handler;\n  \n  is_error = (i2c_handler->Instance->SR1 & 0x400) == 0x400;\n  if (is_error) {\n    i2c_handler->Instance->SR1 = 0xfffffbff;\n    i2c_handler->ErrorCode = 4;\n    i2c_handler->PreviousState = 0;\n    i2c_handler->State = HAL_I2C_STATE_READY;\n    i2c_handler->Lock = HAL_UNLOCKED;\n  }\n  return is_error;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_i2c_error_08002d3c",
                "hi2c": "i2c_handler",
                "bVar1": "is_error",
                "hi2c_local": "local_i2c_handler"
            },
            "calling": [
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnTXEFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "initialize_rcc_oscillators_08002d98",
            "code": "\n\n\nHAL_StatusTypeDef initializeRCCOscillators_08002d98(RCC_OscInitTypeDef *oscillatorSettings)\n\n{\n  uint32_t startTime;\n  uint32_t currentTime;\n  HAL_StatusTypeDef status;\n  bool setBit;\n  RCC_OscInitTypeDef *localOscillatorSettings;\n  uint32_t temporaryRegister;\n  uint32_t tickStartTime;\n  FlagStatus powerClockChanged;\n  \n  if ((oscillatorSettings->OscillatorType & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (oscillatorSettings->HSEState == 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (oscillatorSettings->HSEState == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (oscillatorSettings->HSEState == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (oscillatorSettings->HSEState == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (oscillatorSettings->HSEState == 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTime = HAL_GetTick();\n          if (100 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTime = HAL_GetTick();\n          if (100 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((oscillatorSettings->OscillatorType & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (oscillatorSettings->HSIState != 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 = oscillatorSettings->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (oscillatorSettings->HSIState == 0) {\n      _DAT_42420000 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 = oscillatorSettings->HSICalibrationValue << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((oscillatorSettings->OscillatorType & 8) != 0) {\n    if (oscillatorSettings->LSIState == 0) {\n      _DAT_42420480 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((oscillatorSettings->OscillatorType & 4) != 0) {\n    setBit = (_DAT_4002101c & 0x10000000) == 0;\n    if (setBit) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (oscillatorSettings->LSEState == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (oscillatorSettings->LSEState == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (oscillatorSettings->LSEState == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (oscillatorSettings->LSEState == 0) {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < currentTime - startTime) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (setBit) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((oscillatorSettings->PLL).PLLState == 0) {\nLAB_0800324a:\n    status = HAL_OK;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    status = HAL_ERROR;\n  }\n  else if ((oscillatorSettings->PLL).PLLState == 2) {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if ((oscillatorSettings->PLL).PLLSource == 0x10000) {\n          _DAT_40021004 = oscillatorSettings->HSEPredivValue | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 =\n             (oscillatorSettings->PLL).PLLMUL | (oscillatorSettings->PLL).PLLSource |\n             _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTime = HAL_GetTick();\n          if (2 < currentTime - startTime) {\n            return HAL_TIMEOUT;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    status = HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTime = HAL_GetTick();\n    } while (currentTime - startTime < 3);\n    status = HAL_TIMEOUT;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "initialize_rcc_oscillators_08002d98",
                "RCC_OscInitStruct": "oscillatorSettings",
                "uVar1": "startTime",
                "uVar2": "currentTime",
                "HVar3": "status",
                "bVar4": "setBit",
                "RCC_OscInitStruct_local": "localOscillatorSettings",
                "tmpreg": "temporaryRegister",
                "tickstart": "tickStartTime",
                "pwrclkchanged": "powerClockChanged"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "configure_clocks_08003260",
            "code": "\n\n\nHAL_StatusTypeDef configureClocks_08003260(RCC_ClkInitTypeDef *clockInitStruct,uint32_t flashLatency)\n\n{\n  uint32_t sysClockFreq;\n  uint32_t currentTick;\n  HAL_StatusTypeDef status;\n  uint32_t localFlashLatency;\n  RCC_ClkInitTypeDef *localClockInitStruct;\n  uint32_t tickStart;\n  \n  if (((_DAT_40022000 & 7) < flashLatency) &&\n     (_DAT_40022000 = flashLatency | _DAT_40022000 & 0xfffffff8, flashLatency != (flashLatency & 7))) {\n    status = HAL_ERROR;\n  }\n  else {\n    if ((clockInitStruct->ClockType & 2) != 0) {\n      _DAT_40021004 = clockInitStruct->AHBCLKDivider | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((clockInitStruct->ClockType & 1) == 0) {\nLAB_08003394:\n      if ((flashLatency < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = flashLatency | _DAT_40022000 & 0xfffffff8, flashLatency != (flashLatency & 7))) {\n        status = HAL_ERROR;\n      }\n      else {\n        if ((clockInitStruct->ClockType & 4) != 0) {\n          _DAT_40021004 = clockInitStruct->APB1CLKDivider | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((clockInitStruct->ClockType & 8) != 0) {\n          _DAT_40021004 = clockInitStruct->APB2CLKDivider << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        sysClockFreq = HAL_RCC_GetSysClockFreq();\n        SystemCoreClock = sysClockFreq >> \"\"[_DAT_40021004 >> 4 & 0xf];\n        HAL_InitTick(0xf);\n        status = HAL_OK;\n      }\n    }\n    else {\n      if (clockInitStruct->SYSCLKSource == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return HAL_ERROR;\n        }\n      }\n      else if ((clockInitStruct->SYSCLKSource != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021004 = clockInitStruct->SYSCLKSource | _DAT_40021004 & 0xfffffffc;\n      sysClockFreq = HAL_GetTick();\n      if (clockInitStruct->SYSCLKSource == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n      else if (clockInitStruct->SYSCLKSource == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentTick = HAL_GetTick();\n        } while (currentTick - sysClockFreq < 0x1389);\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003260": "configure_clocks_08003260",
                "RCC_ClkInitStruct": "clockInitStruct",
                "FLatency": "flashLatency",
                "uVar1": "sysClockFreq",
                "uVar2": "currentTick",
                "HVar3": "status",
                "FLatency_local": "localFlashLatency",
                "RCC_ClkInitStruct_local": "localClockInitStruct",
                "tickstart": "tickStart"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_GetTick",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_system_clock_frequency_08003440",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t calculateSystemClockFrequency_08003440(void)\n\n{\n  uint8_t predivFactorTable [2];\n  uint8_t pllMulFactorTable [16];\n  uint32_t pllMul;\n  uint32_t prediv;\n  uint32_t tmpReg;\n  uint32_t sysClockFreq;\n  uint32_t pllClock;\n  \n  pllMulFactorTable[0] = '\\x02';\n  pllMulFactorTable[1] = '\\x03';\n  pllMulFactorTable[2] = '\\x04';\n  pllMulFactorTable[3] = '\\x05';\n  pllMulFactorTable[4] = '\\x06';\n  pllMulFactorTable[5] = '\\a';\n  pllMulFactorTable[6] = '\\b';\n  pllMulFactorTable[7] = '\\t';\n  pllMulFactorTable[8] = '\\n';\n  pllMulFactorTable[9] = '\\v';\n  pllMulFactorTable[10] = '\\f';\n  pllMulFactorTable[11] = '\\r';\n  pllMulFactorTable[12] = '\\x0e';\n  pllMulFactorTable[13] = '\\x0f';\n  pllMulFactorTable[14] = '\\x10';\n  pllMulFactorTable[15] = '\\x10';\n  predivFactorTable[0] = '\\x01';\n  predivFactorTable[1] = '\\x02';\n  if ((_DAT_40021004 & 0xc) == 4) {\n    sysClockFreq = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      pllClock = (uint)pllMulFactorTable[_DAT_40021004 >> 0x12 & 0xf] * 4000000;\n    }\n    else {\n      pllClock = ((uint)pllMulFactorTable[_DAT_40021004 >> 0x12 & 0xf] * 8000000) /\n               (uint)predivFactorTable[_DAT_40021004 >> 0x11 & 1];\n    }\n    sysClockFreq = pllClock;\n  }\n  else {\n    sysClockFreq = 8000000;\n  }\n  return sysClockFreq;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_system_clock_frequency_08003440",
                "aPredivFactorTable": "predivFactorTable",
                "aPLLMULFactorTable": "pllMulFactorTable",
                "pllmul": "pllMul",
                "tmpreg": "tmpReg",
                "sysclockfreq": "sysClockFreq",
                "pllclk": "pllClock"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_system_core_clock_08003504",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getSystemCoreClock_08003504(void)\n\n{\n  return systemClock;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_system_core_clock_08003504",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "get_hclk_divided_by_power_of_two_08003518",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getHCLKDividedByPowerOfTwo_08003518(void)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = HAL_RCC_GetHCLKFreq();\n  return hclkFreq >> \"\"[_DAT_40021004 >> 8 & 7];\n}\n\n",
            "renaming": {
                "FUN_08003518": "get_hclk_divided_by_power_of_two_08003518",
                "uVar1": "hclkFreq"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_I2C_Init"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_adjusted_hclk_freq_08003540",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t getAdjustedHCLKFreq_08003540(void)\n\n{\n  uint32_t hclkFreq;\n  \n  hclkFreq = getHCLKFreq();\n  return hclkFreq >> \"\"[_DAT_40021004 >> 0xb & 7];\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_adjusted_hclk_freq_08003540",
                "uVar1": "hclkFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_function_08003568",
            "code": "\nvoid delayFunction_08003568(uint32_t inputDelay)\n\n{\n  bool delayInProgress;\n  uint32_t localDelay;\n  uint32_t delayCount;\n  \n  delayCount = inputDelay * (SystemCoreClock / 8000);\n  do {\n    delayInProgress = delayCount != 0;\n    delayCount = delayCount - 1;\n  } while (delayInProgress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_function_08003568",
                "mdelay": "inputDelay",
                "mdelay_local": "localDelay",
                "Delay": "delayCount",
                "bVar1": "delayInProgress"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "initialize_timer_080035a4",
            "code": "\nHAL_StatusTypeDef initializeTimer_080035a4(TIM_HandleTypeDef *timer)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_HandleTypeDef *localTimer;\n  \n  if (timer == (TIM_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (timer->State == HAL_TIM_STATE_RESET) {\n      timer->Lock = HAL_UNLOCKED;\n      HAL_TIM_Base_MspInit(timer);\n    }\n    timer->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(timer->Instance,&timer->Init);\n    timer->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "initialize_timer_080035a4",
                "htim": "timer",
                "HVar1": "status",
                "htim_local": "localTimer"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(TIM_HandleTypeDef *htim)\n\n{\n  TIM_HandleTypeDef *htim_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "enable_timer_interrupts_0800360c",
            "code": "\nHAL_StatusTypeDef enableTimerInterrupts_0800360c(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  timerHandle->Instance->DIER = timerHandle->Instance->DIER | 1;\n  timerHandle->Instance->CR1 = timerHandle->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "enable_timer_interrupts_0800360c",
                "htim": "timerHandle",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "initialize_tim_08003640",
            "code": "\nHAL_StatusTypeDef initialize_TIM_08003640(TIM_HandleTypeDef *TIM_handle)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_HandleTypeDef *local_TIM_handle;\n  \n  if (TIM_handle == (TIM_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (TIM_handle->State == HAL_TIM_STATE_RESET) {\n      TIM_handle->Lock = HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(TIM_handle);\n    }\n    TIM_handle->State = HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(TIM_handle->Instance,&TIM_handle->Init);\n    TIM_handle->State = HAL_TIM_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003640": "initialize_tim_08003640",
                "htim": "TIM_handle",
                "HVar1": "status",
                "htim_local": "local_TIM_handle"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "initialize_timer_08003696",
            "code": "\nvoid initializeTimer_08003696(TIM_HandleTypeDef *timer)\n\n{\n  TIM_HandleTypeDef *localTimer;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "initialize_timer_08003696",
                "htim": "timer",
                "htim_local": "localTimer"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "initialize_timer_channel_080036a8",
            "code": "\nHAL_StatusTypeDef initializeTimerChannel_080036a8(TIM_HandleTypeDef *timerHandle,uint32_t channel)\n\n{\n  uint32_t localChannel;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  TIM_CCxchannelCmd(timerHandle->Instance,channel,1);\n  if (timerHandle->Instance == (TIM_TypeDef *)0x40012c00) {\n    timerHandle->Instance->BDTR = timerHandle->Instance->BDTR | 0x8000;\n  }\n  timerHandle->Instance->CR1 = timerHandle->Instance->CR1 | 1;\n  return HAL_OK;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "initialize_timer_channel_080036a8",
                "htim": "timerHandle",
                "Channel": "channel",
                "Channel_local": "localChannel",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "main"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "handle_timer_interrupts_080036f8",
            "code": "\nvoid handleTimerInterrupts_080036f8(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (((timerHandle->Instance->SR & 2) == 2) && ((timerHandle->Instance->DIER & 2) == 2)) {\n    timerHandle->Instance->SR = 0xfffffffd;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((timerHandle->Instance->CCMR1 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timerHandle->Instance->SR & 4) == 4) && ((timerHandle->Instance->DIER & 4) == 4)) {\n    timerHandle->Instance->SR = 0xfffffffb;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((timerHandle->Instance->CCMR1 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timerHandle->Instance->SR & 8) == 8) && ((timerHandle->Instance->DIER & 8) == 8)) {\n    timerHandle->Instance->SR = 0xfffffff7;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((timerHandle->Instance->CCMR2 & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timerHandle->Instance->SR & 0x10) == 0x10) && ((timerHandle->Instance->DIER & 0x10) == 0x10)) {\n    timerHandle->Instance->SR = 0xffffffef;\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((timerHandle->Instance->CCMR2 & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timerHandle);\n      HAL_TIM_PWM_PulseFinishedCallback(timerHandle);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timerHandle);\n    }\n    timerHandle->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  if (((timerHandle->Instance->SR & 1) == 1) && ((timerHandle->Instance->DIER & 1) == 1)) {\n    timerHandle->Instance->SR = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timerHandle);\n  }\n  if (((timerHandle->Instance->SR & 0x80) == 0x80) && ((timerHandle->Instance->DIER & 0x80) == 0x80)) {\n    timerHandle->Instance->SR = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timerHandle);\n  }\n  if (((timerHandle->Instance->SR & 0x40) == 0x40) && ((timerHandle->Instance->DIER & 0x40) == 0x40)) {\n    timerHandle->Instance->SR = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timerHandle);\n  }\n  if (((timerHandle->Instance->SR & 0x20) == 0x20) && ((timerHandle->Instance->DIER & 0x20) == 0x20)) {\n    timerHandle->Instance->SR = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timerHandle);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "handle_timer_interrupts_080036f8",
                "htim": "timerHandle",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "configure_timer_output_channel_08003908",
            "code": "\nHAL_StatusTypeDef configureTimerOutputChannel_08003908(TIM_HandleTypeDef *timerHandle,TIM_OC_InitTypeDef *outputConfig,uint32_t channel)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t localChannel;\n  TIM_OC_InitTypeDef *localOutputConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    switch(channel) {\n    case 0:\n      TIM_OC1_SetConfig(timerHandle->Instance,outputConfig);\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 | 8;\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 & 0xfffffffb;\n      timerHandle->Instance->CCMR1 = outputConfig->OCFastMode | timerHandle->Instance->CCMR1;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(timerHandle->Instance,outputConfig);\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 | 0x800;\n      timerHandle->Instance->CCMR1 = timerHandle->Instance->CCMR1 & 0xfffffbff;\n      timerHandle->Instance->CCMR1 = outputConfig->OCFastMode << 8 | timerHandle->Instance->CCMR1;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(timerHandle->Instance,outputConfig);\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 | 8;\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 & 0xfffffffb;\n      timerHandle->Instance->CCMR2 = outputConfig->OCFastMode | timerHandle->Instance->CCMR2;\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(timerHandle->Instance,outputConfig);\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 | 0x800;\n      timerHandle->Instance->CCMR2 = timerHandle->Instance->CCMR2 & 0xfffffbff;\n      timerHandle->Instance->CCMR2 = outputConfig->OCFastMode << 8 | timerHandle->Instance->CCMR2;\n    }\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003908": "configure_timer_output_channel_08003908",
                "htim": "timerHandle",
                "sConfig": "outputConfig",
                "Channel": "channel",
                "HVar1": "status",
                "Channel_local": "localChannel",
                "sConfig_local": "localOutputConfig",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_OC4_SetConfig",
                "TIM_OC3_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC2_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "configure_timer_clock_08003a94",
            "code": "\nHAL_StatusTypeDef configureTimerClock_08003a94(TIM_HandleTypeDef *timerHandle,TIM_ClockConfigTypeDef *clockConfig)\n\n{\n  HAL_StatusTypeDef status;\n  uint clockSource;\n  TIM_ClockConfigTypeDef *localClockConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  uint32_t tempSmcr;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffff0088;\n    clockSource = clockConfig->ClockSource;\n    if (clockSource == 0x40) {\n      TIM_TI1_ConfigInputStage\n                (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      TIM_ITRx_SetConfig(timerHandle->Instance,0x40);\n    }\n    else if (clockSource < 0x41) {\n      if (clockSource == 0x10) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x10);\n      }\n      else if (clockSource < 0x11) {\n        if (clockSource == 0) {\n          TIM_ITRx_SetConfig(timerHandle->Instance,0);\n        }\n      }\n      else if (clockSource == 0x20) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x20);\n      }\n      else if (clockSource == 0x30) {\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x30);\n      }\n    }\n    else if (clockSource == 0x70) {\n      TIM_ETR_SetConfig(timerHandle->Instance,clockConfig->ClockPrescaler,\n                        clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffffff88 | 0x77;\n    }\n    else if (clockSource < 0x71) {\n      if (clockSource == 0x50) {\n        TIM_TI1_ConfigInputStage\n                  (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x50);\n      }\n      else if (clockSource == 0x60) {\n        TIM_TI2_ConfigInputStage\n                  (timerHandle->Instance,clockConfig->ClockPolarity,clockConfig->ClockFilter)\n        ;\n        TIM_ITRx_SetConfig(timerHandle->Instance,0x60);\n      }\n    }\n    else if (clockSource == 0x1000) {\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xfffffff8;\n    }\n    else if (clockSource == 0x2000) {\n      TIM_ETR_SetConfig(timerHandle->Instance,clockConfig->ClockPrescaler,\n                        clockConfig->ClockPolarity,clockConfig->ClockFilter);\n      timerHandle->Instance->SMCR = timerHandle->Instance->SMCR | 0x4000;\n    }\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "configure_timer_clock_08003a94",
                "htim": "timerHandle",
                "sClockSourceConfig": "clockConfig",
                "HVar1": "status",
                "uVar2": "clockSource",
                "sClockSourceConfig_local": "localClockConfig",
                "htim_local": "localTimerHandle",
                "tmpsmcr": "tempSmcr"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_ETR_SetConfig",
                "TIM_TI2_ConfigInputStage",
                "TIM_TI1_ConfigInputStage",
                "TIM_ITRx_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "initialize_timer_08003c4a",
            "code": "\nvoid initializeTimer_08003c4a(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "initialize_timer_08003c4a",
                "htim": "timerHandle",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "initialize_timer_08003c5c",
            "code": "\nvoid initialize_timer_08003c5c(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *timer_handle_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "initialize_timer_08003c5c",
                "htim": "timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "initialize_timer_08003c6e",
            "code": "\nvoid initialize_timer_08003c6e(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *timer_handle_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "initialize_timer_08003c6e",
                "htim": "timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "init_tim_08003c80",
            "code": "\nvoid init_TIM_08003c80(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *local_timer_handle;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "init_tim_08003c80",
                "htim": "timer_handle",
                "htim_local": "local_timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "configure_timer_08003c94",
            "code": "\nvoid configureTimer_08003c94(TIM_TypeDef *timer,TIM_Base_InitTypeDef *timerConfig)\n\n{\n  TIM_Base_InitTypeDef *localConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t timerCR1;\n  \n  timerCR1 = timer->CR1;\n  if ((((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n      (timer == (TIM_TypeDef *)0x40000400)) || (timer == (TIM_TypeDef *)0x40000800)) {\n    timerCR1 = timerConfig->CounterMode | timerCR1 & 0xffffff8f;\n  }\n  if (((timer == (TIM_TypeDef *)0x40012c00) || (timer == (TIM_TypeDef *)0x40000000)) ||\n     ((timer == (TIM_TypeDef *)0x40000400 || (timer == (TIM_TypeDef *)0x40000800)))) {\n    timerCR1 = timerConfig->ClockDivision | timerCR1 & 0xfffffcff;\n  }\n  timer->CR1 = timerConfig->AutoReloadPreload | timerCR1 & 0xffffff7f;\n  timer->ARR = timerConfig->Period;\n  timer->PSC = timerConfig->Prescaler;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    uRam40012c30 = timerConfig->RepetitionCounter;\n  }\n  timer->EGR = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "configure_timer_08003c94",
                "TIMx": "timer",
                "Structure": "timerConfig",
                "Structure_local": "localConfig",
                "TIMx_local": "localTimer",
                "tmpcr1": "timerCR1"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "configure_tim_output_compare_08003d60",
            "code": "\nvoid configureTimOutputCompare_08003d60(TIM_TypeDef *timerInstance,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint ocMode;\n  uint32_t ocPolarity;\n  TIM_OC_InitTypeDef *localOutputCompareConfig;\n  TIM_TypeDef *localTimerInstance;\n  uint32_t tempCCMRx;\n  uint32_t tempCR2;\n  uint32_t tempCCER;\n  \n  timerInstance->CCER = timerInstance->CCER & 0xfffffffe;\n  tempCR2 = timerInstance->CR2;\n  ocMode = outputCompareConfig->OCMode;\n  ocPolarity = outputCompareConfig->OCPolarity | timerInstance->CCER & 0xfffffffd;\n  if (timerInstance == (TIM_TypeDef *)0x40012c00) {\n    ocPolarity = (outputCompareConfig->OCNPolarity | ocPolarity & 0xfffffff7) & 0xfffffffb;\n    tempCR2 = outputCompareConfig->OCNIdleState | outputCompareConfig->OCIdleState | tempCR2 & 0xfffffcff;\n  }\n  timerInstance->CR2 = tempCR2;\n  timerInstance->CCMR1 = ocMode | timerInstance->CCMR1 & 0xffffff8c;\n  timerInstance->CCR1 = outputCompareConfig->Pulse;\n  timerInstance->CCER = ocPolarity;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "configure_tim_output_compare_08003d60",
                "TIMx": "timerInstance",
                "OC_Config": "outputCompareConfig",
                "uVar1": "ocMode",
                "uVar2": "ocPolarity",
                "OC_Config_local": "localOutputCompareConfig",
                "TIMx_local": "localTimerInstance",
                "tmpccmrx": "tempCCMRx",
                "tmpcr2": "tempCR2",
                "tmpccer": "tempCCER"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "initialize_timer_output_compare_08003e38",
            "code": "\nvoid initializeTimerOutputCompare_08003e38(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint32_t ocMode;\n  uint32_t ocPolarity;\n  TIM_OC_InitTypeDef *outputCompareConfigLocal;\n  TIM_TypeDef *timerLocal;\n  uint32_t tmpCcmrx;\n  uint32_t tmpCr2;\n  uint32_t tmpCcer;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  tmpCr2 = timer->CR2;\n  ocMode = outputCompareConfig->OCMode;\n  ocPolarity = outputCompareConfig->OCPolarity << 4 | timer->CCER & 0xffffffdf;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    ocPolarity = (outputCompareConfig->OCNPolarity << 4 | ocPolarity & 0xffffff7f) & 0xffffffbf;\n    tmpCr2 = outputCompareConfig->OCNIdleState << 2 | outputCompareConfig->OCIdleState << 2 | tmpCr2 & 0xfffff3ff;\n  }\n  timer->CR2 = tmpCr2;\n  timer->CCMR1 = ocMode << 8 | timer->CCMR1 & 0xffff8cff;\n  timer->CCR2 = outputCompareConfig->Pulse;\n  timer->CCER = ocPolarity;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "initialize_timer_output_compare_08003e38",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "uVar1": "ocMode",
                "uVar2": "ocPolarity",
                "OC_Config_local": "outputCompareConfigLocal",
                "TIMx_local": "timerLocal",
                "tmpccmrx": "tmpCcmrx",
                "tmpcr2": "tmpCr2",
                "tmpccer": "tmpCcer"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "configure_timer_output_compare_08003f18",
            "code": "\nvoid configureTimerOutputCompare_08003f18(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputCompareConfig)\n\n{\n  uint outputCompareMode;\n  uint32_t outputCompareConfiguration;\n  TIM_OC_InitTypeDef *outputCompareConfig_local;\n  TIM_TypeDef *timer_local;\n  uint32_t temporaryCCMRX;\n  uint32_t temporaryCR2;\n  uint32_t temporaryCCER;\n  \n  timer->CCER = timer->CCER & 0xfffffeff;\n  temporaryCR2 = timer->CR2;\n  outputCompareMode = outputCompareConfig->OCMode;\n  outputCompareConfiguration = outputCompareConfig->OCPolarity << 8 | timer->CCER & 0xfffffdff;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    outputCompareConfiguration = (outputCompareConfig->OCNPolarity << 8 | outputCompareConfiguration & 0xfffff7ff) & 0xfffffbff;\n    temporaryCR2 = outputCompareConfig->OCNIdleState << 4 | outputCompareConfig->OCIdleState << 4 | temporaryCR2 & 0xffffcfff;\n  }\n  timer->CR2 = temporaryCR2;\n  timer->CCMR2 = outputCompareMode | timer->CCMR2 & 0xffffff8c;\n  timer->CCR3 = outputCompareConfig->Pulse;\n  timer->CCER = outputCompareConfiguration;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "configure_timer_output_compare_08003f18",
                "TIMx": "timer",
                "OC_Config": "outputCompareConfig",
                "OC_Config_local": "outputCompareConfig_local",
                "TIMx_local": "timer_local",
                "tmpccmrx": "temporaryCCMRX",
                "tmpcr2": "temporaryCR2",
                "tmpccer": "temporaryCCER",
                "uVar1": "outputCompareMode",
                "uVar2": "outputCompareConfiguration"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "configure_timer_output_08003ff8",
            "code": "\nvoid configureTimerOutput_08003ff8(TIM_TypeDef *timer,TIM_OC_InitTypeDef *outputConfig)\n\n{\n  uint32_t outputMode;\n  uint32_t outputPolarity;\n  TIM_OC_InitTypeDef *localOutputConfig;\n  TIM_TypeDef *localTimer;\n  uint32_t temporaryCCER;\n  uint32_t temporaryCCMRX;\n  uint32_t temporaryCR2;\n  \n  timer->CCER = timer->CCER & 0xffffefff;\n  temporaryCR2 = timer->CR2;\n  outputMode = outputConfig->OCMode;\n  outputPolarity = outputConfig->OCPolarity;\n  if (timer == (TIM_TypeDef *)0x40012c00) {\n    temporaryCR2 = outputConfig->OCIdleState << 6 | temporaryCR2 & 0xffffbfff;\n  }\n  timer->CR2 = temporaryCR2;\n  timer->CCMR2 = outputMode << 8 | timer->CCMR2 & 0xffff8cff;\n  timer->CCR4 = outputConfig->Pulse;\n  timer->CCER = outputPolarity << 0xc | timer->CCER & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "configure_timer_output_08003ff8",
                "TIMx": "timer",
                "OC_Config": "outputConfig",
                "OC_Config_local": "localOutputConfig",
                "TIMx_local": "localTimer",
                "tmpccer": "temporaryCCER",
                "tmpccmrx": "temporaryCCMRX",
                "tmpcr2": "temporaryCR2",
                "uVar1": "outputMode",
                "uVar2": "outputPolarity"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "configure_timer_input_capture_080040a0",
            "code": "\nvoid configureTimerInputCapture_080040a0(TIM_TypeDef *timer,uint32_t polarity,uint32_t filter)\n\n{\n  uint originalCCR;\n  uint32_t localFilter;\n  uint32_t localPolarity;\n  TIM_TypeDef *localTimer;\n  uint32_t updatedCCR;\n  uint32_t updatedCCMR1;\n  \n  originalCCR = timer->CCER;\n  timer->CCER = timer->CCER & 0xfffffffe;\n  timer->CCMR1 = filter << 4 | timer->CCMR1 & 0xffffff0f;\n  timer->CCER = polarity | originalCCR & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "configure_timer_input_capture_080040a0",
                "TIMx": "timer",
                "TIM_ICPolarity": "polarity",
                "TIM_ICFilter": "filter",
                "uVar1": "originalCCR",
                "TIM_ICFilter_local": "localFilter",
                "TIM_ICPolarity_local": "localPolarity",
                "TIMx_local": "localTimer",
                "tmpccer": "updatedCCR",
                "tmpccmr1": "updatedCCMR1"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "configure_input_capture_08004104",
            "code": "\nvoid configureInputCapture_08004104(TIM_TypeDef *timer,uint32_t inputPolarity,uint32_t inputFilter)\n\n{\n  uint32_t localInputFilter;\n  uint32_t localInputPolarity;\n  TIM_TypeDef *localTimer;\n  uint32_t tempCCER;\n  uint32_t tempCCMR1;\n  \n  timer->CCER = timer->CCER & 0xffffffef;\n  timer->CCMR1 = inputFilter << 0xc | timer->CCMR1 & 0xffff0fff;\n  timer->CCER = inputPolarity << 4 | timer->CCER & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "configure_input_capture_08004104",
                "TIMx": "timer",
                "TIM_ICPolarity": "inputPolarity",
                "TIM_ICFilter": "inputFilter",
                "TIM_ICFilter_local": "localInputFilter",
                "TIM_ICPolarity_local": "localInputPolarity",
                "TIMx_local": "localTimer",
                "tmpccer": "tempCCER",
                "tmpccmr1": "tempCCMR1"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "configure_timer_0800416a",
            "code": "\nvoid configureTimer_0800416a(TIM_TypeDef *timer,uint16_t triggerSource)\n\n{\n  uint16_t localTriggerSource;\n  TIM_TypeDef *localTimer;\n  uint32_t temporarySMCR;\n  \n  timer->SMCR = timer->SMCR & 0xffffff8f | (uint)(triggerSource | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "configure_timer_0800416a",
                "TIMx": "timer",
                "InputTriggerSource": "triggerSource",
                "InputTriggerSource_local": "localTriggerSource",
                "TIMx_local": "localTimer",
                "tmpsmcr": "temporarySMCR"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "configure_external_trigger_080041a8",
            "code": "\nvoid configureExternalTrigger_080041a8(TIM_TypeDef *timer,uint32_t prescaler,uint32_t polarity,\n                 uint32_t filter)\n\n{\n  uint32_t localFilter;\n  uint32_t localPolarity;\n  uint32_t localPrescaler;\n  TIM_TypeDef *localTimer;\n  uint32_t temporarySMCR;\n  \n  timer->SMCR = prescaler | filter << 8 | polarity |\n               timer->SMCR & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "configure_external_trigger_080041a8",
                "TIMx": "timer",
                "TIM_ExtTRGPrescaler": "prescaler",
                "TIM_ExtTRGPolarity": "polarity",
                "ExtTRGFilter": "filter",
                "ExtTRGFilter_local": "localFilter",
                "TIM_ExtTRGPolarity_local": "localPolarity",
                "TIM_ExtTRGPrescaler_local": "localPrescaler",
                "TIMx_local": "localTimer",
                "tmpsmcr": "temporarySMCR"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "set_channel_state_080041ea",
            "code": "\nvoid setChannelState_080041ea(TIM_TypeDef *tim,uint32_t channel,uint32_t channelState)\n\n{\n  uint32_t localChannelState;\n  uint32_t localChannel;\n  TIM_TypeDef *localTim;\n  uint32_t temporary;\n  \n  tim->CCER = tim->CCER & ~(1 << (channel & 0xff));\n  tim->CCER = tim->CCER | channelState << (channel & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "set_channel_state_080041ea",
                "TIMx": "tim",
                "Channel": "channel",
                "ChannelState": "channelState",
                "ChannelState_local": "localChannelState",
                "Channel_local": "localChannel",
                "TIMx_local": "localTim",
                "tmp": "temporary"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "set_break_dead_time_config_0800422e",
            "code": "\nHAL_StatusTypeDef\nsetBreakDeadTimeConfig_0800422e(TIM_HandleTypeDef *timer,TIM_BreakDeadTimeConfigTypeDef *config)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_BreakDeadTimeConfigTypeDef *localConfig;\n  TIM_HandleTypeDef *localTimer;\n  uint32_t bdtr;\n  \n  if (timer->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timer->Lock = HAL_LOCKED;\n    timer->Instance->BDTR =\n         config->AutomaticOutput |\n         (config->AutomaticOutput |\n         (config->BreakPolarity |\n         (config->BreakState |\n         (config->OffStateRunMode |\n         (config->OffStateIDLEMode |\n         (config->LockLevel | config->DeadTime & 0xfffffcff) &\n         0xfffffbff) & 0xfffff7ff) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    timer->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "set_break_dead_time_config_0800422e",
                "htim": "timer",
                "sBreakDeadTimeConfig": "config",
                "HVar1": "status",
                "sBreakDeadTimeConfig_local": "localConfig",
                "htim_local": "localTimer",
                "tmpbdtr": "bdtr"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "configure_master_mode_080042de",
            "code": "\nHAL_StatusTypeDef configureMasterMode_080042de(TIM_HandleTypeDef *timerHandle,TIM_MasterConfigTypeDef *masterConfig)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_MasterConfigTypeDef *localMasterConfig;\n  TIM_HandleTypeDef *localTimerHandle;\n  \n  if (timerHandle->Lock == HAL_LOCKED) {\n    status = HAL_BUSY;\n  }\n  else {\n    timerHandle->Lock = HAL_LOCKED;\n    timerHandle->State = HAL_TIM_STATE_BUSY;\n    timerHandle->Instance->CR2 = timerHandle->Instance->CR2 & 0xffffff8f;\n    timerHandle->Instance->CR2 = masterConfig->MasterOutputTrigger | timerHandle->Instance->CR2;\n    timerHandle->Instance->SMCR = timerHandle->Instance->SMCR & 0xffffff7f;\n    timerHandle->Instance->SMCR = masterConfig->MasterSlaveMode | timerHandle->Instance->SMCR;\n    timerHandle->State = HAL_TIM_STATE_READY;\n    timerHandle->Lock = HAL_UNLOCKED;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080042de": "configure_master_mode_080042de",
                "htim": "timerHandle",
                "sMasterConfig": "masterConfig",
                "HVar1": "status",
                "sMasterConfig_local": "localMasterConfig",
                "htim_local": "localTimerHandle"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "handle_timer_interrupt_08004366",
            "code": "\nvoid handle_timer_interrupt_08004366(TIM_HandleTypeDef *timer_handler)\n\n{\n  TIM_HandleTypeDef *timer_handler_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "handle_timer_interrupt_08004366",
                "htim": "timer_handler"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "initialize_timer_08004378",
            "code": "\nvoid initialize_timer_08004378(TIM_HandleTypeDef *timer_handle)\n\n{\n  TIM_HandleTypeDef *timer_handle_local;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "initialize_timer_08004378",
                "htim": "timer_handle"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_uart_0800438a",
            "code": "\nHAL_StatusTypeDef initializeUART_0800438a(UART_HandleTypeDef *uartHandle)\n\n{\n  HAL_StatusTypeDef status;\n  UART_HandleTypeDef *localUartHandle;\n  \n  if (uartHandle == (UART_HandleTypeDef *)0x0) {\n    status = HAL_ERROR;\n  }\n  else {\n    if (uartHandle->gState == HAL_UART_STATE_RESET) {\n      uartHandle->Lock = HAL_UNLOCKED;\n      HAL_UART_MspInit(uartHandle);\n    }\n    uartHandle->gState = HAL_UART_STATE_BUSY;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xffffdfff;\n    UART_SetConfig(uartHandle);\n    uartHandle->Instance->CR2 = uartHandle->Instance->CR2 & 0xffffb7ff;\n    uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xffffffd5;\n    uartHandle->Instance->CR1 = uartHandle->Instance->CR1 | 0x2000;\n    uartHandle->ErrorCode = 0;\n    uartHandle->gState = HAL_UART_STATE_READY;\n    uartHandle->RxState = HAL_UART_STATE_READY;\n    status = HAL_OK;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_uart_0800438a",
                "huart": "uartHandle",
                "HVar1": "status",
                "huart_local": "localUartHandle"
            },
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "initialize_uart_08004424",
            "code": "\nvoid initialize_uart_08004424(UART_HandleTypeDef *uart_handle)\n\n{\n  UART_HandleTypeDef *local_uart_handle;\n  \n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "initialize_uart_08004424",
                "huart": "uart_handle",
                "huart_local": "local_uart_handle"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "send_data_via_uart_08004436",
            "code": "\nHAL_StatusTypeDef\nsendDataViaUART_08004436(UART_HandleTypeDef *uartHandle,uint8_t *data,uint16_t dataSize,uint32_t timeout)\n\n{\n  uint32_t startTick;\n  uint32_t currentTick;\n  HAL_StatusTypeDef status;\n  int loopCounter;\n  uint32_t localTimeout;\n  uint16_t localSize;\n  uint8_t *localData;\n  UART_HandleTypeDef *localUartHandle;\n  uint16_t *tmpArray;\n  uint32_t startTime;\n  \n  if (uartHandle->gState == HAL_UART_STATE_READY) {\n    if ((data == (uint8_t *)0x0) || (dataSize == 0)) {\n      status = HAL_ERROR;\n    }\n    else if (uartHandle->Lock == HAL_LOCKED) {\n      status = HAL_BUSY;\n    }\n    else {\n      uartHandle->Lock = HAL_LOCKED;\n      uartHandle->ErrorCode = 0;\n      uartHandle->gState = HAL_UART_STATE_BUSY_TX;\n      startTick = HAL_GetTick();\n      uartHandle->TxXferdataSize = dataSize;\n      uartHandle->TxXferCount = dataSize;\n      localData = data;\n      while (uartHandle->TxXferCount != 0) {\n        uartHandle->TxXferCount = uartHandle->TxXferCount - 1;\n        if ((uartHandle->Init).WordLength == 0x1000) {\n          do {\n            if ((uartHandle->Instance->SR & 0x80) == 0x80) {\n              loopCounter = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n          uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n          uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n          uartHandle->gState = HAL_UART_STATE_READY;\n          uartHandle->RxState = HAL_UART_STATE_READY;\n          uartHandle->Lock = HAL_UNLOCKED;\n          loopCounter = 3;\nLAB_0800454c:\n          if (loopCounter != 0) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = *(ushort *)localData & 0x1ff;\n          if ((uartHandle->Init).Parity == 0) {\n            localData = localData + 2;\n          }\n          else {\n            localData = localData + 1;\n          }\n        }\n        else {\n          do {\n            if ((uartHandle->Instance->SR & 0x80) == 0x80) {\n              loopCounter = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n          uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n          uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n          uartHandle->gState = HAL_UART_STATE_READY;\n          uartHandle->RxState = HAL_UART_STATE_READY;\n          uartHandle->Lock = HAL_UNLOCKED;\n          loopCounter = 3;\nLAB_08004614:\n          if (loopCounter != 0) {\n            return HAL_TIMEOUT;\n          }\n          uartHandle->Instance->DR = (uint)*localData;\n          localData = localData + 1;\n        }\n      }\n      do {\n        if ((uartHandle->Instance->SR & 0x40) == 0x40) {\n          loopCounter = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (currentTick = HAL_GetTick(), currentTick - startTick <= timeout))));\n      uartHandle->Instance->CR1 = uartHandle->Instance->CR1 & 0xfffffe5f;\n      uartHandle->Instance->CR3 = uartHandle->Instance->CR3 & 0xfffffffe;\n      uartHandle->gState = HAL_UART_STATE_READY;\n      uartHandle->RxState = HAL_UART_STATE_READY;\n      uartHandle->Lock = HAL_UNLOCKED;\n      loopCounter = 3;\nLAB_080046c6:\n      if (loopCounter == 0) {\n        uartHandle->gState = HAL_UART_STATE_READY;\n        uartHandle->Lock = HAL_UNLOCKED;\n        status = HAL_OK;\n      }\n      else {\n        status = HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    status = HAL_BUSY;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08004436": "send_data_via_uart_08004436",
                "huart": "uartHandle",
                "pData": "data",
                "Size": "dataSize",
                "Timeout": "timeout",
                "uVar1": "startTick",
                "uVar2": "currentTick",
                "HVar3": "status",
                "iVar4": "loopCounter",
                "Timeout_local": "localTimeout",
                "Size_local": "localSize",
                "pData_local": "localData",
                "huart_local": "localUartHandle",
                "tmp": "tmpArray",
                "tickstart": "startTime"
            },
            "calling": [
                "uart_print"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "initialize_uart_080046ec",
            "code": "\nvoid initialize_uart_080046ec(uart *uart)\n\n{\n  uint32_t variable_1;\n  uint32_t variable_2;\n  uint32_t variable_3;\n  uint32_t variable_4;\n  uint32_t variable_5;\n  uint32_t variable_6;\n  uint32_t variable_7;\n  uint32_t variable_8;\n  uint32_t variable_9;\n  uart *uart_local;\n  uint32_t temporary_register;\n  \n  uart->instance->control_register_2 = (uart->initialization).stop_bits | uart->instance->control_register_2 & 0xffffcfff;\n  uart->instance->control_register_1 =\n       uart->instance->control_register_1 & 0xffffe9f3 |\n       (uart->initialization).mode | (uart->initialization).word_length | (uart->initialization).parity;\n  uart->instance->control_register_3 = (uart->initialization).hardware_flow_control | uart->instance->control_register_3 & 0xfffffcff;\n  if (uart->instance == (USART_TypeDef *)0x40013800) {\n    variable_1 = get_pclk2_freq();\n    variable_6 = (uart->initialization).baud_rate;\n    variable_2 = get_pclk2_freq();\n    variable_7 = (uart->initialization).baud_rate;\n    variable_3 = get_pclk2_freq();\n    variable_8 = (uart->initialization).baud_rate;\n    variable_4 = get_pclk2_freq();\n    variable_9 = (uart->initialization).baud_rate;\n    variable_5 = get_pclk2_freq();\n    uart->instance->BRR =\n         ((((variable_4 * 0x19) / (variable_9 << 2) +\n           (int)(((unsigned_long_long)(variable_5 * 0x19) / (unsigned_long_long)((uart->initialization).baud_rate << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) +\n         (int)(((unsigned_long_long)(variable_1 * 0x19) / (unsigned_long_long)(variable_6 << 2)) / 100) * 0x10 +\n         ((((variable_2 * 0x19) / (variable_7 << 2) +\n           (int)(((unsigned_long_long)(variable_3 * 0x19) / (unsigned_long_long)(variable_8 << 2)) / 100) * -100) * 0x10 + 0x32)\n          / 100 & 0xf0);\n  }\n  else {\n    variable_1 = get_pclk1_freq();\n    variable_6 = (uart->initialization).baud_rate;\n    variable_2 = get_pclk1_freq();\n    variable_7 = (uart->initialization).baud_rate;\n    variable_3 = get_pclk1_freq();\n    variable_8 = (uart->initialization).baud_rate;\n    variable_4 = get_pclk1_freq();\n    variable_9 = (uart->initialization).baud_rate;\n    variable_5 = get_pclk1_freq();\n    uart->instance->BRR =\n         ((((variable_4 * 0x19) / (variable_9 << 2) +\n           (int)(((unsigned_long_long)(variable_5 * 0x19) / (unsigned_long_long)((uart->initialization).baud_rate << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) +\n         (int)(((unsigned_long_long)(variable_1 * 0x19) / (unsigned_long_long)(variable_6 << 2)) / 100) * 0x10 +\n         ((((variable_2 * 0x19) / (variable_7 << 2) +\n           (int)(((unsigned_long_long)(variable_3 * 0x19) / (unsigned_long_long)(variable_8 << 2)) / 100) * -100) * 0x10 + 0x32)\n          / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "initialize_uart_080046ec",
                "UART_HandleTypeDef": "uart",
                "huart": "uart",
                "Instance": "instance",
                "CR2": "control_register_2",
                "CR1": "control_register_1",
                "CR3": "control_register_3",
                "Init": "initialization",
                "StopBits": "stop_bits",
                "Mode": "mode",
                "WordLength": "word_length",
                "Parity": "parity",
                "HwFlowCtl": "hardware_flow_control",
                "BaudRate": "baud_rate",
                "tmpreg": "temporary_register",
                "uVar1": "variable_1",
                "uVar2": "variable_2",
                "uVar3": "variable_3",
                "uVar4": "variable_4",
                "uVar5": "variable_5",
                "uVar6": "variable_6",
                "uVar7": "variable_7",
                "uVar8": "variable_8",
                "uVar9": "variable_9",
                "HAL_RCC_GetPCLK2Freq": "get_pclk2_freq",
                "HAL_RCC_GetPCLK1Freq": "get_pclk1_freq",
                "ulonglong": "unsigned_long_long"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_mpu6050_0800491c",
            "code": "\nvoid initializeMpu6050_0800491c(Mpu6050 *sensor)\n\n{\n  Mpu6050 *sensor_local;\n  uint8_t writeData1;\n  uint8_t writeData2;\n  uint8_t writeDataArray [5];\n  \n  writeData1 = '\\0';\n  (*writeRegister)(0xd0,'k',&writeData1,1);\n  writeData2 = '\\x10';\n  (*writeRegister)(0xd0,'\\x1c',&writeData2,1);\n  writeDataArray[0] = '\\b';\n  (*writeRegister)(0xd0,'\\x1b',writeDataArray,1);\n  sensor->accelerationX = 0.0;\n  sensor->accelerationY = 0.0;\n  sensor->accelerationZ = 0.0;\n  sensor->temperature = 0.0;\n  sensor->gyroscopeX = 0.0;\n  sensor->gyroscopeY = 0.0;\n  sensor->gyroscopeZ = 0.0;\n  sensor->gyroscopeXOffset = 0.0;\n  sensor->gyroscopeYOffset = 0.0;\n  sensor->accelerationPitchOffset = 0.0;\n  sensor->accelerationRollOffset = 0.0;\n  calibrateMpu6050(sensor);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_mpu6050_0800491c",
                "mpu6050": "sensor",
                "local_13": "writeData1",
                "local_12": "writeData2",
                "local_11": "writeDataArray",
                "I2C_Write_Reg": "writeRegister",
                "accX": "accelerationX",
                "accY": "accelerationY",
                "accZ": "accelerationZ",
                "temp": "temperature",
                "gyroX": "gyroscopeX",
                "gyroY": "gyroscopeY",
                "gyroZ": "gyroscopeZ",
                "offset_gyroX": "gyroscopeXOffset",
                "offset_gyroY": "gyroscopeYOffset",
                "offset_acc_pitch": "accelerationPitchOffset",
                "offset_acc_roll": "accelerationRollOffset",
                "mpu6050_calibrate": "calibrateMpu6050"
            },
            "calling": [
                "main"
            ],
            "called": [
                "mpu6050_calibrate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_sensor_offsets_080049cc",
            "code": "\nvosampleIndexd calculateSensorOffsets_080049cc(Mpu6050 *sensor)\n\n{\n  undefsampleIndexned4 sampleCount;\n  float offset;\n  Mpu6050 *localSensor;\n  float rollAcceleration;\n  float pitchAcceleration;\n  usampleIndexnt32_t currentTimestamp;\n  sampleIndexnt numSamples;\n  sampleIndexnt sampleIndex;\n  float rollOffset;\n  float pitchOffset;\n  float gyroYOffset;\n  float gyroXOffset;\n  \n  numSamples = 1;\n  gyroXOffset = 0.0;\n  gyroYOffset = 0.0;\n  pitchOffset = 0.0;\n  rollOffset = 0.0;\n  currentTimestamp = (*getCurrentTimestamp)();\n  sampleIndex = 0;\n  whsampleIndexle( true ) {\n    sampleIndexf (numSamples <= sampleIndex) break;\n    pitchAcceleration = 0.0;\n    rollAcceleration = 0.0;\n    sensor_update(sensor);\n    sensor_calc_pitchAcceleration_roll(sensor,&pitchAcceleration,&rollAcceleration);\n    pitchOffset = (float)__addsf3(pitchOffset,pitchAcceleration);\n    rollOffset = (float)__addsf3(rollOffset,rollAcceleration);\n    gyroXOffset = (float)__addsf3(gyroXOffset,sensor->gyroX);\n    gyroYOffset = (float)__addsf3(gyroYOffset,sensor->gyroY);\n    currentTimestamp = (*getCurrentTimestamp)();\n    sampleIndex = sampleIndex + 1;\n  }\n  sampleCount = __floatssampleIndexsf(numSamples);\n  offset = (float)__aeabsampleIndex_fdsampleIndexv(gyroXOffset,sampleCount);\n  sensor->gyroXOffset = offset;\n  sampleCount = __floatssampleIndexsf(numSamples);\n  offset = (float)__aeabsampleIndex_fdsampleIndexv(gyroYOffset,sampleCount);\n  sensor->gyroYOffset = offset;\n  sampleCount = __floatssampleIndexsf(numSamples);\n  offset = (float)__aeabsampleIndex_fdsampleIndexv(pitchOffset,sampleCount);\n  sensor->offset_pitchAcceleration = offset;\n  sampleCount = __floatssampleIndexsf(numSamples);\n  offset = (float)__aeabsampleIndex_fdsampleIndexv(rollOffset,sampleCount);\n  sensor->offset_rollAcceleration = offset;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_sensor_offsets_080049cc",
                "mpu6050": "sensor",
                "uVar1": "sampleCount",
                "fVar2": "offset",
                "mpu6050_local": "localSensor",
                "acc_roll": "rollAcceleration",
                "acc_pitch": "pitchAcceleration",
                "now": "currentTimestamp",
                "num_samples": "numSamples",
                "i": "sampleIndex",
                "offset_accRoll": "rollOffset",
                "offset_accPitch": "pitchOffset",
                "offset_gyroY": "gyroYOffset",
                "offset_gyroX": "gyroXOffset",
                "Get_ms_tick": "getCurrentTimestamp"
            },
            "calling": [
                "mpu6050_init"
            ],
            "called": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_update",
                "__addsf3",
                "__aeabi_fdiv",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "read_mpu6050_data_08004ae0",
            "code": "\nvoid readMpu6050Data_08004ae0(Mpu6050 *sensorData)\n\n{\n  floatemperature fVar1;\n  Mpu6050 *sensorData_local;\n  uintemperature8_temperature rawData [14];\n  intemperature16_temperature gyroZ;\n  intemperature16_temperature gyroY;\n  intemperature16_temperature gyroX;\n  intemperature16_temperature temperature;\n  intemperature16_temperature accZ;\n  intemperature16_temperature accY;\n  intemperature16_temperature accX;\n  \n  (*readReg)(0xd0,';',rawData,0xe);\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[0],rawData[1]));\n  sensorData->accX = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[2],rawData[3]));\n  sensorData->accY = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[4],rawData[5]));\n  sensorData->accZ = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[6],rawData[7]));\n  sensorData->temperatureemp = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[8],rawData[9]));\n  sensorData->gyroYroX = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[10],rawData[11]));\n  sensorData->gyroYroY = fVar1;\n  fVar1 = (floatemperature)__floatemperaturesisf((intemperature)CONCAT11(rawData[12],rawData[13]));\n  sensorData->gyroYroZ = fVar1;\n  retemperatureurn;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "read_mpu6050_data_08004ae0",
                "mpu6050": "sensorData",
                "raw": "rawData",
                "gz": "gyroZ",
                "gy": "gyroY",
                "gx": "gyroX",
                "t": "temperature",
                "az": "accZ",
                "ay": "accY",
                "ax": "accX",
                "I2C_Read_Reg": "readReg"
            },
            "calling": [
                "mpu6050_calibrate",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_pitch_08004bd8",
            "code": "\nvoid calculatePitch_08004bd8(Mpu6050 *mpuSensor,float *pitchAngle)\n\n{\n  undefined4 gyroXOffset;\n  float filteredPitch;\n  undefined8 temp1;\n  undefined8 temp2;\n  float *localPitch;\n  Mpu6050 *localMpuSensor;\n  float accPitch;\n  float gyroX;\n  \n  gyroXOffset = __aeabi_fsub(mpuSensor->gyroX,mpuSensor->offset_gyroX);\n  temp1 = __aeabi_f2d(totalPitch);\n  temp2 = __aeabi_f2d(gyroXOffset);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x83f5c366,0x3f340215);\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                       (int)((ulonglong)temp2 >> 0x20));\n  totalPitch = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = __aeabi_f2d(mpuSensor->accY);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40b00000);\n  temp2 = __aeabi_f2d(mpuSensor->accZ);\n  temp2 = __divdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,0x40b00000);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  temp2 = __aeabi_f2d(mpuSensor->offset_accPitch);\n  temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                   (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40568000);\n  filteredPitch = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  if (firstRun == false) {\n    temp1 = __aeabi_f2d(totalPitch);\n    temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x9999999a,0x3fe99999);\n    temp2 = __aeabi_f2d(filteredPitch);\n    temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x9999999a,0x3fc99999);\n    temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                         (int)((ulonglong)temp2 >> 0x20));\n    totalPitch =\n         (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  }\n  else {\n    firstRun = false;\n    totalPitch = filteredPitch;\n  }\n  *pitchAngle = totalPitch;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_pitch_08004bd8",
                "mpu6050": "mpuSensor",
                "pitch": "pitchAngle",
                "uVar1": "gyroXOffset",
                "fVar2": "filteredPitch",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "pitch_local": "localPitch",
                "mpu6050_local": "localMpuSensor",
                "acc_pitch": "accPitch",
                "gyro_x": "gyroX",
                "mpu6050_calc_pitch::total_pitch": "totalPitch",
                "mpu6050_calc_pitch::first_run": "firstRun"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_f2d",
                "__aeabi_dadd",
                "__muldf3",
                "__truncdfsf2",
                "__subdf3",
                "__aeabi_fsub",
                "__divdf3",
                "atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_pitch_and_roll_08004d78",
            "code": "\nvoid calculatePitchAndRoll_08004d78(Mpu6050 *sensorData,float *pitchAngle,float *rollAngle)\n\n{\n  undefined4 accX_normalized;\n  undefined4 accY_normalized;\n  undefined4 accZ_normalized;\n  float pitchAngleDegrees;\n  float rollAngleDegrees;\n  undefined8 temp1;\n  undefined8 temp2;\n  float *rollAngle_local;\n  float *pitchAngle_local;\n  Mpu6050 *sensorData_local;\n  float accelerationRoll;\n  float accelerationPitch;\n  float accelerationZ;\n  float accelerationY;\n  float accelerationX;\n  \n  accX_normalized = __aeabi_fdiv(sensorData->accX,0x45800000);\n  accY_normalized = __aeabi_fdiv(sensorData->accY,0x45800000);\n  accZ_normalized = __aeabi_fdiv(sensorData->accZ,0x45800000);\n  temp1 = __aeabi_f2d(accY_normalized);\n  temp2 = __aeabi_f2d(accZ_normalized);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  pitchAngleDegrees = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = __aeabi_f2d(accX_normalized);\n  temp2 = __aeabi_f2d(accZ_normalized);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  rollAngleDegrees = (float)__truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  *pitchAngle = pitchAngleDegrees;\n  *rollAngle = rollAngleDegrees;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_pitch_and_roll_08004d78",
                "mpu6050": "sensorData",
                "pitch": "pitchAngle",
                "roll": "rollAngle",
                "uVar1": "accX_normalized",
                "uVar2": "accY_normalized",
                "uVar3": "accZ_normalized",
                "fVar4": "pitchAngleDegrees",
                "fVar5": "rollAngleDegrees",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "acc_roll": "accelerationRoll",
                "acc_pitch": "accelerationPitch",
                "acc_z": "accelerationZ",
                "acc_y": "accelerationY",
                "acc_x": "accelerationX"
            },
            "calling": [
                "mpu6050_calibrate"
            ],
            "called": [
                "__aeabi_fdiv",
                "__aeabi_f2d",
                "__muldf3",
                "__truncdfsf2",
                "atan2",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "execute_system_call_08004e6c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t execute_system_call_08004e6c(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "execute_system_call_08004e6c"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "process_ticks_08004e74",
            "code": "\nint processTicks_08004e74(int inputTicks)\n\n{\n  uint32_t aflResult;\n  int localTicks;\n  \n  if (noHyperCall == 0) {\n    aflResult = aflCall(1,inputTicks,0);\n  }\n  else {\n    aflResult = 0;\n  }\n  return aflResult;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "process_ticks_08004e74",
                "ticks": "inputTicks",
                "uVar1": "aflResult",
                "ticks_local": "localTicks"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "write_data_to_i2_c_device_08004ea4",
            "code": "\nvoid writeDataToI2CDevice_08004ea4(uint8_t deviceAddress,uint8_t registerAddress,uint8_t *dataBuffer,uint16_t dataLength)\n\n{\n  uint8_t *localDataBuffer;\n  uint16_t localDataLength;\n  uint8_t localRegisterAddress;\n  uint8_t localDeviceAddress;\n  \n  HAL_I2C_Mem_Write(&hi2c1,(ushort)deviceAddress,(ushort)registerAddress,1,dataBuffer,dataLength,I2C_TIMEOUT);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "write_data_to_i2_c_device_08004ea4",
                "addr": "deviceAddress",
                "reg": "registerAddress",
                "data": "dataBuffer",
                "len": "dataLength",
                "data_local": "localDataBuffer",
                "len_local": "localDataLength",
                "reg_local": "localRegisterAddress",
                "addr_local": "localDeviceAddress"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "read_i2_c_data_08004ee8",
            "code": "\nvoid read_I2C_data_08004ee8(uint8_t address,uint8_t register,uint8_t *data_buffer,uint16_t data_length)\n\n{\n  uint8_t *local_data_pointer;\n  uint16_t local_data_length;\n  uint8_t local_register;\n  uint8_t local_address;\n  \n  HAL_I2C_Mem_Read(&hi2c1,(ushort)address,(ushort)register,1,data_buffer,data_length,I2C_TIMEOUT);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "read_i2_c_data_08004ee8",
                "addr": "address",
                "reg": "register",
                "data": "data_buffer",
                "len": "data_length",
                "data_local": "local_data_pointer",
                "len_local": "local_data_length",
                "reg_local": "local_register",
                "addr_local": "local_address"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_current_tick_08004f2c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_current_tick_08004f2c(void)\n\n{\n  uint32_t current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_current_tick_08004f2c",
                "uVar1": "current_tick"
            },
            "calling": [],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "transmit_data_via_uart_08004f3c",
            "code": "\nvoid transmitDataViaUART_08004f3c(char *data,uint32_t dataLength)\n\n{\n  uint32_t localDataLength;\n  char *localData;\n  \n  HAL_UART_Transmit(&huart1,(uint8_t *)data,(uint16_t)dataLength,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "transmit_data_via_uart_08004f3c",
                "str": "data",
                "len": "dataLength",
                "len_local": "localDataLength",
                "str_local": "localData"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_string_buffer_08004f60",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeStringBuffer_08004f60(void)\n\n{\n  memset(buffer,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_string_buffer_08004f60",
                "strbuf": "buffer"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "calculate_pid_08004f78",
            "code": "\nvoid calculatePID_08004f78(TIM_HandleTypeDef *timer)\n\n{\n  size_t length;\n  undefined4 tempFloat1;\n  int tempInt1;\n  undefined4 tempFloat2;\n  uint tempUint;\n  undefined8 tempDouble;\n  TIM_HandleTypeDef *localTimer;\n  float pidPwm;\n  uint8_t outputPwm;\n  \n  mpu6050_update(&mpu6050);\n  mpu6050_calc_pitch(&mpu6050,&pitch);\n  flush_strbuf();\n  tempDouble = __aeabi_f2d(pitch);\n  sprintf(strbuf,\"Pitch: %f\\n\",(int)tempDouble,(int)((ulonglong)tempDouble >> 0x20));\n  length = strlength(strbuf);\n  uart_print(strbuf,length);\n  error = (float)__aeabi_fsub(setpoint,pitch);\n  P = (float)__aeabi_fmul(Kp,error);\n  tempFloat1 = __aeabi_fmul(Ki,error);\n  I = (float)__addsf3(tempFloat1,I);\n  tempFloat1 = __floatsisf(maxPwm);\n  tempInt1 = __aeabi_fcmplt(tempFloat1,I);\n  if (tempInt1 == 0) {\n    tempFloat1 = __floatsisf(minPwm);\n    tempInt1 = __aeabi_fcmpgt(tempFloat1,I);\n    if (tempInt1 != 0) {\n      I = (float)__floatunsisf(minPwm);\n    }\n  }\n  else {\n    I = (float)__floatunsisf(maxPwm);\n  }\n  tempUint = (uint)Kd ^ 0x80000000;\n  tempFloat1 = __aeabi_fsub(error,lastError);\n  D = (float)__aeabi_fmul(tempUint,tempFloat1);\n  tempFloat1 = __addsf3(P,I);\n  tempFloat1 = __addsf3(tempFloat1,D);\n  tempFloat2 = __floatsisf(maxPwm);\n  tempInt1 = __aeabi_fcmpgt(tempFloat1,tempFloat2);\n  if (tempInt1 == 0) {\n    tempFloat2 = __floatsisf(minPwm);\n    tempInt1 = __aeabi_fcmplt(tempFloat1,tempFloat2);\n    if (tempInt1 == 0) {\n      outputPwm = __fixunssfsi(tempFloat1);\n    }\n    else {\n      outputPwm = minPwm;\n    }\n  }\n  else {\n    outputPwm = maxPwm;\n  }\n  lastError = error;\n  tempInt1 = __aeabi_fcmpgt(error,0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,2,tempInt1 != 0);\n  tempInt1 = __aeabi_fcmpgt(error,0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,4,tempInt1 == 0);\n  tempInt1 = __aeabi_fcmpgt(error,0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,8,tempInt1 != 0);\n  tempInt1 = __aeabi_fcmpgt(error,0);\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,0x10,tempInt1 == 0);\n  (timer1.Instance)->CCR1 = (uint)outputPwm;\n  (timer1.Instance)->CCR4 = (uint)outputPwm;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "calculate_pid_08004f78",
                "htim": "timer",
                "len": "length",
                "uVar1": "tempFloat1",
                "iVar2": "tempInt1",
                "uVar3": "tempFloat2",
                "uVar4": "tempUint",
                "uVar5": "tempDouble",
                "htim_local": "localTimer",
                "pid_pwm": "pidPwm",
                "out_pwm": "outputPwm"
            },
            "calling": [
                "HAL_TIM_IRQHandler",
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [
                "mpu6050_update",
                "__floatsisf",
                "__aeabi_fcmpgt",
                "uart_print",
                "__aeabi_fmul",
                "mpu6050_calc_pitch",
                "__addsf3",
                "HAL_GPIO_WritePin",
                "__aeabi_f2d",
                "flush_strbuf",
                "__aeabi_fcmplt",
                "strlen",
                "__floatunsisf",
                "__aeabi_fsub",
                "__fixunssfsi",
                "sprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initializeSystem_08005224(void)\n\n{\n  initializeHardwareAbstractionLayer();\n  configureSystemClock();\n  initializeGPIO();\n  initializeI2C1();\n  initializeUSART1_UART();\n  initializeTIM2();\n  initializeTIM1();\n  I2C_Write_Reg = _i2c_write_reg + 1;\n  I2C_Read_Reg = _i2c_read_reg + 1;\n  Get_ms_tick = _get_ms_tick + 1;\n  startPWM(&timer1,0);\n  startPWM(&timer1,0xc);\n  initializeMPU6050(&mpu6050);\n  startInterruptTimer(&timer2);\n  initializeForkServer(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initializeHardwareAbstractionLayer",
                "SystemClock_Config": "configureSystemClock",
                "MX_GPIO_Init": "initializeGPIO",
                "MX_I2C1_Init": "initializeI2C1",
                "MX_USART1_UART_Init": "initializeUSART1_UART",
                "MX_TIM2_Init": "initializeTIM2",
                "MX_TIM1_Init": "initializeTIM1",
                "HAL_TIM_PWM_Start": "startPWM",
                "htim1": "timer1",
                "mpu6050_init": "initializeMPU6050",
                "HAL_TIM_Base_Start_IT": "startInterruptTimer",
                "htim2": "timer2",
                "startForkserver": "initializeForkServer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "HAL_TIM_PWM_Start",
                "MX_GPIO_Init",
                "MX_TIM2_Init",
                "MX_USART1_UART_Init",
                "HAL_TIM_Base_Start_IT",
                "startForkserver",
                "SystemClock_Config",
                "HAL_Init",
                "MX_TIM1_Init",
                "MX_I2C1_Init",
                "mpu6050_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_clocks_080052a0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeClocks_080052a0(void)\n\n{\n  HAL_StatusTypeDef status;\n  uint32_t clockFrequency;\n  RCC_ClkInitTypeDef clockInitSettings;\n  RCC_OscInitTypeDef oscillatorInitSettings;\n  \n  oscillatorInitSettings.OscillatorType = 1;\n  oscillatorInitSettings.HSEState = 0x10000;\n  oscillatorInitSettings.HSEPredivValue = 0;\n  oscillatorInitSettings.HSIState = 1;\n  oscillatorInitSettings.PLL.PLLState = 2;\n  oscillatorInitSettings.PLL.PLLSource = 0x10000;\n  oscillatorInitSettings.PLL.PLLMUL = 0x1c0000;\n  status = HAL_RCC_OscConfig(&oscillatorInitSettings);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x151);\n  }\n  clockInitSettings.ClockType = 0xf;\n  clockInitSettings.SYSCLKSource = 2;\n  clockInitSettings.AHBCLKDivider = 0x80;\n  clockInitSettings.APB1CLKDivider = 0;\n  clockInitSettings.APB2CLKDivider = 0;\n  status = HAL_RCC_ClockConfig(&clockInitSettings,2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x15e);\n  }\n  clockFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(clockFrequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_clocks_080052a0",
                "RCC_ClkInitStruct": "clockInitSettings",
                "RCC_OscInitStruct": "oscillatorInitSettings",
                "HVar1": "status",
                "uVar2": "clockFrequency"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_NVIC_SetPriority",
                "_Error_Handler",
                "HAL_RCC_OscConfig",
                "HAL_RCC_GetHCLKFreq",
                "HAL_SYSTICK_Config",
                "HAL_RCC_ClockConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_i2_c_08005348",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_I2C_08005348(void)\n\n{\n  HAL_StatusTypeDef status;\n  \n  i2c_device.Instance = (I2C_TypeDef *)0x40005400;\n  i2c_device.Init.ClockSpeed = 400000;\n  i2c_device.Init.DutyCycle = 0;\n  i2c_device.Init.OwnAddress1 = 0;\n  i2c_device.Init.AddressingMode = 0x4000;\n  i2c_device.Init.DualAddressMode = 0;\n  i2c_device.Init.OwnAddress2 = 0;\n  i2c_device.Init.GeneralCallMode = 0;\n  i2c_device.Init.NoStretchMode = 0;\n  status = HAL_I2C_Init(&i2c_device);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "HVar1": "status",
                "hi2c1": "i2c_device"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_tim_080053b0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initialize_TIM_080053b0(void)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_BreakDeadTimeConfigTypeDef break_dead_time_config;\n  TIM_OC_InitTypeDef oc_config;\n  TIM_MasterConfigTypeDef master_config;\n  TIM_ClockConfigTypeDef clock_source_config;\n  \n  timer1.Instance = (TIM_TypeDef *)0x40012c00;\n  timer1.Init.Prescaler = 0x708;\n  timer1.Init.CounterMode = 0;\n  timer1.Init.Period = 100;\n  timer1.Init.ClockDivision = 0;\n  timer1.Init.RepetitionCounter = 0;\n  timer1.Init.AutoReloadPreload = 0;\n  status = HAL_TIM_Base_Init(&timer1);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",399);\n  }\n  clock_source_config.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource(&timer1,&clock_source_config);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x194);\n  }\n  status = HAL_TIM_PWM_Init(&timer1);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x198);\n  }\n  master_config.MasterOutputTrigger = 0;\n  master_config.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization(&timer1,&master_config);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x19f);\n  }\n  oc_config.OCMode = 0x60;\n  oc_config.Pulse = 0;\n  oc_config.OCPolarity = 0;\n  oc_config.OCNPolarity = 0;\n  oc_config.OCFastMode = 0;\n  oc_config.OCIdleState = 0;\n  oc_config.OCNIdleState = 0;\n  status = HAL_TIM_PWM_ConfigChannel(&timer1,&oc_config,0);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1ab);\n  }\n  status = HAL_TIM_PWM_ConfigChannel(&timer1,&oc_config,0xc);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1b0);\n  }\n  break_dead_time_config.OffStateRunMode = 0;\n  break_dead_time_config.OffStateIDLEMode = 0;\n  break_dead_time_config.LockLevel = 0;\n  break_dead_time_config.DeadTime = 0;\n  break_dead_time_config.BreakState = 0;\n  break_dead_time_config.BreakPolarity = 0x2000;\n  break_dead_time_config.AutomaticOutput = 0;\n  status = HAL_TIMEx_ConfigBreakDeadTime(&timer1,&break_dead_time_config);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1bc);\n  }\n  HAL_TIM_MspPostInit(&timer1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_tim_080053b0",
                "HVar1": "status",
                "sBreakDeadTimeConfig": "break_dead_time_config",
                "sConfigOC": "oc_config",
                "sMasterConfig": "master_config",
                "sClockSourceConfig": "clock_source_config",
                "htim1": "timer1"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIMEx_MasterConfigSynchronization",
                "HAL_TIM_PWM_Init",
                "_Error_Handler",
                "HAL_TIM_MspPostInit",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_ConfigClockSource",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_Base_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_timer_08005500",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeTimer_08005500(void)\n\n{\n  HAL_StatusTypeDef status;\n  TIM_MasterConfigTypeDef masterConfig;\n  TIM_ClockConfigTypeDef clockSourceConfig;\n  \n  htim2.Instance = (TIM_TypeDef *)0x40000000;\n  htim2.Init.Prescaler = 36000;\n  htim2.Init.CounterMode = 0;\n  htim2.Init.Period = 0x14;\n  htim2.Init.ClockDivision = 0;\n  htim2.Init.AutoReloadPreload = 0;\n  status = HAL_TIM_Base_Init(&htim2);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1d0);\n  }\n  clockSourceConfig.ClockSource = 0x1000;\n  status = HAL_TIM_ConfigClockSource(&htim2,&clockSourceConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1d5);\n  }\n  masterConfig.MasterOutputTrigger = 0x20;\n  masterConfig.MasterSlaveMode = 0;\n  status = HAL_TIMEx_MasterConfigSynchronization(&htim2,&masterConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_timer_08005500",
                "HVar1": "status",
                "sMasterConfig": "masterConfig",
                "sClockSourceConfig": "clockSourceConfig"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIMEx_MasterConfigSynchronization",
                "_Error_Handler",
                "HAL_TIM_ConfigClockSource",
                "HAL_TIM_Base_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_uart_08005598",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUART_08005598(void)\n\n{\n  HAL_StatusTypeDef status;\n  \n  uartConfig.Instance = (USART_TypeDef *)0x40013800;\n  uartConfig.Init.BaudRate = 0x1c200;\n  uartConfig.Init.WordLength = 0;\n  uartConfig.Init.StopBits = 0;\n  uartConfig.Init.Parity = 0;\n  uartConfig.Init.Mode = 0xc;\n  uartConfig.Init.HwFlowCtl = 0;\n  uartConfig.Init.OverSampling = 0;\n  status = HAL_UART_Init(&uartConfig);\n  if (status != HAL_OK) {\n    _Error_Handler(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "HVar1": "status",
                "huart1": "uartConfig"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_gpio_080055f4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeGPIO_080055f4(void)\n\n{\n  uint32_t tmp_register_2;\n  uint32_t tmp_register_1;\n  uint32_t tmp_register;\n  GPIO_InitTypeDef gpio_initialization_struct;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  HAL_GPIO_WritePin((GPIO_TypeDef *)0x40010800,0x1e,GPIO_PIN_RESET);\n  gpio_initialization_struct.Pin = 0x1e;\n  gpio_initialization_struct.Mode = 1;\n  gpio_initialization_struct.Speed = 2;\n  HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpio_initialization_struct);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_gpio_080055f4",
                "tmpreg_2": "tmp_register_2",
                "tmpreg_1": "tmp_register_1",
                "tmpreg": "tmp_register",
                "GPIO_InitStruct": "gpio_initialization_struct"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_WritePin",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(char *file,int line)\n\n{\n  int localLine;\n  char *localFile;\n  \n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674",
                "line_local": "localLine",
                "file_local": "localFile"
            },
            "calling": [
                "MX_TIM2_Init",
                "MX_USART1_UART_Init",
                "SystemClock_Config",
                "MX_TIM1_Init",
                "MX_I2C1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_timer_gpio_08005680",
            "code": "\nvoid initializeTimerGPIO_08005680(TIM_HandleTypeDef *timerHandle)\n\n{\n  TIM_HandleTypeDef *localTimerHandle;\n  GPIO_InitTypeDef gpioInit;\n  \n  if (timerHandle->Instance == (TIM_TypeDef *)0x40012c00) {\n    gpioInit.GPIO_Pin = 0x900;\n    gpioInit.GPIO_Mode = 2;\n    gpioInit.GPIO_Speed = 2;\n    HAL_GPIO_Init((GPIO_TypeDef *)0x40010800,&gpioInit);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_timer_gpio_08005680",
                "htim": "timerHandle",
                "htim_local": "localTimerHandle",
                "GPIO_InitStruct": "gpioInit",
                "Pin": "GPIO_Pin",
                "Mode": "GPIO_Mode",
                "Speed": "GPIO_Speed"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056bc": {
            "entrypoint": "0x080056bc",
            "current_name": "FUNC_080056bc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056bc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056bc": "FUNC_080056bc"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056c8": {
            "entrypoint": "0x080056c8",
            "current_name": "infinite_loop_080056c8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056c8(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056c8": "infinite_loop_080056c8"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056ce": {
            "entrypoint": "0x080056ce",
            "current_name": "infinite_loop_080056ce",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056ce(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056ce": "infinite_loop_080056ce"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056d4": {
            "entrypoint": "0x080056d4",
            "current_name": "infinite_loop_080056d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056d4(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056d4": "infinite_loop_080056d4"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056da": {
            "entrypoint": "0x080056da",
            "current_name": "infinite_loop_080056da",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_080056da(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080056da": "infinite_loop_080056da"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080056e0": {
            "entrypoint": "0x080056e0",
            "current_name": "FUNC_080056e0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056e0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056e0": "FUNC_080056e0"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056ec": {
            "entrypoint": "0x080056ec",
            "current_name": "FUNC_080056ec",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056ec(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056ec": "FUNC_080056ec"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056f8": {
            "entrypoint": "0x080056f8",
            "current_name": "FUNC_080056f8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_080056f8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080056f8": "FUNC_080056f8"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "handle_system_tick_interrupt_08005704",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSystemTickInterrupt_08005704(void)\n\n{\n  incrementTickCounter();\n  systemTickInterruptHandler();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "handle_system_tick_interrupt_08005704",
                "HAL_IncTick": "incrementTickCounter",
                "HAL_SYSTICK_IRQHandler": "systemTickInterruptHandler"
            },
            "calling": [],
            "called": [
                "HAL_IncTick",
                "HAL_SYSTICK_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "handle_tim2_interrupt_08005714",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handle_TIM2_interrupt_08005714(void)\n\n{\n  HAL_TIM_IRQHandler(timer_handle);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "handle_tim2_interrupt_08005714",
                "&htim2": "timer_handle"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "expand_heap_08005728",
            "code": "\nvoid * expandHeap_08005728(intptr_t delta)\n\n{\n  undefined4 *errnoPtr;\n  char *newHeapEnd;\n  char endMarker [4];\n  int increase;\n  char *previousHeapEnd;\n  \n  if (_sbrk::heap_end == (char *)0x0) {\n    _sbrk::heap_end = &end;\n  }\n  previousHeapEnd = _sbrk::heap_end;\n  if (endMarker < _sbrk::heap_end + delta) {\n    increase = delta;\n    errnoPtr = (undefined4 *)__errno();\n    *errnoPtr = 0xc;\n    newHeapEnd = (char *)0xffffffff;\n  }\n  else {\n    newHeapEnd = _sbrk::heap_end;\n    _sbrk::heap_end = _sbrk::heap_end + delta;\n  }\n  return newHeapEnd;\n}\n\n",
            "renaming": {
                "FUN_08005728": "expand_heap_08005728",
                "__delta": "delta",
                "puVar1": "errnoPtr",
                "pcVar2": "newHeapEnd",
                "acStack_18": "endMarker",
                "incr_local": "increase",
                "prev_heap_end": "previousHeapEnd"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [
                "__errno"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_memory_08005780",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid initializeMemory_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_memory_08005780"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e8": {
            "entrypoint": "0x080057e8",
            "current_name": "initialize_system_080057e8",
            "code": "\nvoid initializeSystem_080057e8(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *unrecoveredJumpTable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &completed_8655; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(&__fini_array_end + index);\n  }\n  for (ptr = &completed_8655; ptr < &_ebss; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  unrecoveredJumpTable = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*unrecoveredJumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e8": "initialize_system_080057e8",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "unrecoveredJumpTable"
            },
            "calling": [],
            "called": [
                "main",
                "__libc_init_array",
                "SystemInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005830": {
            "entrypoint": "0x08005830",
            "current_name": "infinite_loop_08005830",
            "code": "\nvoid infiniteLoop_08005830(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005830": "infinite_loop_08005830"
            },
            "calling": [
                "USBWakeUp_IRQHandler"
            ],
            "called": [
                "USBWakeUp_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005834": {
            "entrypoint": "0x08005834",
            "current_name": "FUN_08005834",
            "code": "\nvoid __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4,double param_5)\n\n{\n  int iVar1;\n  undefined4 unaff_r4;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  \n  uVar3 = param_4 & 0x7fffffff;\n  if (((uVar3 | (-param_3 | param_3) >> 0x1f) < 0x7ff00001) &&\n     (uVar4 = param_2 & 0x7fffffff, (uVar4 | (-param_1 | param_1) >> 0x1f) < 0x7ff00001)) {\n    if ((param_4 + 0xc0100000 | param_3) == 0) {\n      atan(param_5);\n      return;\n    }\n    uVar2 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n    if (((((uVar4 | param_1) != 0) && ((uVar3 | param_3) != 0)) && (uVar3 != 0x7ff00000)) &&\n       (uVar4 != 0x7ff00000)) {\n      iVar1 = (int)(uVar4 - uVar3) >> 0x14;\n      if ((iVar1 < 0x3d) && ((-1 < (int)param_4 || (iVar1 + 0x3c < 0 == SCARRY4(iVar1,0x3c))))) {\n        __divdf3(param_1,param_2);\n        fabs((double)CONCAT44(unaff_r4,param_4));\n        atan((double)CONCAT44(unaff_r4,param_4));\n      }\n      if (uVar2 != 1) {\n        if (uVar2 == 2) {\n          uVar5 = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n        }\n        else if (uVar2 != 0) {\n          uVar5 = __subdf3();\n          __subdf3((int)uVar5,(int)((ulonglong)uVar5 >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(param_3,param_4,param_1,param_2);\n  }\n  return;\n}\n\n",
            "renaming": {},
            "calling": [
                "mpu6050_calc_acc_pitch_roll",
                "mpu6050_calc_pitch"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_atan_08005838",
            "code": "\nvoid calculate_atan_08005838(uint dividend,uint divisor,uint remainder,uint quotient,double input_value)\n\n{\n  int difference;\n  undefined4 unused;\n  uint flag;\n  uint positive_remainder;\n  uint positive_quotient;\n  undefined8 result;\n  \n  positive_remainder = quotient & 0x7fffffff;\n  if (((positive_remainder | (-remainder | remainder) >> 0x1f) < 0x7ff00001) &&\n     (positive_quotient = divisor & 0x7fffffff, (positive_quotient | (-dividend | dividend) >> 0x1f) < 0x7ff00001)) {\n    if ((quotient + 0xc0100000 | remainder) == 0) {\n      atan(input_value);\n      return;\n    }\n    flag = (int)quotient >> 0x1e & 2U | divisor >> 0x1f;\n    if (((((positive_quotient | dividend) != 0) && ((positive_remainder | remainder) != 0)) && (positive_remainder != 0x7ff00000)) &&\n       (positive_quotient != 0x7ff00000)) {\n      difference = (int)(positive_quotient - positive_remainder) >> 0x14;\n      if ((difference < 0x3d) && ((-1 < (int)quotient || (difference + 0x3c < 0 == SCARRY4(difference,0x3c))))) {\n        __divdf3(dividend,divisor);\n        fabs((double)CONCAT44(unused,quotient));\n        atan((double)CONCAT44(unused,quotient));\n      }\n      if (flag != 1) {\n        if (flag == 2) {\n          result = __subdf3();\n          __subdf3(0x54442d18,0x400921fb,(int)result,(int)((ulonglong)result >> 0x20));\n        }\n        else if (flag != 0) {\n          result = __subdf3();\n          __subdf3((int)result,(int)((ulonglong)result >> 0x20),0x54442d18,0x400921fb);\n        }\n      }\n    }\n  }\n  else {\n    __aeabi_dadd(remainder,quotient,dividend,divisor);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_atan_08005838",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "quotient",
                "param_5": "input_value",
                "iVar1": "difference",
                "unaff_r4": "unused",
                "uVar2": "flag",
                "uVar3": "positive_remainder",
                "uVar4": "positive_quotient",
                "uVar5": "result"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "fabs",
                "atan",
                "__aeabi_dadd",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_square_inverse_080059f0",
            "code": "\ndouble calculate_square_inverse_080059f0(double x)\n\n{\n  int integral_part;\n  undefined4 result1;\n  undefined4 result2;\n  uint fractional_part;\n  undefined4 result3;\n  undefined4 result4;\n  undefined4 extraout1;\n  undefined4 temp1;\n  undefined4 temp2;\n  undefined4 temp_result1;\n  undefined4 temp_result2;\n  uint abs_fractional_part;\n  int temp_result3;\n  double temp_result4;\n  double final_result;\n  double default_result;\n  undefined8 temp_result5;\n  undefined8 temp_result6;\n  \n  temp_result5 = CONCAT44(fractional_part,integral_part);\n  abs_fractional_part = fractional_part & 0x7fffffff;\n  if (abs_fractional_part < 0x44100000) {\n    if (abs_fractional_part < 0x3fdc0000) {\n      if (abs_fractional_part < 0x3e200000) {\n        temp_result6 = __aeabi_dadd(integral_part,fractional_part,0x8800759c,0x7e37e43c);\n        temp_result3 = __aeabi_dcmpgt((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),0,0x3ff00000);\n        if (temp_result3 != 0) {\n          return default_result;\n        }\n      }\n      temp_result3 = -1;\n    }\n    else {\n      fabs((double)CONCAT44(temp2,temp1));\n      if (abs_fractional_part < 0x3ff30000) {\n        if (abs_fractional_part < 0x3fe60000) {\n          temp_result5 = __aeabi_dadd();\n          temp_result5 = __subdf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),0,0x3ff00000);\n          temp_result6 = __aeabi_dadd(integral_part,extraout1,0,0x40000000);\n          temp_result5 = __divdf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),(int)temp_result6,\n                            (int)((ulonglong)temp_result6 >> 0x20));\n          temp_result3 = 0;\n        }\n        else {\n          temp_result5 = __subdf3();\n          temp_result6 = __aeabi_dadd(integral_part,extraout1,0,0x3ff00000);\n          temp_result5 = __divdf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),(int)temp_result6,\n                            (int)((ulonglong)temp_result6 >> 0x20));\n          temp_result3 = 1;\n        }\n      }\n      else if (abs_fractional_part < 0x40038000) {\n        temp_result5 = __subdf3();\n        temp_result6 = __muldf3(integral_part,extraout1,0,0x3ff80000);\n        temp_result6 = __aeabi_dadd((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),0,0x3ff00000);\n        temp_result5 = __divdf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),(int)temp_result6,\n                          (int)((ulonglong)temp_result6 >> 0x20));\n        temp_result3 = 2;\n      }\n      else {\n        temp_result5 = __divdf3(0,0xbff00000,integral_part,extraout1);\n        temp_result3 = 3;\n      }\n    }\n    temp_result2 = (undefined4)((ulonglong)temp_result5 >> 0x20);\n    temp_result1 = (undefined4)temp_result5;\n    temp_result5 = __muldf3(temp_result1,temp_result2,temp_result1,temp_result2);\n    result3 = (undefined4)((ulonglong)temp_result5 >> 0x20);\n    result1 = (undefined4)temp_result5;\n    temp_result5 = __muldf3(result1,result3,result1,result3);\n    result4 = (undefined4)((ulonglong)temp_result5 >> 0x20);\n    result2 = (undefined4)temp_result5;\n    temp_result5 = __muldf3(result2,result4,0xe322da11,0x3f90ad3a);\n    temp_result5 = __aeabi_dadd((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),0x24760deb,0x3fa97b4b);\n    temp_result5 = __muldf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),result2,result4);\n    temp_result5 = __aeabi_dadd((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),0xa0d03d51,0x3fb10d66);\n    temp_result5 = __muldf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),result2,result4);\n    temp_result5 = __aeabi_dadd((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),0xc54c206e,0x3fb745cd);\n    temp_result5 = __muldf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),result2,result4);\n    temp_result5 = __aeabi_dadd((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),0x920083ff,0x3fc24924);\n    temp_result5 = __muldf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),result2,result4);\n    temp_result5 = __aeabi_dadd((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),0x5555550d,0x3fd55555);\n    temp_result5 = __muldf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),result1,result3);\n    temp_result6 = __muldf3(result2,result4,0x2c6a6c2f,0xbfa2b444);\n    temp_result6 = __subdf3((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),0x52defd9a,0x3fadde2d);\n    temp_result6 = __muldf3((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),result2,result4);\n    temp_result6 = __subdf3((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    temp_result6 = __muldf3((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),result2,result4);\n    temp_result6 = __subdf3((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),0xfe231671,0x3fbc71c6);\n    temp_result6 = __muldf3((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),result2,result4);\n    temp_result6 = __subdf3((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),0x9998ebc4,0x3fc99999);\n    temp_result6 = __muldf3((int)temp_result6,(int)((ulonglong)temp_result6 >> 0x20),result2,result4);\n    temp_result5 = __aeabi_dadd((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),(int)temp_result6,\n                          (int)((ulonglong)temp_result6 >> 0x20));\n    temp_result5 = __muldf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),temp_result1,temp_result2);\n    result1 = (undefined4)((ulonglong)temp_result5 >> 0x20);\n    if (temp_result3 == -1) {\n      final_result = (double)__subdf3(temp_result1,temp_result2,(int)temp_result5,result1);\n      return final_result;\n    }\n    temp_result3 = temp_result3 * 8;\n    temp_result5 = __subdf3((int)temp_result5,result1,*(undefined4 *)(&atanlo + temp_result3),\n                      *(undefined4 *)(&UNK_08009eec + temp_result3));\n    temp_result5 = __subdf3((int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20),temp_result1,temp_result2);\n    final_result = (double)__subdf3(*(undefined4 *)(&atanhi + temp_result3),*(undefined4 *)(&UNK_08009ecc + temp_result3)\n                             ,(int)temp_result5,(int)((ulonglong)temp_result5 >> 0x20));\n    if ((int)fractional_part < 0) {\n      return final_result;\n    }\n  }\n  else {\n    if ((abs_fractional_part < 0x7ff00001) && ((abs_fractional_part != 0x7ff00000 || (integral_part == 0)))) {\n      return temp_result4;\n    }\n    final_result = (double)__aeabi_dadd();\n  }\n  return final_result;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_square_inverse_080059f0",
                "__x": "x",
                "in_r0": "integral_part",
                "in_r1": "fractional_part",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "uVar4": "result4",
                "extraout_r1": "extraout1",
                "in_r3": "temp1",
                "unaff_r4": "temp2",
                "uVar5": "temp_result1",
                "uVar6": "temp_result2",
                "uVar7": "abs_fractional_part",
                "iVar8": "temp_result3",
                "in_d0": "temp_result4",
                "dVar9": "final_result",
                "extraout_d0": "default_result",
                "uVar10": "temp_result5",
                "uVar11": "temp_result6"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "fabs",
                "__aeabi_dadd",
                "__muldf3",
                "__subdf3",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "calculate_input_squared_08005d0c",
            "code": "\ndouble calculate_input_squared_08005d0c(double input_value)\n\n{\n  double result;\n  \n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "calculate_input_squared_08005d0c",
                "__x": "input_value",
                "in_d0": "result"
            },
            "calling": [
                "atan",
                "__ieee754_atan2"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_impure_pointer_08005d14",
            "code": "\nundefined4 getImpurePointer_08005d14(void)\n\n{\n  return impurePointer;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_impure_pointer_08005d14",
                "_impure_ptr": "impurePointer"
            },
            "calling": [
                "_sbrk"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "initialize_preinit_array_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid initializePreinitArray_08005d20(EVP_PKEY_CTX *ctx)\n\n{\n  int counter;\n  code **functionPointer;\n  \n  _init(ctx);\n  counter = 0;\n  functionPointer = (code **)&preinitArrayEnd;\n  do {\n    counter = counter + 1;\n    (**functionPointer)();\n    functionPointer = functionPointer + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "initialize_preinit_array_08005d20",
                "param_1": "ctx",
                "iVar1": "counter",
                "ppcVar2": "functionPointer",
                "__preinit_array_end": "preinitArrayEnd"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "_init",
                "register_fini",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "memset_08005d68",
            "code": "\nvoid * memset_08005d68(void *ptr,int ch,size_t size)\n\n{\n  uint *dest;\n  uint *src;\n  uint *temp;\n  uint count;\n  uint pattern;\n  bool isZero;\n  \n  src = (uint *)ptr;\n  if (((uint)ptr & 3) != 0) {\n    count = size - 1;\n    dest = (uint *)ptr;\n    if (size == 0) {\n      return ptr;\n    }\n    while( true ) {\n      src = (uint *)((int)dest + 1);\n      *(char *)dest = (char)ch;\n      size = count;\n      if (((uint)src & 3) == 0) break;\n      isZero = count == 0;\n      count = count - 1;\n      dest = src;\n      if (isZero) {\n        return ptr;\n      }\n    }\n  }\n  if (3 < size) {\n    pattern = ch & 0xffU | (ch & 0xffU) << 8;\n    pattern = pattern | pattern << 0x10;\n    count = size;\n    dest = src;\n    if (0xf < size) {\n      count = size - 0x10;\n      dest = src + 4;\n      do {\n        dest[-4] = pattern;\n        dest[-3] = pattern;\n        dest[-2] = pattern;\n        dest[-1] = pattern;\n        dest = dest + 4;\n      } while (dest != (uint *)((int)src + (count & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      src = src + ((count >> 4) + 1) * 4;\n      count = size;\n      dest = src;\n      if (size < 4) goto remaining;\n    }\n    do {\n      size = size - 4;\n      *src = pattern;\n      src = src + 1;\n    } while (3 < size);\n    src = (uint *)((int)dest + (count - 4 & 0xfffffffc) + 4);\n    size = count & 3;\n  }\nremaining:\n  if (size != 0) {\n    dest = src;\n    do {\n      temp = (uint *)((int)dest + 1);\n      *(char *)dest = (char)ch;\n      dest = temp;\n    } while ((uint *)(size + (int)src) != temp);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "memset_08005d68",
                "__s": "ptr",
                "__c": "ch",
                "__n": "size",
                "puVar1": "dest",
                "puVar2": "src",
                "puVar3": "temp",
                "uVar4": "count",
                "uVar5": "pattern",
                "bVar6": "isZero",
                "LAB_08005de4": "remaining"
            },
            "calling": [
                "flush_strbuf",
                "_calloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "format_and_print_08005dfc",
            "code": "\nint format_and_print_08005dfc(char *destination,char *format_string,...)\n\n{\n  int result;\n  undefined4 arg2;\n  undefined4 arg3;\n  char *string_buffer [2];\n  undefined4 buffer_size;\n  undefined4 stack_value_1;\n  char *current_position;\n  undefined4 max_buffer_size;\n  undefined4 local_8;\n  undefined4 local_4;\n  \n  max_buffer_size = 0x7fffffff;\n  buffer_size = 0x7fffffff;\n  stack_value_1 = 0xffff0208;\n  string_buffer[0] = destination;\n  current_position = destination;\n  local_8 = arg2;\n  local_4 = arg3;\n  result = _svfprintf_r(_impure_ptr,string_buffer,format_string,&local_8);\n  *string_buffer[0] = '\\0';\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "format_and_print_08005dfc",
                "__s": "destination",
                "__format": "format_string",
                "iVar1": "result",
                "in_r2": "arg2",
                "in_r3": "arg3",
                "local_80": "string_buffer",
                "local_78": "buffer_size",
                "uStack_74": "stack_value_1",
                "local_70": "current_position",
                "local_6c": "max_buffer_size",
                "uStack_8": "local_8",
                "uStack_4": "local_4"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "_svfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "reverse_count_leading_zeros_08005e40",
            "code": "\nsize_t reverseCountLeadingZeros_08005e40(char *data)\n\n{\n  int alignment;\n  uint *alignedData;\n  uint currentValue;\n  \n  alignedData = (uint *)((uint)data & 0xfffffffc);\n  alignment = -((uint)data & 3);\n  currentValue = *alignedData;\n  if (((uint)data & 3) != 0) {\n    currentValue = currentValue | 0xffffffffU >> ((alignment + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    alignedData = alignedData + 1;\n    currentValue = currentValue + 0xfefefeff & ~currentValue & 0x80808080;\n    if (currentValue != 0) break;\n    currentValue = *alignedData;\n    alignment = alignment + 4;\n  }\n  return alignment + (0x1fU - LZCOUNT(currentValue & -currentValue) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "reverse_count_leading_zeros_08005e40",
                "__s": "data",
                "iVar1": "alignment",
                "puVar2": "alignedData",
                "uVar3": "currentValue"
            },
            "calling": [
                "_svfprintf_r",
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int *piVar3;\n  int iVar4;\n  void *pvVar5;\n  int iVar6;\n  undefined4 uVar7;\n  undefined4 uVar8;\n  byte *pbVar9;\n  char cVar10;\n  byte bVar11;\n  int *piVar12;\n  int **ppiVar13;\n  undefined uVar14;\n  ushort uVar15;\n  int *__s;\n  int **ppiVar16;\n  byte **ppbVar17;\n  int *piVar18;\n  int *piVar19;\n  int **ppiVar20;\n  char *pcVar21;\n  uint uVar22;\n  byte *pbVar23;\n  int *piVar24;\n  uint uVar25;\n  uint uVar26;\n  int *piVar27;\n  int *piVar28;\n  byte *pbVar29;\n  bool bVar30;\n  longlong lVar31;\n  undefined8 uVar32;\n  undefined8 uVar33;\n  undefined4 in_stack_fffffe78;\n  int *in_stack_fffffe7c;\n  int *local_168;\n  byte *local_164;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  int *local_150;\n  int *local_148;\n  int local_144;\n  uint local_140;\n  int local_13c;\n  int *local_138;\n  int *local_134;\n  int local_130;\n  int *local_12c;\n  int *local_128;\n  char *local_11c;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0 [2];\n  undefined4 local_e8;\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int local_d4;\n  byte *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  ppiVar2 = (int **)_localeconv_r();\n  __s = *ppiVar2;\n  piVar3 = (int *)strlen((char *)__s);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar4 = _malloc_r(param_1,0x40);\n    *param_2 = iVar4;\n    param_2[4] = iVar4;\n    if (iVar4 == 0) {\n      *param_1 = 0xc;\n      return (byte *)0xffffffff;\n    }\n    param_2[5] = 0x40;\n  }\n  local_128 = (int *)0x0;\n  local_138 = (int *)0x0;\n  local_12c = (int *)0x0;\n  local_d4 = 0;\n  local_d0 = (byte *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\n  local_154 = param_4;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = local_d4 + 1;\n        local_d0 = (byte *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if (local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = (byte *)((int)local_164 + (int)piVar27);\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    uVar26 = 0;\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    local_158 = (char *)piVar27;\n    switch(uVar25) {\n    case 0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (uVar25 == 0) goto LAB_08006216;\n      piVar18 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = 0;\n      local_134 = (int *)0x0;\n      local_130 = 0;\n      local_158 = (char *)0x1;\n      param_3 = (int *)&local_8c;\n      piVar24 = piVar18;\n      local_8c = (char)uVar25;\n      goto LAB_08006298;\n    case 0x23:\n      uVar26 = uVar26 | 1;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x27:\n      iVar4 = _localeconv_r(param_1);\n      local_110 = *(int **)(iVar4 + 4);\n      local_104 = (int *)strlen((char *)local_110);\n      iVar4 = _localeconv_r(param_1);\n      local_108 = *(byte **)(iVar4 + 8);\n      if (local_104 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      uVar25 = (uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        uVar26 = uVar26 | 0x400;\n      }\n      goto LAB_08005f4a;\n    case 0x2a:\n      uVar25 = (uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case 0x2b:\n      local_f5 = 0x2b;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x2d:\n      uVar25 = (uint)*(byte *)piVar28;\nLAB_08006602:\n      uVar26 = uVar26 | 4;\n      goto LAB_08005f4a;\n    case 0x2e:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x2a) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (uVar25 - 0x30 < 10) {\n        piVar27 = (int *)((uVar25 - 0x30) + (int)piVar27 * 10);\n        uVar25 = (uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case 0x30:\n      uVar26 = uVar26 | 0x80;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_08005f58_caseD_31;\n    case 0x41:\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x61:\n    case 0x65:\n    case 0x66:\n    case 0x67:\n      local_154 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      local_128 = *local_154;\n      local_12c = local_154[1];\n      local_154 = local_154 + 2;\n      iVar4 = __unorddf2(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,0x7fefffff);\n      if ((iVar4 == 0) &&\n         (iVar4 = __aeabi_dcmple(local_128,(uint)local_12c & 0x7fffffff,0xffffffff,0x7fefffff),\n         iVar4 == 0)) {\n        iVar4 = __aeabi_dcmplt(local_128,local_12c,0,0);\n        if (iVar4 == 0) {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        param_3 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (uVar25 < 0x48) {\n          param_3 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        local_140 = uVar26 & 0xffffff7f;\n        local_158 = (char *)0x3;\n        local_13c = 0;\n        piVar24 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar4 = __unorddf2(local_128,local_12c,local_128,local_12c);\n      if (iVar4 != 0) {\n        if ((int)local_12c < 0) {\n          piVar18 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar18 = (int *)(uint)local_f5;\n        }\n        param_3 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      piVar24 = local_12c;\n      if (uVar25 == 0x61) {\n        uVar14 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar14,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = uVar26 | 0x102;\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          uVar26 = uVar26 | 2;\n        }\n        else {\n          param_3 = (int *)_malloc_r(param_1,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar15 = *(ushort *)(param_2 + 3) | 0x40;\n            *(ushort *)(param_2 + 3) = uVar15;\n            goto LAB_0800604e;\n          }\n          local_140 = uVar26 | 0x102;\n          uVar26 = uVar26 | 2;\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = 0x2d;\n          piVar24 = local_12c + -0x20000000;\n        }\n        else {\n          local_144 = 0;\n        }\n        if (uVar25 == 0x61) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar4 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar4 != 0) {\n            local_f0[0] = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_138 = param_3;\n          piVar24 = piVar27;\n          goto LAB_080072ba;\n        }\n        if (uVar25 == 0x41) {\n          frexp((double)CONCAT44(in_stack_fffffe7c,in_stack_fffffe78),local_128);\n          uVar32 = __muldf3();\n          iVar4 = __aeabi_dcmpeq((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0);\n          if (iVar4 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_138 = param_3;\n            piVar24 = piVar27;\n          }\n          else {\n            local_f0[0] = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_138 = param_3;\n            piVar24 = piVar27;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (uVar25 == 0x41) {\n          uVar14 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = uVar26 | 0x100;\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if ((uVar25 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = 0;\n      }\n      local_168 = (int *)(uVar25 & 0xffffffdf);\n      in_stack_fffffe7c = piVar27;\n      local_150 = piVar27;\n      if (uVar25 == 0x66) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\n        piVar18 = (int *)((int)param_3 + (int)piVar27);\nLAB_0800764c:\n        if ((*(byte *)param_3 == 0x30) &&\n           (iVar4 = __aeabi_dcmpeq(local_128,piVar24,0,0), iVar4 == 0)) {\n          local_f0[0] = (int *)(1 - (int)local_150);\n        }\n        piVar18 = (int *)((int)piVar18 + (int)local_f0[0]);\n      }\n      else if (uVar25 == 0x46) {\n        in_stack_fffffe78 = 3;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\nLAB_08007760:\n        piVar18 = (int *)((int)param_3 + (int)local_150);\n        if (uVar25 == 0x46) goto LAB_0800764c;\n      }\n      else {\n        if (local_168 == (int *)0x45) {\n          local_150 = (int *)((int)piVar27 + 1);\n        }\n        in_stack_fffffe78 = 2;\n        in_stack_fffffe7c = local_150;\n        param_3 = (int *)_dtoa_r(param_1,local_f0,local_128,piVar24);\n        local_138 = local_e0;\n        if (uVar25 == 0x67) {\n          if ((uVar26 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (uVar25 == 0x47) {\n          if ((uVar26 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar18 = (int *)((int)local_150 + (int)param_3);\n      }\n      iVar4 = __aeabi_dcmpeq(local_128,piVar24,0,0);\n      local_138 = piVar18;\n      if (iVar4 == 0) {\n        for (; local_138 = local_e0, local_e0 < piVar18; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)local_138 - (int)param_3);\n      goto LAB_08006cb0;\n    case 0x43:\n    case 99:\n      piVar18 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar24 = (int *)0x0;\n      local_13c = 0;\n      local_134 = (int *)0x0;\n      local_130 = 0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      param_3 = (int *)&local_8c;\n      goto LAB_08006298;\n    case 0x44:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bcc:\n        piVar24 = *local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar24 = (int *)(int)*(short *)local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bcc;\n        piVar24 = (int *)(int)*(char *)local_154;\n        piVar18 = (int *)((int)piVar24 >> 0x1f);\n        local_154 = ppiVar16;\n      }\n      goto LAB_08006102;\n    case 0x4c:\n      uVar26 = uVar26 | 8;\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x4f:\n      uVar26 = uVar26 | 0x10;\n    case 0x6f:\n      if ((uVar26 & 0x20) == 0) {\n        ppiVar16 = local_154 + 1;\n        if ((uVar26 & 0x10) == 0) {\n          if ((uVar26 & 0x40) == 0) {\n            if ((uVar26 & 0x200) == 0) goto LAB_08006be2;\n            piVar24 = (int *)(uint)*(byte *)local_154;\n            piVar18 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n          else {\n            piVar24 = (int *)(uint)*(ushort *)local_154;\n            piVar18 = (int *)0x0;\n            local_154 = ppiVar16;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar24 = *local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\n        ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar24 = *ppiVar16;\n        piVar18 = ppiVar16[1];\n        local_154 = ppiVar16 + 2;\n      }\n      iVar4 = 0;\n      uVar26 = uVar26 & 0xfffffbff;\n      break;\n    case 0x53:\n    case 0x73:\n      local_f5 = 0;\n      param_3 = *local_154;\n      local_154 = local_154 + 1;\n      local_140 = uVar26;\n      if (param_3 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        param_3 = (int *)&UNK_08009f44;\n        piVar18 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = 0;\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        piVar24 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)strlen((char *)param_3);\n        }\n        else {\n          pvVar5 = memchr(param_3,0,(size_t)piVar27);\n          if (pvVar5 == (void *)0x0) {\n            piVar18 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = 0;\n            local_134 = (int *)0x0;\n            local_130 = 0;\n            piVar24 = (int *)0x0;\n            local_168 = piVar27;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)((int)pvVar5 - (int)param_3);\n        }\n        local_148 = (int *)0x0;\n        local_13c = 0;\n        local_134 = (int *)0x0;\n        local_130 = 0;\n        piVar18 = (int *)(uint)local_f5;\n        piVar24 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_08006538;\n    case 0x55:\n      uVar26 = uVar26 | 0x10;\n      if ((int)(uVar26 << 0x1a) < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar16 = local_154 + 1;\n      if ((int)(uVar26 << 0x1b) < 0) {\nLAB_08006bf2:\n        piVar24 = *local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      else if ((int)(uVar26 << 0x19) < 0) {\n        piVar24 = (int *)(uint)*(ushort *)local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      else {\n        if (-1 < (int)(uVar26 << 0x16)) goto LAB_08006bf2;\n        piVar24 = (int *)(uint)*(byte *)local_154;\n        piVar18 = (int *)0x0;\n        iVar4 = 1;\n        local_154 = ppiVar16;\n      }\n      break;\n    case 0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if ((uVar26 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar16 = local_154 + 1;\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) == 0) {\n          if ((uVar26 & 0x200) == 0) goto LAB_08006bbc;\n          piVar24 = (int *)(uint)*(byte *)local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n        else {\n          piVar24 = (int *)(uint)*(ushort *)local_154;\n          piVar18 = (int *)0x0;\n          local_154 = ppiVar16;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar24 = *local_154;\n        piVar18 = (int *)0x0;\n        local_154 = ppiVar16;\n      }\n      goto LAB_080061be;\n    case 100:\n    case 0x69:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_08006102:\n      if ((int)piVar18 < 0) {\n        bVar30 = piVar24 != (int *)0x0;\n        piVar24 = (int *)-(int)piVar24;\n        piVar18 = (int *)(-(int)piVar18 - (uint)bVar30);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar4 = 1;\n        iVar6 = 1;\n        local_140 = uVar26 & 0xffffff7f;\n        if (((uint)piVar24 | (uint)piVar18) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      local_140 = uVar26;\n      if (piVar18 != (int *)0x0 || (int *)0x9 < piVar24) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case 0x68:\n      uVar25 = (uint)*(byte *)piVar28;\n      if (uVar25 == 0x68) {\n        uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n        uVar26 = uVar26 | 0x200;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        uVar26 = uVar26 | 0x40;\n      }\n      goto LAB_08005f4a;\n    case 0x6a:\n    case 0x71:\n      uVar26 = uVar26 | 0x20;\n    case 0x74:\n    case 0x7a:\nswitchD_08005f58_caseD_74:\n      uVar25 = (uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case 0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case 0x6e:\n      ppiVar16 = local_154 + 1;\n      ppbVar17 = (byte **)*local_154;\n      local_154 = ppiVar16;\n      if ((uVar26 & 0x20) != 0) {\n        *ppbVar17 = local_164;\n        ppbVar17[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if ((uVar26 & 0x10) == 0) {\n        if ((uVar26 & 0x40) != 0) {\n          *(short *)ppbVar17 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if ((uVar26 & 0x200) != 0) {\n          *(char *)ppbVar17 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar17 = local_164;\n      goto LAB_0800620e;\n    case 0x70:\n      local_f4 = 0x7830;\n      piVar24 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      uVar26 = uVar26 | 2;\n      piVar18 = (int *)0x0;\n      iVar4 = 2;\n      uVar25 = 0x78;\n      local_154 = local_154 + 1;\n      break;\n    case 0x75:\n      if (-1 < (int)(uVar26 << 0x1a)) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      iVar4 = 1;\n      local_154 = ppiVar16 + 2;\n      break;\n    case 0x78:\n      local_11c = \"0123456789abcdef\";\n      if ((uVar26 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar16 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar24 = *ppiVar16;\n      piVar18 = ppiVar16[1];\n      local_154 = ppiVar16 + 2;\nLAB_080061be:\n      if (((uVar26 & 1) != 0) && (((uint)piVar24 | (uint)piVar18) != 0)) {\n        uVar26 = uVar26 | 2;\n        local_f4 = CONCAT11((char)uVar25,0x30);\n      }\n      iVar4 = 2;\n      uVar26 = uVar26 & 0xfffffbff;\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      local_140 = uVar26;\n      if (iVar4 != 1) goto LAB_08006136;\nLAB_08006980:\n      local_140 = uVar26;\n      if (piVar18 == (int *)0x0 && piVar24 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar31 = CONCAT44(piVar18,piVar24);\n      local_138 = (int *)0x0;\n      param_3 = (int *)(&bStack_2a + 2);\n      do {\n        iVar4 = (int)((ulonglong)lVar31 >> 0x20);\n        uVar26 = (uint)lVar31;\n        cVar10 = '\\n';\n        __aeabi_uldivmod(uVar26,iVar4,10,0);\n        *(byte *)((int)param_3 + -1) = cVar10 + 0x30;\n        local_138 = (int *)((int)local_138 + 1);\n        param_3 = (int *)((int)param_3 + -1);\n        if (((((local_140 & 0x400) != 0) && (local_138 == (int *)(uint)*local_108)) &&\n            (local_138 != (int *)0xff)) && (iVar4 != 0 || 9 < uVar26)) {\n          param_3 = (int *)((int)param_3 - (int)local_104);\n          strncpy((char *)param_3,(char *)local_110,(size_t)local_104);\n          if (local_108[1] == 0) {\n            local_138 = (int *)0x0;\n          }\n          else {\n            local_108 = local_108 + 1;\n            local_138 = (int *)0x0;\n          }\n        }\n        lVar31 = __aeabi_uldivmod(uVar26,iVar4,10,0);\n      } while (lVar31 != 0);\n      local_158 = (char *)((int)(&bStack_2a + 2) - (int)param_3);\n    }\n    else {\n      local_140 = uVar26 & 0xffffff7f;\n      iVar6 = iVar4;\n      if (((uint)piVar24 | (uint)piVar18) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar4 == 0) {\n            local_158 = (char *)(uVar26 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              param_3 = (int *)(&bStack_2a + 2);\n            }\n            else {\n              param_3 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n            }\n          }\n          else {\n            param_3 = (int *)(&bStack_2a + 2);\n          }\n        }\n        else {\n          if (iVar4 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar24 + '0';\n          param_3 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar4 = iVar6;\n        uVar26 = local_140;\n        if (iVar6 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar4 == 2) {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = (int *)((uint)piVar24 >> 4 | (int)piVar18 << 0x1c);\n            piVar18 = (int *)((uint)piVar18 >> 4);\n            param_3 = (int *)((int)param_3 + -1);\n            *(char *)param_3 = local_11c[(uint)piVar24 & 0xf];\n            piVar24 = piVar19;\n          } while (((uint)piVar19 | (uint)piVar18) != 0);\n        }\n        else {\n          param_3 = (int *)(&bStack_2a + 2);\n          do {\n            piVar19 = param_3;\n            piVar12 = (int *)((uint)piVar24 >> 3 | (int)piVar18 << 0x1d);\n            piVar18 = (int *)((uint)piVar18 >> 3);\n            iVar4 = ((uint)piVar24 & 7) + 0x30;\n            *(byte *)((int)piVar19 + -1) = (byte)iVar4;\n            param_3 = (int *)((int)piVar19 + -1);\n            piVar24 = piVar12;\n          } while (((uint)piVar12 | (uint)piVar18) != 0);\n          if (((local_140 & 1) != 0) && (iVar4 != 0x30)) {\n            param_3 = (int *)((int)piVar19 + -2);\n            local_158 = (char *)(&bStack_2a + (2 - (int)param_3));\n            *(byte *)((int)piVar19 + -2) = 0x30;\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)param_3));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = 0;\n    local_134 = (int *)0x0;\n    local_130 = 0;\n    piVar18 = (int *)(uint)local_f5;\n    piVar24 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  if (local_d0 == (byte *)0x0) {\nLAB_0800604a:\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\n  else {\n    __ssprint_r(param_1,param_2,&local_d8);\n    uVar15 = *(ushort *)(param_2 + 3);\n  }\nLAB_0800604e:\n  if ((uVar15 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (uVar25 == 0x6c) {\n    uVar25 = (uint)*(byte *)((int)piVar28 + 1);\n    uVar26 = uVar26 | 0x20;\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    uVar26 = uVar26 | 0x10;\n  }\n  goto LAB_08005f4a;\n  while (iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0), iVar6 == 0) {\nLAB_080072ba:\n    piVar18 = piVar24;\n    piVar19 = local_138;\n    piVar24 = (int *)((int)piVar18 + -1);\n    uVar32 = __muldf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),0,0x40300000);\n    iVar4 = __aeabi_d2iz();\n    uVar33 = __aeabi_i2d();\n    uVar32 = __subdf3((int)uVar32,(int)((ulonglong)uVar32 >> 0x20),(int)uVar33,\n                      (int)((ulonglong)uVar33 >> 0x20));\n    uVar8 = (undefined4)((ulonglong)uVar32 >> 0x20);\n    uVar7 = (undefined4)uVar32;\n    local_138 = (int *)((int)piVar19 + 1);\n    *(char *)piVar19 = local_158[iVar4];\n    if (piVar24 == (int *)0xffffffff) break;\n  }\n  iVar6 = __aeabi_dcmpgt(uVar7,uVar8,0,0x3fe00000);\n  if ((iVar6 == 0) &&\n     ((iVar6 = __aeabi_dcmpeq(uVar7,uVar8,0,0x3fe00000), iVar6 == 0 || (-1 < iVar4 << 0x1f)))) {\n    if (-1 < (int)piVar24) {\n      piVar18 = (int *)((int)piVar18 + (int)local_138);\n      piVar24 = local_138;\n      do {\n        local_138 = (int *)((int)piVar24 + 1);\n        *(byte *)piVar24 = 0x30;\n        piVar24 = local_138;\n      } while (piVar18 != local_138);\n    }\n  }\n  else {\n    bVar1 = local_158[0xf];\n    bVar11 = *(byte *)piVar19;\n    piVar24 = local_138;\n    local_e0 = piVar19;\n    while (bVar1 == bVar11) {\n      *(byte *)((int)piVar24 + -1) = 0x30;\n      bVar11 = *(byte *)((int)local_e0 + -1);\n      piVar24 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar11 == 0x39) {\n      bVar11 = local_158[10];\n    }\n    else {\n      bVar11 = bVar11 + 1;\n    }\n    *(byte *)((int)piVar24 + -1) = bVar11;\n  }\n  local_138 = (int *)((int)local_138 - (int)param_3);\nLAB_08006cb0:\n  local_168 = (int *)(uVar25 & 0xffffffdf);\n  local_134 = local_f0[0];\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0[0] + 3) < 0 == SCARRY4((int)local_f0[0],3)) &&\n       ((int)local_f0[0] <= (int)piVar27)) {\n      if ((int)local_f0[0] < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)piVar3);\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0[0]));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        uVar25 = 0x67;\n      }\n      else {\n        if ((int)(uVar26 << 0x1f) < 0) {\n          local_158 = (char *)((int)local_f0[0] + (int)piVar3);\n        }\n        else {\n          local_158 = (char *)local_f0[0];\n        }\n        if (-1 < (int)(uVar26 << 0x15)) {\n          uVar25 = 0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0[0]) {\n          uVar25 = 0x67;\n          goto LAB_080074fc;\n        }\n        uVar25 = 0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    uVar25 = uVar25 - 2;\n    local_168 = (int *)(uVar25 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8._0_1_ = (char)uVar25;\n    if (local_168 == (int *)0x41) {\n      local_e8._0_1_ = (char)local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0[0] + -1);\n    if ((int)piVar27 < 0) {\n      local_e8._1_1_ = 0x2d;\n      local_f0[0] = (int *)(1 - (int)local_f0[0]);\n    }\n    else {\n      local_e8._1_1_ = 0x2b;\n      local_f0[0] = piVar27;\n    }\n    if ((int)local_f0[0] < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e8._2_1_ = 0x30;\n        pcVar21 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar21 = (char)local_f0[0] + '0';\n      pcVar21 = pcVar21 + 1;\n    }\n    else {\n      pbVar29 = abStack_dc + 3;\n      pbVar23 = pbVar29;\n      do {\n        pbVar9 = pbVar23;\n        piVar24 = (int *)((uint)local_f0[0] / 10);\n        pbVar9[-1] = (char)local_f0[0] + (char)piVar24 * -10 + 0x30;\n        pbVar23 = pbVar9 + -1;\n        local_f0[0] = piVar24;\n      } while ((int *)0x9 < piVar24);\n      uVar22 = (uint)(piVar24 + 0xc) & 0xff;\n      pbVar9[-2] = (byte)uVar22;\n      if (pbVar9 + -2 < pbVar29) {\n        pbVar9 = pbVar23;\n        pcVar21 = (char *)((int)&local_e8 + 2);\n        while( true ) {\n          *pcVar21 = (char)uVar22;\n          if (pbVar29 == pbVar9) break;\n          uVar22 = (uint)*pbVar9;\n          pbVar9 = pbVar9 + 1;\n          pcVar21 = pcVar21 + 1;\n        }\n        pcVar21 = (char *)(((int)&stack0xfffffe78 * 2 - (int)pbVar23) + 0x152);\n      }\n      else {\n        pcVar21 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar21 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)(uVar26 << 0x1f) < 0)) {\n      local_158 = (char *)((int)local_158 + (int)piVar3);\n    }\n    local_13c = 0;\n    local_134 = (int *)0x0;\n    local_130 = 0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    local_140 = uVar26 & 0xfffffbff | 0x100;\n    local_f0[0] = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0[0] < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (char *)((byte *)((int)piVar3 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = 0;\n      local_130 = 0;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)(uVar26 << 0x1f))) {\n        uVar25 = 0x66;\n        local_158 = (char *)local_f0[0];\n      }\n      else {\n        uVar25 = 0x66;\n        local_158 = (char *)((byte *)((int)local_f0[0] + (int)piVar3) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)(uVar26 << 0x15)) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = 0;\n      local_130 = 0;\n      uVar26 = (uint)*local_108;\n      while (uVar26 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar26) goto LAB_08007524;\n          uVar22 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar26);\n          if (uVar22 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = local_130 + 1;\n          uVar26 = uVar22;\n          if (uVar22 == 0xff) goto LAB_08007524;\n        }\n        local_13c = local_13c + 1;\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_104 * (local_130 + local_13c) + (int)local_158);\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    }\n  }\n  if (local_144 == 0) {\n    piVar18 = (int *)(uint)local_f5;\n    piVar24 = (int *)0x0;\nLAB_08006538:\n    uVar26 = local_140;\n    if (piVar18 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar18 = (int *)0x2d;\n    piVar24 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n    uVar26 = local_140;\n  }\nLAB_08006298:\n  if ((uVar26 & 2) != 0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  if (((uVar26 & 0x84) == 0) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        piVar18 = piVar27;\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)piVar27);\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar27;\n    if (local_d4 < 8) {\n      piVar18 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar18 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar18 != (int *)0x0) {\n    local_d0 = local_d0 + 1;\n    local_d4 = local_d4 + 1;\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((uVar26 & 2) != 0) {\n    local_d0 = local_d0 + 2;\n    local_d4 = local_d4 + 1;\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if (((uVar26 & 0x84) == 0x80) &&\n     (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27)) {\n    if (0x10 < (int)piVar27) {\n      do {\n        while( true ) {\n          piVar18 = piVar27;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar27 = piVar18 + -4;\n          if ((int)(piVar18 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar27 = piVar18 + -4;\n      } while (0x10 < (int)(piVar18 + -4));\nLAB_08006882:\n      piVar27 = piVar18 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar27;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar24 = (int *)((int)piVar24 - (int)local_158);\n  if (0 < (int)piVar24) {\n    if (0x10 < (int)piVar24) {\n      do {\n        while( true ) {\n          piVar27 = piVar24;\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + 0x10;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if (local_d4 < 8) break;\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar24 = piVar27 + -4;\n          if ((int)(piVar27 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar24 = piVar27 + -4;\n      } while (0x10 < (int)(piVar27 + -4));\nLAB_080063d2:\n      piVar24 = piVar27 + -4;\n    }\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar24;\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar24;\n    if (local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  pbVar23 = local_d0;\n  if ((uVar26 & 0x100) == 0) {\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)local_158;\n    *ppiVar2 = param_3;\n    ppiVar2[1] = (int *)local_158;\n    if (local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      pbVar23 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else if ((int)uVar25 < 0x66) {\n    local_158 = (char *)(local_d0 + 1);\n    iVar4 = local_d4 + 1;\n    ppiVar16 = ppiVar2 + 2;\n    local_d0 = (byte *)local_158;\n    if (((int)local_138 < 2) && ((uVar26 & 1) == 0)) {\n      *ppiVar2 = param_3;\n      ppiVar2[1] = (int *)0x1;\n      if (iVar4 < 8) {\n        local_150 = (int *)(local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = iVar4;\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        local_150 = (int *)(local_d4 + 1);\n        ppiVar16 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = param_3;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = iVar4;\n      if (7 < iVar4) {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar16 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = local_d4 + 1;\n      local_d0 = (byte *)(local_158 + (int)piVar3);\n      *ppiVar16 = __s;\n      ppiVar16[1] = piVar3;\n      if (local_d4 < 8) {\n        ppiVar20 = ppiVar16 + 2;\n      }\n      else {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar20 = local_cc;\n      }\n      local_158 = (char *)local_d0;\n      iVar4 = local_d4;\n      local_150 = (int *)(local_d4 + 1);\n      piVar27 = (int *)((int)local_138 + -1);\n      ppiVar13 = ppiVar20 + 2;\n      iVar6 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n      local_d4 = (int)local_150;\n      if (iVar6 == 0) {\n        local_158 = (char *)((byte *)local_158 + (int)piVar27);\n        *ppiVar20 = (int *)((int)param_3 + 1);\n        ppiVar20[1] = piVar27;\n        local_d0 = (byte *)local_158;\n        if ((int)local_150 < 8) {\n          local_150 = (int *)(iVar4 + 2);\n          ppiVar16 = ppiVar13;\n          ppiVar2 = ppiVar20 + 4;\n        }\n        else {\nLAB_08006d9c:\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          local_150 = (int *)(local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar16 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar16 = ppiVar20;\n        ppiVar2 = ppiVar13;\n        if (0 < (int)piVar27) {\n          if (0x10 < (int)piVar27) {\n            while( true ) {\n              local_d0 = (byte *)local_158 + 0x10;\n              *ppiVar20 = (int *)0x8009f60;\n              ppiVar20[1] = (int *)0x10;\n              if (local_d4 < 8) {\n                ppiVar20 = ppiVar20 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                ppiVar20 = local_cc;\n              }\n              piVar27 = piVar27 + -4;\n              local_158 = (char *)local_d0;\n              if ((int)piVar27 < 0x11) break;\n              local_d4 = local_d4 + 1;\n            }\n            local_150 = (int *)(local_d4 + 1);\n            ppiVar13 = ppiVar20 + 2;\n          }\n          *ppiVar20 = (int *)0x8009f60;\n          ppiVar20[1] = piVar27;\n          local_158 = local_158 + (int)piVar27;\n          local_d4 = (int)local_150;\n          local_d0 = (byte *)local_158;\n          if (7 < (int)local_150) goto LAB_08006d9c;\n          local_150 = (int *)((int)local_150 + 1);\n          ppiVar2 = ppiVar13 + 2;\n          ppiVar16 = ppiVar13;\n        }\n      }\n    }\n    ppiVar16[1] = local_10c;\n    local_d0 = (byte *)(local_158 + (int)local_10c);\n    local_d4 = (int)local_150;\n    *ppiVar16 = &local_e8;\n    pbVar23 = local_d0;\n    if (7 < (int)local_150) {\n      iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n      if (iVar4 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      pbVar23 = local_d0;\n    }\n  }\n  else {\n    iVar4 = __aeabi_dcmpeq(local_128,local_12c,0,0);\n    if (iVar4 == 0) {\n      if ((int)local_f0[0] < 1) {\n        local_d4 = local_d4 + 1;\n        local_d0 = pbVar23 + 1;\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0[0] != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = local_d0 + (int)piVar3;\n          *ppiVar2 = __s;\n          ppiVar2[1] = piVar3;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          if ((int)local_f0[0] < 0) {\n            piVar27 = (int *)-(int)local_f0[0];\n            if ((int)(local_f0[0] + 4) < 0 != SCARRY4((int)local_f0[0],0x10)) {\n              do {\n                local_d4 = local_d4 + 1;\n                local_d0 = local_d0 + 0x10;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if (local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar4 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = local_d4 + 1;\n            local_d0 = local_d0 + (int)piVar27;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = local_d0 + (int)local_138;\n          *ppiVar2 = param_3;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar27 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar27 = local_138;\n        }\n        if (0 < (int)piVar27) {\n          local_d0 = pbVar23 + (int)piVar27;\n          local_d4 = local_d4 + 1;\n          *ppiVar2 = param_3;\n          ppiVar2[1] = piVar27;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar24 = local_134;\n        if (-1 < (int)piVar27) {\n          piVar24 = (int *)((int)local_134 - (int)piVar27);\n        }\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\n          local_d4 = local_d4 + 1;\n          pbVar23 = pbVar23 + (int)piVar24;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\n          local_d0 = pbVar23;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        local_134 = (int *)((int)local_134 + (int)param_3);\n        if ((uVar26 & 0x400) != 0) {\n          if (local_130 == 0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != 0) goto LAB_0800717e;\n          local_108 = local_108 + -1;\n          local_130 = local_130 + -1;\n          do {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + (int)local_104;\n            *ppiVar2 = local_110;\n            ppiVar2[1] = local_104;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar24 = (int *)(uint)*local_108;\n            piVar27 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n            if ((int)piVar24 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n              piVar27 = piVar24;\n            }\n            if (0 < (int)piVar27) {\n              local_d0 = local_d0 + (int)piVar27;\n              local_d4 = local_d4 + 1;\n              *ppiVar2 = local_134;\n              ppiVar2[1] = piVar27;\n              if (local_d4 < 8) {\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar24 = (int *)(uint)*local_108;\n              }\n            }\n            piVar18 = piVar24;\n            if (-1 < (int)piVar27) {\n              piVar18 = (int *)((int)piVar24 - (int)piVar27);\n            }\n            if (0 < (int)piVar18) {\n              for (; 0x10 < (int)piVar18; piVar18 = piVar18 + -4) {\n                while( true ) {\n                  local_d4 = local_d4 + 1;\n                  local_d0 = local_d0 + 0x10;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if (local_d4 < 8) break;\n                  iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                  if (iVar4 != 0) goto LAB_0800603e;\n                  piVar18 = piVar18 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar18 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = local_d4 + 1;\n              local_d0 = local_d0 + (int)piVar18;\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar18;\n              if (local_d4 < 8) {\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n                if (iVar4 != 0) goto LAB_0800603e;\n                piVar24 = (int *)(uint)*local_108;\n                ppiVar2 = local_cc;\n              }\n            }\n            local_134 = (int *)((int)local_134 + (int)piVar24);\n            pbVar23 = local_d0;\n            if (local_130 != 0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == 0) {\n              if ((int *)((int)param_3 + (int)local_138) <= local_134) {\n                local_134 = (int *)((int)param_3 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = local_13c + -1;\n          } while( true );\n        }\n        if (((int)local_f0[0] < (int)local_138) || ((uVar26 & 1) != 0)) {\n          local_d4 = local_d4 + 1;\n          local_d0 = pbVar23 + (int)piVar3;\n          *ppiVar2 = __s;\n          ppiVar2[1] = piVar3;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            pbVar23 = local_d0;\n          }\n        }\n        piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n        piVar24 = (int *)((byte *)((int)param_3 + (int)local_138) + -(int)local_134);\n        if ((int)piVar27 <= (int)((byte *)((int)param_3 + (int)local_138) + -(int)local_134)) {\n          piVar24 = piVar27;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = pbVar23 + (int)piVar24;\n          local_d4 = local_d4 + 1;\n          *ppiVar2 = local_134;\n          ppiVar2[1] = piVar24;\n          if (local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            pbVar23 = local_d0;\n          }\n          else {\n            iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n            if (iVar4 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = (int *)((int)local_138 - (int)local_f0[0]);\n            pbVar23 = local_d0;\n          }\n        }\n        if (-1 < (int)piVar24) {\n          piVar27 = (int *)((int)piVar27 - (int)piVar24);\n        }\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = local_d4 + 1;\n      local_d0 = pbVar23 + 1;\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if (local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0[0] < (int)local_138) || (pbVar23 = local_d0, (uVar26 & 1) != 0)) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + (int)piVar3;\n        *ppiVar2 = __s;\n        ppiVar2[1] = piVar3;\n        if (local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n          if (iVar4 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar27 = (int *)((int)local_138 + -1);\n        pbVar23 = local_d0;\n        if (0 < (int)piVar27) {\n          for (; 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n            local_d4 = local_d4 + 1;\n            local_d0 = pbVar23 + 0x10;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if (local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n              if (iVar4 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            pbVar23 = local_d0;\n          }\nLAB_08007014:\n          local_d0 = pbVar23 + (int)piVar27;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar27;\njoined_r0x08006a1c:\n          local_d4 = local_d4 + 1;\n          if (7 < local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  if (((uVar26 & 4) != 0) && (piVar27 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar27))\n  {\n    for (; local_d0 = pbVar23, 0x10 < (int)piVar27; piVar27 = piVar27 + -4) {\n      while( true ) {\n        local_d4 = local_d4 + 1;\n        local_d0 = local_d0 + 0x10;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if (local_d4 < 8) break;\n        iVar4 = __ssprint_r(param_1,param_2,&local_d8);\n        if (iVar4 != 0) goto LAB_0800603e;\n        piVar27 = piVar27 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar27 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      pbVar23 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = local_d4 + 1;\n    local_d0 = local_d0 + (int)piVar27;\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar27;\n    pbVar23 = local_d0;\n    if ((7 < local_d4) &&\n       (iVar4 = __ssprint_r(param_1,param_2,&local_d8), pbVar23 = local_d0, iVar4 != 0))\n    goto LAB_0800603e;\n  }\n  if ((int)local_15c < (int)local_168) {\n    local_15c = local_168;\n  }\n  local_164 = local_164 + (int)local_15c;\n  if ((pbVar23 == (byte *)0x0) || (iVar4 = __ssprint_r(param_1,param_2,&local_d8), iVar4 == 0)) {\n    local_d4 = 0;\n    if (local_148 != (int *)0x0) {\n      _free_r(param_1,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(param_1,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  uVar22 = uVar25 - 0x30;\n  piVar24 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar24 + 1);\n    uVar25 = (uint)*(byte *)piVar24;\n    local_15c = (int *)(uVar22 + (int)local_15c * 10);\n    uVar22 = uVar25 - 0x30;\n    piVar24 = piVar28;\n  } while (uVar22 < 10);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  uVar25 = (uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "sprintf"
            ],
            "called": [
                "__ssprint_r",
                "__aeabi_dcmpgt",
                "__aeabi_uldivmod",
                "_dtoa_r",
                "_localeconv_r",
                "__aeabi_dcmpeq",
                "__aeabi_dcmple",
                "__unorddf2",
                "frexp",
                "__aeabi_dcmplt",
                "__subdf3",
                "strncpy",
                "__aeabi_i2d",
                "_malloc_r",
                "strlen",
                "_free_r",
                "__muldf3",
                "__aeabi_d2iz",
                "memchr"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078b4": {
            "entrypoint": "0x080078b4",
            "current_name": "register_exit_procedure_080078b4",
            "code": "\nint registerExitProcedure_080078b4(functionPointer *functionPointer)\n\n{\n  int result;\n  \n  result = __register_exitproc(0,functionPointer,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080078b4": "register_exit_procedure_080078b4",
                "__func": "functionPointer",
                "iVar1": "result"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_division_080078c0",
            "code": "\nuint calculateDivision_080078c0(int dividend,int divisor)\n\n{\n  uint carry;\n  uint *dividendPtr;\n  int quotient;\n  int dividendLength;\n  int divisorLength;\n  uint result;\n  uint *divisorPtr;\n  uint *dividendEndPtr;\n  uint *divisorEndPtr;\n  uint carry0;\n  uint *divisorPtr2;\n  uint *divisorPtrTemp;\n  \n  dividendLength = *(int *)(divisor + 0x10);\n  if (*(int *)(dividend + 0x10) < dividendLength) {\n    return 0;\n  }\n  divisorLength = dividendLength + -1;\n  divisorPtr = (uint *)(divisor + 0x14);\n  dividendEndPtr = (uint *)(dividend + 0x14);\n  result = dividendEndPtr[divisorLength] / (divisorPtr[divisorLength] + 1);\n  divisorEndPtr = divisorPtr + divisorLength;\n  if (result != 0) {\n    carry = 0;\n    quotient = 0;\n    dividendPtr = dividendEndPtr;\n    divisorPtr2 = divisorPtr;\n    do {\n      divisorPtrTemp = divisorPtr2 + 1;\n      carry = result * (*divisorPtr2 & 0xffff) + carry;\n      carry0 = result * (*divisorPtr2 >> 0x10) + (carry >> 0x10);\n      carry = (quotient - (carry & 0xffff)) + (*dividendPtr & 0xffff);\n      quotient = ((*dividendPtr >> 0x10) - (carry0 & 0xffff)) + ((int)carry >> 0x10);\n      *dividendPtr = carry & 0xffff | quotient * 0x10000;\n      quotient = quotient >> 0x10;\n      carry = carry0 >> 0x10;\n      dividendPtr = dividendPtr + 1;\n      divisorPtr2 = divisorPtrTemp;\n    } while (divisorPtrTemp <= divisorEndPtr);\n    if (dividendEndPtr[divisorLength] == 0) {\n      if ((dividendEndPtr < dividendEndPtr + dividendLength + -2) && (dividendEndPtr[dividendLength + -2] == 0)) {\n        dividendPtr = dividendEndPtr + dividendLength + -3;\n        do {\n          divisorLength = divisorLength + -1;\n          if (dividendPtr <= dividendEndPtr) break;\n          carry = *dividendPtr;\n          dividendPtr = dividendPtr + -1;\n        } while (carry == 0);\n      }\n      *(int *)(dividend + 0x10) = divisorLength;\n    }\n  }\n  dividendLength = __mcmp();\n  if (-1 < dividendLength) {\n    dividendLength = 0;\n    result = result + 1;\n    dividendPtr = dividendEndPtr;\n    do {\n      divisorPtr2 = divisorPtr + 1;\n      carry = (dividendLength - (*divisorPtr & 0xffff)) + (*dividendPtr & 0xffff);\n      dividendLength = ((*dividendPtr >> 0x10) - (*divisorPtr >> 0x10)) + ((int)carry >> 0x10);\n      *dividendPtr = carry & 0xffff | dividendLength * 0x10000;\n      dividendLength = dividendLength >> 0x10;\n      dividendPtr = dividendPtr + 1;\n      divisorPtr = divisorPtr2;\n    } while (divisorPtr2 <= divisorEndPtr);\n    if (dividendEndPtr[divisorLength] == 0) {\n      if ((dividendEndPtr < dividendEndPtr + divisorLength + -1) && (dividendEndPtr[divisorLength + -1] == 0)) {\n        divisorPtr = dividendEndPtr + divisorLength + -2;\n        do {\n          divisorLength = divisorLength + -1;\n          if (divisorPtr <= dividendEndPtr) break;\n          carry = *divisorPtr;\n          divisorPtr = divisorPtr + -1;\n        } while (carry == 0);\n      }\n      *(int *)(dividend + 0x10) = divisorLength;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_division_080078c0",
                "param_1": "dividend",
                "param_2": "divisor",
                "iVar4": "dividendLength",
                "iVar5": "divisorLength",
                "uVar1": "carry",
                "puVar2": "dividendPtr",
                "puVar7": "divisorPtr",
                "puVar8": "dividendEndPtr",
                "puVar9": "divisorEndPtr",
                "uVar6": "result",
                "puVar11": "divisorPtr2",
                "puVar12": "divisorPtrTemp",
                "iVar3": "quotient"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__mcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "convert_float_to_string_080079e8",
            "code": "\nchar * convertFloatToString_080079e8(int floatValue,undefined4 param1,uint integerPart,uint sign,uint precision,\n                   uint scale,int *digits,uint *isNegative,char **outputString)\n\n{\n  bool isInfinity;\n  bool isLessThanZero;\n  bool addExtraZero;\n  char character;\n  byte isZero;\n  undefined4 temp;\n  int shiftAmount;\n  int comparisonResult;\n  int multiplicationResult;\n  char *outputPtr;\n  uint temp1;\n  undefined4 temp2;\n  undefined4 temp3;\n  int shiftResult;\n  int exponentDifference;\n  undefined4 temp4;\n  uint temp5;\n  uint temp6;\n  int powerOfFive;\n  char *loopPtr;\n  char *outputCharPtr;\n  undefined4 *puVar22;\n  undefined4 temp7;\n  int characterCode;\n  bool isNegativeOutput;\n  undefined8 result;\n  undefined8 multiplicationTemp;\n  undefined8 comparisonTemp;\n  uint tens;\n  uint absScale;\n  uint exp;\n  int fractionPartLength;\n  uint printedDigits;\n  int integerPartLength;\n  int fractionPartOffset;\n  uint exponentOffset;\n  uint tensCount;\n  uint uStack_44;\n  uint scaleForFraction;\n  uint exponent;\n  int digitCount;\n  int scaleAndPrecision [2];\n  \n  shiftResult = *(int *)(floatValue + 0x40);\n  if (shiftResult != 0) {\n    temp6 = *(uint *)(floatValue + 0x44);\n    *(uint *)(shiftResult + 4) = temp6;\n    *(int *)(shiftResult + 8) = 1 << (temp6 & 0xff);\n    _Bfree(floatValue,shiftResult);\n    *(undefined4 *)(floatValue + 0x40) = 0;\n  }\n  isNegativeOutput = (int)sign < 0;\n  temp6 = sign;\n  if (isNegativeOutput) {\n    temp6 = sign & 0x7fffffff;\n  }\n  *isNegative = (uint)isNegativeOutput;\n  absScale = sign;\n  if (isNegativeOutput) {\n    absScale = temp6;\n  }\n  temp5 = absScale;\n  if ((~temp6 & 0x7ff00000) == 0) {\n    *digits = 9999;\n    if ((integerPart == 0) && ((temp6 & 0xfffff) == 0)) {\n      outputPtr = \"Infinity\";\n      if (outputString == (char **)0x0) {\n        return outputPtr;\n      }\n      outputCharPtr = \"\";\n    }\n    else {\n      outputPtr = \"NaN\";\n      if (outputString == (char **)0x0) {\n        return outputPtr;\n      }\n      outputCharPtr = \"\";\n    }\n    *outputString = outputCharPtr;\n    return outputPtr;\n  }\n  result = __aeabi_dcmpeq(integerPart,absScale,0,0);\n  if ((int)result != 0) {\n    *digits = 1;\n    if (outputString != (char **)0x0) {\n      *outputString = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  temp = __d2b(floatValue,(int)((ulonglong)result >> 0x20),integerPart,absScale,scaleAndPrecision,&digitCount);\n  shiftResult = digitCount;\n  if (temp6 >> 0x14 == 0) {\n    powerOfFive = scaleAndPrecision[0] + digitCount;\n    exponentDifference = powerOfFive + 0x432;\n    if (exponentDifference < 0x21) {\n      temp6 = integerPart << (0x20U - exponentDifference & 0xff);\n    }\n    else {\n      temp6 = integerPart >> (powerOfFive + 0x412U & 0xff) | temp6 << (0x40U - exponentDifference & 0xff);\n    }\n    result = __floatunsidf(temp6);\n    powerOfFive = powerOfFive + -1;\n    isNegativeOutput = true;\n    temp1 = (int)((ulonglong)result >> 0x20) + 0xfe100000;\n    temp6 = (uint)result;\n  }\n  else {\n    powerOfFive = (temp6 >> 0x14) - 0x3ff;\n    temp1 = absScale & 0xfffff | 0x3ff00000;\n    isNegativeOutput = false;\n    temp6 = integerPart;\n  }\n  result = __subdf3(temp6,temp1,0,0x3ff80000);\n  result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0x636f4361,0x3fd287a7);\n  result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0x8b60c8b3,0x3fc68a28);\n  multiplicationTemp = __aeabi_i2d(powerOfFive);\n  multiplicationTemp = __muldf3((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),0x509f79fb,0x3fd34413);\n  result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),(int)multiplicationTemp,\n                        (int)((ulonglong)multiplicationTemp >> 0x20));\n  temp3 = (undefined4)((ulonglong)result >> 0x20);\n  exp = __aeabi_d2iz();\n  exponentDifference = __aeabi_dcmplt((int)result,temp3,0,0);\n  if (exponentDifference != 0) {\n    multiplicationTemp = __aeabi_i2d(exp);\n    exponentDifference = __aeabi_dcmpeq((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),(int)result,temp3);\n    if (exponentDifference == 0) {\n      exp = exp - 1;\n    }\n  }\n  if (exp < 0x17) {\n    exponentDifference = __aeabi_dcmpgt(*(undefined4 *)(&__mprec_tens + exp * 8),\n                            *(undefined4 *)(&DAT_08009fac + exp * 8),integerPart,absScale);\n    if (exponentDifference == 0) {\n      isLessThanZero = false;\n    }\n    else {\n      exp = exp - 1;\n      isLessThanZero = false;\n    }\n  }\n  else {\n    isLessThanZero = true;\n  }\n  exponentDifference = (shiftResult - powerOfFive) + -1;\n  if (exponentDifference < 0) {\n    fractionPartLength = 1 - (shiftResult - powerOfFive);\n    exponentDifference = 0;\n  }\n  else {\n    fractionPartLength = 0;\n  }\n  if ((int)exp < 0) {\n    exponentOffset = 0;\n    fractionPartLength = fractionPartLength - exp;\n    fractionPartOffset = -exp;\n  }\n  else {\n    exponentDifference = exponentDifference + exp;\n    exponentOffset = exp;\n    fractionPartOffset = 0;\n  }\n  if (9 < precision) {\n    scaleForFraction = 0xffffffff;\n    isInfinity = true;\n    printedDigits = 0xffffffff;\n    addExtraZero = true;\n    precision = 0;\n    scale = 0;\n    goto LAB_08007c24;\n  }\n  isInfinity = (int)precision < 6;\n  if (!isInfinity) {\n    precision = precision - 4;\n  }\n  switch(precision) {\n  case 2:\n    addExtraZero = false;\n    break;\n  case 3:\n    addExtraZero = false;\n    goto LAB_08008300;\n  case 4:\n    addExtraZero = true;\n    break;\n  case 5:\n    addExtraZero = true;\nLAB_08008300:\n    scaleForFraction = exp + scale;\n    printedDigits = scaleForFraction + 1;\n    temp6 = printedDigits;\n    if ((int)printedDigits < 1) {\n      temp6 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(floatValue + 0x44) = 0;\n    outputPtr = (char *)_Balloc(floatValue,0);\n    scaleForFraction = 0xffffffff;\n    printedDigits = 0xffffffff;\n    scale = 0;\n    *(char **)(floatValue + 0x40) = outputPtr;\n    addExtraZero = true;\n    goto LAB_08007e36;\n  }\n  if ((int)scale < 1) {\n    scaleForFraction = 1;\n    scale = 1;\n    printedDigits = 1;\nLAB_08007c24:\n    *(undefined4 *)(floatValue + 0x44) = 0;\n    temp1 = scaleForFraction;\n  }\n  else {\n    scaleForFraction = scale;\n    printedDigits = scale;\n    temp6 = scale;\nLAB_08008314:\n    *(undefined4 *)(floatValue + 0x44) = 0;\n    temp1 = printedDigits;\n    if (0x17 < (int)temp6) {\n      powerOfFive = 4;\n      shiftResult = 1;\n      do {\n        shiftAmount = shiftResult;\n        powerOfFive = powerOfFive * 2;\n        shiftResult = shiftAmount + 1;\n      } while (powerOfFive + 0x14U <= temp6);\n      *(int *)(floatValue + 0x44) = shiftAmount;\n    }\n  }\n  outputPtr = (char *)_Balloc(floatValue);\n  *(char **)(floatValue + 0x40) = outputPtr;\n  if ((temp1 < 0xf) && (isInfinity)) {\n    if ((int)exp < 1) {\n      if (exp == 0) {\n        shiftResult = 2;\n        tens = integerPart;\n      }\n      else {\n        shiftResult = (-exp & 0xf) * 8;\n        result = __muldf3(integerPart,absScale,*(undefined4 *)(&__mprec_tens + shiftResult),\n                          *(undefined4 *)(&DAT_08009fac + shiftResult));\n        absScale = (uint)((ulonglong)result >> 0x20);\n        tens = (uint)result;\n        powerOfFive = (int)-exp >> 4;\n        if (powerOfFive == 0) {\n          shiftResult = 2;\n        }\n        else {\n          isInfinity = false;\n          shiftResult = 2;\n          puVar22 = &__mprec_bigtens;\n          do {\n            if (powerOfFive << 0x1f < 0) {\n              result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),*puVar22,puVar22[1]);\n              isInfinity = true;\n              shiftResult = shiftResult + 1;\n            }\n            powerOfFive = powerOfFive >> 1;\n            puVar22 = puVar22 + 2;\n          } while (powerOfFive != 0);\n          if (isInfinity) {\n            tens = (uint)result;\n            absScale = (uint)((ulonglong)result >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      temp6 = (int)exp >> 4;\n      multiplicationTemp = *(undefined8 *)(&__mprec_tens + (exp & 0xf) * 8);\n      result = *(undefined8 *)(&__mprec_tens + (exp & 0xf) * 8);\n      if ((int)(temp6 << 0x1b) < 0) {\n        comparisonTemp = __divdf3(integerPart,absScale,0x7f73bf3c,0x75154fdd);\n        uStack_44 = (uint)((ulonglong)comparisonTemp >> 0x20);\n        tensCount = (uint)comparisonTemp;\n        shiftResult = 3;\n        temp6 = temp6 & 0xf;\n      }\n      else {\n        shiftResult = 2;\n        uStack_44 = absScale;\n        tensCount = integerPart;\n      }\n      if (temp6 != 0) {\n        puVar22 = &__mprec_bigtens;\n        do {\n          if ((int)(temp6 << 0x1f) < 0) {\n            result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),*puVar22,puVar22[1]);\n            shiftResult = shiftResult + 1;\n          }\n          temp6 = (int)temp6 >> 1;\n          puVar22 = puVar22 + 2;\n          multiplicationTemp = result;\n        } while (temp6 != 0);\n      }\n      absScale = (uint)((ulonglong)multiplicationTemp >> 0x20);\n      tens = (uint)multiplicationTemp;\n      result = __divdf3(tensCount,uStack_44,tens,absScale);\n      tens = (uint)result;\n      absScale = (uint)((ulonglong)result >> 0x20);\n    }\n    result = CONCAT44(absScale,tens);\n    if ((isLessThanZero) && (powerOfFive = __aeabi_dcmplt(tens,absScale,0,0x3ff00000), powerOfFive != 0)) {\n      if (printedDigits == 0) {\n        result = __aeabi_i2d(shiftResult);\n        result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),tens,absScale);\n        result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0,0x401c0000);\n        temp3 = (undefined4)result;\n        shiftResult = (int)((ulonglong)result >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)scaleForFraction) {\n        result = __muldf3(tens,absScale,0,0x40240000);\n        multiplicationTemp = __aeabi_i2d(shiftResult + 1);\n        multiplicationTemp = __muldf3((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),(int)result,\n                          (int)((ulonglong)result >> 0x20));\n        multiplicationTemp = __aeabi_dadd((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),0,0x401c0000);\n        temp3 = (undefined4)multiplicationTemp;\n        tensCount = scaleForFraction;\n        exponent = exp - 1;\n        shiftResult = (int)((ulonglong)multiplicationTemp >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    multiplicationTemp = __aeabi_i2d(shiftResult);\n    multiplicationTemp = __muldf3((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),tens,absScale);\n    multiplicationTemp = __aeabi_dadd((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),0,0x401c0000);\n    temp3 = (undefined4)multiplicationTemp;\n    shiftResult = (int)((ulonglong)multiplicationTemp >> 0x20) + -0x3400000;\n    if (printedDigits != 0) {\n      exponent = exp;\n      tensCount = printedDigits;\nLAB_08007cfa:\n      absScale = (uint)((ulonglong)result >> 0x20);\n      tens = (uint)result;\n      character = __aeabi_d2iz(tens,absScale);\n      character = character + '0';\n      temp4 = (&DAT_08009fa0)[tensCount * 2];\n      temp2 = (&DAT_08009fa4)[tensCount * 2];\n      result = __aeabi_i2d();\n      result = __subdf3(tens,absScale,(int)result,(int)((ulonglong)result >> 0x20));\n      temp7 = (undefined4)((ulonglong)result >> 0x20);\n      outputCharPtr = outputPtr + 1;\n      if (addExtraZero) {\n        multiplicationTemp = __divdf3(0,0x3fe00000,temp4,temp2);\n        multiplicationTemp = __subdf3((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),temp3,shiftResult);\n        temp3 = (undefined4)((ulonglong)multiplicationTemp >> 0x20);\n        *outputPtr = character;\n        shiftResult = __aeabi_dcmpgt((int)multiplicationTemp,temp3,(int)result,temp7);\n        if (shiftResult != 0) {\nLAB_08008784:\n          exp = exponent;\n          goto LAB_08008294;\n        }\n        comparisonTemp = __subdf3(0,0x3ff00000,(int)result,temp7);\n        shiftResult = __aeabi_dcmpgt((int)multiplicationTemp,temp3,(int)comparisonTemp,(int)((ulonglong)comparisonTemp >> 0x20));\n        if (shiftResult == 0) {\n          if (tensCount != 1) {\n            loopPtr = outputCharPtr;\n            do {\n              multiplicationTemp = __muldf3((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),0,0x40240000);\n              temp3 = (undefined4)((ulonglong)multiplicationTemp >> 0x20);\n              result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x40240000);\n              character = __aeabi_d2iz();\n              comparisonTemp = __aeabi_i2d();\n              result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)comparisonTemp,\n                                (int)((ulonglong)comparisonTemp >> 0x20));\n              temp4 = (undefined4)((ulonglong)result >> 0x20);\n              character = character + '0';\n              outputCharPtr = loopPtr + 1;\n              *loopPtr = character;\n              shiftResult = __aeabi_dcmplt((int)result,temp4,(int)multiplicationTemp,temp3);\n              if (shiftResult != 0) {\n                exp = exponent;\n                goto LAB_08008294;\n              }\n              comparisonTemp = __subdf3(0,0x3ff00000,(int)result,temp4);\n              shiftResult = __aeabi_dcmplt((int)comparisonTemp,(int)((ulonglong)comparisonTemp >> 0x20),(int)multiplicationTemp,\n                                      temp3);\n              if (shiftResult != 0) goto LAB_08008798;\n              loopPtr = outputCharPtr;\n            } while (outputCharPtr != outputPtr + tensCount);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        exp = exponent;\n      }\n      else {\n        multiplicationTemp = __muldf3(temp3,shiftResult,temp4,temp2);\n        temp3 = (undefined4)((ulonglong)multiplicationTemp >> 0x20);\n        *outputPtr = character;\n        if (tensCount != 1) {\n          loopPtr = outputCharPtr;\n          do {\n            result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x40240000);\n            character = __aeabi_d2iz();\n            comparisonTemp = __aeabi_i2d();\n            result = __subdf3((int)result,(int)((ulonglong)result >> 0x20),(int)comparisonTemp,\n                              (int)((ulonglong)comparisonTemp >> 0x20));\n            outputCharPtr = loopPtr + 1;\n            *loopPtr = character + '0';\n            loopPtr = outputCharPtr;\n          } while (outputCharPtr != outputPtr + tensCount);\n        }\n        temp4 = (undefined4)((ulonglong)result >> 0x20);\n        comparisonTemp = __aeabi_dadd((int)multiplicationTemp,temp3,0,0x3fe00000);\n        shiftResult = __aeabi_dcmplt((int)comparisonTemp,(int)((ulonglong)comparisonTemp >> 0x20),(int)result,temp4);\n        if (shiftResult == 0) {\n          multiplicationTemp = __subdf3(0,0x3fe00000,(int)multiplicationTemp,temp3);\n          shiftResult = __aeabi_dcmpgt((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),(int)result,temp4);\n          loopPtr = outputCharPtr;\n          if (shiftResult == 0) goto LAB_08007e36;\n          do {\n            outputCharPtr = loopPtr;\n            loopPtr = outputCharPtr + -1;\n          } while (outputCharPtr[-1] == '0');\n          goto LAB_08008784;\n        }\n        exp = exponent;\n        character = outputCharPtr[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    result = __subdf3(tens,absScale,0,0x40140000);\n    temp4 = (undefined4)((ulonglong)result >> 0x20);\n    powerOfFive = __aeabi_dcmpgt((int)result,temp4,temp3,shiftResult);\n    if (powerOfFive == 0) {\n      shiftResult = __aeabi_dcmplt((int)result,temp4,temp3,shiftResult + -0x80000000);\n      if (shiftResult == 0) goto LAB_08007e36;\n      powerOfFive = 0;\n      shiftResult = 0;\n      outputCharPtr = outputPtr;\n      goto LAB_080084f0;\n    }\n    exponentDifference = 0;\n    shiftAmount = 0;\nLAB_08008406:\n    *outputPtr = '1';\n    exp = exp + 1;\n    outputCharPtr = outputPtr + 1;\n    powerOfFive = shiftAmount;\n    shiftResult = exponentDifference;\nLAB_08008416:\n    _Bfree(floatValue,shiftResult);\n    if (powerOfFive == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    outputCharPtr = outputPtr;\n    if ((-1 < scaleAndPrecision[0]) && ((int)exp < 0xf)) {\n      temp3 = *(undefined4 *)(&__mprec_tens + exp * 8);\n      temp4 = *(undefined4 *)(&DAT_08009fac + exp * 8);\n      if ((-1 < (int)scale) || (0 < (int)printedDigits)) {\n        __divdf3(integerPart,temp5,temp3,temp4);\n        isZero = __aeabi_d2iz();\n        result = __aeabi_i2d();\n        result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),temp3,temp4);\n        result = __subdf3(integerPart,temp5,(int)result,(int)((ulonglong)result >> 0x20));\n        *outputPtr = isZero + 0x30;\n        outputCharPtr = outputPtr + 1;\n        if (printedDigits != 1) {\n          result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x40240000);\n          shiftResult = __aeabi_dcmpeq((int)result,(int)((ulonglong)result >> 0x20),0,0);\n          while (shiftResult == 0) {\n            temp7 = (undefined4)((ulonglong)result >> 0x20);\n            __divdf3((int)result,temp7,temp3,temp4);\n            isZero = __aeabi_d2iz();\n            multiplicationTemp = __aeabi_i2d();\n            multiplicationTemp = __muldf3((int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20),temp3,temp4);\n            result = __subdf3((int)result,temp7,(int)multiplicationTemp,(int)((ulonglong)multiplicationTemp >> 0x20));\n            loopPtr = outputCharPtr + 1;\n            *outputCharPtr = isZero + 0x30;\n            outputCharPtr = loopPtr;\n            if (printedDigits == (int)loopPtr - (int)outputPtr) goto LAB_08007f3a;\n            result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x40240000);\n            shiftResult = __aeabi_dcmpeq((int)result,(int)((ulonglong)result >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20));\n        temp7 = (undefined4)((ulonglong)result >> 0x20);\n        shiftResult = __aeabi_dcmpgt((int)result,temp7,temp3,temp4);\n        if ((shiftResult == 0) &&\n           ((shiftResult = __aeabi_dcmpeq((int)result,temp7,temp3,temp4), shiftResult == 0 ||\n            ((isZero & 1) == 0)))) goto LAB_08008294;\n        character = outputCharPtr[-1];\nLAB_08007f7c:\n        while (loopPtr = outputCharPtr + -1, character == '9') {\n          if (outputPtr == loopPtr) {\n            *outputPtr = '0';\n            character = outputCharPtr[-1];\n            exp = exp + 1;\n            loopPtr = outputPtr;\n            break;\n          }\n          character = outputCharPtr[-2];\n          outputCharPtr = loopPtr;\n        }\n        *loopPtr = character + '\\x01';\n        goto LAB_08008294;\n      }\n      if (printedDigits == 0) {\n        result = __muldf3(temp3,temp4,0,0x40140000);\n        multiplicationResult = __aeabi_dcmpge((int)result,(int)((ulonglong)result >> 0x20),integerPart,temp5);\n        powerOfFive = 0;\n        exponentDifference = 0;\n        shiftAmount = 0;\n        shiftResult = 0;\n        if (multiplicationResult == 0) goto LAB_08008406;\n      }\n      else {\n        powerOfFive = 0;\n        shiftResult = 0;\n      }\nLAB_080084f0:\n      exp = ~scale;\n      outputPtr = outputCharPtr;\n      goto LAB_08008416;\n    }\n    shiftResult = fractionPartOffset;\n    if (addExtraZero) {\n      if ((int)precision < 2) {\n        if (isNegativeOutput) {\n          integerPartLength = fractionPartLength;\n          fractionPartLength = fractionPartLength + scaleAndPrecision[0] + 0x433;\n          exponentDifference = exponentDifference + scaleAndPrecision[0] + 0x433;\n        }\n        else {\n          integerPartLength = fractionPartLength;\n          fractionPartLength = fractionPartLength + (0x36 - digitCount);\n          exponentDifference = exponentDifference + (0x36 - digitCount);\n        }\n      }\n      else {\n        powerOfFive = printedDigits - 1;\n        if (fractionPartOffset < powerOfFive) {\n          exponentOffset = exponentOffset + (powerOfFive - fractionPartOffset);\n          shiftResult = 0;\n          fractionPartOffset = powerOfFive;\n        }\n        else {\n          shiftResult = fractionPartOffset - powerOfFive;\n        }\n        if ((int)printedDigits < 0) {\n          integerPartLength = fractionPartLength - printedDigits;\n        }\n        else {\n          exponentDifference = exponentDifference + printedDigits;\n          integerPartLength = fractionPartLength;\n          fractionPartLength = fractionPartLength + printedDigits;\n        }\n      }\n      powerOfFive = __i2b(floatValue,1);\n    }\n    else {\n      integerPartLength = fractionPartLength;\n      powerOfFive = 0;\n    }\n    if ((0 < integerPartLength) && (0 < exponentDifference)) {\n      shiftAmount = integerPartLength;\n      if (exponentDifference <= integerPartLength) {\n        shiftAmount = exponentDifference;\n      }\n      exponentDifference = exponentDifference - shiftAmount;\n      fractionPartLength = fractionPartLength - shiftAmount;\n      integerPartLength = integerPartLength - shiftAmount;\n    }\n    if (fractionPartOffset != 0) {\n      if (addExtraZero) {\n        temp3 = temp;\n        if (shiftResult != 0) {\n          powerOfFive = __pow5mult(floatValue,powerOfFive,shiftResult);\n          temp3 = __multiply(floatValue,powerOfFive,temp);\n          _Bfree(floatValue,temp);\n          temp = temp3;\n          if (fractionPartOffset - shiftResult == 0) goto LAB_08008062;\n        }\n        temp = __pow5mult(floatValue,temp3,fractionPartOffset - shiftResult);\n      }\n      else {\n        temp = __pow5mult(floatValue,temp,fractionPartOffset);\n      }\n    }\nLAB_08008062:\n    shiftResult = __i2b(floatValue,1);\n    if (exponentOffset == 0) {\n      if (((int)precision < 2) && (integerPart == 0)) {\nLAB_0800835a:\n        if ((temp5 & 0xfffff) == 0) {\n          temp5 = temp5 & 0x7ff00000;\n          if (temp5 != 0) {\n            exponentDifference = exponentDifference + 1;\n            fractionPartLength = fractionPartLength + 1;\n            temp5 = 1;\n          }\n        }\n        else {\n          temp5 = 0;\n        }\n        isNegativeOutput = exponentOffset != 0;\n        temp6 = integerPart;\n        exponentOffset = temp5;\n        if (isNegativeOutput) goto LAB_080082d4;\n      }\n      shiftAmount = 1;\n    }\n    else {\n      result = __pow5mult(floatValue,shiftResult);\n      shiftResult = (int)result;\n      if (((int)precision < 2) && (integerPart == 0)) goto LAB_0800835a;\n      exponentOffset = 0;\n      temp6 = (uint)((ulonglong)result >> 0x20);\nLAB_080082d4:\n      shiftAmount = __hi0bits(*(undefined4 *)(shiftResult + *(int *)(shiftResult + 0x10) * 4 + 0x10),temp6);\n      shiftAmount = 0x20 - shiftAmount;\n    }\n    temp6 = shiftAmount + exponentDifference & 0x1f;\n    if (temp6 == 0) {\n      shiftAmount = 0x1c;\nLAB_08008096:\n      exponentDifference = exponentDifference + shiftAmount;\n      fractionPartLength = fractionPartLength + shiftAmount;\n      integerPartLength = integerPartLength + shiftAmount;\n    }\n    else {\n      if (4 < (int)(0x20 - temp6)) {\n        shiftAmount = 0x1c - temp6;\n        goto LAB_08008096;\n      }\n      if (0x20 - temp6 != 4) {\n        shiftAmount = 0x3c - temp6;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < fractionPartLength) {\n      temp = __lshift(floatValue,temp,fractionPartLength);\n    }\n    if (0 < exponentDifference) {\n      shiftResult = __lshift(floatValue,shiftResult,exponentDifference);\n    }\n    loopPtr = outputPtr;\n    if ((isLessThanZero) && (exponentDifference = __mcmp(temp,shiftResult), exponentDifference < 0)) {\n      exp = exp - 1;\n      temp = __multadd(floatValue,temp,10,0);\n      if (addExtraZero) {\n        powerOfFive = __multadd(floatValue,powerOfFive,10,0);\n        if ((0 < (int)scaleForFraction) || ((int)precision < 3)) {\n          printedDigits = scaleForFraction;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)scaleForFraction) || ((int)precision < 3)) {\n        printedDigits = scaleForFraction;\n        goto LAB_0800820a;\n      }\n      printedDigits = scaleForFraction;\nLAB_080084e8:\n      if (printedDigits == 0) {\n        exponentDifference = __multadd(floatValue,shiftResult,5);\n        multiplicationResult = __mcmp(temp,exponentDifference);\n        shiftAmount = powerOfFive;\n        shiftResult = exponentDifference;\n        if (0 < multiplicationResult) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)printedDigits < 1) && (2 < (int)precision)) goto LAB_080084e8;\n    if (addExtraZero) {\nLAB_080080de:\n      tens = powerOfFive;\n      if (0 < integerPartLength) {\n        tens = __lshift(floatValue,powerOfFive,integerPartLength);\n      }\n      powerOfFive = tens;\n      if (exponentOffset != 0) {\n        powerOfFive = _Balloc(floatValue,*(undefined4 *)(tens + 4));\n        memcpy((void *)(powerOfFive + 0xc),(void *)(tens + 0xc),(*(int *)(tens + 0x10) + 2) * 4);\n        powerOfFive = __lshift(floatValue,powerOfFive,1);\n      }\nLAB_08008108:\n      exponentDifference = quorem(temp,shiftResult);\n      shiftAmount = __mcmp(temp,tens);\n      multiplicationResult = __mdiff(floatValue,shiftResult,powerOfFive);\n      characterCode = exponentDifference + 0x30;\n      if (*(int *)(multiplicationResult + 0xc) == 0) {\n        comparisonResult = __mcmp(temp);\n        _Bfree(floatValue,multiplicationResult);\n        if ((comparisonResult != 0) || (precision != 0)) goto LAB_0800815a;\n        if ((integerPart & 1) != 0) {\n          comparisonResult = 0;\n          goto LAB_0800815a;\n        }\n        if (characterCode != 0x39) {\n          if (0 < shiftAmount) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        outputCharPtr = loopPtr + 1;\n        character = '9';\n        *loopPtr = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(floatValue,multiplicationResult);\n      comparisonResult = 1;\nLAB_0800815a:\n      if ((shiftAmount < 0) || (((shiftAmount == 0 && (precision == 0)) && ((integerPart & 1) == 0)))) {\n        if (0 < comparisonResult) {\n          temp = __lshift(floatValue,temp,1);\n          shiftAmount = __mcmp(temp,shiftResult);\n          if ((0 < shiftAmount) || ((shiftAmount == 0 && (exponentDifference << 0x1f < 0)))) {\n            if (characterCode == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            characterCode = exponentDifference + 0x31;\n          }\n        }\nLAB_080085a4:\n        outputCharPtr = loopPtr + 1;\n        *loopPtr = (char)characterCode;\n        goto LAB_08008274;\n      }\n      outputCharPtr = loopPtr + 1;\n      if (0 < comparisonResult) {\n        if (characterCode == 0x39) goto LAB_08008752;\n        *loopPtr = (char)exponentDifference + '1';\n        goto LAB_08008274;\n      }\n      *loopPtr = (char)characterCode;\n      if (outputPtr + (printedDigits - 1) != loopPtr) {\n        temp = __multadd(floatValue,temp,10,0);\n        loopPtr = outputCharPtr;\n        if (tens == powerOfFive) {\n          tens = __multadd(floatValue,tens,10,0);\n          powerOfFive = tens;\n        }\n        else {\n          tens = __multadd(floatValue,tens,10,0);\n          powerOfFive = __multadd(floatValue,powerOfFive,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        characterCode = quorem(temp,shiftResult);\n        characterCode = characterCode + 0x30;\n        outputCharPtr = loopPtr + 1;\n        *loopPtr = (char)characterCode;\n        if ((int)printedDigits <= (int)outputCharPtr - (int)outputPtr) break;\n        temp = __multadd(floatValue,temp,10,0);\n        loopPtr = outputCharPtr;\n      }\n      tens = 0;\n    }\n    temp = __lshift(floatValue,temp,1);\n    exponentDifference = __mcmp(temp,shiftResult);\n    character = outputCharPtr[-1];\n    if ((0 < exponentDifference) || ((exponentDifference == 0 && (characterCode << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        loopPtr = outputCharPtr + -1;\n        if (character != '9') goto code_r0x08008270;\n        if (outputPtr == loopPtr) {\n          *outputPtr = '1';\n          exp = exp + 1;\n          goto LAB_08008274;\n        }\n        character = outputCharPtr[-2];\n        outputCharPtr = loopPtr;\n      } while( true );\n    }\n    while (character == '0') {\n      character = outputCharPtr[-2];\n      outputCharPtr = outputCharPtr + -1;\n    }\nLAB_08008274:\n    _Bfree(floatValue,shiftResult);\n    if (powerOfFive == 0) goto LAB_08008294;\n    if ((tens != 0) && (tens != powerOfFive)) {\n      _Bfree(floatValue);\n    }\n  }\n  _Bfree(floatValue,powerOfFive);\nLAB_08008294:\n  _Bfree(floatValue,temp);\n  *outputCharPtr = '\\0';\n  *digits = exp + 1;\n  if (outputString == (char **)0x0) {\n    return outputPtr;\n  }\n  *outputString = outputCharPtr;\n  return outputPtr;\ncode_r0x08008270:\n  *loopPtr = character + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "convert_float_to_string_080079e8",
                "param_1": "floatValue",
                "param_2": "param1",
                "param_3": "integerPart",
                "param_4": "sign",
                "param_5": "precision",
                "param_6": "scale",
                "param_7": "digits",
                "param_8": "isNegative",
                "param_9": "outputString",
                "bVar1": "isInfinity",
                "bVar2": "isLessThanZero",
                "bVar3": "addExtraZero",
                "cVar4": "character",
                "bVar5": "isZero",
                "uVar6": "temp",
                "iVar7": "shiftAmount",
                "iVar8": "comparisonResult",
                "iVar9": "multiplicationResult",
                "uVar11": "temp1",
                "uVar12": "temp2",
                "uVar13": "temp3",
                "uVar16": "temp4",
                "uVar17": "temp5",
                "uVar18": "temp6",
                "uVar23": "temp7",
                "uVar26": "result",
                "uVar27": "multiplicationTemp",
                "uVar28": "comparisonTemp",
                "local_80": "tens",
                "local_7c": "absScale",
                "local_74": "exp",
                "local_70": "fractionPartLength",
                "local_68": "printedDigits",
                "local_60": "integerPartLength",
                "local_5c": "fractionPartOffset",
                "local_58": "exponentOffset",
                "local_48": "tensCount",
                "local_38": "scaleForFraction",
                "local_34": "exponent",
                "local_30": "digitCount",
                "local_2c": "scaleAndPrecision",
                "iVar14": "shiftResult",
                "iVar15": "exponentDifference",
                "iVar19": "powerOfFive",
                "iVar24": "characterCode",
                "bVar25": "isNegativeOutput",
                "pcVar10": "outputPtr",
                "pcVar20": "loopPtr",
                "pcVar21": "outputCharPtr"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_dcmpgt",
                "__multiply",
                "__aeabi_dcmpge",
                "__d2b",
                "quorem",
                "__hi0bits",
                "__aeabi_dcmpeq",
                "__aeabi_dadd",
                "__multadd",
                "__i2b",
                "__floatunsidf",
                "memcpy",
                "__aeabi_dcmplt",
                "__subdf3",
                "__aeabi_i2d",
                "__lshift",
                "__mdiff",
                "__muldf3",
                "__aeabi_d2iz",
                "_Bfree",
                "_Balloc",
                "__mcmp",
                "__pow5mult",
                "__divdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008818": {
            "entrypoint": "0x08008818",
            "current_name": "execute_global_destructors_08008818",
            "code": "\nvoid execute_global_destructors_08008818(void)\n\n{\n  int loop_count;\n  code **function_pointers;\n  \n  loop_count = 1;\n  function_pointers = (code **)&global_destructor_array_entry;\n  do {\n    loop_count = loop_count + -1;\n    (**function_pointers)();\n    function_pointers = function_pointers + -1;\n  } while (loop_count != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008818": "execute_global_destructors_08008818",
                "iVar1": "loop_count",
                "ppcVar2": "function_pointers",
                "__do_global_dtors_aux_fini_array_entry": "global_destructor_array_entry"
            },
            "calling": [],
            "called": [
                "_fini",
                "__do_global_dtors_aux",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "deallocate_memory_0800884c",
            "code": "\nundefined4 deallocate_memory_0800884c(undefined4 lock_param,int size_param)\n\n{\n  int sbrk_result;\n  int aligned_address;\n  uint malloc_info;\n  \n  lock_memory_allocation();\n  malloc_info = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  aligned_address = ((0xfef - size_param) + malloc_info & 0xfffff000) - 0x1000;\n  if (0xfff < aligned_address) {\n    sbrk_result = _sbrk_r(lock_param,0);\n    if (sbrk_result == DAT_20000454 + malloc_info) {\n      sbrk_result = _sbrk_r(lock_param,-aligned_address);\n      if (sbrk_result != -1) {\n        current_malloc_info = current_malloc_info - aligned_address;\n        *(uint *)(DAT_20000454 + 4) = malloc_info - aligned_address | 1;\n        unlock_memory_allocation(lock_param);\n        return 1;\n      }\n      aligned_address = _sbrk_r(lock_param,0);\n      if (0xf < aligned_address - DAT_20000454) {\n        current_malloc_info = aligned_address - __malloc_sbrk_base;\n        *(uint *)(DAT_20000454 + 4) = aligned_address - DAT_20000454 | 1;\n      }\n    }\n  }\n  unlock_memory_allocation(lock_param);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "deallocate_memory_0800884c",
                "param_1": "lock_param",
                "param_2": "size_param",
                "iVar1": "sbrk_result",
                "iVar2": "aligned_address",
                "uVar3": "malloc_info",
                "__malloc_lock()": "lock_memory_allocation()",
                "__malloc_current_mallinfo": "current_malloc_info",
                "__malloc_unlock(param_1)": "unlock_memory_allocation(lock_param)"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "deallocate_memory_chunk_080088ec",
            "code": "\nvoid deallocateMemoryChunk_080088ec(undefined4 param_lock,int chunk_ptr,undefined4 param_tail,undefined4 param_pad)\n\n{\n  int index;\n  uint *prev_chunk;\n  uint *curr_chunk;\n  undefined *search_ptr;\n  uint chunk_size;\n  uint next_chunk_size;\n  undefined *prev_chunk_ptr;\n  undefined *next_chunk_ptr;\n  undefined4 *prev_used_chunk_ptr;\n  int chunk_divided;\n  uint malloc_flag;\n  uint next_chunk_size_flag;\n  \n  if (chunk_ptr == 0) {\n    return;\n  }\n  __malloc_lock();\n  malloc_flag = *(uint *)(chunk_ptr + -4);\n  prev_chunk = (uint *)(chunk_ptr + -8);\n  chunk_size = malloc_flag & 0xfffffffe;\n  curr_chunk = (uint *)((int)prev_chunk + chunk_size);\n  next_chunk_size = curr_chunk[1] & 0xfffffffc;\n  if (DAT_20000454 == curr_chunk) {\n    chunk_size = chunk_size + next_chunk_size;\n    if ((malloc_flag & 1) == 0) {\n      prev_chunk = (uint *)((int)prev_chunk - *(int *)(chunk_ptr + -8));\n      next_chunk_size = prev_chunk[2];\n      malloc_flag = prev_chunk[3];\n      chunk_size = chunk_size + *(int *)(chunk_ptr + -8);\n      *(uint *)(next_chunk_size + 0xc) = malloc_flag;\n      *(uint *)(malloc_flag + 8) = next_chunk_size;\n    }\n    next_chunk_size = __malloc_trim_threshold;\n    prev_chunk[1] = chunk_size | 1;\n    DAT_20000454 = prev_chunk;\n    if (next_chunk_size <= chunk_size) {\n      _malloc_trim_r(param_lock,__malloc_top_pad);\n    }\nLAB_080089f0:\n    __malloc_unlock(param_lock);\n    return;\n  }\n  curr_chunk[1] = next_chunk_size;\n  if ((malloc_flag & 1) == 0) {\n    prev_chunk = (uint *)((int)prev_chunk - *(int *)(chunk_ptr + -8));\n    prev_used_chunk_ptr = (undefined4 *)prev_chunk[2];\n    chunk_size = chunk_size + *(int *)(chunk_ptr + -8);\n    malloc_flag = *(uint *)((int)curr_chunk + next_chunk_size + 4) & 1;\n    if ((uint **)prev_used_chunk_ptr == &DAT_20000454) {\n      if (malloc_flag == 0) {\n        malloc_flag = curr_chunk[2];\n        next_chunk_size_flag = curr_chunk[3];\n        chunk_size = chunk_size + next_chunk_size;\n        *(uint *)(malloc_flag + 0xc) = next_chunk_size_flag;\n        *(uint *)(next_chunk_size_flag + 8) = malloc_flag;\n        prev_chunk[1] = chunk_size | 1;\n        *(uint *)((int)prev_chunk + chunk_size) = chunk_size;\n      }\n      else {\n        prev_chunk[1] = chunk_size | 1;\n        *curr_chunk = chunk_size;\n      }\n      goto LAB_080089f0;\n    }\n    next_chunk_size_flag = prev_chunk[3];\n    prev_used_chunk_ptr[3] = next_chunk_size_flag;\n    *(undefined4 **)(next_chunk_size_flag + 8) = prev_used_chunk_ptr;\n  }\n  else {\n    malloc_flag = *(uint *)((int)curr_chunk + next_chunk_size + 4) & 1;\n  }\n  if (malloc_flag == 0) {\n    prev_used_chunk_ptr = (undefined4 *)curr_chunk[2];\n    chunk_size = chunk_size + next_chunk_size;\n    if ((uint **)prev_used_chunk_ptr == &DAT_20000454) {\n      DAT_2000045c = prev_chunk;\n      DAT_20000460 = prev_chunk;\n      prev_chunk[2] = (uint)&DAT_20000454;\n      prev_chunk[3] = (uint)&DAT_20000454;\n      prev_chunk[1] = chunk_size | 1;\n      *(uint *)((int)prev_chunk + chunk_size) = chunk_size;\n      goto LAB_080089f0;\n    }\n    next_chunk_size = curr_chunk[3];\n    prev_used_chunk_ptr[3] = next_chunk_size;\n    *(undefined4 **)(next_chunk_size + 8) = prev_used_chunk_ptr;\n    prev_chunk[1] = chunk_size | 1;\n    *(uint *)((int)prev_chunk + chunk_size) = chunk_size;\n  }\n  else {\n    prev_chunk[1] = chunk_size | 1;\n    *(uint *)((int)prev_chunk + chunk_size) = chunk_size;\n  }\n  if (chunk_size < 0x200) {\n    chunk_divided = (chunk_size >> 3) + 1;\n    chunk_size = 1 << ((int)(chunk_size >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    next_chunk_size = *(uint *)(&__malloc_av_ + chunk_divided * 8);\n    prev_chunk[2] = next_chunk_size;\n    prev_chunk[3] = (uint)(&DAT_20000444 + chunk_divided * 8);\n    DAT_20000450 = (undefined *)chunk_size;\n    *(uint **)(&__malloc_av_ + chunk_divided * 8) = prev_chunk;\n    *(uint **)(next_chunk_size + 0xc) = prev_chunk;\n    __malloc_unlock(param_lock,prev_chunk,chunk_size,param_pad);\n    return;\n  }\n  next_chunk_size = chunk_size >> 9;\n  if (next_chunk_size < 5) {\n    chunk_divided = ((chunk_size >> 6) + 0x39) * 8;\n    index = (chunk_size >> 6) + 0x38;\n  }\n  else if (next_chunk_size < 0x15) {\n    chunk_divided = (next_chunk_size + 0x5c) * 8;\n    index = next_chunk_size + 0x5b;\n  }\n  else if (next_chunk_size < 0x55) {\n    chunk_divided = ((chunk_size >> 0xc) + 0x6f) * 8;\n    index = (chunk_size >> 0xc) + 0x6e;\n  }\n  else if (next_chunk_size < 0x155) {\n    chunk_divided = ((chunk_size >> 0xf) + 0x78) * 8;\n    index = (chunk_size >> 0xf) + 0x77;\n  }\n  else if (next_chunk_size < 0x555) {\n    chunk_divided = ((chunk_size >> 0x12) + 0x7d) * 8;\n    index = (chunk_size >> 0x12) + 0x7c;\n  }\n  else {\n    chunk_divided = 0x3f8;\n    index = 0x7e;\n  }\n  search_ptr = *(undefined **)(&__malloc_av_ + chunk_divided);\n  prev_chunk_ptr = &DAT_20000444 + chunk_divided;\n  if (prev_chunk_ptr == search_ptr) {\n    search_ptr = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    next_chunk_ptr = prev_chunk_ptr;\n    DAT_20000450 = search_ptr;\n  }\n  else {\n    do {\n      next_chunk_ptr = search_ptr;\n      if ((*(uint *)(search_ptr + 4) & 0xfffffffc) <= chunk_size) break;\n      search_ptr = *(undefined **)(search_ptr + 8);\n      next_chunk_ptr = prev_chunk_ptr;\n    } while (prev_chunk_ptr != search_ptr);\n    prev_chunk_ptr = *(undefined **)(next_chunk_ptr + 0xc);\n  }\n  prev_chunk[2] = (uint)next_chunk_ptr;\n  prev_chunk[3] = (uint)prev_chunk_ptr;\n  *(uint **)(prev_chunk_ptr + 8) = prev_chunk;\n  *(uint **)(next_chunk_ptr + 0xc) = prev_chunk;\n  __malloc_unlock(param_lock,prev_chunk,search_ptr,param_pad);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "deallocate_memory_chunk_080088ec",
                "param_1": "param_lock",
                "param_2": "chunk_ptr",
                "param_3": "param_tail",
                "param_4": "param_pad",
                "iVar1": "index",
                "puVar2": "prev_chunk",
                "puVar3": "curr_chunk",
                "puVar4": "search_ptr",
                "uVar5": "chunk_size",
                "uVar6": "next_chunk_size",
                "puVar7": "prev_chunk_ptr",
                "puVar8": "next_chunk_ptr",
                "puVar9": "prev_used_chunk_ptr",
                "iVar10": "chunk_divided",
                "uVar11": "malloc_flag",
                "uVar12": "next_chunk_size_flag"
            },
            "calling": [
                "__ssprint_r",
                "_svfprintf_r",
                "_malloc_r",
                "_realloc_r"
            ],
            "called": [
                "__malloc_unlock",
                "_malloc_trim_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_locale_ptr_08008ad4",
            "code": "\nundefined1 * get_locale_ptr_08008ad4(void)\n\n{\n  undefined1 *locale_ptr;\n  \n  locale_ptr = *(undefined1 **)(impure_ptr + 0x34);\n  if (locale_ptr == (undefined1 *)0x0) {\n    locale_ptr = &global_locale;\n  }\n  return locale_ptr + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_locale_ptr_08008ad4",
                "puVar1": "locale_ptr",
                "_impure_ptr": "impure_ptr",
                "__global_locale": "global_locale"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocateMemory_08008af8(undefined4 *param_base,uint size)\n\n{\n  undefined1 *ptr1;\n  undefined1 *ptr2;\n  uint var3;\n  uint var4;\n  int var5;\n  undefined *ptr6;\n  uint var7;\n  uint var8;\n  undefined4 *ptr9;\n  undefined1 *ptr10;\n  undefined *ptr11;\n  int *result;\n  uint var13;\n  uint var14;\n  int var15;\n  undefined4 *ptr16;\n  undefined1 *ptr17;\n  undefined4 *ptr18;\n  \n  var13 = size + 0xb;\n  if (var13 < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    __malloc_lock();\n    var14 = 0x10;\n    var5 = 0x18;\n    var13 = 2;\nLAB_08008b18:\n    ptr11 = *(undefined **)((int)&DAT_20000450 + var5);\n    if ((ptr11 != &DAT_20000444 + var5) ||\n       (ptr11 = *(undefined **)((int)&DAT_20000458 + var5), &__malloc_av_ + var5 != ptr11)) {\n      var5 = *(int *)(ptr11 + 0xc);\n      ptr6 = ptr11 + (*(uint *)(ptr11 + 4) & 0xfffffffc);\n      var13 = *(uint *)(ptr6 + 4);\nLAB_08008b34:\n      var15 = *(int *)(ptr11 + 8);\n      *(int *)(var15 + 0xc) = var5;\n      *(int *)(var5 + 8) = var15;\n      *(uint *)(ptr6 + 4) = var13 | 1;\n      __malloc_unlock(param_base);\n      return (int *)(ptr11 + 8);\n    }\n    var13 = var13 + 2;\n  }\n  else {\n    var14 = var13 & 0xfffffff8;\n    if (((int)var14 < 0) || (var14 < size)) {\nLAB_08008c7a:\n      *param_base = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_lock();\n    if (var14 < 0x1f8) {\n      var13 = var13 >> 3;\n      var5 = var14 + 8;\n      goto LAB_08008b18;\n    }\n    var3 = var13 >> 9;\n    if (var3 == 0) {\n      var5 = 0x200;\n      var7 = 0x40;\n      var3 = 0x3f;\n    }\n    else if (var3 < 5) {\n      var7 = (var13 >> 6) + 0x39;\n      var3 = (var13 >> 6) + 0x38;\n      var5 = var7 * 8;\n    }\n    else if (var3 < 0x15) {\n      var7 = var3 + 0x5c;\n      var3 = var3 + 0x5b;\n      var5 = var7 * 8;\n    }\n    else if (var3 < 0x55) {\n      var7 = (var13 >> 0xc) + 0x6f;\n      var3 = (var13 >> 0xc) + 0x6e;\n      var5 = var7 * 8;\n    }\n    else if (var3 < 0x155) {\n      var7 = (var13 >> 0xf) + 0x78;\n      var3 = (var13 >> 0xf) + 0x77;\n      var5 = var7 * 8;\n    }\n    else if (var3 < 0x555) {\n      var7 = (var13 >> 0x12) + 0x7d;\n      var3 = (var13 >> 0x12) + 0x7c;\n      var5 = var7 * 8;\n    }\n    else {\n      var5 = 0x3f8;\n      var7 = 0x7f;\n      var3 = 0x7e;\n    }\n    for (ptr11 = *(undefined **)((int)&DAT_20000450 + var5); var13 = var7,\n        &DAT_20000444 + var5 != ptr11; ptr11 = *(undefined **)(ptr11 + 0xc)) {\n      var15 = (*(uint *)(ptr11 + 4) & 0xfffffffc) - var14;\n      var13 = var3;\n      if (0xf < var15) break;\n      if (-1 < var15) {\n        ptr6 = ptr11 + (*(uint *)(ptr11 + 4) & 0xfffffffc);\n        var13 = *(uint *)(ptr6 + 4);\n        var5 = *(int *)(ptr11 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  ptr16 = DAT_2000045c;\n  if ((undefined1 **)DAT_2000045c == &DAT_20000454) {\n    var7 = 1 << ((int)var13 >> 2 & 0xffU);\n    var3 = DAT_20000450;\n    if (var7 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    var7 = DAT_2000045c[1];\n    var8 = var7 & 0xfffffffc;\n    var3 = var8 - var14;\n    if (0xf < (int)var3) {\n      ptr18 = (undefined4 *)(var14 + (int)DAT_2000045c);\n      DAT_2000045c[1] = var14 | 1;\n      DAT_2000045c = ptr18;\n      DAT_20000460 = ptr18;\n      ptr18[2] = &DAT_20000454;\n      ptr18[3] = &DAT_20000454;\n      ptr18[1] = var3 | 1;\n      *(uint *)((int)ptr16 + var8) = var3;\n      __malloc_unlock(param_base);\n      return ptr16 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)var3) {\n      *(uint *)((int)ptr16 + var8 + 4) = *(uint *)((int)ptr16 + var8 + 4) | 1;\n      __malloc_unlock(param_base);\n      return ptr16 + 2;\n    }\n    if (var8 < 0x200) {\n      var5 = (var7 >> 3) + 1;\n      var15 = *(int *)(&__malloc_av_ + var5 * 8);\n      var3 = 1 << ((int)(var7 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      ptr16[2] = var15;\n      ptr16[3] = &DAT_20000444 + var5 * 8;\n      DAT_20000450 = var3;\n      *(undefined4 **)(&__malloc_av_ + var5 * 8) = ptr16;\n      *(undefined4 **)(var15 + 0xc) = ptr16;\n    }\n    else {\n      var3 = var7 >> 9;\n      if (var3 < 5) {\n        var5 = ((var7 >> 6) + 0x39) * 8;\n        var15 = (var7 >> 6) + 0x38;\n      }\n      else if (var3 < 0x15) {\n        var5 = (var3 + 0x5c) * 8;\n        var15 = var3 + 0x5b;\n      }\n      else if (var3 < 0x55) {\n        var5 = ((var7 >> 0xc) + 0x6f) * 8;\n        var15 = (var7 >> 0xc) + 0x6e;\n      }\n      else if (var3 < 0x155) {\n        var5 = ((var7 >> 0xf) + 0x78) * 8;\n        var15 = (var7 >> 0xf) + 0x77;\n      }\n      else if (var3 < 0x555) {\n        var5 = ((var7 >> 0x12) + 0x7d) * 8;\n        var15 = (var7 >> 0x12) + 0x7c;\n      }\n      else {\n        var5 = 0x3f8;\n        var15 = 0x7e;\n      }\n      ptr11 = *(undefined **)(&__malloc_av_ + var5);\n      ptr6 = &DAT_20000444 + var5;\n      if (ptr6 == ptr11) {\n        DAT_20000450 = 1 << (var15 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr11 + 4) & 0xfffffffc) <= var8) break;\n          ptr11 = *(undefined **)(ptr11 + 8);\n        } while (ptr6 != ptr11);\n        ptr6 = *(undefined **)(ptr11 + 0xc);\n      }\n      var3 = DAT_20000450;\n      ptr16[2] = ptr11;\n      ptr16[3] = ptr6;\n      *(undefined4 **)(ptr6 + 8) = ptr16;\n      *(undefined4 **)(ptr11 + 0xc) = ptr16;\n    }\n    var7 = 1 << ((int)var13 >> 2 & 0xffU);\n    if (var7 <= var3) {\nLAB_08008c06:\n      if ((var7 & var3) == 0) {\n        var13 = var13 & 0xfffffffc;\n        do {\n          var7 = var7 << 1;\n          var13 = var13 + 4;\n        } while ((var7 & var3) == 0);\n      }\n      do {\n        ptr18 = (undefined4 *)(&__malloc_av_ + var13 * 8);\n        var3 = var13;\n        ptr16 = ptr18;\n        do {\n          for (ptr9 = (undefined4 *)ptr16[3]; ptr16 != ptr9;\n              ptr9 = (undefined4 *)ptr9[3]) {\n            var8 = ptr9[1] & 0xfffffffc;\n            var4 = var8 - var14;\n            if (0xf < (int)var4) {\n              var15 = ptr9[2];\n              var5 = ptr9[3];\n              ptr16 = (undefined4 *)(var14 + (int)ptr9);\n              ptr9[1] = var14 | 1;\n              *(int *)(var15 + 0xc) = var5;\n              *(int *)(var5 + 8) = var15;\n              DAT_2000045c = ptr16;\n              DAT_20000460 = ptr16;\n              ptr16[2] = &DAT_20000454;\n              ptr16[3] = &DAT_20000454;\n              ptr16[1] = var4 | 1;\n              *(uint *)((int)ptr9 + var8) = var4;\n              __malloc_unlock(param_base);\n              return ptr9 + 2;\n            }\n            if (-1 < (int)var4) {\n              var5 = ptr9[3];\n              var15 = ptr9[2];\n              *(uint *)((int)ptr9 + var8 + 4) = *(uint *)((int)ptr9 + var8 + 4) | 1;\n              *(int *)(var15 + 0xc) = var5;\n              *(int *)(var5 + 8) = var15;\n              __malloc_unlock(param_base);\n              return ptr9 + 2;\n            }\n          }\n          var3 = var3 + 1;\n          ptr16 = ptr16 + 2;\n        } while ((var3 & 3) != 0);\n        do {\n          var8 = var13 & 3;\n          ptr16 = ptr18 + -2;\n          var13 = var13 - 1;\n          if (var8 == 0) {\n            DAT_20000450 = DAT_20000450 & ~var7;\n            break;\n          }\n          ptr18 = (undefined4 *)*ptr18;\n        } while (ptr18 == ptr16);\n        var7 = var7 * 2;\n        if ((DAT_20000450 <= var7 && var7 - DAT_20000450 != 0) || (var13 = var3, var7 == 0))\n        break;\n        for (; (var7 & DAT_20000450) == 0; var7 = var7 << 1) {\n          var13 = var13 + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr17 = DAT_20000454;\n  var13 = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((var14 <= var13) && (var3 = var13 - var14, 0xf < (int)var3)) goto LAB_08008dac;\n  if (__malloc_sbrk_base == (undefined1 *)0xffffffff) {\n    var3 = var14 + __malloc_top_pad + 0x10;\n  }\n  else {\n    var3 = var14 + __malloc_top_pad + 0x100f & 0xfffff000;\n  }\n  ptr1 = (undefined1 *)_sbrk_r(param_base,var3);\n  if (ptr1 == (undefined1 *)0xffffffff) {\nLAB_08008ed8:\n    var13 = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    ptr2 = ptr17 + var13;\n    if (ptr2 < ptr1 || ptr2 == ptr1) {\n      ptr10 = __malloc_current_mallinfo + var3;\n      if ((ptr2 != ptr1) || (((uint)ptr2 & 0xfff) != 0)) goto LAB_08008d02;\n      __malloc_current_mallinfo = ptr10;\n      *(uint *)(DAT_20000454 + 4) = var13 + var3 | 1;\n    }\n    else {\n      if (ptr17 != &__malloc_av_) goto LAB_08008ed8;\nLAB_08008d02:\n      __malloc_current_mallinfo = __malloc_current_mallinfo + var3;\n      ptr10 = ptr1;\n      if (__malloc_sbrk_base != (undefined1 *)0xffffffff) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo + ((int)ptr1 - (int)ptr2);\n        ptr10 = __malloc_sbrk_base;\n      }\n      __malloc_sbrk_base = ptr10;\n      var7 = (uint)ptr1 & 7;\n      if (var7 == 0) {\n        var5 = 0x1000;\n      }\n      else {\n        ptr1 = ptr1 + (8 - var7);\n        var5 = 0x1008 - var7;\n      }\n      var5 = var5 - ((uint)(ptr1 + var3) & 0xfff);\n      var15 = _sbrk_r(param_base,var5);\n      if (var15 == -1) {\n        var3 = 1;\n        var5 = 0;\n      }\n      else {\n        var3 = (var15 - (int)ptr1) + var5 | 1;\n      }\n      ptr10 = __malloc_current_mallinfo + var5;\n      DAT_20000454 = ptr1;\n      __malloc_current_mallinfo = ptr10;\n      *(uint *)(ptr1 + 4) = var3;\n      if (ptr17 != &__malloc_av_) {\n        if (var13 < 0x10) {\n          *(undefined4 *)(ptr1 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        var13 = var13 - 0xc & 0xfffffff8;\n        *(uint *)(ptr17 + 4) = *(uint *)(ptr17 + 4) & 1 | var13;\n        *(undefined4 *)(ptr17 + var13 + 4) = 5;\n        *(undefined4 *)(ptr17 + var13 + 8) = 5;\n        if (0xf < var13) {\n          _free_r(param_base,ptr17 + 8);\n          ptr10 = __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem < ptr10) {\n      __malloc_max_sbrked_mem = ptr10;\n    }\n    var13 = *(uint *)(DAT_20000454 + 4);\n    if (__malloc_max_total_mem < ptr10) {\n      __malloc_max_total_mem = ptr10;\n    }\n  }\n  var3 = (var13 & 0xfffffffc) - var14;\n  if ((var14 <= (var13 & 0xfffffffc)) && (0xf < (int)var3)) {\nLAB_08008dac:\n    ptr17 = DAT_20000454 + var14;\n    *(uint *)(DAT_20000454 + 4) = var14 | 1;\n    result = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = ptr17;\n    *(uint *)(ptr17 + 4) = var3 | 1;\n    __malloc_unlock(param_base);\n    return result;\n  }\nLAB_08008eee:\n  __malloc_unlock(param_base);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "param_base",
                "param_2": "size",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "uVar3": "var3",
                "uVar4": "var4",
                "iVar5": "var5",
                "puVar6": "ptr6",
                "uVar7": "var7",
                "uVar8": "var8",
                "puVar9": "ptr9",
                "puVar10": "ptr10",
                "puVar11": "ptr11",
                "piVar12": "result",
                "uVar13": "var13",
                "uVar14": "var14",
                "iVar15": "var15",
                "puVar16": "ptr16",
                "puVar17": "ptr17",
                "puVar18": "ptr18"
            },
            "calling": [
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r",
                "_calloc_r"
            ],
            "called": [
                "_free_r",
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_character_in_string_0800901c",
            "code": "\nvoid * find_character_in_string_0800901c(void *string_ptr,int character,size_t string_length)\n\n{\n  uint xor_result;\n  uint combined_character;\n  uint *current_ptr;\n  uint character_mask;\n  bool reached_end;\n  \n  character_mask = character & 0xff;\n  if (((uint)string_ptr & 3) == 0) {\nLAB_0800904a:\n    if (3 < string_length) {\n      combined_character = (character & 0xffU) << 8 | character_mask;\n      current_ptr = (uint *)string_ptr;\n      do {\n        xor_result = *current_ptr ^ (combined_character | combined_character << 0x10);\n        string_ptr = current_ptr + 1;\n        if ((xor_result + 0xfefefeff & ~xor_result & 0x80808080) != 0) goto LAB_08009050;\n        string_length = string_length - 4;\n        current_ptr = (uint *)string_ptr;\n      } while (3 < string_length);\n    }\n    current_ptr = (uint *)string_ptr;\n    if (string_length == 0) {\n      string_ptr = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      string_ptr = current_ptr;\n                    /* WARNING: Load size is inaccurate */\n      if (*string_ptr != character_mask) {\n        current_ptr = (uint *)(string_length + (int)string_ptr);\n        do {\n          string_ptr = (void *)((int)string_ptr + 1);\n          if (current_ptr == (uint *)string_ptr) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n        } while (*string_ptr != character_mask);\n      }\n    }\n  }\n  else {\n    combined_character = string_length - 1;\n    if (string_length == 0) {\nLAB_0800906c:\n      string_ptr = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*string_ptr != character_mask) {\n        current_ptr = (uint *)((int)string_ptr + 1);\n        do {\n          string_ptr = current_ptr;\n          string_length = combined_character;\n          if (((uint)string_ptr & 3) == 0) goto LAB_0800904a;\n          reached_end = combined_character == 0;\n          combined_character = combined_character - 1;\n          if (reached_end) goto LAB_0800906c;\n                    /* WARNING: Load size is inaccurate */\n          current_ptr = (uint *)((int)string_ptr + 1);\n        } while (*string_ptr != character_mask);\n      }\n    }\n  }\n  return string_ptr;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_character_in_string_0800901c",
                "__s": "string_ptr",
                "__c": "character",
                "__n": "string_length",
                "uVar1": "xor_result",
                "uVar2": "combined_character",
                "puVar3": "current_ptr",
                "uVar4": "character_mask",
                "bVar5": "reached_end"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "acquire_malloc_recursive_mutex_080090a8",
            "code": "\nvoid acquireMallocRecursiveMutex_080090a8(void)\n\n{\n  acquireRecursiveLock(&mallocRecursiveMutex);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "acquire_malloc_recursive_mutex_080090a8",
                "__retarget_lock_acquire_recursive": "acquireRecursiveLock",
                "__lock___malloc_recursive_mutex": "mallocRecursiveMutex"
            },
            "calling": [
                "_malloc_r",
                "_free_r",
                "_malloc_trim_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "release_malloc_recursive_lock_080090b4",
            "code": "\nvoid releaseMallocRecursiveLock_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(&mallocRecursiveLock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "release_malloc_recursive_lock_080090b4",
                "__lock___malloc_recursive_mutex": "mallocRecursiveLock"
            },
            "calling": [
                "_malloc_r",
                "_free_r",
                "_malloc_trim_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_or_retrieve_data_080090c0",
            "code": "\nundefined4 * allocate_or_retrieve_data_080090c0(int data_container,uint index)\n\n{\n  undefined4 *data_ptr;\n  int data_array;\n  \n  data_array = *(int *)(data_container + 0x4c);\n  if (data_array == 0) {\n    data_array = allocate_memory(data_container,4,0x21);\n    *(int *)(data_container + 0x4c) = data_array;\n    if (data_array == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  data_ptr = *(undefined4 **)(data_array + index * 4);\n  if (data_ptr == (undefined4 *)0x0) {\n    data_array = 1 << (index & 0xff);\n    data_ptr = (undefined4 *)allocate_memory(data_container,1,(data_array + 5) * 4);\n    if (data_ptr == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    data_ptr[1] = index;\n    data_ptr[2] = data_array;\n  }\n  else {\n    *(undefined4 *)(data_array + index * 4) = *data_ptr;\n  }\n  data_ptr[3] = 0;\n  data_ptr[4] = 0;\n  return data_ptr;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_or_retrieve_data_080090c0",
                "param_1": "data_container",
                "param_2": "index",
                "puVar1": "data_ptr",
                "iVar2": "data_array",
                "_calloc_r": "allocate_memory"
            },
            "calling": [
                "__multiply",
                "__lshift",
                "_dtoa_r",
                "__d2b",
                "__mdiff",
                "__multadd",
                "__i2b",
                "__pow5mult"
            ],
            "called": [
                "_calloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "update_data_0800910c",
            "code": "\nvoid updateData_0800910c(int dataPtr,undefined4 *updatedValuePtr)\n\n{\n  int dataArrayPtr;\n  \n  if (updatedValuePtr != (undefined4 *)0x0) {\n    dataArrayPtr = *(int *)(dataPtr + 0x4c);\n    *updatedValuePtr = *(undefined4 *)(dataArrayPtr + updatedValuePtr[1] * 4);\n    *(undefined4 **)(dataArrayPtr + updatedValuePtr[1] * 4) = updatedValuePtr;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "update_data_0800910c",
                "param_1": "dataPtr",
                "param_2": "updatedValuePtr",
                "iVar1": "dataArrayPtr"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "calculate_checksum_08009120",
            "code": "\nundefined4 * calculateChecksum_08009120(int size,undefined4 *data,int multiplier,uint checksum)\n\n{\n  undefined4 *result;\n  uint temp;\n  int length;\n  uint *ptr;\n  int index;\n  \n  index = 0;\n  length = data[4];\n  ptr = data + 5;\n  do {\n    index = index + 1;\n    checksum = multiplier * (*ptr & 0xffff) + checksum;\n    temp = multiplier * (*ptr >> 0x10) + (checksum >> 0x10);\n    *ptr = (checksum & 0xffff) + temp * 0x10000;\n    checksum = temp >> 0x10;\n    ptr = ptr + 1;\n  } while (index < length);\n  result = data;\n  if (checksum != 0) {\n    if ((int)data[2] <= length) {\n      result = (undefined4 *)_Balloc(size,data[1] + 1);\n      memcpy(result + 3,data + 3,(data[4] + 2) * 4);\n      index = *(int *)(size + 0x4c);\n      *data = *(undefined4 *)(index + data[1] * 4);\n      *(undefined4 **)(index + data[1] * 4) = data;\n    }\n    result[length + 5] = checksum;\n    result[4] = length + 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009120": "calculate_checksum_08009120",
                "param_1": "size",
                "param_2": "data",
                "param_3": "multiplier",
                "param_4": "checksum",
                "puVar1": "result",
                "uVar2": "temp",
                "iVar3": "length",
                "puVar4": "ptr",
                "iVar5": "index"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "memcpy",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "find_highest_bit_position_080091a4",
            "code": "\nint find_highest_bit_position_080091a4(uint value)\n\n{\n  int bit_position;\n  \n  if ((value & 0xffff0000) == 0) {\n    value = value << 0x10;\n    bit_position = 0x10;\n  }\n  else {\n    bit_position = 0;\n  }\n  if ((value & 0xff000000) == 0) {\n    value = value << 8;\n    bit_position = bit_position + 8;\n  }\n  if ((value & 0xf0000000) == 0) {\n    value = value << 4;\n    bit_position = bit_position + 4;\n  }\n  if ((value & 0xc0000000) == 0) {\n    value = value << 2;\n    bit_position = bit_position + 2;\n  }\n  if (-1 < (int)value) {\n    if ((int)(value << 1) < 0) {\n      return bit_position + 1;\n    }\n    bit_position = 0x20;\n  }\n  return bit_position;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "find_highest_bit_position_080091a4",
                "param_1": "value",
                "iVar1": "bit_position"
            },
            "calling": [
                "_dtoa_r",
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_leading_zeros_080091e4",
            "code": "\nint countLeadingZeros_080091e4(uint *input)\n\n{\n  int leadingZerosCount;\n  uint value;\n  \n  value = *input;\n  if ((value & 7) == 0) {\n    if ((value & 0xffff) == 0) {\n      value = value >> 0x10;\n      leadingZerosCount = 0x10;\n    }\n    else {\n      leadingZerosCount = 0;\n    }\n    if ((value & 0xff) == 0) {\n      value = value >> 8;\n      leadingZerosCount = leadingZerosCount + 8;\n    }\n    if ((value & 0xf) == 0) {\n      value = value >> 4;\n      leadingZerosCount = leadingZerosCount + 4;\n    }\n    if ((value & 3) == 0) {\n      value = value >> 2;\n      leadingZerosCount = leadingZerosCount + 2;\n    }\n    if (-1 < (int)(value << 0x1f)) {\n      value = value >> 1;\n      if (value == 0) {\n        return 0x20;\n      }\n      leadingZerosCount = leadingZerosCount + 1;\n    }\n    *input = value;\n    return leadingZerosCount;\n  }\n  if ((int)(value << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(value << 0x1e)) {\n    *input = value >> 2;\n    return 2;\n  }\n  *input = value >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "input",
                "iVar1": "leadingZerosCount",
                "uVar2": "value"
            },
            "calling": [
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_dynamic_memory_08009244",
            "code": "\nvoid initializeDynamicMemory_08009244(undefined4 size,undefined4 value)\n\n{\n  int allocatedMemory;\n  \n  allocatedMemory = _Balloc(size,1);\n  *(undefined4 *)(allocatedMemory + 0x10) = 1;\n  *(undefined4 *)(allocatedMemory + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_dynamic_memory_08009244",
                "param_1": "size",
                "param_2": "value",
                "iVar1": "allocatedMemory"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "calculate_product_08009258",
            "code": "\nvoid calculateProduct_08009258(undefined4 output,int input1,int input2)\n\n{\n  uint *currentOutput;\n  uint *currentInput;\n  int outputLength;\n  uint intermediateProduct;\n  uint *input1Array;\n  uint input1ArrayStart;\n  uint *input2Array;\n  uint uVar8;\n  int input1ArrayLength;\n  int input2Array;\n  uint input1ArrayEnd;\n  int input1ArrayStart;\n  int input1Array;\n  uint *currentOutput4;\n  uint *currentOutput5;\n  uint *currentInput2;\n  uint *currentOutput2;\n  uint *outputArray;\n  \n  input1ArrayStart = *(int *)(input1 + 0x10);\n  input1ArrayLength = *(int *)(input2 + 0x10);\n  input2Array = input1ArrayLength;\n  input1Array = input1;\n  if (input1ArrayStart < input1ArrayLength) {\n    input2Array = input1ArrayStart;\n    input1ArrayStart = input1ArrayLength;\n    input1Array = input2;\n    input2 = input1;\n  }\n  input1ArrayLength = input1ArrayStart + input2Array;\n  outputLength = *(int *)(input1Array + 4);\n  if (*(int *)(input1Array + 8) < input1ArrayLength) {\n    outputLength = outputLength + 1;\n  }\n  outputLength = _Balloc(output,outputLength);\n  outputArray = (uint *)(outputLength + 0x14);\n  currentOutput2 = outputArray + input1ArrayLength;\n  for (input1Array = outputArray; input1Array < currentOutput2; input1Array = input1Array + 1) {\n    *input1Array = 0;\n  }\n  input1ArrayStart = input2 + 0x14;\n  input1ArrayEnd = input1ArrayStart + input2Array * 4;\n  input1Array = (uint *)(input1Array + 0x14);\n  if (input1ArrayStart < input1ArrayEnd) {\n    input2Array = (uint *)(input1ArrayStart + ((input1ArrayEnd - input2) - 0x15 & 0xfffffffc));\n    currentInput2 = (uint *)(input2 + 0x10);\n    do {\n      while( true ) {\n        currentInput2 = currentInput2 + 1;\n        input1ArrayStart = *currentInput2 & 0xffff;\n        if (input1ArrayStart != 0) break;\n        input1ArrayStart = *currentInput2 >> 0x10;\n        if (input1ArrayStart == 0) goto LAB_080092d2;\nLAB_0800932c:\n        uVar8 = *outputArray;\n        intermediateProduct = 0;\n        currentOutput = input1Array;\n        currentOutput4 = outputArray;\n        input1ArrayEnd = uVar8;\n        do {\n          currentOutput5 = currentOutput4;\n          intermediateProduct = intermediateProduct + input1ArrayStart * *(ushort *)currentOutput + (input1ArrayEnd >> 0x10);\n          *currentOutput5 = uVar8 & 0xffff | intermediateProduct * 0x10000;\n          currentInput = currentOutput + 1;\n          input1ArrayEnd = currentOutput5[1];\n          uVar8 = input1ArrayStart * (*currentOutput >> 0x10) + (input1ArrayEnd & 0xffff) + (intermediateProduct >> 0x10);\n          intermediateProduct = uVar8 >> 0x10;\n          currentOutput = currentInput;\n          currentOutput4 = currentOutput5 + 1;\n        } while (currentInput < input1Array + input1ArrayStart);\n        currentOutput5[1] = uVar8;\n        outputArray = outputArray + 1;\n        if (input2Array == currentInput2) goto LAB_0800937a;\n      }\n      input1ArrayEnd = 0;\n      currentOutput = outputArray;\n      currentOutput4 = input1Array;\n      do {\n        currentInput = currentOutput;\n        currentOutput5 = currentOutput4 + 1;\n        uVar8 = input1ArrayStart * (*currentOutput4 & 0xffff) + (*currentInput & 0xffff) + input1ArrayEnd;\n        intermediateProduct = input1ArrayStart * (*currentOutput4 >> 0x10) + (*currentInput >> 0x10) + (uVar8 >> 0x10);\n        input1ArrayEnd = intermediateProduct >> 0x10;\n        *currentInput = uVar8 & 0xffff | intermediateProduct * 0x10000;\n        currentOutput = currentInput + 1;\n        currentOutput4 = currentOutput5;\n      } while (currentOutput5 < input1Array + input1ArrayStart);\n      currentInput[1] = input1ArrayEnd;\n      input1ArrayStart = *currentInput2 >> 0x10;\n      if (input1ArrayStart != 0) goto LAB_0800932c;\nLAB_080092d2:\n      outputArray = outputArray + 1;\n    } while (input2Array != currentInput2);\n  }\nLAB_0800937a:\n  if (0 < input1ArrayLength) {\n    input1ArrayStart = currentOutput2[-1];\n    currentOutput2 = currentOutput2 + -1;\n    while ((input1ArrayStart == 0 && (input1ArrayLength = input1ArrayLength + -1, input1ArrayLength != 0))) {\n      currentOutput2 = currentOutput2 + -1;\n      input1ArrayStart = *currentOutput2;\n    }\n  }\n  *(int *)(outputLength + 0x10) = input1ArrayLength;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "calculate_product_08009258",
                "param_1": "output",
                "param_2": "input1",
                "param_3": "input2",
                "puVar1": "currentOutput",
                "puVar2": "currentInput",
                "iVar3": "outputLength",
                "uVar4": "intermediateProduct",
                "puVar5": "input1Array",
                "uVar6": "input1ArrayStart",
                "puVar7": "input2Array",
                "puVar16": "currentInput2",
                "puVar17": "currentOutput2",
                "puVar18": "outputArray",
                "iVar9": "input1ArrayLength",
                "iVar10": "input2Array",
                "uVar11": "input1ArrayEnd",
                "iVar12": "input1ArrayStart",
                "iVar13": "input1Array"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "perform_calculation_080093a4",
            "code": "\nundefined4 * performCalculation_080093a4(int input,undefined4 *result,uint size)\n\n{\n  int tempVar1;\n  int tempVar2;\n  undefined4 *tempPointer1;\n  undefined4 *tempPointer2;\n  \n  if ((size & 3) != 0) {\n    result = (undefined4 *)\n              __multadd(input,result,*(undefined4 *)(&p05_6092 + ((size & 3) - 1) * 4),0);\n  }\n  tempVar2 = (int)size >> 2;\n  if (tempVar2 != 0) {\n    tempPointer2 = *(undefined4 **)(input + 0x48);\n    if (tempPointer2 == (undefined4 *)0x0) {\n      tempPointer2 = (undefined4 *)_Balloc(input,1);\n      tempPointer2[4] = 1;\n      tempPointer2[5] = 0x271;\n      *(undefined4 **)(input + 0x48) = tempPointer2;\n      *tempPointer2 = 0;\n    }\n    tempPointer1 = result;\n    if (tempVar2 << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    tempVar2 = tempVar2 >> 1;\n    tempPointer1 = tempPointer2;\n    if (tempVar2 != 0) {\n      while( true ) {\n        tempPointer2 = (undefined4 *)*tempPointer1;\n        if (tempPointer2 == (undefined4 *)0x0) {\n          tempPointer2 = (undefined4 *)__multiply(input,tempPointer1,tempPointer1);\n          *tempPointer1 = tempPointer2;\n          *tempPointer2 = 0;\n        }\n        tempPointer1 = result;\n        if (-1 < tempVar2 << 0x1f) break;\nLAB_080093d2:\n        result = (undefined4 *)__multiply(input,tempPointer1,tempPointer2);\n        if (tempPointer1 == (undefined4 *)0x0) break;\n        tempVar1 = *(int *)(input + 0x4c);\n        tempVar2 = tempVar2 >> 1;\n        *tempPointer1 = *(undefined4 *)(tempVar1 + tempPointer1[1] * 4);\n        *(undefined4 **)(tempVar1 + tempPointer1[1] * 4) = tempPointer1;\n        tempPointer1 = tempPointer2;\n        if (tempVar2 == 0) {\n          return result;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "perform_calculation_080093a4",
                "param_1": "input",
                "param_2": "result",
                "param_3": "size",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "puVar3": "tempPointer1",
                "puVar4": "tempPointer2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__multiply",
                "__multadd",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "reverse_and_allocate_08009444",
            "code": "\nvoid reverseAndAllocate_08009444(int size,undefined4 *data,uint bitOffset)\n\n{\n  int temp1;\n  int temp2;\n  int temp3;\n  undefined4 temp4;\n  int offset;\n  int temp6;\n  uint *dest;\n  uint *src;\n  uint *srcPtr1;\n  uint *destPtr2;\n  int num32BitWords;\n  int adjustedWords;\n  uint carry;\n  uint *destPtr1;\n  \n  offset = data[4];\n  num32BitWords = (int)bitOffset >> 5;\n  adjustedWords = num32BitWords + offset + 1;\n  temp3 = data[1];\n  temp2 = data[2];\n  if ((int)data[2] < adjustedWords) {\n    do {\n      temp6 = temp2 * 2;\n      temp1 = temp2 * -2;\n      temp3 = temp3 + 1;\n      temp2 = temp6;\n    } while (adjustedWords != temp6 && adjustedWords + temp1 < 0 == SBORROW4(adjustedWords,temp6));\n  }\n  temp2 = _Balloc(size,temp3);\n  dest = (uint *)(temp2 + 0x14);\n  if (0 < num32BitWords) {\n    destPtr2 = dest + num32BitWords;\n    src = dest;\n    do {\n      destPtr1 = src + 1;\n      *src = 0;\n      dest = destPtr2;\n      src = destPtr1;\n    } while (destPtr1 != destPtr2);\n  }\n  temp3 = data[4];\n  src = data + 5;\n  bitOffset = bitOffset & 0x1f;\n  if (bitOffset == 0) {\n    dest = dest + -1;\n    destPtr2 = src;\n    do {\n      destPtr1 = destPtr2 + 1;\n      dest = dest + 1;\n      *dest = *destPtr2;\n      destPtr2 = destPtr1;\n    } while (destPtr1 < src + temp3);\n  }\n  else {\n    carry = 0;\n    destPtr2 = src;\n    do {\n      destPtr1 = dest;\n      *destPtr1 = *destPtr2 << bitOffset | carry;\n      srcPtr1 = destPtr2 + 1;\n      carry = *destPtr2 >> (0x20 - bitOffset & 0xff);\n      dest = destPtr1 + 1;\n      destPtr2 = srcPtr1;\n    } while (srcPtr1 < src + temp3);\n    destPtr1[1] = carry;\n    if (carry != 0) {\n      adjustedWords = num32BitWords + offset + 2;\n    }\n  }\n  offset = *(int *)(size + 0x4c);\n  temp3 = data[1];\n  temp4 = *(undefined4 *)(offset + temp3 * 4);\n  *(int *)(temp2 + 0x10) = adjustedWords + -1;\n  *data = temp4;\n  *(undefined4 **)(offset + temp3 * 4) = data;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "reverse_and_allocate_08009444",
                "param_1": "size",
                "param_2": "data",
                "param_3": "bitOffset",
                "iVar1": "temp1",
                "iVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "offset",
                "iVar6": "temp6",
                "puVar7": "dest",
                "puVar8": "src",
                "puVar9": "destPtr1",
                "puVar10": "srcPtr1",
                "puVar11": "destPtr2",
                "iVar12": "num32BitWords",
                "iVar13": "adjustedWords",
                "uVar14": "carry"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compare_arrays_080094f8(int array1_address,int array2_address)\n\n{\n  int size_difference;\n  uint *array2_element;\n  int array2_size;\n  uint *array1_element;\n  \n  array2_size = *(int *)(array2_address + 0x10);\n  size_difference = *(int *)(array1_address + 0x10) - array2_size;\n  if (size_difference == 0) {\n    array2_element = (uint *)(array2_address + 0x14 + array2_size * 4);\n    array1_element = (uint *)(array1_address + 0x14) + array2_size;\n    do {\n      array1_element = array1_element + -1;\n      array2_element = array2_element + -1;\n      if (*array1_element != *array2_element) {\n        if (*array2_element <= *array1_element) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1_address + 0x14) < array1_element);\n  }\n  return size_difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1_address",
                "param_2": "array2_address",
                "iVar1": "size_difference",
                "iVar3": "array2_size",
                "puVar2": "array2_element",
                "puVar4": "array1_element"
            },
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "calculate_checksum_08009530",
            "code": "\nvoid calculateChecksum_08009530(undefined4 input,uint *sourceData,uint *destinationData,undefined4 config)\n\n{\n  int allocationSize;\n  uint *sourceDataPtr;\n  uint sourceDataSize;\n  uint tempVar;\n  undefined4 flag;\n  uint *checksumPtr;\n  uint *sourceDataPtrTemp;\n  uint *sourceDataPtrStart;\n  uint *destinationDataPtrStart;\n  uint *sourceDataPtrEnd;\n  int carry;\n  uint *destinationDataPtrTemp;\n  uint destinationDataSize;\n  uint *destinationDataPtr;\n  \n  sourceDataPtr = (uint *)destinationData[4];\n  sourceDataPtrEnd = sourceData + 5;\n  destinationDataPtrTemp = destinationData + 5;\n  sourceDataPtrTemp = sourceDataPtrEnd;\n  sourceDataPtrStart = sourceData;\n  if ((uint *)sourceData[4] == sourceDataPtr) {\n    checksumPtr = sourceDataPtrEnd + (int)sourceDataPtr;\n    sourceDataPtr = destinationDataPtrTemp + (int)sourceDataPtr;\n    while( true ) {\n      checksumPtr = checksumPtr + -1;\n      sourceDataPtr = sourceDataPtr + -1;\n      if (*checksumPtr != *sourceDataPtr) break;\n      if (checksumPtr <= sourceDataPtrEnd) {\n        carry = _Balloc(input,0,checksumPtr,sourceDataPtr,config);\n        *(undefined4 *)(carry + 0x10) = 1;\n        *(undefined4 *)(carry + 0x14) = 0;\n        return;\n      }\n    }\n    flag = 0;\n    if (*sourceDataPtr <= *checksumPtr) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)sourceData[4] - (int)sourceDataPtr) {\n    flag = 0;\n    checksumPtr = destinationData;\n    goto LAB_08009578;\n  }\n  flag = 1;\n  checksumPtr = sourceDataPtrEnd;\n  sourceDataPtr = sourceData;\n  sourceDataPtrTemp = destinationDataPtrTemp;\n  sourceDataPtrStart = destinationData;\n  destinationData = sourceData;\n  destinationDataPtrTemp = sourceDataPtrEnd;\nLAB_08009578:\n  allocationSize = _Balloc(input,sourceDataPtrStart[1],checksumPtr,sourceDataPtr,config);\n  carry = 0;\n  destinationDataSize = sourceDataPtrStart[4];\n  sourceDataSize = destinationData[4];\n  *(undefined4 *)(allocationSize + 0xc) = flag;\n  sourceDataPtrEnd = sourceDataPtrTemp + destinationDataSize;\n  sourceDataPtr = (uint *)(allocationSize + 0x14);\n  sourceDataPtrStart = destinationDataPtrTemp;\n  do {\n    destinationDataPtr = sourceDataPtrTemp + 1;\n    destinationDataPtrStart = sourceDataPtrStart + 1;\n    tempVar = ((*sourceDataPtrTemp & 0xffff) + carry) - (*sourceDataPtrStart & 0xffff);\n    carry = ((*sourceDataPtrTemp >> 0x10) - (*sourceDataPtrStart >> 0x10)) + ((int)tempVar >> 0x10);\n    tempVar = tempVar & 0xffff | carry * 0x10000;\n    checksumPtr = sourceDataPtr + 1;\n    *sourceDataPtr = tempVar;\n    carry = carry >> 0x10;\n    sourceDataPtr = checksumPtr;\n    sourceDataPtrTemp = destinationDataPtr;\n    sourceDataPtrStart = destinationDataPtrStart;\n  } while (destinationDataPtrStart < destinationDataPtrTemp + sourceDataSize);\n  sourceDataPtr = destinationDataPtr;\n  sourceDataPtrTemp = checksumPtr;\n  if (destinationDataPtr < sourceDataPtrEnd) {\n    do {\n      sourceDataPtrStart = sourceDataPtr + 1;\n      sourceDataSize = (*sourceDataPtr & 0xffff) + carry;\n      carry = ((int)sourceDataSize >> 0x10) + (*sourceDataPtr >> 0x10);\n      tempVar = sourceDataSize & 0xffff | carry * 0x10000;\n      *sourceDataPtrTemp = tempVar;\n      carry = carry >> 0x10;\n      sourceDataPtr = sourceDataPtrStart;\n      sourceDataPtrTemp = sourceDataPtrTemp + 1;\n    } while (sourceDataPtrStart < sourceDataPtrEnd);\n    checksumPtr = (uint *)((int)checksumPtr + ((int)sourceDataPtrEnd + ~(uint)destinationDataPtr & 0xfffffffc) + 4);\n  }\n  checksumPtr = checksumPtr + -1;\n  while (tempVar == 0) {\n    checksumPtr = checksumPtr + -1;\n    destinationDataSize = destinationDataSize - 1;\n    tempVar = *checksumPtr;\n  }\n  *(uint *)(allocationSize + 0x10) = destinationDataSize;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "calculate_checksum_08009530",
                "param_1": "input",
                "param_2": "sourceData",
                "param_3": "destinationData",
                "param_4": "config",
                "iVar1": "allocationSize",
                "puVar2": "sourceDataPtr",
                "uVar3": "sourceDataSize",
                "uVar4": "tempVar",
                "uVar5": "flag",
                "puVar6": "checksumPtr",
                "puVar7": "sourceDataPtrTemp",
                "puVar8": "destinationDataPtr",
                "puVar9": "sourceDataPtrStart",
                "puVar10": "destinationDataPtrStart",
                "puVar11": "sourceDataPtrEnd",
                "iVar12": "carry",
                "puVar13": "destinationDataPtrTemp",
                "uVar14": "destinationDataSize"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "extract_bits_08009630",
            "code": "\nint extractBits_08009630(undefined4 param1,undefined4 param2,uint param3,uint param4,int *output1,\n                int *output2)\n\n{\n  int result;\n  uint bitsShifted;\n  int lowBits;\n  int var1;\n  uint shiftedValue;\n  uint shiftCount;\n  undefined8 highBits;\n  uint tempValue1;\n  uint tempValue2;\n  \n  result = _Balloc(param1,1);\n  shiftCount = (param4 << 1) >> 0x15;\n  tempValue2 = param4 & 0xfffff;\n  if (shiftCount != 0) {\n    tempValue2 = tempValue2 | 0x100000;\n  }\n  if (param3 == 0) {\n    lowBits = __lo0bits(&tempValue2);\n    var1 = 1;\n    bitsShifted = lowBits + 0x20;\n    *(undefined4 *)(result + 0x10) = 1;\n    *(uint *)(result + 0x14) = tempValue2;\n  }\n  else {\n    tempValue1 = param3;\n    bitsShifted = __lo0bits(&tempValue1);\n    if (bitsShifted == 0) {\n      *(uint *)(result + 0x14) = tempValue1;\n    }\n    else {\n      shiftedValue = tempValue2 << (0x20 - bitsShifted & 0xff);\n      tempValue2 = tempValue2 >> (bitsShifted & 0xff);\n      *(uint *)(result + 0x14) = shiftedValue | tempValue1;\n    }\n    if (tempValue2 == 0) {\n      var1 = 1;\n    }\n    else {\n      var1 = 2;\n    }\n    *(uint *)(result + 0x18) = tempValue2;\n    *(int *)(result + 0x10) = var1;\n  }\n  if (shiftCount == 0) {\n    *output1 = bitsShifted - 0x432;\n    highBits = __hi0bits(*(undefined4 *)(result + var1 * 4 + 0x10));\n    *output2 = (int)((ulonglong)highBits >> 0x20) * 0x20 - (int)highBits;\n    return result;\n  }\n  *output1 = (shiftCount - 0x433) + bitsShifted;\n  *output2 = 0x35 - bitsShifted;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009630": "extract_bits_08009630",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "output1",
                "param_6": "output2",
                "iVar1": "result",
                "uVar2": "bitsShifted",
                "iVar3": "lowBits",
                "iVar4": "var1",
                "uVar5": "shiftedValue",
                "uVar6": "shiftCount",
                "uVar7": "highBits",
                "local_20": "tempValue1",
                "local_1c": "tempValue2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__hi0bits",
                "__lo0bits",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_exponential_080096e0",
            "code": "\ndouble calculateExponential_080096e0(double input,int *exponent)\n\n{\n  uint inputBits;\n  uint extraBits;\n  int *output;\n  int shiftAmount;\n  uint absInputBits;\n  double result;\n  \n  shiftAmount = 0;\n  absInputBits = inputBits & 0x7fffffff;\n  *output = 0;\n  if ((absInputBits < 0x7ff00000) && ((absInputBits | (uint)exponent) != 0)) {\n    if (absInputBits < 0x100000) {\n      result = (double)__muldf3(exponent,inputBits,0,0x43500000);\n      shiftAmount = -0x36;\n      absInputBits = extraBits & 0x7fffffff;\n    }\n    *output = ((int)absInputBits >> 0x14) + -0x3fe + shiftAmount;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_exponential_080096e0",
                "__x": "input",
                "__exponent": "exponent",
                "in_r1": "inputBits",
                "extraout_r1": "extraBits",
                "in_r2": "output",
                "iVar1": "shiftAmount",
                "uVar2": "absInputBits",
                "in_d0": "result"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__muldf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "allocate_memory_08009744",
            "code": "\nvoid allocateMemory_08009744(int *error,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *error = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "allocate_memory_08009744",
                "param_1": "error",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_string_08009768",
            "code": "\nchar * copy_string_08009768(char *destination,char *source,size_t length)\n\n{\n  char current_char;\n  uint *source_ptr;\n  uint *destination_ptr;\n  uint *temp_ptr;\n  uint current_uint;\n  \n  destination_ptr = (uint *)destination;\n  if (((((uint)destination | (uint)source) & 3) == 0) && (source_ptr = (uint *)source, 3 < length)) {\n    do {\n      source = (char *)(source_ptr + 1);\n      current_uint = *source_ptr;\n      if ((current_uint + 0xfefefeff & ~current_uint & 0x80808080) != 0) goto LAB_0800979c;\n      length = length - 4;\n      source_ptr = destination_ptr + 1;\n      *destination_ptr = current_uint;\n      destination_ptr = source_ptr;\n      source_ptr = (uint *)source;\n    } while (3 < length);\n  }\n  source_ptr = (uint *)source;\n  if (length != 0) {\nLAB_0800979c:\n    current_char = *(char *)source_ptr;\n    *(char *)destination_ptr = current_char;\n    while( true ) {\n      destination_ptr = (uint *)((int)destination_ptr + 1);\n      length = length - 1;\n      if (current_char == '\\0') break;\n      if (length == 0) {\n        return destination;\n      }\n      source_ptr = (uint *)((int)source_ptr + 1);\n      current_char = *(char *)source_ptr;\n      *(char *)destination_ptr = current_char;\n    }\n    if (length != 0) {\n      source_ptr = destination_ptr;\n      do {\n        temp_ptr = (uint *)((int)source_ptr + 1);\n        *(char *)source_ptr = '\\0';\n        source_ptr = temp_ptr;\n      } while (temp_ptr != (uint *)(length + (int)destination_ptr));\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_string_08009768",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "cVar1": "current_char",
                "puVar2": "source_ptr",
                "puVar3": "destination_ptr",
                "puVar4": "temp_ptr",
                "uVar5": "current_uint"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "copy_and_modify_data_080097cc",
            "code": "\nundefined4 copyAndModifyData_080097cc(undefined4 *errorCode,void **inputArray,int *dataArray)\n\n{\n  void *sourcePtr;\n  void *sizePtr;\n  int remainingSize;\n  void *totalSize;\n  void *copySize;\n  void **currentDataPtr;\n  void **nextDataPtr;\n  void *sourceData;\n  size_t bytesToCopy;\n  \n  if (dataArray[2] != 0) {\n    sourcePtr = *inputArray;\n    totalSize = inputArray[2];\n    nextDataPtr = (void **)*dataArray;\n    do {\n      do {\n        currentDataPtr = nextDataPtr + 2;\n        sourceData = *nextDataPtr;\n        copySize = nextDataPtr[1];\n        nextDataPtr = currentDataPtr;\n      } while (copySize == (void *)0x0);\n      sizePtr = copySize;\n      if ((totalSize <= copySize) && (sizePtr = totalSize, (*(ushort *)(inputArray + 3) & 0x480) != 0)) {\n        bytesToCopy = (int)sourcePtr - (int)inputArray[4];\n        totalSize = (void *)(((int)inputArray[5] * 3) / 2);\n        sourcePtr = (void *)((int)copySize + bytesToCopy + 1);\n        if (totalSize < sourcePtr) {\n          totalSize = sourcePtr;\n        }\n        if ((int)((uint)*(ushort *)(inputArray + 3) << 0x15) < 0) {\n          sizePtr = (void *)_malloc_r(errorCode,totalSize);\n          if (sizePtr == (void *)0x0) {\nLAB_08009896:\n            *errorCode = 0xc;\n            *(ushort *)(inputArray + 3) = *(ushort *)(inputArray + 3) | 0x40;\n            dataArray[1] = 0;\n            dataArray[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(sizePtr,inputArray[4],bytesToCopy);\n          *(ushort *)(inputArray + 3) = *(ushort *)(inputArray + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          sizePtr = (void *)_realloc_r(errorCode);\n          if (sizePtr == (void *)0x0) {\n            _free_r(errorCode,inputArray[4]);\n            goto LAB_08009896;\n          }\n        }\n        sourcePtr = (void *)((int)sizePtr + bytesToCopy);\n        inputArray[5] = totalSize;\n        inputArray[4] = sizePtr;\n        *inputArray = sourcePtr;\n        inputArray[2] = (void *)((int)totalSize - bytesToCopy);\n        sizePtr = copySize;\n      }\n      memmove(sourcePtr,sourceData,(size_t)sizePtr);\n      remainingSize = dataArray[2];\n      totalSize = (void *)((int)inputArray[2] - (int)sizePtr);\n      sourcePtr = (void *)((int)*inputArray + (int)sizePtr);\n      inputArray[2] = totalSize;\n      *inputArray = sourcePtr;\n      dataArray[2] = remainingSize - (int)copySize;\n    } while (remainingSize - (int)copySize != 0);\n  }\n  dataArray[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "copy_and_modify_data_080097cc",
                "param_1": "errorCode",
                "param_2": "inputArray",
                "param_3": "dataArray",
                "pvVar1": "sourcePtr",
                "pvVar2": "sizePtr",
                "iVar3": "remainingSize",
                "pvVar4": "totalSize",
                "pvVar5": "copySize",
                "ppvVar6": "currentDataPtr",
                "ppvVar7": "nextDataPtr",
                "__src": "sourceData",
                "__n": "bytesToCopy"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "memcpy",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "register_function_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 registerFunction_080098c0(int actionType,undefined4 functionPointer,undefined4 parameter1,undefined4 parameter2)\n\n{\n  undefined *registerDataPtr;\n  undefined4 returnValue;\n  uint bitMask;\n  uint registerIndex;\n  \n  __retarget_lock_acquire_recursive(__atexit_recursive_mutex);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  registerDataPtr = DAT_20000168;\n  registerIndex = *(uint *)(DAT_20000168 + 4);\n  if ((int)registerIndex < 0x20) {\n    if (actionType != 0) {\n      *(undefined4 *)(DAT_20000168 + registerIndex * 4 + 0x88) = parameter1;\n      bitMask = 1 << (registerIndex & 0xff);\n      *(uint *)(registerDataPtr + 0x188) = *(uint *)(registerDataPtr + 0x188) | bitMask;\n      *(undefined4 *)(registerDataPtr + registerIndex * 4 + 0x108) = parameter2;\n      if (actionType == 2) {\n        *(uint *)(registerDataPtr + 0x18c) = bitMask | *(uint *)(registerDataPtr + 0x18c);\n      }\n    }\n    *(uint *)(registerDataPtr + 4) = registerIndex + 1;\n    returnValue = __atexit_recursive_mutex;\n    *(undefined4 *)(registerDataPtr + (registerIndex + 2) * 4) = functionPointer;\n    __retarget_lock_release_recursive(returnValue);\n    returnValue = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(__atexit_recursive_mutex);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "register_function_080098c0",
                "param_1": "actionType",
                "param_2": "functionPointer",
                "param_3": "parameter1",
                "param_4": "parameter2",
                "puVar1": "registerDataPtr",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "registerIndex"
            },
            "calling": [
                "atexit"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_and_initialize_memory_08009980",
            "code": "\nundefined4 * allocate_and_initialize_memory_08009980(undefined4 size,int element_size,int num_elements)\n\n{\n  undefined4 *memory;\n  size_t size_allocated;\n  undefined4 *ptr;\n  \n  memory = (undefined4 *)_malloc_r(size,num_elements * element_size);\n  if (memory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  size_allocated = (memory[-1] & 0xfffffffc) - 4;\n  if (size_allocated < 0x25) {\n    ptr = memory;\n    if (0x13 < size_allocated) {\n      *memory = 0;\n      memory[1] = 0;\n      if (0x1b < size_allocated) {\n        memory[2] = 0;\n        memory[3] = 0;\n        if (size_allocated == 0x24) {\n          memory[4] = 0;\n          memory[5] = 0;\n          ptr = memory + 6;\n        }\n        else {\n          ptr = memory + 4;\n        }\n        *ptr = 0;\n        ptr[1] = 0;\n        ptr[2] = 0;\n        return memory;\n      }\n      ptr = memory + 2;\n    }\n    *ptr = 0;\n    ptr[1] = 0;\n    ptr[2] = 0;\n    return memory;\n  }\n  memset(memory,0,size_allocated);\n  return memory;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_and_initialize_memory_08009980",
                "param_1": "size",
                "param_2": "element_size",
                "param_3": "num_elements",
                "__s": "memory",
                "__n": "size_allocated",
                "puVar1": "ptr"
            },
            "calling": [
                "_Balloc"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080099ec": {
            "entrypoint": "0x080099ec",
            "current_name": "extract_uint_from_byte_080099ec",
            "code": "\nuint extract_uint_from_byte_080099ec(undefined4 param,uint *uint_ptr,byte *byte_ptr,int size)\n\n{\n  uint result;\n  uint default_uint;\n  \n  if (uint_ptr == (uint *)0x0) {\n    uint_ptr = &default_uint;\n  }\n  if (byte_ptr == (byte *)0x0) {\n    return 0;\n  }\n  if (size == 0) {\n    result = 0xfffffffe;\n  }\n  else {\n    *uint_ptr = (uint)*byte_ptr;\n    result = (uint)*byte_ptr;\n    if (result != 0) {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080099ec": "extract_uint_from_byte_080099ec",
                "param_1": "param",
                "param_2": "uint_ptr",
                "param_3": "byte_ptr",
                "param_4": "size",
                "uVar1": "result",
                "uStack_4": "default_uint"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "reverse_memcpy_08009a18",
            "code": "\nvoid * reverse_memcpy_08009a18(void *destination,void *source,size_t length)\n\n{\n  undefined4 *dest_ptr;\n  undefined *src_ptr;\n  int src_offset;\n  void *dest_offset;\n  undefined *dest_end;\n  int temp_var1;\n  uint temp_var2;\n  int temp_var3;\n  uint remaining_length;\n  undefined4 *src_end;\n  \n  if ((source < destination) && (src_ptr = (undefined *)((int)source + length), destination < src_ptr)) {\n    dest_end = (undefined *)((int)destination + length);\n    if (length != 0) {\n      do {\n        src_ptr = src_ptr + -1;\n        dest_end = dest_end + -1;\n        *dest_end = *src_ptr;\n      } while ((undefined *)source != src_ptr);\n    }\n  }\n  else {\n    remaining_length = length;\n    dest_offset = destination;\n    if (0xf < length) {\n      if ((((uint)destination | (uint)source) & 3) != 0) goto LAB_08009abc;\n      src_offset = (int)source + 0x10;\n      temp_var3 = (int)destination + 0x10;\n      do {\n        temp_var1 = src_offset + 0x10;\n        *(undefined4 *)(temp_var3 + -0x10) = *(undefined4 *)(src_offset + -0x10);\n        *(undefined4 *)(temp_var3 + -0xc) = *(undefined4 *)(src_offset + -0xc);\n        *(undefined4 *)(temp_var3 + -8) = *(undefined4 *)(src_offset + -8);\n        *(undefined4 *)(temp_var3 + -4) = *(undefined4 *)(src_offset + -4);\n        src_offset = temp_var1;\n        temp_var3 = temp_var3 + 0x10;\n      } while (temp_var1 != (int)source + (length - 0x10 & 0xfffffff0) + 0x20);\n      remaining_length = length & 0xf;\n      src_offset = ((length - 0x10 >> 4) + 1) * 0x10;\n      source = (void *)((int)source + src_offset);\n      dest_offset = (void *)(src_offset + (int)destination);\n      if (3 < remaining_length) {\n        src_end = (undefined4 *)((int)dest_offset + -4);\n        temp_var2 = remaining_length;\n        dest_ptr = (undefined4 *)source;\n        do {\n          temp_var2 = temp_var2 - 4;\n          src_end = src_end + 1;\n          *src_end = *dest_ptr;\n          dest_ptr = dest_ptr + 1;\n        } while (3 < temp_var2);\n        src_offset = (remaining_length - 4 & 0xfffffffc) + 4;\n        source = (void *)((int)source + src_offset);\n        remaining_length = length & 3;\n        dest_offset = (void *)((int)dest_offset + src_offset);\n      }\n    }\n    length = remaining_length;\n    if (remaining_length != 0) {\nLAB_08009abc:\n      src_ptr = (undefined *)((int)dest_offset + -1);\n      src_end = (undefined4 *)source;\n      do {\n        dest_ptr = (undefined4 *)((int)src_end + 1);\n        src_ptr = src_ptr + 1;\n        *src_ptr = *(undefined *)src_end;\n        src_end = dest_ptr;\n      } while (dest_ptr != (undefined4 *)(length + (int)source));\n      return destination;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "reverse_memcpy_08009a18",
                "__dest": "destination",
                "__src": "source",
                "__n": "length",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr",
                "iVar3": "src_offset",
                "pvVar4": "dest_offset",
                "puVar5": "dest_end",
                "iVar6": "temp_var1",
                "uVar7": "temp_var2",
                "iVar8": "temp_var3",
                "uVar9": "remaining_length",
                "puVar10": "src_end"
            },
            "calling": [
                "__ssprint_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocate_memory_08009adc(undefined4 *allocator,int *ptr,uint size)\n\n{\n  int *prev_chunk;\n  int curr_chunk;\n  int *new_chunk;\n  uint chunk_size;\n  int temp;\n  uint curr_chunk_size;\n  size_t copy_size;\n  int *copy_dest;\n  uint adjusted_size;\n  uint adjusted_chunk_size;\n  uint new_chunk_size;\n  int curr_chunk_end;\n  \n  if (ptr == (int *)0x0) {\n    new_chunk = (int *)_malloc_r(allocator,size);\n    return new_chunk;\n  }\n  __malloc_lock();\n  curr_chunk_size = ptr[-1];\n  adjusted_chunk_size = curr_chunk_size & 0xfffffffc;\n  new_chunk = ptr + -2;\n  if (size + 0xb < 0x17) {\n    adjusted_size = 0x10;\n  }\n  else {\n    adjusted_size = size + 0xb & 0xfffffff8;\n    if ((int)adjusted_size < 0) goto LAB_08009b8e;\n  }\n  if (adjusted_size < size) {\nLAB_08009b8e:\n    *allocator = 0xc;\n    return (int *)0x0;\n  }\n  curr_chunk_end = (int)new_chunk + adjusted_chunk_size;\n  new_chunk_size = adjusted_chunk_size;\n  if ((int)adjusted_chunk_size < (int)adjusted_size) {\n    if (DAT_20000454 == curr_chunk_end) {\n      curr_chunk_end = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + adjusted_chunk_size;\n      if ((int)(adjusted_size + 0x10) <= curr_chunk_end) {\n        DAT_20000454 = (int)new_chunk + adjusted_size;\n        *(uint *)(DAT_20000454 + 4) = curr_chunk_end - adjusted_size | 1;\n        ptr[-1] = adjusted_size | ptr[-1] & 1U;\n        __malloc_unlock(allocator);\n        return ptr;\n      }\n      if (-1 < (int)(curr_chunk_size << 0x1f)) {\n        prev_chunk = (int *)((int)new_chunk - ptr[-2]);\n        curr_chunk_size = prev_chunk[1] & 0xfffffffc;\n        if ((int)(adjusted_size + 0x10) <= (int)(curr_chunk_end + curr_chunk_size)) {\n          temp = prev_chunk[3];\n          new_chunk = prev_chunk + 2;\n          curr_chunk = *new_chunk;\n          copy_size = adjusted_chunk_size - 4;\n          *(int *)(curr_chunk + 0xc) = temp;\n          *(int *)(temp + 8) = curr_chunk;\n          if (copy_size < 0x25) {\n            curr_chunk = *ptr;\n            copy_dest = new_chunk;\n            if (0x13 < copy_size) {\n              prev_chunk[2] = curr_chunk;\n              prev_chunk[3] = ptr[1];\n              curr_chunk = ptr[2];\n              if (copy_size < 0x1c) {\n                ptr = ptr + 2;\n                copy_dest = prev_chunk + 4;\n              }\n              else {\n                prev_chunk[4] = curr_chunk;\n                prev_chunk[5] = ptr[3];\n                curr_chunk = ptr[4];\n                if (copy_size == 0x24) {\n                  prev_chunk[6] = curr_chunk;\n                  prev_chunk[7] = ptr[5];\n                  curr_chunk = ptr[6];\n                  ptr = ptr + 6;\n                  copy_dest = prev_chunk + 8;\n                }\n                else {\n                  ptr = ptr + 4;\n                  copy_dest = prev_chunk + 6;\n                }\n              }\n            }\n            *copy_dest = curr_chunk;\n            copy_dest[1] = ptr[1];\n            copy_dest[2] = ptr[2];\n          }\n          else {\n            memmove(new_chunk,ptr,copy_size);\n          }\n          DAT_20000454 = (int)prev_chunk + adjusted_size;\n          *(uint *)(DAT_20000454 + 4) = (curr_chunk_end + curr_chunk_size) - adjusted_size | 1;\n          prev_chunk[1] = adjusted_size | prev_chunk[1] & 1U;\n          __malloc_unlock(allocator);\n          return new_chunk;\n        }\nLAB_08009bb0:\n        new_chunk_size = adjusted_chunk_size + curr_chunk_size;\n        if ((int)adjusted_size <= (int)new_chunk_size) {\n          temp = prev_chunk[3];\n          copy_dest = prev_chunk + 2;\n          curr_chunk = *copy_dest;\n          *(int *)(curr_chunk + 0xc) = temp;\n          curr_chunk_end = (int)prev_chunk + new_chunk_size;\n          *(int *)(temp + 8) = curr_chunk;\n          new_chunk = prev_chunk;\n          if (adjusted_chunk_size - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(copy_dest,ptr,adjusted_chunk_size - 4);\n          ptr = copy_dest;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(curr_chunk_end + 4) & 0xfffffffe) + curr_chunk_end + 4) << 0x1f) {\n        chunk_size = *(uint *)(curr_chunk_end + 4) & 0xfffffffc;\n        new_chunk_size = adjusted_chunk_size + chunk_size;\n        if ((int)new_chunk_size < (int)adjusted_size) {\n          if ((int)(curr_chunk_size << 0x1f) < 0) goto LAB_08009b36;\n          prev_chunk = (int *)((int)new_chunk - ptr[-2]);\n          curr_chunk_size = prev_chunk[1] & 0xfffffffc;\n          new_chunk_size = chunk_size + curr_chunk_size + adjusted_chunk_size;\n          if ((int)new_chunk_size < (int)adjusted_size) goto LAB_08009bb0;\n          curr_chunk = *(int *)(curr_chunk_end + 8);\n          curr_chunk_end = *(int *)(curr_chunk_end + 0xc);\n          *(int *)(curr_chunk + 0xc) = curr_chunk_end;\n          *(int *)(curr_chunk_end + 8) = curr_chunk;\n          copy_dest = prev_chunk + 2;\n          curr_chunk = *copy_dest;\n          temp = prev_chunk[3];\n          *(int *)(curr_chunk + 0xc) = temp;\n          curr_chunk_end = (int)prev_chunk + new_chunk_size;\n          *(int *)(temp + 8) = curr_chunk;\n          new_chunk = prev_chunk;\n          if (0x24 < adjusted_chunk_size - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          adjusted_chunk_size = adjusted_chunk_size - 4;\n          curr_chunk = *ptr;\n          prev_chunk = copy_dest;\n          if (0x13 < adjusted_chunk_size) {\n            new_chunk[2] = curr_chunk;\n            new_chunk[3] = ptr[1];\n            curr_chunk = ptr[2];\n            if (adjusted_chunk_size < 0x1c) {\n              ptr = ptr + 2;\n              prev_chunk = new_chunk + 4;\n            }\n            else {\n              new_chunk[4] = curr_chunk;\n              new_chunk[5] = ptr[3];\n              curr_chunk = ptr[4];\n              if (adjusted_chunk_size == 0x24) {\n                new_chunk[6] = curr_chunk;\n                new_chunk[7] = ptr[5];\n                curr_chunk = ptr[6];\n                ptr = ptr + 6;\n                prev_chunk = new_chunk + 8;\n              }\n              else {\n                ptr = ptr + 4;\n                prev_chunk = new_chunk + 6;\n              }\n            }\n          }\n          *prev_chunk = curr_chunk;\n          prev_chunk[1] = ptr[1];\n          prev_chunk[2] = ptr[2];\n          ptr = copy_dest;\n        }\n        else {\n          curr_chunk = *(int *)(curr_chunk_end + 8);\n          temp = *(int *)(curr_chunk_end + 0xc);\n          *(int *)(curr_chunk + 0xc) = temp;\n          curr_chunk_end = (int)new_chunk + new_chunk_size;\n          *(int *)(temp + 8) = curr_chunk;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(curr_chunk_size << 0x1f)) {\n        prev_chunk = (int *)((int)new_chunk - ptr[-2]);\n        curr_chunk_size = prev_chunk[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    prev_chunk = (int *)_malloc_r(allocator,size);\n    if (prev_chunk != (int *)0x0) {\n      if ((int *)((ptr[-1] & 0xfffffffeU) + (int)new_chunk) == prev_chunk + -2) {\n        new_chunk_size = adjusted_chunk_size + (prev_chunk[-1] & 0xfffffffcU);\n        curr_chunk_end = (int)new_chunk + new_chunk_size;\n        goto LAB_08009c00;\n      }\n      copy_size = adjusted_chunk_size - 4;\n      if (copy_size < 0x25) {\n        curr_chunk_end = *ptr;\n        new_chunk = ptr;\n        copy_dest = prev_chunk;\n        if (0x13 < copy_size) {\n          *prev_chunk = curr_chunk_end;\n          prev_chunk[1] = ptr[1];\n          if (copy_size < 0x1c) {\n            curr_chunk_end = ptr[2];\n            new_chunk = ptr + 2;\n            copy_dest = prev_chunk + 2;\n          }\n          else {\n            prev_chunk[2] = ptr[2];\n            prev_chunk[3] = ptr[3];\n            if (copy_size == 0x24) {\n              prev_chunk[4] = ptr[4];\n              prev_chunk[5] = ptr[5];\n              curr_chunk_end = ptr[6];\n              new_chunk = ptr + 6;\n              copy_dest = prev_chunk + 6;\n            }\n            else {\n              curr_chunk_end = ptr[4];\n              new_chunk = ptr + 4;\n              copy_dest = prev_chunk + 4;\n            }\n          }\n        }\n        *copy_dest = curr_chunk_end;\n        copy_dest[1] = new_chunk[1];\n        copy_dest[2] = new_chunk[2];\n      }\n      else {\n        memmove(prev_chunk,ptr,copy_size);\n      }\n      _free_r(allocator,ptr);\n    }\n    __malloc_unlock(allocator);\n    ptr = prev_chunk;\n  }\n  else {\nLAB_08009c00:\n    if (new_chunk_size - adjusted_size < 0x10) {\n      new_chunk[1] = new_chunk[1] & 1U | new_chunk_size;\n      *(uint *)(curr_chunk_end + 4) = *(uint *)(curr_chunk_end + 4) | 1;\n    }\n    else {\n      new_chunk[1] = new_chunk[1] & 1U | adjusted_size;\n      *(uint *)((int)new_chunk + adjusted_size + 4) = new_chunk_size - adjusted_size | 1;\n      *(uint *)(curr_chunk_end + 4) = *(uint *)(curr_chunk_end + 4) | 1;\n      _free_r(allocator,(int)new_chunk + adjusted_size + 8);\n    }\n    __malloc_unlock(allocator);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "allocator",
                "param_2": "ptr",
                "param_3": "size",
                "piVar1": "prev_chunk",
                "iVar2": "curr_chunk",
                "piVar3": "new_chunk",
                "uVar4": "chunk_size",
                "iVar5": "temp",
                "uVar6": "curr_chunk_size",
                "uVar9": "adjusted_size",
                "uVar10": "adjusted_chunk_size",
                "uVar11": "new_chunk_size",
                "iVar12": "curr_chunk_end",
                "sVar7": "copy_size",
                "piVar8": "copy_dest"
            },
            "calling": [
                "__ssprint_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "_free_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e50": {
            "entrypoint": "0x08009e50",
            "current_name": "copy_to_buffer_08009e50",
            "code": "\nundefined * copyToBuffer_08009e50(undefined4 *buffer,undefined *destination,uint value)\n\n{\n  if (destination != (undefined *)0x0) {\n    if (value < 0x100) {\n      *destination = (char)value;\n      destination = (undefined *)0x1;\n    }\n    else {\n      destination = (undefined *)0xffffffff;\n      *buffer = 0x8a;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08009e50": "copy_to_buffer_08009e50",
                "param_1": "buffer",
                "param_2": "destination",
                "param_3": "value"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "get_pkey_ctx_handle_08009e68",
            "code": "\nint get_pkey_ctx_handle_08009e68(EVP_PKEY_CTX *pkey_ctx)\n\n{\n  return (int)pkey_ctx;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "get_pkey_ctx_handle_08009e68",
                "ctx": "pkey_ctx"
            },
            "calling": [
                "__do_global_dtors_aux",
                "__libc_init_array",
                "frame_dummy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 170662,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000150",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_0800045c",
            "FUN_0800046c",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008ec",
            "FUN_080008f4",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000a9c",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000c2c",
            "FUN_08000c3c",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f58",
            "FUN_08000f60",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000fe0",
            "FUN_08000ff4",
            "FUN_08001008",
            "FUN_0800101c",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001cb8",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_080035fa",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_08003696",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c4a",
            "FUN_08003c5c",
            "FUN_08003c6e",
            "FUN_08003c80",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_08004366",
            "FUN_08004378",
            "FUN_0800438a",
            "FUN_08004424",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_080056c8",
            "FUN_080056ce",
            "FUN_080056d4",
            "FUN_080056da",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "FUN_080057e8",
            "FUN_08005830",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d0c",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078b4",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_08008818",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_080099ec",
            "FUN_08009a18",
            "FUN_08009adc",
            "FUN_08009e50",
            "FUN_08009e68"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c"
        ]
    ],
    "locked_functions": []
}