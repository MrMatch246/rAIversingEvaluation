{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "update_completion_status_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 updateCompletionStatus_000800f4(undefined4 status)\n\n{\n  if ((char)completionFlag == '\\0') {\n    completionFlag._0_1_ = '\\x01';\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "update_completion_status_000800f4",
                "param_1": "status",
                "completed_7857": "completionFlag"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080148": {
            "entrypoint": "0x00080148",
            "current_name": "execute_software_interrupt_00080148",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t executeSoftwareInterrupt_00080148(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  invokeSoftwareInterrupt(0x3f);\n  return a0;\n}\n\n",
            "renaming": {
                "FUN_00080148": "execute_software_interrupt_00080148",
                "software_interrupt": "invokeSoftwareInterrupt"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008014c": {
            "entrypoint": "0x0008014c",
            "current_name": "execute_afl_call_0008014c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint executeAflCall_0008014c(int inputTicks)\n\n{\n  uint32_t returnValue;\n  \n  if (noHyperCall == 0) {\n    returnValue = aflCall(1,inputTicks,0);\n    return returnValue;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008014c": "execute_afl_call_0008014c",
                "ticks": "inputTicks",
                "uVar1": "returnValue"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "initialize_modbus_00080164",
            "code": "\n/* DWARF original prototype: void  begin(Modbus * modbusInstance, long speed) */\n\nvoid __modbusInstancecall Modbus::initializeModbus_00080164(Modbus *modbusInstance,long speed)\n\n{\n  int iVar1;\n  \n  modbusInstance->hardwareSerialPort = &superSerialPort;\n  (**(code **)(serialInstance + 0x18))(&Serial);\n  if (1 < modbusInstance->txEnablePin) {\n    setPinMode((uint)modbusInstance->txEnablePin,1);\n    writeDigital((uint)modbusInstance->txEnablePin,0);\n  }\n  do {\n    iVar1 = (**(code **)(*(int *)modbusInstance->hardwareSerialPort + 0xc))();\n  } while (-1 < iVar1);\n  modbusInstance->bufferSize = '\\0';\n  modbusInstance->lastReceived = '\\0';\n  modbusInstance->errorCount = 0;\n  modbusInstance->outgoingCount = 0;\n  modbusInstance->incomingCount = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "initialize_modbus_00080164",
                "this": "modbusInstance",
                "u32speed": "speed",
                "port": "hardwareSerialPort",
                "u8txenpin": "txEnablePin",
                "u8BufferSize": "bufferSize",
                "u8lastRec": "lastReceived",
                "u16errCnt": "errorCount",
                "u16OutCnt": "outgoingCount",
                "u16InCnt": "incomingCount",
                "Serial.super_HardwareSerial": "superSerialPort",
                "Serial._0_4_": "serialInstance",
                "pinMode": "setPinMode",
                "digitalWrite": "writeDigital"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "pinMode",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801b0": {
            "entrypoint": "0x000801b0",
            "current_name": "get_rx_buffer_000801b0",
            "code": "\n/* DWARF original prototype: int8_t  getRxBuffer_000801b0(Modbus * modbusInstance) */\n\nint8_t __modbusInstancecall Modbus::getRxBuffer_000801b0(Modbus *modbusInstance)\n\n{\n  bool bufferFull;\n  uchar receivedByte;\n  uint8_t bufferSize;\n  int readResult;\n  byte bufferIndex;\n  \n  if (1 < modbusInstance->u8txenpin) {\n    digitalWrite((uint)modbusInstance->u8txenpin,0);\n  }\n  bufferFull = false;\n  modbusInstance->u8BufferSize = '\\0';\n  if (modbusInstance->u8serno < 4) {\n    while (readResult = (**(code **)(*(int *)modbusInstance->port + 8))(), readResult != 0) {\n      bufferIndex = modbusInstance->u8BufferSize;\n      receivedByte = (**(code **)(*(int *)modbusInstance->port + 0xc))();\n      bufferSize = modbusInstance->u8BufferSize;\n      modbusInstance->au8Buffer[bufferIndex] = receivedByte;\n      bufferIndex = bufferSize + 1;\n      modbusInstance->u8BufferSize = bufferIndex;\n      if (0x3f < bufferIndex) {\n        bufferFull = true;\n      }\n    }\n  }\n  modbusInstance->u16InCnt = modbusInstance->u16InCnt + 1;\n  if (bufferFull) {\n    bufferSize = 0xfd;\n    modbusInstance->u16errCnt = modbusInstance->u16errCnt + 1;\n  }\n  else {\n    bufferSize = modbusInstance->u8BufferSize;\n  }\n  return bufferSize;\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "bVar1": "bufferFull",
                "uVar2": "receivedByte",
                "uVar3": "bufferSize",
                "iVar4": "readResult",
                "bVar5": "bufferIndex",
                "FUN_000801b0": "get_rx_buffer_000801b0"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008021c": {
            "entrypoint": "0x0008021c",
            "current_name": "calculate_crc_0008021c",
            "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * modbus, uint8_t length) */\n\nuint16_t __modbuscall Modbus::calculateCRC_0008021c(Modbus *modbus,uint8_t length)\n\n{\n  Modbus *currentModbus;\n  uint crc;\n  char bitCount;\n  uint bit;\n  uint flag;\n  \n  crc = 0xffff;\n  for (currentModbus = modbus; ((int)currentModbus - (int)modbus & 0xffU) < (uint)length;\n      currentModbus = (Modbus *)((int)&currentModbus->port + 1)) {\n    crc = crc ^ currentModbus->au8Buffer[0];\n    bitCount = '\\b';\n    do {\n      bit = crc & 1;\n      crc = crc >> 1;\n      if (bit != 0) {\n        crc = crc ^ 0xa001;\n      }\n      bitCount = bitCount + -1;\n    } while (bitCount != '\\0');\n  }\n  return (ushort)(crc << 8) | (ushort)(crc >> 8);\n}\n\n",
            "renaming": {
                "this": "modbus",
                "u8length": "length",
                "pMVar1": "currentModbus",
                "uVar2": "crc",
                "cVar3": "bitCount",
                "uVar4": "bit",
                "FUN_0008021c": "calculate_crc_0008021c"
            },
            "calling": [
                "sendTxBuffer"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080258": {
            "entrypoint": "0x00080258",
            "current_name": "send_transmitted_buffer_00080258",
            "code": "\n/* DWARF original prototype: void  sendTxBuffer(Modbus * this) */\n\nvoid __thiscall Modbus::sendTransmittedBuffer_00080258(Modbus *this)\n\n{\n  byte bufferLength;\n  uint16_t calculatedCRC;\n  uint16_t crcValue;\n  uint32_t currentTime;\n  int returnValue;\n  \n  bufferLength = this->u8BufferSize;\n  calculatedCRC = calcCRC(this,bufferLength);\n  this->au8Buffer[bufferLength] = (uchar)(calculatedCRC >> 8);\n  this->au8Buffer[bufferLength + 1 & 0xff] = (uchar)calculatedCRC;\n  this->u8BufferSize = bufferLength + 2;\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,1);\n  }\n  if (this->u8serno < 4) {\n    (**(code **)(*(int *)this->port + 4))(this->port,this->au8Buffer,this->u8BufferSize);\n  }\n  if (1 < this->u8txenpin) {\n    digitalWrite((uint)this->u8txenpin,0);\n  }\n  if (this->u8serno < 4) {\n    do {\n      returnValue = (**(code **)(*(int *)this->port + 0xc))();\n    } while (-1 < returnValue);\n  }\n  this->u8BufferSize = '\\0';\n  currentTime = millis();\n  this->u32timeOut = currentTime + this->u16timeOut;\n  this->u16OutCnt = this->u16OutCnt + 1;\n  return;\n}\n\n",
            "renaming": {
                "u8length": "bufferLength",
                "uVar1": "calculatedCRC",
                "u16crc": "crcValue",
                "uVar2": "currentTime",
                "iVar3": "returnValue",
                "FUN_00080258": "send_transmitted_buffer_00080258"
            },
            "calling": [
                "query"
            ],
            "called": [
                "millis",
                "digitalWrite",
                "calcCRC"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000802da": {
            "entrypoint": "0x000802da",
            "current_name": "process_modbus_telegram_000802da",
            "code": "\n/* DWARF original prototype: int8_t  query(ModbusDevice * modbusDevice, telegram telegram) */\n\nint8_t __modbusDevicecall ModbusDevice::processModbusTelegram_000802da(ModbusDevice *modbusDevice,telegram telegram)\n\n{\n  uchar lowerByte;\n  uint upperBytes;\n  uint8_t numBytes;\n  byte tempByte;\n  ushort upperShort;\n  ushort *shortPtr;\n  uint8_t result;\n  ushort tempShort;\n  ushort *shortPtr2;\n  uint tempInt;\n  ushort *shortPtr3;\n  uchar upperByteLocal;\n  uchar lowerByteLocal;\n  uchar lowerShort;\n  \n  upperByteLocal = (uchar)upperBytes;\n  lowerByteLocal = (uchar)(upperBytes >> 8);\n  tempInt = (uint)upperShort;\n  if (modbusDevice->u8id != '\\0') {\n    return -2;\n  }\n  if (modbusDevice->u8state != '\\0') {\n    return -1;\n  }\n  if (0xf6 < ((upperBytes & 0xff) - 1 & 0xff)) {\n    return -3;\n  }\n  modbusDevice->au8Buffer[0] = upperByteLocal;\n  modbusDevice->au8Buffer[1] = lowerByteLocal;\n  modbusDevice->au16regs = shortPtr2;\n  modbusDevice->au8Buffer[2] = (uchar)(upperBytes >> 0x18);\n  modbusDevice->au8Buffer[3] = (uchar)(upperBytes >> 0x10);\n  lowerByte = (uchar)upperShort;\n  lowerShort = (uchar)(upperShort >> 8);\n  switch(lowerByteLocal) {\n  case '\\x01':\n  case '\\x02':\n  case '\\x03':\n  case '\\x04':\n    modbusDevice->au8Buffer[4] = lowerShort;\n    break;\n  case '\\x05':\n    tempShort = *shortPtr2;\n    if (tempShort != 0) {\n      tempShort = 1;\n    }\n    modbusDevice->au8Buffer[4] = -(char)tempShort;\n    tempInt = 0;\n    break;\n  case '\\x06':\n    modbusDevice->au8Buffer[4] = (uchar)(*shortPtr2 >> 8);\n    tempInt = (uint)*shortPtr2;\n    break;\n  default:\n    goto switchD_0008031e_caseD_7;\n  case '\\x0f':\n    tempByte = (byte)(upperShort >> 3) & 0xfe;\n    if ((upperShort & 0xf) != 0) {\n      tempByte = tempByte + 1;\n    }\n    modbusDevice->au8Buffer[5] = lowerByte;\n    modbusDevice->au8Buffer[4] = lowerShort;\n    modbusDevice->au8Buffer[6] = tempByte;\n    result = '\\a';\n    goto LAB_0008034a;\n  case '\\x10':\n    modbusDevice->au8Buffer[4] = lowerShort;\n    modbusDevice->au8Buffer[5] = lowerByte;\n    shortPtr = shortPtr2 + -1;\n    modbusDevice->au8Buffer[6] = lowerByte * '\\x02';\n    modbusDevice->u8BufferSize = '\\a';\n    shortPtr3 = shortPtr + tempInt;\n    while (shortPtr != shortPtr3) {\n      tempByte = modbusDevice->u8BufferSize;\n      modbusDevice->au8Buffer[tempByte] = (uchar)(shortPtr[1] >> 8);\n      tempInt = tempByte + 1 & 0xff;\n      modbusDevice->u8BufferSize = (uint8_t)tempInt;\n      shortPtr = shortPtr + 1;\n      modbusDevice->au8Buffer[tempInt] = (uchar)*shortPtr;\n      modbusDevice->u8BufferSize = tempByte + 2;\n    }\n    goto switchD_0008031e_caseD_7;\n  }\n  modbusDevice->au8Buffer[5] = (uchar)tempInt;\n  result = '\\x06';\nLAB_0008034a:\n  modbusDevice->u8BufferSize = result;\nswitchD_0008031e_caseD_7:\n  sendTransmissionBuffer(modbusDevice);\n  modbusDevice->u8state = '\\x01';\n  return '\\0';\n}\n\n",
            "renaming": {
                "Modbus": "ModbusDevice",
                "this": "modbusDevice",
                "modbus_t": "telegram",
                "uVar1": "lowerByte",
                "in_r1": "upperBytes",
                "u8bytesno": "numBytes",
                "bVar3": "tempByte",
                "in_r2": "upperShort",
                "puVar4": "shortPtr",
                "uVar5": "result",
                "uVar6": "tempShort",
                "in_r3": "shortPtr2",
                "uVar7": "tempInt",
                "puVar8": "shortPtr3",
                "local_1c": "upperByteLocal",
                "local_1b": "lowerByteLocal",
                "uVar2": "lowerShort",
                "sendTxBuffer": "sendTransmissionBuffer",
                "FUN_000802da": "process_modbus_telegram_000802da"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "sendTxBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803d4": {
            "entrypoint": "0x000803d4",
            "current_name": "validate_answer_000803d4",
            "code": "\n/* DWARF orindexgindexnal prototype: uindexnt8_t  valindexdateAnswer(Modbus * modbusInstance) */\n\nuindexnt8_t __modbusInstancecall Modbus::validateAnswer_000803d4(Modbus *modbusInstance)\n\n{\n  uindexnt8_t index;\n  indexnt comparison;\n  \n  indexf ((indexnt)((uindexnt)modbusInstance->au8Buffer[1] << 0x18) < 0) {\n    modbusInstance->errorCount = modbusInstance->errorCount + 1;\n    return 0xfb;\n  }\n  comparison = 0;\n  do {\n    indexf (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[comparison] == modbusInstance->au8Buffer[1]) {\n      return '\\0';\n    }\n    comparison = comparison + 1;\n  } whindexle (comparison != 8);\n  modbusInstance->errorCount = modbusInstance->errorCount + 1;\n  return '\\x01';\n}\n\n",
            "renaming": {
                "this": "modbusInstance",
                "i": "index",
                "iVar1": "comparison",
                "u16errCnt": "errorCount",
                "FUN_000803d4": "validate_answer_000803d4"
            },
            "calling": [
                "poll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080410": {
            "entrypoint": "0x00080410",
            "current_name": "extract_registers_00080410",
            "code": "\n/* DWARF original prototype: void  get_FC3(Modbus * modbusInstance) */\n\nvoid __modbusInstancecall Modbus::extractRegisters_00080410(Modbus *modbusInstance)\n\n{\n  uint16_t registerValue;\n  uint index;\n  byte counter;\n  uint temp;\n  uint16_t *registerArray;\n  \n  counter = 0;\n  while( true ) {\n    temp = (uint)counter;\n    counter = counter + 1;\n    index = temp * 2 + 3 & 0xff;\n    if (modbusInstance->au8Buffer[2] >> 1 <= temp) break;\n    registerArray = modbusInstance->au16regs;\n    registerValue = makeWord(modbusInstance->au8Buffer[index],modbusInstance->au8Buffer[index + 1]);\n    registerArray[temp] = registerValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080410": "extract_registers_00080410",
                "this": "modbusInstance",
                "uVar1": "registerValue",
                "uVar2": "index",
                "bVar3": "counter",
                "uVar4": "temp",
                "puVar5": "registerArray"
            },
            "calling": [
                "poll"
            ],
            "called": [
                "makeWord"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008043e": {
            "entrypoint": "0x0008043e",
            "current_name": "perform_poll_0008043e",
            "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * modbus) */\n\nint __modbuscall Modbus::performPoll_0008043e(Modbus *modbus,pollfd *pollFileDescriptors,nfds_t numFileDescriptors,int timeout)\n\n{\n  byte byteValue;\n  uint8_t uint8Value;\n  uint8_t exceptionCode;\n  uint32_t currentTime;\n  uint8_t currentValue;\n  uint registerValue;\n  \n  if (modbus->serialNumber < 4) {\n    byteValue = (**(code **)(*(int *)modbus->port + 8))();\n    registerValue = (uint)byteValue;\n  }\n  currentTime = millis();\n  if (modbus->timeoutValue < currentTime) {\n    modbus->lastError = 0xff;\n    modbus->state = '\\0';\n    modbus->errorCount = modbus->errorCount + 1;\n  }\n  else if (7 < registerValue) {\n    fetchReceiveBuffer(modbus);\n    uint8Value = validateResponse(modbus);\n    if (uint8Value == '\\0') {\n      if (modbus->buffer[1] - 3 < 2) {\n        fetch_FC3(modbus);\n      }\n      modbus->state = '\\0';\n      uint8Value = modbus->bufferSize;\n    }\n    else {\n      modbus->state = '\\0';\n    }\n    goto LAB_000804a2;\n  }\n  uint8Value = '\\0';\nLAB_000804a2:\n  return (int)(char)uint8Value;\n}\n\n",
            "renaming": {
                "this": "modbus",
                "__fds": "pollFileDescriptors",
                "__nfds": "numFileDescriptors",
                "__timeout": "timeout",
                "bVar1": "byteValue",
                "uVar2": "uint8Value",
                "u8exception": "exceptionCode",
                "uVar3": "currentTime",
                "u8current": "currentValue",
                "unaff_r6": "registerValue",
                "u8serno": "serialNumber",
                "u32timeOut": "timeoutValue",
                "u8lastError": "lastError",
                "u8state": "state",
                "u16errCnt": "errorCount",
                "getRxBuffer": "fetchReceiveBuffer",
                "validateAnswer": "validateResponse",
                "au8Buffer": "buffer",
                "get_FC3": "fetch_FC3",
                "u8BufferSize": "bufferSize",
                "FUN_0008043e": "perform_poll_0008043e"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "getRxBuffer",
                "get_FC3",
                "validateAnswer",
                "millis"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000804a8": {
            "entrypoint": "0x000804a8",
            "current_name": "initialize_device_000804a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeDevice_000804a8(void)\n\n{\n  uint32_t currentTime;\n  \n  pinMode(1,0);\n  pinMode(6,1);\n  pinMode(0,1);\n  pinMode(1,1);\n  digitalWrite(0,0);\n  digitalWrite(1,0);\n  modbusTelegramArray[1].registerAddress = 0x13;\n  modbusTelegramArray[1].coilsNumber = 10;\n  modbusTelegramArray[1].registersArray = au16data + 0x13;\n  modbusTelegramArray[0].functionCode = '\\x03';\n  modbusTelegramArray[2].functionCode = '\\x03';\n  modbusTelegramArray[2].registerAddress = 0x14;\n  modbusTelegramArray[3].coilsNumber = 3;\n  modbusTelegramArray[0].coilsNumber = 0x10;\n  modbusTelegramArray[0].registersArray = au16data;\n  modbusTelegramArray[1].functionCode = '\\x10';\n  modbusTelegramArray[2].coilsNumber = 0xc;\n  modbusTelegramArray[3].functionCode = '\\x10';\n  modbusTelegramArray[4].coilsNumber = 8;\n  modbusTelegramArray[3].registerAddress = 0x1c;\n  modbusTelegramArray[3].registersArray = au16data + 0x1c;\n  modbusTelegramArray[4].unitID = '\\x02';\n  modbusTelegramArray[4].functionCode = '\\x02';\n  modbusTelegramArray[4].registersArray = data8024Array;\n  modbusTelegramArray[5].unitID = '\\x02';\n  modbusTelegramArray[0].unitID = '\\x01';\n  modbusTelegramArray[1].unitID = '\\x01';\n  modbusTelegramArray[2].unitID = '\\x01';\n  modbusTelegramArray[3].unitID = '\\x01';\n  modbusTelegramArray[5].registerAddress = 1;\n  modbusTelegramArray[5].coilsNumber = 1;\n  modbusTelegramArray[0].registerAddress = 0;\n  modbusTelegramArray[2].registersArray = au16data + 0x14;\n  modbusTelegramArray[4].registerAddress = 0;\n  modbusTelegramArray[5].functionCode = '\\x05';\n  modbusTelegramArray[5].registersArray = data8024Array + 1;\n  Modbus::begin(&modbusMaster,0x4b00);\n  modbusMaster.u16timeOut = 2000;\n  waitTime = millis();\n  currentTime = millis();\n  pidTime1 = currentTime + 1000;\n  currentTime = millis();\n  dutyCycleHigh1 = currentTime + 1000;\n  currentTime = millis();\n  dutyCycleLow1 = currentTime + 1000;\n  currentTime = millis();\n  clock = currentTime + 1000;\n  state = '\\0';\n  startForkServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000804a8": "initialize_device_000804a8",
                "uVar1": "currentTime",
                "telegram": "modbusTelegramArray",
                "u16RegAdd": "registerAddress",
                "u16CoilsNo": "coilsNumber",
                "au16reg": "registersArray",
                "u8fct": "functionCode",
                "u8id": "unitID",
                "data8024": "data8024Array",
                "master": "modbusMaster",
                "u32wait": "waitTime",
                "tiempopid1": "pidTime1",
                "dutyalto1": "dutyCycleHigh1",
                "dutybajo1": "dutyCycleLow1",
                "reloj": "clock",
                "u8state": "state",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "pinMode",
                "millis",
                "startForkserver",
                "digitalWrite",
                "begin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805d0": {
            "entrypoint": "0x000805d0",
            "current_name": "temperature_controller_000805d0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid temperatureController_000805d0(void)\n\n{\n  modbus_t modbusTelegram;\n  modbus_t modbusTelegram_00;\n  modbus_t modbusTelegram_01;\n  modbus_t modbusTelegram_02;\n  uint32_t currentTime;\n  undefined4 tempDiff;\n  float tempError;\n  float kiError;\n  float kdError;\n  int comparisonResult;\n  pollfd *pollfdArray;\n  nfds_t numberOfPollfds;\n  int *pointerVar;\n  uint timeoutValue;\n  undefined4 parameter_1;\n  undefined4 parameter_2;\n  float *pointerFloatVar_1;\n  undefined4 parameter_3;\n  ulong *pointerVar_2;\n  float *pointerFloatVar_2;\n  \n  timeoutValue = (uint)u8state;\n  switch(timeoutValue) {\n  case 0:\n    currentTime = millis();\n    if (u32wait < currentTime) goto LAB_000806ca;\n    break;\n  case 1:\n    Modbus::poll(&master,pollfdArray,numberOfPollfds,timeoutValue);\n    if (master.u8state == '\\0') {\n      modbusTelegram._4_4_ = parameter_2;\n      modbusTelegram.u8id = (char)parameter_1;\n      modbusTelegram.u8fct = (char)((uint)parameter_1 >> 8);\n      modbusTelegram.u16RegAdd = (short)((uint)parameter_1 >> 0x10);\n      modbusTelegram.au16reg = (uint16_t *)parameter_3;\n      Modbus::query(&master,modbusTelegram);\n      u8state = u8state + '\\x01';\n      u32wait = millis();\n      tempSensor1 = (int)dataArray[1];\n      tempSensor2 = (int)dataArray[2];\n      kpVar1 = (float)__floatunsisf(dataArray[6]);\n      kiVar1 = (float)__floatsisf(dataArray[7] / 10);\n      kdVar1 = (float)__floatunsisf(dataArray[8]);\n      dutyCycle2 = (int)dataArray[12];\n      dutyCycle1 = (int)dataArray[9];\n      minutes = (int)dataArray[14];\n      seconds = (int)dataArray[15];\n    }\n    break;\n  case 2:\n  case 4:\n  case 6:\n  case 8:\n    Modbus::poll(&master,pollfdArray,numberOfPollfds,timeoutValue);\n    if (master.u8state == '\\0') {\n      u8state = u8state + '\\x01';\n      u32wait = millis();\n    }\n    break;\n  case 3:\n    Modbus::poll(&master,pollfdArray,numberOfPollfds,timeoutValue);\n    if (master.u8state == '\\0') {\n      modbusTelegram_00._4_4_ = parameter_2;\n      modbusTelegram_00.u8id = (char)parameter_1;\n      modbusTelegram_00.u8fct = (char)((uint)parameter_1 >> 8);\n      modbusTelegram_00.u16RegAdd = (short)((uint)parameter_1 >> 0x10);\n      modbusTelegram_00.au16reg = (uint16_t *)parameter_3;\n      Modbus::query(&master,modbusTelegram_00);\n      u8state = u8state + '\\x01';\n      u32wait = millis();\n      waitTime = (int)dataArray[30];\n      state = (int)dataArray[29];\n    }\n    break;\n  case 5:\n    Modbus::poll(&master,pollfdArray,numberOfPollfds,timeoutValue);\n    if (master.u8state == '\\0') {\nLAB_000806c4:\n      modbusTelegram_01._4_4_ = parameter_2;\n      modbusTelegram_01.u8id = (char)parameter_1;\n      modbusTelegram_01.u8fct = (char)((uint)parameter_1 >> 8);\n      modbusTelegram_01.u16RegAdd = (short)((uint)parameter_1 >> 0x10);\n      modbusTelegram_01.au16reg = (uint16_t *)parameter_3;\n      Modbus::query(&master,modbusTelegram_01);\n      goto LAB_000806ca;\n    }\n    break;\n  case 7:\n    Modbus::poll(&master,pollfdArray,numberOfPollfds,timeoutValue);\n    if ((endLoop == 1) && (master.u8state == '\\0')) {\n      dataArray[29] = 0;\n      endLoop = 0;\n      goto LAB_000806c4;\n    }\nLAB_000806ca:\n    u8state = u8state + '\\x01';\n    break;\n  case 9:\n    Modbus::poll(&master,pollfdArray,numberOfPollfds,timeoutValue);\n    if (master.u8state == '\\0') {\n      modbusTelegram_02._4_4_ = parameter_2;\n      modbusTelegram_02.u8id = (char)parameter_1;\n      modbusTelegram_02.u8fct = (char)((uint)parameter_1 >> 8);\n      modbusTelegram_02.u16RegAdd = (short)((uint)parameter_1 >> 0x10);\n      modbusTelegram_02.au16reg = (uint16_t *)parameter_3;\n      Modbus::query(&master,modbusTelegram_02);\n      u32wait = millis();\n    }\n    u8state = '\\0';\n  }\n  remainingMinutes = minutes - mmResult;\n  if (remainingMinutes < 0) {\n    remainingMinutes = remainingMinutes + 0x3c;\n  }\n  remainingSeconds = seconds - ssResult;\n  if (remainingSeconds < 0) {\n    remainingMinutes = remainingMinutes + -1;\n    remainingSeconds = remainingSeconds + 0x3c;\n  }\n  dataArray[27] = (ushort)remainingMinutes;\n  dataArray[28] = (ushort)remainingSeconds;\n  if ((remainingMinutes == 0) && (remainingSeconds == 0)) {\n    endLoop = 1;\n    mmResult = remainingSeconds;\n    ssResult = remainingSeconds;\n  }\n  if (previousMinutes == minutes) {\n    previousSeconds = 1 - seconds;\n    if (1 < (uint)seconds) {\n      previousSeconds = 0;\n    }\n    if (previousSeconds != 0) goto LAB_00080a08;\n  }\n  else {\nLAB_00080a08:\n    previousSeconds = seconds;\n    mmResult = 0;\n    ssResult = 0;\n    ironWait = 0;\n    previousMinutes = minutes;\n  }\n  if (state == 0) {\n    mmResult = state;\n    ssResult = state;\n    pointerVar = &ironWait;\nLAB_000808f2:\n    *pointerVar = ssResult;\n  }\n  else {\n    if (state != 1) goto LAB_000808f4;\n    if ((ironWait < waitTime) && (currentTime = millis(), clock < currentTime)) {\n      ironWait = ironWait + 1;\n      pointerVar_2 = &clock;\n      currentTime = millis();\n      *pointerVar_2 = currentTime + 1000;\n    }\n    if (ironWait < waitTime) goto LAB_000808f4;\n    ironWait = waitTime + 1;\n    if (mmResult < minutes) {\n      currentTime = millis();\n      if (clock < currentTime) {\n        ssResult = ssResult + 1;\n        currentTime = millis();\n        clock = currentTime + 1000;\n      }\n    }\n    else {\n      if (mmResult != minutes) goto LAB_000808f4;\n      if (seconds < ssResult) {\n        pointerVar = &mmResult;\n        ssResult = 0;\n        goto LAB_000808f2;\n      }\n      currentTime = millis();\n      if (clock < currentTime) {\n        ssResult = ssResult + 1;\n        currentTime = millis();\n        clock = currentTime + 1000;\n      }\n    }\n    if (0x3b < ssResult) {\n      ssResult = 0;\n      mmResult = mmResult + 1;\n    }\n  }\nLAB_000808f4:\n  currentTime = millis();\n  if (tiempopidVar1 < currentTime) {\n    tempDiff = __floatsisf(tempSensor1);\n    tempError = (float)__aeabi_fsub(tempDiff,temperatura1);\n    pointerFloatVar_1 = &epVar1;\n    e1 = tempError;\n    kdError = epVar1;\n    tempDiff = __addsf3(tempError,epVar1);\n    tempDiff = __aeabi_fmul(tempDiff,kiVar1);\n    kiError = (float)__addsf3(tempDiff,kipVar1);\n    kiVar1 = kiError;\n    tempDiff = __aeabi_fsub(tempError,kdError);\n    tempDiff = __aeabi_fmul(tempDiff,kdVar1);\n    pointerFloatVar_2 = &kdpVar1;\n    kdError = (float)__aeabi_fsub(tempDiff,kdpVar1);\n    kdVar1 = kdError;\n    tempDiff = __aeabi_fmul(tempError,kpVar1);\n    tempDiff = __addsf3(tempDiff,kiError);\n    __addsf3(tempDiff,kdError);\n    pidVar1 = __aeabi_f2iz();\n    YNVar = (float)__floatsisf();\n    *pointerFloatVar_1 = tempError;\n    incrementVal = 0;\n    kipVar1 = kiError;\n    *pointerFloatVar_2 = kdError;\n    currentTime = millis();\n    tiempopidVar1 = currentTime + dutyCycle1;\n  }\n  kdError = (float)__floatsisf(dutyCycle1);\n  comparisonResult = __aeabi_fcmpge(YNVar,kdError);\n  if (comparisonResult != 0) {\n    YNVar = kdError;\n  }\n  comparisonResult = __aeabi_fcmple(YNVar,0);\n  if (comparisonResult != 0) {\n    YNVar = 0.0;\n  }\n  dataArray[21] = __fixunssfsi(YNVar);\n  incrementVal = incrementVal + 1;\n  inputVal = data8024Array[0] & 1 ^ 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000805d0": "temperature_controller_000805d0",
                "telegram": "modbusTelegram",
                "telegram_00": "modbusTelegram_00",
                "telegram_01": "modbusTelegram_01",
                "telegram_02": "modbusTelegram_02",
                "uVar1": "currentTime",
                "uVar2": "tempDiff",
                "fVar3": "tempError",
                "fVar4": "kiError",
                "fVar5": "kdError",
                "iVar6": "comparisonResult",
                "in_r1": "pollfdArray",
                "in_r2": "numberOfPollfds",
                "piVar7": "pointerVar",
                "__timeout": "timeoutValue",
                "in_stack_ffffffc8": "parameter_1",
                "in_stack_ffffffcc": "parameter_2",
                "in_stack_ffffffd0": "parameter_3",
                "puVar9": "pointerVar_2",
                "pfVar8": "pointerFloatVar_1",
                "pfVar10": "pointerFloatVar_2",
                "mmt": "remainingMinutes",
                "sst": "remainingSeconds",
                "au16data": "dataArray",
                "tempe_z1": "tempSensor1",
                "tempe_z2": "tempSensor2",
                "kpa1": "kpVar1",
                "kia1": "kiVar1",
                "kda1": "kdVar1",
                "duty2": "dutyCycle2",
                "duty1": "dutyCycle1",
                "minutos": "minutes",
                "segundos": "seconds",
                "terminar_ciclo": "endLoop",
                "mmres": "mmResult",
                "ssres": "ssResult",
                "espera_plancha": "ironWait",
                "minutosp": "previousMinutes",
                "segundosp": "previousSeconds",
                "estado": "state",
                "tiempo_espera": "waitTime",
                "reloj": "clock",
                "ep1": "epVar1",
                "kip1": "kipVar1",
                "kdp1": "kdpVar1",
                "pid1": "pidVar1",
                "YN": "YNVar",
                "incre": "incrementVal",
                "in1": "inputVal",
                "data8024": "data8024Array"
            },
            "calling": [
                "main"
            ],
            "called": [
                "__floatunsisf",
                "__aeabi_fmul",
                "__aeabi_fcmple",
                "__addsf3",
                "__floatsisf",
                "query",
                "__aeabi_fsub",
                "__aeabi_fcmpge",
                "poll",
                "millis",
                "__fixunssfsi",
                "__aeabi_f2iz"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a68": {
            "entrypoint": "0x00080a68",
            "current_name": "initialize_master_00080a68",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeMaster_00080a68(void)\n\n{\n  String::String(&emptyString,\"\");\n  registerAtExit(&emptyString,0x815ff,&exitHandle);\n  masterId = '\\0';\n  masterSerialNumber = '\\0';\n  masterTxEnablePin = '\\x06';\n  masterTimeout = 1000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a68": "initialize_master_00080a68",
                "RxString": "emptyString",
                "__aeabi_atexit": "registerAtExit",
                "__dso_handle": "exitHandle",
                "master.u8id": "masterId",
                "master.u8serno": "masterSerialNumber",
                "master.u8txenpin": "masterTxEnablePin",
                "master.u16timeOut": "masterTimeout"
            },
            "calling": [],
            "called": [
                "__aeabi_atexit",
                "String"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "FUNC_00080aa8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080aa8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "FUNC_00080aa8"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080aac": {
            "entrypoint": "0x00080aac",
            "current_name": "initialize_uart_communication_00080aac",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeUartCommunication_00080aac(void)\n\n{\n  UARTClass::IrqHandler(uartInstance);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aac": "initialize_uart_communication_00080aac",
                "&Serial": "uartInstance"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ab8": {
            "entrypoint": "0x00080ab8",
            "current_name": "FUNC_00080ab8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080ab8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ab8": "FUNC_00080ab8"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080aba": {
            "entrypoint": "0x00080aba",
            "current_name": "FUNC_00080aba",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080aba(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080aba": "FUNC_00080aba"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080abc": {
            "entrypoint": "0x00080abc",
            "current_name": "FUNC_00080abc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00080abc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080abc": "FUNC_00080abc"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080ac0": {
            "entrypoint": "0x00080ac0",
            "current_name": "handle_uart_interrupt_00080ac0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleUartInterrupt_00080ac0(void)\n\n{\n  UARTClass::IrqHandler(&uartInstance);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ac0": "handle_uart_interrupt_00080ac0",
                "Serial1.super_UARTClass": "uartInstance"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080acc": {
            "entrypoint": "0x00080acc",
            "current_name": "handle_serial2_interrupt_00080acc",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerial2Interrupt_00080acc(void)\n\n{\n  handleInterrupt(serial2Instance);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080acc": "handle_serial2_interrupt_00080acc",
                "UARTClass::IrqHandler": "handleInterrupt",
                "&Serial2.super_UARTClass": "serial2Instance"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ad8": {
            "entrypoint": "0x00080ad8",
            "current_name": "handle_serial_interrupt_00080ad8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid handleSerialInterrupt_00080ad8(void)\n\n{\n  handleUARTInterrupt(&Serial3.super_UARTClass);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ad8": "handle_serial_interrupt_00080ad8",
                "UARTClass::IrqHandler": "handleUARTInterrupt"
            },
            "calling": [],
            "called": [
                "IrqHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ae4": {
            "entrypoint": "0x00080ae4",
            "current_name": "initialize_system_00080ae4",
            "code": "\n\n\nint initializeSystem_00080ae4(EVP_PKEY_CTX *context)\n\n{\n  int returnValue;\n  uint32_t pin;\n  uint32_t nextPin;\n  \n  SystemInit();\n  _DAT_e000e014 = SystemCoreClock / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  __libc_init_array();\n  pin = 0;\n  do {\n    nextPin = pin + 1;\n    digitalWrite(pin,0);\n    pin = nextPin;\n  } while (nextPin != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  PIO_Configure(&DAT_400e0e00,1,0x300,0);\n  digitalWrite(0,1);\n  PIO_Configure(&DAT_400e0e00,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,0x3000,0);\n  PIO_Configure(&DAT_400e1400,2,0x30,0);\n  PIO_Configure(&DAT_400e1000,1,0xc00,0);\n  PIO_Configure(&DAT_400e0e00,1,3,0);\n  PIO_Configure(&DAT_400e1000,1,0xc000,0);\n  enablePeripheralClock(0x25);\n  initializeADC(0x400c0000,SystemCoreClock,20000000,0xc);\n  configureADCTiming(0x400c0000,0,0x300000,1);\n  configureADCTrigger(0x400c0000,0,0);\n  disableADCInterrupt(0x400c0000,0xffffffff);\n  returnValue = disableAllADCChannel(0x400c0000);\n  initializeAnalogOutput();\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_00080ae4": "initialize_system_00080ae4",
                "ctx": "context",
                "ulPin": "pin",
                "uVar2": "nextPin",
                "pmc_enable_periph_clk": "enablePeripheralClock",
                "adc_init": "initializeADC",
                "adc_configure_timing": "configureADCTiming",
                "adc_configure_trigger": "configureADCTrigger",
                "adc_disable_interrupt": "disableADCInterrupt",
                "adc_disable_all_channel": "disableAllADCChannel",
                "analogOutputInit": "initializeAnalogOutput",
                "iVar1": "returnValue"
            },
            "calling": [
                "main"
            ],
            "called": [
                "PIO_Configure",
                "SystemInit",
                "adc_configure_trigger",
                "adc_disable_interrupt",
                "analogOutputInit",
                "adc_configure_timing",
                "digitalWrite",
                "__libc_init_array",
                "pmc_enable_periph_clk",
                "adc_disable_all_channel",
                "adc_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c0c": {
            "entrypoint": "0x00080c0c",
            "current_name": "initialize_serial_communication_00080c0c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initializeSerialCommunication_00080c0c(void)\n\n{\n  RingBuffer::RingBuffer(rxBuffer1);\n  RingBuffer::RingBuffer(txBuffer1);\n  UARTClass::UARTClass(serialPort,(Uart *)0x400e0800,uart1Interrupt,8,rxBuffer1,txBuffer1);\n  RingBuffer::RingBuffer(rxBuffer2);\n  RingBuffer::RingBuffer(rxBuffer3);\n  RingBuffer::RingBuffer(rxBuffer4);\n  RingBuffer::RingBuffer(txBuffer2);\n  RingBuffer::RingBuffer(txBuffer3);\n  RingBuffer::RingBuffer(txBuffer4);\n  USARTClass::USARTClass(serialPort1,(Usart *)0x40098000,usart1Interrupt,0x11,rxBuffer2,txBuffer2);\n  USARTClass::USARTClass(serialPort2,(Usart *)0x4009c000,usart2Interrupt,0x12,rxBuffer3,txBuffer3);\n  USARTClass::USARTClass(serialPort3,(Usart *)0x400a4000,usart3Interrupt,0x14,rxBuffer4,txBuffer4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080c0c": "initialize_serial_communication_00080c0c",
                "&Serial": "serialPort",
                "UART_IRQn": "uart1Interrupt",
                "&rx_buffer1": "rxBuffer1",
                "&tx_buffer1": "txBuffer1",
                "&rx_buffer2": "rxBuffer2",
                "&rx_buffer3": "rxBuffer3",
                "&rx_buffer4": "rxBuffer4",
                "&tx_buffer2": "txBuffer2",
                "&tx_buffer3": "txBuffer3",
                "&tx_buffer4": "txBuffer4",
                "USART0_IRQn": "usart1Interrupt",
                "USART1_IRQn": "usart2Interrupt",
                "USART3_IRQn": "usart3Interrupt"
            },
            "calling": [],
            "called": [
                "UARTClass",
                "RingBuffer",
                "USARTClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ce0": {
            "entrypoint": "0x00080ce0",
            "current_name": "process_serial_events_00080ce0",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid processSerialEvents_00080ce0(void)\n\n{\n  int availableCount;\n  \n  availableCount = UARTClass::available(&Serial);\n  if (availableCount != 0) {\n    serialEvent();\n  }\n  availableCount = UARTClass::available(&Serial1);\n  if (availableCount != 0) {\n    serialEvent1();\n  }\n  availableCount = UARTClass::available(&Serial2);\n  if (availableCount != 0) {\n    serialEvent2();\n  }\n  availableCount = UARTClass::available(&Serial3);\n  if (availableCount != 0) {\n    serialEvent3();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080ce0": "process_serial_events_00080ce0",
                "iVar1": "availableCount",
                "&Serial1.super_UARTClass": "&Serial1",
                "&Serial2.super_UARTClass": "&Serial2",
                "&Serial3.super_UARTClass": "&Serial3"
            },
            "calling": [
                "main"
            ],
            "called": [
                "serialEvent2",
                "serialEvent3",
                "serialEvent1",
                "serialEvent",
                "available"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d24": {
            "entrypoint": "0x00080d24",
            "current_name": "update_data_00080d24",
            "code": "\nvoid updateData_00080d24(int baseAddress,undefined4 newValue,int condition)\n\n{\n  if (condition != 0) {\n    *(undefined4 *)(baseAddress + 100) = newValue;\n    return;\n  }\n  *(undefined4 *)(baseAddress + 0x60) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d24": "update_data_00080d24",
                "param_1": "baseAddress",
                "param_2": "newValue",
                "param_3": "condition"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d2e": {
            "entrypoint": "0x00080d2e",
            "current_name": "update_config_00080d2e",
            "code": "\nvoid updateConfig_00080d2e(int configAddress,undefined4 option,uint value)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(configAddress + 0x44) = value;\n  switch(option) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(configAddress + 0x70) & *(uint *)(configAddress + 0x70) & ~value;\n    break;\n  case 2:\n    updatedValue = *(uint *)(configAddress + 0x70) | value;\n    break;\n  default:\n    goto switchD_00080d34_caseD_6;\n  }\n  *(uint *)(configAddress + 0x70) = updatedValue;\nswitchD_00080d34_caseD_6:\n  *(uint *)(configAddress + 4) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d2e": "update_config_00080d2e",
                "param_1": "configAddress",
                "param_2": "option",
                "param_3": "value",
                "uVar1": "updatedValue"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d54": {
            "entrypoint": "0x00080d54",
            "current_name": "set_param_values_00080d54",
            "code": "\nvoid setParamValues_00080d54(undefined4 *paramArray,undefined4 newValue,uint flag)\n\n{\n  bool isFlagNegative;\n  \n  isFlagNegative = (int)(flag << 0x1f) < 0;\n  paramArray[0x11] = newValue;\n  if (isFlagNegative) {\n    paramArray[0x19] = newValue;\n  }\n  if (!isFlagNegative) {\n    paramArray[0x18] = newValue;\n  }\n  isFlagNegative = (flag & 10) != 0;\n  if (isFlagNegative) {\n    paramArray[8] = newValue;\n  }\n  if (!isFlagNegative) {\n    paramArray[9] = newValue;\n  }\n  if (((int)(flag << 0x1e) < 0) || ((int)(flag << 0x1c) < 0)) {\n    paramArray[0x20] = newValue;\n  }\n  paramArray[5] = newValue;\n  *paramArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d54": "set_param_values_00080d54",
                "param_1": "paramArray",
                "param_2": "newValue",
                "param_3": "flag",
                "bVar1": "isFlagNegative"
            },
            "calling": [
                "PIO_Configure"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d7a": {
            "entrypoint": "0x00080d7a",
            "current_name": "assign_param_to_array_00080d7a",
            "code": "\nvoid assign_param_to_array_00080d7a(undefined4 *array,undefined4 value,int flag1,int flag2,int flag3)\n\n{\n  array[0x11] = value;\n  if (flag3 == 0) {\n    array[0x18] = value;\n  }\n  else {\n    array[0x19] = value;\n  }\n  if (flag2 == 0) {\n    array[0x15] = value;\n  }\n  else {\n    array[0x14] = value;\n  }\n  if (flag1 == 0) {\n    array[0xd] = value;\n  }\n  else {\n    array[0xc] = value;\n  }\n  array[4] = value;\n  *array = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d7a": "assign_param_to_array_00080d7a",
                "param_1": "array",
                "param_2": "value",
                "param_3": "flag1",
                "param_4": "flag2",
                "param_5": "flag3"
            },
            "calling": [
                "PIO_Configure",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080da0": {
            "entrypoint": "0x00080da0",
            "current_name": "set_peripheral_00080da0",
            "code": "\nundefined4 setPeripheral_00080da0(int deviceAddress,int peripheralType,undefined4 peripheralId,uint peripheralValue)\n\n{\n  bool isNegative;\n  \n  switch(peripheralType) {\n  case 1:\n  case 2:\n    configurePeripheral(deviceAddress,peripheralType,peripheralId);\n    isNegative = (int)(peripheralValue << 0x1f) < 0;\n    *(undefined4 *)(deviceAddress + 0x44) = peripheralId;\n    if (isNegative) {\n      *(undefined4 *)(deviceAddress + 100) = peripheralId;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(deviceAddress + 0x60) = peripheralId;\n    }\n    break;\n  case 3:\n    setInput(deviceAddress,peripheralId,peripheralValue,0x80d55,deviceAddress);\n    break;\n  case 4:\n  case 5:\n    setOutput(deviceAddress,peripheralId,peripheralType == 5,(peripheralValue << 0x1d) >> 0x1f,peripheralValue & 1,peripheralType,peripheralId\n                 );\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080da0": "set_peripheral_00080da0",
                "param_1": "deviceAddress",
                "param_2": "peripheralType",
                "param_3": "peripheralId",
                "param_4": "peripheralValue",
                "bVar1": "isNegative",
                "PIO_SetPeripheral": "configurePeripheral",
                "PIO_SetInput": "setInput",
                "PIO_SetOutput": "setOutput"
            },
            "calling": [
                "pinMode",
                "init"
            ],
            "called": [
                "PIO_SetOutput",
                "PIO_SetInput",
                "PIO_SetPeripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e04": {
            "entrypoint": "0x00080e04",
            "current_name": "check_permissions_00080e04",
            "code": "\nuint checkPermissions_00080e04(int objectAddress,uint permissionMask)\n\n{\n  uint result;\n  \n  result = *(uint *)(objectAddress + 8) & permissionMask;\n  if (result != 0) {\n    if ((permissionMask & *(uint *)(objectAddress + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080e04": "check_permissions_00080e04",
                "param_1": "objectAddress",
                "param_2": "permissionMask",
                "uVar1": "result"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e18": {
            "entrypoint": "0x00080e18",
            "current_name": "check_and_set_bit_00080e18",
            "code": "\n\n\nundefined4 checkAndSetBit_00080e18(uint input)\n\n{\n  uint bitmask;\n  \n  if (input < 0x2d) {\n    if (input < 0x20) {\n      bitmask = 1 << (input & 0xff);\n      if ((bitmask & _DAT_400e0618) != bitmask) {\n        _DAT_400e0610 = bitmask;\n      }\n    }\n    else {\n      bitmask = 1 << (input - 0x20 & 0xff);\n      if ((bitmask & _DAT_400e0708) != bitmask) {\n        _DAT_400e0700 = bitmask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080e18": "check_and_set_bit_00080e18",
                "param_1": "input",
                "uVar1": "bitmask"
            },
            "calling": [
                "pinMode",
                "init",
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e5c": {
            "entrypoint": "0x00080e5c",
            "current_name": "check_and_set_bit_00080e5c",
            "code": "\n\n\nundefined4 checkAndSetBit_00080e5c(uint input)\n\n{\n  uint bitMask;\n  uint bitValue;\n  \n  if (input < 0x2d) {\n    if (input < 0x20) {\n      bitMask = 1 << (input & 0xff);\n      bitValue = _DAT_400e0618 & bitMask;\n      if (bitValue == bitMask) {\n        _DAT_400e0614 = bitValue;\n      }\n    }\n    else {\n      bitMask = 1 << (input - 0x20 & 0xff);\n      bitValue = _DAT_400e0708 & bitMask;\n      if (bitValue == bitMask) {\n        _DAT_400e0704 = bitValue;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080e5c": "check_and_set_bit_00080e5c",
                "param_1": "input",
                "uVar1": "bitMask",
                "uVar2": "bitValue"
            },
            "calling": [
                "pinMode",
                "end"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e9c": {
            "entrypoint": "0x00080e9c",
            "current_name": "initialize_system_00080e9c",
            "code": "\n\n\nvoid initializeSystem_00080e9c(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  systemClock = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080e9c": "initialize_system_00080e9c",
                "SystemCoreClock": "systemClock"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f24": {
            "entrypoint": "0x00080f24",
            "current_name": "initialize_memory_00080f24",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080f6e) */\n\n\nvoid initializeMemory_00080f24(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  \n  for (index = 0; sourceStartAddr + index < sourceEndAddr; index = index + 4) {\n    *(undefined4 *)(sourceStartAddr + index) = *(undefined4 *)(destStartAddr + index);\n  }\n  for (ptr = sourceEndAddr; ptr < destEndAddr; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  main();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080f24": "initialize_memory_00080f24",
                "iVar1": "index",
                "puVar2": "ptr",
                "banzai": "sourceStartAddr",
                "&completed_7857": "sourceEndAddr",
                "&_etext": "destStartAddr",
                "&_ebss": "destEndAddr"
            },
            "calling": [],
            "called": [
                "banzai",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f9c": {
            "entrypoint": "0x00080f9c",
            "current_name": "calculate_threshold_00080f9c",
            "code": "\nundefined4 calculate_threshold_00080f9c(undefined4 *result_ptr,uint total_size,int block_size,int factor)\n\n{\n  uint num_blocks;\n  uint i;\n  uint thresholds [16];\n  \n  thresholds[0] = 0;\n  thresholds[1] = 8;\n  thresholds[2] = 0x10;\n  thresholds[3] = 0x18;\n  thresholds[4] = 0x40;\n  thresholds[5] = 0x50;\n  thresholds[6] = 0x60;\n  thresholds[7] = 0x70;\n  thresholds[8] = 0x200;\n  thresholds[9] = 0x240;\n  thresholds[10] = 0x280;\n  thresholds[11] = 0x2c0;\n  thresholds[12] = 0x300;\n  thresholds[13] = 0x340;\n  thresholds[14] = 0x380;\n  thresholds[15] = 0x3c0;\n  *result_ptr = 1;\n  result_ptr[1] = 0;\n  result_ptr[0x48] = 0x202;\n  result_ptr[0x41] = 0;\n  result_ptr[0x45] = 0;\n  num_blocks = total_size / (uint)(block_size * 2);\n  if (total_size == block_size * 2 * num_blocks) {\n    num_blocks = num_blocks - 1;\n  }\n  i = 0;\n  do {\n    if ((uint)(factor * (int)(((ulonglong)total_size / (ulonglong)((num_blocks + 1) * 2)) / 1000000)) <=\n        thresholds[i]) {\n      result_ptr[1] = (i & 0xf) << 0x10 | (num_blocks & 0xff) << 8 | result_ptr[1];\n      return 0;\n    }\n    i = i + 1;\n  } while (i != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080f9c": "calculate_threshold_00080f9c",
                "param_1": "result_ptr",
                "param_2": "total_size",
                "param_3": "block_size",
                "param_4": "factor",
                "uVar1": "num_blocks",
                "uVar2": "i",
                "local_58": "thresholds"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081034": {
            "entrypoint": "0x00081034",
            "current_name": "update_flags_00081034",
            "code": "\nvoid updateFlags_00081034(int baseAddress,uint value1,uint value2)\n\n{\n  *(uint *)(baseAddress + 4) = value1 | *(uint *)(baseAddress + 4) | (value2 bitwiseAnd 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081034": "update_flags_00081034",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2",
                "&": "bitwiseAnd"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081042": {
            "entrypoint": "0x00081042",
            "current_name": "update_data_00081042",
            "code": "\nvoid updateData_00081042(int dataAddress,uint inputValue1,uint inputValue2,uint inputValue3)\n\n{\n  *(uint *)(dataAddress + 4) =\n       inputValue2 | *(uint *)(dataAddress + 4) | (inputValue1 & 0xf) << 0x18 | (inputValue3 & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081042": "update_data_00081042",
                "param_1": "dataAddress",
                "param_2": "inputValue1",
                "param_3": "inputValue2",
                "param_4": "inputValue3"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008105c": {
            "entrypoint": "0x0008105c",
            "current_name": "set_bit_at_index_0008105c",
            "code": "\nvoid setBitAtIndex_0008105c(int arrayAddress,uint bitIndex)\n\n{\n  *(int *)(arrayAddress + 0x14) = 1 << (bitIndex & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008105c": "set_bit_at_index_0008105c",
                "param_1": "arrayAddress",
                "param_2": "bitIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081066": {
            "entrypoint": "0x00081066",
            "current_name": "set_default_value_00081066",
            "code": "\nvoid setDefaultValue_00081066(int inputParameter)\n\n{\n  *(undefined4 *)(inputParameter + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081066": "set_default_value_00081066",
                "param_1": "inputParameter"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008106e": {
            "entrypoint": "0x0008106e",
            "current_name": "set_parameter_value_0008106e",
            "code": "\nvoid setParameterValue_0008106e(int objectAddress,undefined4 newValue)\n\n{\n  *(undefined4 *)(objectAddress + 0x28) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008106e": "set_parameter_value_0008106e",
                "param_1": "objectAddress",
                "param_2": "newValue"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081074": {
            "entrypoint": "0x00081074",
            "current_name": "execute_isr_00081074",
            "code": "\nvoid execute_isr_00081074(void)\n\n{\n  if (interrupt_service_routine != (code *)0x0) {\n    (*interrupt_service_routine)();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081074": "execute_isr_00081074",
                "gpf_isr": "interrupt_service_routine"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081084": {
            "entrypoint": "0x00081084",
            "current_name": "process_interrupts_00081084",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_00081084(void)\n\n{\n  uint8_t zerosCount;\n  uint32_t interruptStatusRegister;\n  uint remainingZeros;\n  \n  for (interruptStatusRegister = _DAT_400e0e4c; (uint)LZCOUNT(interruptStatusRegister) < 0x20; interruptStatusRegister = interruptStatusRegister & ~(1 << remainingZeros)) {\n    remainingZeros = 0x1fU - LZCOUNT(interruptStatusRegister) & 0xff;\n    if (pioACallbacks[remainingZeros] != (interruptCB)0x0) {\n      (*pioACallbacks[remainingZeros])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081084": "process_interrupts_00081084",
                "isr": "interruptStatusRegister",
                "leading_zeros": "zerosCount",
                "uVar1": "remainingZeros",
                "callbacksPioA": "pioACallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810bc": {
            "entrypoint": "0x000810bc",
            "current_name": "process_interrupts_000810bc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_000810bc(void)\n\n{\n  uint8_t numLeadingZeros;\n  uint32_t interruptStatus;\n  uint shiftAmount;\n  \n  for (interruptStatus = _DAT_400e104c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << shiftAmount)) {\n    shiftAmount = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (callbacksPioB[shiftAmount] != (interruptCB)0x0) {\n      (*callbacksPioB[shiftAmount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810bc": "process_interrupts_000810bc",
                "leading_zeros": "numLeadingZeros",
                "isr": "interruptStatus",
                "uVar1": "shiftAmount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810f4": {
            "entrypoint": "0x000810f4",
            "current_name": "process_callbacks_000810f4",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processCallbacks_000810f4(void)\n\n{\n  uint8_t countLeadingZeros;\n  uint32_t interruptStatusRegister;\n  uint shiftAmount;\n  \n  for (interruptStatusRegister = _DAT_400e124c; (uint)LZCOUNT(interruptStatusRegister) < 0x20; interruptStatusRegister = interruptStatusRegister & ~(1 << shiftAmount)) {\n    shiftAmount = 0x1fU - LZCOUNT(interruptStatusRegister) & 0xff;\n    if (callbacksPioC[shiftAmount] != (interruptCB)0x0) {\n      (*callbacksPioC[shiftAmount])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810f4": "process_callbacks_000810f4",
                "leading_zeros": "countLeadingZeros",
                "isr": "interruptStatusRegister",
                "uVar1": "shiftAmount"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008112c": {
            "entrypoint": "0x0008112c",
            "current_name": "process_interrupts_0008112c",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid processInterrupts_0008112c(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t interruptStatus;\n  uint leadingZeros;\n  \n  for (interruptStatus = _DAT_400e144c; (uint)LZCOUNT(interruptStatus) < 0x20; interruptStatus = interruptStatus & ~(1 << leadingZeros)) {\n    leadingZeros = 0x1fU - LZCOUNT(interruptStatus) & 0xff;\n    if (interruptCallbacks[leadingZeros] != (interruptCB)0x0) {\n      (*interruptCallbacks[leadingZeros])();\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008112c": "process_interrupts_0008112c",
                "isr": "interruptStatus",
                "uVar1": "leadingZeros",
                "callbacksPioD": "interruptCallbacks"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081164": {
            "entrypoint": "0x00081164",
            "current_name": "infinite_loop_00081164",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00081164(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081164": "infinite_loop_00081164"
            },
            "calling": [
                "__halt"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081166": {
            "entrypoint": "0x00081166",
            "current_name": "infinite_loop_00081166",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00081166(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081166": "infinite_loop_00081166"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008116a": {
            "entrypoint": "0x0008116a",
            "current_name": "infinite_loop_0008116a",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_0008116a(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0008116a": "infinite_loop_0008116a"
            },
            "calling": [],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008116e": {
            "entrypoint": "0x0008116e",
            "current_name": "reset_time_tick_0008116e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid resetTimeTick_0008116e(void)\n\n{\n  int isFalse;\n  \n  isFalse = __false();\n  if (isFalse == 0) {\n    resetTick();\n    incrementTimeTick();\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008116e": "reset_time_tick_0008116e",
                "iVar1": "isFalse",
                "tickReset": "resetTick",
                "TimeTick_Increment": "incrementTimeTick"
            },
            "calling": [],
            "called": [
                "TimeTick_Increment",
                "__false",
                "tickReset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081184": {
            "entrypoint": "0x00081184",
            "current_name": "initialize_default_value_00081184",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint initialize_default_value_00081184(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081184": "initialize_default_value_00081184"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081188": {
            "entrypoint": "0x00081188",
            "current_name": "infinite_loop_00081188",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid infiniteLoop_00081188(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00081188": "infinite_loop_00081188"
            },
            "calling": [
                "__halt",
                "SVC_Handler",
                "PendSV_Handler"
            ],
            "called": [
                "__halt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008118c": {
            "entrypoint": "0x0008118c",
            "current_name": "expand_heap_0008118c",
            "code": "\nvoid * expandHeap_0008118c(intptr_t size)\n\n{\n  uchar *previousHeap;\n  uchar *previousHeap;\n  \n  if (currentHeap == (uchar *)0x0) {\n    currentHeap = &endOfDataSegment;\n  }\n  previousHeap = currentHeap;\n  currentHeap = currentHeap + size;\n  return previousHeap;\n}\n\n",
            "renaming": {
                "FUN_0008118c": "expand_heap_0008118c",
                "__delta": "size",
                "puVar1": "previousHeap",
                "prev_heap": "previousHeap",
                "_sbrk::heap": "currentHeap",
                "_ebss": "endOfDataSegment"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811a8": {
            "entrypoint": "0x000811a8",
            "current_name": "copy_string_000811a8",
            "code": "\nint copyString_000811a8(char *source,char *destination)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811a8": "copy_string_000811a8",
                "__from": "source",
                "__to": "destination"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ae": {
            "entrypoint": "0x000811ae",
            "current_name": "check_file_validity_000811ae",
            "code": "\nint checkFileValidity_000811ae(int fileDescriptor)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811ae": "check_file_validity_000811ae",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_close_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b4": {
            "entrypoint": "0x000811b4",
            "current_name": "set_file_permissions_000811b4",
            "code": "\nint setFilePermissions_000811b4(int fileDescriptor,stat *fileStats)\n\n{\n  *(undefined4 *)((int)&fileStats->deviceIdentifier + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811b4": "set_file_permissions_000811b4",
                "__fd": "fileDescriptor",
                "__buf": "fileStats",
                "st_dev": "deviceIdentifier"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811be": {
            "entrypoint": "0x000811be",
            "current_name": "check_file_descriptor_000811be",
            "code": "\nint checkFileDescriptor_000811be(int fileDescriptor)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000811be": "check_file_descriptor_000811be",
                "__fd": "fileDescriptor"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811c2": {
            "entrypoint": "0x000811c2",
            "current_name": "get_file_offset_000811c2",
            "code": "\n__off_t getFileOffset_000811c2(int fileDescriptor,__off_t offset,int origin)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811c2": "get_file_offset_000811c2",
                "__fd": "fileDescriptor",
                "__offset": "offset",
                "__whence": "origin"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811c6": {
            "entrypoint": "0x000811c6",
            "current_name": "process_file_000811c6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint process_file_000811c6(int file_descriptor,char *buffer_ptr,int buffer_len)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000811c6": "process_file_000811c6",
                "file_UNUSED": "file_descriptor",
                "ptr_UNUSED": "buffer_ptr",
                "len_UNUSED": "buffer_len"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811cc": {
            "entrypoint": "0x000811cc",
            "current_name": "convert_byte_array_to_int_000811cc",
            "code": "\n\n/* WARNING: Unknown calling convention */\n\nint convertByteArrayToInt_000811cc(int fileNum,char *byteArray,int arrayLength)\n\n{\n  int index;\n  \n  for (index = 0; index < arrayLength; index = index + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)(byte)byteArray[index];\n  }\n  return arrayLength & ~(arrayLength >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_000811cc": "convert_byte_array_to_int_000811cc",
                "file_UNUSED": "fileNum",
                "ptr": "byteArray",
                "len": "arrayLength",
                "iVar1": "index"
            },
            "calling": [
                "_write_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811f0": {
            "entrypoint": "0x000811f0",
            "current_name": "exit_with_status_000811f0",
            "code": "\nvoid exitWithStatus_000811f0(int status)\n\n{\n  printStatus(\"Exiting with status %d.\\n\",status);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000811f0": "exit_with_status_000811f0",
                "__status": "status",
                "iprintf": "printStatus"
            },
            "calling": [],
            "called": [
                "iprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081200": {
            "entrypoint": "0x00081200",
            "current_name": "FUNC_00081200",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_00081200(int pid_UNUSED,int sig_UNUSED)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081200": "FUNC_00081200"
            },
            "calling": [
                "_kill_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081202": {
            "entrypoint": "0x00081202",
            "current_name": "get_pid_00081202",
            "code": "\n\n\n__pid_t getPid_00081202(void)\n\n{\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00081202": "get_pid_00081202"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081208": {
            "entrypoint": "0x00081208",
            "current_name": "get_tick_count_00081208",
            "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTickCount_00081208(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_00081208": "get_tick_count_00081208",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "sendTxBuffer",
                "setup",
                "poll",
                "loop"
            ],
            "called": [
                "GetTickCount"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008120c": {
            "entrypoint": "0x0008120c",
            "current_name": "FUNC_0008120c",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008120c(uint32_t ms)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008120c": "FUNC_0008120c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008120e": {
            "entrypoint": "0x0008120e",
            "current_name": "FUNC_0008120e",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_0008120e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008120e": "FUNC_0008120e"
            },
            "calling": [
                "init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081210": {
            "entrypoint": "0x00081210",
            "current_name": "configure_pin_00081210",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_00081210(uint32_t pinNumber,uint32_t pinMode)\n\n{\n  undefined4 pinConfig;\n  byte pinStatus1;\n  byte pinStatus2;\n  Pio_conflict *port;\n  \n  if (pinDescriptionArray[pinNumber].pinNumberType != PIO_NOT_A_PIN) {\n    if ((pinStatusArray[pinNumber] & 0xf) == 4) {\n      adc_disable_channel(0x400c0000,pinDescriptionArray[pinNumber].ulADCChannelNumber);\n    }\n    pinStatus2 = pinStatusArray[pinNumber];\n    pinStatus1 = pinStatus2 & 0xf;\n    if ((pinStatus1 < 3) && (pinStatus2 != 0)) {\n      if (pinStatus1 == 2) {\n        if (pinMode == 0) {\n          return;\n        }\n      }\n      else if (pinStatus1 == 1) {\n        if (pinMode == 2) {\n          return;\n        }\n      }\n      else if (pinStatus1 == 3) {\n        if (pinMode == 1) {\n          return;\n        }\n        goto LAB_0008126c;\n      }\n    }\n    if (pinMode != 1) {\nLAB_0008126c:\n      if (pinMode == 0) {\n        pmc_enable_periph_clk(pinDescriptionArray[pinNumber].ulPeripheralId);\n        PIO_Configure(pinDescriptionArray[pinNumber].pPort,3,pinDescriptionArray[pinNumber].pinNumber,0);\n        pinStatus2 = pinStatusArray[pinNumber] & 0xf0 | 2;\n      }\n      else {\n        if (pinMode != 2) {\n          return;\n        }\n        pmc_enable_periph_clk(pinDescriptionArray[pinNumber].ulPeripheralId);\n        PIO_Configure(pinDescriptionArray[pinNumber].pPort,3,pinDescriptionArray[pinNumber].pinNumber,1);\n        pinStatus2 = pinStatusArray[pinNumber] & 0xf0 | 1;\n      }\n      pinStatusArray[pinNumber] = pinStatus2;\n      return;\n    }\n    port = pinDescriptionArray[pinNumber].pPort;\n    if (pinStatus2 >> 4 == 0) {\n      pinConfig = 4;\n    }\n    else {\n      pinConfig = 5;\n    }\n    PIO_Configure(port,pinConfig,pinDescriptionArray[pinNumber].pinNumber,\n                  pinDescriptionArray[pinNumber].pinNumberConfiguration);\n    pinStatusArray[pinNumber] = pinStatusArray[pinNumber] & 0xf0 | 3;\n    if (port->PIO_OSR == 0xffffffff) {\n      pmc_disable_periph_clk(pinDescriptionArray[pinNumber].ulPeripheralId);\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081210": "configure_pin_00081210",
                "ulPin": "pinNumber",
                "ulMode": "pinMode",
                "uVar1": "pinConfig",
                "bVar2": "pinStatus1",
                "bVar3": "pinStatus2",
                "pPVar4": "port",
                "g_APinDescription": "pinDescriptionArray",
                "g_pinStatus": "pinStatusArray"
            },
            "calling": [
                "setup",
                "begin",
                "digitalWrite"
            ],
            "called": [
                "PIO_Configure",
                "pmc_disable_periph_clk",
                "adc_disable_channel",
                "pmc_enable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081318": {
            "entrypoint": "0x00081318",
            "current_name": "configure_pin_00081318",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid configurePin_00081318(uint32_t pinNumber,uint32_t pinValue)\n\n{\n  int outputDataStatus;\n  uint32_t pin;\n  Pio_conflict *pinDescription;\n  uint32_t newPinValue;\n  \n  if (g_APinDescription[pinNumber].pinNumberType != PIO_NOT_A_PIN) {\n    newPinValue = pinValue;\n    if ((g_pinStatus[pinNumber] & 0xf) == 5) {\n      pinMode(pinNumber,1);\n    }\n    g_pinStatus[pinNumber] = g_pinStatus[pinNumber] & 0xf | (byte)(pinValue << 4);\n    pinDescription = g_APinDescription[pinNumber].pPort;\n    pin = g_APinDescription[pinNumber].pinNumber;\n    outputDataStatus = PIO_GetOutputDataStatus(pinDescription,pin);\n    if (outputDataStatus == 0) {\n      PIO_PullUp(pinDescription,pin,pinValue);\n      return;\n    }\n    PIO_SetOutput(pinDescription,pin,pinValue,0,1,newPinValue);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081318": "configure_pin_00081318",
                "ulPin": "pinNumber",
                "ulVal": "pinValue",
                "iVar1": "outputDataStatus",
                "uVar2": "pin",
                "uVar4": "newPinValue",
                "pPVar3": "pinDescription"
            },
            "calling": [
                "getRxBuffer",
                "sendTxBuffer",
                "setup",
                "init",
                "begin"
            ],
            "called": [
                "pinMode",
                "PIO_SetOutput",
                "PIO_PullUp",
                "PIO_GetOutputDataStatus"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081388": {
            "entrypoint": "0x00081388",
            "current_name": "check_and_invoke_banzai_00081388",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid checkAndInvokeBanzai_00081388(void)\n\n{\n  if ((currentTickCount != -1) && (currentTickCount = currentTickCount + -1, currentTickCount == 0)) {\n    performBanzai();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081388": "check_and_invoke_banzai_00081388",
                "ticks": "currentTickCount",
                "banzai": "performBanzai"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "banzai"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813a8": {
            "entrypoint": "0x000813a8",
            "current_name": "initialize_ring_buffer_000813a8",
            "code": "\n/* DWARF original prototype: RingBuffer *  RingBuffer(RingBuffer * ringBuffer) */\n\nRingBuffer * __ringBuffercall RingBuffer::initializeRingBuffer_000813a8(RingBuffer *ringBuffer)\n\n{\n  memset(ringBuffer,0,0x80);\n  ringBuffer->headIndex = 0;\n  ringBuffer->tailIndex = 0;\n  return ringBuffer;\n}\n\n",
            "renaming": {
                "this": "ringBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "FUN_000813a8": "initialize_ring_buffer_000813a8"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813c2": {
            "entrypoint": "0x000813c2",
            "current_name": "store_char_000813c2",
            "code": "\n/* DWARF orheadgheadnal prototype: voheadd  store_char_000813c2(RheadngBuffer * buffer, uheadnt8_t c) */\n\nvoheadd __buffercall RheadngBuffer::store_char_000813c2(RheadngBuffer *buffer,uheadnt8_t c)\n\n{\n  headnt head;\n  uheadnt newHead;\n  \n  head = buffer->headIndex;\n  newHead = head + 1U & 0x7f;\n  headf (newHead != buffer->tailIndex) {\n    buffer->bufferData[buffer->headIndex] = c;\n    buffer->headIndex = newHead;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813c2": "store_char_000813c2",
                "this": "buffer",
                "i": "head",
                "uVar1": "newHead",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_aucBuffer": "bufferData"
            },
            "calling": [
                "IrqHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813e0": {
            "entrypoint": "0x000813e0",
            "current_name": "is_uart_class_instance_valid_000813e0",
            "code": "\n/* DWARF original name: operator bool\n   DWARF original prototype: bool  operator_bool(UARTClass * this_UARTInstance) */\n\nbool __this_UARTInstancecall UARTClass::is_UARTClass_instance_valid_000813e0(UARTClass *this_UARTInstance)\n\n{\n  return true;\n}\n\n",
            "renaming": {
                "FUN_000813e0": "is_uart_class_instance_valid_000813e0",
                "this": "this_UARTInstance"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813e4": {
            "entrypoint": "0x000813e4",
            "current_name": "calculate_available_data_000813e4",
            "code": "\n/* DWARF original prototype: int  available(UARTClass * uartInstance) */\n\nint __uartInstancecall UARTClass::calculateAvailableData_000813e4(UARTClass *uartInstance)\n\n{\n  return uartInstance->receiveBuffer->headIndex - uartInstance->receiveBuffer->tailIndex & 0x7f;\n}\n\n",
            "renaming": {
                "FUN_000813e4": "calculate_available_data_000813e4",
                "this": "uartInstance",
                "_rx_buffer": "receiveBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813f6": {
            "entrypoint": "0x000813f6",
            "current_name": "get_peek_value_000813f6",
            "code": "\n/* DWARF original prototype: int  peek(UARTClass * uartObject) */\n\nint __uartObjectcall UARTClass::getPeekValue_000813f6(UARTClass *uartObject)\n\n{\n  uint peekValue;\n  RingBuffer *rxBuffer;\n  \n  rxBuffer = uartObject->_rx_buffer;\n  if (rxBuffer->_iHead == rxBuffer->_iTail) {\n    peekValue = 0xffffffff;\n  }\n  else {\n    peekValue = (uint)rxBuffer->_aucBuffer[rxBuffer->_iTail];\n  }\n  return peekValue;\n}\n\n",
            "renaming": {
                "FUN_000813f6": "get_peek_value_000813f6",
                "this": "uartObject",
                "pRVar2": "rxBuffer",
                "uVar1": "peekValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081412": {
            "entrypoint": "0x00081412",
            "current_name": "read_byte_from_uart_00081412",
            "code": "\n/* DWARF original prototype: int  read(UARTClass * uartObject) */\n\nssize_t __uartObjectcall UARTClass::readByteFromUART_00081412(UARTClass *uartObject,int fileDescriptor,void *buffer,size_t numBytes)\n\n{\n  dataByte byteValue;\n  unsignedChar uc;\n  Buffer *rxBuffer;\n  \n  rxBuffer = uartObject->rxBuffer;\n  if (rxBuffer->headIndex != rxBuffer->tailIndex) {\n    byteValue = rxBuffer->bufferArray[rxBuffer->tailIndex];\n    rxBuffer->tailIndex = rxBuffer->tailIndex + 1U & 0x7f;\n    return (uint)byteValue;\n  }\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_00081412": "read_byte_from_uart_00081412",
                "this": "uartObject",
                "__fd": "fileDescriptor",
                "__buf": "buffer",
                "__nbytes": "numBytes",
                "byte": "dataByte",
                "uint8_t": "unsignedChar",
                "RingBuffer": "Buffer",
                "pRVar2": "rxBuffer",
                "_rx_buffer": "rxBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_aucBuffer": "bufferArray",
                "bVar1": "byteValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008143c": {
            "entrypoint": "0x0008143c",
            "current_name": "wait_until_transmit_complete_0008143c",
            "code": "\n/* DWARF original prototype: void  flush(UARTClass * uart) */\n\nvoid __uartcall UARTClass::waitUntilTransmitComplete_0008143c(UARTClass *uart)\n\n{\n  do {\n  } while (uart->transmitBuffer->headIndex != uart->transmitBuffer->tailIndex);\n  do {\n  } while (-1 < (int)(uart->uartPort->statusRegister << 0x16));\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008143c": "wait_until_transmit_complete_0008143c",
                "this": "uart",
                "_tx_buffer": "transmitBuffer",
                "_iHead": "headIndex",
                "_iTail": "tailIndex",
                "_pUart": "uartPort",
                "UART_SR": "statusRegister"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081454": {
            "entrypoint": "0x00081454",
            "current_name": "write_uart_data_00081454",
            "code": "\n/* DWARF original prototype: size_t  write(UARTClass * this, uint8_t uc_data) */\n\nssize_t UARTClass UARTClass::write_uart_data_00081454(UARTClass *this,int file_descriptor,void *buffer,size_t size)\n\n{\n  RingBuffer *ring_buffer;\n  uint new_head;\n  \n  ring_buffer = this->transmit_buffer;\n  if (((int)(this->uart_pointer->uart_status_register << 0x1e) < 0) && (ring_buffer->tail_index == ring_buffer->head_index)) {\n    this->uart_pointer->UART_THR = file_descriptor;\n  }\n  else {\n    new_head = ring_buffer->head_index + 1U & 0x8000007f;\n    if ((int)new_head < 0) {\n      new_head = (new_head - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (ring_buffer->tail_index == new_head);\n    ring_buffer->buffer_data[ring_buffer->head_index] = (uchar)file_descriptor;\n    this->transmit_buffer->head_index = new_head;\n    this->uart_pointer->interrupt_enable_register = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00081454": "write_uart_data_00081454",
                "__thiscall": "UARTClass",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "size",
                "pRVar1": "ring_buffer",
                "uVar2": "new_head",
                "_tx_buffer": "transmit_buffer",
                "_pUart": "uart_pointer",
                "UART_SR": "uart_status_register",
                "_iTail": "tail_index",
                "_iHead": "head_index",
                "_aucBuffer": "buffer_data",
                "UART_IER": "interrupt_enable_register"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814a8": {
            "entrypoint": "0x000814a8",
            "current_name": "end_uart_class_000814a8",
            "code": "\n/* DWARF original prototype: void  end(UARTClass * uartObj) */\n\nvoid __uartObjcall UARTClass::endUARTClass_000814a8(UARTClass *uartObj)\n\n{\n  uartObj->rxBuffer->inputHead = uartObj->rxBuffer->inputTail;\n  (**(code **)(*(int *)uartObj + 0x14))();\n  *(int *)((((uint)(int)uartObj->irq >> 5) + 0x20) * 4 + -0x1fff1f00) =\n       1 << (uint)(byte)(uartObj->irq & 0x1f);\n  disablePeripheralClock(uartObj->id);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000814a8": "end_uart_class_000814a8",
                "this": "uartObj",
                "_rx_buffer": "rxBuffer",
                "_iHead": "inputHead",
                "_iTail": "inputTail",
                "_dwIrq": "irq",
                "pmc_disable_periph_clk": "disablePeripheralClock",
                "_dwId": "id"
            },
            "calling": [],
            "called": [
                "pmc_disable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814e4": {
            "entrypoint": "0x000814e4",
            "current_name": "initialize_uart_class_000814e4",
            "code": "\n/* DWARF original prototype: UARTClass *  UARTClass(UARTClass * uartInstance, Uart * uart, IRQn_Type interruptType,\n   uint32_t identifier, RingBuffer * receiveBuffer, RingBuffer * transmitBuffer) */\n\nUARTClass * __uartInstancecall\nUARTClass::initializeUARTClass_000814e4(UARTClass *uartInstance,Uart *uart,IRQn_Type interruptType,uint32_t identifier,RingBuffer *receiveBuffer,\n          RingBuffer *transmitBuffer)\n\n{\n  *(undefined4 *)&uartInstance->field_0x4 = 0;\n  *(undefined4 *)&uartInstance->field_0x8 = 1000;\n  uartInstance->_uart = uart;\n  *(undefined ***)uartInstance = &PTR_write_1_000857a8;\n  uartInstance->_interruptType = interruptType;\n  uartInstance->_rx_buffer = receiveBuffer;\n  uartInstance->_identifier = identifier;\n  uartInstance->_tx_buffer = transmitBuffer;\n  return uartInstance;\n}\n\n",
            "renaming": {
                "this": "uartInstance",
                "pUart": "uart",
                "dwIrq": "interruptType",
                "dwId": "identifier",
                "pRx_buffer": "receiveBuffer",
                "pTx_buffer": "transmitBuffer",
                "FUN_000814e4": "initialize_uart_class_000814e4"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription",
                "USARTClass"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081508": {
            "entrypoint": "0x00081508",
            "current_name": "initialize_uart_00081508",
            "code": "\n/* DWARF original prototype: void  init(UARTClass * uartInstance, uint32_t dwBaudRate, uint32_t modeReg) */\n\nint __uartInstancecall UARTClass::initializeUART_00081508(UARTClass *uartInstance,EVP_PKEY_CTX *evpContext)\n\n{\n  uint irqGroup;\n  RingBuffer *rxBuffer;\n  RwReg modeRegister;\n  Uart *uartPeripheral;\n  \n  pmc_enable_periph_clk(uartInstance->_dwId);\n  uartPeripheral = uartInstance->_pUart;\n  uartPeripheral->UART_PTCR = 0x202;\n  uartPeripheral->UART_CR = 0xac;\n  uartPeripheral->UART_MR = modeRegister;\n  uartPeripheral->UART_BRGR = SystemCoreClock / (uint)evpContext >> 4;\n  uartPeripheral->UART_IDR = 0xffffffff;\n  uartPeripheral->UART_IER = 0x61;\n  irqGroup = (uint)(int)uartInstance->_dwIrq >> 5;\n  *(int *)(irqGroup * 4 + -0x1fff1f00) = 1 << (uint)(byte)(uartInstance->_dwIrq & 0x1f);\n  rxBuffer = uartInstance->_rx_buffer;\n  rxBuffer->_iTail = 0;\n  rxBuffer->_iHead = 0;\n  rxBuffer = uartInstance->_tx_buffer;\n  rxBuffer->_iTail = 0;\n  rxBuffer->_iHead = 0;\n  uartPeripheral->UART_CR = 0x50;\n  return irqGroup;\n}\n\n",
            "renaming": {
                "FUN_00081508": "initialize_uart_00081508",
                "this": "uartInstance",
                "ctx": "evpContext",
                "uVar1": "irqGroup",
                "pRVar2": "rxBuffer",
                "in_r2": "modeRegister",
                "pUVar3": "uartPeripheral"
            },
            "calling": [
                "begin",
                "begin"
            ],
            "called": [
                "pmc_enable_periph_clk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081578": {
            "entrypoint": "0x00081578",
            "current_name": "initialize_uart_00081578",
            "code": "\n/* DWARF original prototype: void  begin(UARTClass * uartObject, uint32_t baudRate) */\n\nvoid __uartObjectcall UARTClass::initializeUART_00081578(UARTClass *uartObject,uint32_t baudRate)\n\n{\n  init(uartObject,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081578": "initialize_uart_00081578",
                "this": "uartObject",
                "dwBaudRate": "baudRate"
            },
            "calling": [],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081580": {
            "entrypoint": "0x00081580",
            "current_name": "handle_interrupt_00081580",
            "code": "\n/* DWARF original prototype: void  IrqHandler(UARTClass * uartInstance) */\n\nvoid __uartInstancecall UARTClass::handleInterrupt_00081580(UARTClass *uartInstance)\n\n{\n  RingBuffer *txBuffer;\n  uint32_t uartStatus;\n  RoReg uartSR;\n  \n  uartSR = uartInstance->_pUart->UART_SR;\n  if ((int)(uartSR << 0x1f) < 0) {\n    RingBuffer::store_char(uartInstance->_rx_buffer,(uint8_t)uartInstance->_pUart->UART_RHR);\n  }\n  if ((int)(uartSR << 0x1e) < 0) {\n    txBuffer = uartInstance->_tx_buffer;\n    if (txBuffer->_iTail != txBuffer->_iHead) {\n      uartInstance->_pUart->UART_THR = (uint)txBuffer->_aucBuffer[txBuffer->_iTail];\n      txBuffer->_iTail = txBuffer->_iTail + 1U & 0x7f;\n      return;\n    }\n    uartInstance->_pUart->UART_IDR = 2;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081580": "handle_interrupt_00081580",
                "this": "uartInstance",
                "pRVar1": "txBuffer",
                "status": "uartStatus",
                "RVar2": "uartSR"
            },
            "calling": [
                "USART1_Handler",
                "UART_Handler",
                "USART3_Handler",
                "USART0_Handler"
            ],
            "called": [
                "store_char"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815ca": {
            "entrypoint": "0x000815ca",
            "current_name": "initialize_usart_000815ca",
            "code": "\n/* DWARF original prototype: void  begin(USARTClass * usart, uint32_t baudRate) */\n\nvoid __usartcall USARTClass::initializeUSART_000815ca(USARTClass *usart,uint32_t baudRate)\n\n{\n  UARTClass::init(&usart->super_UARTClass,(EVP_PKEY_CTX *)baudRate);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000815ca": "initialize_usart_000815ca",
                "this": "usart",
                "dwBaudRate": "baudRate"
            },
            "calling": [],
            "called": [
                "init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815d4": {
            "entrypoint": "0x000815d4",
            "current_name": "initialize_usart_class_000815d4",
            "code": "\n/* DWARF original prototype: USARTClass *  USARTClass(USARTClass * usartObject, Usart * usartPointer, IRQn_Type\n   irqNumber, uint32_t deviceId, RingBuffer * receiveBuffer, RingBuffer * transmitBuffer) */\n\nUSARTClass * __usartObjectcall\nUSARTClass::initializeUSARTClass_000815d4(USARTClass *usartObject,Usart *usartPointer,IRQn_Type irqNumber,uint32_t deviceId,RingBuffer *receiveBuffer,\n          RingBuffer *transmitBuffer)\n\n{\n  initializeUartClass(&usartObject->super_UartClass,(Uart *)usartPointer,irqNumber,deviceId,receiveBuffer,transmitBuffer);\n  *(undefined ***)&usartObject->super_UartClass = &PTR_write_1_000857d8;\n  usartObject->privateUsartPointer = usartPointer;\n  return usartObject;\n}\n\n",
            "renaming": {
                "this": "usartObject",
                "pUsart": "usartPointer",
                "dwIrq": "irqNumber",
                "dwId": "deviceId",
                "pRx_buffer": "receiveBuffer",
                "pTx_buffer": "transmitBuffer",
                "UARTClass": "UartClass",
                "UARTClass::UARTClass": "initializeUartClass",
                "_pUsart": "privateUsartPointer",
                "FUN_000815d4": "initialize_usart_class_000815d4"
            },
            "calling": [
                "_GLOBAL__sub_I_g_APinDescription"
            ],
            "called": [
                "UARTClass"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815f8": {
            "entrypoint": "0x000815f8",
            "current_name": "concatenate_bytes_000815f8",
            "code": "\n/* WARNING: Unknown calowBytelowByteing convention */\n\nuint16_t concatenateBytes_000815f8(uint8_t highByte,uint8_t lowByte)\n\n{\n  return CONCAT11(highByte,lowByte);\n}\n\n",
            "renaming": {
                "FUN_000815f8": "concatenate_bytes_000815f8",
                "h": "highByte",
                "l": "lowByte"
            },
            "calling": [
                "get_FC3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815fe": {
            "entrypoint": "0x000815fe",
            "current_name": "free_buffer_000815fe",
            "code": "\n/* DWARF original prototype: void *  ~String(String * strObj, int unusedParam) */\n\nvoid * __strObjcall String::freeBuffer_000815fe(String *strObj,int unusedParam)\n\n{\n  free(strObj->buffer);\n  return strObj;\n}\n\n",
            "renaming": {
                "this": "strObj",
                "__in_chrg": "unusedParam",
                "FUN_000815fe": "free_buffer_000815fe"
            },
            "calling": [],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008160c": {
            "entrypoint": "0x0008160c",
            "current_name": "clear_string_buffer_0008160c",
            "code": "\n/* DWARF original prototype: void  invalidate(String * str) */\n\nvoid __strcall String::clearStringBuffer_0008160c(String *str)\n\n{\n  if (str->buffer != (char *)0x0) {\n    free(str->buffer);\n  }\n  str->buffer = (char *)0x0;\n  str->len = 0;\n  str->capacity = 0;\n  return;\n}\n\n",
            "renaming": {
                "this": "str",
                "FUN_0008160c": "clear_string_buffer_0008160c"
            },
            "calling": [
                "copy"
            ],
            "called": [
                "free"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081622": {
            "entrypoint": "0x00081622",
            "current_name": "resize_buffer_00081622",
            "code": "\n/* DWARF original prototype: uchar  changeBuffer(String * strObject, uint newMaxStrLen) */\n\nuchar __strObjectcall String::resizeBuffer_00081622(String *strObject,uint newMaxStrLen)\n\n{\n  char *newBuffer;\n  char *newbuffer;\n  \n  newBuffer = (char *)realloc(strObject->buffer,newMaxStrLen + 1);\n  if (newBuffer != (char *)0x0) {\n    strObject->buffer = newBuffer;\n    strObject->capacity = newMaxStrLen;\n    newBuffer = (char *)0x1;\n  }\n  return (uchar)newBuffer;\n}\n\n",
            "renaming": {
                "this": "strObject",
                "maxStrLen": "newMaxStrLen",
                "pcVar1": "newBuffer",
                "FUN_00081622": "resize_buffer_00081622"
            },
            "calling": [
                "reserve"
            ],
            "called": [
                "realloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008163a": {
            "entrypoint": "0x0008163a",
            "current_name": "reserve_memory_0008163a",
            "code": "\n/* DWARF original prototype: uchar  reserve(String * strObj, uint newSize) */\n\nuchar __strObjcall String::reserveMemory_0008163a(String *strObj,uint newSize)\n\n{\n  uchar success;\n  \n  if ((strObj->buffer == (char *)0x0) || (strObj->capacity < newSize)) {\n    success = resizeBuffer(strObj,newSize);\n    if (success == '\\0') {\n      return '\\0';\n    }\n    if (strObj->len == 0) {\n      *strObj->buffer = '\\0';\n    }\n  }\n  return '\\x01';\n}\n\n",
            "renaming": {
                "FUN_0008163a": "reserve_memory_0008163a",
                "this": "strObj",
                "size": "newSize",
                "uVar1": "success",
                "changeBuffer": "resizeBuffer"
            },
            "calling": [
                "copy"
            ],
            "called": [
                "changeBuffer"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008165c": {
            "entrypoint": "0x0008165c",
            "current_name": "copy_string_0008165c",
            "code": "\n/* DWARF original prototype: String *  copy(String * strObj, char * cstr, uint length) */\n\nint __strObjcall String::copyString_0008165c(String *strObj,EVP_PKEY_CTX *srcKey,EVP_PKEY_CTX *dstKey)\n\n{\n  uchar reserveSuccess;\n  \n  reserveSuccess = reserve(strObj,(uint)dstKey);\n  if (reserveSuccess == '\\0') {\n    invalidate(strObj);\n  }\n  else {\n    strObj->len = (uint)dstKey;\n    strcpy(strObj->buffer,(char *)srcKey);\n  }\n  return (int)strObj;\n}\n\n",
            "renaming": {
                "this": "strObj",
                "dst": "srcKey",
                "src": "dstKey",
                "uVar1": "reserveSuccess",
                "FUN_0008165c": "copy_string_0008165c"
            },
            "calling": [
                "String"
            ],
            "called": [
                "reserve",
                "invalidate",
                "strcpy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081682": {
            "entrypoint": "0x00081682",
            "current_name": "initialize_string_00081682",
            "code": "\n/* DWARF original prototype: String *  String(String * strObj, char * cString) */\n\nString * __strObjcall String::initializeString_00081682(String *strObj,char *cString)\n\n{\n  EVP_PKEY_CTX *stringLength;\n  \n  strObj->buffer = (char *)0x0;\n  strObj->capacity = 0;\n  strObj->len = 0;\n  if (cString != (char *)0x0) {\n    stringLength = (EVP_PKEY_CTX *)strlen(cString);\n    copy(strObj,(EVP_PKEY_CTX *)cString,stringLength);\n  }\n  return strObj;\n}\n\n",
            "renaming": {
                "this": "strObj",
                "cstr": "cString",
                "src": "stringLength",
                "FUN_00081682": "initialize_string_00081682"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "strlen",
                "copy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816a6": {
            "entrypoint": "0x000816a6",
            "current_name": "FUNC_000816a6",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid FUNC_000816a6(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816a6": "FUNC_000816a6"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000816a8": {
            "entrypoint": "0x000816a8",
            "current_name": "main_loop_000816a8",
            "code": "\n/* WARNING: Unknown calling convention */\n\nint mainLoop_000816a8(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  setupWatchdog();\n  initialize(ctx);\n  initializeVariant();\n  wait(1);\n  setupEnvironment();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000816a8": "main_loop_000816a8",
                "in_r0": "ctx",
                "_watchdogDefaultSetup": "setupWatchdog",
                "init": "initialize",
                "initVariant": "initializeVariant",
                "delay": "wait",
                "setup": "setupEnvironment",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "initVariant",
                "_watchdogDefaultSetup",
                "serialEventRun",
                "setup",
                "loop",
                "init",
                "delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d4": {
            "entrypoint": "0x000816d4",
            "current_name": "disable_watchdog_000816d4",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableWatchdog_000816d4(void)\n\n{\n  disableWatchdog_000816d4Timer(0x400e1a50);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816d4": "disable_watchdog_000816d4",
                "WDT_Disable": "disableWatchdogTimer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "WDT_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816e0": {
            "entrypoint": "0x000816e0",
            "current_name": "write_to_buffer_000816e0",
            "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x000816f6 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * print_object, uint8_t * buffer, size_t size) */\n\nssize_t __print_objectcall Print::write_to_buffer_000816e0(Print *print_object,int file_descriptor,void *buffer,size_t buffer_size)\n\n{\n  Print *updated_print_object;\n  void *current_position;\n  \n  current_position = (void *)0x0;\n  updated_print_object = print_object;\n  while ((current_position != buffer &&\n         (updated_print_object = (Print *)(**print_object->_vptr_Print)(updated_print_object,(uint)*(byte *)(file_descriptor + (int)current_position)),\n         updated_print_object != (Print *)0x0))) {\n    current_position = (void *)((int)current_position + 1);\n  }\n  return (ssize_t)current_position;\n}\n\n",
            "renaming": {
                "this": "print_object",
                "__fd": "file_descriptor",
                "__buf": "buffer",
                "__n": "buffer_size",
                "pvVar2": "current_position",
                "pPVar1": "updated_print_object",
                "FUN_000816e0": "write_to_buffer_000816e0"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081704": {
            "entrypoint": "0x00081704",
            "current_name": "increment_tick_count_00081704",
            "code": "\nvoid incrementTickCount_00081704(void)\n\n{\n  tickCount = tickCount + 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081704": "increment_tick_count_00081704",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081714": {
            "entrypoint": "0x00081714",
            "current_name": "get_tick_count_00081714",
            "code": "\nundefined4 getTickCount_00081714(void)\n\n{\n  return tickCount;\n}\n\n",
            "renaming": {
                "FUN_00081714": "get_tick_count_00081714",
                "_dwTickCount": "tickCount"
            },
            "calling": [
                "millis"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081720": {
            "entrypoint": "0x00081720",
            "current_name": "initialize_memory_00081720",
            "code": "\nvoid initializeMemory_00081720(int memoryAddress)\n\n{\n  *(undefined4 *)(memoryAddress + 4) = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081720": "initialize_memory_00081720",
                "param_1": "memoryAddress"
            },
            "calling": [
                "_watchdogDefaultSetup"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081728": {
            "entrypoint": "0x00081728",
            "current_name": "convert_to_negative_float_00081728",
            "code": "\nvoid convertToNegativeFloat_00081728(uint inputValue)\n\n{\n  __addsf3(inputValue ^ 0x80000000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081728": "convert_to_negative_float_00081728",
                "param_1": "inputValue"
            },
            "calling": [],
            "called": [
                "__addsf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081730": {
            "entrypoint": "0x00081730",
            "current_name": "calculate_squared_root_00081730",
            "code": "\nuint calculate_squared_root_00081730(uint input_1,uint input_2,undefined4 input_3,uint input_4)\n\n{\n  int shifted_input_1;\n  int shifted_input_2;\n  uint temp_var_1;\n  uint temp_var_2;\n  uint result_1;\n  uint result_2;\n  uint temp_var_3;\n  bool flag;\n  \n  temp_var_1 = input_2 ^ 0x80000000;\n  result_1 = input_1 << 1;\n  flag = result_1 == 0;\n  if (!flag) {\n    input_4 = input_2 << 1;\n    flag = input_4 == 0;\n  }\n  if (!flag) {\n    flag = result_1 == input_4;\n  }\n  shifted_input_1 = (int)result_1 >> 0x18;\n  if (!flag) {\n    flag = shifted_input_1 == -1;\n  }\n  if (!flag) {\n    flag = (int)input_4 >> 0x18 == -1;\n  }\n  if (flag) {\n    shifted_input_2 = (int)(input_2 << 1) >> 0x18;\n    if (shifted_input_1 == -1 || shifted_input_2 == -1) {\n      result_1 = temp_var_1;\n      if (shifted_input_1 == -1) {\n        result_1 = input_1;\n      }\n      if (shifted_input_1 != -1 || shifted_input_2 != -1) {\n        temp_var_1 = result_1;\n      }\n      flag = (result_1 & 0x7fffff) == 0;\n      if (flag) {\n        flag = (temp_var_1 & 0x7fffff) == 0;\n      }\n      if (flag) {\n        flag = result_1 == temp_var_1;\n      }\n      if (!flag) {\n        result_1 = result_1 | 0x400000;\n      }\n      return result_1;\n    }\n    if (((input_1 ^ temp_var_1) & 0x7fffffff) != 0) {\n      if (result_1 == 0) {\n        input_1 = temp_var_1;\n      }\n      return input_1;\n    }\n    if (input_1 != temp_var_1) {\n      return 0;\n    }\n    if ((result_1 & 0xff000000) == 0) {\n      temp_var_1 = input_1 << 1;\n      if ((input_1 & 0x80000000) != 0) {\n        temp_var_1 = temp_var_1 | 0x80000000;\n      }\n      return temp_var_1;\n    }\n    if (result_1 < 0xfe000000) {\n      return input_1 + 0x800000;\n    }\n    input_1 = input_1 & 0x80000000;\nLAB_0008186a:\n    return input_1 | 0x7f800000;\n  }\n  result_1 = result_1 >> 0x18;\n  input_4 = input_4 >> 0x18;\n  temp_var_3 = input_4 - result_1;\n  flag = temp_var_3 != 0;\n  result_2 = result_1;\n  if (flag && result_1 <= input_4) {\n    result_2 = result_1 + temp_var_3;\n  }\n  if (flag && result_1 <= input_4) {\n    temp_var_1 = temp_var_1 ^ input_1;\n  }\n  if (flag && result_1 <= input_4) {\n    input_1 = input_1 ^ temp_var_1;\n  }\n  if (flag && result_1 <= input_4) {\n    temp_var_1 = temp_var_1 ^ input_1;\n  }\n  if (input_4 < result_1) {\n    temp_var_3 = -temp_var_3;\n  }\n  if (0x19 < temp_var_3) {\n    return input_1;\n  }\n  result_1 = input_1 & 0xffffff | 0x800000;\n  if ((input_1 & 0x80000000) != 0) {\n    result_1 = -result_1;\n  }\n  temp_var_2 = temp_var_1 & 0xffffff | 0x800000;\n  if ((temp_var_1 & 0x80000000) != 0) {\n    temp_var_2 = -temp_var_2;\n  }\n  if (result_2 == temp_var_3) {\n    temp_var_2 = temp_var_2 ^ 0x800000;\n    if (result_2 == 0) {\n      result_1 = result_1 ^ 0x800000;\n      result_2 = 1;\n    }\n    else {\n      temp_var_3 = temp_var_3 - 1;\n    }\n  }\n  result_1 = result_1 + ((int)temp_var_2 >> (temp_var_3 & 0xff));\n  temp_var_2 = temp_var_2 << (0x20 - temp_var_3 & 0xff);\n  input_1 = result_1 & 0x80000000;\n  if ((int)result_1 < 0) {\n    flag = temp_var_2 != 0;\n    temp_var_2 = -temp_var_2;\n    result_1 = -result_1 - (uint)flag;\n  }\n  if (result_1 < 0x800000) {\n    temp_var_1 = temp_var_2 & 0x80000000;\n    temp_var_2 = temp_var_2 << 1;\n    result_1 = result_1 * 2 + (uint)(temp_var_1 != 0);\n    temp_var_1 = result_2 - 2;\n    if ((result_1 & 0x800000) == 0) {\n      temp_var_3 = LZCOUNT(result_1) - 8;\n      result_1 = result_1 << (temp_var_3 & 0xff);\n      if ((int)temp_var_1 < (int)temp_var_3) {\n        result_1 = result_1 >> (-(temp_var_1 - temp_var_3) & 0xff);\n      }\n      else {\n        result_1 = result_1 + (temp_var_1 - temp_var_3) * 0x800000;\n      }\n      return result_1 | input_1;\n    }\n  }\n  else {\n    temp_var_1 = result_2 - 1;\n    if (0xffffff < result_1) {\n      temp_var_1 = result_1 & 1;\n      result_1 = result_1 >> 1;\n      temp_var_2 = (uint)(temp_var_1 != 0) << 0x1f | temp_var_2 >> 1;\n      temp_var_1 = result_2;\n      if (0xfd < result_2) goto LAB_0008186a;\n    }\n  }\n  result_1 = result_1 + temp_var_1 * 0x800000 + (uint)(0x7fffffff < temp_var_2);\n  if (temp_var_2 == 0x80000000) {\n    result_1 = result_1 & 0xfffffffe;\n  }\n  return result_1 | input_1;\n}\n\n",
            "renaming": {
                "FUN_00081730": "calculate_squared_root_00081730",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shifted_input_1",
                "iVar2": "shifted_input_2",
                "uVar3": "temp_var_1",
                "uVar4": "temp_var_2",
                "uVar5": "result_1",
                "uVar6": "result_2",
                "uVar7": "temp_var_3",
                "bVar8": "flag"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081734": {
            "entrypoint": "0x00081734",
            "current_name": "calculate_float_00081734",
            "code": "\nuint calculateFloat_00081734(uint floatValue1,uint floatValue2,undefined4 undefinedValue,uint resultValue)\n\n{\n  int shiftedValue1;\n  int shiftedValue2;\n  uint absShiftedValue1;\n  uint absShiftedValue2;\n  uint absShiftedValue;\n  uint difference;\n  bool isEqual;\n  \n  absShiftedValue2 = floatValue1 << 1;\n  isEqual = absShiftedValue2 == 0;\n  if (!isEqual) {\n    resultValue = floatValue2 << 1;\n    isEqual = resultValue == 0;\n  }\n  if (!isEqual) {\n    isEqual = absShiftedValue2 == resultValue;\n  }\n  shiftedValue1 = (int)absShiftedValue2 >> 0x18;\n  if (!isEqual) {\n    isEqual = shiftedValue1 == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)resultValue >> 0x18 == -1;\n  }\n  if (isEqual) {\n    shiftedValue2 = (int)(floatValue2 << 1) >> 0x18;\n    if (shiftedValue1 == -1 || shiftedValue2 == -1) {\n      absShiftedValue2 = floatValue2;\n      if (shiftedValue1 == -1) {\n        absShiftedValue2 = floatValue1;\n      }\n      if (shiftedValue1 != -1 || shiftedValue2 != -1) {\n        floatValue2 = absShiftedValue2;\n      }\n      isEqual = (absShiftedValue2 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (floatValue2 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = absShiftedValue2 == floatValue2;\n      }\n      if (!isEqual) {\n        absShiftedValue2 = absShiftedValue2 | 0x400000;\n      }\n      return absShiftedValue2;\n    }\n    if (((floatValue1 ^ floatValue2) & 0x7fffffff) != 0) {\n      if (absShiftedValue2 == 0) {\n        floatValue1 = floatValue2;\n      }\n      return floatValue1;\n    }\n    if (floatValue1 != floatValue2) {\n      return 0;\n    }\n    if ((absShiftedValue2 & 0xff000000) == 0) {\n      absShiftedValue2 = floatValue1 << 1;\n      if ((floatValue1 & 0x80000000) != 0) {\n        absShiftedValue2 = absShiftedValue2 | 0x80000000;\n      }\n      return absShiftedValue2;\n    }\n    if (absShiftedValue2 < 0xfe000000) {\n      return floatValue1 + 0x800000;\n    }\n    floatValue1 = floatValue1 & 0x80000000;\nLAB_0008186a:\n    return floatValue1 | 0x7f800000;\n  }\n  absShiftedValue2 = absShiftedValue2 >> 0x18;\n  resultValue = resultValue >> 0x18;\n  difference = resultValue - absShiftedValue2;\n  isEqual = difference != 0;\n  absShiftedValue = absShiftedValue2;\n  if (isEqual && absShiftedValue2 <= resultValue) {\n    absShiftedValue = absShiftedValue2 + difference;\n  }\n  if (isEqual && absShiftedValue2 <= resultValue) {\n    floatValue2 = floatValue2 ^ floatValue1;\n  }\n  if (isEqual && absShiftedValue2 <= resultValue) {\n    floatValue1 = floatValue1 ^ floatValue2;\n  }\n  if (isEqual && absShiftedValue2 <= resultValue) {\n    floatValue2 = floatValue2 ^ floatValue1;\n  }\n  if (resultValue < absShiftedValue2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return floatValue1;\n  }\n  absShiftedValue2 = floatValue1 & 0xffffff | 0x800000;\n  if ((floatValue1 & 0x80000000) != 0) {\n    absShiftedValue2 = -absShiftedValue2;\n  }\n  absShiftedValue1 = floatValue2 & 0xffffff | 0x800000;\n  if ((floatValue2 & 0x80000000) != 0) {\n    absShiftedValue1 = -absShiftedValue1;\n  }\n  if (absShiftedValue == difference) {\n    absShiftedValue1 = absShiftedValue1 ^ 0x800000;\n    if (absShiftedValue == 0) {\n      absShiftedValue2 = absShiftedValue2 ^ 0x800000;\n      absShiftedValue = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  absShiftedValue2 = absShiftedValue2 + ((int)absShiftedValue1 >> (difference & 0xff));\n  absShiftedValue1 = absShiftedValue1 << (0x20 - difference & 0xff);\n  floatValue1 = absShiftedValue2 & 0x80000000;\n  if ((int)absShiftedValue2 < 0) {\n    isEqual = absShiftedValue1 != 0;\n    absShiftedValue1 = -absShiftedValue1;\n    absShiftedValue2 = -absShiftedValue2 - (uint)isEqual;\n  }\n  if (absShiftedValue2 < 0x800000) {\n    difference = absShiftedValue1 & 0x80000000;\n    absShiftedValue1 = absShiftedValue1 << 1;\n    absShiftedValue2 = absShiftedValue2 * 2 + (uint)(difference != 0);\n    difference = absShiftedValue - 2;\n    if ((absShiftedValue2 & 0x800000) == 0) {\n      absShiftedValue = LZCOUNT(absShiftedValue2) - 8;\n      absShiftedValue2 = absShiftedValue2 << (absShiftedValue & 0xff);\n      if ((int)difference < (int)absShiftedValue) {\n        absShiftedValue2 = absShiftedValue2 >> (-(difference - absShiftedValue) & 0xff);\n      }\n      else {\n        absShiftedValue2 = absShiftedValue2 + (difference - absShiftedValue) * 0x800000;\n      }\n      return absShiftedValue2 | floatValue1;\n    }\n  }\n  else {\n    difference = absShiftedValue - 1;\n    if (0xffffff < absShiftedValue2) {\n      difference = absShiftedValue2 & 1;\n      absShiftedValue2 = absShiftedValue2 >> 1;\n      absShiftedValue1 = (uint)(difference != 0) << 0x1f | absShiftedValue1 >> 1;\n      difference = absShiftedValue;\n      if (0xfd < absShiftedValue) goto LAB_0008186a;\n    }\n  }\n  absShiftedValue2 = absShiftedValue2 + difference * 0x800000 + (uint)(0x7fffffff < absShiftedValue1);\n  if (absShiftedValue1 == 0x80000000) {\n    absShiftedValue2 = absShiftedValue2 & 0xfffffffe;\n  }\n  return absShiftedValue2 | floatValue1;\n}\n\n",
            "renaming": {
                "FUN_00081734": "calculate_float_00081734",
                "param_1": "floatValue1",
                "param_2": "floatValue2",
                "param_3": "undefinedValue",
                "param_4": "resultValue",
                "iVar1": "shiftedValue1",
                "iVar2": "shiftedValue2",
                "uVar3": "absShiftedValue1",
                "uVar4": "absShiftedValue2",
                "uVar5": "absShiftedValue",
                "uVar6": "difference",
                "bVar7": "isEqual"
            },
            "calling": [
                "loop",
                "__aeabi_frsub"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081894": {
            "entrypoint": "0x00081894",
            "current_name": "calculate_shifted_value_00081894",
            "code": "\nuint calculateShiftedValue_00081894(uint inputValue)\n\n{\n  uint leadingZeros;\n  uint shiftAmount;\n  int baseValue;\n  uint result;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZeros = LZCOUNT(inputValue);\n  shiftAmount = leadingZeros - 8;\n  baseValue = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZeros) {\n    result = 0 << (shiftAmount & 0xff);\n    leadingZeros = baseValue + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < result);\n    if (result == 0x80000000) {\n      leadingZeros = leadingZeros & 0xfffffffe;\n    }\n    return leadingZeros;\n  }\n  shiftAmount = inputValue << leadingZeros + 0x18;\n  leadingZeros = baseValue + ((inputValue >> (0x20 - (leadingZeros + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZeros = leadingZeros & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_00081894": "calculate_shifted_value_00081894",
                "param_1": "inputValue",
                "uVar1": "leadingZeros",
                "uVar2": "shiftAmount",
                "iVar3": "baseValue",
                "uVar4": "result"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008189c": {
            "entrypoint": "0x0008189c",
            "current_name": "reverse_integer_bits_0008189c",
            "code": "\nuint reverse_integer_bits_0008189c(uint input)\n\n{\n  uint leading_zero_count;\n  uint shift_amount;\n  uint sign_bit;\n  int offset;\n  \n  sign_bit = input & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  leading_zero_count = LZCOUNT(input);\n  shift_amount = leading_zero_count - 8;\n  offset = ((sign_bit | 0x4b000000) - 0x800000) + shift_amount * -0x800000;\n  if (7 < leading_zero_count) {\n    leading_zero_count = 0 << (shift_amount & 0xff);\n    sign_bit = offset + (input << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < leading_zero_count);\n    if (leading_zero_count == 0x80000000) {\n      sign_bit = sign_bit & 0xfffffffe;\n    }\n    return sign_bit;\n  }\n  shift_amount = input << leading_zero_count + 0x18;\n  sign_bit = offset + ((input >> (0x20 - (leading_zero_count + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    sign_bit = sign_bit & ~(shift_amount >> 0x1f);\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_0008189c": "reverse_integer_bits_0008189c",
                "param_1": "input",
                "uVar1": "leading_zero_count",
                "uVar2": "shift_amount",
                "uVar3": "sign_bit",
                "iVar4": "offset"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000818b8": {
            "entrypoint": "0x000818b8",
            "current_name": "calculate_adjusted_value_000818b8",
            "code": "\nuint calculateAdjustedValue_000818b8(uint value1,uint value2)\n\n{\n  uint adjustedValue1;\n  uint adjustedValue2;\n  uint shiftAmount;\n  uint shiftedValue;\n  int baseValue;\n  \n  if ((value1 | value2) == 0) {\n    return value1;\n  }\n  adjustedValue1 = value1;\n  adjustedValue2 = value2;\n  if (value2 == 0) {\n    adjustedValue1 = 0;\n    adjustedValue2 = value1;\n  }\n  baseValue = 0x5b000000;\n  if (value2 == 0) {\n    baseValue = 0x4b000000;\n  }\n  shiftAmount = LZCOUNT(adjustedValue2);\n  shiftedValue = shiftAmount - 8;\n  baseValue = baseValue + -0x800000 + shiftedValue * -0x800000;\n  if (shiftAmount < 8) {\n    shiftedValue = adjustedValue2 << shiftAmount + 0x18;\n    adjustedValue2 = baseValue + ((adjustedValue2 >> (0x20 - (shiftAmount + 0x18) & 0xff)) - ((int)shiftedValue >> 0x1f));\n    if ((adjustedValue1 | shiftedValue << 1) == 0) {\n      adjustedValue2 = adjustedValue2 & ~(shiftedValue >> 0x1f);\n    }\n    return adjustedValue2;\n  }\n  shiftAmount = adjustedValue1 << (shiftedValue & 0xff);\n  adjustedValue2 = baseValue + (adjustedValue2 << (shiftedValue & 0xff)) +\n          (adjustedValue1 >> (0x20 - shiftedValue & 0xff)) + (uint)(0x7fffffff < shiftAmount);\n  if (shiftAmount == 0x80000000) {\n    adjustedValue2 = adjustedValue2 & 0xfffffffe;\n  }\n  return adjustedValue2;\n}\n\n",
            "renaming": {
                "FUN_000818b8": "calculate_adjusted_value_000818b8",
                "param_1": "value1",
                "param_2": "value2",
                "uVar1": "adjustedValue1",
                "uVar2": "adjustedValue2",
                "uVar3": "shiftAmount",
                "uVar4": "shiftedValue",
                "iVar5": "baseValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000818c8": {
            "entrypoint": "0x000818c8",
            "current_name": "calculate_result_000818c8",
            "code": "\nuint calculateResult_000818c8(uint input1,uint input2)\n\n{\n  uint absInput2;\n  uint input1Copy;\n  uint leadingZeroes;\n  uint shiftAmount;\n  uint result;\n  int tempVar;\n  bool isInput1NonZero;\n  \n  if ((input1 | input2) == 0) {\n    return input1;\n  }\n  result = input2 & 0x80000000;\n  if ((int)result < 0) {\n    isInput1NonZero = input1 != 0;\n    input1 = -input1;\n    input2 = -input2 - (uint)isInput1NonZero;\n  }\n  input1Copy = input1;\n  absInput2 = input2;\n  if (input2 == 0) {\n    input1Copy = 0;\n    absInput2 = input1;\n  }\n  result = result | 0x5b000000;\n  if (input2 == 0) {\n    result = result + 0xf0000000;\n  }\n  leadingZeroes = LZCOUNT(absInput2);\n  shiftAmount = leadingZeroes - 8;\n  tempVar = (result - 0x800000) + shiftAmount * -0x800000;\n  if (leadingZeroes < 8) {\n    shiftAmount = absInput2 << leadingZeroes + 0x18;\n    result = tempVar + ((absInput2 >> (0x20 - (leadingZeroes + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n    if ((input1Copy | shiftAmount << 1) == 0) {\n      result = result & ~(shiftAmount >> 0x1f);\n    }\n    return result;\n  }\n  leadingZeroes = input1Copy << (shiftAmount & 0xff);\n  result = tempVar + (absInput2 << (shiftAmount & 0xff)) +\n          (input1Copy >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < leadingZeroes);\n  if (leadingZeroes == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000818c8": "calculate_result_000818c8",
                "param_1": "input1",
                "param_2": "input2",
                "uVar1": "absInput2",
                "uVar2": "input1Copy",
                "uVar3": "leadingZeroes",
                "uVar4": "shiftAmount",
                "uVar5": "result",
                "iVar6": "tempVar",
                "bVar7": "isInput1NonZero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081944": {
            "entrypoint": "0x00081944",
            "current_name": "calculate_float_value_00081944",
            "code": "\nuint calculateFloatValue_00081944(uint inputValue1,uint inputValue2,undefined4 undefinedValue,uint inputValue3)\n\n{\n  longlong product;\n  uint result;\n  uint shiftValue1;\n  int sum;\n  int difference1;\n  uint lowerBits;\n  int difference2;\n  uint modifiedInput;\n  bool isZero;\n  bool isCarry;\n  \n  shiftValue1 = inputValue1 >> 0x17 & 0xff;\n  isZero = shiftValue1 == 0;\n  if (!isZero) {\n    inputValue3 = inputValue2 >> 0x17 & 0xff;\n    isZero = inputValue3 == 0;\n  }\n  if (!isZero) {\n    isZero = shiftValue1 == 0xff;\n  }\n  if (!isZero) {\n    isZero = inputValue3 == 0xff;\n  }\n  if (isZero) {\n    inputValue3 = inputValue2 >> 0x17 & 0xff;\n    if (shiftValue1 == 0xff || inputValue3 == 0xff) {\n      isZero = inputValue1 == 0 || inputValue1 == 0x80000000;\n      result = inputValue2;\n      if (inputValue1 != 0 && inputValue1 != 0x80000000) {\n        isZero = inputValue2 == 0;\n        result = inputValue1;\n      }\n      if (!isZero) {\n        isZero = inputValue2 == 0x80000000;\n      }\n      modifiedInput = result;\n      if (((isZero) || ((shiftValue1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((inputValue3 == 0xff && (modifiedInput = inputValue2, (inputValue2 & 0x7fffff) != 0)))) {\n        return modifiedInput | 0x7fc00000;\n      }\n      result = result ^ inputValue2;\n      goto LAB_00081a94;\n    }\n    isZero = (inputValue1 & 0x7fffffff) == 0;\n    if (!isZero) {\n      isZero = (inputValue2 & 0x7fffffff) == 0;\n    }\n    if (isZero) {\n      return (inputValue1 ^ inputValue2) & 0x80000000;\n    }\n    isZero = shiftValue1 == 0;\n    result = inputValue1 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        inputValue1 = inputValue1 << 1;\n        isZero = (inputValue1 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      shiftValue1 = shiftValue1 - 1;\n    }\n    inputValue1 = inputValue1 | result;\n    isZero = inputValue3 == 0;\n    result = inputValue2 & 0x80000000;\n    while( true ) {\n      if (isZero) {\n        inputValue2 = inputValue2 << 1;\n        isZero = (inputValue2 & 0x800000) == 0;\n      }\n      if (!isZero) break;\n      inputValue3 = inputValue3 - 1;\n    }\n    inputValue2 = inputValue2 | result;\n  }\n  sum = shiftValue1 + inputValue3;\n  modifiedInput = inputValue1 ^ inputValue2;\n  shiftValue1 = inputValue1 << 9;\n  isZero = shiftValue1 == 0;\n  if (!isZero) {\n    inputValue2 = inputValue2 << 9;\n    isZero = inputValue2 == 0;\n  }\n  if (isZero) {\n    if (shiftValue1 == 0) {\n      inputValue2 = inputValue2 << 9;\n    }\n    result = modifiedInput & 0x80000000 | inputValue1 & 0x7fffff | inputValue2 >> 9;\n    isCarry = SBORROW4(sum,0x7f);\n    difference1 = sum + -0x7f;\n    isZero = difference1 == 0;\n    difference2 = difference1;\n    if (!isZero && 0x7e < sum) {\n      isCarry = SBORROW4(0xff,difference1);\n      difference2 = 0xff - difference1;\n      isZero = difference1 == 0xff;\n    }\n    if (!isZero && difference2 < 0 == isCarry) {\n      result = result | difference1 * 0x800000;\n    }\n    if (!isZero && difference2 < 0 == isCarry) {\n      return result;\n    }\n    result = result | 0x800000;\n    lowerBits = 0;\n    isCarry = SBORROW4(difference1,1);\n    modifiedInput = sum - 0x80;\n    isZero = modifiedInput == 0;\n    shiftValue1 = modifiedInput;\n  }\n  else {\n    product = (ulonglong)(shiftValue1 >> 5 | 0x8000000) * (ulonglong)(inputValue2 >> 5 | 0x8000000);\n    lowerBits = (uint)product;\n    result = (uint)((ulonglong)product >> 0x20);\n    isZero = result < 0x800000;\n    if (isZero) {\n      result = result << 1;\n    }\n    if (isZero) {\n      result = result | lowerBits >> 0x1f;\n      lowerBits = lowerBits << 1;\n    }\n    result = modifiedInput & 0x80000000 | result;\n    modifiedInput = (sum + -0x7f) - (uint)isZero;\n    isCarry = SBORROW4(modifiedInput,0xfd);\n    isZero = modifiedInput == 0xfd;\n    shiftValue1 = modifiedInput - 0xfd;\n    if (modifiedInput < 0xfe) {\n      result = result + modifiedInput * 0x800000 + (uint)(0x7fffffff < lowerBits);\n      if (lowerBits == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZero || (int)shiftValue1 < 0 != isCarry) {\n    isZero = (int)(modifiedInput + 0x19) < 0;\n    if (modifiedInput == 0xffffffe7 || isZero != SCARRY4(modifiedInput,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (modifiedInput != 0xffffffe7 && isZero == SCARRY4(modifiedInput,0x19)) {\n      shiftValue1 = (result << 1) >> (-modifiedInput & 0xff);\n      modifiedInput = result << (modifiedInput + 0x20 & 0xff);\n      shiftValue1 = ((uint)((result & 0x80000000) != 0) << 0x1f | shiftValue1 >> 1) + (uint)((byte)shiftValue1 & 1);\n      if ((lowerBits | modifiedInput << 1) == 0) {\n        shiftValue1 = shiftValue1 & ~(modifiedInput >> 0x1f);\n      }\n      return shiftValue1;\n    }\n    return result;\n  }\nLAB_00081a94:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_00081944": "calculate_float_value_00081944",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "param_3": "undefinedValue",
                "param_4": "inputValue3",
                "lVar1": "product",
                "uVar2": "result",
                "uVar3": "shiftValue1",
                "iVar4": "sum",
                "iVar5": "difference1",
                "uVar6": "lowerBits",
                "iVar7": "difference2",
                "uVar8": "modifiedInput",
                "bVar9": "isZero",
                "bVar10": "isCarry"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081aac": {
            "entrypoint": "0x00081aac",
            "current_name": "calculate_float_00081aac",
            "code": "\nuint calculateFloat_00081aac(uint input1,uint input2,undefined4 unused,uint input3)\n\n{\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  uint result;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  \n  temp2 = input1 >> 0x17 & 0xff;\n  condition1 = temp2 == 0;\n  if (!condition1) {\n    input3 = input2 >> 0x17 & 0xff;\n    condition1 = input3 == 0;\n  }\n  if (!condition1) {\n    condition1 = temp2 == 0xff;\n  }\n  if (!condition1) {\n    condition1 = input3 == 0xff;\n  }\n  if (condition1) {\n    input3 = input2 >> 0x17 & 0xff;\n    result = input1;\n    if (temp2 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (result = input2, input3 == 0xff)) {\nLAB_00081aa2:\n        return result | 0x7fc00000;\n      }\n    }\n    else {\n      if (input3 == 0xff) {\n        result = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_00081a58:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_00081aa2;\n      }\n      condition1 = (input1 & 0x7fffffff) == 0;\n      if (!condition1) {\n        condition1 = (input2 & 0x7fffffff) == 0;\n      }\n      if (!condition1) {\n        condition1 = temp2 == 0;\n        result = input1 & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            input1 = input1 << 1;\n            condition1 = (input1 & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          temp2 = temp2 - 1;\n        }\n        input1 = input1 | result;\n        condition1 = input3 == 0;\n        result = input2 & 0x80000000;\n        while( true ) {\n          if (condition1) {\n            input2 = input2 << 1;\n            condition1 = (input2 & 0x800000) == 0;\n          }\n          if (!condition1) break;\n          input3 = input3 - 1;\n        }\n        input2 = input2 | result;\n        goto LAB_00081ac4;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_00081a58;\n        goto LAB_00081aa2;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_00081ac4:\n    temp3 = temp2 - input3;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      condition3 = SCARRY4(temp3,0x7f);\n      temp5 = temp3 + 0x7f;\n      condition1 = temp5 < 0;\n      condition2 = temp5 == 0;\n      if (!condition2 && condition1 == condition3) {\n        condition3 = SBORROW4(0xff,temp5);\n        condition1 = 0xff - temp5 < 0;\n        condition2 = temp5 == 0xff;\n      }\n      if (!condition2 && condition1 == condition3) {\n        input1 = input1 | temp5 * 0x800000;\n      }\n      if (!condition2 && condition1 == condition3) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      temp2 = 0;\n      condition2 = SBORROW4(temp5,1);\n      temp4 = temp3 + 0x7e;\n      condition1 = temp4 == 0;\n      result = temp4;\n    }\n    else {\n      temp1 = (input2 << 9) >> 4 | 0x10000000;\n      temp2 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      condition1 = temp1 <= temp2;\n      if (!condition1) {\n        temp2 = temp2 << 1;\n      }\n      temp4 = temp3 + 0x7d + (uint)condition1;\n      result = 0x800000;\n      do {\n        if (temp1 <= temp2) {\n          temp2 = temp2 - temp1;\n          input1 = input1 | result;\n        }\n        condition1 = temp1 >> 1 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 1);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 1;\n        }\n        condition1 = temp1 >> 2 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 2);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 2;\n        }\n        condition1 = temp1 >> 3 <= temp2;\n        if (condition1) {\n          temp2 = temp2 - (temp1 >> 3);\n        }\n        if (condition1) {\n          input1 = input1 | result >> 3;\n        }\n        temp2 = temp2 * 0x10;\n        condition1 = temp2 == 0;\n        if (!condition1) {\n          result = result >> 4;\n          condition1 = result == 0;\n        }\n      } while (!condition1);\n      condition2 = SBORROW4(temp4,0xfd);\n      condition1 = temp4 == 0xfd;\n      result = temp4 - 0xfd;\n      if (temp4 < 0xfe) {\n        input1 = input1 + temp4 * 0x800000 + (uint)(temp1 <= temp2);\n        if (temp2 - temp1 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (condition1 || (int)result < 0 != condition2) {\n      condition1 = (int)(temp4 + 0x19) < 0;\n      if (temp4 == 0xffffffe7 || condition1 != SCARRY4(temp4,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (temp4 == 0xffffffe7 || condition1 != SCARRY4(temp4,0x19)) {\n        return input1;\n      }\n      result = (input1 << 1) >> (-temp4 & 0xff);\n      temp4 = input1 << (temp4 + 0x20 & 0xff);\n      result = ((uint)((input1 & 0x80000000) != 0) << 0x1f | result >> 1) + (uint)((byte)result & 1);\n      if ((temp2 | temp4 << 1) == 0) {\n        result = result & ~(temp4 >> 0x1f);\n      }\n      return result;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_00081aac": "calculate_float_00081aac",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "unused",
                "param_4": "input3",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "result",
                "bVar7": "condition1",
                "bVar8": "condition2",
                "bVar9": "condition3"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081be4": {
            "entrypoint": "0x00081be4",
            "current_name": "calculate_unsigned_divide_00081be4",
            "code": "\nuint calculate_unsigned_divide_00081be4(uint dividend,uint divisor)\n\n{\n  bool is_negative;\n  uint dividend_double;\n  uint divisor_double;\n  uint combined;\n  bool is_zero;\n  \n  dividend_double = dividend * 2;\n  divisor_double = divisor * 2;\n  if (((int)dividend_double >> 0x18 == -1 || (int)divisor_double >> 0x18 == -1) &&\n     ((((int)dividend_double >> 0x18 == -1 && ((dividend & 0x7fffff) != 0)) ||\n      (((int)divisor_double >> 0x18 == -1 && ((divisor & 0x7fffff) != 0)))))) {\n    return 0xffffffff;\n  }\n  combined = dividend_double | divisor & 0x7fffffff;\n  is_zero = combined == 0;\n  if (!is_zero) {\n    combined = dividend ^ divisor;\n    is_zero = combined == 0;\n  }\n  is_negative = -1 < (int)combined;\n  if (is_negative) {\n    dividend = dividend_double + divisor * -2;\n    is_zero = dividend == 0;\n  }\n  if ((is_negative && divisor_double <= dividend_double) && !is_zero) {\n    dividend = (int)divisor >> 0x1f;\n  }\n  if (!is_negative || divisor_double > dividend_double) {\n    dividend = ~((int)divisor >> 0x1f);\n  }\n  if (!is_zero) {\n    dividend = dividend | 1;\n  }\n  return dividend;\n}\n\n",
            "renaming": {
                "FUN_00081be4": "calculate_unsigned_divide_00081be4",
                "param_1": "dividend",
                "param_2": "divisor",
                "uVar2": "dividend_double",
                "uVar3": "divisor_double",
                "uVar4": "combined",
                "bVar1": "is_negative",
                "bVar5": "is_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081bec": {
            "entrypoint": "0x00081bec",
            "current_name": "calculate_result_00081bec",
            "code": "\nuint calculate_result_00081bec(uint input_1,uint input_2)\n\n{\n  bool is_negative_result;\n  uint input_1_doubled;\n  uint input_2_doubled;\n  uint bitwise_or_result;\n  bool is_bitwise_or_result_zero;\n  \n  input_1_doubled = input_1 * 2;\n  input_2_doubled = input_2 * 2;\n  if (((int)input_1_doubled >> 0x18 == -1 || (int)input_2_doubled >> 0x18 == -1) &&\n     ((((int)input_1_doubled >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_doubled >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  bitwise_or_result = input_1_doubled | input_2 & 0x7fffffff;\n  is_bitwise_or_result_zero = bitwise_or_result == 0;\n  if (!is_bitwise_or_result_zero) {\n    bitwise_or_result = input_1 ^ input_2;\n    is_bitwise_or_result_zero = bitwise_or_result == 0;\n  }\n  is_negative_result = -1 < (int)bitwise_or_result;\n  if (is_negative_result) {\n    input_1 = input_1_doubled + input_2 * -2;\n    is_bitwise_or_result_zero = input_1 == 0;\n  }\n  if ((is_negative_result && input_2_doubled <= input_1_doubled) && !is_bitwise_or_result_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative_result || input_2_doubled > input_1_doubled) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_bitwise_or_result_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_00081bec": "calculate_result_00081bec",
                "param_1": "input_1",
                "param_2": "input_2",
                "bVar1": "is_negative_result",
                "uVar2": "input_1_doubled",
                "uVar3": "input_2_doubled",
                "uVar4": "bitwise_or_result",
                "bVar5": "is_bitwise_or_result_zero"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081bf4": {
            "entrypoint": "0x00081bf4",
            "current_name": "calculate_result_00081bf4",
            "code": "\nuint calculate_result_00081bf4(uint input_1,uint input_2)\n\n{\n  bool is_negative_result;\n  uint input_1_doubled;\n  uint input_2_doubled;\n  uint combined_inputs;\n  bool is_zero_result;\n  \n  input_1_doubled = input_1 * 2;\n  input_2_doubled = input_2 * 2;\n  if (((int)input_1_doubled >> 0x18 == -1 || (int)input_2_doubled >> 0x18 == -1) &&\n     ((((int)input_1_doubled >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_doubled >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_inputs = input_1_doubled | input_2 & 0x7fffffff;\n  is_zero_result = combined_inputs == 0;\n  if (!is_zero_result) {\n    combined_inputs = input_1 ^ input_2;\n    is_zero_result = combined_inputs == 0;\n  }\n  is_negative_result = -1 < (int)combined_inputs;\n  if (is_negative_result) {\n    input_1 = input_1_doubled + input_2 * -2;\n    is_zero_result = input_1 == 0;\n  }\n  if ((is_negative_result && input_2_doubled <= input_1_doubled) && !is_zero_result) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_negative_result || input_2_doubled > input_1_doubled) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero_result) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_00081bf4": "calculate_result_00081bf4",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "input_1_doubled",
                "uVar3": "input_2_doubled",
                "uVar4": "combined_inputs",
                "bVar1": "is_negative_result",
                "bVar5": "is_zero_result"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c54": {
            "entrypoint": "0x00081c54",
            "current_name": "compare_floats_00081c54",
            "code": "\nvoid compareFloats_00081c54(undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cfcmpeq(value2,value1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081c54": "compare_floats_00081c54",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpgt",
                "__aeabi_fcmpge"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c5c": {
            "entrypoint": "0x00081c5c",
            "current_name": "concatenate_uint32_00081c5c",
            "code": "\nundefined8 concatenateUint32_00081c5c(undefined4 input1,undefined4 input2)\n\n{\n  __cmpsf2();\n  return CONCAT44(input2,input1);\n}\n\n",
            "renaming": {
                "FUN_00081c5c": "concatenate_uint32_00081c5c",
                "param_1": "input1",
                "param_2": "input2"
            },
            "calling": [
                "__aeabi_fcmpeq",
                "__aeabi_cfrcmple",
                "__aeabi_fcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c6c": {
            "entrypoint": "0x00081c6c",
            "current_name": "check_equality_00081c6c",
            "code": "\nbool check_equality_00081c6c(void)\n\n{\n  char input_character;\n  \n  __aeabi_cfcmpeq();\n  return input_character != '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081c6c": "check_equality_00081c6c",
                "in_ZR": "input_character"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c80": {
            "entrypoint": "0x00081c80",
            "current_name": "is_cy_character_zero_00081c80",
            "code": "\nbool is_cy_character_zero_00081c80(void)\n\n{\n  char cy_character;\n  \n  compare_floats();\n  return cy_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081c80": "is_cy_character_zero_00081c80",
                "in_CY": "cy_character",
                "__aeabi_cfcmpeq": "compare_floats"
            },
            "calling": [],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081c94": {
            "entrypoint": "0x00081c94",
            "current_name": "compare_floats_00081c94",
            "code": "\nbool compareFloats_00081c94(void)\n\n{\n  undefined isZero;\n  undefined isCompared;\n  \n  __aeabi_cfcmpeq();\n  return !(bool)isCompared || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_00081c94": "compare_floats_00081c94",
                "in_ZR": "isZero",
                "in_CY": "isCompared"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081ca8": {
            "entrypoint": "0x00081ca8",
            "current_name": "is_sum_less_than_or_equal_to_zero_00081ca8",
            "code": "\nbool isSumLessThanOrEqualToZero_00081ca8(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cfrcmple();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_00081ca8": "is_sum_less_than_or_equal_to_zero_00081ca8",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081cbc": {
            "entrypoint": "0x00081cbc",
            "current_name": "check_if_input_empty_00081cbc",
            "code": "\nbool check_if_input_empty_00081cbc(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_00081cbc": "check_if_input_empty_00081cbc",
                "in_CY": "input_char"
            },
            "calling": [],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081cd0": {
            "entrypoint": "0x00081cd0",
            "current_name": "transform_number_00081cd0",
            "code": "\nuint transformNumber_00081cd0(uint inputNumber)\n\n{\n  uint shiftedNumber;\n  uint shiftValue;\n  \n  if (inputNumber << 1 < 0x7f000000) {\n    return 0;\n  }\n  shiftedNumber = (inputNumber << 1) >> 0x18;\n  shiftValue = 0x9e - shiftedNumber;\n  if (shiftedNumber < 0x9f && shiftValue != 0) {\n    shiftedNumber = (inputNumber << 8 | 0x80000000) >> (shiftValue & 0xff);\n    if ((inputNumber & 0x80000000) != 0) {\n      shiftedNumber = -shiftedNumber;\n    }\n    return shiftedNumber;\n  }\n  if ((shiftValue == 0xffffff9f) && ((inputNumber & 0x7fffff) != 0)) {\n    return 0;\n  }\n  inputNumber = inputNumber & 0x80000000;\n  if (inputNumber == 0) {\n    inputNumber = 0x7fffffff;\n  }\n  return inputNumber;\n}\n\n",
            "renaming": {
                "FUN_00081cd0": "transform_number_00081cd0",
                "param_1": "inputNumber",
                "uVar1": "shiftedNumber",
                "uVar2": "shiftValue"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d1c": {
            "entrypoint": "0x00081d1c",
            "current_name": "check_input_00081d1c",
            "code": "\nuint check_input_00081d1c(uint input_value)\n\n{\n  uint shift_amount;\n  \n  if (((input_value & 0x80000000) != 0) || (input_value << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shift_amount = 0x9e - ((input_value << 1) >> 0x18);\n  if (-1 < (int)shift_amount) {\n    return (input_value << 8 | 0x80000000) >> (shift_amount & 0xff);\n  }\n  if ((shift_amount == 0xffffff9f) && ((input_value & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00081d1c": "check_input_00081d1c",
                "param_1": "input_value",
                "uVar1": "shift_amount"
            },
            "calling": [
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d5c": {
            "entrypoint": "0x00081d5c",
            "current_name": "register_exit_handler_00081d5c",
            "code": "\nvoid registerExitHandler_00081d5c(undefined4 handlerFunc,undefined4 userData)\n\n{\n  __cxa_atexit(userData,handlerFunc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d5c": "register_exit_handler_00081d5c",
                "param_1": "handlerFunc",
                "param_2": "userData"
            },
            "calling": [
                "_GLOBAL__sub_I__ZN6ModbusC2Ev"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d68": {
            "entrypoint": "0x00081d68",
            "current_name": "register_exit_proc_00081d68",
            "code": "\nvoid registerExitProc_00081d68(undefined4 exitProcType,undefined4 param1,undefined4 param2)\n\n{\n  __register_exitproc(2,exitProcType,param1,param2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d68": "register_exit_proc_00081d68",
                "param_1": "exitProcType",
                "param_2": "param1",
                "param_3": "param2"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d7c": {
            "entrypoint": "0x00081d7c",
            "current_name": "execute_initialization_00081d7c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081d88) */\n/* WARNING: Removing unreachable block (ram,0x00081d8c) */\n/* WARNING: Removing unreachable block (ram,0x00081db8) */\n\nvoid executeInitialization_00081d7c(void)\n\n{\n  int iterationCount;\n  code **functionPointer;\n  \n  initialize();\n  functionPointer = (code **)0x85860;\n  iterationCount = 0;\n  do {\n    iterationCount = iterationCount + 1;\n    functionPointer = functionPointer + 1;\n    (**functionPointer)();\n  } while (iterationCount != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081d7c": "execute_initialization_00081d7c",
                "iVar1": "iterationCount",
                "ppcVar2": "functionPointer",
                "_init": "initialize"
            },
            "calling": [
                "init"
            ],
            "called": [
                "register_fini",
                "_init",
                "frame_dummy"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081dcc": {
            "entrypoint": "0x00081dcc",
            "current_name": "print_formatted_data_00081dcc",
            "code": "\nvoid printFormattedData_00081dcc(undefined4 formatString,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  undefined4 arg1_copy;\n  undefined4 arg2_copy;\n  undefined4 arg3_copy;\n  \n  arg1_copy = arg1;\n  arg2_copy = arg2;\n  arg3_copy = arg3;\n  _vfiprintf_r(_impure_ptr,*(undefined4 *)(_impure_ptr + 8),formatString,&arg1_copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081dcc": "print_formatted_data_00081dcc",
                "param_1": "formatString",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "uStack_c": "arg1_copy",
                "uStack_8": "arg2_copy",
                "uStack_4": "arg3_copy"
            },
            "calling": [
                "_exit"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081df4": {
            "entrypoint": "0x00081df4",
            "current_name": "allocate_memory_00081df4",
            "code": "\nvoid * allocateMemory_00081df4(size_t size)\n\n{\n  void *allocatedMemory;\n  \n  allocatedMemory = (void *)_malloc_r(_impure_ptr,size);\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_00081df4": "allocate_memory_00081df4",
                "__size": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "__register_exitproc"
            ],
            "called": [
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e04": {
            "entrypoint": "0x00081e04",
            "current_name": "free_memory_00081e04",
            "code": "\nvoid freeMemory_00081e04(void *memoryPtr)\n\n{\n  _free_r(_impure_ptr,memoryPtr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081e04": "free_memory_00081e04",
                "__ptr": "memoryPtr"
            },
            "calling": [
                "~String",
                "invalidate"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e14": {
            "entrypoint": "0x00081e14",
            "current_name": "allocate_memory_00081e14",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_00081e14(undefined4 *lock_param,uint size)\n\n{\n  undefined1 *pointer_1;\n  int i;\n  uint temp_var_1;\n  uint temp_var_2;\n  int temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  uint temp_var_6;\n  undefined4 *pointer_2;\n  undefined1 *pointer_3;\n  undefined1 *pointer_4;\n  undefined1 *pointer_5;\n  uint adjusted_size;\n  undefined4 *pointer_6;\n  undefined4 *pointer_7;\n  undefined1 *pointer_8;\n  \n  if (size + 0xb < 0x17) {\n    adjusted_size = 0x10;\n    if (0x10 < size) goto LAB_00081e7a;\n  }\n  else {\n    adjusted_size = size + 0xb & 0xfffffff8;\n    if (((int)adjusted_size < 0) || (adjusted_size < size)) {\nLAB_00081e7a:\n      *lock_param = 0xc;\n      return (int *)0x0;\n    }\n  }\n  __malloc_lock(lock_param);\n  pointer_6 = DAT_20070474;\n  if (adjusted_size < 0x1f8) {\n    pointer_5 = *(undefined1 **)((int)&DAT_20070470 + adjusted_size);\n    if ((pointer_5 != &__malloc_av_ + adjusted_size) ||\n       (pointer_4 = pointer_5 + 8, pointer_5 = *(undefined1 **)(pointer_5 + 0x14), pointer_4 != pointer_5)) {\n      temp_var_6 = *(uint *)(pointer_5 + 4);\n      temp_var_3 = *(int *)(pointer_5 + 0xc);\n      adjusted_size = *(uint *)(pointer_5 + (temp_var_6 & 0xfffffffc) + 4);\n      i = *(int *)(pointer_5 + 8);\n      *(int *)(i + 0xc) = temp_var_3;\n      *(int *)(temp_var_3 + 8) = i;\n      *(uint *)(pointer_5 + (temp_var_6 & 0xfffffffc) + 4) = adjusted_size | 1;\n      __malloc_unlock(lock_param);\n      return (int *)(pointer_5 + 8);\n    }\n    temp_var_6 = (adjusted_size >> 3) + 2;\n  }\n  else {\n    temp_var_6 = adjusted_size >> 9;\n    if (temp_var_6 == 0) {\n      temp_var_3 = 0x7e;\n      i = 0x3f;\n    }\n    else if (temp_var_6 < 5) {\n      i = (adjusted_size >> 6) + 0x38;\n      temp_var_3 = i * 2;\n    }\n    else if (temp_var_6 < 0x15) {\n      i = temp_var_6 + 0x5b;\n      temp_var_3 = i * 2;\n    }\n    else if (temp_var_6 < 0x55) {\n      i = (adjusted_size >> 0xc) + 0x6e;\n      temp_var_3 = i * 2;\n    }\n    else if (temp_var_6 < 0x155) {\n      i = (adjusted_size >> 0xf) + 0x77;\n      temp_var_3 = i * 2;\n    }\n    else if (temp_var_6 < 0x555) {\n      i = (adjusted_size >> 0x12) + 0x7c;\n      temp_var_3 = i * 2;\n    }\n    else {\n      temp_var_3 = 0xfc;\n      i = 0x7e;\n    }\n    for (pointer_5 = (undefined1 *)(&DAT_20070470)[temp_var_3]; &__malloc_av_ + temp_var_3 * 4 != pointer_5;\n        pointer_5 = *(undefined1 **)(pointer_5 + 0xc)) {\n      temp_var_6 = *(uint *)(pointer_5 + 4) & 0xfffffffc;\n      if (0xf < (int)(temp_var_6 - adjusted_size)) {\n        i = i + -1;\n        break;\n      }\n      if (-1 < (int)(temp_var_6 - adjusted_size)) {\n        adjusted_size = *(uint *)(pointer_5 + temp_var_6 + 4);\n        temp_var_3 = *(int *)(pointer_5 + 0xc);\n        i = *(int *)(pointer_5 + 8);\n        *(int *)(i + 0xc) = temp_var_3;\n        *(int *)(temp_var_3 + 8) = i;\n        *(uint *)(pointer_5 + temp_var_6 + 4) = adjusted_size | 1;\n        __malloc_unlock(lock_param);\n        return (int *)(pointer_5 + 8);\n      }\n    }\n    temp_var_6 = i + 1;\n  }\n  temp_var_1 = DAT_20070468;\n  if ((undefined1 **)DAT_20070474 != &DAT_2007046c) {\n    temp_var_1 = DAT_20070474[1];\n    temp_var_2 = temp_var_1 & 0xfffffffc;\n    temp_var_4 = temp_var_2 - adjusted_size;\n    if (0xf < (int)temp_var_4) {\n      pointer_7 = (undefined4 *)(adjusted_size + (int)DAT_20070474);\n      DAT_20070474[1] = adjusted_size | 1;\n      DAT_20070474 = pointer_7;\n      DAT_20070478 = pointer_7;\n      pointer_7[3] = &DAT_2007046c;\n      pointer_7[2] = &DAT_2007046c;\n      pointer_7[1] = temp_var_4 | 1;\n      *(uint *)((int)pointer_7 + temp_var_4) = temp_var_4;\n      __malloc_unlock(lock_param);\n      return pointer_6 + 2;\n    }\n    DAT_20070478 = &DAT_2007046c;\n    DAT_20070474 = &DAT_2007046c;\n    if (-1 < (int)temp_var_4) {\n      *(uint *)((int)pointer_6 + temp_var_2 + 4) = *(uint *)((int)pointer_6 + temp_var_2 + 4) | 1;\n      __malloc_unlock(lock_param);\n      return pointer_6 + 2;\n    }\n    if (temp_var_2 < 0x200) {\n      temp_var_2 = temp_var_1 & 0xfffffff8;\n      i = *(int *)((int)&DAT_2007046c + temp_var_2);\n      temp_var_1 = 1 << ((int)(temp_var_1 >> 3) >> 2 & 0xffU) | DAT_20070468;\n      pointer_6[2] = i;\n      pointer_6[3] = &__malloc_av_ + temp_var_2;\n      DAT_20070468 = temp_var_1;\n      *(undefined4 **)((int)&DAT_2007046c + temp_var_2) = pointer_6;\n      *(undefined4 **)(i + 0xc) = pointer_6;\n    }\n    else {\n      temp_var_4 = temp_var_1 >> 9;\n      if (temp_var_4 < 5) {\n        temp_var_3 = (temp_var_1 >> 6) + 0x38;\n        i = temp_var_3 * 2;\n      }\n      else if (temp_var_4 < 0x15) {\n        temp_var_3 = temp_var_4 + 0x5b;\n        i = temp_var_3 * 2;\n      }\n      else if (temp_var_4 < 0x55) {\n        temp_var_3 = (temp_var_1 >> 0xc) + 0x6e;\n        i = temp_var_3 * 2;\n      }\n      else if (temp_var_4 < 0x155) {\n        temp_var_3 = (temp_var_1 >> 0xf) + 0x77;\n        i = temp_var_3 * 2;\n      }\n      else if (temp_var_4 < 0x555) {\n        temp_var_3 = (temp_var_1 >> 0x12) + 0x7c;\n        i = temp_var_3 * 2;\n      }\n      else {\n        i = 0xfc;\n        temp_var_3 = 0x7e;\n      }\n      pointer_5 = (&DAT_2007046c)[i];\n      if (pointer_5 == &__malloc_av_ + i * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (temp_var_3 >> 2 & 0xffU);\n        pointer_4 = pointer_5;\n      }\n      else {\n        do {\n          pointer_4 = pointer_5;\n          if ((*(uint *)(pointer_5 + 4) & 0xfffffffc) <= temp_var_2) break;\n          pointer_5 = *(undefined1 **)(pointer_5 + 8);\n          pointer_4 = pointer_5;\n        } while (&__malloc_av_ + i * 4 != pointer_5);\n        pointer_5 = *(undefined1 **)(pointer_4 + 0xc);\n      }\n      temp_var_1 = DAT_20070468;\n      pointer_6[3] = pointer_5;\n      pointer_6[2] = pointer_4;\n      *(undefined4 **)(pointer_5 + 8) = pointer_6;\n      *(undefined4 **)(pointer_4 + 0xc) = pointer_6;\n    }\n  }\n  pointer_5 = DAT_2007046c;\n  temp_var_2 = 1 << ((int)temp_var_6 >> 2 & 0xffU);\n  if (temp_var_2 <= temp_var_1) {\n    if ((temp_var_1 & temp_var_2) == 0) {\n      temp_var_6 = temp_var_6 & 0xfffffffc;\n      do {\n        temp_var_2 = temp_var_2 << 1;\n        temp_var_6 = temp_var_6 + 4;\n      } while ((temp_var_1 & temp_var_2) == 0);\n    }\n    do {\n      pointer_7 = (undefined4 *)(&__malloc_av_ + temp_var_6 * 8);\n      pointer_6 = pointer_7;\n      temp_var_1 = temp_var_6;\n      do {\n        for (pointer_2 = (undefined4 *)pointer_6[3]; pointer_6 != pointer_2; pointer_2 = (undefined4 *)pointer_2[3])\n        {\n          temp_var_4 = pointer_2[1] & 0xfffffffc;\n          temp_var_5 = temp_var_4 - adjusted_size;\n          if (0xf < (int)temp_var_5) {\n            temp_var_3 = pointer_2[2];\n            i = pointer_2[3];\n            pointer_6 = (undefined4 *)(adjusted_size + (int)pointer_2);\n            pointer_2[1] = adjusted_size | 1;\n            *(int *)(temp_var_3 + 0xc) = i;\n            *(int *)(i + 8) = temp_var_3;\n            DAT_20070474 = pointer_6;\n            DAT_20070478 = pointer_6;\n            pointer_6[3] = &DAT_2007046c;\n            pointer_6[2] = &DAT_2007046c;\n            pointer_6[1] = temp_var_5 | 1;\n            *(uint *)((int)pointer_6 + temp_var_5) = temp_var_5;\n            __malloc_unlock(lock_param);\n            return pointer_2 + 2;\n          }\n          if (-1 < (int)temp_var_5) {\n            i = pointer_2[2];\n            temp_var_3 = pointer_2[3];\n            *(uint *)((int)pointer_2 + temp_var_4 + 4) = *(uint *)((int)pointer_2 + temp_var_4 + 4) | 1;\n            *(int *)(i + 0xc) = temp_var_3;\n            *(int *)(temp_var_3 + 8) = i;\n            __malloc_unlock(lock_param);\n            return pointer_2 + 2;\n          }\n        }\n        temp_var_1 = temp_var_1 + 1;\n        pointer_6 = pointer_6 + 2;\n      } while ((temp_var_1 & 3) != 0);\n      do {\n        temp_var_4 = temp_var_6 & 3;\n        pointer_6 = pointer_7 + -2;\n        temp_var_6 = temp_var_6 - 1;\n        if (temp_var_4 == 0) {\n          DAT_20070468 = DAT_20070468 & ~temp_var_2;\n          break;\n        }\n        pointer_7 = (undefined4 *)*pointer_7;\n      } while (pointer_7 == pointer_6);\n      temp_var_2 = temp_var_2 * 2;\n      if ((DAT_20070468 <= temp_var_2 && temp_var_2 - DAT_20070468 != 0) || (temp_var_6 = temp_var_1, temp_var_2 == 0))\n      break;\n      for (; (DAT_20070468 & temp_var_2) == 0; temp_var_2 = temp_var_2 << 1) {\n        temp_var_6 = temp_var_6 + 4;\n      }\n    } while( true );\n  }\n  temp_var_6 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  if ((adjusted_size <= temp_var_6) && (temp_var_1 = temp_var_6 - adjusted_size, pointer_4 = DAT_2007046c, 0xf < (int)temp_var_1))\n  goto LAB_0008211e;\n  pointer_8 = DAT_2007046c + temp_var_6;\n  if (__malloc_sbrk_base == (undefined1 *)0xffffffff) {\n    temp_var_1 = adjusted_size + __malloc_top_pad + 0x10;\n  }\n  else {\n    temp_var_1 = adjusted_size + __malloc_top_pad + 0x100f & 0xfffff000;\n  }\n  pointer_4 = (undefined1 *)_sbrk_r(lock_param,temp_var_1);\n  if ((pointer_4 == (undefined1 *)0xffffffff) || ((pointer_4 < pointer_8 && (pointer_5 != &__malloc_av_))))\n  {\n    temp_var_6 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    pointer_4 = DAT_2007046c;\n  }\n  else {\n    pointer_3 = __malloc_current_mallinfo + temp_var_1;\n    __malloc_current_mallinfo = pointer_3;\n    if ((pointer_8 == pointer_4) && (((uint)pointer_8 & 0xfff) == 0)) {\n      *(uint *)(DAT_2007046c + 4) = temp_var_1 + temp_var_6 | 1;\n    }\n    else {\n      pointer_1 = pointer_4;\n      if (__malloc_sbrk_base != (undefined1 *)0xffffffff) {\n        pointer_1 = __malloc_sbrk_base;\n        __malloc_current_mallinfo = pointer_3 + ((int)pointer_4 - (int)pointer_8);\n      }\n      __malloc_sbrk_base = pointer_1;\n      temp_var_2 = (uint)pointer_4 & 7;\n      if (temp_var_2 == 0) {\n        i = 0x1000;\n      }\n      else {\n        pointer_4 = pointer_4 + (8 - temp_var_2);\n        i = 0x1008 - temp_var_2;\n      }\n      i = i - ((uint)(pointer_4 + temp_var_1) & 0xfff);\n      temp_var_3 = _sbrk_r(lock_param,i);\n      if (temp_var_3 == -1) {\n        temp_var_1 = 1;\n        i = 0;\n      }\n      else {\n        temp_var_1 = (temp_var_3 - (int)pointer_4) + i | 1;\n      }\n      pointer_3 = __malloc_current_mallinfo + i;\n      DAT_2007046c = pointer_4;\n      __malloc_current_mallinfo = pointer_3;\n      *(uint *)(pointer_4 + 4) = temp_var_1;\n      if (pointer_5 != &__malloc_av_) {\n        if (temp_var_6 < 0x10) {\n          *(undefined4 *)(pointer_4 + 4) = 1;\n          temp_var_6 = 0;\n          goto LAB_00082108;\n        }\n        temp_var_6 = temp_var_6 - 0xc & 0xfffffff8;\n        *(uint *)(pointer_5 + 4) = temp_var_6 | *(uint *)(pointer_5 + 4) & 1;\n        *(undefined4 *)(pointer_5 + temp_var_6 + 4) = 5;\n        *(undefined4 *)(pointer_5 + temp_var_6 + 8) = 5;\n        if (0xf < temp_var_6) {\n          _free_r(lock_param,pointer_5 + 8);\n          pointer_3 = __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem < pointer_3) {\n      __malloc_max_sbrked_mem = pointer_3;\n    }\n    if (__malloc_max_total_mem < pointer_3) {\n      __malloc_max_total_mem = pointer_3;\n    }\n    temp_var_6 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n    pointer_4 = DAT_2007046c;\n  }\nLAB_00082108:\n  temp_var_1 = temp_var_6 - adjusted_size;\n  if ((temp_var_6 < adjusted_size) || ((int)temp_var_1 < 0x10)) {\n    __malloc_unlock(lock_param);\n    return (int *)0x0;\n  }\nLAB_0008211e:\n  DAT_2007046c = pointer_4 + adjusted_size;\n  *(uint *)(pointer_4 + 4) = adjusted_size | 1;\n  *(uint *)(DAT_2007046c + 4) = temp_var_1 | 1;\n  __malloc_unlock(lock_param);\n  return (int *)(pointer_4 + 8);\n}\n\n",
            "renaming": {
                "FUN_00081e14": "allocate_memory_00081e14",
                "param_1": "lock_param",
                "param_2": "size",
                "puVar1": "pointer_1",
                "iVar2": "i",
                "uVar3": "temp_var_1",
                "uVar4": "temp_var_2",
                "iVar5": "temp_var_3",
                "uVar6": "temp_var_4",
                "uVar7": "temp_var_5",
                "uVar8": "temp_var_6",
                "puVar9": "pointer_2",
                "puVar10": "pointer_3",
                "puVar11": "pointer_4",
                "puVar12": "pointer_5",
                "uVar13": "adjusted_size",
                "puVar14": "pointer_6",
                "puVar15": "pointer_7",
                "puVar16": "pointer_8"
            },
            "calling": [
                "malloc",
                "__sfvwrite_r",
                "_realloc_r",
                "__smakebuf_r"
            ],
            "called": [
                "__malloc_unlock",
                "_sbrk_r",
                "__malloc_lock",
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008234c": {
            "entrypoint": "0x0008234c",
            "current_name": "memmove_0008234c",
            "code": "\nvoid * memmove_0008234c(void *destination,void *source,size_t size)\n\n{\n  undefined *destPtr;\n  undefined4 *destInt32Ptr;\n  undefined4 *destInt32Ptr2;\n  undefined *destCharPtr;\n  undefined4 *srcInt32Ptr;\n  undefined *srcCharPtr;\n  uint remainingSize;\n  uint bytesToCopy;\n  bool isRemaining;\n  \n  destInt32Ptr2 = (undefined4 *)destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      bytesToCopy = size - 4;\n      destPtr = (undefined *)destination;\n      if (3 < size) {\n        do {\n          srcCharPtr = (undefined *)source;\n          destCharPtr = destPtr;\n          isRemaining = bytesToCopy != 0;\n          bytesToCopy = bytesToCopy - 1;\n          *destCharPtr = *srcCharPtr;\n          destPtr = destCharPtr + 1;\n          source = srcCharPtr + 1;\n        } while (isRemaining);\n        destCharPtr[1] = srcCharPtr[1];\n        destCharPtr[2] = srcCharPtr[2];\n        destCharPtr[3] = srcCharPtr[3];\n        return destination;\n      }\n      goto LAB_000823d0;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      bytesToCopy = 4 - ((uint)destination & 3);\n      size = size - bytesToCopy;\n      destInt32Ptr = (undefined4 *)destination;\n      srcInt32Ptr = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)destination & 1) != 0) {\n        srcInt32Ptr = (undefined4 *)((int)source + 1);\n        destInt32Ptr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *source;\n      }\n      destInt32Ptr2 = destInt32Ptr;\n      source = srcInt32Ptr;\n      if ((bytesToCopy & 2) != 0) {\n        source = (void *)((int)srcInt32Ptr + 2);\n        destInt32Ptr2 = (undefined4 *)((int)destInt32Ptr + 2);\n        *(undefined2 *)destInt32Ptr = *(undefined2 *)srcInt32Ptr;\n      }\n    }\n  }\n  while (0x3f < size) {\n                    /* WARNING: Load size is inaccurate */\n    *destInt32Ptr2 = *source;\n    destInt32Ptr2[1] = *(undefined4 *)((int)source + 4);\n    destInt32Ptr2[2] = *(undefined4 *)((int)source + 8);\n    destInt32Ptr2[3] = *(undefined4 *)((int)source + 0xc);\n    destInt32Ptr2[4] = *(undefined4 *)((int)source + 0x10);\n    destInt32Ptr2[5] = *(undefined4 *)((int)source + 0x14);\n    destInt32Ptr2[6] = *(undefined4 *)((int)source + 0x18);\n    destInt32Ptr2[7] = *(undefined4 *)((int)source + 0x1c);\n    destInt32Ptr2[8] = *(undefined4 *)((int)source + 0x20);\n    destInt32Ptr2[9] = *(undefined4 *)((int)source + 0x24);\n    destInt32Ptr2[10] = *(undefined4 *)((int)source + 0x28);\n    destInt32Ptr2[0xb] = *(undefined4 *)((int)source + 0x2c);\n    destInt32Ptr2[0xc] = *(undefined4 *)((int)source + 0x30);\n    destInt32Ptr2[0xd] = *(undefined4 *)((int)source + 0x34);\n    destInt32Ptr2[0xe] = *(undefined4 *)((int)source + 0x38);\n    destInt32Ptr2[0xf] = *(undefined4 *)((int)source + 0x3c);\n    destInt32Ptr2 = destInt32Ptr2 + 0x10;\n    source = (undefined4 *)((int)source + 0x40);\n    size = size - 0x40;\n  }\n  remainingSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *destInt32Ptr2 = *source;\n      destInt32Ptr2[1] = *(undefined4 *)((int)source + 4);\n      destInt32Ptr2[2] = *(undefined4 *)((int)source + 8);\n      destInt32Ptr2[3] = *(undefined4 *)((int)source + 0xc);\n      destInt32Ptr2 = destInt32Ptr2 + 4;\n      source = (void *)((int)source + 0x10);\n      isRemaining = 0xf < remainingSize;\n      remainingSize = remainingSize - 0x10;\n    } while (isRemaining);\n  }\n  bytesToCopy = remainingSize + 0xc;\n  srcInt32Ptr = destInt32Ptr2;\n  destInt32Ptr = (undefined4 *)source;\n  if (0xfffffff3 < remainingSize) {\n    do {\n      source = destInt32Ptr + 1;\n      *srcInt32Ptr = *destInt32Ptr;\n      isRemaining = 3 < bytesToCopy;\n      bytesToCopy = bytesToCopy - 4;\n      destInt32Ptr2 = srcInt32Ptr + 1;\n      srcInt32Ptr = srcInt32Ptr + 1;\n      destInt32Ptr = (undefined4 *)source;\n    } while (isRemaining);\n  }\nLAB_000823d0:\n  if (bytesToCopy + 4 != 0) {\n    destInt32Ptr = destInt32Ptr2;\n    srcInt32Ptr = (undefined4 *)source;\n                    /* WARNING: Load size is inaccurate */\n    if ((bytesToCopy & 1) != 0) {\n      srcInt32Ptr = (undefined4 *)((int)source + 1);\n      destInt32Ptr = (undefined4 *)((int)destInt32Ptr2 + 1);\n      *(undefined *)destInt32Ptr2 = *source;\n    }\n    if ((bytesToCopy + 4 & 2) != 0) {\n      *(undefined2 *)destInt32Ptr = *(undefined2 *)srcInt32Ptr;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_0008234c": "memmove_0008234c",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "puVar1": "destPtr",
                "puVar2": "destInt32Ptr",
                "puVar3": "destInt32Ptr2",
                "puVar4": "destCharPtr",
                "puVar5": "srcInt32Ptr",
                "puVar6": "srcCharPtr",
                "uVar7": "remainingSize",
                "uVar8": "bytesToCopy",
                "bVar9": "isRemaining"
            },
            "calling": [
                "__sfvwrite_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082438": {
            "entrypoint": "0x00082438",
            "current_name": "copy_reverse_bytes_00082438",
            "code": "\nvoid * copy_reverse_bytes_00082438(void *destination,void *source,size_t size)\n\n{\n  int index;\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  undefined4 *temp_dest_ptr;\n  undefined *temp_src_ptr;\n  uint temp_size;\n  undefined *temp_dest_end_ptr;\n  uint remaining_size;\n  \n  if ((source < destination) && (temp_src_ptr = (undefined *)((int)source + size), destination < temp_src_ptr)) {\n    temp_dest_end_ptr = (undefined *)((int)destination + size);\n    index = size - 1;\n    if (size != 0) {\n      do {\n        temp_src_ptr = temp_src_ptr + -1;\n        index = index + -1;\n        temp_dest_end_ptr = temp_dest_end_ptr + -1;\n        *temp_dest_end_ptr = *temp_src_ptr;\n      } while (index != -1);\n    }\n    return destination;\n  }\n  dest_ptr = (undefined4 *)destination;\n  if (size < 0x10) {\n    if (size == 0) {\n      return destination;\n    }\n  }\n  else if ((((uint)destination | (uint)source) & 3) == 0) {\n    src_ptr = (undefined4 *)source;\n    do {\n      temp_dest_ptr = dest_ptr + 4;\n      *dest_ptr = *src_ptr;\n      dest_ptr[1] = src_ptr[1];\n      dest_ptr[2] = src_ptr[2];\n      dest_ptr[3] = src_ptr[3];\n      dest_ptr = temp_dest_ptr;\n      src_ptr = src_ptr + 4;\n    } while (temp_dest_ptr != (undefined4 *)((int)destination + (size - 0x10 & 0xfffffff0) + 0x10));\n    remaining_size = size & 0xf;\n    index = ((size - 0x10 >> 4) + 1) * 0x10;\n    source = (void *)((int)source + index);\n    dest_ptr = (undefined4 *)(index + (int)destination);\n    temp_size = remaining_size;\n    src_ptr = dest_ptr;\n    temp_dest_ptr = (undefined4 *)source;\n    if (3 < remaining_size) {\n      do {\n        temp_size = temp_size - 4;\n        *src_ptr = *temp_dest_ptr;\n        src_ptr = src_ptr + 1;\n        temp_dest_ptr = temp_dest_ptr + 1;\n      } while (3 < temp_size);\n      index = (remaining_size - 4 & 0xfffffffc) + 4;\n      dest_ptr = (undefined4 *)((int)dest_ptr + index);\n      source = (void *)((int)source + index);\n      remaining_size = size & 3;\n    }\n    size = remaining_size;\n    if (size == 0) {\n      return destination;\n    }\n  }\n  src_ptr = dest_ptr;\n  do {\n                    /* WARNING: Load size is inaccurate */\n    temp_dest_ptr = (undefined4 *)((int)src_ptr + 1);\n    *(undefined *)src_ptr = *source;\n    source = (undefined4 *)((int)source + 1);\n    src_ptr = temp_dest_ptr;\n  } while (temp_dest_ptr != (undefined4 *)(size + (int)dest_ptr));\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00082438": "copy_reverse_bytes_00082438",
                "__dest": "destination",
                "__src": "source",
                "__n": "size",
                "iVar1": "index",
                "puVar2": "dest_ptr",
                "puVar3": "src_ptr",
                "puVar4": "temp_dest_ptr",
                "puVar5": "temp_src_ptr",
                "puVar7": "temp_dest_end_ptr",
                "uVar6": "temp_size",
                "uVar8": "remaining_size"
            },
            "calling": [
                "__sfvwrite_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082504": {
            "entrypoint": "0x00082504",
            "current_name": "memset_00082504",
            "code": "\nvoid * memset_00082504(void *dest,int ch,size_t count)\n\n{\n  uint *ptr_dest;\n  uint *ptr_mem;\n  uint *ptr_temp;\n  uint ch32;\n  uint temp_count;\n  bool is_count_zero;\n  \n  ptr_mem = (uint *)dest;\n  if (((uint)dest & 3) != 0) {\n    is_count_zero = count == 0;\n    ptr_dest = (uint *)dest;\n    count = count - 1;\n    if (is_count_zero) {\n      return dest;\n    }\n    while( true ) {\n      ptr_mem = (uint *)((int)ptr_dest + 1);\n      *(char *)ptr_dest = (char)ch;\n      if (((uint)ptr_mem & 3) == 0) break;\n      is_count_zero = count == 0;\n      ptr_dest = ptr_mem;\n      count = count - 1;\n      if (is_count_zero) {\n        return dest;\n      }\n    }\n  }\n  if (3 < count) {\n    ch32 = ch & 0xffU | (ch & 0xffU) << 8;\n    ch32 = ch32 | ch32 << 0x10;\n    temp_count = count;\n    ptr_dest = ptr_mem;\n    if (0xf < count) {\n      temp_count = count - 0x10;\n      do {\n        *ptr_dest = ch32;\n        ptr_dest[1] = ch32;\n        ptr_dest[2] = ch32;\n        ptr_dest[3] = ch32;\n        ptr_dest = ptr_dest + 4;\n      } while (ptr_dest != (uint *)((int)ptr_mem + (temp_count & 0xfffffff0) + 0x10));\n      count = count & 0xf;\n      ptr_mem = ptr_mem + ((temp_count >> 4) + 1) * 4;\n      temp_count = count;\n      ptr_dest = ptr_mem;\n      if (count < 4) goto LAB_00082580;\n    }\n    do {\n      count = count - 4;\n      *ptr_mem = ch32;\n      ptr_mem = ptr_mem + 1;\n    } while (3 < count);\n    ptr_mem = (uint *)((int)ptr_dest + (temp_count - 4 & 0xfffffffc) + 4);\n    count = temp_count & 3;\n  }\nLAB_00082580:\n  if (count != 0) {\n    ptr_dest = ptr_mem;\n    do {\n      ptr_temp = (uint *)((int)ptr_dest + 1);\n      *(char *)ptr_dest = (char)ch;\n      ptr_dest = ptr_temp;\n    } while (ptr_temp != (uint *)(count + (int)ptr_mem));\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_00082504": "memset_00082504",
                "__s": "dest",
                "__c": "ch",
                "__n": "count",
                "puVar1": "ptr_dest",
                "puVar2": "ptr_mem",
                "puVar3": "ptr_temp",
                "uVar4": "ch32",
                "uVar5": "temp_count",
                "bVar6": "is_count_zero"
            },
            "calling": [
                "RingBuffer",
                "__sinit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082598": {
            "entrypoint": "0x00082598",
            "current_name": "FUNC_00082598",
            "code": "\nvoid FUNC_00082598(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00082598": "FUNC_00082598"
            },
            "calling": [
                "_malloc_r",
                "_realloc_r",
                "_malloc_trim_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008259c": {
            "entrypoint": "0x0008259c",
            "current_name": "FUNC_0008259c",
            "code": "\nvoid FUNC_0008259c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008259c": "FUNC_0008259c"
            },
            "calling": [
                "_malloc_r",
                "_realloc_r",
                "_malloc_trim_r",
                "_free_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000825a0": {
            "entrypoint": "0x000825a0",
            "current_name": "reallocate_memory_000825a0",
            "code": "\nvoid * reallocateMemory_000825a0(void *originalPointer,size_t newSize)\n\n{\n  void *reallocPointer;\n  \n  reallocPointer = (void *)_realloc_r(_impure_ptr,originalPointer,newSize);\n  return reallocPointer;\n}\n\n",
            "renaming": {
                "FUN_000825a0": "reallocate_memory_000825a0",
                "__ptr": "originalPointer",
                "__size": "newSize",
                "pvVar1": "reallocPointer"
            },
            "calling": [
                "changeBuffer"
            ],
            "called": [
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825b0": {
            "entrypoint": "0x000825b0",
            "current_name": "allocate_memory_000825b0",
            "code": "\nint * allocateMemory_000825b0(undefined4 *memoryContext,int *existingMemoryBlock,uint newBlockSize)\n\n{\n  int temp1;\n  int *newMemoryBlock;\n  uint temp2;\n  size_t size;\n  uint temp3;\n  int temp4;\n  int *temp5;\n  uint blockSize;\n  uint alignedSize;\n  int *temp6;\n  \n  if (existingMemoryBlock == (int *)0x0) {\n    newMemoryBlock = (int *)_malloc_r(memoryContext,newBlockSize);\n    return newMemoryBlock;\n  }\n  __malloc_lock();\n  temp3 = existingMemoryBlock[-1];\n  blockSize = temp3 & 0xfffffffc;\n  newMemoryBlock = existingMemoryBlock + -2;\n  if (newBlockSize + 0xb < 0x17) {\n    alignedSize = 0x10;\n  }\n  else {\n    alignedSize = newBlockSize + 0xb & 0xfffffff8;\n    if ((int)alignedSize < 0) goto LAB_0008267c;\n  }\n  if (alignedSize < newBlockSize) {\nLAB_0008267c:\n    *memoryContext = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)blockSize < (int)alignedSize) {\n    temp1 = (int)newMemoryBlock + blockSize;\n    if (DAT_2007046c == temp1) {\n      temp2 = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n      temp1 = DAT_2007046c;\n      if ((int)(alignedSize + 0x10) <= (int)(temp2 + blockSize)) {\n        DAT_2007046c = (int)newMemoryBlock + alignedSize;\n        *(uint *)(DAT_2007046c + 4) = (temp2 + blockSize) - alignedSize | 1;\n        existingMemoryBlock[-1] = alignedSize | existingMemoryBlock[-1] & 1U;\n        __malloc_unlock(memoryContext);\n        return existingMemoryBlock;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(temp1 + 4) & 0xfffffffe) + temp1 + 4) & 1) == 0) {\n      temp2 = *(uint *)(temp1 + 4) & 0xfffffffc;\n      if ((int)alignedSize <= (int)(temp2 + blockSize)) {\n        temp4 = *(int *)(temp1 + 0xc);\n        temp1 = *(int *)(temp1 + 8);\n        *(int *)(temp1 + 0xc) = temp4;\n        *(int *)(temp4 + 8) = temp1;\n        blockSize = temp2 + blockSize;\n        goto LAB_0008268c;\n      }\n    }\n    else {\n      temp2 = 0;\n      temp1 = 0;\n    }\n    if (-1 < (int)(temp3 << 0x1f)) {\n      temp6 = (int *)((int)newMemoryBlock - existingMemoryBlock[-2]);\n      temp3 = (temp6[1] & 0xfffffffcU) + blockSize;\n      if (temp1 != 0) {\n        if (temp1 == DAT_2007046c) {\n          if ((int)(alignedSize + 0x10) <= (int)(temp2 + temp3)) {\n            newMemoryBlock = temp6 + 2;\n            temp1 = *newMemoryBlock;\n            temp4 = temp6[3];\n            size = blockSize - 4;\n            *(int *)(temp1 + 0xc) = temp4;\n            *(int *)(temp4 + 8) = temp1;\n            if (size < 0x25) {\n              temp5 = newMemoryBlock;\n              if (0x13 < size) {\n                temp6[2] = *existingMemoryBlock;\n                temp6[3] = existingMemoryBlock[1];\n                if (size < 0x1c) {\n                  existingMemoryBlock = existingMemoryBlock + 2;\n                  temp5 = temp6 + 4;\n                }\n                else {\n                  temp6[4] = existingMemoryBlock[2];\n                  temp6[5] = existingMemoryBlock[3];\n                  if (size == 0x24) {\n                    temp6[6] = existingMemoryBlock[4];\n                    temp5 = existingMemoryBlock + 5;\n                    existingMemoryBlock = existingMemoryBlock + 6;\n                    temp6[7] = *temp5;\n                    temp5 = temp6 + 8;\n                  }\n                  else {\n                    existingMemoryBlock = existingMemoryBlock + 4;\n                    temp5 = temp6 + 6;\n                  }\n                }\n              }\n              *temp5 = *existingMemoryBlock;\n              temp5[1] = existingMemoryBlock[1];\n              temp5[2] = existingMemoryBlock[2];\n            }\n            else {\n              memmove(newMemoryBlock,existingMemoryBlock,size);\n            }\n            DAT_2007046c = (int)temp6 + alignedSize;\n            *(uint *)(DAT_2007046c + 4) = (temp2 + temp3) - alignedSize | 1;\n            temp6[1] = alignedSize | temp6[1] & 1U;\n            __malloc_unlock(memoryContext);\n            return newMemoryBlock;\n          }\n        }\n        else {\n          temp2 = temp2 + temp3;\n          if ((int)alignedSize <= (int)temp2) {\n            temp4 = *(int *)(temp1 + 0xc);\n            temp1 = *(int *)(temp1 + 8);\n            *(int *)(temp1 + 0xc) = temp4;\n            *(int *)(temp4 + 8) = temp1;\n            temp5 = temp6 + 2;\n            temp1 = *temp5;\n            temp4 = temp6[3];\n            size = blockSize - 4;\n            *(int *)(temp1 + 0xc) = temp4;\n            *(int *)(temp4 + 8) = temp1;\n            blockSize = temp2;\n            if (size < 0x25) {\n              newMemoryBlock = temp5;\n              if (0x13 < size) {\n                temp6[2] = *existingMemoryBlock;\n                temp6[3] = existingMemoryBlock[1];\n                if (size < 0x1c) {\n                  existingMemoryBlock = existingMemoryBlock + 2;\n                  newMemoryBlock = temp6 + 4;\n                }\n                else {\n                  temp6[4] = existingMemoryBlock[2];\n                  temp6[5] = existingMemoryBlock[3];\n                  if (size == 0x24) {\n                    temp6[6] = existingMemoryBlock[4];\n                    newMemoryBlock = existingMemoryBlock + 5;\n                    existingMemoryBlock = existingMemoryBlock + 6;\n                    temp6[7] = *newMemoryBlock;\n                    newMemoryBlock = temp6 + 8;\n                  }\n                  else {\n                    existingMemoryBlock = existingMemoryBlock + 4;\n                    newMemoryBlock = temp6 + 6;\n                  }\n                }\n              }\n              *newMemoryBlock = *existingMemoryBlock;\n              newMemoryBlock[1] = existingMemoryBlock[1];\n              newMemoryBlock[2] = existingMemoryBlock[2];\n              temp3 = temp6[1];\n              newMemoryBlock = temp6;\n              existingMemoryBlock = temp5;\n            }\n            else {\n              memmove(temp5,existingMemoryBlock,size);\n              temp3 = temp6[1];\n              newMemoryBlock = temp6;\n              existingMemoryBlock = temp5;\n            }\n            goto LAB_0008268c;\n          }\n        }\n      }\n      if ((int)alignedSize <= (int)temp3) {\n        temp5 = temp6 + 2;\n        temp1 = *temp5;\n        temp4 = temp6[3];\n        size = blockSize - 4;\n        *(int *)(temp1 + 0xc) = temp4;\n        *(int *)(temp4 + 8) = temp1;\n        blockSize = temp3;\n        if (size < 0x25) {\n          newMemoryBlock = temp5;\n          if (0x13 < size) {\n            temp6[2] = *existingMemoryBlock;\n            temp6[3] = existingMemoryBlock[1];\n            if (size < 0x1c) {\n              existingMemoryBlock = existingMemoryBlock + 2;\n              newMemoryBlock = temp6 + 4;\n            }\n            else {\n              temp6[4] = existingMemoryBlock[2];\n              temp6[5] = existingMemoryBlock[3];\n              if (size == 0x24) {\n                temp6[6] = existingMemoryBlock[4];\n                newMemoryBlock = existingMemoryBlock + 5;\n                existingMemoryBlock = existingMemoryBlock + 6;\n                temp6[7] = *newMemoryBlock;\n                newMemoryBlock = temp6 + 8;\n              }\n              else {\n                existingMemoryBlock = existingMemoryBlock + 4;\n                newMemoryBlock = temp6 + 6;\n              }\n            }\n          }\n          *newMemoryBlock = *existingMemoryBlock;\n          newMemoryBlock[1] = existingMemoryBlock[1];\n          newMemoryBlock[2] = existingMemoryBlock[2];\n          temp3 = temp6[1];\n          newMemoryBlock = temp6;\n          existingMemoryBlock = temp5;\n        }\n        else {\n          memmove(temp5,existingMemoryBlock,size);\n          temp3 = temp6[1];\n          newMemoryBlock = temp6;\n          existingMemoryBlock = temp5;\n        }\n        goto LAB_0008268c;\n      }\n    }\n    temp6 = (int *)_malloc_r(memoryContext,newBlockSize);\n    if (temp6 == (int *)0x0) goto LAB_000826a4;\n    temp3 = existingMemoryBlock[-1];\n    if (temp6 + -2 != (int *)((temp3 & 0xfffffffe) + (int)newMemoryBlock)) {\n      size = blockSize - 4;\n      if (size < 0x25) {\n        newMemoryBlock = existingMemoryBlock;\n        temp5 = temp6;\n        if (0x13 < size) {\n          *temp6 = *existingMemoryBlock;\n          temp6[1] = existingMemoryBlock[1];\n          if (size < 0x1c) {\n            newMemoryBlock = existingMemoryBlock + 2;\n            temp5 = temp6 + 2;\n          }\n          else {\n            temp6[2] = existingMemoryBlock[2];\n            temp6[3] = existingMemoryBlock[3];\n            if (size == 0x24) {\n              temp6[4] = existingMemoryBlock[4];\n              temp6[5] = existingMemoryBlock[5];\n              newMemoryBlock = existingMemoryBlock + 6;\n              temp5 = temp6 + 6;\n            }\n            else {\n              newMemoryBlock = existingMemoryBlock + 4;\n              temp5 = temp6 + 4;\n            }\n          }\n        }\n        *temp5 = *newMemoryBlock;\n        temp5[1] = newMemoryBlock[1];\n        temp5[2] = newMemoryBlock[2];\n      }\n      else {\n        memmove(temp6,existingMemoryBlock,size);\n      }\n      _free_r(memoryContext,existingMemoryBlock);\n      goto LAB_000826a4;\n    }\n    blockSize = blockSize + (temp6[-1] & 0xfffffffcU);\n  }\nLAB_0008268c:\n  temp2 = blockSize - alignedSize;\n  temp6 = existingMemoryBlock;\n  if (temp2 < 0x10) {\n    newMemoryBlock[1] = temp3 & 1 | blockSize;\n    *(uint *)((int)newMemoryBlock + blockSize + 4) = *(uint *)((int)newMemoryBlock + blockSize + 4) | 1;\n  }\n  else {\n    newMemoryBlock[1] = temp3 & 1 | alignedSize;\n    *(uint *)((int)newMemoryBlock + alignedSize + 4) = temp2 | 1;\n    *(uint *)((int)newMemoryBlock + temp2 + alignedSize + 4) = *(uint *)((int)newMemoryBlock + temp2 + alignedSize + 4) | 1;\n    _free_r(memoryContext,(int)newMemoryBlock + alignedSize + 8);\n  }\nLAB_000826a4:\n  __malloc_unlock(memoryContext);\n  return temp6;\n}\n\n",
            "renaming": {
                "FUN_000825b0": "allocate_memory_000825b0",
                "param_1": "memoryContext",
                "param_2": "existingMemoryBlock",
                "param_3": "newBlockSize",
                "iVar1": "temp1",
                "piVar2": "newMemoryBlock",
                "uVar3": "temp2",
                "sVar4": "size",
                "uVar5": "temp3",
                "iVar6": "temp4",
                "piVar7": "temp5",
                "uVar8": "blockSize",
                "uVar9": "alignedSize",
                "piVar10": "temp6"
            },
            "calling": [
                "__sfvwrite_r",
                "realloc"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_malloc_r",
                "_free_r",
                "memmove"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082970": {
            "entrypoint": "0x00082970",
            "current_name": "allocate_memory_00082970",
            "code": "\nvoid allocateMemory_00082970(int *error,intptr_t size)\n\n{\n  void *allocatedMemory;\n  \n  errno = 0;\n  allocatedMemory = _sbrk(size);\n  if ((allocatedMemory == (void *)0xffffffff) && (errno != 0)) {\n    *error = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00082970": "allocate_memory_00082970",
                "param_1": "error",
                "param_2": "size",
                "pvVar1": "allocatedMemory"
            },
            "calling": [
                "_malloc_r",
                "_malloc_trim_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082994": {
            "entrypoint": "0x00082994",
            "current_name": "copy_string_00082994",
            "code": "\nchar * copy_string_00082994(char *destination,char *source)\n\n{\n  char current_char;\n  ushort current_short;\n  uint *current_pointer;\n  uint *next_pointer;\n  uint current_value;\n  uint temp_value;\n  uint *current_destination;\n  uint *next_destination;\n  char *copied_string;\n  bool is_null;\n  \n  copied_string = destination;\n  if ((((uint)destination ^ (uint)source) & 3) != 0) {\n    do {\n      current_char = *source;\n      *copied_string = current_char;\n      source = source + 1;\n      copied_string = copied_string + 1;\n    } while (current_char != '\\0');\n    return destination;\n  }\n  next_destination = (uint *)destination;\n  if (((uint)source & 3) != 0) {\n    next_pointer = (uint *)source;\n    if (((uint)source & 1) != 0) {\n      next_pointer = (uint *)(source + 1);\n      current_char = *source;\n      next_destination = (uint *)(destination + 1);\n      *destination = current_char;\n      if (current_char == '\\0') {\n        return destination;\n      }\n    }\n    source = (char *)next_pointer;\n    if (((uint)next_pointer & 2) != 0) {\n      source = (char *)((int)next_pointer + 2);\n      current_short = *(ushort *)next_pointer;\n      is_null = (current_short & 0xff) == 0;\n      if (is_null) {\n        *(char *)next_destination = (char)current_short;\n      }\n      else {\n        *(ushort *)next_destination = current_short;\n        is_null = (current_short & 0xff00) == 0;\n        next_destination = (uint *)((int)next_destination + 2);\n      }\n      if (is_null) {\n        return destination;\n      }\n    }\n  }\n  current_value = *(uint *)source;\n  next_pointer = (uint *)((int)source + 4);\n  current_destination = next_destination;\n  if (((uint)source & 4) != 0) {\n    if ((current_value + 0xfefefeff & ~current_value & 0x80808080) != 0) goto LAB_000829f8;\n    current_destination = next_destination + 1;\n    *next_destination = current_value;\n    next_pointer = (uint *)((int)source + 8);\n    current_value = *(uint *)((int)source + 4);\n  }\n  while( true ) {\n    current_pointer = next_pointer + 1;\n    temp_value = *next_pointer;\n    next_destination = current_destination;\n    if ((current_value + 0xfefefeff & ~current_value & 0x80808080) != 0) break;\n    next_destination = current_destination + 1;\n    *current_destination = current_value;\n    current_value = temp_value;\n    if ((temp_value + 0xfefefeff & ~temp_value & 0x80808080) != 0) break;\n    next_pointer = next_pointer + 2;\n    current_value = *current_pointer;\n    current_destination = current_destination + 2;\n    *next_destination = temp_value;\n  }\nLAB_000829f8:\n  do {\n    *(char *)next_destination = (char)current_value;\n    temp_value = current_value & 0xff;\n    current_value = current_value >> 8 | current_value << 0x18;\n    next_destination = (uint *)((int)next_destination + 1);\n  } while (temp_value != 0);\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_00082994": "copy_string_00082994",
                "__dest": "destination",
                "__src": "source",
                "cVar1": "current_char",
                "uVar2": "current_short",
                "puVar3": "current_pointer",
                "puVar4": "next_pointer",
                "uVar5": "current_value",
                "uVar6": "temp_value",
                "puVar7": "current_destination",
                "puVar8": "next_destination",
                "pcVar9": "copied_string",
                "bVar10": "is_null"
            },
            "calling": [
                "copy"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082a50": {
            "entrypoint": "0x00082a50",
            "current_name": "calculate_string_size_00082a50",
            "code": "\nsize_t calculateStringSize_00082a50(char *string)\n\n{\n  size_t size;\n  uint *modifiedString;\n  uint currentChunk;\n  bool isEndOfChunk;\n  \n  modifiedString = (uint *)((uint)string & 0xfffffffc);\n  size = -((uint)string & 3);\n  currentChunk = *modifiedString;\n  if (((uint)string & 3) != 0) {\n    currentChunk = currentChunk | 0xffffffffU >> ((size + 4 & 0x1f) << 3);\n  }\n  while (modifiedString = modifiedString + 1, (currentChunk + 0xfefefeff & ~currentChunk & 0x80808080) == 0) {\n    size = size + 4;\n    currentChunk = *modifiedString;\n  }\n  isEndOfChunk = (currentChunk & 0xff) == 0;\n  if (!isEndOfChunk) {\n    size = size + 1;\n    isEndOfChunk = (currentChunk & 0xff00) == 0;\n  }\n  if (!isEndOfChunk) {\n    size = size + 1;\n    isEndOfChunk = (currentChunk & 0xff0000) == 0;\n  }\n  if (!isEndOfChunk) {\n    size = size + 1;\n  }\n  return size;\n}\n\n",
            "renaming": {
                "FUN_00082a50": "calculate_string_size_00082a50",
                "__s": "string",
                "sVar1": "size",
                "puVar2": "modifiedString",
                "uVar3": "currentChunk",
                "bVar4": "isEndOfChunk"
            },
            "calling": [
                "String",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082ab0": {
            "entrypoint": "0x00082ab0",
            "current_name": "kill_process_00082ab0",
            "code": "\nint killProcess_00082ab0(processID_t processID,int signalNumber)\n\n{\n  int result;\n  \n  result = _kill_r(_impure_ptr,processID,signalNumber);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082ab0": "kill_process_00082ab0",
                "__pid": "processID",
                "__sig": "signalNumber",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_kill_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082ac0": {
            "entrypoint": "0x00082ac0",
            "current_name": "write_to_file_00082ac0",
            "code": "\nint writeToFile_00082ac0(undefined4 file,int bufferSize,int **data)\n\n{\n  int *dataPtr;\n  int result;\n  int *currentDataPtr;\n  uint tempVar;\n  undefined4 *currentCharPtr;\n  uint dataElement;\n  uint numElements;\n  \n  if (-1 < *(int *)(bufferSize + 100) << 0x12) {\n    result = __sfvwrite_r();\n    data[2] = (int *)0x0;\n    data[1] = (int *)0x0;\n    return result;\n  }\n  currentDataPtr = data[2];\n  dataPtr = *data;\n  while (currentDataPtr != (int *)0x0) {\n    dataElement = dataPtr[1];\n    numElements = dataElement >> 2;\n    if (numElements != 0) {\n      currentCharPtr = (undefined4 *)(*dataPtr + -4);\n      tempVar = 0;\n      do {\n        currentCharPtr = currentCharPtr + 1;\n        result = _fputwc_r(file,*currentCharPtr,bufferSize);\n        tempVar = tempVar + 1;\n        if (result == -1) goto LAB_00082b00;\n      } while (numElements != tempVar);\n      currentDataPtr = data[2];\n    }\n    currentDataPtr = (int *)((int)currentDataPtr - (dataElement & 0xfffffffc));\n    data[2] = currentDataPtr;\n    dataPtr = dataPtr + 2;\n  }\n  result = 0;\nLAB_00082b00:\n  data[2] = (int *)0x0;\n  data[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082ac0": "write_to_file_00082ac0",
                "param_1": "file",
                "param_2": "bufferSize",
                "param_3": "data",
                "piVar1": "dataPtr",
                "iVar2": "result",
                "piVar3": "currentDataPtr",
                "uVar4": "tempVar",
                "puVar5": "currentCharPtr",
                "uVar6": "dataElement",
                "uVar7": "numElements"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_fputwc_r",
                "__sfvwrite_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082b38": {
            "entrypoint": "0x00082b38",
            "current_name": "print_formatted_string_00082b38",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint printFormattedString_00082b38(int buffer,int format,int *******arg_list,int **arg_list_ptr)\n\n{\n  bool is_negative;\n  bool is_decimal;\n  bool is_hash;\n  char cur_char;\n  bool use_uppercase;\n  void *pointer;\n  int ********format_parts;\n  int *temp_ptr;\n  int result;\n  char base_char;\n  int *******cur_format_part;\n  uint digit;\n  int **parg_ptr;\n  uint flags;\n  uint temp_value;\n  int loop_counter;\n  int ********ppppppppiVar17;\n  int iVar18;\n  int *******pppppppiVar19;\n  int *piVar20;\n  int *******pppppppiVar21;\n  uint temp_value2;\n  int *is_negative_ptr;\n  int *******cur_format_part2;\n  undefined4 uVar25;\n  int ********current_pos;\n  bool temp_bool;\n  longlong temp_long;\n  int *******current_length;\n  int *******total_length;\n  int **arg_list_ptr_copy;\n  int buffer_length;\n  char *str_pointer;\n  char sign_char;\n  undefined padding_char;\n  undefined base_prefix_char;\n  int ********format_parts_ptr;\n  int format_parts_count;\n  int *******format_parts_sum;\n  undefined temp_char;\n  char temp_buffer;\n  undefined temp_char2;\n  undefined temp_buffer_ptr [4];\n  int *******format_parts_stack [16];\n  \n  if ((buffer != 0) && (*(int *)(buffer + 0x38) == 0)) {\n    current_posinit();\n  }\n  flags = (uint)*(ushort *)(format + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(format + 0xc) << 0x12)) {\n    flags = flags | 0x2000;\n    *(short *)(format + 0xc) = (short)flags;\n    *(uint *)(format + 100) = *(uint *)(format + 100) & 0xffffdfff;\n  }\n  if (((int)(flags << 0x1c) < 0) && (*(int *)(format + 0x10) != 0)) {\n    if ((flags & 0x1a) != 10) goto LAB_00082b8a;\n  }\n  else {\n    result = current_poswsetup_r(buffer,format);\n    if (result != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(format + 0xc) & 0x1a) != 10) goto LAB_00082b8a;\n  }\n  if (-1 < *(short *)(format + 0xe)) {\n    result = current_posbprintf(buffer,format,arg_list,arg_list_ptr);\n    return result;\n  }\nLAB_00082b8a:\n  str_pointer = (char *)0x0;\n  format_parts_sum = (int *******)0x0;\n  format_parts_count = 0;\n  buffer_length = 0;\n  format_parts = (int ********)temp_buffer_ptr;\n  arg_list_ptr_copy = arg_list_ptr;\n  format_parts_ptr = (int ********)temp_buffer_ptr;\nLAB_00082b9e:\n  cur_format_part = arg_list;\n  if ((*(char *)arg_list != '\\0') && (*(char *)arg_list != '%')) {\n    do {\n      cur_format_part = (int *******)((int)cur_format_part + 1);\n      if (*(char *)cur_format_part == '\\0') break;\n    } while (*(char *)cur_format_part != '%');\n    pppppppiVar21 = (int *******)((int)cur_format_part - (int)arg_list);\n    if (pppppppiVar21 != (int *******)0x0) {\n      format_parts_count = format_parts_count + 1;\n      format_parts_sum = (int *******)((int)format_parts_sum + (int)pppppppiVar21);\n      *format_parts = arg_list;\n      format_parts[1] = pppppppiVar21;\n      if (format_parts_count < 8) {\n        format_parts = format_parts + 2;\n      }\n      else {\n        if (format_parts_sum == (int *******)0x0) {\n          buffer_length = buffer_length + (int)pppppppiVar21;\n          format_parts_count = 0;\n          format_parts = (int ********)temp_buffer_ptr;\n          goto LAB_00082bee;\n        }\n        result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n        format_parts = (int ********)temp_buffer_ptr;\n        if (result != 0) goto LAB_000833de;\n      }\n      buffer_length = buffer_length + (int)pppppppiVar21;\n    }\n  }\nLAB_00082bee:\n  if (*(char *)cur_format_part != '\\0') {\n    sign_char = '\\0';\n    temp_value = (uint)*(byte *)((int)cur_format_part + 1);\n    flags = 0;\n    use_uppercase = false;\n    is_decimal = false;\n    is_negative = false;\n    is_hash = false;\n    temp_bool = false;\n    pppppppiVar21 = (int *******)0x0;\n    total_length = (int *******)0xffffffff;\n    arg_list = (int *******)((int)cur_format_part + 1);\nLAB_00082c12:\n    arg_list = (int *******)((int)arg_list + 1);\nLAB_00082c16:\n    switch(temp_value) {\n    case 0x20:\n      goto switchD_00082c20_caseD_20;\n    default:\n      if (temp_value != 0) {\n        current_length = (int *******)0x1;\n        total_length = (int *******)0x1;\n        current_pos = (int ********)&temp_char;\n        temp_char = (char)temp_value;\n        goto LAB_00083012;\n      }\n      goto LAB_000833d0;\n    case 0x23:\n      is_hash = true;\n      temp_value = (uint)*(byte *)arg_list;\n      goto LAB_00082c12;\n    case 0x2a:\n      pppppppiVar21 = (int *******)*arg_list_ptr_copy;\n      arg_list_ptr_copy = arg_list_ptr_copy + 1;\n      if ((int)pppppppiVar21 < 0) {\n        pppppppiVar21 = (int *******)-(int)pppppppiVar21;\n        goto switchD_00082c20_caseD_2d;\n      }\n      temp_value = (uint)*(byte *)arg_list;\n      goto LAB_00082c12;\n    case 0x2b:\n      temp_value = (uint)*(byte *)arg_list;\n      sign_char = '+';\n      goto LAB_00082c12;\n    case 0x2d:\nswitchD_00082c20_caseD_2d:\n      flags = flags | 4;\n      temp_value = (uint)*(byte *)arg_list;\n      goto LAB_00082c12;\n    case 0x2e:\n      temp_value = (uint)*(byte *)arg_list;\n      cur_format_part = (int *******)((int)arg_list + 1);\n      if (temp_value == 0x2a) {\n        temp_value = (uint)*(byte *)((int)arg_list + 1);\n        total_length = (int *******)*arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        arg_list = cur_format_part;\n        if ((int)total_length < 0) {\n          total_length = (int *******)0xffffffff;\n        }\n        goto LAB_00082c12;\n      }\n      digit = temp_value - 0x30;\n      if (digit < 10) {\n        temp_value2 = 0;\n        do {\n          arg_list = (int *******)((int)cur_format_part + 1);\n          temp_value = (uint)*(byte *)cur_format_part;\n          temp_value2 = digit + temp_value2 * 10;\n          digit = temp_value - 0x30;\n          cur_format_part = arg_list;\n        } while (digit < 10);\n        total_length = (int *******)(temp_value2 | (int)temp_value2 >> 0x1f);\n      }\n      else {\n        total_length = (int *******)0x0;\n        arg_list = cur_format_part;\n      }\n      goto LAB_00082c16;\n    case 0x30:\n      flags = flags | 0x80;\n      temp_value = (uint)*(byte *)arg_list;\n      goto LAB_00082c12;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082c20_caseD_31;\n    case 0x44:\n      is_decimal = true;\n      if (is_negative == false) goto LAB_00083028;\nLAB_00082e98:\n      arg_list_ptr_copy = (int **)((int)arg_list_ptr_copy + 7U & 0xfffffff8);\n      piVar20 = *arg_list_ptr_copy;\n      is_negative_ptr = arg_list_ptr_copy[1];\n      arg_list_ptr_copy = arg_list_ptr_copy + 2;\n      goto LAB_00082eac;\n    case 0x4f:\n      is_decimal = true;\n      if (is_negative != false) goto LAB_00082d42;\nLAB_00082f2a:\n      result = (uint)is_decimal << 4;\n      loop_counter = (uint)is_negative << 5;\n      if ((is_decimal == 0) && (loop_counter = (uint)temp_bool << 6, temp_bool != 0)) {\n        piVar20 = (int *)(uint)*(ushort *)arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        is_negative_ptr = (int *)0x0;\n      }\n      else {\n        result = loop_counter;\n        piVar20 = *arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        is_negative_ptr = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      is_decimal = true;\n      if (is_negative != false) goto LAB_00082e62;\nLAB_00082f7c:\n      if ((is_decimal) || (temp_bool == false)) {\n        result = 1;\n        piVar20 = *arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        is_negative_ptr = (int *)0x0;\n      }\n      else {\n        is_negative_ptr = (int *)0x0;\n        piVar20 = (int *)(uint)*(ushort *)arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        result = 1;\n      }\n      break;\n    case 0x58:\n      str_pointer = \"0123456789ABCDEF\";\n      if (is_negative == false) goto LAB_00083196;\nLAB_00082fb6:\n      parg_ptr = (int **)((int)arg_list_ptr_copy + 7U & 0xfffffff8);\n      arg_list_ptr_copy = parg_ptr + 2;\n      piVar20 = *parg_ptr;\n      is_negative_ptr = parg_ptr[1];\n      goto LAB_00082fca;\n    case 99:\n      piVar20 = *arg_list_ptr_copy;\n      arg_list_ptr_copy = arg_list_ptr_copy + 1;\n      current_length = (int *******)0x1;\n      temp_char = SUB41(piVar20,0);\n      total_length = (int *******)0x1;\n      current_pos = (int ********)&temp_char;\n      goto LAB_00083012;\n    case 100:\n    case 0x69:\n      if (is_negative != false) goto LAB_00082e98;\nLAB_00083028:\n      if ((is_decimal == false) && (temp_bool != false)) {\n        piVar20 = (int *)(int)*(short *)arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        is_negative_ptr = (int *)((int)piVar20 >> 0x1f);\n      }\n      else {\n        piVar20 = *arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        is_negative_ptr = (int *)((int)piVar20 >> 0x1f);\n      }\nLAB_00082eac:\n      if ((int)is_negative_ptr < 0) {\n        temp_bool = piVar20 != (int *)0x0;\n        piVar20 = (int *)-(int)piVar20;\n        is_negative_ptr = (int *)(-(int)is_negative_ptr - (uint)temp_bool);\n        sign_char = '-';\n        cur_char = '-';\n        result = 1;\n        goto LAB_00082d6a;\n      }\n      if (-1 < (int)total_length) {\n        flags = flags & 0xffffff7f;\n      }\n      use_uppercase = false;\n      temp_value = (uint)piVar20 | (uint)is_negative_ptr;\n      result = 1;\n      cur_char = sign_char;\n      goto joined_r0x00082d78;\n    case 0x68:\n      temp_bool = true;\n      temp_value = (uint)*(byte *)arg_list;\n      goto LAB_00082c12;\n    case 0x6c:\n      temp_value = (uint)*(byte *)arg_list;\n      if (temp_value == 0x6c) {\n        is_negative = true;\n        temp_value = (uint)*(byte *)((int)arg_list + 1);\n        arg_list = (int *******)((int)arg_list + 1);\n      }\n      else {\n        is_decimal = true;\n      }\n      goto LAB_00082c12;\n    case 0x6e:\n      if (is_negative == false) {\n        if (is_decimal == false) {\n          if (temp_bool) {\n            piVar20 = *arg_list_ptr_copy;\n            arg_list_ptr_copy = arg_list_ptr_copy + 1;\n            *(short *)piVar20 = (short)buffer_length;\n          }\n          else {\n            piVar20 = *arg_list_ptr_copy;\n            arg_list_ptr_copy = arg_list_ptr_copy + 1;\n            *piVar20 = buffer_length;\n          }\n        }\n        else {\n          piVar20 = *arg_list_ptr_copy;\n          arg_list_ptr_copy = arg_list_ptr_copy + 1;\n          *piVar20 = buffer_length;\n        }\n      }\n      else {\n        piVar20 = *arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        *piVar20 = buffer_length;\n        piVar20[1] = buffer_length >> 0x1f;\n      }\n      goto LAB_00082b9e;\n    case 0x6f:\n      if (is_negative == false) goto LAB_00082f2a;\nLAB_00082d42:\n      parg_ptr = (int **)((int)arg_list_ptr_copy + 7U & 0xfffffff8);\n      arg_list_ptr_copy = parg_ptr + 2;\n      piVar20 = *parg_ptr;\n      is_negative_ptr = parg_ptr[1];\n      result = 0;\n      break;\n    case 0x70:\n      piVar20 = *arg_list_ptr_copy;\n      arg_list_ptr_copy = arg_list_ptr_copy + 1;\n      base_prefix_char = 0x78;\n      use_uppercase = true;\n      is_negative_ptr = (int *)0x0;\n      padding_char = 0x30;\n      str_pointer = \"0123456789abcdef\";\n      result = 2;\n      break;\n    case 0x71:\n      is_negative = true;\n      temp_value = (uint)*(byte *)arg_list;\n      goto LAB_00082c12;\n    case 0x73:\n      current_pos = (int ********)*arg_list_ptr_copy;\n      sign_char = '\\0';\n      arg_list_ptr_copy = arg_list_ptr_copy + 1;\n      if (current_pos != (int ********)0x0) {\n        if ((int)total_length < 0) {\n          total_length = (int *******)strlen((char *)current_pos);\n          cur_format_part = (int *******)0x0;\n          cur_char = sign_char;\n        }\n        else {\n          pointer = memchr(current_pos,0,(size_t)total_length);\n          cur_char = sign_char;\n          if (pointer == (void *)0x0) {\n            cur_format_part = (int *******)0x0;\n          }\n          else {\n            pppppppiVar19 = (int *******)((int)pointer - (int)current_pos);\n            if ((int)total_length <= (int)(int *******)((int)pointer - (int)current_pos)) {\n              pppppppiVar19 = total_length;\n            }\n            cur_format_part = (int *******)0x0;\n            total_length = pppppppiVar19;\n          }\n        }\n        goto LAB_00082da0;\n      }\n      if ((int *******)0x5 < total_length) {\n        total_length = (int *******)0x6;\n      }\n      current_length = (int *******)((uint)total_length & ~((int)total_length >> 0x1f));\n      current_pos = (int ********)&UNK_00085840;\nLAB_00083012:\n      sign_char = '\\0';\n      cur_format_part = (int *******)0x0;\n      goto LAB_00082dba;\n    case 0x75:\n      if (!is_negative) goto LAB_00082f7c;\nLAB_00082e62:\n      parg_ptr = (int **)((int)arg_list_ptr_copy + 7U & 0xfffffff8);\n      arg_list_ptr_copy = parg_ptr + 2;\n      piVar20 = *parg_ptr;\n      is_negative_ptr = parg_ptr[1];\n      result = 1;\n      break;\n    case 0x78:\n      str_pointer = \"0123456789abcdef\";\n      if (is_negative != false) goto LAB_00082fb6;\nLAB_00083196:\n      if ((is_decimal == false) && (temp_bool != false)) {\n        is_negative_ptr = (int *)0x0;\n        piVar20 = (int *)(uint)*(ushort *)arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n      }\n      else {\n        piVar20 = *arg_list_ptr_copy;\n        arg_list_ptr_copy = arg_list_ptr_copy + 1;\n        is_negative_ptr = (int *)0x0;\n      }\nLAB_00082fca:\n      if ((is_hash) && (((uint)piVar20 | (uint)is_negative_ptr) != 0)) {\n        use_uppercase = true;\n        padding_char = 0x30;\n        result = 2;\n        base_prefix_char = (char)temp_value;\n      }\n      else {\n        result = 2;\n      }\n    }\n    sign_char = '\\0';\n    cur_char = '\\0';\nLAB_00082d6a:\n    if (-1 < (int)total_length) {\n      flags = flags & 0xffffff7f;\n    }\n    temp_value = (uint)piVar20 | (uint)is_negative_ptr;\njoined_r0x00082d78:\n    temp_long = CONCAT44(is_negative_ptr,piVar20);\n    cur_format_part = total_length;\n    if ((temp_value == 0) && (total_length == (int *******)0x0)) {\n      current_pos = (int ********)temp_buffer_ptr;\n      if ((result != 0) || (!is_hash)) goto LAB_00082da0;\n      current_pos = (int ********)(&temp_buffer + 1);\n      temp_char2 = '0';\n      goto LAB_00082d9a;\n    }\n    if (result == 1) {\n      if (is_negative_ptr != (int *)0x0 || (int *)0x9 < piVar20) {\n        ppppppppiVar17 = (int ********)(&temp_buffer + 1);\n        do {\n          current_pos = ppppppppiVar17;\n          uVar25 = (undefined4)((ulonglong)temp_long >> 0x20);\n          base_char = '\\n';\n          __aeabi_uldivmod((int)temp_long,uVar25,10,0);\n          *(char *)current_pos = base_char + '0';\n          temp_long = __aeabi_uldivmod((int)temp_long,uVar25,10,0);\n          ppppppppiVar17 = (int ********)((int)current_pos + -1);\n        } while (temp_long != 0);\n        total_length = (int *******)((int)temp_buffer_ptr - (int)current_pos);\n        goto LAB_00082da0;\n      }\n      temp_char2 = (char)piVar20 + '0';\n      current_pos = (int ********)(&temp_buffer + 1);\n      goto LAB_0008351e;\n    }\n    ppppppppiVar17 = (int ********)(&temp_buffer + 1);\n    if (result != 2) goto LAB_0008337e;\n    do {\n      current_pos = ppppppppiVar17;\n      temp_value = (uint)piVar20 & 0xf;\n      piVar20 = (int *)((uint)piVar20 >> 4 | (int)is_negative_ptr << 0x1c);\n      is_negative_ptr = (int *)((uint)is_negative_ptr >> 4);\n      *(char *)current_pos = str_pointer[temp_value];\n      ppppppppiVar17 = (int ********)((int)current_pos + -1);\n    } while (((uint)piVar20 | (uint)is_negative_ptr) != 0);\n    total_length = (int *******)((int)temp_buffer_ptr - (int)current_pos);\n    goto LAB_00082da0;\n  }\nLAB_000833d0:\n  if (format_parts_sum != (int *******)0x0) {\n    current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n  }\nLAB_000833de:\n  if ((int)((uint)*(ushort *)(format + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return buffer_length;\nLAB_0008337e:\n  do {\n    current_pos = ppppppppiVar17;\n    temp_ptr = (int *)((uint)piVar20 >> 3 | (int)is_negative_ptr << 0x1d);\n    is_negative_ptr = (int *)((uint)is_negative_ptr >> 3);\n    result = ((uint)piVar20 & 7) + 0x30;\n    *(char *)current_pos = (char)result;\n    ppppppppiVar17 = (int ********)((int)current_pos + -1);\n    piVar20 = temp_ptr;\n  } while (((uint)temp_ptr | (uint)is_negative_ptr) != 0);\n  if (is_hash) {\n    if (result == 0x30) {\nLAB_00082d9a:\n      total_length = (int *******)((int)temp_buffer_ptr - (int)current_pos);\n    }\n    else {\n      *(undefined *)((int)current_pos + -1) = 0x30;\n      current_pos = ppppppppiVar17;\n      total_length = (int *******)((int)temp_buffer_ptr - (int)ppppppppiVar17);\n    }\n  }\n  else {\nLAB_0008351e:\n    total_length = (int *******)((int)temp_buffer_ptr - (int)current_pos);\n  }\nLAB_00082da0:\n  current_length = total_length;\n  if ((int)total_length < (int)cur_format_part) {\n    current_length = cur_format_part;\n  }\n  if (cur_char != '\\0') {\n    current_length = (int *******)((int)current_length + 1);\n  }\nLAB_00082dba:\n  if (use_uppercase) {\n    current_length = (int *******)((int)current_length + 2);\n  }\n  if ((flags == 0) &&\n     (pppppppiVar19 = (int *******)((int)pppppppiVar21 - (int)current_length), 0 < (int)pppppppiVar19)) {\n    if ((int)pppppppiVar19 < 0x11) {\n      format_parts_count = format_parts_count + 1;\n    }\n    else {\n      do {\n        cur_format_part2 = pppppppiVar19;\n        result = format_parts_count + 1;\n        format_parts_sum = format_parts_sum + 4;\n        *format_parts = (int *******)0x85808;\n        format_parts[1] = (int *******)0x10;\n        if (result < 8) {\n          loop_counter = format_parts_count + 2;\n          format_parts = format_parts + 2;\n          format_parts_count = result;\n        }\n        else if (format_parts_sum == (int *******)0x0) {\n          loop_counter = 1;\n          format_parts = (int ********)temp_buffer_ptr;\n          format_parts_count = 0;\n        }\n        else {\n          format_parts_count = result;\n          result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n          if (result != 0) goto LAB_000833de;\n          loop_counter = format_parts_count + 1;\n          format_parts = (int ********)temp_buffer_ptr;\n        }\n        pppppppiVar19 = cur_format_part2 + -4;\n      } while (0x10 < (int)pppppppiVar19);\n      pppppppiVar19 = cur_format_part2 + -4;\n      format_parts_count = loop_counter;\n    }\n    format_parts_sum = (int *******)((int)format_parts_sum + (int)pppppppiVar19);\n    *format_parts = (int *******)0x85808;\n    format_parts[1] = pppppppiVar19;\n    if (format_parts_count < 8) {\n      result = format_parts_count + 1;\n      format_parts = format_parts + 2;\n    }\n    else if (format_parts_sum == (int *******)0x0) {\n      result = 1;\n      format_parts_count = 0;\n      format_parts = (int ********)temp_buffer_ptr;\n    }\n    else {\n      result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n      if (result != 0) goto LAB_000833de;\n      result = format_parts_count + 1;\n      format_parts = (int ********)temp_buffer_ptr;\n    }\n  }\n  else {\n    result = format_parts_count + 1;\n  }\n  loop_counter = result;\n  if (sign_char != '\\0') {\n    format_parts_sum = (int *******)((int)format_parts_sum + 1);\n    loop_counter = 1;\n    *format_parts = (int *******)&sign_char;\n    format_parts[1] = (int *******)0x1;\n    format_parts_count = result;\n    if (result < 8) {\n      loop_counter = result + 1;\n      format_parts = format_parts + 2;\n    }\n    else if (format_parts_sum == (int *******)0x0) {\n      format_parts_count = 0;\n      format_parts = (int ********)temp_buffer_ptr;\n    }\n    else {\n      result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n      if (result != 0) goto LAB_000833de;\n      loop_counter = format_parts_count + 1;\n      format_parts = (int ********)temp_buffer_ptr;\n    }\n  }\n  result = loop_counter;\n  iVar18 = format_parts_count;\n  if (use_uppercase) {\n    format_parts_sum = (int *******)((int)format_parts_sum + 2);\n    *format_parts = (int *******)&padding_char;\n    format_parts[1] = (int *******)0x2;\n    if (loop_counter < 8) {\n      result = loop_counter + 1;\n      iVar18 = loop_counter;\n      format_parts = format_parts + 2;\n    }\n    else if (format_parts_sum == (int *******)0x0) {\n      result = 1;\n      iVar18 = 0;\n      format_parts = (int ********)temp_buffer_ptr;\n    }\n    else {\n      format_parts_count = loop_counter;\n      result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n      if (result != 0) goto LAB_000833de;\n      result = format_parts_count + 1;\n      iVar18 = format_parts_count;\n      format_parts = (int ********)temp_buffer_ptr;\n    }\n  }\n  format_parts_count = iVar18;\n  if ((flags == 0x80) &&\n     (pppppppiVar19 = (int *******)((int)pppppppiVar21 - (int)current_length), 0 < (int)pppppppiVar19)) {\n    if (0x10 < (int)pppppppiVar19) {\n      do {\n        while( true ) {\n          cur_format_part2 = pppppppiVar19;\n          format_parts_count = iVar18 + 1;\n          format_parts_sum = format_parts_sum + 4;\n          *format_parts = (int *******)&zeroes_6718;\n          format_parts[1] = (int *******)0x10;\n          if (7 < format_parts_count) break;\n          result = iVar18 + 2;\n          format_parts = format_parts + 2;\nLAB_0008348e:\n          iVar18 = format_parts_count;\n          pppppppiVar19 = cur_format_part2 + -4;\n          if ((int)(cur_format_part2 + -4) < 0x11) goto LAB_000834b4;\n        }\n        if (format_parts_sum != (int *******)0x0) {\n          result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n          if (result == 0) {\n            result = format_parts_count + 1;\n            format_parts = (int ********)temp_buffer_ptr;\n            goto LAB_0008348e;\n          }\n          goto LAB_000833de;\n        }\n        result = 1;\n        iVar18 = 0;\n        pppppppiVar19 = cur_format_part2 + -4;\n        format_parts = (int ********)temp_buffer_ptr;\n      } while (0x10 < (int)(cur_format_part2 + -4));\nLAB_000834b4:\n      pppppppiVar19 = cur_format_part2 + -4;\n    }\n    format_parts_sum = (int *******)((int)format_parts_sum + (int)pppppppiVar19);\n    *format_parts = (int *******)&zeroes_6718;\n    format_parts[1] = pppppppiVar19;\n    format_parts_count = result;\n    if (result < 8) {\n      result = result + 1;\n      format_parts = format_parts + 2;\n    }\n    else if (format_parts_sum == (int *******)0x0) {\n      result = 1;\n      format_parts_count = 0;\n      format_parts = (int ********)temp_buffer_ptr;\n    }\n    else {\n      result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n      if (result != 0) goto LAB_000833de;\n      result = format_parts_count + 1;\n      format_parts = (int ********)temp_buffer_ptr;\n    }\n  }\n  cur_format_part = (int *******)((int)cur_format_part - (int)total_length);\n  ppppppppiVar17 = (int ********)temp_buffer_ptr;\n  if ((int)cur_format_part < 1) {\nLAB_000832c6:\n    format_parts_sum = (int *******)((int)format_parts_sum + (int)total_length);\n    *format_parts = (int *******)current_pos;\n    format_parts[1] = total_length;\n    total_length = format_parts_sum;\n    format_parts_count = result;\n    if (result < 8) goto LAB_0008345a;\n    if (format_parts_sum == (int *******)0x0) {\n      format_parts_count = 0;\n    }\n    else {\n      result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n      if (result != 0) goto LAB_000833de;\n    }\n  }\n  else {\n    loop_counter = format_parts_count;\n    if (0x10 < (int)cur_format_part) {\n      do {\n        while( true ) {\n          pppppppiVar19 = cur_format_part;\n          format_parts_count = loop_counter + 1;\n          format_parts_sum = format_parts_sum + 4;\n          *format_parts = (int *******)&zeroes_6718;\n          format_parts[1] = (int *******)0x10;\n          if (7 < format_parts_count) break;\n          result = loop_counter + 2;\n          format_parts = format_parts + 2;\nLAB_00083282:\n          loop_counter = format_parts_count;\n          cur_format_part = pppppppiVar19 + -4;\n          if ((int)(pppppppiVar19 + -4) < 0x11) goto LAB_000832aa;\n        }\n        if (format_parts_sum != (int *******)0x0) {\n          result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n          if (result == 0) {\n            result = format_parts_count + 1;\n            format_parts = (int ********)temp_buffer_ptr;\n            goto LAB_00083282;\n          }\n          goto LAB_000833de;\n        }\n        result = 1;\n        format_parts = (int ********)temp_buffer_ptr;\n        loop_counter = 0;\n        cur_format_part = pppppppiVar19 + -4;\n      } while (0x10 < (int)(pppppppiVar19 + -4));\nLAB_000832aa:\n      cur_format_part = pppppppiVar19 + -4;\n    }\n    format_parts_sum = (int *******)((int)format_parts_sum + (int)cur_format_part);\n    *format_parts = (int *******)&zeroes_6718;\n    format_parts[1] = cur_format_part;\n    if (result < 8) {\n      result = result + 1;\n      format_parts = format_parts + 2;\n      goto LAB_000832c6;\n    }\n    if (format_parts_sum != (int *******)0x0) {\n      format_parts_count = result;\n      result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n      if (result != 0) goto LAB_000833de;\n      result = format_parts_count + 1;\n      format_parts = (int ********)temp_buffer_ptr;\n      goto LAB_000832c6;\n    }\n    format_parts_stack[0] = total_length;\n    format_parts_count = 1;\n    format_parts = (int ********)temp_buffer_ptr;\n    temp_buffer_ptr = (undefined  [4])current_pos;\nLAB_0008345a:\n    ppppppppiVar17 = format_parts + 2;\n    format_parts_sum = total_length;\n  }\n  if (((flags & 4) != 0) &&\n     (cur_format_part = (int *******)((int)pppppppiVar21 - (int)current_length), 0 < (int)cur_format_part)) {\n    result = format_parts_count;\n    if ((int)cur_format_part < 0x11) {\n      loop_counter = format_parts_count + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          format_parts_count = result + 1;\n          format_parts_sum = format_parts_sum + 4;\n          *ppppppppiVar17 = (int *******)0x85808;\n          ppppppppiVar17[1] = (int *******)0x10;\n          if (7 < format_parts_count) break;\n          loop_counter = result + 2;\n          ppppppppiVar17 = ppppppppiVar17 + 2;\nLAB_00083316:\n          cur_format_part = cur_format_part + -4;\n          result = format_parts_count;\n          if ((int)cur_format_part < 0x11) goto LAB_0008333e;\n        }\n        if (format_parts_sum != (int *******)0x0) {\n          result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n          if (result == 0) {\n            loop_counter = format_parts_count + 1;\n            ppppppppiVar17 = (int ********)temp_buffer_ptr;\n            goto LAB_00083316;\n          }\n          goto LAB_000833de;\n        }\n        cur_format_part = cur_format_part + -4;\n        loop_counter = 1;\n        result = 0;\n        ppppppppiVar17 = (int ********)temp_buffer_ptr;\n      } while (0x10 < (int)cur_format_part);\n    }\nLAB_0008333e:\n    format_parts_sum = (int *******)((int)format_parts_sum + (int)cur_format_part);\n    *ppppppppiVar17 = (int *******)0x85808;\n    ppppppppiVar17[1] = cur_format_part;\n    format_parts_count = loop_counter;\n    if (7 < loop_counter) {\n      if (format_parts_sum == (int *******)0x0) {\n        if ((int)current_length < (int)pppppppiVar21) {\n          current_length = pppppppiVar21;\n        }\n        buffer_length = buffer_length + (int)current_length;\n        goto LAB_00083422;\n      }\n      result = current_posprint_r_part_0(buffer,format,&format_parts_ptr);\n      if (result != 0) goto LAB_000833de;\n    }\n  }\n  if ((int)current_length < (int)pppppppiVar21) {\n    current_length = pppppppiVar21;\n  }\n  buffer_length = buffer_length + (int)current_length;\n  if ((format_parts_sum != (int *******)0x0) &&\n     (result = current_posprint_r_part_0(buffer,format,&format_parts_ptr), result != 0)) goto LAB_000833de;\nLAB_00083422:\n  format_parts_count = 0;\n  format_parts = (int ********)temp_buffer_ptr;\n  goto LAB_00082b9e;\nswitchD_00082c20_caseD_31:\n  digit = temp_value - 0x30;\n  pppppppiVar21 = (int *******)0x0;\n  cur_format_part = arg_list;\n  do {\n    arg_list = (int *******)((int)cur_format_part + 1);\n    temp_value = (uint)*(byte *)cur_format_part;\n    pppppppiVar21 = (int *******)(digit + (int)pppppppiVar21 * 10);\n    digit = temp_value - 0x30;\n    cur_format_part = arg_list;\n  } while (digit < 10);\n  goto LAB_00082c16;\nswitchD_00082c20_caseD_20:\n  temp_value = (uint)*(byte *)arg_list;\n  if (sign_char == '\\0') {\n    sign_char = ' ';\n  }\n  goto LAB_00082c12;\n}\n\n",
            "renaming": {
                "FUN_00082b38": "print_formatted_string_00082b38",
                "param_1": "buffer",
                "param_2": "format",
                "param_3": "arg_list",
                "param_4": "arg_list_ptr",
                "bVar1": "is_negative",
                "bVar2": "is_decimal",
                "bVar3": "is_hash",
                "cVar4": "cur_char",
                "bVar5": "use_uppercase",
                "pvVar6": "pointer",
                "ppppppppiVar7": "format_parts",
                "piVar8": "temp_ptr",
                "iVar9": "result",
                "cVar10": "base_char",
                "uVar12": "digit",
                "piVar13": "arg_ptr",
                "uVar14": "flags",
                "uVar15": "temp_value",
                "iVar16": "loop_counter",
                "pppppppiVar11": "cur_format_part",
                "uVar22": "temp_value2",
                "piVar23": "is_negative_ptr",
                "pppppppiVar24": "cur_format_part2",
                "__s": "current_pos",
                "bVar26": "temp_bool",
                "lVar27": "temp_long",
                "local_dc": "current_length",
                "local_d4": "total_length",
                "local_c8": "arg_list_ptr_copy",
                "local_c4": "buffer_length",
                "local_c0": "str_pointer",
                "local_a1": "sign_char",
                "local_a0": "padding_char",
                "local_9f": "base_prefix_char",
                "local_9c": "format_parts_ptr",
                "local_98": "format_parts_count",
                "local_94": "format_parts_sum",
                "local_90": "temp_char",
                "cStack_6a": "temp_buffer",
                "local_69": "temp_char2",
                "local_68": "temp_buffer_ptr",
                "local_64": "format_parts_stack"
            },
            "calling": [
                "__sbprintf",
                "iprintf"
            ],
            "called": [
                "memchr",
                "__sbprintf",
                "__swsetup_r",
                "__sprint_r.part.0",
                "strlen",
                "__sinit",
                "__aeabi_uldivmod"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008378c": {
            "entrypoint": "0x0008378c",
            "current_name": "print_and_flush_buffer_0008378c",
            "code": "\nint print_and_flush_buffer_0008378c(undefined4 stream,int buffer)\n\n{\n  int printf_result;\n  int flush_result;\n  undefined *ptr_buffer [2];\n  undefined4 buffer_size;\n  ushort modified_value;\n  undefined2 current_value;\n  undefined *output_buffer;\n  undefined4 flush_buffer_size;\n  undefined4 unused_value;\n  undefined4 second_value;\n  undefined4 third_value;\n  undefined4 first_value;\n  undefined stack_buffer [1024];\n  \n  first_value = *(undefined4 *)(buffer + 100);\n  second_value = *(undefined4 *)(buffer + 0x1c);\n  current_value = *(undefined2 *)(buffer + 0xe);\n  third_value = *(undefined4 *)(buffer + 0x24);\n  ptr_buffer[0] = stack_buffer;\n  modified_value = *(ushort *)(buffer + 0xc) & 0xfffd;\n  buffer_size = 0x400;\n  flush_buffer_size = 0x400;\n  unused_value = 0;\n  output_buffer = ptr_buffer[0];\n  printf_result = _vfiprintf_r(stream,ptr_buffer);\n  if ((-1 < printf_result) && (flush_result = _fflush_r(stream,ptr_buffer), flush_result != 0)) {\n    printf_result = -1;\n  }\n  if ((int)((uint)modified_value << 0x19) < 0) {\n    *(ushort *)(buffer + 0xc) = *(ushort *)(buffer + 0xc) | 0x40;\n  }\n  return printf_result;\n}\n\n",
            "renaming": {
                "FUN_0008378c": "print_and_flush_buffer_0008378c",
                "param_1": "stream",
                "param_2": "buffer",
                "local_488": "ptr_buffer",
                "local_480": "buffer_size",
                "local_47c": "modified_value",
                "local_47a": "current_value",
                "local_478": "output_buffer",
                "local_474": "flush_buffer_size",
                "local_470": "unused_value",
                "local_46c": "second_value",
                "local_464": "third_value",
                "local_424": "first_value",
                "auStack_420": "stack_buffer",
                "iVar1": "printf_result",
                "iVar2": "flush_result"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "_vfiprintf_r",
                "_fflush_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083808": {
            "entrypoint": "0x00083808",
            "current_name": "process_data_00083808",
            "code": "\nundefined4 processData_00083808(undefined4 *outputStatus,int *inputData)\n\n{\n  int tempVar1;\n  int tempVar2;\n  uint tempVar3;\n  ushort tempVar4;\n  \n  if ((_impure_ptr != 0) && (*(int *)(_impure_ptr + 0x38) == 0)) {\n    __sinit();\n  }\n  tempVar4 = *(ushort *)(inputData + 3);\n  tempVar3 = (uint)tempVar4;\n  if ((int)(tempVar3 << 0x1c) < 0) {\n    tempVar2 = inputData[4];\n  }\n  else {\n    if (-1 < (int)(tempVar3 << 0x1b)) {\n      *outputStatus = 9;\n      *(ushort *)(inputData + 3) = tempVar4 | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(tempVar3 << 0x1d) < 0) {\n      if ((int *)inputData[0xc] != (int *)0x0) {\n        if ((int *)inputData[0xc] != inputData + 0x10) {\n          _free_r(outputStatus);\n          tempVar4 = *(ushort *)(inputData + 3);\n        }\n        inputData[0xc] = 0;\n      }\n      tempVar2 = inputData[4];\n      tempVar4 = tempVar4 & 0xffdb;\n      *inputData = tempVar2;\n      inputData[1] = 0;\n    }\n    else {\n      tempVar2 = inputData[4];\n    }\n    *(ushort *)(inputData + 3) = tempVar4 | 8;\n    tempVar3 = (uint)(tempVar4 | 8);\n  }\n  if ((tempVar2 == 0) && ((tempVar3 & 0x280) != 0x200)) {\n    __smakebuf_r(outputStatus,inputData);\n    tempVar3 = (uint)*(ushort *)(inputData + 3);\n    tempVar2 = inputData[4];\n  }\n  if ((tempVar3 & 1) == 0) {\n    tempVar1 = 0;\n    if (-1 < (int)(tempVar3 << 0x1e)) {\n      tempVar1 = inputData[5];\n    }\n    inputData[2] = tempVar1;\n  }\n  else {\n    inputData[6] = -inputData[5];\n    inputData[2] = 0;\n  }\n  if ((tempVar2 == 0) && ((int)((uint)*(ushort *)(inputData + 3) << 0x18) < 0)) {\n    *(ushort *)(inputData + 3) = *(ushort *)(inputData + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083808": "process_data_00083808",
                "param_1": "outputStatus",
                "param_2": "inputData",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4"
            },
            "calling": [
                "__swbuf_r",
                "__sfvwrite_r",
                "_vfiprintf_r"
            ],
            "called": [
                "_free_r",
                "__sinit",
                "__smakebuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000838cc": {
            "entrypoint": "0x000838cc",
            "current_name": "update_data_000838cc",
            "code": "\nundefined4 updateData_000838cc(int dataType,undefined4 newValue,undefined4 field1,undefined4 field2)\n\n{\n  undefined4 *ptrData;\n  uint index;\n  uint bitMask;\n  \n  if (DAT_20070180 == (undefined4 *)0x0) {\n    DAT_20070180 = (undefined4 *)&DAT_20070184;\n  }\n  index = DAT_20070180[1];\n  ptrData = DAT_20070180;\n  if (0x1f < (int)index) {\n    ptrData = (undefined4 *)malloc(400);\n    if (ptrData == (undefined4 *)0x0) {\n      return 0xffffffff;\n    }\n    *ptrData = DAT_20070180;\n    ptrData[1] = 0;\n    index = 0;\n    DAT_20070180 = ptrData;\n    ptrData[0x62] = 0;\n    ptrData[99] = 0;\n  }\n  if (dataType != 0) {\n    bitMask = 1 << (index & 0xff);\n    ptrData[index + 0x22] = field1;\n    ptrData[0x62] = ptrData[0x62] | bitMask;\n    ptrData[index + 0x42] = field2;\n    if (dataType == 2) {\n      ptrData[99] = bitMask | ptrData[99];\n    }\n  }\n  ptrData[1] = index + 1;\n  ptrData[index + 2] = newValue;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000838cc": "update_data_000838cc",
                "param_1": "dataType",
                "param_2": "newValue",
                "param_3": "field1",
                "param_4": "field2",
                "puVar1": "ptrData",
                "uVar2": "index",
                "uVar3": "bitMask"
            },
            "calling": [
                "atexit",
                "__cxa_atexit"
            ],
            "called": [
                "malloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083974": {
            "entrypoint": "0x00083974",
            "current_name": "FUNC_00083974",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083978) */\n\nvoid FUNC_00083974(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083974": "FUNC_00083974"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "atexit"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083988": {
            "entrypoint": "0x00083988",
            "current_name": "register_exit_proc_00083988",
            "code": "\nint registerExitProc_00083988(function *function)\n\n{\n  int result;\n  \n  result = __register_exitproc(0,function,0,0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00083988": "register_exit_proc_00083988",
                "__func": "function",
                "iVar1": "result"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083994": {
            "entrypoint": "0x00083994",
            "current_name": "process_data_00083994",
            "code": "\nundefined4 processData_00083994(int *dataBuffer,int *infoArray)\n\n{\n  int *tempVar1;\n  int tempVar2;\n  ushort flags;\n  uint tempVar4;\n  int tempVar5;\n  code *functionPtr;\n  int tempVar7;\n  \n  flags = *(ushort *)(infoArray + 3);\n  if ((int)((uint)flags << 0x1c) < 0) {\n    tempVar7 = infoArray[4];\n    if (tempVar7 == 0) {\n      return 0;\n    }\n    tempVar2 = *infoArray;\n    if ((flags & 3) == 0) {\n      tempVar5 = infoArray[5];\n    }\n    else {\n      tempVar5 = 0;\n    }\n    *infoArray = tempVar7;\n    tempVar2 = tempVar2 - tempVar7;\n    infoArray[2] = tempVar5;\n    do {\n      if (tempVar2 < 1) {\n        return 0;\n      }\n      tempVar5 = (*(code *)infoArray[9])(dataBuffer,infoArray[7],tempVar7,tempVar2);\n      tempVar2 = tempVar2 - tempVar5;\n      tempVar7 = tempVar7 + tempVar5;\n    } while (0 < tempVar5);\nLAB_00083a54:\n    *(ushort *)(infoArray + 3) = *(ushort *)(infoArray + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(infoArray + 3) = flags | 0x800;\n  if ((infoArray[1] < 1) && (infoArray[0xf] < 1)) {\n    return 0;\n  }\n  functionPtr = (code *)infoArray[10];\n  if (functionPtr == (code *)0x0) {\n    return 0;\n  }\n  tempVar4 = (uint)(flags | 0x800);\n  tempVar7 = *dataBuffer;\n  *dataBuffer = 0;\n  if ((flags & 0x1000) == 0) {\n    tempVar2 = (*functionPtr)(dataBuffer,infoArray[7],tempVar4 & 0x1000,1);\n    if ((tempVar2 == -1) && (tempVar5 = *dataBuffer, tempVar5 != 0)) {\n      if ((tempVar5 == 0x1d) || (tempVar5 == 0x16)) {\n        *dataBuffer = tempVar7;\n        return 0;\n      }\n      goto LAB_00083a54;\n    }\n    tempVar4 = (uint)*(ushort *)(infoArray + 3);\n    functionPtr = (code *)infoArray[10];\n  }\n  else {\n    tempVar2 = infoArray[0x14];\n  }\n  if (((int)(tempVar4 << 0x1d) < 0) && (tempVar2 = tempVar2 - infoArray[1], infoArray[0xc] != 0)) {\n    tempVar2 = tempVar2 - infoArray[0xf];\n  }\n  tempVar2 = (*functionPtr)(dataBuffer,infoArray[7],tempVar2,0);\n  if (tempVar2 == -1) {\n    tempVar5 = *dataBuffer;\n    if (tempVar5 != 0) {\n      if ((tempVar5 != 0x1d) && (tempVar5 != 0x16)) {\n        *(ushort *)(infoArray + 3) = *(ushort *)(infoArray + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(infoArray + 3) = *(ushort *)(infoArray + 3) & 0xf7ff;\n      *infoArray = infoArray[4];\n      infoArray[1] = 0;\n      goto LAB_00083a00;\n    }\n    flags = *(ushort *)(infoArray + 3) & 0xf7ff;\n    infoArray[1] = 0;\n    *(ushort *)(infoArray + 3) = flags;\n    *infoArray = infoArray[4];\n  }\n  else {\n    flags = *(ushort *)(infoArray + 3) & 0xf7ff;\n    *infoArray = infoArray[4];\n    *(ushort *)(infoArray + 3) = flags;\n    infoArray[1] = 0;\n  }\n  if ((int)((uint)flags << 0x13) < 0) {\n    infoArray[0x14] = tempVar2;\n  }\nLAB_00083a00:\n  tempVar1 = (int *)infoArray[0xc];\n  *dataBuffer = tempVar7;\n  if (tempVar1 == (int *)0x0) {\n    return 0;\n  }\n  if (tempVar1 != infoArray + 0x10) {\n    _free_r(dataBuffer);\n  }\n  infoArray[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083994": "process_data_00083994",
                "param_1": "dataBuffer",
                "param_2": "infoArray",
                "piVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "flags",
                "uVar4": "tempVar4",
                "iVar5": "tempVar5",
                "pcVar6": "functionPtr",
                "iVar7": "tempVar7"
            },
            "calling": [
                "_fflush_r"
            ],
            "called": [
                "_free_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083adc": {
            "entrypoint": "0x00083adc",
            "current_name": "initialize_if_needed_00083adc",
            "code": "\nvoid initializeIfNeeded_00083adc(int ptr,int data)\n\n{\n  if ((ptr != 0) && (*(int *)(ptr + 0x38) == 0)) {\n    initializeStreams();\n  }\n  if (*(short *)(data + 0xc) == 0) {\n    return;\n  }\n  flushStream(ptr);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083adc": "initialize_if_needed_00083adc",
                "param_1": "ptr",
                "param_2": "data",
                "__sinit()": "initializeStreams()",
                "__sflush_r(param_1)": "flushStream(ptr)"
            },
            "calling": [
                "__swbuf_r",
                "__sbprintf",
                "__sfvwrite_r",
                "_fclose_r"
            ],
            "called": [
                "__sflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b08": {
            "entrypoint": "0x00083b08",
            "current_name": "perform_file_walk_00083b08",
            "code": "\nvoid performFileWalk_00083b08(undefined4 ptr)\n\n{\n  fileWalk(ptr,0x846a5);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b08": "perform_file_walk_00083b08",
                "param_1": "ptr",
                "_fwalk": "fileWalk"
            },
            "calling": [],
            "called": [
                "_fwalk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b14": {
            "entrypoint": "0x00083b14",
            "current_name": "initialize_data_structures_00083b14",
            "code": "\nvoid initializeDataStructures_00083b14(int dataStructure)\n\n{\n  undefined4 *pointer1;\n  undefined4 *pointer2;\n  \n  if (*(int *)(dataStructure + 0x38) == 0) {\n    pointer1 = *(undefined4 **)(dataStructure + 4);\n    *(undefined4 *)(dataStructure + 0x3c) = 0x83b09;\n    *(undefined4 *)(dataStructure + 0x2e4) = 3;\n    *(int *)(dataStructure + 0x2e8) = dataStructure + 0x2ec;\n    *(undefined4 *)(dataStructure + 0x2e0) = 0;\n    *(undefined2 *)(pointer1 + 3) = 4;\n    *pointer1 = 0;\n    pointer1[1] = 0;\n    pointer1[2] = 0;\n    pointer1[0x19] = 0;\n    *(undefined2 *)((int)pointer1 + 0xe) = 0;\n    pointer1[4] = 0;\n    pointer1[5] = 0;\n    pointer1[6] = 0;\n    memset(pointer1 + 0x17,0,8);\n    pointer2 = *(undefined4 **)(dataStructure + 8);\n    pointer1[7] = pointer1;\n    pointer1[8] = 0x84441;\n    pointer1[9] = 0x84465;\n    pointer1[10] = 0x8449d;\n    pointer1[0xb] = 0x844bd;\n    *(undefined2 *)((int)pointer2 + 0xe) = 1;\n    *(undefined2 *)(pointer2 + 3) = 9;\n    *pointer2 = 0;\n    pointer2[1] = 0;\n    pointer2[2] = 0;\n    pointer2[0x19] = 0;\n    pointer2[4] = 0;\n    pointer2[5] = 0;\n    pointer2[6] = 0;\n    memset(pointer2 + 0x17,0,8);\n    pointer1 = *(undefined4 **)(dataStructure + 0xc);\n    pointer2[7] = pointer2;\n    pointer2[8] = 0x84441;\n    pointer2[9] = 0x84465;\n    pointer2[10] = 0x8449d;\n    pointer2[0xb] = 0x844bd;\n    *(undefined2 *)(pointer1 + 3) = 0x12;\n    *(undefined2 *)((int)pointer1 + 0xe) = 2;\n    *pointer1 = 0;\n    pointer1[1] = 0;\n    pointer1[2] = 0;\n    pointer1[0x19] = 0;\n    pointer1[4] = 0;\n    pointer1[5] = 0;\n    pointer1[6] = 0;\n    memset(pointer1 + 0x17,0,8);\n    pointer1[7] = pointer1;\n    pointer1[8] = 0x84441;\n    pointer1[9] = 0x84465;\n    pointer1[10] = 0x8449d;\n    pointer1[0xb] = 0x844bd;\n    *(undefined4 *)(dataStructure + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b14": "initialize_data_structures_00083b14",
                "param_1": "dataStructure",
                "puVar1": "pointer1",
                "puVar2": "pointer2"
            },
            "calling": [
                "__swbuf_r",
                "__swsetup_r",
                "_vfiprintf_r",
                "_fflush_r",
                "_fclose_r"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083c08": {
            "entrypoint": "0x00083c08",
            "current_name": "FUNC_00083c08",
            "code": "\nvoid FUNC_00083c08(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c08": "FUNC_00083c08"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083c0c": {
            "entrypoint": "0x00083c0c",
            "current_name": "FUNC_00083c0c",
            "code": "\nvoid FUNC_00083c0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c0c": "FUNC_00083c0c"
            },
            "calling": [
                "_fclose_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083c10": {
            "entrypoint": "0x00083c10",
            "current_name": "execute_fini_functions_00083c10",
            "code": "\nvoid execute_fini_functions_00083c10(void)\n\n{\n  int counter;\n  code **function_pointer_array;\n  \n  counter = 1;\n  function_pointer_array = (code **)&__fini_array_end;\n  do {\n    counter = counter + -1;\n    function_pointer_array = function_pointer_array + -1;\n    (**function_pointer_array)();\n  } while (counter != 0);\n  _fini();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083c10": "execute_fini_functions_00083c10",
                "iVar1": "counter",
                "ppcVar2": "function_pointer_array"
            },
            "calling": [],
            "called": [
                "_fini",
                "__do_global_dtors_aux"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083c40": {
            "entrypoint": "0x00083c40",
            "current_name": "convert_and_write_to_buffer_00083c40",
            "code": "\nuint convertAndWriteToBuffer_00083c40(undefined4 stream,uint value,byte **buffer)\n\n{\n  int mb_cur_max;\n  uint result;\n  uint convertedValue;\n  byte *bufferPointer;\n  uint index;\n  byte valueByte;\n  byte conversionBuffer [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(buffer + 3) << 0x12)) {\n    *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x2000;\n    buffer[0x19] = (byte *)((uint)buffer[0x19] | 0x2000);\n  }\n  mb_cur_max = __locale_mb_cur_max();\n  if ((mb_cur_max == 1) && (value - 1 < 0xff)) {\n    convertedValue = value & 0xff;\n    valueByte = (byte)convertedValue;\n    result = 1;\n  }\n  else {\n    result = _wcrtomb_r(stream,&valueByte,value,buffer + 0x17);\n    if (result == 0xffffffff) {\n      *(ushort *)(buffer + 3) = *(ushort *)(buffer + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (result == 0) {\n      return value;\n    }\n    convertedValue = (uint)valueByte;\n  }\n  index = 0;\n  do {\n    bufferPointer = buffer[2] + -1;\n    buffer[2] = bufferPointer;\n    if ((int)bufferPointer < 0) {\n      if ((int)buffer[6] <= (int)bufferPointer) {\n        **buffer = (byte)convertedValue;\n        bufferPointer = *buffer;\n        convertedValue = (uint)*bufferPointer;\n        if (convertedValue != 10) goto LAB_00083c90;\n      }\n      mb_cur_max = __swbuf_r(stream,convertedValue,buffer);\n      if (mb_cur_max == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **buffer = (byte)convertedValue;\n      bufferPointer = *buffer;\nLAB_00083c90:\n      *buffer = bufferPointer + 1;\n    }\n    if (result <= index + 1) {\n      return value;\n    }\n    convertedValue = (uint)conversionBuffer[index];\n    index = index + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00083c40": "convert_and_write_to_buffer_00083c40",
                "param_1": "stream",
                "param_2": "value",
                "param_3": "buffer",
                "iVar1": "mb_cur_max",
                "uVar2": "result",
                "uVar3": "convertedValue",
                "pbVar4": "bufferPointer",
                "uVar5": "index",
                "local_1c": "valueByte",
                "abStack_1b": "conversionBuffer"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "__swbuf_r",
                "__locale_mb_cur_max",
                "_wcrtomb_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083d00": {
            "entrypoint": "0x00083d00",
            "current_name": "allocate_memory_00083d00",
            "code": "\nundefined4 allocate_memory_00083d00(undefined4 lock,int size)\n\n{\n  int allocation_result;\n  uint heap_size;\n  int allocation_size;\n  \n  __malloc_lock();\n  heap_size = *(uint *)(DAT_2007046c + 4) & 0xfffffffc;\n  allocation_size = ((heap_size - size) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < allocation_size) {\n    allocation_result = _sbrk_r(lock,0);\n    if (allocation_result == DAT_2007046c + heap_size) {\n      allocation_result = _sbrk_r(lock,-allocation_size);\n      if (allocation_result != -1) {\n        __malloc_current_mallinfo = __malloc_current_mallinfo - allocation_size;\n        *(uint *)(DAT_2007046c + 4) = heap_size - allocation_size | 1;\n        __malloc_unlock(lock);\n        return 1;\n      }\n      allocation_size = _sbrk_r(lock,0);\n      if (0xf < allocation_size - DAT_2007046c) {\n        __malloc_current_mallinfo = allocation_size - __malloc_sbrk_base;\n        *(uint *)(DAT_2007046c + 4) = allocation_size - DAT_2007046c | 1;\n      }\n    }\n  }\n  __malloc_unlock(lock);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083d00": "allocate_memory_00083d00",
                "param_1": "lock",
                "param_2": "size",
                "iVar1": "allocation_result",
                "uVar2": "heap_size",
                "iVar3": "allocation_size"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083d9c": {
            "entrypoint": "0x00083d9c",
            "current_name": "deallocate_memory_block_00083d9c",
            "code": "\nvoid deallocateMemoryBlock_00083d9c(undefined4 lock,int memoryBlock)\n\n{\n  undefined4 *ptr;\n  bool bVar2;\n  uint size;\n  int tempVar1;\n  int tempVar2;\n  undefined1 *ptr1;\n  uint tempVar3;\n  undefined1 *ptr2;\n  int tempVar4;\n  uint tempVar5;\n  \n  if (memoryBlock == 0) {\n    return;\n  }\n  acquireLock();\n  size = *(uint *)(memoryBlock + -4);\n  tempVar4 = memoryBlock + -8;\n  tempVar3 = size & 0xfffffffe;\n  tempVar2 = tempVar4 + tempVar3;\n  tempVar5 = *(uint *)(tempVar2 + 4) & 0xfffffffc;\n  if (DAT_2007046c == tempVar2) {\n    tempVar5 = tempVar5 + tempVar3;\n    if (-1 < (int)(size << 0x1f)) {\n      tempVar4 = tempVar4 - *(int *)(memoryBlock + -8);\n      tempVar1 = *(int *)(tempVar4 + 0xc);\n      tempVar2 = *(int *)(tempVar4 + 8);\n      tempVar5 = tempVar5 + *(int *)(memoryBlock + -8);\n      *(int *)(tempVar2 + 0xc) = tempVar1;\n      *(int *)(tempVar1 + 8) = tempVar2;\n    }\n    size = trimThreshold;\n    *(uint *)(tempVar4 + 4) = tempVar5 | 1;\n    DAT_2007046c = tempVar4;\n    if (size <= tempVar5) {\n      trimMemory(lock,trimThreshold);\n    }\n  }\n  else {\n    *(uint *)(tempVar2 + 4) = tempVar5;\n    if ((size & 1) == 0) {\n      tempVar4 = tempVar4 - *(int *)(memoryBlock + -8);\n      ptr = *(undefined4 **)(tempVar4 + 8);\n      tempVar3 = tempVar3 + *(int *)(memoryBlock + -8);\n      if (ptr == &DAT_2007046c) {\n        bVar2 = true;\n      }\n      else {\n        tempVar1 = *(int *)(tempVar4 + 0xc);\n        ptr[3] = tempVar1;\n        *(undefined4 **)(tempVar1 + 8) = ptr;\n        bVar2 = false;\n      }\n    }\n    else {\n      bVar2 = false;\n    }\n    if (-1 < *(int *)(tempVar2 + tempVar5 + 4) << 0x1f) {\n      tempVar3 = tempVar3 + tempVar5;\n      ptr = *(undefined4 **)(tempVar2 + 8);\n      if ((!bVar2) && (ptr == &DAT_2007046c)) {\n        DAT_20070474 = tempVar4;\n        DAT_20070478 = tempVar4;\n        *(int **)(tempVar4 + 0xc) = &DAT_2007046c;\n        *(int **)(tempVar4 + 8) = &DAT_2007046c;\n        *(uint *)(tempVar4 + 4) = tempVar3 | 1;\n        *(uint *)(tempVar4 + tempVar3) = tempVar3;\n        goto LAB_00083e30;\n      }\n      tempVar2 = *(int *)(tempVar2 + 0xc);\n      ptr[3] = tempVar2;\n      *(undefined4 **)(tempVar2 + 8) = ptr;\n    }\n    *(uint *)(tempVar4 + 4) = tempVar3 | 1;\n    *(uint *)(tempVar4 + tempVar3) = tempVar3;\n    if (!bVar2) {\n      if (tempVar3 < 0x200) {\n        size = tempVar3 & 0xfffffff8;\n        tempVar2 = *(int *)((int)&DAT_2007046c + size);\n        DAT_20070468 = DAT_20070468 | 1 << ((int)(tempVar3 >> 3) >> 2 & 0xffU);\n        *(int *)(tempVar4 + 8) = tempVar2;\n        *(undefined1 **)(tempVar4 + 0xc) = &freeList_ + size;\n        *(int *)((int)&DAT_2007046c + size) = tempVar4;\n        *(int *)(tempVar2 + 0xc) = tempVar4;\n        __malloc_unlock(lock);\n        return;\n      }\n      size = tempVar3 >> 9;\n      if (size < 5) {\n        tempVar2 = (tempVar3 >> 6) + 0x38;\n        tempVar1 = tempVar2 * 2;\n      }\n      else if (size < 0x15) {\n        tempVar2 = size + 0x5b;\n        tempVar1 = tempVar2 * 2;\n      }\n      else if (size < 0x55) {\n        tempVar2 = (tempVar3 >> 0xc) + 0x6e;\n        tempVar1 = tempVar2 * 2;\n      }\n      else if (size < 0x155) {\n        tempVar2 = (tempVar3 >> 0xf) + 0x77;\n        tempVar1 = tempVar2 * 2;\n      }\n      else if (size < 0x555) {\n        tempVar2 = (tempVar3 >> 0x12) + 0x7c;\n        tempVar1 = tempVar2 * 2;\n      }\n      else {\n        tempVar1 = 0xfc;\n        tempVar2 = 0x7e;\n      }\n      ptr1 = (undefined1 *)(&DAT_2007046c)[tempVar1];\n      if (ptr1 == &freeList_ + tempVar1 * 4) {\n        DAT_20070468 = DAT_20070468 | 1 << (tempVar2 >> 2 & 0xffU);\n        ptr2 = ptr1;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr1 + 4) & 0xfffffffc) <= tempVar3) break;\n          ptr1 = *(undefined1 **)(ptr1 + 8);\n        } while (&freeList_ + tempVar1 * 4 != ptr1);\n        ptr2 = *(undefined1 **)(ptr1 + 0xc);\n      }\n      *(undefined1 **)(tempVar4 + 0xc) = ptr2;\n      *(undefined1 **)(tempVar4 + 8) = ptr1;\n      *(int *)(ptr2 + 8) = tempVar4;\n      *(int *)(ptr1 + 0xc) = tempVar4;\n    }\n  }\nLAB_00083e30:\n  __malloc_unlock(lock);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083d9c": "deallocate_memory_block_00083d9c",
                "param_1": "lock",
                "param_2": "memoryBlock",
                "puVar1": "ptr",
                "uVar3": "size",
                "iVar4": "tempVar1",
                "iVar5": "tempVar2",
                "puVar6": "ptr1",
                "uVar7": "tempVar3",
                "puVar8": "ptr2",
                "iVar9": "tempVar4",
                "uVar10": "tempVar5",
                "__malloc_lock": "acquireLock",
                "__malloc_top_pad": "trimThreshold",
                "__malloc_trim_threshold": "trimThreshold",
                "_malloc_trim_r": "trimMemory",
                "__malloc_av": "freeList"
            },
            "calling": [
                "__swsetup_r",
                "__sfvwrite_r",
                "_malloc_r",
                "_realloc_r",
                "__sflush_r",
                "_fclose_r",
                "free"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_malloc_trim_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083f34": {
            "entrypoint": "0x00083f34",
            "current_name": "process_data_00083f34",
            "code": "\nundefined4 processData_00083f34(undefined4 *errorCode,void **data,undefined4 *length)\n\n{\n  void **ppVar1;\n  int result;\n  void *dest;\n  void *newBlock;\n  void *source;\n  void *blockSize;\n  ushort status;\n  uint size;\n  int remainingSize;\n  void **ptr;\n  void *ptr1;\n  void *ptr2;\n  void *copySize;\n  size_t copyOffset;\n  void *flag;\n  \n  if (length[2] != 0) {\n    status = *(ushort *)(data + 3);\n    size = (uint)status;\n    if (((int)(size << 0x1c) < 0) && (data[4] != (void *)0x0)) {\n      ptr = (void **)*length;\n    }\n    else {\n      result = __swsetup_r(errorCode,data);\n      if (result != 0) {\n        return 0xffffffff;\n      }\n      status = *(ushort *)(data + 3);\n      size = (uint)status;\n      ptr = (void **)*length;\n    }\n    if ((status & 2) == 0) {\n      source = (void *)(size & 2);\n      ptr2 = source;\n      ptr1 = source;\n      flag = source;\n      if ((size & 1) == 0) {\n        source = (void *)0x0;\n        ptr2 = (void *)0x0;\n        while( true ) {\n          while (source == (void *)0x0) {\n            ptr2 = *ptr;\n            ppVar1 = ptr + 1;\n            ptr = ptr + 2;\n            source = *ppVar1;\n          }\n          ptr1 = data[2];\n          if ((int)(size << 0x16) < 0) {\n            if (source < ptr1) {\n              dest = *data;\n              ptr1 = source;\n            }\n            else if ((size & 0x480) == 0) {\n              dest = *data;\n            }\n            else {\n              copyOffset = (int)*data - (int)data[4];\n              ptr1 = (void *)(copyOffset + 1 + (int)source);\n              dest = (void *)(((int)data[5] * 3) / 2);\n              if (ptr1 <= dest) {\n                ptr1 = dest;\n              }\n              if ((int)(size << 0x15) < 0) {\n                newBlock = (void *)_malloc_r(errorCode,ptr1);\n                if (newBlock == (void *)0x0) {\n                  *errorCode = 0xc;\n                  status = *(ushort *)(data + 3);\n                  goto LAB_00084030;\n                }\n                memcpy(newBlock,data[4],copyOffset);\n                *(ushort *)(data + 3) = *(ushort *)(data + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                newBlock = (void *)_realloc_r(errorCode);\n                if (newBlock == (void *)0x0) {\n                  _free_r(errorCode,data[4]);\n                  status = *(ushort *)(data + 3) & 0xff7f;\n                  *errorCode = 0xc;\n                  goto LAB_00084030;\n                }\n              }\n              dest = (void *)((int)newBlock + copyOffset);\n              data[4] = newBlock;\n              data[5] = ptr1;\n              *data = dest;\n              data[2] = (void *)((int)ptr1 - copyOffset);\n              ptr1 = source;\n            }\n            memmove(dest,ptr2,(size_t)ptr1);\n            data[2] = (void *)((int)data[2] - (int)ptr1);\n            *data = (void *)((int)*data + (int)ptr1);\n            ptr1 = source;\n          }\n          else if ((data[4] < *data) || (dest = data[5], source < dest)) {\n            if (source < ptr1) {\n              ptr1 = source;\n            }\n            memmove(*data,ptr2,(size_t)ptr1);\n            dest = data[2];\n            data[2] = (void *)((int)dest - (int)ptr1);\n            *data = (void *)((int)*data + (int)ptr1);\n            if (((void *)((int)dest - (int)ptr1) == (void *)0x0) &&\n               (result = _fflush_r(errorCode,data), result != 0)) goto LAB_0008402e;\n          }\n          else {\n            ptr1 = (void *)0x7fffffff;\n            if (source < (void *)0x7fffffff) {\n              ptr1 = source;\n            }\n            ptr1 = (void *)(*(code *)data[9])\n                                        (errorCode,data[7],ptr2,\n                                         ((uint)ptr1 / (uint)dest) * (int)dest);\n            if ((int)ptr1 < 1) goto LAB_0008402e;\n          }\n          result = length[2];\n          ptr2 = (void *)((int)ptr2 + (int)ptr1);\n          source = (void *)((int)source - (int)ptr1);\n          length[2] = result - (int)ptr1;\n          if (result - (int)ptr1 == 0) break;\n          size = (uint)*(ushort *)(data + 3);\n        }\n      }\n      else {\n        do {\n          while (source == (void *)0x0) {\n            ptr1 = *ptr;\n            source = ptr[1];\n            flag = (void *)0x0;\n            ptr = ptr + 2;\n          }\n          if (flag == (void *)0x0) {\n            ptr2 = memchr(ptr1,10,(size_t)source);\n            if (ptr2 == (void *)0x0) {\n              ptr2 = (void *)((int)source + 1);\n              flag = (void *)0x1;\n            }\n            else {\n              ptr2 = (void *)((int)ptr2 + (1 - (int)ptr1));\n              flag = (void *)0x1;\n            }\n          }\n          newBlock = *data;\n          dest = ptr2;\n          if (source <= ptr2) {\n            dest = source;\n          }\n          blockSize = data[5];\n          if ((data[4] < newBlock) &&\n             (copySize = (void *)((int)data[2] + (int)blockSize), (int)copySize < (int)dest)) {\n            memmove(newBlock,ptr1,(size_t)copySize);\n            *data = (void *)((int)*data + (int)copySize);\n            result = _fflush_r(errorCode,data);\n            if (result != 0) goto LAB_0008402e;\n          }\n          else if ((int)dest < (int)blockSize) {\n            memmove(newBlock,ptr1,(size_t)dest);\n            data[2] = (void *)((int)data[2] - (int)dest);\n            *data = (void *)((int)dest + (int)*data);\n            copySize = dest;\n          }\n          else {\n            copySize = (void *)(*(code *)data[9])(errorCode,data[7],ptr1,blockSize);\n            if ((int)copySize < 1) goto LAB_0008402e;\n          }\n          ptr2 = (void *)((int)ptr2 - (int)copySize);\n          if (ptr2 == (void *)0x0) {\n            result = _fflush_r(errorCode,data);\n            if (result != 0) goto LAB_0008402e;\n            flag = (void *)0x0;\n          }\n          result = length[2];\n          ptr1 = (void *)((int)ptr1 + (int)copySize);\n          source = (void *)((int)source - (int)copySize);\n          length[2] = result - (int)copySize;\n        } while (result - (int)copySize != 0);\n      }\n    }\n    else {\n      ptr2 = (void *)0x0;\n      source = (void *)0x0;\n      do {\n        while( true ) {\n          ptr1 = source;\n          if ((void *)0x7ffffbff < source) {\n            ptr1 = (void *)0x7ffffc00;\n          }\n          if (source != (void *)0x0) break;\n          ptr2 = *ptr;\n          source = ptr[1];\n          ptr = ptr + 2;\n        }\n        result = (*(code *)data[9])(errorCode,data[7],ptr2,ptr1);\n        if (result < 1) {\nLAB_0008402e:\n          status = *(ushort *)(data + 3);\nLAB_00084030:\n          *(ushort *)(data + 3) = status | 0x40;\n          return 0xffffffff;\n        }\n        remainingSize = length[2];\n        ptr2 = (void *)((int)ptr2 + result);\n        source = (void *)((int)source - result);\n        length[2] = remainingSize - result;\n      } while (remainingSize - result != 0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083f34": "process_data_00083f34",
                "param_1": "errorCode",
                "param_2": "data",
                "param_3": "length",
                "ppvVar10": "ptr",
                "iVar2": "result",
                "pvVar3": "dest",
                "pvVar4": "newBlock",
                "pvVar5": "source",
                "pvVar6": "blockSize",
                "__n": "copySize",
                "__n_00": "copyOffset",
                "local_2c": "flag",
                "uVar7": "status",
                "uVar8": "size",
                "iVar9": "remainingSize",
                "pvVar11": "ptr1",
                "pvVar12": "ptr2",
                "ppvVar1": "ppVar1"
            },
            "calling": [
                "__sprint_r.part.0"
            ],
            "called": [
                "memchr",
                "__swsetup_r",
                "_malloc_r",
                "_realloc_r",
                "_free_r",
                "memcpy",
                "_fflush_r",
                "memmove"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084248": {
            "entrypoint": "0x00084248",
            "current_name": "process_data_00084248",
            "code": "\nuint processData_00084248(int inputParam,code *callbackFunc)\n\n{\n  uint result;\n  int offset;\n  int count;\n  uint combinedResult;\n  int *ptrArray;\n  \n  ptrArray = (int *)(inputParam + 0x2e0);\n  if (ptrArray != (int *)0x0) {\n    combinedResult = 0;\n    do {\n      offset = ptrArray[2];\n      count = ptrArray[1] + -1;\n      if (-1 < count) {\n        do {\n          count = count + -1;\n          if ((1 < *(ushort *)(offset + 0xc)) && (*(short *)(offset + 0xe) != -1)) {\n            result = (*callbackFunc)(offset);\n            combinedResult = combinedResult | result;\n          }\n          offset = offset + 0x68;\n        } while (count != -1);\n      }\n      ptrArray = (int *)*ptrArray;\n    } while (ptrArray != (int *)0x0);\n    return combinedResult;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084248": "process_data_00084248",
                "param_1": "inputParam",
                "param_2": "callbackFunc",
                "uVar1": "result",
                "iVar2": "offset",
                "iVar3": "count",
                "uVar4": "combinedResult",
                "piVar5": "ptrArray"
            },
            "calling": [
                "_cleanup_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084290": {
            "entrypoint": "0x00084290",
            "current_name": "get_charset_00084290",
            "code": "\nchar * getCharset_00084290(void)\n\n{\n  return charset;\n}\n\n",
            "renaming": {
                "FUN_00084290": "get_charset_00084290",
                "lc_ctype_charset": "charset"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084298": {
            "entrypoint": "0x00084298",
            "current_name": "get_max_mb_cur_00084298",
            "code": "\nundefined4 getMaxMbCur_00084298(void)\n\n{\n  return maxMultibyteCharacterLength;\n}\n\n",
            "renaming": {
                "FUN_00084298": "get_max_mb_cur_00084298",
                "__mb_cur_max": "maxMultibyteCharacterLength"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "check_file_permissions_000842a4",
            "code": "\nvoid checkFilePermissions_000842a4(int fileDescriptor,int *fileInfo)\n\n{\n  ushort filePermission;\n  int fileStatus;\n  int allocationStatus;\n  uint fileMask;\n  bool isTerminal;\n  undefined fileStatBuffer [4];\n  uint fileMode;\n  \n  filePermission = *(ushort *)(fileInfo + 3);\n  fileMask = (uint)filePermission;\n  if ((int)(fileMask << 0x1e) < 0) {\n    *fileInfo = (int)fileInfo + 0x43;\n    fileInfo[4] = (int)fileInfo + 0x43;\n    fileInfo[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)fileInfo + 0xe)) {\n    fileStatus = _fstat_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe),fileStatBuffer);\n    if (-1 < fileStatus) {\n      isTerminal = (fileMode & 0xf000) == 0x2000;\n      if (((fileMode & 0xf000) == 0x8000) && (fileInfo[10] == 0x8449d)) {\n        fileStatus = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x400;\n        fileInfo[0x13] = 0x400;\n      }\n      else {\n        fileStatus = 0x400;\n        *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 0x800;\n      }\n      goto LAB_00084300;\n    }\n    filePermission = *(ushort *)(fileInfo + 3);\n    fileMask = (uint)filePermission;\n  }\n  *(ushort *)(fileInfo + 3) = filePermission | 0x800;\n  if ((fileMask & 0x80) == 0) {\n    fileStatus = 0x400;\n  }\n  else {\n    fileStatus = 0x40;\n  }\n  isTerminal = false;\nLAB_00084300:\n  allocationStatus = _malloc_r(fileDescriptor,fileStatus);\n  filePermission = *(ushort *)(fileInfo + 3);\n  if (allocationStatus == 0) {\n    if (-1 < (int)((uint)filePermission << 0x16)) {\n      *(ushort *)(fileInfo + 3) = filePermission | 2;\n      *fileInfo = (int)fileInfo + 0x43;\n      fileInfo[4] = (int)fileInfo + 0x43;\n      fileInfo[5] = 1;\n    }\n  }\n  else {\n    *(undefined4 *)(fileDescriptor + 0x3c) = 0x83b09;\n    *(ushort *)(fileInfo + 3) = filePermission | 0x80;\n    *fileInfo = allocationStatus;\n    fileInfo[4] = allocationStatus;\n    fileInfo[5] = fileStatus;\n    if ((isTerminal) && (fileStatus = _isatty_r(fileDescriptor,(int)*(short *)((int)fileInfo + 0xe)), fileStatus != 0)) {\n      *(ushort *)(fileInfo + 3) = *(ushort *)(fileInfo + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "check_file_permissions_000842a4",
                "param_1": "fileDescriptor",
                "param_2": "fileInfo",
                "uVar1": "filePermission",
                "iVar2": "fileStatus",
                "iVar3": "allocationStatus",
                "uVar4": "fileMask",
                "bVar5": "isTerminal",
                "auStack_54": "fileStatBuffer",
                "local_50": "fileMode"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_isatty_r",
                "_malloc_r",
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084384": {
            "entrypoint": "0x00084384",
            "current_name": "find_first_byte_00084384",
            "code": "\nvoid * find_first_byte_00084384(void *buffer,int target_byte,size_t buffer_length)\n\n{\n  uint target_value;\n  uint xor_result;\n  int iteration_count;\n  uint *ptr_buffer;\n  uint uVar5;\n  bool break_condition;\n  \n  target_value = target_byte & 0xff;\n  if (((uint)buffer & 3) == 0) {\nLAB_000843b4:\n    if (3 < buffer_length) {\n      uVar5 = target_value | target_value << 8;\n      ptr_buffer = (uint *)buffer;\n      do {\n        xor_result = *ptr_buffer ^ (uVar5 | uVar5 << 0x10);\n        buffer = ptr_buffer;\n        if ((xor_result + 0xfefefeff & ~xor_result & 0x80808080) != 0) break;\n        buffer_length = buffer_length - 4;\n        buffer = ptr_buffer + 1;\n        ptr_buffer = ptr_buffer + 1;\n      } while (3 < buffer_length);\n    }\n    if (buffer_length == 0) {\n      buffer = (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*buffer != target_value) {\n        iteration_count = 0;\n        do {\n          buffer = (void *)((int)buffer + 1);\n          break_condition = iteration_count == buffer_length - 1;\n          iteration_count = iteration_count + 1;\n          if (break_condition) goto LAB_000843dc;\n                    /* WARNING: Load size is inaccurate */\n        } while (*buffer != target_value);\n      }\n    }\n  }\n  else if (buffer_length == 0) {\nLAB_000843dc:\n    buffer = (uint *)0x0;\n  }\n  else {\n                    /* WARNING: Load size is inaccurate */\n    if (*buffer != target_value) {\n      ptr_buffer = (uint *)((int)buffer + 1);\n      buffer_length = buffer_length - 1;\n      do {\n        buffer = ptr_buffer;\n        if (((uint)buffer & 3) == 0) goto LAB_000843b4;\n        if (buffer_length == 0) goto LAB_000843dc;\n                    /* WARNING: Load size is inaccurate */\n        ptr_buffer = (uint *)((int)buffer + 1);\n        buffer_length = buffer_length - 1;\n      } while (*buffer != target_value);\n    }\n  }\n  return buffer;\n}\n\n",
            "renaming": {
                "FUN_00084384": "find_first_byte_00084384",
                "__s": "buffer",
                "__c": "target_byte",
                "__n": "buffer_length",
                "uVar1": "target_value",
                "uVar2": "xor_result",
                "iVar3": "iteration_count",
                "puVar4": "ptr_buffer",
                "bVar6": "break_condition"
            },
            "calling": [
                "__sfvwrite_r",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084418": {
            "entrypoint": "0x00084418",
            "current_name": "terminate_process_00084418",
            "code": "\nvoid terminateProcess_00084418(int *error,int processID,int exitCode)\n\n{\n  errno = 0;\n  _kill(processID,exitCode);\n  if ((processID == -1) && (errno != 0)) {\n    *error = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084418": "terminate_process_00084418",
                "param_1": "error",
                "param_2": "processID",
                "param_3": "exitCode"
            },
            "calling": [
                "kill"
            ],
            "called": [
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084440": {
            "entrypoint": "0x00084440",
            "current_name": "update_data_00084440",
            "code": "\nvoid updateData_00084440(undefined4 ptr_buffer,int ptr_data)\n\n{\n  int readResult;\n  \n  readResult = _read_r(ptr_buffer,(int)*(short *)(ptr_data + 0xe));\n  if (-1 < readResult) {\n    *(int *)(ptr_data + 0x50) = *(int *)(ptr_data + 0x50) + readResult;\n    return;\n  }\n  *(ushort *)(ptr_data + 0xc) = *(ushort *)(ptr_data + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084440": "update_data_00084440",
                "param_1": "ptr_buffer",
                "param_2": "ptr_data",
                "iVar1": "readResult"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084464": {
            "entrypoint": "0x00084464",
            "current_name": "update_data_and_write_00084464",
            "code": "\nvoid updateDataAndWrite_00084464(undefined4 fileDescriptor,int dataPointer,undefined4 bufferPointer,undefined4 bufferSize)\n\n{\n  ushort dataValue;\n  \n  dataValue = *(ushort *)(dataPointer + 0xc);\n  if ((int)((uint)dataValue << 0x17) < 0) {\n    fileSeek(fileDescriptor,(int)*(short *)(dataPointer + 0xe),0,2);\n    dataValue = *(ushort *)(dataPointer + 0xc);\n  }\n  *(ushort *)(dataPointer + 0xc) = dataValue & 0xefff;\n  fileWrite(fileDescriptor,(int)*(short *)(dataPointer + 0xe),bufferPointer,bufferSize);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084464": "update_data_and_write_00084464",
                "param_1": "fileDescriptor",
                "param_2": "dataPointer",
                "param_3": "bufferPointer",
                "param_4": "bufferSize",
                "uVar1": "dataValue",
                "_lseek_r": "fileSeek",
                "_write_r": "fileWrite"
            },
            "calling": [],
            "called": [
                "_write_r",
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008449c": {
            "entrypoint": "0x0008449c",
            "current_name": "update_file_pointer_0008449c",
            "code": "\nvoid updateFilePointer_0008449c(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  int seekResult;\n  ushort updatedFlag;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  if (seekResult == -1) {\n    updatedFlag = *(ushort *)(bufferAddress + 0xc) & 0xefff;\n  }\n  else {\n    updatedFlag = *(ushort *)(bufferAddress + 0xc) | 0x1000;\n  }\n  if (seekResult != -1) {\n    *(int *)(bufferAddress + 0x50) = seekResult;\n  }\n  *(ushort *)(bufferAddress + 0xc) = updatedFlag;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008449c": "update_file_pointer_0008449c",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "iVar1": "seekResult",
                "uVar2": "updatedFlag"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "close_file_descriptor_000844bc",
            "code": "\nvoid closeFileDescriptor_000844bc(undefined4 fileDescriptor,int bufferAddress)\n\n{\n  _close_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe));\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "close_file_descriptor_000844bc",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress"
            },
            "calling": [],
            "called": [
                "_close_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844c4": {
            "entrypoint": "0x000844c4",
            "current_name": "reverse_input_000844c4",
            "code": "\nuint reverseInput_000844c4(int inputPointer,uint inputValue,undefined4 *data,undefined4 length)\n\n{\n  ushort ushortValue;\n  uint uintValue;\n  undefined *ptrValue;\n  int intValue;\n  \n  if ((inputPointer != 0) && (*(int *)(inputPointer + 0x38) == 0)) {\n    __sinit();\n  }\n  ushortValue = *(ushort *)(data + 3);\n  uintValue = (uint)ushortValue;\n  data[2] = data[6];\n  if ((-1 < (int)(uintValue << 0x1c)) || (intValue = data[4], intValue == 0)) {\n    intValue = __swsetup_r(inputPointer,data,ushortValue,uintValue,length);\n    if (intValue != 0) {\n      return 0xffffffff;\n    }\n    ushortValue = *(ushort *)(data + 3);\n    intValue = data[4];\n    uintValue = (uint)ushortValue;\n  }\n  inputValue = inputValue & 0xff;\n  if ((int)(uintValue << 0x12) < 0) {\n    ptrValue = (undefined *)*data;\n    intValue = (int)ptrValue - intValue;\n    if (intValue < (int)data[5]) {\nLAB_000844f6:\n      intValue = intValue + 1;\n      goto LAB_000844f8;\n    }\n  }\n  else {\n    data[0x19] = data[0x19] & 0xffffdfff;\n    ptrValue = (undefined *)*data;\n    *(ushort *)(data + 3) = ushortValue | 0x2000;\n    intValue = (int)ptrValue - intValue;\n    if (intValue < (int)data[5]) goto LAB_000844f6;\n  }\n  intValue = _fflush_r(inputPointer,data);\n  if (intValue != 0) {\n    return 0xffffffff;\n  }\n  ptrValue = (undefined *)*data;\n  intValue = 1;\nLAB_000844f8:\n  data[2] = data[2] + -1;\n  *data = ptrValue + 1;\n  *ptrValue = (char)inputValue;\n  if (((data[5] == intValue) ||\n      (((int)((uint)*(ushort *)(data + 3) << 0x1f) < 0 && (inputValue == 10)))) &&\n     (intValue = _fflush_r(inputPointer,data), intValue != 0)) {\n    return 0xffffffff;\n  }\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_000844c4": "reverse_input_000844c4",
                "param_1": "inputPointer",
                "param_2": "inputValue",
                "param_3": "data",
                "param_4": "length",
                "uVar1": "ushortValue",
                "uVar2": "uintValue",
                "puVar3": "ptrValue",
                "iVar4": "intValue"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__swsetup_r",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008456c": {
            "entrypoint": "0x0008456c",
            "current_name": "convert_to_multi_byte_0008456c",
            "code": "\nvoid convertToMultiByte_0008456c(undefined4 *outputString,int inputSize,undefined4 inputValue,undefined4 *errorCode)\n\n{\n  code *converter;\n  undefined4 charset;\n  int conversionResult;\n  undefined conversionBuffer [12];\n  \n  converter = __wctomb;\n  if (inputSize == 0) {\n    charset = __locale_charset();\n    conversionResult = (*converter)(outputString,conversionBuffer,0,charset,errorCode);\n  }\n  else {\n    charset = __locale_charset();\n    conversionResult = (*converter)(outputString,inputSize,inputValue,charset,errorCode);\n  }\n  if (conversionResult == -1) {\n    *errorCode = 0;\n    *outputString = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008456c": "convert_to_multi_byte_0008456c",
                "param_1": "outputString",
                "param_2": "inputSize",
                "param_3": "inputValue",
                "param_4": "errorCode",
                "pcVar1": "converter",
                "uVar2": "charset",
                "iVar3": "conversionResult",
                "auStack_24": "conversionBuffer"
            },
            "calling": [
                "_fputwc_r"
            ],
            "called": [
                "__locale_charset",
                "__ascii_wctomb"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845bc": {
            "entrypoint": "0x000845bc",
            "current_name": "set_char_or_error_000845bc",
            "code": "\nundefined4 set_char_or_error_000845bc(undefined4 *output_ptr,undefined *char_ptr,uint value)\n\n{\n  if (char_ptr == (undefined *)0x0) {\n    return 0;\n  }\n  if (value < 0x100) {\n    *char_ptr = (char)value;\n    return 1;\n  }\n  *output_ptr = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_000845bc": "set_char_or_error_000845bc",
                "param_1": "output_ptr",
                "param_2": "char_ptr",
                "param_3": "value"
            },
            "calling": [
                "_wcrtomb_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845d8": {
            "entrypoint": "0x000845d8",
            "current_name": "write_data_to_file_000845d8",
            "code": "\nvoid writeDataToFile_000845d8(int *error,int fileDescriptor,char *buffer,int length)\n\n{\n  int writeResult;\n  \n  errno = 0;\n  writeResult = _write(fileDescriptor,buffer,length);\n  if ((writeResult == -1) && (errno != 0)) {\n    *error = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000845d8": "write_data_to_file_000845d8",
                "param_1": "error",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "length",
                "iVar1": "writeResult"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084600": {
            "entrypoint": "0x00084600",
            "current_name": "close_file_with_error_handling_00084600",
            "code": "\nvoid closeFileWithErrorHandling_00084600(int *errorCode,int fileDescriptor)\n\n{\n  int closeResult;\n  \n  errno = 0;\n  closeResult = _close(fileDescriptor);\n  if ((closeResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084600": "close_file_with_error_handling_00084600",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "iVar1": "closeResult"
            },
            "calling": [
                "__sclose"
            ],
            "called": [
                "_close"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084624": {
            "entrypoint": "0x00084624",
            "current_name": "flush_and_free_resources_00084624",
            "code": "\nundefined4 flushAndFreeResources_00084624(int fileDescriptor,int stream)\n\n{\n  undefined4 returnValue;\n  int result;\n  \n  if (stream != 0) {\n    if ((fileDescriptor != 0) && (*(int *)(fileDescriptor + 0x38) == 0)) {\n      __sinit();\n    }\n    if (*(short *)(stream + 0xc) != 0) {\n      returnValue = _fflush_r(fileDescriptor,stream);\n      if ((*(code **)(stream + 0x2c) != (code *)0x0) &&\n         (result = (**(code **)(stream + 0x2c))(fileDescriptor,*(undefined4 *)(stream + 0x1c)), result < 0)\n         ) {\n        returnValue = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(stream + 0xc) << 0x18) < 0) {\n        _free_r(fileDescriptor,*(undefined4 *)(stream + 0x10));\n      }\n      if (*(int *)(stream + 0x30) != 0) {\n        if (*(int *)(stream + 0x30) != stream + 0x40) {\n          _free_r(fileDescriptor);\n        }\n        *(undefined4 *)(stream + 0x30) = 0;\n      }\n      if (*(int *)(stream + 0x44) != 0) {\n        _free_r(fileDescriptor);\n        *(undefined4 *)(stream + 0x44) = 0;\n      }\n      __sfp_lock_acquire();\n      *(undefined2 *)(stream + 0xc) = 0;\n      __sfp_lock_release();\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084624": "flush_and_free_resources_00084624",
                "param_1": "fileDescriptor",
                "param_2": "stream",
                "uVar1": "returnValue",
                "iVar2": "result"
            },
            "calling": [
                "fclose"
            ],
            "called": [
                "__sfp_lock_release",
                "_free_r",
                "__sfp_lock_acquire",
                "_fflush_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846a4": {
            "entrypoint": "0x000846a4",
            "current_name": "close_file_000846a4",
            "code": "\nint closeFile_000846a4(FILE *file)\n\n{\n  int result;\n  \n  result = _fclose_r(_impure_ptr,file);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000846a4": "close_file_000846a4",
                "__stream": "file",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "_fclose_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846b4": {
            "entrypoint": "0x000846b4",
            "current_name": "get_file_status_000846b4",
            "code": "\nvoid get_file_status_000846b4(int *error_code,int file_descriptor,stat *file_status)\n\n{\n  int status;\n  \n  error_number = 0;\n  status = _fstat(file_descriptor,file_status);\n  if ((status == -1) && (error_number != 0)) {\n    *error_code = error_number;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000846b4": "get_file_status_000846b4",
                "param_1": "error_code",
                "param_2": "file_descriptor",
                "param_3": "file_status",
                "iVar1": "status",
                "errno": "error_number"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000846dc": {
            "entrypoint": "0x000846dc",
            "current_name": "check_is_terminal_000846dc",
            "code": "\nvoid checkIsTerminal_000846dc(int *errorCode,int fileDescriptor)\n\n{\n  int isTTYResult;\n  \n  errno = 0;\n  isTTYResult = _isatty(fileDescriptor);\n  if ((isTTYResult == -1) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000846dc": "check_is_terminal_000846dc",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "iVar1": "isTTYResult"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084700": {
            "entrypoint": "0x00084700",
            "current_name": "seek_and_set_errno_00084700",
            "code": "\nvoid seekAndSetErrno_00084700(int *errPtr,int fileDesc,__off_t offset,int whence)\n\n{\n  __off_t result;\n  \n  errno = 0;\n  result = _lseek(fileDesc,offset,whence);\n  if ((result == -1) && (errno != 0)) {\n    *errPtr = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084700": "seek_and_set_errno_00084700",
                "param_1": "errPtr",
                "param_2": "fileDesc",
                "param_3": "offset",
                "param_4": "whence",
                "_Var1": "result"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084728": {
            "entrypoint": "0x00084728",
            "current_name": "read_file_00084728",
            "code": "\nvoid readFile_00084728(int *errorCode,int fileDescriptor,char *buffer,int count)\n\n{\n  int bytesRead;\n  \n  errno = 0;\n  bytesRead = _read(fileDescriptor,buffer,count);\n  if ((bytesRead == -1) && (errno != 0)) {\n    *errorCode = errno;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084728": "read_file_00084728",
                "param_1": "errorCode",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "bytesRead"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084750": {
            "entrypoint": "0x00084750",
            "current_name": "perform_division_00084750",
            "code": "\nvoid performDivision_00084750(int dividend,int divisor,int remainder,int isZero)\n\n{\n  if ((isZero == 0) && (remainder == 0)) {\n    if (divisor != 0 || dividend != 0) {\n      dividend = -1;\n    }\n    handleZeroDivision(dividend);\n    return;\n  }\n  performULDivMod();\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084750": "perform_division_00084750",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "remainder",
                "param_4": "isZero",
                "__aeabi_idiv0": "handleZeroDivision",
                "__gnu_uldivmod_helper": "performULDivMod"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__gnu_uldivmod_helper",
                "__aeabi_idiv0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008477c": {
            "entrypoint": "0x0008477c",
            "current_name": "calculate_difference_0008477c",
            "code": "\nvoid calculate_difference_0008477c(uint input_value,int input_number,undefined4 constant1,undefined4 constant2,int *result_array)\n\n{\n  uint result;\n  longlong product;\n  \n  product = __divdi3();\n  product = product * CONCAT44(constant2,constant1);\n  result = (uint)product;\n  *result_array = input_value - result;\n  result_array[1] = (input_number - (int)((ulonglong)product >> 0x20)) - (uint)(input_value < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008477c": "calculate_difference_0008477c",
                "param_1": "input_value",
                "param_2": "input_number",
                "param_3": "constant1",
                "param_4": "constant2",
                "param_5": "result_array",
                "uVar1": "result",
                "lVar2": "product"
            },
            "calling": [],
            "called": [
                "__divdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000847ac": {
            "entrypoint": "0x000847ac",
            "current_name": "subtract_and_update_000847ac",
            "code": "\nvoid subtract_and_update_000847ac(uint input_param,int size_param,undefined4 lower_param,undefined4 upper_param,int *output_param)\n\n{\n  uint result;\n  longlong product;\n  \n  product = __udivdi3();\n  product = product * CONCAT44(upper_param,lower_param);\n  result = (uint)product;\n  *output_param = input_param - result;\n  output_param[1] = (size_param - (int)((ulonglong)product >> 0x20)) - (uint)(input_param < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000847ac": "subtract_and_update_000847ac",
                "param_1": "input_param",
                "param_2": "size_param",
                "param_3": "lower_param",
                "param_4": "upper_param",
                "param_5": "output_param",
                "uVar1": "result",
                "lVar2": "product"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [
                "__udivdi3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000847dc": {
            "entrypoint": "0x000847dc",
            "current_name": "FUNC_000847dc",
            "code": "\nvoid FUNC_000847dc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000847dc": "FUNC_000847dc"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000847e0": {
            "entrypoint": "0x000847e0",
            "current_name": "divide_unsigned_integers_000847e0",
            "code": "\nundefined8 divideUnsignedIntegers_000847e0(uint dividend,uint dividend_low,uint divisor,uint divisor_low)\n\n{\n  longlong result;\n  uint quotient_high;\n  uint quotient_low;\n  uint temp1;\n  uint temp2;\n  int leadingZeroCount;\n  uint mask;\n  uint extendedDivisor;\n  uint leadingZeroCountDiff;\n  uint isDivisorNegative;\n  uint shiftCount;\n  uint divisorExtended;\n  bool isCarry;\n  \n  if ((int)dividend_low < 0) {\n    isCarry = dividend != 0;\n    dividend = -dividend;\n    dividend_low = -dividend_low - (uint)isCarry;\n    leadingZeroCountDiff = 0xffffffff;\n  }\n  else {\n    leadingZeroCountDiff = 0;\n  }\n  if ((int)divisor_low < 0) {\n    leadingZeroCountDiff = ~leadingZeroCountDiff;\n    isCarry = divisor != 0;\n    divisor = -divisor;\n    divisor_low = -divisor_low - (uint)isCarry;\n  }\n  if (divisor_low == 0) {\n    if (dividend_low < divisor) {\n      leadingZeroCount = LZCOUNT(divisor);\n      if (leadingZeroCount != 0) {\n        quotient_low = dividend >> (0x20U - leadingZeroCount & 0xff);\n        divisor = divisor << leadingZeroCount;\n        dividend = dividend << leadingZeroCount;\n        dividend_low = dividend_low << leadingZeroCount | quotient_low;\n      }\n      quotient_high = divisor >> 0x10;\n      temp1 = dividend_low / quotient_high;\n      mask = (divisor & 0xffff) * temp1;\n      isDivisorNegative = dividend >> 0x10 | (dividend_low - quotient_high * temp1) * 0x10000;\n      quotient_low = temp1;\n      if (isDivisorNegative <= mask && mask - isDivisorNegative != 0) {\n        isCarry = CARRY4(isDivisorNegative,divisor);\n        isDivisorNegative = isDivisorNegative + divisor;\n        quotient_low = temp1 - 1;\n        if ((isCarry == false) && (isDivisorNegative <= mask && mask - isDivisorNegative != 0)) {\n          quotient_low = temp1 - 2;\n          isDivisorNegative = isDivisorNegative + divisor;\n        }\n      }\n      extendedDivisor = (isDivisorNegative - mask) / quotient_high;\n      temp1 = (divisor & 0xffff) * extendedDivisor;\n      mask = dividend & 0xffff | ((isDivisorNegative - mask) - quotient_high * extendedDivisor) * 0x10000;\n      quotient_high = extendedDivisor;\n      if (mask <= temp1 && temp1 - mask != 0) {\n        quotient_high = extendedDivisor - 1;\n        if ((CARRY4(mask,divisor) == false) &&\n           (mask + divisor <= temp1 && temp1 - (mask + divisor) != 0)) {\n          quotient_high = extendedDivisor - 2;\n        }\n      }\n      quotient_high = quotient_high | quotient_low << 0x10;\n      quotient_low = 0;\n    }\n    else {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      leadingZeroCount = LZCOUNT(divisor);\n      if (leadingZeroCount == 0) {\n        dividend_low = dividend_low - divisor;\n        temp1 = divisor >> 0x10;\n        divisorExtended = divisor & 0xffff;\n        quotient_low = 1;\n      }\n      else {\n        divisor = divisor << leadingZeroCount;\n        quotient_low = dividend_low >> (0x20U - leadingZeroCount & 0xff);\n        temp1 = divisor >> 0x10;\n        isDivisorNegative = quotient_low / temp1;\n        divisorExtended = divisor & 0xffff;\n        mask = divisorExtended * isDivisorNegative;\n        extendedDivisor = dividend >> (0x20U - leadingZeroCount & 0xff) | dividend_low << leadingZeroCount;\n        quotient_low = extendedDivisor >> 0x10 | (quotient_low - temp1 * isDivisorNegative) * 0x10000;\n        dividend = dividend << leadingZeroCount;\n        quotient_high = isDivisorNegative;\n        if (quotient_low <= mask && mask - quotient_low != 0) {\n          isCarry = CARRY4(quotient_low,divisor);\n          quotient_low = quotient_low + divisor;\n          quotient_high = isDivisorNegative - 1;\n          if ((isCarry == false) && (quotient_low <= mask && mask - quotient_low != 0)) {\n            quotient_high = isDivisorNegative - 2;\n            quotient_low = quotient_low + divisor;\n          }\n        }\n        temp2 = (quotient_low - mask) / temp1;\n        isDivisorNegative = divisorExtended * temp2;\n        dividend_low = extendedDivisor & 0xffff | ((quotient_low - mask) - temp1 * temp2) * 0x10000;\n        quotient_low = temp2;\n        if (dividend_low <= isDivisorNegative && isDivisorNegative - dividend_low != 0) {\n          isCarry = CARRY4(dividend_low,divisor);\n          dividend_low = dividend_low + divisor;\n          quotient_low = temp2 - 1;\n          if ((isCarry == false) && (dividend_low <= isDivisorNegative && isDivisorNegative - dividend_low != 0)) {\n            quotient_low = temp2 - 2;\n            dividend_low = dividend_low + divisor;\n          }\n        }\n        dividend_low = dividend_low - isDivisorNegative;\n        quotient_low = quotient_low | quotient_high << 0x10;\n      }\n      quotient_high = dividend_low / temp1;\n      isDivisorNegative = divisorExtended * quotient_high;\n      extendedDivisor = dividend >> 0x10 | (dividend_low - temp1 * quotient_high) * 0x10000;\n      mask = quotient_high;\n      if (extendedDivisor <= isDivisorNegative && isDivisorNegative - extendedDivisor != 0) {\n        isCarry = CARRY4(extendedDivisor,divisor);\n        extendedDivisor = extendedDivisor + divisor;\n        mask = quotient_high - 1;\n        if ((isCarry == false) && (extendedDivisor <= isDivisorNegative && isDivisorNegative - extendedDivisor != 0)) {\n          mask = quotient_high - 2;\n          extendedDivisor = extendedDivisor + divisor;\n        }\n      }\n      temp2 = (extendedDivisor - isDivisorNegative) / temp1;\n      divisorExtended = divisorExtended * temp2;\n      temp1 = dividend & 0xffff | ((extendedDivisor - isDivisorNegative) - temp1 * temp2) * 0x10000;\n      quotient_high = temp2;\n      if (temp1 <= divisorExtended && divisorExtended - temp1 != 0) {\n        quotient_high = temp2 - 1;\n        if ((CARRY4(temp1,divisor) == false) &&\n           (temp1 + divisor <= divisorExtended && divisorExtended - (temp1 + divisor) != 0)) {\n          quotient_high = temp2 - 2;\n        }\n      }\n      quotient_high = quotient_high | mask << 0x10;\n    }\n  }\n  else if (dividend_low < divisor_low) {\n    quotient_low = 0;\n    quotient_high = 0;\n  }\n  else {\n    leadingZeroCount = LZCOUNT(divisor_low);\n    if (leadingZeroCount == 0) {\n      if ((divisor_low < dividend_low) || (divisor <= dividend)) {\n        quotient_low = 0;\n        quotient_high = 1;\n      }\n      else {\n        quotient_high = 0;\n        quotient_low = 0;\n      }\n    }\n    else {\n      quotient_low = 0x20 - leadingZeroCount;\n      temp1 = dividend_low >> (quotient_low & 0xff);\n      divisorExtended = divisor >> (quotient_low & 0xff) | divisor_low << leadingZeroCount;\n      isDivisorNegative = divisorExtended >> 0x10;\n      quotient_high = temp1 / isDivisorNegative;\n      extendedDivisor = (divisorExtended & 0xffff) * quotient_high;\n      mask = dividend_low << leadingZeroCount | dividend >> (quotient_low & 0xff);\n      temp1 = mask >> 0x10 | (temp1 - isDivisorNegative * quotient_high) * 0x10000;\n      quotient_low = quotient_high;\n      if (temp1 <= extendedDivisor && extendedDivisor - temp1 != 0) {\n        isCarry = CARRY4(temp1,divisorExtended);\n        temp1 = temp1 + divisorExtended;\n        quotient_low = quotient_high - 1;\n        if ((isCarry == false) && (temp1 <= extendedDivisor && extendedDivisor - temp1 != 0)) {\n          quotient_low = quotient_high - 2;\n          temp1 = temp1 + divisorExtended;\n        }\n      }\n      temp2 = (temp1 - extendedDivisor) / isDivisorNegative;\n      shiftCount = (divisorExtended & 0xffff) * temp2;\n      temp1 = mask & 0xffff | ((temp1 - extendedDivisor) - isDivisorNegative * temp2) * 0x10000;\n      quotient_high = temp2;\n      if (temp1 <= shiftCount && shiftCount - temp1 != 0) {\n        isCarry = CARRY4(temp1,divisorExtended);\n        temp1 = temp1 + divisorExtended;\n        quotient_high = temp2 - 1;\n        if ((isCarry == false) && (temp1 <= shiftCount && shiftCount - temp1 != 0)) {\n          quotient_high = temp2 - 2;\n          temp1 = temp1 + divisorExtended;\n        }\n      }\n      quotient_high = quotient_high | quotient_low << 0x10;\n      result = (ulonglong)quotient_high * (ulonglong)(divisor << leadingZeroCount);\n      mask = (uint)((ulonglong)result >> 0x20);\n      quotient_low = 0;\n      if ((temp1 - shiftCount < mask) ||\n         ((temp1 - shiftCount == mask && (dividend << leadingZeroCount < (uint)result)))) {\n        quotient_high = quotient_high - 1;\n        quotient_low = 0;\n      }\n    }\n  }\n  if (leadingZeroCountDiff != 0) {\n    isCarry = quotient_high != 0;\n    quotient_high = -quotient_high;\n    quotient_low = -quotient_low - (uint)isCarry;\n  }\n  return CONCAT44(quotient_low,quotient_high);\n}\n\n",
            "renaming": {
                "FUN_000847e0": "divide_unsigned_integers_000847e0",
                "param_1": "dividend",
                "param_2": "dividend_low",
                "param_3": "divisor",
                "param_4": "divisor_low",
                "lVar1": "result",
                "uVar2": "quotient_high",
                "uVar3": "quotient_low",
                "uVar4": "temp1",
                "uVar5": "temp2",
                "uVar7": "mask",
                "uVar8": "extendedDivisor",
                "uVar9": "leadingZeroCountDiff",
                "uVar10": "isDivisorNegative",
                "uVar11": "shiftCount",
                "uVar12": "divisorExtended",
                "bVar13": "isCarry",
                "iVar6": "leadingZeroCount"
            },
            "calling": [
                "__gnu_ldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084a80": {
            "entrypoint": "0x00084a80",
            "current_name": "calculate_dividend_quotient_00084a80",
            "code": "\nulonglong calculateDividendQuotient_00084a80(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  longlong temp_long;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  uint temp8;\n  int shiftCount;\n  bool carryFlag;\n  \n  if (remainder == 0) {\n    if (quotient <= divisor) {\n      if (quotient == 0) {\n        quotient = 1 / 0;\n      }\n      shiftCount = LZCOUNT(quotient);\n      if (shiftCount == 0) {\n        divisor = divisor - quotient;\n        temp2 = quotient >> 0x10;\n        temp4 = quotient & 0xffff;\n        temp1 = 1;\n      }\n      else {\n        quotient = quotient << shiftCount;\n        temp7 = divisor >> (0x20U - shiftCount & 0xff);\n        temp2 = quotient >> 0x10;\n        temp8 = temp7 / temp2;\n        temp4 = quotient & 0xffff;\n        temp1 = temp4 * temp8;\n        temp5 = dividend >> (0x20U - shiftCount & 0xff) | divisor << shiftCount;\n        temp3 = temp5 >> 0x10 | (temp7 - temp2 * temp8) * 0x10000;\n        dividend = dividend << shiftCount;\n        temp7 = temp8;\n        if (temp3 <= temp1 && temp1 - temp3 != 0) {\n          carryFlag = CARRY4(temp3,quotient);\n          temp3 = temp3 + quotient;\n          temp7 = temp8 - 1;\n          if ((carryFlag == false) && (temp3 <= temp1 && temp1 - temp3 != 0)) {\n            temp7 = temp8 - 2;\n            temp3 = temp3 + quotient;\n          }\n        }\n        temp6 = (temp3 - temp1) / temp2;\n        temp8 = temp4 * temp6;\n        divisor = temp5 & 0xffff | ((temp3 - temp1) - temp2 * temp6) * 0x10000;\n        temp1 = temp6;\n        if (divisor <= temp8 && temp8 - divisor != 0) {\n          carryFlag = CARRY4(divisor,quotient);\n          divisor = divisor + quotient;\n          temp1 = temp6 - 1;\n          if ((carryFlag == false) && (divisor <= temp8 && temp8 - divisor != 0)) {\n            temp1 = temp6 - 2;\n            divisor = divisor + quotient;\n          }\n        }\n        divisor = divisor - temp8;\n        temp1 = temp1 | temp7 << 0x10;\n      }\n      temp8 = divisor / temp2;\n      temp3 = temp4 * temp8;\n      temp5 = dividend >> 0x10 | (divisor - temp2 * temp8) * 0x10000;\n      temp7 = temp8;\n      if (temp5 <= temp3 && temp3 - temp5 != 0) {\n        carryFlag = CARRY4(temp5,quotient);\n        temp5 = temp5 + quotient;\n        temp7 = temp8 - 1;\n        if ((carryFlag == false) && (temp5 <= temp3 && temp3 - temp5 != 0)) {\n          temp7 = temp8 - 2;\n          temp5 = temp5 + quotient;\n        }\n      }\n      temp8 = (temp5 - temp3) / temp2;\n      temp4 = temp4 * temp8;\n      temp5 = dividend & 0xffff | ((temp5 - temp3) - temp2 * temp8) * 0x10000;\n      temp2 = temp8;\n      if (temp5 <= temp4 && temp4 - temp5 != 0) {\n        temp2 = temp8 - 1;\n        if ((CARRY4(temp5,quotient) == false) &&\n           (temp5 + quotient <= temp4 && temp4 - (temp5 + quotient) != 0)) {\n          temp2 = temp8 - 2;\n        }\n      }\n      return CONCAT44(temp1,temp2 | temp7 << 0x10);\n    }\n    shiftCount = LZCOUNT(quotient);\n    if (shiftCount != 0) {\n      temp7 = dividend >> (0x20U - shiftCount & 0xff);\n      quotient = quotient << shiftCount;\n      dividend = dividend << shiftCount;\n      divisor = temp7 | divisor << shiftCount;\n    }\n    temp1 = quotient >> 0x10;\n    temp2 = divisor / temp1;\n    temp4 = (quotient & 0xffff) * temp2;\n    temp8 = dividend >> 0x10 | (divisor - temp1 * temp2) * 0x10000;\n    temp7 = temp2;\n    if (temp8 <= temp4 && temp4 - temp8 != 0) {\n      carryFlag = CARRY4(temp8,quotient);\n      temp8 = temp8 + quotient;\n      temp7 = temp2 - 1;\n      if ((carryFlag == false) && (temp8 <= temp4 && temp4 - temp8 != 0)) {\n        temp7 = temp2 - 2;\n        temp8 = temp8 + quotient;\n      }\n    }\n    temp5 = (temp8 - temp4) / temp1;\n    temp2 = (quotient & 0xffff) * temp5;\n    temp4 = dividend & 0xffff | ((temp8 - temp4) - temp1 * temp5) * 0x10000;\n    temp1 = temp5;\n    if (temp4 <= temp2 && temp2 - temp4 != 0) {\n      temp1 = temp5 - 1;\n      if ((CARRY4(temp4,quotient) == false) &&\n         (temp4 + quotient <= temp2 && temp2 - (temp4 + quotient) != 0)) {\n        temp1 = temp5 - 2;\n      }\n    }\n    temp1 = temp1 | temp7 << 0x10;\n  }\n  else {\n    if (divisor < remainder) {\n      return 0;\n    }\n    shiftCount = LZCOUNT(remainder);\n    if (shiftCount == 0) {\n      if ((remainder < divisor) || (quotient <= dividend)) {\n        return 1;\n      }\n      temp1 = 0;\n    }\n    else {\n      temp1 = 0x20 - shiftCount;\n      temp7 = divisor >> (temp1 & 0xff);\n      temp2 = remainder << shiftCount | quotient >> (temp1 & 0xff);\n      temp4 = temp2 >> 0x10;\n      temp3 = temp7 / temp4;\n      temp8 = (temp2 & 0xffff) * temp3;\n      temp5 = dividend >> (temp1 & 0xff) | divisor << shiftCount;\n      temp1 = temp5 >> 0x10 | (temp7 - temp4 * temp3) * 0x10000;\n      temp7 = temp3;\n      if (temp1 <= temp8 && temp8 - temp1 != 0) {\n        carryFlag = CARRY4(temp1,temp2);\n        temp1 = temp1 + temp2;\n        temp7 = temp3 - 1;\n        if ((carryFlag == false) && (temp1 <= temp8 && temp8 - temp1 != 0)) {\n          temp7 = temp3 - 2;\n          temp1 = temp1 + temp2;\n        }\n      }\n      temp3 = (temp1 - temp8) / temp4;\n      temp6 = (temp2 & 0xffff) * temp3;\n      temp4 = temp5 & 0xffff | ((temp1 - temp8) - temp4 * temp3) * 0x10000;\n      temp1 = temp3;\n      if (temp4 <= temp6 && temp6 - temp4 != 0) {\n        carryFlag = CARRY4(temp4,temp2);\n        temp4 = temp4 + temp2;\n        temp1 = temp3 - 1;\n        if ((carryFlag == false) && (temp4 <= temp6 && temp6 - temp4 != 0)) {\n          temp1 = temp3 - 2;\n          temp4 = temp4 + temp2;\n        }\n      }\n      temp1 = temp1 | temp7 << 0x10;\n      temp_long = (ulonglong)temp1 * (ulonglong)(quotient << shiftCount);\n      temp7 = (uint)((ulonglong)temp_long >> 0x20);\n      if ((temp4 - temp6 < temp7) || ((temp4 - temp6 == temp7 && (dividend << shiftCount < (uint)temp_long)))\n         ) {\n        temp1 = temp1 - 1;\n      }\n    }\n  }\n  return (ulonglong)temp1;\n}\n\n",
            "renaming": {
                "FUN_00084a80": "calculate_dividend_quotient_00084a80",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "lVar1": "temp_long",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "uVar4": "temp3",
                "uVar5": "temp4",
                "uVar6": "temp5",
                "uVar7": "temp6",
                "uVar8": "temp7",
                "uVar9": "temp8",
                "iVar10": "shiftCount",
                "bVar11": "carryFlag"
            },
            "calling": [
                "__gnu_uldivmod_helper"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085858": {
            "entrypoint": "0x00085858",
            "current_name": "FUNC_00085858",
            "code": "\nvoid FUNC_00085858(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085858": "FUNC_00085858"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00085874": {
            "entrypoint": "0x00085874",
            "current_name": "FUNC_00085874",
            "code": "\nvoid FUNC_00085874(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085874": "FUNC_00085874"
            },
            "calling": [
                "__libc_fini_array"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_20070000": {
            "entrypoint": "0x20070000",
            "current_name": "disable_irq_interrupts_20070000",
            "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableIRQInterrupts_20070000(void)\n\n{\n  disableIRQinterrupts();\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *(undefined4 *)(DAT_2007001c + 4) = DAT_20070020;\n  do {\n  } while (-1 < *(int *)(DAT_2007001c + 8) << 0x1f);\n  *DAT_20070028 = DAT_20070024;\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_20070000": "disable_irq_interrupts_20070000"
            },
            "calling": [
                "tickReset",
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 117928,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080148",
            "FUN_0008014c",
            "FUN_00080164",
            "FUN_000801b0",
            "FUN_0008021c",
            "FUN_00080258",
            "FUN_000802da",
            "FUN_000803d4",
            "FUN_00080410",
            "FUN_0008043e",
            "FUN_000804a8",
            "FUN_000805d0",
            "FUN_00080a68",
            "FUN_00080aac",
            "FUN_00080ac0",
            "FUN_00080acc",
            "FUN_00080ad8",
            "FUN_00080ae4",
            "FUN_00080c0c",
            "FUN_00080ce0",
            "FUN_00080d24",
            "FUN_00080d2e",
            "FUN_00080d54",
            "FUN_00080d7a",
            "FUN_00080da0",
            "FUN_00080e04",
            "FUN_00080e18",
            "FUN_00080e5c",
            "FUN_00080e9c",
            "FUN_00080f24",
            "FUN_00080f9c",
            "FUN_00081034",
            "FUN_00081042",
            "FUN_0008105c",
            "FUN_00081066",
            "FUN_0008106e",
            "FUN_00081074",
            "FUN_00081084",
            "FUN_000810bc",
            "FUN_000810f4",
            "FUN_0008112c",
            "FUN_00081164",
            "FUN_00081166",
            "FUN_0008116a",
            "FUN_0008116e",
            "FUN_00081184",
            "FUN_00081188",
            "FUN_0008118c",
            "FUN_000811a8",
            "FUN_000811ae",
            "FUN_000811b4",
            "FUN_000811be",
            "FUN_000811c2",
            "FUN_000811c6",
            "FUN_000811cc",
            "FUN_000811f0",
            "FUN_00081202",
            "FUN_00081208",
            "FUN_00081210",
            "FUN_00081318",
            "FUN_00081388",
            "FUN_000813a8",
            "FUN_000813c2",
            "FUN_000813e0",
            "FUN_000813e4",
            "FUN_000813f6",
            "FUN_00081412",
            "FUN_0008143c",
            "FUN_00081454",
            "FUN_000814a8",
            "FUN_000814e4",
            "FUN_00081508",
            "FUN_00081578",
            "FUN_00081580",
            "FUN_000815ca",
            "FUN_000815d4",
            "FUN_000815f8",
            "FUN_000815fe",
            "FUN_0008160c",
            "FUN_00081622",
            "FUN_0008163a",
            "FUN_0008165c",
            "FUN_00081682",
            "FUN_000816a8",
            "FUN_000816d4",
            "FUN_000816e0",
            "FUN_00081704",
            "FUN_00081714",
            "FUN_00081720",
            "FUN_00081728",
            "FUN_00081730",
            "FUN_00081734",
            "FUN_00081894",
            "FUN_0008189c",
            "FUN_000818b8",
            "FUN_000818c8",
            "FUN_00081944",
            "FUN_00081aac",
            "FUN_00081be4",
            "FUN_00081bec",
            "FUN_00081bf4",
            "FUN_00081c54",
            "FUN_00081c5c",
            "FUN_00081c6c",
            "FUN_00081c80",
            "FUN_00081c94",
            "FUN_00081ca8",
            "FUN_00081cbc",
            "FUN_00081cd0",
            "FUN_00081d1c",
            "FUN_00081d5c",
            "FUN_00081d68",
            "FUN_00081d7c",
            "FUN_00081dcc",
            "FUN_00081df4",
            "FUN_00081e04",
            "FUN_00081e14",
            "FUN_0008234c",
            "FUN_00082438",
            "FUN_00082504",
            "FUN_000825a0",
            "FUN_000825b0",
            "FUN_00082970",
            "FUN_00082994",
            "FUN_00082a50",
            "FUN_00082ab0",
            "FUN_00082ac0",
            "FUN_00082b38",
            "FUN_0008378c",
            "FUN_00083808",
            "FUN_000838cc",
            "FUN_00083988",
            "FUN_00083994",
            "FUN_00083adc",
            "FUN_00083b08",
            "FUN_00083b14",
            "FUN_00083c10",
            "FUN_00083c40",
            "FUN_00083d00",
            "FUN_00083d9c",
            "FUN_00083f34",
            "FUN_00084248",
            "FUN_00084290",
            "FUN_00084298",
            "FUN_000842a4",
            "FUN_00084384",
            "FUN_00084418",
            "FUN_00084440",
            "FUN_00084464",
            "FUN_0008449c",
            "FUN_000844bc",
            "FUN_000844c4",
            "FUN_0008456c",
            "FUN_000845bc",
            "FUN_000845d8",
            "FUN_00084600",
            "FUN_00084624",
            "FUN_000846a4",
            "FUN_000846b4",
            "FUN_000846dc",
            "FUN_00084700",
            "FUN_00084728",
            "FUN_00084750",
            "FUN_0008477c",
            "FUN_000847ac",
            "FUN_000847e0",
            "FUN_00084a80",
            "FUN_20070000"
        ]
    ],
    "locked_functions": []
}