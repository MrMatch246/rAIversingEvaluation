{
  "functions": {
    "_init": {
      "entrypoint": "0x00102000",
      "current_name": "_init",
      "code": "\nint _init(EVP_PKEY_CTX *ctx)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d __gmon_start__();\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__gmon_start__"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102020": {
      "entrypoint": "0x00102020",
      "current_name": "FUN_00102020",
      "code": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x0010a000",
      "current_name": "free",
      "code": "\n\n\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "free"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcasecmp": {
      "entrypoint": "0x0010a008",
      "current_name": "strcasecmp",
      "code": "\n\n\n\nint strcasecmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcasecmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strcasecmp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "abort": {
      "entrypoint": "0x0010a018",
      "current_name": "abort",
      "code": "\n\n\n\nvoid abort(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* abort@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "abort"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__errno_location": {
      "entrypoint": "0x0010a020",
      "current_name": "__errno_location",
      "code": "\n\n\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "__errno_location"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strncmp": {
      "entrypoint": "0x0010a028",
      "current_name": "strncmp",
      "code": "\n\n\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strncmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strncmp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ferror": {
      "entrypoint": "0x0010a040",
      "current_name": "ferror",
      "code": "\n\n\n\nint ferror(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "ferror"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fread": {
      "entrypoint": "0x0010a048",
      "current_name": "fread",
      "code": "\n\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fread@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fread"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "textdomain": {
      "entrypoint": "0x0010a050",
      "current_name": "textdomain",
      "code": "\n\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "textdomain"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x0010a058",
      "current_name": "fclose",
      "code": "\n\n\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fclose"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bindtextdomain": {
      "entrypoint": "0x0010a068",
      "current_name": "bindtextdomain",
      "code": "\n\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "bindtextdomain"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dcgettext": {
      "entrypoint": "0x0010a070",
      "current_name": "dcgettext",
      "code": "\n\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "dcgettext"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x0010a078",
      "current_name": "strlen",
      "code": "\n\n\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strlen"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mmap": {
      "entrypoint": "0x0010a080",
      "current_name": "mmap",
      "code": "\n\n\n\nvoid * mmap(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off_t __offset)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mmap@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "mmap"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getopt_long": {
      "entrypoint": "0x0010a088",
      "current_name": "getopt_long",
      "code": "\n\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "getopt_long"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printf": {
      "entrypoint": "0x0010a090",
      "current_name": "printf",
      "code": "\n\n\n\nint printf(char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* printf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "printf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rewind": {
      "entrypoint": "0x0010a098",
      "current_name": "rewind",
      "code": "\n\n\n\nvoid rewind(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* rewind@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "rewind"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "snprintf": {
      "entrypoint": "0x0010a0a0",
      "current_name": "snprintf",
      "code": "\n\n\n\nint snprintf(char *__s,size_t __maxlen,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* snprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "snprintf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sbrk": {
      "entrypoint": "0x0010a0a8",
      "current_name": "sbrk",
      "code": "\n\n\n\nvoid * sbrk(intptr_t __delta)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sbrk@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "sbrk"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcmp": {
      "entrypoint": "0x0010a0b0",
      "current_name": "strcmp",
      "code": "\n\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strcmp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fprintf": {
      "entrypoint": "0x0010a0c0",
      "current_name": "fprintf",
      "code": "\n\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fprintf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ftell": {
      "entrypoint": "0x0010a0c8",
      "current_name": "ftell",
      "code": "\n\n\n\nlong ftell(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ftell@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "ftell"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stat": {
      "entrypoint": "0x0010a0d8",
      "current_name": "stat",
      "code": "\n\n\n\nint stat(char *__file,stat *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* stat@GLIBC_2.33 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "stat"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x0010a0e8",
      "current_name": "memcpy",
      "code": "\n\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@GLIBC_2.14 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "memcpy"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fileno": {
      "entrypoint": "0x0010a0f0",
      "current_name": "fileno",
      "code": "\n\n\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fileno"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "malloc": {
      "entrypoint": "0x0010a0f8",
      "current_name": "malloc",
      "code": "\n\n\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "malloc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fflush": {
      "entrypoint": "0x0010a100",
      "current_name": "fflush",
      "code": "\n\n\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fflush"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fseek": {
      "entrypoint": "0x0010a108",
      "current_name": "fseek",
      "code": "\n\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fseek"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "realloc": {
      "entrypoint": "0x0010a110",
      "current_name": "realloc",
      "code": "\n\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "realloc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "munmap": {
      "entrypoint": "0x0010a118",
      "current_name": "munmap",
      "code": "\n\n\n\nint munmap(void *__addr,size_t __len)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* munmap@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "munmap"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setlocale": {
      "entrypoint": "0x0010a120",
      "current_name": "setlocale",
      "code": "\n\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "setlocale"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x0010a128",
      "current_name": "memmove",
      "code": "\n\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memmove@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "memmove"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fopen": {
      "entrypoint": "0x0010a130",
      "current_name": "fopen",
      "code": "\n\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fopen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fopen"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "vfprintf": {
      "entrypoint": "0x0010a138",
      "current_name": "vfprintf",
      "code": "\n\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* vfprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "vfprintf"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtoul": {
      "entrypoint": "0x0010a140",
      "current_name": "strtoul",
      "code": "\n\n\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtoul@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strtoul"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "exit": {
      "entrypoint": "0x0010a150",
      "current_name": "exit",
      "code": "\n\n\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "exit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fwrite": {
      "entrypoint": "0x0010a158",
      "current_name": "fwrite",
      "code": "\n\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fwrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strdup": {
      "entrypoint": "0x0010a168",
      "current_name": "strdup",
      "code": "\n\n\n\nchar * strdup(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strdup@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strdup"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strerror": {
      "entrypoint": "0x0010a170",
      "current_name": "strerror",
      "code": "\n\n\n\nchar * strerror(int __errnum)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strerror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "strerror"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fstat": {
      "entrypoint": "0x0010a178",
      "current_name": "fstat",
      "code": "\n\n\n\nint fstat(int __fd,stat *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fstat@GLIBC_2.33 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "fstat"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getc": {
      "entrypoint": "0x0010a180",
      "current_name": "getc",
      "code": "\n\n\n\nint getc(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "getc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_finalize": {
      "entrypoint": "0x0010a190",
      "current_name": "__cxa_finalize",
      "code": "\n\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "__cxa_finalize"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "elf_x86_feature.cold": {
      "entrypoint": "0x001022c0",
      "current_name": "elf_x86_feature.cold",
      "code": "\nundefined  [16] elf_x86_feature_cold(void)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  char *unaff_RBX;\n  int unaff_EBP;\n  undefined auVar4 [16];\n  undefined8 unaff_retaddr;\n  \n  iVar1 \u003d strcasecmp(unaff_RBX,\"lam_u48\");\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d 4;\n  }\n  else {\n    iVar1 \u003d strcasecmp(unaff_RBX,\"lam_u57\");\n    uVar2 \u003d 8;\n    if (iVar1 !\u003d 0) {\n      uVar3 \u003d dcgettext(0,\"Unknown x86 feature: %s\\n\",5);\n      error(uVar3);\n      uVar3 \u003d 0xffffffff;\n      goto LAB_00104ca5;\n    }\n  }\n  if (unaff_EBP \u003d\u003d 0) {\n    disable_x86_features \u003d uVar2 | disable_x86_features;\n    enable_x86_features \u003d ~uVar2 \u0026 enable_x86_features;\n  }\n  else {\n    enable_x86_features \u003d uVar2 | enable_x86_features;\n    disable_x86_features \u003d disable_x86_features \u0026 ~uVar2;\n  }\n  uVar3 \u003d 0;\nLAB_00104ca5:\n  auVar4._8_8_ \u003d unaff_retaddr;\n  auVar4._0_8_ \u003d uVar3;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "elf_x86_feature"
      ],
      "called": [
        "error",
        "strcasecmp",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "elf_osabi.cold": {
      "entrypoint": "0x00102323",
      "current_name": "elf_osabi.cold",
      "code": "\nundefined  [16] elf_osabi_cold(void)\n\n{\n  undefined8 uVar1;\n  undefined auVar2 [16];\n  undefined8 unaff_retaddr;\n  \n  uVar1 \u003d dcgettext(0,\"Unknown OSABI: %s\\n\",5);\n  error(uVar1);\n  auVar2._8_8_ \u003d unaff_retaddr;\n  auVar2._0_8_ \u003d 0xffffffff;\n  return auVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "elf_osabi"
      ],
      "called": [
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "elf_machine.cold": {
      "entrypoint": "0x0010234b",
      "current_name": "elf_machine.cold",
      "code": "\nint elf_machine_cold(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *unaff_RBX;\n  \n  iVar1 \u003d strcasecmp(unaff_RBX,\"x86_64\");\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d 0x3e;\n  }\n  else {\n    iVar1 \u003d strcasecmp(unaff_RBX,\"x86-64\");\n    if (iVar1 \u003d\u003d 0) {\n      iVar1 \u003d 0x3e;\n    }\n    else {\n      iVar1 \u003d strcasecmp(unaff_RBX,\"none\");\n      if (iVar1 !\u003d 0) {\n        uVar2 \u003d dcgettext(0,\"Unknown machine type: %s\\n\",5);\n        error(uVar2);\n        iVar1 \u003d -1;\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "elf_machine"
      ],
      "called": [
        "error",
        "strcasecmp",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "elf_type.cold": {
      "entrypoint": "0x001023ce",
      "current_name": "elf_type.cold",
      "code": "\nundefined8 elf_type_cold(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "elf_type"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_object.cold": {
      "entrypoint": "0x00102434",
      "current_name": "process_object.cold",
      "code": "\nundefined8 process_object_cold(void)\n\n{\n  undefined8 uVar1;\n  size_t sVar2;\n  FILE *unaff_RBX;\n  char *pcVar3;\n  \n  uVar1 \u003d dcgettext(0,\"%s: Failed to seek to ELF header\\n\",5);\n  error(uVar1);\n  if (elf_header[6] \u003d\u003d \u0027\\x01\u0027) {\n    if ((ushort)elf_header._58_2_ \u003d\u003d output_elf_machine) {\n      return 0;\n    }\n    if (input_elf_class \u003d\u003d 0xffffffff) {\n      if (elf_header._58_2_ \u003d\u003d 6) {\n        input_elf_class \u003d 1;\n      }\n      else if ((ushort)elf_header._58_2_ \u003c 7) {\n        input_elf_class \u003d (elf_header._58_2_ !\u003d 3) + 1 + (uint)(elf_header._58_2_ !\u003d 3);\n      }\n      else {\n        input_elf_class \u003d 3 - ((ushort)(elf_header._58_2_ - 0xb4) \u003c 2);\n      }\n    }\n    if ((elf_header[4] \u003d\u003d input_elf_class) || (input_elf_class \u003d\u003d 3)) {\n      if ((elf_header[4] \u003d\u003d output_elf_class) || (output_elf_class \u003d\u003d 3)) {\n        if (((ushort)elf_header._58_2_ \u003d\u003d input_elf_machine) || (input_elf_machine \u003d\u003d 0xffffffff)) {\n          if ((input_elf_type \u003d\u003d 0xffffffff) || ((ushort)elf_header._56_2_ \u003d\u003d input_elf_type)) {\n            if ((input_elf_osabi \u003d\u003d 0xffffffff) || (elf_header[7] \u003d\u003d input_elf_osabi)) {\n              if ((elf_header[8] \u003d\u003d input_elf_abiversion) || (input_elf_abiversion \u003d\u003d 0xffffffff)) {\n                if (elf_header[4] \u003d\u003d 1) {\n                  if (output_elf_machine !\u003d 0xffffffff) {\n                    (*byte_put)(0x109392,(long)(int)output_elf_machine,2);\n                  }\n                  if (output_elf_type !\u003d -1) {\n                    (*byte_put)(0x109390,(long)output_elf_type,2);\n                  }\n                  if (output_elf_osabi !\u003d -1) {\n                    ehdr32[7] \u003d (undefined)output_elf_osabi;\n                  }\n                  if (output_elf_abiversion !\u003d -1) {\n                    ehdr32[8] \u003d (undefined)output_elf_abiversion;\n                  }\n                  sVar2 \u003d fwrite(ehdr32,0x34,1,unaff_RBX);\n                  if (sVar2 \u003d\u003d 1) {\n                    return 0;\n                  }\n                  uVar1 \u003d FUN_001024ec();\n                  return uVar1;\n                }\n                if (elf_header[4] !\u003d 2) {\n                    \n                  abort();\n                }\n                if (output_elf_machine !\u003d 0xffffffff) {\n                  (*byte_put)(0x109352,(long)(int)output_elf_machine,2);\n                }\n                if (output_elf_type !\u003d -1) {\n                  (*byte_put)(0x109350,(long)output_elf_type,2);\n                }\n                if (output_elf_osabi !\u003d -1) {\n                  ehdr64[7] \u003d (undefined)output_elf_osabi;\n                }\n                if (output_elf_abiversion !\u003d -1) {\n                  ehdr64[8] \u003d (undefined)output_elf_abiversion;\n                }\n                sVar2 \u003d fwrite(ehdr64,0x40,1,unaff_RBX);\n                if (sVar2 \u003d\u003d 1) {\n                  return 0;\n                }\n                uVar1 \u003d FUN_001024ec();\n                return uVar1;\n              }\n              pcVar3 \u003d \"%s: Unmatched EI_ABIVERSION: %d is not %d\\n\";\n            }\n            else {\n              pcVar3 \u003d \"%s: Unmatched EI_OSABI: %d is not %d\\n\";\n            }\n          }\n          else {\n            pcVar3 \u003d \"%s: Unmatched e_type: %d is not %d\\n\";\n          }\n        }\n        else {\n          pcVar3 \u003d \"%s: Unmatched e_machine: %d is not %d\\n\";\n        }\n        uVar1 \u003d dcgettext(0,pcVar3,5);\n        error(uVar1);\n        return 1;\n      }\n      pcVar3 \u003d \"%s: Unmatched output EI_CLASS: %d is not %d\\n\";\n    }\n    else {\n      pcVar3 \u003d \"%s: Unmatched input EI_CLASS: %d is not %d\\n\";\n    }\n    uVar1 \u003d dcgettext(0,pcVar3,5);\n    error(uVar1);\n  }\n  else {\n    uVar1 \u003d dcgettext(0,\"%s: Unsupported EI_VERSION: %d is not %d\\n\",5);\n    error(uVar1);\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_object"
      ],
      "called": [
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001024ec": {
      "entrypoint": "0x001024ec",
      "current_name": "FUN_001024ec",
      "code": "\nundefined8 FUN_001024ec(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 \u003d __errno_location();\n  strerror(*piVar1);\n  uVar2 \u003d dcgettext(0,\"%s: Failed to update ELF header: %s\\n\",5);\n  error(uVar2);\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_object"
      ],
      "called": [
        "__errno_location",
        "error",
        "dcgettext",
        "strerror"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102558": {
      "entrypoint": "0x00102558",
      "current_name": "FUN_00102558",
      "code": "\nundefined8 FUN_00102558(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 \u003d dcgettext(0,\"%s: Failed to read ELF header\\n\",5);\n  error(uVar1);\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_object"
      ],
      "called": [
        "error",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setup_archive.constprop.0": {
      "entrypoint": "0x001025ab",
      "current_name": "setup_archive.constprop.0",
      "code": "\nundefined4\nsetup_archive_constprop_0\n          (char **param_1,char *param_2,FILE *param_3,long param_4,undefined4 param_5)\n\n{\n  char **__ptr;\n  undefined uVar1;\n  char cVar2;\n  int iVar3;\n  char *pcVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  char *pcVar7;\n  \n  pcVar4 \u003d strdup(param_2);\n  param_1[2] \u003d (char *)0x0;\n  *(undefined4 *)((long)param_1 + 0x54) \u003d 0;\n  *param_1 \u003d pcVar4;\n  param_1[1] \u003d (char *)param_3;\n  param_1[5] \u003d (char *)0x0;\n  param_1[6] \u003d (char *)0x0;\n  *(undefined4 *)(param_1 + 10) \u003d param_5;\n  param_1[9] \u003d (char *)0x8;\n  *(undefined (*) [16])(param_1 + 3) \u003d ZEXT816(0);\n  *(undefined (*) [16])(param_1 + 7) \u003d ZEXT816(0);\n  iVar3 \u003d fseek(param_3,8,0);\n  pcVar4 \u003d \"%s: failed to seek to first archive header\\n\";\n  if (iVar3 !\u003d 0) goto LAB_00102658;\n  __ptr \u003d param_1 + 0xb;\n  sVar5 \u003d fread(__ptr,1,0x3c,param_3);\n  if (sVar5 !\u003d 0x3c) {\n    if (sVar5 \u003d\u003d 0) {\n      return 0;\n    }\n    pcVar4 \u003d \"%s: failed to read archive header\\n\";\n    goto LAB_00102658;\n  }\n  cVar2 \u003d startswith(__ptr,\"/               \");\n  if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n    cVar2 \u003d startswith(__ptr,\"/SYM64/         \");\n    if (cVar2 !\u003d \u0027\\0\u0027) {\n      *(undefined4 *)((long)param_1 + 0x54) \u003d 1;\n      iVar3 \u003d process_archive_index_and_symbols_constprop_0(param_1,8);\n      goto joined_r0x001026dd;\n    }\n  }\n  else {\n    iVar3 \u003d process_archive_index_and_symbols_constprop_0(param_1,4);\njoined_r0x001026dd:\n    if (iVar3 \u003d\u003d 0) {\n      return 1;\n    }\n  }\n  cVar2 \u003d startswith(__ptr);\n  if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n    return 0;\n  }\n  uVar1 \u003d *(undefined *)((long)param_1 + 0x92);\n  *(undefined *)((long)param_1 + 0x92) \u003d 0;\n  pcVar4 \u003d (char *)strtoul((char *)(param_1 + 0x11),(char **)0x0,10);\n  pcVar7 \u003d \"%s: long name table is too small, (size \u003d %ld)\\n\";\n  param_1[7] \u003d pcVar4;\n  *(undefined *)((long)param_1 + 0x92) \u003d uVar1;\n  if ((char *)0x7 \u003c pcVar4) {\n    if (((long)pcVar4 \u003c\u003d param_4) \u0026\u0026 (-1 \u003c (long)pcVar4)) {\n      param_1[9] \u003d pcVar4 + 0x3c + (long)param_1[9];\n      pcVar7 \u003d (char *)malloc((size_t)(pcVar4 + 1));\n      param_1[6] \u003d pcVar7;\n      if (pcVar7 \u003d\u003d (char *)0x0) {\n        uVar6 \u003d dcgettext(0,\"Out of memory reading long symbol names in archive\\n\",5);\n        error(uVar6);\n        return 1;\n      }\n      sVar5 \u003d fread(pcVar7,(size_t)pcVar4,1,param_3);\n      if (sVar5 \u003d\u003d 1) {\n        if ((*(byte *)(param_1 + 7) \u0026 1) !\u003d 0) {\n          getc(param_3);\n        }\n        param_1[6][(long)param_1[7]] \u003d \u0027\\0\u0027;\n        return 0;\n      }\n      free(param_1[6]);\n      pcVar4 \u003d \"%s: failed to read long symbol name string table\\n\";\n      param_1[6] \u003d (char *)0x0;\nLAB_00102658:\n      uVar6 \u003d dcgettext(0,pcVar4,5);\n      error(uVar6,param_2);\n      return 1;\n    }\n    pcVar7 \u003d \"%s: long name table is too big, (size \u003d %#lx)\\n\";\n  }\n  uVar6 \u003d dcgettext(0,pcVar7,5);\n  error(uVar6,param_2,pcVar4);\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_archive",
        "get_archive_member_name"
      ],
      "called": [
        "strdup",
        "fseek",
        "strtoul",
        "fread",
        "getc",
        "process_archive_index_and_symbols.constprop.0",
        "free",
        "malloc",
        "error",
        "dcgettext",
        "startswith"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "startswith": {
      "entrypoint": "0x001027fd",
      "current_name": "startswith",
      "code": "\nundefined  [16] startswith(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 in_RAX;\n  size_t __n;\n  undefined4 extraout_var;\n  undefined auVar2 [16];\n  \n  __n \u003d strlen(param_2);\n  iVar1 \u003d strncmp(param_1,param_2,__n);\n  auVar2._1_7_ \u003d (undefined7)(CONCAT44(extraout_var,iVar1) \u003e\u003e 8);\n  auVar2[0] \u003d iVar1 \u003d\u003d 0;\n  auVar2._8_8_ \u003d in_RAX;\n  return auVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup_archive.constprop.0"
      ],
      "called": [
        "strlen",
        "strncmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "byte_get_little_endian.cold": {
      "entrypoint": "0x00102825",
      "current_name": "byte_get_little_endian.cold",
      "code": "\nvoid byte_get_little_endian_cold(long param_1,undefined8 param_2)\n\n{\n  FUN_00103ab3(param_1,param_2,\n               (ulong)*(byte *)(param_1 + 1) \u003c\u003c 8 | (ulong)*(byte *)(param_1 + 2) \u003c\u003c 0x10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "byte_get_little_endian"
      ],
      "called": [
        "FUN_00103ab3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "caseD_0": {
      "entrypoint": "0x0010289a",
      "current_name": "caseD_0",
      "code": "\nvoid switchD_00103aac::caseD_0(void)\n\n{\n  undefined8 uVar1;\n  undefined4 unaff_EBX;\n  \n  uVar1 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n  error(uVar1,unaff_EBX);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "byte_get_little_endian"
      ],
      "called": [
        "abort",
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_archive_index_and_symbols.constprop.0": {
      "entrypoint": "0x001028be",
      "current_name": "process_archive_index_and_symbols.constprop.0",
      "code": "\nundefined8 process_archive_index_and_symbols_constprop_0(undefined8 *param_1)\n\n{\n  undefined uVar1;\n  int iVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  char *pcVar7;\n  \n  uVar1 \u003d *(undefined *)((long)param_1 + 0x92);\n  *(undefined *)((long)param_1 + 0x92) \u003d 0;\n  uVar3 \u003d strtoul((char *)(param_1 + 0x11),(char **)0x0,10);\n  *(undefined *)((long)param_1 + 0x92) \u003d uVar1;\n  if ((long)uVar3 \u003c 0) {\n    uVar6 \u003d *param_1;\n    uVar4 \u003d dcgettext(0,\"%s: invalid archive header size: %ld\\n\",5);\n    error(uVar4,uVar6,uVar3);\n  }\n  else {\n    uVar3 \u003d uVar3 + 1 \u0026 0xfffffffffffffffe;\n    param_1[9] \u003d uVar3 + 0x3c + param_1[9];\n    iVar2 \u003d fseek((FILE *)param_1[1],uVar3,1);\n    if (iVar2 \u003d\u003d 0) {\n      sVar5 \u003d fread(param_1 + 0xb,1,0x3c,(FILE *)param_1[1]);\n      if ((sVar5 \u003d\u003d 0x3c) || (sVar5 \u003d\u003d 0)) {\n        return 1;\n      }\n      uVar6 \u003d *param_1;\n      pcVar7 \u003d \"%s: failed to read archive header following archive index\\n\";\n    }\n    else {\n      uVar6 \u003d *param_1;\n      pcVar7 \u003d \"%s: failed to skip archive symbol table\\n\";\n    }\n    uVar4 \u003d dcgettext(0,pcVar7,5);\n    error(uVar4,uVar6);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup_archive.constprop.0"
      ],
      "called": [
        "strtoul",
        "fread",
        "fseek",
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_archive_member_name": {
      "entrypoint": "0x001029a5",
      "current_name": "get_archive_member_name",
      "code": "\nundefined4 * get_archive_member_name(undefined8 *param_1,char **param_2)\n\n{\n  undefined uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  int iVar6;\n  ulong uVar7;\n  ulong uVar8;\n  ulong uVar9;\n  undefined8 uVar10;\n  FILE *__stream;\n  size_t sVar11;\n  undefined4 *puVar12;\n  long lVar13;\n  char *pcVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char *local_c0;\n  stat local_b8;\n  \n  if (*(char *)(param_1 + 0xb) !\u003d \u0027/\u0027) {\n    lVar13 \u003d 0;\n    do {\n      if (*(char *)((long)param_1 + lVar13 + 0x58) \u003d\u003d \u0027/\u0027) {\n        *(undefined *)((long)param_1 + lVar13 + 0x58) \u003d 0;\n        puVar12 \u003d (undefined4 *)xstrdup(param_1 + 0xb);\n        return puVar12;\n      }\n      lVar13 \u003d lVar13 + 1;\n    } while (lVar13 !\u003d 0x10);\n    puVar12 \u003d (undefined4 *)xmalloc(0x11);\n    uVar2 \u003d *(undefined4 *)(param_1 + 0xb);\n    uVar3 \u003d *(undefined4 *)((long)param_1 + 0x5c);\n    uVar4 \u003d *(undefined4 *)(param_1 + 0xc);\n    uVar5 \u003d *(undefined4 *)((long)param_1 + 100);\n    *(undefined *)(puVar12 + 4) \u003d 0;\n    *puVar12 \u003d uVar2;\n    puVar12[1] \u003d uVar3;\n    puVar12[2] \u003d uVar4;\n    puVar12[3] \u003d uVar5;\n    return puVar12;\n  }\n  if ((param_1[6] \u003d\u003d 0) || (param_1[7] \u003d\u003d 0)) {\n    pcVar15 \u003d \"Archive member uses long names, but no longname table found\\n\";\nLAB_00102acd:\n    uVar10 \u003d dcgettext(0,pcVar15,5);\n    error(uVar10);\n    return (undefined4 *)0x0;\n  }\n  uVar1 \u003d *(undefined *)((long)param_1 + 0x92);\n  param_1[8] \u003d 0;\n  *(undefined *)((long)param_1 + 0x92) \u003d 0;\n  uVar7 \u003d strtoul((char *)((long)param_1 + 0x59),\u0026local_c0,10);\n  if (((*(int *)(param_1 + 10) !\u003d 0) \u0026\u0026 (local_c0 !\u003d (char *)0x0)) \u0026\u0026 (*local_c0 \u003d\u003d \u0027:\u0027)) {\n    uVar8 \u003d strtoul(local_c0 + 1,(char **)0x0,10);\n    param_1[8] \u003d uVar8;\n  }\n  uVar8 \u003d param_1[7];\n  *(undefined *)((long)param_1 + 0x92) \u003d uVar1;\n  if (uVar8 \u003c uVar7) {\n    uVar10 \u003d dcgettext(0,\"Found long name index (%ld) beyond end of long name table\\n\",5);\n    error(uVar10,uVar7);\n    return (undefined4 *)0x0;\n  }\n  lVar13 \u003d param_1[6];\n  for (uVar9 \u003d uVar7;\n      ((uVar8 !\u003d uVar9 \u0026\u0026 (*(char *)(lVar13 + uVar9) !\u003d \u0027\\0\u0027)) \u0026\u0026\n      (*(char *)(lVar13 + uVar9) !\u003d \u0027\\n\u0027)); uVar9 \u003d uVar9 + 1) {\n  }\n  if ((uVar9 !\u003d 0) \u0026\u0026 (*(char *)(lVar13 + -1 + uVar9) \u003d\u003d \u0027/\u0027)) {\n    uVar9 \u003d uVar9 - 1;\n  }\n  if (uVar9 \u003c uVar8) {\n    uVar8 \u003d uVar9;\n  }\n  *(undefined *)(lVar13 + uVar8) \u003d 0;\n  if ((*(int *)(param_1 + 10) \u003d\u003d 0) || (param_1[8] \u003d\u003d 0)) goto LAB_00102c2d;\n  if (uVar8 \u003c\u003d uVar7) {\n    pcVar15 \u003d \"Invalid Thin archive member name\\n\";\n    goto LAB_00102acd;\n  }\n  pcVar15 \u003d (char *)adjust_relative_path(*param_1,param_1[6] + uVar7,uVar8 - uVar7);\n  if (pcVar15 !\u003d (char *)0x0) {\n    if ((*param_2 \u003d\u003d (char *)0x0) || (iVar6 \u003d strcmp(*param_2,pcVar15), iVar6 !\u003d 0)) {\n      if ((FILE *)param_2[1] !\u003d (FILE *)0x0) {\n        fclose((FILE *)param_2[1]);\n        param_2[1] \u003d (char *)0x0;\n      }\n      release_archive(param_2);\n      __stream \u003d fopen(pcVar15,\"rb\");\n      if (__stream !\u003d (FILE *)0x0) {\n        iVar6 \u003d fileno(__stream);\n        iVar6 \u003d fstat(iVar6,\u0026local_b8);\n        if ((-1 \u003c iVar6) \u0026\u0026\n           (iVar6 \u003d setup_archive_constprop_0(param_2,pcVar15,__stream,local_b8.st_size,0),\n           iVar6 \u003d\u003d 0)) goto LAB_00102b84;\n      }\n    }\n    else {\nLAB_00102b84:\n      iVar6 \u003d fseek((FILE *)param_2[1],param_1[8],0);\n      if (iVar6 \u003d\u003d 0) {\n        sVar11 \u003d fread(param_2 + 0xb,1,0x3c,(FILE *)param_2[1]);\n        if (sVar11 \u003d\u003d 0x3c) {\n          if (*(short *)((long)param_2 + 0x92) \u003d\u003d 0xa60) {\n            puVar12 \u003d (undefined4 *)get_archive_member_name(param_2,0);\n            if (puVar12 !\u003d (undefined4 *)0x0) {\n              free(pcVar15);\n              return puVar12;\n            }\n            goto LAB_00102c25;\n          }\n          pcVar14 \u003d *param_2;\n          pcVar16 \u003d \"%s: did not find a valid archive header\\n\";\n        }\n        else {\n          pcVar14 \u003d *param_2;\n          pcVar16 \u003d \"%s: failed to read archive header\\n\";\n        }\n      }\n      else {\n        pcVar14 \u003d *param_2;\n        pcVar16 \u003d \"%s: failed to seek to next file name\\n\";\n      }\n      uVar10 \u003d dcgettext(0,pcVar16,5);\n      error(uVar10,pcVar14);\n    }\n  }\nLAB_00102c25:\n  free(pcVar15);\nLAB_00102c2d:\n  puVar12 \u003d (undefined4 *)xstrdup(param_1[6] + uVar7);\n  return puVar12;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_archive",
        "get_archive_member_name"
      ],
      "called": [
        "setup_archive.constprop.0",
        "fseek",
        "xmalloc",
        "free",
        "fstat",
        "fclose",
        "fopen",
        "xstrdup",
        "fileno",
        "strtoul",
        "fread",
        "release_archive",
        "error",
        "adjust_relative_path",
        "strcmp",
        "dcgettext",
        "get_archive_member_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "byte_put_little_endian.cold": {
      "entrypoint": "0x00102c98",
      "current_name": "byte_put_little_endian.cold",
      "code": "\nvoid byte_put_little_endian_cold(void)\n\n{\n  undefined8 uVar1;\n  undefined4 unaff_EBX;\n  \n  uVar1 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n  error(uVar1,unaff_EBX);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "byte_put_little_endian"
      ],
      "called": [
        "abort",
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc.cold": {
      "entrypoint": "0x00102cbc",
      "current_name": "xmalloc.cold",
      "code": "\nchar * xmalloc_cold(undefined8 param_1,char *param_2)\n\n{\n  ulong __size;\n  long lVar1;\n  char cVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  ulong extraout_RDX;\n  char *unaff_RBX;\n  ulong uVar7;\n  byte bVar8;\n  \n  bVar8 \u003d 0;\n  xmalloc_failed();\n  pcVar3 \u003d unaff_RBX;\n  pcVar4 \u003d unaff_RBX;\n  while (cVar2 \u003d *pcVar3, cVar2 !\u003d \u0027\\0\u0027) {\n    pcVar3 \u003d pcVar3 + 1;\n    if (cVar2 \u003d\u003d \u0027/\u0027) {\n      pcVar4 \u003d pcVar3;\n    }\n  }\n  if ((*param_2 \u003d\u003d \u0027/\u0027) || (unaff_RBX \u003d\u003d pcVar4)) {\n    if (extraout_RDX + 1 \u003d\u003d 0) {\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(extraout_RDX + 1);\n    uVar6 \u003d extraout_RDX;\n    pcVar3 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar6 !\u003d 0; uVar6 \u003d uVar6 - 1) {\n        *pcVar3 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      pcVar4[extraout_RDX] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  else {\n    uVar7 \u003d (long)pcVar4 - (long)unaff_RBX;\n    lVar1 \u003d uVar7 + extraout_RDX;\n    uVar6 \u003d extraout_RDX;\n    if (extraout_RDX \u003c\u003d uVar7) {\n      uVar6 \u003d uVar7;\n    }\n    __size \u003d lVar1 + 1;\n    if (__size \u003c uVar6) {\n      uVar5 \u003d dcgettext(0,\"Abnormal length of thin archive member name: %lx\\n\",5);\n      error(uVar5,extraout_RDX);\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(__size);\n    pcVar3 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar6 \u003d extraout_RDX, uVar7 !\u003d 0; uVar7 \u003d uVar7 - 1) {\n        *pcVar3 \u003d *unaff_RBX;\n        unaff_RBX \u003d unaff_RBX + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      for (; uVar6 !\u003d 0; uVar6 \u003d uVar6 - 1) {\n        *pcVar3 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      pcVar4[lVar1] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  uVar5 \u003d dcgettext(0,\"Out of memory\\n\",5);\n  error(uVar5);\n  return (char *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "xmalloc"
      ],
      "called": [
        "xmalloc_failed"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adjust_relative_path": {
      "entrypoint": "0x00102cc4",
      "current_name": "adjust_relative_path",
      "code": "\nchar * adjust_relative_path(char *param_1,char *param_2,ulong param_3)\n\n{\n  ulong __size;\n  long lVar1;\n  char cVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  ulong uVar7;\n  byte bVar8;\n  \n  bVar8 \u003d 0;\n  pcVar3 \u003d param_1;\n  pcVar4 \u003d param_1;\n  while (cVar2 \u003d *pcVar3, cVar2 !\u003d \u0027\\0\u0027) {\n    pcVar3 \u003d pcVar3 + 1;\n    if (cVar2 \u003d\u003d \u0027/\u0027) {\n      pcVar4 \u003d pcVar3;\n    }\n  }\n  if ((*param_2 \u003d\u003d \u0027/\u0027) || (param_1 \u003d\u003d pcVar4)) {\n    if (param_3 + 1 \u003d\u003d 0) {\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(param_3 + 1);\n    uVar6 \u003d param_3;\n    pcVar3 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar6 !\u003d 0; uVar6 \u003d uVar6 - 1) {\n        *pcVar3 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      pcVar4[param_3] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  else {\n    uVar7 \u003d (long)pcVar4 - (long)param_1;\n    lVar1 \u003d uVar7 + param_3;\n    uVar6 \u003d param_3;\n    if (param_3 \u003c\u003d uVar7) {\n      uVar6 \u003d uVar7;\n    }\n    __size \u003d lVar1 + 1;\n    if (__size \u003c uVar6) {\n      uVar5 \u003d dcgettext(0,\"Abnormal length of thin archive member name: %lx\\n\",5);\n      error(uVar5,param_3);\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(__size);\n    pcVar3 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar7 !\u003d 0; uVar7 \u003d uVar7 - 1) {\n        *pcVar3 \u003d *param_1;\n        param_1 \u003d param_1 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      for (; param_3 !\u003d 0; param_3 \u003d param_3 - 1) {\n        *pcVar3 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      pcVar4[lVar1] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  uVar5 \u003d dcgettext(0,\"Out of memory\\n\",5);\n  error(uVar5);\n  return (char *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_archive",
        "get_archive_member_name"
      ],
      "called": [
        "malloc",
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "warn": {
      "entrypoint": "0x00102da5",
      "current_name": "warn",
      "code": "\n\n\nvoid warn(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n         undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,char *param_9,\n         undefined8 param_10,undefined8 param_11,undefined8 param_12,undefined8 param_13,\n         undefined8 param_14)\n\n{\n  char in_AL;\n  char *__format;\n  undefined4 local_e0;\n  undefined4 local_dc;\n  undefined *local_d8;\n  undefined *local_d0;\n  undefined local_c8 [8];\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_98 \u003d param_1;\n    local_88 \u003d param_2;\n    local_78 \u003d param_3;\n    local_68 \u003d param_4;\n    local_58 \u003d param_5;\n    local_48 \u003d param_6;\n    local_38 \u003d param_7;\n    local_28 \u003d param_8;\n  }\n  local_c0 \u003d param_10;\n  local_b8 \u003d param_11;\n  local_b0 \u003d param_12;\n  local_a8 \u003d param_13;\n  local_a0 \u003d param_14;\n  fflush(_stdout);\n  local_d8 \u003d \u0026stack0x00000008;\n  local_d0 \u003d local_c8;\n  local_e0 \u003d 8;\n  local_dc \u003d 0x30;\n  __format \u003d (char *)dcgettext(0,\"%s: Warning: \",5);\n  fprintf(_stderr,__format,\"elfedit\");\n  vfprintf(_stderr,param_9,\u0026local_e0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "fprintf",
        "fflush",
        "dcgettext",
        "vfprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "error": {
      "entrypoint": "0x00102e85",
      "current_name": "error",
      "code": "\n\n\nvoid error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n          undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,char *param_9,\n          undefined8 param_10,undefined8 param_11,undefined8 param_12,undefined8 param_13,\n          undefined8 param_14)\n\n{\n  char in_AL;\n  char *__format;\n  undefined4 local_e0;\n  undefined4 local_dc;\n  undefined *local_d8;\n  undefined *local_d0;\n  undefined local_c8 [8];\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_98 \u003d param_1;\n    local_88 \u003d param_2;\n    local_78 \u003d param_3;\n    local_68 \u003d param_4;\n    local_58 \u003d param_5;\n    local_48 \u003d param_6;\n    local_38 \u003d param_7;\n    local_28 \u003d param_8;\n  }\n  local_c0 \u003d param_10;\n  local_b8 \u003d param_11;\n  local_b0 \u003d param_12;\n  local_a8 \u003d param_13;\n  local_a0 \u003d param_14;\n  fflush(_stdout);\n  local_d8 \u003d \u0026stack0x00000008;\n  local_d0 \u003d local_c8;\n  local_e0 \u003d 8;\n  local_dc \u003d 0x30;\n  __format \u003d (char *)dcgettext(0,\"%s: Error: \",5);\n  fprintf(_stderr,__format,\"elfedit\");\n  vfprintf(_stderr,param_9,\u0026local_e0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "caseD_0",
        "setup_archive.constprop.0",
        "process_object.cold",
        "process_object",
        "FUN_00102558",
        "FUN_001024ec",
        "process_archive",
        "main",
        "elf_osabi.cold",
        "elf_x86_feature.cold",
        "byte_put_little_endian.cold",
        "elf_machine.cold",
        "byte_get_big_endian",
        "process_archive_index_and_symbols.constprop.0",
        "byte_put_big_endian",
        "adjust_relative_path",
        "get_archive_member_name",
        "elf_type"
      ],
      "called": [
        "fprintf",
        "fflush",
        "dcgettext",
        "vfprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "release_archive": {
      "entrypoint": "0x00102f65",
      "current_name": "release_archive",
      "code": "\nvoid release_archive(void **param_1)\n\n{\n  free(*param_1);\n  free(param_1[3]);\n  free(param_1[4]);\n  free(param_1[6]);\n  *param_1 \u003d (void *)0x0;\n  param_1[6] \u003d (void *)0x0;\n  *(undefined (*) [16])(param_1 + 3) \u003d ZEXT816(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_archive",
        "get_archive_member_name"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "consume_whitespace": {
      "entrypoint": "0x00102fa0",
      "current_name": "consume_whitespace",
      "code": "\nvoid consume_whitespace(byte **param_1)\n\n{\n  while ((_sch_istable[(ulong)**param_1 * 2] \u0026 0x40) !\u003d 0) {\n    *param_1 \u003d *param_1 + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xexit.constprop.0": {
      "entrypoint": "0x00102fbc",
      "current_name": "xexit.constprop.0",
      "code": "\nvoid xexit_constprop_0(void)\n\n{\n                    \n  exit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "xmalloc_failed",
        "main"
      ],
      "called": [
        "exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc_failed": {
      "entrypoint": "0x00102fc7",
      "current_name": "xmalloc_failed",
      "code": "\n\n\nchar * xmalloc_failed(undefined8 param_1)\n\n{\n  char cVar1;\n  void *pvVar2;\n  size_t sVar3;\n  ulong uVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  undefined8 extraout_RDX;\n  long lVar7;\n  char *__s;\n  FILE *__ptr;\n  char *pcVar8;\n  byte bVar9;\n  undefined8 extraout_XMM0_Qa;\n  uint uStack_f8;\n  char **ppcVar10;\n  char **ppcVar11;\n  char *apcStack_e0 [4];\n  undefined8 uStack_c0;\n  long lStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_28;\n  \n  bVar9 \u003d 0;\n  pvVar2 \u003d sbrk(0);\n  lStack_b8 \u003d (long)pvVar2 + -0x10a0e0;\n  apcStack_e0[3] \u003d \"\";\n  __s \u003d \"\\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\\n\";\n  __ptr \u003d _stderr;\n  uStack_c0 \u003d param_1;\n  fprintf(_stderr,\"\\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\\n\");\n  cVar1 \u003d xexit_constprop_0();\n  if (cVar1 !\u003d \u0027\\0\u0027) {\n    uStack_b0 \u003d extraout_XMM0_Qa;\n  }\n  lVar7 \u003d 0;\n  uStack_f8 \u003d 0x10;\n  pcVar8 \u003d __s;\n  ppcVar10 \u003d (char **)register0x00000020;\n  apcStack_e0[2] \u003d (char *)extraout_RDX;\n  uStack_28 \u003d param_1;\n  do {\n    sVar3 \u003d strlen(pcVar8);\n    lVar7 \u003d lVar7 + sVar3;\n    if (uStack_f8 \u003c 0x30) {\n      uVar4 \u003d (ulong)uStack_f8;\n      uStack_f8 \u003d uStack_f8 + 8;\n      ppcVar6 \u003d (char **)((long)apcStack_e0 + uVar4);\n      ppcVar11 \u003d ppcVar10;\n    }\n    else {\n      ppcVar11 \u003d ppcVar10 + 1;\n      ppcVar6 \u003d ppcVar10;\n    }\n    pcVar8 \u003d *ppcVar6;\n    ppcVar10 \u003d ppcVar11;\n  } while (pcVar8 !\u003d (char *)0x0);\n  pcVar5 \u003d (char *)xmalloc(lVar7 + 1);\n  uStack_f8 \u003d 0x10;\n  pcVar8 \u003d pcVar5;\n  ppcVar10 \u003d (char **)register0x00000020;\n  do {\n    sVar3 \u003d strlen(__s);\n    for (; sVar3 !\u003d 0; sVar3 \u003d sVar3 - 1) {\n      *pcVar8 \u003d *__s;\n      __s \u003d __s + (ulong)bVar9 * -2 + 1;\n      pcVar8 \u003d pcVar8 + (ulong)bVar9 * -2 + 1;\n    }\n    if (uStack_f8 \u003c 0x30) {\n      uVar4 \u003d (ulong)uStack_f8;\n      uStack_f8 \u003d uStack_f8 + 8;\n      ppcVar6 \u003d (char **)((long)apcStack_e0 + uVar4);\n      ppcVar11 \u003d ppcVar10;\n    }\n    else {\n      ppcVar11 \u003d ppcVar10 + 1;\n      ppcVar6 \u003d ppcVar10;\n    }\n    __s \u003d *ppcVar6;\n    ppcVar10 \u003d ppcVar11;\n  } while (__s !\u003d (char *)0x0);\n  *pcVar8 \u003d \u0027\\0\u0027;\n  free(__ptr);\n  return pcVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "xrealloc",
        "xmalloc.cold"
      ],
      "called": [
        "sbrk",
        "fprintf",
        "xexit.constprop.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "reconcat": {
      "entrypoint": "0x00103006",
      "current_name": "reconcat",
      "code": "\nchar * reconcat(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n               undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n               void *param_9,char *param_10,undefined8 param_11,undefined8 param_12,\n               undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  size_t sVar1;\n  ulong uVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  long lVar5;\n  char *pcVar6;\n  byte bVar7;\n  uint local_f0;\n  char **local_e8;\n  char *local_d8 [4];\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined4 local_a8;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  \n  bVar7 \u003d 0;\n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_a8 \u003d param_1;\n    local_98 \u003d param_2;\n    local_88 \u003d param_3;\n    local_78 \u003d param_4;\n    local_68 \u003d param_5;\n    local_58 \u003d param_6;\n    local_48 \u003d param_7;\n    local_38 \u003d param_8;\n  }\n  local_e8 \u003d (char **)\u0026stack0x00000008;\n  lVar5 \u003d 0;\n  local_f0 \u003d 0x10;\n  pcVar6 \u003d param_10;\n  local_d8[2] \u003d (char *)param_11;\n  local_d8[3] \u003d (char *)param_12;\n  local_b8 \u003d param_13;\n  local_b0 \u003d param_14;\n  do {\n    sVar1 \u003d strlen(pcVar6);\n    lVar5 \u003d lVar5 + sVar1;\n    if (local_f0 \u003c 0x30) {\n      uVar2 \u003d (ulong)local_f0;\n      local_f0 \u003d local_f0 + 8;\n      ppcVar4 \u003d (char **)((long)local_d8 + uVar2);\n    }\n    else {\n      ppcVar4 \u003d local_e8;\n      local_e8 \u003d local_e8 + 1;\n    }\n    pcVar6 \u003d *ppcVar4;\n  } while (pcVar6 !\u003d (char *)0x0);\n  pcVar3 \u003d (char *)xmalloc(lVar5 + 1);\n  local_f0 \u003d 0x10;\n  local_e8 \u003d (char **)\u0026stack0x00000008;\n  pcVar6 \u003d pcVar3;\n  do {\n    sVar1 \u003d strlen(param_10);\n    for (; sVar1 !\u003d 0; sVar1 \u003d sVar1 - 1) {\n      *pcVar6 \u003d *param_10;\n      param_10 \u003d param_10 + (ulong)bVar7 * -2 + 1;\n      pcVar6 \u003d pcVar6 + (ulong)bVar7 * -2 + 1;\n    }\n    if (local_f0 \u003c 0x30) {\n      uVar2 \u003d (ulong)local_f0;\n      local_f0 \u003d local_f0 + 8;\n      ppcVar4 \u003d (char **)((long)local_d8 + uVar2);\n    }\n    else {\n      ppcVar4 \u003d local_e8;\n      local_e8 \u003d local_e8 + 1;\n    }\n    param_10 \u003d *ppcVar4;\n  } while (param_10 !\u003d (char *)0x0);\n  *pcVar6 \u003d \u0027\\0\u0027;\n  free(param_9);\n  return pcVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "usage"
      ],
      "called": [
        "xmalloc",
        "free",
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xstrdup": {
      "entrypoint": "0x00103160",
      "current_name": "xstrdup",
      "code": "\nvoid xstrdup(char *param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  long lVar3;\n  byte bVar4;\n  \n  bVar4 \u003d 0;\n  sVar1 \u003d strlen(param_1);\n  lVar3 \u003d sVar1 + 1;\n  pcVar2 \u003d (char *)xmalloc(lVar3);\n  for (; lVar3 !\u003d 0; lVar3 \u003d lVar3 + -1) {\n    *pcVar2 \u003d *param_1;\n    param_1 \u003d param_1 + (ulong)bVar4 * -2 + 1;\n    pcVar2 \u003d pcVar2 + (ulong)bVar4 * -2 + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main",
        "get_archive_member_name"
      ],
      "called": [
        "xmalloc",
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "concat.constprop.0": {
      "entrypoint": "0x00103186",
      "current_name": "concat.constprop.0",
      "code": "\nchar * concat_constprop_0(undefined4 param_1,undefined4 param_2,undefined4 param_3,\n                         undefined4 param_4,undefined4 param_5,undefined4 param_6,undefined4 param_7\n                         ,undefined4 param_8,undefined8 param_9,undefined8 param_10,\n                         undefined8 param_11,undefined8 param_12,undefined8 param_13,\n                         undefined8 param_14)\n\n{\n  char in_AL;\n  size_t sVar1;\n  ulong uVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  long lVar5;\n  char *pcVar6;\n  char *pcVar7;\n  byte bVar8;\n  uint local_e0;\n  char **local_d8;\n  char *local_c8 [4];\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  bVar8 \u003d 0;\n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_98 \u003d param_1;\n    local_88 \u003d param_2;\n    local_78 \u003d param_3;\n    local_68 \u003d param_4;\n    local_58 \u003d param_5;\n    local_48 \u003d param_6;\n    local_38 \u003d param_7;\n    local_28 \u003d param_8;\n  }\n  local_d8 \u003d (char **)\u0026stack0x00000008;\n  lVar5 \u003d 0;\n  local_e0 \u003d 8;\n  pcVar6 \u003d \"none\";\n  local_c8[1] \u003d (char *)param_10;\n  local_c8[2] \u003d (char *)param_11;\n  local_c8[3] \u003d (char *)param_12;\n  local_a8 \u003d param_13;\n  local_a0 \u003d param_14;\n  do {\n    sVar1 \u003d strlen(pcVar6);\n    lVar5 \u003d lVar5 + sVar1;\n    if (local_e0 \u003c 0x30) {\n      uVar2 \u003d (ulong)local_e0;\n      local_e0 \u003d local_e0 + 8;\n      ppcVar4 \u003d (char **)((long)local_c8 + uVar2);\n    }\n    else {\n      ppcVar4 \u003d local_d8;\n      local_d8 \u003d local_d8 + 1;\n    }\n    pcVar6 \u003d *ppcVar4;\n  } while (pcVar6 !\u003d (char *)0x0);\n  pcVar6 \u003d \"none\";\n  pcVar3 \u003d (char *)xmalloc(lVar5 + 1);\n  local_e0 \u003d 8;\n  local_d8 \u003d (char **)\u0026stack0x00000008;\n  pcVar7 \u003d pcVar3;\n  do {\n    sVar1 \u003d strlen(pcVar6);\n    for (; sVar1 !\u003d 0; sVar1 \u003d sVar1 - 1) {\n      *pcVar7 \u003d *pcVar6;\n      pcVar6 \u003d pcVar6 + (ulong)bVar8 * -2 + 1;\n      pcVar7 \u003d pcVar7 + (ulong)bVar8 * -2 + 1;\n    }\n    if (local_e0 \u003c 0x30) {\n      uVar2 \u003d (ulong)local_e0;\n      local_e0 \u003d local_e0 + 8;\n      ppcVar4 \u003d (char **)((long)local_c8 + uVar2);\n    }\n    else {\n      ppcVar4 \u003d local_d8;\n      local_d8 \u003d local_d8 + 1;\n    }\n    pcVar6 \u003d *ppcVar4;\n  } while (pcVar6 !\u003d (char *)0x0);\n  *pcVar7 \u003d \u0027\\0\u0027;\n  return pcVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "usage"
      ],
      "called": [
        "xmalloc",
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "usage": {
      "entrypoint": "0x001032de",
      "current_name": "usage",
      "code": "\nvoid usage(FILE *param_1,int param_2)\n\n{\n  undefined8 *puVar1;\n  void *__ptr;\n  char *pcVar2;\n  undefined4 *puVar3;\n  \n  puVar3 \u003d \u0026osabis;\n  __ptr \u003d (void *)concat_constprop_0(\u0026DAT_00106137,0);\n  do {\n    puVar1 \u003d (undefined8 *)(puVar3 + 6);\n    puVar3 \u003d puVar3 + 4;\n    __ptr \u003d (void *)reconcat(__ptr,__ptr,\u0026DAT_001061ef,*puVar1,0);\n  } while (puVar3 !\u003d (undefined4 *)\u0026DAT_00108d90);\n  pcVar2 \u003d (char *)dcgettext(0,\"Usage: %s \u003coption(s)\u003e elffile(s)\\n\",5);\n  fprintf(param_1,pcVar2,\"elfedit\");\n  pcVar2 \u003d (char *)dcgettext(0,\" Update the ELF header of ELF files\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  --input-mach [none|i386|iamcu|l1om|k1om|x86_64]\\n                              Set input machine type\\n  --output-mach [none|i386|iamcu|l1om|k1om|x86_64]\\n                              Set output machine type\\n  --input-type [none|rel|exec|dyn]\\n                              Set input file type\\n  --output-type [none|rel|exec|dyn]\\n                              Set output file type\\n  --input-osabi [%s]\\n                              Set input OSABI\\n  --output-osabi [%s]\\n                              Set output OSABI\\n  --input-abiversion [0-255]  Set input ABIVERSION\\n  --output-abiversion [0-255] Set output ABIVERSION\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2,__ptr,__ptr);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  --enable-x86-feature [ibt|shstk|lam_u48|lam_u57]\\n                              Enable x86 feature\\n  --disable-x86-feature [ibt|shstk|lam_u48|lam_u57]\\n                              Disable x86 feature\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -h --help                   Display this information\\n  -v --version                Display the version number of %s\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2,\"elfedit\");\n  if (param_2 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(param_1,pcVar2,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n  free(__ptr);\n                    \n  exit(param_2);\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "exit",
        "fprintf",
        "free",
        "concat.constprop.0",
        "dcgettext",
        "reconcat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xrealloc": {
      "entrypoint": "0x00103449",
      "current_name": "xrealloc",
      "code": "\nvoid xrealloc(void *param_1,size_t param_2)\n\n{\n  size_t __size;\n  void *pvVar1;\n  \n  __size \u003d 1;\n  if (param_2 !\u003d 0) {\n    __size \u003d param_2;\n  }\n  if (param_1 \u003d\u003d (void *)0x0) {\n    pvVar1 \u003d malloc(__size);\n  }\n  else {\n    pvVar1 \u003d realloc(param_1,__size);\n  }\n  if (pvVar1 \u003d\u003d (void *)0x0) {\n    xmalloc_failed(__size);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "xmalloc_failed",
        "realloc",
        "malloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "byte_get_big_endian": {
      "entrypoint": "0x0010347f",
      "current_name": "byte_get_big_endian",
      "code": "\nulong byte_get_big_endian(ulong *param_1,undefined4 param_2)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  undefined8 uVar3;\n  \n  switch(param_2) {\n  case 1:\n    return (ulong)*(byte *)param_1;\n  case 2:\n    return (ulong)CONCAT11((char)*(undefined2 *)param_1,(char)((ushort)*(undefined2 *)param_1 \u003e\u003e 8))\n    ;\n  case 3:\n    return (ulong)*(byte *)((long)param_1 + 1) \u003c\u003c 8 | (ulong)*(byte *)param_1 \u003c\u003c 0x10 |\n           (ulong)*(byte *)((long)param_1 + 2);\n  case 4:\n    uVar1 \u003d *(uint *)param_1;\n    return (ulong)(uVar1 \u003e\u003e 0x18 | (uVar1 \u0026 0xff0000) \u003e\u003e 8 | (uVar1 \u0026 0xff00) \u003c\u003c 8 | uVar1 \u003c\u003c 0x18);\n  case 5:\n    uVar1 \u003d *(uint *)((long)param_1 + 1);\n    return (ulong)CONCAT14(*(byte *)param_1,\n                           uVar1 \u003e\u003e 0x18 | (uVar1 \u0026 0xff0000) \u003e\u003e 8 | (uVar1 \u0026 0xff00) \u003c\u003c 8 |\n                           uVar1 \u003c\u003c 0x18);\n  case 6:\n    uVar1 \u003d *(uint *)((long)param_1 + 2);\n    return (ulong)*(byte *)((long)param_1 + 1) \u003c\u003c 0x20 | (ulong)*(byte *)param_1 \u003c\u003c 0x28 |\n           (ulong)(uVar1 \u003e\u003e 0x18 | (uVar1 \u0026 0xff0000) \u003e\u003e 8 | (uVar1 \u0026 0xff00) \u003c\u003c 8 | uVar1 \u003c\u003c 0x18);\n  case 7:\n    uVar1 \u003d *(uint *)((long)param_1 + 3);\n    return (ulong)*(byte *)((long)param_1 + 2) \u003c\u003c 0x20 | (ulong)*(byte *)((long)param_1 + 1) \u003c\u003c 0x28\n           | (ulong)*(byte *)param_1 \u003c\u003c 0x30 |\n           (ulong)(uVar1 \u003e\u003e 0x18 | (uVar1 \u0026 0xff0000) \u003e\u003e 8 | (uVar1 \u0026 0xff00) \u003c\u003c 8 | uVar1 \u003c\u003c 0x18);\n  case 8:\n    uVar2 \u003d *param_1;\n    return uVar2 \u003e\u003e 0x38 | (uVar2 \u0026 0xff000000000000) \u003e\u003e 0x28 | (uVar2 \u0026 0xff0000000000) \u003e\u003e 0x18 |\n           (uVar2 \u0026 0xff00000000) \u003e\u003e 8 | (uVar2 \u0026 0xff000000) \u003c\u003c 8 | (uVar2 \u0026 0xff0000) \u003c\u003c 0x18 |\n           (uVar2 \u0026 0xff00) \u003c\u003c 0x28 | uVar2 \u003c\u003c 0x38;\n  default:\n    uVar3 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n    error(uVar3,param_2);\n                    \n    abort();\n  }\n}\n\n",
      "renaming": {},
      "calling": [
        "process_object"
      ],
      "called": [
        "abort",
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "byte_put_big_endian": {
      "entrypoint": "0x0010354e",
      "current_name": "byte_put_big_endian",
      "code": "\nvoid byte_put_big_endian(long param_1,ulong param_2,uint param_3)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  uVar3 \u003d (ulong)param_3;\n  if (8 \u003c param_3) {\n    uVar1 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n    error(uVar1,param_3);\n                    \n    abort();\n  }\n  while (iVar2 \u003d (int)uVar3, uVar3 \u003d (ulong)(iVar2 - 1), iVar2 !\u003d 0) {\n    *(char *)(param_1 + uVar3) \u003d (char)param_2;\n    param_2 \u003d param_2 \u003e\u003e 8;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_object"
      ],
      "called": [
        "abort",
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_archive": {
      "entrypoint": "0x0010358d",
      "current_name": "process_archive",
      "code": "\nuint process_archive(undefined8 param_1,FILE *param_2,char param_3)\n\n{\n  long lVar1;\n  char *pcVar2;\n  int iVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  size_t sVar6;\n  undefined8 uVar7;\n  ulong uVar8;\n  size_t sVar9;\n  char *__s;\n  size_t sVar10;\n  size_t sVar11;\n  char *__s_00;\n  char *pcVar12;\n  FILE *__stream;\n  char *pcVar13;\n  uint uVar14;\n  stat local_208;\n  undefined local_178 [24];\n  undefined local_160 [16];\n  undefined8 local_148;\n  undefined local_d8 [16];\n  undefined local_c0 [16];\n  undefined8 local_a8;\n  long local_98;\n  long local_90;\n  int local_88;\n  undefined local_80 [48];\n  char local_50 [10];\n  short local_46;\n  \n  local_148 \u003d 0;\n  local_d8 \u003d ZEXT816(0);\n  local_c0 \u003d ZEXT816(0);\n  local_178._0_16_ \u003d ZEXT816(0);\n  local_160 \u003d ZEXT816(0);\n  local_a8 \u003d 0;\n  iVar3 \u003d fileno(param_2);\n  iVar3 \u003d fstat(iVar3,\u0026local_208);\n  if ((iVar3 \u003c 0) ||\n     (iVar3 \u003d setup_archive_constprop_0(local_d8,param_1,param_2,local_208.st_size,param_3),\n     iVar3 !\u003d 0)) {\nLAB_001036cc:\n    uVar14 \u003d 1;\nLAB_00103a46:\n    if ((FILE *)local_178._8_8_ !\u003d (FILE *)0x0) {\n      fclose((FILE *)local_178._8_8_);\n    }\n    release_archive(local_178);\n    release_archive(local_d8);\n  }\n  else {\n    uVar14 \u003d 0;\n    while (iVar3 \u003d fseek(param_2,local_90,0), iVar3 \u003d\u003d 0) {\n      sVar6 \u003d fread(local_80,1,0x3c,param_2);\n      if (sVar6 !\u003d 0x3c) {\n        if (sVar6 \u003d\u003d 0) goto LAB_00103a46;\n        pcVar13 \u003d \"%s: failed to read archive header\\n\";\nLAB_001036b8:\n        uVar5 \u003d dcgettext(0,pcVar13,5);\n        error(uVar5,param_1);\n        goto LAB_001036cc;\n      }\n      if (local_46 !\u003d 0xa60) {\n        uVar5 \u003d local_d8._0_8_;\n        uVar7 \u003d dcgettext(0,\"%s: did not find a valid archive header\\n\",5);\n        error(uVar7,uVar5);\n        goto LAB_001036cc;\n      }\n      local_90 \u003d local_90 + 0x3c;\n      uVar8 \u003d strtoul(local_50,(char **)0x0,10);\n      archive_file_size \u003d (uVar8 + 1) - (ulong)((uVar8 \u0026 1) \u003d\u003d 0);\n      pcVar13 \u003d (char *)get_archive_member_name(local_d8,local_178);\n      if (pcVar13 \u003d\u003d (char *)0x0) {\n        pcVar13 \u003d \"%s: bad archive file name\\n\";\n        goto LAB_001036b8;\n      }\n      sVar9 \u003d strlen(pcVar13);\n      __s \u003d (char *)dcgettext(0,\"\u003ccorrupt\u003e\",5);\n      pcVar12 \u003d (char *)local_d8._0_8_;\n      sVar10 \u003d strlen((char *)local_d8._0_8_);\n      sVar11 \u003d strlen(pcVar13);\n      sVar6 \u003d sVar10 + sVar11 + 3;\n      if (local_88 \u003d\u003d 0) {\n        __s_00 \u003d (char *)malloc(sVar6);\n        if (__s_00 \u003d\u003d (char *)0x0) goto LAB_001037d3;\n        snprintf(__s_00,sVar6,\"%s(%s)\",pcVar12,pcVar13);\n      }\n      else if (local_98 \u003d\u003d 0) {\n        __s_00 \u003d (char *)malloc(sVar6);\n        if (__s_00 \u003d\u003d (char *)0x0) {\nLAB_001037d3:\n          uVar5 \u003d dcgettext(0,\"Out of memory\\n\",5);\n          error(uVar5);\n          uVar5 \u003d dcgettext(0,\"%s: bad archive file name\\n\",5);\n          error(uVar5,param_1);\n          free(pcVar13);\n          goto LAB_001036cc;\n        }\n        snprintf(__s_00,sVar6,\"%s[%s]\",pcVar12,pcVar13);\n      }\n      else {\n        pcVar2 \u003d (char *)local_178._0_8_;\n        lVar1 \u003d sVar10 + sVar11 + 5;\n        if ((char *)local_178._0_8_ \u003d\u003d (char *)0x0) {\n          sVar6 \u003d strlen(__s);\n          sVar6 \u003d lVar1 + sVar6;\n          __s_00 \u003d (char *)malloc(sVar6);\n          pcVar2 \u003d __s;\n        }\n        else {\n          sVar6 \u003d strlen((char *)local_178._0_8_);\n          sVar6 \u003d lVar1 + sVar6;\n          __s_00 \u003d (char *)malloc(sVar6);\n        }\n        if (__s_00 \u003d\u003d (char *)0x0) goto LAB_001037d3;\n        snprintf(__s_00,sVar6,\"%s[%s(%s)]\",pcVar12,pcVar2,pcVar13);\n      }\n      if (param_3 \u003d\u003d \u0027\\0\u0027) {\n        free(pcVar13);\n        local_90 \u003d local_90 + archive_file_size;\n        uVar4 \u003d process_object(__s_00,param_2);\n        uVar14 \u003d uVar14 | uVar4;\n      }\n      else {\n        if (local_98 \u003d\u003d 0) {\n          pcVar12 \u003d (char *)adjust_relative_path(param_1,pcVar13,sVar9);\n          free(pcVar13);\n          if (pcVar12 !\u003d (char *)0x0) {\n            __stream \u003d fopen(pcVar12,\"r+b\");\n            if (__stream !\u003d (FILE *)0x0) {\n              uVar4 \u003d process_object(__s_00,__stream);\n              uVar14 \u003d uVar14 | uVar4;\n              fclose(__stream);\n              free(pcVar12);\n              goto LAB_00103a39;\n            }\n            uVar5 \u003d dcgettext(0,\"Input file \\\u0027%s\\\u0027 is not readable\\n\",5);\n            error(uVar5,pcVar12);\n            free(pcVar12);\n          }\n          free(__s_00);\n          goto LAB_001036cc;\n        }\n        free(pcVar13);\n        iVar3 \u003d fseek((FILE *)local_178._8_8_,local_98 + 0x3c,0);\n        if (iVar3 !\u003d 0) {\n          uVar5 \u003d local_178._0_8_;\n          uVar7 \u003d dcgettext(0,\"%s: failed to seek to archive member\\n\",5);\n          error(uVar7,uVar5);\n          free(__s_00);\n          goto LAB_001036cc;\n        }\n        uVar4 \u003d process_object(__s_00,local_178._8_8_);\n        uVar14 \u003d uVar14 | uVar4;\n      }\nLAB_00103a39:\n      free(__s_00);\n    }\n    uVar5 \u003d dcgettext(0,\"%s: failed to seek to next archive header\\n\",5);\n    uVar14 \u003d 1;\n    error(uVar5,param_1);\n  }\n  return uVar14;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "setup_archive.constprop.0",
        "fseek",
        "free",
        "strlen",
        "fstat",
        "process_object",
        "fopen",
        "fclose",
        "fileno",
        "strtoul",
        "fread",
        "snprintf",
        "malloc",
        "release_archive",
        "error",
        "adjust_relative_path",
        "dcgettext",
        "get_archive_member_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "byte_get_little_endian": {
      "entrypoint": "0x00103a90",
      "current_name": "byte_get_little_endian",
      "code": "\nulong byte_get_little_endian(ulong *param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  \n  switch(param_2 \u0026 0xffffffff) {\n  default:\n    uVar2 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n    error(uVar2,param_2 \u0026 0xffffffff);\n                    \n    abort();\n  case 1:\n    return (ulong)*(byte *)param_1;\n  case 2:\n    return (ulong)*(ushort *)param_1;\n  case 3:\n    uVar1 \u003d FUN_00103ab3(param_1,param_2,\n                         (ulong)*(byte *)((long)param_1 + 1) \u003c\u003c 8 |\n                         (ulong)*(byte *)((long)param_1 + 2) \u003c\u003c 0x10);\n    return uVar1;\n  case 4:\n    return (ulong)*(uint *)param_1;\n  case 5:\n    uVar1 \u003d FUN_00103ab3(param_1,param_2,(ulong)*(byte *)((long)param_1 + 4) \u003c\u003c 0x20);\n    return uVar1;\n  case 6:\n    uVar1 \u003d FUN_00103ab3(param_1,param_2,\n                         (ulong)*(byte *)((long)param_1 + 4) \u003c\u003c 0x20 |\n                         (ulong)*(byte *)((long)param_1 + 5) \u003c\u003c 0x28);\n    return uVar1;\n  case 7:\n    uVar1 \u003d FUN_00103ab3(param_1,param_2,\n                         (ulong)*(byte *)((long)param_1 + 4) \u003c\u003c 0x20 |\n                         (ulong)*(byte *)((long)param_1 + 5) \u003c\u003c 0x28 | (ulong)*(uint *)param_1);\n    return uVar1;\n  case 8:\n    return *param_1;\n  }\n}\n\n",
      "renaming": {},
      "calling": [
        "process_object"
      ],
      "called": [
        "caseD_0",
        "byte_get_little_endian.cold",
        "FUN_00103ab3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103ab3": {
      "entrypoint": "0x00103ab3",
      "current_name": "FUN_00103ab3",
      "code": "\nvoid FUN_00103ab3(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "byte_get_little_endian.cold",
        "byte_get_little_endian"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "byte_put_little_endian": {
      "entrypoint": "0x00103ad0",
      "current_name": "byte_put_little_endian",
      "code": "\nvoid byte_put_little_endian(long param_1,ulong param_2,uint param_3)\n\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  \n  if (param_3 \u003c 9) {\n    for (uVar2 \u003d 0; param_3 !\u003d uVar2; uVar2 \u003d uVar2 + 1) {\n      *(char *)(param_1 + uVar2) \u003d (char)param_2;\n      param_2 \u003d param_2 \u003e\u003e 8;\n    }\n    return;\n  }\n  uVar1 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n  error(uVar1,param_3);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "process_object"
      ],
      "called": [
        "byte_put_little_endian.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_start": {
      "entrypoint": "0x00103b00",
      "current_name": "_start",
      "code": "\nvoid processEntry _start(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(main,param_2,\u0026stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__libc_start_main",
        "main"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "deregister_tm_clones": {
      "entrypoint": "0x00103b30",
      "current_name": "deregister_tm_clones",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00103b43) */\n/* WARNING: Removing unreachable block (ram,0x00103b4f) */\n\nvoid deregister_tm_clones(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__do_global_dtors_aux"
      ],
      "called": [
        "_ITM_deregisterTMCloneTable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "register_tm_clones": {
      "entrypoint": "0x00103b60",
      "current_name": "register_tm_clones",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00103b84) */\n/* WARNING: Removing unreachable block (ram,0x00103b90) */\n\nvoid register_tm_clones(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "frame_dummy"
      ],
      "called": [
        "_ITM_registerTMCloneTable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__do_global_dtors_aux": {
      "entrypoint": "0x00103ba0",
      "current_name": "__do_global_dtors_aux",
      "code": "\nvoid __do_global_dtors_aux(void)\n\n{\n  if (completed_0 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  __cxa_finalize(__dso_handle);\n  deregister_tm_clones();\n  completed_0 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__cxa_finalize",
        "deregister_tm_clones"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "frame_dummy": {
      "entrypoint": "0x00103be0",
      "current_name": "frame_dummy",
      "code": "\nvoid frame_dummy(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "register_tm_clones"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main": {
      "entrypoint": "0x00103bf0",
      "current_name": "main",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\n\nuint main(int param_1,long *param_2)\n\n{\n  char cVar1;\n  byte bVar2;\n  ulong uVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  bool bVar7;\n  int iVar8;\n  uint uVar9;\n  int iVar10;\n  void *__addr;\n  void *__ptr;\n  undefined8 uVar11;\n  long *plVar12;\n  ulong uVar13;\n  ulong uVar14;\n  ulong uVar15;\n  ulong uVar16;\n  FILE *pFVar17;\n  size_t sVar18;\n  byte *__s;\n  size_t sVar19;\n  int *piVar20;\n  long lVar21;\n  long *plVar22;\n  byte *pbVar23;\n  long lVar24;\n  long *plVar25;\n  undefined8 uVar26;\n  ulong uVar27;\n  byte *pbVar28;\n  uint uVar29;\n  long lVar30;\n  uint uVar31;\n  int iVar32;\n  undefined1 *puVar33;\n  uint uVar34;\n  char *pcVar35;\n  ulong uVar36;\n  char *pcVar37;\n  undefined8 *puVar38;\n  ulong uVar39;\n  undefined8 *local_138;\n  ulong local_120;\n  char *local_d8;\n  byte *local_d0;\n  stat local_c8;\n  \n  iVar8 \u003d 0;\n  iVar32 \u003d 2000;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  plVar22 \u003d param_2;\nLAB_00103c54:\n  lVar30 \u003d (long)(iVar8 + 1);\n  do {\n    iVar8 \u003d (int)lVar30;\n    if (param_1 \u003c\u003d iVar8) {\n      puVar33 \u003d options;\n      break;\n    }\n    if (*(char *)plVar22[lVar30] \u003d\u003d \u0027@\u0027) {\n      iVar32 \u003d iVar32 + -1;\n      if (iVar32 \u003d\u003d 0) {\n        lVar30 \u003d *plVar22;\n        pcVar37 \u003d \"%s: error: too many @-files encountered\\n\";\n        goto LAB_00104739;\n      }\n      pcVar37 \u003d (char *)plVar22[lVar30] + 1;\n      iVar10 \u003d stat(pcVar37,\u0026local_c8);\n      if (-1 \u003c iVar10) {\n        if ((local_c8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n          do {\n            lVar30 \u003d *plVar22;\n            pcVar37 \u003d \"%s: error: @-file refers to a directory\\n\";\nLAB_00104739:\n            fprintf(_stderr,pcVar37,lVar30);\n            xexit_constprop_0();\n          } while( true );\n        }\n        pFVar17 \u003d fopen(pcVar37,\"r\");\n        if (pFVar17 !\u003d (FILE *)0x0) goto code_r0x00104650;\n      }\n    }\n    lVar30 \u003d lVar30 + 1;\n  } while( true );\nLAB_00103c87:\n  iVar8 \u003d getopt_long(param_1,plVar22,\u0026DAT_0010604c,puVar33,0);\n  if (iVar8 \u003d\u003d -1) {\n    if ((_optind \u003d\u003d param_1) ||\n       (((enable_x86_features | disable_x86_features) \u003d\u003d 0 \u0026\u0026\n        (puVar33 \u003d (undefined1 *)0x0,\n        (output_elf_machine \u0026 output_elf_type \u0026 output_elf_osabi \u0026 output_elf_abiversion) \u003d\u003d\n        0xffffffff)))) goto switchD_00103cba_caseD_69;\n    uVar31 \u003d 0;\n    goto LAB_00103d1c;\n  }\n  switch(iVar8) {\n  case 0x68:\n    usage(_stdout,0);\n  default:\nswitchD_00103cba_caseD_69:\n    usage(_stderr,1);\n    goto switchD_00103cba_caseD_9a;\n  case 0x76:\n    printf(\"GNU %s %s\\n\",\"elfedit\",\"(GNU Binutils for Debian) 2.40\");\n    pcVar37 \u003d (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n    printf(pcVar37);\n    pcVar37 \u003d (char *)dcgettext(0,\n                                \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                                ,5);\n    printf(pcVar37);\n                    \n    exit(0);\n  case 0x96:\n    input_elf_machine \u003d elf_machine(_optarg);\n    if (input_elf_machine \u003c 0) {\n      return 1;\n    }\n    if (input_elf_machine \u003d\u003d 6) {\n      input_elf_class \u003d 1;\n    }\n    else if (input_elf_machine \u003c 7) {\n      input_elf_class \u003d (input_elf_machine !\u003d 3) + 1 + (uint)(input_elf_machine !\u003d 3);\n    }\n    else {\n      input_elf_class \u003d 3 - (uint)(input_elf_machine - 0xb4U \u003c 2);\n    }\n    goto LAB_00103c87;\n  case 0x97:\n    output_elf_machine \u003d elf_machine(_optarg);\n    if ((int)output_elf_machine \u003c 0) {\n      return 1;\n    }\n    if ((int)output_elf_machine \u003c 0xb6) {\n      output_elf_class \u003d 2;\n      if (((int)output_elf_machine \u003c 0xb4) \u0026\u0026 (output_elf_class \u003d 1, output_elf_machine !\u003d 3)) {\n        output_elf_class \u003d (output_elf_machine !\u003d 6) + 1 + (uint)(output_elf_machine !\u003d 6);\n      }\n    }\n    else {\n      output_elf_class \u003d 3;\n    }\n    goto LAB_00103c87;\n  case 0x98:\n    input_elf_type \u003d elf_type(_optarg);\n    uVar31 \u003d input_elf_type;\n    break;\n  case 0x99:\n    output_elf_type \u003d elf_type(_optarg);\n    uVar31 \u003d output_elf_type;\n    break;\n  case 0x9a:\n    goto switchD_00103cba_caseD_9a;\n  case 0x9b:\n    output_elf_osabi \u003d elf_osabi(_optarg);\n    uVar31 \u003d output_elf_osabi;\n    break;\n  case 0x9c:\n    uVar16 \u003d strtoul(_optarg,\u0026local_d8,0);\n    uVar31 \u003d (uint)uVar16;\n    cVar1 \u003d *local_d8;\n    input_elf_abiversion \u003d uVar31;\n    pcVar37 \u003d _optarg;\n    goto joined_r0x00104334;\n  case 0x9d:\n    uVar16 \u003d strtoul(_optarg,\u0026local_d8,0);\n    uVar31 \u003d (uint)uVar16;\n    cVar1 \u003d *local_d8;\n    output_elf_abiversion \u003d uVar31;\n    pcVar37 \u003d _optarg;\njoined_r0x00104334:\n    _optarg \u003d pcVar37;\n    if ((cVar1 !\u003d \u0027\\0\u0027) || (0xff \u003c uVar31)) {\n      uVar26 \u003d dcgettext(0,\"Invalid ABIVERSION: %s\\n\",5);\n      error(uVar26,pcVar37);\n      return 1;\n    }\n    goto LAB_00103c87;\n  case 0x9e:\n    uVar26 \u003d 1;\n    goto LAB_00103e9d;\n  case 0x9f:\n    uVar26 \u003d 0;\nLAB_00103e9d:\n    uVar31 \u003d elf_x86_feature(_optarg,uVar26);\n  }\njoined_r0x00103eae:\n  if ((int)uVar31 \u003c 0) {\n    return 1;\n  }\n  goto LAB_00103c87;\nLAB_00103d1c:\n  lVar30 \u003d (long)_optind;\n  if (param_1 \u003c\u003d _optind) {\n    return uVar31;\n  }\n  _optind \u003d _optind + 1;\n  pcVar37 \u003d (char *)plVar22[lVar30];\n  iVar8 \u003d stat(pcVar37,\u0026local_c8);\n  if (iVar8 \u003c 0) {\n    piVar20 \u003d __errno_location();\n    pcVar35 \u003d \"\\\u0027%s\\\u0027: No such file\\n\";\n    if (*piVar20 \u003d\u003d 2) goto LAB_00104497;\n    pcVar35 \u003d strerror(*piVar20);\n    uVar26 \u003d dcgettext(0,\"Could not locate \\\u0027%s\\\u0027.  System error message: %s\\n\",5);\n    error(uVar26,pcVar37,pcVar35);\nLAB_001044ab:\n    uVar9 \u003d 1;\n  }\n  else {\n    if ((local_c8.st_mode \u0026 0xf000) !\u003d 0x8000) {\n      pcVar35 \u003d \"\\\u0027%s\\\u0027 is not an ordinary file\\n\";\nLAB_00104497:\n      uVar26 \u003d dcgettext(0,pcVar35,5);\n      error(uVar26,pcVar37);\n      goto LAB_001044ab;\n    }\n    pFVar17 \u003d fopen(pcVar37,\"r+b\");\n    if (pFVar17 \u003d\u003d (FILE *)0x0) {\n      pcVar35 \u003d \"Input file \\\u0027%s\\\u0027 is not readable\\n\";\n      goto LAB_00104497;\n    }\n    sVar18 \u003d fread(\u0026local_d0,8,1,pFVar17);\n    if (sVar18 !\u003d 1) {\n      uVar26 \u003d dcgettext(0,\"%s: Failed to read file\\\u0027s magic number\\n\",5);\n      error(uVar26,pcVar37);\n      fclose(pFVar17);\n      goto LAB_001044ab;\n    }\n    if (local_d0 \u003d\u003d (byte *)0xa3e686372613c21) {\n      uVar9 \u003d process_archive(pcVar37,pFVar17,0);\n    }\n    else if (local_d0 \u003d\u003d (byte *)0xa3e6e6968743c21) {\n      uVar9 \u003d process_archive(pcVar37,pFVar17,1);\n    }\n    else {\n      rewind(pFVar17);\n      archive_file_size \u003d 0;\n      uVar9 \u003d process_object(pcVar37,pFVar17);\n      if (((uVar9 \u003d\u003d 0) \u0026\u0026 ((ushort)(elf_header._56_2_ - 2) \u003c 2)) \u0026\u0026\n         ((enable_x86_features | disable_x86_features) !\u003d 0)) {\n        if ((elf_header._58_2_ \u003d\u003d 3) ||\n           (pcVar35 \u003d \"%s: Not an i386 nor x86-64 ELF file\\n\", elf_header._58_2_ \u003d\u003d 0x3e)) {\n          iVar8 \u003d fileno(pFVar17);\n          iVar8 \u003d fstat(iVar8,\u0026local_c8);\n          if (iVar8 \u003c 0) {\n            uVar26 \u003d dcgettext(0,\"%s: stat () failed\\n\",5);\n            error(uVar26,pcVar37);\n            uVar9 \u003d 1;\n          }\n          else {\n            iVar8 \u003d fileno(pFVar17);\n            __addr \u003d mmap((void *)0x0,local_c8.st_size,3,1,iVar8,0);\n            if (__addr \u003d\u003d (void *)0xffffffffffffffff) {\n              pcVar35 \u003d \"%s: mmap () failed\\n\";\n              goto LAB_0010438d;\n            }\n            __ptr \u003d (void *)xmalloc((ulong)(uint)elf_header._68_4_ \u003c\u003c 6);\n            uVar26 \u003d elf_header._24_8_;\n            if (elf_header[4] \u003d\u003d \u0027\\x01\u0027) {\n              for (uVar16 \u003d 0; (uint)uVar16 \u003c (uint)elf_header._68_4_;\n                  uVar16 \u003d (ulong)((uint)uVar16 + 1)) {\n                lVar30 \u003d uVar16 * 0x20 + uVar26 + (long)__addr;\n                puVar38 \u003d (undefined8 *)((long)__ptr + uVar16 * 0x40);\n                uVar11 \u003d (*byte_get)(lVar30,4);\n                *puVar38 \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 4,4);\n                puVar38[2] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 8,4);\n                puVar38[3] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0xc,4);\n                puVar38[4] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x10,4);\n                puVar38[5] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x14,4);\n                puVar38[6] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x18,4);\n                puVar38[1] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x1c,4);\n                puVar38[7] \u003d uVar11;\n              }\n            }\n            else {\n              for (uVar29 \u003d 0; uVar29 \u003c (uint)elf_header._68_4_; uVar29 \u003d uVar29 + 1) {\n                lVar30 \u003d (ulong)uVar29 * 0x38 + uVar26 + (long)__addr;\n                puVar38 \u003d (undefined8 *)((ulong)uVar29 * 0x40 + (long)__ptr);\n                uVar11 \u003d (*byte_get)(lVar30,4);\n                *puVar38 \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 8,8);\n                puVar38[2] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x10,8);\n                puVar38[3] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x18,8);\n                puVar38[4] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x20,8);\n                puVar38[5] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x28,8);\n                puVar38[6] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 4,4);\n                puVar38[1] \u003d uVar11;\n                uVar11 \u003d (*byte_get)(lVar30 + 0x30,8);\n                puVar38[7] \u003d uVar11;\n              }\n            }\n            for (uVar16 \u003d 0; (uint)uVar16 \u003c (uint)elf_header._68_4_;\n                uVar16 \u003d (ulong)((uint)uVar16 + 1)) {\n              plVar12 \u003d (long *)(uVar16 * 0x40 + (long)__ptr);\n              if (*plVar12 \u003d\u003d 4) {\n                lVar30 \u003d plVar12[5];\n                uVar3 \u003d plVar12[7];\n                uVar36 \u003d (long)__addr + plVar12[2];\n                for (local_120 \u003d uVar36; local_120 \u003c uVar36 + lVar30;\n                    local_120 \u003d local_120 + ((uVar3 - 1) + uVar15 + uVar14 \u0026 uVar27)) {\n                  if ((uVar36 - local_120) + lVar30 \u003c 0xc) {\nLAB_001044cb:\n                    uVar26 \u003d dcgettext(0,\"%s: Invalid PT_NOTE segment\\n\",5);\n                    error(uVar26,pcVar37);\n                    uVar9 \u003d 1;\n                    goto LAB_001042bf;\n                  }\n                  lVar21 \u003d (*byte_get)(local_120 + 8,4);\n                  uVar13 \u003d (*byte_get)(local_120,4);\n                  if ((uVar36 - (long)(char *)(local_120 + 0xc)) + lVar30 \u003c uVar13)\n                  goto LAB_001044cb;\n                  uVar14 \u003d (*byte_get)(local_120 + 4,4);\n                  uVar27 \u003d -uVar3;\n                  uVar15 \u003d uVar3 + 0xb + uVar13 \u0026 uVar27;\n                  uVar39 \u003d local_120 + uVar15;\n                  if ((uVar14 !\u003d 0) \u0026\u0026\n                     ((uVar36 + lVar30 \u003c\u003d uVar39 || ((uVar36 - uVar39) + lVar30 \u003c uVar14))))\n                  goto LAB_001044cb;\n                  if ((uVar13 \u003d\u003d 4) \u0026\u0026\n                     ((iVar8 \u003d strcmp((char *)(local_120 + 0xc),\"GNU\"), iVar8 \u003d\u003d 0 \u0026\u0026 (lVar21 \u003d\u003d 5))\n                     )) {\n                    if ((uVar14 \u003c 8) || (uVar14 % uVar3 !\u003d 0)) goto LAB_001044cb;\n                    uVar13 \u003d uVar39 + uVar14;\n                    do {\n                      iVar8 \u003d (*byte_get)(uVar39,4);\n                      uVar29 \u003d (*byte_get)(uVar39 + 4,4);\n                      lVar21 \u003d uVar39 + 8;\n                      if (uVar13 \u003c lVar21 + (ulong)uVar29) goto LAB_001044cb;\n                      if (iVar8 \u003d\u003d -0x3ffffffe) {\n                        if (uVar29 !\u003d 4) goto LAB_001044cb;\n                        uVar29 \u003d (*byte_get)(lVar21,4);\n                        if (enable_x86_features \u003d\u003d 0) {\n                          uVar34 \u003d uVar29;\n                          if (disable_x86_features \u003d\u003d 0) goto LAB_001042bf;\nLAB_001042ac:\n                          uVar34 \u003d uVar34 \u0026 ~disable_x86_features;\n                        }\n                        else {\n                          uVar34 \u003d enable_x86_features | uVar29;\n                          if (disable_x86_features !\u003d 0) goto LAB_001042ac;\n                        }\n                        if (uVar29 !\u003d uVar34) {\n                          (*byte_put)(lVar21,uVar34,4);\n                        }\n                        goto LAB_001042bf;\n                      }\n                      uVar39 \u003d lVar21 + ((ulong)uVar29 + (uVar3 - 1) \u0026 uVar27);\n                    } while (7 \u003c (long)(uVar13 - uVar39));\n                  }\n                }\n              }\n            }\nLAB_001042bf:\n            free(__ptr);\n            munmap(__addr,local_c8.st_size);\n          }\n        }\n        else {\nLAB_0010438d:\n          uVar26 \u003d dcgettext(0,pcVar35,5);\n          error(uVar26,pcVar37);\n        }\n      }\n    }\n    fclose(pFVar17);\n  }\n  uVar31 \u003d uVar31 | uVar9;\n  goto LAB_00103d1c;\nswitchD_00103cba_caseD_9a:\n  input_elf_osabi \u003d elf_osabi(_optarg);\n  uVar31 \u003d input_elf_osabi;\n  goto joined_r0x00103eae;\ncode_r0x00104650:\n  iVar10 \u003d fseek(pFVar17,0,2);\n  if (((iVar10 !\u003d -1) \u0026\u0026 (sVar18 \u003d ftell(pFVar17), sVar18 !\u003d 0xffffffffffffffff)) \u0026\u0026\n     (iVar10 \u003d fseek(pFVar17,0,0), iVar10 !\u003d -1)) {\n    __s \u003d (byte *)xmalloc(sVar18 + 1);\n    sVar19 \u003d fread(__s,1,sVar18,pFVar17);\n    if ((sVar18 \u003d\u003d sVar19) || (iVar10 \u003d ferror(pFVar17), iVar10 \u003d\u003d 0)) {\n      __s[sVar19] \u003d 0;\n      pbVar28 \u003d __s;\nLAB_001046fc:\n      if (*pbVar28 \u003d\u003d 0) {\n        local_138 \u003d (undefined8 *)xmalloc(8);\n        *local_138 \u003d 0;\n      }\n      else {\n        if ((_sch_istable[(ulong)*pbVar28 * 2] \u0026 0x40) !\u003d 0) goto code_r0x00104718;\n        local_d0 \u003d __s;\n        strlen((char *)__s);\n        pbVar28 \u003d (byte *)xmalloc();\n        local_138 \u003d (undefined8 *)0x0;\n        iVar10 \u003d 0;\n        bVar6 \u003d false;\n        bVar5 \u003d false;\n        bVar7 \u003d false;\n        lVar21 \u003d 0;\n        do {\n          consume_whitespace(\u0026local_d0);\n          pbVar23 \u003d pbVar28;\n          if ((iVar10 \u003d\u003d 0) || (iVar10 + -1 \u003c\u003d (int)lVar21)) {\n            if (local_138 \u003d\u003d (undefined8 *)0x0) {\n              iVar10 \u003d 8;\n              local_138 \u003d (undefined8 *)xmalloc(0x40);\n            }\n            else {\n              iVar10 \u003d iVar10 * 2;\n              local_138 \u003d (undefined8 *)xrealloc(local_138,(long)iVar10 \u003c\u003c 3);\n            }\n            local_138[lVar21] \u003d 0;\n          }\n          for (; bVar2 \u003d *local_d0, bVar2 !\u003d 0; local_d0 \u003d local_d0 + 1) {\n            if (((_sch_istable[(ulong)bVar2 * 2] \u0026 0x40) !\u003d 0) \u0026\u0026\n               (bVar4 \u003d (bool)(bVar5 | bVar7 | bVar6), !bVar4)) {\n              bVar6 \u003d false;\n              bVar7 \u003d false;\n              bVar5 \u003d bVar4;\n              break;\n            }\n            if (bVar6) {\n              *pbVar23 \u003d bVar2;\n              bVar6 \u003d false;\n              pbVar23 \u003d pbVar23 + 1;\n            }\n            else if (bVar2 \u003d\u003d 0x5c) {\n              bVar6 \u003d true;\n            }\n            else if (bVar5) {\n              if (bVar2 \u003d\u003d 0x27) {\n                bVar5 \u003d false;\n              }\n              else {\nLAB_00104c08:\n                *pbVar23 \u003d bVar2;\n                pbVar23 \u003d pbVar23 + 1;\n              }\n            }\n            else if (bVar7) {\n              if (bVar2 !\u003d 0x22) goto LAB_00104c08;\n              bVar7 \u003d false;\n            }\n            else if (bVar2 \u003d\u003d 0x27) {\n              bVar5 \u003d true;\n            }\n            else {\n              if (bVar2 !\u003d 0x22) goto LAB_00104c08;\n              bVar7 \u003d true;\n            }\n          }\n          *pbVar23 \u003d 0;\n          uVar26 \u003d xstrdup();\n          local_138[lVar21] \u003d uVar26;\n          local_138[lVar21 + 1] \u003d 0;\n          consume_whitespace(\u0026local_d0);\n          lVar21 \u003d lVar21 + 1;\n        } while (*local_d0 !\u003d 0);\n        free(pbVar28);\n      }\n      if (plVar22 \u003d\u003d param_2) {\n        lVar21 \u003d 1;\n        do {\n          lVar24 \u003d lVar21;\n          lVar21 \u003d lVar24 + 1;\n        } while (plVar22[lVar24 + -1] !\u003d 0);\n        plVar25 \u003d (long *)xmalloc((long)(int)lVar24 \u003c\u003c 3);\n        plVar12 \u003d plVar25;\n        while (lVar21 \u003d *plVar22, plVar22 \u003d plVar22 + 1, lVar21 !\u003d 0) {\n          lVar21 \u003d xstrdup();\n          *plVar12 \u003d lVar21;\n          plVar12 \u003d plVar12 + 1;\n        }\n        *plVar12 \u003d 0;\n        lVar21 \u003d 0;\n      }\n      else {\n        lVar21 \u003d 0;\n        plVar25 \u003d plVar22;\n      }\n      for (; local_138[lVar21] !\u003d 0; lVar21 \u003d lVar21 + 1) {\n      }\n      free((void *)plVar25[lVar30]);\n      plVar22 \u003d (long *)xrealloc(plVar25,(lVar21 + 1 + (long)param_1) * 8);\n      memmove(plVar22 + lVar30 + lVar21,plVar22 + lVar30 + 1,(long)(param_1 - iVar8) \u003c\u003c 3);\n      param_1 \u003d param_1 + -1 + (int)lVar21;\n      memcpy(plVar22 + lVar30,local_138,lVar21 * 8);\n      free(local_138);\n      free(__s);\n      iVar8 \u003d iVar8 + -1;\n    }\n    else {\n      free(__s);\n    }\n  }\n  fclose(pFVar17);\n  goto LAB_00103c54;\ncode_r0x00104718:\n  pbVar28 \u003d pbVar28 + 1;\n  goto LAB_001046fc;\n}\n\n",
      "renaming": {},
      "calling": [
        "_start"
      ],
      "called": [
        "xrealloc",
        "fseek",
        "free",
        "textdomain",
        "fclose",
        "process_archive",
        "xstrdup",
        "memcpy",
        "getopt_long",
        "printf",
        "fileno",
        "usage",
        "ferror",
        "bindtextdomain",
        "fread",
        "xexit.constprop.0",
        "strcmp",
        "stat",
        "consume_whitespace",
        "rewind",
        "memmove",
        "xmalloc",
        "elf_x86_feature",
        "strlen",
        "fstat",
        "process_object",
        "setlocale",
        "fopen",
        "strerror",
        "elf_machine",
        "exit",
        "__errno_location",
        "fprintf",
        "ftell",
        "strtoul",
        "munmap",
        "error",
        "dcgettext",
        "mmap",
        "elf_osabi",
        "elf_type"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "elf_x86_feature": {
      "entrypoint": "0x00104c60",
      "current_name": "elf_x86_feature",
      "code": "\nundefined  [16] elf_x86_feature(char *param_1,int param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  undefined auVar4 [16];\n  \n  iVar1 \u003d strcasecmp(param_1,\"ibt\");\n  uVar2 \u003d 1;\n  if (iVar1 !\u003d 0) {\n    iVar1 \u003d strcasecmp(param_1,\"shstk\");\n    uVar2 \u003d 2;\n    if (iVar1 !\u003d 0) {\n      iVar1 \u003d strcasecmp(param_1,\"lam_u48\");\n      if (iVar1 \u003d\u003d 0) {\n        uVar2 \u003d 4;\n      }\n      else {\n        iVar1 \u003d strcasecmp(param_1,\"lam_u57\");\n        uVar2 \u003d 8;\n        if (iVar1 !\u003d 0) {\n          uVar3 \u003d dcgettext(0,\"Unknown x86 feature: %s\\n\",5);\n          error(uVar3,param_1);\n          uVar3 \u003d 0xffffffff;\n          goto LAB_00104ca5;\n        }\n      }\n    }\n  }\n  if (param_2 \u003d\u003d 0) {\n    disable_x86_features \u003d uVar2 | disable_x86_features;\n    enable_x86_features \u003d ~uVar2 \u0026 enable_x86_features;\n  }\n  else {\n    enable_x86_features \u003d uVar2 | enable_x86_features;\n    disable_x86_features \u003d disable_x86_features \u0026 ~uVar2;\n  }\n  uVar3 \u003d 0;\nLAB_00104ca5:\n  auVar4._8_8_ \u003d param_4;\n  auVar4._0_8_ \u003d uVar3;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "elf_x86_feature.cold",
        "strcasecmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "elf_osabi": {
      "entrypoint": "0x00104ce0",
      "current_name": "elf_osabi",
      "code": "\nundefined  [16] elf_osabi(char *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  uint uVar4;\n  undefined4 *puVar5;\n  undefined auVar6 [16];\n  \n  puVar5 \u003d \u0026osabis;\n  uVar3 \u003d 0;\n  do {\n    iVar1 \u003d strcasecmp(param_1,*(char **)(puVar5 + 2));\n    if (iVar1 \u003d\u003d 0) {\n      uVar3 \u003d (ulong)(uint)(\u0026osabis)[uVar3 * 4];\n      goto LAB_00104d20;\n    }\n    uVar4 \u003d (int)uVar3 + 1;\n    uVar3 \u003d (ulong)uVar4;\n    puVar5 \u003d puVar5 + 4;\n  } while (uVar4 !\u003d 0x10);\n  uVar2 \u003d dcgettext(0,\"Unknown OSABI: %s\\n\",5);\n  error(uVar2,param_1);\n  uVar3 \u003d 0xffffffff;\nLAB_00104d20:\n  auVar6._8_8_ \u003d param_4;\n  auVar6._0_8_ \u003d uVar3;\n  return auVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "strcasecmp",
        "elf_osabi.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "elf_machine": {
      "entrypoint": "0x00104d30",
      "current_name": "elf_machine",
      "code": "\nint elf_machine(char *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  iVar1 \u003d strcasecmp(param_1,\"i386\");\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d 3;\n  }\n  else {\n    iVar1 \u003d strcasecmp(param_1,\"iamcu\");\n    if (iVar1 \u003d\u003d 0) {\n      return 6;\n    }\n    iVar2 \u003d strcasecmp(param_1,\"l1om\");\n    iVar1 \u003d 0xb4;\n    if (iVar2 !\u003d 0) {\n      iVar1 \u003d strcasecmp(param_1,\"k1om\");\n      if (iVar1 \u003d\u003d 0) {\n        return 0xb5;\n      }\n      iVar1 \u003d strcasecmp(param_1,\"x86_64\");\n      if (iVar1 \u003d\u003d 0) {\n        iVar1 \u003d 0x3e;\n      }\n      else {\n        iVar1 \u003d strcasecmp(param_1,\"x86-64\");\n        if (iVar1 \u003d\u003d 0) {\n          iVar1 \u003d 0x3e;\n        }\n        else {\n          iVar1 \u003d strcasecmp(param_1,\"none\");\n          if (iVar1 !\u003d 0) {\n            uVar3 \u003d dcgettext(0,\"Unknown machine type: %s\\n\",5);\n            error(uVar3,param_1);\n            iVar1 \u003d -1;\n          }\n        }\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "elf_machine.cold",
        "strcasecmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "elf_type": {
      "entrypoint": "0x00104da0",
      "current_name": "elf_type",
      "code": "\nint elf_type(char *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  iVar1 \u003d strcasecmp(param_1,\"rel\");\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d 1;\n  }\n  else {\n    iVar2 \u003d strcasecmp(param_1,\"exec\");\n    iVar1 \u003d 2;\n    if (iVar2 !\u003d 0) {\n      iVar1 \u003d strcasecmp(param_1,\"dyn\");\n      if (iVar1 \u003d\u003d 0) {\n        iVar1 \u003d 3;\n      }\n      else {\n        iVar1 \u003d strcasecmp(param_1,\"none\");\n        if (iVar1 !\u003d 0) {\n          uVar3 \u003d dcgettext(0,\"Unknown type: %s\\n\",5);\n          error(uVar3,param_1);\n          iVar1 \u003d -1;\n        }\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "error",
        "strcasecmp",
        "dcgettext",
        "elf_type.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_object": {
      "entrypoint": "0x00104de0",
      "current_name": "process_object",
      "code": "\nundefined8 process_object(undefined8 param_1,FILE *param_2)\n\n{\n  int iVar1;\n  long __off;\n  size_t sVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  uint uVar5;\n  uint uVar6;\n  \n  __off \u003d ftell(param_2);\n  sVar2 \u003d fread(elf_header,0x10,1,param_2);\n  if ((sVar2 \u003d\u003d 1) \u0026\u0026 (elf_header._0_4_ \u003d\u003d 0x464c457f)) {\n    byte_put \u003d byte_put_big_endian;\n    if (elf_header[5] !\u003d \u0027\\x02\u0027) {\n      byte_put \u003d byte_put_little_endian;\n    }\n    byte_get \u003d byte_get_big_endian;\n    if (elf_header[5] !\u003d \u0027\\x02\u0027) {\n      byte_get \u003d byte_get_little_endian;\n    }\n    if ((char)elf_header._4_4_ \u003d\u003d \u0027\\x01\u0027) {\n      sVar2 \u003d fread(ehdr32 + 0x10,0x24,1,param_2);\n      if (sVar2 !\u003d 1) goto code_r0x00102558;\n      elf_header._56_2_ \u003d (*byte_get)(0x109390,2);\n      elf_header._58_2_ \u003d (*byte_get)(0x109392,2);\n      elf_header._40_8_ \u003d (*byte_get)(0x109394,4);\n      elf_header._16_8_ \u003d (*byte_get)(0x109398,4);\n      elf_header._24_8_ \u003d (*byte_get)(0x10939c,4);\n      elf_header._32_8_ \u003d (*byte_get)(0x1093a0,4);\n      elf_header._48_8_ \u003d (*byte_get)(0x1093a4,4);\n      elf_header._60_4_ \u003d (*byte_get)(0x1093a8,2);\n      elf_header._64_4_ \u003d (*byte_get)(0x1093aa,2);\n      elf_header._68_4_ \u003d (*byte_get)(0x1093ac,2);\n      elf_header._72_4_ \u003d (*byte_get)(0x1093ae,2);\n      elf_header._76_4_ \u003d (*byte_get)(0x1093b0,2);\n      elf_header._80_4_ \u003d (*byte_get)(0x1093b2,2);\n      ehdr32._0_4_ \u003d elf_header._0_4_;\n      ehdr32._4_4_ \u003d elf_header._4_4_;\n      ehdr32._8_4_ \u003d elf_header._8_4_;\n      ehdr32._12_4_ \u003d elf_header._12_4_;\n    }\n    else {\n      if ((char)elf_header._4_4_ !\u003d \u0027\\x02\u0027) {\n        uVar3 \u003d FUN_00102558();\n        return uVar3;\n      }\n      sVar2 \u003d fread(ehdr64 + 0x10,0x30,1,param_2);\n      if (sVar2 !\u003d 1) goto code_r0x00102558;\n      elf_header._56_2_ \u003d (*byte_get)(0x109350,2);\n      elf_header._58_2_ \u003d (*byte_get)(0x109352,2);\n      elf_header._40_8_ \u003d (*byte_get)(0x109354,4);\n      elf_header._16_8_ \u003d (*byte_get)(0x109358,8);\n      elf_header._24_8_ \u003d (*byte_get)(0x109360,8);\n      elf_header._32_8_ \u003d (*byte_get)(0x109368,8);\n      elf_header._48_8_ \u003d (*byte_get)(0x109370,4);\n      elf_header._60_4_ \u003d (*byte_get)(0x109374,2);\n      elf_header._64_4_ \u003d (*byte_get)(0x109376,2);\n      elf_header._68_4_ \u003d (*byte_get)(0x109378,2);\n      elf_header._72_4_ \u003d (*byte_get)(0x10937a,2);\n      elf_header._76_4_ \u003d (*byte_get)(0x10937c,2);\n      elf_header._80_4_ \u003d (*byte_get)(0x10937e,2);\n      ehdr64._0_4_ \u003d elf_header._0_4_;\n      ehdr64._4_4_ \u003d elf_header._4_4_;\n      ehdr64._8_4_ \u003d elf_header._8_4_;\n      ehdr64._12_4_ \u003d elf_header._12_4_;\n    }\n    iVar1 \u003d fseek(param_2,__off,0);\n    if (iVar1 !\u003d 0) {\n      uVar3 \u003d dcgettext(0,\"%s: Failed to seek to ELF header\\n\",5);\n      error(uVar3,param_1);\n    }\n    uVar5 \u003d (uint)elf_header._4_4_ \u003e\u003e 0x10 \u0026 0xff;\n    if ((char)uVar5 \u003d\u003d \u0027\\x01\u0027) {\n      uVar5 \u003d (uint)(ushort)elf_header._58_2_;\n      if (uVar5 \u003d\u003d output_elf_machine) {\n        return 0;\n      }\n      uVar6 \u003d elf_header._4_4_ \u0026 0xff;\n      if (input_elf_class \u003d\u003d 0xffffffff) {\n        if (elf_header._58_2_ \u003d\u003d 6) {\n          input_elf_class \u003d 1;\n        }\n        else if ((ushort)elf_header._58_2_ \u003c 7) {\n          input_elf_class \u003d (elf_header._58_2_ !\u003d 3) + 1 + (uint)(elf_header._58_2_ !\u003d 3);\n        }\n        else {\n          input_elf_class \u003d 3 - ((ushort)(elf_header._58_2_ - 0xb4) \u003c 2);\n        }\n      }\n      if ((uVar6 \u003d\u003d input_elf_class) || (input_elf_class \u003d\u003d 3)) {\n        if ((uVar6 \u003d\u003d output_elf_class) || (output_elf_class \u003d\u003d 3)) {\n          if ((uVar5 \u003d\u003d input_elf_machine) || (input_elf_machine \u003d\u003d 0xffffffff)) {\n            uVar5 \u003d (uint)(ushort)elf_header._56_2_;\n            if ((input_elf_type \u003d\u003d 0xffffffff) || (uVar5 \u003d\u003d input_elf_type)) {\n              uVar5 \u003d (uint)elf_header._4_4_ \u003e\u003e 0x18;\n              if ((input_elf_osabi \u003d\u003d 0xffffffff) || (uVar5 \u003d\u003d input_elf_osabi)) {\n                uVar5 \u003d elf_header._8_4_ \u0026 0xff;\n                if ((uVar5 \u003d\u003d input_elf_abiversion) || (input_elf_abiversion \u003d\u003d 0xffffffff)) {\n                  if ((char)uVar6 \u003d\u003d \u0027\\x01\u0027) {\n                    if (output_elf_machine !\u003d 0xffffffff) {\n                      (*byte_put)(0x109392,(long)(int)output_elf_machine,2);\n                    }\n                    if (output_elf_type !\u003d -1) {\n                      (*byte_put)(0x109390,(long)output_elf_type,2);\n                    }\n                    if (output_elf_osabi !\u003d -1) {\n                      ehdr32[7] \u003d (char)output_elf_osabi;\n                    }\n                    if (output_elf_abiversion !\u003d -1) {\n                      ehdr32[8] \u003d (char)output_elf_abiversion;\n                    }\n                    sVar2 \u003d fwrite(ehdr32,0x34,1,param_2);\n                    if (sVar2 \u003d\u003d 1) {\n                      return 0;\n                    }\n                    uVar3 \u003d FUN_001024ec();\n                    return uVar3;\n                  }\n                  if ((char)uVar6 !\u003d \u0027\\x02\u0027) {\n                    \n                    abort();\n                  }\n                  if (output_elf_machine !\u003d 0xffffffff) {\n                    (*byte_put)(0x109352,(long)(int)output_elf_machine,2);\n                  }\n                  if (output_elf_type !\u003d -1) {\n                    (*byte_put)(0x109350,(long)output_elf_type,2);\n                  }\n                  if (output_elf_osabi !\u003d -1) {\n                    ehdr64[7] \u003d (char)output_elf_osabi;\n                  }\n                  if (output_elf_abiversion !\u003d -1) {\n                    ehdr64[8] \u003d (char)output_elf_abiversion;\n                  }\n                  sVar2 \u003d fwrite(ehdr64,0x40,1,param_2);\n                  if (sVar2 \u003d\u003d 1) {\n                    return 0;\n                  }\n                  uVar3 \u003d FUN_001024ec();\n                  return uVar3;\n                }\n                pcVar4 \u003d \"%s: Unmatched EI_ABIVERSION: %d is not %d\\n\";\n                uVar6 \u003d input_elf_abiversion;\n              }\n              else {\n                pcVar4 \u003d \"%s: Unmatched EI_OSABI: %d is not %d\\n\";\n                uVar6 \u003d input_elf_osabi;\n              }\n            }\n            else {\n              pcVar4 \u003d \"%s: Unmatched e_type: %d is not %d\\n\";\n              uVar6 \u003d input_elf_type;\n            }\n          }\n          else {\n            pcVar4 \u003d \"%s: Unmatched e_machine: %d is not %d\\n\";\n            uVar6 \u003d input_elf_machine;\n          }\n          uVar3 \u003d dcgettext(0,pcVar4,5);\n          error(uVar3,param_1,uVar5,uVar6);\n          return 1;\n        }\n        pcVar4 \u003d \"%s: Unmatched output EI_CLASS: %d is not %d\\n\";\n        uVar5 \u003d output_elf_class;\n      }\n      else {\n        pcVar4 \u003d \"%s: Unmatched input EI_CLASS: %d is not %d\\n\";\n        uVar5 \u003d input_elf_class;\n      }\n      uVar3 \u003d dcgettext(0,pcVar4,5);\n      error(uVar3,param_1,uVar6,uVar5);\n    }\n    else {\n      uVar3 \u003d dcgettext(0,\"%s: Unsupported EI_VERSION: %d is not %d\\n\",5);\n      error(uVar3,param_1,uVar5,1);\n    }\n  }\n  else {\ncode_r0x00102558:\n    uVar3 \u003d dcgettext(0,\"%s: Failed to read ELF header\\n\",5);\n    error(uVar3,param_1);\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_archive",
        "main"
      ],
      "called": [
        "abort",
        "process_object.cold",
        "fwrite",
        "fseek",
        "FUN_00102558",
        "FUN_001024ec",
        "byte_put_little_endian",
        "byte_get_big_endian",
        "ftell",
        "fread",
        "byte_put_big_endian",
        "byte_get_little_endian",
        "error",
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc": {
      "entrypoint": "0x00105370",
      "current_name": "xmalloc",
      "code": "\nchar * xmalloc(char *param_1,char *param_2)\n\n{\n  ulong __size;\n  long lVar1;\n  char cVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  char *pcVar5;\n  char *pcVar6;\n  ulong uVar7;\n  ulong extraout_RDX;\n  ulong uVar8;\n  byte bVar9;\n  \n  bVar9 \u003d 0;\n  pcVar5 \u003d (char *)0x1;\n  if (param_1 !\u003d (char *)0x0) {\n    pcVar5 \u003d param_1;\n  }\n  pcVar6 \u003d (char *)malloc((size_t)pcVar5);\n  if (pcVar6 !\u003d (char *)0x0) {\n    return pcVar6;\n  }\n  xmalloc_failed();\n  pcVar6 \u003d pcVar5;\n  pcVar4 \u003d pcVar5;\n  while (cVar2 \u003d *pcVar6, cVar2 !\u003d \u0027\\0\u0027) {\n    pcVar6 \u003d pcVar6 + 1;\n    if (cVar2 \u003d\u003d \u0027/\u0027) {\n      pcVar4 \u003d pcVar6;\n    }\n  }\n  if ((*param_2 \u003d\u003d \u0027/\u0027) || (pcVar5 \u003d\u003d pcVar4)) {\n    if (extraout_RDX + 1 \u003d\u003d 0) {\n      return (char *)0x0;\n    }\n    pcVar6 \u003d (char *)malloc(extraout_RDX + 1);\n    uVar7 \u003d extraout_RDX;\n    pcVar5 \u003d pcVar6;\n    if (pcVar6 !\u003d (char *)0x0) {\n      for (; uVar7 !\u003d 0; uVar7 \u003d uVar7 - 1) {\n        *pcVar5 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar9 * -2 + 1;\n        pcVar5 \u003d pcVar5 + (ulong)bVar9 * -2 + 1;\n      }\n      pcVar6[extraout_RDX] \u003d \u0027\\0\u0027;\n      return pcVar6;\n    }\n  }\n  else {\n    uVar8 \u003d (long)pcVar4 - (long)pcVar5;\n    lVar1 \u003d uVar8 + extraout_RDX;\n    uVar7 \u003d extraout_RDX;\n    if (extraout_RDX \u003c\u003d uVar8) {\n      uVar7 \u003d uVar8;\n    }\n    __size \u003d lVar1 + 1;\n    if (__size \u003c uVar7) {\n      uVar3 \u003d dcgettext(0,\"Abnormal length of thin archive member name: %lx\\n\",5);\n      error(uVar3,extraout_RDX);\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(__size);\n    pcVar6 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar7 \u003d extraout_RDX, uVar8 !\u003d 0; uVar8 \u003d uVar8 - 1) {\n        *pcVar6 \u003d *pcVar5;\n        pcVar5 \u003d pcVar5 + (ulong)bVar9 * -2 + 1;\n        pcVar6 \u003d pcVar6 + (ulong)bVar9 * -2 + 1;\n      }\n      for (; uVar7 !\u003d 0; uVar7 \u003d uVar7 - 1) {\n        *pcVar6 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar9 * -2 + 1;\n        pcVar6 \u003d pcVar6 + (ulong)bVar9 * -2 + 1;\n      }\n      pcVar4[lVar1] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  uVar3 \u003d dcgettext(0,\"Out of memory\\n\",5);\n  error(uVar3);\n  return (char *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "xstrdup",
        "concat.constprop.0",
        "main",
        "get_archive_member_name",
        "reconcat"
      ],
      "called": [
        "malloc",
        "xmalloc.cold"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fini": {
      "entrypoint": "0x00105394",
      "current_name": "_fini",
      "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_start_main": {
      "entrypoint": "0x0010a010",
      "current_name": "__libc_start_main",
      "code": "\n\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@GLIBC_2.34 */\n  halt_baddata();\n}\n\n",
      "renaming": {},
      "calling": [
        "_start"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}