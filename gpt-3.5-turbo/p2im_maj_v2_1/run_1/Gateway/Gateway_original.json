{
  "functions": {
    "__do_global_dtors_aux": {
      "entrypoint": "0x0800010c",
      "current_name": "__do_global_dtors_aux",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 __do_global_dtors_aux(undefined4 param_1)\n\n{\n  if ((char)completed_8667 \u003d\u003d \u0027\\0\u0027) {\n    completed_8667._0_1_ \u003d \u0027\\x01\u0027;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "frame_dummy": {
      "entrypoint": "0x08000130",
      "current_name": "frame_dummy",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08000134) */\n/* WARNING: Removing unreachable block (ram,0x0800014e) */\n/* WARNING: Removing unreachable block (ram,0x08000144) */\n/* WARNING: Removing unreachable block (ram,0x08000160) */\n/* WARNING: Removing unreachable block (ram,0x08000154) */\n\nvoid frame_dummy(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x08000178",
      "current_name": "strlen",
      "code": "\nsize_t strlen(char *__s)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 \u003d __s;\n  do {\n    pcVar2 \u003d pcVar3 + 1;\n    cVar1 \u003d *pcVar3;\n    pcVar3 \u003d pcVar2;\n  } while (cVar1 !\u003d \u0027\\0\u0027);\n  return (size_t)(pcVar2 + (-1 - (int)__s));\n}\n\n",
      "renaming": {},
      "calling": [
        "sendString",
        "setFirmwareNameAndVersion",
        "printNumber"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "aflCall": {
      "entrypoint": "0x08000188",
      "current_name": "aflCall",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
      "renaming": {},
      "calling": [
        "startForkserver"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "startForkserver": {
      "entrypoint": "0x0800018c",
      "current_name": "startForkserver",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (noHyperCall !\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d aflCall(1,ticks,0);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "aflCall"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setPinValueCallback": {
      "entrypoint": "0x080001a8",
      "current_name": "setPinValueCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinValueCallback(byte pin,int value)\n\n{\n  bool bVar1;\n  byte bVar2;\n  uint ulPin;\n  uint32_t uVar3;\n  \n  ulPin \u003d (uint)pin;\n  if (ulPin \u003c 0x3c) {\n    if (ulPin \u003c 0x3c) {\n      if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n        bVar1 \u003d false;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n        if (uVar3 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar3 \u003d\u003d 1) {\n            bVar1 \u003d false;\n          }\n          else {\n            bVar1 \u003d true;\n          }\n        }\n      }\n    }\n    else {\n      bVar1 \u003d false;\n    }\n  }\n  else {\n    bVar1 \u003d false;\n  }\n  if ((bVar1) \u0026\u0026 (bVar2 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin), bVar2 \u003d\u003d \u0027\\x01\u0027)) {\n    firmata::FirmataClass::setPinState(\u0026Firmata,pin,value);\n    digitalWrite(ulPin,value);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "pinNametoDigitalPin",
        "digitalWrite",
        "setPinState",
        "getPinMode"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "analogWriteCallback": {
      "entrypoint": "0x08000214",
      "current_name": "analogWriteCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid analogWriteCallback(byte pin,int value)\n\n{\n  bool bVar1;\n  byte bVar2;\n  _Bool _Var3;\n  uint ulPin;\n  uint32_t uVar4;\n  void *in_r2;\n  \n  ulPin \u003d (uint)pin;\n  if (0x3b \u003c ulPin) {\n    return;\n  }\n  bVar2 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin);\n  if (bVar2 \u003d\u003d \u0027\\x03\u0027) {\n    if (ulPin \u003c 0x3c) {\n      if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n        _Var3 \u003d false;\n      }\n      else {\n        uVar4 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n        if (uVar4 \u003d\u003d 0) {\n          _Var3 \u003d false;\n        }\n        else {\n          uVar4 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar4 \u003d\u003d 1) {\n            _Var3 \u003d false;\n          }\n          else {\n            _Var3 \u003d pin_in_pinmap((\u0026digitalPin)[ulPin],(PinMap_conflict *)\u0026PinMap_PWM);\n          }\n        }\n      }\n    }\n    else {\n      _Var3 \u003d false;\n    }\n    if (_Var3 !\u003d false) {\n      analogWrite(ulPin,value);\n    }\n    firmata::FirmataClass::setPinState(\u0026Firmata,pin,value);\n  }\n  else if (bVar2 \u003d\u003d \u0027\\x04\u0027) {\n    if (ulPin \u003c 0x3c) {\n      if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n        bVar1 \u003d false;\n      }\n      else {\n        uVar4 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n        if (uVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          uVar4 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar4 \u003d\u003d 1) {\n            bVar1 \u003d false;\n          }\n          else {\n            bVar1 \u003d true;\n          }\n        }\n      }\n    }\n    else {\n      bVar1 \u003d false;\n    }\n    if (bVar1) {\n      Servo::write(servos + servoPinMap[ulPin],value,in_r2,(size_t)servos);\n    }\n    firmata::FirmataClass::setPinState(\u0026Firmata,pin,value);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sysexCallback"
      ],
      "called": [
        "write",
        "pinNametoDigitalPin",
        "setPinState",
        "pin_in_pinmap",
        "getPinMode",
        "analogWrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digitalWriteCallback": {
      "entrypoint": "0x080002ec",
      "current_name": "digitalWriteCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid digitalWriteCallback(byte port,int value)\n\n{\n  bool bVar1;\n  byte bVar2;\n  uint uVar3;\n  uint32_t uVar4;\n  int iVar5;\n  byte pin_00;\n  uint32_t ulPin;\n  uint uVar6;\n  byte lastPin;\n  uint uVar7;\n  byte pin;\n  byte pin_1;\n  uint32_t ulPin_00;\n  uint uVar8;\n  byte pinValue;\n  \n  uVar3 \u003d (uint)port;\n  if (uVar3 \u003c 5) {\n    uVar7 \u003d (uVar3 + 1 \u0026 0x1f) * 8;\n    if (0x3c \u003c uVar7) {\n      uVar7 \u003d 0x3c;\n    }\n    uVar8 \u003d 0;\n    uVar6 \u003d 1;\n    ulPin_00 \u003d (uVar3 \u0026 0x1f) * 8;\n    for (ulPin \u003d ulPin_00; ulPin \u003c uVar7; ulPin \u003d ulPin + 1 \u0026 0xff) {\n      if (ulPin \u003c 0x3c) {\n        if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n          bVar1 \u003d false;\n        }\n        else {\n          uVar4 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar4 \u003d\u003d 0) {\n            bVar1 \u003d false;\n          }\n          else {\n            uVar4 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n            if (uVar4 \u003d\u003d 1) {\n              bVar1 \u003d false;\n            }\n            else {\n              bVar1 \u003d true;\n            }\n          }\n        }\n      }\n      else {\n        bVar1 \u003d false;\n      }\n      if (bVar1) {\n        pin_00 \u003d (byte)ulPin;\n        bVar2 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin_00);\n        if ((bVar2 !\u003d \u0027\\x01\u0027) \u0026\u0026\n           (bVar2 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin_00), bVar2 !\u003d \u0027\\0\u0027)) {\n          bVar1 \u003d false;\n        }\n        if (bVar1) {\n          uVar3 \u003d (uint)((uVar6 \u0026 value) !\u003d 0);\n          bVar2 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin_00);\n          if (bVar2 \u003d\u003d \u0027\\x01\u0027) {\n            uVar8 \u003d uVar6 | uVar8;\n          }\n          else {\n            bVar2 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin_00);\n            if (bVar2 \u003d\u003d \u0027\\0\u0027) {\n              if (uVar3 \u003d\u003d 0) {\n                bVar1 \u003d false;\n              }\n              else {\n                iVar5 \u003d firmata::FirmataClass::getPinState(\u0026Firmata,pin_00);\n                if (iVar5 \u003d\u003d 1) {\n                  bVar1 \u003d false;\n                }\n              }\n            }\n            else {\n              bVar1 \u003d false;\n            }\n            if (bVar1) {\n              pinMode(ulPin,2);\n            }\n          }\n          firmata::FirmataClass::setPinState(\u0026Firmata,pin_00,uVar3);\n        }\n      }\n      uVar6 \u003d (uVar6 \u0026 0x7f) \u003c\u003c 1;\n    }\n    if ((uVar8 \u0026 1) !\u003d 0) {\n      digitalWrite(ulPin_00,value \u0026 1);\n    }\n    if ((uVar8 \u0026 2) !\u003d 0) {\n      digitalWrite(ulPin_00 + 1,value \u0026 2);\n    }\n    if ((uVar8 \u0026 4) !\u003d 0) {\n      digitalWrite(ulPin_00 + 2,value \u0026 4);\n    }\n    if ((uVar8 \u0026 8) !\u003d 0) {\n      digitalWrite(ulPin_00 + 3,value \u0026 8);\n    }\n    if ((uVar8 \u0026 0x10) !\u003d 0) {\n      digitalWrite(ulPin_00 + 4,value \u0026 0x10);\n    }\n    if ((uVar8 \u0026 0x20) !\u003d 0) {\n      digitalWrite(ulPin_00 + 5,value \u0026 0x20);\n    }\n    if ((uVar8 \u0026 0x40) !\u003d 0) {\n      digitalWrite(ulPin_00 + 6,value \u0026 0x40);\n    }\n    if ((uVar8 \u0026 0x80) !\u003d 0) {\n      digitalWrite(ulPin_00 + 7,value \u0026 0x80);\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "getPinState",
        "pinMode",
        "pinNametoDigitalPin",
        "digitalWrite",
        "setPinState",
        "getPinMode"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "reportAnalogCallback": {
      "entrypoint": "0x08000488",
      "current_name": "reportAnalogCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reportAnalogCallback(byte analogPin,int value)\n\n{\n  uint ulPin;\n  uint32_t value_00;\n  \n  ulPin \u003d (uint)analogPin;\n  if (ulPin \u003c 0xe) {\n    if (value \u003d\u003d 0) {\n      analogInputsToReport \u003d analogInputsToReport \u0026 ~(1 \u003c\u003c ulPin);\n      return;\n    }\n    analogInputsToReport \u003d 1 \u003c\u003c ulPin | analogInputsToReport;\n    if (!isResetting) {\n      value_00 \u003d analogRead(ulPin);\n      firmata::FirmataClass::sendAnalog(\u0026Firmata,analogPin,value_00);\n      return;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback"
      ],
      "called": [
        "sendAnalog",
        "analogRead"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__static_initialization_and_destruction_0": {
      "entrypoint": "0x08008f78",
      "current_name": "__static_initialization_and_destruction_0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid __static_initialization_and_destruction_0(int __initialize_p,int __priority)\n\n{\n  if (__initialize_p !\u003d 1) {\n    return;\n  }\n  if (__priority \u003d\u003d 0xffff) {\n    gpio_irq_conf[0].irqnb \u003d EXTI0_IRQn;\n    gpio_irq_conf[0].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[1].irqnb \u003d EXTI1_IRQn;\n    gpio_irq_conf[1].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[2].irqnb \u003d EXTI2_IRQn;\n    gpio_irq_conf[2].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[3].irqnb \u003d EXTI3_IRQn;\n    gpio_irq_conf[3].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[4].irqnb \u003d EXTI4_IRQn;\n    gpio_irq_conf[4].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[5].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[5].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[6].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[6].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[7].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[7].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[8].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[8].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[9].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[9].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[10].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[10].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[11].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[11].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[12].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[12].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[13].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[13].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[14].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[14].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[15].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[15].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    __aeabi_atexit(0,0x8008f51,0x20000000);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
      ],
      "called": [
        "__aeabi_atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "attachServo": {
      "entrypoint": "0x08000500",
      "current_name": "attachServo",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid attachServo(byte pin,int minPulse,int maxPulse)\n\n{\n  uint pin_00;\n  \n  pin_00 \u003d (uint)pin;\n  if (0xb \u003c servoCount) {\n    firmata::FirmataClass::sendString(\u0026Firmata,\"Max servos attached\");\n    return;\n  }\n  if (detachedServoCount \u003d\u003d 0) {\n    servoPinMap[pin_00] \u003d servoCount;\n    servoCount \u003d servoCount + \u0027\\x01\u0027;\n  }\n  else {\n    servoPinMap[pin_00] \u003d (\u0026DAT_2000011f)[detachedServoCount];\n    detachedServoCount \u003d detachedServoCount + 0xff;\n  }\n  if ((0 \u003c minPulse) \u0026\u0026 (0 \u003c maxPulse)) {\n    Servo::attach(servos + servoPinMap[pin_00],pin_00,minPulse,maxPulse);\n    return;\n  }\n  Servo::attach(servos + servoPinMap[pin_00],pin_00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback",
        "sysexCallback"
      ],
      "called": [
        "attach",
        "sendString",
        "attach"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "detachServo": {
      "entrypoint": "0x08000588",
      "current_name": "detachServo",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid detachServo(byte pin)\n\n{\n  Servo::detach(servos + servoPinMap[pin]);\n  if ((servoPinMap[pin] \u003d\u003d servoCount) \u0026\u0026 (servoCount !\u003d \u0027\\0\u0027)) {\n    servoCount \u003d servoCount + 0xff;\n  }\n  else if (servoCount !\u003d \u0027\\0\u0027) {\n    detachedServoCount \u003d detachedServoCount + 1;\n    (\u0026DAT_2000011f)[detachedServoCount] \u003d servoPinMap[pin];\n  }\n  servoPinMap[pin] \u003d 0xff;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback",
        "sysexCallback"
      ],
      "called": [
        "detach"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "disableI2CPins": {
      "entrypoint": "0x080005e0",
      "current_name": "disableI2CPins",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid disableI2CPins(void)\n\n{\n  isI2CEnabled \u003d false;\n  queryIndex \u003d -1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback",
        "systemResetCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setPinModeCallback": {
      "entrypoint": "0x080005f8",
      "current_name": "setPinModeCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setPinModeCallback(byte pin,int mode)\n\n{\n  byte bVar1;\n  PinName_conflict PVar2;\n  bool bVar3;\n  bool bVar4;\n  _Bool _Var5;\n  uint ulPin;\n  uint32_t uVar6;\n  char cVar7;\n  uint uVar8;\n  \n  ulPin \u003d (uint)pin;\n  bVar1 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin);\n  if (bVar1 !\u003d \u0027\\x7f\u0027) {\n    bVar1 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin);\n    if (bVar1 \u003d\u003d \u0027\\x06\u0027) {\n      if (isI2CEnabled \u003d\u003d false) {\n        cVar7 \u003d \u0027\\0\u0027;\n      }\n      else {\n        cVar7 \u003d isI2CEnabled;\n        if (mode \u003d\u003d 6) {\n          cVar7 \u003d \u0027\\0\u0027;\n        }\n      }\n    }\n    else {\n      cVar7 \u003d \u0027\\0\u0027;\n    }\n    if (cVar7 !\u003d \u0027\\0\u0027) {\n      disableI2CPins();\n    }\n    if (ulPin \u003c 0x3c) {\n      if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n        bVar3 \u003d false;\n      }\n      else {\n        uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n        if (uVar6 \u003d\u003d 0) {\n          bVar3 \u003d false;\n        }\n        else {\n          uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar6 \u003d\u003d 1) {\n            bVar3 \u003d false;\n          }\n          else if (mode \u003d\u003d 4) {\n            bVar3 \u003d false;\n          }\n          else {\n            bVar3 \u003d true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 \u003d false;\n    }\n    if (bVar3) {\n      if (servoPinMap[ulPin] \u003c 0xc) {\n        bVar3 \u003d Servo::attached(servos + servoPinMap[ulPin]);\n      }\n      else {\n        bVar3 \u003d false;\n      }\n      if (bVar3 !\u003d false) {\n        detachServo(pin);\n      }\n    }\n    uVar8 \u003d ulPin - 0x2e \u0026 0xff;\n    if (uVar8 \u003c 0xe) {\n      if (ulPin \u003c 0x3c) {\n        PVar2 \u003d (\u0026digitalPin)[ulPin];\n      }\n      else {\n        PVar2 \u003d NC;\n      }\n      uVar6 \u003d pinNametoDigitalPin(PVar2);\n      if (uVar6 \u003d\u003d 0) {\n        bVar3 \u003d false;\n      }\n      else {\n        if (ulPin \u003c 0x3c) {\n          PVar2 \u003d (\u0026digitalPin)[ulPin];\n        }\n        else {\n          PVar2 \u003d NC;\n        }\n        uVar6 \u003d pinNametoDigitalPin(PVar2);\n        if (uVar6 \u003d\u003d 1) {\n          bVar3 \u003d false;\n        }\n        else {\n          bVar3 \u003d true;\n        }\n      }\n    }\n    else {\n      bVar3 \u003d false;\n    }\n    if (bVar3) {\n      reportAnalogCallback((byte)uVar8,(uint)(mode \u003d\u003d 2));\n    }\n    if (ulPin \u003c 0x3c) {\n      if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n        bVar3 \u003d false;\n      }\n      else {\n        uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n        if (uVar6 \u003d\u003d 0) {\n          bVar3 \u003d false;\n        }\n        else {\n          uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar6 \u003d\u003d 1) {\n            bVar3 \u003d false;\n          }\n          else {\n            bVar3 \u003d true;\n          }\n        }\n      }\n    }\n    else {\n      bVar3 \u003d false;\n    }\n    if (bVar3) {\n      if ((mode \u003d\u003d 0) || (mode \u003d\u003d 0xb)) {\n        portConfigInputs[pin \u003e\u003e 3] \u003d portConfigInputs[pin \u003e\u003e 3] | (byte)(1 \u003c\u003c (ulPin \u0026 7));\n      }\n      else {\n        portConfigInputs[pin \u003e\u003e 3] \u003d portConfigInputs[pin \u003e\u003e 3] \u0026 ~(byte)(1 \u003c\u003c (ulPin \u0026 7));\n      }\n    }\n    firmata::FirmataClass::setPinState(\u0026Firmata,pin,0);\n    switch(mode) {\n    case 0:\n      if (ulPin \u003c 0x3c) {\n        if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n          bVar3 \u003d false;\n        }\n        else {\n          uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar6 \u003d\u003d 0) {\n            bVar3 \u003d false;\n          }\n          else {\n            uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n            if (uVar6 \u003d\u003d 1) {\n              bVar3 \u003d false;\n            }\n            else {\n              bVar3 \u003d true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 \u003d false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,0);\n        firmata::FirmataClass::setPinMode(\u0026Firmata,pin,\u0027\\0\u0027);\n        return;\n      }\n      break;\n    case 1:\n      if (ulPin \u003c 0x3c) {\n        if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n          bVar3 \u003d false;\n        }\n        else {\n          uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar6 \u003d\u003d 0) {\n            bVar3 \u003d false;\n          }\n          else {\n            uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n            if (uVar6 \u003d\u003d 1) {\n              bVar3 \u003d false;\n            }\n            else {\n              bVar3 \u003d true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 \u003d false;\n      }\n      if (bVar3) {\n        bVar1 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,pin);\n        if (bVar1 \u003d\u003d \u0027\\x03\u0027) {\n          digitalWrite(ulPin,0);\n        }\n        pinMode(ulPin,1);\n        firmata::FirmataClass::setPinMode(\u0026Firmata,pin,\u0027\\x01\u0027);\n        return;\n      }\n      break;\n    case 2:\n      if (uVar8 \u003c 0xe) {\n        if (ulPin \u003c 0x3c) {\n          PVar2 \u003d (\u0026digitalPin)[ulPin];\n        }\n        else {\n          PVar2 \u003d NC;\n        }\n        uVar6 \u003d pinNametoDigitalPin(PVar2);\n        if (uVar6 \u003d\u003d 0) {\n          bVar3 \u003d false;\n        }\n        else {\n          if (ulPin \u003c 0x3c) {\n            PVar2 \u003d (\u0026digitalPin)[ulPin];\n          }\n          else {\n            PVar2 \u003d NC;\n          }\n          uVar6 \u003d pinNametoDigitalPin(PVar2);\n          if (uVar6 \u003d\u003d 1) {\n            bVar3 \u003d false;\n          }\n          else {\n            bVar3 \u003d true;\n          }\n        }\n      }\n      else {\n        bVar3 \u003d false;\n      }\n      if (bVar3) {\n        if (ulPin \u003c 0x3c) {\n          if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n            bVar3 \u003d false;\n          }\n          else {\n            uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n            if (uVar6 \u003d\u003d 0) {\n              bVar3 \u003d false;\n            }\n            else {\n              uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n              if (uVar6 \u003d\u003d 1) {\n                bVar3 \u003d false;\n              }\n            }\n          }\n        }\n        else {\n          bVar3 \u003d false;\n        }\n        if (bVar3) {\n          pinMode(ulPin,0);\n        }\n        firmata::FirmataClass::setPinMode(\u0026Firmata,pin,\u0027\\x02\u0027);\n        return;\n      }\n      break;\n    case 3:\n      if (ulPin \u003c 0x3c) {\n        if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n          _Var5 \u003d false;\n        }\n        else {\n          uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar6 \u003d\u003d 0) {\n            _Var5 \u003d false;\n          }\n          else {\n            uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n            if (uVar6 \u003d\u003d 1) {\n              _Var5 \u003d false;\n            }\n            else {\n              _Var5 \u003d pin_in_pinmap((\u0026digitalPin)[ulPin],(PinMap_conflict *)\u0026PinMap_PWM);\n            }\n          }\n        }\n      }\n      else {\n        _Var5 \u003d false;\n      }\n      if (_Var5 !\u003d false) {\n        pinMode(ulPin,1);\n        analogWrite(ulPin,0);\n        firmata::FirmataClass::setPinMode(\u0026Firmata,pin,\u0027\\x03\u0027);\n        return;\n      }\n      break;\n    case 4:\n      if (ulPin \u003c 0x3c) {\n        if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n          bVar3 \u003d false;\n        }\n        else {\n          uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar6 \u003d\u003d 0) {\n            bVar3 \u003d false;\n          }\n          else {\n            uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n            if (uVar6 \u003d\u003d 1) {\n              bVar3 \u003d false;\n            }\n            else {\n              bVar3 \u003d true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 \u003d false;\n      }\n      if (bVar3) {\n        firmata::FirmataClass::setPinMode(\u0026Firmata,pin,\u0027\\x04\u0027);\n        if ((servoPinMap[ulPin] !\u003d 0xff) \u0026\u0026\n           (bVar4 \u003d Servo::attached(servos + servoPinMap[ulPin]), bVar4)) {\n          bVar3 \u003d false;\n        }\n        if (bVar3) {\n          attachServo(pin,-1,-1);\n          return;\n        }\n      }\n      break;\n    default:\n      firmata::FirmataClass::sendString(\u0026Firmata,\"Unknown pin mode\");\n      break;\n    case 6:\n      if (ulPin \u003c 0x3c) {\n        if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n          _Var5 \u003d false;\n        }\n        else {\n          uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar6 \u003d\u003d 0) {\n            _Var5 \u003d false;\n          }\n          else {\n            uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n            if (uVar6 \u003d\u003d 1) {\n              _Var5 \u003d false;\n            }\n            else {\n              _Var5 \u003d pin_in_pinmap((\u0026digitalPin)[ulPin],(PinMap_conflict *)\u0026PinMap_I2C_SDA);\n              if (!_Var5) {\n                _Var5 \u003d pin_in_pinmap((\u0026digitalPin)[ulPin],(PinMap_conflict *)\u0026PinMap_I2C_SCL);\n              }\n            }\n          }\n        }\n      }\n      else {\n        _Var5 \u003d false;\n      }\n      if (_Var5 !\u003d false) {\n        firmata::FirmataClass::setPinMode(\u0026Firmata,pin,\u0027\\x06\u0027);\n        return;\n      }\n      break;\n    case 10:\n      break;\n    case 0xb:\n      if (ulPin \u003c 0x3c) {\n        if ((\u0026digitalPin)[ulPin] \u003d\u003d NC) {\n          bVar3 \u003d false;\n        }\n        else {\n          uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n          if (uVar6 \u003d\u003d 0) {\n            bVar3 \u003d false;\n          }\n          else {\n            uVar6 \u003d pinNametoDigitalPin((\u0026digitalPin)[ulPin]);\n            if (uVar6 \u003d\u003d 1) {\n              bVar3 \u003d false;\n            }\n            else {\n              bVar3 \u003d true;\n            }\n          }\n        }\n      }\n      else {\n        bVar3 \u003d false;\n      }\n      if (bVar3) {\n        pinMode(ulPin,2);\n        firmata::FirmataClass::setPinMode(\u0026Firmata,pin,\u0027\\v\u0027);\n        firmata::FirmataClass::setPinState(\u0026Firmata,pin,1);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "enableI2CPins",
        "sysexCallback",
        "systemResetCallback"
      ],
      "called": [
        "pinMode",
        "pinNametoDigitalPin",
        "disableI2CPins",
        "setPinState",
        "attachServo",
        "pin_in_pinmap",
        "setPinMode",
        "sendString",
        "detachServo",
        "digitalWrite",
        "getPinMode",
        "reportAnalogCallback",
        "attached",
        "analogWrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "enableI2CPins": {
      "entrypoint": "0x08000a64",
      "current_name": "enableI2CPins",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid enableI2CPins(void)\n\n{\n  _Bool _Var1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  for (uVar3 \u003d 0; uVar3 \u003c 0x3c; uVar3 \u003d uVar3 + 1 \u0026 0xff) {\n    if (uVar3 \u003c 0x3c) {\n      if ((\u0026digitalPin)[uVar3] \u003d\u003d NC) {\n        _Var1 \u003d false;\n      }\n      else {\n        uVar2 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar3]);\n        if (uVar2 \u003d\u003d 0) {\n          _Var1 \u003d false;\n        }\n        else {\n          uVar2 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar3]);\n          if (uVar2 \u003d\u003d 1) {\n            _Var1 \u003d false;\n          }\n          else {\n            _Var1 \u003d pin_in_pinmap((\u0026digitalPin)[uVar3],(PinMap_conflict *)\u0026PinMap_I2C_SDA);\n            if (!_Var1) {\n              _Var1 \u003d pin_in_pinmap((\u0026digitalPin)[uVar3],(PinMap_conflict *)\u0026PinMap_I2C_SCL);\n            }\n          }\n        }\n      }\n    }\n    else {\n      _Var1 \u003d false;\n    }\n    if (_Var1 !\u003d false) {\n      setPinModeCallback((byte)uVar3,6);\n    }\n  }\n  isI2CEnabled \u003d true;\n  TwoWire::begin(\u0026Wire);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sysexCallback"
      ],
      "called": [
        "pinNametoDigitalPin",
        "setPinModeCallback",
        "begin",
        "pin_in_pinmap"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "systemResetCallback": {
      "entrypoint": "0x08000aec",
      "current_name": "systemResetCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid systemResetCallback(void)\n\n{\n  bool bVar1;\n  PinName_conflict PVar2;\n  uint32_t uVar3;\n  byte i;\n  uint uVar4;\n  byte i_1;\n  \n  isResetting \u003d true;\n  if (isI2CEnabled) {\n    disableI2CPins();\n  }\n  for (uVar4 \u003d 0; uVar4 \u003c 5; uVar4 \u003d uVar4 + 1 \u0026 0xff) {\n    reportPINs[uVar4] \u003d \u0027\\0\u0027;\n    portConfigInputs[uVar4] \u003d \u0027\\0\u0027;\n    previousPINs[uVar4] \u003d \u0027\\0\u0027;\n  }\n  for (uVar4 \u003d 0; uVar4 \u003c 0x3c; uVar4 \u003d uVar4 + 1 \u0026 0xff) {\n    if ((uVar4 - 0x2e \u0026 0xff) \u003c 0xe) {\n      if (uVar4 \u003c 0x3c) {\n        PVar2 \u003d (\u0026digitalPin)[uVar4];\n      }\n      else {\n        PVar2 \u003d NC;\n      }\n      uVar3 \u003d pinNametoDigitalPin(PVar2);\n      if (uVar3 \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        if (uVar4 \u003c 0x3c) {\n          PVar2 \u003d (\u0026digitalPin)[uVar4];\n        }\n        else {\n          PVar2 \u003d NC;\n        }\n        uVar3 \u003d pinNametoDigitalPin(PVar2);\n        if (uVar3 \u003d\u003d 1) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    else {\n      bVar1 \u003d false;\n    }\n    if (bVar1) {\n      setPinModeCallback((byte)uVar4,2);\n    }\n    else {\n      if ((((uVar4 \u003c 0x3c) \u0026\u0026 ((\u0026digitalPin)[uVar4] !\u003d NC)) \u0026\u0026\n          (uVar3 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar4]), uVar3 !\u003d 0)) \u0026\u0026\n         (uVar3 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar4]), uVar3 !\u003d 1)) {\n        bVar1 \u003d true;\n      }\n      if (bVar1) {\n        setPinModeCallback((byte)uVar4,1);\n      }\n    }\n    servoPinMap[uVar4] \u003d 0xff;\n  }\n  analogInputsToReport \u003d 0;\n  detachedServoCount \u003d \u0027\\0\u0027;\n  servoCount \u003d \u0027\\0\u0027;\n  isResetting \u003d false;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "pinNametoDigitalPin",
        "setPinModeCallback",
        "disableI2CPins"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "outputPort": {
      "entrypoint": "0x08000be8",
      "current_name": "outputPort",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid outputPort(byte portNumber,byte portValue,byte forceSend)\n\n{\n  byte bVar1;\n  \n  bVar1 \u003d portConfigInputs[portNumber] \u0026 portValue;\n  if ((forceSend !\u003d \u0027\\0\u0027) || ((uint)bVar1 !\u003d (uint)previousPINs[portNumber])) {\n    firmata::FirmataClass::sendDigitalPort(\u0026Firmata,portNumber,(uint)bVar1);\n    previousPINs[portNumber] \u003d bVar1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "checkDigitalInputs",
        "reportDigitalCallback"
      ],
      "called": [
        "sendDigitalPort"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "reportDigitalCallback": {
      "entrypoint": "0x08000c18",
      "current_name": "reportDigitalCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reportDigitalCallback(byte port,int value)\n\n{\n  byte bVar1;\n  bool bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uchar pin;\n  uint uVar5;\n  byte portValue;\n  \n  uVar5 \u003d (uint)port;\n  if ((uVar5 \u003c 5) \u0026\u0026 (reportPINs[uVar5] \u003d (byte)value, value !\u003d 0)) {\n    bVar1 \u003d portConfigInputs[uVar5];\n    uVar5 \u003d (uVar5 \u0026 0x1f) * 8;\n    if (uVar5 \u003c 0x3c) {\n      if ((\u0026digitalPin)[uVar5] \u003d\u003d NC) {\n        portValue \u003d 0;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar5]);\n        if (uVar3 \u003d\u003d 0) {\n          portValue \u003d 0;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar5]);\n          if (uVar3 \u003d\u003d 1) {\n            portValue \u003d 0;\n          }\n          else if ((bVar1 \u0026 1) \u003d\u003d 0) {\n            portValue \u003d 0;\n          }\n          else {\n            iVar4 \u003d digitalRead(uVar5);\n            if (iVar4 \u003d\u003d 0) {\n              portValue \u003d 0;\n            }\n            else {\n              portValue \u003d 1;\n            }\n          }\n        }\n      }\n    }\n    else {\n      portValue \u003d 0;\n    }\n    if (uVar5 + 1 \u003c 0x3c) {\n      if ((\u0026DAT_0800a909)[uVar5] \u003d\u003d NC) {\n        bVar2 \u003d false;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a909)[uVar5]);\n        if (uVar3 \u003d\u003d 0) {\n          bVar2 \u003d false;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a909)[uVar5]);\n          if (uVar3 \u003d\u003d 1) {\n            bVar2 \u003d false;\n          }\n          else if ((bVar1 \u0026 2) \u003d\u003d 0) {\n            bVar2 \u003d false;\n          }\n          else {\n            iVar4 \u003d digitalRead(uVar5 + 1);\n            if (iVar4 \u003d\u003d 0) {\n              bVar2 \u003d false;\n            }\n            else {\n              bVar2 \u003d true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (bVar2) {\n      portValue \u003d portValue | 2;\n    }\n    if (uVar5 + 2 \u003c 0x3c) {\n      if ((\u0026DAT_0800a90a)[uVar5] \u003d\u003d NC) {\n        bVar2 \u003d false;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90a)[uVar5]);\n        if (uVar3 \u003d\u003d 0) {\n          bVar2 \u003d false;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90a)[uVar5]);\n          if (uVar3 \u003d\u003d 1) {\n            bVar2 \u003d false;\n          }\n          else if ((bVar1 \u0026 4) \u003d\u003d 0) {\n            bVar2 \u003d false;\n          }\n          else {\n            iVar4 \u003d digitalRead(uVar5 + 2);\n            if (iVar4 \u003d\u003d 0) {\n              bVar2 \u003d false;\n            }\n            else {\n              bVar2 \u003d true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (bVar2) {\n      portValue \u003d portValue | 4;\n    }\n    if (uVar5 + 3 \u003c 0x3c) {\n      if ((\u0026DAT_0800a90b)[uVar5] \u003d\u003d NC) {\n        bVar2 \u003d false;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90b)[uVar5]);\n        if (uVar3 \u003d\u003d 0) {\n          bVar2 \u003d false;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90b)[uVar5]);\n          if (uVar3 \u003d\u003d 1) {\n            bVar2 \u003d false;\n          }\n          else if ((bVar1 \u0026 8) \u003d\u003d 0) {\n            bVar2 \u003d false;\n          }\n          else {\n            iVar4 \u003d digitalRead(uVar5 + 3);\n            if (iVar4 \u003d\u003d 0) {\n              bVar2 \u003d false;\n            }\n            else {\n              bVar2 \u003d true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (bVar2) {\n      portValue \u003d portValue | 8;\n    }\n    if (uVar5 + 4 \u003c 0x3c) {\n      if ((\u0026DAT_0800a90c)[uVar5] \u003d\u003d NC) {\n        bVar2 \u003d false;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90c)[uVar5]);\n        if (uVar3 \u003d\u003d 0) {\n          bVar2 \u003d false;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90c)[uVar5]);\n          if (uVar3 \u003d\u003d 1) {\n            bVar2 \u003d false;\n          }\n          else if ((bVar1 \u0026 0x10) \u003d\u003d 0) {\n            bVar2 \u003d false;\n          }\n          else {\n            iVar4 \u003d digitalRead(uVar5 + 4);\n            if (iVar4 \u003d\u003d 0) {\n              bVar2 \u003d false;\n            }\n            else {\n              bVar2 \u003d true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (bVar2) {\n      portValue \u003d portValue | 0x10;\n    }\n    if (uVar5 + 5 \u003c 0x3c) {\n      if ((\u0026DAT_0800a90d)[uVar5] \u003d\u003d NC) {\n        bVar2 \u003d false;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90d)[uVar5]);\n        if (uVar3 \u003d\u003d 0) {\n          bVar2 \u003d false;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90d)[uVar5]);\n          if (uVar3 \u003d\u003d 1) {\n            bVar2 \u003d false;\n          }\n          else if ((bVar1 \u0026 0x20) \u003d\u003d 0) {\n            bVar2 \u003d false;\n          }\n          else {\n            iVar4 \u003d digitalRead(uVar5 + 5);\n            if (iVar4 \u003d\u003d 0) {\n              bVar2 \u003d false;\n            }\n            else {\n              bVar2 \u003d true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (bVar2) {\n      portValue \u003d portValue | 0x20;\n    }\n    if (uVar5 + 6 \u003c 0x3c) {\n      if ((\u0026DAT_0800a90e)[uVar5] \u003d\u003d NC) {\n        bVar2 \u003d false;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90e)[uVar5]);\n        if (uVar3 \u003d\u003d 0) {\n          bVar2 \u003d false;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90e)[uVar5]);\n          if (uVar3 \u003d\u003d 1) {\n            bVar2 \u003d false;\n          }\n          else if ((bVar1 \u0026 0x40) \u003d\u003d 0) {\n            bVar2 \u003d false;\n          }\n          else {\n            iVar4 \u003d digitalRead(uVar5 + 6);\n            if (iVar4 \u003d\u003d 0) {\n              bVar2 \u003d false;\n            }\n            else {\n              bVar2 \u003d true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (bVar2) {\n      portValue \u003d portValue | 0x40;\n    }\n    if (uVar5 + 7 \u003c 0x3c) {\n      if ((\u0026DAT_0800a90f)[uVar5] \u003d\u003d NC) {\n        bVar2 \u003d false;\n      }\n      else {\n        uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90f)[uVar5]);\n        if (uVar3 \u003d\u003d 0) {\n          bVar2 \u003d false;\n        }\n        else {\n          uVar3 \u003d pinNametoDigitalPin((\u0026DAT_0800a90f)[uVar5]);\n          if (uVar3 \u003d\u003d 1) {\n            bVar2 \u003d false;\n          }\n          else if ((bVar1 \u0026 0x80) \u003d\u003d 0) {\n            bVar2 \u003d false;\n          }\n          else {\n            iVar4 \u003d digitalRead(uVar5 + 7);\n            if (iVar4 \u003d\u003d 0) {\n              bVar2 \u003d false;\n            }\n            else {\n              bVar2 \u003d true;\n            }\n          }\n        }\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (bVar2) {\n      portValue \u003d portValue | 0x80;\n    }\n    outputPort(port,portValue,\u0027\\x01\u0027);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "outputPort",
        "pinNametoDigitalPin",
        "digitalRead"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "checkDigitalInputs": {
      "entrypoint": "0x08000ef8",
      "current_name": "checkDigitalInputs",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08001ade) */\n/* WARNING: Removing unreachable block (ram,0x08001a4a) */\n/* WARNING: Removing unreachable block (ram,0x080019b6) */\n/* WARNING: Removing unreachable block (ram,0x08001912) */\n/* WARNING: Removing unreachable block (ram,0x08001866) */\n/* WARNING: Removing unreachable block (ram,0x080017d2) */\n/* WARNING: Removing unreachable block (ram,0x0800173e) */\n/* WARNING: Removing unreachable block (ram,0x0800169a) */\n/* WARNING: Removing unreachable block (ram,0x080015ee) */\n/* WARNING: Removing unreachable block (ram,0x0800155a) */\n/* WARNING: Removing unreachable block (ram,0x08001490) */\n/* WARNING: Removing unreachable block (ram,0x080014a2) */\n/* WARNING: Removing unreachable block (ram,0x080014e4) */\n/* WARNING: Removing unreachable block (ram,0x080014b0) */\n/* WARNING: Removing unreachable block (ram,0x080014ba) */\n/* WARNING: Removing unreachable block (ram,0x080014e8) */\n/* WARNING: Removing unreachable block (ram,0x080014c2) */\n/* WARNING: Removing unreachable block (ram,0x080014b6) */\n/* WARNING: Removing unreachable block (ram,0x08001496) */\n/* WARNING: Removing unreachable block (ram,0x08001430) */\n/* WARNING: Removing unreachable block (ram,0x08001376) */\n/* WARNING: Removing unreachable block (ram,0x080012e2) */\n/* WARNING: Removing unreachable block (ram,0x0800124e) */\n/* WARNING: Removing unreachable block (ram,0x080011b8) */\n/* WARNING: Removing unreachable block (ram,0x08001100) */\n/* WARNING: Removing unreachable block (ram,0x0800106c) */\n/* WARNING: Removing unreachable block (ram,0x08000fd8) */\n/* WARNING: Removing unreachable block (ram,0x08000f42) */\n/* WARNING: Removing unreachable block (ram,0x08000f8e) */\n/* WARNING: Removing unreachable block (ram,0x08001022) */\n/* WARNING: Removing unreachable block (ram,0x080010b6) */\n/* WARNING: Removing unreachable block (ram,0x0800114a) */\n/* WARNING: Removing unreachable block (ram,0x08001204) */\n/* WARNING: Removing unreachable block (ram,0x08001298) */\n/* WARNING: Removing unreachable block (ram,0x0800132c) */\n/* WARNING: Removing unreachable block (ram,0x080013c0) */\n/* WARNING: Removing unreachable block (ram,0x0800147c) */\n/* WARNING: Removing unreachable block (ram,0x08001510) */\n/* WARNING: Removing unreachable block (ram,0x080015a4) */\n/* WARNING: Removing unreachable block (ram,0x08001638) */\n/* WARNING: Removing unreachable block (ram,0x080016f4) */\n/* WARNING: Removing unreachable block (ram,0x08001788) */\n/* WARNING: Removing unreachable block (ram,0x0800181c) */\n/* WARNING: Removing unreachable block (ram,0x080018b0) */\n/* WARNING: Removing unreachable block (ram,0x0800196c) */\n/* WARNING: Removing unreachable block (ram,0x08001a00) */\n/* WARNING: Removing unreachable block (ram,0x08001a94) */\n/* WARNING: Removing unreachable block (ram,0x08001b28) */\n/* WARNING: Removing unreachable block (ram,0x080014ca) */\n/* WARNING: Unknown calling convention */\n\nvoid checkDigitalInputs(void)\n\n{\n  bool bVar1;\n  byte bVar2;\n  uint32_t uVar3;\n  int iVar4;\n  byte bVar5;\n  \n  bVar2 \u003d portConfigInputs[0];\n  if (reportPINs[0] !\u003d \u0027\\0\u0027) {\n    uVar3 \u003d pinNametoDigitalPin(PA_3);\n    if (uVar3 \u003d\u003d 0) {\n      bVar5 \u003d 0;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_3);\n      if (uVar3 \u003d\u003d 1) {\n        bVar5 \u003d 0;\n      }\n      else if ((bVar2 \u0026 1) \u003d\u003d 0) {\n        bVar5 \u003d 0;\n      }\n      else {\n        iVar4 \u003d digitalRead(0);\n        if (iVar4 \u003d\u003d 0) {\n          bVar5 \u003d 0;\n        }\n        else {\n          bVar5 \u003d 1;\n        }\n      }\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_2);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_2);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 2) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(1);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 2;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_10);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_10);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 4) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(2);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 4;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_3);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_3);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 8) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(3);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 8;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_5);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_5);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x10) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(4);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x10;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_4);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_4);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x20) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(5);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x20;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_10);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_10);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x40) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(6);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x40;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_8);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_8);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x80) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(7);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x80;\n    }\n    outputPort(\u0027\\0\u0027,bVar5,\u0027\\0\u0027);\n  }\n  bVar2 \u003d portConfigInputs[1];\n  if (reportPINs[1] !\u003d \u0027\\0\u0027) {\n    uVar3 \u003d pinNametoDigitalPin(PA_9);\n    if (uVar3 \u003d\u003d 0) {\n      bVar5 \u003d 0;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_9);\n      if (uVar3 \u003d\u003d 1) {\n        bVar5 \u003d 0;\n      }\n      else if ((bVar2 \u0026 1) \u003d\u003d 0) {\n        bVar5 \u003d 0;\n      }\n      else {\n        iVar4 \u003d digitalRead(8);\n        if (iVar4 \u003d\u003d 0) {\n          bVar5 \u003d 0;\n        }\n        else {\n          bVar5 \u003d 1;\n        }\n      }\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_7);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_7);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 2) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(9);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 2;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_6);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_6);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 4) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(10);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 4;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_7);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_7);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 8) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0xb);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 8;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_6);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_6);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x10) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0xc);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x10;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_5);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_5);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x20) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0xd);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x20;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_9);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_9);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x40) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0xe);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x40;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_8);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_8);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x80) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0xf);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x80;\n    }\n    outputPort(\u0027\\x01\u0027,bVar5,\u0027\\0\u0027);\n  }\n  bVar2 \u003d portConfigInputs[2];\n  if (reportPINs[2] !\u003d \u0027\\0\u0027) {\n    uVar3 \u003d pinNametoDigitalPin(PC_10);\n    if (uVar3 \u003d\u003d 0) {\n      bVar5 \u003d 0;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_10);\n      if (uVar3 \u003d\u003d 1) {\n        bVar5 \u003d 0;\n      }\n      else if ((bVar2 \u0026 1) \u003d\u003d 0) {\n        bVar5 \u003d 0;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x10);\n        if (iVar4 \u003d\u003d 0) {\n          bVar5 \u003d 0;\n        }\n        else {\n          bVar5 \u003d 1;\n        }\n      }\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_12);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_12);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 2) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x11);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 2;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_13);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_13);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 8) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x13);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 8;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_14);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_14);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x10) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x14);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x10;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_15);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_15);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x20) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x15);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x20;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_7);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_7);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x40) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x16);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x40;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_13);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_13);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x80) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x17);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x80;\n    }\n    outputPort(\u0027\\x02\u0027,bVar5,\u0027\\0\u0027);\n  }\n  bVar2 \u003d portConfigInputs[3];\n  if (reportPINs[3] !\u003d \u0027\\0\u0027) {\n    uVar3 \u003d pinNametoDigitalPin(PC_14);\n    if (uVar3 \u003d\u003d 0) {\n      bVar5 \u003d 0;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_14);\n      if (uVar3 \u003d\u003d 1) {\n        bVar5 \u003d 0;\n      }\n      else if ((bVar2 \u0026 1) \u003d\u003d 0) {\n        bVar5 \u003d 0;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x18);\n        if (iVar4 \u003d\u003d 0) {\n          bVar5 \u003d 0;\n        }\n        else {\n          bVar5 \u003d 1;\n        }\n      }\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_15);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_15);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 2) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x19);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 2;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PD_0);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PD_0);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 4) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x1a);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 4;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PD_1);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PD_1);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 8) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x1b);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 8;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_2);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_2);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x10) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x1c);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x10;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_3);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_3);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x20) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x1d);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x20;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_11);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_11);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x40) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x1e);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x40;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PD_2);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PD_2);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x80) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x1f);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x80;\n    }\n    outputPort(\u0027\\x03\u0027,bVar5,\u0027\\0\u0027);\n  }\n  bVar2 \u003d portConfigInputs[4];\n  if (reportPINs[4] !\u003d \u0027\\0\u0027) {\n    uVar3 \u003d pinNametoDigitalPin(PC_9);\n    if (uVar3 \u003d\u003d 0) {\n      bVar5 \u003d 0;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_9);\n      if (uVar3 \u003d\u003d 1) {\n        bVar5 \u003d 0;\n      }\n      else if ((bVar2 \u0026 1) \u003d\u003d 0) {\n        bVar5 \u003d 0;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x20);\n        if (iVar4 \u003d\u003d 0) {\n          bVar5 \u003d 0;\n        }\n        else {\n          bVar5 \u003d 1;\n        }\n      }\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_8);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_8);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 2) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x21);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 2;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_6);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_6);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 4) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x22);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 4;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PC_5);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PC_5);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 8) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x23);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 8;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_12);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_12);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x10) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x24);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x10;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PA_11);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PA_11);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x20) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x25);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x20;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_12);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_12);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x40) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x26);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x40;\n    }\n    uVar3 \u003d pinNametoDigitalPin(PB_11);\n    if (uVar3 \u003d\u003d 0) {\n      bVar1 \u003d false;\n    }\n    else {\n      uVar3 \u003d pinNametoDigitalPin(PB_11);\n      if (uVar3 \u003d\u003d 1) {\n        bVar1 \u003d false;\n      }\n      else if ((bVar2 \u0026 0x80) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        iVar4 \u003d digitalRead(0x27);\n        if (iVar4 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          bVar1 \u003d true;\n        }\n      }\n    }\n    if (bVar1) {\n      bVar5 \u003d bVar5 | 0x80;\n    }\n    outputPort(\u0027\\x04\u0027,bVar5,\u0027\\0\u0027);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "outputPort",
        "pinNametoDigitalPin",
        "digitalRead"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setup": {
      "entrypoint": "0x08001b48",
      "current_name": "setup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setup(void)\n\n{\n  firmata::FirmataClass::setFirmwareNameAndVersion\n            (\u0026Firmata,\"/home/bo/p2im/p2im-real_firmware_scratch/Gateway/StandardFirmata.ino\",\u0027\\x02\u0027,\n             \u0027\\x05\u0027);\n  firmata::FirmataClass::attach(\u0026Firmata,0xe0,analogWriteCallback + 1);\n  firmata::FirmataClass::attach(\u0026Firmata,0x90,digitalWriteCallback + 1);\n  firmata::FirmataClass::attach(\u0026Firmata,0xc0,reportAnalogCallback + 1);\n  firmata::FirmataClass::attach(\u0026Firmata,0xd0,reportDigitalCallback + 1);\n  firmata::FirmataClass::attach(\u0026Firmata,0xf4,setPinModeCallback + 1);\n  firmata::FirmataClass::attach(\u0026Firmata,0xf5,setPinValueCallback + 1);\n  firmata::FirmataClass::attach(\u0026Firmata,0xf0,sysexCallback + 1);\n  firmata::FirmataClass::attach(\u0026Firmata,0xff,systemResetCallback);\n  firmata::FirmataClass::begin(\u0026Firmata,0xe100);\n  systemResetCallback();\n  startForkserver(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "attach",
        "begin",
        "setFirmwareNameAndVersion",
        "startForkserver",
        "attach",
        "attach",
        "systemResetCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_analogInputsToReport": {
      "entrypoint": "0x08001be8",
      "current_name": "_GLOBAL__sub_I_analogInputsToReport",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I_analogInputsToReport(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "wireWrite": {
      "entrypoint": "0x08001bf8",
      "current_name": "wireWrite",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid wireWrite(byte data)\n\n{\n  void *in_r2;\n  size_t in_r3;\n  \n  TwoWire::write(\u0026Wire,(uint)data,in_r2,in_r3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "readAndReportData",
        "sysexCallback"
      ],
      "called": [
        "write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "wireRead": {
      "entrypoint": "0x08001c08",
      "current_name": "wireRead",
      "code": "\n/* WARNING: Unknown calling convention */\n\nbyte wireRead(void)\n\n{\n  ssize_t sVar1;\n  int in_r1;\n  void *in_r2;\n  size_t in_r3;\n  \n  sVar1 \u003d TwoWire::read(\u0026Wire,in_r1,in_r2,in_r3);\n  return (byte)sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "readAndReportData"
      ],
      "called": [
        "read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "readAndReportData": {
      "entrypoint": "0x08001c18",
      "current_name": "readAndReportData",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid readAndReportData(byte address,int theRegister,byte numBytes,byte stopTX)\n\n{\n  bool bVar1;\n  byte bVar2;\n  int iVar3;\n  int iVar4;\n  uint uVar5;\n  \n  uVar5 \u003d (uint)numBytes;\n  if (theRegister \u003d\u003d -1) {\n    theRegister \u003d 0;\n  }\n  else {\n    TwoWire::beginTransmission(\u0026Wire,address);\n    wireWrite((byte)theRegister);\n    TwoWire::endTransmission(\u0026Wire,stopTX);\n  }\n  TwoWire::requestFrom(\u0026Wire,address,numBytes);\n  iVar3 \u003d TwoWire::available(\u0026Wire);\n  if ((int)uVar5 \u003c iVar3) {\n    firmata::FirmataClass::sendString(\u0026Firmata,\"I2C: Too many bytes received\");\n  }\n  else {\n    iVar3 \u003d TwoWire::available(\u0026Wire);\n    if (iVar3 \u003c (int)uVar5) {\n      firmata::FirmataClass::sendString(\u0026Firmata,\"I2C: Too few bytes received\");\n    }\n  }\n  i2cRxData[1] \u003d (byte)theRegister;\n  iVar3 \u003d 0;\n  i2cRxData[0] \u003d address;\n  while( true ) {\n    if (iVar3 \u003c (int)uVar5) {\n      iVar4 \u003d TwoWire::available(\u0026Wire);\n      if (iVar4 \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        bVar1 \u003d true;\n      }\n    }\n    else {\n      bVar1 \u003d false;\n    }\n    if (!bVar1) break;\n    bVar2 \u003d wireRead();\n    i2cRxData[iVar3 + 2] \u003d bVar2;\n    iVar3 \u003d iVar3 + 1;\n  }\n  firmata::FirmataClass::sendSysex(\u0026Firmata,\u0027w\u0027,numBytes + \u0027\\x02\u0027,i2cRxData);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "sysexCallback"
      ],
      "called": [
        "endTransmission",
        "available",
        "sendString",
        "sendSysex",
        "requestFrom",
        "wireWrite",
        "beginTransmission",
        "wireRead"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sysexCallback": {
      "entrypoint": "0x08001cd0",
      "current_name": "sysexCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid sysexCallback(byte command,byte argc,byte *argv)\n\n{\n  byte bVar1;\n  uint8_t address;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  byte slaveAddress;\n  byte data;\n  PinName_conflict PVar5;\n  _Bool _Var6;\n  byte bVar7;\n  uint32_t uVar8;\n  int iVar9;\n  int val;\n  byte mode;\n  byte bVar10;\n  byte stopTX;\n  byte i;\n  byte i_1;\n  undefined1 *in_r3;\n  uint uVar11;\n  uint delayTime;\n  byte pin_1;\n  undefined1 *__n;\n  size_t sVar12;\n  int maxPulse;\n  byte pin;\n  uint uVar13;\n  int minPulse;\n  int iVar14;\n  bool bVar15;\n  \n  uVar13 \u003d (uint)argc;\n  switch(command) {\n  case \u0027i\u0027:\n    firmata::FirmataClass::write(\u0026Firmata,0xf0,argv,(size_t)in_r3);\n    firmata::FirmataClass::write(\u0026Firmata,0x6a,argv,(size_t)in_r3);\n    for (uVar13 \u003d 0; uVar13 \u003c 0x3c; uVar13 \u003d uVar13 + 1 \u0026 0xff) {\n      uVar11 \u003d uVar13 - 0x2e \u0026 0xff;\n      if (uVar11 \u003c 0xe) {\n        if (uVar13 \u003c 0x3c) {\n          in_r3 \u003d \u0026digitalPin;\n          PVar5 \u003d (\u0026digitalPin)[uVar13];\n        }\n        else {\n          PVar5 \u003d NC;\n        }\n        uVar8 \u003d pinNametoDigitalPin(PVar5);\n        if (uVar8 \u003d\u003d 0) {\n          uVar11 \u003d 0x7f;\n        }\n        else {\n          if (uVar13 \u003c 0x3c) {\n            in_r3 \u003d \u0026digitalPin;\n            PVar5 \u003d (\u0026digitalPin)[uVar13];\n          }\n          else {\n            PVar5 \u003d NC;\n          }\n          uVar8 \u003d pinNametoDigitalPin(PVar5);\n          if (uVar8 \u003d\u003d 1) {\n            uVar11 \u003d 0x7f;\n          }\n        }\n      }\n      else {\n        uVar11 \u003d 0x7f;\n      }\n      firmata::FirmataClass::write(\u0026Firmata,uVar11,argv,(size_t)in_r3);\n    }\n    firmata::FirmataClass::write(\u0026Firmata,0xf7,argv,(size_t)in_r3);\n    break;\n  case \u0027k\u0027:\n    firmata::FirmataClass::write(\u0026Firmata,0xf0,argv,(size_t)in_r3);\n    firmata::FirmataClass::write(\u0026Firmata,0x6c,argv,(size_t)in_r3);\n    for (uVar13 \u003d 0; uVar13 \u003c 0x3c; uVar13 \u003d uVar13 + 1 \u0026 0xff) {\n      if (uVar13 \u003c 0x3c) {\n        if ((\u0026digitalPin)[uVar13] \u003d\u003d NC) {\n          sVar12 \u003d 0;\n        }\n        else {\n          uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n          if (uVar8 \u003d\u003d 0) {\n            sVar12 \u003d 0;\n          }\n          else {\n            uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n            if (uVar8 \u003d\u003d 1) {\n              sVar12 \u003d 0;\n            }\n            else {\n              sVar12 \u003d 1;\n            }\n          }\n        }\n      }\n      else {\n        sVar12 \u003d 0;\n      }\n      if (sVar12 !\u003d 0) {\n        firmata::FirmataClass::write(\u0026Firmata,0,argv,sVar12);\n        firmata::FirmataClass::write(\u0026Firmata,1,argv,sVar12);\n        firmata::FirmataClass::write(\u0026Firmata,0xb,argv,sVar12);\n        firmata::FirmataClass::write(\u0026Firmata,1,argv,sVar12);\n        firmata::FirmataClass::write(\u0026Firmata,1,argv,sVar12);\n        firmata::FirmataClass::write(\u0026Firmata,1,argv,sVar12);\n      }\n      if ((uVar13 - 0x2e \u0026 0xff) \u003c 0xe) {\n        if (uVar13 \u003c 0x3c) {\n          PVar5 \u003d (\u0026digitalPin)[uVar13];\n        }\n        else {\n          PVar5 \u003d NC;\n        }\n        uVar8 \u003d pinNametoDigitalPin(PVar5);\n        if (uVar8 \u003d\u003d 0) {\n          __n \u003d (undefined1 *)0x0;\n        }\n        else {\n          if (uVar13 \u003c 0x3c) {\n            PVar5 \u003d (\u0026digitalPin)[uVar13];\n          }\n          else {\n            PVar5 \u003d NC;\n          }\n          uVar8 \u003d pinNametoDigitalPin(PVar5);\n          if (uVar8 \u003d\u003d 1) {\n            __n \u003d (undefined1 *)0x0;\n          }\n          else {\n            __n \u003d (undefined1 *)0x1;\n          }\n        }\n      }\n      else {\n        __n \u003d (undefined1 *)0x0;\n      }\n      if (__n !\u003d (undefined1 *)0x0) {\n        firmata::FirmataClass::write(\u0026Firmata,2,argv,(size_t)__n);\n        firmata::FirmataClass::write(\u0026Firmata,10,argv,(size_t)__n);\n      }\n      if (uVar13 \u003c 0x3c) {\n        __n \u003d \u0026digitalPin;\n        if ((\u0026digitalPin)[uVar13] \u003d\u003d NC) {\n          _Var6 \u003d false;\n        }\n        else {\n          uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n          if (uVar8 \u003d\u003d 0) {\n            _Var6 \u003d false;\n          }\n          else {\n            __n \u003d \u0026digitalPin;\n            uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n            if (uVar8 \u003d\u003d 1) {\n              _Var6 \u003d false;\n            }\n            else {\n              __n \u003d \u0026digitalPin;\n              _Var6 \u003d pin_in_pinmap((\u0026digitalPin)[uVar13],(PinMap_conflict *)\u0026PinMap_PWM);\n            }\n          }\n        }\n      }\n      else {\n        _Var6 \u003d false;\n      }\n      if (_Var6 !\u003d false) {\n        firmata::FirmataClass::write(\u0026Firmata,3,argv,(size_t)__n);\n        firmata::FirmataClass::write(\u0026Firmata,8,argv,(size_t)__n);\n      }\n      if (uVar13 \u003c 0x3c) {\n        if ((\u0026digitalPin)[uVar13] \u003d\u003d NC) {\n          sVar12 \u003d 0;\n        }\n        else {\n          uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n          if (uVar8 \u003d\u003d 0) {\n            sVar12 \u003d 0;\n          }\n          else {\n            uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n            if (uVar8 \u003d\u003d 1) {\n              sVar12 \u003d 0;\n            }\n            else {\n              sVar12 \u003d 1;\n            }\n          }\n        }\n      }\n      else {\n        sVar12 \u003d 0;\n      }\n      if (sVar12 !\u003d 0) {\n        firmata::FirmataClass::write(\u0026Firmata,4,argv,sVar12);\n        firmata::FirmataClass::write(\u0026Firmata,0xe,argv,sVar12);\n      }\n      if (uVar13 \u003c 0x3c) {\n        if ((\u0026digitalPin)[uVar13] \u003d\u003d NC) {\n          in_r3 \u003d (undefined1 *)0x0;\n        }\n        else {\n          uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n          if (uVar8 \u003d\u003d 0) {\n            in_r3 \u003d (undefined1 *)0x0;\n          }\n          else {\n            uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n            if (uVar8 \u003d\u003d 1) {\n              in_r3 \u003d (undefined1 *)0x0;\n            }\n            else {\n              _Var6 \u003d pin_in_pinmap((\u0026digitalPin)[uVar13],(PinMap_conflict *)\u0026PinMap_I2C_SDA);\n              in_r3 \u003d (undefined1 *)(uint)_Var6;\n              if (in_r3 \u003d\u003d (undefined1 *)0x0) {\n                _Var6 \u003d pin_in_pinmap((\u0026digitalPin)[uVar13],(PinMap_conflict *)\u0026PinMap_I2C_SCL);\n                in_r3 \u003d (undefined1 *)(uint)_Var6;\n              }\n            }\n          }\n        }\n      }\n      else {\n        in_r3 \u003d (undefined1 *)0x0;\n      }\n      if (in_r3 !\u003d (undefined1 *)0x0) {\n        firmata::FirmataClass::write(\u0026Firmata,6,argv,(size_t)in_r3);\n        firmata::FirmataClass::write(\u0026Firmata,1,argv,(size_t)in_r3);\n      }\n      firmata::FirmataClass::write(\u0026Firmata,0x7f,argv,(size_t)in_r3);\n    }\n    firmata::FirmataClass::write(\u0026Firmata,0xf7,argv,(size_t)in_r3);\n    return;\n  case \u0027m\u0027:\n    if (uVar13 !\u003d 0) {\n      bVar1 \u003d *argv;\n      firmata::FirmataClass::write(\u0026Firmata,0xf0,argv,(size_t)in_r3);\n      firmata::FirmataClass::write(\u0026Firmata,0x6e,argv,(size_t)in_r3);\n      firmata::FirmataClass::write(\u0026Firmata,(uint)bVar1,argv,(size_t)in_r3);\n      if (bVar1 \u003c 0x3c) {\n        bVar7 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,bVar1);\n        firmata::FirmataClass::write(\u0026Firmata,(uint)bVar7,argv,(size_t)in_r3);\n        uVar13 \u003d firmata::FirmataClass::getPinState(\u0026Firmata,bVar1);\n        firmata::FirmataClass::write(\u0026Firmata,uVar13 \u0026 0x7f,argv,(size_t)in_r3);\n        uVar13 \u003d firmata::FirmataClass::getPinState(\u0026Firmata,bVar1);\n        in_r3 \u003d (undefined1 *)0xff80;\n        if ((uVar13 \u0026 0xff80) !\u003d 0) {\n          iVar9 \u003d firmata::FirmataClass::getPinState(\u0026Firmata,bVar1);\n          firmata::FirmataClass::write(\u0026Firmata,(uint)(iVar9 \u003c\u003c 0x12) \u003e\u003e 0x19,argv,(size_t)in_r3);\n        }\n        uVar13 \u003d firmata::FirmataClass::getPinState(\u0026Firmata,bVar1);\n        if ((uVar13 \u0026 0xc000) !\u003d 0) {\n          iVar9 \u003d firmata::FirmataClass::getPinState(\u0026Firmata,bVar1);\n          firmata::FirmataClass::write(\u0026Firmata,(uint)(iVar9 \u003c\u003c 0xb) \u003e\u003e 0x19,argv,(size_t)in_r3);\n        }\n      }\n      firmata::FirmataClass::write(\u0026Firmata,0xf7,argv,(size_t)in_r3);\n      return;\n    }\n    break;\n  case \u0027o\u0027:\n    if (1 \u003c uVar13) {\n      uVar11 \u003d (uint)argv[1];\n      if (2 \u003c uVar13) {\n        uVar11 \u003d uVar11 | (uint)argv[2] \u003c\u003c 7;\n      }\n      if (3 \u003c uVar13) {\n        uVar11 \u003d uVar11 | (uint)argv[3] \u003c\u003c 0xe;\n      }\n      analogWriteCallback(*argv,uVar11);\n      return;\n    }\n    break;\n  case \u0027p\u0027:\n    if (4 \u003c uVar13) {\n      bVar1 \u003d *argv;\n      uVar13 \u003d (uint)bVar1;\n      bVar7 \u003d argv[1];\n      bVar2 \u003d argv[2];\n      bVar3 \u003d argv[3];\n      bVar4 \u003d argv[4];\n      if (uVar13 \u003c 0x3c) {\n        if ((\u0026digitalPin)[uVar13] \u003d\u003d NC) {\n          bVar15 \u003d false;\n        }\n        else {\n          uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n          if (uVar8 \u003d\u003d 0) {\n            bVar15 \u003d false;\n          }\n          else {\n            uVar8 \u003d pinNametoDigitalPin((\u0026digitalPin)[uVar13]);\n            if (uVar8 \u003d\u003d 1) {\n              bVar15 \u003d false;\n            }\n            else {\n              bVar15 \u003d true;\n            }\n          }\n        }\n      }\n      else {\n        bVar15 \u003d false;\n      }\n      if (bVar15) {\n        if (servoPinMap[uVar13] \u003c 0xc) {\n          bVar15 \u003d Servo::attached(servos + servoPinMap[uVar13]);\n        }\n        else {\n          bVar15 \u003d false;\n        }\n        if (bVar15 !\u003d false) {\n          detachServo(bVar1);\n        }\n        attachServo(bVar1,(uint)bVar7 + (uint)bVar2 * 0x80,(uint)bVar3 + (uint)bVar4 * 0x80);\n        setPinModeCallback(bVar1,4);\n        return;\n      }\n    }\n    break;\n  case \u0027v\u0027:\n    bVar1 \u003d argv[1];\n    if ((bVar1 \u0026 0x20) !\u003d 0) {\n      firmata::FirmataClass::sendString(\u0026Firmata,\"10-bit addressing not supported\");\n      return;\n    }\n    address \u003d *argv;\n    bVar15 \u003d (bVar1 \u0026 0x40) \u003d\u003d 0;\n    if ((bVar1 \u0026 0x18) \u003c 0x19) {\n      switch(bVar1 \u0026 0x18) {\n      case 0:\n        TwoWire::beginTransmission(\u0026Wire,address);\n        for (uVar11 \u003d 2; uVar11 \u003c uVar13; uVar11 \u003d uVar11 + 2 \u0026 0xff) {\n          wireWrite(argv[uVar11 + 1] * -0x80 + argv[uVar11]);\n        }\n        TwoWire::endTransmission(\u0026Wire);\n        return;\n      case 8:\n        if (uVar13 \u003d\u003d 6) {\n          iVar9 \u003d (uint)argv[2] + (uint)argv[3] * 0x80;\n          bVar10 \u003d argv[4] + argv[5] * -0x80;\n        }\n        else {\n          bVar10 \u003d argv[2] + argv[3] * -0x80;\n          iVar9 \u003d -1;\n        }\n        readAndReportData(address,iVar9,bVar10,bVar15);\n        return;\n      case 0x10:\n        if (queryIndex + 1 \u003c 8) {\n          if (uVar13 \u003d\u003d 6) {\n            iVar9 \u003d (uint)argv[2] + (uint)argv[3] * 0x80;\n            bVar10 \u003d argv[4] + argv[5] * -0x80;\n          }\n          else {\n            bVar10 \u003d argv[2] + argv[3] * -0x80;\n            iVar9 \u003d -1;\n          }\n          queryIndex \u003d queryIndex + \u0027\\x01\u0027;\n          iVar14 \u003d (int)queryIndex;\n          query[iVar14].addr \u003d address;\n          query[iVar14].reg \u003d iVar9;\n          query[iVar14].bytes \u003d bVar10;\n          *(bool *)(iVar14 * 0xc + 0x20000191) \u003d bVar15;\n          return;\n        }\n        firmata::FirmataClass::sendString(\u0026Firmata,\"too many queries\");\n        return;\n      case 0x18:\n        if (queryIndex \u003c 1) {\n          queryIndex \u003d -1;\n          return;\n        }\n      }\n      for (uVar13 \u003d 0; iVar9 \u003d queryIndex + 1, (int)uVar13 \u003c iVar9; uVar13 \u003d uVar13 + 1 \u0026 0xff) {\n        if (address \u003d\u003d query[uVar13].addr) goto LAB_08001e66;\n      }\n      uVar13 \u003d 0;\nLAB_08001e66:\n      for (; (int)uVar13 \u003c iVar9; uVar13 \u003d uVar13 + 1 \u0026 0xff) {\n        if (uVar13 \u003c 8) {\n          iVar14 \u003d uVar13 + 1;\n          query[uVar13].addr \u003d query[iVar14].addr;\n          query[uVar13].reg \u003d query[iVar14].reg;\n          query[uVar13].bytes \u003d query[iVar14].bytes;\n          query[uVar13].stopTX \u003d query[iVar14].stopTX;\n        }\n      }\n      queryIndex \u003d queryIndex + -1;\n      return;\n    }\n    break;\n  case \u0027x\u0027:\n    uVar11 \u003d (uint)*argv + (uint)argv[1] * 0x80;\n    if ((1 \u003c uVar13) \u0026\u0026 (uVar11 !\u003d 0)) {\n      i2cReadDelayTime \u003d uVar11;\n    }\n    if (!isI2CEnabled) {\n      enableI2CPins();\n      return;\n    }\n    break;\n  case \u0027z\u0027:\n    if ((1 \u003c uVar13) \u0026\u0026\n       (samplingInterval \u003d (uint)*argv + (uint)argv[1] * 0x80, samplingInterval \u003d\u003d 0)) {\n      samplingInterval \u003d 1;\n      return;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "getPinState",
        "pinNametoDigitalPin",
        "setPinModeCallback",
        "attachServo",
        "pin_in_pinmap",
        "endTransmission",
        "wireWrite",
        "readAndReportData",
        "enableI2CPins",
        "sendString",
        "detachServo",
        "beginTransmission",
        "write",
        "getPinMode",
        "analogWriteCallback",
        "attached"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "loop": {
      "entrypoint": "0x080022f8",
      "current_name": "loop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid loop(void)\n\n{\n  bool bVar1;\n  PinName_conflict PVar2;\n  byte bVar3;\n  int iVar4;\n  uint32_t uVar5;\n  byte i;\n  uint uVar6;\n  byte analogPin;\n  uint ulPin;\n  \n  checkDigitalInputs();\n  while (iVar4 \u003d firmata::FirmataClass::available(\u0026Firmata), iVar4 !\u003d 0) {\n    firmata::FirmataClass::processInput(\u0026Firmata);\n  }\n  currentMillis \u003d millis();\n  if (samplingInterval \u003c currentMillis - previousMillis) {\n    previousMillis \u003d previousMillis + samplingInterval;\n    for (uVar6 \u003d 0; uVar6 \u003c 0x3c; uVar6 \u003d uVar6 + 1 \u0026 0xff) {\n      ulPin \u003d uVar6 - 0x2e \u0026 0xff;\n      if (ulPin \u003c 0xe) {\n        if (uVar6 \u003c 0x3c) {\n          PVar2 \u003d (\u0026digitalPin)[uVar6];\n        }\n        else {\n          PVar2 \u003d NC;\n        }\n        uVar5 \u003d pinNametoDigitalPin(PVar2);\n        if (uVar5 \u003d\u003d 0) {\n          bVar1 \u003d false;\n        }\n        else {\n          if (uVar6 \u003c 0x3c) {\n            PVar2 \u003d (\u0026digitalPin)[uVar6];\n          }\n          else {\n            PVar2 \u003d NC;\n          }\n          uVar5 \u003d pinNametoDigitalPin(PVar2);\n          if (uVar5 \u003d\u003d 1) {\n            bVar1 \u003d false;\n          }\n          else {\n            bVar3 \u003d firmata::FirmataClass::getPinMode(\u0026Firmata,(byte)uVar6);\n            if (bVar3 \u003d\u003d \u0027\\x02\u0027) {\n              bVar1 \u003d true;\n            }\n            else {\n              bVar1 \u003d false;\n            }\n          }\n        }\n      }\n      else {\n        bVar1 \u003d false;\n      }\n      if ((bVar1) \u0026\u0026 ((analogInputsToReport \u003e\u003e ulPin \u0026 1U) !\u003d 0)) {\n        uVar5 \u003d analogRead(ulPin);\n        firmata::FirmataClass::sendAnalog(\u0026Firmata,(byte)ulPin,uVar5);\n      }\n    }\n    if (-1 \u003c queryIndex) {\n      for (uVar6 \u003d 0; (int)uVar6 \u003c queryIndex + 1; uVar6 \u003d uVar6 + 1 \u0026 0xff) {\n        readAndReportData(query[uVar6].addr,query[uVar6].reg,query[uVar6].bytes,query[uVar6].stopTX)\n        ;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "sendAnalog",
        "checkDigitalInputs",
        "millis",
        "pinNametoDigitalPin",
        "analogRead",
        "available",
        "processInput",
        "readAndReportData",
        "getPinMode"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isTimerActive": {
      "entrypoint": "0x08002400",
      "current_name": "isTimerActive",
      "code": "\n/* WARNING: Unknown calling convention */\n\nboolean isTimerActive(timer16_Sequence_t timer)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d 0;\n  while( true ) {\n    if (0xb \u003c uVar1) {\n      return false;\n    }\n    if (((byte)servos[(uint)timer * 0xc + uVar1].Pin \u0026 0x40) !\u003d 0) break;\n    uVar1 \u003d uVar1 + 1 \u0026 0xff;\n  }\n  return true;\n}\n\n",
      "renaming": {},
      "calling": [
        "detach",
        "attach"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "initISR": {
      "entrypoint": "0x0800242c",
      "current_name": "initISR",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initISR(stimer_t *obj)\n\n{\n  TimerPulseInit((stimer_t_conflict *)obj,60000,0x5dc,ServoIrqHandle + 1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "attach"
      ],
      "called": [
        "TimerPulseInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ServoIrqHandle": {
      "entrypoint": "0x08002444",
      "current_name": "ServoIrqHandle",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid ServoIrqHandle(stimer_t *obj,uint32_t channel)\n\n{\n  bool bVar1;\n  uint32_t uVar2;\n  int iVar3;\n  uint uVar4;\n  \n  uVar4 \u003d (uint)obj-\u003eidx;\n  if ((timerChannel[uVar4] \u0026 0x80U) \u003d\u003d 0) {\n    iVar3 \u003d uVar4 * 0xc;\n    if (timerChannel[uVar4] + iVar3 \u003c (int)(uint)ServoCount) {\n      if (((byte)servos[timerChannel[uVar4] + iVar3].Pin \u0026 0x40) \u003d\u003d 0) {\n        bVar1 \u003d false;\n      }\n      else {\n        bVar1 \u003d true;\n      }\n    }\n    else {\n      bVar1 \u003d false;\n    }\n    if (bVar1) {\n      digitalWrite((byte)servos[iVar3 + timerChannel[uVar4]].Pin \u0026 0x3f,0);\n    }\n  }\n  else {\n    setTimerCounter((stimer_t_conflict *)obj,0);\n  }\n  timerChannel[uVar4] \u003d timerChannel[uVar4] + \u0027\\x01\u0027;\n  iVar3 \u003d uVar4 * 0xc;\n  if (timerChannel[uVar4] + iVar3 \u003c (int)(uint)ServoCount) {\n    if (timerChannel[uVar4] \u003c \u0027\\f\u0027) {\n      bVar1 \u003d true;\n    }\n    else {\n      bVar1 \u003d false;\n    }\n  }\n  else {\n    bVar1 \u003d false;\n  }\n  if (bVar1) {\n    if (((byte)servos[timerChannel[uVar4] + iVar3].Pin \u0026 0x40) !\u003d 0) {\n      digitalWrite((byte)servos[timerChannel[uVar4] + iVar3].Pin \u0026 0x3f,1);\n    }\n    uVar2 \u003d getTimerCounter((stimer_t_conflict *)obj);\n    setCCRRegister((stimer_t_conflict *)obj,channel,\n                   servos[iVar3 + timerChannel[uVar4]].ticks + uVar2);\n    return;\n  }\n  uVar2 \u003d getTimerCounter((stimer_t_conflict *)obj);\n  if (uVar2 + 4 \u003c 20000) {\n    setCCRRegister((stimer_t_conflict *)obj,channel,20000);\n  }\n  else {\n    uVar2 \u003d getTimerCounter((stimer_t_conflict *)obj);\n    setCCRRegister((stimer_t_conflict *)obj,channel,uVar2 + 4);\n  }\n  timerChannel[uVar4] \u003d -1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "setCCRRegister",
        "getTimerCounter",
        "setTimerCounter",
        "digitalWrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "finISR": {
      "entrypoint": "0x08002578",
      "current_name": "finISR",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid finISR(stimer_t *obj)\n\n{\n  TimerPulseDeinit((stimer_t_conflict *)obj);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "detach"
      ],
      "called": [
        "TimerPulseDeinit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Servo": {
      "entrypoint": "0x08002580",
      "current_name": "Servo",
      "code": "\n/* DWARF original prototype: Servo *  Servo(Servo * this) */\n\nServo * __thiscall Servo::Servo(Servo *this)\n\n{\n  uint8_t uVar1;\n  uint uVar2;\n  \n  uVar2 \u003d (uint)ServoCount;\n  if (0xb \u003c uVar2) {\n    this-\u003eservoIndex \u003d 0xff;\n    return this;\n  }\n  uVar1 \u003d ServoCount + \u0027\\x01\u0027;\n  this-\u003eservoIndex \u003d ServoCount;\n  ServoCount \u003d uVar1;\n  servos[uVar2].ticks \u003d 0x5dc;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "attach": {
      "entrypoint": "0x08003370",
      "current_name": "attach",
      "code": "\n/* DWARF original prototype: void  attach(FirmataParser * this, uint8_t command,\n   sysexCallbackFunction newFunction, void * context) */\n\nvoid __thiscall\nfirmata::FirmataParser::attach\n          (FirmataParser *this,uint8_t command,sysexCallbackFunction newFunction,void *context)\n\n{\n  this-\u003ecurrentSysexCallback \u003d newFunction;\n  this-\u003ecurrentSysexCallbackContext \u003d context;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FirmataClass"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "detach": {
      "entrypoint": "0x08002644",
      "current_name": "detach",
      "code": "\n/* DWARF original prototype: void  detach(Servo * this) */\n\nvoid __thiscall Servo::detach(Servo *this)\n\n{\n  byte bVar1;\n  boolean bVar2;\n  \n  bVar1 \u003d this-\u003eservoIndex;\n  servos[bVar1].Pin \u003d (ServoPin_t)((byte)servos[bVar1].Pin \u0026 0xbf);\n  bVar2 \u003d isTimerActive(bVar1 / 0xc);\n  if (!bVar2) {\n    finISR(\u0026_timer);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "detachServo"
      ],
      "called": [
        "isTimerActive",
        "finISR"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "writeMicroseconds": {
      "entrypoint": "0x0800267c",
      "current_name": "writeMicroseconds",
      "code": "\n/* DWARF original prototype: void  writeMicroseconds(Servo * this, int value) */\n\nvoid __thiscall Servo::writeMicroseconds(Servo *this,int value)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  if (this-\u003eservoIndex \u003c 0xc) {\n    uVar1 \u003d (0x88 - this-\u003emin) * 4;\n    if ((uVar1 - value \u003d\u003d 0 || (int)uVar1 \u003c value) \u0026\u0026\n       (iVar2 \u003d 600 - this-\u003emax, uVar1 \u003d iVar2 * 4,\n       value \u003d\u003d uVar1 || value + iVar2 * -4 \u003c 0 !\u003d SBORROW4(value,uVar1))) {\n      uVar1 \u003d value;\n    }\n    servos[this-\u003eservoIndex].ticks \u003d uVar1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write": {
      "entrypoint": "0x08008e4e",
      "current_name": "write",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008e62 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t __thiscall Print::write(Print *this,int __fd,void *__buf,size_t __n)\n\n{\n  Print *pPVar1;\n  int iVar2;\n  \n  iVar2 \u003d 0;\n  pPVar1 \u003d this;\n  while( true ) {\n    if (__buf \u003d\u003d (void *)0x0) {\n      return iVar2;\n    }\n    pPVar1 \u003d (Print *)(**this-\u003e_vptr_Print)(pPVar1,(uint)*(byte *)__fd,__buf,*this-\u003e_vptr_Print,__n)\n    ;\n    if (pPVar1 \u003d\u003d (Print *)0x0) break;\n    iVar2 \u003d iVar2 + 1;\n    __fd \u003d (int)(__fd + 1);\n    __buf \u003d (void *)((int)__buf + -1);\n  }\n  return iVar2;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "attached": {
      "entrypoint": "0x080026f8",
      "current_name": "attached",
      "code": "\n/* DWARF original prototype: bool  attached(Servo * this) */\n\nbool __thiscall Servo::attached(Servo *this)\n\n{\n  return SUB41(((uint)(byte)servos[this-\u003eservoIndex].Pin \u003c\u003c 0x19) \u003e\u003e 0x1f,0);\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback",
        "sysexCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "available": {
      "entrypoint": "0x08008afa",
      "current_name": "available",
      "code": "\n/* DWARF original prototype: int  available(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::available(HardwareSerial *this)\n\n{\n  return ((this-\u003e_serial).rx_head + 0x40) - (uint)(this-\u003e_serial).rx_tail \u0026 0x3f;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read": {
      "entrypoint": "0x08008b2a",
      "current_name": "read",
      "code": "\n/* DWARF original prototype: int  read(HardwareSerial * this) */\n\nssize_t __thiscall HardwareSerial::read(HardwareSerial *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  uchar c;\n  \n  uVar2 \u003d (this-\u003e_serial).rx_tail;\n  if ((uint)(this-\u003e_serial).rx_head !\u003d (uint)uVar2) {\n    bVar1 \u003d (this-\u003e_serial).rx_buff[uVar2];\n    (this-\u003e_serial).rx_tail \u003d uVar2 + 1 \u0026 0x3f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "peek": {
      "entrypoint": "0x08008b0e",
      "current_name": "peek",
      "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::peek(HardwareSerial *this)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)(this-\u003e_serial).rx_tail;\n  if ((this-\u003e_serial).rx_head !\u003d uVar1) {\n    return (uint)(this-\u003e_serial).rx_buff[uVar1];\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "onRequestService": {
      "entrypoint": "0x08002774",
      "current_name": "onRequestService",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::onRequestService(void)\n\n{\n  if (user_onRequest !\u003d (_func_void *)0x0) {\n    txBufferIndex \u003d \u0027\\0\u0027;\n    txBufferLength \u003d \u0027\\0\u0027;\n    (*user_onRequest)();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "flush": {
      "entrypoint": "0x08008b52",
      "current_name": "flush",
      "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * this) */\n\nvoid __thiscall HardwareSerial::flush(HardwareSerial *this)\n\n{\n  if (this-\u003e_written !\u003d false) {\n    do {\n    } while ((this-\u003e_serial).tx_head !\u003d (this-\u003e_serial).tx_tail);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TwoWire": {
      "entrypoint": "0x0800291c",
      "current_name": "TwoWire",
      "code": "\n/* DWARF original prototype: TwoWire *  TwoWire(TwoWire * this) */\n\nTwoWire * __thiscall TwoWire::TwoWire(TwoWire *this)\n\n{\n  (this-\u003esuper_Stream).super_Print.write_error \u003d 0;\n  (this-\u003esuper_Stream)._timeout \u003d 1000;\n  (this-\u003esuper_Stream).super_Print._vptr_Print \u003d (_func_int_varargs **)\u0026PTR_write_1_0800a5a0;\n  (this-\u003e_i2c).sda \u003d PB_9;\n  (this-\u003e_i2c).scl \u003d PB_8;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "begin": {
      "entrypoint": "0x08008c44",
      "current_name": "begin",
      "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * this, ulong baud, byte config) */\n\nvoid __thiscall HardwareSerial::begin(HardwareSerial *this,ulong baud,byte config)\n\n{\n  byte bVar1;\n  int iVar2;\n  \n  (this-\u003e_serial).baudrate \u003d baud;\n  this-\u003e_config \u003d config;\n  bVar1 \u003d config \u0026 7;\n  if (bVar1 \u003d\u003d 4) {\n    iVar2 \u003d 7;\n  }\n  else if (bVar1 \u003d\u003d 6) {\n    iVar2 \u003d 8;\n  }\n  else if (bVar1 \u003d\u003d 2) {\n    iVar2 \u003d 6;\n  }\n  else {\n    iVar2 \u003d 0;\n  }\n  if ((config \u0026 0x30) \u003d\u003d 0x30) {\n    (this-\u003e_serial).parity \u003d 0x600;\n    iVar2 \u003d iVar2 + 1;\n  }\n  else if ((config \u0026 0x20) \u003d\u003d 0) {\n    (this-\u003e_serial).parity \u003d 0;\n  }\n  else {\n    (this-\u003e_serial).parity \u003d 0x400;\n    iVar2 \u003d iVar2 + 1;\n  }\n  if ((config \u0026 8) \u003d\u003d 0) {\n    (this-\u003e_serial).stopbits \u003d 0;\n  }\n  else {\n    (this-\u003e_serial).stopbits \u003d 0x2000;\n  }\n  if (iVar2 \u003d\u003d 8) {\n    (this-\u003e_serial).databits \u003d 0;\n  }\n  else if (iVar2 \u003d\u003d 9) {\n    (this-\u003e_serial).databits \u003d 0x1000;\n  }\n  else {\n    iVar2 \u003d 0;\n  }\n  if (iVar2 !\u003d 0) {\n    uart_init((serial_t *)\u0026this-\u003e_serial);\n    uart_attach_rx_callback((serial_t *)\u0026this-\u003e_serial,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!\u003d0\");\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "uart_attach_rx_callback",
        "uart_init",
        "__assert_func"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "beginTransmission": {
      "entrypoint": "0x08002a30",
      "current_name": "beginTransmission",
      "code": "\n/* DWARF original prototype: void  beginTransmission(TwoWire * this, uint8_t address) */\n\nvoid __thiscall TwoWire::beginTransmission(TwoWire *this,uint8_t address)\n\n{\n  transmitting \u003d \u0027\\x01\u0027;\n  txAddress \u003d address \u003c\u003c 1;\n  txBufferIndex \u003d \u0027\\0\u0027;\n  txBufferLength \u003d \u0027\\0\u0027;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "readAndReportData",
        "requestFrom",
        "sysexCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "endTransmission": {
      "entrypoint": "0x08002ac0",
      "current_name": "endTransmission",
      "code": "\n/* DWARF original prototype: uint8_t  endTransmission(TwoWire * this) */\n\nuint8_t __thiscall TwoWire::endTransmission(TwoWire *this)\n\n{\n  uint8_t uVar1;\n  \n  uVar1 \u003d endTransmission(this,\u0027\\x01\u0027);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "sysexCallback"
      ],
      "called": [
        "endTransmission"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "allocateRxBuffer": {
      "entrypoint": "0x08002acc",
      "current_name": "allocateRxBuffer",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::allocateRxBuffer(size_t length)\n\n{\n  if (rxBufferAllocated \u003c length) {\n    if (length \u003c 0x20) {\n      length \u003d 0x20;\n    }\n    rxBuffer \u003d (uint8_t *)realloc(rxBuffer,length);\n    if (rxBuffer \u003d\u003d (uint8_t *)0x0) {\n      rxBufferAllocated \u003d \u0027\\0\u0027;\n    }\n    else {\n      rxBufferAllocated \u003d (uint8_t)length;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "onReceiveService",
        "requestFrom"
      ],
      "called": [
        "realloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "onReceiveService": {
      "entrypoint": "0x08002b00",
      "current_name": "onReceiveService",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TwoWire::onReceiveService(uint8_t *inBytes,int numBytes)\n\n{\n  if ((user_onReceive !\u003d (_func_void_int *)0x0) \u0026\u0026 (rxBufferLength \u003c\u003d rxBufferIndex)) {\n    allocateRxBuffer(numBytes);\n    if (rxBuffer \u003d\u003d (uint8_t *)0x0) {\n      _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/libraries/Wire/src/Wire.cpp\"\n                     ,0x183);\n    }\n    memcpy(rxBuffer,inBytes,numBytes);\n    rxBufferIndex \u003d \u0027\\0\u0027;\n    rxBufferLength \u003d (uint8_t)numBytes;\n    (*user_onReceive)(numBytes);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "allocateRxBuffer",
        "memcpy",
        "_Error_Handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "requestFrom": {
      "entrypoint": "0x08002c14",
      "current_name": "requestFrom",
      "code": "\n/* DWARF original prototype: uint8_t  requestFrom(TwoWire * this, uint8_t address, uint8_t quantity)\n    */\n\nuint8_t __thiscall TwoWire::requestFrom(TwoWire *this,uint8_t address,uint8_t quantity)\n\n{\n  uint8_t uVar1;\n  \n  uVar1 \u003d requestFrom(this,address,quantity,\u0027\\x01\u0027);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "readAndReportData"
      ],
      "called": [
        "requestFrom"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE": {
      "entrypoint": "0x08002c1e",
      "current_name": "_GLOBAL__sub_I__ZN7TwoWire8rxBufferE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I__ZN7TwoWire8rxBufferE(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticAnalogCallback": {
      "entrypoint": "0x08002c2c",
      "current_name": "staticAnalogCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticAnalogCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (currentAnalogCallback !\u003d (callbackFunction)0x0) {\n    (*currentAnalogCallback)(command,(int)value);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticDigitalCallback": {
      "entrypoint": "0x08002c40",
      "current_name": "staticDigitalCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticDigitalCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (currentDigitalCallback !\u003d (callbackFunction)0x0) {\n    (*currentDigitalCallback)(command,(int)value);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticPinModeCallback": {
      "entrypoint": "0x08002c54",
      "current_name": "staticPinModeCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticPinModeCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (currentPinModeCallback !\u003d (callbackFunction)0x0) {\n    (*currentPinModeCallback)(command,(int)value);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticPinValueCallback": {
      "entrypoint": "0x08002c68",
      "current_name": "staticPinValueCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticPinValueCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (currentPinValueCallback !\u003d (callbackFunction)0x0) {\n    (*currentPinValueCallback)(command,(int)value);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticReportAnalogCallback": {
      "entrypoint": "0x08002c7c",
      "current_name": "staticReportAnalogCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticReportAnalogCallback(void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (currentReportAnalogCallback !\u003d (callbackFunction)0x0) {\n    (*currentReportAnalogCallback)(command,(int)value);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticReportDigitalCallback": {
      "entrypoint": "0x08002c90",
      "current_name": "staticReportDigitalCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticReportDigitalCallback\n               (void *param_1,uint8_t command,uint16_t value)\n\n{\n  if (currentReportDigitalCallback !\u003d (callbackFunction)0x0) {\n    (*currentReportDigitalCallback)(command,(int)value);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticStringCallback": {
      "entrypoint": "0x08002ca4",
      "current_name": "staticStringCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticStringCallback(void *param_1,char *c_str)\n\n{\n  if (currentStringCallback !\u003d (stringCallbackFunction)0x0) {\n    (*currentStringCallback)(c_str);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticSysexCallback": {
      "entrypoint": "0x08002cb8",
      "current_name": "staticSysexCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticSysexCallback\n               (void *param_1,uint8_t command,size_t argc,uint8_t *argv)\n\n{\n  if (currentSysexCallback !\u003d (sysexCallbackFunction)0x0) {\n    (*currentSysexCallback)(command,(uint8_t)argc,argv);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticSystemResetCallback": {
      "entrypoint": "0x08002cd0",
      "current_name": "staticSystemResetCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticSystemResetCallback(void *param_1)\n\n{\n  if (currentSystemResetCallback !\u003d (systemCallbackFunction)0x0) {\n    (*currentSystemResetCallback)();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FirmataClass": {
      "entrypoint": "0x08002ce0",
      "current_name": "FirmataClass",
      "code": "\n/* DWARF original prototype: FirmataClass *  FirmataClass(FirmataClass * this) */\n\nFirmataClass * __thiscall firmata::FirmataClass::FirmataClass(FirmataClass *this)\n\n{\n  FirmataParser *this_00;\n  \n  FirmataMarshaller::FirmataMarshaller(\u0026this-\u003emarshaller);\n  this_00 \u003d \u0026this-\u003eparser;\n  FirmataParser::FirmataParser(this_00,this-\u003eparserBuffer,0x40);\n  this-\u003efirmwareVersionCount \u003d \u0027\\0\u0027;\n  this-\u003efirmwareVersionVector \u003d (byte *)0x0;\n  this-\u003eblinkVersionDisabled \u003d false;\n  FirmataParser::attach(this_00,0xe0,staticAnalogCallback + 1,(void *)0x0);\n  FirmataParser::attach(this_00,0x90,staticDigitalCallback + 1,(void *)0x0);\n  FirmataParser::attach(this_00,0xc0,staticReportAnalogCallback + 1,(void *)0x0);\n  FirmataParser::attach(this_00,0xd0,staticReportDigitalCallback + 1,(void *)0x0);\n  FirmataParser::attach(this_00,0xf4,staticPinModeCallback + 1,(void *)0x0);\n  FirmataParser::attach(this_00,0xf5,staticPinValueCallback + 1,(void *)0x0);\n  FirmataParser::attach(this_00,\u0027q\u0027,staticStringCallback + 1,(void *)0x0);\n  FirmataParser::attach(this_00,0xf0,staticSysexCallback + 1,(void *)0x0);\n  FirmataParser::attach(this_00,\u0027y\u0027,staticReportFirmwareCallback + 1,this);\n  FirmataParser::attach(this_00,0xf9,staticReportVersionCallback + 1,this);\n  FirmataParser::attach(this_00,0xff,staticSystemResetCallback + 1,(void *)0x0);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "attach",
        "attach",
        "attach",
        "attach",
        "attach",
        "FirmataParser",
        "FirmataMarshaller"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printVersion": {
      "entrypoint": "0x08002ddc",
      "current_name": "printVersion",
      "code": "\n/* DWARF original prototype: void  printVersion(FirmataClass * this) */\n\nvoid __thiscall firmata::FirmataClass::printVersion(FirmataClass *this)\n\n{\n  FirmataMarshaller::sendVersion(\u0026this-\u003emarshaller,\u0027\\x02\u0027,\u0027\\x05\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin",
        "staticReportVersionCallback"
      ],
      "called": [
        "sendVersion"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticReportVersionCallback": {
      "entrypoint": "0x08002dea",
      "current_name": "staticReportVersionCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticReportVersionCallback(void *context)\n\n{\n  if (context !\u003d (void *)0x0) {\n    printVersion((FirmataClass *)context);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "printVersion"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printFirmwareVersion": {
      "entrypoint": "0x08002df6",
      "current_name": "printFirmwareVersion",
      "code": "\n/* DWARF original prototype: void  printFirmwareVersion(FirmataClass * this) */\n\nvoid __thiscall firmata::FirmataClass::printFirmwareVersion(FirmataClass *this)\n\n{\n  uint8_t *puVar1;\n  \n  if (this-\u003efirmwareVersionCount \u003d\u003d 0) {\n    return;\n  }\n  puVar1 \u003d this-\u003efirmwareVersionVector;\n  FirmataMarshaller::sendFirmwareVersion\n            (\u0026this-\u003emarshaller,*puVar1,puVar1[1],this-\u003efirmwareVersionCount - 2,puVar1 + 2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin",
        "staticReportFirmwareCallback"
      ],
      "called": [
        "sendFirmwareVersion"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "staticReportFirmwareCallback": {
      "entrypoint": "0x08002e1a",
      "current_name": "staticReportFirmwareCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid firmata::FirmataClass::staticReportFirmwareCallback\n               (void *context,size_t param_2,size_t param_3,char *param_4)\n\n{\n  if (context !\u003d (void *)0x0) {\n    printFirmwareVersion((FirmataClass *)context);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "printFirmwareVersion"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setFirmwareNameAndVersion": {
      "entrypoint": "0x08002e44",
      "current_name": "setFirmwareNameAndVersion",
      "code": "\n/* DWARF original prototype: void  setFirmwareNameAndVersion(FirmataClass * this, char * name, byte\n   major, byte minor) */\n\nvoid __thiscall\nfirmata::FirmataClass::setFirmwareNameAndVersion\n          (FirmataClass *this,char *name,byte major,byte minor)\n\n{\n  byte bVar1;\n  char *pcVar2;\n  char *extension;\n  char *pcVar3;\n  char *firmwareName;\n  byte *pbVar4;\n  size_t sVar5;\n  \n  pcVar2 \u003d strstr(name,\".cpp\");\n  pcVar3 \u003d strrchr(name,0x2f);\n  if (pcVar3 \u003d\u003d (char *)0x0) {\n    pcVar3 \u003d strrchr(name,0x5c);\n  }\n  if (pcVar3 !\u003d (char *)0x0) {\n    name \u003d pcVar3 + 1;\n  }\n  if (pcVar2 \u003d\u003d (char *)0x0) {\n    sVar5 \u003d strlen(name);\n    this-\u003efirmwareVersionCount \u003d (char)sVar5 + \u0027\\x02\u0027;\n  }\n  else {\n    this-\u003efirmwareVersionCount \u003d ((char)pcVar2 - (char)name) + \u0027\\x02\u0027;\n  }\n  free(this-\u003efirmwareVersionVector);\n  bVar1 \u003d this-\u003efirmwareVersionCount;\n  pbVar4 \u003d (byte *)malloc(bVar1 + 1);\n  this-\u003efirmwareVersionVector \u003d pbVar4;\n  pbVar4[bVar1] \u003d \u0027\\0\u0027;\n  *pbVar4 \u003d major;\n  pbVar4[1] \u003d minor;\n  strncpy((char *)(pbVar4 + 2),name,this-\u003efirmwareVersionCount - 2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "strstr",
        "strlen",
        "strrchr",
        "strncpy",
        "malloc",
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "processInput": {
      "entrypoint": "0x08002ed2",
      "current_name": "processInput",
      "code": "\n/* DWARF original prototype: void  processInput(FirmataClass * this) */\n\nvoid __thiscall firmata::FirmataClass::processInput(FirmataClass *this)\n\n{\n  int iVar1;\n  int inputData;\n  \n  iVar1 \u003d (*(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print[3])();\n  if (iVar1 !\u003d -1) {\n    FirmataParser::parse(\u0026this-\u003eparser,(uint8_t)iVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "parse"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendAnalog": {
      "entrypoint": "0x08003158",
      "current_name": "sendAnalog",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800318c */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendAnalog(FirmataMarshaller * this, uint8_t pin, uint16_t value)\n    */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendAnalog(FirmataMarshaller *this,uint8_t pin,uint16_t value)\n\n{\n  uint16_t local_a;\n  \n  if (this-\u003eFirmataStream !\u003d (Stream *)0x0) {\n    local_a \u003d value;\n    if ((pin \u003c 0x10) \u0026\u0026 (value \u003c 0x4000)) {\n      (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this,pin | 0xe0);\n      encodeByteStream(this,2,(uint8_t *)\u0026local_a,2);\n    }\n    else {\n      sendExtendedAnalog(this,pin,2,(uint8_t *)\u0026local_a);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sendAnalog"
      ],
      "called": [
        "encodeByteStream",
        "sendExtendedAnalog"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendDigitalPort": {
      "entrypoint": "0x0800319e",
      "current_name": "sendDigitalPort",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031ba */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendDigitalPort(FirmataMarshaller * this, uint8_t portNumber,\n   uint16_t portData) */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendDigitalPort\n          (FirmataMarshaller *this,uint8_t portNumber,uint16_t portData)\n\n{\n  uint16_t local_a;\n  \n  if (this-\u003eFirmataStream !\u003d (Stream *)0x0) {\n    local_a \u003d portData;\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this,portNumber \u0026 0xf | 0x90);\n    encodeByteStream(this,2,(uint8_t *)\u0026local_a,2);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sendDigitalPort"
      ],
      "called": [
        "encodeByteStream"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendSysex": {
      "entrypoint": "0x0800325a",
      "current_name": "sendSysex",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003272 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendSysex(FirmataMarshaller * this, uint8_t command, size_t\n   bytec, uint8_t * bytev) */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendSysex\n          (FirmataMarshaller *this,uint8_t command,size_t bytec,uint8_t *bytev)\n\n{\n  uint uVar1;\n  \n  if (this-\u003eFirmataStream !\u003d (Stream *)0x0) {\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this,0xf0);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,(uint)command);\n    for (uVar1 \u003d 0; uVar1 \u003c bytec; uVar1 \u003d uVar1 + 1) {\n      encodeByteStream(this,1,bytev + uVar1,0);\n    }\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,0xf7);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sendString",
        "sendSysex"
      ],
      "called": [
        "encodeByteStream"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendString": {
      "entrypoint": "0x080032a2",
      "current_name": "sendString",
      "code": "\n/* DWARF original prototype: void  sendString(FirmataMarshaller * this, char * string) */\n\nvoid __thiscall firmata::FirmataMarshaller::sendString(FirmataMarshaller *this,char *string)\n\n{\n  size_t bytec;\n  \n  bytec \u003d strlen(string);\n  sendSysex(this,\u0027q\u0027,bytec,(uint8_t *)string);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sendString"
      ],
      "called": [
        "strlen",
        "sendSysex"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getPinMode": {
      "entrypoint": "0x08002fa0",
      "current_name": "getPinMode",
      "code": "\n/* DWARF original prototype: byte  getPinMode(FirmataClass * this, byte pin) */\n\nbyte __thiscall firmata::FirmataClass::getPinMode(FirmataClass *this,byte pin)\n\n{\n  return this-\u003epinConfig[pin];\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "setPinModeCallback",
        "digitalWriteCallback",
        "analogWriteCallback",
        "sysexCallback",
        "setPinValueCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setPinMode": {
      "entrypoint": "0x08002fa8",
      "current_name": "setPinMode",
      "code": "\n/* DWARF original prototype: void  setPinMode(FirmataClass * this, byte pin, byte config) */\n\nvoid __thiscall firmata::FirmataClass::setPinMode(FirmataClass *this,byte pin,byte config)\n\n{\n  if (this-\u003epinConfig[pin] !\u003d \u0027\\x7f\u0027) {\n    this-\u003epinConfig[pin] \u003d config;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getPinState": {
      "entrypoint": "0x08002fba",
      "current_name": "getPinState",
      "code": "\n/* DWARF original prototype: int  getPinState(FirmataClass * this, byte pin) */\n\nint __thiscall firmata::FirmataClass::getPinState(FirmataClass *this,byte pin)\n\n{\n  return this-\u003epinState[pin];\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWriteCallback",
        "sysexCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setPinState": {
      "entrypoint": "0x08002fc2",
      "current_name": "setPinState",
      "code": "\n/* DWARF original prototype: void  setPinState(FirmataClass * this, byte pin, int state) */\n\nvoid __thiscall firmata::FirmataClass::setPinState(FirmataClass *this,byte pin,int state)\n\n{\n  this-\u003epinState[pin] \u003d state;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback",
        "digitalWriteCallback",
        "analogWriteCallback",
        "setPinValueCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strobeBlinkPin": {
      "entrypoint": "0x08002fca",
      "current_name": "strobeBlinkPin",
      "code": "\n/* DWARF original prototype: void  strobeBlinkPin(FirmataClass * this, byte pin, int count, int\n   onInterval, int offInterval) */\n\nvoid __thiscall\nfirmata::FirmataClass::strobeBlinkPin\n          (FirmataClass *this,byte pin,int count,int onInterval,int offInterval)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0; (int)uVar1 \u003c count; uVar1 \u003d uVar1 + 1 \u0026 0xff) {\n    delay(offInterval);\n    digitalWrite((uint)pin,1);\n    delay(onInterval);\n    digitalWrite((uint)pin,0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "blinkVersion"
      ],
      "called": [
        "delay",
        "digitalWrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "blinkVersion": {
      "entrypoint": "0x08003002",
      "current_name": "blinkVersion",
      "code": "\n/* DWARF original prototype: void  blinkVersion(FirmataClass * this) */\n\nvoid __thiscall firmata::FirmataClass::blinkVersion(FirmataClass *this)\n\n{\n  if (this-\u003eblinkVersionDisabled !\u003d false) {\n    return;\n  }\n  pinMode(0xd,1);\n  strobeBlinkPin(this,\u0027\\r\u0027,2,0x28,0xd2);\n  delay(0xfa);\n  strobeBlinkPin(this,\u0027\\r\u0027,5,0x28,0xd2);\n  delay(0x7d);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "strobeBlinkPin",
        "pinMode",
        "delay"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_Firmata": {
      "entrypoint": "0x0800306c",
      "current_name": "_GLOBAL__sub_I_Firmata",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I_Firmata(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "encodeByteStream": {
      "entrypoint": "0x0800307a",
      "current_name": "encodeByteStream",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003102 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  encodeByteStream(FirmataMarshaller * this, size_t bytec, uint8_t\n   * bytev, size_t max_bytes) */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::encodeByteStream\n          (FirmataMarshaller *this,size_t bytec,uint8_t *bytev,size_t max_bytes)\n\n{\n  uint8_t transmit_byte;\n  uint8_t outstanding_bit_cache;\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  uVar1 \u003d (uint)*bytev;\n  if (max_bytes \u003d\u003d 0) {\n    max_bytes \u003d 0xffffffff;\n  }\n  uVar4 \u003d 0;\n  uVar2 \u003d 0;\n  uVar3 \u003d 0;\n  while ((uVar4 \u003c bytec \u0026\u0026 (uVar3 \u003c max_bytes))) {\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)\n              (this-\u003eFirmataStream,((uint)bytev[uVar4] \u003c\u003c (uVar2 \u0026 0xff) | uVar1) \u0026 0x7f);\n    uVar1 \u003d (int)(uint)bytev[uVar4] \u003e\u003e (7 - uVar2 \u0026 0xff) \u0026 0xff;\n    uVar2 \u003d uVar2 + 1;\n    while ((uVar3 \u003d uVar3 + 1, 6 \u003c uVar2 \u0026\u0026 (uVar3 \u003c max_bytes))) {\n      (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,uVar1 \u0026 0x7f);\n      uVar1 \u003d uVar1 \u003e\u003e 7;\n      uVar2 \u003d uVar2 - 7;\n    }\n    uVar4 \u003d uVar4 + 1;\n  }\n  if ((uVar2 !\u003d 0) \u0026\u0026 (uVar3 \u003c max_bytes)) {\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)\n              (this-\u003eFirmataStream,(1 \u003c\u003c (uVar2 \u0026 0xff)) - 1U \u0026 uVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sendSysex",
        "sendFirmwareVersion",
        "sendAnalog",
        "sendExtendedAnalog",
        "sendDigitalPort"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendExtendedAnalog": {
      "entrypoint": "0x08003106",
      "current_name": "sendExtendedAnalog",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0800311e */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendExtendedAnalog(FirmataMarshaller * this, uint8_t pin, size_t\n   bytec, uint8_t * bytev) */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendExtendedAnalog\n          (FirmataMarshaller *this,uint8_t pin,size_t bytec,uint8_t *bytev)\n\n{\n  if (this-\u003eFirmataStream !\u003d (Stream *)0x0) {\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this,0xf0);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,0x6f);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,(uint)pin);\n    encodeByteStream(this,bytec,bytev,bytec);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,0xf7);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sendAnalog"
      ],
      "called": [
        "encodeByteStream"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FirmataMarshaller": {
      "entrypoint": "0x0800314e",
      "current_name": "FirmataMarshaller",
      "code": "\n/* DWARF original prototype: FirmataMarshaller *  FirmataMarshaller(FirmataMarshaller * this) */\n\nFirmataMarshaller * __thiscall\nfirmata::FirmataMarshaller::FirmataMarshaller(FirmataMarshaller *this)\n\n{\n  this-\u003eFirmataStream \u003d (Stream *)0x0;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "FirmataClass"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendFirmwareVersion": {
      "entrypoint": "0x080031ce",
      "current_name": "sendFirmwareVersion",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080031e8 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendFirmwareVersion(FirmataMarshaller * this, uint8_t major,\n   uint8_t minor, size_t bytec, uint8_t * bytev) */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendFirmwareVersion\n          (FirmataMarshaller *this,uint8_t major,uint8_t minor,size_t bytec,uint8_t *bytev)\n\n{\n  _func_int_varargs *p_Var1;\n  uint uVar2;\n  \n  if (this-\u003eFirmataStream !\u003d (Stream *)0x0) {\n    p_Var1 \u003d *(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print;\n    (*p_Var1)(this,0xf0,(uint)minor,p_Var1,bytec);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,0x79);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,(uint)major);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,(uint)minor);\n    for (uVar2 \u003d 0; uVar2 \u003c bytec; uVar2 \u003d uVar2 + 1) {\n      encodeByteStream(this,1,bytev + uVar2,0);\n    }\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,0xf7);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "printFirmwareVersion"
      ],
      "called": [
        "encodeByteStream"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendVersion": {
      "entrypoint": "0x0800322c",
      "current_name": "sendVersion",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08003240 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendVersion(FirmataMarshaller * this, uint8_t major, uint8_t\n   minor) */\n\nvoid __thiscall\nfirmata::FirmataMarshaller::sendVersion(FirmataMarshaller *this,uint8_t major,uint8_t minor)\n\n{\n  if (this-\u003eFirmataStream !\u003d (Stream *)0x0) {\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this,0xf9);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,(uint)major);\n    (**(this-\u003eFirmataStream-\u003esuper_Print)._vptr_Print)(this-\u003eFirmataStream,(uint)minor);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "printVersion"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FirmataParser": {
      "entrypoint": "0x080032bc",
      "current_name": "FirmataParser",
      "code": "\n/* DWARF original prototype: FirmataParser *  FirmataParser(FirmataParser * this, uint8_t *\n   dataBuffer, size_t dataBufferSize) */\n\nFirmataParser * __thiscall\nfirmata::FirmataParser::FirmataParser(FirmataParser *this,uint8_t *dataBuffer,size_t dataBufferSize)\n\n{\n  this-\u003edataBuffer \u003d dataBuffer;\n  this-\u003edataBufferSize \u003d dataBufferSize;\n  this-\u003eexecuteMultiByteCommand \u003d \u0027\\0\u0027;\n  this-\u003emultiByteChannel \u003d \u0027\\0\u0027;\n  this-\u003ewaitForData \u003d 0;\n  this-\u003eparsingSysex \u003d false;\n  this-\u003esysexBytesRead \u003d 0;\n  this-\u003ecurrentAnalogCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentDigitalCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentReportAnalogCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentReportDigitalCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentPinModeCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentPinValueCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentReportFirmwareCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentReportVersionCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentDataBufferOverflowCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentStringCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentSysexCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentSystemResetCallbackContext \u003d (void *)0x0;\n  this-\u003ecurrentAnalogCallback \u003d (callbackFunction)0x0;\n  this-\u003ecurrentDigitalCallback \u003d (callbackFunction)0x0;\n  this-\u003ecurrentReportAnalogCallback \u003d (callbackFunction)0x0;\n  this-\u003ecurrentReportDigitalCallback \u003d (callbackFunction)0x0;\n  this-\u003ecurrentPinModeCallback \u003d (callbackFunction)0x0;\n  this-\u003ecurrentPinValueCallback \u003d (callbackFunction)0x0;\n  this-\u003ecurrentDataBufferOverflowCallback \u003d (dataBufferOverflowCallbackFunction)0x0;\n  this-\u003ecurrentStringCallback \u003d (stringCallbackFunction)0x0;\n  this-\u003ecurrentSysexCallback \u003d (sysexCallbackFunction)0x0;\n  this-\u003ecurrentReportFirmwareCallback \u003d (versionCallbackFunction)0x0;\n  this-\u003ecurrentReportVersionCallback \u003d (systemCallbackFunction)0x0;\n  this-\u003ecurrentSystemResetCallback \u003d (systemCallbackFunction)0x0;\n  this-\u003eallowBufferUpdate \u003d dataBuffer \u003d\u003d (uint8_t *)0x0;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "FirmataClass"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bufferDataAtPosition": {
      "entrypoint": "0x08003376",
      "current_name": "bufferDataAtPosition",
      "code": "\n/* DWARF original prototype: bool  bufferDataAtPosition(FirmataParser * this, uint8_t data, size_t\n   pos) */\n\nbool __thiscall\nfirmata::FirmataParser::bufferDataAtPosition(FirmataParser *this,uint8_t data,size_t pos)\n\n{\n  bool bVar1;\n  bool bufferOverflow;\n  \n  if (pos \u003c this-\u003edataBufferSize) {\n    bVar1 \u003d false;\n  }\n  else {\n    bVar1 \u003d true;\n    if (this-\u003ecurrentDataBufferOverflowCallback !\u003d (dataBufferOverflowCallbackFunction)0x0) {\n      this-\u003eallowBufferUpdate \u003d true;\n      (*this-\u003ecurrentDataBufferOverflowCallback)(this-\u003ecurrentDataBufferOverflowCallbackContext);\n      if (pos \u003c this-\u003edataBufferSize) {\n        bVar1 \u003d false;\n      }\n      else {\n        bVar1 \u003d true;\n      }\n    }\n  }\n  if (!bVar1) {\n    this-\u003edataBuffer[pos] \u003d data;\n  }\n  return bVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse",
        "processSysexMessage"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "decodeByteStream": {
      "entrypoint": "0x080033a8",
      "current_name": "decodeByteStream",
      "code": "\n/* DWARF original prototype: size_t  decodeByteStream(FirmataParser * this, size_t bytec, uint8_t *\n   bytev) */\n\nsize_t __thiscall\nfirmata::FirmataParser::decodeByteStream(FirmataParser *this,size_t bytec,uint8_t *bytev)\n\n{\n  byte bVar1;\n  size_t sVar2;\n  uint uVar3;\n  \n  sVar2 \u003d 0;\n  for (uVar3 \u003d 0; uVar3 \u003c bytec; uVar3 \u003d uVar3 + 2) {\n    bVar1 \u003d bytev[uVar3];\n    bytev[sVar2] \u003d bVar1;\n    bytev[sVar2] \u003d bytev[uVar3 + 1] \u003c\u003c 7 | bVar1;\n    sVar2 \u003d sVar2 + 1;\n  }\n  return sVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "processSysexMessage"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "processSysexMessage": {
      "entrypoint": "0x080033cc",
      "current_name": "processSysexMessage",
      "code": "\n/* DWARF original prototype: void  processSysexMessage(FirmataParser * this) */\n\nvoid __thiscall firmata::FirmataParser::processSysexMessage(FirmataParser *this)\n\n{\n  uint8_t uVar1;\n  size_t sVar2;\n  uint8_t *puVar3;\n  \n  puVar3 \u003d this-\u003edataBuffer;\n  uVar1 \u003d *puVar3;\n  if (uVar1 \u003d\u003d \u0027q\u0027) {\n    if (this-\u003ecurrentStringCallback !\u003d (stringCallbackFunction)0x0) {\n      sVar2 \u003d decodeByteStream(this,this-\u003esysexBytesRead - 1,puVar3 + 1);\n      bufferDataAtPosition(this,\u0027\\0\u0027,sVar2 + 1);\n      (*this-\u003ecurrentStringCallback)\n                (this-\u003ecurrentStringCallbackContext,(char *)(this-\u003edataBuffer + 1));\n      return;\n    }\n  }\n  else if (uVar1 \u003d\u003d \u0027y\u0027) {\n    if (this-\u003ecurrentReportFirmwareCallback !\u003d (versionCallbackFunction)0x0) {\n      if (this-\u003esysexBytesRead \u003c 3) {\n        (*this-\u003ecurrentReportFirmwareCallback)\n                  (this-\u003ecurrentReportFirmwareCallbackContext,0,0,(char *)0x0);\n        return;\n      }\n      sVar2 \u003d decodeByteStream(this,this-\u003esysexBytesRead - 3,puVar3 + 3);\n      bufferDataAtPosition(this,\u0027\\0\u0027,sVar2 + 3);\n      puVar3 \u003d this-\u003edataBuffer;\n      (*this-\u003ecurrentReportFirmwareCallback)\n                (this-\u003ecurrentReportFirmwareCallbackContext,(uint)puVar3[1],(uint)puVar3[2],\n                 (char *)(puVar3 + 3));\n      return;\n    }\n  }\n  else if (this-\u003ecurrentSysexCallback !\u003d (sysexCallbackFunction)0x0) {\n    (*this-\u003ecurrentSysexCallback)\n              (this-\u003ecurrentSysexCallbackContext,uVar1,this-\u003esysexBytesRead - 1,puVar3 + 1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse"
      ],
      "called": [
        "bufferDataAtPosition",
        "decodeByteStream"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "systemReset": {
      "entrypoint": "0x0800344a",
      "current_name": "systemReset",
      "code": "\n/* DWARF original prototype: void  systemReset(FirmataParser * this) */\n\nvoid __thiscall firmata::FirmataParser::systemReset(FirmataParser *this)\n\n{\n  size_t i;\n  \n  this-\u003ewaitForData \u003d 0;\n  this-\u003eexecuteMultiByteCommand \u003d \u0027\\0\u0027;\n  this-\u003emultiByteChannel \u003d \u0027\\0\u0027;\n  for (i \u003d 0; i \u003c this-\u003edataBufferSize; i \u003d i + 1) {\n    this-\u003edataBuffer[i] \u003d \u0027\\0\u0027;\n  }\n  this-\u003eparsingSysex \u003d false;\n  this-\u003esysexBytesRead \u003d 0;\n  if (this-\u003ecurrentSystemResetCallback !\u003d (systemCallbackFunction)0x0) {\n    (*this-\u003ecurrentSystemResetCallback)(this-\u003ecurrentSystemResetCallbackContext);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "parse"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "parse": {
      "entrypoint": "0x08003474",
      "current_name": "parse",
      "code": "\n/* DWARF original prototype: void  parse(FirmataParser * this, uint8_t inputData) */\n\nvoid __thiscall firmata::FirmataParser::parse(FirmataParser *this,uint8_t inputData)\n\n{\n  byte bVar1;\n  uint uVar2;\n  size_t pos;\n  \n  uVar2 \u003d (uint)inputData;\n  if (this-\u003eparsingSysex !\u003d false) {\n    if (uVar2 !\u003d 0xf7) {\n      bufferDataAtPosition(this,inputData,this-\u003esysexBytesRead);\n      this-\u003esysexBytesRead \u003d this-\u003esysexBytesRead + 1;\n      return;\n    }\n    this-\u003eparsingSysex \u003d false;\n    processSysexMessage(this);\n    return;\n  }\n  if ((this-\u003ewaitForData \u003d\u003d 0) || (0x7f \u003c uVar2)) {\n    if (uVar2 \u003c 0xf0) {\n      this-\u003emultiByteChannel \u003d inputData \u0026 0xf;\n      uVar2 \u003d uVar2 \u0026 0xf0;\n    }\n    if (uVar2 \u003d\u003d 0xf0) {\n      this-\u003eparsingSysex \u003d true;\n      this-\u003esysexBytesRead \u003d 0;\n      return;\n    }\n    if (uVar2 \u003c 0xf1) {\n      if (uVar2 !\u003d 0xc0) {\n        if (uVar2 \u003c 0xc1) {\n          if (uVar2 !\u003d 0x90) {\n            return;\n          }\n        }\n        else {\n          if (uVar2 \u003d\u003d 0xd0) goto LAB_0800359c;\n          if (uVar2 !\u003d 0xe0) {\n            return;\n          }\n        }\nLAB_08003586:\n        this-\u003ewaitForData \u003d 2;\n        this-\u003eexecuteMultiByteCommand \u003d (uint8_t)uVar2;\n        return;\n      }\nLAB_0800359c:\n      this-\u003ewaitForData \u003d 1;\n      this-\u003eexecuteMultiByteCommand \u003d (uint8_t)uVar2;\n      return;\n    }\n    if (uVar2 !\u003d 0xf9) {\n      if (0xf9 \u003c uVar2) {\n        if (uVar2 \u003d\u003d 0xff) {\n          systemReset(this);\n          return;\n        }\n        return;\n      }\n      if (1 \u003c uVar2 - 0xf4) {\n        return;\n      }\n      goto LAB_08003586;\n    }\n    if (this-\u003ecurrentReportVersionCallback !\u003d (systemCallbackFunction)0x0) {\n      (*this-\u003ecurrentReportVersionCallback)(this-\u003ecurrentReportVersionCallbackContext);\n    }\n  }\n  else {\n    pos \u003d this-\u003ewaitForData - 1;\n    this-\u003ewaitForData \u003d pos;\n    bufferDataAtPosition(this,inputData,pos);\n    if ((this-\u003ewaitForData \u003d\u003d 0) \u0026\u0026 (bVar1 \u003d this-\u003eexecuteMultiByteCommand, bVar1 !\u003d 0)) {\n      if (bVar1 \u003d\u003d 0xd0) {\n        if (this-\u003ecurrentReportDigitalCallback !\u003d (callbackFunction)0x0) {\n          (*this-\u003ecurrentReportDigitalCallback)\n                    (this-\u003ecurrentReportDigitalCallbackContext,this-\u003emultiByteChannel,\n                     (uint16_t)*this-\u003edataBuffer);\n        }\n      }\n      else if (bVar1 \u003c 0xd1) {\n        if (bVar1 \u003d\u003d 0x90) {\n          if (this-\u003ecurrentDigitalCallback !\u003d (callbackFunction)0x0) {\n            (*this-\u003ecurrentDigitalCallback)\n                      (this-\u003ecurrentDigitalCallbackContext,this-\u003emultiByteChannel,\n                       (ushort)this-\u003edataBuffer[1] + (ushort)*this-\u003edataBuffer * 0x80);\n          }\n        }\n        else if ((bVar1 \u003d\u003d 0xc0) \u0026\u0026 (this-\u003ecurrentReportAnalogCallback !\u003d (callbackFunction)0x0)) {\n          (*this-\u003ecurrentReportAnalogCallback)\n                    (this-\u003ecurrentReportAnalogCallbackContext,this-\u003emultiByteChannel,\n                     (uint16_t)*this-\u003edataBuffer);\n        }\n      }\n      else if (bVar1 \u003d\u003d 0xf4) {\n        if (this-\u003ecurrentPinModeCallback !\u003d (callbackFunction)0x0) {\n          (*this-\u003ecurrentPinModeCallback)\n                    (this-\u003ecurrentPinModeCallbackContext,this-\u003edataBuffer[1],\n                     (uint16_t)*this-\u003edataBuffer);\n        }\n      }\n      else if (bVar1 \u003d\u003d 0xf5) {\n        if (this-\u003ecurrentPinValueCallback !\u003d (callbackFunction)0x0) {\n          (*this-\u003ecurrentPinValueCallback)\n                    (this-\u003ecurrentPinValueCallbackContext,this-\u003edataBuffer[1],\n                     (uint16_t)*this-\u003edataBuffer);\n        }\n      }\n      else if ((bVar1 \u003d\u003d 0xe0) \u0026\u0026 (this-\u003ecurrentAnalogCallback !\u003d (callbackFunction)0x0)) {\n        (*this-\u003ecurrentAnalogCallback)\n                  (this-\u003ecurrentAnalogCallbackContext,this-\u003emultiByteChannel,\n                   (ushort)this-\u003edataBuffer[1] + (ushort)*this-\u003edataBuffer * 0x80);\n      }\n      this-\u003eexecuteMultiByteCommand \u003d \u0027\\0\u0027;\n      return;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "processInput"
      ],
      "called": [
        "processSysexMessage",
        "bufferDataAtPosition",
        "systemReset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemClock_Config": {
      "entrypoint": "0x080035b8",
      "current_name": "SystemClock_Config",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SystemClock_Config(void)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  RCC_PeriphCLKInitTypeDef PeriphClkInit;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  \n  RCC_OscInitStruct.OscillatorType \u003d 2;\n  RCC_OscInitStruct.HSIState \u003d 1;\n  RCC_OscInitStruct.HSICalibrationValue \u003d 0x10;\n  RCC_OscInitStruct.PLL.PLLState \u003d 2;\n  RCC_OscInitStruct.PLL.PLLSource \u003d 0;\n  RCC_OscInitStruct.PLL.PLLMUL \u003d 0x380000;\n  HVar1 \u003d HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)\u0026RCC_OscInitStruct);\n  if (HVar1 !\u003d HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  RCC_ClkInitStruct.ClockType \u003d 0xf;\n  RCC_ClkInitStruct.SYSCLKSource \u003d 2;\n  RCC_ClkInitStruct.AHBCLKDivider \u003d 0;\n  RCC_ClkInitStruct.APB1CLKDivider \u003d 0x400;\n  RCC_ClkInitStruct.APB2CLKDivider \u003d 0;\n  HVar1 \u003d HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)\u0026RCC_ClkInitStruct,2);\n  if (HVar1 !\u003d HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  PeriphClkInit.PeriphClockSelection \u003d 2;\n  PeriphClkInit.AdcClockSelection \u003d 0x8000;\n  HVar1 \u003d HAL_RCCEx_PeriphCLKConfig((RCC_PeriphCLKInitTypeDef_conflict *)\u0026PeriphClkInit);\n  if (HVar1 !\u003d HAL_OK) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  uVar2 \u003d HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(uVar2 / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "hw_config_init"
      ],
      "called": [
        "HAL_SYSTICK_CLKSourceConfig",
        "HAL_RCC_OscConfig",
        "_Error_Handler",
        "HAL_RCC_ClockConfig",
        "HAL_RCC_GetHCLKFreq",
        "HAL_SYSTICK_Config",
        "HAL_NVIC_SetPriority",
        "HAL_RCCEx_PeriphCLKConfig"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Reset_Handler": {
      "entrypoint": "0x08003658",
      "current_name": "Reset_Handler",
      "code": "\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 \u003d 0; (undefined4 *)(iVar1 + 0x20000000) \u003c \u0026completed_8667; iVar1 \u003d iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) \u003d *(undefined4 *)(\u0026_sidata + iVar1);\n  }\n  for (puVar2 \u003d \u0026completed_8667; puVar2 \u003c \u0026_ebss; puVar2 \u003d puVar2 + 1) {\n    *puVar2 \u003d 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE \u003d (code *)0x800368a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800368a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "main",
        "__libc_init_array",
        "SystemInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USB_HP_CAN1_TX_IRQHandler": {
      "entrypoint": "0x080036a0",
      "current_name": "USB_HP_CAN1_TX_IRQHandler",
      "code": "\nvoid USB_HP_CAN1_TX_IRQHandler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "USB_HP_CAN1_TX_IRQHandler"
      ],
      "called": [
        "USB_HP_CAN1_TX_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "init": {
      "entrypoint": "0x08008c20",
      "current_name": "init",
      "code": "\n/* DWARF original prototype: void  init(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::init(HardwareSerial *this,EVP_PKEY_CTX *ctx)\n\n{\n  (this-\u003e_serial).rx_buff \u003d this-\u003e_rx_buffer;\n  (this-\u003e_serial).rx_head \u003d 0;\n  (this-\u003e_serial).rx_tail \u003d 0;\n  (this-\u003e_serial).tx_buff \u003d this-\u003e_tx_buffer;\n  (this-\u003e_serial).tx_head \u003d 0;\n  (this-\u003e_serial).tx_tail \u003d 0;\n  return (int)this;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinNametoDigitalPin": {
      "entrypoint": "0x080036ac",
      "current_name": "pinNametoDigitalPin",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pinNametoDigitalPin(PinName_conflict p)\n\n{\n  uint32_t uVar1;\n  \n  if ((uint)((int)p \u003c\u003c 0x18) \u003e\u003e 0x1c \u003c 5) {\n    for (uVar1 \u003d 0; (uVar1 \u003c 0x3c \u0026\u0026 ((int)p !\u003d (int)(char)(\u0026digitalPin)[uVar1])); uVar1 \u003d uVar1 + 1\n        ) {\n    }\n  }\n  else {\n    uVar1 \u003d 0xffffffff;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "checkDigitalInputs",
        "loop",
        "setPinModeCallback",
        "digitalWriteCallback",
        "enableI2CPins",
        "reportDigitalCallback",
        "analogWriteCallback",
        "sysexCallback",
        "setPinValueCallback",
        "systemResetCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_MspInit": {
      "entrypoint": "0x080036d4",
      "current_name": "HAL_MspInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_MspInit(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_InitTick": {
      "entrypoint": "0x080036d8",
      "current_name": "HAL_InitTick",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_InitTick(uint32_t TickPriority)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (uVar1 !\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (0xf \u003c TickPriority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,TickPriority,0);\n  uwTickPrio \u003d TickPriority;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_Init",
        "HAL_RCC_ClockConfig"
      ],
      "called": [
        "HAL_SYSTICK_Config",
        "HAL_NVIC_SetPriority"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_Init": {
      "entrypoint": "0x08003724",
      "current_name": "HAL_Init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_Init(void)\n\n{\n  _DAT_40022000 \u003d _DAT_40022000 | 0x10;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_InitTick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "hw_config_init"
      ],
      "called": [
        "HAL_MspInit",
        "HAL_NVIC_SetPriorityGrouping",
        "HAL_InitTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_IncTick": {
      "entrypoint": "0x08003748",
      "current_name": "HAL_IncTick",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_IncTick(void)\n\n{\n  uwTick \u003d uwTickFreq + uwTick;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GetTick": {
      "entrypoint": "0x08003760",
      "current_name": "HAL_GetTick",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetTick(void)\n\n{\n  return uwTick;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_PollForConversion",
        "i2c_master_read",
        "ADC_Enable",
        "UART_WaitOnFlagUntilTimeout",
        "HAL_UART_Transmit",
        "uart_debug_write",
        "HAL_RCC_OscConfig",
        "ADC_ConversionStop_Disable",
        "HAL_RCC_ClockConfig",
        "HAL_ADCEx_Calibration_Start",
        "GetCurrentMilli",
        "HAL_RCCEx_PeriphCLKConfig",
        "i2c_master_write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_PollForConversion": {
      "entrypoint": "0x0800376c",
      "current_name": "HAL_ADC_PollForConversion",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  int iVar4;\n  uint32_t uVar5;\n  ADC_TypeDef *pAVar6;\n  uint uVar7;\n  uint32_t Conversion_Timeout_CPU_cycles;\n  \n  Conversion_Timeout_CPU_cycles \u003d 0;\n  uVar2 \u003d HAL_GetTick();\n  uVar5 \u003d SystemCoreClock;\n  pAVar6 \u003d hadc-\u003eInstance;\n  if ((pAVar6-\u003eCR2 \u0026 0x100) \u003d\u003d 0) {\n    if (((pAVar6-\u003eCR1 \u0026 0x100) \u003d\u003d 0) \u0026\u0026 ((pAVar6-\u003eSQR1 \u0026 0xf00000) \u003d\u003d 0)) {\n      do {\n        if ((hadc-\u003eInstance-\u003eSR \u0026 2) !\u003d 0) goto LAB_0800387e;\n      } while ((Timeout \u003d\u003d 0xffffffff) ||\n              ((Timeout !\u003d 0 \u0026\u0026 (uVar5 \u003d HAL_GetTick(), uVar5 - uVar2 \u003c\u003d Timeout))));\n      hadc-\u003eState \u003d hadc-\u003eState | 4;\n      hadc-\u003eLock \u003d HAL_UNLOCKED;\n      HVar1 \u003d HAL_TIMEOUT;\n    }\n    else {\n      uVar3 \u003d HAL_RCCEx_GetPeriphCLKFreq(2);\n      pAVar6 \u003d hadc-\u003eInstance;\n      if (((pAVar6-\u003eSMPR2 \u0026 0x24924924) \u003d\u003d 0) \u0026\u0026 ((pAVar6-\u003eSMPR1 \u0026 0x924924) \u003d\u003d 0)) {\n        if ((pAVar6-\u003eSMPR2 \u0026 0x12492492) \u003d\u003d 0) {\n          if ((pAVar6-\u003eSMPR1 \u0026 0x492492) \u003d\u003d 0) {\n            iVar4 \u003d 0x14;\n          }\n          else {\n            iVar4 \u003d 0x29;\n          }\n        }\n        else {\n          iVar4 \u003d 0x29;\n        }\n      }\n      else if (((pAVar6-\u003eSMPR2 \u0026 0x12492492) \u003d\u003d 0) \u0026\u0026 ((pAVar6-\u003eSMPR1 \u0026 0x492492) \u003d\u003d 0)) {\n        iVar4 \u003d 0x54;\n      }\n      else if ((pAVar6-\u003eSMPR2 \u0026 0x249249) \u003d\u003d 0) {\n        if ((pAVar6-\u003eSMPR1 \u0026 0x249249) \u003d\u003d 0) {\n          iVar4 \u003d 0x54;\n        }\n        else {\n          iVar4 \u003d 0xfc;\n        }\n      }\n      else {\n        iVar4 \u003d 0xfc;\n      }\n      uVar7 \u003d (uVar5 / uVar3) * iVar4;\n      for (; Conversion_Timeout_CPU_cycles \u003c\u003d uVar7 \u0026\u0026 uVar7 - Conversion_Timeout_CPU_cycles !\u003d 0;\n          Conversion_Timeout_CPU_cycles \u003d Conversion_Timeout_CPU_cycles + 1) {\n        if ((Timeout !\u003d 0xffffffff) \u0026\u0026\n           ((Timeout \u003d\u003d 0 || (uVar5 \u003d HAL_GetTick(), Timeout \u003c uVar5 - uVar2)))) {\n          hadc-\u003eState \u003d hadc-\u003eState | 4;\n          hadc-\u003eLock \u003d HAL_UNLOCKED;\n          return HAL_TIMEOUT;\n        }\n      }\nLAB_0800387e:\n      hadc-\u003eInstance-\u003eSR \u003d 0xffffffed;\n      hadc-\u003eState \u003d hadc-\u003eState | 0x200;\n      if ((hadc-\u003eInstance-\u003eCR2 \u0026 0xe0000) \u003d\u003d 0xe0000) {\n        if ((hadc-\u003eInit).ContinuousConvMode \u003d\u003d 0) {\n          hadc-\u003eState \u003d hadc-\u003eState \u0026 0xfffffeff;\n          if ((hadc-\u003eState \u0026 0x1000) \u003d\u003d 0) {\n            hadc-\u003eState \u003d hadc-\u003eState | 1;\n            HVar1 \u003d HAL_OK;\n          }\n          else {\n            HVar1 \u003d HAL_OK;\n          }\n        }\n        else {\n          HVar1 \u003d HAL_OK;\n        }\n      }\n      else {\n        HVar1 \u003d HAL_OK;\n      }\n    }\n  }\n  else {\n    hadc-\u003eState \u003d hadc-\u003eState | 0x20;\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n    HVar1 \u003d HAL_ERROR;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "HAL_RCCEx_GetPeriphCLKFreq",
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_GetValue": {
      "entrypoint": "0x080038dc",
      "current_name": "HAL_ADC_GetValue",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_ADC_GetValue(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc-\u003eInstance-\u003eDR;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_ConfigChannel": {
      "entrypoint": "0x080038e4",
      "current_name": "HAL_ADC_ConfigChannel",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc,ADC_ChannelConfTypeDef *sConfig)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  uint32_t wait_loop_index;\n  \n  if (hadc-\u003eLock \u003d\u003d HAL_LOCKED) {\n    HVar1 \u003d HAL_BUSY;\n  }\n  else {\n    hadc-\u003eLock \u003d HAL_LOCKED;\n    uVar2 \u003d sConfig-\u003eRank;\n    if (uVar2 \u003c 7) {\n      uVar2 \u003d uVar2 * 5 - 5;\n      hadc-\u003eInstance-\u003eSQR3 \u003d\n           sConfig-\u003eChannel \u003c\u003c (uVar2 \u0026 0xff) | hadc-\u003eInstance-\u003eSQR3 \u0026 ~(0x1f \u003c\u003c (uVar2 \u0026 0xff));\n    }\n    else if (uVar2 \u003c 0xd) {\n      uVar2 \u003d uVar2 * 5 - 0x23;\n      hadc-\u003eInstance-\u003eSQR2 \u003d\n           sConfig-\u003eChannel \u003c\u003c (uVar2 \u0026 0xff) | hadc-\u003eInstance-\u003eSQR2 \u0026 ~(0x1f \u003c\u003c (uVar2 \u0026 0xff));\n    }\n    else {\n      uVar2 \u003d uVar2 * 5 - 0x41;\n      hadc-\u003eInstance-\u003eSQR1 \u003d\n           sConfig-\u003eChannel \u003c\u003c (uVar2 \u0026 0xff) | hadc-\u003eInstance-\u003eSQR1 \u0026 ~(0x1f \u003c\u003c (uVar2 \u0026 0xff));\n    }\n    uVar2 \u003d sConfig-\u003eChannel;\n    if (uVar2 \u003c 10) {\n      hadc-\u003eInstance-\u003eSMPR2 \u003d\n           sConfig-\u003eSamplingTime \u003c\u003c (uVar2 * 3 \u0026 0xff) |\n           hadc-\u003eInstance-\u003eSMPR2 \u0026 ~(7 \u003c\u003c (uVar2 * 3 \u0026 0xff));\n    }\n    else {\n      uVar2 \u003d uVar2 * 3 - 0x1e;\n      hadc-\u003eInstance-\u003eSMPR1 \u003d\n           sConfig-\u003eSamplingTime \u003c\u003c (uVar2 \u0026 0xff) | hadc-\u003eInstance-\u003eSMPR1 \u0026 ~(7 \u003c\u003c (uVar2 \u0026 0xff));\n    }\n    if (sConfig-\u003eChannel - 0x10 \u003c 2) {\n      if (hadc-\u003eInstance \u003d\u003d (ADC_TypeDef *)0x40012400) {\n        if ((uRam40012408 \u0026 0x800000) \u003d\u003d 0) {\n          uRam40012408 \u003d uRam40012408 | 0x800000;\n          if (sConfig-\u003eChannel \u003d\u003d 0x10) {\n            for (wait_loop_index \u003d (SystemCoreClock / 1000000) * 10; wait_loop_index !\u003d 0;\n                wait_loop_index \u003d wait_loop_index - 1) {\n            }\n            HVar1 \u003d HAL_OK;\n          }\n          else {\n            HVar1 \u003d HAL_OK;\n          }\n        }\n        else {\n          HVar1 \u003d HAL_OK;\n        }\n      }\n      else {\n        hadc-\u003eState \u003d hadc-\u003eState | 0x20;\n        HVar1 \u003d HAL_ERROR;\n      }\n    }\n    else {\n      HVar1 \u003d HAL_OK;\n    }\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_GetState": {
      "entrypoint": "0x08003a1c",
      "current_name": "HAL_ADC_GetState",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_ADC_GetState(ADC_HandleTypeDef *hadc)\n\n{\n  return hadc-\u003eState;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ADC_Enable": {
      "entrypoint": "0x08003a20",
      "current_name": "ADC_Enable",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict ADC_Enable(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  ADC_TypeDef *pAVar4;\n  uint32_t wait_loop_index;\n  \n  pAVar4 \u003d hadc-\u003eInstance;\n  if ((pAVar4-\u003eCR2 \u0026 1) \u003d\u003d 0) {\n    pAVar4-\u003eCR2 \u003d pAVar4-\u003eCR2 | 1;\n    for (wait_loop_index \u003d SystemCoreClock / 1000000; wait_loop_index !\u003d 0;\n        wait_loop_index \u003d wait_loop_index - 1) {\n    }\n    uVar2 \u003d HAL_GetTick();\n    do {\n      if ((hadc-\u003eInstance-\u003eCR2 \u0026 1) !\u003d 0) {\n        return HAL_OK;\n      }\n      uVar3 \u003d HAL_GetTick();\n    } while (uVar3 - uVar2 \u003c 3);\n    hadc-\u003eState \u003d hadc-\u003eState | 0x10;\n    hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode | 1;\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n    HVar1 \u003d HAL_ERROR;\n  }\n  else {\n    HVar1 \u003d HAL_OK;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_Start",
        "HAL_ADCEx_Calibration_Start"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_Start": {
      "entrypoint": "0x08003aa0",
      "current_name": "HAL_ADC_Start",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_ADC_Start(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  ADC_TypeDef *pAVar2;\n  \n  if (hadc-\u003eLock !\u003d HAL_LOCKED) {\n    hadc-\u003eLock \u003d HAL_LOCKED;\n    HVar1 \u003d ADC_Enable(hadc);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      hadc-\u003eState \u003d hadc-\u003eState \u0026 0xfffffcfe | 0x100;\n      pAVar2 \u003d hadc-\u003eInstance;\n      if ((pAVar2 \u003d\u003d (ADC_TypeDef *)0x40012800) \u0026\u0026 ((_DAT_40012404 \u0026 0xf0000) !\u003d 0)) {\n        hadc-\u003eState \u003d hadc-\u003eState | 0x100000;\n        if ((_DAT_40012404 \u0026 0x400) !\u003d 0) {\n          hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffcfff | 0x1000;\n        }\n      }\n      else {\n        hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffefffff;\n        if ((pAVar2-\u003eCR1 \u0026 0x400) !\u003d 0) {\n          hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffcfff | 0x1000;\n        }\n      }\n      if ((hadc-\u003eState \u0026 0x1000) \u003d\u003d 0) {\n        hadc-\u003eErrorCode \u003d 0;\n      }\n      else {\n        hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode \u0026 0xfffffff9;\n      }\n      hadc-\u003eLock \u003d HAL_UNLOCKED;\n      pAVar2-\u003eSR \u003d 0xfffffffd;\n      pAVar2 \u003d hadc-\u003eInstance;\n      if (((pAVar2-\u003eCR2 \u0026 0xe0000) \u003d\u003d 0xe0000) \u0026\u0026\n         ((pAVar2 !\u003d (ADC_TypeDef *)0x40012800 || ((_DAT_40012404 \u0026 0xf0000) \u003d\u003d 0)))) {\n        pAVar2-\u003eCR2 \u003d pAVar2-\u003eCR2 | 0x500000;\n      }\n      else {\n        pAVar2-\u003eCR2 \u003d pAVar2-\u003eCR2 | 0x100000;\n      }\n    }\n    else {\n      hadc-\u003eLock \u003d HAL_UNLOCKED;\n    }\n    return HVar1;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_Enable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ADC_ConversionStop_Disable": {
      "entrypoint": "0x08003b8c",
      "current_name": "ADC_ConversionStop_Disable",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict ADC_ConversionStop_Disable(ADC_HandleTypeDef *hadc)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  ADC_TypeDef *pAVar3;\n  \n  pAVar3 \u003d hadc-\u003eInstance;\n  if ((pAVar3-\u003eCR2 \u0026 1) \u003d\u003d 0) {\n    return HAL_OK;\n  }\n  pAVar3-\u003eCR2 \u003d pAVar3-\u003eCR2 \u0026 0xfffffffe;\n  uVar1 \u003d HAL_GetTick();\n  do {\n    if ((hadc-\u003eInstance-\u003eCR2 \u0026 1) \u003d\u003d 0) {\n      return HAL_OK;\n    }\n    uVar2 \u003d HAL_GetTick();\n  } while (uVar2 - uVar1 \u003c 3);\n  hadc-\u003eState \u003d hadc-\u003eState | 0x10;\n  hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode | 1;\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_Stop",
        "HAL_ADC_Init",
        "HAL_ADCEx_Calibration_Start",
        "HAL_ADC_DeInit"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_Init": {
      "entrypoint": "0x08003bd8",
      "current_name": "HAL_ADC_Init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_ADC_Init(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint32_t uVar5;\n  \n  if (hadc \u003d\u003d (ADC_HandleTypeDef *)0x0) {\n    return HAL_ERROR;\n  }\n  if (hadc-\u003eState \u003d\u003d 0) {\n    hadc-\u003eErrorCode \u003d 0;\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n    HAL_ADC_MspInit(hadc);\n  }\n  HVar1 \u003d ADC_ConversionStop_Disable(hadc);\n  if (((hadc-\u003eState \u0026 0x10) \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_OK)) {\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffeefd | 2;\n    uVar5 \u003d (hadc-\u003eInit).ContinuousConvMode;\n    uVar3 \u003d (hadc-\u003eInit).DataAlign | (hadc-\u003eInit).ExternalTrigConv | uVar5 \u003c\u003c 1;\n    uVar2 \u003d (hadc-\u003eInit).ScanConvMode;\n    if (uVar2 \u003d\u003d 0x100) {\n      uVar4 \u003d 0x100;\n    }\n    else {\n      uVar4 \u003d 0;\n      if (uVar2 \u003d\u003d 1) {\n        uVar4 \u003d 0x100;\n      }\n    }\n    if ((hadc-\u003eInit).DiscontinuousConvMode \u003d\u003d 1) {\n      if (uVar5 \u003d\u003d 0) {\n        uVar4 \u003d uVar4 | ((hadc-\u003eInit).NbrOfDiscConversion - 1) * 0x2000 | 0x800;\n      }\n      else {\n        hadc-\u003eState \u003d hadc-\u003eState | 0x20;\n        hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode | 1;\n      }\n    }\n    hadc-\u003eInstance-\u003eCR1 \u003d uVar4 | hadc-\u003eInstance-\u003eCR1 \u0026 0xffff16ff;\n    hadc-\u003eInstance-\u003eCR2 \u003d hadc-\u003eInstance-\u003eCR2 \u0026 0xffe1f7fd | uVar3;\n    uVar2 \u003d (hadc-\u003eInit).ScanConvMode;\n    if ((uVar2 \u003d\u003d 0x100) || (uVar2 \u003d\u003d 1)) {\n      uVar4 \u003d ((hadc-\u003eInit).NbrOfConversion - 1) * 0x100000;\n    }\n    else {\n      uVar4 \u003d 0;\n    }\n    hadc-\u003eInstance-\u003eSQR1 \u003d uVar4 | hadc-\u003eInstance-\u003eSQR1 \u0026 0xff0fffff;\n    if (uVar3 !\u003d (hadc-\u003eInstance-\u003eCR2 \u0026 0xff1f0efe)) {\n      hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffffed | 0x10;\n      hadc-\u003eErrorCode \u003d hadc-\u003eErrorCode | 1;\n      return HAL_ERROR;\n    }\n    hadc-\u003eErrorCode \u003d 0;\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xfffffffc | 1;\n    return HAL_OK;\n  }\n  hadc-\u003eState \u003d hadc-\u003eState | 0x10;\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_ConversionStop_Disable",
        "HAL_ADC_MspInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_DeInit": {
      "entrypoint": "0x08003ce8",
      "current_name": "HAL_ADC_DeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_ADC_DeInit(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  \n  if (hadc \u003d\u003d (ADC_HandleTypeDef *)0x0) {\n    HVar1 \u003d HAL_ERROR;\n  }\n  else {\n    hadc-\u003eState \u003d hadc-\u003eState | 2;\n    HVar1 \u003d ADC_ConversionStop_Disable(hadc);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      hadc-\u003eInstance-\u003eSR \u003d 0xffffffe0;\n      hadc-\u003eInstance-\u003eCR1 \u003d hadc-\u003eInstance-\u003eCR1 \u0026 0xff3f0000;\n      hadc-\u003eInstance-\u003eCR2 \u003d hadc-\u003eInstance-\u003eCR2 \u0026 0xff0106f0;\n      hadc-\u003eInstance-\u003eSMPR1 \u003d hadc-\u003eInstance-\u003eSMPR1 \u0026 0xff000000;\n      hadc-\u003eInstance-\u003eSMPR2 \u003d hadc-\u003eInstance-\u003eSMPR2 \u0026 0xc0000000;\n      hadc-\u003eInstance-\u003eJOFR1 \u003d hadc-\u003eInstance-\u003eJOFR1 \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eJOFR2 \u003d hadc-\u003eInstance-\u003eJOFR2 \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eJOFR3 \u003d hadc-\u003eInstance-\u003eJOFR3 \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eJOFR4 \u003d hadc-\u003eInstance-\u003eJOFR4 \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eHTR \u003d hadc-\u003eInstance-\u003eHTR \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eLTR \u003d hadc-\u003eInstance-\u003eLTR \u0026 0xfffff000;\n      hadc-\u003eInstance-\u003eSQR1 \u003d hadc-\u003eInstance-\u003eSQR1 \u0026 0xff000000;\n      hadc-\u003eInstance-\u003eSQR1 \u003d hadc-\u003eInstance-\u003eSQR1 \u0026 0xff000000;\n      hadc-\u003eInstance-\u003eSQR2 \u003d hadc-\u003eInstance-\u003eSQR2 \u0026 0xc0000000;\n      hadc-\u003eInstance-\u003eSQR3 \u003d hadc-\u003eInstance-\u003eSQR3 \u0026 0xc0000000;\n      hadc-\u003eInstance-\u003eJSQR \u003d hadc-\u003eInstance-\u003eJSQR \u0026 0xffc00000;\n      hadc-\u003eInstance-\u003eJSQR \u003d hadc-\u003eInstance-\u003eJSQR \u0026 0xffc00000;\n      HAL_ADC_MspDeInit(hadc);\n      hadc-\u003eErrorCode \u003d 0;\n      hadc-\u003eState \u003d 0;\n    }\n    hadc-\u003eLock \u003d HAL_UNLOCKED;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_ConversionStop_Disable",
        "HAL_ADC_MspDeInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_Stop": {
      "entrypoint": "0x08003de4",
      "current_name": "HAL_ADC_Stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_ADC_Stop(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  \n  if (hadc-\u003eLock \u003d\u003d HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc-\u003eLock \u003d HAL_LOCKED;\n  HVar1 \u003d ADC_ConversionStop_Disable(hadc);\n  if (HVar1 \u003d\u003d HAL_OK) {\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffeefe | 1;\n  }\n  hadc-\u003eLock \u003d HAL_UNLOCKED;\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_ConversionStop_Disable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADCEx_Calibration_Start": {
      "entrypoint": "0x08003e20",
      "current_name": "HAL_ADCEx_Calibration_Start",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  ADC_TypeDef *pAVar4;\n  uint32_t tickstart;\n  uint32_t wait_loop_index;\n  \n  if (hadc-\u003eLock \u003d\u003d HAL_LOCKED) {\n    return HAL_BUSY;\n  }\n  hadc-\u003eLock \u003d HAL_LOCKED;\n  HVar1 \u003d ADC_ConversionStop_Disable(hadc);\n  if (HVar1 \u003d\u003d HAL_OK) {\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffeefd | 2;\n    uVar3 \u003d SystemCoreClock;\n    uVar2 \u003d HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (wait_loop_index \u003d uVar3 / uVar2 \u003c\u003c 1; wait_loop_index !\u003d 0;\n        wait_loop_index \u003d wait_loop_index - 1) {\n    }\n    ADC_Enable(hadc);\n    hadc-\u003eInstance-\u003eCR2 \u003d hadc-\u003eInstance-\u003eCR2 | 8;\n    uVar3 \u003d HAL_GetTick();\n    while (pAVar4 \u003d hadc-\u003eInstance, (pAVar4-\u003eCR2 \u0026 8) !\u003d 0) {\n      uVar2 \u003d HAL_GetTick();\n      if (10 \u003c uVar2 - uVar3) {\n        hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffffed | 0x10;\n        hadc-\u003eLock \u003d HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    pAVar4-\u003eCR2 \u003d pAVar4-\u003eCR2 | 4;\n    uVar3 \u003d HAL_GetTick();\n    while ((hadc-\u003eInstance-\u003eCR2 \u0026 4) !\u003d 0) {\n      uVar2 \u003d HAL_GetTick();\n      if (10 \u003c uVar2 - uVar3) {\n        hadc-\u003eState \u003d hadc-\u003eState \u0026 0xffffffed | 0x10;\n        hadc-\u003eLock \u003d HAL_UNLOCKED;\n        return HAL_ERROR;\n      }\n    }\n    hadc-\u003eState \u003d hadc-\u003eState \u0026 0xfffffffc | 1;\n  }\n  hadc-\u003eLock \u003d HAL_UNLOCKED;\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "ADC_Enable",
        "ADC_ConversionStop_Disable",
        "HAL_RCCEx_GetPeriphCLKFreq",
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_SetPriorityGrouping": {
      "entrypoint": "0x08003f0c",
      "current_name": "HAL_NVIC_SetPriorityGrouping",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  uint32_t reg_value;\n  \n  _DAT_e000ed0c \u003d (PriorityGroup \u0026 7) \u003c\u003c 8 | _DAT_e000ed0c \u0026 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "premain",
        "HAL_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_SetPriority": {
      "entrypoint": "0x08003f30",
      "current_name": "HAL_NVIC_SetPriority",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_SetPriority(IRQn_Type_conflict IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t PriorityGroupTmp;\n  uint32_t SubPriorityBits;\n  uint32_t PreemptPriorityBits;\n  \n  uVar1 \u003d (uint)IRQn;\n  uVar2 \u003d (uint)(_DAT_e000ed0c \u003c\u003c 0x15) \u003e\u003e 0x1d;\n  PreemptPriorityBits \u003d 7 - uVar2;\n  if (3 \u003c PreemptPriorityBits) {\n    PreemptPriorityBits \u003d 4;\n  }\n  if (uVar2 + 4 \u003c 7) {\n    SubPriorityBits \u003d 0;\n  }\n  else {\n    SubPriorityBits \u003d uVar2 - 3;\n  }\n  uVar2 \u003d (PreemptPriority \u0026 (1 \u003c\u003c (PreemptPriorityBits \u0026 0xff)) - 1U) \u003c\u003c (SubPriorityBits \u0026 0xff) |\n          (1 \u003c\u003c (SubPriorityBits \u0026 0xff)) - 1U \u0026 SubPriority;\n  if ((int)uVar1 \u003c 0) {\n    *(char *)((uVar1 \u0026 0xf) + 0xe000ed14) \u003d (char)(uVar2 \u003c\u003c 4);\n  }\n  else {\n    *(char *)(uVar1 + 0xe000e400) \u003d (char)(uVar2 \u003c\u003c 4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "uart_attach_rx_callback",
        "SystemClock_Config",
        "i2c_custom_init",
        "HAL_InitTick",
        "TimerPulseInit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_EnableIRQ": {
      "entrypoint": "0x08003f94",
      "current_name": "HAL_NVIC_EnableIRQ",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_EnableIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)IRQn;\n  if (-1 \u003c (int)uVar1) {\n    *(int *)((uVar1 \u003e\u003e 5) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uVar1 \u0026 0x1f);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "uart_attach_rx_callback",
        "i2c_custom_init",
        "TimerPulseInit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_DisableIRQ": {
      "entrypoint": "0x08003fb0",
      "current_name": "HAL_NVIC_DisableIRQ",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_DisableIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)IRQn;\n  if (-1 \u003c (int)uVar1) {\n    *(int *)(((uVar1 \u003e\u003e 5) + 0x20) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uVar1 \u0026 0x1f);\n    DataSynchronizationBarrier(0xf);\n    InstructionSynchronizationBarrier(0xf);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "TimerPulseDeinit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_Config": {
      "entrypoint": "0x08003fd8",
      "current_name": "HAL_SYSTICK_Config",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n\n{\n  if (TicksNumb - 1 \u003c 0x1000000) {\n    _DAT_e000e014 \u003d TicksNumb - 1;\n    DAT_e000ed23 \u003d 0xf0;\n    _DAT_e000e018 \u003d 0;\n    _DAT_e000e010 \u003d 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config",
        "HAL_InitTick"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_ClearPendingIRQ": {
      "entrypoint": "0x08004004",
      "current_name": "HAL_NVIC_ClearPendingIRQ",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)IRQn;\n  if (-1 \u003c (int)uVar1) {\n    *(int *)(((uVar1 \u003e\u003e 5) + 0x60) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uVar1 \u0026 0x1f);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "USART1_IRQHandler",
        "USART3_IRQHandler",
        "USART2_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_CLKSourceConfig": {
      "entrypoint": "0x08004024",
      "current_name": "HAL_SYSTICK_CLKSourceConfig",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n\n{\n  if (CLKSource !\u003d 4) {\n    _DAT_e000e010 \u003d _DAT_e000e010 \u0026 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 \u003d _DAT_e000e010 | 4;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_Callback": {
      "entrypoint": "0x08004044",
      "current_name": "HAL_SYSTICK_Callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_SYSTICK_Callback(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_SYSTICK_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_IRQHandler": {
      "entrypoint": "0x08004046",
      "current_name": "HAL_SYSTICK_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_SYSTICK_IRQHandler(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [
        "HAL_SYSTICK_Callback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DMA_Abort_IT": {
      "entrypoint": "0x08004050",
      "current_name": "HAL_DMA_Abort_IT",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_DMA_Abort_IT(DMA_HandleTypeDef_conflict *hdma)\n\n{\n  DMA_Channel_TypeDef_conflict *pDVar1;\n  \n  if (hdma-\u003eState !\u003d HAL_DMA_STATE_BUSY) {\n    hdma-\u003eErrorCode \u003d 4;\n    return HAL_ERROR;\n  }\n  hdma-\u003eInstance-\u003eCCR \u003d hdma-\u003eInstance-\u003eCCR \u0026 0xfffffff1;\n  hdma-\u003eInstance-\u003eCCR \u003d hdma-\u003eInstance-\u003eCCR \u0026 0xfffffffe;\n  pDVar1 \u003d hdma-\u003eInstance;\n  if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef_conflict *)0x40020008) {\n    _DAT_40020004 \u003d 1;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef_conflict *)0x4002001c) {\n    _DAT_40020004 \u003d 0x10;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef_conflict *)0x40020030) {\n    _DAT_40020004 \u003d 0x100;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef_conflict *)0x40020044) {\n    _DAT_40020004 \u003d 0x1000;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef_conflict *)0x40020058) {\n    _DAT_40020004 \u003d 0x10000;\n  }\n  else if (pDVar1 \u003d\u003d (DMA_Channel_TypeDef_conflict *)0x4002006c) {\n    _DAT_40020004 \u003d 0x100000;\n  }\n  else {\n    _DAT_40020004 \u003d 0x1000000;\n  }\n  hdma-\u003eState \u003d HAL_DMA_STATE_READY;\n  hdma-\u003eLock \u003d HAL_UNLOCKED;\n  if (hdma-\u003eXferAbortCallback !\u003d (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0) {\n    (*hdma-\u003eXferAbortCallback)(hdma);\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_ITError",
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_Init": {
      "entrypoint": "0x080040e8",
      "current_name": "HAL_GPIO_Init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_GPIO_Init(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint32_t uVar6;\n  int iVar7;\n  uint32_t *configregister;\n  int iVar8;\n  uint32_t tmpreg;\n  \n  uVar6 \u003d 0;\n  uVar4 \u003d 0;\n  do {\n    if (0xf \u003c uVar4) {\n      return;\n    }\n    uVar2 \u003d 1 \u003c\u003c (uVar4 \u0026 0xff);\n    uVar3 \u003d GPIO_Init-\u003ePin \u0026 uVar2;\n    if (uVar2 \u003d\u003d uVar3) {\n      uVar5 \u003d GPIO_Init-\u003eMode;\n      if (uVar5 \u003d\u003d 0x12) {\n        uVar6 \u003d GPIO_Init-\u003eSpeed + 0xc;\n      }\n      else if (uVar5 \u003c 0x13) {\n        if (uVar5 \u003d\u003d 2) {\n          uVar6 \u003d GPIO_Init-\u003eSpeed + 8;\n        }\n        else if (uVar5 \u003c 3) {\n          if (uVar5 \u003d\u003d 0) goto LAB_0800423a;\n          if (uVar5 \u003d\u003d 1) {\n            uVar6 \u003d GPIO_Init-\u003eSpeed;\n          }\n        }\n        else if (uVar5 \u003d\u003d 3) {\n          uVar6 \u003d 0;\n        }\n        else if (uVar5 \u003d\u003d 0x11) {\n          uVar6 \u003d GPIO_Init-\u003eSpeed + 4;\n        }\n      }\n      else if (uVar5 \u003d\u003d 0x10210000) {\nLAB_0800423a:\n        if (GPIO_Init-\u003ePull \u003d\u003d 0) {\n          uVar6 \u003d 4;\n        }\n        else if (GPIO_Init-\u003ePull \u003d\u003d 1) {\n          GPIOx-\u003eBSRR \u003d uVar2;\n          uVar6 \u003d 8;\n        }\n        else {\n          GPIOx-\u003eBRR \u003d uVar2;\n          uVar6 \u003d 8;\n        }\n      }\n      else if (uVar5 \u003c 0x10210001) {\n        if ((uVar5 \u003d\u003d 0x10110000) || (uVar5 \u003d\u003d 0x10120000)) goto LAB_0800423a;\n      }\n      else if ((uVar5 \u003d\u003d 0x10310000) || ((uVar5 \u003d\u003d 0x10320000 || (uVar5 \u003d\u003d 0x10220000))))\n      goto LAB_0800423a;\n      uVar2 \u003d uVar4;\n      pGVar1 \u003d GPIOx;\n      if (0xff \u003c uVar3) {\n        uVar2 \u003d uVar4 - 8;\n        pGVar1 \u003d (GPIO_TypeDef *)\u0026GPIOx-\u003eCRH;\n      }\n      pGVar1-\u003eCRL \u003d pGVar1-\u003eCRL \u0026 ~(0xf \u003c\u003c (uVar2 \u003c\u003c 2 \u0026 0xff)) | uVar6 \u003c\u003c (uVar2 \u003c\u003c 2 \u0026 0xff);\n      if ((GPIO_Init-\u003eMode \u0026 0x10000000) !\u003d 0) {\n        _DAT_40021018 \u003d _DAT_40021018 | 1;\n        iVar7 \u003d (uVar4 \u0026 3) \u003c\u003c 2;\n        if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40010800) {\n          iVar8 \u003d 0;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40010c00) {\n          iVar8 \u003d 1;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40011000) {\n          iVar8 \u003d 2;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40011400) {\n          iVar8 \u003d 3;\n        }\n        else {\n          iVar8 \u003d 4;\n        }\n        *(uint *)(((uVar4 \u003e\u003e 2) + 2) * 4 + 0x40010000) \u003d\n             *(uint *)(((uVar4 \u003e\u003e 2) + 2) * 4 + 0x40010000) \u0026 ~(0xf \u003c\u003c iVar7) | iVar8 \u003c\u003c iVar7;\n        if ((GPIO_Init-\u003eMode \u0026 0x10000) \u003d\u003d 0) {\n          _DAT_40010400 \u003d _DAT_40010400 \u0026 ~uVar3;\n        }\n        else {\n          _DAT_40010400 \u003d _DAT_40010400 | uVar3;\n        }\n        if ((GPIO_Init-\u003eMode \u0026 0x20000) \u003d\u003d 0) {\n          _DAT_40010404 \u003d _DAT_40010404 \u0026 ~uVar3;\n        }\n        else {\n          _DAT_40010404 \u003d _DAT_40010404 | uVar3;\n        }\n        if ((GPIO_Init-\u003eMode \u0026 0x100000) \u003d\u003d 0) {\n          _DAT_40010408 \u003d _DAT_40010408 \u0026 ~uVar3;\n        }\n        else {\n          _DAT_40010408 \u003d _DAT_40010408 | uVar3;\n        }\n        if ((GPIO_Init-\u003eMode \u0026 0x200000) \u003d\u003d 0) {\n          _DAT_4001040c \u003d _DAT_4001040c \u0026 ~uVar3;\n        }\n        else {\n          _DAT_4001040c \u003d uVar3 | _DAT_4001040c;\n        }\n      }\n    }\n    uVar4 \u003d uVar4 + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_init",
        "HAL_TIM_PWM_MspInit",
        "HAL_ADC_MspInit",
        "i2c_custom_init",
        "uart_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_ReadPin": {
      "entrypoint": "0x080042d4",
      "current_name": "HAL_GPIO_ReadPin",
      "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin)\n\n{\n  GPIO_PinState bitstatus;\n  \n  if (((uint)GPIO_Pin \u0026 GPIOx-\u003eIDR) \u003d\u003d 0) {\n    bitstatus \u003d GPIO_PIN_RESET;\n    return bitstatus;\n  }\n  return GPIO_PIN_SET;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_read"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_WritePin": {
      "entrypoint": "0x080042e2",
      "current_name": "HAL_GPIO_WritePin",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin,GPIO_PinState PinState)\n\n{\n  if (PinState \u003d\u003d GPIO_PIN_RESET) {\n    GPIOx-\u003eBSRR \u003d (uint)GPIO_Pin \u003c\u003c 0x10;\n    return;\n  }\n  GPIOx-\u003eBSRR \u003d (uint)GPIO_Pin;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_EXTI_IRQHandler": {
      "entrypoint": "0x080042f0",
      "current_name": "HAL_GPIO_EXTI_IRQHandler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n\n{\n  if ((_DAT_40010414 \u0026 GPIO_Pin) !\u003d 0) {\n    _DAT_40010414 \u003d (uint)GPIO_Pin;\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "EXTI9_5_IRQHandler",
        "EXTI4_IRQHandler",
        "EXTI3_IRQHandler",
        "EXTI1_IRQHandler",
        "EXTI2_IRQHandler",
        "EXTI0_IRQHandler",
        "EXTI15_10_IRQHandler"
      ],
      "called": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Master_SB": {
      "entrypoint": "0x0800430c",
      "current_name": "I2C_Master_SB",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_Master_SB(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n    if (hi2c-\u003eEventCount \u003d\u003d 0) {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xfe;\n    }\n    else {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff | 1;\n    }\n  }\n  else if ((hi2c-\u003eInit).AddressingMode \u003d\u003d 0x4000) {\n    if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xfe;\n    }\n    else {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff | 1;\n    }\n  }\n  else if (hi2c-\u003eEventCount \u003d\u003d 0) {\n    hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eDevaddress \u003c\u003c 0x10) \u003e\u003e 0x17 \u0026 6 | 0xf0;\n  }\n  else if (hi2c-\u003eEventCount \u003d\u003d 1) {\n    hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eDevaddress \u003c\u003c 0x10) \u003e\u003e 0x17 \u0026 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Master_ADD10": {
      "entrypoint": "0x08004396",
      "current_name": "I2C_Master_ADD10",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_Master_ADD10(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Master_ADDR": {
      "entrypoint": "0x080043a2",
      "current_name": "I2C_Master_ADDR",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_Master_ADDR(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint32_t CurrentXferOptions;\n  uint32_t uVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t Prev_State;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  \n  uVar1 \u003d hi2c-\u003eXferOptions;\n  if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) \u0026\u0026\n     ((hi2c-\u003eEventCount !\u003d 0 || (hi2c-\u003eMode !\u003d HAL_I2C_MODE_MEM)))) {\n    if ((hi2c-\u003eEventCount \u003d\u003d 0) \u0026\u0026 ((hi2c-\u003eInit).AddressingMode \u003d\u003d 0xc000)) {\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n      hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n    }\n    else {\n      if (hi2c-\u003eXferCount \u003d\u003d 0) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      }\n      else if (hi2c-\u003eXferCount \u003d\u003d 1) {\n        if (uVar1 \u003d\u003d 0xffff0000) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          pIVar2 \u003d hi2c-\u003eInstance;\n          if ((pIVar2-\u003eCR2 \u0026 0x800) \u003d\u003d 0) {\n            pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 0x200;\n          }\n          else {\n            pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 \u0026 0xfffffbff;\n          }\n        }\n        else if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (hi2c-\u003ePreviousState \u003d\u003d 0x12)) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n        }\n        else if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n        }\n      }\n      else if (hi2c-\u003eXferCount \u003d\u003d 2) {\n        if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x800;\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n        }\n        pIVar2 \u003d hi2c-\u003eInstance;\n        if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n          pIVar2-\u003eCR2 \u003d pIVar2-\u003eCR2 | 0x1000;\n        }\n      }\n      else {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        pIVar2 \u003d hi2c-\u003eInstance;\n        if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n          pIVar2-\u003eCR2 \u003d pIVar2-\u003eCR2 | 0x1000;\n        }\n      }\n      hi2c-\u003eEventCount \u003d 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_SlaveTransmit_BTF": {
      "entrypoint": "0x0800457c",
      "current_name": "I2C_SlaveTransmit_BTF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_SlaveTransmit_BTF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  byte *pbVar1;\n  \n  if (hi2c-\u003eXferCount !\u003d 0) {\n    pbVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d pbVar1 + 1;\n    hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar1;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_SlaveReceive_BTF": {
      "entrypoint": "0x0800459c",
      "current_name": "I2C_SlaveReceive_BTF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_SlaveReceive_BTF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c-\u003eXferCount !\u003d 0) {\n    puVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n    *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MspInit": {
      "entrypoint": "0x080045bc",
      "current_name": "HAL_I2C_MspInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MspInit(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_Init": {
      "entrypoint": "0x080045c0",
      "current_name": "HAL_I2C_Init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_I2C_Init(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  bool bVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint32_t uVar5;\n  \n  if (hi2c \u003d\u003d (I2C_HandleTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_RESET) {\n    hi2c-\u003eLock \u003d HAL_UNLOCKED;\n    HAL_I2C_MspInit(hi2c);\n  }\n  hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY;\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n  uVar2 \u003d HAL_RCC_GetPCLK1Freq();\n  if ((hi2c-\u003eInit).ClockSpeed \u003c 0x186a1) {\n    if (uVar2 \u003c 2000000) {\n      bVar1 \u003d true;\n    }\n    else {\n      bVar1 \u003d false;\n    }\n  }\n  else {\n    bVar1 \u003d uVar2 \u003c 4000000;\n  }\n  if (bVar1) {\n    return HAL_ERROR;\n  }\n  uVar3 \u003d uVar2 / 1000000;\n  hi2c-\u003eInstance-\u003eCR2 \u003d uVar3;\n  if (100000 \u003c (hi2c-\u003eInit).ClockSpeed) {\n    uVar3 \u003d (uVar3 * 300) / 1000;\n  }\n  hi2c-\u003eInstance-\u003eTRISE \u003d uVar3 + 1;\n  uVar3 \u003d (hi2c-\u003eInit).ClockSpeed;\n  if (uVar3 \u003c 0x186a1) {\n    uVar2 \u003d (uVar2 - 1) / (uVar3 \u003c\u003c 1) + 1 \u0026 0xfff;\n    if (uVar2 \u003c 4) {\n      uVar2 \u003d 4;\n    }\n  }\n  else {\n    uVar5 \u003d (hi2c-\u003eInit).DutyCycle;\n    if (uVar5 \u003d\u003d 0) {\n      uVar4 \u003d (uVar2 - 1) / (uVar3 * 3);\n    }\n    else {\n      uVar4 \u003d (uVar2 - 1) / (uVar3 * 0x19);\n    }\n    if ((uVar4 + 1 \u0026 0xfff) \u003d\u003d 0) {\n      uVar2 \u003d 1;\n    }\n    else if (uVar5 \u003d\u003d 0) {\n      uVar2 \u003d (uVar2 - 1) / (uVar3 * 3) + 1 \u0026 0xfff | 0x8000;\n    }\n    else {\n      uVar2 \u003d (uVar2 - 1) / (uVar3 * 0x19) + 1 \u0026 0xfff | 0xc000;\n    }\n  }\n  hi2c-\u003eInstance-\u003eCCR \u003d uVar2;\n  hi2c-\u003eInstance-\u003eCR1 \u003d (hi2c-\u003eInit).GeneralCallMode | (hi2c-\u003eInit).NoStretchMode;\n  hi2c-\u003eInstance-\u003eOAR1 \u003d (hi2c-\u003eInit).AddressingMode | (hi2c-\u003eInit).OwnAddress1;\n  hi2c-\u003eInstance-\u003eOAR2 \u003d (hi2c-\u003eInit).DualAddressMode | (hi2c-\u003eInit).OwnAddress2;\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 1;\n  hi2c-\u003eErrorCode \u003d 0;\n  hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n  hi2c-\u003ePreviousState \u003d 0;\n  hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "i2c_custom_init"
      ],
      "called": [
        "HAL_RCC_GetPCLK1Freq",
        "HAL_I2C_MspInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_Master_Transmit_IT": {
      "entrypoint": "0x08004728",
      "current_name": "HAL_I2C_Master_Transmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_I2C_Master_Transmit_IT\n          (I2C_HandleTypeDef_conflict *hi2c,uint16_t DevAddress,uint8_t *pData,uint16_t Size)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t count;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_READY) {\n    count \u003d (SystemCoreClock / 25000) * 0x19;\n    do {\n      if (count \u003d\u003d 0) {\n        hi2c-\u003ePreviousState \u003d 0;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        hi2c-\u003eLock \u003d HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      pIVar2 \u003d hi2c-\u003eInstance;\n      count \u003d count - 1;\n    } while ((pIVar2-\u003eSR2 \u0026 2) !\u003d 0);\n    if (hi2c-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      hi2c-\u003eLock \u003d HAL_LOCKED;\n      if ((pIVar2-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n        pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 1;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY_TX;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_MASTER;\n      HVar1 \u003d HAL_OK;\n      hi2c-\u003eErrorCode \u003d 0;\n      hi2c-\u003epBuffPtr \u003d pData;\n      hi2c-\u003eXferCount \u003d Size;\n      hi2c-\u003eXferOptions \u003d 0xffff0000;\n      hi2c-\u003eXferSize \u003d hi2c-\u003eXferCount;\n      hi2c-\u003eDevaddress \u003d (uint)DevAddress;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n      hi2c-\u003eLock \u003d HAL_UNLOCKED;\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "i2c_master_write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_Master_Receive_IT": {
      "entrypoint": "0x080047f4",
      "current_name": "HAL_I2C_Master_Receive_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_I2C_Master_Receive_IT\n          (I2C_HandleTypeDef_conflict *hi2c,uint16_t DevAddress,uint8_t *pData,uint16_t Size)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t count;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_READY) {\n    count \u003d (SystemCoreClock / 25000) * 0x19;\n    do {\n      if (count \u003d\u003d 0) {\n        hi2c-\u003ePreviousState \u003d 0;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        hi2c-\u003eLock \u003d HAL_UNLOCKED;\n        return HAL_TIMEOUT;\n      }\n      pIVar2 \u003d hi2c-\u003eInstance;\n      count \u003d count - 1;\n    } while ((pIVar2-\u003eSR2 \u0026 2) !\u003d 0);\n    if (hi2c-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      hi2c-\u003eLock \u003d HAL_LOCKED;\n      if ((pIVar2-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n        pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 1;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY_RX;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_MASTER;\n      HVar1 \u003d HAL_OK;\n      hi2c-\u003eErrorCode \u003d 0;\n      hi2c-\u003epBuffPtr \u003d pData;\n      hi2c-\u003eXferCount \u003d Size;\n      hi2c-\u003eXferOptions \u003d 0xffff0000;\n      hi2c-\u003eXferSize \u003d hi2c-\u003eXferCount;\n      hi2c-\u003eDevaddress \u003d (uint)DevAddress;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n      hi2c-\u003eLock \u003d HAL_UNLOCKED;\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "i2c_master_read"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_Slave_Sequential_Transmit_IT": {
      "entrypoint": "0x080048c8",
      "current_name": "HAL_I2C_Slave_Sequential_Transmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_I2C_Slave_Sequential_Transmit_IT\n          (I2C_HandleTypeDef_conflict *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (hi2c-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      hi2c-\u003eLock \u003d HAL_LOCKED;\n      pIVar2 \u003d hi2c-\u003eInstance;\n      if ((pIVar2-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n        pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 1;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY_TX_LISTEN;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_SLAVE;\n      HVar1 \u003d HAL_OK;\n      hi2c-\u003eErrorCode \u003d 0;\n      hi2c-\u003epBuffPtr \u003d pData;\n      hi2c-\u003eXferCount \u003d Size;\n      hi2c-\u003eXferOptions \u003d XferOptions;\n      hi2c-\u003eXferSize \u003d hi2c-\u003eXferCount;\n      hi2c-\u003eLock \u003d HAL_UNLOCKED;\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_AddrCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_Slave_Sequential_Receive_IT": {
      "entrypoint": "0x08004954",
      "current_name": "HAL_I2C_Slave_Sequential_Receive_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_I2C_Slave_Sequential_Receive_IT\n          (I2C_HandleTypeDef_conflict *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (hi2c-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      hi2c-\u003eLock \u003d HAL_LOCKED;\n      pIVar2 \u003d hi2c-\u003eInstance;\n      if ((pIVar2-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n        pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 1;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY_RX_LISTEN;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_SLAVE;\n      HVar1 \u003d HAL_OK;\n      hi2c-\u003eErrorCode \u003d 0;\n      hi2c-\u003epBuffPtr \u003d pData;\n      hi2c-\u003eXferCount \u003d Size;\n      hi2c-\u003eXferOptions \u003d XferOptions;\n      hi2c-\u003eXferSize \u003d hi2c-\u003eXferCount;\n      hi2c-\u003eLock \u003d HAL_UNLOCKED;\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_AddrCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_EnableListen_IT": {
      "entrypoint": "0x080049e0",
      "current_name": "HAL_I2C_EnableListen_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_I2C_EnableListen_IT(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  I2C_TypeDef_conflict *pIVar1;\n  \n  if (hi2c-\u003eState !\u003d HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n  pIVar1 \u003d hi2c-\u003eInstance;\n  if ((pIVar1-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n    pIVar1-\u003eCR1 \u003d pIVar1-\u003eCR1 | 1;\n  }\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n  hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x300;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "i2c_attachSlaveRxEvent",
        "i2c_attachSlaveTxEvent",
        "HAL_I2C_ErrorCallback",
        "HAL_I2C_ListenCpltCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MasterTxCpltCallback": {
      "entrypoint": "0x08004a1e",
      "current_name": "HAL_I2C_MasterTxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterTransmit_TXE",
        "I2C_MasterTransmit_BTF"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MasterRxCpltCallback": {
      "entrypoint": "0x08004a20",
      "current_name": "HAL_I2C_MasterRxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterReceive_BTF",
        "I2C_MasterReceive_RXNE"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_SlaveTxCpltCallback": {
      "entrypoint": "0x08004a22",
      "current_name": "HAL_I2C_SlaveTxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_SlaveTransmit_TXE",
        "I2C_Slave_AF"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_SlaveTransmit_TXE": {
      "entrypoint": "0x08004a24",
      "current_name": "I2C_SlaveTransmit_TXE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_SlaveTransmit_TXE(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  byte *pbVar2;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    pbVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n    hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    if ((hi2c-\u003eXferCount \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      hi2c-\u003ePreviousState \u003d 0x21;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveTxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_SlaveRxCpltCallback": {
      "entrypoint": "0x08004a74",
      "current_name": "HAL_I2C_SlaveRxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_Slave_STOPF",
        "I2C_SlaveReceive_RXNE"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_SlaveReceive_RXNE": {
      "entrypoint": "0x08004a76",
      "current_name": "I2C_SlaveReceive_RXNE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_SlaveReceive_RXNE(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  uint8_t *puVar2;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    if ((hi2c-\u003eXferCount \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      hi2c-\u003ePreviousState \u003d 0x22;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveRxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Slave_ADDR": {
      "entrypoint": "0x08004ac2",
      "current_name": "I2C_Slave_ADDR",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_Slave_ADDR(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint16_t AddrMatchCode;\n  \n  if ((hi2c-\u003eInstance-\u003eSR2 \u0026 0x80) \u003d\u003d 0) {\n    AddrMatchCode \u003d *(uint16_t *)\u0026(hi2c-\u003eInit).OwnAddress1;\n  }\n  else {\n    AddrMatchCode \u003d *(uint16_t *)\u0026(hi2c-\u003eInit).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(hi2c,(hi2c-\u003eInstance-\u003eSR2 \u0026 4) \u003d\u003d 0,AddrMatchCode);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_AddrCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Slave_AF": {
      "entrypoint": "0x08004aec",
      "current_name": "I2C_Slave_AF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_Slave_AF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint32_t CurrentXferOptions;\n  uint32_t CurrentState;\n  \n  if (((hi2c-\u003eXferOptions \u003d\u003d 4) || (hi2c-\u003eXferOptions \u003d\u003d 8)) \u0026\u0026\n     (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN)) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  else if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003ePreviousState \u003d 0x21;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\n  }\n  else {\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveTxCpltCallback",
        "HAL_I2C_ListenCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MemTxCpltCallback": {
      "entrypoint": "0x08004b80",
      "current_name": "HAL_I2C_MemTxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterTransmit_TXE",
        "I2C_MasterTransmit_BTF"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_MasterTransmit_TXE": {
      "entrypoint": "0x08004b82",
      "current_name": "I2C_MasterTransmit_TXE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_MasterTransmit_TXE(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  uint32_t CurrentState;\n  byte *pbVar2;\n  uint32_t CurrentXferOptions;\n  uint32_t uVar3;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  uVar3 \u003d hi2c-\u003eXferOptions;\n  if ((hi2c-\u003eXferSize \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX)) {\n    if ((uVar3 \u003d\u003d 4) || ((uVar3 \u003d\u003d 8 || (uVar3 \u003d\u003d 0xffff0000)))) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(hi2c);\n      }\n      else {\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n      hi2c-\u003ePreviousState \u003d 0x11;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(hi2c);\n    }\n  }\n  else if ((HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX) ||\n          ((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX)))) {\n    if (hi2c-\u003eXferCount \u003d\u003d 0) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n    }\n    else if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n      if (hi2c-\u003eEventCount \u003d\u003d 0) {\n        if (hi2c-\u003eMemaddSize \u003d\u003d 1) {\n          hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eMemaddress \u0026 0xff;\n          hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 2;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eMemaddress \u003c\u003c 0x10) \u003e\u003e 0x18;\n          hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n        }\n      }\n      else if (hi2c-\u003eEventCount \u003d\u003d 1) {\n        hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eMemaddress \u0026 0xff;\n        hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n      }\n      else if (hi2c-\u003eEventCount \u003d\u003d 2) {\n        if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n        }\n        else if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n          pbVar2 \u003d hi2c-\u003epBuffPtr;\n          hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n          hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n          hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n        }\n      }\n    }\n    else {\n      pbVar2 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n      hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MemTxCpltCallback",
        "HAL_I2C_MasterTxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_MasterTransmit_BTF": {
      "entrypoint": "0x08004ccc",
      "current_name": "I2C_MasterTransmit_BTF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_MasterTransmit_BTF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint32_t uVar1;\n  uint32_t CurrentXferOptions;\n  byte *pbVar2;\n  \n  uVar1 \u003d hi2c-\u003eXferOptions;\n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n    if (hi2c-\u003eXferCount \u003d\u003d 0) {\n      if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (uVar1 \u003d\u003d 0xffff0000)) {\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n        hi2c-\u003ePreviousState \u003d 0;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(hi2c);\n        }\n        else {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(hi2c);\n        }\n      }\n      else {\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        hi2c-\u003ePreviousState \u003d 0x11;\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      pbVar2 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n      hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MemTxCpltCallback",
        "HAL_I2C_MasterTxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MemRxCpltCallback": {
      "entrypoint": "0x08004d6a",
      "current_name": "HAL_I2C_MemRxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterReceive_BTF",
        "I2C_MasterReceive_RXNE"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_MasterReceive_RXNE": {
      "entrypoint": "0x08004d6c",
      "current_name": "I2C_MasterReceive_RXNE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_MasterReceive_RXNE(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) {\n    if (hi2c-\u003eXferCount \u003c 4) {\n      if (hi2c-\u003eXferCount - 2 \u003c 2) {\n        if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x800;\n        }\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      }\n      else {\n        if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n        }\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        puVar1 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n        *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n        hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        hi2c-\u003ePreviousState \u003d 0;\n        if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n      }\n    }\n    else {\n      puVar1 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n      *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MasterRxCpltCallback",
        "HAL_I2C_MemRxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_MasterReceive_BTF": {
      "entrypoint": "0x08004e3c",
      "current_name": "I2C_MasterReceive_BTF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_MasterReceive_BTF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  uint32_t uVar1;\n  uint32_t CurrentXferOptions;\n  uint8_t *puVar2;\n  \n  uVar1 \u003d hi2c-\u003eXferOptions;\n  if (hi2c-\u003eXferCount \u003d\u003d 3) {\n    if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (uVar1 \u003d\u003d 0xffff0000)) {\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    }\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  else if (hi2c-\u003eXferCount \u003d\u003d 2) {\n    if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (uVar1 \u003d\u003d 0xffff0000)) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffcff;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n    }\n    else {\n      if (uVar1 \u003d\u003d 2) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n      }\n      else {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n      }\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffcff;\n    }\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003ePreviousState \u003d 0;\n    if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(hi2c);\n    }\n    else {\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MasterRxCpltCallback",
        "HAL_I2C_MemRxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_AbortCpltCallback": {
      "entrypoint": "0x08004f3a",
      "current_name": "HAL_I2C_AbortCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_ITError",
        "I2C_DMAAbort"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_ITError": {
      "entrypoint": "0x08004f3c",
      "current_name": "I2C_ITError",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C_ITError(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint8_t *puVar2;\n  I2C_TypeDef_conflict *pIVar3;\n  \n  if (hi2c-\u003eState - 0x29 \u003c 2) {\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((hi2c-\u003eState !\u003d HAL_I2C_STATE_ABORT) \u0026\u0026 ((hi2c-\u003eInstance-\u003eCR2 \u0026 0x800) \u003d\u003d 0)) {\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    }\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n  }\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n  pIVar3 \u003d hi2c-\u003eInstance;\n  if ((pIVar3-\u003eCR2 \u0026 0x800) \u003d\u003d 0) {\n    if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_ABORT) {\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eErrorCode \u003d 0;\n      if ((pIVar3-\u003eSR1 \u0026 0x40) !\u003d 0) {\n        puVar2 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n        *puVar2 \u003d (uint8_t)pIVar3-\u003eDR;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(hi2c);\n    }\n    else {\n      if ((pIVar3-\u003eSR1 \u0026 0x40) !\u003d 0) {\n        puVar2 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n        *puVar2 \u003d (uint8_t)pIVar3-\u003eDR;\n      }\n      HAL_I2C_ErrorCallback(hi2c);\n    }\n  }\n  else {\n    pIVar3-\u003eCR2 \u003d pIVar3-\u003eCR2 \u0026 0xfffff7ff;\n    if (hi2c-\u003ehdmatx-\u003eState \u003d\u003d HAL_DMA_STATE_READY) {\n      hi2c-\u003ehdmarx-\u003eXferAbortCallback \u003d I2C_DMAAbort + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(hi2c-\u003ehdmarx);\n      if (HVar1 !\u003d HAL_OK) {\n        if ((hi2c-\u003eInstance-\u003eSR1 \u0026 0x40) !\u003d 0) {\n          puVar2 \u003d hi2c-\u003epBuffPtr;\n          hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n          *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n        }\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        (*hi2c-\u003ehdmarx-\u003eXferAbortCallback)(hi2c-\u003ehdmarx);\n      }\n    }\n    else {\n      hi2c-\u003ehdmatx-\u003eXferAbortCallback \u003d I2C_DMAAbort + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(hi2c-\u003ehdmatx);\n      if (HVar1 !\u003d HAL_OK) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        (*hi2c-\u003ehdmatx-\u003eXferAbortCallback)(hi2c-\u003ehdmatx);\n      }\n    }\n  }\n  if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) \u0026\u0026 ((hi2c-\u003eErrorCode \u0026 4) !\u003d 0)) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_Slave_STOPF",
        "HAL_I2C_ER_IRQHandler"
      ],
      "called": [
        "HAL_I2C_ErrorCallback",
        "HAL_I2C_AbortCpltCallback",
        "HAL_I2C_ListenCpltCallback",
        "HAL_DMA_Abort_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Slave_STOPF": {
      "entrypoint": "0x08005084",
      "current_name": "I2C_Slave_STOPF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict I2C_Slave_STOPF(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint8_t *puVar3;\n  uint32_t CurrentState;\n  uint32_t tmpreg;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 1;\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n  pIVar2 \u003d hi2c-\u003eInstance;\n  if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n    if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) || (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c-\u003eXferCount \u003d (uint16_t)hi2c-\u003ehdmarx-\u003eInstance-\u003eCNDTR;\n    }\n    else {\n      hi2c-\u003eXferCount \u003d (uint16_t)hi2c-\u003ehdmatx-\u003eInstance-\u003eCNDTR;\n    }\n  }\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    if ((pIVar2-\u003eSR1 \u0026 4) !\u003d 0) {\n      puVar3 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar3 + 1;\n      *puVar3 \u003d (uint8_t)pIVar2-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n    if ((hi2c-\u003eInstance-\u003eSR1 \u0026 0x40) !\u003d 0) {\n      puVar3 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar3 + 1;\n      *puVar3 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 4;\n  }\n  if (hi2c-\u003eErrorCode \u003d\u003d 0) {\n    if (((HVar1 \u003d\u003d HAL_I2C_STATE_LISTEN) || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c-\u003eXferOptions \u003d 0xffff0000;\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if ((hi2c-\u003ePreviousState \u003d\u003d 0x22) || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX)) {\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    I2C_ITError(hi2c);\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "I2C_ITError",
        "HAL_I2C_ListenCpltCallback",
        "HAL_I2C_SlaveRxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_EV_IRQHandler": {
      "entrypoint": "0x08005188",
      "current_name": "HAL_I2C_EV_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  I2C_TypeDef_conflict *pIVar1;\n  uint32_t CurrentMode;\n  uint uVar2;\n  uint32_t sr1itflags;\n  uint uVar3;\n  uint32_t itsources;\n  uint uVar4;\n  uint32_t sr2itflags;\n  \n  pIVar1 \u003d hi2c-\u003eInstance;\n  uVar4 \u003d pIVar1-\u003eSR2;\n  uVar2 \u003d pIVar1-\u003eSR1;\n  uVar3 \u003d pIVar1-\u003eCR2;\n  if ((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MASTER) || (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM)) {\n    if (((uVar2 \u0026 0x10001) \u003d\u003d 0) || ((uVar3 \u0026 0x200) \u003d\u003d 0)) {\n      if (((uVar2 \u0026 0x10008) \u003d\u003d 0) || ((uVar3 \u0026 0x200) \u003d\u003d 0)) {\n        if (((uVar2 \u0026 0x10002) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n          I2C_Master_ADDR(hi2c);\n        }\n      }\n      else {\n        I2C_Master_ADD10(hi2c);\n      }\n    }\n    else {\n      I2C_Master_SB(hi2c);\n    }\n    if ((uVar4 \u0026 0x100004) \u003d\u003d 0) {\n      if ((((uVar2 \u0026 0x10040) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_MasterReceive_RXNE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_MasterReceive_BTF(hi2c);\n        return;\n      }\n    }\n    else {\n      if ((((uVar2 \u0026 0x10080) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_MasterTransmit_TXE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_MasterTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  else {\n    if (((uVar2 \u0026 0x10002) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n      I2C_Slave_ADDR(hi2c);\n      return;\n    }\n    if (((uVar2 \u0026 0x10010) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n      I2C_Slave_STOPF(hi2c);\n      return;\n    }\n    if ((uVar4 \u0026 0x100004) \u003d\u003d 0) {\n      if ((((uVar2 \u0026 0x10040) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_SlaveReceive_RXNE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_SlaveReceive_BTF(hi2c);\n      }\n    }\n    else {\n      if ((((uVar2 \u0026 0x10080) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_SlaveTransmit_TXE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_SlaveTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C1_EV_IRQHandler",
        "I2C2_EV_IRQHandler"
      ],
      "called": [
        "I2C_Slave_STOPF",
        "I2C_MasterReceive_BTF",
        "I2C_MasterTransmit_TXE",
        "I2C_Master_ADDR",
        "I2C_SlaveTransmit_TXE",
        "I2C_SlaveReceive_RXNE",
        "I2C_SlaveTransmit_BTF",
        "I2C_MasterTransmit_BTF",
        "I2C_MasterReceive_RXNE",
        "I2C_SlaveReceive_BTF",
        "I2C_Slave_ADDR",
        "I2C_Master_ADD10",
        "I2C_Master_SB"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_ER_IRQHandler": {
      "entrypoint": "0x080052f0",
      "current_name": "HAL_I2C_ER_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  I2C_TypeDef_conflict *pIVar2;\n  uint32_t sr1itflags;\n  uint uVar3;\n  uint32_t itsources;\n  uint uVar4;\n  \n  pIVar2 \u003d hi2c-\u003eInstance;\n  uVar3 \u003d pIVar2-\u003eSR1;\n  uVar4 \u003d pIVar2-\u003eCR2;\n  if (((uVar3 \u0026 0x10100) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 1;\n    pIVar2-\u003eSR1 \u003d 0xfffffeff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x8000;\n  }\n  if (((uVar3 \u0026 0x10200) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 2;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffdff;\n  }\n  if (((uVar3 \u0026 0x10400) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    HVar1 \u003d hi2c-\u003eState;\n    if (((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_SLAVE) \u0026\u0026 (hi2c-\u003eXferCount \u003d\u003d 0)) \u0026\u0026\n       (((HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((HVar1 \u003d\u003d HAL_I2C_STATE_LISTEN \u0026\u0026 (hi2c-\u003ePreviousState \u003d\u003d 0x21)))))) {\n      I2C_Slave_AF(hi2c);\n    }\n    else {\n      hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 4;\n      if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MASTER) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      }\n      hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    }\n  }\n  if (((uVar3 \u0026 0x10800) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 8;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffff7ff;\n  }\n  if (hi2c-\u003eErrorCode !\u003d 0) {\n    I2C_ITError(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C1_ER_IRQHandler",
        "I2C2_ER_IRQHandler"
      ],
      "called": [
        "I2C_ITError",
        "I2C_Slave_AF"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_DMAAbort": {
      "entrypoint": "0x080053cc",
      "current_name": "I2C_DMAAbort",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C_DMAAbort(DMA_HandleTypeDef_conflict *hdma)\n\n{\n  I2C_HandleTypeDef_conflict *hi2c_00;\n  I2C_HandleTypeDef_conflict *hi2c;\n  \n  hi2c_00 \u003d (I2C_HandleTypeDef_conflict *)hdma-\u003eParent;\n  hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n  hi2c_00-\u003eXferCount \u003d 0;\n  hi2c_00-\u003ehdmatx-\u003eXferAbortCallback \u003d (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  hi2c_00-\u003ehdmarx-\u003eXferAbortCallback \u003d (_func_void___DMA_HandleTypeDef_ptr_conflict *)0x0;\n  if (hi2c_00-\u003eState !\u003d HAL_I2C_STATE_ABORT) {\n    hi2c_00-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c_00-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n    HAL_I2C_ErrorCallback(hi2c_00);\n    return;\n  }\n  hi2c_00-\u003eState \u003d HAL_I2C_STATE_READY;\n  hi2c_00-\u003eMode \u003d HAL_I2C_MODE_NONE;\n  hi2c_00-\u003eErrorCode \u003d 0;\n  hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(hi2c_00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ErrorCallback",
        "HAL_I2C_AbortCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_GetState": {
      "entrypoint": "0x0800542a",
      "current_name": "HAL_I2C_GetState",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_I2C_StateTypeDef_conflict HAL_I2C_GetState(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return hi2c-\u003eState;\n}\n\n",
      "renaming": {},
      "calling": [
        "i2c_master_read",
        "i2c_master_write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_GetError": {
      "entrypoint": "0x08005430",
      "current_name": "HAL_I2C_GetError",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_I2C_GetError(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return hi2c-\u003eErrorCode;\n}\n\n",
      "renaming": {},
      "calling": [
        "i2c_master_read",
        "i2c_master_write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "RCC_Delay": {
      "entrypoint": "0x08005434",
      "current_name": "RCC_Delay",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid RCC_Delay(uint32_t mdelay)\n\n{\n  bool bVar1;\n  uint32_t Delay;\n  \n  Delay \u003d mdelay * (SystemCoreClock / 8000);\n  do {\n    bVar1 \u003d Delay !\u003d 0;\n    Delay \u003d Delay - 1;\n  } while (bVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_OscConfig"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_OscConfig": {
      "entrypoint": "0x08005460",
      "current_name": "HAL_RCC_OscConfig",
      "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_RCC_OscConfig(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  bool bVar4;\n  uint32_t tmpreg;\n  \n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 1) !\u003d 0) {\n    if (((_DAT_40021004 \u0026 0xc) \u003d\u003d 4) ||\n       (((_DAT_40021004 \u0026 0xc) \u003d\u003d 8 \u0026\u0026 ((_DAT_40021004 \u0026 0x10000) !\u003d 0)))) {\n      if (((_DAT_40021000 \u0026 0x20000) !\u003d 0) \u0026\u0026 (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      uVar3 \u003d RCC_OscInitStruct-\u003eHSEState;\n      if (uVar3 \u003d\u003d 0x10000) {\n        _DAT_40021000 \u003d _DAT_40021000 | 0x10000;\n      }\n      else if (uVar3 \u003d\u003d 0) {\n        _DAT_40021000 \u003d _DAT_40021000 \u0026 0xfffaffff;\n      }\n      else if (uVar3 \u003d\u003d 0x50000) {\n        _DAT_40021000 \u003d _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 \u003d _DAT_40021000 \u0026 0xfffaffff;\n      }\n      if (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        while ((_DAT_40021000 \u0026 0x20000) !\u003d 0) {\n          uVar2 \u003d HAL_GetTick();\n          if (100 \u003c uVar2 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar3 \u003d HAL_GetTick();\n        while ((_DAT_40021000 \u0026 0x20000) \u003d\u003d 0) {\n          uVar2 \u003d HAL_GetTick();\n          if (100 \u003c uVar2 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 2) !\u003d 0) {\n    if (((_DAT_40021004 \u0026 0xc) \u003d\u003d 0) ||\n       (((_DAT_40021004 \u0026 0xc) \u003d\u003d 8 \u0026\u0026 ((_DAT_40021004 \u0026 0x10000) \u003d\u003d 0)))) {\n      if (((_DAT_40021000 \u0026 2) !\u003d 0) \u0026\u0026 (RCC_OscInitStruct-\u003eHSIState !\u003d 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40021000 \u003d _DAT_40021000 \u0026 0xffffff07 | RCC_OscInitStruct-\u003eHSICalibrationValue \u003c\u003c 3;\n    }\n    else if (RCC_OscInitStruct-\u003eHSIState \u003d\u003d 0) {\n      _DAT_42420000 \u003d 0;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021000 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (2 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 \u003d 1;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021000 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (2 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40021000 \u003d _DAT_40021000 \u0026 0xffffff07 | RCC_OscInitStruct-\u003eHSICalibrationValue \u003c\u003c 3;\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 8) !\u003d 0) {\n    if (RCC_OscInitStruct-\u003eLSIState \u003d\u003d 0) {\n      _DAT_42420480 \u003d 0;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021024 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (2 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 \u003d 1;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021024 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (2 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 4) !\u003d 0) {\n    bVar4 \u003d (_DAT_4002101c \u0026 0x10000000) \u003d\u003d 0;\n    if (bVar4) {\n      _DAT_4002101c \u003d _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n      _DAT_40007000 \u003d _DAT_40007000 | 0x100;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (100 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    uVar3 \u003d RCC_OscInitStruct-\u003eLSEState;\n    if (uVar3 \u003d\u003d 1) {\n      _DAT_40021020 \u003d _DAT_40021020 | 1;\n    }\n    else if (uVar3 \u003d\u003d 0) {\n      _DAT_40021020 \u003d _DAT_40021020 \u0026 0xfffffffa;\n    }\n    else if (uVar3 \u003d\u003d 5) {\n      _DAT_40021020 \u003d _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 \u003d _DAT_40021020 \u0026 0xfffffffa;\n    }\n    if (RCC_OscInitStruct-\u003eLSEState \u003d\u003d 0) {\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021020 \u0026 2) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40021020 \u0026 2) \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar4) {\n      _DAT_4002101c \u003d _DAT_4002101c \u0026 0xefffffff;\n    }\n  }\n  uVar3 \u003d (RCC_OscInitStruct-\u003ePLL).PLLState;\n  if (uVar3 \u003d\u003d 0) {\n    HVar1 \u003d HAL_OK;\n  }\n  else if ((_DAT_40021004 \u0026 0xc) \u003d\u003d 8) {\n    HVar1 \u003d HAL_ERROR;\n  }\n  else if (uVar3 \u003d\u003d 2) {\n    _DAT_42420060 \u003d 0;\n    uVar3 \u003d HAL_GetTick();\n    do {\n      if ((_DAT_40021000 \u0026 0x2000000) \u003d\u003d 0) {\n        if ((RCC_OscInitStruct-\u003ePLL).PLLSource \u003d\u003d 0x10000) {\n          _DAT_40021004 \u003d _DAT_40021004 \u0026 0xfffdffff | RCC_OscInitStruct-\u003eHSEPredivValue;\n        }\n        _DAT_40021004 \u003d\n             _DAT_40021004 \u0026 0xffc2ffff |\n             (RCC_OscInitStruct-\u003ePLL).PLLSource | (RCC_OscInitStruct-\u003ePLL).PLLMUL;\n        _DAT_42420060 \u003d 1;\n        uVar3 \u003d HAL_GetTick();\n        do {\n          if ((_DAT_40021000 \u0026 0x2000000) !\u003d 0) {\n            return HAL_OK;\n          }\n          uVar2 \u003d HAL_GetTick();\n        } while (uVar2 - uVar3 \u003c 3);\n        return HAL_TIMEOUT;\n      }\n      uVar2 \u003d HAL_GetTick();\n    } while (uVar2 - uVar3 \u003c 3);\n    HVar1 \u003d HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42420060 \u003d 0;\n    uVar3 \u003d HAL_GetTick();\n    do {\n      if ((_DAT_40021000 \u0026 0x2000000) \u003d\u003d 0) {\n        return HAL_OK;\n      }\n      uVar2 \u003d HAL_GetTick();\n    } while (uVar2 - uVar3 \u003c 3);\n    HVar1 \u003d HAL_TIMEOUT;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "RCC_Delay",
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetSysClockFreq": {
      "entrypoint": "0x08005840",
      "current_name": "HAL_RCC_GetSysClockFreq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetSysClockFreq(void)\n\n{\n  uint32_t uVar1;\n  uint8_t aPredivFactorTable [2];\n  uint8_t aPLLMULFactorTable [16];\n  \n  aPLLMULFactorTable[12] \u003d \u0027\\x0e\u0027;\n  aPLLMULFactorTable[13] \u003d \u0027\\x0f\u0027;\n  aPLLMULFactorTable[14] \u003d \u0027\\x10\u0027;\n  aPLLMULFactorTable[15] \u003d \u0027\\x10\u0027;\n  aPLLMULFactorTable[8] \u003d \u0027\\n\u0027;\n  aPLLMULFactorTable[9] \u003d \u0027\\v\u0027;\n  aPLLMULFactorTable[10] \u003d \u0027\\f\u0027;\n  aPLLMULFactorTable[11] \u003d \u0027\\r\u0027;\n  aPLLMULFactorTable[4] \u003d \u0027\\x06\u0027;\n  aPLLMULFactorTable[5] \u003d \u0027\\a\u0027;\n  aPLLMULFactorTable[6] \u003d \u0027\\b\u0027;\n  aPLLMULFactorTable[7] \u003d \u0027\\t\u0027;\n  aPLLMULFactorTable[0] \u003d \u0027\\x02\u0027;\n  aPLLMULFactorTable[1] \u003d \u0027\\x03\u0027;\n  aPLLMULFactorTable[2] \u003d \u0027\\x04\u0027;\n  aPLLMULFactorTable[3] \u003d \u0027\\x05\u0027;\n  aPredivFactorTable[0] \u003d \u0027\\x01\u0027;\n  aPredivFactorTable[1] \u003d \u0027\\x02\u0027;\n  if ((_DAT_40021004 \u0026 0xc) \u003d\u003d 8) {\n    if ((_DAT_40021004 \u0026 0x10000) \u003d\u003d 0) {\n      uVar1 \u003d (uint)aPLLMULFactorTable[(_DAT_40021004 \u003c\u003c 10) \u003e\u003e 0x1c] * 4000000;\n    }\n    else {\n      uVar1 \u003d ((uint)aPLLMULFactorTable[(_DAT_40021004 \u003c\u003c 10) \u003e\u003e 0x1c] * 8000000) /\n              (uint)aPredivFactorTable[-((int)(_DAT_40021004 \u003c\u003c 0xe) \u003e\u003e 0x1f)];\n    }\n  }\n  else {\n    uVar1 \u003d 8000000;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_ClockConfig"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_ClockConfig": {
      "entrypoint": "0x080058ac",
      "current_name": "HAL_RCC_ClockConfig",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_RCC_ClockConfig(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t FLatency)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  if ((_DAT_40022000 \u0026 7) \u003c FLatency) {\n    _DAT_40022000 \u003d _DAT_40022000 \u0026 0xfffffff8 | FLatency;\n    if (FLatency !\u003d (FLatency \u0026 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 2) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xffffff0f | RCC_ClkInitStruct-\u003eAHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 1) !\u003d 0) {\n    uVar3 \u003d RCC_ClkInitStruct-\u003eSYSCLKSource;\n    if (uVar3 \u003d\u003d 1) {\n      if ((_DAT_40021000 \u0026 0x20000) \u003d\u003d 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((uVar3 !\u003d 2) \u0026\u0026 ((_DAT_40021000 \u0026 2) \u003d\u003d 0)) {\n      return HAL_ERROR;\n    }\n    _DAT_40021004 \u003d uVar3 | _DAT_40021004 \u0026 0xfffffffc;\n    uVar1 \u003d HAL_GetTick();\n    if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 1) {\n      while ((_DAT_40021004 \u0026 0xc) !\u003d 4) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else if (RCC_ClkInitStruct-\u003eSYSCLKSource \u003d\u003d 2) {\n      while ((_DAT_40021004 \u0026 0xc) !\u003d 8) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 \u0026 0xc) !\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        if (5000 \u003c uVar2 - uVar1) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if (FLatency \u003c (_DAT_40022000 \u0026 7)) {\n    _DAT_40022000 \u003d _DAT_40022000 \u0026 0xfffffff8 | FLatency;\n    if (FLatency !\u003d (FLatency \u0026 7)) {\n      return HAL_ERROR;\n    }\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 4) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xfffff8ff | RCC_ClkInitStruct-\u003eAPB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 8) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xffffc7ff | RCC_ClkInitStruct-\u003eAPB2CLKDivider \u003c\u003c 3;\n  }\n  uVar1 \u003d HAL_RCC_GetSysClockFreq();\n  SystemCoreClock \u003d uVar1 \u003e\u003e \"\"[(_DAT_40021004 \u003c\u003c 0x18) \u003e\u003e 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_RCC_GetSysClockFreq",
        "HAL_InitTick",
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetHCLKFreq": {
      "entrypoint": "0x08005a1c",
      "current_name": "HAL_RCC_GetHCLKFreq",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetHCLKFreq(void)\n\n{\n  return SystemCoreClock;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_GetPCLK1Freq",
        "SystemClock_Config",
        "HAL_RCC_GetPCLK2Freq"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetPCLK1Freq": {
      "entrypoint": "0x08005a28",
      "current_name": "HAL_RCC_GetPCLK1Freq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetPCLK1Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  return uVar1 \u003e\u003e \"\"[(uint)(_DAT_40021004 \u003c\u003c 0x15) \u003e\u003e 0x1d];\n}\n\n",
      "renaming": {},
      "calling": [
        "getTimerClkFreq",
        "UART_SetConfig",
        "HAL_I2C_Init"
      ],
      "called": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetPCLK2Freq": {
      "entrypoint": "0x08005a48",
      "current_name": "HAL_RCC_GetPCLK2Freq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetPCLK2Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  return uVar1 \u003e\u003e \"\"[(uint)(_DAT_40021004 \u003c\u003c 0x12) \u003e\u003e 0x1d];\n}\n\n",
      "renaming": {},
      "calling": [
        "getTimerClkFreq",
        "UART_SetConfig",
        "HAL_RCCEx_GetPeriphCLKFreq"
      ],
      "called": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetClockConfig": {
      "entrypoint": "0x08005a68",
      "current_name": "HAL_RCC_GetClockConfig",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t *pFLatency)\n\n{\n  RCC_ClkInitStruct-\u003eClockType \u003d 0xf;\n  RCC_ClkInitStruct-\u003eSYSCLKSource \u003d _DAT_40021004 \u0026 3;\n  RCC_ClkInitStruct-\u003eAHBCLKDivider \u003d _DAT_40021004 \u0026 0xf0;\n  RCC_ClkInitStruct-\u003eAPB1CLKDivider \u003d _DAT_40021004 \u0026 0x700;\n  RCC_ClkInitStruct-\u003eAPB2CLKDivider \u003d _DAT_40021004 \u003e\u003e 3 \u0026 0x700;\n  *pFLatency \u003d _DAT_40022000 \u0026 7;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "getTimerClkFreq"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCCEx_PeriphCLKConfig": {
      "entrypoint": "0x08005aa4",
      "current_name": "HAL_RCCEx_PeriphCLKConfig",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef_conflict *PeriphClkInit)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  bool bVar5;\n  uint32_t tmpreg;\n  \n  if ((PeriphClkInit-\u003ePeriphClockSelection \u0026 1) !\u003d 0) {\n    bVar5 \u003d (_DAT_4002101c \u0026 0x10000000) \u003d\u003d 0;\n    if (bVar5) {\n      _DAT_4002101c \u003d _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n      _DAT_40007000 \u003d _DAT_40007000 | 0x100;\n      uVar3 \u003d HAL_GetTick();\n      while ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n        uVar4 \u003d HAL_GetTick();\n        if (100 \u003c uVar4 - uVar3) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (((_DAT_40021020 \u0026 0x300) !\u003d 0) \u0026\u0026\n       ((_DAT_40021020 \u0026 0x300) !\u003d (PeriphClkInit-\u003eRTCClockSelection \u0026 0x300))) {\n      uVar2 \u003d _DAT_40021020 \u0026 0xfffffcff;\n      _DAT_42420440 \u003d 0;\n      uVar1 \u003d _DAT_40021020 \u0026 1;\n      _DAT_40021020 \u003d uVar2;\n      if (uVar1 !\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        while ((_DAT_40021020 \u0026 2) \u003d\u003d 0) {\n          uVar4 \u003d HAL_GetTick();\n          if (5000 \u003c uVar4 - uVar3) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n    _DAT_40021020 \u003d _DAT_40021020 \u0026 0xfffffcff | PeriphClkInit-\u003eRTCClockSelection;\n    if (bVar5) {\n      _DAT_4002101c \u003d _DAT_4002101c \u0026 0xefffffff;\n    }\n  }\n  if ((PeriphClkInit-\u003ePeriphClockSelection \u0026 2) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xffff3fff | PeriphClkInit-\u003eAdcClockSelection;\n  }\n  if ((PeriphClkInit-\u003ePeriphClockSelection \u0026 0x10) !\u003d 0) {\n    _DAT_40021004 \u003d _DAT_40021004 \u0026 0xffbfffff | PeriphClkInit-\u003eUsbClockSelection;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCCEx_GetPeriphCLKFreq": {
      "entrypoint": "0x08005bb8",
      "current_name": "HAL_RCCEx_GetPeriphCLKFreq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)\n\n{\n  uint32_t uVar1;\n  uint uVar2;\n  uint8_t aPredivFactorTable [2];\n  uint8_t aPLLMULFactorTable [16];\n  \n  aPLLMULFactorTable[12] \u003d \u0027\\x0e\u0027;\n  aPLLMULFactorTable[13] \u003d \u0027\\x0f\u0027;\n  aPLLMULFactorTable[14] \u003d \u0027\\x10\u0027;\n  aPLLMULFactorTable[15] \u003d \u0027\\x10\u0027;\n  aPLLMULFactorTable[8] \u003d \u0027\\n\u0027;\n  aPLLMULFactorTable[9] \u003d \u0027\\v\u0027;\n  aPLLMULFactorTable[10] \u003d \u0027\\f\u0027;\n  aPLLMULFactorTable[11] \u003d \u0027\\r\u0027;\n  aPLLMULFactorTable[4] \u003d \u0027\\x06\u0027;\n  aPLLMULFactorTable[5] \u003d \u0027\\a\u0027;\n  aPLLMULFactorTable[6] \u003d \u0027\\b\u0027;\n  aPLLMULFactorTable[7] \u003d \u0027\\t\u0027;\n  aPLLMULFactorTable[0] \u003d \u0027\\x02\u0027;\n  aPLLMULFactorTable[1] \u003d \u0027\\x03\u0027;\n  aPLLMULFactorTable[2] \u003d \u0027\\x04\u0027;\n  aPLLMULFactorTable[3] \u003d \u0027\\x05\u0027;\n  aPredivFactorTable[0] \u003d \u0027\\x01\u0027;\n  aPredivFactorTable[1] \u003d \u0027\\x02\u0027;\n  if (PeriphClk \u003d\u003d 2) {\n    uVar1 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar1 \u003d uVar1 / ((((_DAT_40021004 \u003c\u003c 0x10) \u003e\u003e 0x1e) + 1) * 2);\n  }\n  else if (PeriphClk \u003d\u003d 0x10) {\n    if ((_DAT_40021000 \u0026 0x1000000) \u003d\u003d 0) {\n      uVar1 \u003d 0;\n    }\n    else {\n      if ((_DAT_40021004 \u0026 0x10000) \u003d\u003d 0) {\n        uVar2 \u003d 4000000;\n      }\n      else {\n        uVar2 \u003d 8000000 / aPredivFactorTable[-((int)(_DAT_40021004 \u003c\u003c 0xe) \u003e\u003e 0x1f)];\n      }\n      uVar1 \u003d uVar2 * aPLLMULFactorTable[(_DAT_40021004 \u003c\u003c 10) \u003e\u003e 0x1c];\n      if ((_DAT_40021004 \u0026 0x400000) \u003d\u003d 0) {\n        uVar1 \u003d (uVar1 * 2) / 3;\n      }\n    }\n  }\n  else if (PeriphClk \u003d\u003d 1) {\n    if ((_DAT_40021020 \u0026 0x302) \u003d\u003d 0x102) {\n      uVar1 \u003d 0x8000;\n    }\n    else if (((_DAT_40021020 \u0026 0x300) \u003d\u003d 0x200) \u0026\u0026 ((_DAT_40021024 \u0026 2) !\u003d 0)) {\n      uVar1 \u003d 32000;\n    }\n    else if ((_DAT_40021020 \u0026 0x300) \u003d\u003d 0x300) {\n      if ((_DAT_40021000 \u0026 0x20000) \u003d\u003d 0) {\n        uVar1 \u003d 0;\n      }\n      else {\n        uVar1 \u003d 0xf424;\n      }\n    }\n    else {\n      uVar1 \u003d 0;\n    }\n  }\n  else {\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_PollForConversion",
        "HAL_ADCEx_Calibration_Start"
      ],
      "called": [
        "HAL_RCC_GetPCLK2Freq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RTC_AlarmIRQHandler": {
      "entrypoint": "0x08005cb4",
      "current_name": "HAL_RTC_AlarmIRQHandler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)\n\n{\n  if (((hrtc-\u003eInstance-\u003eCRH \u0026 2) !\u003d 0) \u0026\u0026 ((hrtc-\u003eInstance-\u003eCRL \u0026 2) !\u003d 0)) {\n    HAL_RTC_AlarmAEventCallback(hrtc);\n    hrtc-\u003eInstance-\u003eCRL \u003d 0xfffffffd;\n  }\n  _DAT_40010414 \u003d 0x20000;\n  hrtc-\u003eState \u003d HAL_RTC_STATE_READY;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "RTC_Alarm_IRQHandler"
      ],
      "called": [
        "HAL_RTC_AlarmAEventCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_OC1_SetConfig": {
      "entrypoint": "0x08005cec",
      "current_name": "TIM_OC1_SetConfig",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_OC1_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_OC_InitTypeDef *OC_Config)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 0xfffffffe;\n  uVar2 \u003d TIMx-\u003eCR2;\n  uVar3 \u003d OC_Config-\u003eOCMode;\n  uVar1 \u003d TIMx-\u003eCCER \u0026 0xfffffffd | OC_Config-\u003eOCPolarity;\n  if (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    uVar1 \u003d (uVar1 \u0026 0xfffffff7 | OC_Config-\u003eOCNPolarity) \u0026 0xfffffffb;\n    uVar2 \u003d uVar2 \u0026 0xfffffcff | OC_Config-\u003eOCIdleState | OC_Config-\u003eOCNIdleState;\n  }\n  TIMx-\u003eCR2 \u003d uVar2;\n  TIMx-\u003eCCMR1 \u003d TIMx-\u003eCCMR1 \u0026 0xffffff8c | uVar3;\n  TIMx-\u003eCCR1 \u003d OC_Config-\u003ePulse;\n  TIMx-\u003eCCER \u003d uVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_ConfigChannel",
        "HAL_TIM_OC_ConfigChannel"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_OC3_SetConfig": {
      "entrypoint": "0x08005d48",
      "current_name": "TIM_OC3_SetConfig",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_OC3_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_OC_InitTypeDef *OC_Config)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  \n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 0xfffffeff;\n  uVar2 \u003d TIMx-\u003eCR2;\n  uVar3 \u003d OC_Config-\u003eOCMode;\n  uVar1 \u003d TIMx-\u003eCCER \u0026 0xfffffdff | OC_Config-\u003eOCPolarity \u003c\u003c 8;\n  if (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    uVar1 \u003d (uVar1 \u0026 0xfffff7ff | OC_Config-\u003eOCNPolarity \u003c\u003c 8) \u0026 0xfffffbff;\n    uVar2 \u003d uVar2 \u0026 0xffffcfff | OC_Config-\u003eOCIdleState \u003c\u003c 4 | OC_Config-\u003eOCNIdleState \u003c\u003c 4;\n  }\n  TIMx-\u003eCR2 \u003d uVar2;\n  TIMx-\u003eCCMR2 \u003d TIMx-\u003eCCMR2 \u0026 0xffffff8c | uVar3;\n  TIMx-\u003eCCR3 \u003d OC_Config-\u003ePulse;\n  TIMx-\u003eCCER \u003d uVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_ConfigChannel",
        "HAL_TIM_OC_ConfigChannel"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_OC4_SetConfig": {
      "entrypoint": "0x08005dac",
      "current_name": "TIM_OC4_SetConfig",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_OC4_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_OC_InitTypeDef *OC_Config)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  \n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 0xffffefff;\n  uVar1 \u003d TIMx-\u003eCR2;\n  uVar2 \u003d OC_Config-\u003eOCMode;\n  uVar3 \u003d OC_Config-\u003eOCPolarity;\n  if (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    uVar1 \u003d uVar1 \u0026 0xffffbfff | OC_Config-\u003eOCIdleState \u003c\u003c 6;\n  }\n  TIMx-\u003eCR2 \u003d uVar1;\n  TIMx-\u003eCCMR2 \u003d TIMx-\u003eCCMR2 \u0026 0xffff8cff | uVar2 \u003c\u003c 8;\n  TIMx-\u003eCCR4 \u003d OC_Config-\u003ePulse;\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 0xffffdfff | uVar3 \u003c\u003c 0xc;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_ConfigChannel",
        "HAL_TIM_OC_ConfigChannel"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_DeInit": {
      "entrypoint": "0x08005df4",
      "current_name": "HAL_TIM_OC_DeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIM_OC_DeInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  htim-\u003eState \u003d HAL_TIM_STATE_BUSY;\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  HAL_TIM_OC_MspDeInit(htim);\n  htim-\u003eState \u003d HAL_TIM_STATE_RESET;\n  htim-\u003eLock \u003d HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "TimerPulseDeinit"
      ],
      "called": [
        "HAL_TIM_OC_MspDeInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_DeInit": {
      "entrypoint": "0x08005e2e",
      "current_name": "HAL_TIM_PWM_DeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_DeInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  htim-\u003eState \u003d HAL_TIM_STATE_BUSY;\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(htim);\n  htim-\u003eState \u003d HAL_TIM_STATE_RESET;\n  htim-\u003eLock \u003d HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "HAL_TIM_PWM_MspDeInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_IC_CaptureCallback": {
      "entrypoint": "0x08005e68",
      "current_name": "HAL_TIM_IC_CaptureCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_PulseFinishedCallback": {
      "entrypoint": "0x08005e6a",
      "current_name": "HAL_TIM_PWM_PulseFinishedCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_TriggerCallback": {
      "entrypoint": "0x08005e6c",
      "current_name": "HAL_TIM_TriggerCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_TriggerCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_IRQHandler": {
      "entrypoint": "0x08005e6e",
      "current_name": "HAL_TIM_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef_conflict *htim)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 2) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 2) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffd;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((htim-\u003eInstance-\u003eCCMR1 \u0026 3) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 4) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 4) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffb;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((htim-\u003eInstance-\u003eCCMR1 \u0026 0x300) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 8) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 8) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffff7;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((htim-\u003eInstance-\u003eCCMR2 \u0026 3) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x10) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x10) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffef;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((htim-\u003eInstance-\u003eCCMR2 \u0026 0x300) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 1) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 1) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x80) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x80) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffff7f;\n    HAL_TIMEx_BreakCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x40) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x40) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffbf;\n    HAL_TIM_TriggerCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x20) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x20) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(htim);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "TIM2_IRQHandler",
        "TIM3_IRQHandler",
        "TIM1_UP_IRQHandler",
        "TIM4_IRQHandler"
      ],
      "called": [
        "HAL_TIM_PWM_PulseFinishedCallback",
        "HAL_TIM_TriggerCallback",
        "HAL_TIM_OC_DelayElapsedCallback",
        "HAL_TIM_IC_CaptureCallback",
        "HAL_TIM_PeriodElapsedCallback",
        "HAL_TIMEx_BreakCallback",
        "HAL_TIMEx_CommutationCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_Base_SetConfig": {
      "entrypoint": "0x08005fe8",
      "current_name": "TIM_Base_SetConfig",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_Base_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_Base_InitTypeDef_conflict *Structure)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d TIMx-\u003eCR1;\n  if ((((TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) || (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40000000)\n       ) || (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40000400)) ||\n     (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40000800)) {\n    uVar1 \u003d uVar1 \u0026 0xffffff8f | Structure-\u003eCounterMode;\n  }\n  if (((TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) || (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40000000))\n     || ((TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40000400 || (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40000800)\n         ))) {\n    uVar1 \u003d uVar1 \u0026 0xfffffcff | Structure-\u003eClockDivision;\n  }\n  TIMx-\u003eCR1 \u003d uVar1 \u0026 0xffffff7f | Structure-\u003eAutoReloadPreload;\n  TIMx-\u003eARR \u003d Structure-\u003ePeriod;\n  TIMx-\u003ePSC \u003d Structure-\u003ePrescaler;\n  if (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    uRam40012c30 \u003d Structure-\u003eRepetitionCounter;\n  }\n  TIMx-\u003eEGR \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_OC_Init",
        "HAL_TIM_PWM_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_Init": {
      "entrypoint": "0x08006060",
      "current_name": "HAL_TIM_OC_Init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIM_OC_Init(TIM_HandleTypeDef_conflict *htim)\n\n{\n  if (htim !\u003d (TIM_HandleTypeDef_conflict *)0x0) {\n    if (htim-\u003eState \u003d\u003d HAL_TIM_STATE_RESET) {\n      htim-\u003eLock \u003d HAL_UNLOCKED;\n      HAL_TIM_OC_MspInit(htim);\n    }\n    htim-\u003eState \u003d HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(htim-\u003eInstance,\u0026htim-\u003eInit);\n    htim-\u003eState \u003d HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "TimerPulseInit"
      ],
      "called": [
        "HAL_TIM_OC_MspInit",
        "TIM_Base_SetConfig"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_Init": {
      "entrypoint": "0x08006092",
      "current_name": "HAL_TIM_PWM_Init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_Init(TIM_HandleTypeDef_conflict *htim)\n\n{\n  if (htim !\u003d (TIM_HandleTypeDef_conflict *)0x0) {\n    if (htim-\u003eState \u003d\u003d HAL_TIM_STATE_RESET) {\n      htim-\u003eLock \u003d HAL_UNLOCKED;\n      HAL_TIM_PWM_MspInit(htim);\n    }\n    htim-\u003eState \u003d HAL_TIM_STATE_BUSY;\n    TIM_Base_SetConfig(htim-\u003eInstance,\u0026htim-\u003eInit);\n    htim-\u003eState \u003d HAL_TIM_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_start"
      ],
      "called": [
        "HAL_TIM_PWM_MspInit",
        "TIM_Base_SetConfig"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_OC2_SetConfig": {
      "entrypoint": "0x080060c4",
      "current_name": "TIM_OC2_SetConfig",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_OC2_SetConfig(TIM_TypeDef_conflict *TIMx,TIM_OC_InitTypeDef *OC_Config)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  \n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 0xffffffef;\n  uVar2 \u003d TIMx-\u003eCR2;\n  uVar3 \u003d OC_Config-\u003eOCMode;\n  uVar1 \u003d TIMx-\u003eCCER \u0026 0xffffffdf | OC_Config-\u003eOCPolarity \u003c\u003c 4;\n  if (TIMx \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    uVar1 \u003d (uVar1 \u0026 0xffffff7f | OC_Config-\u003eOCNPolarity \u003c\u003c 4) \u0026 0xffffffbf;\n    uVar2 \u003d uVar2 \u0026 0xfffff3ff | OC_Config-\u003eOCIdleState \u003c\u003c 2 | OC_Config-\u003eOCNIdleState \u003c\u003c 2;\n  }\n  TIMx-\u003eCR2 \u003d uVar2;\n  TIMx-\u003eCCMR1 \u003d TIMx-\u003eCCMR1 \u0026 0xffff8cff | uVar3 \u003c\u003c 8;\n  TIMx-\u003eCCR2 \u003d OC_Config-\u003ePulse;\n  TIMx-\u003eCCER \u003d uVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_ConfigChannel",
        "HAL_TIM_OC_ConfigChannel"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_ConfigChannel": {
      "entrypoint": "0x08006128",
      "current_name": "HAL_TIM_OC_ConfigChannel",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_TIM_OC_ConfigChannel\n          (TIM_HandleTypeDef_conflict *htim,TIM_OC_InitTypeDef *sConfig,uint32_t Channel)\n\n{\n  if (htim-\u003eLock !\u003d HAL_LOCKED) {\n    htim-\u003eLock \u003d HAL_LOCKED;\n    htim-\u003eState \u003d HAL_TIM_STATE_BUSY;\n    switch(Channel) {\n    case 0:\n      TIM_OC1_SetConfig(htim-\u003eInstance,sConfig);\n      break;\n    case 4:\n      TIM_OC2_SetConfig(htim-\u003eInstance,sConfig);\n      break;\n    case 8:\n      TIM_OC3_SetConfig(htim-\u003eInstance,sConfig);\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(htim-\u003eInstance,sConfig);\n    }\n    htim-\u003eState \u003d HAL_TIM_STATE_READY;\n    htim-\u003eLock \u003d HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "TimerPulseInit"
      ],
      "called": [
        "TIM_OC3_SetConfig",
        "TIM_OC1_SetConfig",
        "TIM_OC2_SetConfig",
        "TIM_OC4_SetConfig"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_ConfigChannel": {
      "entrypoint": "0x08006186",
      "current_name": "HAL_TIM_PWM_ConfigChannel",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_TIM_PWM_ConfigChannel\n          (TIM_HandleTypeDef_conflict *htim,TIM_OC_InitTypeDef *sConfig,uint32_t Channel)\n\n{\n  if (htim-\u003eLock !\u003d HAL_LOCKED) {\n    htim-\u003eLock \u003d HAL_LOCKED;\n    htim-\u003eState \u003d HAL_TIM_STATE_BUSY;\n    switch(Channel) {\n    case 0:\n      TIM_OC1_SetConfig(htim-\u003eInstance,sConfig);\n      htim-\u003eInstance-\u003eCCMR1 \u003d htim-\u003eInstance-\u003eCCMR1 | 8;\n      htim-\u003eInstance-\u003eCCMR1 \u003d htim-\u003eInstance-\u003eCCMR1 \u0026 0xfffffffb;\n      htim-\u003eInstance-\u003eCCMR1 \u003d htim-\u003eInstance-\u003eCCMR1 | sConfig-\u003eOCFastMode;\n      break;\n    case 4:\n      TIM_OC2_SetConfig(htim-\u003eInstance,sConfig);\n      htim-\u003eInstance-\u003eCCMR1 \u003d htim-\u003eInstance-\u003eCCMR1 | 0x800;\n      htim-\u003eInstance-\u003eCCMR1 \u003d htim-\u003eInstance-\u003eCCMR1 \u0026 0xfffffbff;\n      htim-\u003eInstance-\u003eCCMR1 \u003d htim-\u003eInstance-\u003eCCMR1 | sConfig-\u003eOCFastMode \u003c\u003c 8;\n      break;\n    case 8:\n      TIM_OC3_SetConfig(htim-\u003eInstance,sConfig);\n      htim-\u003eInstance-\u003eCCMR2 \u003d htim-\u003eInstance-\u003eCCMR2 | 8;\n      htim-\u003eInstance-\u003eCCMR2 \u003d htim-\u003eInstance-\u003eCCMR2 \u0026 0xfffffffb;\n      htim-\u003eInstance-\u003eCCMR2 \u003d htim-\u003eInstance-\u003eCCMR2 | sConfig-\u003eOCFastMode;\n      break;\n    case 0xc:\n      TIM_OC4_SetConfig(htim-\u003eInstance,sConfig);\n      htim-\u003eInstance-\u003eCCMR2 \u003d htim-\u003eInstance-\u003eCCMR2 | 0x800;\n      htim-\u003eInstance-\u003eCCMR2 \u003d htim-\u003eInstance-\u003eCCMR2 \u0026 0xfffffbff;\n      htim-\u003eInstance-\u003eCCMR2 \u003d htim-\u003eInstance-\u003eCCMR2 | sConfig-\u003eOCFastMode \u003c\u003c 8;\n    }\n    htim-\u003eState \u003d HAL_TIM_STATE_READY;\n    htim-\u003eLock \u003d HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_start"
      ],
      "called": [
        "TIM_OC3_SetConfig",
        "TIM_OC1_SetConfig",
        "TIM_OC2_SetConfig",
        "TIM_OC4_SetConfig"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_CCxChannelCmd": {
      "entrypoint": "0x08006262",
      "current_name": "TIM_CCxChannelCmd",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_CCxChannelCmd(TIM_TypeDef_conflict *TIMx,uint32_t Channel,uint32_t ChannelState)\n\n{\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 ~(1 \u003c\u003c (Channel \u0026 0xff));\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER | ChannelState \u003c\u003c (Channel \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_Start",
        "HAL_TIM_OC_Start_IT",
        "HAL_TIM_OC_Stop_IT",
        "HAL_TIM_PWM_Stop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_Start_IT": {
      "entrypoint": "0x08006280",
      "current_name": "HAL_TIM_OC_Start_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIM_OC_Start_IT(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  switch(Channel) {\n  case 0:\n    htim-\u003eInstance-\u003eDIER \u003d htim-\u003eInstance-\u003eDIER | 2;\n    break;\n  case 4:\n    htim-\u003eInstance-\u003eDIER \u003d htim-\u003eInstance-\u003eDIER | 4;\n    break;\n  case 8:\n    htim-\u003eInstance-\u003eDIER \u003d htim-\u003eInstance-\u003eDIER | 8;\n    break;\n  case 0xc:\n    htim-\u003eInstance-\u003eDIER \u003d htim-\u003eInstance-\u003eDIER | 0x10;\n  }\n  TIM_CCxChannelCmd(htim-\u003eInstance,Channel,1);\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    uRam40012c44 \u003d uRam40012c44 | 0x8000;\n  }\n  htim-\u003eInstance-\u003eCR1 \u003d htim-\u003eInstance-\u003eCR1 | 1;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "TimerPulseInit"
      ],
      "called": [
        "TIM_CCxChannelCmd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_Stop_IT": {
      "entrypoint": "0x080062f4",
      "current_name": "HAL_TIM_OC_Stop_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  switch(Channel) {\n  case 0:\n    htim-\u003eInstance-\u003eDIER \u003d htim-\u003eInstance-\u003eDIER \u0026 0xfffffffd;\n    break;\n  case 4:\n    htim-\u003eInstance-\u003eDIER \u003d htim-\u003eInstance-\u003eDIER \u0026 0xfffffffb;\n    break;\n  case 8:\n    htim-\u003eInstance-\u003eDIER \u003d htim-\u003eInstance-\u003eDIER \u0026 0xfffffff7;\n    break;\n  case 0xc:\n    htim-\u003eInstance-\u003eDIER \u003d htim-\u003eInstance-\u003eDIER \u0026 0xffffffef;\n  }\n  TIM_CCxChannelCmd(htim-\u003eInstance,Channel,0);\n  if (((htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) \u0026\u0026 ((uRam40012c20 \u0026 0x1111) \u003d\u003d 0)) \u0026\u0026\n     ((uRam40012c20 \u0026 0x444) \u003d\u003d 0)) {\n    uRam40012c44 \u003d uRam40012c44 \u0026 0xffff7fff;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "TimerPulseDeinit"
      ],
      "called": [
        "TIM_CCxChannelCmd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_Start": {
      "entrypoint": "0x08006390",
      "current_name": "HAL_TIM_PWM_Start",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_Start(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_CCxChannelCmd(htim-\u003eInstance,Channel,1);\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    uRam40012c44 \u003d uRam40012c44 | 0x8000;\n  }\n  htim-\u003eInstance-\u003eCR1 \u003d htim-\u003eInstance-\u003eCR1 | 1;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_start"
      ],
      "called": [
        "TIM_CCxChannelCmd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_Stop": {
      "entrypoint": "0x080063c0",
      "current_name": "HAL_TIM_PWM_Stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIM_PWM_Stop(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  TIM_CCxChannelCmd(htim-\u003eInstance,Channel,0);\n  if (((htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) \u0026\u0026 ((uRam40012c20 \u0026 0x1111) \u003d\u003d 0)) \u0026\u0026\n     ((uRam40012c20 \u0026 0x444) \u003d\u003d 0)) {\n    uRam40012c44 \u003d uRam40012c44 \u0026 0xffff7fff;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  htim-\u003eState \u003d HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "TIM_CCxChannelCmd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_CCxNChannelCmd": {
      "entrypoint": "0x08006420",
      "current_name": "TIM_CCxNChannelCmd",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_CCxNChannelCmd(TIM_TypeDef_conflict *TIMx,uint32_t Channel,uint32_t ChannelNState)\n\n{\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 ~(4 \u003c\u003c (Channel \u0026 0xff));\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER | ChannelNState \u003c\u003c (Channel \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIMEx_PWMN_Start",
        "HAL_TIMEx_PWMN_Stop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIMEx_PWMN_Start": {
      "entrypoint": "0x0800643c",
      "current_name": "HAL_TIMEx_PWMN_Start",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_CCxNChannelCmd(htim-\u003eInstance,Channel,4);\n  htim-\u003eInstance-\u003eBDTR \u003d htim-\u003eInstance-\u003eBDTR | 0x8000;\n  htim-\u003eInstance-\u003eCR1 \u003d htim-\u003eInstance-\u003eCR1 | 1;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_start"
      ],
      "called": [
        "TIM_CCxNChannelCmd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIMEx_PWMN_Stop": {
      "entrypoint": "0x08006460",
      "current_name": "HAL_TIMEx_PWMN_Stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef_conflict *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef_conflict *pTVar1;\n  \n  TIM_CCxNChannelCmd(htim-\u003eInstance,Channel,0);\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eBDTR \u003d pTVar1-\u003eBDTR \u0026 0xffff7fff;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "TIM_CCxNChannelCmd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIMEx_CommutationCallback": {
      "entrypoint": "0x080064ac",
      "current_name": "HAL_TIMEx_CommutationCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIMEx_BreakCallback": {
      "entrypoint": "0x080064ae",
      "current_name": "HAL_TIMEx_BreakCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIMEx_BreakCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_EndRxTransfer": {
      "entrypoint": "0x080064b0",
      "current_name": "UART_EndRxTransfer",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART_EndRxTransfer(UART_HandleTypeDef *huart)\n\n{\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffedf;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_Transmit_IT": {
      "entrypoint": "0x080064cc",
      "current_name": "UART_Transmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict UART_Transmit_IT(UART_HandleTypeDef *huart)\n\n{\n  uint16_t uVar1;\n  byte *pbVar2;\n  uint16_t *tmp;\n  \n  if (huart-\u003egState !\u003d HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n    huart-\u003eInstance-\u003eDR \u003d *(ushort *)huart-\u003epTxBuffPtr \u0026 0x1ff;\n    if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n      huart-\u003epTxBuffPtr \u003d huart-\u003epTxBuffPtr + 2;\n    }\n    else {\n      huart-\u003epTxBuffPtr \u003d huart-\u003epTxBuffPtr + 1;\n    }\n  }\n  else {\n    pbVar2 \u003d huart-\u003epTxBuffPtr;\n    huart-\u003epTxBuffPtr \u003d pbVar2 + 1;\n    huart-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n  }\n  uVar1 \u003d huart-\u003eTxXferCount - 1;\n  huart-\u003eTxXferCount \u003d uVar1;\n  if (uVar1 \u003d\u003d 0) {\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffff7f;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_SetConfig": {
      "entrypoint": "0x08006538",
      "current_name": "UART_SetConfig",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART_SetConfig(UART_HandleTypeDef *huart)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  uint32_t uVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  USART_TypeDef *pUVar10;\n  \n  huart-\u003eInstance-\u003eCR2 \u003d huart-\u003eInstance-\u003eCR2 \u0026 0xffffcfff | (huart-\u003eInit).StopBits;\n  huart-\u003eInstance-\u003eCR1 \u003d\n       (huart-\u003eInit).WordLength | (huart-\u003eInit).Parity | (huart-\u003eInit).Mode |\n       huart-\u003eInstance-\u003eCR1 \u0026 0xffffe9f3;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffcff | (huart-\u003eInit).HwFlowCtl;\n  pUVar10 \u003d huart-\u003eInstance;\n  if (pUVar10 !\u003d (USART_TypeDef *)0x40013800) {\n    uVar1 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar6 \u003d (huart-\u003eInit).BaudRate;\n    uVar2 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar7 \u003d (huart-\u003eInit).BaudRate;\n    uVar3 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar8 \u003d (huart-\u003eInit).BaudRate;\n    uVar4 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar9 \u003d (huart-\u003eInit).BaudRate;\n    uVar5 \u003d HAL_RCC_GetPCLK1Freq();\n    pUVar10-\u003eBRR \u003d ((uint)((int)((ulonglong)\n                                 (((uVar4 * 0x19) / (uVar9 \u003c\u003c 2) +\n                                  (int)(((ulonglong)(uVar5 * 0x19) /\n                                        (ulonglong)((huart-\u003eInit).BaudRate \u003c\u003c 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f \u003e\u003e 0x20) \u003c\u003c 0x17) \u003e\u003e 0x1c) +\n                   ((((uVar2 * 0x19) / (uVar7 \u003c\u003c 2) +\n                     (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 \u003c\u003c 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 \u0026 0xf0) +\n                   (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uVar6 \u003c\u003c 2)) / 100) * 0x10;\n    return;\n  }\n  uVar1 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar6 \u003d (huart-\u003eInit).BaudRate;\n  uVar2 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar7 \u003d (huart-\u003eInit).BaudRate;\n  uVar3 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar8 \u003d (huart-\u003eInit).BaudRate;\n  uVar4 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar9 \u003d (huart-\u003eInit).BaudRate;\n  uVar5 \u003d HAL_RCC_GetPCLK2Freq();\n  iRam40013808 \u003d ((uint)((int)((ulonglong)\n                               (((uVar4 * 0x19) / (uVar9 \u003c\u003c 2) +\n                                (int)(((ulonglong)(uVar5 * 0x19) /\n                                      (ulonglong)((huart-\u003eInit).BaudRate \u003c\u003c 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f \u003e\u003e 0x20) \u003c\u003c 0x17) \u003e\u003e 0x1c) +\n                 ((((uVar2 * 0x19) / (uVar7 \u003c\u003c 2) +\n                   (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 \u003c\u003c 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 \u0026 0xf0) +\n                 (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uVar6 \u003c\u003c 2)) / 100) * 0x10;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Init"
      ],
      "called": [
        "HAL_RCC_GetPCLK1Freq",
        "HAL_RCC_GetPCLK2Freq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_WaitOnFlagUntilTimeout": {
      "entrypoint": "0x080066e8",
      "current_name": "UART_WaitOnFlagUntilTimeout",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nUART_WaitOnFlagUntilTimeout\n          (UART_HandleTypeDef *huart,uint32_t Flag,FlagStatus Status,uint32_t Tickstart,\n          uint32_t Timeout)\n\n{\n  uint32_t uVar1;\n  \n  do {\n    if (((Flag \u0026 ~huart-\u003eInstance-\u003eSR) \u003d\u003d 0) !\u003d (bool)Status) {\n      return HAL_OK;\n    }\n  } while ((Timeout \u003d\u003d 0xffffffff) ||\n          ((Timeout !\u003d 0 \u0026\u0026 (uVar1 \u003d HAL_GetTick(), uVar1 - Tickstart \u003c\u003d Timeout))));\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffe5f;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003egState \u003d HAL_UART_STATE_READY;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  huart-\u003eLock \u003d HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Transmit"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_MspInit": {
      "entrypoint": "0x0800674c",
      "current_name": "HAL_UART_MspInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_Init": {
      "entrypoint": "0x0800674e",
      "current_name": "HAL_UART_Init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict HAL_UART_Init(UART_HandleTypeDef *huart)\n\n{\n  if (huart !\u003d (UART_HandleTypeDef *)0x0) {\n    if (huart-\u003egState \u003d\u003d HAL_UART_STATE_RESET) {\n      huart-\u003eLock \u003d HAL_UNLOCKED;\n      HAL_UART_MspInit(huart);\n    }\n    huart-\u003egState \u003d HAL_UART_STATE_BUSY;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffdfff;\n    UART_SetConfig(huart);\n    huart-\u003eInstance-\u003eCR2 \u003d huart-\u003eInstance-\u003eCR2 \u0026 0xffffb7ff;\n    huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xffffffd5;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x2000;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003egState \u003d HAL_UART_STATE_READY;\n    huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [
        "HAL_UART_MspInit",
        "UART_SetConfig"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_Transmit": {
      "entrypoint": "0x080067ac",
      "current_name": "HAL_UART_Transmit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_UART_Transmit(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t Tickstart;\n  uint16_t *tmp;\n  \n  if (huart-\u003egState \u003d\u003d HAL_UART_STATE_READY) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (huart-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      huart-\u003eLock \u003d HAL_LOCKED;\n      huart-\u003eErrorCode \u003d 0;\n      huart-\u003egState \u003d HAL_UART_STATE_BUSY_TX;\n      Tickstart \u003d HAL_GetTick();\n      huart-\u003eTxXferSize \u003d Size;\n      huart-\u003eTxXferCount \u003d Size;\n      while (huart-\u003eTxXferCount !\u003d 0) {\n        huart-\u003eTxXferCount \u003d huart-\u003eTxXferCount - 1;\n        if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n          HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 !\u003d HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart-\u003eInstance-\u003eDR \u003d *(ushort *)pData \u0026 0x1ff;\n          if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n            pData \u003d (uint8_t *)((int)pData + 2);\n          }\n          else {\n            pData \u003d (uint8_t *)((int)pData + 1);\n          }\n        }\n        else {\n          HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 !\u003d HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart-\u003eInstance-\u003eDR \u003d (uint)*pData;\n          pData \u003d (uint8_t *)((int)pData + 1);\n        }\n      }\n      HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x40,RESET,Tickstart,Timeout);\n      if (HVar1 \u003d\u003d HAL_OK) {\n        huart-\u003egState \u003d HAL_UART_STATE_READY;\n        huart-\u003eLock \u003d HAL_UNLOCKED;\n        HVar1 \u003d HAL_OK;\n      }\n      else {\n        HVar1 \u003d HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_write"
      ],
      "called": [
        "UART_WaitOnFlagUntilTimeout",
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_Transmit_IT": {
      "entrypoint": "0x0800688e",
      "current_name": "HAL_UART_Transmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_UART_Transmit_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart-\u003egState !\u003d HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData \u003d\u003d (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size \u003d\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (huart-\u003eLock !\u003d HAL_LOCKED) {\n    huart-\u003epTxBuffPtr \u003d pData;\n    huart-\u003eTxXferSize \u003d Size;\n    huart-\u003eTxXferCount \u003d Size;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003egState \u003d HAL_UART_STATE_BUSY_TX;\n    huart-\u003eLock \u003d HAL_UNLOCKED;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "HAL_UART_TxCpltCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_Receive_IT": {
      "entrypoint": "0x080068d6",
      "current_name": "HAL_UART_Receive_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict\nHAL_UART_Receive_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart-\u003eRxState !\u003d HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData \u003d\u003d (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size \u003d\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (huart-\u003eLock !\u003d HAL_LOCKED) {\n    huart-\u003epRxBuffPtr \u003d pData;\n    huart-\u003eRxXferSize \u003d Size;\n    huart-\u003eRxXferCount \u003d Size;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003eRxState \u003d HAL_UART_STATE_BUSY_RX;\n    huart-\u003eLock \u003d HAL_UNLOCKED;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x100;\n    huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 | 1;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x20;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_rx_callback",
        "uart_getc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_EndTransmit_IT": {
      "entrypoint": "0x08006932",
      "current_name": "UART_EndTransmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict UART_EndTransmit_IT(UART_HandleTypeDef *huart)\n\n{\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffffbf;\n  huart-\u003egState \u003d HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(huart);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [
        "HAL_UART_TxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_Receive_IT": {
      "entrypoint": "0x0800694c",
      "current_name": "UART_Receive_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef_conflict UART_Receive_IT(UART_HandleTypeDef *huart)\n\n{\n  uint16_t *tmp;\n  byte *pbVar1;\n  uint16_t uVar2;\n  uint8_t *puVar3;\n  \n  if (huart-\u003eRxState !\u003d HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n    if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n      *(ushort *)huart-\u003epRxBuffPtr \u003d (ushort)((huart-\u003eInstance-\u003eDR \u003c\u003c 0x17) \u003e\u003e 0x17);\n      huart-\u003epRxBuffPtr \u003d huart-\u003epRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)huart-\u003epRxBuffPtr \u003d (ushort)huart-\u003eInstance-\u003eDR \u0026 0xff;\n      huart-\u003epRxBuffPtr \u003d huart-\u003epRxBuffPtr + 1;\n    }\n  }\n  else if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n    puVar3 \u003d huart-\u003epRxBuffPtr;\n    huart-\u003epRxBuffPtr \u003d puVar3 + 1;\n    *puVar3 \u003d (uint8_t)huart-\u003eInstance-\u003eDR;\n  }\n  else {\n    pbVar1 \u003d huart-\u003epRxBuffPtr;\n    huart-\u003epRxBuffPtr \u003d pbVar1 + 1;\n    *pbVar1 \u003d (byte)huart-\u003eInstance-\u003eDR \u0026 0x7f;\n  }\n  uVar2 \u003d huart-\u003eRxXferCount - 1;\n  huart-\u003eRxXferCount \u003d uVar2;\n  if (uVar2 !\u003d 0) {\n    return HAL_OK;\n  }\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffffdf;\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffeff;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(huart);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [
        "HAL_UART_RxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_IRQHandler": {
      "entrypoint": "0x080069ec",
      "current_name": "HAL_UART_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint uVar2;\n  uint32_t cr1its;\n  USART_TypeDef *pUVar3;\n  uint32_t cr3its;\n  uint uVar4;\n  uint uVar5;\n  uint32_t isrflags;\n  \n  pUVar3 \u003d huart-\u003eInstance;\n  uVar5 \u003d pUVar3-\u003eSR;\n  uVar2 \u003d pUVar3-\u003eCR1;\n  if ((((uVar5 \u0026 0xf) \u003d\u003d 0) \u0026\u0026 ((uVar5 \u0026 0x20) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x20) !\u003d 0)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if (((uVar5 \u0026 0xf) \u003d\u003d 0) || ((uVar4 \u003d pUVar3-\u003eCR3 \u0026 1, uVar4 \u003d\u003d 0 \u0026\u0026 ((uVar2 \u0026 0x120) \u003d\u003d 0)))) {\n    if (((uVar5 \u0026 0x80) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x80) !\u003d 0)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if (((uVar5 \u0026 0x40) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x40) !\u003d 0)) {\n      UART_EndTransmit_IT(huart);\n    }\n  }\n  else {\n    if (((uVar5 \u0026 1) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x100) !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 1;\n    }\n    if (((uVar5 \u0026 4) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 2;\n    }\n    if (((uVar5 \u0026 2) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 4;\n    }\n    if (((uVar5 \u0026 8) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 8;\n    }\n    if (huart-\u003eErrorCode !\u003d 0) {\n      if (((uVar5 \u0026 0x20) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x20) !\u003d 0)) {\n        UART_Receive_IT(huart);\n      }\n      if (((huart-\u003eErrorCode \u0026 8) \u003d\u003d 0) \u0026\u0026 ((huart-\u003eInstance-\u003eCR3 \u0026 0x40) \u003d\u003d 0)) {\n        HAL_UART_ErrorCallback(huart);\n        huart-\u003eErrorCode \u003d 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      pUVar3 \u003d huart-\u003eInstance;\n      if ((pUVar3-\u003eCR3 \u0026 0x40) \u003d\u003d 0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      pUVar3-\u003eCR3 \u003d pUVar3-\u003eCR3 \u0026 0xffffffbf;\n      if (huart-\u003ehdmarx \u003d\u003d (DMA_HandleTypeDef_conflict *)0x0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      huart-\u003ehdmarx-\u003eXferAbortCallback \u003d UART_DMAAbortOnError + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(huart-\u003ehdmarx);\n      if (HVar1 !\u003d HAL_OK) {\n        (*huart-\u003ehdmarx-\u003eXferAbortCallback)(huart-\u003ehdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "USART1_IRQHandler",
        "USART3_IRQHandler",
        "USART2_IRQHandler"
      ],
      "called": [
        "UART_EndTransmit_IT",
        "UART_EndRxTransfer",
        "HAL_UART_ErrorCallback",
        "UART_Transmit_IT",
        "UART_Receive_IT",
        "HAL_DMA_Abort_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_DMAAbortOnError": {
      "entrypoint": "0x08006b0c",
      "current_name": "UART_DMAAbortOnError",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART_DMAAbortOnError(DMA_HandleTypeDef_conflict *hdma)\n\n{\n  UART_HandleTypeDef *huart_00;\n  UART_HandleTypeDef *huart;\n  \n  huart_00 \u003d (UART_HandleTypeDef *)hdma-\u003eParent;\n  huart_00-\u003eRxXferCount \u003d 0;\n  huart_00-\u003eTxXferCount \u003d 0;\n  HAL_UART_ErrorCallback(huart_00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_UART_ErrorCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_GetState": {
      "entrypoint": "0x08006b1c",
      "current_name": "HAL_UART_GetState",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)\n\n{\n  return huart-\u003eRxState | huart-\u003egState;\n}\n\n",
      "renaming": {},
      "calling": [
        "serial_tx_active",
        "serial_rx_active"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "is_pin_configured": {
      "entrypoint": "0x08006b28",
      "current_name": "is_pin_configured",
      "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool is_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint32_t index;\n  \n  index \u003d map[(uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c];\n  return (_Bool)((byte)(index \u003e\u003e ((int)pin \u0026 0xfU)) \u0026 1);\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode",
        "digitalWrite",
        "digitalRead",
        "analogWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_pin_configured": {
      "entrypoint": "0x08006b3e",
      "current_name": "set_pin_configured",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  uint32_t index;\n  \n  uVar1 \u003d (uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c;\n  map[uVar1] \u003d map[uVar1] | 1 \u003c\u003c ((int)pin \u0026 0xfU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode",
        "analogWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "reset_pin_configured": {
      "entrypoint": "0x08006b5c",
      "current_name": "reset_pin_configured",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  uint32_t index;\n  \n  uVar1 \u003d (uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c;\n  map[uVar1] \u003d map[uVar1] \u0026 ~(1 \u003c\u003c ((int)pin \u0026 0xfU));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_GPIO_Port": {
      "entrypoint": "0x08006b7c",
      "current_name": "get_GPIO_Port",
      "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * get_GPIO_Port(uint32_t port_idx)\n\n{\n  switch(port_idx) {\n  case 0:\n    return (GPIO_TypeDef *)0x40010800;\n  case 1:\n    return (GPIO_TypeDef *)0x40010c00;\n  case 2:\n    return (GPIO_TypeDef *)0x40011000;\n  case 3:\n    return (GPIO_TypeDef *)0x40011400;\n  case 4:\n    return (GPIO_TypeDef *)0x40011800;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite",
        "digitalRead"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_GPIO_Port_Clock": {
      "entrypoint": "0x08006bb8",
      "current_name": "set_GPIO_Port_Clock",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * set_GPIO_Port_Clock(uint32_t port_idx)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  \n  switch(port_idx) {\n  case 0:\n    _DAT_40021018 \u003d _DAT_40021018 | 4;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 \u003d _DAT_40021018 | 8;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 \u003d _DAT_40021018 | 0x10;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 \u003d _DAT_40021018 | 0x20;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 \u003d _DAT_40021018 | 0x40;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40011800;\n    break;\n  default:\n    pGVar1 \u003d (GPIO_TypeDef *)0x0;\n  }\n  return pGVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_init",
        "HAL_TIM_PWM_MspInit",
        "HAL_ADC_MspInit",
        "i2c_custom_init",
        "uart_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_adc_channel": {
      "entrypoint": "0x08006c60",
      "current_name": "get_adc_channel",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_adc_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint32_t function;\n  \n  uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_ADC);\n  function \u003d uVar1 \u003c\u003c 0xc;\n  function \u003d function \u003e\u003e 0x1b;\n  if (0x10 \u003c function - 1) {\n    function \u003d 0;\n  }\n  return function;\n}\n\n",
      "renaming": {},
      "calling": [
        "adc_read_value"
      ],
      "called": [
        "pinmap_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_pwm_channel": {
      "entrypoint": "0x08006c7c",
      "current_name": "get_pwm_channel",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_pwm_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint32_t function;\n  \n  uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n  function \u003d uVar1 \u003c\u003c 0xc;\n  function \u003d function \u003e\u003e 0x1b;\n  if (function \u003d\u003d 3) {\n    return 8;\n  }\n  if (function !\u003d 4) {\n    if (function !\u003d 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop",
        "pwm_start"
      ],
      "called": [
        "pinmap_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_MspInit": {
      "entrypoint": "0x08006ca8",
      "current_name": "HAL_ADC_MspInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)\n\n{\n  GPIO_TypeDef *GPIOx;\n  GPIO_TypeDef *port;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (hadc-\u003eInstance \u003d\u003d (ADC_TypeDef *)0x40012400) {\n    _DAT_40021018 \u003d _DAT_40021018 | 0x200;\n  }\n  else if (hadc-\u003eInstance \u003d\u003d (ADC_TypeDef *)0x40012800) {\n    _DAT_40021018 \u003d _DAT_40021018 | 0x400;\n  }\n  GPIOx \u003d set_GPIO_Port_Clock((uint)((int)g_current_pin \u003c\u003c 0x18) \u003e\u003e 0x1c);\n  GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (g_current_pin \u0026 0xfU) \u0026 0xffff;\n  GPIO_InitStruct.Mode \u003d 3;\n  GPIO_InitStruct.Pull \u003d 0;\n  HAL_GPIO_Init(GPIOx,\u0026GPIO_InitStruct);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_Init"
      ],
      "called": [
        "HAL_GPIO_Init",
        "set_GPIO_Port_Clock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_ADC_MspDeInit": {
      "entrypoint": "0x08006d24",
      "current_name": "HAL_ADC_MspDeInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_ADC_MspDeInit(ADC_HandleTypeDef *hadc)\n\n{\n  if (hadc-\u003eInstance !\u003d (ADC_TypeDef *)0x40012400) {\n    if (hadc-\u003eInstance \u003d\u003d (ADC_TypeDef *)0x40012800) {\n      _DAT_4002100c \u003d _DAT_4002100c \u0026 0xfffffbff;\n      _DAT_40021018 \u003d _DAT_40021018 \u0026 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c \u003d _DAT_4002100c \u0026 0xfffffdff;\n  _DAT_40021018 \u003d _DAT_40021018 \u0026 0xfffffdff;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_ADC_DeInit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_read_value": {
      "entrypoint": "0x08006d80",
      "current_name": "adc_read_value",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t adc_read_value(PinName_conflict pin)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint16_t uhADCxConvertedValue;\n  ADC_ChannelConfTypeDef AdcChannelConf;\n  ADC_HandleTypeDef AdcHandle;\n  \n  memset(\u0026AdcHandle,0,0x30);\n  AdcChannelConf.Channel \u003d 0;\n  AdcChannelConf.Rank \u003d 0;\n  AdcChannelConf.SamplingTime \u003d 0;\n  uhADCxConvertedValue \u003d 0;\n  AdcHandle.Instance \u003d (ADC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)\u0026PinMap_ADC);\n  if (AdcHandle.Instance \u003d\u003d (ADC_TypeDef *)0x0) {\n    uhADCxConvertedValue \u003d 0;\n  }\n  else {\n    AdcHandle.Init.DataAlign \u003d 0;\n    AdcHandle.Init.ScanConvMode \u003d 0;\n    AdcHandle.Init.ContinuousConvMode \u003d 0;\n    AdcHandle.Init.DiscontinuousConvMode \u003d 0;\n    AdcHandle.Init.ExternalTrigConv \u003d 0xe0000;\n    AdcHandle.State \u003d 0;\n    AdcHandle.Init.NbrOfConversion \u003d 1;\n    AdcHandle.Init.NbrOfDiscConversion \u003d 0;\n    g_current_pin \u003d pin;\n    HVar1 \u003d HAL_ADC_Init(\u0026AdcHandle);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      AdcChannelConf.Channel \u003d get_adc_channel(pin);\n      if (AdcChannelConf.Channel \u003c 0x12) {\n        AdcChannelConf.Rank \u003d 1;\n        AdcChannelConf.SamplingTime \u003d 2;\n        HVar1 \u003d HAL_ADC_ConfigChannel(\u0026AdcHandle,\u0026AdcChannelConf);\n        if (HVar1 \u003d\u003d HAL_OK) {\n          HVar1 \u003d HAL_ADCEx_Calibration_Start(\u0026AdcHandle);\n          if (HVar1 \u003d\u003d HAL_OK) {\n            HVar1 \u003d HAL_ADC_Start(\u0026AdcHandle);\n            if (HVar1 \u003d\u003d HAL_OK) {\n              HVar1 \u003d HAL_ADC_PollForConversion(\u0026AdcHandle,10);\n              if (HVar1 \u003d\u003d HAL_OK) {\n                uVar2 \u003d HAL_ADC_GetState(\u0026AdcHandle);\n                if ((uVar2 \u0026 0x200) !\u003d 0) {\n                  uVar2 \u003d HAL_ADC_GetValue(\u0026AdcHandle);\n                  uhADCxConvertedValue \u003d (uint16_t)uVar2;\n                }\n                HVar1 \u003d HAL_ADC_Stop(\u0026AdcHandle);\n                if (HVar1 \u003d\u003d HAL_OK) {\n                  HVar1 \u003d HAL_ADC_DeInit(\u0026AdcHandle);\n                  if (HVar1 !\u003d HAL_OK) {\n                    uhADCxConvertedValue \u003d 0;\n                  }\n                }\n                else {\n                  uhADCxConvertedValue \u003d 0;\n                }\n              }\n              else {\n                uhADCxConvertedValue \u003d 0;\n              }\n            }\n            else {\n              uhADCxConvertedValue \u003d 0;\n            }\n          }\n          else {\n            uhADCxConvertedValue \u003d 0;\n          }\n        }\n        else {\n          uhADCxConvertedValue \u003d 0;\n        }\n      }\n      else {\n        uhADCxConvertedValue \u003d 0;\n      }\n    }\n    else {\n      uhADCxConvertedValue \u003d 0;\n    }\n  }\n  return uhADCxConvertedValue;\n}\n\n",
      "renaming": {},
      "calling": [
        "analogRead"
      ],
      "called": [
        "HAL_ADC_PollForConversion",
        "pinmap_peripheral",
        "HAL_ADC_GetState",
        "HAL_ADC_GetValue",
        "HAL_ADC_ConfigChannel",
        "HAL_ADC_Start",
        "HAL_ADC_Stop",
        "HAL_ADC_Init",
        "HAL_ADCEx_Calibration_Start",
        "get_adc_channel",
        "HAL_ADC_DeInit",
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_MspInit": {
      "entrypoint": "0x08006e68",
      "current_name": "HAL_TIM_PWM_MspInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_PWM_MspInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  uint32_t uVar1;\n  uint32_t function;\n  GPIO_TypeDef *GPIOx;\n  GPIO_TypeDef *port;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  uVar1 \u003d pinmap_function(g_current_pin,(PinMap_conflict *)\u0026PinMap_PWM);\n  timer_enable_clock(htim);\n  GPIOx \u003d set_GPIO_Port_Clock((uint)((int)g_current_pin \u003c\u003c 0x18) \u003e\u003e 0x1c);\n  GPIO_InitStruct.Mode \u003d 2;\n  GPIO_InitStruct.Pull \u003d 0;\n  GPIO_InitStruct.Speed \u003d 3;\n  _DAT_40021018 \u003d _DAT_40021018 | 1;\n  switch((uVar1 \u003c\u003c 0x11) \u003e\u003e 0x19) {\n  case 1:\n    tmpreg_10 \u003d tmpreg_10 | 0x7000001;\n    break;\n  case 2:\n    tmpreg_10 \u003d tmpreg_10 \u0026 0xfffffffe | 0x7000000;\n    break;\n  case 3:\n    tmpreg_10 \u003d tmpreg_10 | 0x7000002;\n    break;\n  case 4:\n    tmpreg_10 \u003d tmpreg_10 \u0026 0xfffffffd | 0x7000000;\n    break;\n  case 5:\n    tmpreg_10 \u003d tmpreg_10 | 0x7000004;\n    break;\n  case 6:\n    tmpreg_10 \u003d tmpreg_10 \u0026 0xfffffffb | 0x7000000;\n    break;\n  case 7:\n    tmpreg_10 \u003d tmpreg_10 | 0x7000008;\n    break;\n  case 8:\n    tmpreg_10 \u003d tmpreg_10 \u0026 0xfffffff7 | 0x7000000;\n    break;\n  case 9:\n    tmpreg_10 \u003d tmpreg_10 | 0x7000030;\n    break;\n  case 10:\n    tmpreg_1 \u003d tmpreg_10 \u0026 0xffffffcf;\n    tmpreg_10 \u003d tmpreg_1 | 0x7000010;\n    break;\n  case 0xb:\n    tmpreg_2 \u003d tmpreg_10 \u0026 0xffffffcf;\n    tmpreg_10 \u003d tmpreg_2 | 0x7000000;\n    break;\n  case 0xc:\n    tmpreg_10 \u003d tmpreg_10 | 0x70000c0;\n    break;\n  case 0xd:\n    tmpreg_3 \u003d tmpreg_10 \u0026 0xffffff3f;\n    tmpreg_10 \u003d tmpreg_3 | 0x7000040;\n    break;\n  case 0xe:\n    tmpreg_4 \u003d tmpreg_10 \u0026 0xffffff3f;\n    tmpreg_10 \u003d tmpreg_4 | 0x7000000;\n    break;\n  case 0xf:\n    tmpreg_10 \u003d tmpreg_10 | 0x7000300;\n    break;\n  case 0x10:\n    tmpreg_5 \u003d tmpreg_10 \u0026 0xfffffcff;\n    tmpreg_10 \u003d tmpreg_5 | 0x7000200;\n    break;\n  case 0x11:\n    tmpreg_6 \u003d tmpreg_10 \u0026 0xfffffcff;\n    tmpreg_10 \u003d tmpreg_6 | 0x7000100;\n    break;\n  case 0x12:\n    tmpreg_7 \u003d tmpreg_10 \u0026 0xfffffcff;\n    tmpreg_10 \u003d tmpreg_7 | 0x7000000;\n    break;\n  case 0x13:\n    tmpreg_10 \u003d tmpreg_10 | 0x7000c00;\n    break;\n  case 0x14:\n    tmpreg_8 \u003d tmpreg_10 \u0026 0xfffff3ff;\n    tmpreg_10 \u003d tmpreg_8 | 0x7000800;\n    break;\n  case 0x15:\n    tmpreg_9 \u003d tmpreg_10 \u0026 0xfffff3ff;\n    tmpreg_10 \u003d tmpreg_9 | 0x7000000;\n    break;\n  case 0x16:\n    tmpreg_10 \u003d tmpreg_10 | 0x7001000;\n    break;\n  case 0x17:\n    tmpreg_10 \u003d tmpreg_10 \u0026 0xffffefff | 0x7000000;\n    break;\n  case 0x1b:\n    tmpreg_10 \u003d tmpreg_10 | 0x7008000;\n    break;\n  case 0x1c:\n    tmpreg_10 \u003d tmpreg_10 \u0026 0xffff7fff | 0x7000000;\n    break;\n  case 0x21:\n    tmpreg_10 \u003d tmpreg_10 \u0026 0xf8ffffff;\n    break;\n  case 0x22:\n    tmpreg_11 \u003d tmpreg_10 \u0026 0xf8ffffff;\n    tmpreg_10 \u003d tmpreg_11 | 0x1000000;\n    break;\n  case 0x23:\n    tmpreg_12 \u003d tmpreg_10 \u0026 0xf8ffffff;\n    tmpreg_10 \u003d tmpreg_12 | 0x2000000;\n    break;\n  case 0x24:\n    tmpreg_10 \u003d tmpreg_10 \u0026 0xf8ffffff | 0x4000000;\n  }\n  GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (g_current_pin \u0026 0xfU) \u0026 0xffff;\n  HAL_GPIO_Init(GPIOx,\u0026GPIO_InitStruct);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_Init"
      ],
      "called": [
        "HAL_GPIO_Init",
        "timer_enable_clock",
        "set_GPIO_Port_Clock",
        "pinmap_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_MspDeInit": {
      "entrypoint": "0x08007110",
      "current_name": "HAL_TIM_PWM_MspDeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_DeInit"
      ],
      "called": [
        "timer_disable_clock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pwm_start": {
      "entrypoint": "0x08007118",
      "current_name": "pwm_start",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pwm_start(PinName_conflict pin,uint32_t clock_freq,uint32_t period,uint32_t value,\n              uint8_t do_init)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t timChannel;\n  uint32_t uVar3;\n  TIM_OC_InitTypeDef timConfig;\n  TIM_HandleTypeDef_conflict timHandle;\n  \n  memset(\u0026timHandle,0,0x40);\n  timConfig.OCMode \u003d 0;\n  timConfig.Pulse \u003d 0;\n  timConfig.OCPolarity \u003d 0;\n  timConfig.OCNPolarity \u003d 0;\n  timConfig.OCFastMode \u003d 0;\n  timConfig.OCIdleState \u003d 0;\n  timConfig.OCNIdleState \u003d 0;\n  timHandle.Instance \u003d (TIM_TypeDef_conflict *)pinmap_peripheral(pin,(PinMap_conflict *)\u0026PinMap_PWM)\n  ;\n  if (timHandle.Instance !\u003d (TIM_TypeDef_conflict *)0x0) {\n    uVar2 \u003d getTimerClkFreq(timHandle.Instance);\n    timHandle.Init.Prescaler \u003d uVar2 / clock_freq - 1;\n    timHandle.Init.Period \u003d period - 1;\n    timHandle.Init.ClockDivision \u003d 0;\n    timHandle.Init.CounterMode \u003d 0;\n    timHandle.Init.RepetitionCounter \u003d 0;\n    timHandle.State \u003d HAL_TIM_STATE_RESET;\n    if (((do_init !\u003d \u0027\\x01\u0027) ||\n        (g_current_pin \u003d pin, HVar1 \u003d HAL_TIM_PWM_Init(\u0026timHandle), HVar1 \u003d\u003d HAL_OK)) \u0026\u0026\n       (((uVar2 \u003d get_pwm_channel(pin), uVar2 \u003d\u003d 0 ||\n         (((uVar2 \u003d\u003d 4 || (uVar2 \u003d\u003d 8)) || (uVar2 \u003d\u003d 0xc)))) || (uVar2 \u003d\u003d 0x18)))) {\n      timConfig.OCMode \u003d 0x60;\n      timConfig.OCPolarity \u003d 0;\n      timConfig.OCFastMode \u003d 0;\n      timConfig.OCNPolarity \u003d 0;\n      timConfig.OCNIdleState \u003d 0;\n      timConfig.OCIdleState \u003d 0;\n      timConfig.Pulse \u003d value;\n      HVar1 \u003d HAL_TIM_PWM_ConfigChannel(\u0026timHandle,\u0026timConfig,uVar2);\n      if (HVar1 \u003d\u003d HAL_OK) {\n        uVar3 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n        if ((uVar3 \u0026 0x100000) \u003d\u003d 0) {\n          HAL_TIM_PWM_Start(\u0026timHandle,uVar2);\n        }\n        else {\n          HAL_TIMEx_PWMN_Start(\u0026timHandle,uVar2);\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "analogWrite"
      ],
      "called": [
        "pinmap_peripheral",
        "HAL_TIM_PWM_Start",
        "HAL_TIMEx_PWMN_Start",
        "getTimerClkFreq",
        "HAL_TIM_PWM_ConfigChannel",
        "pinmap_function",
        "HAL_TIM_PWM_Init",
        "get_pwm_channel",
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pwm_stop": {
      "entrypoint": "0x080071e4",
      "current_name": "pwm_stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pwm_stop(PinName_conflict pin)\n\n{\n  uint32_t Channel;\n  uint32_t timChannel;\n  uint32_t uVar1;\n  TIM_HandleTypeDef_conflict timHandle;\n  \n  timHandle.Instance \u003d (TIM_TypeDef_conflict *)pinmap_peripheral(pin,(PinMap_conflict *)\u0026PinMap_PWM)\n  ;\n  if ((timHandle.Instance !\u003d (TIM_TypeDef_conflict *)0x0) \u0026\u0026\n     ((((Channel \u003d get_pwm_channel(pin), Channel \u003d\u003d 0 || (Channel \u003d\u003d 4)) || (Channel \u003d\u003d 8)) ||\n      ((Channel \u003d\u003d 0xc || (Channel \u003d\u003d 0x18)))))) {\n    uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n    if ((uVar1 \u0026 0x100000) \u003d\u003d 0) {\n      HAL_TIM_PWM_Stop(\u0026timHandle,Channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(\u0026timHandle,Channel);\n    }\n    HAL_TIM_PWM_DeInit(\u0026timHandle);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [
        "pinmap_peripheral",
        "HAL_TIM_PWM_DeInit",
        "pinmap_function",
        "get_pwm_channel",
        "HAL_TIM_PWM_Stop",
        "HAL_TIMEx_PWMN_Stop"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "GetCurrentMilli": {
      "entrypoint": "0x0800723c",
      "current_name": "GetCurrentMilli",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t GetCurrentMilli(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_GetTick();\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "millis"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "noOsSystickHandler": {
      "entrypoint": "0x08007244",
      "current_name": "noOsSystickHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid noOsSystickHandler(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SysTick_Handler": {
      "entrypoint": "0x08007246",
      "current_name": "SysTick_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SysTick_Handler(void)\n\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "noOsSystickHandler",
        "HAL_IncTick",
        "HAL_SYSTICK_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digital_io_init": {
      "entrypoint": "0x08007258",
      "current_name": "digital_io_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid digital_io_init(PinName_conflict pin,uint32_t mode,uint32_t pull)\n\n{\n  uint uVar1;\n  GPIO_TypeDef *GPIOx;\n  GPIO_TypeDef *port;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg;\n  GPIO_InitTypeDef GPIO_InitStructure;\n  \n  uVar1 \u003d (uint)pin;\n  GPIOx \u003d set_GPIO_Port_Clock((uVar1 \u003c\u003c 0x18) \u003e\u003e 0x1c);\n  GPIO_InitStructure.Pin \u003d 1 \u003c\u003c (uVar1 \u0026 0xf) \u0026 0xffff;\n  GPIO_InitStructure.Speed \u003d 3;\n  _DAT_40021018 \u003d _DAT_40021018 | 1;\n  if ((uVar1 - 0xd \u0026 0xff) \u003c 2) {\n    _DAT_40010004 \u003d _DAT_40010004 \u0026 0xf8ffffff | 0x4000000;\n  }\n  if (((uVar1 \u003d\u003d 0xf) || (uVar1 \u003d\u003d 0x13)) || (uVar1 \u003d\u003d 0x14)) {\n    tmpreg_1 \u003d _DAT_40010004 \u0026 0xf8ffffff;\n    _DAT_40010004 \u003d tmpreg_1 | 0x2000000;\n  }\n  GPIO_InitStructure.Mode \u003d mode;\n  GPIO_InitStructure.Pull \u003d pull;\n  HAL_GPIO_Init(GPIOx,\u0026GPIO_InitStructure);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [
        "HAL_GPIO_Init",
        "set_GPIO_Port_Clock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digital_io_write": {
      "entrypoint": "0x080072d8",
      "current_name": "digital_io_write",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid digital_io_write(GPIO_TypeDef *port,uint32_t pin,uint32_t val)\n\n{\n  if (val \u003d\u003d 0) {\n    HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_SET);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite"
      ],
      "called": [
        "HAL_GPIO_WritePin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digital_io_read": {
      "entrypoint": "0x080072f0",
      "current_name": "digital_io_read",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t digital_io_read(GPIO_TypeDef *port,uint32_t pin)\n\n{\n  GPIO_PinState GVar1;\n  \n  GVar1 \u003d HAL_GPIO_ReadPin(port,(uint16_t)pin);\n  return (uint)GVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalRead"
      ],
      "called": [
        "HAL_GPIO_ReadPin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "hw_config_init": {
      "entrypoint": "0x080072fa",
      "current_name": "hw_config_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid hw_config_init(void)\n\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [
        "SystemClock_Config",
        "HAL_Init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_find_peripheral": {
      "entrypoint": "0x08007306",
      "current_name": "pinmap_find_peripheral",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * pinmap_find_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return (void *)0x0;\n    }\n    if (map-\u003epin \u003d\u003d pin) break;\n    map \u003d map + 1;\n  }\n  return map-\u003eperipheral;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_peripheral",
        "pinmap_find_peripheral"
      ],
      "called": [
        "pinmap_find_peripheral"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_peripheral": {
      "entrypoint": "0x08007320",
      "current_name": "pinmap_peripheral",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * pinmap_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  void *pvVar1;\n  \n  if (pin !\u003d NC) {\n    pvVar1 \u003d pinmap_find_peripheral(pin,map);\n    return pvVar1;\n  }\n  return (void *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop",
        "uart_debug_write",
        "i2c_custom_init",
        "pwm_start",
        "adc_read_value",
        "uart_init",
        "uart_debug_init"
      ],
      "called": [
        "pinmap_find_peripheral"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_find_pin": {
      "entrypoint": "0x08007332",
      "current_name": "pinmap_find_pin",
      "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict pinmap_find_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003eperipheral \u003d\u003d (void *)0x0) {\n      return NC;\n    }\n    if (map-\u003eperipheral \u003d\u003d peripheral) break;\n    map \u003d map + 1;\n  }\n  return map-\u003epin;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_find_pin",
        "pinmap_pin"
      ],
      "called": [
        "pinmap_find_pin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_pin": {
      "entrypoint": "0x0800734a",
      "current_name": "pinmap_pin",
      "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict pinmap_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  PinName_conflict PVar1;\n  \n  if (peripheral !\u003d (void *)0x0) {\n    PVar1 \u003d pinmap_find_pin(peripheral,map);\n    return PVar1;\n  }\n  return NC;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_init",
        "HardwareSerial"
      ],
      "called": [
        "pinmap_find_pin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_find_function": {
      "entrypoint": "0x0800735a",
      "current_name": "pinmap_find_function",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pinmap_find_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return 0xffffffff;\n    }\n    if (map-\u003epin \u003d\u003d pin) break;\n    map \u003d map + 1;\n  }\n  return map-\u003efunction;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_find_function",
        "pinmap_function"
      ],
      "called": [
        "pinmap_find_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_function": {
      "entrypoint": "0x08007376",
      "current_name": "pinmap_function",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pinmap_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  uint32_t uVar1;\n  \n  if (pin \u003d\u003d NC) {\n    return 0xffffffff;\n  }\n  uVar1 \u003d pinmap_find_function(pin,map);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop",
        "HAL_TIM_PWM_MspInit",
        "i2c_custom_init",
        "pwm_start",
        "uart_init",
        "get_pwm_channel",
        "get_adc_channel"
      ],
      "called": [
        "pinmap_find_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pin_in_pinmap": {
      "entrypoint": "0x0800738a",
      "current_name": "pin_in_pinmap",
      "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pin_in_pinmap(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  if (pin \u003d\u003d NC) {\n    return false;\n  }\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return false;\n    }\n    if (pin \u003d\u003d map-\u003epin) break;\n    map \u003d map + 1;\n  }\n  return true;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode",
        "setPinModeCallback",
        "enableI2CPins",
        "analogWriteCallback",
        "sysexCallback",
        "analogWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_merge_peripheral": {
      "entrypoint": "0x080073ae",
      "current_name": "pinmap_merge_peripheral",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * pinmap_merge_peripheral(void *a,void *b)\n\n{\n  if (a !\u003d b) {\n    if (a \u003d\u003d (void *)0x0) {\n      return b;\n    }\n    if (b \u003d\u003d (void *)0x0) {\n      return a;\n    }\n    a \u003d (void *)0x0;\n  }\n  return a;\n}\n\n",
      "renaming": {},
      "calling": [
        "i2c_custom_init",
        "uart_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RTC_AlarmAEventCallback": {
      "entrypoint": "0x080073c0",
      "current_name": "HAL_RTC_AlarmAEventCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)\n\n{\n  if (RTCUserCallback !\u003d (voidCallbackPtr)0x0) {\n    (*RTCUserCallback)(callbackUserData);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RTC_AlarmIRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "RTC_Alarm_IRQHandler": {
      "entrypoint": "0x080073d8",
      "current_name": "RTC_Alarm_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid RTC_Alarm_IRQHandler(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(\u0026RtcHandle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_RTC_AlarmIRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_Error_Handler": {
      "entrypoint": "0x080073e8",
      "current_name": "_Error_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _Error_Handler(char *msg,int val)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "onReceiveService",
        "SystemClock_Config",
        "_Error_Handler"
      ],
      "called": [
        "_Error_Handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemInit": {
      "entrypoint": "0x080073ec",
      "current_name": "SystemInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid SystemInit(void)\n\n{\n  _DAT_40021000 \u003d _DAT_40021000 \u0026 0xfef2ffff | 1;\n  _DAT_40021004 \u003d _DAT_40021004 \u0026 0xf8800000;\n  _DAT_40021008 \u003d 0x9f0000;\n  _DAT_e000ed08 \u003d 0x8000000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "timer_enable_clock": {
      "entrypoint": "0x08007438",
      "current_name": "timer_enable_clock",
      "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n/* WARNING: Unknown calling convention */\n\nvoid timer_enable_clock(TIM_HandleTypeDef_conflict *htim)\n\n{\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  \n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    _DAT_40021018 \u003d _DAT_40021018 | 0x800;\n    timer_handles[0] \u003d htim;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40000000) {\n    _DAT_4002101c \u003d _DAT_4002101c | 1;\n    timer_handles[1] \u003d htim;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40000400) {\n    _DAT_4002101c \u003d _DAT_4002101c | 2;\n    timer_handles[2] \u003d htim;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40000800) {\n    _DAT_4002101c \u003d _DAT_4002101c | 4;\n    timer_handles[3] \u003d htim;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_MspInit",
        "HAL_TIM_OC_MspInit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "timer_disable_clock": {
      "entrypoint": "0x080074e0",
      "current_name": "timer_disable_clock",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid timer_disable_clock(TIM_HandleTypeDef_conflict *htim)\n\n{\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n    _DAT_40021018 \u003d _DAT_40021018 \u0026 0xfffff7ff;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40000000) {\n    _DAT_4002101c \u003d _DAT_4002101c \u0026 0xfffffffe;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40000400) {\n    _DAT_4002101c \u003d _DAT_4002101c \u0026 0xfffffffd;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef_conflict *)0x40000800) {\n    _DAT_4002101c \u003d _DAT_4002101c \u0026 0xfffffffb;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_MspDeInit",
        "HAL_TIM_OC_MspDeInit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getTimerIrq": {
      "entrypoint": "0x08007544",
      "current_name": "getTimerIrq",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimerIrq(TIM_TypeDef_conflict *tim)\n\n{\n  if (tim \u003d\u003d (TIM_TypeDef_conflict *)0xffffffff) {\n    return 0;\n  }\n  if (tim \u003d\u003d (TIM_TypeDef_conflict *)0x40000400) {\n    return 0x1d;\n  }\n  if (tim \u003c (TIM_TypeDef_conflict *)0x40000401) {\n    if (tim \u003d\u003d (TIM_TypeDef_conflict *)0x40000000) {\n      return 0x1c;\n    }\n  }\n  else {\n    if (tim \u003d\u003d (TIM_TypeDef_conflict *)0x40000800) {\n      return 0x1e;\n    }\n    if (tim \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n      return 0x19;\n    }\n  }\n  iprintf(\"TIM: Unknown timer IRQn\");\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "TimerPulseDeinit",
        "TimerPulseInit"
      ],
      "called": [
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getTimerClkSrc": {
      "entrypoint": "0x08007594",
      "current_name": "getTimerClkSrc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t getTimerClkSrc(TIM_TypeDef_conflict *tim)\n\n{\n  if (tim \u003d\u003d (TIM_TypeDef_conflict *)0xffffffff) {\n    return \u0027\\0\u0027;\n  }\n  if (tim \u003d\u003d (TIM_TypeDef_conflict *)0x40000400) {\n    return \u0027\\x01\u0027;\n  }\n  if (tim \u003c (TIM_TypeDef_conflict *)0x40000401) {\n    if (tim \u003d\u003d (TIM_TypeDef_conflict *)0x40000000) {\n      return \u0027\\x01\u0027;\n    }\n  }\n  else {\n    if (tim \u003d\u003d (TIM_TypeDef_conflict *)0x40000800) {\n      return \u0027\\x01\u0027;\n    }\n    if (tim \u003d\u003d (TIM_TypeDef_conflict *)0x40012c00) {\n      return \u0027\\x02\u0027;\n    }\n  }\n  iprintf(\"TIM: Unknown timer instance\");\n  return \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "getTimerClkFreq"
      ],
      "called": [
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getTimerClkFreq": {
      "entrypoint": "0x080075dc",
      "current_name": "getTimerClkFreq",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimerClkFreq(TIM_TypeDef_conflict *tim)\n\n{\n  uint32_t uVar1;\n  uint8_t uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t pFLatency;\n  RCC_ClkInitTypeDef_conflict clkconfig;\n  \n  clkconfig.ClockType \u003d 0;\n  clkconfig.SYSCLKSource \u003d 0;\n  clkconfig.AHBCLKDivider \u003d 0;\n  clkconfig.APB1CLKDivider \u003d 0;\n  clkconfig.APB2CLKDivider \u003d 0;\n  pFLatency \u003d 0;\n  HAL_RCC_GetClockConfig(\u0026clkconfig,\u0026pFLatency);\n  uVar2 \u003d getTimerClkSrc(tim);\n  uVar1 \u003d clkconfig.APB2CLKDivider;\n  uVar4 \u003d clkconfig.APB1CLKDivider;\n  if (uVar2 \u003d\u003d \u0027\\x01\u0027) {\n    uVar3 \u003d HAL_RCC_GetPCLK1Freq();\n  }\n  else if (uVar2 \u003d\u003d \u0027\\x02\u0027) {\n    uVar3 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar4 \u003d uVar1;\n  }\n  else {\n    iprintf(\"TIM: Unknown clock source\");\n    uVar3 \u003d 0;\n    uVar4 \u003d 0;\n  }\n  if (uVar4 !\u003d 0x500) {\n    if (uVar4 \u003c 0x501) {\n      if (uVar4 !\u003d 0x400) {\n        return uVar3;\n      }\n    }\n    else if ((uVar4 !\u003d 0x600) \u0026\u0026 (uVar4 !\u003d 0x700)) {\n      return uVar3;\n    }\n  }\n  return uVar3 \u003c\u003c 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_start",
        "TimerPulseInit"
      ],
      "called": [
        "HAL_RCC_GetPCLK1Freq",
        "getTimerClkSrc",
        "HAL_RCC_GetClockConfig",
        "iprintf",
        "HAL_RCC_GetPCLK2Freq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TimerPulseInit": {
      "entrypoint": "0x08007648",
      "current_name": "TimerPulseInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TimerPulseInit(stimer_t_conflict *obj,uint16_t period,uint16_t pulseWidth,\n                   _func_void_stimer_t_ptr_uint32_t_conflict *irqHandle)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  TIM_HandleTypeDef_conflict *handle;\n  TIM_HandleTypeDef_conflict *htim;\n  TIM_OC_InitTypeDef sConfig;\n  \n  sConfig.OCMode \u003d 0;\n  sConfig.Pulse \u003d 0;\n  sConfig.OCPolarity \u003d 0;\n  sConfig.OCNPolarity \u003d 0;\n  sConfig.OCFastMode \u003d 0;\n  sConfig.OCIdleState \u003d 0;\n  sConfig.OCNIdleState \u003d 0;\n  htim \u003d \u0026obj-\u003ehandle;\n  obj-\u003etimer \u003d (TIM_TypeDef_conflict *)0x40000000;\n  (obj-\u003ehandle).Instance \u003d (TIM_TypeDef_conflict *)0x40000000;\n  (obj-\u003ehandle).Init.Period \u003d (uint)period;\n  uVar2 \u003d getTimerClkFreq((TIM_TypeDef_conflict *)0x40000000);\n  (obj-\u003ehandle).Init.Prescaler \u003d uVar2 / 1000000 - 1;\n  (obj-\u003ehandle).Init.ClockDivision \u003d 0;\n  (obj-\u003ehandle).Init.CounterMode \u003d 0;\n  (obj-\u003ehandle).Init.RepetitionCounter \u003d 0;\n  obj-\u003eirqHandleOC \u003d irqHandle;\n  sConfig.OCMode \u003d 0;\n  sConfig.OCPolarity \u003d 0;\n  sConfig.OCFastMode \u003d 0;\n  sConfig.OCNPolarity \u003d 0;\n  sConfig.OCIdleState \u003d 0;\n  sConfig.OCNIdleState \u003d 0;\n  sConfig.Pulse \u003d (uint)pulseWidth;\n  uVar2 \u003d getTimerIrq(obj-\u003etimer);\n  HAL_NVIC_SetPriority((IRQn_Type_conflict)uVar2,0xe,0);\n  uVar2 \u003d getTimerIrq(obj-\u003etimer);\n  HAL_NVIC_EnableIRQ((IRQn_Type_conflict)uVar2);\n  HVar1 \u003d HAL_TIM_OC_Init(htim);\n  if ((HVar1 \u003d\u003d HAL_OK) \u0026\u0026 (HVar1 \u003d HAL_TIM_OC_ConfigChannel(htim,\u0026sConfig,0), HVar1 \u003d\u003d HAL_OK)) {\n    HAL_TIM_OC_Start_IT(htim,0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "initISR"
      ],
      "called": [
        "getTimerIrq",
        "HAL_TIM_OC_Init",
        "HAL_TIM_OC_Start_IT",
        "getTimerClkFreq",
        "HAL_NVIC_EnableIRQ",
        "HAL_NVIC_SetPriority",
        "HAL_TIM_OC_ConfigChannel"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TimerPulseDeinit": {
      "entrypoint": "0x080076e0",
      "current_name": "TimerPulseDeinit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TimerPulseDeinit(stimer_t_conflict *obj)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  TIM_HandleTypeDef_conflict *handle;\n  \n  obj-\u003eirqHandleOC \u003d (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0;\n  uVar2 \u003d getTimerIrq(obj-\u003etimer);\n  HAL_NVIC_DisableIRQ((IRQn_Type_conflict)uVar2);\n  HVar1 \u003d HAL_TIM_OC_DeInit(\u0026obj-\u003ehandle);\n  if (HVar1 \u003d\u003d HAL_OK) {\n    HAL_TIM_OC_Stop_IT(\u0026obj-\u003ehandle,0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "finISR"
      ],
      "called": [
        "getTimerIrq",
        "HAL_NVIC_DisableIRQ",
        "HAL_TIM_OC_Stop_IT",
        "HAL_TIM_OC_DeInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_MspInit": {
      "entrypoint": "0x08007708",
      "current_name": "HAL_TIM_OC_MspInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_OC_MspInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  timer_enable_clock(htim);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_OC_Init"
      ],
      "called": [
        "timer_enable_clock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_MspDeInit": {
      "entrypoint": "0x08007710",
      "current_name": "HAL_TIM_OC_MspDeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef_conflict *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_OC_DeInit"
      ],
      "called": [
        "timer_disable_clock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_timer_obj": {
      "entrypoint": "0x08007718",
      "current_name": "get_timer_obj",
      "code": "\n/* WARNING: Unknown calling convention */\n\nstimer_t_conflict * get_timer_obj(TIM_HandleTypeDef_conflict *htim)\n\n{\n  return (stimer_t_conflict *)\u0026htim[-1].Lock;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_OC_DelayElapsedCallback",
        "HAL_TIM_PeriodElapsedCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_DelayElapsedCallback": {
      "entrypoint": "0x0800771c",
      "current_name": "HAL_TIM_OC_DelayElapsedCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  stimer_t_conflict *psVar1;\n  stimer_t_conflict *obj;\n  \n  psVar1 \u003d get_timer_obj(htim);\n  if ((psVar1-\u003eirqHandleOC !\u003d (_func_void_stimer_t_ptr_uint32_t_conflict *)0x0) \u0026\u0026\n     (htim-\u003eChannel \u003d\u003d HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*psVar1-\u003eirqHandleOC)(psVar1,0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [
        "get_timer_obj"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PeriodElapsedCallback": {
      "entrypoint": "0x08007736",
      "current_name": "HAL_TIM_PeriodElapsedCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef_conflict *htim)\n\n{\n  stimer_t_conflict *psVar1;\n  stimer_t_conflict *obj;\n  \n  psVar1 \u003d get_timer_obj(htim);\n  if (psVar1-\u003eirqHandle !\u003d (_func_void_stimer_t_ptr_conflict *)0x0) {\n    (*psVar1-\u003eirqHandle)(psVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [
        "get_timer_obj"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getTimerCounter": {
      "entrypoint": "0x08007744",
      "current_name": "getTimerCounter",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t getTimerCounter(stimer_t_conflict *obj)\n\n{\n  return ((obj-\u003ehandle).Instance)-\u003eCNT;\n}\n\n",
      "renaming": {},
      "calling": [
        "ServoIrqHandle"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setTimerCounter": {
      "entrypoint": "0x0800774a",
      "current_name": "setTimerCounter",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setTimerCounter(stimer_t_conflict *obj,uint32_t value)\n\n{\n  ((obj-\u003ehandle).Instance)-\u003eCNT \u003d value;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "ServoIrqHandle"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setCCRRegister": {
      "entrypoint": "0x08007750",
      "current_name": "setCCRRegister",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setCCRRegister(stimer_t_conflict *obj,uint32_t channel,uint32_t value)\n\n{\n  (\u0026((obj-\u003ehandle).Instance)-\u003eCCR1)[channel] \u003d value;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "ServoIrqHandle"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM1_UP_IRQHandler": {
      "entrypoint": "0x08007760",
      "current_name": "TIM1_UP_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM1_UP_IRQHandler(void)\n\n{\n  if (timer_handles[0] !\u003d (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[0]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM2_IRQHandler": {
      "entrypoint": "0x08007774",
      "current_name": "TIM2_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM2_IRQHandler(void)\n\n{\n  if (timer_handles[1] !\u003d (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[1]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM3_IRQHandler": {
      "entrypoint": "0x08007788",
      "current_name": "TIM3_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM3_IRQHandler(void)\n\n{\n  if (timer_handles[2] !\u003d (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM4_IRQHandler": {
      "entrypoint": "0x0800779c",
      "current_name": "TIM4_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM4_IRQHandler(void)\n\n{\n  if (timer_handles[3] !\u003d (TIM_HandleTypeDef_conflict *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[3]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "i2c_custom_init": {
      "entrypoint": "0x080077b0",
      "current_name": "i2c_custom_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid i2c_custom_init(i2c_t_conflict *obj,i2c_timing_e_conflict timing,uint32_t addressingMode,\n                    uint32_t ownAddress,uint8_t master)\n\n{\n  void *a;\n  I2C_TypeDef_conflict *i2c_sda;\n  void *b;\n  I2C_TypeDef_conflict *i2c_scl;\n  I2C_TypeDef_conflict *pIVar1;\n  GPIO_TypeDef *pGVar2;\n  GPIO_TypeDef *port;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_14;\n  uint32_t tmpreg_15;\n  uint32_t tmpreg_17;\n  uint32_t tmpreg_18;\n  uint32_t tmpreg_19;\n  uint32_t tmpreg_20;\n  uint32_t tmpreg_21;\n  uint32_t tmpreg_22;\n  uint32_t tmpreg_23;\n  uint32_t tmpreg_24;\n  uint32_t tmpreg_25;\n  uint32_t tmpreg_26;\n  uint32_t tmpreg_27;\n  uint32_t tmpreg_28;\n  uint32_t tmpreg_29;\n  I2C_HandleTypeDef_conflict *hi2c;\n  I2C_HandleTypeDef_conflict *handle;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_16;\n  uint32_t tmpreg_2;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj !\u003d (i2c_t_conflict *)0x0) {\n    hi2c \u003d \u0026obj-\u003ehandle;\n    a \u003d pinmap_peripheral(obj-\u003esda,(PinMap_conflict *)\u0026PinMap_I2C_SDA);\n    b \u003d pinmap_peripheral(obj-\u003escl,(PinMap_conflict *)\u0026PinMap_I2C_SCL);\n    if ((a \u003d\u003d (void *)0x0) || (b \u003d\u003d (void *)0x0)) {\n      iprintf(\"ERROR: at least one I2C pin has no peripheral\\n\");\n    }\n    else {\n      pIVar1 \u003d (I2C_TypeDef_conflict *)pinmap_merge_peripheral(a,b);\n      obj-\u003ei2c \u003d pIVar1;\n      if (pIVar1 \u003d\u003d (I2C_TypeDef_conflict *)0x0) {\n        iprintf(\"ERROR: I2C pins mismatch\\n\");\n      }\n      else {\n        if (pIVar1 \u003d\u003d (I2C_TypeDef_conflict *)0x40005400) {\n          _DAT_4002101c \u003d _DAT_4002101c | 0x200000;\n          _DAT_40021010 \u003d _DAT_40021010 \u0026 0xffdfffff;\n          obj-\u003eirq \u003d I2C1_EV_IRQn;\n          obj-\u003eirqER \u003d I2C1_ER_IRQn;\n          i2c_handles \u003d hi2c;\n        }\n        if (obj-\u003ei2c \u003d\u003d (I2C_TypeDef_conflict *)0x40005800) {\n          _DAT_4002101c \u003d _DAT_4002101c | 0x400000;\n          _DAT_40021010 \u003d _DAT_40021010 \u0026 0xffbfffff;\n          obj-\u003eirq \u003d I2C2_EV_IRQn;\n          obj-\u003eirqER \u003d I2C2_ER_IRQn;\n          I2C2_ER_IRQHandler::handle \u003d hi2c;\n        }\n        pGVar2 \u003d set_GPIO_Port_Clock((uint)((int)obj-\u003escl \u003c\u003c 0x18) \u003e\u003e 0x1c);\n        port \u003d (GPIO_TypeDef *)(int)obj-\u003escl;\n        GPIO_InitStruct.Pin \u003d 1 \u003c\u003c ((uint)port \u0026 0xf) \u0026 0xffff;\n        uVar3 \u003d pinmap_function(obj-\u003escl,(PinMap_conflict *)\u0026PinMap_I2C_SCL);\n        uVar4 \u003d pinmap_function(obj-\u003escl,(PinMap_conflict *)\u0026PinMap_I2C_SCL);\n        GPIO_InitStruct.Mode \u003d (uVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 4 | uVar4 \u0026 7;\n        GPIO_InitStruct.Speed \u003d 3;\n        uVar3 \u003d pinmap_function(obj-\u003escl,(PinMap_conflict *)\u0026PinMap_I2C_SCL);\n        GPIO_InitStruct.Pull \u003d (uVar3 \u003c\u003c 0x1a) \u003e\u003e 0x1e;\n        uVar3 \u003d pinmap_function(obj-\u003escl,(PinMap_conflict *)\u0026PinMap_I2C_SCL);\n        _DAT_40021018 \u003d _DAT_40021018 | 1;\n        switch((uVar3 \u003c\u003c 0x11) \u003e\u003e 0x19) {\n        case 1:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_3 \u003d tmpreg_26 \u0026 0xffffffcf;\n          tmpreg_26 \u003d tmpreg_3 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_4 \u003d tmpreg_26 \u0026 0xffffffcf;\n          tmpreg_26 \u003d tmpreg_4 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_26 \u003d tmpreg_26 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_5 \u003d tmpreg_26 \u0026 0xffffff3f;\n          tmpreg_26 \u003d tmpreg_5 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_6 \u003d tmpreg_26 \u0026 0xffffff3f;\n          tmpreg_26 \u003d tmpreg_6 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_7 \u003d tmpreg_26 \u0026 0xfffffcff;\n          tmpreg_26 \u003d tmpreg_7 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_8 \u003d tmpreg_26 \u0026 0xfffffcff;\n          tmpreg_26 \u003d tmpreg_8 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_9 \u003d tmpreg_26 \u0026 0xfffffcff;\n          tmpreg_26 \u003d tmpreg_9 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_10 \u003d tmpreg_26 \u0026 0xfffff3ff;\n          tmpreg_26 \u003d tmpreg_10 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_11 \u003d tmpreg_26 \u0026 0xfffff3ff;\n          tmpreg_26 \u003d tmpreg_11 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_26 \u003d tmpreg_26 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_26 \u003d tmpreg_26 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_12 \u003d tmpreg_26 \u0026 0xf8ffffff;\n          tmpreg_26 \u003d tmpreg_12;\n          break;\n        case 0x22:\n          tmpreg_13 \u003d tmpreg_26 \u0026 0xf8ffffff;\n          tmpreg_26 \u003d tmpreg_13 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_14 \u003d tmpreg_26 \u0026 0xf8ffffff;\n          tmpreg_26 \u003d tmpreg_14 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_15 \u003d tmpreg_26 \u0026 0xf8ffffff;\n          tmpreg_26 \u003d tmpreg_15 | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar2,\u0026GPIO_InitStruct);\n        pGVar2 \u003d set_GPIO_Port_Clock((uint)((int)obj-\u003esda \u003c\u003c 0x18) \u003e\u003e 0x1c);\n        GPIO_InitStruct.Pin \u003d 1 \u003c\u003c ((int)obj-\u003esda \u0026 0xfU) \u0026 0xffff;\n        uVar3 \u003d pinmap_function(obj-\u003esda,(PinMap_conflict *)\u0026PinMap_I2C_SDA);\n        uVar4 \u003d pinmap_function(obj-\u003esda,(PinMap_conflict *)\u0026PinMap_I2C_SDA);\n        GPIO_InitStruct.Mode \u003d (uVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 4 | uVar4 \u0026 7;\n        GPIO_InitStruct.Speed \u003d 3;\n        uVar3 \u003d pinmap_function(obj-\u003esda,(PinMap_conflict *)\u0026PinMap_I2C_SDA);\n        GPIO_InitStruct.Pull \u003d (uVar3 \u003c\u003c 0x1a) \u003e\u003e 0x1e;\n        uVar3 \u003d pinmap_function(obj-\u003esda,(PinMap_conflict *)\u0026PinMap_I2C_SDA);\n        _DAT_40021018 \u003d _DAT_40021018 | 1;\n        switch((uVar3 \u003c\u003c 0x11) \u003e\u003e 0x19) {\n        case 1:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_17 \u003d tmpreg_26 \u0026 0xffffffcf;\n          tmpreg_26 \u003d tmpreg_17 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_18 \u003d tmpreg_26 \u0026 0xffffffcf;\n          tmpreg_26 \u003d tmpreg_18 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_26 \u003d tmpreg_26 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_19 \u003d tmpreg_26 \u0026 0xffffff3f;\n          tmpreg_26 \u003d tmpreg_19 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_20 \u003d tmpreg_26 \u0026 0xffffff3f;\n          tmpreg_26 \u003d tmpreg_20 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_21 \u003d tmpreg_26 \u0026 0xfffffcff;\n          tmpreg_26 \u003d tmpreg_21 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_22 \u003d tmpreg_26 \u0026 0xfffffcff;\n          tmpreg_26 \u003d tmpreg_22 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_23 \u003d tmpreg_26 \u0026 0xfffffcff;\n          tmpreg_26 \u003d tmpreg_23 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_26 \u003d tmpreg_26 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_24 \u003d tmpreg_26 \u0026 0xfffff3ff;\n          tmpreg_26 \u003d tmpreg_24 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_25 \u003d tmpreg_26 \u0026 0xfffff3ff;\n          tmpreg_26 \u003d tmpreg_25 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_26 \u003d tmpreg_26 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_26 \u003d tmpreg_26 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_26 \u003d tmpreg_26 \u0026 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpreg_27 \u003d tmpreg_26 \u0026 0xf8ffffff;\n          tmpreg_26 \u003d tmpreg_27 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_28 \u003d tmpreg_26 \u0026 0xf8ffffff;\n          tmpreg_26 \u003d tmpreg_28 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_29 \u003d tmpreg_26 \u0026 0xf8ffffff;\n          tmpreg_26 \u003d tmpreg_29 | 0x4000000;\n        }\n        HAL_GPIO_Init(pGVar2,\u0026GPIO_InitStruct);\n        (obj-\u003ehandle).Instance \u003d obj-\u003ei2c;\n        (obj-\u003ehandle).Init.ClockSpeed \u003d timing;\n        (obj-\u003ehandle).Init.DutyCycle \u003d 0;\n        (obj-\u003ehandle).Init.OwnAddress1 \u003d ownAddress;\n        (obj-\u003ehandle).Init.OwnAddress2 \u003d 0xff;\n        (obj-\u003ehandle).Init.AddressingMode \u003d addressingMode;\n        (obj-\u003ehandle).Init.DualAddressMode \u003d 0;\n        (obj-\u003ehandle).Init.GeneralCallMode \u003d 0;\n        (obj-\u003ehandle).Init.NoStretchMode \u003d 0;\n        (obj-\u003ehandle).State \u003d HAL_I2C_STATE_RESET;\n        HAL_NVIC_SetPriority(obj-\u003eirq,0,1);\n        HAL_NVIC_EnableIRQ(obj-\u003eirq);\n        HAL_NVIC_SetPriority(obj-\u003eirqER,0,1);\n        HAL_NVIC_EnableIRQ(obj-\u003eirqER);\n        HAL_I2C_Init(hi2c);\n        obj-\u003eisMaster \u003d master;\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "pinmap_peripheral",
        "HAL_GPIO_Init",
        "pinmap_merge_peripheral",
        "set_GPIO_Port_Clock",
        "pinmap_function",
        "HAL_NVIC_SetPriority",
        "HAL_NVIC_EnableIRQ",
        "iprintf",
        "HAL_I2C_Init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "i2c_master_write": {
      "entrypoint": "0x08007e74",
      "current_name": "i2c_master_write",
      "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict\ni2c_master_write(i2c_t_conflict *obj,uint8_t dev_address,uint8_t *data,uint16_t size)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  HAL_StatusTypeDef_conflict HVar2;\n  uint32_t uVar3;\n  uint32_t tickstart;\n  uint32_t uVar4;\n  uint uVar5;\n  i2c_status_e_conflict iVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  \n  uVar3 \u003d HAL_GetTick();\n  uVar5 \u003d 0;\n  iVar6 \u003d I2C_ERROR;\n  do {\n    hi2c \u003d \u0026obj-\u003ehandle;\n    HVar2 \u003d HAL_I2C_Master_Transmit_IT(hi2c,(ushort)dev_address,data,size);\n    if (HVar2 \u003d\u003d HAL_OK) {\n      iVar6 \u003d I2C_OK;\n      while ((HVar1 \u003d HAL_I2C_GetState(hi2c), HVar1 !\u003d HAL_I2C_STATE_READY \u0026\u0026 (iVar6 \u003d\u003d I2C_OK))) {\n        uVar4 \u003d HAL_GetTick();\n        uVar5 \u003d uVar4 - uVar3;\n        if (uVar5 \u003c 0x65) {\n          uVar4 \u003d HAL_I2C_GetError(hi2c);\n          if (uVar4 !\u003d 0) {\n            iVar6 \u003d I2C_ERROR;\n          }\n        }\n        else {\n          iVar6 \u003d I2C_TIMEOUT;\n        }\n      }\n    }\n    uVar4 \u003d HAL_I2C_GetError(hi2c);\n  } while ((uVar4 \u003d\u003d 4) \u0026\u0026 (uVar5 \u003c 100));\n  return iVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "endTransmission"
      ],
      "called": [
        "HAL_I2C_GetError",
        "HAL_I2C_GetState",
        "HAL_I2C_Master_Transmit_IT",
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "i2c_slave_write_IT": {
      "entrypoint": "0x08007ede",
      "current_name": "i2c_slave_write_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict i2c_slave_write_IT(i2c_t_conflict *obj,uint8_t *data,uint16_t size)\n\n{\n  uint uVar1;\n  \n  if (0x20 \u003c size) {\n    return I2C_ERROR;\n  }\n  for (uVar1 \u003d 0; uVar1 \u003c size; uVar1 \u003d uVar1 + 1 \u0026 0xff) {\n    obj-\u003ei2cTxRxBuffer[uVar1] \u003d data[uVar1];\n    obj-\u003ei2cTxRxBufferSize \u003d obj-\u003ei2cTxRxBufferSize + \u0027\\x01\u0027;\n  }\n  return I2C_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "write",
        "write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "i2c_master_read": {
      "entrypoint": "0x08007f0e",
      "current_name": "i2c_master_read",
      "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_status_e_conflict\ni2c_master_read(i2c_t_conflict *obj,uint8_t dev_address,uint8_t *data,uint16_t size)\n\n{\n  HAL_I2C_StateTypeDef_conflict HVar1;\n  HAL_StatusTypeDef_conflict HVar2;\n  uint32_t uVar3;\n  uint32_t tickstart;\n  uint32_t uVar4;\n  uint uVar5;\n  i2c_status_e_conflict iVar6;\n  I2C_HandleTypeDef_conflict *hi2c;\n  \n  uVar3 \u003d HAL_GetTick();\n  uVar5 \u003d 0;\n  iVar6 \u003d I2C_ERROR;\n  do {\n    hi2c \u003d \u0026obj-\u003ehandle;\n    HVar2 \u003d HAL_I2C_Master_Receive_IT(hi2c,(ushort)dev_address,data,size);\n    if (HVar2 \u003d\u003d HAL_OK) {\n      iVar6 \u003d I2C_OK;\n      while ((HVar1 \u003d HAL_I2C_GetState(hi2c), HVar1 !\u003d HAL_I2C_STATE_READY \u0026\u0026 (iVar6 \u003d\u003d I2C_OK))) {\n        uVar4 \u003d HAL_GetTick();\n        uVar5 \u003d uVar4 - uVar3;\n        if (uVar5 \u003c 0x65) {\n          uVar4 \u003d HAL_I2C_GetError(hi2c);\n          if (uVar4 !\u003d 0) {\n            iVar6 \u003d I2C_ERROR;\n          }\n        }\n        else {\n          iVar6 \u003d I2C_TIMEOUT;\n        }\n      }\n    }\n    uVar4 \u003d HAL_I2C_GetError(hi2c);\n  } while ((uVar4 \u003d\u003d 4) \u0026\u0026 (uVar5 \u003c 100));\n  return iVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "requestFrom"
      ],
      "called": [
        "HAL_I2C_Master_Receive_IT",
        "HAL_I2C_GetError",
        "HAL_I2C_GetState",
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_i2c_obj": {
      "entrypoint": "0x08007f78",
      "current_name": "get_i2c_obj",
      "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t_conflict * get_i2c_obj(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  return (i2c_t_conflict *)\u0026hi2c[-1].EventCount;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_AddrCallback",
        "HAL_I2C_ErrorCallback",
        "HAL_I2C_ListenCpltCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "i2c_attachSlaveRxEvent": {
      "entrypoint": "0x08007f7c",
      "current_name": "i2c_attachSlaveRxEvent",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid i2c_attachSlaveRxEvent(i2c_t_conflict *obj,_func_void_uint8_t_ptr_int *function)\n\n{\n  if (obj !\u003d (i2c_t_conflict *)0x0) {\n    if (function !\u003d (_func_void_uint8_t_ptr_int *)0x0) {\n      obj-\u003ei2c_onSlaveReceive \u003d function;\n      HAL_I2C_EnableListen_IT(\u0026obj-\u003ehandle);\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "HAL_I2C_EnableListen_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "i2c_attachSlaveTxEvent": {
      "entrypoint": "0x08007f8e",
      "current_name": "i2c_attachSlaveTxEvent",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid i2c_attachSlaveTxEvent(i2c_t_conflict *obj,_func_void *function)\n\n{\n  if (obj !\u003d (i2c_t_conflict *)0x0) {\n    if (function !\u003d (_func_void *)0x0) {\n      obj-\u003ei2c_onSlaveTransmit \u003d function;\n      HAL_I2C_EnableListen_IT(\u0026obj-\u003ehandle);\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "HAL_I2C_EnableListen_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_AddrCallback": {
      "entrypoint": "0x08007fa0",
      "current_name": "HAL_I2C_AddrCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_AddrCallback\n               (I2C_HandleTypeDef_conflict *hi2c,uint8_t TransferDirection,uint16_t AddrMatchCode)\n\n{\n  i2c_t_conflict *piVar1;\n  i2c_t_conflict *obj;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if ((uint)AddrMatchCode \u003d\u003d (hi2c-\u003eInit).OwnAddress1) {\n    if (TransferDirection \u003d\u003d \u0027\\0\u0027) {\n      piVar1-\u003ei2cTxRxBufferSize \u003d \u0027\\0\u0027;\n      piVar1-\u003eslaveMode \u003d \u0027\\0\u0027;\n      if (piVar1-\u003ei2c_onSlaveTransmit !\u003d (_func_void *)0x0) {\n        (*piVar1-\u003ei2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (hi2c,piVar1-\u003ei2cTxRxBuffer,(ushort)piVar1-\u003ei2cTxRxBufferSize,8);\n      return;\n    }\n    piVar1-\u003eslaveMode \u003d \u0027\\x01\u0027;\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c,piVar1-\u003ei2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_Slave_ADDR"
      ],
      "called": [
        "HAL_I2C_Slave_Sequential_Receive_IT",
        "get_i2c_obj",
        "HAL_I2C_Slave_Sequential_Transmit_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_ListenCpltCallback": {
      "entrypoint": "0x08007ff0",
      "current_name": "HAL_I2C_ListenCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  i2c_t_conflict *piVar1;\n  i2c_t_conflict *obj;\n  uint uVar2;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if (((piVar1-\u003ei2c_onSlaveReceive !\u003d (_func_void_uint8_t_ptr_int *)0x0) \u0026\u0026\n      (piVar1-\u003eslaveMode \u003d\u003d \u0027\\x01\u0027)) \u0026\u0026\n     (uVar2 \u003d 0x20 - *(byte *)\u0026(piVar1-\u003ehandle).XferSize \u0026 0xff, uVar2 !\u003d 0)) {\n    (*piVar1-\u003ei2c_onSlaveReceive)(piVar1-\u003ei2cTxRxBuffer,uVar2);\n  }\n  HAL_I2C_EnableListen_IT(hi2c);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_Slave_STOPF",
        "I2C_ITError",
        "I2C_Slave_AF"
      ],
      "called": [
        "get_i2c_obj",
        "HAL_I2C_EnableListen_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_ErrorCallback": {
      "entrypoint": "0x08008020",
      "current_name": "HAL_I2C_ErrorCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef_conflict *hi2c)\n\n{\n  i2c_t_conflict *piVar1;\n  i2c_t_conflict *obj;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if (piVar1-\u003eisMaster \u003d\u003d \u0027\\0\u0027) {\n    HAL_I2C_EnableListen_IT(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_ITError",
        "I2C_DMAAbort"
      ],
      "called": [
        "get_i2c_obj",
        "HAL_I2C_EnableListen_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C1_EV_IRQHandler": {
      "entrypoint": "0x08008038",
      "current_name": "I2C1_EV_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C1_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c_handles);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C1_ER_IRQHandler": {
      "entrypoint": "0x08008048",
      "current_name": "I2C1_ER_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C1_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C2_EV_IRQHandler": {
      "entrypoint": "0x08008058",
      "current_name": "I2C2_EV_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C2_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(I2C2_ER_IRQHandler::handle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C2_ER_IRQHandler": {
      "entrypoint": "0x08008068",
      "current_name": "I2C2_ER_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C2_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(I2C2_ER_IRQHandler::handle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_init": {
      "entrypoint": "0x08008078",
      "current_name": "uart_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid uart_init(serial_t *obj)\n\n{\n  void *a;\n  USART_TypeDef *uart_tx;\n  void *b;\n  USART_TypeDef *uart_rx;\n  USART_TypeDef *pUVar1;\n  GPIO_TypeDef *pGVar2;\n  GPIO_TypeDef *port;\n  uint32_t uVar3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  uint32_t tmpreg_11;\n  uint32_t tmpreg_12;\n  uint32_t tmpreg_13;\n  uint32_t tmpreg_14;\n  uint32_t tmpreg_15;\n  uint32_t tmpreg_16;\n  UART_HandleTypeDef *huart;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    a \u003d pinmap_peripheral(obj-\u003epin_tx,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    b \u003d pinmap_peripheral(obj-\u003epin_rx,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    if ((b \u003d\u003d (void *)0x0) || (a \u003d\u003d (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      pUVar1 \u003d (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj-\u003euart \u003d pUVar1;\n      if (pUVar1 \u003d\u003d (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40013800) {\n          _DAT_4002100c \u003d _DAT_4002100c \u0026 0xffffbfff;\n          _DAT_40021018 \u003d _DAT_40021018 | 0x4000;\n          obj-\u003eindex \u003d \u0027\\0\u0027;\n          obj-\u003eirq \u003d USART1_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40004400) {\n          _DAT_40021010 \u003d _DAT_40021010 \u0026 0xfffdffff;\n          _DAT_4002101c \u003d _DAT_4002101c | 0x20000;\n          obj-\u003eindex \u003d \u0027\\x01\u0027;\n          obj-\u003eirq \u003d USART2_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40004800) {\n          _DAT_40021010 \u003d _DAT_40021010 \u0026 0xfffbffff;\n          _DAT_4002101c \u003d _DAT_4002101c | 0x40000;\n          obj-\u003eindex \u003d \u0027\\x02\u0027;\n          obj-\u003eirq \u003d USART3_IRQn;\n        }\n        pGVar2 \u003d set_GPIO_Port_Clock((uint)((int)obj-\u003epin_rx \u003c\u003c 0x18) \u003e\u003e 0x1c);\n        uVar3 \u003d pinmap_function(obj-\u003epin_rx,(PinMap_conflict *)\u0026PinMap_UART_RX);\n        GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (obj-\u003epin_rx \u0026 0xfU) \u0026 0xffff;\n        GPIO_InitStruct.Mode \u003d (uVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 4 | uVar3 \u0026 7;\n        GPIO_InitStruct.Pull \u003d (uVar3 \u003c\u003c 0x1a) \u003e\u003e 0x1e;\n        _DAT_40021018 \u003d _DAT_40021018 | 1;\n        switch((uVar3 \u003c\u003c 0x11) \u003e\u003e 0x19) {\n        case 1:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000001;\n          break;\n        case 2:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000002;\n          break;\n        case 4:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000004;\n          break;\n        case 6:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000008;\n          break;\n        case 8:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000030;\n          break;\n        case 10:\n          tmpreg_4 \u003d tmpreg_13 \u0026 0xffffffcf;\n          tmpreg_13 \u003d tmpreg_4 | 0x7000010;\n          break;\n        case 0xb:\n          tmpreg_5 \u003d tmpreg_13 \u0026 0xffffffcf;\n          tmpreg_13 \u003d tmpreg_5 | 0x7000000;\n          break;\n        case 0xc:\n          tmpreg_13 \u003d tmpreg_13 | 0x70000c0;\n          break;\n        case 0xd:\n          tmpreg_6 \u003d tmpreg_13 \u0026 0xffffff3f;\n          tmpreg_13 \u003d tmpreg_6 | 0x7000040;\n          break;\n        case 0xe:\n          tmpreg_7 \u003d tmpreg_13 \u0026 0xffffff3f;\n          tmpreg_13 \u003d tmpreg_7 | 0x7000000;\n          break;\n        case 0xf:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000300;\n          break;\n        case 0x10:\n          tmpreg_8 \u003d tmpreg_13 \u0026 0xfffffcff;\n          tmpreg_13 \u003d tmpreg_8 | 0x7000200;\n          break;\n        case 0x11:\n          tmpreg_9 \u003d tmpreg_13 \u0026 0xfffffcff;\n          tmpreg_13 \u003d tmpreg_9 | 0x7000100;\n          break;\n        case 0x12:\n          tmpreg_10 \u003d tmpreg_13 \u0026 0xfffffcff;\n          tmpreg_13 \u003d tmpreg_10 | 0x7000000;\n          break;\n        case 0x13:\n          tmpreg_13 \u003d tmpreg_13 | 0x7000c00;\n          break;\n        case 0x14:\n          tmpreg_11 \u003d tmpreg_13 \u0026 0xfffff3ff;\n          tmpreg_13 \u003d tmpreg_11 | 0x7000800;\n          break;\n        case 0x15:\n          tmpreg_12 \u003d tmpreg_13 \u0026 0xfffff3ff;\n          tmpreg_13 \u003d tmpreg_12 | 0x7000000;\n          break;\n        case 0x16:\n          tmpreg_13 \u003d tmpreg_13 | 0x7001000;\n          break;\n        case 0x17:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          tmpreg_13 \u003d tmpreg_13 | 0x7008000;\n          break;\n        case 0x1c:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          tmpreg_13 \u003d tmpreg_13 \u0026 0xf8ffffff;\n          break;\n        case 0x22:\n          tmpreg_14 \u003d tmpreg_13 \u0026 0xf8ffffff;\n          tmpreg_13 \u003d tmpreg_14 | 0x1000000;\n          break;\n        case 0x23:\n          tmpreg_15 \u003d tmpreg_13 \u0026 0xf8ffffff;\n          tmpreg_13 \u003d tmpreg_15 | 0x2000000;\n          break;\n        case 0x24:\n          tmpreg_16 \u003d tmpreg_13 \u0026 0xf8ffffff;\n          tmpreg_13 \u003d tmpreg_16 | 0x4000000;\n        }\n        GPIO_InitStruct.Speed \u003d 3;\n        HAL_GPIO_Init(pGVar2,\u0026GPIO_InitStruct);\n        pGVar2 \u003d set_GPIO_Port_Clock((uint)((int)obj-\u003epin_tx \u003c\u003c 0x18) \u003e\u003e 0x1c);\n        uVar3 \u003d pinmap_function(obj-\u003epin_tx,(PinMap_conflict *)\u0026PinMap_UART_TX);\n        GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (obj-\u003epin_tx \u0026 0xfU) \u0026 0xffff;\n        GPIO_InitStruct.Mode \u003d (uVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 4 | uVar3 \u0026 7;\n        GPIO_InitStruct.Pull \u003d (uVar3 \u003c\u003c 0x1a) \u003e\u003e 0x1e;\n        HAL_GPIO_Init(pGVar2,\u0026GPIO_InitStruct);\n        uart_handlers[obj-\u003eindex] \u003d \u0026obj-\u003ehandle;\n        (obj-\u003ehandle).Instance \u003d obj-\u003euart;\n        (obj-\u003ehandle).Init.BaudRate \u003d obj-\u003ebaudrate;\n        (obj-\u003ehandle).Init.WordLength \u003d obj-\u003edatabits;\n        (obj-\u003ehandle).Init.StopBits \u003d obj-\u003estopbits;\n        (obj-\u003ehandle).Init.Parity \u003d obj-\u003eparity;\n        (obj-\u003ehandle).Init.Mode \u003d 0xc;\n        (obj-\u003ehandle).Init.HwFlowCtl \u003d 0;\n        (obj-\u003ehandle).Init.OverSampling \u003d 0;\n        HAL_UART_Init(\u0026obj-\u003ehandle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin",
        "uart_debug_init"
      ],
      "called": [
        "pinmap_peripheral",
        "HAL_GPIO_Init",
        "pinmap_merge_peripheral",
        "set_GPIO_Port_Clock",
        "HAL_UART_Init",
        "pinmap_function",
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_debug_init": {
      "entrypoint": "0x080084b0",
      "current_name": "uart_debug_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid uart_debug_init(void)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d pinmap_peripheral(PA_2,(PinMap_conflict *)\u0026PinMap_UART_TX);\n  if (pvVar1 !\u003d (void *)0x0) {\n    pvVar1 \u003d pinmap_peripheral(PA_2,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    serial_debug.pin_rx \u003d pinmap_pin(pvVar1,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    serial_debug.pin_tx \u003d PA_2;\n    serial_debug.baudrate \u003d 0x2580;\n    serial_debug.parity \u003d 0;\n    serial_debug.databits \u003d 0;\n    serial_debug.stopbits \u003d 0;\n    uart_init(\u0026serial_debug);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_write"
      ],
      "called": [
        "pinmap_peripheral",
        "pinmap_pin",
        "uart_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_debug_write": {
      "entrypoint": "0x08008500",
      "current_name": "uart_debug_write",
      "code": "\n/* WARNING: Unknown calling convention */\n\nsize_t uart_debug_write(uint8_t *data,uint32_t size)\n\n{\n  HAL_StatusTypeDef_conflict HVar1;\n  uint32_t uVar2;\n  uint32_t tickstart;\n  void *pvVar3;\n  USART_TypeDef *pUVar4;\n  uint32_t uVar5;\n  uint uVar6;\n  \n  uVar2 \u003d HAL_GetTick();\n  pvVar3 \u003d pinmap_peripheral(PA_2,(PinMap_conflict *)\u0026PinMap_UART_TX);\n  if (pvVar3 \u003d\u003d (void *)0x0) {\n    return 0;\n  }\n  uVar6 \u003d 0;\n  while ((uVar6 \u003c 5 \u0026\u0026\n         ((uart_handlers[uVar6] \u003d\u003d (UART_HandleTypeDef *)0x0 ||\n          (pUVar4 \u003d (USART_TypeDef *)pinmap_peripheral(PA_2,(PinMap_conflict *)\u0026PinMap_UART_TX),\n          uart_handlers[uVar6]-\u003eInstance !\u003d pUVar4))))) {\n    uVar6 \u003d uVar6 + 1 \u0026 0xff;\n  }\n  if (4 \u003c uVar6) {\n    if ((4 \u003c serial_debug.index) \u0026\u0026 (uart_debug_init(), 4 \u003c serial_debug.index)) {\n      return 0;\n    }\n    uVar6 \u003d (uint)serial_debug.index;\n  }\n  do {\n    HVar1 \u003d HAL_UART_Transmit(uart_handlers[uVar6],data,(uint16_t)size,1000);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      return size;\n    }\n    uVar5 \u003d HAL_GetTick();\n  } while (uVar5 - uVar2 \u003c 1000);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_write"
      ],
      "called": [
        "pinmap_peripheral",
        "HAL_UART_Transmit",
        "HAL_GetTick",
        "uart_debug_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_rx_active": {
      "entrypoint": "0x080085b8",
      "current_name": "serial_rx_active",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t serial_rx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 \u003d HAL_UART_GetState(uart_handlers[obj-\u003eindex]);\n  return (HVar1 \u0026 0x22) \u003d\u003d 0x22;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_rx_callback",
        "uart_getc"
      ],
      "called": [
        "HAL_UART_GetState"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_tx_active": {
      "entrypoint": "0x080085dc",
      "current_name": "serial_tx_active",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t serial_tx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 \u003d HAL_UART_GetState(uart_handlers[obj-\u003eindex]);\n  return (HVar1 \u0026 0x21) \u003d\u003d 0x21;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [
        "HAL_UART_GetState"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_getc": {
      "entrypoint": "0x08008600",
      "current_name": "uart_getc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint uart_getc(serial_t *obj,uchar *c)\n\n{\n  uint8_t uVar1;\n  \n  if (obj \u003d\u003d (serial_t *)0x0) {\n    return -1;\n  }\n  uVar1 \u003d serial_rx_active(obj);\n  if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n    *c \u003d obj-\u003erecv;\n    HAL_UART_Receive_IT(uart_handlers[obj-\u003eindex],\u0026obj-\u003erecv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rx_complete_irq"
      ],
      "called": [
        "HAL_UART_Receive_IT",
        "serial_rx_active"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_attach_rx_callback": {
      "entrypoint": "0x0800863c",
      "current_name": "uart_attach_rx_callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid uart_attach_rx_callback(serial_t *obj,_func_void_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    uVar2 \u003d serial_rx_active(obj);\n    if (uVar2 \u003d\u003d \u0027\\0\u0027) {\n      bVar1 \u003d obj-\u003eindex;\n      rx_callback[bVar1] \u003d callback;\n      rx_callback_obj[bVar1] \u003d obj;\n      HAL_NVIC_SetPriority(obj-\u003eirq,0,1);\n      HAL_NVIC_EnableIRQ(obj-\u003eirq);\n      HAL_UART_Receive_IT(uart_handlers[obj-\u003eindex],\u0026obj-\u003erecv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "HAL_NVIC_EnableIRQ",
        "HAL_NVIC_SetPriority",
        "HAL_UART_Receive_IT",
        "serial_rx_active"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_attach_tx_callback": {
      "entrypoint": "0x08008694",
      "current_name": "uart_attach_tx_callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid uart_attach_tx_callback(serial_t *obj,_func_int_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    bVar1 \u003d obj-\u003eindex;\n    tx_callback[bVar1] \u003d callback;\n    tx_callback_obj[bVar1] \u003d obj;\n    HAL_NVIC_SetPriority(obj-\u003eirq,0,2);\n    HAL_NVIC_EnableIRQ(obj-\u003eirq);\n    HAL_UART_Transmit_IT(uart_handlers[obj-\u003eindex],obj-\u003etx_buff + obj-\u003etx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [
        "HAL_UART_Transmit_IT",
        "HAL_NVIC_EnableIRQ",
        "HAL_NVIC_SetPriority"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_index": {
      "entrypoint": "0x080086e8",
      "current_name": "uart_index",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t uart_index(UART_HandleTypeDef *huart)\n\n{\n  uint uVar1;\n  \n  if (huart \u003d\u003d (UART_HandleTypeDef *)0x0) {\n    uVar1 \u003d 5;\n  }\n  else {\n    uVar1 \u003d 0;\n    while( true ) {\n      if (4 \u003c uVar1) {\n        return (uint8_t)uVar1;\n      }\n      if (huart \u003d\u003d uart_handlers[uVar1]) break;\n      uVar1 \u003d uVar1 + 1 \u0026 0xff;\n    }\n  }\n  return (uint8_t)uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_RxCpltCallback",
        "HAL_UART_TxCpltCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_RxCpltCallback": {
      "entrypoint": "0x0800870c",
      "current_name": "HAL_UART_RxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint8_t index;\n  uint uVar2;\n  \n  bVar1 \u003d uart_index(huart);\n  uVar2 \u003d (uint)bVar1;\n  if (uVar2 \u003c 5) {\n    (*rx_callback[uVar2])(rx_callback_obj[uVar2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_Receive_IT"
      ],
      "called": [
        "uart_index"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_TxCpltCallback": {
      "entrypoint": "0x08008730",
      "current_name": "HAL_UART_TxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint8_t index;\n  int iVar3;\n  serial_t *obj;\n  serial_t *psVar4;\n  uint uVar2;\n  \n  bVar1 \u003d uart_index(huart);\n  uVar2 \u003d (uint)bVar1;\n  psVar4 \u003d tx_callback_obj[uVar2];\n  if ((uVar2 \u003c 5) \u0026\u0026 (iVar3 \u003d (*tx_callback[uVar2])(psVar4), iVar3 !\u003d -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[psVar4-\u003eindex],psVar4-\u003etx_buff + psVar4-\u003etx_tail,1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_EndTransmit_IT"
      ],
      "called": [
        "HAL_UART_Transmit_IT",
        "uart_index"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_ErrorCallback": {
      "entrypoint": "0x0800877c",
      "current_name": "HAL_UART_ErrorCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)\n\n{\n  uint32_t tmpval;\n  \n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_DMAAbortOnError",
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART1_IRQHandler": {
      "entrypoint": "0x080087bc",
      "current_name": "USART1_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART1_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[0]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_UART_IRQHandler",
        "HAL_NVIC_ClearPendingIRQ"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART2_IRQHandler": {
      "entrypoint": "0x080087d4",
      "current_name": "USART2_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART2_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[1]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART3_IRQHandler": {
      "entrypoint": "0x080087ec",
      "current_name": "USART3_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART3_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  if (uart_handlers[2] !\u003d (UART_HandleTypeDef *)0x0) {\n    HAL_UART_IRQHandler(uart_handlers[2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_UART_IRQHandler",
        "HAL_NVIC_ClearPendingIRQ"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk": {
      "entrypoint": "0x08008804",
      "current_name": "_sbrk",
      "code": "\nvoid * _sbrk(intptr_t __delta)\n\n{\n  char *pcVar1;\n  char *prev_heap_end;\n  \n  if (_sbrk::heap_end \u003d\u003d (char *)0x0) {\n    _sbrk::heap_end \u003d \u0026_ebss;\n  }\n  pcVar1 \u003d _sbrk::heap_end;\n  if (_sbrk::heap_end + __delta \u003c\u003d \u0026stack0x00000000) {\n    _sbrk::heap_end \u003d _sbrk::heap_end + __delta;\n    return pcVar1;\n  }\n  errno \u003d 0xc;\n  return (void *)0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_sbrk_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close": {
      "entrypoint": "0x08008840",
      "current_name": "_close",
      "code": "\nint _close(int __fd)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_close_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat": {
      "entrypoint": "0x08008846",
      "current_name": "_fstat",
      "code": "\nint _fstat(int __fd,stat *__buf)\n\n{\n  *(undefined4 *)((int)\u0026__buf-\u003est_dev + 4) \u003d 0x2000;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fstat_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty": {
      "entrypoint": "0x08008850",
      "current_name": "_isatty",
      "code": "\nint _isatty(int __fd)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_isatty_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek": {
      "entrypoint": "0x08008854",
      "current_name": "_lseek",
      "code": "\n__off_t _lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_lseek_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read": {
      "entrypoint": "0x08008858",
      "current_name": "_read",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _read(int file_UNUSED,char *ptr_UNUSED,int len_UNUSED)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_read_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write": {
      "entrypoint": "0x0800885c",
      "current_name": "_write",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _write(int file_UNUSED,char *ptr,int len)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d uart_debug_write((uint8_t *)ptr,len);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_write_r"
      ],
      "called": [
        "uart_debug_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_exit": {
      "entrypoint": "0x08008868",
      "current_name": "_exit",
      "code": "\nvoid _exit(int __status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "_exit",
        "abort"
      ],
      "called": [
        "_exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_kill": {
      "entrypoint": "0x0800886c",
      "current_name": "_kill",
      "code": "\nint _kill(__pid_t __pid,int __sig)\n\n{\n  errno \u003d 0x16;\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_kill_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getpid": {
      "entrypoint": "0x0800887c",
      "current_name": "_getpid",
      "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_getpid_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "analogRead": {
      "entrypoint": "0x08008880",
      "current_name": "analogRead",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t analogRead(uint32_t ulPin)\n\n{\n  bool bVar1;\n  PinName_conflict p;\n  uint16_t uVar2;\n  uint32_t uVar3;\n  \n  if (ulPin \u003c 0xe) {\n    if (ulPin + 0x2e \u003c 0x3c) {\n      bVar1 \u003d true;\n    }\n    else {\n      bVar1 \u003d false;\n    }\n  }\n  else {\n    bVar1 \u003d ulPin \u003c 0x3c;\n  }\n  if (bVar1) {\n    if (ulPin \u003c 0xe) {\n      ulPin \u003d ulPin + 0x2e;\n    }\n    p \u003d (\u0026digitalPin)[ulPin];\n  }\n  else {\n    p \u003d NC;\n  }\n  if (p \u003d\u003d NC) {\n    uVar3 \u003d 0;\n  }\n  else {\n    uVar2 \u003d adc_read_value(p);\n    uVar3 \u003d (uint32_t)uVar2;\n    if (_readResolution !\u003d 0xc) {\n      if ((uint)_readResolution \u003c 0xc) {\n        return (uint)(uVar2 \u003e\u003e (0xcU - _readResolution \u0026 0xff));\n      }\n      return uVar3 \u003c\u003c (_readResolution - 0xcU \u0026 0xff);\n    }\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "reportAnalogCallback"
      ],
      "called": [
        "adc_read_value"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "analogWrite": {
      "entrypoint": "0x080088e0",
      "current_name": "analogWrite",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid analogWrite(uint32_t ulPin,uint32_t ulValue)\n\n{\n  _Bool _Var1;\n  PinName_conflict p;\n  \n  if (ulPin \u003c 0x3c) {\n    p \u003d (\u0026digitalPin)[ulPin];\n  }\n  else {\n    p \u003d NC;\n  }\n  if (p !\u003d NC) {\n    _Var1 \u003d pin_in_pinmap(p,(PinMap_conflict *)\u0026PinMap_PWM);\n    if (_Var1) {\n      _Var1 \u003d is_pin_configured(p,g_anOutputPinConfigured);\n      if (!_Var1) {\n        set_pin_configured(p,g_anOutputPinConfigured);\n      }\n      if (_writeResolution !\u003d 8) {\n        if ((uint)_writeResolution \u003c 9) {\n          ulValue \u003d ulValue \u003c\u003c (8U - _writeResolution \u0026 0xff);\n        }\n        else {\n          ulValue \u003d ulValue \u003e\u003e (_writeResolution - 8U \u0026 0xff);\n        }\n      }\n      pwm_start(p,0x3e418,0xff,ulValue,!_Var1);\n    }\n    else {\n      pinMode(ulPin,1);\n      if (_writeResolution !\u003d 8) {\n        if ((uint)_writeResolution \u003c 9) {\n          ulValue \u003d ulValue \u003c\u003c (8U - _writeResolution \u0026 0xff);\n        }\n        else {\n          ulValue \u003d ulValue \u003e\u003e (_writeResolution - 8U \u0026 0xff);\n        }\n      }\n      if (ulValue \u003c 0x80) {\n        digitalWrite(ulPin,0);\n      }\n      else {\n        digitalWrite(ulPin,1);\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback",
        "analogWriteCallback"
      ],
      "called": [
        "pinMode",
        "set_pin_configured",
        "digitalWrite",
        "pin_in_pinmap",
        "pwm_start",
        "is_pin_configured"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinMode": {
      "entrypoint": "0x08008990",
      "current_name": "pinMode",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pinMode(uint32_t ulPin,uint32_t ulMode)\n\n{\n  _Bool _Var1;\n  PinName_conflict p;\n  \n  if (ulPin \u003c 0x3c) {\n    p \u003d (\u0026digitalPin)[ulPin];\n  }\n  else {\n    p \u003d NC;\n  }\n  if (p !\u003d NC) {\n    _Var1 \u003d is_pin_configured(p,g_anOutputPinConfigured);\n    if (_Var1) {\n      _Var1 \u003d pin_in_pinmap(p,(PinMap_conflict *)\u0026PinMap_PWM);\n      if (_Var1) {\n        pwm_stop(p);\n      }\n      reset_pin_configured(p,g_anOutputPinConfigured);\n    }\n    switch(ulMode) {\n    case 0:\n      digital_io_init(p,0,0);\n      break;\n    case 1:\n      digital_io_init(p,1,0);\n      break;\n    case 2:\n      digital_io_init(p,0,1);\n      break;\n    case 3:\n      digital_io_init(p,0,2);\n    }\n    set_pin_configured(p,g_digPinConfigured);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setPinModeCallback",
        "digitalWriteCallback",
        "blinkVersion",
        "attach",
        "analogWrite"
      ],
      "called": [
        "digital_io_init",
        "pwm_stop",
        "set_pin_configured",
        "pin_in_pinmap",
        "is_pin_configured",
        "reset_pin_configured"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digitalWrite": {
      "entrypoint": "0x08008a24",
      "current_name": "digitalWrite",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid digitalWrite(uint32_t ulPin,uint32_t ulVal)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  PinName_conflict p;\n  uint uVar2;\n  \n  if (ulPin \u003c 0x3c) {\n    uVar2 \u003d (uint)(char)(\u0026digitalPin)[ulPin];\n  }\n  else {\n    uVar2 \u003d 0xffffffff;\n  }\n  if ((uVar2 !\u003d 0xffffffff) \u0026\u0026\n     (_Var1 \u003d is_pin_configured((PinName_conflict)uVar2,g_digPinConfigured), _Var1)) {\n    port \u003d get_GPIO_Port((uVar2 \u003c\u003c 0x18) \u003e\u003e 0x1c);\n    digital_io_write(port,1 \u003c\u003c (uVar2 \u0026 0xf) \u0026 0xffff,ulVal);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "strobeBlinkPin",
        "ServoIrqHandle",
        "setPinModeCallback",
        "digitalWriteCallback",
        "setPinValueCallback",
        "analogWrite"
      ],
      "called": [
        "digital_io_write",
        "get_GPIO_Port",
        "is_pin_configured"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digitalRead": {
      "entrypoint": "0x08008a6c",
      "current_name": "digitalRead",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint digitalRead(uint32_t ulPin)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  uint32_t uVar2;\n  PinName_conflict p;\n  uint uVar3;\n  \n  if (ulPin \u003c 0x3c) {\n    uVar3 \u003d (uint)(char)(\u0026digitalPin)[ulPin];\n  }\n  else {\n    uVar3 \u003d 0xffffffff;\n  }\n  if (uVar3 \u003d\u003d 0xffffffff) {\n    uVar3 \u003d 0;\n  }\n  else {\n    _Var1 \u003d is_pin_configured((PinName_conflict)uVar3,g_digPinConfigured);\n    if (_Var1) {\n      port \u003d get_GPIO_Port((uVar3 \u003c\u003c 0x18) \u003e\u003e 0x1c);\n      uVar2 \u003d digital_io_read(port,1 \u003c\u003c (uVar3 \u0026 0xf) \u0026 0xffff);\n      uVar3 \u003d uVar2 \u0026 0xff;\n    }\n    else {\n      uVar3 \u003d 0;\n    }\n  }\n  if (uVar3 !\u003d 0) {\n    uVar3 \u003d 1;\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "checkDigitalInputs",
        "reportDigitalCallback"
      ],
      "called": [
        "get_GPIO_Port",
        "is_pin_configured",
        "digital_io_read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "millis": {
      "entrypoint": "0x08008abc",
      "current_name": "millis",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t millis(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d GetCurrentMilli();\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "GetCurrentMilli"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "delay": {
      "entrypoint": "0x08008ac4",
      "current_name": "delay",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delay(uint32_t ms)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "strobeBlinkPin",
        "blinkVersion"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_tx_complete_irq": {
      "entrypoint": "0x08008ac6",
      "current_name": "_tx_complete_irq",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::_tx_complete_irq(serial_t_conflict *obj)\n\n{\n  ushort uVar1;\n  uint16_t uVar2;\n  int iVar3;\n  \n  iVar3 \u003d obj-\u003etx_tail + 1;\n  uVar1 \u003d (ushort)iVar3;\n  uVar2 \u003d uVar1 \u0026 0x7f;\n  if (iVar3 \u003d\u003d 0) {\n    uVar2 \u003d -(-uVar1 \u0026 0x7f);\n  }\n  obj-\u003etx_tail \u003d uVar2;\n  if (obj-\u003etx_head !\u003d obj-\u003etx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_rx_complete_irq": {
      "entrypoint": "0x08008b66",
      "current_name": "_rx_complete_irq",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HardwareSerial::_rx_complete_irq(serial_t_conflict *obj)\n\n{\n  int iVar1;\n  rx_buffer_index_t i;\n  ushort uVar2;\n  uchar c;\n  \n  iVar1 \u003d uart_getc((serial_t *)obj,\u0026c);\n  if ((iVar1 \u003d\u003d 0) \u0026\u0026 (uVar2 \u003d obj-\u003erx_head + 1 \u0026 0x3f, uVar2 !\u003d obj-\u003erx_tail)) {\n    obj-\u003erx_buff[obj-\u003erx_head] \u003d c;\n    obj-\u003erx_head \u003d uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "uart_getc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEventRun": {
      "entrypoint": "0x08008bf4",
      "current_name": "serialEventRun",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08008bfa) */\n/* WARNING: Removing unreachable block (ram,0x08008c0c) */\n/* WARNING: Removing unreachable block (ram,0x08008c02) */\n/* WARNING: Removing unreachable block (ram,0x08008c14) */\n/* WARNING: Unknown calling convention */\n\nvoid serialEventRun(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "available"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setRx": {
      "entrypoint": "0x08008d00",
      "current_name": "setRx",
      "code": "\n/* DWARF original prototype: void  setRx(HardwareSerial * this, uint32_t _rx) */\n\nvoid __thiscall HardwareSerial::setRx(HardwareSerial *this,uint32_t _rx)\n\n{\n  PinName PVar1;\n  \n  if (_rx \u003c 0x3c) {\n    PVar1 \u003d (\u0026digitalPin)[_rx];\n  }\n  else {\n    PVar1 \u003d NC;\n  }\n  (this-\u003e_serial).pin_rx \u003d PVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setTx": {
      "entrypoint": "0x08008d18",
      "current_name": "setTx",
      "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * this, uint32_t _tx) */\n\nvoid __thiscall HardwareSerial::setTx(HardwareSerial *this,uint32_t _tx)\n\n{\n  PinName PVar1;\n  \n  if (_tx \u003c 0x3c) {\n    PVar1 \u003d (\u0026digitalPin)[_tx];\n  }\n  else {\n    PVar1 \u003d NC;\n  }\n  (this-\u003e_serial).pin_tx \u003d PVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HardwareSerial": {
      "entrypoint": "0x08008d30",
      "current_name": "HardwareSerial",
      "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * this, void *\n   peripheral) */\n\nHardwareSerial * __thiscall HardwareSerial::HardwareSerial(HardwareSerial *this,void *peripheral)\n\n{\n  PinName_conflict PVar1;\n  EVP_PKEY_CTX *extraout_r1;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *extraout_r1_00;\n  \n  (this-\u003esuper_Stream).super_Print.write_error \u003d 0;\n  (this-\u003esuper_Stream)._timeout \u003d 1000;\n  (this-\u003esuper_Stream).super_Print._vptr_Print \u003d (_func_int_varargs **)\u0026PTR_write_1_0800aab8;\n  if (this \u003d\u003d \u0026Serial2) {\n    setRx(\u0026Serial2,0);\n    setTx(\u0026Serial2,1);\n    ctx \u003d extraout_r1_00;\n  }\n  else {\n    PVar1 \u003d pinmap_pin(peripheral,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    (this-\u003e_serial).pin_rx \u003d PVar1;\n    PVar1 \u003d pinmap_pin(peripheral,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    (this-\u003e_serial).pin_tx \u003d PVar1;\n    ctx \u003d extraout_r1;\n  }\n  init(this,ctx);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "setRx",
        "pinmap_pin",
        "setTx",
        "init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_Serial2": {
      "entrypoint": "0x08008db0",
      "current_name": "_GLOBAL__sub_I_Serial2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I_Serial2(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printTo": {
      "entrypoint": "0x08008dbe",
      "current_name": "printTo",
      "code": "\n/* DWARF original prototype: size_t  printTo(IPAddress * this, Print * p) */\n\nsize_t __thiscall IPAddress::printTo(IPAddress *this,Print *p)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar4 \u003d 0;\n  for (iVar3 \u003d 0; iVar3 \u003c 3; iVar3 \u003d iVar3 + 1) {\n    sVar1 \u003d Print::print(p,(this-\u003e_address).bytes[iVar3],10);\n    sVar2 \u003d Print::print(p,\u0027.\u0027);\n    iVar4 \u003d iVar4 + sVar1 + sVar2;\n  }\n  sVar1 \u003d Print::print(p,(this-\u003e_address).bytes[3],10);\n  return sVar1 + iVar4;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "print",
        "print"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "IPAddress": {
      "entrypoint": "0x08008df8",
      "current_name": "IPAddress",
      "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * this, uint8_t first_octet, uint8_t\n   second_octet, uint8_t third_octet, uint8_t fourth_octet) */\n\nIPAddress * __thiscall\nIPAddress::IPAddress\n          (IPAddress *this,uint8_t first_octet,uint8_t second_octet,uint8_t third_octet,\n          uint8_t fourth_octet)\n\n{\n  (this-\u003esuper_Printable)._vptr_Printable \u003d (_func_int_varargs **)\u0026DAT_0800ab0c;\n  (this-\u003e_address).bytes[0] \u003d first_octet;\n  (this-\u003e_address).bytes[1] \u003d second_octet;\n  (this-\u003e_address).bytes[2] \u003d third_octet;\n  (this-\u003e_address).bytes[3] \u003d fourth_octet;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I__ZN9IPAddressC2Ev": {
      "entrypoint": "0x08008e40",
      "current_name": "_GLOBAL__sub_I__ZN9IPAddressC2Ev",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I__ZN9IPAddressC2Ev(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print": {
      "entrypoint": "0x08008eec",
      "current_name": "print",
      "code": "\n/* DWARF original prototype: size_t  print(Print * this, uchar b, int base) */\n\nsize_t __thiscall Print::print(Print *this,uchar b,int base)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d print(this,(uint)b,base);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "printTo"
      ],
      "called": [
        "print"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printNumber": {
      "entrypoint": "0x08008e7c",
      "current_name": "printNumber",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08008ecc */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  printNumber(Print * this, ulong n, uint8_t base) */\n\nsize_t __thiscall Print::printNumber(Print *this,ulong n,uint8_t base)\n\n{\n  char cVar1;\n  char c;\n  size_t sVar2;\n  size_t sVar3;\n  ulong m;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char *__s;\n  char buf [33];\n  \n  uVar5 \u003d (uint)base;\n  buf[32] \u003d \u0027\\0\u0027;\n  if (uVar5 \u003c 2) {\n    uVar5 \u003d 10;\n  }\n  __s \u003d buf + 0x20;\n  m \u003d n;\n  do {\n    uVar6 \u003d m / uVar5;\n    uVar4 \u003d (m \u0026 0xff) - (uVar6 * uVar5 \u0026 0xff) \u0026 0xff;\n    __s \u003d __s + -1;\n    cVar1 \u003d (char)uVar4;\n    if (uVar4 \u003c 10) {\n      cVar1 \u003d cVar1 + \u00270\u0027;\n    }\n    else {\n      cVar1 \u003d cVar1 + \u00277\u0027;\n    }\n    *__s \u003d cVar1;\n    m \u003d uVar6;\n  } while (uVar6 !\u003d 0);\n  if (__s \u003d\u003d (char *)0x0) {\n    sVar3 \u003d 0;\n  }\n  else {\n    sVar2 \u003d strlen(__s);\n    sVar3 \u003d (*this-\u003e_vptr_Print[1])(sVar2,__s,sVar2);\n  }\n  return sVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "print"
      ],
      "called": [
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "map": {
      "entrypoint": "0x08008ef4",
      "current_name": "map",
      "code": "\n/* WARNING: Unknown calling convention */\n\nlong map(long x,long in_min,long in_max,long out_min,long out_max)\n\n{\n  return (uint)((out_max - out_min) * (x - in_min)) / (uint)(in_max - in_min) + out_min;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "initVariant": {
      "entrypoint": "0x08008f0c",
      "current_name": "initVariant",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initVariant(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "premain": {
      "entrypoint": "0x08008f0e",
      "current_name": "premain",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid premain(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  ctx \u003d (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(ctx);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [
        "init",
        "HAL_NVIC_SetPriorityGrouping"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main": {
      "entrypoint": "0x08008f1c",
      "current_name": "main",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint main(void)\n\n{\n  initVariant();\n  setup();\n  do {\n    loop();\n    serialEventRun();\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "initVariant",
        "serialEventRun",
        "loop",
        "setup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_pin_id": {
      "entrypoint": "0x08008f3c",
      "current_name": "get_pin_id",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t get_pin_id(uint16_t pin)\n\n{\n  uint uVar1;\n  uint8_t uVar2;\n  \n  uVar2 \u003d \u0027\\0\u0027;\n  for (uVar1 \u003d (uint)pin; uVar1 !\u003d 1; uVar1 \u003d uVar1 \u003e\u003e 1) {\n    uVar2 \u003d uVar2 + \u0027\\x01\u0027;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__tcf_0": {
      "entrypoint": "0x08008f50",
      "current_name": "__tcf_0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid __tcf_0(void *param_1)\n\n{\n  gpio_irq_conf_str *pgVar1;\n  _Manager_type p_Var2;\n  gpio_irq_conf_str *pgVar3;\n  \n  pgVar1 \u003d (gpio_irq_conf_str *)\u0026__malloc_free_list;\n  while (pgVar3 \u003d pgVar1, pgVar3 !\u003d gpio_irq_conf) {\n    p_Var2 \u003d pgVar3[-1].callback.super__Function_base._M_manager;\n    pgVar1 \u003d pgVar3 + -1;\n    if (p_Var2 !\u003d (_Manager_type)0x0) {\n      (*p_Var2)((_Any_data *)\u0026pgVar3[-1].callback,(_Any_data *)\u0026pgVar3[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI0_IRQHandler": {
      "entrypoint": "0x08009024",
      "current_name": "EXTI0_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI0_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI1_IRQHandler": {
      "entrypoint": "0x0800902e",
      "current_name": "EXTI1_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI1_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI2_IRQHandler": {
      "entrypoint": "0x08009038",
      "current_name": "EXTI2_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI2_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI3_IRQHandler": {
      "entrypoint": "0x08009042",
      "current_name": "EXTI3_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI3_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI4_IRQHandler": {
      "entrypoint": "0x0800904c",
      "current_name": "EXTI4_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI4_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(0x10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI9_5_IRQHandler": {
      "entrypoint": "0x08009056",
      "current_name": "EXTI9_5_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI9_5_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0x20; uVar1 \u003c 0x201; uVar1 \u003d uVar1 \u003c\u003c 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI15_10_IRQHandler": {
      "entrypoint": "0x0800906c",
      "current_name": "EXTI15_10_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI15_10_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0x400; uVar1 \u003c 0x8001; uVar1 \u003d uVar1 \u003c\u003c 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "operator()": {
      "entrypoint": "0x08009084",
      "current_name": "operator()",
      "code": "\n/* DWARF original prototype: void  operator()(function\u003cvoid()\u003e * this) */\n\nvoid __thiscall std::function\u003cvoid()\u003e::operator()(function\u003cvoid()\u003e *this)\n\n{\n  if ((this-\u003esuper__Function_base)._M_manager !\u003d (_Manager_type)0x0) {\n    (*this-\u003e_M_invoker)((_Any_data *)this);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "called": [
        "__throw_bad_function_call"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_EXTI_Callback": {
      "entrypoint": "0x08009094",
      "current_name": "HAL_GPIO_EXTI_Callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n\n{\n  byte bVar1;\n  uint8_t irq_id;\n  \n  bVar1 \u003d get_pin_id(GPIO_Pin);\n  if (gpio_irq_conf[bVar1].callback.super__Function_base._M_manager !\u003d (_Manager_type)0x0) {\n    std::function\u003cvoid()\u003e::operator()(\u0026gpio_irq_conf[bVar1].callback);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "called": [
        "get_pin_id",
        "operator()"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm": {
      "entrypoint": "0x080090b4",
      "current_name": "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_atexit": {
      "entrypoint": "0x080090c2",
      "current_name": "__aeabi_atexit",
      "code": "\nvoid __aeabi_atexit(undefined4 param_1,undefined4 param_2)\n\n{\n  __cxa_atexit(param_2,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "__cxa_atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__assert_func": {
      "entrypoint": "0x080090cc",
      "current_name": "__assert_func",
      "code": "\nvoid __assert_func(undefined4 param_1,undefined4 param_2,char *param_3,undefined4 param_4)\n\n{\n  char *pcVar1;\n  \n  if (param_3 \u003d\u003d (char *)0x0) {\n    param_3 \u003d \"\";\n    pcVar1 \u003d param_3;\n  }\n  else {\n    pcVar1 \u003d \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           param_4,param_1,param_2,pcVar1,param_3,param_4);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "abort",
        "fiprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_atexit": {
      "entrypoint": "0x08009108",
      "current_name": "__cxa_atexit",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08009110) */\n\nlonglong __cxa_atexit(undefined4 param_1,uint param_2)\n\n{\n  return (ulonglong)param_2 \u003c\u003c 0x20;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_atexit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fiprintf": {
      "entrypoint": "0x08009124",
      "current_name": "fiprintf",
      "code": "\nint fiprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 \u003d in_r2;\n  uStack_4 \u003d in_r3;\n  iVar1 \u003d _vfiprintf_r(_impure_ptr,__stream,__format,\u0026uStack_8,__stream,\u0026uStack_8);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__assert_func"
      ],
      "called": [
        "_vfiprintf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_init_array": {
      "entrypoint": "0x08009148",
      "current_name": "__libc_init_array",
      "code": "\nvoid __libc_init_array(void)\n\n{\n  int iVar1;\n  \n  for (iVar1 \u003d 0; iVar1 !\u003d 0; iVar1 \u003d iVar1 + 1) {\n    (*(code *)(\u0026__preinit_array_end)[iVar1])();\n  }\n  _init();\n  for (iVar1 \u003d 0; iVar1 !\u003d 0xc; iVar1 \u003d iVar1 + 1) {\n    (*(code *)(\u0026__preinit_array_end)[iVar1])();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "premain",
        "_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "malloc": {
      "entrypoint": "0x08009190",
      "current_name": "malloc",
      "code": "\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d (void *)_malloc_r(_impure_ptr,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "setFirmwareNameAndVersion"
      ],
      "called": [
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x080091a0",
      "current_name": "free",
      "code": "\nvoid free(void *__ptr)\n\n{\n  _free_r(_impure_ptr,__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setFirmwareNameAndVersion"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x080091b0",
      "current_name": "memcpy",
      "code": "\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar2 \u003d (undefined *)((int)__dest + -1);\n  puVar1 \u003d (undefined *)(__n + (int)__src);\n  for (; (undefined *)__src !\u003d puVar1; __src \u003d (void *)((int)__src + 1)) {\n    puVar2 \u003d puVar2 + 1;\n    *puVar2 \u003d *__src;\n                    /* WARNING: Load size is inaccurate */\n  }\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "write",
        "onReceiveService",
        "_realloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memset": {
      "entrypoint": "0x080091c6",
      "current_name": "memset",
      "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 \u003d (undefined *)__s; puVar1 !\u003d (undefined *)(__n + (int)__s); puVar1 \u003d puVar1 + 1) {\n    *puVar1 \u003d (char)__c;\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "endTransmission",
        "__sfmoreglue",
        "pwm_start",
        "std.isra.0",
        "adc_read_value",
        "flush",
        "begin",
        "__sfp"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_free_r": {
      "entrypoint": "0x080091d8",
      "current_name": "_free_r",
      "code": "\nvoid _free_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int **extraout_r1;\n  int **ppiVar1;\n  int **ppiVar2;\n  int *piVar3;\n  int **ppiVar4;\n  int **ppiVar5;\n  \n  if (param_2 \u003d\u003d 0) {\n    return;\n  }\n  ppiVar5 \u003d (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) \u003c 0) {\n    ppiVar5 \u003d (int **)((int)ppiVar5 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  ppiVar2 \u003d (int **)\u0026__malloc_free_list;\n  if (__malloc_free_list \u003d\u003d (int **)0x0) {\n    ppiVar5[1] \u003d (int *)0x0;\n    ppiVar1 \u003d extraout_r1;\n    __malloc_free_list \u003d ppiVar5;\n  }\n  else {\n    ppiVar2 \u003d __malloc_free_list;\n    if (ppiVar5 \u003c __malloc_free_list) {\n      ppiVar1 \u003d (int **)*ppiVar5;\n      ppiVar2 \u003d (int **)((int)ppiVar5 + (int)ppiVar1);\n      if (__malloc_free_list \u003d\u003d ppiVar2) {\n        piVar3 \u003d *__malloc_free_list;\n        __malloc_free_list \u003d (int **)__malloc_free_list[1];\n        ppiVar2 \u003d (int **)((int)piVar3 + (int)ppiVar1);\n        *ppiVar5 \u003d (int *)ppiVar2;\n      }\n      ppiVar5[1] \u003d (int *)__malloc_free_list;\n      __malloc_free_list \u003d ppiVar5;\n    }\n    else {\n      do {\n        ppiVar4 \u003d ppiVar2;\n        ppiVar2 \u003d (int **)ppiVar4[1];\n        if (ppiVar2 \u003d\u003d (int **)0x0) break;\n      } while (ppiVar2 \u003c\u003d ppiVar5);\n      ppiVar1 \u003d (int **)*ppiVar4;\n      if ((int **)((int)ppiVar4 + (int)ppiVar1) \u003d\u003d ppiVar5) {\n        ppiVar1 \u003d (int **)((int)ppiVar1 + (int)*ppiVar5);\n        *ppiVar4 \u003d (int *)ppiVar1;\n        if (ppiVar2 \u003d\u003d (int **)((int)ppiVar4 + (int)ppiVar1)) {\n          piVar3 \u003d *ppiVar2;\n          ppiVar2 \u003d (int **)ppiVar2[1];\n          ppiVar1 \u003d (int **)((int)ppiVar1 + (int)piVar3);\n          *ppiVar4 \u003d (int *)ppiVar1;\n          ppiVar4[1] \u003d (int *)ppiVar2;\n        }\n      }\n      else if (ppiVar5 \u003c (int **)((int)ppiVar4 + (int)ppiVar1)) {\n        *param_1 \u003d 0xc;\n      }\n      else {\n        ppiVar1 \u003d (int **)((int)ppiVar5 + (int)*ppiVar5);\n        if (ppiVar2 \u003d\u003d ppiVar1) {\n          piVar3 \u003d *ppiVar2;\n          ppiVar2 \u003d (int **)ppiVar2[1];\n          ppiVar1 \u003d (int **)((int)piVar3 + (int)*ppiVar5);\n          *ppiVar5 \u003d (int *)ppiVar1;\n        }\n        ppiVar5[1] \u003d (int *)ppiVar2;\n        ppiVar4[1] \u003d (int *)ppiVar5;\n      }\n    }\n  }\n  __malloc_unlock(param_1,ppiVar1,ppiVar2,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r",
        "__sflush_r",
        "_realloc_r",
        "free"
      ],
      "called": [
        "__malloc_lock",
        "__malloc_unlock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_r": {
      "entrypoint": "0x08009270",
      "current_name": "_malloc_r",
      "code": "\nuint _malloc_r(undefined4 *param_1,uint param_2)\n\n{\n  uint *puVar1;\n  int iVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint *puVar5;\n  uint uVar6;\n  \n  uVar6 \u003d (param_2 + 3 \u0026 0xfffffffc) + 8;\n  if (uVar6 \u003c 0xc) {\n    uVar6 \u003d 0xc;\n  }\n  if (((int)uVar6 \u003c 0) || (uVar6 \u003c param_2)) {\n    *param_1 \u003d 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 \u003d __malloc_free_list;\n    puVar5 \u003d __malloc_free_list;\n    while (puVar3 \u003d puVar1, puVar3 !\u003d (uint *)0x0) {\n      uVar4 \u003d *puVar3 - uVar6;\n      if (-1 \u003c (int)uVar4) {\n        if (uVar4 \u003c 0xc) {\n          if (puVar5 \u003d\u003d puVar3) {\n            puVar1 \u003d (uint *)puVar5[1];\n            __malloc_free_list \u003d puVar1;\n          }\n          else {\n            puVar1 \u003d (uint *)puVar3[1];\n          }\n          if (puVar5 !\u003d puVar3) {\n            puVar5[1] \u003d (uint)puVar1;\n            puVar5 \u003d puVar3;\n          }\n        }\n        else {\n          *puVar3 \u003d uVar4;\n          *(uint *)((int)puVar3 + uVar4) \u003d uVar6;\n          puVar5 \u003d (uint *)((int)puVar3 + uVar4);\n        }\n        goto LAB_080092d4;\n      }\n      puVar5 \u003d puVar3;\n      puVar1 \u003d (uint *)puVar3[1];\n    }\n    if (__malloc_sbrk_start \u003d\u003d 0) {\n      __malloc_sbrk_start \u003d _sbrk_r(param_1);\n    }\n    puVar1 \u003d (uint *)_sbrk_r(param_1,uVar6);\n    if ((puVar1 !\u003d (uint *)0xffffffff) \u0026\u0026\n       ((puVar5 \u003d (uint *)((int)puVar1 + 3U \u0026 0xfffffffc), puVar1 \u003d\u003d puVar5 ||\n        (iVar2 \u003d _sbrk_r(param_1,(int)puVar5 - (int)puVar1), iVar2 !\u003d -1)))) {\n      *puVar5 \u003d uVar6;\nLAB_080092d4:\n      __malloc_unlock(param_1);\n      uVar6 \u003d (int)puVar5 + 0xbU \u0026 0xfffffff8;\n      iVar2 \u003d uVar6 - (int)(puVar5 + 1);\n      if (iVar2 !\u003d 0) {\n        *(int *)((int)puVar5 + iVar2) \u003d -iVar2;\n        return uVar6;\n      }\n      return uVar6;\n    }\n    *param_1 \u003d 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfmoreglue",
        "_realloc_r",
        "__smakebuf_r",
        "malloc"
      ],
      "called": [
        "__malloc_lock",
        "__malloc_unlock",
        "_sbrk_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfputc_r": {
      "entrypoint": "0x0800932c",
      "current_name": "__sfputc_r",
      "code": "\nuint __sfputc_r(undefined4 param_1,byte param_2,byte **param_3)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  pbVar2 \u003d param_3[2] + -1;\n  param_3[2] \u003d pbVar2;\n  if (((int)pbVar2 \u003c 0) \u0026\u0026 (((int)pbVar2 \u003c (int)param_3[6] || (param_2 \u003d\u003d 10)))) {\n    uVar1 \u003d __swbuf_r();\n    return uVar1;\n  }\n  pbVar2 \u003d *param_3;\n  *param_3 \u003d pbVar2 + 1;\n  *pbVar2 \u003d param_2;\n  return (uint)param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfputs_r"
      ],
      "called": [
        "__swbuf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfputs_r": {
      "entrypoint": "0x08009358",
      "current_name": "__sfputs_r",
      "code": "\nint __sfputs_r(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 \u003d param_3 + param_4;\n  iVar3 \u003d param_4;\n  do {\n    if (param_3 \u003d\u003d puVar2) {\n      return 0;\n    }\n    iVar1 \u003d __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 \u003d iVar1 + 1;\n    param_3 \u003d param_3 + 1;\n  } while (param_4 !\u003d 0);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "__sfputc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_vfiprintf_r": {
      "entrypoint": "0x0800937c",
      "current_name": "_vfiprintf_r",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08009550) */\n\nint _vfiprintf_r(int param_1,undefined4 *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  int iVar2;\n  void *pvVar3;\n  int *piVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  int unaff_r9;\n  int iVar7;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c \u003d param_4;\n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d *(undefined4 **)(param_1 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(undefined4 **)(param_1 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n  }\n  if (((-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1c)) || (param_2[4] \u003d\u003d 0)) \u0026\u0026\n     (iVar7 \u003d __swsetup_r(param_1,param_2), iVar7 !\u003d 0)) {\n    return -1;\n  }\n  local_74 \u003d 0;\n  local_6f \u003d 0x20;\n  local_6e \u003d 0x30;\n  pbVar5 \u003d param_3;\nLAB_080093be:\n  pbVar6 \u003d pbVar5;\n  if (*pbVar6 !\u003d 0) goto LAB_08009474;\n  goto LAB_080093c8;\nLAB_08009474:\n  pbVar5 \u003d pbVar6 + 1;\n  if (*pbVar6 !\u003d 0x25) goto LAB_080093be;\nLAB_080093c8:\n  iVar7 \u003d (int)pbVar6 - (int)param_3;\n  if (iVar7 !\u003d 0) {\n    iVar2 \u003d __sfputs_r(param_1,param_2,param_3,iVar7);\n    if (iVar2 \u003d\u003d -1) {\nLAB_08009568:\n      if ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x19) \u003c 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 \u003d local_74 + iVar7;\n  }\n  if (*pbVar6 \u003d\u003d 0) goto LAB_08009568;\n  local_88 \u003d 0;\n  local_7c \u003d 0;\n  local_84 \u003d -1;\n  local_80 \u003d 0;\n  local_45 \u003d 0;\n  local_30 \u003d 0;\n  pbVar5 \u003d pbVar6 + 1;\n  while( true ) {\n    pvVar3 \u003d memchr(\"#-0+ \",(uint)*pbVar5,5);\n    param_3 \u003d pbVar5 + 1;\n    if (pvVar3 \u003d\u003d (void *)0x0) break;\n    local_88 \u003d 1 \u003c\u003c ((int)pvVar3 + 0xf7ff54b0U \u0026 0xff) | local_88;\n    pbVar5 \u003d param_3;\n  }\n  if ((int)(local_88 \u003c\u003c 0x1b) \u003c 0) {\n    local_45 \u003d 0x20;\n  }\n  if ((int)(local_88 \u003c\u003c 0x1c) \u003c 0) {\n    local_45 \u003d 0x2b;\n  }\n  if (*pbVar5 \u003d\u003d 0x2a) {\n    piVar4 \u003d local_8c + 1;\n    iVar7 \u003d *local_8c;\n    local_8c \u003d piVar4;\n    if (iVar7 \u003c 0) {\n      local_7c \u003d -iVar7;\n      local_88 \u003d local_88 | 2;\n      goto LAB_080094a6;\n    }\n  }\n  else {\n    bVar1 \u003d false;\n    iVar7 \u003d local_7c;\n    param_3 \u003d pbVar5;\n    while( true ) {\n      if (9 \u003c *param_3 - 0x30) break;\n      iVar7 \u003d iVar7 * 10 + (*param_3 - 0x30);\n      bVar1 \u003d true;\n      param_3 \u003d param_3 + 1;\n    }\n    if (!bVar1) goto LAB_080094a6;\n  }\n  local_7c \u003d iVar7;\nLAB_080094a6:\n  if (*param_3 \u003d\u003d 0x2e) {\n    if (param_3[1] \u003d\u003d 0x2a) {\n      param_3 \u003d param_3 + 2;\n      piVar4 \u003d local_8c + 1;\n      local_84 \u003d *local_8c;\n      local_8c \u003d piVar4;\n      if (local_84 \u003c 0) {\n        local_84 \u003d -1;\n      }\n    }\n    else {\n      bVar1 \u003d false;\n      iVar7 \u003d 0;\n      local_84 \u003d 0;\n      while( true ) {\n        param_3 \u003d param_3 + 1;\n        if (9 \u003c *param_3 - 0x30) break;\n        iVar7 \u003d iVar7 * 10 + (*param_3 - 0x30);\n        bVar1 \u003d true;\n      }\n      if (bVar1) {\n        local_84 \u003d iVar7;\n      }\n    }\n  }\n  pvVar3 \u003d memchr(\u0026DAT_0800ab56,(uint)*param_3,3);\n  if (pvVar3 !\u003d (void *)0x0) {\n    param_3 \u003d param_3 + 1;\n    local_88 \u003d local_88 | 0x40 \u003c\u003c ((int)pvVar3 + 0xf7ff54aaU \u0026 0xff);\n  }\n  local_70 \u003d *param_3;\n  param_3 \u003d param_3 + 1;\n  pvVar3 \u003d memchr(\"efgEFG\",(uint)local_70,6);\n  if (pvVar3 \u003d\u003d (void *)0x0) {\n    unaff_r9 \u003d _printf_i(param_1,\u0026local_88,param_2,0x8009359,\u0026local_8c);\n    if (unaff_r9 \u003d\u003d -1) goto LAB_08009568;\n  }\n  else {\n    local_8c \u003d (int *)(((int)local_8c + 7U \u0026 0xfffffff8) + 8);\n  }\n  local_74 \u003d local_74 + unaff_r9;\n  pbVar5 \u003d param_3;\n  goto LAB_080093be;\n}\n\n",
      "renaming": {},
      "calling": [
        "fiprintf",
        "iprintf"
      ],
      "called": [
        "memchr",
        "_printf_i",
        "__swsetup_r",
        "__sinit",
        "__sfputs_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_printf_common": {
      "entrypoint": "0x080095a8",
      "current_name": "_printf_common",
      "code": "\nundefined4\n_printf_common(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar3 \u003d param_2[4];\n  if ((int)param_2[4] \u003c (int)param_2[2]) {\n    uVar3 \u003d param_2[2];\n  }\n  *param_3 \u003d uVar3;\n  if (*(char *)((int)param_2 + 0x43) !\u003d \u0027\\0\u0027) {\n    *param_3 \u003d uVar3 + 1;\n  }\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *param_3 \u003d *param_3 + 2;\n  }\n  if ((*param_2 \u0026 6) \u003d\u003d 0) {\n    for (iVar1 \u003d 0; iVar1 \u003c (int)(param_2[3] - *param_3); iVar1 \u003d iVar1 + 1) {\n      iVar2 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar2 \u003d\u003d -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uVar3 \u003d (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar3 !\u003d 0) {\n    uVar3 \u003d 1;\n  }\n  uVar4 \u003d uVar3;\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *(undefined *)((int)param_2 + uVar3 + 0x43) \u003d 0x30;\n    uVar4 \u003d uVar3 + 2;\n    *(undefined *)((int)param_2 + uVar3 + 0x44) \u003d *(undefined *)((int)param_2 + 0x45);\n  }\n  iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar4);\n  if (iVar1 !\u003d -1) {\n    uVar3 \u003d param_2[3];\n    bVar5 \u003d (*param_2 \u0026 6) !\u003d 4;\n    if (bVar5) {\n      uVar3 \u003d 0;\n    }\n    uVar4 \u003d 0;\n    if (!bVar5) {\n      uVar3 \u003d uVar3 - *param_3;\n    }\n    if (!bVar5) {\n      uVar3 \u003d uVar3 \u0026 ~((int)uVar3 \u003e\u003e 0x1f);\n    }\n    if ((int)param_2[4] \u003c (int)param_2[2]) {\n      uVar3 \u003d uVar3 + (param_2[2] - param_2[4]);\n    }\n    while( true ) {\n      if (uVar3 \u003d\u003d uVar4) {\n        return 0;\n      }\n      iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 \u003d\u003d -1) break;\n      uVar4 \u003d uVar4 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_printf_i"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_printf_i": {
      "entrypoint": "0x08009698",
      "current_name": "_printf_i",
      "code": "\nuint _printf_i(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  char *pcVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint uVar10;\n  uint uVar11;\n  char *pcVar12;\n  char *__s;\n  uint local_24 [2];\n  \n  bVar1 \u003d *(byte *)(param_2 + 6);\n  __s \u003d (char *)((int)param_2 + 0x43);\n  if (bVar1 !\u003d 0x6e) {\n    if (bVar1 \u003c 0x6f) {\n      if (bVar1 !\u003d 99) {\n        if (bVar1 \u003c 100) {\n          if (bVar1 \u003d\u003d 0) goto LAB_08009852;\n          if (bVar1 !\u003d 0x58) goto LAB_080096c8;\n          *(undefined *)((int)param_2 + 0x45) \u003d 0x58;\n          pcVar6 \u003d \"0123456789ABCDEF\";\nLAB_080097e2:\n          uVar7 \u003d *param_2;\n          puVar3 \u003d *param_5;\n          *param_5 \u003d puVar3 + 1;\n          if (((uVar7 \u0026 0x80) \u003d\u003d 0) \u0026\u0026 ((int)(uVar7 \u003c\u003c 0x19) \u003c 0)) {\n            uVar10 \u003d (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar10 \u003d *puVar3;\n          }\n          if ((int)(uVar7 \u003c\u003c 0x1f) \u003c 0) {\n            *param_2 \u003d uVar7 | 0x20;\n          }\n          if (uVar10 \u003d\u003d 0) {\n            *param_2 \u003d *param_2 \u0026 0xffffffdf;\n          }\n          uVar7 \u003d 0x10;\nLAB_08009778:\n          *(undefined *)((int)param_2 + 0x43) \u003d 0;\n        }\n        else {\n          if ((bVar1 !\u003d 100) \u0026\u0026 (bVar1 !\u003d 0x69)) goto LAB_080096c8;\n          uVar10 \u003d *param_2;\n          puVar3 \u003d *param_5;\n          if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n            *param_5 \u003d puVar3 + 1;\n            if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_080096e8;\n            uVar10 \u003d (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 \u003d puVar3 + 1;\nLAB_080096e8:\n            uVar10 \u003d *puVar3;\n          }\n          if ((int)uVar10 \u003c 0) {\n            uVar10 \u003d -uVar10;\n            *(undefined *)((int)param_2 + 0x43) \u003d 0x2d;\n          }\n          pcVar6 \u003d \"0123456789ABCDEF\";\n          uVar7 \u003d 10;\n        }\n        uVar11 \u003d param_2[1];\n        param_2[2] \u003d uVar11;\n        pcVar12 \u003d __s;\n        if ((int)uVar11 \u003c 0) {\n          if (uVar10 !\u003d 0) goto LAB_08009816;\nLAB_080098c4:\n          *(char *)((int)param_2 + 0x42) \u003d *pcVar6;\n          pcVar12 \u003d (char *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 \u003d *param_2 \u0026 0xfffffffb;\n          if (uVar10 \u003d\u003d 0) {\n            if (uVar11 !\u003d 0) goto LAB_080098c4;\n          }\n          else {\nLAB_08009816:\n            do {\n              uVar11 \u003d uVar10 / uVar7;\n              pcVar12 \u003d pcVar12 + -1;\n              *pcVar12 \u003d pcVar6[uVar10 - uVar7 * uVar11];\n              uVar10 \u003d uVar11;\n            } while (uVar11 !\u003d 0);\n          }\n        }\n        if (((uVar7 \u003d\u003d 8) \u0026\u0026 ((int)(*param_2 \u003c\u003c 0x1f) \u003c 0)) \u0026\u0026 ((int)param_2[1] \u003c\u003d (int)param_2[4]))\n        {\n          pcVar12[-1] \u003d \u00270\u0027;\n          pcVar12 \u003d pcVar12 + -1;\n        }\n        param_2[4] \u003d (int)__s - (int)pcVar12;\n        __s \u003d pcVar12;\n        goto LAB_080097be;\n      }\n      puVar3 \u003d *param_5;\n      *param_5 \u003d puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) \u003d (char)*puVar3;\nLAB_08009728:\n      __s \u003d (char *)((int)param_2 + 0x42);\n      uVar10 \u003d 1;\n    }\n    else {\n      if (bVar1 !\u003d 0x73) {\n        if (bVar1 \u003c 0x74) {\n          if (bVar1 \u003d\u003d 0x6f) {\nLAB_0800974e:\n            uVar10 \u003d *param_2;\n            puVar3 \u003d *param_5;\n            if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n              *param_5 \u003d puVar3 + 1;\n              if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_0800975c;\n              uVar10 \u003d (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 \u003d puVar3 + 1;\nLAB_0800975c:\n              uVar10 \u003d *puVar3;\n            }\n            if (bVar1 \u003d\u003d 0x6f) {\n              uVar7 \u003d 8;\n            }\n            else {\n              uVar7 \u003d 10;\n            }\n            pcVar6 \u003d \"0123456789ABCDEF\";\n            goto LAB_08009778;\n          }\n          if (bVar1 \u003d\u003d 0x70) {\n            *param_2 \u003d *param_2 | 0x20;\nLAB_0800970e:\n            pcVar6 \u003d \"0123456789abcdef\";\n            *(undefined *)((int)param_2 + 0x45) \u003d 0x78;\n            goto LAB_080097e2;\n          }\n        }\n        else {\n          if (bVar1 \u003d\u003d 0x75) goto LAB_0800974e;\n          if (bVar1 \u003d\u003d 0x78) goto LAB_0800970e;\n        }\nLAB_080096c8:\n        *(byte *)((int)param_2 + 0x42) \u003d bVar1;\n        goto LAB_08009728;\n      }\n      ppcVar9 \u003d (char **)*param_5;\n      *param_5 \u003d (uint *)(ppcVar9 + 1);\n      __s \u003d *ppcVar9;\n      pvVar4 \u003d memchr(__s,0,param_2[1]);\n      if (pvVar4 !\u003d (void *)0x0) {\n        param_2[1] \u003d (int)pvVar4 - (int)__s;\n      }\n      uVar10 \u003d param_2[1];\n    }\n    param_2[4] \u003d uVar10;\n    *(undefined *)((int)param_2 + 0x43) \u003d 0;\n    goto LAB_080097be;\n  }\n  uVar10 \u003d *param_2;\n  ppuVar8 \u003d (uint **)*param_5;\n  uVar7 \u003d param_2[5];\n  if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n    *param_5 \u003d (uint *)(ppuVar8 + 1);\n    puVar3 \u003d *ppuVar8;\n    if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_0800983e;\n    *(short *)puVar3 \u003d (short)uVar7;\n  }\n  else {\n    *param_5 \u003d (uint *)(ppuVar8 + 1);\n    puVar3 \u003d *ppuVar8;\nLAB_0800983e:\n    *puVar3 \u003d uVar7;\n  }\nLAB_08009852:\n  param_2[4] \u003d 0;\nLAB_080097be:\n  iVar2 \u003d _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 \u003d\u003d -1) || (iVar2 \u003d (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 \u003d\u003d -1)) {\nLAB_080097d2:\n    uVar10 \u003d 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 \u003c\u003c 0x1e) \u003c 0) {\n      for (iVar2 \u003d 0; iVar2 \u003c (int)(param_2[3] - local_24[0]); iVar2 \u003d iVar2 + 1) {\n        iVar5 \u003d (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 \u003d\u003d -1) goto LAB_080097d2;\n      }\n    }\n    uVar10 \u003d param_2[3];\n    if ((int)param_2[3] \u003c (int)local_24[0]) {\n      uVar10 \u003d local_24[0];\n    }\n  }\n  return uVar10;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "memchr",
        "_printf_common"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "iprintf": {
      "entrypoint": "0x080098d8",
      "current_name": "iprintf",
      "code": "\nint iprintf(char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *pcVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 \u003d _impure_ptr;\n  pcVar2 \u003d __format;\n  uStack_c \u003d in_r1;\n  uStack_8 \u003d in_r2;\n  uStack_4 \u003d in_r3;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  iVar1 \u003d _vfiprintf_r(iVar1,*(undefined4 *)(iVar1 + 8),__format,\u0026uStack_c,pcVar2,\u0026uStack_c);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "getTimerIrq",
        "getTimerClkFreq",
        "getTimerClkSrc",
        "i2c_custom_init",
        "uart_init"
      ],
      "called": [
        "_vfiprintf_r",
        "__sinit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "realloc": {
      "entrypoint": "0x08009908",
      "current_name": "realloc",
      "code": "\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d (void *)_realloc_r(_impure_ptr,__ptr,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "write",
        "allocateRxBuffer",
        "write"
      ],
      "called": [
        "_realloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk_r": {
      "entrypoint": "0x08009918",
      "current_name": "_sbrk_r",
      "code": "\nvoid _sbrk_r(int *param_1,intptr_t param_2)\n\n{\n  void *pvVar1;\n  \n  errno \u003d 0;\n  pvVar1 \u003d _sbrk(param_2);\n  if ((pvVar1 \u003d\u003d (void *)0xffffffff) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r"
      ],
      "called": [
        "_sbrk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strchr": {
      "entrypoint": "0x08009938",
      "current_name": "strchr",
      "code": "\nchar * strchr(char *__s,int __c)\n\n{\n  byte *pbVar1;\n  \n  do {\n    pbVar1 \u003d (byte *)__s;\n    if (*pbVar1 \u003d\u003d 0) {\n      if ((__c \u0026 0xffU) !\u003d 0) {\n        pbVar1 \u003d (byte *)0x0;\n      }\n      return (char *)pbVar1;\n    }\n    __s \u003d (char *)(pbVar1 + 1);\n  } while ((__c \u0026 0xffU) !\u003d (uint)*pbVar1);\n  return (char *)pbVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "strrchr"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strncpy": {
      "entrypoint": "0x08009954",
      "current_name": "strncpy",
      "code": "\nchar * strncpy(char *__dest,char *__src,size_t __n)\n\n{\n  char cVar1;\n  size_t sVar2;\n  char *pcVar3;\n  char *pcVar4;\n  \n  pcVar3 \u003d __dest;\n  do {\n    pcVar4 \u003d pcVar3;\n    sVar2 \u003d __n;\n    if (sVar2 \u003d\u003d 0) {\n      return __dest;\n    }\n    cVar1 \u003d *__src;\n    pcVar3 \u003d pcVar4 + 1;\n    *pcVar4 \u003d cVar1;\n    __src \u003d __src + 1;\n    __n \u003d sVar2 - 1;\n  } while (cVar1 !\u003d \u0027\\0\u0027);\n  for (; pcVar3 !\u003d pcVar4 + sVar2; pcVar3 \u003d pcVar3 + 1) {\n    *pcVar3 \u003d \u0027\\0\u0027;\n  }\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "setFirmwareNameAndVersion"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strrchr": {
      "entrypoint": "0x0800997e",
      "current_name": "strrchr",
      "code": "\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  if (__c !\u003d 0) {\n    pcVar2 \u003d (char *)0x0;\n    while (pcVar1 \u003d strchr(__s,__c), pcVar1 !\u003d (char *)0x0) {\n      __s \u003d pcVar1 + 1;\n      pcVar2 \u003d pcVar1;\n    }\n    return pcVar2;\n  }\n  pcVar2 \u003d strchr(__s,0);\n  return pcVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "setFirmwareNameAndVersion"
      ],
      "called": [
        "strchr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strstr": {
      "entrypoint": "0x080099a4",
      "current_name": "strstr",
      "code": "\nchar * strstr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  if (*__haystack \u003d\u003d \u0027\\0\u0027) {\n    if (*__needle !\u003d \u0027\\0\u0027) {\n      __haystack \u003d (char *)0x0;\n    }\n    return __haystack;\n  }\n  do {\n    pcVar1 \u003d __haystack;\n    if (*pcVar1 \u003d\u003d \u0027\\0\u0027) {\n      return (char *)0x0;\n    }\n    pcVar3 \u003d __needle + -1;\n    pcVar2 \u003d pcVar1 + -1;\n    do {\n      pcVar3 \u003d pcVar3 + 1;\n      if (*pcVar3 \u003d\u003d \u0027\\0\u0027) {\n        return pcVar1;\n      }\n      pcVar2 \u003d pcVar2 + 1;\n      __haystack \u003d pcVar1 + 1;\n    } while (*pcVar2 \u003d\u003d *pcVar3);\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "setFirmwareNameAndVersion"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swbuf_r": {
      "entrypoint": "0x080099dc",
      "current_name": "__swbuf_r",
      "code": "\nuint __swbuf_r(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_3 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_3 \u003d *(int **)(param_1 + 4);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026__sf_fake_stdout) {\n    param_3 \u003d *(int **)(param_1 + 8);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026__sf_fake_stderr) {\n    param_3 \u003d *(int **)(param_1 + 0xc);\n  }\n  param_3[2] \u003d param_3[6];\n  uVar2 \u003d (uint)*(ushort *)(param_3 + 3);\n  iVar1 \u003d uVar2 \u003c\u003c 0x1c;\n  if (((iVar1 \u003c 0) \u0026\u0026 (uVar2 \u003d param_3[4], uVar2 !\u003d 0)) ||\n     (iVar1 \u003d __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 \u003d\u003d 0)) {\n    param_2 \u003d param_2 \u0026 0xff;\n    iVar1 \u003d *param_3 - param_3[4];\n    if ((iVar1 \u003c param_3[5]) || (iVar1 \u003d _fflush_r(param_1,param_3), iVar1 \u003d\u003d 0)) {\n      param_3[2] \u003d param_3[2] + -1;\n      puVar3 \u003d (undefined *)*param_3;\n      *param_3 \u003d (int)(puVar3 + 1);\n      *puVar3 \u003d (char)param_2;\n      if (iVar1 + 1 !\u003d param_3[5]) {\n        if (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x1f)) {\n          return param_2;\n        }\n        if (param_2 !\u003d 10) {\n          return param_2;\n        }\n      }\n      iVar1 \u003d _fflush_r(param_1,param_3);\n      if (iVar1 \u003d\u003d 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfputc_r"
      ],
      "called": [
        "__swsetup_r",
        "__sinit",
        "_fflush_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swsetup_r": {
      "entrypoint": "0x08009a80",
      "current_name": "__swsetup_r",
      "code": "\nuint __swsetup_r(undefined4 *param_1,undefined4 *param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  ushort uVar3;\n  \n  iVar1 \u003d _impure_ptr;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 0xc);\n  }\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  uVar2 \u003d (uint)uVar3;\n  if (-1 \u003c (int)(uVar2 \u003c\u003c 0x1c)) {\n    if (-1 \u003c (int)(uVar2 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      goto LAB_08009ab0;\n    }\n    if ((int)(uVar2 \u003c\u003c 0x1d) \u003c 0) {\n      if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] \u003d 0;\n      }\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xffdb;\n      param_2[1] \u003d 0;\n      *param_2 \u003d param_2[4];\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] \u003d\u003d 0) \u0026\u0026 ((*(ushort *)(param_2 + 3) \u0026 0x280) !\u003d 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  uVar2 \u003d uVar3 \u0026 1;\n  if ((uVar3 \u0026 1) \u003d\u003d 0) {\n    if (-1 \u003c (int)((uint)uVar3 \u003c\u003c 0x1e)) {\n      uVar2 \u003d param_2[5];\n    }\n    param_2[2] \u003d uVar2;\n  }\n  else {\n    param_2[2] \u003d 0;\n    param_2[6] \u003d -param_2[5];\n  }\n  if (param_2[4] \u003d\u003d 0) {\n    uVar3 \u003d *(ushort *)(param_2 + 3);\n    uVar2 \u003d (int)(short)uVar3 \u0026 0x80;\n    if (uVar2 !\u003d 0) {\nLAB_08009ab0:\n      *(ushort *)(param_2 + 3) \u003d uVar3 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    uVar2 \u003d 0;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r",
        "__swbuf_r"
      ],
      "called": [
        "__sinit",
        "__smakebuf_r",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "abort": {
      "entrypoint": "0x08009b5c",
      "current_name": "abort",
      "code": "\n\n\nvoid abort(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "__throw_bad_function_call",
        "__assert_func"
      ],
      "called": [
        "_exit",
        "raise"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sflush_r": {
      "entrypoint": "0x08009b6c",
      "current_name": "__sflush_r",
      "code": "\nundefined4 __sflush_r(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar3 \u003d (uint)uVar4;\n  if ((int)(uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar1 \u003d param_2[4];\n    if (iVar1 !\u003d 0) {\n      iVar5 \u003d uVar3 \u003c\u003c 0x1e;\n      bVar9 \u003d iVar5 !\u003d 0;\n      if (bVar9) {\n        iVar5 \u003d 0;\n      }\n      iVar7 \u003d *param_2;\n      if (!bVar9) {\n        iVar5 \u003d param_2[5];\n      }\n      *param_2 \u003d iVar1;\n      param_2[2] \u003d iVar5;\n      for (iVar7 \u003d iVar7 - iVar1; 0 \u003c iVar7; iVar7 \u003d iVar7 - iVar5) {\n        iVar5 \u003d (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 \u003c 1) {\n          uVar4 \u003d *(ushort *)(param_2 + 3);\n          goto LAB_08009c62;\n        }\n        iVar1 \u003d iVar1 + iVar5;\n      }\n    }\n  }\n  else if (((0 \u003c param_2[1]) || (0 \u003c param_2[0x10])) \u0026\u0026\n          (pcVar6 \u003d (code *)param_2[0xb], pcVar6 !\u003d (code *)0x0)) {\n    uVar8 \u003d *param_1;\n    *param_1 \u003d 0;\n    if ((uVar4 \u0026 0x1000) \u003d\u003d 0) {\n      iVar1 \u003d (*pcVar6)(param_1,param_2[8],uVar3 \u0026 0x1000,1);\n      if ((iVar1 \u003d\u003d -1) \u0026\u0026 (uVar3 \u003d *param_1, uVar3 !\u003d 0)) {\n        if ((uVar3 !\u003d 0x1d) \u0026\u0026 (uVar3 !\u003d 0x16)) {\n          *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *param_1 \u003d uVar8;\n        return 0;\n      }\n    }\n    else {\n      iVar1 \u003d param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1d) \u003c 0) \u0026\u0026\n       (iVar1 \u003d iVar1 - param_2[1], param_2[0xd] !\u003d 0)) {\n      iVar1 \u003d iVar1 - param_2[0x10];\n    }\n    iVar1 \u003d (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 \u003d *(ushort *)(param_2 + 3);\n    if ((iVar1 \u003d\u003d -1) \u0026\u0026\n       ((0x1d \u003c *param_1 || (-1 \u003c (int)((0x20400001U \u003e\u003e (*param_1 \u0026 0xff)) \u003c\u003c 0x1f))))) {\nLAB_08009c62:\n      *(ushort *)(param_2 + 3) \u003d uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    param_2[1] \u003d 0;\n    *param_2 \u003d param_2[4];\n    if (((int)((uint)uVar4 \u003c\u003c 0x13) \u003c 0) \u0026\u0026 ((iVar1 !\u003d -1 || (*param_1 \u003d\u003d 0)))) {\n      param_2[0x15] \u003d iVar1;\n    }\n    piVar2 \u003d (int *)param_2[0xd];\n    *param_1 \u003d uVar8;\n    if (piVar2 !\u003d (int *)0x0) {\n      if (piVar2 !\u003d param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] \u003d 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fflush_r": {
      "entrypoint": "0x08009c7c",
      "current_name": "_fflush_r",
      "code": "\nundefined4 _fflush_r(int param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  if (param_2[4] !\u003d 0) {\n    if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n      __sinit();\n    }\n    if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n      param_2 \u003d *(undefined4 **)(param_1 + 4);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n      param_2 \u003d *(undefined4 **)(param_1 + 8);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n      param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 3) !\u003d 0) {\n      uVar1 \u003d __sflush_r(param_1,param_2,param_3,param_4);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swbuf_r"
      ],
      "called": [
        "__sflush_r",
        "__sinit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_cleanup_r": {
      "entrypoint": "0x08009cd0",
      "current_name": "_cleanup_r",
      "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk_reent(param_1,0x8009c7d);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fwalk_reent"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "std.isra.0": {
      "entrypoint": "0x08009cdc",
      "current_name": "std.isra.0",
      "code": "\nvoid std_isra_0(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  *param_1 \u003d 0;\n  param_1[1] \u003d 0;\n  param_1[2] \u003d 0;\n  *(undefined2 *)(param_1 + 3) \u003d param_2;\n  param_1[0x19] \u003d 0;\n  *(undefined2 *)((int)param_1 + 0xe) \u003d param_3;\n  param_1[4] \u003d 0;\n  param_1[5] \u003d 0;\n  param_1[6] \u003d 0;\n  memset(param_1 + 0x17,0,8);\n  param_1[8] \u003d param_1;\n  param_1[9] \u003d 0x800a021;\n  param_1[10] \u003d 0x800a043;\n  param_1[0xb] \u003d 0x800a07b;\n  param_1[0xc] \u003d 0x800a09f;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfmoreglue": {
      "entrypoint": "0x08009d24",
      "current_name": "__sfmoreglue",
      "code": "\nundefined4 * __sfmoreglue(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 \u003d (param_2 + -1) * 0x68;\n  puVar1 \u003d (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 !\u003d (undefined4 *)0x0) {\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d param_2;\n    puVar1[2] \u003d puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfp"
      ],
      "called": [
        "memset",
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sinit": {
      "entrypoint": "0x08009d50",
      "current_name": "__sinit",
      "code": "\nvoid __sinit(undefined1 *param_1)\n\n{\n  undefined4 uVar1;\n  undefined1 *puVar2;\n  \n  if (*(int *)(param_1 + 0x18) \u003d\u003d 0) {\n    *(undefined4 *)(param_1 + 0x48) \u003d 0;\n    *(undefined4 *)(param_1 + 0x4c) \u003d 0;\n    *(undefined4 *)(param_1 + 0x50) \u003d 0;\n    puVar2 \u003d \u0026impure_data;\n    *(undefined4 *)(param_1 + 0x28) \u003d 0x8009cd1;\n    if (param_1 \u003d\u003d \u0026impure_data) {\n      puVar2 \u003d (undefined1 *)0x1;\n    }\n    if (param_1 \u003d\u003d \u0026impure_data) {\n      *(undefined1 **)(param_1 + 0x18) \u003d puVar2;\n    }\n    uVar1 \u003d __sfp();\n    *(undefined4 *)(param_1 + 4) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) \u003d uVar1;\n    std_isra_0(*(undefined4 *)(param_1 + 4),4,0);\n    std_isra_0(*(undefined4 *)(param_1 + 8),9,1);\n    std_isra_0(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r",
        "_vfiprintf_r",
        "_fflush_r",
        "iprintf",
        "__swbuf_r",
        "__sfp"
      ],
      "called": [
        "std.isra.0",
        "__sfp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp": {
      "entrypoint": "0x08009db0",
      "current_name": "__sfp",
      "code": "\nint * __sfp(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int **ppiVar3;\n  \n  if (DAT_200000ac \u003d\u003d 0) {\n    __sinit(\u0026impure_data);\n  }\n  ppiVar3 \u003d (int **)\u0026DAT_200000dc;\n  do {\n    piVar2 \u003d ppiVar3[2];\n    piVar1 \u003d ppiVar3[1];\n    while (piVar1 \u003d (int *)((int)piVar1 + -1), -1 \u003c (int)piVar1) {\n      if (*(short *)(piVar2 + 3) \u003d\u003d 0) {\n        *(undefined2 *)((int)piVar2 + 0xe) \u003d 0xffff;\n        piVar2[0x19] \u003d 0;\n        *(undefined2 *)(piVar2 + 3) \u003d 1;\n        *piVar2 \u003d 0;\n        piVar2[2] \u003d 0;\n        piVar2[1] \u003d 0;\n        piVar2[4] \u003d 0;\n        piVar2[5] \u003d 0;\n        piVar2[6] \u003d 0;\n        memset(piVar2 + 0x17,0,8);\n        piVar2[0xd] \u003d 0;\n        piVar2[0xe] \u003d 0;\n        piVar2[0x12] \u003d 0;\n        piVar2[0x13] \u003d 0;\n        return piVar2;\n      }\n      piVar2 \u003d piVar2 + 0x1a;\n    }\n    if (*ppiVar3 \u003d\u003d (int *)0x0) {\n      piVar1 \u003d (int *)__sfmoreglue(param_1,4);\n      *ppiVar3 \u003d piVar1;\n      if (piVar1 \u003d\u003d (int *)0x0) {\n        *param_1 \u003d 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar3 \u003d (int **)*ppiVar3;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "__sfmoreglue",
        "__sinit",
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fwalk_reent": {
      "entrypoint": "0x08009e28",
      "current_name": "_fwalk_reent",
      "code": "\nuint _fwalk_reent(int param_1,code *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  \n  uVar5 \u003d 0;\n  for (piVar3 \u003d (int *)(param_1 + 0x48); piVar3 !\u003d (int *)0x0; piVar3 \u003d (int *)*piVar3) {\n    iVar4 \u003d piVar3[2];\n    iVar6 \u003d piVar3[1];\n    while (iVar6 \u003d iVar6 + -1, -1 \u003c iVar6) {\n      if ((1 \u003c *(ushort *)(iVar4 + 0xc)) \u0026\u0026 (iVar2 \u003d *(short *)(iVar4 + 0xe) + 1, iVar2 !\u003d 0)) {\n        uVar1 \u003d (*param_2)(param_1,iVar4,param_3,iVar2,param_4);\n        uVar5 \u003d uVar5 | uVar1;\n      }\n      iVar4 \u003d iVar4 + 0x68;\n    }\n  }\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "_cleanup_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swhatbuf_r": {
      "entrypoint": "0x08009e64",
      "current_name": "__swhatbuf_r",
      "code": "\nundefined4 __swhatbuf_r(undefined4 param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_4c [4];\n  uint local_48;\n  \n  if ((*(short *)(param_2 + 0xe) \u003c 0) ||\n     (iVar1 \u003d _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),auStack_4c), iVar1 \u003c 0)) {\n    *param_4 \u003d 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x18) \u003c 0) {\n      uVar2 \u003d 0x40;\n      goto LAB_08009ea4;\n    }\n  }\n  else {\n    *param_4 \u003d (uint)((local_48 \u0026 0xf000) \u003d\u003d 0x2000);\n  }\n  uVar2 \u003d 0x400;\nLAB_08009ea4:\n  *param_3 \u003d uVar2;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_fstat_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__smakebuf_r": {
      "entrypoint": "0x08009eac",
      "current_name": "__smakebuf_r",
      "code": "\nvoid __smakebuf_r(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int local_18;\n  int *local_14;\n  \n  if (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1e)) {\n    local_18 \u003d param_1;\n    local_14 \u003d param_2;\n    uVar1 \u003d __swhatbuf_r(param_1,param_2,\u0026local_18,\u0026local_14);\n    iVar2 \u003d _malloc_r(param_1,local_18);\n    if (iVar2 !\u003d 0) {\n      *(undefined4 *)(param_1 + 0x28) \u003d 0x8009cd1;\n      *param_2 \u003d iVar2;\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x80;\n      param_2[4] \u003d iVar2;\n      param_2[5] \u003d local_18;\n      if ((local_14 !\u003d (int *)0x0) \u0026\u0026\n         (iVar2 \u003d _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 !\u003d 0)) {\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) \u003d uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) \u003c\u003c 0x16 \u003c 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 2;\n  }\n  *param_2 \u003d (int)param_2 + 0x47;\n  param_2[4] \u003d (int)param_2 + 0x47;\n  param_2[5] \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r"
      ],
      "called": [
        "_isatty_r",
        "__swhatbuf_r",
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memchr": {
      "entrypoint": "0x08009f2c",
      "current_name": "memchr",
      "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  byte *pbVar1;\n  byte *pbVar2;\n  \n  pbVar1 \u003d (byte *)__s;\n  do {\n    pbVar2 \u003d pbVar1;\n    if (pbVar2 \u003d\u003d (byte *)(__n + (int)__s)) {\n      return (void *)0x0;\n    }\n    pbVar1 \u003d pbVar2 + 1;\n  } while ((uint)*pbVar2 !\u003d (__c \u0026 0xffU));\n  return pbVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_printf_i",
        "_vfiprintf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_lock": {
      "entrypoint": "0x08009f48",
      "current_name": "__malloc_lock",
      "code": "\nvoid __malloc_lock(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_free_r",
        "_malloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_unlock": {
      "entrypoint": "0x08009f4a",
      "current_name": "__malloc_unlock",
      "code": "\nvoid __malloc_unlock(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_free_r",
        "_malloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_realloc_r": {
      "entrypoint": "0x08009f4c",
      "current_name": "_realloc_r",
      "code": "\nvoid * _realloc_r(undefined4 param_1,void *param_2,uint param_3,undefined4 param_4)\n\n{\n  void *pvVar1;\n  uint uVar2;\n  \n  if (param_2 !\u003d (void *)0x0) {\n    if (param_3 \u003d\u003d 0) {\n      _free_r();\n      pvVar1 \u003d (void *)0x0;\n    }\n    else {\n      uVar2 \u003d _malloc_usable_size_r();\n      pvVar1 \u003d param_2;\n      if ((uVar2 \u003c param_3) \u0026\u0026 (pvVar1 \u003d (void *)_malloc_r(param_1,param_3), pvVar1 !\u003d (void *)0x0))\n      {\n        memcpy(pvVar1,param_2,param_3);\n        _free_r(param_1,param_2);\n      }\n    }\n    return pvVar1;\n  }\n  pvVar1 \u003d (void *)_malloc_r(param_1,param_3,param_3,param_4);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "realloc"
      ],
      "called": [
        "memcpy",
        "_malloc_usable_size_r",
        "_free_r",
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_raise_r": {
      "entrypoint": "0x08009f98",
      "current_name": "_raise_r",
      "code": "\nundefined4 _raise_r(undefined4 *param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t _Var1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if (0x1f \u003c param_2) {\n    *param_1 \u003d 0x16;\n    return 0xffffffff;\n  }\n  iVar3 \u003d param_1[0x11];\n  if ((iVar3 !\u003d 0) \u0026\u0026 (pcVar4 \u003d *(code **)(iVar3 + param_2 * 4), pcVar4 !\u003d (code *)0x0)) {\n    if (pcVar4 !\u003d (code *)0x1) {\n      if (pcVar4 \u003d\u003d (code *)0xffffffff) {\n        *param_1 \u003d 0x16;\n        return 1;\n      }\n      *(undefined4 *)(iVar3 + param_2 * 4) \u003d 0;\n      (*pcVar4)(param_2);\n    }\n    return 0;\n  }\n  _Var1 \u003d _getpid_r();\n  uVar2 \u003d _kill_r(param_1,_Var1,param_2,param_4);\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "raise"
      ],
      "called": [
        "_kill_r",
        "_getpid_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "raise": {
      "entrypoint": "0x08009fe8",
      "current_name": "raise",
      "code": "\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _raise_r(_impure_ptr,__sig);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "abort"
      ],
      "called": [
        "_raise_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_kill_r": {
      "entrypoint": "0x08009ff8",
      "current_name": "_kill_r",
      "code": "\nvoid _kill_r(int *param_1,__pid_t param_2,int param_3)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _kill(param_2,param_3);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_raise_r"
      ],
      "called": [
        "_kill"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getpid_r": {
      "entrypoint": "0x0800a01c",
      "current_name": "_getpid_r",
      "code": "\n\n\n__pid_t _getpid_r(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_raise_r"
      ],
      "called": [
        "_getpid"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sread": {
      "entrypoint": "0x0800a020",
      "current_name": "__sread",
      "code": "\nvoid __sread(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  iVar1 \u003d _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 \u003d -1 \u003c iVar1;\n  if (bVar3) {\n    uVar2 \u003d *(int *)(param_2 + 0x54) + iVar1;\n  }\n  else {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) \u003d (short)uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_read_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swrite": {
      "entrypoint": "0x0800a042",
      "current_name": "__swrite",
      "code": "\nvoid __swrite(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x17) \u003c 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_write_r",
        "_lseek_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sseek": {
      "entrypoint": "0x0800a07a",
      "current_name": "__sseek",
      "code": "\nvoid __sseek(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  bool bVar3;\n  \n  iVar1 \u003d _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 \u003d iVar1 \u003d\u003d -1;\n  if (bVar3) {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  }\n  else {\n    *(int *)(param_2 + 0x54) \u003d iVar1;\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sclose": {
      "entrypoint": "0x0800a09e",
      "current_name": "__sclose",
      "code": "\nvoid __sclose(undefined4 param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_close_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write_r": {
      "entrypoint": "0x0800a0a8",
      "current_name": "_write_r",
      "code": "\nvoid _write_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _write(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swrite"
      ],
      "called": [
        "_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close_r": {
      "entrypoint": "0x0800a0cc",
      "current_name": "_close_r",
      "code": "\nvoid _close_r(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _close(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sclose"
      ],
      "called": [
        "_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat_r": {
      "entrypoint": "0x0800a0ec",
      "current_name": "_fstat_r",
      "code": "\nvoid _fstat_r(int *param_1,int param_2,stat *param_3)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _fstat(param_2,param_3);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swhatbuf_r"
      ],
      "called": [
        "_fstat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty_r": {
      "entrypoint": "0x0800a110",
      "current_name": "_isatty_r",
      "code": "\nvoid _isatty_r(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _isatty(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_isatty"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek_r": {
      "entrypoint": "0x0800a130",
      "current_name": "_lseek_r",
      "code": "\nvoid _lseek_r(int *param_1,int param_2,__off_t param_3,int param_4)\n\n{\n  __off_t _Var1;\n  \n  errno \u003d 0;\n  _Var1 \u003d _lseek(param_2,param_3,param_4);\n  if ((_Var1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swrite",
        "__sseek"
      ],
      "called": [
        "_lseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_usable_size_r": {
      "entrypoint": "0x0800a154",
      "current_name": "_malloc_usable_size_r",
      "code": "\nint _malloc_usable_size_r(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d *(int *)(param_2 + -4) + -4;\n  if (*(int *)(param_2 + -4) \u003c 0) {\n    iVar1 \u003d iVar1 + *(int *)(param_2 + iVar1);\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_realloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read_r": {
      "entrypoint": "0x0800a168",
      "current_name": "_read_r",
      "code": "\nvoid _read_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _read(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sread"
      ],
      "called": [
        "_read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__throw_bad_function_call": {
      "entrypoint": "0x0800a18c",
      "current_name": "__throw_bad_function_call",
      "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::__throw_bad_function_call(void)\n\n{\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "operator()"
      ],
      "called": [
        "abort"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_ctype_byname": {
      "entrypoint": "0x0800a3a0",
      "current_name": "_GLOBAL__sub_I_ctype_byname",
      "code": "\n/* std::ctype_byname\u003cchar\u003e::ctype_byname(std::__cxx11::basic_string\u003cchar, std::char_traits\u003cchar\u003e,\n   std::allocator\u003cchar\u003e \u003e const\u0026, unsigned int) */\n\nvoid std::ctype_byname\u003cchar\u003e::_GLOBAL__sub_I_ctype_byname(void)\n\n{\n  if (-1 \u003c __cxx11::moneypunct\u003cchar,false\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::moneypunct\u003cchar,false\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::moneypunct\u003cchar,true\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::moneypunct\u003cchar,true\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::money_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c\n           0x1f) {\n    __cxx11::money_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::money_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c\n           0x1f) {\n    __cxx11::money_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::numpunct\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::numpunct\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::time_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f\n     ) {\n    __cxx11::time_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::messages\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::messages\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::collate\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::collate\u003cchar\u003e::id \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_init": {
      "entrypoint": "0x0800a424",
      "current_name": "_init",
      "code": "\nvoid _init(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array",
        "__do_global_dtors_aux"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fini": {
      "entrypoint": "0x0800a430",
      "current_name": "_fini",
      "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}