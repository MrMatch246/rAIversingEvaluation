{
  "functions": {
    "__do_global_dtors_aux": {
      "entrypoint": "0x080001ac",
      "current_name": "__do_global_dtors_aux",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x080001b8) */\n\nundefined4 __do_global_dtors_aux(undefined4 param_1)\n\n{\n  if ((char)completed_8667 \u003d\u003d \u0027\\0\u0027) {\n    completed_8667._0_1_ \u003d \u0027\\x01\u0027;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "frame_dummy": {
      "entrypoint": "0x080001d0",
      "current_name": "frame_dummy",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x080001d4) */\n/* WARNING: Removing unreachable block (ram,0x080001ee) */\n/* WARNING: Removing unreachable block (ram,0x080001e4) */\n/* WARNING: Removing unreachable block (ram,0x08000200) */\n/* WARNING: Removing unreachable block (ram,0x080001f4) */\n\nvoid frame_dummy(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x08000218",
      "current_name": "strlen",
      "code": "\nsize_t strlen(char *__s)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 \u003d __s;\n  do {\n    pcVar2 \u003d pcVar3 + 1;\n    cVar1 \u003d *pcVar3;\n    pcVar3 \u003d pcVar2;\n  } while (cVar1 !\u003d \u0027\\0\u0027);\n  return (size_t)(pcVar2 + (-1 - (int)__s));\n}\n\n",
      "renaming": {},
      "calling": [
        "printNumber"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memchr": {
      "entrypoint": "0x08000230",
      "current_name": "memchr",
      "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  char cVar4;\n  char cVar5;\n  byte *pbVar6;\n  uint *puVar7;\n  byte *pbVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  uint uVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  bool bVar17;\n  \n  uVar9 \u003d __c \u0026 0xff;\n  if ((int)__n \u003c 0x10) {\njoined_r0x08000290:\n    do {\n      if (__n \u003d\u003d 0) {\n        return (void *)0x0;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 \u003d (uint *)((int)__s + 1);\n      bVar1 \u003d *__s;\n      __n \u003d __n - 1;\n      __s \u003d puVar7;\n    } while (bVar1 !\u003d uVar9);\n  }\n  else {\n    uVar10 \u003d (uint)__s \u0026 7;\n    while( true ) {\n      if (uVar10 \u003d\u003d 0) {\n        uVar10 \u003d uVar9 | uVar9 \u003c\u003c 8;\n        uVar10 \u003d uVar10 | uVar10 \u003c\u003c 0x10;\n        uVar11 \u003d __n \u0026 0xfffffff8;\n        do {\n          puVar7 \u003d (uint *)((int)__s + 8);\n                    /* WARNING: Load size is inaccurate */\n          uVar11 \u003d uVar11 - 8;\n          uVar12 \u003d *__s ^ uVar10;\n          uVar13 \u003d *(uint *)((int)__s + 4) ^ uVar10;\n          cVar2 \u003d -((char)uVar12 \u003d\u003d \u0027\\0\u0027);\n          cVar3 \u003d -((char)(uVar12 \u003e\u003e 8) \u003d\u003d \u0027\\0\u0027);\n          cVar4 \u003d -((char)(uVar12 \u003e\u003e 0x10) \u003d\u003d \u0027\\0\u0027);\n          cVar5 \u003d -((char)(uVar12 \u003e\u003e 0x18) \u003d\u003d \u0027\\0\u0027);\n          uVar12 \u003d CONCAT13(cVar5,CONCAT12(cVar4,CONCAT11(cVar3,cVar2)));\n          bVar14 \u003d (char)uVar13 !\u003d \u0027\\0\u0027;\n          bVar15 \u003d (char)(uVar13 \u003e\u003e 8) !\u003d \u0027\\0\u0027;\n          bVar16 \u003d (char)(uVar13 \u003e\u003e 0x10) !\u003d \u0027\\0\u0027;\n          bVar17 \u003d (char)(uVar13 \u003e\u003e 0x18) !\u003d \u0027\\0\u0027;\n          uVar13 \u003d CONCAT13(bVar17 * cVar5 - !bVar17,\n                            CONCAT12(bVar16 * cVar4 - !bVar16,\n                                     CONCAT11(bVar15 * cVar3 - !bVar15,bVar14 * cVar2 - !bVar14)));\n          if (uVar13 !\u003d 0) {\n            if (uVar12 \u003d\u003d 0) {\n              pbVar8 \u003d (byte *)((int)__s + 5);\n              uVar12 \u003d uVar13;\n            }\n            else {\n              pbVar8 \u003d (byte *)((int)__s + 1);\n            }\n            if ((uVar12 \u0026 1) \u003d\u003d 0) {\n              bVar14 \u003d (uVar12 \u0026 0x100) \u003d\u003d 0;\n              pbVar6 \u003d pbVar8 + 1;\n              if (bVar14) {\n                bVar14 \u003d (uVar12 \u0026 0x18000) \u003d\u003d 0;\n                pbVar6 \u003d pbVar8 + 2;\n              }\n              pbVar8 \u003d pbVar6;\n              if (bVar14) {\n                pbVar8 \u003d pbVar8 + 1;\n              }\n            }\n            return pbVar8 + -1;\n          }\n          __s \u003d puVar7;\n        } while (uVar11 !\u003d 0);\n        __n \u003d __n \u0026 7;\n        goto joined_r0x08000290;\n      }\n                    /* WARNING: Load size is inaccurate */\n      puVar7 \u003d (uint *)((int)__s + 1);\n      __n \u003d __n - 1;\n      if (*__s \u003d\u003d uVar9) break;\n      uVar10 \u003d (uint)puVar7 \u0026 7;\n      __s \u003d puVar7;\n      if (__n \u003d\u003d 0) {\n        return (void *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)puVar7 + -1);\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r",
        "_printf_i"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_uldivmod": {
      "entrypoint": "0x080002d0",
      "current_name": "__aeabi_uldivmod",
      "code": "\nvoid __aeabi_uldivmod(int param_1,int param_2,int param_3,int param_4)\n\n{\n  if ((param_4 \u003d\u003d 0) \u0026\u0026 (param_3 \u003d\u003d 0)) {\n    if (param_2 !\u003d 0 || param_1 !\u003d 0) {\n      param_2 \u003d -1;\n      param_1 \u003d -1;\n    }\n    __aeabi_idiv0(param_1,param_2);\n    return;\n  }\n  __udivmoddi4();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_GetSysClockFreq"
      ],
      "called": [
        "__aeabi_idiv0",
        "__udivmoddi4"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__udivmoddi4": {
      "entrypoint": "0x08000300",
      "current_name": "__udivmoddi4",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x080005aa) */\n\nulonglong __udivmoddi4(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  ulonglong uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  bool bVar11;\n  \n  if (param_4 \u003d\u003d 0) {\n    if (param_2 \u003c param_3) {\n      iVar10 \u003d LZCOUNT(param_3);\n      if (iVar10 !\u003d 0) {\n        param_3 \u003d param_3 \u003c\u003c iVar10;\n        param_2 \u003d param_1 \u003e\u003e (0x20U - iVar10 \u0026 0xff) | param_2 \u003c\u003c iVar10;\n        param_1 \u003d param_1 \u003c\u003c iVar10;\n      }\n      uVar8 \u003d param_3 \u003e\u003e 0x10;\n      uVar6 \u003d param_2 / uVar8;\n      uVar5 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar8 * uVar6) * 0x10000;\n      uVar4 \u003d uVar6 * (param_3 \u0026 0xffff);\n      uVar3 \u003d uVar6;\n      if (uVar5 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar5 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar5,param_3);\n        uVar5 \u003d uVar5 + param_3;\n        uVar3 \u003d uVar6 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar5 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar5 !\u003d 0)) {\n          uVar3 \u003d uVar6 - 2;\n          uVar5 \u003d uVar5 + param_3;\n        }\n      }\n      uVar6 \u003d (uVar5 - uVar4) / uVar8;\n      uVar5 \u003d param_1 \u0026 0xffff | ((uVar5 - uVar4) - uVar8 * uVar6) * 0x10000;\n      uVar8 \u003d uVar6 * (param_3 \u0026 0xffff);\n      uVar4 \u003d uVar6;\n      if (uVar5 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar5 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar5,param_3);\n        uVar5 \u003d uVar5 + param_3;\n        uVar4 \u003d uVar6 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar5 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar5 !\u003d 0)) {\n          uVar4 \u003d uVar6 - 2;\n          uVar5 \u003d uVar5 + param_3;\n        }\n      }\n      uVar5 \u003d uVar5 - uVar8;\n      uVar4 \u003d uVar4 | uVar3 \u003c\u003c 0x10;\n      uVar3 \u003d 0;\n    }\n    else {\n      if (param_3 \u003d\u003d 0) {\n        param_3 \u003d 1 / 0;\n      }\n      iVar10 \u003d LZCOUNT(param_3);\n      if (iVar10 \u003d\u003d 0) {\n        param_2 \u003d param_2 - param_3;\n        uVar5 \u003d param_3 \u003e\u003e 0x10;\n        uVar9 \u003d param_3 \u0026 0xffff;\n        uVar3 \u003d 1;\n      }\n      else {\n        param_3 \u003d param_3 \u003c\u003c iVar10;\n        uVar5 \u003d param_3 \u003e\u003e 0x10;\n        uVar4 \u003d param_2 \u003e\u003e (0x20U - iVar10 \u0026 0xff);\n        uVar7 \u003d param_1 \u003e\u003e (0x20U - iVar10 \u0026 0xff) | param_2 \u003c\u003c iVar10;\n        uVar3 \u003d uVar4 / uVar5;\n        uVar9 \u003d param_3 \u0026 0xffff;\n        uVar8 \u003d uVar7 \u003e\u003e 0x10 | (uVar4 - uVar5 * uVar3) * 0x10000;\n        uVar6 \u003d uVar3 * uVar9;\n        param_1 \u003d param_1 \u003c\u003c iVar10;\n        uVar4 \u003d uVar3;\n        if (uVar8 \u003c\u003d uVar6 \u0026\u0026 uVar6 - uVar8 !\u003d 0) {\n          bVar11 \u003d CARRY4(uVar8,param_3);\n          uVar8 \u003d uVar8 + param_3;\n          uVar4 \u003d uVar3 - 1;\n          if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar8 \u003c\u003d uVar6 \u0026\u0026 uVar6 - uVar8 !\u003d 0)) {\n            uVar4 \u003d uVar3 - 2;\n            uVar8 \u003d uVar8 + param_3;\n          }\n        }\n        uVar2 \u003d (uVar8 - uVar6) / uVar5;\n        param_2 \u003d uVar7 \u0026 0xffff | ((uVar8 - uVar6) - uVar5 * uVar2) * 0x10000;\n        uVar6 \u003d uVar2 * uVar9;\n        uVar3 \u003d uVar2;\n        if (param_2 \u003c\u003d uVar6 \u0026\u0026 uVar6 - param_2 !\u003d 0) {\n          bVar11 \u003d CARRY4(param_2,param_3);\n          param_2 \u003d param_2 + param_3;\n          uVar3 \u003d uVar2 - 1;\n          if ((bVar11 \u003d\u003d false) \u0026\u0026 (param_2 \u003c\u003d uVar6 \u0026\u0026 uVar6 - param_2 !\u003d 0)) {\n            uVar3 \u003d uVar2 - 2;\n            param_2 \u003d param_2 + param_3;\n          }\n        }\n        param_2 \u003d param_2 - uVar6;\n        uVar3 \u003d uVar3 | uVar4 \u003c\u003c 0x10;\n      }\n      uVar7 \u003d param_2 / uVar5;\n      uVar8 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar5 * uVar7) * 0x10000;\n      uVar4 \u003d uVar9 * uVar7;\n      uVar6 \u003d uVar7;\n      if (uVar8 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar8 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar8,param_3);\n        uVar8 \u003d uVar8 + param_3;\n        uVar6 \u003d uVar7 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar8 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar8 !\u003d 0)) {\n          uVar6 \u003d uVar7 - 2;\n          uVar8 \u003d uVar8 + param_3;\n        }\n      }\n      uVar7 \u003d (uVar8 - uVar4) / uVar5;\n      uVar5 \u003d param_1 \u0026 0xffff | ((uVar8 - uVar4) - uVar5 * uVar7) * 0x10000;\n      uVar9 \u003d uVar9 * uVar7;\n      uVar4 \u003d uVar7;\n      if (uVar5 \u003c\u003d uVar9 \u0026\u0026 uVar9 - uVar5 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar5,param_3);\n        uVar5 \u003d uVar5 + param_3;\n        uVar4 \u003d uVar7 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar5 \u003c\u003d uVar9 \u0026\u0026 uVar9 - uVar5 !\u003d 0)) {\n          uVar4 \u003d uVar7 - 2;\n          uVar5 \u003d uVar5 + param_3;\n        }\n      }\n      uVar5 \u003d uVar5 - uVar9;\n      uVar4 \u003d uVar4 | uVar6 \u003c\u003c 0x10;\n    }\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d uVar5 \u003e\u003e iVar10;\n      param_5[1] \u003d 0;\n      return CONCAT44(uVar3,uVar4);\n    }\n  }\n  else if (param_2 \u003c param_4) {\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d param_1;\n      param_5[1] \u003d param_2;\n      return 0;\n    }\n    uVar4 \u003d 0;\n    uVar3 \u003d 0;\n  }\n  else {\n    iVar10 \u003d LZCOUNT(param_4);\n    if (iVar10 !\u003d 0) {\n      uVar8 \u003d 0x20 - iVar10;\n      uVar3 \u003d param_3 \u003e\u003e (uVar8 \u0026 0xff) | param_4 \u003c\u003c iVar10;\n      uVar9 \u003d uVar3 \u003e\u003e 0x10;\n      uVar4 \u003d param_2 \u003e\u003e (uVar8 \u0026 0xff);\n      uVar2 \u003d param_1 \u003e\u003e (uVar8 \u0026 0xff) | param_2 \u003c\u003c iVar10;\n      uVar7 \u003d uVar4 / uVar9;\n      uVar6 \u003d uVar2 \u003e\u003e 0x10 | (uVar4 - uVar9 * uVar7) * 0x10000;\n      uVar5 \u003d uVar7 * (uVar3 \u0026 0xffff);\n      param_1 \u003d param_1 \u003c\u003c iVar10;\n      uVar4 \u003d uVar7;\n      if (uVar6 \u003c\u003d uVar5 \u0026\u0026 uVar5 - uVar6 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar6,uVar3);\n        uVar6 \u003d uVar6 + uVar3;\n        uVar4 \u003d uVar7 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar5 \u0026\u0026 uVar5 - uVar6 !\u003d 0)) {\n          uVar4 \u003d uVar7 - 2;\n          uVar6 \u003d uVar6 + uVar3;\n        }\n      }\n      uVar7 \u003d (uVar6 - uVar5) / uVar9;\n      uVar6 \u003d uVar2 \u0026 0xffff | ((uVar6 - uVar5) - uVar9 * uVar7) * 0x10000;\n      uVar9 \u003d uVar7 * (uVar3 \u0026 0xffff);\n      uVar5 \u003d uVar7;\n      if (uVar6 \u003c\u003d uVar9 \u0026\u0026 uVar9 - uVar6 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar6,uVar3);\n        uVar6 \u003d uVar6 + uVar3;\n        uVar5 \u003d uVar7 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar9 \u0026\u0026 uVar9 - uVar6 !\u003d 0)) {\n          uVar5 \u003d uVar7 - 2;\n          uVar6 \u003d uVar6 + uVar3;\n        }\n      }\n      uVar5 \u003d uVar5 | uVar4 \u003c\u003c 0x10;\n      uVar1 \u003d (ulonglong)uVar5 * (ulonglong)(param_3 \u003c\u003c iVar10);\n      if (CONCAT44(uVar6 - uVar9,param_1) \u003c uVar1) {\n        uVar1 \u003d uVar1 - CONCAT44(uVar3,param_3 \u003c\u003c iVar10);\n        uVar5 \u003d uVar5 - 1;\n      }\n      if (param_5 !\u003d (uint *)0x0) {\n        uVar4 \u003d ((uVar6 - uVar9) - (int)(uVar1 \u003e\u003e 0x20)) - (uint)(param_1 \u003c (uint)uVar1);\n        *param_5 \u003d uVar4 \u003c\u003c (uVar8 \u0026 0xff) | param_1 - (uint)uVar1 \u003e\u003e iVar10;\n        param_5[1] \u003d uVar4 \u003e\u003e iVar10;\n      }\n      return (ulonglong)uVar5;\n    }\n    if ((param_4 \u003c param_2) || (param_3 \u003c\u003d param_1)) {\n      bVar11 \u003d param_1 \u003c param_3;\n      param_1 \u003d param_1 - param_3;\n      param_2 \u003d (param_2 - param_4) - (uint)bVar11;\n      uVar4 \u003d 1;\n    }\n    else {\n      uVar4 \u003d 0;\n    }\n    uVar3 \u003d 0;\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d param_1;\n      param_5[1] \u003d param_2;\n      return (ulonglong)uVar4;\n    }\n  }\n  return CONCAT44(uVar3,uVar4);\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_uldivmod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_idiv0": {
      "entrypoint": "0x080005dc",
      "current_name": "__aeabi_idiv0",
      "code": "\nvoid __aeabi_idiv0(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_uldivmod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "aflCall": {
      "entrypoint": "0x080005e0",
      "current_name": "aflCall",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
      "renaming": {},
      "calling": [
        "startForkserver"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "startForkserver": {
      "entrypoint": "0x080005e4",
      "current_name": "startForkserver",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (noHyperCall !\u003d 0) {\n    return 0;\n  }\n  uVar1 \u003d aflCall(1,ticks,0);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "aflCall"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "begin": {
      "entrypoint": "0x08004388",
      "current_name": "begin",
      "code": "\n/* DWARF original prototype: void  begin(HardwareSerial * this, ulong baud, byte config) */\n\nvoid __thiscall HardwareSerial::begin(HardwareSerial *this,ulong baud,byte config)\n\n{\n  byte bVar1;\n  int iVar2;\n  \n  (this-\u003e_serial).baudrate \u003d baud;\n  this-\u003e_config \u003d config;\n  bVar1 \u003d config \u0026 7;\n  if (bVar1 \u003d\u003d 4) {\n    iVar2 \u003d 7;\n  }\n  else if (bVar1 \u003d\u003d 6) {\n    iVar2 \u003d 8;\n  }\n  else if (bVar1 \u003d\u003d 2) {\n    iVar2 \u003d 6;\n  }\n  else {\n    iVar2 \u003d 0;\n  }\n  if ((config \u0026 0x30) \u003d\u003d 0x30) {\n    (this-\u003e_serial).parity \u003d 0x600;\n    iVar2 \u003d iVar2 + 1;\n  }\n  else if ((config \u0026 0x20) \u003d\u003d 0) {\n    (this-\u003e_serial).parity \u003d 0;\n  }\n  else {\n    (this-\u003e_serial).parity \u003d 0x400;\n    iVar2 \u003d iVar2 + 1;\n  }\n  if ((config \u0026 8) \u003d\u003d 0) {\n    (this-\u003e_serial).stopbits \u003d 0;\n  }\n  else {\n    (this-\u003e_serial).stopbits \u003d 0x2000;\n  }\n  if (iVar2 \u003d\u003d 8) {\n    (this-\u003e_serial).databits \u003d 0;\n  }\n  else if (iVar2 \u003d\u003d 9) {\n    (this-\u003e_serial).databits \u003d 0x1000;\n  }\n  else {\n    iVar2 \u003d 0;\n  }\n  if (iVar2 !\u003d 0) {\n    uart_init((serial_t *)\u0026this-\u003e_serial);\n    uart_attach_rx_callback((serial_t *)\u0026this-\u003e_serial,_rx_complete_irq + 1);\n    return;\n  }\n                    \n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!\u003d0\");\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "__assert_func",
        "uart_attach_rx_callback",
        "uart_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "init": {
      "entrypoint": "0x08004364",
      "current_name": "init",
      "code": "\n/* DWARF original prototype: void  init(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::init(HardwareSerial *this,EVP_PKEY_CTX *ctx)\n\n{\n  (this-\u003e_serial).rx_buff \u003d this-\u003e_rx_buffer;\n  (this-\u003e_serial).rx_head \u003d 0;\n  (this-\u003e_serial).rx_tail \u003d 0;\n  (this-\u003e_serial).tx_buff \u003d this-\u003e_tx_buffer;\n  (this-\u003e_serial).tx_head \u003d 0;\n  (this-\u003e_serial).tx_tail \u003d 0;\n  return (int)this;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Modbus": {
      "entrypoint": "0x08000682",
      "current_name": "Modbus",
      "code": "\n/* DWARF original prototype: Modbus *  Modbus(Modbus * this, uint8_t u8id, uint8_t u8serno, uint8_t\n   u8txenpin) */\n\nModbus * __thiscall Modbus::Modbus(Modbus *this,uint8_t u8id,uint8_t u8serno,uint8_t u8txenpin)\n\n{\n  init(this,(EVP_PKEY_CTX *)(uint)u8id);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__static_initialization_and_destruction_0": {
      "entrypoint": "0x080046b4",
      "current_name": "__static_initialization_and_destruction_0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid __static_initialization_and_destruction_0(int __initialize_p,int __priority)\n\n{\n  if (__initialize_p !\u003d 1) {\n    return;\n  }\n  if (__priority \u003d\u003d 0xffff) {\n    gpio_irq_conf[0].irqnb \u003d EXTI0_IRQn;\n    gpio_irq_conf[0].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[1].irqnb \u003d EXTI1_IRQn;\n    gpio_irq_conf[1].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[2].irqnb \u003d EXTI2_IRQn;\n    gpio_irq_conf[2].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[3].irqnb \u003d EXTI3_IRQn;\n    gpio_irq_conf[3].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[4].irqnb \u003d EXTI4_IRQn;\n    gpio_irq_conf[4].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[5].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[5].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[6].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[6].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[7].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[7].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[8].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[8].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[9].irqnb \u003d EXTI9_5_IRQn;\n    gpio_irq_conf[9].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[10].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[10].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[11].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[11].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[12].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[12].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[13].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[13].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[14].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[14].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    gpio_irq_conf[15].irqnb \u003d EXTI15_10_IRQn;\n    gpio_irq_conf[15].callback.super__Function_base._M_manager \u003d (_Manager_type)0x0;\n    __aeabi_atexit(0,0x800468d,0x20000000);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm"
      ],
      "called": [
        "__aeabi_atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getRxBuffer": {
      "entrypoint": "0x080006b4",
      "current_name": "getRxBuffer",
      "code": "\n/* DWARF original prototype: int8_t  getRxBuffer(Modbus * this) */\n\nint8_t __thiscall Modbus::getRxBuffer(Modbus *this)\n\n{\n  bool bVar1;\n  int iVar2;\n  byte bVar3;\n  \n  if (1 \u003c this-\u003eu8txenpin) {\n    digitalWrite((uint)this-\u003eu8txenpin,0);\n  }\n  this-\u003eu8BufferSize \u003d \u0027\\0\u0027;\n  if (this-\u003eu8serno \u003c 4) {\n    bVar1 \u003d false;\n    while (iVar2 \u003d (*(this-\u003eport-\u003esuper_Stream).super_Print._vptr_Print[2])(), iVar2 !\u003d 0) {\n      bVar3 \u003d this-\u003eu8BufferSize;\n      iVar2 \u003d (*(this-\u003eport-\u003esuper_Stream).super_Print._vptr_Print[3])();\n      this-\u003eau8Buffer[bVar3] \u003d (uint8_t)iVar2;\n      bVar3 \u003d this-\u003eu8BufferSize + 1;\n      this-\u003eu8BufferSize \u003d bVar3;\n      if (0x3f \u003c bVar3) {\n        bVar1 \u003d true;\n      }\n    }\n  }\n  else {\n    bVar1 \u003d false;\n  }\n  this-\u003eu16InCnt \u003d this-\u003eu16InCnt + 1;\n  if (bVar1) {\n    this-\u003eu16errCnt \u003d this-\u003eu16errCnt + 1;\n    return -3;\n  }\n  return this-\u003eu8BufferSize;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "digitalWrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "calcCRC": {
      "entrypoint": "0x08000728",
      "current_name": "calcCRC",
      "code": "\n/* DWARF original prototype: uint16_t  calcCRC(Modbus * this, uint8_t u8length) */\n\nuint16_t __thiscall Modbus::calcCRC(Modbus *this,uint8_t u8length)\n\n{\n  uchar j;\n  uint uVar1;\n  uint flag;\n  uint uVar2;\n  uint uVar3;\n  \n  uVar1 \u003d 0xffff;\n  for (uVar3 \u003d 0; uVar3 \u003c u8length; uVar3 \u003d uVar3 + 1 \u0026 0xff) {\n    uVar1 \u003d uVar1 ^ this-\u003eau8Buffer[uVar3];\n    for (j \u003d 1; j \u003c 9; j \u003d j + 1) {\n      uVar2 \u003d uVar1 \u0026 1;\n      uVar1 \u003d uVar1 \u003e\u003e 1;\n      if (uVar2 !\u003d 0) {\n        uVar1 \u003d uVar1 ^ 0xa001;\n      }\n    }\n  }\n  return (ushort)(uVar1 \u003c\u003c 8) | (ushort)(uVar1 \u003e\u003e 8);\n}\n\n",
      "renaming": {},
      "calling": [
        "sendTxBuffer"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sendTxBuffer": {
      "entrypoint": "0x0800076c",
      "current_name": "sendTxBuffer",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080007ec */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: void  sendTxBuffer(Modbus * this) */\n\nvoid __thiscall Modbus::sendTxBuffer(Modbus *this)\n\n{\n  byte u8length;\n  uint16_t uVar1;\n  uint16_t u16crc;\n  int iVar2;\n  uint32_t uVar3;\n  uint uVar4;\n  \n  u8length \u003d this-\u003eu8BufferSize;\n  uVar1 \u003d calcCRC(this,u8length);\n  this-\u003eau8Buffer[u8length] \u003d (uint8_t)(uVar1 \u003e\u003e 8);\n  uVar4 \u003d u8length + 1 \u0026 0xff;\n  this-\u003eau8Buffer[uVar4] \u003d (uint8_t)uVar1;\n  this-\u003eu8BufferSize \u003d (char)uVar4 + \u0027\\x01\u0027;\n  if (1 \u003c this-\u003eu8txenpin) {\n    digitalWrite((uint)this-\u003eu8txenpin,1);\n  }\n  if (this-\u003eu8serno \u003c 4) {\n    (*(this-\u003eport-\u003esuper_Stream).super_Print._vptr_Print[1])\n              (this-\u003eport,this-\u003eau8Buffer,(uint)this-\u003eu8BufferSize);\n  }\n  if (1 \u003c this-\u003eu8txenpin) {\n    digitalWrite((uint)this-\u003eu8txenpin,0);\n  }\n  if (this-\u003eu8serno \u003c 4) {\n    do {\n      iVar2 \u003d (*(this-\u003eport-\u003esuper_Stream).super_Print._vptr_Print[3])();\n    } while (-1 \u003c iVar2);\n  }\n  this-\u003eu8BufferSize \u003d \u0027\\0\u0027;\n  uVar3 \u003d millis();\n  this-\u003eu32timeOut \u003d uVar3 + this-\u003eu16timeOut;\n  this-\u003eu16OutCnt \u003d this-\u003eu16OutCnt + 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "process_FC16",
        "poll",
        "process_FC3",
        "process_FC6",
        "process_FC15",
        "process_FC5",
        "process_FC1"
      ],
      "called": [
        "calcCRC",
        "digitalWrite",
        "millis"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "validateRequest": {
      "entrypoint": "0x080007f0",
      "current_name": "validateRequest",
      "code": "\n/* DWARF original prototype: uint8_t  validateRequest(Modbus * this) */\n\nuint8_t __thiscall Modbus::validateRequest(Modbus *this)\n\n{\n  bool bVar1;\n  uint16_t uVar2;\n  uint16_t uVar3;\n  uint uVar4;\n  uint8_t u8regs;\n  \n  uVar4 \u003d 0;\n  do {\n    if (7 \u003c uVar4) {\n      bVar1 \u003d false;\nLAB_0800080a:\n      if (!bVar1) {\n        this-\u003eu16errCnt \u003d this-\u003eu16errCnt + 1;\n        return \u0027\\x01\u0027;\n      }\n      switch(this-\u003eau8Buffer[1]) {\n      case \u0027\\x01\u0027:\n      case \u0027\\x02\u0027:\n      case \u0027\\x0f\u0027:\n        goto switchD_08000816_caseD_1;\n      case \u0027\\x03\u0027:\n      case \u0027\\x04\u0027:\n      case \u0027\\x10\u0027:\n        uVar2 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n        uVar3 \u003d makeWord(this-\u003eau8Buffer[4],this-\u003eau8Buffer[5]);\n        if (this-\u003eu8regsize \u003c (byte)((char)uVar3 + (char)uVar2)) {\n          return \u0027\\x02\u0027;\n        }\n        return \u0027\\0\u0027;\n      case \u0027\\x05\u0027:\n        uVar2 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n        if ((uint)this-\u003eu8regsize \u003c ((uint)uVar2 \u003c\u003c 0x14) \u003e\u003e 0x18) {\n          return \u0027\\x02\u0027;\n        }\n        return \u0027\\0\u0027;\n      case \u0027\\x06\u0027:\n        uVar2 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n        if (this-\u003eu8regsize \u003c (byte)uVar2) {\n          return \u0027\\x02\u0027;\n        }\n        return \u0027\\0\u0027;\n      default:\n        return \u0027\\0\u0027;\n      }\n    }\n    if (\"\\x01\\x02\\x03\\x04\\x05\\x06\\x0f\\x10\"[uVar4] \u003d\u003d this-\u003eau8Buffer[1]) {\n      bVar1 \u003d true;\n      goto LAB_0800080a;\n    }\n    uVar4 \u003d uVar4 + 1 \u0026 0xff;\n  } while( true );\nswitchD_08000816_caseD_1:\n  uVar2 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n  uVar3 \u003d makeWord(this-\u003eau8Buffer[4],this-\u003eau8Buffer[5]);\n  if ((uint)this-\u003eu8regsize \u003c\n      ((((uint)uVar2 \u003c\u003c 0xc) \u003e\u003e 0x10) + (((uint)uVar3 \u003c\u003c 0xc) \u003e\u003e 0x10) \u0026 0xff)) {\n    return \u0027\\x02\u0027;\n  }\n  return \u0027\\0\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "makeWord"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "buildException": {
      "entrypoint": "0x080008cc",
      "current_name": "buildException",
      "code": "\n/* DWARF original prototype: void  buildException(Modbus * this, uint8_t u8exception) */\n\nvoid __thiscall Modbus::buildException(Modbus *this,uint8_t u8exception)\n\n{\n  byte bVar1;\n  uint8_t u8func;\n  \n  bVar1 \u003d this-\u003eau8Buffer[1];\n  this-\u003eau8Buffer[0] \u003d this-\u003eu8id;\n  this-\u003eau8Buffer[1] \u003d bVar1 ^ 0x80;\n  this-\u003eau8Buffer[2] \u003d u8exception;\n  this-\u003eu8BufferSize \u003d \u0027\\x03\u0027;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_FC1": {
      "entrypoint": "0x080008e2",
      "current_name": "process_FC1",
      "code": "\n/* DWARF original prototype: int8_t  process_FC1(Modbus * this, uint16_t * regs, uint8_t u8size) */\n\nint8_t __thiscall Modbus::process_FC1(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint16_t uVar1;\n  uint16_t uVar2;\n  uint16_t u16Coilno;\n  uint uVar3;\n  uint uVar4;\n  uint8_t uVar5;\n  uint8_t u8bytesno;\n  uint8_t u8CopyBufferSize;\n  uint16_t u16StartCoil;\n  \n  uVar1 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n  uVar2 \u003d makeWord(this-\u003eau8Buffer[4],this-\u003eau8Buffer[5]);\n  uVar5 \u003d (uint8_t)(((uint)uVar2 \u003c\u003c 0x15) \u003e\u003e 0x18);\n  if ((uVar2 \u0026 7) !\u003d 0) {\n    uVar5 \u003d uVar5 + \u0027\\x01\u0027;\n  }\n  this-\u003eau8Buffer[2] \u003d uVar5;\n  this-\u003eu8BufferSize \u003d \u0027\\x03\u0027;\n  uVar4 \u003d 0;\n  for (uVar3 \u003d 0; uVar3 \u003c uVar2; uVar3 \u003d uVar3 + 1 \u0026 0xffff) {\n    if (((int)(uint)regs[(uVar3 + uVar1) * 0x100000 \u003e\u003e 0x18] \u003e\u003e (uVar3 + uVar1 \u0026 0xf) \u0026 1U) \u003d\u003d 0) {\n      this-\u003eau8Buffer[this-\u003eu8BufferSize] \u003d\n           this-\u003eau8Buffer[this-\u003eu8BufferSize] \u0026 ~(byte)(1 \u003c\u003c uVar4);\n    }\n    else {\n      this-\u003eau8Buffer[this-\u003eu8BufferSize] \u003d this-\u003eau8Buffer[this-\u003eu8BufferSize] | (byte)(1 \u003c\u003c uVar4)\n      ;\n    }\n    uVar4 \u003d uVar4 + 1 \u0026 0xff;\n    if (7 \u003c uVar4) {\n      this-\u003eu8BufferSize \u003d this-\u003eu8BufferSize + \u0027\\x01\u0027;\n      uVar4 \u003d 0;\n    }\n  }\n  if ((uVar2 \u0026 7) !\u003d 0) {\n    this-\u003eu8BufferSize \u003d this-\u003eu8BufferSize + \u0027\\x01\u0027;\n  }\n  uVar5 \u003d this-\u003eu8BufferSize;\n  sendTxBuffer(this);\n  return uVar5 + \u0027\\x02\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "makeWord",
        "sendTxBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_FC3": {
      "entrypoint": "0x08000998",
      "current_name": "process_FC3",
      "code": "\n/* DWARF original prototype: int8_t  process_FC3(Modbus * this, uint16_t * regs, uint8_t u8size) */\n\nint8_t __thiscall Modbus::process_FC3(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  uint8_t u8regsno;\n  uint16_t uVar3;\n  uint16_t uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint8_t u8CopyBufferSize;\n  uint8_t u8StartAdd;\n  uint8_t i;\n  \n  uVar3 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n  uVar4 \u003d makeWord(this-\u003eau8Buffer[4],this-\u003eau8Buffer[5]);\n  this-\u003eau8Buffer[2] \u003d (byte)uVar4 \u003c\u003c 1;\n  this-\u003eu8BufferSize \u003d \u0027\\x03\u0027;\n  for (uVar5 \u003d (uint)(byte)uVar3; uVar5 \u003c (uint)(byte)uVar3 + (uint)(byte)uVar4;\n      uVar5 \u003d uVar5 + 1 \u0026 0xff) {\n    bVar1 \u003d this-\u003eu8BufferSize;\n    this-\u003eau8Buffer[bVar1] \u003d (uint8_t)(regs[uVar5] \u003e\u003e 8);\n    uVar6 \u003d bVar1 + 1 \u0026 0xff;\n    uVar2 \u003d (uint8_t)uVar6;\n    this-\u003eu8BufferSize \u003d uVar2;\n    this-\u003eau8Buffer[uVar6] \u003d *(uint8_t *)(regs + uVar5);\n    this-\u003eu8BufferSize \u003d uVar2 + \u0027\\x01\u0027;\n  }\n  uVar2 \u003d this-\u003eu8BufferSize;\n  sendTxBuffer(this);\n  return uVar2 + \u0027\\x02\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "makeWord",
        "sendTxBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_FC5": {
      "entrypoint": "0x08000a00",
      "current_name": "process_FC5",
      "code": "\n/* DWARF original prototype: int8_t  process_FC5(Modbus * this, uint16_t * regs, uint8_t u8size) */\n\nint8_t __thiscall Modbus::process_FC5(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint8_t u8currentBit;\n  uint16_t uVar1;\n  uint16_t u16coil;\n  uint uVar2;\n  uint8_t u8currentRegister;\n  uint uVar3;\n  \n  uVar1 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n  uVar3 \u003d ((uint)uVar1 \u003c\u003c 0x14) \u003e\u003e 0x18;\n  uVar2 \u003d uVar1 \u0026 0xf;\n  if (this-\u003eau8Buffer[4] \u003d\u003d 0xff) {\n    regs[uVar3] \u003d (ushort)(1 \u003c\u003c uVar2) | regs[uVar3];\n  }\n  else {\n    regs[uVar3] \u003d regs[uVar3] \u0026 ~(ushort)(1 \u003c\u003c uVar2);\n  }\n  this-\u003eu8BufferSize \u003d \u0027\\x06\u0027;\n  sendTxBuffer(this);\n  return \u0027\\b\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "makeWord",
        "sendTxBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_FC6": {
      "entrypoint": "0x08000a4e",
      "current_name": "process_FC6",
      "code": "\n/* DWARF original prototype: int8_t  process_FC6(Modbus * this, uint16_t * regs, uint8_t u8size) */\n\nint8_t __thiscall Modbus::process_FC6(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint16_t uVar1;\n  uint16_t uVar2;\n  uint16_t u16val;\n  uint8_t u8add;\n  \n  uVar1 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n  uVar2 \u003d makeWord(this-\u003eau8Buffer[4],this-\u003eau8Buffer[5]);\n  regs[(byte)uVar1] \u003d uVar2;\n  this-\u003eu8BufferSize \u003d \u0027\\x06\u0027;\n  sendTxBuffer(this);\n  return \u0027\\b\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "makeWord",
        "sendTxBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_FC15": {
      "entrypoint": "0x08000a7a",
      "current_name": "process_FC15",
      "code": "\n/* DWARF original prototype: int8_t  process_FC15(Modbus * this, uint16_t * regs, uint8_t u8size) */\n\nint8_t __thiscall Modbus::process_FC15(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  uint16_t uVar1;\n  uint16_t uVar2;\n  uint16_t u16Coilno;\n  uint uVar3;\n  uint uVar4;\n  uint8_t u8currentBit;\n  uint uVar5;\n  uint16_t u16StartCoil;\n  uint8_t u8currentRegister;\n  uint uVar6;\n  uint uVar7;\n  \n  uVar1 \u003d makeWord(this-\u003eau8Buffer[2],this-\u003eau8Buffer[3]);\n  uVar2 \u003d makeWord(this-\u003eau8Buffer[4],this-\u003eau8Buffer[5]);\n  uVar4 \u003d 0;\n  uVar7 \u003d 7;\n  for (uVar3 \u003d 0; uVar3 \u003c uVar2; uVar3 \u003d uVar3 + 1 \u0026 0xffff) {\n    uVar6 \u003d (uVar3 + uVar1) * 0x100000 \u003e\u003e 0x18;\n    uVar5 \u003d uVar3 + uVar1 \u0026 0xf;\n    if (((int)(uint)this-\u003eau8Buffer[uVar7] \u003e\u003e uVar4 \u0026 1U) \u003d\u003d 0) {\n      regs[uVar6] \u003d regs[uVar6] \u0026 ~(ushort)(1 \u003c\u003c uVar5);\n    }\n    else {\n      regs[uVar6] \u003d (ushort)(1 \u003c\u003c uVar5) | regs[uVar6];\n    }\n    uVar4 \u003d uVar4 + 1 \u0026 0xff;\n    if (7 \u003c uVar4) {\n      uVar7 \u003d uVar7 + 1 \u0026 0xff;\n      uVar4 \u003d 0;\n    }\n  }\n  this-\u003eu8BufferSize \u003d \u0027\\x06\u0027;\n  sendTxBuffer(this);\n  return \u0027\\b\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "makeWord",
        "sendTxBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "process_FC16": {
      "entrypoint": "0x08000b04",
      "current_name": "process_FC16",
      "code": "\n/* DWARF original prototype: int8_t  process_FC16(Modbus * this, uint16_t * regs, uint8_t u8size) */\n\nint8_t __thiscall Modbus::process_FC16(Modbus *this,uint16_t *regs,uint8_t u8size)\n\n{\n  byte bVar1;\n  byte bVar2;\n  uint8_t uVar3;\n  uint16_t uVar4;\n  uint16_t temp;\n  uint8_t u8CopyBufferSize;\n  uint8_t i;\n  uint uVar5;\n  uint8_t u8regsno;\n  uint8_t u8StartAdd;\n  \n  bVar1 \u003d this-\u003eau8Buffer[3];\n  bVar2 \u003d this-\u003eau8Buffer[5];\n  this-\u003eau8Buffer[4] \u003d \u0027\\0\u0027;\n  this-\u003eau8Buffer[5] \u003d bVar2;\n  this-\u003eu8BufferSize \u003d \u0027\\x06\u0027;\n  for (uVar5 \u003d 0; uVar5 \u003c bVar2; uVar5 \u003d uVar5 + 1 \u0026 0xff) {\n    uVar4 \u003d makeWord(this-\u003eau8Buffer[uVar5 * 2 + 7],this-\u003eau8Buffer[uVar5 * 2 + 8]);\n    regs[bVar1 + uVar5] \u003d uVar4;\n  }\n  uVar3 \u003d this-\u003eu8BufferSize;\n  sendTxBuffer(this);\n  return uVar3 + \u0027\\x02\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "poll"
      ],
      "called": [
        "makeWord",
        "sendTxBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "poll": {
      "entrypoint": "0x08000b54",
      "current_name": "poll",
      "code": "\n/* DWARF original prototype: int8_t  poll(Modbus * this, uint16_t * regs, uint8_t u8size) */\n\nint __thiscall Modbus::poll(Modbus *this,pollfd *__fds,nfds_t __nfds,int __timeout)\n\n{\n  uint8_t u8size;\n  uint8_t uVar1;\n  int8_t i8state;\n  uint8_t u8exception;\n  int8_t iVar2;\n  uint uVar3;\n  uint32_t uVar4;\n  uint8_t u8current;\n  uint unaff_r5;\n  int iVar5;\n  \n  this-\u003eau16regs \u003d (uint16_t *)__fds;\n  u8size \u003d (uint8_t)__nfds;\n  this-\u003eu8regsize \u003d u8size;\n  if (this-\u003eu8serno \u003c 4) {\n    uVar3 \u003d (*(this-\u003eport-\u003esuper_Stream).super_Print._vptr_Print[2])();\n    unaff_r5 \u003d uVar3 \u0026 0xff;\n  }\n  if (unaff_r5 \u003d\u003d 0) {\n    iVar5 \u003d 0;\n  }\n  else if ((int)unaff_r5 \u003c 8) {\n    iVar5 \u003d 0;\n  }\n  else {\n    uVar1 \u003d getRxBuffer(this);\n    iVar5 \u003d (int)(char)uVar1;\n    this-\u003eu8lastError \u003d uVar1;\n    if (this-\u003eau8Buffer[0] \u003d\u003d this-\u003eu8id) {\n      uVar1 \u003d validateRequest(this);\n      if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n        uVar4 \u003d millis();\n        this-\u003eu32timeOut \u003d this-\u003eu16timeOut + uVar4;\n        this-\u003eu8lastError \u003d \u0027\\0\u0027;\n        switch(this-\u003eau8Buffer[1]) {\n        case \u0027\\x01\u0027:\n        case \u0027\\x02\u0027:\n          iVar2 \u003d process_FC1(this,(uint16_t *)__fds,u8size);\n          iVar5 \u003d (int)iVar2;\n          break;\n        case \u0027\\x03\u0027:\n        case \u0027\\x04\u0027:\n          iVar2 \u003d process_FC3(this,(uint16_t *)__fds,u8size);\n          iVar5 \u003d (int)iVar2;\n          break;\n        case \u0027\\x05\u0027:\n          iVar2 \u003d process_FC5(this,(uint16_t *)__fds,u8size);\n          iVar5 \u003d (int)iVar2;\n          break;\n        case \u0027\\x06\u0027:\n          iVar2 \u003d process_FC6(this,(uint16_t *)__fds,u8size);\n          iVar5 \u003d (int)iVar2;\n          break;\n        case \u0027\\x0f\u0027:\n          iVar2 \u003d process_FC15(this,(uint16_t *)__fds,u8size);\n          iVar5 \u003d (int)iVar2;\n          break;\n        case \u0027\\x10\u0027:\n          iVar2 \u003d process_FC16(this,(uint16_t *)__fds,u8size);\n          iVar5 \u003d (int)iVar2;\n        }\n      }\n      else {\n        if (uVar1 !\u003d 0xff) {\n          buildException(this,uVar1);\n          sendTxBuffer(this);\n        }\n        this-\u003eu8lastError \u003d uVar1;\n        iVar5 \u003d (int)(char)uVar1;\n      }\n    }\n    else {\n      iVar5 \u003d 0;\n    }\n  }\n  return iVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "process_FC16",
        "sendTxBuffer",
        "validateRequest",
        "process_FC6",
        "process_FC3",
        "buildException",
        "process_FC15",
        "process_FC5",
        "getRxBuffer",
        "millis",
        "process_FC1"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setup": {
      "entrypoint": "0x08000c4c",
      "current_name": "setup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setup(void)\n\n{\n  startForkserver(0);\n  Modbus::begin(\u0026slave,0x4b00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "begin",
        "startForkserver"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "loop": {
      "entrypoint": "0x08000c64",
      "current_name": "loop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid loop(void)\n\n{\n  int in_r3;\n  \n  Modbus::poll(\u0026slave,(pollfd *)au16data,0x10,in_r3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "poll"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I__ZN6ModbusC2Ev": {
      "entrypoint": "0x08000c7c",
      "current_name": "_GLOBAL__sub_I__ZN6ModbusC2Ev",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I__ZN6ModbusC2Ev(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemClock_Config": {
      "entrypoint": "0x08000c8c",
      "current_name": "SystemClock_Config",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid SystemClock_Config(void)\n\n{\n  uint32_t uVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  RCC_OscInitTypeDef RCC_OscInitStruct;\n  RCC_ClkInitTypeDef RCC_ClkInitStruct;\n  \n  _DAT_40023840 \u003d _DAT_40023840 | 0x10000000;\n  _DAT_40007000 \u003d _DAT_40007000 | 0xc000;\n  RCC_OscInitStruct.OscillatorType \u003d 1;\n  RCC_OscInitStruct.HSEState \u003d 0x50000;\n  RCC_OscInitStruct.PLL.PLLState \u003d 2;\n  RCC_OscInitStruct.PLL.PLLSource \u003d 0x400000;\n  RCC_OscInitStruct.PLL.PLLM \u003d 8;\n  RCC_OscInitStruct.PLL.PLLN \u003d 0x150;\n  RCC_OscInitStruct.PLL.PLLP \u003d 2;\n  RCC_OscInitStruct.PLL.PLLQ \u003d 7;\n  HAL_RCC_OscConfig((RCC_OscInitTypeDef_conflict *)\u0026RCC_OscInitStruct);\n  HAL_PWREx_EnableOverDrive();\n  RCC_ClkInitStruct.ClockType \u003d 0xf;\n  RCC_ClkInitStruct.SYSCLKSource \u003d 2;\n  RCC_ClkInitStruct.AHBCLKDivider \u003d 0;\n  RCC_ClkInitStruct.APB1CLKDivider \u003d 0x1400;\n  RCC_ClkInitStruct.APB2CLKDivider \u003d 0x1000;\n  HAL_RCC_ClockConfig((RCC_ClkInitTypeDef_conflict *)\u0026RCC_ClkInitStruct,5);\n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(uVar1 / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(SysTick_IRQn,0,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "hw_config_init"
      ],
      "called": [
        "HAL_NVIC_SetPriority",
        "HAL_SYSTICK_Config",
        "HAL_RCC_OscConfig",
        "HAL_SYSTICK_CLKSourceConfig",
        "HAL_RCC_GetHCLKFreq",
        "HAL_PWREx_EnableOverDrive",
        "HAL_RCC_ClockConfig"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Reset_Handler": {
      "entrypoint": "0x08000d3c",
      "current_name": "Reset_Handler",
      "code": "\n/* WARNING: This function may have set the stack pointer */\n\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 \u003d 0; (undefined4 *)(iVar1 + 0x20000000) \u003c \u0026completed_8667; iVar1 \u003d iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) \u003d *(undefined4 *)(\u0026_sidata + iVar1);\n  }\n  for (puVar2 \u003d \u0026completed_8667; puVar2 \u003c \u0026_ebss; puVar2 \u003d puVar2 + 1) {\n    *puVar2 \u003d 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  UNRECOVERED_JUMPTABLE \u003d (code *)0x8000d72;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08000d72. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "SystemInit",
        "main",
        "__libc_init_array"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "CAN2_SCE_IRQHandler": {
      "entrypoint": "0x08000d8c",
      "current_name": "CAN2_SCE_IRQHandler",
      "code": "\nvoid CAN2_SCE_IRQHandler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "CAN2_SCE_IRQHandler"
      ],
      "called": [
        "CAN2_SCE_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_MspInit": {
      "entrypoint": "0x08000d96",
      "current_name": "HAL_MspInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_MspInit(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_InitTick": {
      "entrypoint": "0x08000d98",
      "current_name": "HAL_InitTick",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_SYSTICK_Config((uint32_t)((ulonglong)SystemCoreClock / (1000 / (ulonglong)uwTickFreq))\n                            );\n  if (uVar1 !\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (0xf \u003c TickPriority) {\n    return HAL_ERROR;\n  }\n  HAL_NVIC_SetPriority(SysTick_IRQn,TickPriority,0);\n  uwTickPrio \u003d TickPriority;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_ClockConfig",
        "HAL_Init"
      ],
      "called": [
        "HAL_NVIC_SetPriority",
        "HAL_SYSTICK_Config"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_Init": {
      "entrypoint": "0x08000de4",
      "current_name": "HAL_Init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_Init(void)\n\n{\n  _DAT_40023c00 \u003d _DAT_40023c00 | 0x700;\n  HAL_NVIC_SetPriorityGrouping(3);\n  HAL_InitTick(0xf);\n  HAL_MspInit();\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "hw_config_init"
      ],
      "called": [
        "HAL_MspInit",
        "HAL_NVIC_SetPriorityGrouping",
        "HAL_InitTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_IncTick": {
      "entrypoint": "0x08000e18",
      "current_name": "HAL_IncTick",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_IncTick(void)\n\n{\n  uwTick \u003d uwTickFreq + uwTick;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GetTick": {
      "entrypoint": "0x08000e30",
      "current_name": "HAL_GetTick",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_GetTick(void)\n\n{\n  return uwTick;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Transmit",
        "uart_debug_write",
        "HAL_RCC_OscConfig",
        "HAL_PWREx_EnableOverDrive",
        "GetCurrentMilli",
        "UART_WaitOnFlagUntilTimeout",
        "HAL_RCC_ClockConfig"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_SetPriorityGrouping": {
      "entrypoint": "0x08000e3c",
      "current_name": "HAL_NVIC_SetPriorityGrouping",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)\n\n{\n  uint32_t reg_value;\n  \n  _DAT_e000ed0c \u003d (PriorityGroup \u0026 7) \u003c\u003c 8 | _DAT_e000ed0c \u0026 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "premain",
        "HAL_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_SetPriority": {
      "entrypoint": "0x08000e60",
      "current_name": "HAL_NVIC_SetPriority",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_SetPriority(IRQn_Type_conflict IRQn,uint32_t PreemptPriority,uint32_t SubPriority)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint32_t PriorityGroupTmp;\n  uint32_t SubPriorityBits;\n  uint32_t PreemptPriorityBits;\n  \n  uVar1 \u003d (uint)IRQn;\n  uVar2 \u003d (uint)(_DAT_e000ed0c \u003c\u003c 0x15) \u003e\u003e 0x1d;\n  PreemptPriorityBits \u003d 7 - uVar2;\n  if (3 \u003c PreemptPriorityBits) {\n    PreemptPriorityBits \u003d 4;\n  }\n  if (uVar2 + 4 \u003c 7) {\n    SubPriorityBits \u003d 0;\n  }\n  else {\n    SubPriorityBits \u003d uVar2 - 3;\n  }\n  uVar2 \u003d (PreemptPriority \u0026 (1 \u003c\u003c (PreemptPriorityBits \u0026 0xff)) - 1U) \u003c\u003c (SubPriorityBits \u0026 0xff) |\n          (1 \u003c\u003c (SubPriorityBits \u0026 0xff)) - 1U \u0026 SubPriority;\n  if ((int)uVar1 \u003c 0) {\n    *(char *)((uVar1 \u0026 0xf) + 0xe000ed14) \u003d (char)(uVar2 \u003c\u003c 4);\n  }\n  else {\n    *(char *)(uVar1 + 0xe000e400) \u003d (char)(uVar2 \u003c\u003c 4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "uart_attach_rx_callback",
        "HAL_InitTick",
        "SystemClock_Config"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_EnableIRQ": {
      "entrypoint": "0x08000ec4",
      "current_name": "HAL_NVIC_EnableIRQ",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_EnableIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)IRQn;\n  if (-1 \u003c (int)uVar1) {\n    *(int *)((uVar1 \u003e\u003e 5) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uVar1 \u0026 0x1f);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "uart_attach_rx_callback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_Config": {
      "entrypoint": "0x08000ee0",
      "current_name": "HAL_SYSTICK_Config",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)\n\n{\n  if (TicksNumb - 1 \u003c 0x1000000) {\n    _DAT_e000e014 \u003d TicksNumb - 1;\n    DAT_e000ed23 \u003d 0xf0;\n    _DAT_e000e018 \u003d 0;\n    _DAT_e000e010 \u003d 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_InitTick",
        "SystemClock_Config"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_NVIC_ClearPendingIRQ": {
      "entrypoint": "0x08000f0c",
      "current_name": "HAL_NVIC_ClearPendingIRQ",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_NVIC_ClearPendingIRQ(IRQn_Type_conflict IRQn)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)IRQn;\n  if (-1 \u003c (int)uVar1) {\n    *(int *)(((uVar1 \u003e\u003e 5) + 0x60) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uVar1 \u0026 0x1f);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART4_IRQHandler",
        "USART6_IRQHandler",
        "USART2_IRQHandler",
        "UART5_IRQHandler",
        "USART3_IRQHandler",
        "UART8_IRQHandler",
        "UART7_IRQHandler",
        "USART1_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_CLKSourceConfig": {
      "entrypoint": "0x08000f2c",
      "current_name": "HAL_SYSTICK_CLKSourceConfig",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)\n\n{\n  if (CLKSource !\u003d 4) {\n    _DAT_e000e010 \u003d _DAT_e000e010 \u0026 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 \u003d _DAT_e000e010 | 4;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_Callback": {
      "entrypoint": "0x08000f4c",
      "current_name": "HAL_SYSTICK_Callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_SYSTICK_Callback(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_SYSTICK_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_SYSTICK_IRQHandler": {
      "entrypoint": "0x08000f4e",
      "current_name": "HAL_SYSTICK_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_SYSTICK_IRQHandler(void)\n\n{\n  HAL_SYSTICK_Callback();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [
        "HAL_SYSTICK_Callback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DAC_DeInit": {
      "entrypoint": "0x08000f56",
      "current_name": "HAL_DAC_DeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_DAC_DeInit(DAC_HandleTypeDef *hdac)\n\n{\n  if (hdac !\u003d (DAC_HandleTypeDef *)0x0) {\n    hdac-\u003eState \u003d HAL_DAC_STATE_BUSY;\n    HAL_DAC_MspDeInit(hdac);\n    hdac-\u003eErrorCode \u003d 0;\n    hdac-\u003eState \u003d HAL_DAC_STATE_RESET;\n    hdac-\u003eLock \u003d HAL_UNLOCKED;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "dac_stop"
      ],
      "called": [
        "HAL_DAC_MspDeInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DAC_Stop": {
      "entrypoint": "0x08000f72",
      "current_name": "HAL_DAC_Stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_DAC_Stop(DAC_HandleTypeDef *hdac,uint32_t Channel)\n\n{\n  hdac-\u003eInstance-\u003eCR \u003d hdac-\u003eInstance-\u003eCR \u0026 ~(1 \u003c\u003c (Channel \u0026 0xff));\n  hdac-\u003eState \u003d HAL_DAC_STATE_READY;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "dac_stop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DMA_Abort_IT": {
      "entrypoint": "0x08000f8c",
      "current_name": "HAL_DMA_Abort_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)\n\n{\n  if (hdma-\u003eState !\u003d HAL_DMA_STATE_BUSY) {\n    hdma-\u003eErrorCode \u003d 0x80;\n    return HAL_ERROR;\n  }\n  hdma-\u003eState \u003d HAL_DMA_STATE_ABORT;\n  hdma-\u003eInstance-\u003eCR \u003d hdma-\u003eInstance-\u003eCR \u0026 0xfffffffe;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_ITError",
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_Init": {
      "entrypoint": "0x08000fb4",
      "current_name": "HAL_GPIO_Init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_GPIO_Init(GPIO_TypeDef *GPIOx,GPIO_InitTypeDef *GPIO_Init)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint32_t uVar6;\n  int iVar7;\n  uint uVar8;\n  int iVar9;\n  uint32_t tmpreg;\n  \n  for (uVar3 \u003d 0; uVar3 \u003c 0x10; uVar3 \u003d uVar3 + 1) {\n    uVar2 \u003d 1 \u003c\u003c (uVar3 \u0026 0xff);\n    uVar4 \u003d uVar2 \u0026 GPIO_Init-\u003ePin;\n    uVar1 \u003d _DAT_40013c0c;\n    if (uVar2 \u003d\u003d uVar4) {\n      if ((GPIO_Init-\u003eMode \u003d\u003d 2) || (GPIO_Init-\u003eMode \u003d\u003d 0x12)) {\n        iVar9 \u003d (uVar3 \u0026 7) \u003c\u003c 2;\n        GPIOx-\u003eAFR[uVar3 \u003e\u003e 3] \u003d\n             GPIOx-\u003eAFR[uVar3 \u003e\u003e 3] \u0026 ~(0xf \u003c\u003c iVar9) | GPIO_Init-\u003eAlternate \u003c\u003c iVar9;\n      }\n      uVar8 \u003d uVar3 \u003c\u003c 1;\n      uVar1 \u003d ~(3 \u003c\u003c (uVar8 \u0026 0xff));\n      GPIOx-\u003eMODER \u003d GPIOx-\u003eMODER \u0026 uVar1 | (GPIO_Init-\u003eMode \u0026 3) \u003c\u003c (uVar8 \u0026 0xff);\n      uVar6 \u003d GPIO_Init-\u003eMode;\n      if (((uVar6 - 1 \u003c 2) || (uVar6 \u003d\u003d 0x11)) || (uVar6 \u003d\u003d 0x12)) {\n        GPIOx-\u003eOSPEEDR \u003d GPIOx-\u003eOSPEEDR \u0026 uVar1 | GPIO_Init-\u003eSpeed \u003c\u003c (uVar8 \u0026 0xff);\n        GPIOx-\u003eOTYPER \u003d\n             GPIOx-\u003eOTYPER \u0026 ~uVar2 | ((GPIO_Init-\u003eMode \u003c\u003c 0x1b) \u003e\u003e 0x1f) \u003c\u003c (uVar3 \u0026 0xff);\n      }\n      GPIOx-\u003ePUPDR \u003d uVar1 \u0026 GPIOx-\u003ePUPDR | GPIO_Init-\u003ePull \u003c\u003c (uVar8 \u0026 0xff);\n      uVar1 \u003d _DAT_40013c0c;\n      if ((GPIO_Init-\u003eMode \u0026 0x10000000) !\u003d 0) {\n        _DAT_40023844 \u003d _DAT_40023844 | 0x4000;\n        iVar9 \u003d (uVar3 \u0026 3) \u003c\u003c 2;\n        if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40020000) {\n          iVar7 \u003d 0;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40020400) {\n          iVar7 \u003d 1;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40020800) {\n          iVar7 \u003d 2;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40020c00) {\n          iVar7 \u003d 3;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40021000) {\n          iVar7 \u003d 4;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40021400) {\n          iVar7 \u003d 5;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40021800) {\n          iVar7 \u003d 6;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40021c00) {\n          iVar7 \u003d 7;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40022000) {\n          iVar7 \u003d 8;\n        }\n        else if (GPIOx \u003d\u003d (GPIO_TypeDef *)0x40022400) {\n          iVar7 \u003d 9;\n        }\n        else {\n          iVar7 \u003d 10;\n        }\n        *(uint *)(((uVar3 \u003e\u003e 2) + 2) * 4 + 0x40013800) \u003d\n             *(uint *)(((uVar3 \u003e\u003e 2) + 2) * 4 + 0x40013800) \u0026 ~(0xf \u003c\u003c iVar9) | iVar7 \u003c\u003c iVar9;\n        uVar1 \u003d ~uVar4;\n        uVar2 \u003d _DAT_40013c00 \u0026 uVar1;\n        if ((GPIO_Init-\u003eMode \u0026 0x10000) !\u003d 0) {\n          uVar2 \u003d uVar4 | _DAT_40013c00;\n        }\n        uVar8 \u003d uVar1 \u0026 _DAT_40013c04;\n        if ((GPIO_Init-\u003eMode \u0026 0x20000) !\u003d 0) {\n          uVar8 \u003d uVar4 | _DAT_40013c04;\n        }\n        uVar5 \u003d uVar1 \u0026 _DAT_40013c08;\n        if ((GPIO_Init-\u003eMode \u0026 0x100000) !\u003d 0) {\n          uVar5 \u003d uVar4 | _DAT_40013c08;\n        }\n        _DAT_40013c00 \u003d uVar2;\n        _DAT_40013c04 \u003d uVar8;\n        _DAT_40013c08 \u003d uVar5;\n        uVar1 \u003d uVar1 \u0026 _DAT_40013c0c;\n        if ((GPIO_Init-\u003eMode \u0026 0x200000) !\u003d 0) {\n          uVar1 \u003d uVar4 | _DAT_40013c0c;\n        }\n      }\n    }\n    _DAT_40013c0c \u003d uVar1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_init",
        "uart_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_WritePin": {
      "entrypoint": "0x08001198",
      "current_name": "HAL_GPIO_WritePin",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx,uint16_t GPIO_Pin,GPIO_PinState PinState)\n\n{\n  if (PinState \u003d\u003d GPIO_PIN_RESET) {\n    GPIOx-\u003eBSRR \u003d (uint)GPIO_Pin \u003c\u003c 0x10;\n    return;\n  }\n  GPIOx-\u003eBSRR \u003d (uint)GPIO_Pin;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_EXTI_IRQHandler": {
      "entrypoint": "0x080011a4",
      "current_name": "HAL_GPIO_EXTI_IRQHandler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)\n\n{\n  if ((_DAT_40013c14 \u0026 GPIO_Pin) !\u003d 0) {\n    _DAT_40013c14 \u003d (uint)GPIO_Pin;\n    HAL_GPIO_EXTI_Callback(GPIO_Pin);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "EXTI0_IRQHandler",
        "EXTI4_IRQHandler",
        "EXTI3_IRQHandler",
        "EXTI9_5_IRQHandler",
        "EXTI15_10_IRQHandler",
        "EXTI1_IRQHandler",
        "EXTI2_IRQHandler"
      ],
      "called": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Master_SB": {
      "entrypoint": "0x080011c0",
      "current_name": "I2C_Master_SB",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_Master_SB(I2C_HandleTypeDef *hi2c)\n\n{\n  if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n    if (hi2c-\u003eEventCount \u003d\u003d 0) {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xfe;\n    }\n    else {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff | 1;\n    }\n  }\n  else if ((hi2c-\u003eInit).AddressingMode \u003d\u003d 0x4000) {\n    if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xfe;\n    }\n    else {\n      hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff | 1;\n    }\n  }\n  else if (hi2c-\u003eEventCount \u003d\u003d 0) {\n    hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eDevaddress \u003c\u003c 0x10) \u003e\u003e 0x17 \u0026 6 | 0xf0;\n  }\n  else if (hi2c-\u003eEventCount \u003d\u003d 1) {\n    hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eDevaddress \u003c\u003c 0x10) \u003e\u003e 0x17 \u0026 6 | 0xf1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Master_ADD10": {
      "entrypoint": "0x0800124a",
      "current_name": "I2C_Master_ADD10",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_Master_ADD10(I2C_HandleTypeDef *hi2c)\n\n{\n  hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eDevaddress \u0026 0xff;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Master_ADDR": {
      "entrypoint": "0x08001256",
      "current_name": "I2C_Master_ADDR",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_Master_ADDR(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t CurrentXferOptions;\n  uint32_t uVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t Prev_State;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  \n  uVar1 \u003d hi2c-\u003eXferOptions;\n  if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) \u0026\u0026\n     ((hi2c-\u003eEventCount !\u003d 0 || (hi2c-\u003eMode !\u003d HAL_I2C_MODE_MEM)))) {\n    if ((hi2c-\u003eEventCount \u003d\u003d 0) \u0026\u0026 ((hi2c-\u003eInit).AddressingMode \u003d\u003d 0xc000)) {\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n      hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n    }\n    else {\n      if (hi2c-\u003eXferCount \u003d\u003d 0) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      }\n      else if (hi2c-\u003eXferCount \u003d\u003d 1) {\n        if (uVar1 \u003d\u003d 0xffff0000) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          pIVar2 \u003d hi2c-\u003eInstance;\n          if ((pIVar2-\u003eCR2 \u0026 0x800) \u003d\u003d 0) {\n            pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 0x200;\n          }\n          else {\n            pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 \u0026 0xfffffbff;\n          }\n        }\n        else if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (hi2c-\u003ePreviousState \u003d\u003d 0x12)) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n        }\n        else if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n        }\n      }\n      else if (hi2c-\u003eXferCount \u003d\u003d 2) {\n        if (hi2c-\u003eXferOptions \u003d\u003d 2) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x800;\n        }\n        pIVar2 \u003d hi2c-\u003eInstance;\n        if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n          pIVar2-\u003eCR2 \u003d pIVar2-\u003eCR2 | 0x1000;\n        }\n      }\n      else {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n        pIVar2 \u003d hi2c-\u003eInstance;\n        if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n          pIVar2-\u003eCR2 \u003d pIVar2-\u003eCR2 | 0x1000;\n        }\n      }\n      hi2c-\u003eEventCount \u003d 0;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_SlaveTransmit_BTF": {
      "entrypoint": "0x08001420",
      "current_name": "I2C_SlaveTransmit_BTF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_SlaveTransmit_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  byte *pbVar1;\n  \n  if (hi2c-\u003eXferCount !\u003d 0) {\n    pbVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d pbVar1 + 1;\n    hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar1;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_SlaveReceive_BTF": {
      "entrypoint": "0x08001440",
      "current_name": "I2C_SlaveReceive_BTF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_SlaveReceive_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c-\u003eXferCount !\u003d 0) {\n    puVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n    *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_Slave_Sequential_Transmit_IT": {
      "entrypoint": "0x08001460",
      "current_name": "HAL_I2C_Slave_Sequential_Transmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nHAL_I2C_Slave_Sequential_Transmit_IT\n          (I2C_HandleTypeDef *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (hi2c-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      hi2c-\u003eLock \u003d HAL_LOCKED;\n      pIVar2 \u003d hi2c-\u003eInstance;\n      if ((pIVar2-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n        pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 1;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY_TX_LISTEN;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_SLAVE;\n      HVar1 \u003d HAL_OK;\n      hi2c-\u003eErrorCode \u003d 0;\n      hi2c-\u003epBuffPtr \u003d pData;\n      hi2c-\u003eXferCount \u003d Size;\n      hi2c-\u003eXferOptions \u003d XferOptions;\n      hi2c-\u003eXferSize \u003d hi2c-\u003eXferCount;\n      hi2c-\u003eLock \u003d HAL_UNLOCKED;\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_AddrCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_Slave_Sequential_Receive_IT": {
      "entrypoint": "0x080014ec",
      "current_name": "HAL_I2C_Slave_Sequential_Receive_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nHAL_I2C_Slave_Sequential_Receive_IT\n          (I2C_HandleTypeDef *hi2c,uint8_t *pData,uint16_t Size,uint32_t XferOptions)\n\n{\n  HAL_StatusTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t tmpreg;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (hi2c-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      hi2c-\u003eLock \u003d HAL_LOCKED;\n      pIVar2 \u003d hi2c-\u003eInstance;\n      if ((pIVar2-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n        pIVar2-\u003eCR1 \u003d pIVar2-\u003eCR1 | 1;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_BUSY_RX_LISTEN;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_SLAVE;\n      HVar1 \u003d HAL_OK;\n      hi2c-\u003eErrorCode \u003d 0;\n      hi2c-\u003epBuffPtr \u003d pData;\n      hi2c-\u003eXferCount \u003d Size;\n      hi2c-\u003eXferOptions \u003d XferOptions;\n      hi2c-\u003eXferSize \u003d hi2c-\u003eXferCount;\n      hi2c-\u003eLock \u003d HAL_UNLOCKED;\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x700;\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_AddrCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_EnableListen_IT": {
      "entrypoint": "0x08001578",
      "current_name": "HAL_I2C_EnableListen_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_I2C_EnableListen_IT(I2C_HandleTypeDef *hi2c)\n\n{\n  I2C_TypeDef *pIVar1;\n  \n  if (hi2c-\u003eState !\u003d HAL_I2C_STATE_READY) {\n    return HAL_BUSY;\n  }\n  hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n  pIVar1 \u003d hi2c-\u003eInstance;\n  if ((pIVar1-\u003eCR1 \u0026 1) \u003d\u003d 0) {\n    pIVar1-\u003eCR1 \u003d pIVar1-\u003eCR1 | 1;\n  }\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x400;\n  hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 | 0x300;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_ErrorCallback",
        "HAL_I2C_ListenCpltCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MasterTxCpltCallback": {
      "entrypoint": "0x080015b6",
      "current_name": "HAL_I2C_MasterTxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MasterTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterTransmit_BTF",
        "I2C_MasterTransmit_TXE"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MasterRxCpltCallback": {
      "entrypoint": "0x080015b8",
      "current_name": "HAL_I2C_MasterRxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MasterRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterReceive_BTF",
        "I2C_MasterReceive_RXNE"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_SlaveTxCpltCallback": {
      "entrypoint": "0x080015ba",
      "current_name": "HAL_I2C_SlaveTxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_SlaveTransmit_TXE",
        "I2C_Slave_AF"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_SlaveTransmit_TXE": {
      "entrypoint": "0x080015bc",
      "current_name": "I2C_SlaveTransmit_TXE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_SlaveTransmit_TXE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  byte *pbVar2;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    pbVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n    hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    if ((hi2c-\u003eXferCount \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      hi2c-\u003ePreviousState \u003d 0x21;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveTxCpltCallback(hi2c);\n    }\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveTxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_SlaveRxCpltCallback": {
      "entrypoint": "0x0800160c",
      "current_name": "HAL_I2C_SlaveRxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_SlaveReceive_RXNE",
        "I2C_Slave_STOPF"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_SlaveReceive_RXNE": {
      "entrypoint": "0x0800160e",
      "current_name": "I2C_SlaveReceive_RXNE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_SlaveReceive_RXNE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  uint8_t *puVar2;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    puVar2 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n    *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    if ((hi2c-\u003eXferCount \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      hi2c-\u003ePreviousState \u003d 0x22;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveRxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Slave_ADDR": {
      "entrypoint": "0x0800165a",
      "current_name": "I2C_Slave_ADDR",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_Slave_ADDR(I2C_HandleTypeDef *hi2c)\n\n{\n  uint16_t AddrMatchCode;\n  \n  if ((hi2c-\u003eInstance-\u003eSR2 \u0026 0x80) \u003d\u003d 0) {\n    AddrMatchCode \u003d *(uint16_t *)\u0026(hi2c-\u003eInit).OwnAddress1;\n  }\n  else {\n    AddrMatchCode \u003d *(uint16_t *)\u0026(hi2c-\u003eInit).OwnAddress2;\n  }\n  HAL_I2C_AddrCallback(hi2c,(hi2c-\u003eInstance-\u003eSR2 \u0026 4) \u003d\u003d 0,AddrMatchCode);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_AddrCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Slave_AF": {
      "entrypoint": "0x08001684",
      "current_name": "I2C_Slave_AF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_Slave_AF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t CurrentXferOptions;\n  uint32_t CurrentState;\n  \n  if (((hi2c-\u003eXferOptions \u003d\u003d 4) || (hi2c-\u003eXferOptions \u003d\u003d 8)) \u0026\u0026\n     (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN)) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  else if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003ePreviousState \u003d 0x21;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    HAL_I2C_SlaveTxCpltCallback(hi2c);\n  }\n  else {\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "called": [
        "HAL_I2C_SlaveTxCpltCallback",
        "HAL_I2C_ListenCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MemTxCpltCallback": {
      "entrypoint": "0x08001718",
      "current_name": "HAL_I2C_MemTxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MemTxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterTransmit_BTF",
        "I2C_MasterTransmit_TXE"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_MasterTransmit_TXE": {
      "entrypoint": "0x0800171a",
      "current_name": "I2C_MasterTransmit_TXE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_MasterTransmit_TXE(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  uint32_t CurrentState;\n  byte *pbVar2;\n  uint32_t CurrentXferOptions;\n  uint32_t uVar3;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  uVar3 \u003d hi2c-\u003eXferOptions;\n  if ((hi2c-\u003eXferSize \u003d\u003d 0) \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX)) {\n    if ((uVar3 \u003d\u003d 4) || ((uVar3 \u003d\u003d 8 || (uVar3 \u003d\u003d 0xffff0000)))) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        HAL_I2C_MemTxCpltCallback(hi2c);\n      }\n      else {\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n      hi2c-\u003ePreviousState \u003d 0x11;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      HAL_I2C_MasterTxCpltCallback(hi2c);\n    }\n  }\n  else if ((HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX) ||\n          ((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM \u0026\u0026 (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX)))) {\n    if (hi2c-\u003eXferCount \u003d\u003d 0) {\n      hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n    }\n    else if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n      if (hi2c-\u003eEventCount \u003d\u003d 0) {\n        if (hi2c-\u003eMemaddSize \u003d\u003d 1) {\n          hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eMemaddress \u0026 0xff;\n          hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 2;\n        }\n        else {\n          hi2c-\u003eInstance-\u003eDR \u003d (hi2c-\u003eMemaddress \u003c\u003c 0x10) \u003e\u003e 0x18;\n          hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n        }\n      }\n      else if (hi2c-\u003eEventCount \u003d\u003d 1) {\n        hi2c-\u003eInstance-\u003eDR \u003d hi2c-\u003eMemaddress \u0026 0xff;\n        hi2c-\u003eEventCount \u003d hi2c-\u003eEventCount + 1;\n      }\n      else if (hi2c-\u003eEventCount \u003d\u003d 2) {\n        if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) {\n          hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n        }\n        else if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n          pbVar2 \u003d hi2c-\u003epBuffPtr;\n          hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n          hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n          hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n        }\n      }\n    }\n    else {\n      pbVar2 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n      hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MasterTxCpltCallback",
        "HAL_I2C_MemTxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_MasterTransmit_BTF": {
      "entrypoint": "0x08001864",
      "current_name": "I2C_MasterTransmit_BTF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_MasterTransmit_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t uVar1;\n  uint32_t CurrentXferOptions;\n  byte *pbVar2;\n  \n  uVar1 \u003d hi2c-\u003eXferOptions;\n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_TX) {\n    if (hi2c-\u003eXferCount \u003d\u003d 0) {\n      if (((uVar1 \u003d\u003d 4) || (uVar1 \u003d\u003d 8)) || (uVar1 \u003d\u003d 0xffff0000)) {\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n        hi2c-\u003ePreviousState \u003d 0;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MemTxCpltCallback(hi2c);\n        }\n        else {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterTxCpltCallback(hi2c);\n        }\n      }\n      else {\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        hi2c-\u003ePreviousState \u003d 0x11;\n        hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        HAL_I2C_MasterTxCpltCallback(hi2c);\n      }\n    }\n    else {\n      pbVar2 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d pbVar2 + 1;\n      hi2c-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MasterTxCpltCallback",
        "HAL_I2C_MemTxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_MemRxCpltCallback": {
      "entrypoint": "0x08001902",
      "current_name": "HAL_I2C_MemRxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_MasterReceive_BTF",
        "I2C_MasterReceive_RXNE"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_MasterReceive_RXNE": {
      "entrypoint": "0x08001904",
      "current_name": "I2C_MasterReceive_RXNE",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_MasterReceive_RXNE(I2C_HandleTypeDef *hi2c)\n\n{\n  uint8_t *puVar1;\n  \n  if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) {\n    if (hi2c-\u003eXferCount \u003c 4) {\n      if (hi2c-\u003eXferCount \u003c 2) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n        puVar1 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n        *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n        hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        hi2c-\u003ePreviousState \u003d 0;\n        if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MemRxCpltCallback(hi2c);\n        }\n        else {\n          hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n          HAL_I2C_MasterRxCpltCallback(hi2c);\n        }\n      }\n    }\n    else {\n      puVar1 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n      *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n      if (hi2c-\u003eXferCount \u003d\u003d 3) {\n        hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n      }\n    }\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MasterRxCpltCallback",
        "HAL_I2C_MemRxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_MasterReceive_BTF": {
      "entrypoint": "0x080019a0",
      "current_name": "I2C_MasterReceive_BTF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_MasterReceive_BTF(I2C_HandleTypeDef *hi2c)\n\n{\n  uint32_t CurrentXferOptions;\n  uint8_t *puVar1;\n  \n  if (hi2c-\u003eXferCount \u003d\u003d 4) {\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n    puVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n    *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  else if (hi2c-\u003eXferCount \u003d\u003d 3) {\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffbff;\n    hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n    puVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n    *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  else if (hi2c-\u003eXferCount \u003d\u003d 2) {\n    if (hi2c-\u003eXferOptions - 1 \u003c 2) {\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x100;\n    }\n    else {\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n    }\n    puVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n    *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    puVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n    *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffffcff;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003ePreviousState \u003d 0;\n    if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM) {\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_MemRxCpltCallback(hi2c);\n    }\n    else {\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_MasterRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    puVar1 \u003d hi2c-\u003epBuffPtr;\n    hi2c-\u003epBuffPtr \u003d puVar1 + 1;\n    *puVar1 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n    hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "HAL_I2C_MasterRxCpltCallback",
        "HAL_I2C_MemRxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_AbortCpltCallback": {
      "entrypoint": "0x08001aac",
      "current_name": "HAL_I2C_AbortCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_AbortCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_ITError",
        "I2C_DMAAbort"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_ITError": {
      "entrypoint": "0x08001ab0",
      "current_name": "I2C_ITError",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C_ITError(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint8_t *puVar2;\n  I2C_TypeDef *pIVar3;\n  \n  if (hi2c-\u003eState - 0x29 \u003c 2) {\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_LISTEN;\n  }\n  else {\n    if ((hi2c-\u003eState !\u003d HAL_I2C_STATE_ABORT) \u0026\u0026 ((hi2c-\u003eInstance-\u003eCR2 \u0026 0x800) \u003d\u003d 0)) {\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    }\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n  }\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffff7ff;\n  pIVar3 \u003d hi2c-\u003eInstance;\n  if ((pIVar3-\u003eCR2 \u0026 0x800) \u003d\u003d 0) {\n    if (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_ABORT) {\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eErrorCode \u003d 0;\n      if ((pIVar3-\u003eSR1 \u0026 0x40) !\u003d 0) {\n        puVar2 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n        *puVar2 \u003d (uint8_t)pIVar3-\u003eDR;\n      }\n      hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n      HAL_I2C_AbortCpltCallback(hi2c);\n    }\n    else {\n      if ((pIVar3-\u003eSR1 \u0026 0x40) !\u003d 0) {\n        puVar2 \u003d hi2c-\u003epBuffPtr;\n        hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n        *puVar2 \u003d (uint8_t)pIVar3-\u003eDR;\n      }\n      HAL_I2C_ErrorCallback(hi2c);\n    }\n  }\n  else {\n    pIVar3-\u003eCR2 \u003d pIVar3-\u003eCR2 \u0026 0xfffff7ff;\n    if (hi2c-\u003ehdmatx-\u003eState \u003d\u003d HAL_DMA_STATE_READY) {\n      hi2c-\u003ehdmarx-\u003eXferAbortCallback \u003d I2C_DMAAbort + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(hi2c-\u003ehdmarx);\n      if (HVar1 !\u003d HAL_OK) {\n        if ((hi2c-\u003eInstance-\u003eSR1 \u0026 0x40) !\u003d 0) {\n          puVar2 \u003d hi2c-\u003epBuffPtr;\n          hi2c-\u003epBuffPtr \u003d puVar2 + 1;\n          *puVar2 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n        }\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        (*hi2c-\u003ehdmarx-\u003eXferAbortCallback)(hi2c-\u003ehdmarx);\n      }\n    }\n    else {\n      hi2c-\u003ehdmatx-\u003eXferAbortCallback \u003d I2C_DMAAbort + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(hi2c-\u003ehdmatx);\n      if (HVar1 !\u003d HAL_OK) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n        hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n        (*hi2c-\u003ehdmatx-\u003eXferAbortCallback)(hi2c-\u003ehdmatx);\n      }\n    }\n  }\n  if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_LISTEN) \u0026\u0026 ((hi2c-\u003eErrorCode \u0026 4) !\u003d 0)) {\n    hi2c-\u003eXferOptions \u003d 0xffff0000;\n    hi2c-\u003ePreviousState \u003d 0;\n    hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    HAL_I2C_ListenCpltCallback(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_Slave_STOPF",
        "HAL_I2C_ER_IRQHandler"
      ],
      "called": [
        "HAL_I2C_ErrorCallback",
        "HAL_I2C_ListenCpltCallback",
        "HAL_DMA_Abort_IT",
        "HAL_I2C_AbortCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_Slave_STOPF": {
      "entrypoint": "0x08001bfc",
      "current_name": "I2C_Slave_STOPF",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef I2C_Slave_STOPF(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint8_t *puVar3;\n  uint32_t CurrentState;\n  uint32_t tmpreg;\n  \n  HVar1 \u003d hi2c-\u003eState;\n  hi2c-\u003eInstance-\u003eCR2 \u003d hi2c-\u003eInstance-\u003eCR2 \u0026 0xfffff8ff;\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 1;\n  hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n  pIVar2 \u003d hi2c-\u003eInstance;\n  if ((pIVar2-\u003eCR2 \u0026 0x800) !\u003d 0) {\n    if ((hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX) || (hi2c-\u003eState \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) {\n      hi2c-\u003eXferCount \u003d (uint16_t)hi2c-\u003ehdmarx-\u003eInstance-\u003eNDTR;\n    }\n    else {\n      hi2c-\u003eXferCount \u003d (uint16_t)hi2c-\u003ehdmatx-\u003eInstance-\u003eNDTR;\n    }\n  }\n  if (hi2c-\u003eXferCount !\u003d 0) {\n    if ((pIVar2-\u003eSR1 \u0026 4) !\u003d 0) {\n      puVar3 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar3 + 1;\n      *puVar3 \u003d (uint8_t)pIVar2-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n    if ((hi2c-\u003eInstance-\u003eSR1 \u0026 0x40) !\u003d 0) {\n      puVar3 \u003d hi2c-\u003epBuffPtr;\n      hi2c-\u003epBuffPtr \u003d puVar3 + 1;\n      *puVar3 \u003d (uint8_t)hi2c-\u003eInstance-\u003eDR;\n      hi2c-\u003eXferCount \u003d hi2c-\u003eXferCount - 1;\n    }\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 4;\n  }\n  if (hi2c-\u003eErrorCode \u003d\u003d 0) {\n    if (((HVar1 \u003d\u003d HAL_I2C_STATE_LISTEN) || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX_LISTEN)) ||\n       (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) {\n      hi2c-\u003eXferOptions \u003d 0xffff0000;\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_ListenCpltCallback(hi2c);\n    }\n    else if ((hi2c-\u003ePreviousState \u003d\u003d 0x22) || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_RX)) {\n      hi2c-\u003ePreviousState \u003d 0;\n      hi2c-\u003eState \u003d HAL_I2C_STATE_READY;\n      hi2c-\u003eMode \u003d HAL_I2C_MODE_NONE;\n      HAL_I2C_SlaveRxCpltCallback(hi2c);\n    }\n  }\n  else {\n    I2C_ITError(hi2c);\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "called": [
        "I2C_ITError",
        "HAL_I2C_SlaveRxCpltCallback",
        "HAL_I2C_ListenCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_EV_IRQHandler": {
      "entrypoint": "0x08001d00",
      "current_name": "HAL_I2C_EV_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_EV_IRQHandler(I2C_HandleTypeDef *hi2c)\n\n{\n  I2C_TypeDef *pIVar1;\n  uint32_t CurrentMode;\n  uint uVar2;\n  uint32_t sr1itflags;\n  uint uVar3;\n  uint32_t itsources;\n  uint uVar4;\n  uint32_t sr2itflags;\n  \n  pIVar1 \u003d hi2c-\u003eInstance;\n  uVar4 \u003d pIVar1-\u003eSR2;\n  uVar2 \u003d pIVar1-\u003eSR1;\n  uVar3 \u003d pIVar1-\u003eCR2;\n  if ((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MASTER) || (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MEM)) {\n    if (((uVar2 \u0026 0x10001) \u003d\u003d 0) || ((uVar3 \u0026 0x200) \u003d\u003d 0)) {\n      if (((uVar2 \u0026 0x10008) \u003d\u003d 0) || ((uVar3 \u0026 0x200) \u003d\u003d 0)) {\n        if (((uVar2 \u0026 0x10002) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n          I2C_Master_ADDR(hi2c);\n        }\n      }\n      else {\n        I2C_Master_ADD10(hi2c);\n      }\n    }\n    else {\n      I2C_Master_SB(hi2c);\n    }\n    if ((uVar4 \u0026 0x100004) \u003d\u003d 0) {\n      if ((((uVar2 \u0026 0x10040) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_MasterReceive_RXNE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_MasterReceive_BTF(hi2c);\n        return;\n      }\n    }\n    else {\n      if ((((uVar2 \u0026 0x10080) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_MasterTransmit_TXE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_MasterTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  else {\n    if (((uVar2 \u0026 0x10002) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n      I2C_Slave_ADDR(hi2c);\n      return;\n    }\n    if (((uVar2 \u0026 0x10010) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n      I2C_Slave_STOPF(hi2c);\n      return;\n    }\n    if ((uVar4 \u0026 0x100004) \u003d\u003d 0) {\n      if ((((uVar2 \u0026 0x10040) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_SlaveReceive_RXNE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_SlaveReceive_BTF(hi2c);\n      }\n    }\n    else {\n      if ((((uVar2 \u0026 0x10080) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x400) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x10004) \u003d\u003d 0)) {\n        I2C_SlaveTransmit_TXE(hi2c);\n        return;\n      }\n      if (((uVar2 \u0026 0x10004) !\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x200) !\u003d 0)) {\n        I2C_SlaveTransmit_BTF(hi2c);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C2_EV_IRQHandler",
        "I2C1_EV_IRQHandler",
        "I2C3_EV_IRQHandler"
      ],
      "called": [
        "I2C_MasterReceive_BTF",
        "I2C_SlaveTransmit_TXE",
        "I2C_MasterTransmit_BTF",
        "I2C_SlaveReceive_RXNE",
        "I2C_Master_SB",
        "I2C_MasterTransmit_TXE",
        "I2C_Master_ADD10",
        "I2C_Slave_STOPF",
        "I2C_SlaveTransmit_BTF",
        "I2C_Slave_ADDR",
        "I2C_Master_ADDR",
        "I2C_MasterReceive_RXNE",
        "I2C_SlaveReceive_BTF"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_ER_IRQHandler": {
      "entrypoint": "0x08001e68",
      "current_name": "HAL_I2C_ER_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_ER_IRQHandler(I2C_HandleTypeDef *hi2c)\n\n{\n  HAL_I2C_StateTypeDef HVar1;\n  I2C_TypeDef *pIVar2;\n  uint32_t sr1itflags;\n  uint uVar3;\n  uint32_t itsources;\n  uint uVar4;\n  \n  pIVar2 \u003d hi2c-\u003eInstance;\n  uVar3 \u003d pIVar2-\u003eSR1;\n  uVar4 \u003d pIVar2-\u003eCR2;\n  if (((uVar3 \u0026 0x10100) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 1;\n    pIVar2-\u003eSR1 \u003d 0xfffffeff;\n  }\n  if (((uVar3 \u0026 0x10200) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 2;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffdff;\n  }\n  if (((uVar3 \u0026 0x10400) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    HVar1 \u003d hi2c-\u003eState;\n    if (((hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_SLAVE) \u0026\u0026 (hi2c-\u003eXferCount \u003d\u003d 0)) \u0026\u0026\n       (((HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX || (HVar1 \u003d\u003d HAL_I2C_STATE_BUSY_TX_LISTEN)) ||\n        ((HVar1 \u003d\u003d HAL_I2C_STATE_LISTEN \u0026\u0026 (hi2c-\u003ePreviousState \u003d\u003d 0x21)))))) {\n      I2C_Slave_AF(hi2c);\n    }\n    else {\n      hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 4;\n      if (hi2c-\u003eMode \u003d\u003d HAL_I2C_MODE_MASTER) {\n        hi2c-\u003eInstance-\u003eCR1 \u003d hi2c-\u003eInstance-\u003eCR1 | 0x200;\n      }\n      hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffffbff;\n    }\n  }\n  if (((uVar3 \u0026 0x10800) !\u003d 0) \u0026\u0026 ((uVar4 \u0026 0x100) !\u003d 0)) {\n    hi2c-\u003eErrorCode \u003d hi2c-\u003eErrorCode | 8;\n    hi2c-\u003eInstance-\u003eSR1 \u003d 0xfffff7ff;\n  }\n  if (hi2c-\u003eErrorCode !\u003d 0) {\n    I2C_ITError(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C3_ER_IRQHandler",
        "I2C2_ER_IRQHandler",
        "I2C1_ER_IRQHandler"
      ],
      "called": [
        "I2C_Slave_AF",
        "I2C_ITError"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C_DMAAbort": {
      "entrypoint": "0x08001f3c",
      "current_name": "I2C_DMAAbort",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C_DMAAbort(DMA_HandleTypeDef *hdma)\n\n{\n  I2C_HandleTypeDef *hi2c_00;\n  I2C_HandleTypeDef *hi2c;\n  \n  hi2c_00 \u003d (I2C_HandleTypeDef *)hdma-\u003eParent;\n  hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffbff;\n  hi2c_00-\u003eXferCount \u003d 0;\n  hi2c_00-\u003ehdmatx-\u003eXferAbortCallback \u003d (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  hi2c_00-\u003ehdmarx-\u003eXferAbortCallback \u003d (_func_void___DMA_HandleTypeDef_ptr *)0x0;\n  if (hi2c_00-\u003eState !\u003d HAL_I2C_STATE_ABORT) {\n    hi2c_00-\u003eState \u003d HAL_I2C_STATE_READY;\n    hi2c_00-\u003eMode \u003d HAL_I2C_MODE_NONE;\n    hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n    HAL_I2C_ErrorCallback(hi2c_00);\n    return;\n  }\n  hi2c_00-\u003eState \u003d HAL_I2C_STATE_READY;\n  hi2c_00-\u003eMode \u003d HAL_I2C_MODE_NONE;\n  hi2c_00-\u003eErrorCode \u003d 0;\n  hi2c_00-\u003eInstance-\u003eCR1 \u003d hi2c_00-\u003eInstance-\u003eCR1 \u0026 0xfffffffe;\n  HAL_I2C_AbortCpltCallback(hi2c_00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ErrorCallback",
        "HAL_I2C_AbortCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_PWREx_EnableOverDrive": {
      "entrypoint": "0x08001f9c",
      "current_name": "HAL_PWREx_EnableOverDrive",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t tmpreg;\n  \n  _DAT_40023840 \u003d _DAT_40023840 | 0x10000000;\n  _DAT_420e0040 \u003d 1;\n  uVar1 \u003d HAL_GetTick();\n  do {\n    if ((_DAT_40007004 \u0026 0x10000) !\u003d 0) {\n      _DAT_420e0044 \u003d 1;\n      uVar1 \u003d HAL_GetTick();\n      do {\n        if ((_DAT_40007004 \u0026 0x20000) !\u003d 0) {\n          return HAL_OK;\n        }\n        uVar2 \u003d HAL_GetTick();\n      } while (uVar2 - uVar1 \u003c 0x3e9);\n      return HAL_TIMEOUT;\n    }\n    uVar2 \u003d HAL_GetTick();\n  } while (uVar2 - uVar1 \u003c 0x3e9);\n  return HAL_TIMEOUT;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_OscConfig": {
      "entrypoint": "0x0800201c",
      "current_name": "HAL_RCC_OscConfig",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef_conflict *RCC_OscInitStruct)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint32_t tickstart;\n  bool bVar4;\n  uint32_t tmpreg;\n  \n  if (RCC_OscInitStruct \u003d\u003d (RCC_OscInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 1) !\u003d 0) {\n    if (((_DAT_40023808 \u0026 0xc) \u003d\u003d 4) ||\n       (((_DAT_40023808 \u0026 0xc) \u003d\u003d 8 \u0026\u0026 ((_DAT_40023804 \u0026 0x400000) !\u003d 0)))) {\n      if (((_DAT_40023800 \u0026 0x20000) !\u003d 0) \u0026\u0026 (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 0)) {\n        return HAL_ERROR;\n      }\n    }\n    else {\n      if (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 0x10000) {\n        _DAT_40023800 \u003d _DAT_40023800 | 0x10000;\n      }\n      else if (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 0x50000) {\n        _DAT_40023800 \u003d _DAT_40023800 | 0x50000;\n      }\n      else {\n        _DAT_40023800 \u003d _DAT_40023800 \u0026 0xfffaffff;\n      }\n      if (RCC_OscInitStruct-\u003eHSEState \u003d\u003d 0) {\n        uVar2 \u003d HAL_GetTick();\n        while ((_DAT_40023800 \u0026 0x20000) !\u003d 0) {\n          uVar3 \u003d HAL_GetTick();\n          if (100 \u003c uVar3 - uVar2) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n      else {\n        uVar2 \u003d HAL_GetTick();\n        while ((_DAT_40023800 \u0026 0x20000) \u003d\u003d 0) {\n          uVar3 \u003d HAL_GetTick();\n          if (100 \u003c uVar3 - uVar2) {\n            return HAL_TIMEOUT;\n          }\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 2) !\u003d 0) {\n    if (((_DAT_40023808 \u0026 0xc) \u003d\u003d 0) ||\n       (((_DAT_40023808 \u0026 0xc) \u003d\u003d 8 \u0026\u0026 ((_DAT_40023804 \u0026 0x400000) \u003d\u003d 0)))) {\n      if (((_DAT_40023800 \u0026 2) !\u003d 0) \u0026\u0026 (RCC_OscInitStruct-\u003eHSIState !\u003d 1)) {\n        return HAL_ERROR;\n      }\n      _DAT_40023800 \u003d _DAT_40023800 \u0026 0xffffff07 | RCC_OscInitStruct-\u003eHSICalibrationValue \u003c\u003c 3;\n    }\n    else if (RCC_OscInitStruct-\u003eHSIState \u003d\u003d 0) {\n      _DAT_42470000 \u003d 0;\n      uVar2 \u003d HAL_GetTick();\n      while ((_DAT_40023800 \u0026 2) !\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        if (2 \u003c uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470000 \u003d 1;\n      uVar2 \u003d HAL_GetTick();\n      while ((_DAT_40023800 \u0026 2) \u003d\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        if (2 \u003c uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n      _DAT_40023800 \u003d _DAT_40023800 \u0026 0xffffff07 | RCC_OscInitStruct-\u003eHSICalibrationValue \u003c\u003c 3;\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 8) !\u003d 0) {\n    if (RCC_OscInitStruct-\u003eLSIState \u003d\u003d 0) {\n      _DAT_42470e80 \u003d 0;\n      uVar2 \u003d HAL_GetTick();\n      while ((_DAT_40023874 \u0026 2) !\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        if (2 \u003c uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      _DAT_42470e80 \u003d 1;\n      uVar2 \u003d HAL_GetTick();\n      while ((_DAT_40023874 \u0026 2) \u003d\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        if (2 \u003c uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n  }\n  if ((RCC_OscInitStruct-\u003eOscillatorType \u0026 4) !\u003d 0) {\n    bVar4 \u003d (_DAT_40023840 \u0026 0x10000000) \u003d\u003d 0;\n    if (bVar4) {\n      _DAT_40023840 \u003d _DAT_40023840 | 0x10000000;\n    }\n    if ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n      _DAT_40007000 \u003d _DAT_40007000 | 0x100;\n      uVar2 \u003d HAL_GetTick();\n      while ((_DAT_40007000 \u0026 0x100) \u003d\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        if (2 \u003c uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (RCC_OscInitStruct-\u003eLSEState \u003d\u003d 1) {\n      _DAT_40023870 \u003d _DAT_40023870 | 1;\n    }\n    else if (RCC_OscInitStruct-\u003eLSEState \u003d\u003d 5) {\n      _DAT_40023870 \u003d _DAT_40023870 | 5;\n    }\n    else {\n      _DAT_40023870 \u003d _DAT_40023870 \u0026 0xfffffffa;\n    }\n    if (RCC_OscInitStruct-\u003eLSEState \u003d\u003d 0) {\n      uVar2 \u003d HAL_GetTick();\n      while ((_DAT_40023870 \u0026 2) !\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        if (5000 \u003c uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    else {\n      uVar2 \u003d HAL_GetTick();\n      while ((_DAT_40023870 \u0026 2) \u003d\u003d 0) {\n        uVar3 \u003d HAL_GetTick();\n        if (5000 \u003c uVar3 - uVar2) {\n          return HAL_TIMEOUT;\n        }\n      }\n    }\n    if (bVar4) {\n      _DAT_40023840 \u003d _DAT_40023840 \u0026 0xefffffff;\n    }\n  }\n  uVar2 \u003d (RCC_OscInitStruct-\u003ePLL).PLLState;\n  if (uVar2 \u003d\u003d 0) {\n    HVar1 \u003d HAL_OK;\n  }\n  else if ((_DAT_40023808 \u0026 0xc) \u003d\u003d 8) {\n    HVar1 \u003d HAL_ERROR;\n  }\n  else if (uVar2 \u003d\u003d 2) {\n    _DAT_42470060 \u003d 0;\n    uVar2 \u003d HAL_GetTick();\n    do {\n      if ((_DAT_40023800 \u0026 0x2000000) \u003d\u003d 0) {\n        _DAT_40023804 \u003d\n             (RCC_OscInitStruct-\u003ePLL).PLLSource | (RCC_OscInitStruct-\u003ePLL).PLLM |\n             (RCC_OscInitStruct-\u003ePLL).PLLN \u003c\u003c 6 |\n             (((RCC_OscInitStruct-\u003ePLL).PLLP \u003e\u003e 1) - 1) * 0x10000 |\n             (RCC_OscInitStruct-\u003ePLL).PLLQ \u003c\u003c 0x18;\n        _DAT_42470060 \u003d 1;\n        uVar2 \u003d HAL_GetTick();\n        do {\n          if ((_DAT_40023800 \u0026 0x2000000) !\u003d 0) {\n            return HAL_OK;\n          }\n          uVar3 \u003d HAL_GetTick();\n        } while (uVar3 - uVar2 \u003c 3);\n        return HAL_TIMEOUT;\n      }\n      uVar3 \u003d HAL_GetTick();\n    } while (uVar3 - uVar2 \u003c 3);\n    HVar1 \u003d HAL_TIMEOUT;\n  }\n  else {\n    _DAT_42470060 \u003d 0;\n    uVar2 \u003d HAL_GetTick();\n    do {\n      if ((_DAT_40023800 \u0026 0x2000000) \u003d\u003d 0) {\n        return HAL_OK;\n      }\n      uVar3 \u003d HAL_GetTick();\n    } while (uVar3 - uVar2 \u003c 3);\n    HVar1 \u003d HAL_TIMEOUT;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetSysClockFreq": {
      "entrypoint": "0x080023b4",
      "current_name": "HAL_RCC_GetSysClockFreq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetSysClockFreq(void)\n\n{\n  uint uVar1;\n  \n  if ((_DAT_40023808 \u0026 0xc) \u003d\u003d 4) {\n    return 8000000;\n  }\n  if ((_DAT_40023808 \u0026 0xc) !\u003d 8) {\n    return 16000000;\n  }\n  if ((_DAT_40023804 \u0026 0x400000) \u003d\u003d 0) {\n    uVar1 \u003d (_DAT_40023804 \u003c\u003c 0x11) \u003e\u003e 0x17;\n    uVar1 \u003d __aeabi_uldivmod(uVar1 * 16000000,\n                             (((uint)(uVar1 * 0x20 \u003c uVar1) * -0x3f -\n                              (uint)(uVar1 * 0x7c0 \u003c uVar1 * 0x1f)) * 8 +\n                             (uint)CARRY4(uVar1 * 0x3d08,uVar1)) * 0x400 | uVar1 * 0x3d09 \u003e\u003e 0x16,\n                             _DAT_40023804 \u0026 0x3f,0);\n  }\n  else {\n    uVar1 \u003d (_DAT_40023804 \u003c\u003c 0x11) \u003e\u003e 0x17;\n    uVar1 \u003d __aeabi_uldivmod(uVar1 * 8000000,\n                             (((uint)(uVar1 * 0x20 \u003c uVar1) * -0x3f -\n                              (uint)(uVar1 * 0x7c0 \u003c uVar1 * 0x1f)) * 8 +\n                             (uint)CARRY4(uVar1 * 0x3d08,uVar1)) * 0x200,_DAT_40023804 \u0026 0x3f,0);\n  }\n  return uVar1 / ((((_DAT_40023804 \u003c\u003c 0xe) \u003e\u003e 0x1e) + 1) * 2);\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_ClockConfig"
      ],
      "called": [
        "__aeabi_uldivmod"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_ClockConfig": {
      "entrypoint": "0x08002488",
      "current_name": "HAL_RCC_ClockConfig",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nHAL_RCC_ClockConfig(RCC_ClkInitTypeDef_conflict *RCC_ClkInitStruct,uint32_t FLatency)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint uVar3;\n  uint32_t tickstart;\n  \n  if (RCC_ClkInitStruct \u003d\u003d (RCC_ClkInitTypeDef_conflict *)0x0) {\n    return HAL_ERROR;\n  }\n  if (((_DAT_40023c00 \u0026 0xf) \u003c FLatency) \u0026\u0026\n     (_DAT_40023c00 \u003d CONCAT31(DAT_40023c00_1,(char)FLatency), FLatency !\u003d (FLatency \u0026 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 2) !\u003d 0) {\n    if ((RCC_ClkInitStruct-\u003eClockType \u0026 4) !\u003d 0) {\n      _DAT_40023808 \u003d _DAT_40023808 | 0x1c00;\n    }\n    if ((RCC_ClkInitStruct-\u003eClockType \u0026 8) !\u003d 0) {\n      _DAT_40023808 \u003d _DAT_40023808 | 0xe000;\n    }\n    _DAT_40023808 \u003d _DAT_40023808 \u0026 0xffffff0f | RCC_ClkInitStruct-\u003eAHBCLKDivider;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 1) !\u003d 0) {\n    uVar3 \u003d RCC_ClkInitStruct-\u003eSYSCLKSource;\n    if (uVar3 \u003d\u003d 1) {\n      if ((_DAT_40023800 \u0026 0x20000) \u003d\u003d 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if (uVar3 - 2 \u003c 2) {\n      if ((_DAT_40023800 \u0026 0x2000000) \u003d\u003d 0) {\n        return HAL_ERROR;\n      }\n    }\n    else if ((_DAT_40023800 \u0026 2) \u003d\u003d 0) {\n      return HAL_ERROR;\n    }\n    _DAT_40023808 \u003d uVar3 | _DAT_40023808 \u0026 0xfffffffc;\n    uVar1 \u003d HAL_GetTick();\n    while ((_DAT_40023808 \u0026 0xc) !\u003d RCC_ClkInitStruct-\u003eSYSCLKSource * 4) {\n      uVar2 \u003d HAL_GetTick();\n      if (5000 \u003c uVar2 - uVar1) {\n        return HAL_TIMEOUT;\n      }\n    }\n  }\n  if ((FLatency \u003c (_DAT_40023c00 \u0026 0xf)) \u0026\u0026\n     (_DAT_40023c00 \u003d CONCAT31(DAT_40023c00_1,(char)FLatency), FLatency !\u003d (FLatency \u0026 0xf))) {\n    return HAL_ERROR;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 4) !\u003d 0) {\n    _DAT_40023808 \u003d _DAT_40023808 \u0026 0xffffe3ff | RCC_ClkInitStruct-\u003eAPB1CLKDivider;\n  }\n  if ((RCC_ClkInitStruct-\u003eClockType \u0026 8) !\u003d 0) {\n    _DAT_40023808 \u003d _DAT_40023808 \u0026 0xffff1fff | RCC_ClkInitStruct-\u003eAPB2CLKDivider \u003c\u003c 3;\n  }\n  uVar1 \u003d HAL_RCC_GetSysClockFreq();\n  SystemCoreClock \u003d uVar1 \u003e\u003e \"\"[(_DAT_40023808 \u003c\u003c 0x18) \u003e\u003e 0x1c];\n  HAL_InitTick(0xf);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "SystemClock_Config"
      ],
      "called": [
        "HAL_GetTick",
        "HAL_InitTick",
        "HAL_RCC_GetSysClockFreq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetHCLKFreq": {
      "entrypoint": "0x080025e0",
      "current_name": "HAL_RCC_GetHCLKFreq",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetHCLKFreq(void)\n\n{\n  return SystemCoreClock;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RCC_GetPCLK2Freq",
        "SystemClock_Config",
        "HAL_RCC_GetPCLK1Freq"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetPCLK1Freq": {
      "entrypoint": "0x080025ec",
      "current_name": "HAL_RCC_GetPCLK1Freq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetPCLK1Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  return uVar1 \u003e\u003e \"\"[(uint)(_DAT_40023808 \u003c\u003c 0x13) \u003e\u003e 0x1d];\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_SetConfig"
      ],
      "called": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RCC_GetPCLK2Freq": {
      "entrypoint": "0x0800260c",
      "current_name": "HAL_RCC_GetPCLK2Freq",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nuint32_t HAL_RCC_GetPCLK2Freq(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_RCC_GetHCLKFreq();\n  return uVar1 \u003e\u003e \"\"[(uint)(_DAT_40023808 \u003c\u003c 0x10) \u003e\u003e 0x1d];\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_SetConfig"
      ],
      "called": [
        "HAL_RCC_GetHCLKFreq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RTC_AlarmIRQHandler": {
      "entrypoint": "0x0800262c",
      "current_name": "HAL_RTC_AlarmIRQHandler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef *hrtc)\n\n{\n  if (((hrtc-\u003eInstance-\u003eISR \u0026 0x100) !\u003d 0) \u0026\u0026 ((hrtc-\u003eInstance-\u003eCR \u0026 0x1000) !\u003d 0)) {\n    HAL_RTC_AlarmAEventCallback(hrtc);\n    hrtc-\u003eInstance-\u003eISR \u003d hrtc-\u003eInstance-\u003eISR \u0026 0xff | 0xfffffe7f;\n  }\n  if (((hrtc-\u003eInstance-\u003eISR \u0026 0x200) !\u003d 0) \u0026\u0026 ((hrtc-\u003eInstance-\u003eCR \u0026 0x2000) !\u003d 0)) {\n    HAL_RTCEx_AlarmBEventCallback(hrtc);\n    hrtc-\u003eInstance-\u003eISR \u003d hrtc-\u003eInstance-\u003eISR \u0026 0xff | 0xfffffd7f;\n  }\n  _DAT_40013c14 \u003d 0x20000;\n  hrtc-\u003eState \u003d HAL_RTC_STATE_READY;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "RTC_Alarm_IRQHandler"
      ],
      "called": [
        "HAL_RTCEx_AlarmBEventCallback",
        "HAL_RTC_AlarmAEventCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RTCEx_AlarmBEventCallback": {
      "entrypoint": "0x0800268c",
      "current_name": "HAL_RTCEx_AlarmBEventCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RTC_AlarmIRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_DeInit": {
      "entrypoint": "0x0800268e",
      "current_name": "HAL_TIM_PWM_DeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  htim-\u003eState \u003d HAL_TIM_STATE_BUSY;\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  HAL_TIM_PWM_MspDeInit(htim);\n  htim-\u003eState \u003d HAL_TIM_STATE_RESET;\n  htim-\u003eLock \u003d HAL_UNLOCKED;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "HAL_TIM_PWM_MspDeInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_IC_CaptureCallback": {
      "entrypoint": "0x080026c8",
      "current_name": "HAL_TIM_IC_CaptureCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_PulseFinishedCallback": {
      "entrypoint": "0x080026ca",
      "current_name": "HAL_TIM_PWM_PulseFinishedCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_TriggerCallback": {
      "entrypoint": "0x080026cc",
      "current_name": "HAL_TIM_TriggerCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_IRQHandler": {
      "entrypoint": "0x080026ce",
      "current_name": "HAL_TIM_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 2) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 2) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffd;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_1;\n    if ((htim-\u003eInstance-\u003eCCMR1 \u0026 3) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 4) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 4) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffb;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_2;\n    if ((htim-\u003eInstance-\u003eCCMR1 \u0026 0x300) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 8) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 8) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffff7;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_3;\n    if ((htim-\u003eInstance-\u003eCCMR2 \u0026 3) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x10) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x10) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffef;\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_4;\n    if ((htim-\u003eInstance-\u003eCCMR2 \u0026 0x300) \u003d\u003d 0) {\n      HAL_TIM_OC_DelayElapsedCallback(htim);\n      HAL_TIM_PWM_PulseFinishedCallback(htim);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(htim);\n    }\n    htim-\u003eChannel \u003d HAL_TIM_ACTIVE_CHANNEL_CLEARED;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 1) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 1) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x80) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x80) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffff7f;\n    HAL_TIMEx_BreakCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x40) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x40) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffbf;\n    HAL_TIM_TriggerCallback(htim);\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eSR \u0026 0x20) !\u003d 0) \u0026\u0026 ((pTVar1-\u003eDIER \u0026 0x20) !\u003d 0)) {\n    pTVar1-\u003eSR \u003d 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(htim);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "TIM7_IRQHandler",
        "TIM3_IRQHandler",
        "TIM6_DAC_IRQHandler",
        "TIM2_IRQHandler",
        "TIM1_TRG_COM_TIM11_IRQHandler",
        "TIM8_BRK_TIM12_IRQHandler",
        "TIM8_UP_TIM13_IRQHandler",
        "TIM8_TRG_COM_TIM14_IRQHandler",
        "TIM5_IRQHandler",
        "TIM1_UP_TIM10_IRQHandler",
        "TIM4_IRQHandler",
        "TIM1_BRK_TIM9_IRQHandler"
      ],
      "called": [
        "HAL_TIMEx_BreakCallback",
        "HAL_TIM_IC_CaptureCallback",
        "HAL_TIM_PeriodElapsedCallback",
        "HAL_TIM_OC_DelayElapsedCallback",
        "HAL_TIM_TriggerCallback",
        "HAL_TIM_PWM_PulseFinishedCallback",
        "HAL_TIMEx_CommutationCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_CCxChannelCmd": {
      "entrypoint": "0x08002848",
      "current_name": "TIM_CCxChannelCmd",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_CCxChannelCmd(TIM_TypeDef *TIMx,uint32_t Channel,uint32_t ChannelState)\n\n{\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 ~(1 \u003c\u003c (Channel \u0026 0xff));\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER | ChannelState \u003c\u003c (Channel \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_Stop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_Stop": {
      "entrypoint": "0x08002864",
      "current_name": "HAL_TIM_PWM_Stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim,uint32_t Channel)\n\n{\n  bool bVar1;\n  TIM_TypeDef *pTVar2;\n  \n  TIM_CCxChannelCmd(htim-\u003eInstance,Channel,0);\n  pTVar2 \u003d htim-\u003eInstance;\n  if (pTVar2 \u003d\u003d (TIM_TypeDef *)0x40010000) {\n    bVar1 \u003d true;\n  }\n  else if (pTVar2 \u003d\u003d (TIM_TypeDef *)0x40010400) {\n    bVar1 \u003d true;\n  }\n  else {\n    bVar1 \u003d false;\n  }\n  if (((bVar1) \u0026\u0026 ((pTVar2-\u003eCCER \u0026 0x1111) \u003d\u003d 0)) \u0026\u0026 ((pTVar2-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar2-\u003eBDTR \u003d pTVar2-\u003eBDTR \u0026 0xffff7fff;\n  }\n  pTVar2 \u003d htim-\u003eInstance;\n  if (((pTVar2-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar2-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar2-\u003eCR1 \u003d pTVar2-\u003eCR1 \u0026 0xfffffffe;\n  }\n  htim-\u003eState \u003d HAL_TIM_STATE_READY;\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "TIM_CCxChannelCmd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM_CCxNChannelCmd": {
      "entrypoint": "0x080028d4",
      "current_name": "TIM_CCxNChannelCmd",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM_CCxNChannelCmd(TIM_TypeDef *TIMx,uint32_t Channel,uint32_t ChannelNState)\n\n{\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER \u0026 ~(4 \u003c\u003c (Channel \u0026 0xff));\n  TIMx-\u003eCCER \u003d TIMx-\u003eCCER | ChannelNState \u003c\u003c (Channel \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIMEx_PWMN_Stop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIMEx_PWMN_Stop": {
      "entrypoint": "0x080028f0",
      "current_name": "HAL_TIMEx_PWMN_Stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim,uint32_t Channel)\n\n{\n  TIM_TypeDef *pTVar1;\n  \n  TIM_CCxNChannelCmd(htim-\u003eInstance,Channel,0);\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eBDTR \u003d pTVar1-\u003eBDTR \u0026 0xffff7fff;\n  }\n  pTVar1 \u003d htim-\u003eInstance;\n  if (((pTVar1-\u003eCCER \u0026 0x1111) \u003d\u003d 0) \u0026\u0026 ((pTVar1-\u003eCCER \u0026 0x444) \u003d\u003d 0)) {\n    pTVar1-\u003eCR1 \u003d pTVar1-\u003eCR1 \u0026 0xfffffffe;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "TIM_CCxNChannelCmd"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIMEx_CommutationCallback": {
      "entrypoint": "0x0800293c",
      "current_name": "HAL_TIMEx_CommutationCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIMEx_BreakCallback": {
      "entrypoint": "0x0800293e",
      "current_name": "HAL_TIMEx_BreakCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_EndRxTransfer": {
      "entrypoint": "0x08002940",
      "current_name": "UART_EndRxTransfer",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART_EndRxTransfer(UART_HandleTypeDef *huart)\n\n{\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffedf;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_Transmit_IT": {
      "entrypoint": "0x0800295c",
      "current_name": "UART_Transmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)\n\n{\n  uint16_t uVar1;\n  byte *pbVar2;\n  uint16_t *tmp;\n  \n  if (huart-\u003egState !\u003d HAL_UART_STATE_BUSY_TX) {\n    return HAL_BUSY;\n  }\n  if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n    huart-\u003eInstance-\u003eDR \u003d *(ushort *)huart-\u003epTxBuffPtr \u0026 0x1ff;\n    if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n      huart-\u003epTxBuffPtr \u003d huart-\u003epTxBuffPtr + 2;\n    }\n    else {\n      huart-\u003epTxBuffPtr \u003d huart-\u003epTxBuffPtr + 1;\n    }\n  }\n  else {\n    pbVar2 \u003d huart-\u003epTxBuffPtr;\n    huart-\u003epTxBuffPtr \u003d pbVar2 + 1;\n    huart-\u003eInstance-\u003eDR \u003d (uint)*pbVar2;\n  }\n  uVar1 \u003d huart-\u003eTxXferCount - 1;\n  huart-\u003eTxXferCount \u003d uVar1;\n  if (uVar1 \u003d\u003d 0) {\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffff7f;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x40;\n    return HAL_OK;\n  }\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_SetConfig": {
      "entrypoint": "0x080029c8",
      "current_name": "UART_SetConfig",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART_SetConfig(UART_HandleTypeDef *huart)\n\n{\n  uint32_t uVar1;\n  uint32_t uVar2;\n  uint32_t uVar3;\n  uint32_t uVar4;\n  uint32_t uVar5;\n  uint32_t uVar6;\n  uint32_t uVar7;\n  uint32_t uVar8;\n  uint32_t uVar9;\n  USART_TypeDef *pUVar10;\n  \n  huart-\u003eInstance-\u003eCR2 \u003d huart-\u003eInstance-\u003eCR2 \u0026 0xffffcfff | (huart-\u003eInit).StopBits;\n  huart-\u003eInstance-\u003eCR1 \u003d\n       huart-\u003eInstance-\u003eCR1 \u0026 0xffff69f3 |\n       (huart-\u003eInit).WordLength | (huart-\u003eInit).Parity | (huart-\u003eInit).Mode |\n       (huart-\u003eInit).OverSampling;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffcff | (huart-\u003eInit).HwFlowCtl;\n  if ((huart-\u003eInit).OverSampling \u003d\u003d 0x8000) {\n    pUVar10 \u003d huart-\u003eInstance;\n    if ((pUVar10 !\u003d (USART_TypeDef *)0x40011000) \u0026\u0026 (pUVar10 !\u003d (USART_TypeDef *)0x40011400)) {\n      uVar1 \u003d HAL_RCC_GetPCLK1Freq();\n      uVar6 \u003d (huart-\u003eInit).BaudRate;\n      uVar2 \u003d HAL_RCC_GetPCLK1Freq();\n      uVar7 \u003d (huart-\u003eInit).BaudRate;\n      uVar3 \u003d HAL_RCC_GetPCLK1Freq();\n      uVar8 \u003d (huart-\u003eInit).BaudRate;\n      uVar4 \u003d HAL_RCC_GetPCLK1Freq();\n      uVar9 \u003d (huart-\u003eInit).BaudRate;\n      uVar5 \u003d HAL_RCC_GetPCLK1Freq();\n      pUVar10-\u003eBRR \u003d ((uint)((int)((ulonglong)\n                                   (((uVar4 * 0x19) / (uVar9 \u003c\u003c 1) +\n                                    (int)(((ulonglong)(uVar5 * 0x19) /\n                                          (ulonglong)((huart-\u003eInit).BaudRate \u003c\u003c 1)) / 100) * -100) *\n                                    8 + 0x32) * 0x51eb851f \u003e\u003e 0x20) \u003c\u003c 0x18) \u003e\u003e 0x1d) +\n                     ((((uVar2 * 0x19) / (uVar7 \u003c\u003c 1) +\n                       (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 \u003c\u003c 1)) / 100) * -100) *\n                       8 + 0x32) / 100 \u0026 0xf8) * 2 +\n                     (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uVar6 \u003c\u003c 1)) / 100) * 0x10;\n      return;\n    }\n    uVar1 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar6 \u003d (huart-\u003eInit).BaudRate;\n    uVar2 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar7 \u003d (huart-\u003eInit).BaudRate;\n    uVar3 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar8 \u003d (huart-\u003eInit).BaudRate;\n    uVar4 \u003d HAL_RCC_GetPCLK2Freq();\n    uVar9 \u003d (huart-\u003eInit).BaudRate;\n    uVar5 \u003d HAL_RCC_GetPCLK2Freq();\n    pUVar10-\u003eBRR \u003d ((uint)((int)((ulonglong)\n                                 (((uVar4 * 0x19) / (uVar9 \u003c\u003c 1) +\n                                  (int)(((ulonglong)(uVar5 * 0x19) /\n                                        (ulonglong)((huart-\u003eInit).BaudRate \u003c\u003c 1)) / 100) * -100) * 8\n                                 + 0x32) * 0x51eb851f \u003e\u003e 0x20) \u003c\u003c 0x18) \u003e\u003e 0x1d) +\n                   ((((uVar2 * 0x19) / (uVar7 \u003c\u003c 1) +\n                     (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 \u003c\u003c 1)) / 100) * -100) * 8\n                    + 0x32) / 100 \u0026 0xf8) * 2 +\n                   (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uVar6 \u003c\u003c 1)) / 100) * 0x10;\n    return;\n  }\n  pUVar10 \u003d huart-\u003eInstance;\n  if ((pUVar10 !\u003d (USART_TypeDef *)0x40011000) \u0026\u0026 (pUVar10 !\u003d (USART_TypeDef *)0x40011400)) {\n    uVar1 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar6 \u003d (huart-\u003eInit).BaudRate;\n    uVar2 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar7 \u003d (huart-\u003eInit).BaudRate;\n    uVar3 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar8 \u003d (huart-\u003eInit).BaudRate;\n    uVar4 \u003d HAL_RCC_GetPCLK1Freq();\n    uVar9 \u003d (huart-\u003eInit).BaudRate;\n    uVar5 \u003d HAL_RCC_GetPCLK1Freq();\n    pUVar10-\u003eBRR \u003d ((uint)((int)((ulonglong)\n                                 (((uVar4 * 0x19) / (uVar9 \u003c\u003c 2) +\n                                  (int)(((ulonglong)(uVar5 * 0x19) /\n                                        (ulonglong)((huart-\u003eInit).BaudRate \u003c\u003c 2)) / 100) * -100) *\n                                  0x10 + 0x32) * 0x51eb851f \u003e\u003e 0x20) \u003c\u003c 0x17) \u003e\u003e 0x1c) +\n                   ((((uVar2 * 0x19) / (uVar7 \u003c\u003c 2) +\n                     (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 \u003c\u003c 2)) / 100) * -100) *\n                     0x10 + 0x32) / 100 \u0026 0xf0) +\n                   (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uVar6 \u003c\u003c 2)) / 100) * 0x10;\n    return;\n  }\n  uVar1 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar6 \u003d (huart-\u003eInit).BaudRate;\n  uVar2 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar7 \u003d (huart-\u003eInit).BaudRate;\n  uVar3 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar8 \u003d (huart-\u003eInit).BaudRate;\n  uVar4 \u003d HAL_RCC_GetPCLK2Freq();\n  uVar9 \u003d (huart-\u003eInit).BaudRate;\n  uVar5 \u003d HAL_RCC_GetPCLK2Freq();\n  pUVar10-\u003eBRR \u003d ((uint)((int)((ulonglong)\n                               (((uVar4 * 0x19) / (uVar9 \u003c\u003c 2) +\n                                (int)(((ulonglong)(uVar5 * 0x19) /\n                                      (ulonglong)((huart-\u003eInit).BaudRate \u003c\u003c 2)) / 100) * -100) *\n                                0x10 + 0x32) * 0x51eb851f \u003e\u003e 0x20) \u003c\u003c 0x17) \u003e\u003e 0x1c) +\n                 ((((uVar2 * 0x19) / (uVar7 \u003c\u003c 2) +\n                   (int)(((ulonglong)(uVar3 * 0x19) / (ulonglong)(uVar8 \u003c\u003c 2)) / 100) * -100) * 0x10\n                  + 0x32) / 100 \u0026 0xf0) +\n                 (int)(((ulonglong)(uVar1 * 0x19) / (ulonglong)(uVar6 \u003c\u003c 2)) / 100) * 0x10;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Init"
      ],
      "called": [
        "HAL_RCC_GetPCLK2Freq",
        "HAL_RCC_GetPCLK1Freq"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_WaitOnFlagUntilTimeout": {
      "entrypoint": "0x08002d0c",
      "current_name": "UART_WaitOnFlagUntilTimeout",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nUART_WaitOnFlagUntilTimeout\n          (UART_HandleTypeDef *huart,uint32_t Flag,FlagStatus Status,uint32_t Tickstart,\n          uint32_t Timeout)\n\n{\n  uint32_t uVar1;\n  \n  do {\n    if (((Flag \u0026 ~huart-\u003eInstance-\u003eSR) \u003d\u003d 0) !\u003d (bool)Status) {\n      return HAL_OK;\n    }\n  } while ((Timeout \u003d\u003d 0xffffffff) ||\n          ((Timeout !\u003d 0 \u0026\u0026 (uVar1 \u003d HAL_GetTick(), uVar1 - Tickstart \u003c\u003d Timeout))));\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffe5f;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003egState \u003d HAL_UART_STATE_READY;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  huart-\u003eLock \u003d HAL_UNLOCKED;\n  return HAL_TIMEOUT;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Transmit"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_MspInit": {
      "entrypoint": "0x08002d70",
      "current_name": "HAL_UART_MspInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_MspInit(UART_HandleTypeDef *huart)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_Init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_Init": {
      "entrypoint": "0x08002d72",
      "current_name": "HAL_UART_Init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)\n\n{\n  if (huart !\u003d (UART_HandleTypeDef *)0x0) {\n    if (huart-\u003egState \u003d\u003d HAL_UART_STATE_RESET) {\n      huart-\u003eLock \u003d HAL_UNLOCKED;\n      HAL_UART_MspInit(huart);\n    }\n    huart-\u003egState \u003d HAL_UART_STATE_BUSY;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffdfff;\n    UART_SetConfig(huart);\n    huart-\u003eInstance-\u003eCR2 \u003d huart-\u003eInstance-\u003eCR2 \u0026 0xffffb7ff;\n    huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xffffffd5;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x2000;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003egState \u003d HAL_UART_STATE_READY;\n    huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n    return HAL_OK;\n  }\n  return HAL_ERROR;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [
        "UART_SetConfig",
        "HAL_UART_MspInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_Transmit": {
      "entrypoint": "0x08002dd0",
      "current_name": "HAL_UART_Transmit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef\nHAL_UART_Transmit(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size,uint32_t Timeout)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint32_t Tickstart;\n  uint16_t *tmp;\n  \n  if (huart-\u003egState \u003d\u003d HAL_UART_STATE_READY) {\n    if (pData \u003d\u003d (uint8_t *)0x0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (Size \u003d\u003d 0) {\n      HVar1 \u003d HAL_ERROR;\n    }\n    else if (huart-\u003eLock \u003d\u003d HAL_LOCKED) {\n      HVar1 \u003d HAL_BUSY;\n    }\n    else {\n      huart-\u003eLock \u003d HAL_LOCKED;\n      huart-\u003eErrorCode \u003d 0;\n      huart-\u003egState \u003d HAL_UART_STATE_BUSY_TX;\n      Tickstart \u003d HAL_GetTick();\n      huart-\u003eTxXferSize \u003d Size;\n      huart-\u003eTxXferCount \u003d Size;\n      while (huart-\u003eTxXferCount !\u003d 0) {\n        huart-\u003eTxXferCount \u003d huart-\u003eTxXferCount - 1;\n        if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n          HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 !\u003d HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart-\u003eInstance-\u003eDR \u003d *(ushort *)pData \u0026 0x1ff;\n          if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n            pData \u003d (uint8_t *)((int)pData + 2);\n          }\n          else {\n            pData \u003d (uint8_t *)((int)pData + 1);\n          }\n        }\n        else {\n          HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x80,RESET,Tickstart,Timeout);\n          if (HVar1 !\u003d HAL_OK) {\n            return HAL_TIMEOUT;\n          }\n          huart-\u003eInstance-\u003eDR \u003d (uint)*pData;\n          pData \u003d (uint8_t *)((int)pData + 1);\n        }\n      }\n      HVar1 \u003d UART_WaitOnFlagUntilTimeout(huart,0x40,RESET,Tickstart,Timeout);\n      if (HVar1 \u003d\u003d HAL_OK) {\n        huart-\u003egState \u003d HAL_UART_STATE_READY;\n        huart-\u003eLock \u003d HAL_UNLOCKED;\n        HVar1 \u003d HAL_OK;\n      }\n      else {\n        HVar1 \u003d HAL_TIMEOUT;\n      }\n    }\n  }\n  else {\n    HVar1 \u003d HAL_BUSY;\n  }\n  return HVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_write"
      ],
      "called": [
        "HAL_GetTick",
        "UART_WaitOnFlagUntilTimeout"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_Transmit_IT": {
      "entrypoint": "0x08002eb2",
      "current_name": "HAL_UART_Transmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart-\u003egState !\u003d HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData \u003d\u003d (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size \u003d\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (huart-\u003eLock !\u003d HAL_LOCKED) {\n    huart-\u003epTxBuffPtr \u003d pData;\n    huart-\u003eTxXferSize \u003d Size;\n    huart-\u003eTxXferCount \u003d Size;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003egState \u003d HAL_UART_STATE_BUSY_TX;\n    huart-\u003eLock \u003d HAL_UNLOCKED;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x80;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_tx_callback",
        "HAL_UART_TxCpltCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_Receive_IT": {
      "entrypoint": "0x08002efa",
      "current_name": "HAL_UART_Receive_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart,uint8_t *pData,uint16_t Size)\n\n{\n  if (huart-\u003eRxState !\u003d HAL_UART_STATE_READY) {\n    return HAL_BUSY;\n  }\n  if (pData \u003d\u003d (uint8_t *)0x0) {\n    return HAL_ERROR;\n  }\n  if (Size \u003d\u003d 0) {\n    return HAL_ERROR;\n  }\n  if (huart-\u003eLock !\u003d HAL_LOCKED) {\n    huart-\u003epRxBuffPtr \u003d pData;\n    huart-\u003eRxXferSize \u003d Size;\n    huart-\u003eRxXferCount \u003d Size;\n    huart-\u003eErrorCode \u003d 0;\n    huart-\u003eRxState \u003d HAL_UART_STATE_BUSY_RX;\n    huart-\u003eLock \u003d HAL_UNLOCKED;\n    huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 | 1;\n    huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 | 0x120;\n    return HAL_OK;\n  }\n  return HAL_BUSY;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_rx_callback",
        "uart_getc"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_EndTransmit_IT": {
      "entrypoint": "0x08002f4c",
      "current_name": "UART_EndTransmit_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)\n\n{\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xffffffbf;\n  huart-\u003egState \u003d HAL_UART_STATE_READY;\n  HAL_UART_TxCpltCallback(huart);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [
        "HAL_UART_TxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_Receive_IT": {
      "entrypoint": "0x08002f66",
      "current_name": "UART_Receive_IT",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)\n\n{\n  uint16_t *tmp;\n  byte *pbVar1;\n  uint16_t uVar2;\n  uint8_t *puVar3;\n  \n  if (huart-\u003eRxState !\u003d HAL_UART_STATE_BUSY_RX) {\n    return HAL_BUSY;\n  }\n  if ((huart-\u003eInit).WordLength \u003d\u003d 0x1000) {\n    if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n      *(ushort *)huart-\u003epRxBuffPtr \u003d (ushort)((huart-\u003eInstance-\u003eDR \u003c\u003c 0x17) \u003e\u003e 0x17);\n      huart-\u003epRxBuffPtr \u003d huart-\u003epRxBuffPtr + 2;\n    }\n    else {\n      *(ushort *)huart-\u003epRxBuffPtr \u003d (ushort)huart-\u003eInstance-\u003eDR \u0026 0xff;\n      huart-\u003epRxBuffPtr \u003d huart-\u003epRxBuffPtr + 1;\n    }\n  }\n  else if ((huart-\u003eInit).Parity \u003d\u003d 0) {\n    puVar3 \u003d huart-\u003epRxBuffPtr;\n    huart-\u003epRxBuffPtr \u003d puVar3 + 1;\n    *puVar3 \u003d (uint8_t)huart-\u003eInstance-\u003eDR;\n  }\n  else {\n    pbVar1 \u003d huart-\u003epRxBuffPtr;\n    huart-\u003epRxBuffPtr \u003d pbVar1 + 1;\n    *pbVar1 \u003d (byte)huart-\u003eInstance-\u003eDR \u0026 0x7f;\n  }\n  uVar2 \u003d huart-\u003eRxXferCount - 1;\n  huart-\u003eRxXferCount \u003d uVar2;\n  if (uVar2 !\u003d 0) {\n    return HAL_OK;\n  }\n  huart-\u003eInstance-\u003eCR1 \u003d huart-\u003eInstance-\u003eCR1 \u0026 0xfffffedf;\n  huart-\u003eInstance-\u003eCR3 \u003d huart-\u003eInstance-\u003eCR3 \u0026 0xfffffffe;\n  huart-\u003eRxState \u003d HAL_UART_STATE_READY;\n  HAL_UART_RxCpltCallback(huart);\n  return HAL_OK;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_IRQHandler"
      ],
      "called": [
        "HAL_UART_RxCpltCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_IRQHandler": {
      "entrypoint": "0x08002ffc",
      "current_name": "HAL_UART_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_IRQHandler(UART_HandleTypeDef *huart)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint uVar2;\n  uint32_t cr1its;\n  USART_TypeDef *pUVar3;\n  uint32_t cr3its;\n  uint uVar4;\n  uint uVar5;\n  uint32_t isrflags;\n  \n  pUVar3 \u003d huart-\u003eInstance;\n  uVar5 \u003d pUVar3-\u003eSR;\n  uVar2 \u003d pUVar3-\u003eCR1;\n  if ((((uVar5 \u0026 0xf) \u003d\u003d 0) \u0026\u0026 ((uVar5 \u0026 0x20) !\u003d 0)) \u0026\u0026 ((uVar2 \u0026 0x20) !\u003d 0)) {\n    UART_Receive_IT(huart);\n    return;\n  }\n  if (((uVar5 \u0026 0xf) \u003d\u003d 0) || ((uVar4 \u003d pUVar3-\u003eCR3 \u0026 1, uVar4 \u003d\u003d 0 \u0026\u0026 ((uVar2 \u0026 0x120) \u003d\u003d 0)))) {\n    if (((uVar5 \u0026 0x80) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x80) !\u003d 0)) {\n      UART_Transmit_IT(huart);\n      return;\n    }\n    if (((uVar5 \u0026 0x40) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x40) !\u003d 0)) {\n      UART_EndTransmit_IT(huart);\n    }\n  }\n  else {\n    if (((uVar5 \u0026 1) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x100) !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 1;\n    }\n    if (((uVar5 \u0026 4) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 2;\n    }\n    if (((uVar5 \u0026 2) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 4;\n    }\n    if (((uVar5 \u0026 8) !\u003d 0) \u0026\u0026 (uVar4 !\u003d 0)) {\n      huart-\u003eErrorCode \u003d huart-\u003eErrorCode | 8;\n    }\n    if (huart-\u003eErrorCode !\u003d 0) {\n      if (((uVar5 \u0026 0x20) !\u003d 0) \u0026\u0026 ((uVar2 \u0026 0x20) !\u003d 0)) {\n        UART_Receive_IT(huart);\n      }\n      if (((huart-\u003eErrorCode \u0026 8) \u003d\u003d 0) \u0026\u0026 ((huart-\u003eInstance-\u003eCR3 \u0026 0x40) \u003d\u003d 0)) {\n        HAL_UART_ErrorCallback(huart);\n        huart-\u003eErrorCode \u003d 0;\n        return;\n      }\n      UART_EndRxTransfer(huart);\n      pUVar3 \u003d huart-\u003eInstance;\n      if ((pUVar3-\u003eCR3 \u0026 0x40) \u003d\u003d 0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      pUVar3-\u003eCR3 \u003d pUVar3-\u003eCR3 \u0026 0xffffffbf;\n      if (huart-\u003ehdmarx \u003d\u003d (DMA_HandleTypeDef *)0x0) {\n        HAL_UART_ErrorCallback(huart);\n        return;\n      }\n      huart-\u003ehdmarx-\u003eXferAbortCallback \u003d UART_DMAAbortOnError + 1;\n      HVar1 \u003d HAL_DMA_Abort_IT(huart-\u003ehdmarx);\n      if (HVar1 !\u003d HAL_OK) {\n        (*huart-\u003ehdmarx-\u003eXferAbortCallback)(huart-\u003ehdmarx);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART4_IRQHandler",
        "USART6_IRQHandler",
        "USART2_IRQHandler",
        "UART5_IRQHandler",
        "USART3_IRQHandler",
        "UART8_IRQHandler",
        "UART7_IRQHandler",
        "USART1_IRQHandler"
      ],
      "called": [
        "UART_Receive_IT",
        "HAL_UART_ErrorCallback",
        "UART_EndRxTransfer",
        "UART_EndTransmit_IT",
        "UART_Transmit_IT",
        "HAL_DMA_Abort_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_DMAAbortOnError": {
      "entrypoint": "0x0800311c",
      "current_name": "UART_DMAAbortOnError",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)\n\n{\n  UART_HandleTypeDef *huart_00;\n  UART_HandleTypeDef *huart;\n  \n  huart_00 \u003d (UART_HandleTypeDef *)hdma-\u003eParent;\n  huart_00-\u003eRxXferCount \u003d 0;\n  huart_00-\u003eTxXferCount \u003d 0;\n  HAL_UART_ErrorCallback(huart_00);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_UART_ErrorCallback"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_GetState": {
      "entrypoint": "0x0800312c",
      "current_name": "HAL_UART_GetState",
      "code": "\n/* WARNING: Unknown calling convention */\n\nHAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)\n\n{\n  return huart-\u003eRxState | huart-\u003egState;\n}\n\n",
      "renaming": {},
      "calling": [
        "serial_rx_active",
        "serial_tx_active"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "is_pin_configured": {
      "entrypoint": "0x08003138",
      "current_name": "is_pin_configured",
      "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool is_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint32_t index;\n  \n  index \u003d map[(uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c];\n  return (_Bool)((byte)(index \u003e\u003e ((int)pin \u0026 0xfU)) \u0026 1);\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode",
        "digitalWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_pin_configured": {
      "entrypoint": "0x0800314e",
      "current_name": "set_pin_configured",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid set_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  uint32_t index;\n  \n  uVar1 \u003d (uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c;\n  map[uVar1] \u003d map[uVar1] | 1 \u003c\u003c ((int)pin \u0026 0xfU);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "reset_pin_configured": {
      "entrypoint": "0x0800316c",
      "current_name": "reset_pin_configured",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid reset_pin_configured(PinName_conflict pin,uint32_t *map)\n\n{\n  uint uVar1;\n  uint32_t index;\n  \n  uVar1 \u003d (uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c;\n  map[uVar1] \u003d map[uVar1] \u0026 ~(1 \u003c\u003c ((int)pin \u0026 0xfU));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_GPIO_Port": {
      "entrypoint": "0x0800318c",
      "current_name": "get_GPIO_Port",
      "code": "\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * get_GPIO_Port(uint32_t port_idx)\n\n{\n  switch(port_idx) {\n  case 0:\n    return (GPIO_TypeDef *)0x40020000;\n  case 1:\n    return (GPIO_TypeDef *)0x40020400;\n  case 2:\n    return (GPIO_TypeDef *)0x40020800;\n  case 3:\n    return (GPIO_TypeDef *)0x40020c00;\n  case 4:\n    return (GPIO_TypeDef *)0x40021000;\n  case 5:\n    return (GPIO_TypeDef *)0x40021400;\n  case 6:\n    return (GPIO_TypeDef *)0x40021800;\n  case 7:\n    return (GPIO_TypeDef *)0x40021c00;\n  case 8:\n    return (GPIO_TypeDef *)0x40022000;\n  case 9:\n    return (GPIO_TypeDef *)0x40022400;\n  case 10:\n    return (GPIO_TypeDef *)0x40022800;\n  default:\n    return (GPIO_TypeDef *)0x0;\n  }\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "set_GPIO_Port_Clock": {
      "entrypoint": "0x080031fc",
      "current_name": "set_GPIO_Port_Clock",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nGPIO_TypeDef * set_GPIO_Port_Clock(uint32_t port_idx)\n\n{\n  GPIO_TypeDef *pGVar1;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  uint32_t tmpreg_8;\n  uint32_t tmpreg_9;\n  uint32_t tmpreg_10;\n  \n  switch(port_idx) {\n  case 0:\n    _DAT_40023830 \u003d _DAT_40023830 | 1;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40020000;\n    break;\n  case 1:\n    _DAT_40023830 \u003d _DAT_40023830 | 2;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40020400;\n    break;\n  case 2:\n    _DAT_40023830 \u003d _DAT_40023830 | 4;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40020800;\n    break;\n  case 3:\n    _DAT_40023830 \u003d _DAT_40023830 | 8;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40020c00;\n    break;\n  case 4:\n    _DAT_40023830 \u003d _DAT_40023830 | 0x10;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40021000;\n    break;\n  case 5:\n    _DAT_40023830 \u003d _DAT_40023830 | 0x20;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40021400;\n    break;\n  case 6:\n    _DAT_40023830 \u003d _DAT_40023830 | 0x40;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40021800;\n    break;\n  case 7:\n    _DAT_40023830 \u003d _DAT_40023830 | 0x80;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40021c00;\n    break;\n  case 8:\n    _DAT_40023830 \u003d _DAT_40023830 | 0x100;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40022000;\n    break;\n  case 9:\n    _DAT_40023830 \u003d _DAT_40023830 | 0x200;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40022400;\n    break;\n  case 10:\n    _DAT_40023830 \u003d _DAT_40023830 | 0x400;\n    pGVar1 \u003d (GPIO_TypeDef *)0x40022800;\n    break;\n  default:\n    pGVar1 \u003d (GPIO_TypeDef *)0x0;\n  }\n  return pGVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "digital_io_init",
        "uart_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_dac_channel": {
      "entrypoint": "0x08003380",
      "current_name": "get_dac_channel",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_dac_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint32_t function;\n  \n  uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_DAC);\n  function \u003d uVar1 \u003c\u003c 0xc;\n  function \u003d function \u003e\u003e 0x1b;\n  if (function !\u003d 2) {\n    return 0;\n  }\n  return 0x10;\n}\n\n",
      "renaming": {},
      "calling": [
        "dac_stop"
      ],
      "called": [
        "pinmap_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_pwm_channel": {
      "entrypoint": "0x0800339c",
      "current_name": "get_pwm_channel",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t get_pwm_channel(PinName_conflict pin)\n\n{\n  uint32_t uVar1;\n  uint32_t function;\n  \n  uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n  function \u003d uVar1 \u003c\u003c 0xc;\n  function \u003d function \u003e\u003e 0x1b;\n  if (function \u003d\u003d 3) {\n    return 8;\n  }\n  if (function !\u003d 4) {\n    if (function !\u003d 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop"
      ],
      "called": [
        "pinmap_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_DAC_MspDeInit": {
      "entrypoint": "0x080033c8",
      "current_name": "HAL_DAC_MspDeInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid HAL_DAC_MspDeInit(DAC_HandleTypeDef *hdac)\n\n{\n  _DAT_40023840 \u003d _DAT_40023840 \u0026 0xdfffffff;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_DAC_DeInit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dac_stop": {
      "entrypoint": "0x080033d8",
      "current_name": "dac_stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid dac_stop(PinName_conflict pin)\n\n{\n  uint32_t Channel;\n  uint32_t dacChannel;\n  DAC_HandleTypeDef DacHandle;\n  \n  DacHandle.Instance \u003d (DAC_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)\u0026PinMap_DAC);\n  if ((DacHandle.Instance !\u003d (DAC_TypeDef *)0x0) \u0026\u0026\n     ((Channel \u003d get_dac_channel(pin), Channel \u003d\u003d 0 || (Channel \u003d\u003d 0x10)))) {\n    HAL_DAC_Stop(\u0026DacHandle,Channel);\n    HAL_DAC_DeInit(\u0026DacHandle);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [
        "pinmap_peripheral",
        "HAL_DAC_Stop",
        "get_dac_channel",
        "HAL_DAC_DeInit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PWM_MspDeInit": {
      "entrypoint": "0x0800340c",
      "current_name": "HAL_TIM_PWM_MspDeInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)\n\n{\n  timer_disable_clock(htim);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_DeInit"
      ],
      "called": [
        "timer_disable_clock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pwm_stop": {
      "entrypoint": "0x08003414",
      "current_name": "pwm_stop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pwm_stop(PinName_conflict pin)\n\n{\n  uint32_t Channel;\n  uint32_t timChannel;\n  uint32_t uVar1;\n  TIM_HandleTypeDef timHandle;\n  \n  timHandle.Instance \u003d (TIM_TypeDef *)pinmap_peripheral(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n  if ((timHandle.Instance !\u003d (TIM_TypeDef *)0x0) \u0026\u0026\n     ((((Channel \u003d get_pwm_channel(pin), Channel \u003d\u003d 0 || (Channel \u003d\u003d 4)) || (Channel \u003d\u003d 8)) ||\n      ((Channel \u003d\u003d 0xc || (Channel \u003d\u003d 0x18)))))) {\n    uVar1 \u003d pinmap_function(pin,(PinMap_conflict *)\u0026PinMap_PWM);\n    if ((uVar1 \u0026 0x100000) \u003d\u003d 0) {\n      HAL_TIM_PWM_Stop(\u0026timHandle,Channel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(\u0026timHandle,Channel);\n    }\n    HAL_TIM_PWM_DeInit(\u0026timHandle);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [
        "pinmap_peripheral",
        "HAL_TIM_PWM_Stop",
        "HAL_TIM_PWM_DeInit",
        "pinmap_function",
        "HAL_TIMEx_PWMN_Stop",
        "get_pwm_channel"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "GetCurrentMilli": {
      "entrypoint": "0x0800346c",
      "current_name": "GetCurrentMilli",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t GetCurrentMilli(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d HAL_GetTick();\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "millis"
      ],
      "called": [
        "HAL_GetTick"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "noOsSystickHandler": {
      "entrypoint": "0x08003474",
      "current_name": "noOsSystickHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid noOsSystickHandler(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SysTick_Handler": {
      "entrypoint": "0x08003476",
      "current_name": "SysTick_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SysTick_Handler(void)\n\n{\n  HAL_IncTick();\n  HAL_SYSTICK_IRQHandler();\n  noOsSystickHandler();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_SYSTICK_IRQHandler",
        "HAL_IncTick",
        "noOsSystickHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digital_io_init": {
      "entrypoint": "0x08003486",
      "current_name": "digital_io_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid digital_io_init(PinName_conflict pin,uint32_t mode,uint32_t pull)\n\n{\n  GPIO_TypeDef *GPIOx;\n  GPIO_TypeDef *port;\n  GPIO_InitTypeDef GPIO_InitStructure;\n  \n  GPIOx \u003d set_GPIO_Port_Clock((uint)((int)pin \u003c\u003c 0x18) \u003e\u003e 0x1c);\n  GPIO_InitStructure.Pin \u003d 1 \u003c\u003c ((int)pin \u0026 0xfU) \u0026 0xffff;\n  GPIO_InitStructure.Speed \u003d 2;\n  GPIO_InitStructure.Mode \u003d mode;\n  GPIO_InitStructure.Pull \u003d pull;\n  HAL_GPIO_Init(GPIOx,\u0026GPIO_InitStructure);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [
        "HAL_GPIO_Init",
        "set_GPIO_Port_Clock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digital_io_write": {
      "entrypoint": "0x080034b6",
      "current_name": "digital_io_write",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid digital_io_write(GPIO_TypeDef *port,uint32_t pin,uint32_t val)\n\n{\n  if (val \u003d\u003d 0) {\n    HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_RESET);\n    return;\n  }\n  HAL_GPIO_WritePin(port,(uint16_t)pin,GPIO_PIN_SET);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite"
      ],
      "called": [
        "HAL_GPIO_WritePin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "hw_config_init": {
      "entrypoint": "0x080034ce",
      "current_name": "hw_config_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid hw_config_init(void)\n\n{\n  HAL_Init();\n  SystemClock_Config();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [
        "SystemClock_Config",
        "HAL_Init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_find_peripheral": {
      "entrypoint": "0x080034da",
      "current_name": "pinmap_find_peripheral",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * pinmap_find_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return (void *)0x0;\n    }\n    if (map-\u003epin \u003d\u003d pin) break;\n    map \u003d map + 1;\n  }\n  return map-\u003eperipheral;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_peripheral",
        "pinmap_find_peripheral"
      ],
      "called": [
        "pinmap_find_peripheral"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_peripheral": {
      "entrypoint": "0x080034f4",
      "current_name": "pinmap_peripheral",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * pinmap_peripheral(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  void *pvVar1;\n  \n  if (pin !\u003d NC) {\n    pvVar1 \u003d pinmap_find_peripheral(pin,map);\n    return pvVar1;\n  }\n  return (void *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_write",
        "dac_stop",
        "pwm_stop",
        "uart_init",
        "uart_debug_init"
      ],
      "called": [
        "pinmap_find_peripheral"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_find_pin": {
      "entrypoint": "0x08003506",
      "current_name": "pinmap_find_pin",
      "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict pinmap_find_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003eperipheral \u003d\u003d (void *)0x0) {\n      return NC;\n    }\n    if (map-\u003eperipheral \u003d\u003d peripheral) break;\n    map \u003d map + 1;\n  }\n  return map-\u003epin;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_find_pin",
        "pinmap_pin"
      ],
      "called": [
        "pinmap_find_pin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_pin": {
      "entrypoint": "0x0800351e",
      "current_name": "pinmap_pin",
      "code": "\n/* WARNING: Unknown calling convention */\n\nPinName_conflict pinmap_pin(void *peripheral,PinMap_conflict *map)\n\n{\n  PinName_conflict PVar1;\n  \n  if (peripheral !\u003d (void *)0x0) {\n    PVar1 \u003d pinmap_find_pin(peripheral,map);\n    return PVar1;\n  }\n  return NC;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial",
        "uart_debug_init"
      ],
      "called": [
        "pinmap_find_pin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_find_function": {
      "entrypoint": "0x0800352e",
      "current_name": "pinmap_find_function",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pinmap_find_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return 0xffffffff;\n    }\n    if (map-\u003epin \u003d\u003d pin) break;\n    map \u003d map + 1;\n  }\n  return map-\u003efunction;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinmap_function",
        "pinmap_find_function"
      ],
      "called": [
        "pinmap_find_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_function": {
      "entrypoint": "0x0800354a",
      "current_name": "pinmap_function",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pinmap_function(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  uint32_t uVar1;\n  \n  if (pin \u003d\u003d NC) {\n    return 0xffffffff;\n  }\n  uVar1 \u003d pinmap_find_function(pin,map);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "pwm_stop",
        "uart_init",
        "get_dac_channel",
        "get_pwm_channel"
      ],
      "called": [
        "pinmap_find_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pin_in_pinmap": {
      "entrypoint": "0x0800355e",
      "current_name": "pin_in_pinmap",
      "code": "\n/* WARNING: Unknown calling convention */\n\n_Bool pin_in_pinmap(PinName_conflict pin,PinMap_conflict *map)\n\n{\n  if (pin \u003d\u003d NC) {\n    return false;\n  }\n  while( true ) {\n    if (map-\u003epin \u003d\u003d NC) {\n      return false;\n    }\n    if (pin \u003d\u003d map-\u003epin) break;\n    map \u003d map + 1;\n  }\n  return true;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinmap_merge_peripheral": {
      "entrypoint": "0x08003582",
      "current_name": "pinmap_merge_peripheral",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid * pinmap_merge_peripheral(void *a,void *b)\n\n{\n  if (a !\u003d b) {\n    if (a \u003d\u003d (void *)0x0) {\n      return b;\n    }\n    if (b \u003d\u003d (void *)0x0) {\n      return a;\n    }\n    a \u003d (void *)0x0;\n  }\n  return a;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_RTC_AlarmAEventCallback": {
      "entrypoint": "0x08003594",
      "current_name": "HAL_RTC_AlarmAEventCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)\n\n{\n  if (RTCUserCallback !\u003d (voidCallbackPtr)0x0) {\n    (*RTCUserCallback)(callbackUserData);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_RTC_AlarmIRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "RTC_Alarm_IRQHandler": {
      "entrypoint": "0x080035ac",
      "current_name": "RTC_Alarm_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid RTC_Alarm_IRQHandler(void)\n\n{\n  HAL_RTC_AlarmIRQHandler(\u0026RtcHandle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_RTC_AlarmIRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemInit": {
      "entrypoint": "0x080035bc",
      "current_name": "SystemInit",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid SystemInit(void)\n\n{\n  _DAT_40023808 \u003d 0;\n  _DAT_40023804 \u003d 0x24003010;\n  _DAT_40023800 \u003d _DAT_40023800 \u0026 0xfef2ffff | 1;\n  _DAT_4002380c \u003d 0;\n  _DAT_e000ed08 \u003d 0x8000000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "timer_disable_clock": {
      "entrypoint": "0x080035fc",
      "current_name": "timer_disable_clock",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid timer_disable_clock(TIM_HandleTypeDef *htim)\n\n{\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40010000) {\n    _DAT_40023844 \u003d _DAT_40023844 \u0026 0xfffffffe;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40000000) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xfffffffe;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40000400) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xfffffffd;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40000800) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xfffffffb;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40000c00) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xfffffff7;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40001000) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xffffffef;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40001400) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xffffffdf;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40010400) {\n    _DAT_40023844 \u003d _DAT_40023844 \u0026 0xfffffffd;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40014000) {\n    _DAT_40023844 \u003d _DAT_40023844 \u0026 0xfffeffff;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40014400) {\n    _DAT_40023844 \u003d _DAT_40023844 \u0026 0xfffdffff;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40014800) {\n    _DAT_40023844 \u003d _DAT_40023844 \u0026 0xfffbffff;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40001800) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xffffffbf;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40001c00) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xffffff7f;\n  }\n  if (htim-\u003eInstance \u003d\u003d (TIM_TypeDef *)0x40002000) {\n    _DAT_40023840 \u003d _DAT_40023840 \u0026 0xfffffeff;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PWM_MspDeInit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_timer_obj": {
      "entrypoint": "0x08003750",
      "current_name": "get_timer_obj",
      "code": "\n/* WARNING: Unknown calling convention */\n\nstimer_t * get_timer_obj(TIM_HandleTypeDef *htim)\n\n{\n  return (stimer_t *)\u0026htim[-1].Lock;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_PeriodElapsedCallback",
        "HAL_TIM_OC_DelayElapsedCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_OC_DelayElapsedCallback": {
      "entrypoint": "0x08003754",
      "current_name": "HAL_TIM_OC_DelayElapsedCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)\n\n{\n  stimer_t *psVar1;\n  stimer_t *obj;\n  \n  psVar1 \u003d get_timer_obj(htim);\n  if ((psVar1-\u003eirqHandleOC !\u003d (_func_void_stimer_t_ptr_uint32_t *)0x0) \u0026\u0026\n     (htim-\u003eChannel \u003d\u003d HAL_TIM_ACTIVE_CHANNEL_1)) {\n    (*psVar1-\u003eirqHandleOC)(psVar1,0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [
        "get_timer_obj"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_TIM_PeriodElapsedCallback": {
      "entrypoint": "0x0800376e",
      "current_name": "HAL_TIM_PeriodElapsedCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)\n\n{\n  stimer_t *psVar1;\n  stimer_t *obj;\n  \n  psVar1 \u003d get_timer_obj(htim);\n  if (psVar1-\u003eirqHandle !\u003d (_func_void_stimer_t_ptr *)0x0) {\n    (*psVar1-\u003eirqHandle)(psVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_TIM_IRQHandler"
      ],
      "called": [
        "get_timer_obj"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM1_UP_TIM10_IRQHandler": {
      "entrypoint": "0x0800377c",
      "current_name": "TIM1_UP_TIM10_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM1_UP_TIM10_IRQHandler(void)\n\n{\n  if (timer_handles[0] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[0]);\n  }\n  if (timer_handles[9] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[9]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM2_IRQHandler": {
      "entrypoint": "0x08003798",
      "current_name": "TIM2_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM2_IRQHandler(void)\n\n{\n  if (timer_handles[1] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[1]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM3_IRQHandler": {
      "entrypoint": "0x080037ac",
      "current_name": "TIM3_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM3_IRQHandler(void)\n\n{\n  if (timer_handles[2] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM4_IRQHandler": {
      "entrypoint": "0x080037c0",
      "current_name": "TIM4_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM4_IRQHandler(void)\n\n{\n  if (timer_handles[3] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[3]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM5_IRQHandler": {
      "entrypoint": "0x080037d4",
      "current_name": "TIM5_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM5_IRQHandler(void)\n\n{\n  if (timer_handles[4] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[4]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM6_DAC_IRQHandler": {
      "entrypoint": "0x080037e8",
      "current_name": "TIM6_DAC_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM6_DAC_IRQHandler(void)\n\n{\n  if (timer_handles[5] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[5]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM7_IRQHandler": {
      "entrypoint": "0x080037fc",
      "current_name": "TIM7_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM7_IRQHandler(void)\n\n{\n  if (timer_handles[6] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[6]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM8_UP_TIM13_IRQHandler": {
      "entrypoint": "0x08003810",
      "current_name": "TIM8_UP_TIM13_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM8_UP_TIM13_IRQHandler(void)\n\n{\n  if (timer_handles[7] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[7]);\n  }\n  if (timer_handles[12] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[12]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM1_BRK_TIM9_IRQHandler": {
      "entrypoint": "0x0800382c",
      "current_name": "TIM1_BRK_TIM9_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM1_BRK_TIM9_IRQHandler(void)\n\n{\n  if (timer_handles[8] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[8]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM1_TRG_COM_TIM11_IRQHandler": {
      "entrypoint": "0x08003840",
      "current_name": "TIM1_TRG_COM_TIM11_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM1_TRG_COM_TIM11_IRQHandler(void)\n\n{\n  if (timer_handles[10] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[10]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM8_BRK_TIM12_IRQHandler": {
      "entrypoint": "0x08003854",
      "current_name": "TIM8_BRK_TIM12_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM8_BRK_TIM12_IRQHandler(void)\n\n{\n  if (timer_handles[11] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[11]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TIM8_TRG_COM_TIM14_IRQHandler": {
      "entrypoint": "0x08003868",
      "current_name": "TIM8_TRG_COM_TIM14_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TIM8_TRG_COM_TIM14_IRQHandler(void)\n\n{\n  if (timer_handles[13] !\u003d (TIM_HandleTypeDef *)0x0) {\n    HAL_TIM_IRQHandler(timer_handles[13]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_TIM_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_i2c_obj": {
      "entrypoint": "0x0800387c",
      "current_name": "get_i2c_obj",
      "code": "\n/* WARNING: Unknown calling convention */\n\ni2c_t * get_i2c_obj(I2C_HandleTypeDef *hi2c)\n\n{\n  return (i2c_t *)\u0026hi2c[-1].EventCount;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_I2C_ErrorCallback",
        "HAL_I2C_AddrCallback",
        "HAL_I2C_ListenCpltCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_AddrCallback": {
      "entrypoint": "0x08003880",
      "current_name": "HAL_I2C_AddrCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c,uint8_t TransferDirection,uint16_t AddrMatchCode)\n\n{\n  i2c_t *piVar1;\n  i2c_t *obj;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if ((uint)AddrMatchCode \u003d\u003d (hi2c-\u003eInit).OwnAddress1) {\n    if (TransferDirection \u003d\u003d \u0027\\0\u0027) {\n      piVar1-\u003ei2cTxRxBufferSize \u003d \u0027\\0\u0027;\n      piVar1-\u003eslaveMode \u003d \u0027\\0\u0027;\n      if (piVar1-\u003ei2c_onSlaveTransmit !\u003d (_func_void *)0x0) {\n        (*piVar1-\u003ei2c_onSlaveTransmit)();\n      }\n      HAL_I2C_Slave_Sequential_Transmit_IT\n                (hi2c,piVar1-\u003ei2cTxRxBuffer,(ushort)piVar1-\u003ei2cTxRxBufferSize,8);\n      return;\n    }\n    piVar1-\u003eslaveMode \u003d \u0027\\x01\u0027;\n    HAL_I2C_Slave_Sequential_Receive_IT(hi2c,piVar1-\u003ei2cTxRxBuffer,0x20,8);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_Slave_ADDR"
      ],
      "called": [
        "HAL_I2C_Slave_Sequential_Transmit_IT",
        "HAL_I2C_Slave_Sequential_Receive_IT",
        "get_i2c_obj"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_ListenCpltCallback": {
      "entrypoint": "0x080038d0",
      "current_name": "HAL_I2C_ListenCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  i2c_t *piVar1;\n  i2c_t *obj;\n  uint uVar2;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if (((piVar1-\u003ei2c_onSlaveReceive !\u003d (_func_void_uint8_t_ptr_int *)0x0) \u0026\u0026\n      (piVar1-\u003eslaveMode \u003d\u003d \u0027\\x01\u0027)) \u0026\u0026\n     (uVar2 \u003d 0x20 - *(byte *)\u0026(piVar1-\u003ehandle).XferSize \u0026 0xff, uVar2 !\u003d 0)) {\n    (*piVar1-\u003ei2c_onSlaveReceive)(piVar1-\u003ei2cTxRxBuffer,uVar2);\n  }\n  HAL_I2C_EnableListen_IT(hi2c);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_Slave_AF",
        "I2C_ITError",
        "I2C_Slave_STOPF"
      ],
      "called": [
        "HAL_I2C_EnableListen_IT",
        "get_i2c_obj"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_I2C_ErrorCallback": {
      "entrypoint": "0x08003900",
      "current_name": "HAL_I2C_ErrorCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)\n\n{\n  i2c_t *piVar1;\n  i2c_t *obj;\n  \n  piVar1 \u003d get_i2c_obj(hi2c);\n  if (piVar1-\u003eisMaster \u003d\u003d \u0027\\0\u0027) {\n    HAL_I2C_EnableListen_IT(hi2c);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "I2C_ITError",
        "I2C_DMAAbort"
      ],
      "called": [
        "get_i2c_obj",
        "HAL_I2C_EnableListen_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C1_EV_IRQHandler": {
      "entrypoint": "0x08003918",
      "current_name": "I2C1_EV_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C1_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(i2c_handles);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C1_ER_IRQHandler": {
      "entrypoint": "0x08003928",
      "current_name": "I2C1_ER_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C1_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(i2c_handles);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C2_EV_IRQHandler": {
      "entrypoint": "0x08003938",
      "current_name": "I2C2_EV_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C2_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(I2C2_ER_IRQHandler::handle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C2_ER_IRQHandler": {
      "entrypoint": "0x08003948",
      "current_name": "I2C2_ER_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C2_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(I2C2_ER_IRQHandler::handle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C3_EV_IRQHandler": {
      "entrypoint": "0x08003958",
      "current_name": "I2C3_EV_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C3_EV_IRQHandler(void)\n\n{\n  HAL_I2C_EV_IRQHandler(I2C3_ER_IRQHandler::handle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_EV_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "I2C3_ER_IRQHandler": {
      "entrypoint": "0x08003968",
      "current_name": "I2C3_ER_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid I2C3_ER_IRQHandler(void)\n\n{\n  HAL_I2C_ER_IRQHandler(I2C3_ER_IRQHandler::handle);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_I2C_ER_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_init": {
      "entrypoint": "0x08003978",
      "current_name": "uart_init",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid uart_init(serial_t *obj)\n\n{\n  void *a;\n  USART_TypeDef *uart_tx;\n  void *b;\n  USART_TypeDef *uart_rx;\n  USART_TypeDef *pUVar1;\n  GPIO_TypeDef *pGVar2;\n  GPIO_TypeDef *port;\n  uint32_t uVar3;\n  UART_HandleTypeDef *huart;\n  uint32_t tmpreg;\n  uint32_t tmpreg_1;\n  uint32_t tmpreg_2;\n  uint32_t tmpreg_3;\n  uint32_t tmpreg_4;\n  uint32_t tmpreg_5;\n  uint32_t tmpreg_6;\n  uint32_t tmpreg_7;\n  GPIO_InitTypeDef GPIO_InitStruct;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    a \u003d pinmap_peripheral(obj-\u003epin_tx,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    b \u003d pinmap_peripheral(obj-\u003epin_rx,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    if ((b \u003d\u003d (void *)0x0) || (a \u003d\u003d (void *)0x0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\");\n    }\n    else {\n      pUVar1 \u003d (USART_TypeDef *)pinmap_merge_peripheral(a,b);\n      obj-\u003euart \u003d pUVar1;\n      if (pUVar1 \u003d\u003d (USART_TypeDef *)0x0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40011000) {\n          _DAT_40023824 \u003d _DAT_40023824 \u0026 0xffffffef;\n          _DAT_40023844 \u003d _DAT_40023844 | 0x10;\n          obj-\u003eindex \u003d \u0027\\0\u0027;\n          obj-\u003eirq \u003d USART1_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40004400) {\n          _DAT_40023820 \u003d _DAT_40023820 \u0026 0xfffdffff;\n          _DAT_40023840 \u003d _DAT_40023840 | 0x20000;\n          obj-\u003eindex \u003d \u0027\\x01\u0027;\n          obj-\u003eirq \u003d USART2_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40004800) {\n          _DAT_40023820 \u003d _DAT_40023820 \u0026 0xfffbffff;\n          _DAT_40023840 \u003d _DAT_40023840 | 0x40000;\n          obj-\u003eindex \u003d \u0027\\x02\u0027;\n          obj-\u003eirq \u003d USART3_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40004c00) {\n          _DAT_40023820 \u003d _DAT_40023820 \u0026 0xfff7ffff;\n          _DAT_40023840 \u003d _DAT_40023840 | 0x80000;\n          obj-\u003eindex \u003d \u0027\\x03\u0027;\n          obj-\u003eirq \u003d UART4_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40005000) {\n          _DAT_40023820 \u003d _DAT_40023820 \u0026 0xffefffff;\n          _DAT_40023840 \u003d _DAT_40023840 | 0x100000;\n          obj-\u003eindex \u003d \u0027\\x04\u0027;\n          obj-\u003eirq \u003d UART5_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40011400) {\n          _DAT_40023824 \u003d _DAT_40023824 \u0026 0xffffffdf;\n          _DAT_40023844 \u003d _DAT_40023844 | 0x20;\n          obj-\u003eindex \u003d \u0027\\x05\u0027;\n          obj-\u003eirq \u003d USART6_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40007800) {\n          _DAT_40023820 \u003d _DAT_40023820 \u0026 0xbfffffff;\n          _DAT_40023840 \u003d _DAT_40023840 | 0x40000000;\n          obj-\u003eindex \u003d \u0027\\x06\u0027;\n          obj-\u003eirq \u003d UART7_IRQn;\n        }\n        else if (pUVar1 \u003d\u003d (USART_TypeDef *)0x40007c00) {\n          _DAT_40023820 \u003d _DAT_40023820 \u0026 0x7fffffff;\n          _DAT_40023840 \u003d _DAT_40023840 | 0x80000000;\n          obj-\u003eindex \u003d \u0027\\a\u0027;\n          obj-\u003eirq \u003d UART8_IRQn;\n        }\n        pGVar2 \u003d set_GPIO_Port_Clock((uint)((int)obj-\u003epin_rx \u003c\u003c 0x18) \u003e\u003e 0x1c);\n        uVar3 \u003d pinmap_function(obj-\u003epin_rx,(PinMap_conflict *)\u0026PinMap_UART_RX);\n        GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (obj-\u003epin_rx \u0026 0xfU) \u0026 0xffff;\n        GPIO_InitStruct.Mode \u003d (uVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 4 | uVar3 \u0026 7;\n        GPIO_InitStruct.Pull \u003d (uVar3 \u003c\u003c 0x1a) \u003e\u003e 0x1e;\n        GPIO_InitStruct.Alternate \u003d (uVar3 \u003c\u003c 0x11) \u003e\u003e 0x19;\n        GPIO_InitStruct.Speed \u003d 3;\n        HAL_GPIO_Init(pGVar2,\u0026GPIO_InitStruct);\n        pGVar2 \u003d set_GPIO_Port_Clock((uint)((int)obj-\u003epin_tx \u003c\u003c 0x18) \u003e\u003e 0x1c);\n        uVar3 \u003d pinmap_function(obj-\u003epin_tx,(PinMap_conflict *)\u0026PinMap_UART_TX);\n        GPIO_InitStruct.Pin \u003d 1 \u003c\u003c (obj-\u003epin_tx \u0026 0xfU) \u0026 0xffff;\n        GPIO_InitStruct.Mode \u003d (uVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 4 | uVar3 \u0026 7;\n        GPIO_InitStruct.Pull \u003d (uVar3 \u003c\u003c 0x1a) \u003e\u003e 0x1e;\n        HAL_GPIO_Init(pGVar2,\u0026GPIO_InitStruct);\n        uart_handlers[obj-\u003eindex] \u003d \u0026obj-\u003ehandle;\n        (obj-\u003ehandle).Instance \u003d obj-\u003euart;\n        (obj-\u003ehandle).Init.BaudRate \u003d obj-\u003ebaudrate;\n        (obj-\u003ehandle).Init.WordLength \u003d obj-\u003edatabits;\n        (obj-\u003ehandle).Init.StopBits \u003d obj-\u003estopbits;\n        (obj-\u003ehandle).Init.Parity \u003d obj-\u003eparity;\n        (obj-\u003ehandle).Init.Mode \u003d 0xc;\n        (obj-\u003ehandle).Init.HwFlowCtl \u003d 0;\n        (obj-\u003ehandle).Init.OverSampling \u003d 0;\n        HAL_UART_Init(\u0026obj-\u003ehandle);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin",
        "uart_debug_init"
      ],
      "called": [
        "pinmap_peripheral",
        "pinmap_merge_peripheral",
        "iprintf",
        "HAL_GPIO_Init",
        "set_GPIO_Port_Clock",
        "HAL_UART_Init",
        "pinmap_function"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_debug_init": {
      "entrypoint": "0x08003cc8",
      "current_name": "uart_debug_init",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid uart_debug_init(void)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d pinmap_peripheral(PD_8,(PinMap_conflict *)\u0026PinMap_UART_TX);\n  if (pvVar1 !\u003d (void *)0x0) {\n    pvVar1 \u003d pinmap_peripheral(PD_8,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    serial_debug.pin_rx \u003d pinmap_pin(pvVar1,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    serial_debug.pin_tx \u003d PD_8;\n    serial_debug.baudrate \u003d 0x2580;\n    serial_debug.parity \u003d 0;\n    serial_debug.databits \u003d 0;\n    serial_debug.stopbits \u003d 0;\n    uart_init(\u0026serial_debug);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_debug_write"
      ],
      "called": [
        "pinmap_peripheral",
        "uart_init",
        "pinmap_pin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_debug_write": {
      "entrypoint": "0x08003d18",
      "current_name": "uart_debug_write",
      "code": "\n/* WARNING: Unknown calling convention */\n\nsize_t uart_debug_write(uint8_t *data,uint32_t size)\n\n{\n  HAL_StatusTypeDef HVar1;\n  uint32_t uVar2;\n  uint32_t tickstart;\n  void *pvVar3;\n  USART_TypeDef *pUVar4;\n  uint32_t uVar5;\n  uint uVar6;\n  \n  uVar2 \u003d HAL_GetTick();\n  pvVar3 \u003d pinmap_peripheral(PD_8,(PinMap_conflict *)\u0026PinMap_UART_TX);\n  if (pvVar3 \u003d\u003d (void *)0x0) {\n    return 0;\n  }\n  uVar6 \u003d 0;\n  while ((uVar6 \u003c 10 \u0026\u0026\n         ((uart_handlers[uVar6] \u003d\u003d (UART_HandleTypeDef *)0x0 ||\n          (pUVar4 \u003d (USART_TypeDef *)pinmap_peripheral(PD_8,(PinMap_conflict *)\u0026PinMap_UART_TX),\n          uart_handlers[uVar6]-\u003eInstance !\u003d pUVar4))))) {\n    uVar6 \u003d uVar6 + 1 \u0026 0xff;\n  }\n  if (9 \u003c uVar6) {\n    if ((9 \u003c serial_debug.index) \u0026\u0026 (uart_debug_init(), 9 \u003c serial_debug.index)) {\n      return 0;\n    }\n    uVar6 \u003d (uint)serial_debug.index;\n  }\n  do {\n    HVar1 \u003d HAL_UART_Transmit(uart_handlers[uVar6],data,(uint16_t)size,1000);\n    if (HVar1 \u003d\u003d HAL_OK) {\n      return size;\n    }\n    uVar5 \u003d HAL_GetTick();\n  } while (uVar5 - uVar2 \u003c 1000);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_write"
      ],
      "called": [
        "HAL_GetTick",
        "pinmap_peripheral",
        "HAL_UART_Transmit",
        "uart_debug_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_rx_active": {
      "entrypoint": "0x08003dd0",
      "current_name": "serial_rx_active",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t serial_rx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 \u003d HAL_UART_GetState(uart_handlers[obj-\u003eindex]);\n  return (HVar1 \u0026 0x22) \u003d\u003d 0x22;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_attach_rx_callback",
        "uart_getc"
      ],
      "called": [
        "HAL_UART_GetState"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serial_tx_active": {
      "entrypoint": "0x08003df4",
      "current_name": "serial_tx_active",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t serial_tx_active(serial_t *obj)\n\n{\n  HAL_UART_StateTypeDef HVar1;\n  \n  HVar1 \u003d HAL_UART_GetState(uart_handlers[obj-\u003eindex]);\n  return (HVar1 \u0026 0x21) \u003d\u003d 0x21;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [
        "HAL_UART_GetState"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_getc": {
      "entrypoint": "0x08003e18",
      "current_name": "uart_getc",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint uart_getc(serial_t *obj,uchar *c)\n\n{\n  uint8_t uVar1;\n  \n  if (obj \u003d\u003d (serial_t *)0x0) {\n    return -1;\n  }\n  uVar1 \u003d serial_rx_active(obj);\n  if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n    *c \u003d obj-\u003erecv;\n    HAL_UART_Receive_IT(uart_handlers[obj-\u003eindex],\u0026obj-\u003erecv,1);\n    return 0;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_rx_complete_irq"
      ],
      "called": [
        "serial_rx_active",
        "HAL_UART_Receive_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_attach_rx_callback": {
      "entrypoint": "0x08003e54",
      "current_name": "uart_attach_rx_callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid uart_attach_rx_callback(serial_t *obj,_func_void_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  uint8_t uVar2;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    uVar2 \u003d serial_rx_active(obj);\n    if (uVar2 \u003d\u003d \u0027\\0\u0027) {\n      bVar1 \u003d obj-\u003eindex;\n      rx_callback[bVar1] \u003d callback;\n      rx_callback_obj[bVar1] \u003d obj;\n      HAL_NVIC_SetPriority(obj-\u003eirq,0,1);\n      HAL_NVIC_EnableIRQ(obj-\u003eirq);\n      HAL_UART_Receive_IT(uart_handlers[obj-\u003eindex],\u0026obj-\u003erecv,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "HAL_NVIC_SetPriority",
        "HAL_NVIC_EnableIRQ",
        "serial_rx_active",
        "HAL_UART_Receive_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_attach_tx_callback": {
      "entrypoint": "0x08003eac",
      "current_name": "uart_attach_tx_callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid uart_attach_tx_callback(serial_t *obj,_func_int_serial_t_ptr *callback)\n\n{\n  byte bVar1;\n  \n  if (obj !\u003d (serial_t *)0x0) {\n    bVar1 \u003d obj-\u003eindex;\n    tx_callback[bVar1] \u003d callback;\n    tx_callback_obj[bVar1] \u003d obj;\n    HAL_NVIC_SetPriority(obj-\u003eirq,0,2);\n    HAL_NVIC_EnableIRQ(obj-\u003eirq);\n    HAL_UART_Transmit_IT(uart_handlers[obj-\u003eindex],obj-\u003etx_buff + obj-\u003etx_tail,1);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [
        "HAL_NVIC_SetPriority",
        "HAL_NVIC_EnableIRQ",
        "HAL_UART_Transmit_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "uart_index": {
      "entrypoint": "0x08003f00",
      "current_name": "uart_index",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t uart_index(UART_HandleTypeDef *huart)\n\n{\n  uint uVar1;\n  \n  if (huart \u003d\u003d (UART_HandleTypeDef *)0x0) {\n    uVar1 \u003d 10;\n  }\n  else {\n    uVar1 \u003d 0;\n    while( true ) {\n      if (9 \u003c uVar1) {\n        return (uint8_t)uVar1;\n      }\n      if (huart \u003d\u003d uart_handlers[uVar1]) break;\n      uVar1 \u003d uVar1 + 1 \u0026 0xff;\n    }\n  }\n  return (uint8_t)uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_UART_RxCpltCallback",
        "HAL_UART_TxCpltCallback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_RxCpltCallback": {
      "entrypoint": "0x08003f24",
      "current_name": "HAL_UART_RxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint8_t index;\n  uint uVar2;\n  \n  bVar1 \u003d uart_index(huart);\n  uVar2 \u003d (uint)bVar1;\n  if (uVar2 \u003c 10) {\n    (*rx_callback[uVar2])(rx_callback_obj[uVar2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_Receive_IT"
      ],
      "called": [
        "uart_index"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_TxCpltCallback": {
      "entrypoint": "0x08003f48",
      "current_name": "HAL_UART_TxCpltCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)\n\n{\n  byte bVar1;\n  uint8_t index;\n  int iVar3;\n  serial_t *obj;\n  serial_t *psVar4;\n  uint uVar2;\n  \n  bVar1 \u003d uart_index(huart);\n  uVar2 \u003d (uint)bVar1;\n  psVar4 \u003d tx_callback_obj[uVar2];\n  if ((uVar2 \u003c 10) \u0026\u0026 (iVar3 \u003d (*tx_callback[uVar2])(psVar4), iVar3 !\u003d -1)) {\n    HAL_UART_Transmit_IT(uart_handlers[psVar4-\u003eindex],psVar4-\u003etx_buff + psVar4-\u003etx_tail,1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_EndTransmit_IT"
      ],
      "called": [
        "uart_index",
        "HAL_UART_Transmit_IT"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_UART_ErrorCallback": {
      "entrypoint": "0x08003f94",
      "current_name": "HAL_UART_ErrorCallback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)\n\n{\n  uint32_t tmpval;\n  \n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "UART_DMAAbortOnError",
        "HAL_UART_IRQHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART1_IRQHandler": {
      "entrypoint": "0x08003fd4",
      "current_name": "USART1_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART1_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART1_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[0]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART2_IRQHandler": {
      "entrypoint": "0x08003fec",
      "current_name": "USART2_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART2_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART2_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[1]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART3_IRQHandler": {
      "entrypoint": "0x08004004",
      "current_name": "USART3_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART3_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART3_IRQn);\n  if (uart_handlers[2] !\u003d (UART_HandleTypeDef *)0x0) {\n    HAL_UART_IRQHandler(uart_handlers[2]);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART4_IRQHandler": {
      "entrypoint": "0x0800401c",
      "current_name": "UART4_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART4_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART4_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[3]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART5_IRQHandler": {
      "entrypoint": "0x08004034",
      "current_name": "UART5_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART5_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART5_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[4]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART6_IRQHandler": {
      "entrypoint": "0x0800404c",
      "current_name": "USART6_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART6_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(USART6_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[5]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART7_IRQHandler": {
      "entrypoint": "0x08004064",
      "current_name": "UART7_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART7_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART7_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[6]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART8_IRQHandler": {
      "entrypoint": "0x0800407c",
      "current_name": "UART8_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART8_IRQHandler(void)\n\n{\n  HAL_NVIC_ClearPendingIRQ(UART8_IRQn);\n  HAL_UART_IRQHandler(uart_handlers[7]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_NVIC_ClearPendingIRQ",
        "HAL_UART_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk": {
      "entrypoint": "0x08004094",
      "current_name": "_sbrk",
      "code": "\nvoid * _sbrk(intptr_t __delta)\n\n{\n  char *pcVar1;\n  char *prev_heap_end;\n  \n  if (_sbrk::heap_end \u003d\u003d (char *)0x0) {\n    _sbrk::heap_end \u003d \u0026_ebss;\n  }\n  pcVar1 \u003d _sbrk::heap_end;\n  if (_sbrk::heap_end + __delta \u003c\u003d \u0026stack0x00000000) {\n    _sbrk::heap_end \u003d _sbrk::heap_end + __delta;\n    return pcVar1;\n  }\n  errno \u003d 0xc;\n  return (void *)0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_sbrk_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close": {
      "entrypoint": "0x080040d0",
      "current_name": "_close",
      "code": "\nint _close(int __fd)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_close_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat": {
      "entrypoint": "0x080040d6",
      "current_name": "_fstat",
      "code": "\nint _fstat(int __fd,stat *__buf)\n\n{\n  *(undefined4 *)((int)\u0026__buf-\u003est_dev + 4) \u003d 0x2000;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fstat_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty": {
      "entrypoint": "0x080040e0",
      "current_name": "_isatty",
      "code": "\nint _isatty(int __fd)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_isatty_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek": {
      "entrypoint": "0x080040e4",
      "current_name": "_lseek",
      "code": "\n__off_t _lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_lseek_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read": {
      "entrypoint": "0x080040e8",
      "current_name": "_read",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _read(int file_UNUSED,char *ptr_UNUSED,int len_UNUSED)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_read_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write": {
      "entrypoint": "0x080040ec",
      "current_name": "_write",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _write(int file_UNUSED,char *ptr,int len)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d uart_debug_write((uint8_t *)ptr,len);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_write_r"
      ],
      "called": [
        "uart_debug_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_exit": {
      "entrypoint": "0x080040f8",
      "current_name": "_exit",
      "code": "\nvoid _exit(int __status)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "abort",
        "_exit"
      ],
      "called": [
        "_exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_kill": {
      "entrypoint": "0x080040fc",
      "current_name": "_kill",
      "code": "\nint _kill(__pid_t __pid,int __sig)\n\n{\n  errno \u003d 0x16;\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_kill_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getpid": {
      "entrypoint": "0x0800410c",
      "current_name": "_getpid",
      "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_getpid_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinMode": {
      "entrypoint": "0x08004110",
      "current_name": "pinMode",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pinMode(uint32_t ulPin,uint32_t ulMode)\n\n{\n  _Bool _Var1;\n  PinName_conflict p;\n  \n  if (ulPin \u003c 0x60) {\n    p \u003d *(PinName_conflict *)(\u0026digitalPin + ulPin * 2);\n  }\n  else {\n    p \u003d NC;\n  }\n  if (p !\u003d NC) {\n    _Var1 \u003d is_pin_configured(p,g_anOutputPinConfigured);\n    if (_Var1) {\n      _Var1 \u003d pin_in_pinmap(p,(PinMap_conflict *)\u0026PinMap_DAC);\n      if (_Var1) {\n        dac_stop(p);\n      }\n      else {\n        _Var1 \u003d pin_in_pinmap(p,(PinMap_conflict *)\u0026PinMap_PWM);\n        if (_Var1) {\n          pwm_stop(p);\n        }\n      }\n      reset_pin_configured(p,g_anOutputPinConfigured);\n    }\n    switch(ulMode) {\n    case 0:\n      digital_io_init(p,0,0);\n      break;\n    case 1:\n      digital_io_init(p,1,0);\n      break;\n    case 2:\n      digital_io_init(p,0,1);\n      break;\n    case 3:\n      digital_io_init(p,0,2);\n    }\n    set_pin_configured(p,g_digPinConfigured);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "digital_io_init",
        "dac_stop",
        "reset_pin_configured",
        "is_pin_configured",
        "set_pin_configured",
        "pwm_stop",
        "pin_in_pinmap"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digitalWrite": {
      "entrypoint": "0x080041bc",
      "current_name": "digitalWrite",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid digitalWrite(uint32_t ulPin,uint32_t ulVal)\n\n{\n  _Bool _Var1;\n  GPIO_TypeDef *port;\n  PinName_conflict p;\n  uint uVar2;\n  \n  if (ulPin \u003c 0x60) {\n    uVar2 \u003d (uint)*(short *)(\u0026digitalPin + ulPin * 2);\n  }\n  else {\n    uVar2 \u003d 0xffffffff;\n  }\n  if ((uVar2 !\u003d 0xffffffff) \u0026\u0026\n     (_Var1 \u003d is_pin_configured((PinName_conflict)uVar2,g_digPinConfigured), _Var1)) {\n    port \u003d get_GPIO_Port((uVar2 \u003c\u003c 0x18) \u003e\u003e 0x1c);\n    digital_io_write(port,1 \u003c\u003c (uVar2 \u0026 0xf) \u0026 0xffff,ulVal);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "sendTxBuffer",
        "begin",
        "getRxBuffer"
      ],
      "called": [
        "digital_io_write",
        "is_pin_configured",
        "get_GPIO_Port"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "millis": {
      "entrypoint": "0x08004204",
      "current_name": "millis",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t millis(void)\n\n{\n  uint32_t uVar1;\n  \n  uVar1 \u003d GetCurrentMilli();\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "sendTxBuffer",
        "poll"
      ],
      "called": [
        "GetCurrentMilli"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_tx_complete_irq": {
      "entrypoint": "0x0800420c",
      "current_name": "_tx_complete_irq",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint HardwareSerial::_tx_complete_irq(serial_t_conflict *obj)\n\n{\n  ushort uVar1;\n  uint16_t uVar2;\n  int iVar3;\n  \n  iVar3 \u003d obj-\u003etx_tail + 1;\n  uVar1 \u003d (ushort)iVar3;\n  uVar2 \u003d uVar1 \u0026 0x7f;\n  if (iVar3 \u003d\u003d 0) {\n    uVar2 \u003d -(-uVar1 \u0026 0x7f);\n  }\n  obj-\u003etx_tail \u003d uVar2;\n  if (obj-\u003etx_head !\u003d obj-\u003etx_tail) {\n    return 0;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "available": {
      "entrypoint": "0x08004240",
      "current_name": "available",
      "code": "\n/* DWARF original prototype: int  available(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::available(HardwareSerial *this)\n\n{\n  return ((this-\u003e_serial).rx_head + 0x40) - (uint)(this-\u003e_serial).rx_tail \u0026 0x3f;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "peek": {
      "entrypoint": "0x08004254",
      "current_name": "peek",
      "code": "\n/* DWARF original prototype: int  peek(HardwareSerial * this) */\n\nint __thiscall HardwareSerial::peek(HardwareSerial *this)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d (uint)(this-\u003e_serial).rx_tail;\n  if ((this-\u003e_serial).rx_head !\u003d uVar1) {\n    return (uint)(this-\u003e_serial).rx_buff[uVar1];\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read": {
      "entrypoint": "0x08004270",
      "current_name": "read",
      "code": "\n/* DWARF original prototype: int  read(HardwareSerial * this) */\n\nssize_t __thiscall HardwareSerial::read(HardwareSerial *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  ushort uVar2;\n  uchar c;\n  \n  uVar2 \u003d (this-\u003e_serial).rx_tail;\n  if ((uint)(this-\u003e_serial).rx_head !\u003d (uint)uVar2) {\n    bVar1 \u003d (this-\u003e_serial).rx_buff[uVar2];\n    (this-\u003e_serial).rx_tail \u003d uVar2 + 1 \u0026 0x3f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "flush": {
      "entrypoint": "0x08004298",
      "current_name": "flush",
      "code": "\n/* DWARF original prototype: void  flush(HardwareSerial * this) */\n\nvoid __thiscall HardwareSerial::flush(HardwareSerial *this)\n\n{\n  if (this-\u003e_written !\u003d false) {\n    do {\n    } while ((this-\u003e_serial).tx_head !\u003d (this-\u003e_serial).tx_tail);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_rx_complete_irq": {
      "entrypoint": "0x080042ac",
      "current_name": "_rx_complete_irq",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HardwareSerial::_rx_complete_irq(serial_t_conflict *obj)\n\n{\n  int iVar1;\n  rx_buffer_index_t i;\n  ushort uVar2;\n  uchar c;\n  \n  iVar1 \u003d uart_getc((serial_t *)obj,\u0026c);\n  if ((iVar1 \u003d\u003d 0) \u0026\u0026 (uVar2 \u003d obj-\u003erx_head + 1 \u0026 0x3f, uVar2 !\u003d obj-\u003erx_tail)) {\n    obj-\u003erx_buff[obj-\u003erx_head] \u003d c;\n    obj-\u003erx_head \u003d uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "uart_getc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write": {
      "entrypoint": "0x0800459a",
      "current_name": "write",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x080045ae */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  write(Print * this, uint8_t * buffer, size_t size) */\n\nssize_t __thiscall Print::write(Print *this,int __fd,void *__buf,size_t __n)\n\n{\n  Print *pPVar1;\n  int iVar2;\n  \n  iVar2 \u003d 0;\n  pPVar1 \u003d this;\n  while( true ) {\n    if (__buf \u003d\u003d (void *)0x0) {\n      return iVar2;\n    }\n    pPVar1 \u003d (Print *)(**this-\u003e_vptr_Print)(pPVar1,(uint)*(byte *)__fd,__buf,*this-\u003e_vptr_Print,__n)\n    ;\n    if (pPVar1 \u003d\u003d (Print *)0x0) break;\n    iVar2 \u003d iVar2 + 1;\n    __fd \u003d (int)(__fd + 1);\n    __buf \u003d (void *)((int)__buf + -1);\n  }\n  return iVar2;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEventRun": {
      "entrypoint": "0x08004338",
      "current_name": "serialEventRun",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0800433e) */\n/* WARNING: Removing unreachable block (ram,0x08004350) */\n/* WARNING: Removing unreachable block (ram,0x08004346) */\n/* WARNING: Removing unreachable block (ram,0x08004358) */\n/* WARNING: Unknown calling convention */\n\nvoid serialEventRun(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "available"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setRx": {
      "entrypoint": "0x08004444",
      "current_name": "setRx",
      "code": "\n/* DWARF original prototype: void  setRx(HardwareSerial * this, uint32_t _rx) */\n\nvoid __thiscall HardwareSerial::setRx(HardwareSerial *this,uint32_t _rx)\n\n{\n  PinName PVar1;\n  \n  if (_rx \u003c 0x60) {\n    PVar1 \u003d *(PinName *)(\u0026digitalPin + _rx * 2);\n  }\n  else {\n    PVar1 \u003d NC;\n  }\n  (this-\u003e_serial).pin_rx \u003d PVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setTx": {
      "entrypoint": "0x08004460",
      "current_name": "setTx",
      "code": "\n/* DWARF original prototype: void  setTx(HardwareSerial * this, uint32_t _tx) */\n\nvoid __thiscall HardwareSerial::setTx(HardwareSerial *this,uint32_t _tx)\n\n{\n  PinName PVar1;\n  \n  if (_tx \u003c 0x60) {\n    PVar1 \u003d *(PinName *)(\u0026digitalPin + _tx * 2);\n  }\n  else {\n    PVar1 \u003d NC;\n  }\n  (this-\u003e_serial).pin_tx \u003d PVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HardwareSerial"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HardwareSerial": {
      "entrypoint": "0x0800447c",
      "current_name": "HardwareSerial",
      "code": "\n/* DWARF original prototype: HardwareSerial *  HardwareSerial(HardwareSerial * this, void *\n   peripheral) */\n\nHardwareSerial * __thiscall HardwareSerial::HardwareSerial(HardwareSerial *this,void *peripheral)\n\n{\n  PinName_conflict PVar1;\n  EVP_PKEY_CTX *extraout_r1;\n  EVP_PKEY_CTX *ctx;\n  EVP_PKEY_CTX *extraout_r1_00;\n  \n  (this-\u003esuper_Stream).super_Print.write_error \u003d 0;\n  (this-\u003esuper_Stream)._timeout \u003d 1000;\n  (this-\u003esuper_Stream).super_Print._vptr_Print \u003d (_func_int_varargs **)\u0026PTR_write_1_08005ed4;\n  if (this \u003d\u003d \u0026Serial3) {\n    setRx(\u0026Serial3,0x4c);\n    setTx(\u0026Serial3,0x4d);\n    ctx \u003d extraout_r1_00;\n  }\n  else {\n    PVar1 \u003d pinmap_pin(peripheral,(PinMap_conflict *)\u0026PinMap_UART_RX);\n    (this-\u003e_serial).pin_rx \u003d PVar1;\n    PVar1 \u003d pinmap_pin(peripheral,(PinMap_conflict *)\u0026PinMap_UART_TX);\n    (this-\u003e_serial).pin_tx \u003d PVar1;\n    ctx \u003d extraout_r1;\n  }\n  init(this,ctx);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "init",
        "setTx",
        "pinmap_pin",
        "setRx"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_Serial3": {
      "entrypoint": "0x080044fc",
      "current_name": "_GLOBAL__sub_I_Serial3",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I_Serial3(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printTo": {
      "entrypoint": "0x0800450a",
      "current_name": "printTo",
      "code": "\n/* DWARF original prototype: size_t  printTo(IPAddress * this, Print * p) */\n\nsize_t __thiscall IPAddress::printTo(IPAddress *this,Print *p)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  int iVar3;\n  int iVar4;\n  \n  iVar4 \u003d 0;\n  for (iVar3 \u003d 0; iVar3 \u003c 3; iVar3 \u003d iVar3 + 1) {\n    sVar1 \u003d Print::print(p,(this-\u003e_address).bytes[iVar3],10);\n    sVar2 \u003d Print::print(p,\u0027.\u0027);\n    iVar4 \u003d iVar4 + sVar1 + sVar2;\n  }\n  sVar1 \u003d Print::print(p,(this-\u003e_address).bytes[3],10);\n  return sVar1 + iVar4;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "print",
        "print"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "IPAddress": {
      "entrypoint": "0x08004544",
      "current_name": "IPAddress",
      "code": "\n/* DWARF original prototype: IPAddress *  IPAddress(IPAddress * this, uint8_t first_octet, uint8_t\n   second_octet, uint8_t third_octet, uint8_t fourth_octet) */\n\nIPAddress * __thiscall\nIPAddress::IPAddress\n          (IPAddress *this,uint8_t first_octet,uint8_t second_octet,uint8_t third_octet,\n          uint8_t fourth_octet)\n\n{\n  (this-\u003esuper_Printable)._vptr_Printable \u003d (_func_int_varargs **)\u0026DAT_08005f28;\n  (this-\u003e_address).bytes[0] \u003d first_octet;\n  (this-\u003e_address).bytes[1] \u003d second_octet;\n  (this-\u003e_address).bytes[2] \u003d third_octet;\n  (this-\u003e_address).bytes[3] \u003d fourth_octet;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I__ZN9IPAddressC2Ev": {
      "entrypoint": "0x0800458c",
      "current_name": "_GLOBAL__sub_I__ZN9IPAddressC2Ev",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I__ZN9IPAddressC2Ev(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print": {
      "entrypoint": "0x08004638",
      "current_name": "print",
      "code": "\n/* DWARF original prototype: size_t  print(Print * this, uchar b, int base) */\n\nsize_t __thiscall Print::print(Print *this,uchar b,int base)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d print(this,(uint)b,base);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "printTo"
      ],
      "called": [
        "print"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printNumber": {
      "entrypoint": "0x080045c8",
      "current_name": "printNumber",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x08004618 */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  printNumber(Print * this, ulong n, uint8_t base) */\n\nsize_t __thiscall Print::printNumber(Print *this,ulong n,uint8_t base)\n\n{\n  char cVar1;\n  char c;\n  size_t sVar2;\n  size_t sVar3;\n  ulong m;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  char *__s;\n  char buf [33];\n  \n  uVar5 \u003d (uint)base;\n  buf[32] \u003d \u0027\\0\u0027;\n  if (uVar5 \u003c 2) {\n    uVar5 \u003d 10;\n  }\n  __s \u003d buf + 0x20;\n  m \u003d n;\n  do {\n    uVar6 \u003d m / uVar5;\n    uVar4 \u003d (m \u0026 0xff) - ((int)(short)uVar6 * (int)(short)uVar5 \u0026 0xffU) \u0026 0xff;\n    __s \u003d __s + -1;\n    cVar1 \u003d (char)uVar4;\n    if (uVar4 \u003c 10) {\n      cVar1 \u003d cVar1 + \u00270\u0027;\n    }\n    else {\n      cVar1 \u003d cVar1 + \u00277\u0027;\n    }\n    *__s \u003d cVar1;\n    m \u003d uVar6;\n  } while (uVar6 !\u003d 0);\n  if (__s \u003d\u003d (char *)0x0) {\n    sVar3 \u003d 0;\n  }\n  else {\n    sVar2 \u003d strlen(__s);\n    sVar3 \u003d (*this-\u003e_vptr_Print[1])(sVar2,__s,sVar2);\n  }\n  return sVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "print"
      ],
      "called": [
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "makeWord": {
      "entrypoint": "0x08004640",
      "current_name": "makeWord",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint16_t makeWord(uint8_t h,uint8_t l)\n\n{\n  return CONCAT11(h,l);\n}\n\n",
      "renaming": {},
      "calling": [
        "process_FC16",
        "validateRequest",
        "process_FC3",
        "process_FC6",
        "process_FC15",
        "process_FC5",
        "process_FC1"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "initVariant": {
      "entrypoint": "0x08004646",
      "current_name": "initVariant",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initVariant(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "premain": {
      "entrypoint": "0x08004648",
      "current_name": "premain",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid premain(void)\n\n{\n  EVP_PKEY_CTX *ctx;\n  \n  ctx \u003d (EVP_PKEY_CTX *)0x3;\n  HAL_NVIC_SetPriorityGrouping(3);\n  init(ctx);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [
        "init",
        "HAL_NVIC_SetPriorityGrouping"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main": {
      "entrypoint": "0x08004658",
      "current_name": "main",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint main(void)\n\n{\n  initVariant();\n  setup();\n  do {\n    loop();\n    serialEventRun();\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "initVariant",
        "loop",
        "setup",
        "serialEventRun"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "get_pin_id": {
      "entrypoint": "0x08004678",
      "current_name": "get_pin_id",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint8_t get_pin_id(uint16_t pin)\n\n{\n  uint uVar1;\n  uint8_t uVar2;\n  \n  uVar2 \u003d \u0027\\0\u0027;\n  for (uVar1 \u003d (uint)pin; uVar1 !\u003d 1; uVar1 \u003d uVar1 \u003e\u003e 1) {\n    uVar2 \u003d uVar2 + \u0027\\x01\u0027;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__tcf_0": {
      "entrypoint": "0x0800468c",
      "current_name": "__tcf_0",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid __tcf_0(void *param_1)\n\n{\n  gpio_irq_conf_str *pgVar1;\n  _Manager_type p_Var2;\n  gpio_irq_conf_str *pgVar3;\n  \n  pgVar1 \u003d (gpio_irq_conf_str *)\u0026__malloc_free_list;\n  while (pgVar3 \u003d pgVar1, pgVar3 !\u003d gpio_irq_conf) {\n    p_Var2 \u003d pgVar3[-1].callback.super__Function_base._M_manager;\n    pgVar1 \u003d pgVar3 + -1;\n    if (p_Var2 !\u003d (_Manager_type)0x0) {\n      (*p_Var2)((_Any_data *)\u0026pgVar3[-1].callback,(_Any_data *)\u0026pgVar3[-1].callback,\n                __destroy_functor);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI0_IRQHandler": {
      "entrypoint": "0x08004760",
      "current_name": "EXTI0_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI0_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI1_IRQHandler": {
      "entrypoint": "0x0800476a",
      "current_name": "EXTI1_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI1_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI2_IRQHandler": {
      "entrypoint": "0x08004774",
      "current_name": "EXTI2_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI2_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI3_IRQHandler": {
      "entrypoint": "0x0800477e",
      "current_name": "EXTI3_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI3_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI4_IRQHandler": {
      "entrypoint": "0x08004788",
      "current_name": "EXTI4_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI4_IRQHandler(void)\n\n{\n  HAL_GPIO_EXTI_IRQHandler(0x10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI9_5_IRQHandler": {
      "entrypoint": "0x08004792",
      "current_name": "EXTI9_5_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI9_5_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0x20; uVar1 \u003c 0x201; uVar1 \u003d uVar1 \u003c\u003c 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "EXTI15_10_IRQHandler": {
      "entrypoint": "0x080047a8",
      "current_name": "EXTI15_10_IRQHandler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid EXTI15_10_IRQHandler(void)\n\n{\n  uint uVar1;\n  \n  for (uVar1 \u003d 0x400; uVar1 \u003c 0x8001; uVar1 \u003d uVar1 \u003c\u003c 1) {\n    HAL_GPIO_EXTI_IRQHandler((uint16_t)uVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "operator()": {
      "entrypoint": "0x080047c0",
      "current_name": "operator()",
      "code": "\n/* DWARF original prototype: void  operator()(function\u003cvoid()\u003e * this) */\n\nvoid __thiscall std::function\u003cvoid()\u003e::operator()(function\u003cvoid()\u003e *this)\n\n{\n  if ((this-\u003esuper__Function_base)._M_manager !\u003d (_Manager_type)0x0) {\n    (*this-\u003e_M_invoker)((_Any_data *)this);\n    return;\n  }\n                    \n  __throw_bad_function_call();\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_Callback"
      ],
      "called": [
        "__throw_bad_function_call"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "HAL_GPIO_EXTI_Callback": {
      "entrypoint": "0x080047d0",
      "current_name": "HAL_GPIO_EXTI_Callback",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)\n\n{\n  byte bVar1;\n  uint8_t irq_id;\n  \n  bVar1 \u003d get_pin_id(GPIO_Pin);\n  if (gpio_irq_conf[bVar1].callback.super__Function_base._M_manager !\u003d (_Manager_type)0x0) {\n    std::function\u003cvoid()\u003e::operator()(\u0026gpio_irq_conf[bVar1].callback);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "HAL_GPIO_EXTI_IRQHandler"
      ],
      "called": [
        "get_pin_id",
        "operator()"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm": {
      "entrypoint": "0x080047f0",
      "current_name": "_GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I__Z22stm32_interrupt_enableP12GPIO_TypeDeftSt8functionIFvvEEm(void)\n\n{\n  __static_initialization_and_destruction_0(1,0xffff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__static_initialization_and_destruction_0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_atexit": {
      "entrypoint": "0x080047fe",
      "current_name": "__aeabi_atexit",
      "code": "\nvoid __aeabi_atexit(undefined4 param_1,undefined4 param_2)\n\n{\n  __cxa_atexit(param_2,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__static_initialization_and_destruction_0"
      ],
      "called": [
        "__cxa_atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__assert_func": {
      "entrypoint": "0x08004808",
      "current_name": "__assert_func",
      "code": "\nvoid __assert_func(undefined4 param_1,undefined4 param_2,char *param_3,undefined4 param_4)\n\n{\n  char *pcVar1;\n  \n  if (param_3 \u003d\u003d (char *)0x0) {\n    param_3 \u003d \"\";\n    pcVar1 \u003d param_3;\n  }\n  else {\n    pcVar1 \u003d \", function: \";\n  }\n  fiprintf(*(FILE **)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           param_4,param_1,param_2,pcVar1,param_3,param_4);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "begin"
      ],
      "called": [
        "abort",
        "fiprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_atexit": {
      "entrypoint": "0x08004844",
      "current_name": "__cxa_atexit",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0800484c) */\n\nlonglong __cxa_atexit(undefined4 param_1,uint param_2)\n\n{\n  return (ulonglong)param_2 \u003c\u003c 0x20;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_atexit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fiprintf": {
      "entrypoint": "0x08004860",
      "current_name": "fiprintf",
      "code": "\nint fiprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 \u003d in_r2;\n  uStack_4 \u003d in_r3;\n  iVar1 \u003d _vfiprintf_r(_impure_ptr,__stream,__format,\u0026uStack_8,__stream,\u0026uStack_8);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__assert_func"
      ],
      "called": [
        "_vfiprintf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_init_array": {
      "entrypoint": "0x08004884",
      "current_name": "__libc_init_array",
      "code": "\nvoid __libc_init_array(void)\n\n{\n  int iVar1;\n  \n  for (iVar1 \u003d 0; iVar1 !\u003d 0; iVar1 \u003d iVar1 + 1) {\n    (*(code *)(\u0026__preinit_array_end)[iVar1])();\n  }\n  _init();\n  for (iVar1 \u003d 0; iVar1 !\u003d 10; iVar1 \u003d iVar1 + 1) {\n    (*(code *)(\u0026__preinit_array_end)[iVar1])();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "premain",
        "_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memset": {
      "entrypoint": "0x080048cc",
      "current_name": "memset",
      "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  undefined *puVar1;\n  \n  for (puVar1 \u003d (undefined *)__s; puVar1 !\u003d (undefined *)(__n + (int)__s); puVar1 \u003d puVar1 + 1) {\n    *puVar1 \u003d (char)__c;\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfp",
        "std.isra.0",
        "__sfmoreglue"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_free_r": {
      "entrypoint": "0x080048dc",
      "current_name": "_free_r",
      "code": "\nvoid _free_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int *piVar1;\n  int **extraout_r1;\n  int **ppiVar2;\n  int **ppiVar3;\n  int **ppiVar4;\n  int **ppiVar5;\n  bool bVar6;\n  \n  if (param_2 \u003d\u003d 0) {\n    return;\n  }\n  ppiVar5 \u003d (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) \u003c 0) {\n    ppiVar5 \u003d (int **)((int)ppiVar5 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  ppiVar3 \u003d (int **)\u0026__malloc_free_list;\n  if (__malloc_free_list \u003d\u003d (int **)0x0) {\n    ppiVar5[1] \u003d (int *)0x0;\n    ppiVar2 \u003d extraout_r1;\n    __malloc_free_list \u003d ppiVar5;\n  }\n  else {\n    ppiVar3 \u003d __malloc_free_list;\n    if (ppiVar5 \u003c __malloc_free_list) {\n      ppiVar2 \u003d (int **)*ppiVar5;\n      ppiVar3 \u003d (int **)((int)ppiVar5 + (int)ppiVar2);\n      bVar6 \u003d __malloc_free_list \u003d\u003d ppiVar3;\n      if (bVar6) {\n        ppiVar3 \u003d (int **)*__malloc_free_list;\n        __malloc_free_list \u003d (int **)__malloc_free_list[1];\n      }\n      ppiVar5[1] \u003d (int *)__malloc_free_list;\n      __malloc_free_list \u003d ppiVar5;\n      if (bVar6) {\n        ppiVar3 \u003d (int **)((int)ppiVar3 + (int)ppiVar2);\n        *ppiVar5 \u003d (int *)ppiVar3;\n      }\n    }\n    else {\n      do {\n        ppiVar4 \u003d ppiVar3;\n        ppiVar3 \u003d (int **)ppiVar4[1];\n        if (ppiVar3 \u003d\u003d (int **)0x0) break;\n      } while (ppiVar3 \u003c\u003d ppiVar5);\n      ppiVar2 \u003d (int **)*ppiVar4;\n      if ((int **)((int)ppiVar4 + (int)ppiVar2) \u003d\u003d ppiVar5) {\n        ppiVar2 \u003d (int **)((int)ppiVar2 + (int)*ppiVar5);\n        *ppiVar4 \u003d (int *)ppiVar2;\n        if (ppiVar3 \u003d\u003d (int **)((int)ppiVar4 + (int)ppiVar2)) {\n          piVar1 \u003d *ppiVar3;\n          ppiVar3 \u003d (int **)ppiVar3[1];\n          ppiVar4[1] \u003d (int *)ppiVar3;\n          ppiVar2 \u003d (int **)((int)ppiVar2 + (int)piVar1);\n          *ppiVar4 \u003d (int *)ppiVar2;\n        }\n      }\n      else if (ppiVar5 \u003c (int **)((int)ppiVar4 + (int)ppiVar2)) {\n        *param_1 \u003d 0xc;\n      }\n      else {\n        ppiVar2 \u003d (int **)((int)ppiVar5 + (int)*ppiVar5);\n        bVar6 \u003d ppiVar3 \u003d\u003d ppiVar2;\n        if (bVar6) {\n          ppiVar2 \u003d (int **)*ppiVar3;\n          ppiVar3 \u003d (int **)ppiVar3[1];\n        }\n        ppiVar5[1] \u003d (int *)ppiVar3;\n        if (bVar6) {\n          ppiVar2 \u003d (int **)((int)ppiVar2 + (int)*ppiVar5);\n          *ppiVar5 \u003d (int *)ppiVar2;\n        }\n        ppiVar4[1] \u003d (int *)ppiVar5;\n      }\n    }\n  }\n  __malloc_unlock(param_1,ppiVar2,ppiVar3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r",
        "__sflush_r"
      ],
      "called": [
        "__malloc_unlock",
        "__malloc_lock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_r": {
      "entrypoint": "0x08004978",
      "current_name": "_malloc_r",
      "code": "\nuint _malloc_r(undefined4 *param_1,uint param_2)\n\n{\n  uint *puVar1;\n  int iVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint *puVar5;\n  uint uVar6;\n  \n  uVar6 \u003d (param_2 + 3 \u0026 0xfffffffc) + 8;\n  if (uVar6 \u003c 0xc) {\n    uVar6 \u003d 0xc;\n  }\n  if (((int)uVar6 \u003c 0) || (uVar6 \u003c param_2)) {\n    *param_1 \u003d 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 \u003d __malloc_free_list;\n    puVar5 \u003d __malloc_free_list;\n    while (puVar3 \u003d puVar1, puVar3 !\u003d (uint *)0x0) {\n      uVar4 \u003d *puVar3 - uVar6;\n      if (-1 \u003c (int)uVar4) {\n        if (uVar4 \u003c 0xc) {\n          if (puVar5 \u003d\u003d puVar3) {\n            puVar1 \u003d (uint *)puVar5[1];\n          }\n          else {\n            puVar1 \u003d (uint *)puVar3[1];\n          }\n          if (puVar5 !\u003d puVar3) {\n            puVar5[1] \u003d (uint)puVar1;\n            puVar5 \u003d puVar3;\n            puVar1 \u003d __malloc_free_list;\n          }\n        }\n        else {\n          *puVar3 \u003d uVar4;\n          *(uint *)((int)puVar3 + uVar4) \u003d uVar6;\n          puVar5 \u003d (uint *)((int)puVar3 + uVar4);\n          puVar1 \u003d __malloc_free_list;\n        }\n        goto LAB_080049dc;\n      }\n      puVar5 \u003d puVar3;\n      puVar1 \u003d (uint *)puVar3[1];\n    }\n    if (__malloc_sbrk_start \u003d\u003d 0) {\n      __malloc_sbrk_start \u003d _sbrk_r(param_1);\n    }\n    puVar1 \u003d (uint *)_sbrk_r(param_1,uVar6);\n    if ((puVar1 !\u003d (uint *)0xffffffff) \u0026\u0026\n       ((puVar5 \u003d (uint *)((int)puVar1 + 3U \u0026 0xfffffffc), puVar1 \u003d\u003d puVar5 ||\n        (iVar2 \u003d _sbrk_r(param_1,(int)puVar5 - (int)puVar1), iVar2 !\u003d -1)))) {\n      *puVar5 \u003d uVar6;\n      puVar1 \u003d __malloc_free_list;\nLAB_080049dc:\n      __malloc_free_list \u003d puVar1;\n      __malloc_unlock(param_1);\n      uVar6 \u003d (int)puVar5 + 0xbU \u0026 0xfffffff8;\n      iVar2 \u003d uVar6 - (int)(puVar5 + 1);\n      if (iVar2 !\u003d 0) {\n        *(int *)((int)puVar5 + iVar2) \u003d -iVar2;\n        return uVar6;\n      }\n      return uVar6;\n    }\n    *param_1 \u003d 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r",
        "__sfmoreglue"
      ],
      "called": [
        "__malloc_unlock",
        "__malloc_lock",
        "_sbrk_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfputc_r": {
      "entrypoint": "0x08004a34",
      "current_name": "__sfputc_r",
      "code": "\nuint __sfputc_r(undefined4 param_1,byte param_2,byte **param_3)\n\n{\n  uint uVar1;\n  byte *pbVar2;\n  \n  pbVar2 \u003d param_3[2] + -1;\n  param_3[2] \u003d pbVar2;\n  if (((int)pbVar2 \u003c 0) \u0026\u0026 (((int)pbVar2 \u003c (int)param_3[6] || (param_2 \u003d\u003d 10)))) {\n    uVar1 \u003d __swbuf_r();\n    return uVar1;\n  }\n  pbVar2 \u003d *param_3;\n  *param_3 \u003d pbVar2 + 1;\n  *pbVar2 \u003d param_2;\n  return (uint)param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfputs_r"
      ],
      "called": [
        "__swbuf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfputs_r": {
      "entrypoint": "0x08004a60",
      "current_name": "__sfputs_r",
      "code": "\nint __sfputs_r(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 \u003d param_3 + param_4;\n  iVar3 \u003d param_4;\n  do {\n    if (param_3 \u003d\u003d puVar2) {\n      return 0;\n    }\n    iVar1 \u003d __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 \u003d iVar1 + 1;\n    param_3 \u003d param_3 + 1;\n  } while (param_4 !\u003d 0);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "__sfputc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_vfiprintf_r": {
      "entrypoint": "0x08004a84",
      "current_name": "_vfiprintf_r",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x08004c58) */\n\nint _vfiprintf_r(int param_1,undefined4 *param_2,byte *param_3,int *param_4)\n\n{\n  bool bVar1;\n  int iVar2;\n  void *pvVar3;\n  int *piVar4;\n  byte *pbVar5;\n  byte *pbVar6;\n  int unaff_r9;\n  int iVar7;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 local_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  local_8c \u003d param_4;\n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d *(undefined4 **)(param_1 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(undefined4 **)(param_1 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n  }\n  if (((-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1c)) || (param_2[4] \u003d\u003d 0)) \u0026\u0026\n     (iVar7 \u003d __swsetup_r(param_1,param_2), iVar7 !\u003d 0)) {\n    return -1;\n  }\n  local_74 \u003d 0;\n  local_6f \u003d 0x20;\n  local_6e \u003d 0x30;\n  pbVar5 \u003d param_3;\nLAB_08004ac6:\n  pbVar6 \u003d pbVar5;\n  if (*pbVar6 !\u003d 0) goto LAB_08004b7c;\n  goto LAB_08004ad0;\nLAB_08004b7c:\n  pbVar5 \u003d pbVar6 + 1;\n  if (*pbVar6 !\u003d 0x25) goto LAB_08004ac6;\nLAB_08004ad0:\n  iVar7 \u003d (int)pbVar6 - (int)param_3;\n  if (iVar7 !\u003d 0) {\n    iVar2 \u003d __sfputs_r(param_1,param_2,param_3,iVar7);\n    if (iVar2 \u003d\u003d -1) {\nLAB_08004c70:\n      if ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x19) \u003c 0) {\n        return -1;\n      }\n      return local_74;\n    }\n    local_74 \u003d local_74 + iVar7;\n  }\n  if (*pbVar6 \u003d\u003d 0) goto LAB_08004c70;\n  local_88 \u003d 0;\n  local_7c \u003d 0;\n  local_84 \u003d -1;\n  local_80 \u003d 0;\n  local_45 \u003d 0;\n  local_30 \u003d 0;\n  pbVar5 \u003d pbVar6 + 1;\n  while( true ) {\n    pvVar3 \u003d memchr(\"#-0+ \",(uint)*pbVar5,5);\n    param_3 \u003d pbVar5 + 1;\n    if (pvVar3 \u003d\u003d (void *)0x0) break;\n    local_88 \u003d 1 \u003c\u003c ((int)pvVar3 + 0xf7ffa094U \u0026 0xff) | local_88;\n    pbVar5 \u003d param_3;\n  }\n  if ((int)(local_88 \u003c\u003c 0x1b) \u003c 0) {\n    local_45 \u003d 0x20;\n  }\n  if ((int)(local_88 \u003c\u003c 0x1c) \u003c 0) {\n    local_45 \u003d 0x2b;\n  }\n  if (*pbVar5 \u003d\u003d 0x2a) {\n    piVar4 \u003d local_8c + 1;\n    iVar7 \u003d *local_8c;\n    local_8c \u003d piVar4;\n    if (iVar7 \u003c 0) {\n      local_7c \u003d -iVar7;\n      local_88 \u003d local_88 | 2;\n      goto LAB_08004bae;\n    }\n  }\n  else {\n    bVar1 \u003d false;\n    iVar7 \u003d local_7c;\n    param_3 \u003d pbVar5;\n    while( true ) {\n      if (9 \u003c *param_3 - 0x30) break;\n      iVar7 \u003d iVar7 * 10 + (*param_3 - 0x30);\n      bVar1 \u003d true;\n      param_3 \u003d param_3 + 1;\n    }\n    if (!bVar1) goto LAB_08004bae;\n  }\n  local_7c \u003d iVar7;\nLAB_08004bae:\n  if (*param_3 \u003d\u003d 0x2e) {\n    if (param_3[1] \u003d\u003d 0x2a) {\n      local_84 \u003d *local_8c;\n      if (local_84 \u003c 0) {\n        local_84 \u003d -1;\n      }\n      param_3 \u003d param_3 + 2;\n      local_8c \u003d local_8c + 1;\n    }\n    else {\n      bVar1 \u003d false;\n      local_84 \u003d 0;\n      iVar7 \u003d 0;\n      while( true ) {\n        param_3 \u003d param_3 + 1;\n        if (9 \u003c *param_3 - 0x30) break;\n        iVar7 \u003d iVar7 * 10 + (*param_3 - 0x30);\n        bVar1 \u003d true;\n      }\n      if (bVar1) {\n        local_84 \u003d iVar7;\n      }\n    }\n  }\n  pvVar3 \u003d memchr(\u0026DAT_08005f72,(uint)*param_3,3);\n  if (pvVar3 !\u003d (void *)0x0) {\n    local_88 \u003d local_88 | 0x40 \u003c\u003c ((int)pvVar3 + 0xf7ffa08eU \u0026 0xff);\n    param_3 \u003d param_3 + 1;\n  }\n  local_70 \u003d *param_3;\n  param_3 \u003d param_3 + 1;\n  pvVar3 \u003d memchr(\"efgEFG\",(uint)local_70,6);\n  if (pvVar3 \u003d\u003d (void *)0x0) {\n    unaff_r9 \u003d _printf_i(param_1,\u0026local_88,param_2,0x8004a61,\u0026local_8c);\n    if (unaff_r9 \u003d\u003d -1) goto LAB_08004c70;\n  }\n  else {\n    local_8c \u003d (int *)(((int)local_8c + 7U \u0026 0xfffffff8) + 8);\n  }\n  local_74 \u003d local_74 + unaff_r9;\n  pbVar5 \u003d param_3;\n  goto LAB_08004ac6;\n}\n\n",
      "renaming": {},
      "calling": [
        "iprintf",
        "fiprintf"
      ],
      "called": [
        "__swsetup_r",
        "__sinit",
        "memchr",
        "__sfputs_r",
        "_printf_i"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_printf_common": {
      "entrypoint": "0x08004cb0",
      "current_name": "_printf_common",
      "code": "\nundefined4\n_printf_common(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  bool bVar5;\n  \n  uVar3 \u003d param_2[4];\n  if ((int)param_2[4] \u003c (int)param_2[2]) {\n    uVar3 \u003d param_2[2];\n  }\n  *param_3 \u003d uVar3;\n  if (*(char *)((int)param_2 + 0x43) !\u003d \u0027\\0\u0027) {\n    *param_3 \u003d uVar3 + 1;\n  }\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *param_3 \u003d *param_3 + 2;\n  }\n  if ((*param_2 \u0026 6) \u003d\u003d 0) {\n    for (iVar1 \u003d 0; iVar1 \u003c (int)(param_2[3] - *param_3); iVar1 \u003d iVar1 + 1) {\n      iVar2 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar2 \u003d\u003d -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  uVar3 \u003d (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar3 !\u003d 0) {\n    uVar3 \u003d 1;\n  }\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *(undefined *)((int)param_2 + uVar3 + 0x43) \u003d 0x30;\n    *(undefined *)((int)param_2 + uVar3 + 0x44) \u003d *(undefined *)((int)param_2 + 0x45);\n    uVar3 \u003d uVar3 + 2;\n  }\n  iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar3);\n  if (iVar1 !\u003d -1) {\n    uVar3 \u003d param_2[3];\n    bVar5 \u003d (*param_2 \u0026 6) \u003d\u003d 4;\n    if (bVar5) {\n      uVar3 \u003d uVar3 - *param_3;\n    }\n    if (bVar5) {\n      uVar3 \u003d uVar3 \u0026 ~((int)uVar3 \u003e\u003e 0x1f);\n    }\n    else {\n      uVar3 \u003d 0;\n    }\n    if ((int)param_2[4] \u003c (int)param_2[2]) {\n      uVar3 \u003d uVar3 + (param_2[2] - param_2[4]);\n    }\n    uVar4 \u003d 0;\n    while( true ) {\n      if (uVar3 \u003d\u003d uVar4) {\n        return 0;\n      }\n      iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 \u003d\u003d -1) break;\n      uVar4 \u003d uVar4 + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_printf_i"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_printf_i": {
      "entrypoint": "0x08004d9c",
      "current_name": "_printf_i",
      "code": "\nuint _printf_i(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5)\n\n{\n  byte bVar1;\n  int iVar2;\n  uint *puVar3;\n  void *pvVar4;\n  int iVar5;\n  char *pcVar6;\n  uint uVar7;\n  uint **ppuVar8;\n  char **ppcVar9;\n  uint uVar10;\n  uint uVar11;\n  char *pcVar12;\n  char *__s;\n  uint local_24 [2];\n  \n  bVar1 \u003d *(byte *)(param_2 + 6);\n  __s \u003d (char *)((int)param_2 + 0x43);\n  if (bVar1 !\u003d 0x6e) {\n    if (bVar1 \u003c 0x6f) {\n      if (bVar1 !\u003d 99) {\n        if (bVar1 \u003c 100) {\n          if (bVar1 \u003d\u003d 0) goto LAB_08004f56;\n          if (bVar1 !\u003d 0x58) goto LAB_08004dcc;\n          *(undefined *)((int)param_2 + 0x45) \u003d 0x58;\n          pcVar6 \u003d \"0123456789ABCDEF\";\nLAB_08004ee6:\n          uVar7 \u003d *param_2;\n          puVar3 \u003d *param_5;\n          *param_5 \u003d puVar3 + 1;\n          if (((uVar7 \u0026 0x80) \u003d\u003d 0) \u0026\u0026 ((int)(uVar7 \u003c\u003c 0x19) \u003c 0)) {\n            uVar10 \u003d (uint)*(ushort *)puVar3;\n          }\n          else {\n            uVar10 \u003d *puVar3;\n          }\n          if ((int)(uVar7 \u003c\u003c 0x1f) \u003c 0) {\n            *param_2 \u003d uVar7 | 0x20;\n          }\n          if (uVar10 \u003d\u003d 0) {\n            *param_2 \u003d *param_2 \u0026 0xffffffdf;\n          }\n          uVar7 \u003d 0x10;\nLAB_08004e7c:\n          *(undefined *)((int)param_2 + 0x43) \u003d 0;\n        }\n        else {\n          if ((bVar1 !\u003d 100) \u0026\u0026 (bVar1 !\u003d 0x69)) goto LAB_08004dcc;\n          uVar10 \u003d *param_2;\n          puVar3 \u003d *param_5;\n          if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n            *param_5 \u003d puVar3 + 1;\n            if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_08004dec;\n            uVar10 \u003d (uint)(short)*(ushort *)puVar3;\n          }\n          else {\n            *param_5 \u003d puVar3 + 1;\nLAB_08004dec:\n            uVar10 \u003d *puVar3;\n          }\n          if ((int)uVar10 \u003c 0) {\n            uVar10 \u003d -uVar10;\n            *(undefined *)((int)param_2 + 0x43) \u003d 0x2d;\n          }\n          pcVar6 \u003d \"0123456789ABCDEF\";\n          uVar7 \u003d 10;\n        }\n        uVar11 \u003d param_2[1];\n        param_2[2] \u003d uVar11;\n        pcVar12 \u003d __s;\n        if ((int)uVar11 \u003c 0) {\n          if (uVar10 !\u003d 0) goto LAB_08004f1a;\nLAB_08004fc8:\n          *(char *)((int)param_2 + 0x42) \u003d *pcVar6;\n          pcVar12 \u003d (char *)((int)param_2 + 0x42);\n        }\n        else {\n          *param_2 \u003d *param_2 \u0026 0xfffffffb;\n          if (uVar10 \u003d\u003d 0) {\n            if (uVar11 !\u003d 0) goto LAB_08004fc8;\n          }\n          else {\nLAB_08004f1a:\n            do {\n              uVar11 \u003d uVar10 / uVar7;\n              pcVar12 \u003d pcVar12 + -1;\n              *pcVar12 \u003d pcVar6[uVar10 - uVar7 * uVar11];\n              uVar10 \u003d uVar11;\n            } while (uVar11 !\u003d 0);\n          }\n        }\n        if (((uVar7 \u003d\u003d 8) \u0026\u0026 ((int)(*param_2 \u003c\u003c 0x1f) \u003c 0)) \u0026\u0026 ((int)param_2[1] \u003c\u003d (int)param_2[4]))\n        {\n          pcVar12[-1] \u003d \u00270\u0027;\n          pcVar12 \u003d pcVar12 + -1;\n        }\n        param_2[4] \u003d (int)__s - (int)pcVar12;\n        __s \u003d pcVar12;\n        goto LAB_08004ec2;\n      }\n      puVar3 \u003d *param_5;\n      *param_5 \u003d puVar3 + 1;\n      *(char *)((int)param_2 + 0x42) \u003d (char)*puVar3;\nLAB_08004e2c:\n      __s \u003d (char *)((int)param_2 + 0x42);\n      uVar10 \u003d 1;\n    }\n    else {\n      if (bVar1 !\u003d 0x73) {\n        if (bVar1 \u003c 0x74) {\n          if (bVar1 \u003d\u003d 0x6f) {\nLAB_08004e52:\n            uVar10 \u003d *param_2;\n            puVar3 \u003d *param_5;\n            if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n              *param_5 \u003d puVar3 + 1;\n              if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_08004e60;\n              uVar10 \u003d (uint)*(ushort *)puVar3;\n            }\n            else {\n              *param_5 \u003d puVar3 + 1;\nLAB_08004e60:\n              uVar10 \u003d *puVar3;\n            }\n            pcVar6 \u003d \"0123456789ABCDEF\";\n            if (bVar1 \u003d\u003d 0x6f) {\n              uVar7 \u003d 8;\n            }\n            else {\n              uVar7 \u003d 10;\n            }\n            goto LAB_08004e7c;\n          }\n          if (bVar1 \u003d\u003d 0x70) {\n            *param_2 \u003d *param_2 | 0x20;\nLAB_08004e12:\n            *(undefined *)((int)param_2 + 0x45) \u003d 0x78;\n            pcVar6 \u003d \"0123456789abcdef\";\n            goto LAB_08004ee6;\n          }\n        }\n        else {\n          if (bVar1 \u003d\u003d 0x75) goto LAB_08004e52;\n          if (bVar1 \u003d\u003d 0x78) goto LAB_08004e12;\n        }\nLAB_08004dcc:\n        *(byte *)((int)param_2 + 0x42) \u003d bVar1;\n        goto LAB_08004e2c;\n      }\n      ppcVar9 \u003d (char **)*param_5;\n      *param_5 \u003d (uint *)(ppcVar9 + 1);\n      __s \u003d *ppcVar9;\n      pvVar4 \u003d memchr(__s,0,param_2[1]);\n      if (pvVar4 !\u003d (void *)0x0) {\n        param_2[1] \u003d (int)pvVar4 - (int)__s;\n      }\n      uVar10 \u003d param_2[1];\n    }\n    param_2[4] \u003d uVar10;\n    *(undefined *)((int)param_2 + 0x43) \u003d 0;\n    goto LAB_08004ec2;\n  }\n  uVar10 \u003d *param_2;\n  ppuVar8 \u003d (uint **)*param_5;\n  uVar7 \u003d param_2[5];\n  if ((uVar10 \u0026 0x80) \u003d\u003d 0) {\n    *param_5 \u003d (uint *)(ppuVar8 + 1);\n    puVar3 \u003d *ppuVar8;\n    if ((uVar10 \u0026 0x40) \u003d\u003d 0) goto LAB_08004f42;\n    *(short *)puVar3 \u003d (short)uVar7;\n  }\n  else {\n    *param_5 \u003d (uint *)(ppuVar8 + 1);\n    puVar3 \u003d *ppuVar8;\nLAB_08004f42:\n    *puVar3 \u003d uVar7;\n  }\nLAB_08004f56:\n  param_2[4] \u003d 0;\nLAB_08004ec2:\n  iVar2 \u003d _printf_common(param_1,param_2,local_24,param_3,param_4);\n  if ((iVar2 \u003d\u003d -1) || (iVar2 \u003d (*param_4)(param_1,param_3,__s,param_2[4]), iVar2 \u003d\u003d -1)) {\nLAB_08004ed6:\n    uVar10 \u003d 0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 \u003c\u003c 0x1e) \u003c 0) {\n      for (iVar2 \u003d 0; iVar2 \u003c (int)(param_2[3] - local_24[0]); iVar2 \u003d iVar2 + 1) {\n        iVar5 \u003d (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar5 \u003d\u003d -1) goto LAB_08004ed6;\n      }\n    }\n    uVar10 \u003d param_2[3];\n    if ((int)param_2[3] \u003c (int)local_24[0]) {\n      uVar10 \u003d local_24[0];\n    }\n  }\n  return uVar10;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "_printf_common",
        "memchr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "iprintf": {
      "entrypoint": "0x08004fdc",
      "current_name": "iprintf",
      "code": "\nint iprintf(char *__format,...)\n\n{\n  int iVar1;\n  undefined4 in_r1;\n  undefined4 in_r2;\n  undefined4 in_r3;\n  char *pcVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  iVar1 \u003d _impure_ptr;\n  pcVar2 \u003d __format;\n  uStack_c \u003d in_r1;\n  uStack_8 \u003d in_r2;\n  uStack_4 \u003d in_r3;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  iVar1 \u003d _vfiprintf_r(iVar1,*(undefined4 *)(iVar1 + 8),__format,\u0026uStack_c,pcVar2,\u0026uStack_c);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "uart_init"
      ],
      "called": [
        "__sinit",
        "_vfiprintf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk_r": {
      "entrypoint": "0x0800500c",
      "current_name": "_sbrk_r",
      "code": "\nvoid _sbrk_r(int *param_1,intptr_t param_2)\n\n{\n  void *pvVar1;\n  \n  errno \u003d 0;\n  pvVar1 \u003d _sbrk(param_2);\n  if ((pvVar1 \u003d\u003d (void *)0xffffffff) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r"
      ],
      "called": [
        "_sbrk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swbuf_r": {
      "entrypoint": "0x0800502c",
      "current_name": "__swbuf_r",
      "code": "\nuint __swbuf_r(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_3 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_3 \u003d *(int **)(param_1 + 4);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026__sf_fake_stdout) {\n    param_3 \u003d *(int **)(param_1 + 8);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026__sf_fake_stderr) {\n    param_3 \u003d *(int **)(param_1 + 0xc);\n  }\n  param_3[2] \u003d param_3[6];\n  uVar2 \u003d (uint)*(ushort *)(param_3 + 3);\n  iVar1 \u003d uVar2 \u003c\u003c 0x1c;\n  if (((iVar1 \u003c 0) \u0026\u0026 (uVar2 \u003d param_3[4], uVar2 !\u003d 0)) ||\n     (iVar1 \u003d __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 \u003d\u003d 0)) {\n    iVar1 \u003d *param_3 - param_3[4];\n    param_2 \u003d param_2 \u0026 0xff;\n    if ((iVar1 \u003c param_3[5]) || (iVar1 \u003d _fflush_r(param_1,param_3), iVar1 \u003d\u003d 0)) {\n      param_3[2] \u003d param_3[2] + -1;\n      puVar3 \u003d (undefined *)*param_3;\n      *param_3 \u003d (int)(puVar3 + 1);\n      *puVar3 \u003d (char)param_2;\n      if (iVar1 + 1 !\u003d param_3[5]) {\n        if (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x1f)) {\n          return param_2;\n        }\n        if (param_2 !\u003d 10) {\n          return param_2;\n        }\n      }\n      iVar1 \u003d _fflush_r(param_1,param_3);\n      if (iVar1 \u003d\u003d 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfputc_r"
      ],
      "called": [
        "__swsetup_r",
        "__sinit",
        "_fflush_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swsetup_r": {
      "entrypoint": "0x080050d0",
      "current_name": "__swsetup_r",
      "code": "\nuint __swsetup_r(undefined4 *param_1,undefined4 *param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  ushort uVar3;\n  \n  iVar1 \u003d _impure_ptr;\n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x18) \u003d\u003d 0)) {\n    __sinit(_impure_ptr);\n  }\n  if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n    param_2 \u003d *(undefined4 **)(iVar1 + 0xc);\n  }\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  uVar2 \u003d (uint)uVar3;\n  if (-1 \u003c (int)(uVar2 \u003c\u003c 0x1c)) {\n    if (-1 \u003c (int)(uVar2 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      goto LAB_08005100;\n    }\n    if ((int)(uVar2 \u003c\u003c 0x1d) \u003c 0) {\n      if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] \u003d 0;\n      }\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xffdb;\n      param_2[1] \u003d 0;\n      *param_2 \u003d param_2[4];\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] \u003d\u003d 0) \u0026\u0026 ((*(ushort *)(param_2 + 3) \u0026 0x280) !\u003d 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  uVar2 \u003d uVar3 \u0026 1;\n  if ((uVar3 \u0026 1) \u003d\u003d 0) {\n    if (-1 \u003c (int)((uint)uVar3 \u003c\u003c 0x1e)) {\n      uVar2 \u003d param_2[5];\n    }\n    param_2[2] \u003d uVar2;\n  }\n  else {\n    param_2[2] \u003d 0;\n    param_2[6] \u003d -param_2[5];\n  }\n  if (param_2[4] \u003d\u003d 0) {\n    uVar3 \u003d *(ushort *)(param_2 + 3);\n    uVar2 \u003d (int)(short)uVar3 \u0026 0x80;\n    if (uVar2 !\u003d 0) {\nLAB_08005100:\n      *(ushort *)(param_2 + 3) \u003d uVar3 | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    uVar2 \u003d 0;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swbuf_r",
        "_vfiprintf_r"
      ],
      "called": [
        "__smakebuf_r",
        "__sinit",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "abort": {
      "entrypoint": "0x080051ac",
      "current_name": "abort",
      "code": "\n\n\nvoid abort(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "__assert_func",
        "__throw_bad_function_call"
      ],
      "called": [
        "_exit",
        "raise"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sflush_r": {
      "entrypoint": "0x080051bc",
      "current_name": "__sflush_r",
      "code": "\nundefined4 __sflush_r(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar3 \u003d (uint)uVar4;\n  if ((int)(uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar1 \u003d param_2[4];\n    if (iVar1 !\u003d 0) {\n      iVar5 \u003d uVar3 \u003c\u003c 0x1e;\n      bVar9 \u003d iVar5 \u003d\u003d 0;\n      iVar7 \u003d *param_2;\n      if (bVar9) {\n        iVar5 \u003d param_2[5];\n      }\n      *param_2 \u003d iVar1;\n      if (!bVar9) {\n        iVar5 \u003d 0;\n      }\n      param_2[2] \u003d iVar5;\n      for (iVar7 \u003d iVar7 - iVar1; 0 \u003c iVar7; iVar7 \u003d iVar7 - iVar5) {\n        iVar5 \u003d (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 \u003c 1) {\n          uVar4 \u003d *(ushort *)(param_2 + 3);\n          goto LAB_080052b2;\n        }\n        iVar1 \u003d iVar1 + iVar5;\n      }\n    }\n  }\n  else if (((0 \u003c param_2[1]) || (0 \u003c param_2[0x10])) \u0026\u0026\n          (pcVar6 \u003d (code *)param_2[0xb], pcVar6 !\u003d (code *)0x0)) {\n    uVar8 \u003d *param_1;\n    *param_1 \u003d 0;\n    if ((uVar4 \u0026 0x1000) \u003d\u003d 0) {\n      iVar1 \u003d (*pcVar6)(param_1,param_2[8],uVar3 \u0026 0x1000,1);\n      if ((iVar1 \u003d\u003d -1) \u0026\u0026 (uVar3 \u003d *param_1, uVar3 !\u003d 0)) {\n        if ((uVar3 !\u003d 0x1d) \u0026\u0026 (uVar3 !\u003d 0x16)) {\n          *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        *param_1 \u003d uVar8;\n        return 0;\n      }\n    }\n    else {\n      iVar1 \u003d param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1d) \u003c 0) \u0026\u0026\n       (iVar1 \u003d iVar1 - param_2[1], param_2[0xd] !\u003d 0)) {\n      iVar1 \u003d iVar1 - param_2[0x10];\n    }\n    iVar1 \u003d (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 \u003d *(ushort *)(param_2 + 3);\n    if ((iVar1 \u003d\u003d -1) \u0026\u0026\n       ((0x1d \u003c *param_1 || (-1 \u003c (int)((0x20400001U \u003e\u003e (*param_1 \u0026 0xff)) \u003c\u003c 0x1f))))) {\nLAB_080052b2:\n      *(ushort *)(param_2 + 3) \u003d uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    param_2[1] \u003d 0;\n    *param_2 \u003d param_2[4];\n    if (((int)((uint)uVar4 \u003c\u003c 0x13) \u003c 0) \u0026\u0026 ((iVar1 !\u003d -1 || (*param_1 \u003d\u003d 0)))) {\n      param_2[0x15] \u003d iVar1;\n    }\n    piVar2 \u003d (int *)param_2[0xd];\n    *param_1 \u003d uVar8;\n    if (piVar2 !\u003d (int *)0x0) {\n      if (piVar2 !\u003d param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] \u003d 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fflush_r": {
      "entrypoint": "0x080052cc",
      "current_name": "_fflush_r",
      "code": "\nundefined4 _fflush_r(int param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  if (param_2[4] !\u003d 0) {\n    if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n      __sinit();\n    }\n    if (param_2 \u003d\u003d \u0026__sf_fake_stdin) {\n      param_2 \u003d *(undefined4 **)(param_1 + 4);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stdout) {\n      param_2 \u003d *(undefined4 **)(param_1 + 8);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026__sf_fake_stderr) {\n      param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 3) !\u003d 0) {\n      uVar1 \u003d __sflush_r(param_1,param_2,param_3,param_4);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swbuf_r"
      ],
      "called": [
        "__sinit",
        "__sflush_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_cleanup_r": {
      "entrypoint": "0x08005320",
      "current_name": "_cleanup_r",
      "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk_reent(param_1,0x80052cd);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fwalk_reent"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "std.isra.0": {
      "entrypoint": "0x0800532c",
      "current_name": "std.isra.0",
      "code": "\nvoid std_isra_0(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  *param_1 \u003d 0;\n  param_1[1] \u003d 0;\n  param_1[2] \u003d 0;\n  *(undefined2 *)(param_1 + 3) \u003d param_2;\n  param_1[0x19] \u003d 0;\n  *(undefined2 *)((int)param_1 + 0xe) \u003d param_3;\n  param_1[4] \u003d 0;\n  param_1[5] \u003d 0;\n  param_1[6] \u003d 0;\n  memset(param_1 + 0x17,0,8);\n  param_1[9] \u003d 0x8005609;\n  param_1[10] \u003d 0x800562b;\n  param_1[0xb] \u003d 0x8005663;\n  param_1[8] \u003d param_1;\n  param_1[0xc] \u003d 0x8005687;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfmoreglue": {
      "entrypoint": "0x08005374",
      "current_name": "__sfmoreglue",
      "code": "\nundefined4 * __sfmoreglue(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 \u003d (param_2 + -1) * 0x68;\n  puVar1 \u003d (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 !\u003d (undefined4 *)0x0) {\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d param_2;\n    puVar1[2] \u003d puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfp"
      ],
      "called": [
        "memset",
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sinit": {
      "entrypoint": "0x080053a0",
      "current_name": "__sinit",
      "code": "\nvoid __sinit(undefined1 *param_1)\n\n{\n  undefined4 uVar1;\n  undefined1 *puVar2;\n  \n  if (*(int *)(param_1 + 0x18) \u003d\u003d 0) {\n    *(undefined4 *)(param_1 + 0x48) \u003d 0;\n    *(undefined4 *)(param_1 + 0x4c) \u003d 0;\n    *(undefined4 *)(param_1 + 0x50) \u003d 0;\n    puVar2 \u003d \u0026impure_data;\n    *(undefined4 *)(param_1 + 0x28) \u003d 0x8005321;\n    if (param_1 \u003d\u003d \u0026impure_data) {\n      puVar2 \u003d (undefined1 *)0x1;\n    }\n    if (param_1 \u003d\u003d \u0026impure_data) {\n      *(undefined1 **)(param_1 + 0x18) \u003d puVar2;\n    }\n    uVar1 \u003d __sfp();\n    *(undefined4 *)(param_1 + 4) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) \u003d uVar1;\n    std_isra_0(*(undefined4 *)(param_1 + 4),4,0);\n    std_isra_0(*(undefined4 *)(param_1 + 8),9,1);\n    std_isra_0(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r",
        "__sfp",
        "iprintf",
        "__swbuf_r",
        "_vfiprintf_r",
        "_fflush_r"
      ],
      "called": [
        "__sfp",
        "std.isra.0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp": {
      "entrypoint": "0x08005400",
      "current_name": "__sfp",
      "code": "\nint * __sfp(undefined4 *param_1)\n\n{\n  int *piVar1;\n  int *piVar2;\n  int **ppiVar3;\n  \n  if (DAT_200000bc \u003d\u003d 0) {\n    __sinit(\u0026impure_data);\n  }\n  ppiVar3 \u003d (int **)\u0026DAT_200000ec;\n  do {\n    piVar2 \u003d ppiVar3[2];\n    piVar1 \u003d ppiVar3[1];\n    while (piVar1 \u003d (int *)((int)piVar1 + -1), -1 \u003c (int)piVar1) {\n      if (*(short *)(piVar2 + 3) \u003d\u003d 0) {\n        *(undefined2 *)((int)piVar2 + 0xe) \u003d 0xffff;\n        *(undefined2 *)(piVar2 + 3) \u003d 1;\n        piVar2[0x19] \u003d 0;\n        *piVar2 \u003d 0;\n        piVar2[2] \u003d 0;\n        piVar2[1] \u003d 0;\n        piVar2[4] \u003d 0;\n        piVar2[5] \u003d 0;\n        piVar2[6] \u003d 0;\n        memset(piVar2 + 0x17,0,8);\n        piVar2[0xd] \u003d 0;\n        piVar2[0xe] \u003d 0;\n        piVar2[0x12] \u003d 0;\n        piVar2[0x13] \u003d 0;\n        return piVar2;\n      }\n      piVar2 \u003d piVar2 + 0x1a;\n    }\n    if (*ppiVar3 \u003d\u003d (int *)0x0) {\n      piVar1 \u003d (int *)__sfmoreglue(param_1,4);\n      *ppiVar3 \u003d piVar1;\n      if (piVar1 \u003d\u003d (int *)0x0) {\n        *param_1 \u003d 0xc;\n        return (int *)0x0;\n      }\n    }\n    ppiVar3 \u003d (int **)*ppiVar3;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__sinit"
      ],
      "called": [
        "memset",
        "__sinit",
        "__sfmoreglue"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fwalk_reent": {
      "entrypoint": "0x08005478",
      "current_name": "_fwalk_reent",
      "code": "\nuint _fwalk_reent(int param_1,code *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint uVar1;\n  int iVar2;\n  int *piVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  \n  uVar5 \u003d 0;\n  for (piVar3 \u003d (int *)(param_1 + 0x48); piVar3 !\u003d (int *)0x0; piVar3 \u003d (int *)*piVar3) {\n    iVar4 \u003d piVar3[2];\n    iVar6 \u003d piVar3[1];\n    while (iVar6 \u003d iVar6 + -1, -1 \u003c iVar6) {\n      if ((1 \u003c *(ushort *)(iVar4 + 0xc)) \u0026\u0026 (iVar2 \u003d *(short *)(iVar4 + 0xe) + 1, iVar2 !\u003d 0)) {\n        uVar1 \u003d (*param_2)(param_1,iVar4,param_3,iVar2,param_4);\n        uVar5 \u003d uVar5 | uVar1;\n      }\n      iVar4 \u003d iVar4 + 0x68;\n    }\n  }\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "_cleanup_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swhatbuf_r": {
      "entrypoint": "0x080054b4",
      "current_name": "__swhatbuf_r",
      "code": "\nundefined4 __swhatbuf_r(undefined4 param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_4c [4];\n  uint local_48;\n  \n  if ((*(short *)(param_2 + 0xe) \u003c 0) ||\n     (iVar1 \u003d _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),auStack_4c), iVar1 \u003c 0)) {\n    *param_4 \u003d 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x18) \u003c 0) {\n      uVar2 \u003d 0x40;\n      goto LAB_080054f4;\n    }\n  }\n  else {\n    *param_4 \u003d (uint)((local_48 \u0026 0xf000) \u003d\u003d 0x2000);\n  }\n  uVar2 \u003d 0x400;\nLAB_080054f4:\n  *param_3 \u003d uVar2;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_fstat_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__smakebuf_r": {
      "entrypoint": "0x080054fc",
      "current_name": "__smakebuf_r",
      "code": "\nvoid __smakebuf_r(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int local_18;\n  int *local_14;\n  \n  if (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1e)) {\n    local_18 \u003d param_1;\n    local_14 \u003d param_2;\n    uVar1 \u003d __swhatbuf_r(param_1,param_2,\u0026local_18,\u0026local_14);\n    iVar2 \u003d _malloc_r(param_1,local_18);\n    if (iVar2 !\u003d 0) {\n      *(undefined4 *)(param_1 + 0x28) \u003d 0x8005321;\n      *param_2 \u003d iVar2;\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x80;\n      param_2[5] \u003d local_18;\n      param_2[4] \u003d iVar2;\n      if ((local_14 !\u003d (int *)0x0) \u0026\u0026\n         (iVar2 \u003d _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 !\u003d 0)) {\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) \u003d uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) \u003c\u003c 0x16 \u003c 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 2;\n  }\n  *param_2 \u003d (int)param_2 + 0x47;\n  param_2[4] \u003d (int)param_2 + 0x47;\n  param_2[5] \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r"
      ],
      "called": [
        "__swhatbuf_r",
        "_malloc_r",
        "_isatty_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_lock": {
      "entrypoint": "0x0800557c",
      "current_name": "__malloc_lock",
      "code": "\nvoid __malloc_lock(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_free_r",
        "_malloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_unlock": {
      "entrypoint": "0x0800557e",
      "current_name": "__malloc_unlock",
      "code": "\nvoid __malloc_unlock(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_free_r",
        "_malloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_raise_r": {
      "entrypoint": "0x08005580",
      "current_name": "_raise_r",
      "code": "\nundefined4 _raise_r(undefined4 *param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t _Var1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if (0x1f \u003c param_2) {\n    *param_1 \u003d 0x16;\n    return 0xffffffff;\n  }\n  iVar3 \u003d param_1[0x11];\n  if ((iVar3 !\u003d 0) \u0026\u0026 (pcVar4 \u003d *(code **)(iVar3 + param_2 * 4), pcVar4 !\u003d (code *)0x0)) {\n    if (pcVar4 !\u003d (code *)0x1) {\n      if (pcVar4 \u003d\u003d (code *)0xffffffff) {\n        *param_1 \u003d 0x16;\n        return 1;\n      }\n      *(undefined4 *)(iVar3 + param_2 * 4) \u003d 0;\n      (*pcVar4)(param_2);\n    }\n    return 0;\n  }\n  _Var1 \u003d _getpid_r();\n  uVar2 \u003d _kill_r(param_1,_Var1,param_2,param_4);\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "raise"
      ],
      "called": [
        "_kill_r",
        "_getpid_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "raise": {
      "entrypoint": "0x080055d0",
      "current_name": "raise",
      "code": "\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _raise_r(_impure_ptr,__sig);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "abort"
      ],
      "called": [
        "_raise_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_kill_r": {
      "entrypoint": "0x080055e0",
      "current_name": "_kill_r",
      "code": "\nvoid _kill_r(int *param_1,__pid_t param_2,int param_3)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _kill(param_2,param_3);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_raise_r"
      ],
      "called": [
        "_kill"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getpid_r": {
      "entrypoint": "0x08005604",
      "current_name": "_getpid_r",
      "code": "\n\n\n__pid_t _getpid_r(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_raise_r"
      ],
      "called": [
        "_getpid"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sread": {
      "entrypoint": "0x08005608",
      "current_name": "__sread",
      "code": "\nvoid __sread(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  iVar1 \u003d _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 \u003d -1 \u003c iVar1;\n  if (bVar3) {\n    uVar2 \u003d *(int *)(param_2 + 0x54) + iVar1;\n  }\n  else {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) \u003d (short)uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_read_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swrite": {
      "entrypoint": "0x0800562a",
      "current_name": "__swrite",
      "code": "\nvoid __swrite(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x17) \u003c 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r",
        "_write_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sseek": {
      "entrypoint": "0x08005662",
      "current_name": "__sseek",
      "code": "\nvoid __sseek(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  bool bVar3;\n  \n  iVar1 \u003d _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 \u003d iVar1 \u003d\u003d -1;\n  if (bVar3) {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  }\n  else {\n    *(int *)(param_2 + 0x54) \u003d iVar1;\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sclose": {
      "entrypoint": "0x08005686",
      "current_name": "__sclose",
      "code": "\nvoid __sclose(undefined4 param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_close_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write_r": {
      "entrypoint": "0x08005690",
      "current_name": "_write_r",
      "code": "\nvoid _write_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _write(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swrite"
      ],
      "called": [
        "_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close_r": {
      "entrypoint": "0x080056b4",
      "current_name": "_close_r",
      "code": "\nvoid _close_r(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _close(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sclose"
      ],
      "called": [
        "_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat_r": {
      "entrypoint": "0x080056d4",
      "current_name": "_fstat_r",
      "code": "\nvoid _fstat_r(int *param_1,int param_2,stat *param_3)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _fstat(param_2,param_3);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swhatbuf_r"
      ],
      "called": [
        "_fstat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty_r": {
      "entrypoint": "0x080056f8",
      "current_name": "_isatty_r",
      "code": "\nvoid _isatty_r(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _isatty(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_isatty"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek_r": {
      "entrypoint": "0x08005718",
      "current_name": "_lseek_r",
      "code": "\nvoid _lseek_r(int *param_1,int param_2,__off_t param_3,int param_4)\n\n{\n  __off_t _Var1;\n  \n  errno \u003d 0;\n  _Var1 \u003d _lseek(param_2,param_3,param_4);\n  if ((_Var1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sseek",
        "__swrite"
      ],
      "called": [
        "_lseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read_r": {
      "entrypoint": "0x0800573c",
      "current_name": "_read_r",
      "code": "\nvoid _read_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _read(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sread"
      ],
      "called": [
        "_read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__throw_bad_function_call": {
      "entrypoint": "0x08005760",
      "current_name": "__throw_bad_function_call",
      "code": "\n\n/* std::__throw_bad_function_call() */\n\nvoid std::__throw_bad_function_call(void)\n\n{\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "operator()"
      ],
      "called": [
        "abort"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_ctype_byname": {
      "entrypoint": "0x08005974",
      "current_name": "_GLOBAL__sub_I_ctype_byname",
      "code": "\n/* std::ctype_byname\u003cchar\u003e::ctype_byname(std::__cxx11::basic_string\u003cchar, std::char_traits\u003cchar\u003e,\n   std::allocator\u003cchar\u003e \u003e const\u0026, unsigned int) */\n\nvoid std::ctype_byname\u003cchar\u003e::_GLOBAL__sub_I_ctype_byname(void)\n\n{\n  if (-1 \u003c __cxx11::moneypunct\u003cchar,false\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::moneypunct\u003cchar,false\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::moneypunct\u003cchar,true\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::moneypunct\u003cchar,true\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::money_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c\n           0x1f) {\n    __cxx11::money_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::money_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c\n           0x1f) {\n    __cxx11::money_put\u003cchar,std::ostreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::numpunct\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::numpunct\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::time_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003c\u003c 0x1f\n     ) {\n    __cxx11::time_get\u003cchar,std::istreambuf_iterator\u003cchar,std::char_traits\u003cchar\u003e\u003e\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::messages\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::messages\u003cchar\u003e::id \u003d 1;\n  }\n  if (-1 \u003c __cxx11::collate\u003cchar\u003e::id \u003c\u003c 0x1f) {\n    __cxx11::collate\u003cchar\u003e::id \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_init": {
      "entrypoint": "0x080059f8",
      "current_name": "_init",
      "code": "\nvoid _init(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__do_global_dtors_aux",
        "__libc_init_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fini": {
      "entrypoint": "0x08005a04",
      "current_name": "_fini",
      "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}