{
    "functions": {
        "FUN_00113dfe": {
            "renaming": {
                "FUN_00113dfe": "update_memory_00113dfe",
                "param_1": "value",
                "param_2": "data",
                "lVar1": "memoryAddress"
            },
            "code": "\nvoid updateMemory_00113dfe(undefined4 value,undefined data)\n\n{\n  long memoryAddress;\n  \n  memoryAddress = FUN_00112904(3,value);\n  if (memoryAddress != 0) {\n    *(undefined *)(memoryAddress + 0x10) = data;\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113dfe",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "update_memory_00113dfe"
        },
        "bfd_get_mach": {
            "renaming": {},
            "code": "\nvoid bfd_get_mach(void)\n\n{\n  bfd_get_mach();\n  return;\n}\n\n",
            "called": [
                "bfd_get_mach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104650",
            "calling": [
                "FUN_00105828",
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "bfd_get_mach"
        },
        "bfd_close_all_done": {
            "renaming": {},
            "code": "\nvoid bfd_close_all_done(void)\n\n{\n  bfd_close_all_done();\n  return;\n}\n\n",
            "called": [
                "bfd_close_all_done"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104900",
            "calling": [
                "FUN_00104ea2",
                "FUN_00119f70",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_close_all_done"
        },
        "bfd_get_section_contents": {
            "renaming": {},
            "code": "\nvoid bfd_get_section_contents(void)\n\n{\n  bfd_get_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_get_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104260",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_get_section_contents"
        },
        "FUN_0010ab4d": {
            "renaming": {
                "FUN_0010ab4d": "append_to_log_0010ab4d",
                "param_1": "logStructPtr",
                "param_2": "logMessage",
                "param_3": "unusedParameter1",
                "param_4": "unusedParameter2",
                "uVar1": "logStructAddress",
                "lVar2": "logStructPtrCopy",
                "auVar3": "result",
                "sVar4": "messageLength",
                "pcVar5": "logPtr",
                "sVar6": "logPtrLength",
                "auVar7": "returnVal"
            },
            "code": "\nundefined  [16] appendToLog_0010ab4d(long logStructPtr,char *logMessage,undefined8 unusedParameter1,undefined8 unusedParameter2)\n\n{\n  ulong logStructAddress;\n  long logStructPtrCopy;\n  undefined result [16];\n  size_t messageLength;\n  char *logPtr;\n  size_t logPtrLength;\n  undefined returnVal [16];\n  \n  logStructAddress = *(ulong *)(logStructPtr + 0x60);\n  if ((logStructAddress != 0) && (*(long *)(logStructAddress + 0x20) != 0)) {\n    logPtr = *(char **)(logStructAddress + 0x30);\n    messageLength = strlen(logMessage);\n    if (logPtr == (char *)0x0) {\n      logPtr = (char *)xmalloc(messageLength + 3);\n      *logPtr = '\\0';\n    }\n    else {\n      logPtrLength = strlen(logPtr);\n      logPtr = (char *)xrealloc(logPtr,messageLength + 4 + logPtrLength);\n    }\n    messageLength = strlen(logPtr);\n    sprintf(logPtr + messageLength,\"%s::\",logMessage);\n    logStructPtrCopy = *(long *)(logStructPtr + 0x60);\n    *(char **)(logStructPtrCopy + 0x30) = logPtr;\n    returnVal._1_7_ = (undefined7)((ulong)logStructPtrCopy >> 8);\n    returnVal[0] = 1;\n    returnVal._8_8_ = unusedParameter2;\n    return returnVal;\n  }\n  result._8_8_ = 0;\n  result._0_8_ = logStructAddress;\n  return result << 0x40;\n}\n\n",
            "called": [
                "xmalloc",
                "xrealloc",
                "sprintf",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ab4d",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "append_to_log_0010ab4d"
        },
        "FUN_0010c218": {
            "renaming": {
                "FUN_0010c218": "process_file_type_0010c218",
                "param_1": "file_info",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "localized_message",
                "lVar2": "file_type",
                "pauVar3": "allocated_buffer",
                "lVar4": "current_file"
            },
            "code": "\n\n\nlong process_file_type_0010c218(long file_info,long param2,long param3)\n\n{\n  undefined8 localized_message;\n  long file_type;\n  undefined (*allocated_buffer) [16];\n  long current_file;\n  \n  if ((param2 != 0) && (param3 != 0)) {\n    if ((*(long *)(file_info + 8) == 0) || (*(long *)(file_info + 0x10) == 0)) {\n      localized_message = dcgettext(0,\"debug_name_type: no current file\",5);\n      fprintf(_stderr,\"%s\\n\",localized_message);\n    }\n    else {\n      file_type = FUN_00112904(0x16,0);\n      if (file_type != 0) {\n        allocated_buffer = (undefined (*) [16])xmalloc(0x10);\n        current_file = *(long *)(file_info + 0x10);\n        *allocated_buffer = ZEXT816(0);\n        *(long *)(*allocated_buffer + 8) = param3;\n        *(undefined (**) [16])(file_type + 0x10) = allocated_buffer;\n        current_file = FUN_00112925(current_file + 0x10,param2,0,3);\n        if (current_file != 0) {\n          *(long *)(current_file + 0x20) = file_type;\n          *(long *)*allocated_buffer = current_file;\n          return file_type;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc",
                "FUN_00112904",
                "FUN_00112925"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c218",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010dac0",
                "FUN_0011173a",
                "FUN_00112a33"
            ],
            "imported": false,
            "current_name": "process_file_type_0010c218"
        },
        "strncmp": {
            "renaming": {},
            "code": "\n\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = strncmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "strncmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040e0",
            "calling": [
                "FUN_00113fb0",
                "FUN_0010ee3f",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "strncmp"
        },
        "FUN_00116b90": {
            "renaming": {
                "FUN_00116b90": "FUNC_00116b90"
            },
            "code": "\n\n\nuint FUNC_00116b90(uint param_1,char **param_2)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  bool bVar5;\n  undefined *puVar6;\n  byte bVar7;\n  char cVar8;\n  int iVar9;\n  uint uVar10;\n  int iVar11;\n  undefined4 uVar12;\n  int iVar13;\n  FILE *pFVar14;\n  size_t sVar15;\n  byte *__s;\n  size_t sVar16;\n  byte *__ptr;\n  long lVar17;\n  char **ppcVar18;\n  long *__src;\n  char **ppcVar19;\n  undefined8 *puVar20;\n  char *__template;\n  FILE *pFVar21;\n  undefined8 uVar22;\n  FILE **ppFVar23;\n  undefined8 uVar24;\n  int *piVar25;\n  char *pcVar26;\n  ulong uVar27;\n  byte *pbVar28;\n  undefined **ppuVar29;\n  long lVar30;\n  byte *pbVar31;\n  char *pcVar32;\n  FILE *pFVar33;\n  char *pcVar34;\n  FILE *unaff_R12;\n  int iVar35;\n  uint uVar36;\n  char *unaff_R13;\n  byte bVar37;\n  FILE *pFVar38;\n  bool bVar39;\n  FILE *local_130;\n  FILE *local_120;\n  size_t local_118;\n  ulong local_110;\n  long *local_108;\n  FILE *local_d8;\n  FILE *local_d0;\n  undefined local_c8 [152];\n  \n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_00127600 = *param_2;\n  xmalloc_set_program_name();\n  ppcVar18 = param_2;\n  if (1 < (int)param_1) {\n    local_120 = (FILE *)0x7d0;\n    unaff_R13 = (char *)(ulong)param_1;\n    unaff_R12 = (FILE *)0x1;\n    iVar11 = 0;\n    do {\n      iVar13 = (int)unaff_R12;\n      lVar30 = (long)iVar13;\n      iVar35 = (int)unaff_R13;\n      if (*ppcVar18[lVar30] == '@') {\n        uVar10 = (int)local_120 - 1;\n        local_120 = (FILE *)(ulong)uVar10;\n        if (uVar10 == 0) {\n          pcVar32 = *ppcVar18;\n          pcVar26 = \"%s: error: too many @-files encountered\\n\";\nLAB_00118365:\n          fprintf(_stderr,pcVar26,pcVar32);\n                    \n          xexit(1);\n        }\n        pcVar32 = ppcVar18[lVar30] + 1;\n        iVar9 = stat(pcVar32,(stat *)local_c8);\n        if (iVar9 < 0) goto LAB_00116fd0;\n        if ((local_c8._24_4_ & 0xf000) == 0x4000) {\n          pcVar32 = *ppcVar18;\n          pcVar26 = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00118365;\n        }\n        pFVar14 = fopen(pcVar32,\"r\");\n        if (pFVar14 == (FILE *)0x0) goto LAB_00116fd0;\n        iVar9 = fseek(pFVar14,0,2);\n        if (((iVar9 == -1) || (sVar15 = ftell(pFVar14), sVar15 == 0xffffffffffffffff)) ||\n           (iVar9 = fseek(pFVar14,0,0), iVar9 == -1)) {\nLAB_00117070:\n          fclose(pFVar14);\n          if (iVar13 + 1 < iVar35) goto LAB_00116fde;\n          goto LAB_00117086;\n        }\n        __s = (byte *)xmalloc(sVar15 + 1);\n        sVar16 = fread(__s,1,sVar15,pFVar14);\n        if ((sVar15 != sVar16) && (iVar9 = ferror(pFVar14), iVar9 != 0)) {\n          free(__s);\n          goto LAB_00117070;\n        }\n        __s[sVar16] = 0;\n        bVar7 = *__s;\n        pbVar28 = __s;\n        if (bVar7 != 0) {\nLAB_00116d58:\n          if (((&_sch_istable)[(ulong)bVar7 * 2] & 0x40) != 0) goto LAB_00116d48;\n          sVar15 = strlen((char *)__s);\n          __ptr = (byte *)xmalloc(sVar15 + 1);\n          __src = (long *)0x0;\n          iVar9 = 0;\n          bVar39 = false;\n          bVar5 = false;\n          bVar4 = false;\n          local_110 = 0;\n          pbVar28 = __s;\n          do {\n            while (((&_sch_istable)[(ulong)*pbVar28 * 2] & 0x40) != 0) {\n              pbVar28 = pbVar28 + 1;\n            }\n            if ((iVar9 == 0) || (iVar9 + -1 <= (int)local_110)) {\n              if (__src == (long *)0x0) {\n                iVar9 = 8;\n                __src = (long *)xmalloc(0x40);\n                local_108 = __src + local_110;\n                *local_108 = 0;\n              }\n              else {\n                iVar9 = iVar9 * 2;\n                __src = (long *)xrealloc(__src,(long)iVar9 << 3);\n                local_108 = __src + local_110;\n                *local_108 = 0;\n              }\n            }\n            else {\n              local_108 = __src + local_110;\n            }\n            bVar7 = *pbVar28;\n            pbVar31 = __ptr;\n            while (bVar7 != 0) {\n              while( true ) {\n                if ((((&_sch_istable)[(ulong)bVar7 * 2] & 0x40) != 0) &&\n                   (!(bool)(bVar5 | bVar4 | bVar39))) {\n                  bVar4 = false;\n                  bVar39 = false;\n                  bVar5 = false;\n                  goto LAB_00116e3f;\n                }\n                if (!bVar4) break;\n                pbVar28 = pbVar28 + 1;\n                *pbVar31 = bVar7;\n                pbVar31 = pbVar31 + 1;\n                bVar4 = false;\n                bVar7 = *pbVar28;\n                if (bVar7 == 0) goto LAB_00116e3f;\n              }\n              if (bVar7 == 0x5c) {\n                bVar4 = true;\n              }\n              else if (bVar5) {\n                if (bVar7 == 0x27) {\n                  bVar5 = false;\n                }\n                else {\nLAB_00116fb1:\n                  *pbVar31 = bVar7;\n                  pbVar31 = pbVar31 + 1;\n                }\n              }\n              else if (bVar39) {\n                if (bVar7 != 0x22) goto LAB_00116fb1;\n                bVar39 = false;\n              }\n              else if (bVar7 == 0x27) {\n                bVar5 = true;\n              }\n              else {\n                if (bVar7 != 0x22) goto LAB_00116fb1;\n                bVar39 = true;\n              }\n              pbVar1 = pbVar28 + 1;\n              pbVar28 = pbVar28 + 1;\n              bVar7 = *pbVar1;\n            }\nLAB_00116e3f:\n            *pbVar31 = 0;\n            lVar17 = xstrdup(__ptr);\n            *local_108 = lVar17;\n            __src[local_110 + 1] = 0;\n            bVar7 = *pbVar28;\n            bVar2 = (&_sch_istable)[(ulong)bVar7 * 2];\n            while ((bVar2 & 0x40) != 0) {\n              bVar7 = pbVar28[1];\n              pbVar28 = pbVar28 + 1;\n              bVar2 = (&_sch_istable)[(ulong)bVar7 * 2];\n            }\n            local_110 = local_110 + 1;\n          } while (bVar7 != 0);\n          free(__ptr);\n          ppcVar19 = ppcVar18;\n          if (param_2 == ppcVar18) goto LAB_001172ad;\n          goto LAB_00116ed7;\n        }\nLAB_0011728f:\n        __src = (long *)xmalloc(8);\n        *__src = 0;\n        if (param_2 == ppcVar18) {\nLAB_001172ad:\n          if (*ppcVar18 == (char *)0x0) {\n            iVar9 = 0;\n          }\n          else {\n            lVar17 = 1;\n            do {\n              iVar9 = (int)lVar17;\n              ppcVar19 = ppcVar18 + lVar17;\n              lVar17 = lVar17 + 1;\n            } while (*ppcVar19 != (char *)0x0);\n          }\n          lVar17 = 0;\n          ppcVar19 = (char **)xmalloc((long)(iVar9 + 1) << 3);\n          pcVar32 = *ppcVar18;\n          while (pcVar32 != (char *)0x0) {\n            uVar24 = xstrdup();\n            *(undefined8 *)((long)ppcVar19 + lVar17) = uVar24;\n            lVar17 = lVar17 + 8;\n            pcVar32 = *(char **)((long)ppcVar18 + lVar17);\n          }\n          *(undefined8 *)((long)ppcVar19 + lVar17) = 0;\nLAB_00116ed7:\n          ppcVar18 = ppcVar19;\n          if (*__src == 0) goto LAB_00117768;\n          lVar17 = 0;\n          do {\n            lVar17 = lVar17 + 1;\n          } while (__src[lVar17] != 0);\n          local_118 = lVar17 * 8;\n        }\n        else {\nLAB_00117768:\n          lVar17 = 0;\n          local_118 = 0;\n        }\n        free(ppcVar18[lVar30]);\n        ppcVar18 = (char **)xrealloc(ppcVar18,(lVar17 + 1 + (long)iVar35) * 8);\n        uVar36 = iVar35 + -1 + (int)lVar17;\n        unaff_R13 = (char *)(ulong)uVar36;\n        memmove(ppcVar18 + lVar30 + lVar17,ppcVar18 + 1 + lVar30,(long)(iVar35 - iVar13) << 3);\n        memcpy(ppcVar18 + lVar30,__src,local_118);\n        free(__src);\n        free(__s);\n        fclose(pFVar14);\n        uVar10 = iVar11 + 1;\n        unaff_R12 = (FILE *)(lVar30 * 8);\n        if ((int)uVar36 <= (int)uVar10) goto LAB_00117086;\n      }\n      else {\nLAB_00116fd0:\n        if (iVar35 <= iVar13 + 1) goto LAB_00117086;\nLAB_00116fde:\n        uVar10 = iVar13 + 1;\n        iVar11 = iVar13;\n      }\n      unaff_R12 = (FILE *)(ulong)uVar10;\n    } while( true );\n  }\nLAB_0011708b:\n  DAT_00127a48 = 0;\n  DAT_00127a44 = 0;\n  iVar11 = bfd_init();\n  pcVar32 = \"fatal error: libbfd ABI mismatch\";\n  if (iVar11 != 0x118) {\nLAB_00117aed:\n    uVar24 = dcgettext(0,pcVar32,5);\n                    \n    FUN_00119dd0(uVar24);\n  }\n  pcVar32 = \"x86_64-pc-linux-gnu\";\n  bVar7 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n  pcVar26 = DAT_00127600;\n  if (bVar7 == 0) {\n    uVar12 = bfd_get_error();\n    pcVar26 = (char *)bfd_errmsg(uVar12);\n    pcVar34 = \"can\\'t set BFD default target to `%s\\': %s\";\nLAB_00118de6:\n    uVar24 = dcgettext(0,pcVar34,5);\n                    \n    FUN_00119dd0(uVar24,pcVar32,pcVar26);\n  }\n  uVar10 = _DAT_001264c0;\n  if ((int)_DAT_001264c0 < 0) {\n    sVar15 = strlen(DAT_00127600);\n    uVar10 = 0;\n    if (4 < (int)sVar15) {\n      iVar11 = filename_cmp(pcVar26 + (long)(int)sVar15 + -5,\"strip\");\n      uVar10 = (uint)(iVar11 == 0);\n    }\n  }\n  _DAT_001264c0 = uVar10;\n  DAT_00127a18 = FUN_00113f20();\n  DAT_00127a10 = FUN_00113f20();\n  DAT_00127a28 = FUN_00113f20();\n  DAT_00127a08 = FUN_00113f20();\n  DAT_00127a00 = FUN_00113f20();\n  DAT_001279f8 = FUN_00113f20();\n  DAT_001279f0 = FUN_00113f20();\n  DAT_001278f0 = htab_create_alloc(0x10,FUN_00108800,FUN_00108898);\n  DAT_001278e8 = FUN_00113f20();\n  puVar6 = PTR_DAT_001264e0;\n  if (__xexit_cleanup == (code *)0x0) {\n    __xexit_cleanup = FUN_0011a390;\n  }\n  if (0x1f < *(int *)(PTR_DAT_001264e0 + 8)) {\n    puVar20 = (undefined8 *)malloc(0x110);\n    if (puVar20 == (undefined8 *)0x0) goto LAB_001171a7;\n    *puVar20 = puVar6;\n    *(undefined4 *)(puVar20 + 1) = 0;\n    PTR_DAT_001264e0 = (undefined *)puVar20;\n  }\n  puVar6 = PTR_DAT_001264e0;\n  iVar11 = *(int *)(PTR_DAT_001264e0 + 8);\n  *(int *)(PTR_DAT_001264e0 + 8) = iVar11 + 1;\n  *(code **)(puVar6 + (long)iVar11 * 8 + 0x10) = FUN_001054af;\nLAB_001171a7:\n  bfd_set_error_program_name(*ppcVar18);\n  if (_DAT_001264c0 != 0) {\n    local_130 = (FILE *)0x0;\n    unaff_R12 = (FILE *)0x0;\n    ppuVar29 = (undefined **)(FILE *)0x0;\n    pFVar14 = (FILE *)0x0;\n    bVar37 = 0;\n    bVar2 = 0;\nswitchD_001177df_caseD_0:\n    do {\n      uVar12 = getopt_long(param_1,ppcVar18,\"I:O:F:K:MN:R:o:sSpdgxXHhVvwDU\",\n                           &PTR_s_disable_deterministic_archives_00126500);\n      pFVar21 = _optarg;\n      switch(uVar12) {\n      case 0x44:\n        _DAT_001264b0 = 1;\n        break;\n      case 0x48:\n      case 0x68:\n        FUN_00108a2a(_stdout,0);\n      case 0x46:\n        local_130 = _optarg;\n        pFVar14 = _optarg;\n        break;\n      case 0x49:\n        local_130 = _optarg;\n        break;\n      case 0x4b:\n        local_120 = _optarg;\n        ppFVar23 = (FILE **)htab_find_slot(DAT_00127a28,_optarg,1);\n        *ppFVar23 = pFVar21;\n        break;\n      case 0x4d:\n        DAT_00127a20 = bVar7;\n        bVar2 = bVar7;\n        break;\n      case 0x4e:\n        local_120 = _optarg;\n        ppFVar23 = (FILE **)htab_find_slot(DAT_00127a18,_optarg,1);\n        *ppFVar23 = pFVar21;\n        break;\n      case 0x4f:\n        pFVar14 = _optarg;\n        break;\n      case 0x52:\n        FUN_00114c20(_optarg);\n        break;\n      case 0x53:\n      case 100:\n      case 0x67:\n        DAT_00127a48 = 2;\n        break;\n      case 0x55:\n        _DAT_001264b0 = 0;\n        break;\n      case 0x56:\n        unaff_R12 = (FILE *)(ulong)bVar7;\n        break;\n      case 0x58:\n        DAT_00127a44 = 1;\n        break;\n      case 0x6f:\n        ppuVar29 = (undefined **)_optarg;\n        break;\n      case 0x70:\n        DAT_001279eb = 1;\n        break;\n      case 0x73:\n        DAT_00127a48 = 7;\n        break;\n      case 0x76:\n        DAT_001279e9 = 1;\n        break;\n      case 0x77:\n        DAT_001279ea = 1;\n        break;\n      case 0x78:\n        DAT_00127a44 = 2;\n        break;\n      case 0xa9:\n        bVar37 = bVar7;\n        break;\n      case 0xb2:\n        DAT_00127a38 = 1;\n        break;\n      case 0xb3:\n        FUN_00114190(_optarg,1,4);\n        break;\n      case 0xb5:\n        DAT_00127959 = 1;\n        break;\n      case 0xba:\n        DAT_00127a20 = 0;\n        bVar2 = bVar7;\n        break;\n      case 0xbc:\n        DAT_00127a48 = 4;\n        break;\n      case 0xc6:\n        FUN_00114190(_optarg,1,0x100);\n        break;\n      case 0xd0:\n        DAT_00127a48 = 5;\n        break;\n      case 0xd2:\n        goto switchD_001177df_caseD_d2;\n      default:\n        if (((bVar2 == 0) && (DAT_00127a48 < 8)) &&\n           ((-0xdaL >> ((byte)DAT_00127a48 & 0x3f) & 1U) == 0)) {\n          DAT_00127a20 = 1;\n        }\n        if (bVar37 != 0) goto LAB_00118a4c;\n        if ((char)unaff_R12 != '\\0') {\n          FUN_00119970(\"strip\");\n          goto LAB_001189a2;\n        }\n        if (_DAT_001264b0 < 0) {\n          _DAT_001264b0 = 1;\n        }\n        if (((DAT_00127a48 | DAT_00127a44) == 0) &&\n           (lVar30 = htab_elements(DAT_00127a18), lVar30 == 0)) {\n          DAT_00127a48 = 7;\n        }\n        if (pFVar14 == (FILE *)0x0) {\n          pFVar14 = local_130;\n        }\n        unaff_R12 = (FILE *)(long)(int)_optind;\n        if ((_optind != param_1) &&\n           (((FILE *)ppuVar29 == (FILE *)0x0 || ((int)param_1 <= (int)(_optind + 1)))))\n        goto LAB_00117888;\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 0xb:\n      case 0xc:\n      case 0xd:\n      case 0xe:\n      case 0xf:\n      case 0x10:\n      case 0x11:\n      case 0x12:\n      case 0x13:\n      case 0x14:\n      case 0x15:\n      case 0x16:\n      case 0x17:\n      case 0x18:\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x1c:\n      case 0x1d:\n      case 0x1e:\n      case 0x1f:\n      case 0x20:\n      case 0x21:\n      case 0x22:\n      case 0x23:\n      case 0x24:\n      case 0x25:\n      case 0x26:\n      case 0x27:\n      case 0x28:\n      case 0x29:\n      case 0x2a:\n      case 0x2b:\n      case 0x2c:\n      case 0x2d:\n      case 0x2e:\n      case 0x2f:\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n      case 0x3a:\n      case 0x3b:\n      case 0x3c:\n      case 0x3d:\n      case 0x3e:\n      case 0x3f:\n      case 0x40:\n      case 0x41:\n      case 0x42:\n      case 0x43:\n      case 0x45:\n      case 0x47:\n      case 0x4a:\n      case 0x4c:\n      case 0x50:\n      case 0x51:\n      case 0x54:\n      case 0x57:\n      case 0x59:\n      case 0x5a:\n      case 0x5b:\n      case 0x5c:\n      case 0x5d:\n      case 0x5e:\n      case 0x5f:\n      case 0x60:\n      case 0x61:\n      case 0x62:\n      case 99:\n      case 0x65:\n      case 0x66:\n      case 0x69:\n      case 0x6a:\n      case 0x6b:\n      case 0x6c:\n      case 0x6d:\n      case 0x6e:\n      case 0x71:\n      case 0x72:\n      case 0x74:\n      case 0x75:\n      case 0x79:\n      case 0x7a:\n      case 0x7b:\n      case 0x7c:\n      case 0x7d:\n      case 0x7e:\n      case 0x7f:\n      case 0x80:\n      case 0x81:\n      case 0x82:\n      case 0x83:\n      case 0x84:\n      case 0x85:\n      case 0x86:\n      case 0x87:\n      case 0x88:\n      case 0x89:\n      case 0x8a:\n      case 0x8b:\n      case 0x8c:\n      case 0x8d:\n      case 0x8e:\n      case 0x8f:\n      case 0x90:\n      case 0x91:\n      case 0x92:\n      case 0x93:\n      case 0x94:\n      case 0x95:\n      case 0x96:\n      case 0x97:\n      case 0x98:\n      case 0x99:\n      case 0x9a:\n      case 0x9b:\n      case 0x9c:\n      case 0x9d:\n      case 0x9e:\n      case 0x9f:\n      case 0xa0:\n      case 0xa1:\n      case 0xa2:\n      case 0xa3:\n      case 0xa4:\n      case 0xa5:\n      case 0xa6:\n      case 0xa7:\n      case 0xa8:\n      case 0xaa:\n      case 0xab:\n      case 0xac:\n      case 0xad:\n      case 0xae:\n      case 0xaf:\n      case 0xb0:\n      case 0xb1:\n      case 0xb4:\n      case 0xb6:\n      case 0xb7:\n      case 0xb8:\n      case 0xb9:\n      case 0xbb:\n      case 0xbd:\n      case 0xbe:\n      case 0xbf:\n      case 0xc0:\n      case 0xc1:\n      case 0xc2:\n      case 0xc3:\n      case 0xc4:\n      case 0xc5:\n      case 199:\n      case 200:\n      case 0xc9:\n      case 0xca:\n      case 0xcb:\n      case 0xcc:\n      case 0xcd:\n      case 0xce:\n      case 0xcf:\n      case 0xd1:\n        FUN_00108a2a(_stderr,1);\n        unaff_R13 = (char *)&PTR_s_disable_deterministic_archives_00126500;\n        goto switchD_00117234_caseD_c1;\n      }\n    } while( true );\n  }\n  local_108 = (long *)0x0;\n  local_d8 = (FILE *)0x0;\n  local_d0 = (FILE *)0x0;\n  local_130 = (FILE *)(ulong)bVar7;\n  local_120 = (FILE *)0x0;\n  local_118 = 0;\n  local_110 = 0;\n  ppuVar29 = (undefined **)(FILE *)0x0;\n  bVar2 = 0;\nswitchD_00117234_caseD_0:\n  uVar36 = getopt_long(param_1,ppcVar18,\"b:B:i:I:j:K:MN:s:O:d:F:L:G:R:SpgxXHhVvW:wDU\",\n                       &PTR_s_add_gnu_debuglink_00126900);\n  pFVar14 = _optarg;\n  uVar10 = DAT_00127908;\n  pcVar26 = (char *)(ulong)uVar36;\n  if (uVar36 != 0xffffffff) goto code_r0x00117223;\n  if (bVar2 != 0) {\n    pcVar32 = \"--globalize-symbol(s) is incompatible with -G/--keep-global-symbol(s)\";\n    if ((char)local_108 != '\\0') goto LAB_00117aed;\n  }\n  if ((char)local_118 != '\\0') {\nLAB_00118a4c:\n    FUN_001199d0();\n    return DAT_00127a40;\n  }\n  if ((char)local_110 != '\\0') {\n    FUN_00119970(\"objcopy\");\n    goto LAB_00118398;\n  }\n  if ((DAT_00127a3c != 0) && (DAT_001264bc == -1)) {\n    pcVar32 = \"interleave start byte must be set with --byte\";\n    goto LAB_00117aed;\n  }\n  if (DAT_00127a3c <= DAT_001264bc) {\n    pcVar32 = \"byte number must be less than interleave\";\n    goto LAB_00117aed;\n  }\n  pcVar32 = \"interleave width must be less than or equal to interleave - byte`\";\n  if (DAT_00127a3c - DAT_001264bc < DAT_001264b8) goto LAB_00117aed;\n  if ((_optind == param_1) || ((int)(_optind + 2) < (int)param_1)) goto switchD_00117234_caseD_1;\n  pcVar32 = ppcVar18[(int)_optind];\n  if ((int)(_optind + 1) < (int)param_1) {\n    pcVar34 = ppcVar18[(long)(int)_optind + 1];\n  }\n  else {\n    pcVar34 = (char *)0x0;\n  }\n  if (_DAT_001264b0 < 0) {\n    _DAT_001264b0 = 1;\n  }\n  if ((DAT_00127a48 | DAT_00127a44) == 0) {\n    DAT_00127a48 = 1;\n  }\n  if (local_d0 == (FILE *)0x0) {\n    local_d0 = local_d8;\n    if (local_d8 != (FILE *)0x0) {\nLAB_00117661:\n      cVar8 = FUN_00113fb0(local_d8,&DAT_0011b300);\n      if (cVar8 != '\\0') {\n        iVar11 = FUN_00108c86(&local_d8);\n        if (iVar11 < 0) {\n          pcVar32 = \"unknown input EFI target: %s\";\n          pFVar14 = local_d8;\n          goto LAB_001176c2;\n        }\n        if (local_d0 == (FILE *)0x0) goto LAB_0011743e;\n      }\n      goto LAB_001175b1;\n    }\n  }\n  else {\n    if (local_d8 != (FILE *)0x0) goto LAB_00117661;\nLAB_001175b1:\n    cVar8 = FUN_00113fb0(local_d0,&DAT_0011b300);\n    if (cVar8 != '\\0') {\n      iVar11 = FUN_00108c86(&local_d0);\n      if (iVar11 < 0) {\n        pcVar32 = \"unknown output EFI target: %s\";\n        pFVar14 = local_d0;\n        goto LAB_001176c2;\n      }\n      if (DAT_00126474 == -1) {\n        DAT_00126474 = (short)iVar11;\n      }\n      if (DAT_001264a8 == -1) {\n        DAT_001264a8 = 0x200;\n      }\n      if (DAT_00126488 == -1) {\n        DAT_00126488 = 0x1000;\n      }\n    }\n  }\nLAB_0011743e:\n  if ((pcVar34 == (char *)0x0) || (uVar10 = filename_cmp(pcVar32,pcVar34), uVar10 == 0)) {\n    __template = (char *)FUN_00114cf0(pcVar32);\n    uVar36 = mkstemp(__template);\n    if (uVar36 == 0xffffffff) {\n      free(__template);\n      piVar25 = __errno_location();\n      pcVar26 = strerror(*piVar25);\n      pcVar34 = \"warning: could not create temporary file whilst copying \\'%s\\', (error: %s)\";\n      goto LAB_00118de6;\n    }\n    uVar10 = uVar36;\n    if (-1 < (int)uVar36) {\n      uVar10 = dup(uVar36);\n      pcVar26 = (char *)(ulong)uVar10;\n    }\n  }\n  else {\n    uVar36 = 0xffffffff;\n    __template = pcVar34;\n  }\n  FUN_00114690(pcVar32,__template,uVar36,local_c8,local_d8,local_d0,local_120,uVar10);\n  if (DAT_00127a40 == 0) {\n    if (pcVar34 != (char *)0x0) {\n      pcVar32 = pcVar34;\n    }\n    iVar11 = FUN_00115970(__template,pcVar32,pcVar26,local_c8,DAT_001279eb);\n    DAT_00127a40 = (uint)(iVar11 != 0);\n  }\n  else {\n    if (-1 < (int)pcVar26) {\n      close((int)pcVar26);\n    }\n    unlink_if_ordinary(__template);\n  }\n  if (pcVar34 != __template) {\n    free(__template);\n  }\n  puVar20 = DAT_00127900;\n  if ((char)local_130 != '\\0') {\n    for (; puVar20 != (undefined8 *)0x0; puVar20 = (undefined8 *)*puVar20) {\n      if (*(char *)(puVar20 + 2) == '\\0') {\n        uVar10 = *(uint *)((long)puVar20 + 0x14);\n        if ((uVar10 & 0x18) != 0) {\n          uVar24 = puVar20[3];\n          uVar3 = puVar20[1];\n          uVar22 = dcgettext(0,\"%s %s%c0x%lx never used\",5);\n          FUN_00119ed0(uVar22,\"--change-section-vma\",uVar3,\n                       (-(uint)((uVar10 & 8) == 0) & 0xffffffee) + 0x3d,uVar24);\n          uVar10 = *(uint *)((long)puVar20 + 0x14);\n        }\n        if ((uVar10 & 0x60) != 0) {\n          uVar24 = puVar20[4];\n          uVar3 = puVar20[1];\n          uVar22 = dcgettext(0,\"%s %s%c0x%lx never used\",5);\n          FUN_00119ed0(uVar22,\"--change-section-lma\",uVar3,\n                       (-(uint)((uVar10 & 0x20) == 0) & 0xffffffee) + 0x3d,uVar24);\n        }\n      }\n    }\n  }\n  free(DAT_00127970);\n  free(DAT_00127968);\n  free(DAT_00127960);\n  free(DAT_00127950);\n  free(DAT_00127948);\n  free(DAT_00127940);\n  free(DAT_00127938);\n  return DAT_00127a40;\nLAB_00116d48:\n  bVar7 = pbVar28[1];\n  pbVar28 = pbVar28 + 1;\n  if (bVar7 == 0) goto LAB_0011728f;\n  goto LAB_00116d58;\nLAB_00117086:\n  param_1 = (uint)unaff_R13;\n  goto LAB_0011708b;\nLAB_00117888:\n  uVar10 = DAT_00127a40;\n  if ((int)param_1 <= (int)unaff_R12) {\n    return DAT_00127a40;\n  }\n  lVar30 = FUN_00113f50(ppcVar18[(long)unaff_R12]);\n  if (lVar30 < 1) {\nLAB_00118edb:\n    DAT_00127a40 = 1;\n  }\n  else {\n    pcVar32 = ppcVar18[(long)unaff_R12];\n    if ((FILE *)ppuVar29 == (FILE *)0x0) {\nLAB_001178b9:\n      pFVar21 = (FILE *)FUN_00114cf0(pcVar32);\n      iVar11 = mkstemp((char *)pFVar21);\n      if (iVar11 == -1) {\n        free(pFVar21);\n        uVar24 = dcgettext(0,\"could not create temporary file to hold stripped copy\",5);\n        FUN_001126c0(ppcVar18[(long)unaff_R12],0,0,uVar24);\n        goto LAB_00118edb;\n      }\n      iVar13 = -1;\n      if (-1 < iVar11) {\n        iVar13 = dup(iVar11);\n      }\n    }\n    else {\n      iVar11 = filename_cmp(pcVar32,ppuVar29);\n      if (iVar11 == 0) {\n        pcVar32 = ppcVar18[(long)unaff_R12];\n        goto LAB_001178b9;\n      }\n      iVar11 = -1;\n      iVar13 = -1;\n      pFVar21 = (FILE *)ppuVar29;\n    }\n    DAT_00127a40 = 0;\n    FUN_00114690(ppcVar18[(long)unaff_R12],pFVar21,iVar11,local_c8,local_130,pFVar14,0);\n    if (DAT_00127a40 == 0) {\n      pFVar33 = (FILE *)ppuVar29;\n      if ((FILE *)ppuVar29 == (FILE *)0x0) {\n        pFVar33 = (FILE *)ppcVar18[(long)unaff_R12];\n      }\n      iVar11 = FUN_00115970(pFVar21,pFVar33,iVar13,local_c8,DAT_001279eb);\n      DAT_00127a40 = uVar10;\n      if (iVar11 != 0) {\n        DAT_00127a40 = 1;\n      }\n    }\n    else {\n      if (-1 < iVar13) {\n        close(iVar13);\n      }\n      unlink_if_ordinary(pFVar21);\n    }\n    if ((FILE *)ppuVar29 != pFVar21) {\n      free(pFVar21);\n    }\n  }\n  unaff_R12 = (FILE *)((long)&unaff_R12->_flags + 1);\n  goto LAB_00117888;\nswitchD_001177df_caseD_d2:\n  DAT_00127a48 = 3;\n  goto switchD_001177df_caseD_0;\nLAB_001189a2:\n  pcVar32 = \"bad format for --set-section-alignment: numeric argument needed\";\n  goto LAB_00117aed;\nLAB_00119858:\n  if (iVar13 == 10) goto LAB_0011902d;\n  if (iVar13 == 0xd) goto LAB_00119866;\n  if (iVar13 + 1U < 2) goto LAB_001198cd;\n  if ((iVar13 != 0x20) && (iVar13 != 9)) {\n    if (iVar13 != 0x23) goto LAB_001198d6;\n    goto LAB_001198ec;\n  }\n  iVar13 = getc((FILE *)ppuVar29);\n  goto LAB_00119858;\nLAB_0011902d:\n  if (iVar13 == 0xd) {\nLAB_00119866:\n    iVar13 = getc((FILE *)ppuVar29);\n    if (iVar13 == 10) {\n      if (*(char *)(int *)unaff_R13 != '\\0') {\n        FUN_00108d9a(pFVar14,unaff_R13,\n                     (undefined *)((long)&unaff_R12->_flags + (long)(int *)unaff_R13));\n      }\n      goto LAB_0011988e;\n    }\nLAB_001198cd:\n    if (iVar13 != -1) {\nLAB_001198d6:\n      pcVar32 = \"%s:%d: garbage found at end of line\";\nLAB_00119756:\n      uVar24 = dcgettext(0,pcVar32,5);\n                    \n      FUN_00119dd0(uVar24,pFVar14,iVar11 + -1);\n    }\n  }\n  else {\n    iVar13 = 10;\n  }\nLAB_0011903b:\n  if (*(char *)(int *)unaff_R13 != '\\0') {\n    FUN_00108d9a(pFVar14,unaff_R13,(undefined *)((long)&unaff_R12->_flags + (long)(int *)unaff_R13))\n    ;\n  }\n  unaff_R12 = (FILE *)ppuVar29;\n  if (iVar13 == -1) goto LAB_00119065;\nLAB_0011988e:\n  iVar13 = getc((FILE *)ppuVar29);\n  iVar11 = iVar11 + 1;\n  goto LAB_00118ace;\nswitchD_00117234_caseD_c7:\n  pcVar32 = strchr((char *)_optarg,0x3d);\n  if ((pcVar32 != (char *)0x0) && ((int)pcVar32 != iVar11)) {\n    uVar27 = (long)pcVar32 - (long)pFVar14 & 0xffffffff;\n    pcVar34 = pcVar32 + 1;\n    pcVar26 = (char *)xmalloc((int)((long)pcVar32 - (long)pFVar14) + 1);\n    strncpy(pcVar26,(char *)_optarg,uVar27);\n    pcVar26[uVar27] = '\\0';\n    pcVar32 = strchr(pcVar34,0x2c);\n    if (pcVar32 == (char *)0x0) {\n      unaff_R12 = (FILE *)0xffffffff;\n      sVar15 = strlen(pcVar34);\n      sVar15 = sVar15 & 0xffffffff;\n    }\n    else {\n      sVar15 = (size_t)(uint)((int)pcVar32 - (int)pcVar34);\n      uVar10 = FUN_00113fe0(pcVar32 + 1);\n      unaff_R12 = (FILE *)(ulong)uVar10;\n    }\n    if ((int)sVar15 != 0) {\n      unaff_R13 = (char *)xmalloc((int)sVar15 + 1);\n      strncpy(unaff_R13,pcVar34,sVar15);\n      *(undefined *)((long)(int *)unaff_R13 + sVar15) = 0;\n      ppuVar29 = (undefined **)DAT_001278f8;\n      goto LAB_00117f6f;\n    }\n  }\n  uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n  FUN_00119dd0(uVar24,\"--rename-section\");\ncode_r0x00117223:\n  iVar11 = (int)_optarg;\n  switch(pcVar26) {\n  case (char *)0x0:\n    goto switchD_00117234_caseD_0;\n  default:\nswitchD_00117234_caseD_1:\n    FUN_00108916(_stderr,1);\n    do {\n      iVar11 = strcmp(*ppuVar29,pcVar26);\n      if (iVar11 == 0) {\n        iVar11 = strcmp(*(char **)((long)ppuVar29 + 8),unaff_R13);\n        if ((iVar11 != 0) || ((int)unaff_R12 != *(int *)((long)ppuVar29 + 0x10))) {\n          uVar24 = dcgettext(0,\"Multiple renames of section %s\",5);\n                    \n          FUN_00119dd0(uVar24,pcVar26);\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      ppuVar29 = (undefined **)*(FILE **)((long)ppuVar29 + 0x18);\nLAB_00117f6f:\n    } while ((FILE *)ppuVar29 != (FILE *)0x0);\n    pFVar14 = (FILE *)xmalloc(0x20);\n    *(char **)pFVar14 = pcVar26;\n    pFVar14->_IO_read_ptr = unaff_R13;\n    *(int *)&pFVar14->_IO_read_end = (int)unaff_R12;\n    pFVar14->_IO_read_base = (char *)DAT_001278f8;\n    DAT_001278f8 = pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x42:\n    ppuVar29 = (undefined **)&optarg;\n    local_120 = (FILE *)bfd_scan_arch(_optarg);\n    if (local_120 != (FILE *)0x0) goto switchD_00117234_caseD_0;\n    pcVar32 = \"architecture %s unknown\";\n    pFVar14 = _optarg;\n    break;\n  case (char *)0x44:\n    _DAT_001264b0 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x46:\n    local_d0 = _optarg;\n    local_d8 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x47:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_001279f8,_optarg,1);\n    *ppFVar23 = pFVar14;\n    local_108 = (long *)(ulong)bVar7;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x48:\n  case (char *)0x68:\n    FUN_00108916(_stdout,0);\n  case (char *)0xcd:\n    _bfd_srec_forceS3 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x49:\n  case (char *)0x73:\n    local_d8 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4b:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_00127a28,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4c:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_00127a08,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4d:\n    DAT_00127a20 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4e:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_00127a18,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x4f:\n  case (char *)0x64:\n    local_d0 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x52:\n    FUN_00114c20(_optarg);\n    goto switchD_00117234_caseD_0;\n  case (char *)0x53:\n    DAT_00127a48 = 7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x55:\n    _DAT_001264b0 = 0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x56:\n    local_110 = (ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x57:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_001279f0,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x58:\n    DAT_00127a44 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x62:\n    lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n    DAT_001264bc = (int)lVar30;\n    if (DAT_001264bc < 0) {\n      pcVar32 = \"byte number must be non-negative\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x67:\n    DAT_00127a48 = 2;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x69:\n    if (_optarg == (FILE *)0x0) {\n      DAT_00127a3c = 4;\n    }\n    else {\n      lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n      DAT_00127a3c = (int)lVar30;\n      if (DAT_00127a3c < 1) {\n        pcVar32 = \"interleave must be positive\";\n        goto LAB_00117aed;\n      }\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x6a:\n    FUN_00114190(_optarg,1,2);\n    DAT_00127a39 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x70:\n    DAT_001279eb = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x76:\n    DAT_001279e9 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x77:\n    DAT_001279ea = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x78:\n    DAT_00127a44 = 2;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x96:\n    DAT_001279e0 = FUN_00114c80(_optarg,DAT_001279e0,\"--add-section\");\n    FUN_00114d60(DAT_001279e0);\n    goto switchD_00117234_caseD_0;\n  case (char *)0x97:\n    DAT_001264b4 = 1;\n    DAT_00127a30 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x98:\n    puVar20 = (undefined8 *)xmalloc(0x30);\n    *puVar20 = 0;\n    unaff_R13 = (char *)_optarg;\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      FUN_00119dd0(uVar24,\"--add-symbol\");\n    }\n    ppuVar29 = (undefined **)(pcVar32 + 1);\n    pcVar32 = strchr((char *)ppuVar29,0x3a);\n    uVar24 = FUN_0011a480(unaff_R13);\n    puVar20[1] = uVar24;\n    if (pcVar32 == (char *)0x0) {\n      puVar20[4] = 0;\n      lVar30 = strtol((char *)ppuVar29,(char **)0x0,0);\n    }\n    else {\n      uVar24 = FUN_0011a480(ppuVar29);\n      puVar20[4] = uVar24;\n      lVar30 = strtol((char *)(FILE *)(pcVar32 + 1),(char **)0x0,0);\n      ppuVar29 = (undefined **)(FILE *)(pcVar32 + 1);\n    }\n    puVar20[2] = lVar30;\n    pcVar32 = strchr((char *)ppuVar29,0x2c);\n    puVar20[5] = 0;\n    if (pcVar32 == (char *)0x0) {\n      *(undefined4 *)(puVar20 + 3) = 2;\n      unaff_R12 = (FILE *)0x0;\n    }\n    else {\n      ppuVar29 = (undefined **)0x0;\n      pFVar14 = (FILE *)(pcVar32 + 1);\n      do {\n        unaff_R12 = pFVar14;\n        pcVar32 = strchr((char *)unaff_R12,0x2c);\n        if (pcVar32 == (char *)0x0) {\n          sVar15 = strlen((char *)unaff_R12);\n          pFVar14 = (FILE *)0x0;\n        }\n        else {\n          pFVar14 = (FILE *)(pcVar32 + 1);\n          sVar15 = (long)pcVar32 - (long)unaff_R12;\n        }\n        uVar10 = (uint)ppuVar29;\n        if (sVar15 == 5) {\n          iVar11 = strncasecmp(\"local\",(char *)unaff_R12,5);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 1);\n          }\n          else {\n            iVar11 = strncasecmp(\"debug\",(char *)unaff_R12,5);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 4);\n          }\n        }\n        else if (sVar15 == 6) {\n          iVar11 = strncasecmp(\"global\",(char *)unaff_R12,6);\n          if ((iVar11 == 0) || (iVar11 = strncasecmp(\"export\",(char *)unaff_R12,6), iVar11 == 0)) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 2);\n          }\n          else {\n            iVar11 = strncasecmp(\"object\",(char *)unaff_R12,6);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 0x10000);\n          }\n        }\n        else if (sVar15 == 8) {\n          iVar11 = strncasecmp(\"function\",(char *)unaff_R12,8);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)(ulong)(uVar10 | 8);\n          }\n          else {\n            iVar11 = strncasecmp(\"indirect\",(char *)unaff_R12,8);\n            if (iVar11 != 0) goto LAB_0011862f;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x2000);\n          }\n        }\n        else if (sVar15 == 4) {\n          iVar11 = strncasecmp(\"weak\",(char *)unaff_R12,4);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x80);\n          }\n          else {\n            iVar11 = strncasecmp(\"file\",(char *)unaff_R12,4);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x4000);\n          }\n        }\n        else if (sVar15 == 7) {\n          iVar11 = strncasecmp(\"section\",(char *)unaff_R12,7);\n          if (iVar11 == 0) {\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x100);\n          }\n          else {\n            iVar11 = strncasecmp(\"warning\",(char *)unaff_R12,7);\n            if (iVar11 != 0) goto LAB_001186b2;\n            ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x1000);\n          }\n        }\n        else {\n          if (sVar15 == 0xb) {\n            iVar11 = strncasecmp(\"constructor\",(char *)unaff_R12,0xb);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)((ulong)ppuVar29 | 0x800);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 9) {\n            iVar11 = strncasecmp(\"synthetic\",(char *)unaff_R12,9);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x200000);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 0x11) {\n            iVar11 = strncasecmp(\"indirect-function\",(char *)unaff_R12,0x11);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x400008);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 == 0xd) {\n            iVar11 = strncasecmp(\"unique-object\",(char *)unaff_R12,0xd);\n            if (iVar11 == 0) {\n              ppuVar29 = (undefined **)(ulong)(uVar10 | 0x810000);\n              goto LAB_00117e3d;\n            }\n          }\n          else if (sVar15 < 8) goto LAB_001186b2;\nLAB_0011862f:\n          iVar11 = strncasecmp(\"before=\",(char *)unaff_R12,7);\n          if (iVar11 != 0) {\nLAB_001186b2:\n            pcVar32 = (char *)xmalloc(sVar15 + 1);\n            strncpy(pcVar32,(char *)unaff_R12,sVar15);\n            pcVar32[sVar15] = '\\0';\n            uVar24 = dcgettext(0,\"unrecognized symbol flag `%s\\'\",5);\n            FUN_00119ed0(uVar24,pcVar32);\n            uVar24 = dcgettext(0,\"supported flags: %s\",5);\n                    \n            FUN_00119dd0(uVar24,\n                         \"local, global, export, debug, function, weak, section, constructor, warning, indirect, file, object, synthetic, indirect-function, unique-object, before=<othersym>\"\n                        );\n          }\n          uVar24 = FUN_0011a480(&unaff_R12->field_0x7,sVar15 - 7);\n          puVar20[5] = uVar24;\n        }\nLAB_00117e3d:\n      } while (pFVar14 != (FILE *)0x0);\n      *(int *)(puVar20 + 3) = (int)ppuVar29;\n      unaff_R13 = (char *)0x0;\n      if (puVar20[5] != 0) {\n        *puVar20 = DAT_001279c8;\n        bVar39 = DAT_001279c8 == (undefined8 *)0x0;\n        DAT_001279c8 = puVar20;\n        if (bVar39) {\n          PTR_DAT_001275c0 = (undefined *)puVar20;\n        }\n        goto LAB_00117e65;\n      }\n    }\n    *(undefined8 **)PTR_DAT_001275c0 = puVar20;\n    PTR_DAT_001275c0 = (undefined *)puVar20;\nLAB_00117e65:\n    DAT_001279c0 = DAT_001279c0 + 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x99:\n    DAT_00127930 = strtoul((char *)_optarg,(char **)0x0,0);\n    if (DAT_00127930 == 0) {\n      pcVar32 = \"unable to parse alternative machine code\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9a:\n    _DAT_001279b0 = FUN_00119940(_optarg,\"--change-addresses\");\n    DAT_001279b8 = _DAT_001279b0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9b:\n    DAT_001279a8 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9c:\n  case (char *)0x9d:\n  case (char *)0x9e:\n    ppuVar29 = (undefined **)strchr((char *)_optarg,0x3d);\n    if (uVar36 == 0x9d) {\n      uVar12 = 0x40;\n      unaff_R13 = \"--change-section-lma\";\n      if ((FILE *)ppuVar29 != (FILE *)0x0) {\n        uVar12 = 0x20;\n        goto LAB_00117a19;\n      }\n    }\n    else if (uVar36 == 0x9e) {\n      if ((FILE *)ppuVar29 != (FILE *)0x0) {\n        unaff_R13 = \"--change-section-vma\";\n        uVar12 = 8;\n        goto LAB_00117a19;\n      }\n      uVar12 = 0x10;\n      unaff_R13 = \"--change-section-vma\";\n    }\n    else {\n      unaff_R13 = \"--change-section-address\";\n      uVar12 = 0x28;\n      if ((FILE *)ppuVar29 != (FILE *)0x0) goto LAB_00117a19;\n      uVar12 = 0x50;\n    }\n    ppuVar29 = (undefined **)strchr((char *)pFVar14,0x2b);\n    if (((FILE *)ppuVar29 == (FILE *)0x0) &&\n       (ppuVar29 = (undefined **)strchr((char *)pFVar14,0x2d), (FILE *)ppuVar29 == (FILE *)0x0)) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      FUN_00119dd0(uVar24,unaff_R13);\n    }\nLAB_00117a19:\n    iVar11 = (int)ppuVar29 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    unaff_R12 = (FILE *)(long)iVar11;\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(size_t)unaff_R12);\n    pcVar32[(long)unaff_R12] = '\\0';\n    lVar30 = FUN_00114190(pcVar32,1,uVar12);\n    lVar17 = FUN_00119940((undefined *)((long)(int *)ppuVar29 + 1),unaff_R13);\n    if (*(char *)(int *)ppuVar29 == '-') {\n      lVar17 = -lVar17;\n    }\n    if ((uVar36 == 0x9d) || (*(long *)(lVar30 + 0x18) = lVar17, uVar36 != 0x9e)) {\n      *(long *)(lVar30 + 0x20) = lVar17;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0x9f:\n    DAT_001279b8 = FUN_00119940(_optarg,\"--change-start\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa0:\n    local_130 = (FILE *)(ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa1:\n    ppuVar29 = (undefined **)_optarg;\n    if (_optarg == (FILE *)0x0) {\nLAB_00118398:\n      DAT_001279a4 = 1;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)_optarg,\"none\");\n    if (iVar11 == 0) {\n      DAT_001279a4 = 0x20;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib\");\n    if (iVar11 == 0) {\n      DAT_001279a4 = 3;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib-gnu\");\n    if (iVar11 == 0) {\n      DAT_001279a4 = 5;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zlib-gabi\");\n    if (iVar11 == 0) {\n      DAT_001279a4 = 9;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"zstd\");\n    if (iVar11 == 0) {\n      DAT_001279a4 = 0x11;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unrecognized --compress-debug-sections type `%s\\'\";\n    break;\n  case (char *)0xa2:\n    DAT_001279a0 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa3:\n    DAT_001279a4 = 0x20;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa4:\n    DAT_001279d0 = FUN_00114c80(_optarg,DAT_001279d0,\"--dump-section\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa5:\n    iVar11 = strcasecmp((char *)_optarg,\"yes\");\n    if (iVar11 == 0) {\n      DAT_0012799c = 1;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcasecmp((char *)pFVar14,\"no\");\n    if (iVar11 == 0) {\n      DAT_0012799c = 2;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unrecognized --elf-stt-common= option `%s\\'\";\n    break;\n  case (char *)0xa6:\n    DAT_00127a48 = 6;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa7:\n    DAT_0012790c = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa8:\n    DAT_001264a8 = FUN_00119940(_optarg,\"--file-alignment\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xa9:\n    local_118 = (size_t)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xaa:\n    ppuVar29 = (undefined **)FUN_00119940(_optarg,\"--gap-fill\");\n    DAT_00127999 = SUB81(ppuVar29,0);\n    if ((FILE *)0xff < ppuVar29) {\n      uVar24 = dcgettext(0,\"Warning: truncating gap-fill from 0x%lx to 0x%x\",5);\n      FUN_00119ed0(uVar24,ppuVar29,(ulong)ppuVar29 & 0xff);\n    }\n    DAT_00127998 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xab:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_00127a00,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    bVar2 = bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xac:\n    FUN_00114460(_optarg,DAT_00127a00,&DAT_00127948);\n    bVar2 = bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xad:\n    DAT_001264a0 = strtoul((char *)_optarg,(char **)(FILE *)local_c8,0);\n    unaff_R12 = _optarg;\n    ppuVar29 = (undefined **)(FILE *)local_c8;\n    if ((FILE *)local_c8._0_8_ != _optarg) {\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        DAT_00126498 = strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)(FILE *)local_c8,0\n                              );\n        pFVar14 = _optarg;\n        if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n          uVar24 = dcgettext(0,\"%s: invalid commit value for --heap\",5);\n          FUN_00119ed0(uVar24,pFVar14);\n          ppuVar29 = (undefined **)pFVar14;\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      if (*(char *)(int *)local_c8._0_8_ == '\\0') goto switchD_00117234_caseD_0;\n    }\n    uVar24 = dcgettext(0,\"%s: invalid reserve value for --heap\",5);\n    FUN_00119ed0(uVar24,unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xae:\n    DAT_00126490 = FUN_00119940(_optarg,\"--image-base\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xaf:\n    DAT_00127910 = DAT_00127910 | 0x100;\n    DAT_00127914 = DAT_00127914 & 0xfffffeff;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb0:\n    lVar30 = strtol((char *)_optarg,(char **)0x0,10);\n    DAT_001264b8 = (int)lVar30;\n    if (DAT_001264b8 < 1) {\n      pcVar32 = \"interleave width must be positive\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb1:\n    FUN_00114460(_optarg,DAT_001279f8,&DAT_00127940);\n    local_108 = (long *)(ulong)bVar7;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb2:\n    DAT_00127a38 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb3:\n    FUN_00114190(_optarg,1,4);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb4:\n    FUN_00114460(_optarg,DAT_00127a28,&DAT_00127960);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb5:\n    DAT_00127959 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb6:\n    DAT_00127958 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb7:\n    FUN_00114460(_optarg,DAT_00127a08,&DAT_00127950);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xb8:\n    iVar11 = strcmp(\"enable\",(char *)_optarg);\n    if (iVar11 == 0) {\n      DAT_001264b4 = 1;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcmp(\"disable\",(char *)pFVar14);\n    if (iVar11 == 0) {\n      DAT_001264b4 = 0;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    iVar11 = strcmp(\"keep\",(char *)pFVar14);\n    if (iVar11 == 0) {\n      DAT_001264b4 = 2;\n      ppuVar29 = (undefined **)pFVar14;\n      goto switchD_00117234_caseD_0;\n    }\n    pcVar32 = \"unknown long section names option \\'%s\\'\";\n    break;\n  case (char *)0xba:\n    DAT_00127a20 = 0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbb:\n    local_130 = (FILE *)0x0;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbc:\n    DAT_00127a48 = 4;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbd:\n    DAT_00127990 = FUN_00119940(_optarg,\"--pad-to\");\n    DAT_00127989 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbe:\n    DAT_00127918 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xbf:\n    DAT_00127920 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc0:\n    DAT_00127928 = _optarg;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc1:\nswitchD_00117234_caseD_c1:\n    DAT_00127914 = DAT_00127914 | 0x100;\n    DAT_00127910 = DAT_00127910 & 0xfffffeff;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc2:\n    DAT_00127914 = DAT_00127914 | 0x80;\n    DAT_00127910 = DAT_00127910 & 0xffffff7f;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc3:\n    unaff_R13 = &optarg;\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      FUN_00119dd0(uVar24,\"--redefine-sym\");\n    }\n    ppuVar29 = (undefined **)(pcVar32 + 1);\n    iVar11 = (int)pcVar32 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    strncpy(pcVar32,(char *)_optarg,(long)iVar11);\n    pcVar32[iVar11] = '\\0';\n    sVar15 = strlen((char *)ppuVar29);\n    unaff_R12 = (FILE *)xmalloc((long)((int)sVar15 + 1));\n    strcpy((char *)unaff_R12,(char *)ppuVar29);\n    FUN_00108d9a(\"--redefine-sym\",pcVar32,unaff_R12);\n    free(pcVar32);\n    free(unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc4:\n    ppuVar29 = (undefined **)fopen((char *)_optarg,\"r\");\n    if ((FILE *)ppuVar29 == (FILE *)0x0) {\n      piVar25 = __errno_location();\n      pcVar32 = strerror(*piVar25);\n      uVar24 = dcgettext(0,\"couldn\\'t open symbol redefinition file %s (error: %s)\",5);\n                    \n      FUN_00119dd0(uVar24,pFVar14,pcVar32);\n    }\n    pFVar21 = (FILE *)0x64;\n    unaff_R13 = (char *)xmalloc(0x65);\n    iVar13 = getc((FILE *)ppuVar29);\n    iVar11 = 2;\nLAB_00118ace:\n    unaff_R12 = (FILE *)ppuVar29;\n    if (iVar13 != -1) {\n      pFVar33 = (FILE *)0x0;\n      while ((iVar13 != 0x20 && (iVar13 != 9))) {\n        if ((iVar13 == 10) || (iVar13 == 0xd)) {\n          *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n          goto LAB_00118faa;\n        }\n        if (iVar13 == 0) break;\n        if (iVar13 == -1) {\n          *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n          unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n          goto LAB_00119803;\n        }\n        unaff_R12 = pFVar33;\n        if (iVar13 == 0x23) goto LAB_00119745;\n        pFVar38 = (FILE *)((long)&pFVar33->_flags + 1);\n        *(char *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = (char)iVar13;\n        if (pFVar21 <= pFVar38) {\n          pFVar21 = (FILE *)((long)pFVar21 * 2);\n          unaff_R13 = (char *)xrealloc(unaff_R13,(undefined *)((long)&pFVar21->_flags + 1));\n        }\n        iVar13 = getc((FILE *)ppuVar29);\n        pFVar33 = pFVar38;\n      }\n      unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n      *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n      while ((iVar13 == 0x20 || (iVar13 == 9))) {\n        iVar13 = getc((FILE *)ppuVar29);\n      }\n      if (iVar13 == 0x23) {\nLAB_00119745:\n        if (unaff_R12 != (FILE *)0x0) goto LAB_0011974a;\n        pFVar33 = (FILE *)0x0;\n        unaff_R12 = (FILE *)0x0;\nLAB_001197ca:\n        *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n        while ((iVar13 != 10 && (iVar13 != -1))) {\n          iVar13 = getc((FILE *)ppuVar29);\n        }\n        goto LAB_0011903b;\n      }\nLAB_00118faa:\n      unaff_R12 = (FILE *)((long)&pFVar33->_flags + 1);\n      if (((iVar13 == 10) || (iVar13 == 0xd)) || (iVar13 == 0)) goto LAB_00119745;\n      pFVar38 = unaff_R12;\n      if (iVar13 != -1) {\n        do {\n          pFVar33 = (FILE *)((long)&pFVar38->_flags + 1);\n          *(char *)((long)&pFVar38->_flags + (long)(int *)unaff_R13) = (char)iVar13;\n          if (pFVar21 <= pFVar33) {\n            pFVar21 = (FILE *)((long)pFVar21 * 2);\n            unaff_R13 = (char *)xrealloc(unaff_R13,(undefined *)((long)&pFVar21->_flags + 1));\n          }\n          iVar13 = getc((FILE *)ppuVar29);\n          if ((iVar13 == 0x20) || (iVar13 == 9)) {\nLAB_001198b6:\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            pFVar33 = (FILE *)((long)&pFVar38->_flags + 2);\n            goto LAB_00119858;\n          }\n          if ((iVar13 == 10) || (iVar13 == 0xd)) {\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            goto LAB_0011902d;\n          }\n          if (iVar13 == 0) goto LAB_001198b6;\n          if (iVar13 == -1) {\n            *(undefined *)((long)&pFVar33->_flags + (long)(int *)unaff_R13) = 0;\n            unaff_R12 = (FILE *)((long)&pFVar38->_flags + 2);\n            goto LAB_00119803;\n          }\n          pFVar38 = pFVar33;\n        } while (iVar13 != 0x23);\nLAB_001198ec:\n        if ((pFVar33 == (FILE *)0x0) || ((unaff_R12 != (FILE *)0x0 && (unaff_R12 != pFVar33)))) {\n          iVar13 = 0x23;\n          goto LAB_001197ca;\n        }\nLAB_0011974a:\n        pcVar32 = \"%s:%d: missing new symbol name\";\n        goto LAB_00119756;\n      }\nLAB_00119803:\n      if (unaff_R12 != (FILE *)0x0) {\n        pcVar32 = \"%s:%d: premature end of file\";\n        goto LAB_00119756;\n      }\n    }\nLAB_00119065:\n    free(unaff_R13);\n    fclose((FILE *)ppuVar29);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc5:\n    DAT_00127988 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc6:\n    FUN_00114190(_optarg,1,0x100);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc7:\n    goto switchD_00117234_caseD_c7;\n  case (char *)0xc8:\n    ppuVar29 = (undefined **)(ulong)DAT_00127908;\n    uVar27 = strtol((char *)_optarg,(char **)0x0,10);\n    DAT_00127908 = (uint)uVar27;\n    if (((int)DAT_00127908 < 1) || ((uVar27 & 1) != 0)) {\n      pcVar32 = \"number of bytes to reverse must be positive and even\";\n      goto LAB_00117aed;\n    }\n    if ((uVar10 != DAT_00127908) && (uVar10 != 0)) {\n      uVar24 = dcgettext(0,\"Warning: ignoring previous --reverse-bytes value of %d\",5);\n      FUN_00119ed0(uVar24,uVar10);\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xc9:\n    DAT_00126488 = FUN_00119940(_optarg,\"--section-alignment\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xca:\n    unaff_R12 = (FILE *)strchr((char *)_optarg,0x3d);\n    if (unaff_R12 == (FILE *)0x0) {\n      uVar24 = dcgettext(0,\"bad format for %s\",5);\n                    \n      FUN_00119dd0(uVar24,\"--set-section-flags\");\n    }\n    iVar11 = (int)unaff_R12 - iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(long)iVar11);\n    pcVar32[iVar11] = '\\0';\n    ppuVar29 = (undefined **)FUN_00114190(pcVar32,1,0x80);\n    uVar12 = FUN_00113fe0((undefined *)((long)&unaff_R12->_flags + 1));\n    *(undefined4 *)((long)ppuVar29 + 0x28) = uVar12;\n    unaff_R13 = (char *)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcb:\n    pcVar32 = strchr((char *)_optarg,0x3d);\n    if (pcVar32 == (char *)0x0) {\n      pcVar32 = \"bad format for --set-section-alignment: argument needed\";\n      goto LAB_00117aed;\n    }\n    uVar27 = strtol(pcVar32 + 1,(char **)0x0,10);\n    if ((int)uVar27 < 1) goto LAB_001189a2;\n    unaff_R12 = (FILE *)0x0;\n    while( true ) {\n      if ((uVar27 & 1) != 0) break;\n      uVar27 = (ulong)(uint)((int)uVar27 >> 1);\n      unaff_R12 = (FILE *)(ulong)((int)unaff_R12 + 1);\n    }\n    if ((int)uVar27 != 1) {\n      pcVar32 = \"bad format for --set-section-alignment: alignment is not a power of two\";\n      goto LAB_00117aed;\n    }\n    iVar11 = (int)pcVar32 - (int)_optarg;\n    ppuVar29 = (undefined **)(long)iVar11;\n    pcVar32 = (char *)xmalloc((long)(iVar11 + 1));\n    pcVar32 = strncpy(pcVar32,(char *)_optarg,(size_t)ppuVar29);\n    pcVar32[(long)ppuVar29] = '\\0';\n    lVar30 = FUN_00114190(pcVar32,1,0x200);\n    if (lVar30 != 0) {\n      *(int *)(lVar30 + 0x2c) = (int)unaff_R12;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcc:\n    _DAT_00127980 = FUN_00119940(_optarg,\"--set-start\");\n    DAT_00127978 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xce:\n    __bfd_srec_len = FUN_00119940(_optarg,\"--srec-len\");\n    goto switchD_00117234_caseD_0;\n  case (char *)0xcf:\n    DAT_00126480 = strtoul((char *)_optarg,(char **)(FILE *)local_c8,0);\n    unaff_R12 = _optarg;\n    ppuVar29 = (undefined **)(FILE *)local_c8;\n    if ((FILE *)local_c8._0_8_ != _optarg) {\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        DAT_00126478 = strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)(FILE *)local_c8,0\n                              );\n        pFVar14 = _optarg;\n        if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n          uVar24 = dcgettext(0,\"%s: invalid commit value for --stack\",5);\n          FUN_00119ed0(uVar24,pFVar14);\n          ppuVar29 = (undefined **)pFVar14;\n        }\n        goto switchD_00117234_caseD_0;\n      }\n      if (*(char *)(int *)local_c8._0_8_ == '\\0') goto switchD_00117234_caseD_0;\n    }\n    uVar24 = dcgettext(0,\"%s: invalid reserve value for --stack\",5);\n    FUN_00119ed0(uVar24,unaff_R12);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd0:\n    DAT_00127a48 = 5;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd1:\n    FUN_00114460(_optarg,DAT_00127a18,&DAT_00127970);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd2:\n    DAT_00127a48 = 3;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd3:\n    ppFVar23 = (FILE **)htab_find_slot(DAT_00127a10,_optarg,1);\n    *ppFVar23 = pFVar14;\n    ppuVar29 = (undefined **)pFVar14;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd4:\n    FUN_00114460(_optarg,DAT_00127a10,&DAT_00127968);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd5:\n    pcVar32 = strchr((char *)_optarg,0x3a);\n    pFVar21 = pFVar14;\n    if (pcVar32 != (char *)0x0) {\n      pFVar21 = (FILE *)xstrdup(pFVar14);\n      lVar30 = (long)((int)pcVar32 - iVar11);\n      *(undefined *)((long)&pFVar21->_flags + lVar30) = 0;\n      local_c8._0_8_ = pFVar21;\n      uVar27 = strtoul((char *)((long)&pFVar21->_flags + lVar30 + 1),(char **)local_c8,0);\n      DAT_00126472 = (undefined2)uVar27;\n      if (*(char *)(int *)local_c8._0_8_ == '.') {\n        uVar27 = strtoul((char *)((long)(int *)local_c8._0_8_ + 1),(char **)local_c8,0);\n        DAT_00126470 = (undefined2)uVar27;\n      }\n      if (*(char *)(int *)local_c8._0_8_ != '\\0') {\n        uVar24 = dcgettext(0,\"%s: bad version in PE subsystem\",5);\n        FUN_00119ed0(uVar24,pFVar14);\n      }\n    }\n    lVar30 = strtol((char *)pFVar21,(char **)local_c8,0);\n    if (*(char *)(int *)local_c8._0_8_ == '\\0') {\n      lVar17 = 0;\n      while ((short)lVar30 != (&DAT_00125caa)[lVar17 * 8]) {\n        lVar17 = lVar17 + 1;\n        if (lVar17 == 10) goto LAB_00119248;\n      }\n      ppuVar29 = &PTR_s_native_00125ca0;\n      cVar8 = (&DAT_00125ca8)[lVar17 * 0x10];\n      DAT_00126474 = (short)lVar30;\n    }\n    else {\n      unaff_R13 = (char *)0x0;\n      while( true ) {\n        iVar11 = strcmp((char *)pFVar21,(&PTR_s_native_00125ca0)[(long)unaff_R13 * 2]);\n        if (iVar11 == 0) break;\n        unaff_R13 = (char *)((long)(int *)unaff_R13 + 1);\n        if ((FILE *)unaff_R13 == (FILE *)0xa) goto LAB_00119248;\n      }\n      ppuVar29 = &PTR_s_native_00125ca0 + (long)unaff_R13 * 2;\n      DAT_00126474 = (&DAT_00125caa)[(long)unaff_R13 * 8];\n      cVar8 = (&DAT_00125ca8)[(long)unaff_R13 * 0x10];\n    }\n    if (cVar8 == -1) {\nLAB_00119248:\n      uVar24 = dcgettext(0,\"unknown PE subsystem: %s\",5);\n                    \n      FUN_00119dd0(uVar24,pFVar14);\n    }\n    if (cVar8 != '\\0') {\n      if (DAT_001264a8 == -1) {\n        DAT_001264a8 = 0x200;\n      }\n      if (DAT_00126488 == -1) {\n        DAT_00126488 = 0x1000;\n      }\n    }\n    unaff_R12 = pFVar14;\n    if (pFVar14 != pFVar21) {\n      free(pFVar21);\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd6:\n    DAT_001279d8 = FUN_00114c80(_optarg,DAT_001279d8,\"--update-section\");\n    FUN_00114d60(DAT_001279d8);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd7:\n    _VerilogDataWidth = FUN_00119940(_optarg,\"--verilog-data-width\");\n    if ((0x10 < _VerilogDataWidth) || ((0x10116UL >> ((byte)_VerilogDataWidth & 0x3f) & 1) == 0)) {\n      pcVar32 = \"error: verilog data width must be 1, 2, 4, 8 or 16\";\n      goto LAB_00117aed;\n    }\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd8:\n    DAT_001279e8 = 1;\n    goto switchD_00117234_caseD_0;\n  case (char *)0xd9:\n    FUN_00114460(_optarg,DAT_001279f0,&DAT_00127938);\n    goto switchD_00117234_caseD_0;\n  case (char *)0xda:\n    DAT_00127910 = DAT_00127910 | 0x80;\n    DAT_00127914 = DAT_00127914 & 0xffffff7f;\n    goto switchD_00117234_caseD_0;\n  }\nLAB_001176c2:\n  uVar24 = dcgettext(0,pcVar32,5);\n                    \n  FUN_00119dd0(uVar24,pFVar14);\n}\n\n",
            "called": [
                "htab_find_slot",
                "FUN_00113f50",
                "getopt_long",
                "FUN_0011a390",
                "FUN_00108c86",
                "mkstemp",
                "FUN_00108d9a",
                "strncasecmp",
                "fseek",
                "FUN_00114460",
                "ftell",
                "strcmp",
                "FUN_00108898",
                "FUN_00119dd0",
                "dup",
                "FUN_00108a2a",
                "FUN_00114c20",
                "getc",
                "FUN_00114190",
                "xmalloc",
                "unlink_if_ordinary",
                "htab_create_alloc",
                "xrealloc",
                "strtol",
                "bfd_errmsg",
                "textdomain",
                "fopen",
                "strlen",
                "strcpy",
                "FUN_00114cf0",
                "bfd_scan_arch",
                "close",
                "FUN_0011a480",
                "FUN_00114690",
                "FUN_00113fe0",
                "memcpy",
                "free",
                "dcgettext",
                "FUN_00113fb0",
                "FUN_00119940",
                "xstrdup",
                "filename_cmp",
                "xcalloc",
                "strerror",
                "FUN_001126c0",
                "bfd_init",
                "FUN_001054af",
                "fread",
                "FUN_00108800",
                "fprintf",
                "FUN_00119970",
                "bfd_set_default_target",
                "strncpy",
                "bfd_get_error",
                "htab_elements",
                "FUN_001199d0",
                "FUN_00114d60",
                "strcasecmp",
                "FUN_00108916",
                "bfd_set_error_program_name",
                "malloc",
                "stat",
                "strchr",
                "FUN_00119ed0",
                "FUN_00115970",
                "strtoul",
                "FUN_00114c80",
                "memmove",
                "ferror",
                "free",
                "__errno_location",
                "fclose",
                "setlocale",
                "bindtextdomain",
                "xmalloc_set_program_name",
                "FUN_00113f20",
                "xexit"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116b90",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "FUNC_00116b90"
        },
        "FUN_0010be88": {
            "renaming": {
                "FUN_0010be88": "debug_start_block_0010be88",
                "param_1": "block_ptr",
                "param_2": "start_ptr",
                "param_3": "end_ptr",
                "param_4": "result",
                "puVar1": "ptr1",
                "uVar2": "status",
                "puVar3": "allocated_memory",
                "puVar4": "temp_ptr",
                "lVar5": "length",
                "puVar6": "current_ptr",
                "puVar7": "temp_memory",
                "bVar8": "flag",
                "auVar9": "return_value"
            },
            "code": "\n\n\nundefined  [16] debug_start_block_0010be88(long block_ptr,undefined8 start_ptr,undefined8 end_ptr,undefined8 result)\n\n{\n  undefined8 *ptr1;\n  undefined8 status;\n  undefined4 *allocated_memory;\n  undefined8 *temp_ptr;\n  long length;\n  undefined8 *current_ptr;\n  undefined4 *temp_memory;\n  byte flag;\n  undefined return_value [16];\n  \n  flag = 0;\n  if ((*(long *)(block_ptr + 8) == 0) || (*(long *)(block_ptr + 0x20) == 0)) {\n    status = dcgettext(0,\"debug_start_block_0010be88: no current block\",5);\n    fprintf(_stderr,\"%s\\n\",status);\n    status = 0;\n  }\n  else {\n    allocated_memory = (undefined4 *)xmalloc(0x30);\n    temp_memory = allocated_memory;\n    for (length = 0xc; length != 0; length = length + -1) {\n      *temp_memory = 0;\n      temp_memory = temp_memory + (ulong)flag * -2 + 1;\n    }\n    length = *(long *)(block_ptr + 0x20);\n    *(undefined8 *)(allocated_memory + 6) = start_ptr;\n    *(undefined8 *)(allocated_memory + 8) = 0xffffffffffffffff;\n    *(long *)(allocated_memory + 2) = length;\n    ptr1 = *(undefined8 **)(length + 0x10);\n    current_ptr = (undefined8 *)(length + 0x10);\n    while (temp_ptr = ptr1, temp_ptr != (undefined8 *)0x0) {\n      current_ptr = temp_ptr;\n      ptr1 = (undefined8 *)*temp_ptr;\n    }\n    *current_ptr = allocated_memory;\n    status = 1;\n    *(undefined4 **)(block_ptr + 0x20) = allocated_memory;\n  }\n  return_value._8_8_ = result;\n  return_value._0_8_ = status;\n  return return_value;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010be88",
            "calling": [
                "FUN_0010554f",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "debug_start_block_0010be88"
        },
        "bfd_get_error": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104370",
            "calling": [
                "FUN_00116b90",
                "FUN_0011a110",
                "FUN_001126c0",
                "FUN_00119f70",
                "FUN_0010e6a8",
                "FUN_00115dc0",
                "FUN_001083b7",
                "FUN_0010e07c",
                "FUN_0011378f",
                "FUN_0010e2f0",
                "FUN_0010554f",
                "FUN_00114690",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "bfd_get_error"
        },
        "bfd_fdopenw": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048d0",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_fdopenw"
        },
        "FUN_0010ba08": {
            "renaming": {
                "FUN_0010ba08": "generate_warning_message_0010ba08",
                "param_1": "parameters",
                "param_2": "fieldName",
                "param_3": "value",
                "param_4": "size",
                "param_5": "dataType",
                "cVar1": "currentFlag",
                "iVar2": "structSize",
                "lVar3": "localVariable",
                "__s": "fieldNameMessage",
                "sVar4": "paramLen",
                "sVar5": "fieldNameLen",
                "sVar6": "messageLen",
                "__s_00": "formattedMessage",
                "uVar7": "warningMessage",
                "uVar8": "returnVal",
                "pcVar9": "dataTypeStr",
                "xmalloc": "customMalloc",
                "dcgettext": "customGetText",
                "sprintf": "customFormatString",
                "free": "customFree",
                "abort": "terminateExecution"
            },
            "code": "\nundefined8\ngenerateWarningMessage_0010ba08(undefined8 *parameters,char *fieldName,undefined8 value,ulong size,int dataType)\n\n{\n  char currentFlag;\n  int structSize;\n  long localVariable;\n  char *fieldNameMessage;\n  size_t paramLen;\n  size_t fieldNameLen;\n  size_t messageLen;\n  char *formattedMessage;\n  undefined8 warningMessage;\n  undefined8 returnVal;\n  char *dataTypeStr;\n  \n  currentFlag = *(char *)(parameters[0xc] + 0x1c);\n  structSize = *(int *)(parameters[0xc] + 0x18);\n  fieldNameMessage = (char *)FUN_00109b2f();\n  if (*(char **)(parameters[0xc] + 0x20) == (char *)0x0) {\n    returnVal = 0;\n  }\n  else {\n    paramLen = strlen(*(char **)(parameters[0xc] + 0x20));\n    fieldNameLen = strlen(fieldName);\n    messageLen = strlen(fieldNameMessage);\n    formattedMessage = (char *)xmalloc(paramLen + 0x32 + fieldNameLen + messageLen);\n    if (dataType == 1) {\n      dataTypeStr = \"/1\";\n    }\n    else {\n      dataTypeStr = \"/0\";\n      if ((dataType != 2) && (dataTypeStr = \"\", dataType != 0)) {\n                    \n        abort();\n      }\n    }\n    if ((size == 0) && (size = (ulong)(uint)(structSize * 8), size == 0)) {\n      returnVal = *(undefined8 *)*parameters;\n      warningMessage = dcgettext(0,\"%s: warning: unknown size for field `%s\\' in struct\",5);\n      FUN_00119ed0(warningMessage,returnVal,fieldName);\n    }\n    sprintf(formattedMessage,\"%s%s:%s%s,%ld,%ld;\",*(undefined8 *)(parameters[0xc] + 0x20),fieldName,dataTypeStr,fieldNameMessage,\n            value,size);\n    free(*(void **)(parameters[0xc] + 0x20));\n    localVariable = parameters[0xc];\n    *(char **)(localVariable + 0x20) = formattedMessage;\n    if (currentFlag != '\\0') {\n      *(undefined *)(localVariable + 0x1c) = 1;\n    }\n    returnVal = CONCAT71((int7)((ulong)localVariable >> 8),1);\n  }\n  return returnVal;\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "free",
                "FUN_00119ed0",
                "abort",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ba08",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "generate_warning_message_0010ba08"
        },
        "FUN_0010aa53": {
            "renaming": {
                "FUN_0010aa53": "process_data_0010aa53",
                "param_1": "input",
                "param_2": "value",
                "param_3": "flag",
                "param_4": "mode",
                "cVar1": "flagValue",
                "lVar2": "dataStruct",
                "cVar3": "charValue",
                "uVar4": "counter",
                "__s": "string1",
                "sVar5": "length",
                "pcVar6": "dynamicString",
                "lVar7": "newDataStruct",
                "uVar8": "result",
                "uVar9": "tempVar1",
                "uVar10": "tempVar2"
            },
            "code": "\nundefined8 processData_0010aa53(long input,undefined8 value,char flag,int mode)\n\n{\n  char flagValue;\n  long dataStruct;\n  char charValue;\n  uint counter;\n  char *string1;\n  size_t length;\n  char *dynamicString;\n  long newDataStruct;\n  undefined8 result;\n  ulong tempVar1;\n  ulong tempVar2;\n  \n  flagValue = *(char *)(*(long *)(input + 0x60) + 0x1c);\n  string1 = (char *)FUN_00109b2f();\n  length = strlen(string1);\n  dynamicString = (char *)xmalloc(length + 0x19);\n  *dynamicString = flag + '0';\n  if (mode == 1) {\n    charValue = '1';\n  }\n  else {\n    charValue = '0';\n    if ((mode != 2) && (charValue = '2', mode != 0)) {\n                    \n      abort();\n    }\n  }\n  dynamicString[1] = charValue;\n  sprintf(dynamicString + 2,\"%ld,%s;\",value);\n  free(string1);\n  dataStruct = *(long *)(input + 0x60);\n  result = 0;\n  if ((dataStruct != 0) && (*(long *)(dataStruct + 0x20) != 0)) {\n    dataStruct = *(long *)(dataStruct + 0x28);\n    tempVar2 = 0;\n    if (dataStruct != 0) {\n      counter = 0;\n      do {\n        tempVar1 = (ulong)counter;\n        tempVar2 = (ulong)counter;\n        counter = counter + 1;\n      } while (*(long *)(dataStruct + tempVar1 * 8) != 0);\n    }\n    newDataStruct = xrealloc(dataStruct,(ulong)((int)tempVar2 + 2) << 3);\n    *(char **)(newDataStruct + tempVar2 * 8) = dynamicString;\n    *(undefined8 *)(newDataStruct + (ulong)((int)tempVar2 + 1) * 8) = 0;\n    dataStruct = *(long *)(input + 0x60);\n    *(long *)(dataStruct + 0x28) = newDataStruct;\n    if (flagValue != '\\0') {\n      *(undefined *)(dataStruct + 0x1c) = 1;\n    }\n    result = 1;\n  }\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "xrealloc",
                "abort",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010aa53",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_data_0010aa53"
        },
        "FUN_0011173a": {
            "renaming": {
                "FUN_0011173a": "decode_function_0011173a",
                "param_1": "input",
                "param_2": "data",
                "param_3": "opcode",
                "param_4": "mode",
                "param_5": "value",
                "param_6": "string",
                "cVar1": "tempChar",
                "bVar2": "tempByte",
                "__ptr": "pointer",
                "cVar3": "tempChar2",
                "uVar4": "returnValue",
                "iVar5": "tempInt",
                "puVar6": "dynamicPointer",
                "plVar7": "dynamicLong",
                "pcVar8": "tempCharPointer",
                "uVar9": "tempReturnValue",
                "lVar10": "tempLong1",
                "lVar11": "tempLong2",
                "lVar12": "tempLong3",
                "pplVar13": "pointerPointer",
                "uVar14": "tempUInt1",
                "uVar15": "tempUInt2",
                "local_48": "localCharPointer",
                "local_40": "localPointerPointerArray",
                "dVar19": "tempDouble"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0011244f) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nundefined decode_function_0011173a(undefined8 input,long *data,int opcode,int mode,ulong value,\n                      char *string)\n\n{\n  char tempChar;\n  byte tempByte;\n  void *pointer;\n  char tempChar2;\n  undefined returnValue;\n  int tempInt;\n  undefined8 *dynamicPointer;\n  long *dynamicLong;\n  char *tempCharPointer;\n  undefined8 tempReturnValue;\n  long tempLong1;\n  long tempLong2;\n  long tempLong3;\n  long **pointerPointer;\n  ulong tempUInt1;\n  ulong tempUInt2;\n  char *ptempChar6;\n  uint uVar17;\n  long **pplVar18;\n  double tempDouble;\n  char *localCharPointer;\n  long **localPointerPointerArray [2];\n  \n  if (data[4] != 0) {\n    if (((opcode == 100) && (*string != '\\0')) && (data[5] == value)) goto LAB_00111a06;\n    tempChar2 = FUN_0010bbd3(input);\n    if (tempChar2 == '\\0') {\n      return 0;\n    }\n    *(undefined *)((long)data + 0x44) = 0;\n    *(undefined4 *)(data + 8) = 0;\n    data[9] = data[4];\n    if (*(char *)(data + 1) == '\\0') {\n      data[6] = data[5];\n    }\n    *(undefined4 *)(data + 0x10) = 1;\n    dynamicPointer = (undefined8 *)xmalloc(8);\n    data[0x11] = (long)dynamicPointer;\n    *dynamicPointer = 0;\n    data[4] = 0;\n  }\n  strlen(string);\n  if (opcode == 0x84) {\nLAB_00111ab7:\n    returnValue = FUN_00108f08(input,string);\n    return returnValue;\n  }\n  if (opcode < 0x85) {\n    if (opcode == 0x3c) {\n      tempInt = strcmp(string,\"gcc2_compiled.\");\n      if (tempInt == 0) {\n        *(undefined4 *)(data + 8) = 2;\n        return 1;\n      }\n      tempInt = strcmp(string,\"gcc_compiled.\");\n      if (tempInt == 0) {\n        *(undefined4 *)(data + 8) = 1;\n        return 1;\n      }\n      *(undefined *)((long)data + 0x44) = 1;\n      return 1;\n    }\n    if (opcode < 0x3d) {\n      if (opcode == 0x24) {\n        if (*string == '\\0') {\n          if (*(char *)(data + 0xc) == '\\0') {\n            return 1;\n          }\n          if (*(char *)(data + 1) != '\\0') {\n            value = value + data[7];\n          }\n          tempChar2 = FUN_0010c1c6(input,data);\n          if (tempChar2 != '\\0') {\n            tempChar2 = FUN_0010be1a(input,value);\n            if (tempChar2 != '\\0') {\n              *(undefined *)(data + 0xc) = 0;\n              data[0xd] = -1;\n              return 1;\n            }\n            return 0;\n          }\n          return 0;\n        }\n        if ((*(char *)(data + 0xc) != '\\0') &&\n           ((value < (ulong)data[0xd] || (data[0xd] == 0xffffffffffffffff)))) {\n          data[0xd] = value;\n        }\n      }\n      else if (opcode < 0x25) {\n        if (opcode == 0xc) {\n          return 1;\n        }\n        if (opcode - 0x1eU < 2) {\n          return 1;\n        }\n      }\n      else {\n        if (opcode == 0x2a) {\n          return 1;\n        }\n        if (opcode == 0x38) {\n          return 1;\n        }\n      }\n    }\n    else {\n      if (opcode == 100) {\nLAB_00111a06:\n        if (*(char *)(data + 0xc) != '\\0') {\n          tempUInt1 = value;\n          if (((*string != '\\0') && (tempUInt2 = data[0xd], tempUInt2 != 0xffffffffffffffff)) &&\n             (tempUInt1 = tempUInt2, value < tempUInt2)) {\n            tempUInt1 = value;\n          }\n          tempChar2 = FUN_0010c1c6(input,data);\n          if (tempChar2 == '\\0') {\n            return 0;\n          }\n          tempChar2 = FUN_0010be1a(input,tempUInt1);\n          if (tempChar2 == '\\0') {\n            return 0;\n          }\n          *(undefined *)(data + 0xc) = 0;\n          data[0xd] = -1;\n        }\n        if (*string == '\\0') {\n          return 1;\n        }\n        pointer = (void *)data[4];\n        if (pointer == (void *)0x0) {\n          tempLong3 = xstrdup(string);\n          data[4] = tempLong3;\n        }\n        else {\n          if (*string == '/') {\n            tempLong3 = xstrdup(string);\n          }\n          else {\n            tempLong3 = concat(pointer,string,0);\n          }\n          data[4] = tempLong3;\n          free(pointer);\n        }\n        data[5] = value;\n        return 1;\n      }\n      if (opcode < 0x65) {\n        if (opcode == 0x44) {\n          tempLong3 = 0;\n          if (*(char *)(data + 0xc) != '\\0') {\n            tempLong3 = data[7];\n          }\n          returnValue = FUN_0010bf86(input,(long)mode,tempLong3 + value);\n          return returnValue;\n        }\n        if (opcode == 0x62) {\n          return 1;\n        }\n      }\n      else if (opcode == 0x82) {\n        dynamicLong = (long *)xmalloc();\n        tempInt = *(int *)(data + 0x10);\n        tempLong1 = data[10];\n        tempLong2 = data[0xb];\n        dynamicLong[5] = 0;\n        tempLong3 = data[0x11];\n        *(int *)(dynamicLong + 4) = tempInt;\n        uVar17 = tempInt + 1;\n        *(uint *)(data + 0x10) = uVar17;\n        *dynamicLong = tempLong2;\n        dynamicLong[1] = tempLong1;\n        dynamicLong[2] = (long)string;\n        dynamicLong[3] = value;\n        data[10] = (long)dynamicLong;\n        data[0xb] = (long)dynamicLong;\n        tempLong3 = xrealloc(tempLong3,(ulong)uVar17 << 3);\n        uVar17 = *(uint *)(dynamicLong + 4);\n        data[0x11] = tempLong3;\n        *(undefined8 *)(tempLong3 + (ulong)uVar17 * 8) = 0;\n        goto LAB_00111ab7;\n      }\n    }\nLAB_00111c29:\n    tempCharPointer = strchr(string,0x3a);\n    if ((tempCharPointer != (char *)0x0) && ((tempCharPointer[1] & 0xdfU) == 0x46)) {\n      if (*(char *)(data + 0xc) != '\\0') {\n        tempUInt1 = data[0xd];\n        tempUInt2 = value;\n        if ((tempUInt1 != 0xffffffffffffffff) && (tempUInt2 = tempUInt1, value < tempUInt1)) {\n          tempUInt2 = value;\n        }\n        tempChar2 = FUN_0010c1c6(input,data);\n        if (tempChar2 == '\\0') {\n          return 0;\n        }\n        tempChar2 = FUN_0010be1a(input,tempUInt2);\n        if (tempChar2 == '\\0') {\n          return 0;\n        }\n        data[0xd] = -1;\n      }\n      if (*(char *)(data + 1) != '\\0') {\n        data[7] = value;\n      }\n      *(undefined *)(data + 0xc) = 1;\n    }\n    localCharPointer = strchr(string,0x3a);\n    if (localCharPointer == (char *)0x0) {\n      return 1;\n    }\nLAB_00111cbc:\n    if (localCharPointer[1] == ':') goto code_r0x00111cc7;\n    if (*string == '$') {\n      tempChar2 = string[1];\n      ptempChar6 = \"eh_throw\";\n      if (tempChar2 != 'e') {\n        if (tempChar2 < 'f') {\n          if ((tempChar2 != 'X') && (tempChar2 != '_')) {\nLAB_00111d1a:\n            tempReturnValue = dcgettext(0,\"unknown C++ encoded name\",5);\n            FUN_00108fe8(string,tempReturnValue);\n          }\n        }\n        else {\n          ptempChar6 = \"this\";\n          if (tempChar2 == 't') goto LAB_00111d62;\n          if (tempChar2 != 'v') goto LAB_00111d1a;\n        }\n        goto LAB_00111d38;\n      }\n    }\n    else {\nLAB_00111d38:\n      ptempChar6 = (char *)0x0;\n      if ((string != localCharPointer) && ((*string != ' ' || (localCharPointer != string + 1)))) {\n        ptempChar6 = (char *)FUN_00109a0b(string,(int)localCharPointer - (int)string);\n      }\n    }\nLAB_00111d62:\n    tempByte = localCharPointer[1];\n    tempCharPointer = localCharPointer + 1;\n    if (((byte)(*(ushort *)(&_sch_istable + (ulong)tempByte * 2) >> 2) & 1 |\n        (tempByte == 0x2d || tempByte == 0x28)) != 0) {\nswitchD_00111de5_caseD_58:\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempReturnValue = 4;\n      goto LAB_001123e8;\n    }\n    if (tempByte == 0) goto switchD_00111de5_caseD_44;\n    tempCharPointer = localCharPointer + 2;\n    tempChar2 = localCharPointer[1];\n    switch(tempChar2) {\n    case 'C':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      tempCharPointer = \"debug_record_label: not implemented\";\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      goto LAB_00111b96;\n    default:\n      goto switchD_00111de5_caseD_44;\n    case 'F':\n    case 'f':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempChar2 = FUN_0010bc80(input,ptempChar6,tempLong3,tempChar2 == 'F',value);\n      if (tempChar2 != '\\0') {\n        do {\n          if (*localCharPointer != ';') {\n            return 1;\n          }\n          localCharPointer = localCharPointer + 1;\n          tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n        } while (tempLong3 != 0);\n        return 0;\n      }\n      return 0;\n    case 'G':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      if (ptempChar6 == (char *)0x0) goto LAB_0011208f;\n      tempLong1 = data[3];\n      dynamicLong = (long *)data[2];\n      tempChar2 = *(char *)(*(long *)(*data + 8) + 0x1c);\n      goto LAB_00112045;\n    case 'P':\n      if (opcode == 0x24) {\n        localCharPointer = tempCharPointer;\n        do {\n          if (*localCharPointer != ';') {\n            return 1;\n          }\n          localCharPointer = localCharPointer + 1;\n          tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n        } while (tempLong3 != 0);\n        return 0;\n      }\n    case 'R':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempReturnValue = 2;\n      break;\n    case 'S':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempReturnValue = 2;\n      goto LAB_001121c4;\n    case 'T':\n      tempChar2 = localCharPointer[2];\n      if (tempChar2 == 't') {\n        tempCharPointer = localCharPointer + 3;\n      }\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,ptempChar6,&localCharPointer,localPointerPointerArray);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      if (ptempChar6 == (char *)0x0) {\n        return 1;\n      }\n      tempChar = *(char *)(data + 0x35);\n      dynamicLong = (long *)FUN_0010c6be(input,ptempChar6,tempLong3);\n      if (dynamicLong == (long *)0x0) {\n        return 0;\n      }\n      if (localPointerPointerArray[0] != (long **)0x0) {\n        *localPointerPointerArray[0] = dynamicLong;\n      }\n      if (tempChar != '\\0') goto LAB_001122f0;\n      pointerPointer = (long **)(data + 0x34);\n      pplVar18 = (long **)data[0x34];\n      goto LAB_001122b2;\n    case 'V':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempReturnValue = 3;\n      goto LAB_001123e8;\n    case 'X':\n    case 'l':\n    case 's':\n      goto switchD_00111de5_caseD_58;\n    case 'Y':\n      tempCharPointer = localCharPointer + 3;\n      if (((localCharPointer[2] != '\\0') && (tempCharPointer = localCharPointer + 4, localCharPointer[3] == 'n')) &&\n         (tempCharPointer = localCharPointer + 5, ptempChar6 = localCharPointer + 4, localCharPointer = tempCharPointer, *ptempChar6 == '0')) {\n        for (; tempCharPointer = localCharPointer, *localCharPointer != '\\0'; localCharPointer = localCharPointer + 1) {\n          if (*localCharPointer == ';') {\n            return 1;\n          }\n        }\n      }\n      goto switchD_00111de5_caseD_44;\n    case 'a':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempReturnValue = 4;\n      break;\n    case 'c':\n      if (localCharPointer[2] == '=') {\n        tempCharPointer = localCharPointer + 4;\n        tempChar2 = localCharPointer[3];\n        localCharPointer = tempCharPointer;\n        if (tempChar2 == 'i') {\n          tempLong3 = strtol(tempCharPointer,(char **)0x0,10);\n          if (ptempChar6 == (char *)0x0) {\n            return 0;\n          }\n          tempLong1 = FUN_00112996(input,ptempChar6,4);\n          if (tempLong1 != 0) {\n            *(long *)(tempLong1 + 0x20) = (long)(int)tempLong3;\n            return 1;\n          }\n          return 0;\n        }\n        if (tempChar2 == 'r') {\n          tempDouble = strtod(tempCharPointer,(char **)0x0);\n          if (ptempChar6 == (char *)0x0) {\n            return 0;\n          }\n          tempLong3 = FUN_00112996(input,ptempChar6,5);\n          if (tempLong3 != 0) {\n            *(double *)(tempLong3 + 0x20) = tempDouble;\n            return 1;\n          }\n          return 0;\n        }\n        if (tempChar2 == 'e') {\n          tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n          if (tempLong3 == 0) {\n            return 0;\n          }\n          tempCharPointer = localCharPointer;\n          if (*localCharPointer == ',') {\n            tempLong1 = strtol(localCharPointer,(char **)0x0,10);\n            if (ptempChar6 == (char *)0x0) {\n              return 0;\n            }\n            tempLong2 = FUN_00112996(input,ptempChar6,6);\n            if (tempLong2 != 0) {\n              dynamicLong = (long *)xmalloc(0x10);\n              *dynamicLong = tempLong3;\n              dynamicLong[1] = (long)(int)tempLong1;\n              *(long **)(tempLong2 + 0x20) = dynamicLong;\n              return 1;\n            }\n            return 0;\n          }\n        }\n      }\n      goto switchD_00111de5_caseD_44;\n    case 'p':\n      if (localCharPointer[2] == 'F') {\n        localCharPointer = localCharPointer + 3;\n        tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n        if (tempLong3 == 0) {\n          return 0;\n        }\n        tempReturnValue = FUN_00113ce0(tempLong3,0,0);\n        tempLong3 = FUN_00113d3a(tempReturnValue);\n      }\n      else {\n        localCharPointer = tempCharPointer;\n        tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      }\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempReturnValue = 1;\n      break;\n    case 'r':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempReturnValue = 5;\nLAB_001123e8:\n      tempChar2 = FUN_0010c139(input,data,ptempChar6,tempLong3,tempReturnValue,value);\n      goto joined_r0x001123f8;\n    case 't':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,ptempChar6,&localCharPointer,localPointerPointerArray);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      if (ptempChar6 == (char *)0x0) {\n        return 1;\n      }\n      dynamicLong = (long *)FUN_0010c218(input,ptempChar6,tempLong3);\n      if (dynamicLong == (long *)0x0) {\n        return 0;\n      }\n      if (localPointerPointerArray[0] == (long **)0x0) {\n        return 1;\n      }\n      *localPointerPointerArray[0] = dynamicLong;\n      return 1;\n    case 'v':\n      localCharPointer = tempCharPointer;\n      tempLong3 = FUNC_0010ee3f(input,data,0,&localCharPointer,0);\n      if (tempLong3 == 0) {\n        return 0;\n      }\n      tempReturnValue = 3;\n    }\n    tempChar2 = FUN_0010bd62(input,ptempChar6,tempLong3,tempReturnValue,value);\n    goto joined_r0x001123f8;\n  }\n  if (opcode == 0xe0) {\n    if ((*(char *)((long)data + 0x44) != '\\0') && (mode == 1)) {\n      return 1;\n    }\n    tempChar2 = FUN_0010c1c6(input,data);\n    if (tempChar2 == '\\0') {\n      return 0;\n    }\n    tempChar2 = FUN_0010bf20(input,data[7] + data[6] + value);\n    if (tempChar2 == '\\0') {\n      return 0;\n    }\n    data = data + 0xe;\n    *(int *)data = *(int *)data + -1;\n    tempCharPointer = \"Too many N_RBRACs\\n\";\n    if (-1 < *(int *)data) {\n      return 1;\n    }\n  }\n  else {\n    if (0xe0 < opcode) {\n      if (opcode == 0xe2) {\n        tempCharPointer = \"debug_start_common_block: not implemented\";\n      }\n      else {\n        tempCharPointer = \"debug_end_common_block: not implemented\";\n        if (opcode != 0xe4) goto LAB_00111c29;\n      }\nLAB_00111b96:\n      tempReturnValue = dcgettext(0,tempCharPointer,5);\n      fprintf(_stderr,\"%s\\n\",tempReturnValue);\n      return 0;\n    }\n    if (opcode != 0xc0) {\n      if (opcode == 0xc2) {\n        tempInt = *(int *)(data + 0x10);\n        *(uint *)(data + 0x10) = tempInt + 1U;\n        tempLong3 = xrealloc(data[0x11],(ulong)(tempInt + 1U) << 3);\n        dynamicPointer = (undefined8 *)data[0xb];\n        data[0x11] = tempLong3;\n        while( true ) {\n          if (dynamicPointer == (undefined8 *)0x0) {\n            tempReturnValue = dcgettext(0,\"Undefined N_EXCL\",5);\n            FUN_00108fe8(string,tempReturnValue);\n            *(undefined8 *)(data[0x11] + (ulong)(*(int *)(data + 0x10) - 1) * 8) = 0;\n            return 1;\n          }\n          if ((value == dynamicPointer[3]) && (tempInt = strcmp((char *)dynamicPointer[2],string), tempInt == 0))\n          break;\n          dynamicPointer = (undefined8 *)*dynamicPointer;\n        }\n        *(undefined8 *)(tempLong3 + (ulong)(*(int *)(data + 0x10) - 1) * 8) = dynamicPointer[5];\n        return 1;\n      }\n      if (opcode == 0xa2) {\n        tempLong3 = data[10];\n        if (tempLong3 != 0) {\n          tempLong1 = *(long *)(tempLong3 + 8);\n          uVar17 = *(uint *)(tempLong3 + 0x20);\n          data[10] = tempLong1;\n          if ((uVar17 < *(uint *)(data + 0x10)) &&\n             (*(undefined8 *)(tempLong3 + 0x28) = *(undefined8 *)(data[0x11] + (ulong)uVar17 * 8),\n             tempLong1 != 0)) {\n            string = *(char **)(tempLong1 + 0x10);\n            goto LAB_00111ab7;\n          }\n        }\n        string = (char *)data[9];\n        goto LAB_00111ab7;\n      }\n      goto LAB_00111c29;\n    }\n    if ((*(char *)((long)data + 0x44) != '\\0') && (mode == 1)) {\n      return 1;\n    }\n    if (*(char *)(data + 0xc) != '\\0') {\n      tempChar2 = FUN_0010be88(input,data[7] + data[6] + value);\n      if (tempChar2 == '\\0') {\n        return 0;\n      }\n      tempChar2 = FUN_0010c1c6(input,data);\n      if (tempChar2 != '\\0') {\n        *(int *)(data + 0xe) = *(int *)(data + 0xe) + 1;\n        return 1;\n      }\n      return 0;\n    }\n    tempCharPointer = \"N_LBRAC not within function\\n\";\n  }\n  tempCharPointer = (char *)dcgettext(0,tempCharPointer,5);\n  fprintf(_stderr,tempCharPointer);\n  return 0;\ncode_r0x00111cc7:\n  localCharPointer = localCharPointer + 2;\n  localCharPointer = strchr(localCharPointer,0x3a);\n  if (localCharPointer == (char *)0x0) {\n    tempCharPointer = (char *)0x0;\nswitchD_00111de5_caseD_44:\n    localCharPointer = tempCharPointer;\n    FUN_00108fb9(string);\n    return 0;\n  }\n  goto LAB_00111cbc;\nLAB_001122b2:\n  if (pplVar18 == (long **)0x0) {\nLAB_001122f0:\n    if (tempChar2 != 't') {\n      return 1;\n    }\n    dynamicLong = (long *)FUN_0010c218(input,ptempChar6,dynamicLong);\n    if (dynamicLong != (long *)0x0) {\n      if (localPointerPointerArray[0] == (long **)0x0) {\n        return 1;\n      }\n      *localPointerPointerArray[0] = dynamicLong;\n      return 1;\n    }\n    return 0;\n  }\n  if ((*(char *)pplVar18[1] == *ptempChar6) &&\n     (tempInt = strcmp((char *)pplVar18[1],ptempChar6), tempInt == 0)) {\n    pplVar18[3] = dynamicLong;\n    *pointerPointer = *pplVar18;\n    goto LAB_001122f0;\n  }\n  pointerPointer = pplVar18;\n  pplVar18 = (long **)*pplVar18;\n  goto LAB_001122b2;\nLAB_00112045:\n  if (tempLong1 < 1) {\nLAB_0011208f:\n    tempReturnValue = 1;\nLAB_001121c4:\n    tempChar2 = FUN_0010c05d(input,ptempChar6,tempLong3,tempReturnValue,value);\njoined_r0x001123f8:\n    if (tempChar2 != '\\0') {\n      return 1;\n    }\n    return 0;\n  }\n  tempCharPointer = *(char **)(*dynamicLong + 8);\n  if ((tempChar2 != '\\0') && (tempChar2 == *tempCharPointer)) {\n    tempCharPointer = tempCharPointer + 1;\n  }\n  if ((*tempCharPointer == *ptempChar6) && (tempInt = strcmp(tempCharPointer,ptempChar6), tempInt == 0)) {\n    value = *(long *)(*dynamicLong + 0x10) + *(long *)(*(long *)(*dynamicLong + 0x20) + 0x30);\n    goto LAB_0011208f;\n  }\n  tempLong1 = tempLong1 + -1;\n  dynamicLong = dynamicLong + 1;\n  goto LAB_00112045;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_0010c05d",
                "xstrdup",
                "FUN_0010bd62",
                "FUN_00108f08",
                "FUN_0010bf20",
                "fprintf",
                "FUN_00108fb9",
                "FUN_00113ce0",
                "FUN_0010c139",
                "strcmp",
                "FUN_00113d3a",
                "FUN_0010ee3f",
                "FUN_00108fe8",
                "FUN_0010c218",
                "xmalloc",
                "FUN_0010bbd3",
                "strchr",
                "xrealloc",
                "FUN_0010c1c6",
                "FUN_0010c6be",
                "strtod",
                "FUN_00112996",
                "strtol",
                "strlen",
                "FUN_0010bf86",
                "FUN_0010be1a",
                "free",
                "FUN_0010bc80",
                "FUN_0010be88",
                "concat",
                "FUN_00109a0b"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011173a",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "decode_function_0011173a"
        },
        "FUN_00115dc0": {
            "renaming": {
                "FUN_00115dc0": "process_binary_00115dc0",
                "param_1": "sourceFile",
                "param_2": "options",
                "param_3": "symbolTable",
                "cVar1": "errorCode",
                "iVar2": "bfdErrorCode",
                "uVar3": "relocBound",
                "lVar4": "relocResult",
                "puVar5": "relocTable",
                "uVar6": "relocCount",
                "UNRECOVERED_JUMPTABLE": "jumpTableFunction",
                "puVar7": "outputRelocTable",
                "puVar8": "currentRelocEntry",
                "uVar9": "currentEntryIndex",
                "uStack_38": "localVariable",
                "bfd_get_error": "getBfdError",
                "bfd_alloc": "allocateBfd",
                "dcgettext": "getErrorMessage",
                "bfd_get_reloc_upper_bound": "getRelocUpperBound",
                "bfd_canonicalize_reloc": "canonicalizeReloc",
                "xexit": "exit"
            },
            "code": "\nvoid processBinary_00115dc0(undefined8 sourceFile,undefined8 *options,long symbolTable)\n\n{\n  char errorCode;\n  int bfdErrorCode;\n  undefined8 relocBound;\n  long relocResult;\n  undefined8 *relocTable;\n  ulong relocCount;\n  code *jumpTableFunction;\n  undefined8 *outputRelocTable;\n  undefined8 *currentRelocEntry;\n  ulong currentEntryIndex;\n  undefined8 localVariable;\n  \n  errorCode = FUN_00115f50(sourceFile,options,0);\n  if (errorCode != '\\0') {\n    return;\n  }\n  relocBound = options[0xc];\n  if ((((*(byte *)(symbolTable + 0x48) & 7) != 3) && (DAT_00127a48 != 6)) &&\n     (relocResult = FUN_00114190(*options,0,0x100), relocResult == 0)) {\n    relocResult = bfd_get_reloc_upper_bound(sourceFile,options);\n    if (relocResult < 0) {\n      if ((relocResult != -1) || (bfdErrorCode = bfd_get_error(), bfdErrorCode != 5)) {\n        DAT_00127a40 = 1;\n        relocBound = 0;\nLAB_00108315:\n        FUN_001126c0(0,sourceFile,options,relocBound,localVariable);\n        return;\n      }\n    }\n    else if (relocResult != 0) {\n      relocTable = (undefined8 *)options[0xe];\n      if (relocTable == (undefined8 *)0x0) {\n        relocTable = (undefined8 *)bfd_alloc(symbolTable);\n        if (relocTable == (undefined8 *)0x0) {\n          FUN_0011a110(0);\n                    \n          xexit(1);\n        }\n        relocCount = bfd_canonicalize_reloc(sourceFile,options,relocTable,DAT_001278d0);\n        if ((long)relocCount < 0) {\n          DAT_00127a40 = 1;\n          relocBound = dcgettext(0,\"relocation count is negative\",5);\n          goto LAB_00108315;\n        }\n      }\n      else {\n        relocCount = (ulong)*(uint *)(options + 0xf);\n      }\n      if (DAT_00127a48 == 7) {\n        outputRelocTable = relocTable;\n        for (currentEntryIndex = 0; currentEntryIndex != relocCount; currentEntryIndex = currentEntryIndex + 1) {\n          currentRelocEntry = outputRelocTable;\n          if (((*(long **)relocTable[currentEntryIndex] != (long *)0x0) &&\n              (relocResult = **(long **)relocTable[currentEntryIndex], relocResult != 0)) &&\n             (errorCode = FUN_00115d70(*(undefined8 *)(relocResult + 8),DAT_00127a28), errorCode != '\\0')) {\n            currentRelocEntry = outputRelocTable + 1;\n            *outputRelocTable = relocTable[currentEntryIndex];\n          }\n          outputRelocTable = currentRelocEntry;\n        }\n        *outputRelocTable = 0;\n        relocCount = (long)outputRelocTable - (long)relocTable >> 3;\n      }\n      jumpTableFunction = *(code **)(*(long *)(symbolTable + 8) + 0x288);\n      if (relocCount == 0) {\n        relocCount = 0;\n        relocTable = (undefined8 *)0x0;\n      }\n      else {\n        relocCount = relocCount & 0xffffffff;\n      }\n      goto LAB_00115e9a;\n    }\n  }\n  relocCount = 0;\n  relocTable = (undefined8 *)0x0;\n  jumpTableFunction = *(code **)(*(long *)(symbolTable + 8) + 0x288);\nLAB_00115e9a:\n                    /* WARNING: Could not recover jumptable at 0x00115eae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTableFunction)(symbolTable,relocBound,relocTable,relocCount);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00114190",
                "FUN_00115f50",
                "FUN_0011a110",
                "FUN_001082df",
                "bfd_get_error",
                "bfd_canonicalize_reloc",
                "bfd_alloc",
                "FUN_001126c0",
                "bfd_get_reloc_upper_bound",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115dc0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_binary_00115dc0"
        },
        "concat": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104320",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010d21c",
                "FUN_00104ea2",
                "FUN_0010554f",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "concat"
        },
        "FUN_0010d559": {
            "renaming": {
                "FUN_0010d559": "process_data_0010d559",
                "param_1": "output_values",
                "param_2": "input_data",
                "param_3": "output_length",
                "bVar1": "first_byte",
                "pbVar2": "current_byte",
                "cVar3": "result",
                "uVar4": "expected_length",
                "iVar5": "comparison_result",
                "ppcVar6": "output_data",
                "sVar7": "data_length",
                "lVar8": "result_value",
                "plVar9": "search_result",
                "pcVar10": "comparison_string",
                "__s1": "search_string",
                "__ptr": "temp_buffer",
                "pbVar11": "updated_current_byte",
                "uVar12": "mode",
                "local_64": "count",
                "local_40": "temporary_buffer"
            },
            "code": "\nundefined8 process_data_0010d559(undefined8 *output_values,byte **input_data,long *output_length)\n\n{\n  byte first_byte;\n  byte *current_byte;\n  char result;\n  uint expected_length;\n  int comparison_result;\n  char **output_data;\n  size_t data_length;\n  long result_value;\n  long *search_result;\n  char *comparison_string;\n  char *search_string;\n  void *temp_buffer;\n  byte *updated_current_byte;\n  undefined8 mode;\n  byte *__nptr;\n  int count;\n  char *temporary_buffer [2];\n  \n  current_byte = *input_data;\n  first_byte = current_byte[1];\n  if ((char)first_byte < ':') {\n    if ((char)first_byte < '1') goto LAB_0010d5d8;\n    count = (char)first_byte + -0x30;\n    if (current_byte[2] == 0x5f) {\n      *input_data = current_byte + 1;\n    }\n    updated_current_byte = *input_data + 2;\n  }\n  else {\n    if (((first_byte != 0x5f) || (((&_sch_istable)[(ulong)current_byte[2] * 2] & 4) == 0)) ||\n       (current_byte[2] == 0x30)) goto LAB_0010d5d8;\n    __nptr = current_byte + 2;\n    result_value = strtol((char *)__nptr,(char **)0x0,10);\n    count = (int)result_value;\n    while (((&_sch_istable)[(ulong)*__nptr * 2] & 4) != 0) {\n      __nptr = __nptr + 1;\n    }\n    updated_current_byte = __nptr + 1;\n    if (*__nptr != 0x5f) goto LAB_0010d5d8;\n  }\n  *input_data = updated_current_byte;\n  output_data = (char **)0x0;\n  if (output_length != (long *)0x0) {\n    output_data = temporary_buffer;\n  }\n  result_value = 0;\n  while( true ) {\n    while( true ) {\n      count = count + -1;\n      if (count == -1) {\n        if (output_length != (long *)0x0) {\n          *output_length = result_value;\n        }\n        return 1;\n      }\n      if (**input_data == 0x5f) {\n        *input_data = *input_data + 1;\n      }\n      if (**input_data != 0x74) break;\n      result = FUN_0010d21c(output_values,input_data,output_data);\n      comparison_string = temporary_buffer[0];\n      if (result == '\\0') {\n        return 0;\n      }\n      if (output_length != (long *)0x0) {\n        data_length = strlen(temporary_buffer[0]);\n        result_value = FUN_0010afd5(*output_values,output_values[1],comparison_string,data_length & 0xffffffff,9);\n        free(comparison_string);\n        if (result_value == 0) {\n          return 0;\n        }\n      }\n    }\n    expected_length = FUN_00108e76(input_data);\n    data_length = strlen((char *)*input_data);\n    if (data_length < expected_length) break;\n    if (output_length != (long *)0x0) {\n      if ((result_value != 0) && (search_result = (long *)FUN_00113b1e(result_value), search_result != (long *)0x0)) {\n        comparison_string = (char *)FUN_00109a0b(*input_data,expected_length);\n        for (; result_value = *search_result, result_value != 0; search_result = search_result + 1) {\n          result_value = *(long *)(result_value + 8);\n          if (result_value == 0) {\n            free(comparison_string);\n            return 0;\n          }\n          search_string = (char *)FUN_001129f4(result_value);\n          if ((search_string != (char *)0x0) && (comparison_result = strcmp(search_string,comparison_string), comparison_result == 0)) break;\n        }\n        free(comparison_string);\n        if (result_value != 0) goto LAB_0010d7ad;\n      }\n      mode = 9;\n      if (count == 0) {\n        temp_buffer = (void *)FUN_00109a0b(*input_data,expected_length);\n        result_value = FUN_0010914e(*output_values,temp_buffer);\n        free(temp_buffer);\n        if (result_value != 0) goto LAB_0010d7ad;\n        mode = 0;\n      }\n      result_value = FUN_0010afd5(*output_values,output_values[1],*input_data,expected_length,mode);\n      if (result_value == 0) {\n        return 0;\n      }\n    }\nLAB_0010d7ad:\n    *input_data = *input_data + expected_length;\n  }\nLAB_0010d5d8:\n  FUN_0010911f(current_byte);\n  return 0;\n}\n\n",
            "called": [
                "free",
                "FUN_0010d21c",
                "strcmp",
                "FUN_0010911f",
                "FUN_00113b1e",
                "FUN_0010914e",
                "FUN_00108e76",
                "FUN_00109a0b",
                "FUN_0010afd5",
                "strtol",
                "FUN_001129f4",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d559",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010c95e"
            ],
            "imported": false,
            "current_name": "process_data_0010d559"
        },
        "FUN_00119e70": {
            "renaming": {
                "FUN_00119e70": "print_error_message_00119e70",
                "param_1": "errorMessage",
                "param_2": "formatArguments",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printErrorMessage_00119e70(char *errorMessage,__gnuc_va_list formatArguments)\n\n{\n  fflush(standardOutput);\n  fprintf(standardError,\"%s: \",DAT_00127600);\n  vfprintf(standardError,errorMessage,formatArguments);\n  putc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "putc",
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119e70",
            "calling": [
                "FUN_00119ed0",
                "FUN_00119dd0"
            ],
            "imported": false,
            "current_name": "print_error_message_00119e70"
        },
        "FUN_00108466": {
            "renaming": {
                "FUN_00108466": "cleanup_and_free_memory_00108466",
                "param_7": "memoryToFree"
            },
            "code": "\nvoid cleanupAndFreeMemory_00108466(void)\n\n{\n  void *memoryToFree;\n  \n  DAT_00127a40 = 1;\n  FUN_001126c0(0);\n  free(memoryToFree);\n  return;\n}\n\n",
            "called": [
                "free",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108466",
            "calling": [
                "FUN_00116110"
            ],
            "imported": false,
            "current_name": "cleanup_and_free_memory_00108466"
        },
        "mkstemps": {
            "renaming": {},
            "code": "\n\n\nint mkstemps(char *__template,int __suffixlen)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemps(__template,__suffixlen);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemps"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104030",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "mkstemps"
        },
        "setlocale": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104680",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "setlocale"
        },
        "FUN_00108e76": {
            "renaming": {
                "FUN_00108e76": "parse_integer_from_string_00108e76",
                "param_1": "string",
                "bVar1": "current_char",
                "iVar2": "result"
            },
            "code": "\nint parse_integer_from_string_00108e76(byte **string)\n\n{\n  byte current_char;\n  int result;\n  \n  result = 0;\n  while( true ) {\n    current_char = **string;\n    if (((&_sch_istable)[(ulong)current_char * 2] & 4) == 0) break;\n    *string = *string + 1;\n    result = result * 10 + -0x30 + (int)(char)current_char;\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108e76",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010d21c",
                "FUN_0010c95e",
                "FUN_0010d559"
            ],
            "imported": false,
            "current_name": "parse_integer_from_string_00108e76"
        },
        "FUN_0010bb52": {
            "renaming": {
                "FUN_0010bb52": "create_hash_function_0010bb52",
                "param_1": "inputValue",
                "param_2": "param2Value",
                "param_3": "param3Value",
                "lVar1": "hashResult"
            },
            "code": "\nlong createHashFunction_0010bb52(long inputValue,undefined8 param2Value,undefined8 param3Value)\n\n{\n  long hashResult;\n  \n  if (((inputValue != 0) || (inputValue = bfd_hash_allocate(param2Value,0x30), inputValue != 0)) &&\n     (hashResult = bfd_hash_newfunc(inputValue,param2Value,param3Value), hashResult != 0)) {\n    *(undefined8 *)(hashResult + 0x20) = 0xffffffffffffffff;\n    *(undefined8 *)(hashResult + 0x18) = 0;\n    *(undefined4 *)(hashResult + 0x28) = 0;\n    return hashResult;\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_hash_allocate",
                "bfd_hash_newfunc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bb52",
            "calling": [
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "create_hash_function_0010bb52"
        },
        "thunk_FUN_0010e439": {
            "renaming": {
                "thunk_FUN_0010e439": "set_param_value_thunk_0010e439",
                "param_1": "base_address",
                "param_2": "new_value"
            },
            "code": "\nvoid set_param_value_thunk_0010e439(long base_address,undefined8 new_value)\n\n{\n  *(undefined8 *)(base_address + 0x210) = new_value;\n  FUN_0010e2f0(base_address,0x84,0,0,new_value);\n  return;\n}\n\n",
            "called": [
                "FUN_0010e439"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e451",
            "calling": [
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "set_param_value_thunk_0010e439"
        },
        "FUN_0011283f": {
            "renaming": {
                "FUN_0011283f": "check_directory_access_0011283f",
                "param_1": "path",
                "param_2": "directory",
                "iVar1": "access_result",
                "sStack_a8": "file_stat"
            },
            "code": "\nchar * check_directory_access_0011283f(char *path,char *directory)\n\n{\n  int access_result;\n  stat file_stat;\n  \n  if ((directory == (char *)0x0) && (path != (char *)0x0)) {\n    access_result = access(path,7);\n    if (access_result == 0) {\n      access_result = stat(path,&file_stat);\n      if ((access_result == 0) && ((file_stat.st_mode & 0xf000) == 0x4000)) {\n        directory = path;\n      }\n    }\n  }\n  return directory;\n}\n\n",
            "called": [
                "stat",
                "access"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011283f",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "check_directory_access_0011283f"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "bfd_set_section_size": {
            "renaming": {},
            "code": "\nvoid bfd_set_section_size(void)\n\n{\n  bfd_set_section_size();\n  return;\n}\n\n",
            "called": [
                "bfd_set_section_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045f0",
            "calling": [
                "FUN_00116110",
                "FUN_00107880",
                "FUN_00115530",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_set_section_size"
        },
        "FUN_00108237": {
            "renaming": {
                "FUN_00108237": "close_file_and_return_error_00108237",
                "unaff_R12D": "fileDescriptor",
                "piVar2": "errnoLocation",
                "iVar1": "previousErrno"
            },
            "code": "\nundefined8 closeFileAndReturnError_00108237(void)\n\n{\n  int previousErrno;\n  int *errnoLocation;\n  int fileDescriptor;\n  \n  errnoLocation = __errno_location();\n  previousErrno = *errnoLocation;\n  close(fileDescriptor);\n  *errnoLocation = previousErrno;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "__errno_location",
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108237",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "close_file_and_return_error_00108237"
        },
        "bfd_hash_allocate": {
            "renaming": {},
            "code": "\nvoid bfd_hash_allocate(void)\n\n{\n  bfd_hash_allocate();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_allocate"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104450",
            "calling": [
                "FUN_0010bb52"
            ],
            "imported": false,
            "current_name": "bfd_hash_allocate"
        },
        "close": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043c0",
            "calling": [
                "FUN_00115a90",
                "FUN_00116b90",
                "FUN_001199d0",
                "FUN_00114690",
                "FUN_00108237"
            ],
            "imported": false,
            "current_name": "close"
        },
        "getenv": {
            "renaming": {},
            "code": "\n\n\nchar * getenv(char *__name)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = getenv(__name);\n  return pcVar1;\n}\n\n",
            "called": [
                "getenv"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104040",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "getenv"
        },
        "fnmatch": {
            "renaming": {},
            "code": "\n\n\nint fnmatch(char *__pattern,char *__name,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = fnmatch(__pattern,__name,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "fnmatch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104340",
            "calling": [
                "FUN_00114190",
                "FUN_0011a170"
            ],
            "imported": false,
            "current_name": "fnmatch"
        },
        "FUN_0010bc80": {
            "renaming": {
                "FUN_0010bc80": "debug_record_function_0010bc80",
                "param_1": "debug_info_addr",
                "param_2": "file_name",
                "param_3": "line_num",
                "param_4": "flag",
                "uVar1": "error_message",
                "plVar2": "debug_record_ptr",
                "puVar3": "memory_alloc_ptr",
                "lVar4": "loop_counter",
                "puVar5": "loop_ptr",
                "pcVar6": "empty_string",
                "bVar7": "loop_flag",
                "auVar8": "return_value"
            },
            "code": "\n\n\nundefined  [16]\ndebug_record_function_0010bc80(long debug_info_addr,char *file_name,long line_num,uint flag,undefined8 param_5,\n            undefined8 param_6)\n\n{\n  undefined8 error_message;\n  long *debug_record_ptr;\n  undefined4 *memory_alloc_ptr;\n  long loop_counter;\n  undefined4 *loop_ptr;\n  char *empty_string;\n  byte loop_flag;\n  undefined return_value [16];\n  \n  loop_flag = 0;\n  empty_string = \"\";\n  if (file_name != (char *)0x0) {\n    empty_string = file_name;\n  }\n  if (line_num != 0) {\n    if (*(long *)(debug_info_addr + 8) == 0) {\n      error_message = dcgettext(0,\"debug_record_function_0010bc80: no debug_set_filename call\",5);\n      fprintf(_stderr,\"%s\\n\",error_message);\n    }\n    else {\n      debug_record_ptr = (long *)xmalloc(0x18);\n      *debug_record_ptr = line_num;\n      *(undefined (*) [16])(debug_record_ptr + 1) = ZEXT816(0);\n      memory_alloc_ptr = (undefined4 *)xmalloc(0x30);\n      *(long **)(debug_info_addr + 0x18) = debug_record_ptr;\n      debug_record_ptr[2] = (long)memory_alloc_ptr;\n      loop_ptr = memory_alloc_ptr;\n      for (loop_counter = 0xc; loop_counter != 0; loop_counter = loop_counter + -1) {\n        *loop_ptr = 0;\n        loop_ptr = loop_ptr + (ulong)loop_flag * -2 + 1;\n      }\n      *(undefined4 **)(debug_info_addr + 0x20) = memory_alloc_ptr;\n      loop_counter = *(long *)(debug_info_addr + 0x10);\n      *(undefined8 *)(memory_alloc_ptr + 6) = param_5;\n      *(undefined8 *)(memory_alloc_ptr + 8) = 0xffffffffffffffff;\n      loop_counter = FUN_00112925(loop_counter + 0x10,empty_string,3,(flag & 0xff) + 1);\n      if (loop_counter != 0) {\n        *(long **)(loop_counter + 0x20) = debug_record_ptr;\n        error_message = CONCAT71((int7)((ulong)loop_counter >> 8),1);\n        goto LAB_0010bd56;\n      }\n    }\n  }\n  error_message = 0;\nLAB_0010bd56:\n  return_value._8_8_ = param_6;\n  return_value._0_8_ = error_message;\n  return return_value;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc",
                "FUN_00112925"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bc80",
            "calling": [
                "FUN_0010554f",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "debug_record_function_0010bc80"
        },
        "fchmod": {
            "renaming": {},
            "code": "\n\n\nint fchmod(int __fd,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = fchmod(__fd,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "fchmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046c0",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "fchmod"
        },
        "FUN_001152b6": {
            "renaming": {
                "FUN_001152b6": "FUNC_001152b6"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_001152b6(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  uint uVar13;\n  undefined4 uVar14;\n  int iVar15;\n  long *plVar16;\n  long lVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  size_t sVar20;\n  size_t sVar21;\n  char *pcVar22;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar23;\n  long lVar24;\n  ulong uVar25;\n  int *piVar26;\n  long lVar27;\n  ulong uVar28;\n  FILE *__s_00;\n  long **pplVar29;\n  undefined4 unaff_EBX;\n  long **__ptr_01;\n  char *pcVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  int iVar33;\n  long **pplVar34;\n  long unaff_RBP;\n  char *pcVar35;\n  undefined4 *puVar36;\n  undefined8 *puVar37;\n  int unaff_R12D;\n  char **ppcVar38;\n  void *pvVar39;\n  undefined8 *unaff_R14;\n  undefined **ppuVar40;\n  bool bVar41;\n  byte bVar42;\n  long param_7;\n  ulong uStack0000000000000010;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar42 = 0;\n  if (unaff_R12D == 0) {\n    unaff_R12D = *(int *)(unaff_RBP + 0xc);\n    unaff_EBX = *(undefined4 *)(unaff_RBP + 0x10);\n    if (((unaff_R12D == 0) && (*(int *)(unaff_R14[1] + 8) != 5)) &&\n       (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) {\n      uVar28 = FUNC_00107880();\n      return uVar28;\n    }\n  }\n  else {\n    uVar19 = FUN_001125fa();\n    uVar18 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    FUN_00119ed0(uVar18,uVar19);\n  }\n  cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x2a0))(param_7,unaff_R12D,unaff_EBX);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar12 = bfd_get_arch();\n      if (iVar12 == 0) {\n        uVar19 = FUN_001125fa();\n        uVar18 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        FUN_00119ed0(uVar18,uVar19);\n        return 0;\n      }\n      uVar19 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar19 = bfd_printable_arch_mach(uVar14,uVar19);\n      uVar18 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      FUN_00119ed0(uVar18,uVar19);\n      return 0;\n    }\n    iVar12 = bfd_get_arch();\n    iVar33 = bfd_get_arch(param_7);\n    if (iVar12 != iVar33) {\n      uVar28 = FUN_00105828();\n      return uVar28;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    FUN_001126c0(0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_7 + 8) + 1) == 2) &&\n     (cVar10 = FUN_00113fb0(**(undefined8 **)(param_7 + 8),&DAT_0011b503), cVar10 != '\\0')) {\n    lVar27 = *(long *)(param_7 + 0x110);\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = FUN_00113fb0(*(undefined8 *)unaff_R14[1],&DAT_0011b503), cVar10 != '\\0')) {\n      lVar17 = unaff_R14[0x22];\n      bVar41 = DAT_001279eb == '\\0';\n      puVar31 = (undefined8 *)(lVar17 + 200);\n      puVar37 = (undefined8 *)(lVar27 + 200);\n      for (lVar24 = 0x32; lVar24 != 0; lVar24 = lVar24 + -1) {\n        *puVar37 = *puVar31;\n        puVar31 = puVar31 + (ulong)bVar42 * -2 + 1;\n        puVar37 = puVar37 + (ulong)bVar42 * -2 + 1;\n      }\n      if (bVar41) {\n        *(undefined4 *)(lVar27 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar27 + 0x2a4) = (int)*(undefined8 *)(lVar17 + 0xa8);\n      }\n    }\n    uVar28 = DAT_001264a8;\n    if (DAT_001264a8 == 0xffffffffffffffff) {\n      DAT_001264a8 = 0x200;\n      uVar28 = 0x200;\n    }\n    else {\n      *(int *)(lVar27 + 0x10c) = (int)DAT_001264a8;\n    }\n    if (DAT_00126498 != -1) {\n      *(long *)(lVar27 + 0x148) = DAT_00126498;\n    }\n    if (DAT_001264a0 != -1) {\n      *(long *)(lVar27 + 0x148) = DAT_001264a0;\n    }\n    if (DAT_00126490 != -1) {\n      *(long *)(lVar27 + 0x100) = DAT_00126490;\n    }\n    uVar23 = DAT_00126488;\n    if (DAT_00126488 == 0xffffffffffffffff) {\n      DAT_00126488 = 0x1000;\n      uVar23 = 0x1000;\n    }\n    else {\n      *(int *)(lVar27 + 0x108) = (int)DAT_00126488;\n    }\n    if (DAT_00126478 != -1) {\n      *(long *)(lVar27 + 0x138) = DAT_00126478;\n    }\n    if (DAT_00126480 != -1) {\n      *(long *)(lVar27 + 0x138) = DAT_00126480;\n    }\n    if (DAT_00126474 != -1) {\n      *(short *)(lVar27 + 300) = DAT_00126474;\n    }\n    if (DAT_00126472 != -1) {\n      *(short *)(lVar27 + 0x118) = DAT_00126472;\n    }\n    if (DAT_00126470 != -1) {\n      *(short *)(lVar27 + 0x11a) = DAT_00126470;\n    }\n    if (uVar23 < uVar28) {\n      uVar19 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      FUN_00119ed0(uVar19,uVar28,uVar23);\n    }\n  }\n  plVar6 = DAT_001278d0;\n  free(DAT_001278d0);\n  if (plVar6 == DAT_001278c8) {\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(DAT_001278c8);\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar27 < 0) goto LAB_00107a82;\n  DAT_001278c8 = (long *)xmalloc();\n  DAT_001278d0 = DAT_001278c8;\n  uStack0000000000000010 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)uStack0000000000000010 < 0) goto LAB_00107a82;\n  if (uStack0000000000000010 == 0) {\n    free(DAT_001278d0);\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar31 = DAT_001279e0;\n  if ((DAT_0012790c == '\\0') &&\n     (cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x168))(), puVar31 = DAT_001279e0,\n     cVar10 == '\\0')) {\n    DAT_00127a40 = 1;\n    dcgettext(0,\"error in private header data\",5);\n    FUN_001126c0(0);\n    puVar31 = DAT_001279e0;\n  }\n  for (; puVar37 = DAT_001279d8, puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    uVar11 = 0x128;\n    lVar27 = FUN_00114190(puVar31[1],0,0x80);\n    if (lVar27 != 0) {\n      uVar11 = FUN_00115f30(*(uint *)(lVar27 + 0x28) | 0x100,param_7,puVar31[1]);\n    }\n    lVar27 = bfd_get_section_by_name(param_7,puVar31[1]);\n    if (lVar27 != 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    lVar27 = bfd_make_section_with_flags(param_7,puVar31[1],uVar11 | 0x100000);\n    puVar31[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      FUN_001126c0(0,param_7,puVar31[5],0);\n      return 0;\n    }\n    lVar27 = FUN_00114190(puVar31[1],0,0x18);\n    if (lVar27 != 0) {\n      uVar19 = *(undefined8 *)(lVar27 + 0x18);\n      lVar27 = puVar31[5];\n      *(byte *)(lVar27 + 0x28) = *(byte *)(lVar27 + 0x28) | 1;\n      *(undefined8 *)(lVar27 + 0x30) = uVar19;\n      *(undefined8 *)(lVar27 + 0x38) = uVar19;\n    }\n    lVar27 = FUN_00114190(puVar31[1],0,0x60);\n    if (lVar27 != 0) {\n      lVar17 = puVar31[5];\n      *(undefined8 *)(lVar17 + 0x38) = *(undefined8 *)(lVar27 + 0x20);\n      if (0x3e < *(uint *)(lVar17 + 0x7c)) {\n        FUN_001126c0(0,param_7,lVar17,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n    lVar27 = bfd_get_section_by_name();\n    puVar37[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar37[1];\n      uVar18 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      FUN_00119ed0(uVar18,uVar19);\n      return 0;\n    }\n    uVar19 = *(undefined8 *)(lVar27 + 0x60);\n    cVar10 = bfd_set_section_size(uVar19);\n    if (cVar10 == '\\0') {\n      FUN_001126c0(0,param_7,uVar19,0);\n      return 0;\n    }\n  }\n  puVar31 = DAT_001279d0;\n  if (DAT_00127a20 == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar34 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar34;\n    if (pplVar34 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (DAT_00127a20 != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar34[1]; puVar31 = DAT_001279d0, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    lVar27 = bfd_get_section_by_name();\n    if (lVar27 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      FUN_001126c0(0);\n    }\n    else if ((*(byte *)(lVar27 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      FUN_001126c0(0);\n    }\n    else {\n      sVar20 = *(size_t *)(lVar27 + 0x40);\n      __s_00 = fopen((char *)puVar31[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        FUN_001126c0(puVar31[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          FUN_001126c0(0);\n        }\n        else if ((sVar20 != 0) &&\n                (sVar21 = fwrite(in_stack_00000140,1,sVar20,__s_00), sVar21 != sVar20)) {\n          piVar26 = __errno_location();\n          pcVar35 = strerror(*piVar26);\n          uVar19 = puVar31[2];\n          uVar18 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          FUN_00119ed0(uVar18,uVar19,pcVar35);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (DAT_00127a30 == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    lVar27 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar27 != 0) {\n      uVar19 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      FUN_00119ed0(uVar19);\n      DAT_00127a30 = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(param_7);\n    lVar27 = DAT_00127a30;\n    if (lStack0000000000000078 == 0) {\n      uVar19 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar19,lVar27);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_7 + 8) + 8) == 2) {\n      uVar23 = 0;\n      for (uVar28 = *(ulong *)(param_7 + 0x90); uVar28 != 0; uVar28 = *(ulong *)(uVar28 + 8)) {\n        uVar25 = *(ulong *)(uVar28 + 0x30);\n        uVar32 = uVar23;\n        uVar7 = uVar28;\n        uVar8 = uVar23;\n        if (uVar25 != 0) {\n          while ((uVar32 = uVar7, uVar8 != 0 &&\n                 (uVar32 = uVar28, uVar25 <= *(ulong *)(uVar23 + 0x30)))) {\n            uVar28 = *(ulong *)(uVar28 + 8);\n            if (uVar28 == 0) goto LAB_00107db8;\n            uVar25 = *(ulong *)(uVar28 + 0x30);\n            uVar7 = uVar23;\n            uVar8 = uVar25;\n          }\n        }\n        uVar23 = uVar32;\n      }\nLAB_00107db8:\n      if (uVar23 == 0) {\n        uVar28 = 0x1000;\n      }\n      else {\n        uVar23 = *(long *)(uVar23 + 0x40) + *(long *)(uVar23 + 0x30);\n        uVar28 = 0xffffffffffffffff;\n        if (uVar23 < 0xfffffffffffff001) {\n          uVar28 = uVar23 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = uVar28;\n      *(ulong *)(lStack0000000000000078 + 0x38) = uVar28;\n    }\n  }\n  plVar6 = DAT_001278d0;\n  iStack000000000000006c = *(int *)(param_7 + 0xa0);\n  if (iStack000000000000006c != 0) {\n    uVar28 = FUN_0010554f();\n    return uVar28;\n  }\n  if (DAT_001279a0 == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar40 = &PTR_s__stab_00125c60;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    puVar36 = puStack0000000000000020;\n    for (lVar27 = 0x18; lVar27 != 0; lVar27 = lVar27 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar42 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar40;\n      lVar27 = bfd_get_section_by_name();\n      lVar17 = bfd_get_section_by_name();\n      if ((lVar27 != 0) && (lVar17 != 0)) {\n        lVar27 = *(long *)(lVar27 + 0x40);\n        __ptr = (void *)xmalloc(lVar27);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar28 = *(ulong *)(lVar17 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar28 + 1);\n          in_stack_00000018 = bfd_get_section_contents();\n          if (in_stack_00000018 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar28) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)FUN_00112894(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar39 = __ptr; pvVar39 <= (void *)((long)__ptr + lVar27 + -0xc);\n                  pvVar39 = (void *)((long)pvVar39 + 0xc)) {\n                uVar23 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                bVar2 = *(byte *)((long)pvVar39 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar39 + 6);\n                lVar17 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar39 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar17;\n                }\n                else {\n                  uVar25 = (uVar23 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar25 < uVar28) {\n                    pcVar35 = (char *)((long)__ptr_00 + uVar25);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar20 = strlen(pcVar35);\n                      if (((sVar20 == 0) || (pcVar30 = pcVar35 + (sVar20 - 1), *pcVar30 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar27) < (long)pvVar39 + 0x10U)) goto LAB_001077fb;\n                      *pcVar30 = '\\0';\n                      pvVar39 = (void *)((long)pvVar39 + 0xc);\n                      iVar12 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                      uVar23 = (ulong)(uint)(iVar12 + (int)lStack0000000000000088);\n                      if (uVar28 <= uVar23) break;\n                      pcVar35 = (char *)concat(pcVar35,(long)__ptr_00 + uVar23,0);\n                      *pcVar30 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar35;\n                    }\n                    uVar19 = *unaff_R14;\n                    pcVar30 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar30,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    FUN_001088ae((ulong)bVar2,uVar14,lVar17,pcVar35);\n                    cVar10 = FUN_0011173a(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      FUN_00108b3e();\n                      FUN_00108863();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar19 = *unaff_R14;\n                    pcVar35 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar35,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc,\n                            uVar23 & 0xffffffff,(ulong)bVar2,((long)pvVar39 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              FUN_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar40 = ppuVar40 + 2;\n    } while (ppuVar40 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = FUN_0010c892(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(puStack0000000000000020);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar27 = 0;\n      for (plVar16 = plVar6; plVar16 < plVar6 + uStack0000000000000010; plVar16 = plVar16 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar27 == 0) && (lVar27 = FUN_00112894(), lVar27 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar35 = (char *)0x0;\n          pcVar30 = in_stack_00000150;\n          while (((*pcVar30 != '\\0' && (sVar20 = strlen(pcVar30), pcVar30[sVar20 - 1] == '\\\\')) &&\n                 (plVar16 + 1 < plVar6 + uStack0000000000000010))) {\n            pcVar22 = (char *)xstrdup(pcVar30);\n            sVar20 = strlen(pcVar22);\n            pcVar22[sVar20 - 1] = '\\0';\n            pcVar30 = (char *)concat(pcVar22,*(undefined8 *)(plVar16[1] + 8),0);\n            free(pcVar22);\n            free(pcVar35);\n            plVar16 = plVar16 + 1;\n            pcVar35 = pcVar30;\n          }\n          FUN_001088ae(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar30)\n          ;\n          in_stack_00000018 = FUN_0011173a(puStack0000000000000020,lVar27,uStack0000000000000158);\n          if (in_stack_00000018 == '\\0') {\n            FUN_00108b3e();\n            FUN_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      FUN_00108863();\n      if ((lVar27 != 0) && (cVar10 = FUN_0010c892(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (in_stack_00000018 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (uStack0000000000000010 != 0)) {\n        in_stack_00000140 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar31 = (undefined8 *)&stack0x00000148;\n        for (lVar27 = 0x22; lVar27 != 0; lVar27 = lVar27 + -1) {\n          *(undefined4 *)puVar31 = 0;\n          puVar31 = (undefined8 *)((long)puVar31 + (ulong)bVar42 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = uStack0000000000000010;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)uStack0000000000000010 <= in_stack_000000d0) goto LAB_00105590;\n            lVar27 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar17 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar35 = *(char **)(lVar27 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar17) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = FUN_0010bbd3(puStack0000000000000020);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = FUN_0010bbd3(puStack0000000000000020);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar24 = FUN_0010dac0();\n            if (lVar24 == 0) break;\n            cVar9 = FUN_00112a33(&stack0x00000140,lVar27,lVar17);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar35;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar12 = strcmp(pcVar35,\".bb\");\n              if (iVar12 == 0) {\n                cVar9 = FUN_0010be88(puStack0000000000000020);\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".eb\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = FUN_0010bf20(puStack0000000000000020);\n              }\n              break;\n            case 0x65:\n              iVar12 = strcmp(pcVar35,\".bf\");\n              if (iVar12 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar17 = FUN_0010dac0();\n                  if ((lVar17 == 0) ||\n                     (cVar10 = FUN_0010bc80(puStack0000000000000020), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar12 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar12 = in_stack_00000118 - 1;\n                    }\n                    lVar27 = *(long *)(*(long *)(lVar27 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar33 = _uStack0000000000000048[4];\n                      if (iVar33 == 0) break;\n                      cVar9 = FUN_0010bf86(puStack0000000000000020,iVar12 + iVar33,\n                                           *(long *)(_uStack0000000000000048 + 6) + lVar27);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".ef\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = FUN_0010be1a(puStack0000000000000020);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar19 = dcgettext(0,pcVar35,5);\n              FUN_00119ed0(uVar19);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar35 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar19 = dcgettext(0,pcVar35,5);\n        FUN_00119ed0(uVar19);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) & 0x42) != 0) && ((*(uint *)(param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) == '\\0') && (DAT_00127959 == '\\0')) {\n      if (uStack0000000000000010 != 0) {\n        plVar6 = DAT_001278d0 + uStack0000000000000010;\n        plVar16 = DAT_001278d0;\n        do {\n          uVar11 = *(uint *)(*plVar16 + 0x18);\n          if ((uVar11 & 0x1000000) != 0) {\n            *(uint *)(*plVar16 + 0x18) = uVar11 & 0xfeffffff;\n          }\n          plVar16 = plVar16 + 1;\n        } while (plVar6 != plVar16);\n      }\n    }\n    else {\n      for (lVar27 = *(long *)(param_7 + 0x90); lVar27 != 0; lVar27 = *(long *)(lVar27 + 8)) {\n        if (*(long *)(lVar27 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar27 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a48 == 2) || (DAT_00127a48 == 7)) {\nLAB_001059fe:\n    if (DAT_00127a48 == 7) {\nLAB_00105a3b:\n      plVar16 = (long *)xmalloc();\n      plVar6 = DAT_001278d0;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      DAT_001278c8 = plVar16;\n      if (uStack0000000000000010 == 0) {\n        uVar28 = 0;\n      }\n      else {\n        uVar28 = 0;\n        _in_stack_00000018 = 0;\n        do {\n          iVar12 = DAT_001279c0;\n          plVar4 = (long *)plVar6[_in_stack_00000018];\n          pcVar5 = (code *)plVar4[4];\n          uVar11 = *(uint *)(plVar4 + 3);\n          pcVar35 = (char *)plVar4[1];\n          pcVar30 = pcVar35;\n          if (DAT_001279c8 != (undefined8 *)0x0) {\n            iVar33 = 0;\n            puVar31 = DAT_001279c8;\n            while ((iVar33 < iVar12 && (pcVar22 = (char *)puVar31[5], pcVar22 != (char *)0x0))) {\n              if (pcVar22 != \"\") {\n                iVar15 = strcmp(pcVar22,pcVar35);\n                if (iVar15 == 0) {\n                  free(pcVar22);\n                  uVar23 = uVar28 + 1;\n                  puVar31[5] = \"\";\n                  lVar27 = FUN_0011a2e0(puVar31);\n                  uVar19 = DAT_001278f0;\n                  plVar16[uVar28] = lVar27;\n                  lVar27 = htab_elements(uVar19);\n                  if ((lVar27 != 0) || (DAT_001278f8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar31 = (undefined8 *)*puVar31;\n              }\n              iVar33 = iVar33 + 1;\n            }\n          }\n          lVar27 = htab_elements(DAT_001278f0);\n          uVar23 = uVar28;\n          if ((lVar27 != 0) || (DAT_001278f8 != (char **)0x0)) {\n            if (pcVar35 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar35 == '_') && (pcVar35[1] == '_')) &&\n                 (iVar12 = strcmp(pcVar35 + (pcVar35[2] == '_'),\"__gnu_lto_slim\"), iVar12 == 0)) {\n                uVar19 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                FUN_00119dd0(uVar19);\n              }\n            }\n            _cStack0000000000000148 = 0;\n            in_stack_00000140 = pcVar35;\n            lVar27 = htab_find(DAT_001278f0);\n            if (((lVar27 == 0) || (pcVar30 = *(char **)(lVar27 + 8), pcVar35 == pcVar30)) &&\n               (pcVar30 = pcVar35, ppcVar38 = DAT_001278f8, (uVar11 & 0x100) != 0)) {\n              for (; ppcVar38 != (char **)0x0; ppcVar38 = (char **)ppcVar38[3]) {\n                iVar12 = strcmp(*ppcVar38,pcVar35);\n                if (iVar12 == 0) {\n                  pcVar30 = ppcVar38[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar30;\n            cVar10 = *pcVar30;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar35 = DAT_00127928;\n            if ((DAT_001279a8 != '\\0') && (*(char *)(*(long *)(param_7 + 8) + 0x1c) != '\\0')) {\n              lVar27 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar10 = *pcVar35;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar35 = DAT_00127928;\n          lVar27 = unaff_R14[1];\n          if (*(char *)(lVar27 + 0x1c) == cVar10) {\n            if (DAT_001279a8 == '\\0') {\n              if ((DAT_00127988 == '\\0') ||\n                 ((((uVar11 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              goto joined_r0x00106565;\n            }\n            cVar10 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar10 == '\\0') goto LAB_0010677d;\n            if (DAT_00127928 != (char *)0x0) {\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\nLAB_001066bc:\n              sVar20 = strlen(pcVar35);\n              pcVar35 = (char *)xmalloc(sVar20 + lVar27);\n              goto LAB_001066d0;\n            }\n            *pcVar30 = cVar10;\n            plVar4[1] = (long)pcVar30;\n            uVar28 = uVar23;\n          }\n          else {\n            if ((DAT_001279a8 == '\\0') || (*(char *)(*(long *)(param_7 + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar28 = uVar23;\n              if (pcVar35 == (char *)0x0) goto LAB_00105b32;\n              sVar20 = strlen(pcVar30);\n              sVar21 = strlen(pcVar35);\n              pcVar22 = (char *)xmalloc(sVar21 + sVar20 + 1);\n              pcVar35 = pcVar22;\n            }\n            else {\nLAB_0010668d:\n              pcVar35 = DAT_00127928;\n              if ((*(char *)(lVar27 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar27 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\n              if (pcVar35 != (char *)0x0) goto LAB_001066bc;\n              pcVar35 = (char *)xmalloc(lVar27);\nLAB_001066d0:\n              pcVar22 = pcVar35 + 1;\n              *pcVar35 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            __s = DAT_00127928;\n            if (DAT_00127928 != (char *)0x0) {\n              strcpy(pcVar22,DAT_00127928);\n              sVar20 = strlen(__s);\n              pcVar22 = pcVar22 + sVar20;\n            }\n            strcpy(pcVar22,pcVar30);\n            plVar4[1] = (long)pcVar35;\n            pcVar30 = pcVar35;\n            uVar28 = uVar23;\n          }\nLAB_00105b32:\n          if (DAT_00127a48 == 7) goto LAB_001067a8;\n          if (((uVar11 & 0x20) == 0) &&\n             (((uVar11 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar11 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar12 = bfd_decode_symclass(plVar4), iVar12 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ea == '\\0') {\n                lVar27 = htab_find();\n                if (lVar27 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                in_stack_00000140 = pcVar30;\n                htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar11 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar11 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar27 = *(long *)(plVar4[4] + 0xd0), lVar27 == 0)) ||\n                   (*(long *)(lVar27 + 0x40) == 0)) {\n                  if ((DAT_00127a48 == 3) || (DAT_00127a44 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a44 == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = DAT_001279a0;\n              if (1 < DAT_00127a48 - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a48 != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ea == '\\0') {\n            lVar27 = htab_find();\n            if (lVar27 != 0) {\nLAB_0010687f:\n              uVar19 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              FUN_00119ed0(uVar19);\n              DAT_00127a40 = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar30;\n            htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar11 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ea != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar30;\n              htab_traverse(DAT_00127a10,FUN_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar27 = htab_find();\n            if (lVar27 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a38 != '\\0') && ((uVar11 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ea == '\\0') {\n              lVar27 = htab_find();\n              if (lVar27 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar30;\n              htab_traverse(DAT_00127a28,FUN_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = FUN_001159d0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar11 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar11 & 0x82) != 0) {\n                  cVar10 = FUN_00115d70(pcVar30);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar27 = htab_elements(DAT_001279f8), lVar27 == 0 ||\n                      (cVar10 = FUN_00115d70(pcVar30), cVar10 != '\\0')))) {\n                    if (((((DAT_00127958 == '\\0') ||\n                          (uVar13 = *(uint *)(plVar4 + 3), (uVar13 & 0x200000) != 0)) ||\n                         (lVar27 = *plVar4, lVar27 == 0)) ||\n                        ((*(int *)(*(long *)(lVar27 + 8) + 8) != 5 ||\n                         (*(long *)(lVar27 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar13 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar13 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar11 & 1) != 0) && (cVar10 = FUN_00115d70(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279e8 != '\\0') || (cVar10 = FUN_00115d70(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar16[uVar28] = (long)plVar4;\n              uVar28 = uVar28 + 1;\n            }\n          }\n          _in_stack_00000018 = _in_stack_00000018 + 1;\n        } while (uStack0000000000000010 != _in_stack_00000018);\n      }\n      if (DAT_001279c8 != (undefined8 *)0x0) {\n        puVar31 = DAT_001279c8;\n        iVar12 = DAT_001279c0;\n        for (lVar27 = 0; lVar27 < iVar12; lVar27 = lVar27 + 1) {\n          pcVar35 = (char *)puVar31[5];\n          if (pcVar35 == (char *)0x0) {\n            plVar6 = plVar16 + uVar28;\n            uVar28 = uVar28 + 1;\n            lVar17 = FUN_0011a2e0(puVar31,param_7);\n            *plVar6 = lVar17;\n            iVar12 = DAT_001279c0;\n          }\n          else if (pcVar35 != \"\") {\n            uVar19 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            FUN_00119dd0(uVar19,pcVar35);\n          }\n          puVar31 = (undefined8 *)*puVar31;\n        }\n      }\n      bVar41 = DAT_001279a0 == '\\0';\n      plVar16[uVar28] = 0;\n      if ((bVar41) || (puStack0000000000000020 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        uStack0000000000000010 = uVar28 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar12 = *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar12 == 5) || (iVar12 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = FUN_0011378f(param_7,puStack0000000000000020,&stack0x000000c0,&stack0x00000110,\n                              &stack0x000000e0,&stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar27 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar17 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar27 == 0) || (lVar17 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar27,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar17,in_stack_00000140), cVar10 == '\\0')) {\n            pcVar35 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar27 + 0x7c) = 2;\n            *(undefined4 *)(lVar17 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar27,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents\n                                   (param_7,lVar17,in_stack_000000e0,0,in_stack_00000140),\n               cVar10 != '\\0')) {\n              free(puStack0000000000000020);\n              goto LAB_00105cfa;\n            }\n            pcVar35 = \"can\\'t set debugging section contents\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          FUN_001126c0(0,param_7,0,uVar19);\n          free(in_stack_000000e0);\n          free(puStack0000000000000020);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar19 = **(undefined8 **)(param_7 + 8);\n        uVar18 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        FUN_001126c0(0,param_7,0,uVar18,uVar19);\n      }\n      free(puStack0000000000000020);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar12 = bfd_get_error();\n      if (iVar12 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a40 = 1;\n  }\n  else {\n    if ((DAT_00127a48 - 3U < 4) || ((DAT_00127a44 != 0 || (DAT_00127958 != '\\0'))))\n    goto LAB_00105a07;\n    lVar27 = htab_elements(DAT_00127a18);\n    if (((lVar27 != 0) ||\n        (((((((lVar27 = htab_elements(DAT_00127a28), lVar27 != 0 ||\n              (lVar27 = htab_elements(DAT_00127a08), lVar27 != 0)) ||\n             (lVar27 = htab_elements(DAT_00127a00), lVar27 != 0)) ||\n            ((lVar27 = htab_elements(DAT_001279f8), lVar27 != 0 ||\n             (lVar27 = htab_elements(DAT_001279f0), lVar27 != 0)))) ||\n           (lVar27 = htab_elements(DAT_001278f0), lVar27 != 0)) ||\n          (((DAT_00127928 != (char *)0x0 || (DAT_001278d8 != '\\0')) ||\n           ((DAT_00127a39 != '\\0' ||\n            (((DAT_001279a0 != '\\0' || (DAT_001279a8 != '\\0')) || (DAT_00127988 != '\\0')))))))) ||\n         ((DAT_001278f8 != (char **)0x0 || (DAT_001279e8 != '\\0')))))) || (DAT_001279c0 != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,DAT_001278c8,uStack0000000000000010 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,FUN_00115dc0,param_7);\n    bfd_map_over_sections(unaff_R14,FUN_00116110,param_7);\n    for (puVar31 = DAT_001279e0; puVar37 = DAT_001279d8, puVar31 != (undefined8 *)0x0;\n        puVar31 = (undefined8 *)*puVar31) {\n      cVar10 = bfd_set_section_contents(param_7,puVar31[5],puVar31[4],0,puVar31[3]);\n      if (cVar10 == '\\0') {\n        FUN_001126c0(0,param_7,puVar31[5],0);\n        return 0;\n      }\n    }\n    for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n      uVar19 = *(undefined8 *)(puVar37[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar19,puVar37[4],0,puVar37[3]);\n      if (cVar10 == '\\0') {\n        FUN_001126c0(0,param_7,uVar19,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((DAT_00127a20 != '\\0') && (_DAT_001264c0 == 0)) {\n        uVar19 = *unaff_R14;\n        uVar18 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        FUN_00119ed0(uVar18,uVar19);\n      }\n    }\n    else {\n      pplVar34 = (long **)0x0;\n      for (puVar31 = *(undefined8 **)(param_7 + 0x90); puVar31 != (undefined8 *)0x0;\n          puVar31 = (undefined8 *)puVar31[1]) {\n        if (((DAT_00127a20 != '\\0') && (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar31[0x1a] + 4) == 7 &&\n            (cVar10 = FUN_00113fb0(*puVar31,\".gnu.build.attributes\"), cVar10 != '\\0')))) {\n          if (pplVar34 == (long **)0x0) {\n            pplVar34 = __ptr_01;\n          }\n          pplVar29 = __ptr_01;\n          if ((undefined8 *)(*pplVar34)[0xc] == puVar31) {\nLAB_0010625f:\n            pcVar35 = \"error: failed to merge notes\";\n            if (pplVar34[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar31,pplVar34[1],0,pplVar34[2]);\n              if (cVar10 == '\\0') {\n                uVar19 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                FUN_001126c0(0,param_7,puVar31,uVar19);\n                return 0;\n              }\n              pplVar34 = (long **)pplVar34[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar34 = pplVar29;\n              if ((undefined8 *)(*pplVar29)[0xc] == puVar31) goto LAB_0010625f;\n              pplVar34 = (long **)pplVar29[3];\n              pplVar29 = pplVar34;\n            } while (pplVar34 != (long **)0x0);\n            pcVar35 = \"error: failed to locate merged notes\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          FUN_001126c0(0,param_7,puVar31,uVar19);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar34 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar34;\n      } while (pplVar34 != (long **)0x0);\n    }\n    if ((DAT_00127a30 == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,lStack0000000000000078),\n       lVar27 = DAT_00127a30, cVar10 != '\\0')) {\n      uVar11 = (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      uVar28 = (ulong)uVar11;\n      if ((char)uVar11 != '\\0') {\n        if (DAT_00127930 == 0) {\n          return uVar28;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,DAT_00127930 & 0xffffffff);\n        uVar23 = DAT_00127930;\n        if (cVar10 == '\\0') {\n          uVar19 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          FUN_00119ed0(uVar19,uVar23);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) == 5) {\n            uVar19 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            FUN_00119ed0(uVar19);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) = (short)DAT_00127930;\n            return uVar28;\n          }\n          uVar19 = dcgettext(0,\"ignoring the alternative value\",5);\n          FUN_00119ed0(uVar19);\n          return uVar28;\n        }\n        return uVar28;\n      }\n      uVar19 = dcgettext(0,\"error copying private BFD data\",5);\n      FUN_001126c0(0,param_7,0,uVar19);\n    }\n    else {\n      uVar19 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar19,lVar27);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar34[0x1a] + 4) == 7)) &&\n      (cVar10 = FUN_00113fb0(*pplVar34), cVar10 != '\\0')) &&\n     ((pplVar34[0xc] != (long *)0x0 && (plVar6 = pplVar34[8], plVar6 != (long *)0x0)))) {\n    pplVar29 = (long **)xmalloc(0x20);\n    pplVar29[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      FUN_001126c0(0);\n      free(pplVar29);\n    }\n    else {\n      plVar16 = (long *)FUN_001163d0();\n      pplVar29[2] = plVar16;\n      if ((plVar16 == plVar6) || (cVar10 = bfd_set_section_size(pplVar34[0xc]), cVar10 != '\\0')) {\n        pplVar29[3] = (long *)__ptr_01;\n        *pplVar29 = (long *)pplVar34;\n        __ptr_01 = pplVar29;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        FUN_001126c0(0,param_7,pplVar34);\n        free(pplVar29[1]);\n        free(pplVar29);\n      }\n    }\n  }\n  pplVar34 = (long **)pplVar34[1];\n  puVar31 = DAT_001279d0;\n  if (pplVar34 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_001125fa",
                "FUN_00107880",
                "FUN_00119ed0"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001152b6",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "FUNC_001152b6"
        },
        "FUN_00114cf0": {
            "renaming": {
                "FUN_00114cf0": "allocate_and_copy_path_00114cf0",
                "param_1": "path",
                "pcVar1": "last_delimiter",
                "lVar2": "length",
                "lVar3": "path_offset",
                "lVar4": "delimiter_offset",
                "pcVar5": "new_path",
                "bVar6": "found_delimiter"
            },
            "code": "\nvoid allocate_and_copy_path_00114cf0(char *path)\n\n{\n  char *last_delimiter;\n  long length;\n  long path_offset;\n  long delimiter_offset;\n  char *new_path;\n  byte found_delimiter;\n  \n  found_delimiter = 0;\n  last_delimiter = strrchr(path,0x2f);\n  if (last_delimiter == (char *)0x0) {\n    last_delimiter = (char *)xmalloc(9);\n    path_offset = 0;\n  }\n  else {\n    delimiter_offset = (long)last_delimiter - (long)path;\n    last_delimiter = (char *)xmalloc(delimiter_offset + 0xb);\n    path_offset = delimiter_offset + 1;\n    new_path = last_delimiter;\n    for (length = delimiter_offset; length != 0; length = length + -1) {\n      *new_path = *path;\n      path = path + (ulong)found_delimiter * -2 + 1;\n      new_path = new_path + (ulong)found_delimiter * -2 + 1;\n    }\n    last_delimiter[delimiter_offset] = '/';\n  }\n  *(undefined8 *)(last_delimiter + path_offset) = 0x5858585858587473;\n  *(undefined *)((long)(last_delimiter + path_offset) + 8) = 0;\n  return;\n}\n\n",
            "called": [
                "xmalloc",
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114cf0",
            "calling": [
                "FUN_00116b90",
                "FUN_0011a0e0"
            ],
            "imported": false,
            "current_name": "allocate_and_copy_path_00114cf0"
        },
        "FUN_0010a181": {
            "renaming": {
                "FUN_0010a181": "process_data_0010a181",
                "param_1": "dataPointer",
                "param_2": "startValue",
                "param_3": "endValue",
                "param_4": "flag",
                "cVar1": "charValue",
                "__s": "string1",
                "__s_00": "string2",
                "sVar5": "length1",
                "sVar6": "length2",
                "__s_01": "resultString",
                "local_41": "localFlag",
                "iVar2": "intVar1",
                "lVar7": "longVar1",
                "iVar3": "intVar2",
                "uVar4": "result"
            },
            "code": "\nundefined4 processData_0010a181(long dataPointer,long startValue,long endValue,byte flag)\n\n{\n  char charValue;\n  int intVar1;\n  int intVar2;\n  undefined4 result;\n  char *string1;\n  char *string2;\n  size_t length1;\n  size_t length2;\n  char *resultString;\n  long longVar1;\n  byte localFlag;\n  \n  charValue = *(char *)(*(long *)(dataPointer + 0x60) + 0x1c);\n  string1 = (char *)FUN_00109b2f();\n  localFlag = 1;\n  if (charValue == '\\0') {\n    localFlag = *(byte *)(*(long *)(dataPointer + 0x60) + 0x1c);\n  }\n  intVar1 = *(int *)(*(long *)(dataPointer + 0x60) + 0x18);\n  string2 = (char *)FUN_00109b2f(dataPointer);\n  length1 = strlen(string1);\n  length2 = strlen(string2);\n  resultString = (char *)xmalloc(length1 + 100 + length2);\n  if (flag == 0) {\n    *resultString = '\\0';\n    longVar1 = 0;\n    localFlag = localFlag & 1;\n  }\n  else {\n    longVar1 = *(long *)(dataPointer + 0x68);\n    *(long *)(dataPointer + 0x68) = longVar1 + 1;\n    sprintf(resultString,\"%ld=@S;\",longVar1);\n    localFlag = flag;\n  }\n  length1 = strlen(resultString);\n  sprintf(resultString + length1,\"ar%s;%ld;%ld;%s\",string1,startValue,endValue,string2);\n  free(string1);\n  free(string2);\n  intVar2 = 0;\n  if (startValue <= endValue) {\n    intVar2 = intVar1 * (((int)endValue - (int)startValue) + 1);\n  }\n  result = FUN_00109b52(dataPointer,resultString,longVar1,localFlag,intVar2);\n  if ((char)result != '\\0') {\n    free(resultString);\n  }\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00109b52",
                "free",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a181",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_data_0010a181"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104540",
            "calling": [
                "FUN_00116b90",
                "FUN_0011a480"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "FUN_001199d0": {
            "renaming": {
                "FUN_001199d0": "print_bfd_header_info_001199d0",
                "iVar1": "columnWidth",
                "iVar2": "archIndex",
                "iVar3": "strcmpResult",
                "pcVar4": "headerFormat",
                "sVar5": "headerLength",
                "pcVar6": "tempFilePath",
                "uVar7": "concatenatedPath",
                "piVar8": "errorNumberPtr",
                "iVar9": "archIndex2",
                "lVar10": "loopIndex1",
                "lVar11": "loopIndex2",
                "ppcVar12": "archMachPtr",
                "uVar13": "maxArchMachLength",
                "uVar14": "archNameLength",
                "local_70": "tempFileResult"
            },
            "code": "\n\n\nvoid printBFDHeaderInfo_001199d0(void)\n\n{\n  int columnWidth;\n  int archIndex;\n  int strcmpResult;\n  char *headerFormat;\n  size_t headerLength;\n  char *tempFilePath;\n  undefined8 concatenatedPath;\n  int *errorNumberPtr;\n  int archIndex2;\n  long loopIndex1;\n  long loopIndex2;\n  char **archMachPtr;\n  uint maxArchMachLength;\n  ulong archNameLength;\n  int tempFileResult;\n  \n  headerFormat = (char *)dcgettext(0,\"BFD header file version %s\\n\",5);\n  printf(headerFormat,\"(GNU Binutils for Debian) 2.40\");\n  if (DAT_001278e0 == (char *)0x0) {\n    headerFormat = getenv(\"TMPDIR\");\n    concatenatedPath = FUN_0011283f(headerFormat,0);\n    headerFormat = getenv(\"TMP\");\n    concatenatedPath = FUN_0011283f(headerFormat,concatenatedPath);\n    headerFormat = getenv(\"TEMP\");\n    concatenatedPath = FUN_0011283f(headerFormat,concatenatedPath);\n    concatenatedPath = FUN_0011283f(&DAT_0011b39a,concatenatedPath);\n    concatenatedPath = FUN_0011283f(\"/var/tmp\",concatenatedPath);\n    headerFormat = (char *)FUN_0011283f(&DAT_00120324,concatenatedPath);\n    if (headerFormat == (char *)0x0) {\n      headerFormat = \".\";\n    }\n    headerLength = strlen(headerFormat);\n    tempFilePath = (char *)xmalloc((int)headerLength + 2);\n    DAT_001278e0 = strcpy(tempFilePath,headerFormat);\n    DAT_001278e0[headerLength & 0xffffffff] = '/';\n    DAT_001278e0[(int)headerLength + 1] = '\\0';\n  }\n  headerFormat = DAT_001278e0;\n  headerLength = strlen(DAT_001278e0);\n  loopIndex1 = (long)(int)headerLength;\n  tempFilePath = (char *)xmalloc(loopIndex1 + 9);\n  strcpy(tempFilePath,headerFormat);\n  *(undefined2 *)(tempFilePath + loopIndex1) = 0x6363;\n  *(undefined4 *)(tempFilePath + loopIndex1 + 2) = 0x58585858;\n  *(undefined4 *)((long)(tempFilePath + loopIndex1 + 2) + 3) = 0x585858;\n  tempFilePath[loopIndex1 + 8] = '\\0';\n  archIndex = mkstemps(tempFilePath,0);\n  if (archIndex == -1) {\n    errorNumberPtr = __errno_location();\n    tempFilePath = strerror(*errorNumberPtr);\n    fprintf(_stderr,\"Cannot create temporary file in %s: %s\\n\",headerFormat,tempFilePath);\n                    \n    abort();\n  }\n  archIndex = close(archIndex);\n  if (archIndex != 0) {\n                    \n    abort();\n  }\n  maxArchMachLength = 0;\n  archIndex = 2;\n  bfd_iterate_over_targets(FUN_00119f70);\n  unlink(tempFilePath);\n  free(tempFilePath);\n  tempFileResult = 0;\n  do {\n    headerFormat = (char *)bfd_printable_arch_mach(archIndex);\n    headerLength = strlen(headerFormat);\n    if ((int)maxArchMachLength < (int)(uint)headerLength) {\n      maxArchMachLength = (uint)headerLength;\n    }\n    archIndex = archIndex + 1;\n  } while (archIndex != 0x57);\n  headerFormat = getenv(\"COLUMNS\");\n  archIndex = tempFileResult;\n  if (headerFormat != (char *)0x0) {\n    loopIndex1 = strtol(headerFormat,(char **)0x0,10);\n    columnWidth = (int)loopIndex1;\n    if (columnWidth != 0) goto LAB_00119b11;\n  }\n  columnWidth = 0x50;\nLAB_00119b11:\n  do {\n    tempFileResult = archIndex;\n    if (-1 < tempFileResult) {\n      return;\n    }\n    loopIndex2 = (long)tempFileResult;\n    archIndex2 = (columnWidth - maxArchMachLength) + -1;\n    loopIndex1 = loopIndex2;\n    do {\n      archIndex = (int)loopIndex1;\n      if (-1 < archIndex) break;\n      headerLength = strlen(*(char **)(loopIndex1 * 0x60));\n      loopIndex1 = loopIndex1 + 1;\n      archIndex2 = (archIndex2 - (int)headerLength) + -1;\n    } while (-1 < archIndex2);\n    printf(\"\\n%*s\",(ulong)(maxArchMachLength + 1),&DAT_0011b4a1);\n    for (archMachPtr = (char **)(loopIndex2 * 0x60);\n        ((ulong)(uint)(archIndex - tempFileResult) + loopIndex2) * 0x60 - (long)archMachPtr != 0;\n        archMachPtr = archMachPtr + 0xc) {\n      printf(\"%s \",*archMachPtr);\n    }\n    archIndex2 = 2;\n    putc(10,_stdout);\n    do {\n      headerFormat = (char *)bfd_printable_arch_mach(archIndex2,0);\n      strcmpResult = strcmp(headerFormat,\"UNKNOWN!\");\n      if (strcmpResult != 0) {\n        concatenatedPath = bfd_printable_arch_mach(archIndex2,0);\n        printf(\"%*s \",(ulong)maxArchMachLength,concatenatedPath);\n        archMachPtr = (char **)(loopIndex2 * 0x60);\n        strcmpResult = tempFileResult;\n        while (archIndex != strcmpResult) {\n          if (*(char *)((long)archMachPtr + (ulong)(archIndex2 - 2) + 8) == '\\0') {\n            headerLength = strlen(*archMachPtr);\n            for (archNameLength = headerLength & 0xffffffff; (int)archNameLength != 0; archNameLength = (ulong)((int)archNameLength - 1)) {\n              putc(0x2d,_stdout);\n            }\n          }\n          else {\n            fputs(*archMachPtr,_stdout);\n          }\n          strcmpResult = strcmpResult + 1;\n          if (archIndex != strcmpResult) {\n            putc(0x20,_stdout);\n          }\n          archMachPtr = archMachPtr + 0xc;\n        }\n        putc(10,_stdout);\n      }\n      archIndex2 = archIndex2 + 1;\n    } while (archIndex2 != 0x57);\n  } while( true );\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "strerror",
                "mkstemps",
                "bfd_printable_arch_mach",
                "FUN_00119f70",
                "strlen",
                "strcpy",
                "getenv",
                "fprintf",
                "__errno_location",
                "free",
                "bfd_iterate_over_targets",
                "unlink",
                "FUN_0011283f",
                "abort",
                "close",
                "FUN_00104943",
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001199d0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "print_bfd_header_info_001199d0"
        },
        "FUN_0010847a": {
            "renaming": {
                "FUN_0010847a": "execute_initial_setup_0010847a"
            },
            "code": "\nvoid executeInitialSetup_0010847a(void)\n\n{\n  FUN_00116490();\n  return;\n}\n\n",
            "called": [
                "FUN_00116490"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010847a",
            "calling": [
                "FUN_001086af"
            ],
            "imported": false,
            "current_name": "execute_initial_setup_0010847a"
        },
        "FUN_0010d21c": {
            "renaming": {
                "FUN_0010d21c": "reverse_and_improve_code_0010d21c",
                "bVar1": "byteVar1",
                "pbVar2": "bytePtrVar2",
                "bVar3": "byteVar3",
                "cVar4": "charVar4",
                "bVar5": "byteVar5",
                "uVar6": "resultVar",
                "iVar7": "intVar7",
                "uVar8": "uintVar8",
                "sVar9": "sizeVar9",
                "pbVar10": "bytePtrVar10",
                "__ptr": "ptrVar",
                "__ptr_00": "ptrVar2",
                "__haystack": "haystackVar",
                "pcVar11": "charPtrVar11",
                "uVar12": "ulongVar12",
                "pcVar13": "charPtrVar13",
                "bVar14": "byteVar14",
                "pcVar15": "charPtrVar15",
                "bVar16": "byteVar16",
                "bVar17": "byteVar17",
                "bVar18": "byteVar18",
                "bVar19": "byteVar19",
                "uVar20": "uintVar20",
                "uVar21": "ulongVar21",
                "local_3c": "localArray"
            },
            "code": "\nundefined4 reverseAndImproveCode_0010d21c(undefined8 param_1,byte **param_2,undefined8 *param_3)\n\n{\n  byte byteVar1;\n  byte *bytePtrVar2;\n  byte byteVar3;\n  char charVar4;\n  byte byteVar5;\n  undefined4 resultVar;\n  int intVar7;\n  uint uintVar8;\n  size_t sizeVar9;\n  byte *bytePtrVar10;\n  void *ptrVar;\n  void *ptrVar2;\n  char *haystackVar;\n  char *charPtrVar11;\n  undefined8 ulongVar12;\n  char *charPtrVar13;\n  byte byteVar14;\n  char *charPtrVar15;\n  byte byteVar16;\n  byte byteVar17;\n  byte byteVar18;\n  byte byteVar19;\n  uint uintVar20;\n  ulong ulongVar21;\n  uint localArray [3];\n  \n  bytePtrVar2 = *param_2;\n  *param_2 = bytePtrVar2 + 1;\n  localArray[0] = FUN_00108e76(param_2);\n  ulongVar21 = (ulong)localArray[0];\n  if (localArray[0] != 0) {\n    bytePtrVar10 = *param_2;\n    sizeVar9 = strlen((char *)bytePtrVar10);\n    if (ulongVar21 <= sizeVar9) {\n      *param_2 = bytePtrVar10 + ulongVar21;\n      uintVar20 = 0;\n      resultVar = FUN_00108ea1(param_2,localArray);\n      if ((char)resultVar != '\\0') {\nLAB_0010d2b4:\n        if (localArray[0] <= uintVar20) {\n          if (param_3 == (undefined8 *)0x0) {\n            return resultVar;\n          }\n          ptrVar = (void *)FUN_00109a0b(bytePtrVar2,(int)*param_2 - (int)bytePtrVar2);\n          ptrVar2 = (void *)concat(\"NoSuchStrinG__\",ptrVar,0);\n          free(ptrVar);\n          haystackVar = (char *)cplus_demangle(ptrVar2,2);\n          free(ptrVar2);\n          if ((haystackVar != (char *)0x0) &&\n             (charPtrVar11 = strstr(haystackVar,\"::NoSuchStrinG\"), charPtrVar13 = haystackVar,\n             charPtrVar15 = haystackVar, charPtrVar11 != (char *)0x0)) {\n            for (; charPtrVar13 != charPtrVar11; charPtrVar13 = charPtrVar13 + 1) {\n              if ((*charPtrVar13 != ' ') ||\n                 (((charPtrVar13[1] == '>' && (haystackVar < charPtrVar13)) && (charPtrVar13[-1] == '>')))) {\n                *charPtrVar15 = *charPtrVar13;\n                charPtrVar15 = charPtrVar15 + 1;\n              }\n            }\n            ulongVar12 = FUN_00109a0b(haystackVar,(int)charPtrVar15 - (int)haystackVar);\n            *param_3 = ulongVar12;\n            free(haystackVar);\n            return resultVar;\n          }\n          FUN_0010911f(bytePtrVar2);\n          free(haystackVar);\n          return 0;\n        }\n        bytePtrVar10 = *param_2;\n        if (*bytePtrVar10 != 0x5a) {\n          byteVar5 = FUN_0010c95e(param_1,param_2,0);\n          if (byteVar5 == 0) {\n            return 0;\n          }\n          byteVar3 = 0;\n          byteVar14 = 0;\n          byteVar18 = 0;\n          byteVar17 = 0;\n          byteVar19 = 0;\nLAB_0010d2e9:\n          do {\n            do {\n              byteVar16 = byteVar3;\n              byteVar1 = *bytePtrVar10;\n              if ((byteVar14 | byteVar1 == 0) != 0) {\n                byteVar5 = 0;\n                goto switchD_0010d329_caseD_70;\n              }\n              byteVar3 = byteVar5;\n              byteVar14 = byteVar5;\n            } while ('v' < (char)byteVar1);\n            if ((char)byteVar1 < 'b') {\n              if ((char)byteVar1 < 'U') {\n                if ((char)byteVar1 < 'C') goto LAB_0010d2e9;\n                ulongVar21 = 1L << (byteVar1 + 0xbd & 0x3f);\n                if ((ulongVar21 & 0x11409) == 0) {\n                  if ((ulongVar21 & 0xa000) != 0) goto switchD_0010d329_caseD_70;\n                  if (byteVar1 == 0x54) goto switchD_0010d329_caseD_76;\n                  goto LAB_0010d2e9;\n                }\n              }\n              else if (1 < (byte)(byteVar1 + 0xab)) goto LAB_0010d2e9;\n              bytePtrVar10 = bytePtrVar10 + 1;\n              byteVar3 = byteVar16;\n              byteVar14 = 0;\n              goto LAB_0010d2e9;\n            }\n            switch(byteVar1) {\n            case 0x62:\n              byteVar3 = byteVar16;\n              byteVar18 = byteVar5;\n              break;\n            case 99:\n              byteVar3 = byteVar16;\n              byteVar19 = byteVar5;\n              break;\n            case 100:\n            case 0x66:\n            case 0x72:\n              byteVar3 = byteVar16;\n              byteVar17 = byteVar5;\n              break;\n            case 0x70:\n              goto switchD_0010d329_caseD_70;\n            case 0x76:\nswitchD_0010d329_caseD_76:\n                    \n              abort();\n            }\n          } while( true );\n        }\n        *param_2 = bytePtrVar10 + 1;\n        charVar4 = FUN_0010c95e(param_1,param_2,0);\n        if (charVar4 == '\\0') {\n          return 0;\n        }\n        goto LAB_0010d2b1;\n      }\n    }\n  }\nLAB_0010d280:\n  FUN_0010911f(bytePtrVar2);\n  return 0;\nswitchD_0010d329_caseD_70:\n  if (byteVar16 == 0) {\n    if (byteVar19 == 0) {\n      if (byteVar18 == 0) {\n        if (byteVar17 == 0) {\n          if (byteVar5 != 0) {\n            uintVar8 = FUN_00108e76(param_2);\n            if (uintVar8 == 0) goto LAB_0010d280;\n            *param_2 = *param_2 + uintVar8;\n          }\n        }\n        else {\n          if (**param_2 == 0x6d) {\n            *param_2 = *param_2 + 1;\n          }\n          while( true ) {\n            bytePtrVar10 = *param_2;\n            if (((&_sch_istable)[(ulong)*bytePtrVar10 * 2] & 4) == 0) break;\n            *param_2 = bytePtrVar10 + 1;\n          }\n          if (*bytePtrVar10 == 0x2e) {\n            do {\n              bytePtrVar10 = bytePtrVar10 + 1;\n              *param_2 = bytePtrVar10;\n            } while (((&_sch_istable)[(ulong)*bytePtrVar10 * 2] & 4) != 0);\n          }\n          bytePtrVar10 = *param_2;\n          if (*bytePtrVar10 == 0x65) {\n            do {\n              bytePtrVar10 = bytePtrVar10 + 1;\n              *param_2 = bytePtrVar10;\n            } while (((&_sch_istable)[(ulong)*bytePtrVar10 * 2] & 4) != 0);\n          }\n        }\n      }\n      else {\n        uintVar8 = FUN_00108e76(param_2);\n        if (1 < uintVar8) goto LAB_0010d280;\n      }\n    }\n    else {\n      if (**param_2 == 0x6d) {\n        *param_2 = *param_2 + 1;\n      }\n      intVar7 = FUN_00108e76(param_2);\n      if (intVar7 == 0) goto LAB_0010d280;\n    }\n  }\n  else {\n    if (**param_2 == 0x6d) {\n      *param_2 = *param_2 + 1;\n    }\n    while (((&_sch_istable)[(ulong)**param_2 * 2] & 4) != 0) {\n      *param_2 = *param_2 + 1;\n    }\n  }\nLAB_0010d2b1:\n  uintVar20 = uintVar20 + 1;\n  goto LAB_0010d2b4;\n}\n\n",
            "called": [
                "free",
                "strstr",
                "abort",
                "FUN_0010911f",
                "cplus_demangle",
                "FUN_00108e76",
                "FUN_0010c95e",
                "FUN_00109a0b",
                "FUN_00108ea1",
                "concat",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d21c",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010c95e",
                "FUN_0010d559"
            ],
            "imported": false,
            "current_name": "reverse_and_improve_code_0010d21c"
        },
        "FUN_001054af": {
            "renaming": {
                "FUN_001054af": "delete_hash_tables_001054af",
                "param_1": "unusedParam1",
                "param_2": "unusedParam2",
                "in_RAX": "unusedVar1"
            },
            "code": "\nvoid deleteHashTables_001054af(undefined8 unusedParam1,undefined8 unusedParam2)\n\n{\n  undefined8 unusedVar1;\n  \n  htab_delete(DAT_00127a18);\n  htab_delete(DAT_00127a10);\n  htab_delete(DAT_00127a28);\n  htab_delete(DAT_00127a08);\n  htab_delete(DAT_00127a00);\n  htab_delete(DAT_001279f8);\n  htab_delete(DAT_001279f0);\n  htab_delete(DAT_001278f0);\n  htab_delete(DAT_001278e8,unusedParam2,unusedVar1);\n  return;\n}\n\n",
            "called": [
                "htab_delete"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001054af",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "delete_hash_tables_001054af"
        },
        "FUN_0010c139": {
            "renaming": {
                "FUN_0010c139": "allocate_and_update_0010c139",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "uVar1": "previousPointer",
                "cVar2": "charValue",
                "uVar3": "returnValue",
                "puVar4": "allocatedMemory",
                "in_R10": "registerValue",
                "unaff_R15": "unaffectedValue"
            },
            "code": "\nulong allocateAndUpdate_0010c139(undefined8 param1,long param2,undefined8 param3,undefined8 param4,\n                  undefined4 param5,undefined8 param6)\n\n{\n  undefined8 previousPointer;\n  char charValue;\n  ulong returnValue;\n  undefined8 *allocatedMemory;\n  undefined8 registerValue;\n  undefined8 unaffectedValue;\n  \n  charValue = *(char *)(param2 + 0x60);\n  if ((charValue != '\\0') && ((*(int *)(param2 + 0x40) != 0 || (*(char *)(param2 + 0x44) == '\\0')))) {\n    allocatedMemory = (undefined8 *)xmalloc(0x28);\n    previousPointer = *(undefined8 *)(param2 + 0x78);\n    *(undefined8 *)((long)allocatedMemory + 0x1c) = 0;\n    allocatedMemory[2] = param4;\n    *(undefined4 *)(allocatedMemory + 3) = param5;\n    allocatedMemory[4] = param6;\n    *(undefined8 **)(param2 + 0x78) = allocatedMemory;\n    *allocatedMemory = previousPointer;\n    allocatedMemory[1] = param3;\n    return CONCAT71((int7)((ulong)unaffectedValue >> 8),charValue) & 0xffffffff;\n  }\n  returnValue = FUN_0010c05d(param1,param3,param4,param5,param6,registerValue);\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_0010c05d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c139",
            "calling": [
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "allocate_and_update_0010c139"
        },
        "FUN_0010e439": {
            "renaming": {
                "FUN_0010e439": "update_data_0010e439",
                "param_1": "dataAddr",
                "param_2": "newValue"
            },
            "code": "\nvoid updateData_0010e439(long dataAddr,undefined8 newValue)\n\n{\n  *(undefined8 *)(dataAddr + 0x210) = newValue;\n  FUN_0010e2f0(dataAddr,0x84,0,0,newValue);\n  return;\n}\n\n",
            "called": [
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e439",
            "calling": [
                "FUN_0011378f",
                "thunk_FUN_0010e439"
            ],
            "imported": false,
            "current_name": "update_data_0010e439"
        },
        "sprintf": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047e0",
            "calling": [
                "FUN_001125fa",
                "FUN_0010abdd",
                "FUN_00109e76",
                "FUN_0010a181",
                "FUN_0010b948",
                "FUN_00109cf4",
                "FUN_0010e6a8",
                "FUN_00109d97",
                "FUN_0010a2b9",
                "FUN_0010e918",
                "FUN_0010a77a",
                "FUN_0010eafe",
                "FUN_0010e7c2",
                "FUN_00109dfe",
                "FUN_0010e9a0",
                "FUN_0010ba08",
                "FUN_0010e8a9",
                "FUN_0010e453",
                "FUN_0010ee3f",
                "FUN_0010a69a",
                "FUN_0010ebb0",
                "FUN_00109ed3",
                "FUN_0010aa53",
                "FUN_0010a83e",
                "FUN_0010e842",
                "FUN_0010ae0e",
                "FUN_0010a424",
                "FUN_0010a94e",
                "FUN_0010b800",
                "FUN_0010e5db",
                "FUN_0010a0e9",
                "FUN_0010a377",
                "FUN_0010ab4d"
            ],
            "imported": false,
            "current_name": "sprintf"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104270",
            "calling": [
                "FUN_001125fa",
                "FUN_00113fb0",
                "FUN_00116b90",
                "FUN_0010abdd",
                "FUN_0010a181",
                "FUN_00113ede",
                "FUN_0011173a",
                "FUN_00108c86",
                "FUN_0010e6a8",
                "FUN_0010a2b9",
                "FUN_0010e918",
                "FUN_0010a77a",
                "FUN_001199d0",
                "FUN_0011378f",
                "FUN_0010eafe",
                "FUN_00104943",
                "FUN_0010554f",
                "FUN_0010e7c2",
                "FUN_0010e9a0",
                "FUN_0010ba08",
                "FUN_0010e8a9",
                "FUN_0010e453",
                "FUN_0010ee3f",
                "FUN_0010a69a",
                "FUN_0010ebb0",
                "FUN_00109ed3",
                "FUN_0010aa53",
                "FUN_0010d21c",
                "FUN_00115530",
                "FUN_0010a83e",
                "FUN_00109bbb",
                "FUN_0010e842",
                "FUN_0010d559",
                "FUN_0010ae0e",
                "FUN_0010a424",
                "FUN_0010a94e",
                "FUN_0010b800",
                "FUN_0010e5db",
                "FUN_0010a0e9",
                "FUN_0010a377",
                "FUN_00104ad6",
                "FUN_0010e2f0",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_0010ab4d"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "memcmp": {
            "renaming": {},
            "code": "\n\n\nint memcmp(void *__s1,void *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = memcmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "memcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104420",
            "calling": [
                "FUN_0011a1b0",
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "memcmp"
        },
        "FUN_00109d3e": {
            "renaming": {
                "FUN_00109d3e": "perform_operation_00109d3e",
                "param_1": "inputValue",
                "param_2": "arrayLength",
                "uVar1": "defaultValue"
            },
            "code": "\nvoid performOperation_00109d3e(undefined8 inputValue,int arrayLength)\n\n{\n  undefined8 defaultValue;\n  \n  defaultValue = 0xfffffffffffffff0;\n  if (arrayLength - 1U < 8) {\n    defaultValue = *(undefined8 *)(&DAT_00121360 + (ulong)(arrayLength - 1U) * 8);\n  }\n  FUN_00109cf4(inputValue,defaultValue,arrayLength);\n  return;\n}\n\n",
            "called": [
                "FUN_00109cf4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d3e",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "perform_operation_00109d3e"
        },
        "FUN_00112502": {
            "renaming": {
                "FUN_00112502": "check_and_process_data_00112502",
                "param_1": "data_ptr",
                "param_2": "helper_var",
                "param_3": "target_value",
                "uVar1": "count",
                "puVar2": "subdata_ptr",
                "uVar3": "temp_value",
                "cVar4": "result"
            },
            "code": "\nundefined check_and_process_data_00112502(long data_ptr,undefined8 helper_var,ulong target_value)\n\n{\n  uint count;\n  undefined8 *subdata_ptr;\n  undefined8 temp_value;\n  char result;\n  \n  do {\n    subdata_ptr = *(undefined8 **)(data_ptr + 0x40);\n    if (subdata_ptr == (undefined8 *)0x0) {\n      return 1;\n    }\n    while ((count = *(uint *)(data_ptr + 0x48), count < 10 && (subdata_ptr[(ulong)count + 2] != -1))) {\n      if (target_value <= (ulong)subdata_ptr[(ulong)count + 0xc]) {\n        return 1;\n      }\n      result = FUN_0010edb4(helper_var,*(undefined8 *)(subdata_ptr[1] + 8));\n      if (result == '\\0') {\n        return 0;\n      }\n      *(int *)(data_ptr + 0x48) = *(int *)(data_ptr + 0x48) + 1;\n    }\n    temp_value = *subdata_ptr;\n    *(undefined4 *)(data_ptr + 0x48) = 0;\n    *(undefined8 *)(data_ptr + 0x40) = temp_value;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_0010edb4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112502",
            "calling": [
                "FUN_001135a5",
                "FUN_00113a4d",
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "check_and_process_data_00112502"
        },
        "bfd_fill_in_gnu_debuglink_section": {
            "renaming": {},
            "code": "\nvoid bfd_fill_in_gnu_debuglink_section(void)\n\n{\n  bfd_fill_in_gnu_debuglink_section();\n  return;\n}\n\n",
            "called": [
                "bfd_fill_in_gnu_debuglink_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104600",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_fill_in_gnu_debuglink_section"
        },
        "FUN_00104cc1": {
            "renaming": {
                "FUN_00104cc1": "parse_and_ignore_rubbish_00104cc1",
                "unaff_EBP": "lineNumber",
                "unaff_RBX": "currentLine",
                "unaff_R13": "translatedLine",
                "unaff_R14": "readingPointer",
                "unaff_R15": "endOfBuffer",
                "param_7": "errorMessage",
                "param_8": "output",
                "param_9": "input"
            },
            "code": "\nvoid parseAndIgnoreRubbish_00104cc1(void)\n\n{\n  undefined8 uVar1;\n  byte **ppbVar2;\n  byte *pbVar3;\n  byte bVar4;\n  byte *currentLine;\n  byte *pbVar5;\n  int lineNumber;\n  byte *in_R10;\n  undefined8 translatedLine;\n  byte *readingPointer;\n  byte *endOfBuffer;\n  undefined8 errorMessage;\n  undefined8 *output;\n  byte *input;\n  \ncode_r0x00104cc1:\n  input = in_R10;\n  uVar1 = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n  FUN_00119ed0(uVar1,errorMessage,lineNumber);\n  pbVar5 = currentLine;\n  in_R10 = input;\nLAB_00114599:\n  do {\n    *in_R10 = 0;\n    if (endOfBuffer < in_R10) {\n      ppbVar2 = (byte **)htab_find_slot();\n      *ppbVar2 = endOfBuffer;\n    }\n    lineNumber = lineNumber + 1;\n    pbVar3 = pbVar5;\n    if (readingPointer[1] == 0) {\n      *output = translatedLine;\n      return;\n    }\n    for (; bVar4 = *pbVar3, readingPointer = pbVar3, bVar4 != 10; pbVar3 = pbVar3 + 1) {\n      if ((char)bVar4 < '\\v') {\n        if (bVar4 == 0) {\n          currentLine = pbVar3 + 1;\n          goto LAB_00114553;\n        }\n      }\n      else {\n        if (bVar4 == 0xd) {\n          *pbVar3 = 0;\n          currentLine = pbVar3 + 1;\n          if (pbVar3[1] == 10) {\n            currentLine = pbVar3 + 2;\n            readingPointer = pbVar3 + 1;\n          }\n          goto LAB_00114553;\n        }\n        if (bVar4 == 0x23) {\n          FUN_00104d1c();\n          return;\n        }\n      }\n    }\n    *pbVar3 = 0;\n    if (pbVar3[1] == 0xd) {\n      readingPointer = pbVar3 + 1;\n      currentLine = pbVar3 + 2;\n    }\n    else {\n      currentLine = pbVar3 + 1;\n    }\nLAB_00114553:\n    bVar4 = *pbVar5;\n    endOfBuffer = pbVar5;\n    while ((bVar4 == 0x20 || (in_R10 = endOfBuffer, bVar4 == 9))) {\n      pbVar5 = endOfBuffer + 1;\n      endOfBuffer = endOfBuffer + 1;\n      bVar4 = *pbVar5;\n    }\n    do {\n      pbVar5 = currentLine;\n      if ((bVar4 == 10) || (bVar4 == 0xd)) goto LAB_00114676;\n      if (bVar4 == 0) goto LAB_00114599;\n      bVar4 = in_R10[1];\n      in_R10 = in_R10 + 1;\n    } while ((bVar4 != 0x20) && (bVar4 != 9));\n    if ((char)bVar4 < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (bVar4 & 0x3f) & 1U) == 0) goto LAB_00114599;\n    }\n    bVar4 = in_R10[1];\n    if ((((((bVar4 == 9) || (bVar4 == 0x20)) && ((bVar4 = in_R10[2], bVar4 == 9 || (bVar4 == 0x20)))\n          ) && ((bVar4 = in_R10[3], bVar4 == 9 || (bVar4 == 0x20)))) &&\n        ((bVar4 = in_R10[4], bVar4 == 9 || (bVar4 == 0x20)))) &&\n       ((bVar4 = in_R10[5], bVar4 == 9 || (bVar4 == 0x20)))) {\n      bVar4 = in_R10[6];\n      pbVar3 = in_R10 + 6;\n      if ((bVar4 == 9) || (bVar4 == 0x20)) {\n        do {\n          do {\n            bVar4 = pbVar3[1];\n            pbVar3 = pbVar3 + 1;\n          } while (bVar4 == 0x20);\n        } while (bVar4 == 9);\n      }\n    }\n    if ((0xd < bVar4) || ((-0x2402L >> (bVar4 & 0x3f) & 1U) != 0)) goto code_r0x00104cc1;\n  } while( true );\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00104cc1",
                "FUN_00119ed0",
                "FUN_00104c36",
                "htab_find_slot",
                "FUN_00104d1c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104cc1",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "parse_and_ignore_rubbish_00104cc1"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042b0",
            "calling": [
                "FUN_00116b90",
                "FUN_0010ee3f",
                "FUN_0010abdd",
                "FUN_00109ed3",
                "FUN_0010aa53",
                "FUN_00114dc7",
                "FUN_0010d7d4",
                "FUN_00119f70",
                "FUN_0011173a",
                "FUN_0010b6ea",
                "FUN_00109c2e",
                "FUN_00109be3",
                "FUN_0010e07c",
                "FUN_0010e2f0",
                "FUN_0010dac0",
                "FUN_0010ab4d"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "FUN_00113bfa": {
            "renaming": {
                "FUN_00113bfa": "allocate_and_store_parameters_00113bfa",
                "param_1": "input1",
                "param_2": "input2",
                "lVar1": "result",
                "plVar2": "allocated_memory"
            },
            "code": "\nlong allocate_and_store_parameters_00113bfa(long input1,long input2)\n\n{\n  long result;\n  long *allocated_memory;\n  \n  if (((input1 != 0) && (input2 != 0)) && (result = FUN_00112904(0x12,0), result != 0)) {\n    allocated_memory = (long *)xmalloc(0x10);\n    *allocated_memory = input1;\n    allocated_memory[1] = input2;\n    *(long **)(result + 0x10) = allocated_memory;\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113bfa",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010c95e"
            ],
            "imported": false,
            "current_name": "allocate_and_store_parameters_00113bfa"
        },
        "FUN_00108375": {
            "renaming": {
                "FUN_00108375": "drop_share_flag_if_not_coff_00108375",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "var1",
                "uVar2": "var2",
                "unaff_EBX": "ebx"
            },
            "code": "\nuint dropShareFlagIfNotCOFF_00108375(undefined8 param1,undefined8 *param2,undefined8 param3)\n\n{\n  undefined8 var1;\n  undefined8 var2;\n  uint ebx;\n  \n  if (*(int *)(param2[1] + 8) != 2) {\n    var1 = *param2;\n    ebx = ebx & 0xf7ffffff;\n    var2 = dcgettext(0,\"%s[%s]: Note - dropping \\'share\\' flag as output format is not COFF\",5);\n    FUN_00119ed0(var2,var1,param3);\n  }\n  return ebx;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00119ed0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108375",
            "calling": [
                "FUN_00115f30"
            ],
            "imported": false,
            "current_name": "drop_share_flag_if_not_coff_00108375"
        },
        "bfd_get_arch": {
            "renaming": {},
            "code": "\nvoid bfd_get_arch(void)\n\n{\n  bfd_get_arch();\n  return;\n}\n\n",
            "called": [
                "bfd_get_arch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104570",
            "calling": [
                "FUN_00107880",
                "FUN_00104ea2",
                "FUN_00105828",
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "bfd_get_arch"
        },
        "FUN_00109e76": {
            "renaming": {
                "FUN_00109e76": "generate_formatted_string_00109e76",
                "param_1": "inputPointer",
                "param_2": "inputValue",
                "lVar1": "currentValue",
                "local_5a": "formattedString"
            },
            "code": "\nvoid generateFormattedString_00109e76(long inputPointer,uint inputValue)\n\n{\n  long currentValue;\n  char formattedString [58];\n  \n  currentValue = *(long *)(inputPointer + 0x68);\n  *(long *)(inputPointer + 0x68) = currentValue + 1;\n  sprintf(formattedString,\"%ld=r%ld;%u;0;\",currentValue,currentValue,(ulong)inputValue);\n  FUN_00109b52(inputPointer,formattedString,currentValue,1,inputValue * 2);\n  return;\n}\n\n",
            "called": [
                "FUN_00109b52",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109e76",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "generate_formatted_string_00109e76"
        },
        "FUN_001088ae": {
            "renaming": {
                "FUN_001088ae": "update_data_001088ae",
                "param_1": "newValue1",
                "param_2": "newValue2",
                "param_3": "newValue3",
                "param_4": "newValue4",
                "iVar1": "nextIndex",
                "lVar2": "currentIndex",
                "lVar3": "arrayIndex",
                "uVar4": "duplicatedString"
            },
            "code": "\nulong updateData_001088ae(undefined4 newValue1,undefined4 newValue2,undefined8 newValue3,undefined8 newValue4)\n\n{\n  int nextIndex;\n  long currentIndex;\n  long arrayIndex;\n  undefined8 duplicatedString;\n  \n  currentIndex = (long)DAT_001278c0;\n  arrayIndex = currentIndex * 0x18;\n  free((void *)(&DAT_00127750)[currentIndex * 3]);\n  *(undefined4 *)(&DAT_00127740 + arrayIndex) = newValue1;\n  *(undefined4 *)(&DAT_00127744 + arrayIndex) = newValue2;\n  *(undefined8 *)(&DAT_00127748 + arrayIndex) = newValue3;\n  duplicatedString = xstrdup(newValue4);\n  (&DAT_00127750)[currentIndex * 3] = duplicatedString;\n  nextIndex = DAT_001278c0 + 1;\n  DAT_001278c0 = nextIndex % 0x10;\n  return (long)nextIndex / 0x10 & 0xffffffff;\n}\n\n",
            "called": [
                "xstrdup",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001088ae",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "update_data_001088ae"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a4b4",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "FUN_0010afd5": {
            "renaming": {
                "FUN_0010afd5": "lookup_and_update_0010afd5",
                "param_1": "list",
                "param_2": "context",
                "param_3": "string",
                "param_4": "param1",
                "param_5": "param2",
                "param_6": "param3",
                "iVar1": "comparison_result",
                "__s2": "lookup_string",
                "puVar2": "current_item",
                "uVar3": "result",
                "lVar4": "result_value",
                "puVar5": "sub_list_item",
                "puVar6": "data_ptr",
                "bVar7": "flag",
                "auVar8": "result_struct"
            },
            "code": "\nundefined  [16]\nlookup_and_update_0010afd5(undefined8 *list,long context,undefined8 string,undefined4 param1,\n            undefined4 param2,undefined8 param3)\n\n{\n  int comparison_result;\n  char *lookup_string;\n  undefined8 *current_item;\n  undefined8 result;\n  long result_value;\n  undefined8 *sub_list_item;\n  undefined4 *data_ptr;\n  byte flag;\n  undefined result_struct [16];\n  \n  flag = 0;\n  lookup_string = (char *)FUN_00109a0b(string,param1);\n  for (list = (undefined8 *)*list; list != (undefined8 *)0x0;\n      list = (undefined8 *)*list) {\n    for (current_item = (undefined8 *)list[1]; current_item != (undefined8 *)0x0;\n        current_item = (undefined8 *)*current_item) {\n      if ((undefined8 *)current_item[2] != (undefined8 *)0x0) {\n        for (sub_list_item = *(undefined8 **)(undefined8 *)current_item[2]; sub_list_item != (undefined8 *)0x0;\n            sub_list_item = (undefined8 *)*sub_list_item) {\n          if ((*(int *)((long)sub_list_item + 0x14) == 1) && (*(char *)sub_list_item[1] == *lookup_string)) {\n            comparison_result = strcmp((char *)sub_list_item[1],lookup_string);\n            if (comparison_result == 0) {\n              result_value = sub_list_item[4];\n              if (result_value == 0) goto LAB_0010b05b;\n              free(lookup_string);\n              goto LAB_0010b0eb;\n            }\n          }\n        }\n      }\n    }\n  }\nLAB_0010b05b:\n  current_item = *(undefined8 **)(context + 0x1a0);\n  do {\n    if (current_item == (undefined8 *)0x0) {\n      current_item = (undefined8 *)xmalloc(0x28);\n      result = *(undefined8 *)(context + 0x1a0);\n      data_ptr = (undefined4 *)((long)current_item + 0x14);\n      for (result_value = 5; result_value != 0; result_value = result_value + -1) {\n        *data_ptr = 0;\n        data_ptr = data_ptr + (ulong)flag * -2 + 1;\n      }\n      *(undefined4 *)(current_item + 2) = param2;\n      *current_item = result;\n      current_item[1] = lookup_string;\n      result = FUN_00113e23(current_item + 3,lookup_string);\n      *(undefined8 **)(context + 0x1a0) = current_item;\n      current_item[4] = result;\nLAB_0010b0e7:\n      result_value = current_item[4];\nLAB_0010b0eb:\n      result_struct._8_8_ = param3;\n      result_struct._0_8_ = result_value;\n      return result_struct;\n    }\n    if (*(char *)current_item[1] == *lookup_string) {\n      comparison_result = strcmp((char *)current_item[1],lookup_string);\n      if (comparison_result == 0) {\n        if (*(int *)(current_item + 2) == 0) {\n          *(undefined4 *)(current_item + 2) = param2;\n        }\n        free(lookup_string);\n        goto LAB_0010b0e7;\n      }\n    }\n    current_item = (undefined8 *)*current_item;\n  } while( true );\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "strcmp",
                "FUN_00109a0b",
                "FUN_00113e23"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010afd5",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_0010d559"
            ],
            "imported": false,
            "current_name": "lookup_and_update_0010afd5"
        },
        "FUN_0010ee3f": {
            "renaming": {
                "FUN_0010ee3f": "FUNC_0010ee3f"
            },
            "code": "\n\n\nvoid * FUNC_0010ee3f(undefined8 param_1,long param_2,char *param_3,byte **param_4,undefined8 *param_5\n                   ,byte *param_6)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte *pbVar3;\n  long lVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  char cVar8;\n  byte bVar9;\n  int iVar10;\n  undefined4 uVar11;\n  uint uVar12;\n  undefined4 uVar13;\n  int iVar14;\n  undefined8 uVar15;\n  char *pcVar16;\n  void *pvVar17;\n  void **ppvVar18;\n  long lVar19;\n  long lVar20;\n  int *piVar21;\n  undefined *puVar22;\n  char **ppcVar23;\n  void *pvVar24;\n  void *pvVar25;\n  ulong uVar26;\n  byte *pbVar27;\n  byte *pbVar28;\n  char *pcVar29;\n  size_t sVar30;\n  byte *pbVar31;\n  undefined8 *puVar32;\n  size_t sVar33;\n  byte **ppbVar34;\n  void **ppvVar35;\n  undefined8 uVar36;\n  undefined8 uVar37;\n  long lVar38;\n  long *plVar39;\n  char *pcVar40;\n  bool bVar41;\n  byte *pbVar42;\n  char cVar43;\n  undefined uVar44;\n  ulong uVar45;\n  char *pcVar46;\n  byte bVar47;\n  byte bVar48;\n  ulong uVar49;\n  byte *pbVar50;\n  bool bVar51;\n  bool bVar52;\n  undefined auVar53 [16];\n  undefined auVar54 [16];\n  void *local_158;\n  char *local_150;\n  byte *local_140;\n  char local_138;\n  char local_130;\n  uint local_12c;\n  char *local_128;\n  byte *local_120;\n  void *local_118;\n  byte *local_110;\n  undefined4 local_100;\n  uint local_fc;\n  uint local_f0;\n  uint local_ec;\n  uint local_e0;\n  int local_d0;\n  char local_a9;\n  undefined8 local_a8;\n  byte *local_a0;\n  undefined8 local_98;\n  long local_90;\n  long local_88;\n  char local_80;\n  undefined7 uStack_7f;\n  void *local_78;\n  undefined4 local_70;\n  int local_6c;\n  void *local_68;\n  int local_5c;\n  \n  bVar48 = 0;\n  if (param_5 != (undefined8 *)0x0) {\n    *param_5 = 0;\n  }\n  pbVar3 = *param_4;\n  if (param_6 <= pbVar3) {\n    return (void *)0x0;\n  }\n  *(undefined *)(param_2 + 0x1a8) = 0;\n  bVar9 = *pbVar3;\n  if (((bVar9 != 0x28 && bVar9 != 0x2d) &\n      ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar9 * 2) >> 2) ^ 1)) == 0) {\n    cVar6 = FUN_00109ab1(param_4,&local_a8,param_6);\n    if (cVar6 == '\\0') {\n      return (void *)0x0;\n    }\n    if (**param_4 != 0x3d) {\n      pvVar17 = (void *)FUN_0010c2d2(param_1,param_2,&local_a8);\n      return pvVar17;\n    }\n    if (param_5 != (undefined8 *)0x0) {\n      if (-1 < (int)((uint)local_a8 | local_a8._4_4_)) {\n        uVar15 = FUN_00109022(param_2);\n        *param_5 = uVar15;\n      }\n    }\n    *param_4 = *param_4 + 1;\n    local_12c = 0xffffffff;\n    cVar8 = '\\0';\n    do {\n      while( true ) {\n        do {\n          cVar43 = cVar8;\n          pbVar27 = *param_4;\n          if (((*pbVar27 != 0x40) ||\n              (bVar9 = pbVar27[1], ((&_sch_istable)[(ulong)bVar9 * 2] & 4) != 0)) ||\n             (pbVar50 = pbVar27, bVar9 == 0x28 || bVar9 == 0x2d)) goto LAB_0010efe0;\n          while( true ) {\n            bVar9 = pbVar50[1];\n            if (bVar9 == 0x3b) break;\n            pbVar50 = pbVar50 + 1;\n            if (bVar9 == 0) goto switchD_0010f055_caseD_24;\n          }\n          *param_4 = pbVar50 + 2;\n          bVar9 = pbVar27[1];\n          cVar8 = cVar6;\n        } while (bVar9 == 0x53);\n        cVar8 = cVar43;\n        if (bVar9 != 0x73) break;\n        lVar38 = strtol((char *)(pbVar27 + 2),(char **)0x0,10);\n        local_12c = 0xffffffff;\n        if (7 < (int)lVar38) {\n          local_12c = (int)lVar38 >> 3;\n        }\n      }\n    } while (bVar9 != 0);\n    goto switchD_0010f055_caseD_24;\n  }\n  local_12c = 0xffffffff;\n  cVar43 = '\\0';\n  local_a8 = 0xffffffffffffffff;\nLAB_0010efe0:\n  pbVar50 = *param_4;\n  bVar9 = *pbVar50;\n  pbVar27 = pbVar50 + 1;\n  *param_4 = pbVar27;\n  if ('x' < (char)bVar9) goto switchD_0010f055_caseD_24;\n  if ((char)bVar9 < 'a') {\n    if (bVar9 == 0x40) {\n      lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar38 == 0) {\n        return (void *)0x0;\n      }\n      if (**param_4 != 0x2c) goto switchD_0010f055_caseD_24;\n      *param_4 = *param_4 + 1;\n      lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar19 == 0) {\n        return (void *)0x0;\n      }\n      pvVar17 = (void *)FUN_00113bfa(lVar38,lVar19);\n    }\n    else if ((char)bVar9 < 'A') {\n      if ('-' < (char)bVar9) {\n        if (9 < (byte)(bVar9 - 0x30)) goto switchD_0010f055_caseD_24;\nswitchD_0010f055_caseD_28:\n        *param_4 = pbVar50;\n        cVar6 = FUN_00109ab1(param_4,&local_98,param_6);\n        if (cVar6 == '\\0') {\n          return (void *)0x0;\n        }\n        iVar10 = (uint)local_a8;\n        if ((uint)local_a8 == (uint)local_98) {\n          if (local_a8._4_4_ == local_98._4_4_) {\n            pvVar17 = (void *)FUN_00113e17();\n            if (iVar10 != -1) {\n              ppvVar18 = (void **)FUN_00109022(param_2,&local_a8);\n              if (ppvVar18 == (void **)0x0) {\n                return (void *)0x0;\n              }\n              *ppvVar18 = pvVar17;\n            }\n            goto LAB_001115e2;\n          }\n        }\n        *param_4 = pbVar50;\n        pvVar17 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (pvVar17 == (void *)0x0) {\n          return (void *)0x0;\n        }\n        if (iVar10 != -1) {\n          ppvVar18 = (void **)FUN_00109022(param_2,&local_a8);\n          if (ppvVar18 == (void **)0x0) {\n            return (void *)0x0;\n          }\n          *ppvVar18 = pvVar17;\n        }\n        goto LAB_001115eb;\n      }\n      if ((char)bVar9 < '#') goto switchD_0010f055_caseD_24;\n      switch(bVar9) {\n      case 0x23:\n        if (pbVar50[1] == 0x23) {\n          *param_4 = pbVar50 + 2;\n          lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar38 == 0) {\n            return (void *)0x0;\n          }\n          if (**param_4 != 0x3b) goto switchD_0010f055_caseD_24;\n          *param_4 = *param_4 + 1;\n          pvVar17 = (void *)FUN_00113b98(lVar38,0,0,0);\n        }\n        else {\n          lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar38 == 0) {\n            return (void *)0x0;\n          }\n          if (**param_4 != 0x2c) goto switchD_0010f055_caseD_24;\n          *param_4 = *param_4 + 1;\n          lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n          if (lVar19 == 0) {\n            return (void *)0x0;\n          }\n          uVar45 = 10;\n          uVar49 = 0;\n          auVar53 = xmalloc(0x50);\n          while( true ) {\n            lVar20 = auVar53._0_8_;\n            pbVar27 = *param_4;\n            iVar10 = (int)uVar49;\n            if (*pbVar27 == 0x3b) break;\n            if (*pbVar27 != 0x2c) {\n              FUN_00108fb9(pbVar3);\n              return (void *)0x0;\n            }\n            *param_4 = pbVar27 + 1;\n            if ((uint)uVar45 <= iVar10 + 1U) {\n              uVar45 = (ulong)((uint)uVar45 + 10);\n              lVar20 = xrealloc(lVar20,uVar45 << 3);\n            }\n            auVar54 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n            auVar53._8_8_ = auVar54._8_8_;\n            auVar53._0_8_ = lVar20;\n            *(long *)(lVar20 + uVar49 * 8) = auVar54._0_8_;\n            if (auVar54._0_8_ == 0) {\n              return (void *)0x0;\n            }\n            uVar49 = (ulong)(iVar10 + 1U);\n          }\n          uVar15 = 1;\n          *param_4 = pbVar27 + 1;\n          uVar45 = uVar49;\n          if (iVar10 != 0) {\n            uVar45 = (ulong)(iVar10 - 1);\n            lVar4 = *(long *)(lVar20 + uVar45 * 8);\n            if (((lVar4 == 0) ||\n                (piVar21 = (int *)FUN_00112b6e(lVar4,0,0x3b,1), piVar21 == (int *)0x0)) ||\n               (*piVar21 != 2)) {\n              uVar15 = 1;\n              uVar45 = uVar49;\n            }\n            else {\n              uVar15 = 0;\n            }\n          }\n          *(undefined8 *)(lVar20 + uVar45 * 8) = 0;\n          pvVar17 = (void *)FUN_00113b98(lVar19,lVar38,lVar20,uVar15);\n        }\n        break;\n      default:\n        goto switchD_0010f055_caseD_24;\n      case 0x26:\n        uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        pvVar17 = (void *)FUN_00113cb9(uVar15);\n        break;\n      case 0x28:\n      case 0x2d:\n        goto switchD_0010f055_caseD_28;\n      case 0x2a:\n        uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        pvVar17 = (void *)FUN_00113d3a(uVar15);\n      }\n    }\n    else if (bVar9 == 0x52) {\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      lVar38 = FUN_00109a32(param_4,0,param_6);\n      if ((**param_4 != 0x3b) || (uVar11 = FUN_00109a32(param_4,0,param_6), **param_4 != 0x3b))\n      goto LAB_0010fb4c;\n      if (lVar38 - 3U < 3) {\n        pvVar17 = (void *)FUN_00112904(5);\n      }\n      else {\n        pvVar17 = (void *)FUN_00113df2(uVar11);\n      }\n    }\n    else {\n      if (bVar9 == 0x53) {\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (lVar38 == 0) {\n          return (void *)0x0;\n        }\n        pvVar17 = (void *)FUN_00112904(0x11,0);\n        if (pvVar17 == (void *)0x0) {\n          return (void *)0x0;\n        }\n        plVar39 = (long *)xmalloc(0x10);\n        *(undefined4 *)((long)plVar39 + 9) = 0;\n        *plVar39 = lVar38;\n        *(undefined4 *)((long)plVar39 + 0xc) = 0;\n        *(char *)(plVar39 + 1) = cVar43;\n        *(long **)((long)pvVar17 + 0x10) = plVar39;\n        goto LAB_001115eb;\n      }\n      if (bVar9 != 0x42) goto switchD_0010f055_caseD_24;\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)FUN_00113b4a(uVar15);\n    }\n  }\n  else {\n    switch(bVar9) {\n    case 0x61:\n      if (pbVar50[1] != 0x72) goto switchD_0010f055_caseD_24;\n      pbVar50 = pbVar50 + 2;\n      *param_4 = pbVar50;\n      if (param_6 <= pbVar50) {\n        return (void *)0x0;\n      }\n      local_a0 = pbVar50;\n      cVar6 = FUN_00109ab1(&local_a0,&local_98,param_6);\n      if (cVar6 == '\\0') {\n        return (void *)0x0;\n      }\n      if ((((uint)local_98 | local_98._4_4_) == 0) && (**param_4 != 0x3d)) {\n        lVar38 = FUN_0010914e(param_1,\"int\");\n        if ((lVar38 == 0) && (lVar38 = FUN_00113dfe(4,0), lVar38 == 0)) {\n          return (void *)0x0;\n        }\n        *param_4 = local_a0;\n      }\n      else {\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      }\n      pbVar3 = *param_4;\n      if (*pbVar3 != 0x3b) {\nLAB_0011151b:\n        FUN_00108fb9(pbVar50);\n        return (void *)0x0;\n      }\n      *param_4 = pbVar3 + 1;\n      bVar48 = pbVar3[1];\n      bVar48 = (bVar48 != 0x2d && bVar48 != 0) &\n               ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar48 * 2) >> 2) ^ 1);\n      if (bVar48 != 0) {\n        *param_4 = pbVar3 + 2;\n      }\n      uVar15 = FUN_00109a32(param_4,0,param_6);\n      pbVar3 = *param_4;\n      if (*pbVar3 != 0x3b) goto LAB_0011151b;\n      *param_4 = pbVar3 + 1;\n      bVar9 = pbVar3[1];\n      bVar9 = (bVar9 != 0x2d && bVar9 != 0) &\n              ((byte)(*(ushort *)(&_sch_istable + (ulong)bVar9 * 2) >> 2) ^ 1);\n      if (bVar9 != 0) {\n        *param_4 = pbVar3 + 2;\n        bVar48 = bVar9;\n      }\n      uVar36 = FUN_00109a32(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0011151b;\n      *param_4 = *param_4 + 1;\n      lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      if (lVar19 == 0) {\n        return (void *)0x0;\n      }\n      if (bVar48 != 0) {\n        uVar15 = 0;\n      }\n      uVar37 = 0xffffffffffffffff;\n      if (bVar48 == 0) {\n        uVar37 = uVar36;\n      }\n      pvVar17 = (void *)FUN_00113c43(lVar19,lVar38,uVar15,uVar37,cVar43);\n      break;\n    case 0x62:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      if (pbVar50[1] == 0x73) {\n        uVar44 = 0;\n      }\n      else {\n        if (pbVar50[1] != 0x75) goto LAB_0010fb4c;\n        uVar44 = 1;\n      }\n      *param_4 = pbVar50 + 2;\n      if (((byte)(pbVar50[2] + 0x9e) < 2) || (pbVar50[2] == 0x76)) {\n        *param_4 = pbVar50 + 3;\n      }\n      FUN_00109a32(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      FUN_00109a32(param_4,0,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      uVar49 = FUN_00109a32(param_4,0,param_6);\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      if (uVar49 != 0) {\n        pvVar17 = (void *)FUN_00113dfe(uVar49 >> 3 & 0xffffffff,uVar44);\n        break;\n      }\nLAB_0010fa8f:\n      pvVar17 = (void *)FUN_00113e17();\n      break;\n    default:\n      goto switchD_0010f055_caseD_24;\n    case 0x65:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      if (pbVar50[1] == 0x2d) {\n        while( true ) {\n          pbVar3 = *param_4;\n          if (*pbVar3 == 0x3a) break;\n          if (*pbVar3 == 0) goto LAB_0010fb4c;\n          *param_4 = pbVar3 + 1;\n        }\n        *param_4 = pbVar3 + 1;\n      }\n      uVar45 = 10;\n      pvVar17 = (void *)xmalloc(0x50);\n      pvVar24 = (void *)xmalloc(0x50);\n      uVar49 = 0;\n      while( true ) {\n        pbVar3 = *param_4;\n        pbVar50 = pbVar3;\n        if ((*pbVar3 < 0x3c) && ((-0x800100000000002 >> (*pbVar3 & 0x3f) & 1U) == 0)) break;\n        for (; *pbVar50 != 0x3a; pbVar50 = pbVar50 + 1) {\n          if (*pbVar50 == 0) {\n            FUN_00108fb9(pbVar27);\n            free(pvVar17);\n            free(pvVar24);\n            return (void *)0x0;\n          }\n        }\n        pvVar25 = (void *)FUN_00109a0b(pbVar3,(int)pbVar50 - (int)pbVar3);\n        *param_4 = pbVar50 + 1;\n        uVar15 = FUN_00109a32(param_4,0,param_6);\n        if (**param_4 != 0x2c) {\n          FUN_00108fb9(pbVar27);\n          free(pvVar25);\n          free(pvVar17);\n          free(pvVar24);\n          return (void *)0x0;\n        }\n        uVar12 = (int)uVar49 + 1;\n        *param_4 = *param_4 + 1;\n        if ((uint)uVar45 <= uVar12) {\n          uVar45 = (ulong)((uint)uVar45 + 10);\n          pvVar17 = (void *)xrealloc(pvVar17,uVar45 << 3);\n          pvVar24 = (void *)xrealloc(pvVar24,uVar45 << 3);\n        }\n        *(void **)((long)pvVar17 + uVar49 * 8) = pvVar25;\n        *(undefined8 *)((long)pvVar24 + uVar49 * 8) = uVar15;\n        uVar49 = (ulong)uVar12;\n      }\n      *(undefined8 *)((long)pvVar17 + uVar49 * 8) = 0;\n      *(undefined8 *)((long)pvVar24 + uVar49 * 8) = 0;\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      pvVar17 = (void *)FUN_00113d6e(pvVar17,pvVar24);\n      break;\n    case 0x66:\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)FUN_00113ce0(uVar15,0,0);\n      break;\n    case 0x6b:\n      uVar15 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n      pvVar17 = (void *)FUN_00113b71(uVar15);\n      break;\n    case 0x72:\n      if (param_6 <= pbVar27) {\n        return (void *)0x0;\n      }\n      cVar6 = FUN_00109ab1(param_4,&local_98,param_6);\n      if (cVar6 == '\\0') {\n        return (void *)0x0;\n      }\n      bVar51 = false;\n      if ((uint)local_98 == (uint)local_a8) {\n        bVar51 = local_98._4_4_ == local_a8._4_4_;\n      }\n      lVar38 = 0;\n      if (**param_4 == 0x3d) {\n        *param_4 = pbVar27;\n        lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n        if (lVar38 == 0) {\n          return (void *)0x0;\n        }\n      }\n      if (**param_4 == 0x3b) {\n        *param_4 = *param_4 + 1;\n      }\n      pbVar3 = *param_4;\n      uVar49 = FUN_00109a32(param_4,&local_a9,param_6);\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      pbVar50 = *param_4 + 1;\n      *param_4 = pbVar50;\n      uVar45 = FUN_00109a32(param_4,&local_a0,param_6);\n      cVar6 = local_a9;\n      if (**param_4 != 0x3b) goto LAB_0010fb4c;\n      *param_4 = *param_4 + 1;\n      if ((local_a9 == '\\0') && ((char)local_a0 == '\\0')) {\nLAB_0010f700:\n        if (lVar38 != 0) goto LAB_0010f956;\n        if ((!bVar51) || (uVar49 != 0)) {\n          bVar52 = uVar45 != 0;\n          if ((!bVar51) || (bVar52)) {\n            if (((long)uVar49 < 1) || (bVar52)) {\n              if ((uVar45 == 0xffffffffffffffff) && (uVar49 == 0)) goto LAB_0010f788;\n              if (uVar49 == 0) goto LAB_0010f829;\n              if ((-1 < (long)uVar49) || (bVar52)) goto LAB_0010f8cd;\n              if ((uVar49 == 0xfffffffffffffff8) || (bVar51)) goto LAB_0010f89d;\n              if (uVar49 != 0xffffffffffffffff) {\n                if (uVar49 != 1) goto LAB_0010f956;\n                goto LAB_0010f8eb;\n              }\nLAB_0010f8ff:\n              if (uVar45 == 0x7f) goto LAB_0010f810;\n              if (uVar45 == 0x7fff) {\nLAB_0010f912:\n                pvVar17 = (void *)FUN_00113dfe(2,0);\n              }\n              else {\n                if (uVar45 != 0x7fffffff) {\n                  if (uVar45 == 0x7fffffffffffffff) goto LAB_0010f7a5;\n                  goto LAB_0010f956;\n                }\nLAB_0010f92f:\n                pvVar17 = (void *)FUN_00113dfe(4,0);\n              }\n            }\n            else {\n              pvVar17 = (void *)FUN_00113df2(uVar49 & 0xffffffff);\n            }\n          }\n          else if ((long)uVar49 < 1) {\n            if (-1 < (long)uVar49) {\nLAB_0010f8cd:\n              if (uVar49 == ~uVar45) goto LAB_0010f8ff;\n              if (uVar49 == uVar45 + 1) {\n                if (uVar45 == 0x7f) goto LAB_0010f810;\nLAB_0010f8eb:\n                if (uVar45 == 0x7fff) goto LAB_0010f912;\n                if (uVar45 == 0x7fffffff) goto LAB_0010f92f;\n              }\nLAB_0010f956:\n              if (bVar51) {\nLAB_0010fb4c:\n                FUN_00108fb9(pbVar27);\n                return (void *)0x0;\n              }\n              lVar38 = FUN_0010c2d2(param_1,param_2,&local_98);\n              if (lVar38 == 0) {\n                uVar15 = dcgettext(0,\"missing index type\",5);\n                FUN_00108fe8(pbVar27,uVar15);\n                lVar38 = FUN_00113dfe(4,0);\n                if (lVar38 == 0) {\n                  return (void *)0x0;\n                }\n              }\n              pvVar17 = (void *)FUN_00112904(0xf,0);\n              if (pvVar17 == (void *)0x0) {\n                return (void *)0x0;\n              }\n              plVar39 = (long *)xmalloc(0x18);\n              *plVar39 = lVar38;\n              plVar39[1] = uVar49;\n              plVar39[2] = uVar45;\n              *(long **)((long)pvVar17 + 0x10) = plVar39;\n              goto LAB_001115eb;\n            }\nLAB_0010f89d:\n            pvVar17 = (void *)FUN_00113dfe(-(int)uVar49,1);\n          }\n          else {\n            pvVar17 = (void *)FUN_00112904(5,uVar49 & 0xffffffff);\n          }\n        }\n        else {\n          if (uVar45 == 0) goto LAB_0010fa8f;\n          if (uVar45 == 0xffffffffffffffff) {\nLAB_0010f788:\n            if (param_3 != (char *)0x0) {\n              iVar10 = strcmp(param_3,\"long long int\");\n              if (iVar10 == 0) goto LAB_0010f7a5;\n              iVar10 = strcmp(param_3,\"long long unsigned int\");\n              if (iVar10 == 0) goto LAB_0010f7ce;\n            }\nLAB_0010f7f3:\n            pvVar17 = (void *)FUN_00113dfe(4,1);\n          }\n          else if (uVar45 == 0x7f) {\nLAB_0010f810:\n            pvVar17 = (void *)FUN_00113dfe(1,0);\n          }\n          else {\nLAB_0010f829:\n            if ((long)uVar45 < 0) {\n              pvVar17 = (void *)FUN_00113dfe(-(int)uVar45,1);\n            }\n            else if (uVar45 == 0xff) {\n              pvVar17 = (void *)FUN_00113dfe(1,1);\n            }\n            else {\n              if (uVar45 != 0xffff) {\n                if (uVar45 != 0xffffffff) goto LAB_0010f956;\n                goto LAB_0010f7f3;\n              }\n              pvVar17 = (void *)FUN_00113dfe(2,1);\n            }\n          }\n        }\n      }\n      else {\n        if (lVar38 != 0) {\nLAB_0010f6e2:\n          uVar15 = dcgettext(0,\"numeric overflow\",5);\n          FUN_00108fe8(pbVar27,uVar15);\n          goto LAB_0010f700;\n        }\n        cVar8 = FUN_00113fb0(pbVar3,\"01000000000000000000000;\");\n        if ((cVar8 == '\\0') ||\n           (cVar8 = FUN_00113fb0(pbVar50,\"0777777777777777777777;\"), cVar8 == '\\0')) {\n          if ((cVar6 == '\\x01') ||\n             ((uVar49 != 0 ||\n              (cVar6 = FUN_00113fb0(pbVar50,\"01777777777777777777777;\"), cVar6 == '\\0'))))\n          goto LAB_0010f6e2;\nLAB_0010f7ce:\n          pvVar17 = (void *)FUN_00113dfe(8,1);\n        }\n        else {\nLAB_0010f7a5:\n          pvVar17 = (void *)FUN_00113dfe(8,0);\n        }\n      }\n      break;\n    case 0x73:\n    case 0x75:\n      uVar49 = FUN_00109a32(param_4,0,param_6);\n      pbVar3 = *param_4;\n      if (pbVar3 < param_6) {\n        local_118 = (void *)0x0;\n        if (*pbVar3 == 0x21) {\n          *param_4 = pbVar3 + 1;\n          uVar12 = FUN_00109a32(param_4,0,param_6);\n          if (**param_4 != 0x2c) {\nLAB_0010fe26:\n            FUN_00108fb9(pbVar3);\n            goto LAB_0010fe2e;\n          }\n          *param_4 = *param_4 + 1;\n          lVar38 = 0;\n          local_118 = (void *)xmalloc();\n          while ((uint)lVar38 < uVar12) {\n            bVar1 = **param_4;\n            if (bVar1 == 0x30) {\nLAB_0010fe06:\n              uVar44 = 0;\n            }\n            else {\n              if (bVar1 != 0x31) {\n                if (bVar1 != 0) {\n                  uVar15 = dcgettext(0,\"unknown virtual character for baseclass\",5);\n                  FUN_00108fe8(pbVar3,uVar15);\n                  goto LAB_0010fe06;\n                }\n                goto LAB_0010fe26;\n              }\n              uVar44 = 1;\n            }\n            pbVar27 = *param_4;\n            *param_4 = pbVar27 + 1;\n            bVar1 = pbVar27[1];\n            if (bVar1 == 0x31) {\n              uVar11 = 1;\n            }\n            else {\n              if ((char)bVar1 < '2') {\n                if (bVar1 == 0) goto LAB_0010fe26;\n                uVar11 = 2;\n                if (bVar1 == 0x30) goto LAB_0010fd53;\nLAB_0010fe6c:\n                uVar15 = dcgettext(0,\"unknown visibility character for baseclass\",5);\n                FUN_00108fe8(pbVar3,uVar15);\n              }\n              else if (bVar1 != 0x32) goto LAB_0010fe6c;\n              uVar11 = 0;\n            }\nLAB_0010fd53:\n            *param_4 = *param_4 + 1;\n            uVar13 = FUN_00109a32(param_4,0,param_6);\n            if (**param_4 != 0x2c) goto LAB_0010fe26;\n            *param_4 = *param_4 + 1;\n            lVar19 = FUNC_0010ee3f(param_1,param_2,0,param_4);\n            if (lVar19 == 0) goto LAB_0010fe2e;\n            plVar39 = (long *)xmalloc();\n            *(undefined8 *)((long)plVar39 + 0xd) = 0;\n            *(undefined4 *)(plVar39 + 1) = uVar13;\n            *(undefined4 *)((long)plVar39 + 0x14) = 0;\n            *plVar39 = lVar19;\n            *(long **)((long)local_118 + lVar38 * 8) = plVar39;\n            lVar38 = lVar38 + 1;\n            *(undefined *)((long)plVar39 + 0xc) = uVar44;\n            *(undefined4 *)(plVar39 + 2) = uVar11;\n            if (**param_4 != 0x3b) goto LAB_0010fe2e;\n            *param_4 = *param_4 + 1;\n          }\n          *(undefined8 *)((long)local_118 + lVar38 * 8) = 0;\n        }\n        pbVar3 = *param_4;\n        if (pbVar3 < param_6) {\n          uVar45 = 0;\n          local_158 = (void *)xmalloc(0x50);\n          bVar51 = false;\n          local_150._0_4_ = 10;\n          while (pbVar27 = *param_4, *pbVar27 != 0x3b) {\n            uVar12 = (int)uVar45 + 1;\n            if ((uint)local_150 <= uVar12) {\n              local_150._0_4_ = (uint)local_150 + 10;\n              local_158 = (void *)xrealloc(local_158);\n            }\n            if (((*pbVar27 == 0x24) || (*pbVar27 == 0x2e)) && (pbVar27[1] != 0x5f)) {\n              *param_4 = *param_4 + 1;\n              plVar39 = (long *)((long)local_158 + uVar45 * 8);\n              *plVar39 = 0;\n              pbVar27 = *param_4;\n              if (pbVar27 < param_6) {\n                if (*pbVar27 == 0x76) {\n                  *param_4 = pbVar27 + 1;\n                  bVar1 = pbVar27[1];\n                  if (bVar1 != 0) {\n                    *param_4 = pbVar27 + 2;\n                    lVar38 = FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n                    if (lVar38 == 0) goto LAB_001102dc;\n                    if (bVar1 == 0x62) {\n                      puVar22 = (undefined *)FUN_001129f4();\n                      if (puVar22 == (undefined *)0x0) {\n                        uVar15 = dcgettext(0,\"unnamed $vb type\",5);\n                        FUN_00108fe8(pbVar27,uVar15);\n                        puVar22 = &DAT_001206ea;\n                      }\n                      pcVar40 = (char *)concat(&DAT_0012077e,puVar22,0);\n                    }\n                    else {\n                      pcVar40 = \"_vptr$\";\n                      if (bVar1 != 0x66) {\n                        uVar15 = dcgettext(0,\"unrecognized C++ abbreviation\",5);\n                        pcVar40 = \"INVALID_CPLUSPLUS_ABBREV\";\n                        FUN_00108fe8(pbVar27,uVar15);\n                      }\n                    }\n                    if (**param_4 == 0x3a) {\n                      *param_4 = *param_4 + 1;\n                      pcVar16 = (char *)FUNC_0010ee3f(param_1,param_2,0);\n                      if (**param_4 == 0x2c) {\n                        *param_4 = *param_4 + 1;\n                        uVar11 = FUN_00109a32(param_4,0,param_6);\n                        if (**param_4 == 0x3b) {\n                          *param_4 = *param_4 + 1;\n                          ppcVar23 = (char **)xmalloc(0x20);\n                          *(undefined8 *)((long)ppcVar23 + 0x14) = 0;\n                          *(undefined4 *)((long)ppcVar23 + 0x1c) = 0;\n                          *ppcVar23 = pcVar40;\n                          ppcVar23[1] = pcVar16;\n                          *(undefined4 *)(ppcVar23 + 3) = uVar11;\n                          *(undefined4 *)(ppcVar23 + 2) = 2;\n                          *plVar39 = (long)ppcVar23;\n                          goto LAB_001102eb;\n                        }\n                      }\n                    }\n                  }\n                }\n                FUN_00108fb9(pbVar27);\n              }\nLAB_001102dc:\n              free(local_158);\n              goto LAB_0010fe2e;\n            }\n            pcVar40 = strchr((char *)pbVar27,0x3a);\n            if (pcVar40 == (char *)0x0) {\n              FUN_00108fb9(pbVar3);\n              free(local_158);\n              goto LAB_0010fe2e;\n            }\n            if (pcVar40[1] == ':') break;\n            pbVar27 = *param_4;\n            if (param_6 <= pbVar27) goto LAB_001102dc;\n            pvVar17 = (void *)FUN_00109a0b(pbVar27,(int)pcVar40 - (int)pbVar27);\n            *param_4 = (byte *)(pcVar40 + 1);\n            if (pcVar40[1] == '/') {\n              *param_4 = (byte *)(pcVar40 + 2);\n              cVar6 = pcVar40[2];\n              if (cVar6 == '1') {\n                uVar11 = 1;\n              }\n              else if (cVar6 < '2') {\n                if (cVar6 == '\\0') {\n                  FUN_00108fb9(pbVar27);\n                  goto LAB_001102dc;\n                }\n                uVar11 = 2;\n                if (cVar6 != '0') goto LAB_00110152;\n              }\n              else {\n                if (cVar6 != '2') {\nLAB_00110152:\n                  uVar15 = dcgettext(0,\"unknown visibility character for field\",5);\n                  FUN_00108fe8(pbVar27,uVar15);\n                }\n                uVar11 = 0;\n              }\n              *param_4 = *param_4 + 1;\n            }\n            else {\n              uVar11 = 0;\n            }\n            pvVar24 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4);\n            if (pvVar24 == (void *)0x0) {\nLAB_001101e1:\n              free(pvVar17);\n              goto LAB_001102dc;\n            }\n            puVar32 = (undefined8 *)((long)local_158 + uVar45 * 8);\n            pbVar50 = *param_4;\n            if (*pbVar50 != 0x3a) {\n              if (*pbVar50 == 0x2c) {\n                *param_4 = pbVar50 + 1;\n                uVar45 = FUN_00109a32(param_4,0,param_6);\n                if (**param_4 == 0x2c) {\n                  *param_4 = *param_4 + 1;\n                  uVar26 = FUN_00109a32(param_4,0,param_6);\n                  if (**param_4 == 0x3b) {\n                    *param_4 = *param_4 + 1;\n                    if ((uVar45 | uVar26) == 0) {\n                      uVar11 = 3;\n                    }\n                    ppvVar18 = (void **)xmalloc(0x20);\n                    *(undefined8 *)((long)ppvVar18 + 0x14) = 0;\n                    *ppvVar18 = pvVar17;\n                    ppvVar18[1] = pvVar24;\n                    *(int *)(ppvVar18 + 3) = (int)uVar45;\n                    *(int *)((long)ppvVar18 + 0x1c) = (int)uVar26;\n                    *(undefined4 *)(ppvVar18 + 2) = uVar11;\n                    *puVar32 = ppvVar18;\n                    goto LAB_001102eb;\n                  }\n                }\n              }\nLAB_001101d9:\n              FUN_00108fb9(pbVar27);\n              goto LAB_001101e1;\n            }\n            pbVar50 = pbVar50 + 1;\n            *param_4 = pbVar50;\n            pcVar40 = strchr((char *)pbVar50,0x3b);\n            if (pcVar40 == (char *)0x0) goto LAB_001101d9;\n            pvVar25 = (void *)FUN_00109a0b(pbVar50);\n            *param_4 = (byte *)(pcVar40 + 1);\n            ppvVar18 = (void **)xmalloc(0x20);\n            bVar51 = true;\n            *(undefined8 *)((long)ppvVar18 + 0x15) = 0;\n            *ppvVar18 = pvVar17;\n            ppvVar18[1] = pvVar24;\n            *(undefined *)((long)ppvVar18 + 0x14) = 1;\n            ppvVar18[3] = pvVar25;\n            *(undefined4 *)(ppvVar18 + 2) = uVar11;\n            *puVar32 = ppvVar18;\nLAB_001102eb:\n            uVar45 = (ulong)uVar12;\n          }\n          *(undefined8 *)((long)local_158 + uVar45 * 8) = 0;\n          pbVar3 = *param_4;\n          if (param_6 <= pbVar3) goto LAB_001112f3;\n          local_128 = (char *)0x0;\n          pbVar27 = (byte *)0x0;\n          pvVar24 = (void *)0x0;\n          local_150 = (char *)0x0;\n          local_e0 = 0;\n          local_fc = 0;\nLAB_00110345:\n          pbVar50 = *param_4;\n          bVar1 = *pbVar50;\n          if (((bVar1 != 0x3b) && (pcVar40 = strchr((char *)pbVar50,0x3a), pcVar40 != (char *)0x0))\n             && (pcVar40[1] == ':')) {\n            pbVar28 = (byte *)(pcVar40 + 2);\n            if (((bVar1 == 0x6f) && (pbVar50[1] == 0x70)) && (pbVar50[2] == 0x24)) {\n              *param_4 = pbVar28;\n              for (pbVar50 = pbVar28; *pbVar50 != 0x2e; pbVar50 = pbVar50 + 1) {\n                if (*pbVar50 == 0) goto LAB_00110788;\n              }\n              pbVar50 = pbVar50 + 1;\n              local_150 = (char *)FUN_00109a0b(pbVar28);\n            }\n            else {\n              local_150 = (char *)FUN_00109a0b(pbVar50);\n              pbVar50 = pbVar28;\n            }\n            *param_4 = pbVar50;\n            local_128 = (char *)xmalloc();\n            local_ec = 10;\n            local_140 = (byte *)0x0;\n            local_f0 = 0;\nLAB_00110406:\n            pbVar50 = local_140;\n            if (local_140 == (byte *)0x0) {\n              pbVar50 = (byte *)FUNC_0010ee3f(param_1,param_2,0);\n              if (pbVar50 == (byte *)0x0) goto LAB_001111e9;\n              if (**param_4 != 0x3a) goto LAB_00110788;\n            }\n            pbVar28 = *param_4;\n            *param_4 = pbVar28 + 1;\n            pcVar40 = strchr((char *)(pbVar28 + 1),0x3b);\n            if (pcVar40 == (char *)0x0) goto LAB_00110788;\n            piVar21 = (int *)FUN_00112b6e(pbVar50,0);\n            bVar52 = false;\n            if ((piVar21 != (int *)0x0) && (bVar52 = false, *piVar21 == 0x13)) {\n              bVar52 = true;\n              piVar21 = (int *)FUN_00112b6e(pbVar50,0);\n              if (piVar21 != (int *)0x0) {\n                if (*piVar21 == 0xd) {\n                  lVar38 = *(long *)(*(long *)(piVar21 + 4) + 8);\n                }\n                else {\n                  if (*piVar21 != 0x13) goto LAB_001104b1;\n                  lVar38 = *(long *)(*(long *)(piVar21 + 4) + 0x10);\n                }\n                bVar52 = lVar38 == 0;\n              }\n            }\nLAB_001104b1:\n            pbVar27 = (byte *)FUN_00109a0b(*param_4,(int)pcVar40 - (int)*param_4);\n            *param_4 = (byte *)(pcVar40 + 1);\n            cVar6 = pcVar40[1];\n            if (cVar6 == '0') {\n              local_100 = 2;\n            }\n            else if (cVar6 == '1') {\n              local_100 = 1;\n            }\n            else {\n              if (cVar6 == '\\0') goto LAB_00110788;\n              local_100 = 0;\n            }\n            *param_4 = (byte *)(pcVar40 + 2);\n            bVar1 = pcVar40[2];\n            if ('D' < (char)bVar1) {\nswitchD_00110537_caseD_40:\n              uVar15 = dcgettext(0,\"const/volatile indicator missing\",5);\n              FUN_00108fe8(pbVar3,uVar15);\n              goto switchD_00110537_caseD_3f;\n            }\n            if ((char)bVar1 < '?') {\n              if ((bVar1 & 0xfb) != 0x2a) goto switchD_00110537_caseD_40;\n              goto switchD_00110537_caseD_3f;\n            }\n            switch(bVar1) {\n            default:\n              goto switchD_00110537_caseD_40;\n            case 0x41:\n              *param_4 = (byte *)(pcVar40 + 3);\n            case 0x3f:\nswitchD_00110537_caseD_3f:\n              local_130 = '\\0';\n              local_138 = '\\0';\n              break;\n            case 0x42:\n              local_130 = '\\0';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\x01';\n              break;\n            case 0x43:\n              local_130 = '\\x01';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\0';\n              break;\n            case 0x44:\n              local_130 = '\\x01';\n              *param_4 = (byte *)(pcVar40 + 3);\n              local_138 = '\\x01';\n            }\n            pbVar28 = *param_4;\n            bVar1 = *pbVar28;\n            pbVar31 = pbVar27;\n            if (bVar1 == 0x2e) {\n              *param_4 = pbVar28 + 1;\nLAB_001106bd:\n              bVar41 = false;\n              local_120 = (byte *)0x0;\n              local_110 = (byte *)0x0;\n              local_140 = (byte *)0x0;\n            }\n            else {\n              if (bVar1 == 0x3f) {\n                *param_4 = pbVar28 + 1;\n                sVar33 = strlen(local_150);\n                iVar10 = strncmp((char *)pbVar27,local_150,sVar33);\n                if (iVar10 == 0) {\n                  bVar41 = true;\n                  local_120 = (byte *)0x0;\n                  local_110 = (byte *)0x0;\n                  local_140 = (byte *)0x0;\n                  goto LAB_00110703;\n                }\n                bVar41 = true;\n                local_140 = (byte *)0x0;\n                local_120 = (byte *)0x0;\n                local_110 = (byte *)0x0;\nLAB_0011072b:\n                lVar38 = FUN_0010c2d2(param_1,param_2,&local_a8);\n                if (lVar38 == 0) goto LAB_001111e9;\n                piVar21 = (int *)FUN_00112b6e(pbVar50,0);\n                if ((piVar21 == (int *)0x0) ||\n                   (((*piVar21 != 0xd && (*piVar21 != 0x13)) ||\n                    (lVar19 = **(long **)(piVar21 + 4), lVar19 == 0)))) goto LAB_00110788;\n                bVar1 = *pbVar27;\n                if (((bVar1 == 0x5f) && (pbVar27[1] == 0x5f)) &&\n                   ((bVar47 = pbVar27[2], ((&_sch_istable)[(ulong)bVar47 * 2] & 4) != 0 ||\n                    (bVar47 == 0x51 || bVar47 == 0x74)))) {\n                  bVar52 = true;\n                  bVar47 = 1;\nLAB_00110827:\n                  bVar2 = pbVar27[1];\n                  if ((bVar2 == 0x24) || (bVar2 == 0x2e)) {\n                    if (pbVar27[2] != 0x5f) goto LAB_0011085d;\n                    goto LAB_00110a69;\n                  }\n                  bVar7 = FUN_00113fb0(pbVar27,&DAT_001207c3);\n                  if (bVar2 != 0x5a) goto LAB_0011086f;\n                  if ((bVar47 | bVar7) != 0) goto LAB_00110a58;\n                  uVar45 = 0;\nLAB_00110a9d:\n                  local_a0 = pbVar31;\n                  if ((*pbVar31 == 0x5f) && (pbVar31[1] == 0x5a)) {\n                    sVar33 = strlen((char *)pbVar31);\n                    cplus_demangle_init_info(pbVar31,3,sVar33,&local_98);\n                    pvVar17 = malloc((long)local_6c << 5);\n                    local_78 = pvVar17;\n                    pvVar25 = malloc((long)local_5c << 3);\n                    local_68 = pvVar25;\n                    if ((pvVar17 == (void *)0x0) || (pvVar25 == (void *)0x0)) {\n                      free(pvVar17);\n                      free(pvVar25);\n                    }\n                    else {\n                      piVar21 = (int *)cplus_demangle_mangled_name(&local_98,1);\n                      if (*(char *)CONCAT71(uStack_7f,local_80) == '\\0') {\n                        free(local_68);\n                        pvVar17 = local_78;\n                        if (piVar21 != (int *)0x0) {\n                          if ((*piVar21 == 3) && (**(int **)(piVar21 + 6) == 0x29)) {\n                            lVar20 = FUN_0010b6ea(param_1,param_2,\n                                                  *(undefined8 *)(*(int **)(piVar21 + 6) + 6),\n                                                  &local_a9);\n                            free(pvVar17);\n                            goto LAB_001110a9;\n                          }\n                          pcVar40 = (char *)dcgettext(0,\"Demangled name is not a function\\n\",5);\n                          fprintf(_stderr,pcVar40);\n                          free(pvVar17);\n                          goto LAB_001111e9;\n                        }\n                      }\n                      else {\n                        free(local_68);\n                      }\n                      free(local_78);\n                    }\n                    FUN_0010911f(pbVar31);\n                  }\n                  else {\n                    local_80 = '\\0';\n                    local_88 = 0;\n                    local_6c = 10;\n                    local_98 = param_1;\n                    local_90 = param_2;\n                    local_78 = (void *)xmalloc(0xa0);\n                    pbVar50 = local_a0;\n                    local_70 = 0;\n                    pbVar28 = local_a0;\n                    if ((int)uVar45 == 0) {\n                      do {\n                        pbVar42 = (byte *)strchr((char *)pbVar28,0x5f);\n                        if (pbVar42 == (byte *)0x0) {\n                          FUN_0010911f(pbVar50);\n                          goto LAB_00111097;\n                        }\n                        pbVar28 = pbVar42 + 1;\n                      } while (pbVar42[1] != 0x5f);\n                      sVar33 = strspn((char *)pbVar42,\"_\");\n                      if (2 < (uint)sVar33) {\n                        pbVar42 = pbVar42 + ((uint)sVar33 - 2);\n                      }\n                    }\n                    else {\n                      pbVar42 = local_a0 + uVar45;\n                    }\n                    bVar1 = pbVar42[2];\n                    if (local_a0 == pbVar42) {\n                      if ((((&_sch_istable)[(ulong)bVar1 * 2] & 4) != 0) ||\n                         (pbVar50 = pbVar42, bVar1 == 0x51 || bVar1 == 0x74)) {\n                        local_a0 = pbVar42 + 2;\nLAB_00110d86:\n                        pbVar50 = local_a0;\n                        if (*local_a0 != 0) {\n                          pbVar28 = (byte *)0x0;\n                          cVar8 = '\\0';\n                          cVar6 = '\\0';\n                          while (pbVar42 = local_a0, bVar1 = *local_a0, bVar1 != 0) {\n                            if (bVar1 == 0x51) {\n                              cVar6 = FUN_0010d559(&local_98,&local_a0,0);\n                              if (cVar6 != '\\0') {\n                                cVar6 = FUN_00109be3(&local_98,pbVar42,(int)local_a0 - (int)pbVar42)\n                                ;\njoined_r0x00110fbc:\n                                if (cVar6 != '\\0') {\n                                  pbVar28 = (byte *)0x0;\n                                  goto LAB_0011100c;\n                                }\n                              }\n                              goto LAB_00111097;\n                            }\n                            if ('Q' < (char)bVar1) {\n                              if (bVar1 == 0x5f) {\n                                FUN_0010911f(pbVar50);\n                              }\n                              else {\n                                if (bVar1 != 0x74) {\n                                  if (bVar1 != 0x53) goto LAB_00110fd7;\n                                  goto LAB_00110ead;\n                                }\n                                if (pbVar28 == (byte *)0x0) {\n                                  pbVar28 = local_a0;\n                                }\n                                cVar6 = FUN_0010d21c(&local_98,&local_a0,0);\n                                if (cVar6 != '\\0') {\n                                  cVar6 = FUN_00109be3(&local_98,pbVar28,\n                                                       (int)local_a0 - (int)pbVar28);\n                                  goto joined_r0x00110fbc;\n                                }\n                              }\n                              goto LAB_00111097;\n                            }\n                            if (bVar1 != 0x43) {\n                              if ((char)bVar1 < 'D') {\n                                if ((byte)(bVar1 - 0x30) < 10) {\n                                  if (pbVar28 == (byte *)0x0) {\n                                    pbVar28 = local_a0;\n                                  }\n                                  uVar12 = FUN_00108e76(&local_a0);\n                                  pbVar5 = local_a0;\n                                  sVar33 = strlen((char *)local_a0);\n                                  if (uVar12 <= sVar33) {\n                                    local_a0 = pbVar5 + uVar12;\n                                    cVar6 = FUN_00109be3(&local_98,pbVar28,\n                                                         (int)local_a0 - (int)pbVar28);\n                                    goto joined_r0x00110fbc;\n                                  }\n                                  FUN_0010911f(pbVar42);\n                                  goto LAB_00111097;\n                                }\n                              }\n                              else if (bVar1 == 0x46) {\n                                local_a0 = local_a0 + 1;\n                                cVar8 = FUN_0010d882(&local_98,&local_a0,&local_88,&local_80);\n                                if (cVar8 != '\\0') {\n                                  pbVar28 = (byte *)0x0;\n                                  pbVar42 = local_a0;\n                                  goto LAB_00111004;\n                                }\n                                goto LAB_00111097;\n                              }\nLAB_00110fd7:\n                              cVar8 = FUN_0010d882(&local_98,&local_a0,&local_88,&local_80);\n                              pbVar42 = local_a0;\n                              if (cVar8 != '\\0') goto LAB_00111004;\n                              goto LAB_00111097;\n                            }\nLAB_00110ead:\n                            pbVar42 = local_a0 + 1;\n                            if (pbVar28 == (byte *)0x0) {\n                              pbVar28 = local_a0;\n                            }\nLAB_00111004:\n                            local_a0 = pbVar42;\n                            if (cVar6 != '\\0') {\nLAB_0011100c:\n                              cVar8 = FUN_0010d882(&local_98,&local_a0,&local_88,&local_80);\n                              cVar6 = cVar8;\n                              if (cVar8 == '\\0') goto LAB_00111097;\n                            }\n                          }\n                          if ((cVar8 == '\\0') &&\n                             (cVar6 = FUN_0010d882(&local_98,&local_a0,&local_88,&local_80),\n                             cVar6 == '\\0')) goto LAB_00111097;\n                        }\n                        free(local_78);\n                        local_78 = (void *)0x0;\n                        if (local_88 == 0) {\n                          pcVar40 = (char *)dcgettext(0,\"no argument types in mangled string\\n\",5);\n                          fprintf(_stderr,pcVar40);\n                        }\n                        local_a9 = local_80;\n                        lVar20 = local_88;\nLAB_001110a9:\n                        if (lVar20 != 0) {\n                          pbVar50 = (byte *)FUN_00113b98(lVar19,lVar38,lVar20,local_a9);\n                          goto LAB_001110d5;\n                        }\n                        goto LAB_001111e9;\n                      }\n                      for (; *pbVar50 == 0x5f; pbVar50 = pbVar50 + 1) {\n                      }\n                      pcVar40 = strstr((char *)pbVar50,\"__\");\n                      if ((pcVar40 != (char *)0x0) && (pcVar40[2] != '\\0')) {\n                        cVar6 = FUN_00113e5e(&local_98,&local_a0,pcVar40);\n                        goto LAB_00110d7e;\n                      }\n                      FUN_0010911f(pbVar42);\n                    }\n                    else if (bVar1 == 0) {\n                      FUN_0010911f(local_a0);\n                    }\n                    else {\n                      cVar6 = FUN_00113e5e(&local_98,&local_a0,pbVar42);\nLAB_00110d7e:\n                      if (cVar6 != '\\0') goto LAB_00110d86;\n                    }\nLAB_00111097:\n                    free(local_78);\n                  }\n                  goto LAB_001111e9;\n                }\n                cVar6 = FUN_00113fb0(pbVar27,&DAT_001207be);\n                if (cVar6 == '\\0') {\n                  if (param_3 == (char *)0x0) {\n                    bVar47 = 0;\n                    bVar52 = false;\n                  }\n                  else {\n                    iVar10 = strcmp(local_150,param_3);\n                    bVar52 = iVar10 == 0;\n                    bVar47 = 0;\n                  }\n                }\n                else {\n                  bVar47 = 1;\n                  bVar52 = true;\n                }\n                if (bVar1 == 0x5f) goto LAB_00110827;\nLAB_0011085d:\n                bVar7 = FUN_00113fb0(pbVar27,&DAT_001207c3);\nLAB_0011086f:\n                if ((bVar47 | bVar7) == 0) {\n                  pcVar40 = param_3;\n                  if (param_3 == (char *)0x0) {\n                    if (local_138 == '\\0') {\n                      pcVar16 = \"\";\n                      if (local_130 != '\\0') {\n                        pcVar16 = \"V\";\n                      }\n                      pcVar46 = \"\";\n                    }\n                    else {\n                      pcVar16 = \"\";\n                      if (local_130 != '\\0') {\n                        pcVar16 = \"V\";\n                      }\n                      pcVar46 = \"C\";\n                    }\nLAB_00110917:\n                    iVar10 = 0;\n                    sprintf((char *)&local_98,\"__%s%s\",pcVar46,pcVar16);\n                  }\n                  else {\n                    pcVar46 = \"C\";\n                    pcVar16 = \"V\";\n                    sVar33 = strlen(param_3);\n                    iVar10 = (int)sVar33;\n                    if (local_138 == '\\0') {\n                      pcVar46 = \"\";\n                    }\n                    if (local_130 == '\\0') {\n                      pcVar16 = \"\";\n                    }\n                    if (iVar10 == 0) goto LAB_00110917;\n                    pcVar29 = strchr(param_3,0x3c);\n                    if (pcVar29 == (char *)0x0) {\n                      sprintf((char *)&local_98,\"__%s%s%d\",pcVar46,pcVar16);\n                    }\n                    else {\n                      iVar10 = 0;\n                      sprintf((char *)&local_98,\"__%s%s\",pcVar46,pcVar16);\n                      pcVar40 = (char *)0x0;\n                    }\n                  }\n                  iVar14 = 0;\n                  if (!bVar52) {\n                    sVar33 = strlen(local_150);\n                    iVar14 = (int)sVar33;\n                  }\n                  sVar33 = strlen((char *)&local_98);\n                  sVar30 = strlen((char *)pbVar27);\n                  local_d0 = (int)sVar33;\n                  if (((*local_150 == 'o') && (local_150[1] == 'p')) &&\n                     ((local_150[2] == '$' || (local_150[2] == '.')))) goto LAB_001111e9;\n                  pbVar31 = (byte *)xmalloc(iVar10 + 1 + iVar14 + local_d0 + (int)sVar30);\n                  if (bVar52) {\n                    *pbVar31 = 0;\n                  }\n                  else {\n                    strcpy((char *)pbVar31,local_150);\n                  }\n                  sVar33 = strlen((char *)pbVar31);\n                  uVar45 = sVar33 & 0xffffffff;\n                  strcpy((char *)(pbVar31 + sVar33),(char *)&local_98);\n                  if (pcVar40 != (char *)0x0) {\n                    strcat((char *)pbVar31,pcVar40);\n                  }\n                  strcat((char *)pbVar31,(char *)pbVar27);\n                  if (*pbVar27 != 0) goto LAB_00110a9d;\n                }\n                else {\nLAB_00110a58:\n                  if ((bVar1 != 0) && ((bVar7 & 1) == 0)) {\n                    uVar45 = 0;\n                    goto LAB_00110a9d;\n                  }\n                }\nLAB_00110a69:\n                puVar32 = (undefined8 *)xmalloc(8);\n                *puVar32 = 0;\n                pbVar50 = (byte *)FUN_00113b98(lVar19,lVar38,puVar32,0);\nLAB_001110d5:\n                if (pbVar50 == (byte *)0x0) goto LAB_001111e9;\n                goto LAB_001110de;\n              }\n              if (bVar1 != 0x2a) {\n                FUN_00108fe8(pbVar3,\"member function type missing\");\n                goto LAB_001106bd;\n              }\n              *param_4 = pbVar28 + 1;\n              uVar12 = FUN_00109a32(param_4,0,param_6);\n              pbVar28 = *param_4;\n              if (*pbVar28 != 0x3b) goto LAB_00110788;\n              local_110 = (byte *)(ulong)(uVar12 & 0x7fffffff);\n              *param_4 = pbVar28 + 1;\n              bVar41 = pbVar28[1] == 0x3b || pbVar28[1] == 0;\n              if (bVar41) {\n                bVar41 = false;\n                local_120 = (byte *)0x0;\n                local_140 = (byte *)0x0;\n              }\n              else {\n                pbVar28 = (byte *)FUNC_0010ee3f(param_1,param_2,0,param_4);\n                bVar1 = **param_4;\n                if (bVar1 != 0x3a) {\n                  if (bVar1 == 0x3b) {\n                    *param_4 = *param_4 + 1;\n                    local_140 = (byte *)0x0;\n                    local_120 = pbVar28;\n                    goto LAB_00110703;\n                  }\n                  goto LAB_00110788;\n                }\n                local_120 = (byte *)0x0;\n                local_140 = pbVar28;\n              }\n            }\nLAB_00110703:\n            if (bVar52) goto LAB_0011072b;\nLAB_001110de:\n            uVar12 = local_f0 + 1;\n            if (local_ec <= uVar12) {\n              local_ec = local_ec + 10;\n              local_128 = (char *)xrealloc(local_128,(ulong)local_ec << 3);\n            }\n            if (bVar41) {\n              ppbVar34 = (byte **)xmalloc(0x28);\n              puVar22 = (undefined *)((long)ppbVar34 + 0x16);\n              for (lVar38 = 0x12; lVar38 != 0; lVar38 = lVar38 + -1) {\n                *puVar22 = 0;\n                puVar22 = puVar22 + (ulong)bVar48 * -2 + 1;\n              }\n              *ppbVar34 = pbVar31;\n              ppbVar34[1] = pbVar50;\n              *(undefined4 *)(ppbVar34 + 2) = local_100;\n              ppbVar34[3] = (byte *)0xffffffffffffffff;\n              *(char *)((long)ppbVar34 + 0x14) = local_138;\n              *(char *)((long)ppbVar34 + 0x15) = local_130;\n            }\n            else {\n              ppbVar34 = (byte **)xmalloc(0x28);\n              puVar22 = (undefined *)((long)ppbVar34 + 0x16);\n              for (lVar38 = 0x12; lVar38 != 0; lVar38 = lVar38 + -1) {\n                *puVar22 = 0;\n                puVar22 = puVar22 + (ulong)bVar48 * -2 + 1;\n              }\n              *ppbVar34 = pbVar31;\n              ppbVar34[1] = pbVar50;\n              *(undefined4 *)(ppbVar34 + 2) = local_100;\n              *(char *)((long)ppbVar34 + 0x14) = local_138;\n              *(char *)((long)ppbVar34 + 0x15) = local_130;\n              ppbVar34[3] = local_110;\n              ppbVar34[4] = local_120;\n            }\n            *(byte ***)(local_128 + (ulong)local_f0 * 8) = ppbVar34;\n            pbVar50 = *param_4;\n            if ((*pbVar50 == 0x3b) || (local_f0 = uVar12, *pbVar50 == 0)) goto LAB_00111678;\n            goto LAB_00110406;\n          }\n          if (pvVar24 != (void *)0x0) {\n            *(undefined8 *)((long)pvVar24 + (ulong)local_fc * 8) = 0;\n          }\n          pbVar3 = *param_4;\n          if (param_6 <= pbVar3) goto LAB_001112f3;\n          if (*pbVar3 == 0x3b) {\n            *param_4 = pbVar3 + 1;\n          }\n          pbVar27 = *param_4;\n          if (*pbVar27 == 0x7e) {\n            *param_4 = pbVar27 + 1;\n            if (((pbVar27[1] & 0xef) == 0x2d) || (pbVar27[1] == 0x2b)) {\n              *param_4 = pbVar27 + 2;\n            }\n            if (**param_4 != 0x25) goto LAB_001112ee;\n            pbVar27 = *param_4 + 1;\n            *param_4 = pbVar27;\n            cVar6 = FUN_00109ab1(param_4,&local_98,param_6);\n            if (cVar6 == '\\0') goto LAB_001112f3;\n            if ((uint)local_98 != (uint)local_a8) {\nLAB_001112a2:\n              *param_4 = pbVar27;\n              pvVar25 = (void *)FUNC_0010ee3f(param_1,param_2,0,param_4,0,param_6);\n              for (pbVar27 = *param_4; *pbVar27 != 0x3b; pbVar27 = pbVar27 + 1) {\n                if (*pbVar27 == 0) {\n                  FUN_00108fb9(pbVar3);\n                  goto LAB_001112f3;\n                }\n              }\n              *param_4 = pbVar27 + 1;\n              goto LAB_00111307;\n            }\n            if (local_98._4_4_ != local_a8._4_4_) goto LAB_001112a2;\n            pvVar25 = (void *)0x0;\n          }\n          else {\nLAB_001112ee:\n            pvVar25 = (void *)0x0;\nLAB_00111307:\n            if ((((ulong)local_118 | (ulong)pvVar24 | (ulong)pvVar25) == 0) && (!bVar51)) {\n              pvVar17 = (void *)FUN_00113da9(bVar9 == 0x73,uVar49,local_158);\n              break;\n            }\n            cVar6 = '\\0';\n          }\n          pvVar17 = (void *)FUN_00112904((bVar9 != 0x73) + '\\t',uVar49 & 0xffffffff);\n          if (pvVar17 == (void *)0x0) {\n            return (void *)0x0;\n          }\n          ppvVar35 = (void **)xmalloc(0x28);\n          lVar38 = 8;\n          ppvVar18 = ppvVar35 + 1;\n          if (cVar6 != '\\0') {\n            pvVar25 = pvVar17;\n          }\n          for (; lVar38 != 0; lVar38 = lVar38 + -1) {\n            *(undefined4 *)ppvVar18 = 0;\n            ppvVar18 = (void **)((long)ppvVar18 + (ulong)bVar48 * -8 + 4);\n          }\n          ppvVar35[3] = pvVar24;\n          ppvVar35[4] = pvVar25;\n          *ppvVar35 = local_158;\n          ppvVar35[2] = local_118;\n          *(void ***)((long)pvVar17 + 0x10) = ppvVar35;\n          goto LAB_001115eb;\n        }\n      }\nLAB_0010fe2e:\n      local_158 = (void *)0x0;\nLAB_001112f3:\n      free(local_158);\n      return (void *)0x0;\n    case 0x78:\n      bVar48 = pbVar50[1];\n      if (bVar48 == 0x73) {\nLAB_0010f0fd:\n        uVar15 = 7;\n      }\n      else if ((char)bVar48 < 't') {\n        if (bVar48 == 0) goto switchD_0010f055_caseD_24;\n        uVar15 = 0xb;\n        if (bVar48 != 0x65) goto LAB_0010f0df;\n      }\n      else {\n        uVar15 = 8;\n        if (bVar48 != 0x75) {\nLAB_0010f0df:\n          uVar15 = dcgettext(0,\"unrecognized cross reference type\",5);\n          FUN_00108fe8(pbVar3,uVar15);\n          goto LAB_0010f0fd;\n        }\n      }\n      pbVar27 = *param_4 + 1;\n      *param_4 = pbVar27;\n      pcVar16 = strchr((char *)pbVar27,0x3c);\n      pcVar40 = strchr((char *)pbVar27,0x3a);\n      if (pcVar40 == (char *)0x0) {\nswitchD_0010f055_caseD_24:\n        FUN_00108fb9(pbVar3);\n        return (void *)0x0;\n      }\n      if (((pcVar16 != (char *)0x0) && (pcVar16 < pcVar40)) && (pcVar40[1] == ':')) {\n        iVar10 = 0;\n        for (; cVar6 = *pcVar16, cVar6 != '\\0'; pcVar16 = pcVar16 + 1) {\n          if (cVar6 == '<') {\n            iVar10 = iVar10 + 1;\n          }\n          else if (cVar6 == '>') {\n            iVar10 = iVar10 + -1;\n          }\n          else if ((iVar10 == 0) && (pcVar40 = pcVar16, cVar6 == ':')) goto LAB_0010f176;\n        }\n        goto switchD_0010f055_caseD_24;\n      }\nLAB_0010f176:\n      uVar49 = (long)pcVar40 - (long)pbVar27;\n      if ((param_3 != (char *)0x0) &&\n         ((iVar10 = strncmp(param_3,(char *)pbVar27,uVar49), iVar10 == 0 &&\n          (param_3[uVar49] == '\\0')))) {\n        *(undefined *)(param_2 + 0x1a8) = 1;\n      }\n      pvVar17 = (void *)FUN_0010afd5(param_1,param_2,pbVar27,uVar49 & 0xffffffff,uVar15);\n      *param_4 = (byte *)(pcVar40 + 1);\n    }\n  }\nLAB_001115e2:\n  if (pvVar17 == (void *)0x0) {\n    return (void *)0x0;\n  }\nLAB_001115eb:\n  if ((uint)local_a8 != -1) {\n    ppvVar18 = (void **)FUN_00109022(param_2,&local_a8);\n    if (ppvVar18 == (void **)0x0) {\n      return (void *)0x0;\n    }\n    *ppvVar18 = pvVar17;\n  }\n  if (local_12c != 0xffffffff) {\n    uVar12 = *(uint *)((long)pvVar17 + 4);\n    if ((uVar12 != 0) && (local_12c != uVar12)) {\n      pcVar40 = (char *)dcgettext(0,\"Warning: changing type size from %d to %d\\n\",5);\n      fprintf(_stderr,pcVar40,(ulong)uVar12,(ulong)local_12c);\n    }\n    *(uint *)((long)pvVar17 + 4) = local_12c;\n    return pvVar17;\n  }\n  return pvVar17;\nLAB_00110788:\n  FUN_00108fb9(pbVar3);\nLAB_001111e9:\n  free(local_150);\n  free(local_128);\n  free(pbVar27);\n  goto LAB_001112f3;\nLAB_00111678:\n  *(undefined8 *)(local_128 + (ulong)uVar12 * 8) = 0;\n  if (*pbVar50 != 0) {\n    *param_4 = pbVar50 + 1;\n  }\n  if (local_e0 <= local_fc + 1) {\n    local_e0 = local_e0 + 10;\n    pvVar24 = (void *)xrealloc(pvVar24,(ulong)local_e0 << 3);\n  }\n  ppcVar23 = (char **)xmalloc(0x10);\n  *ppcVar23 = local_150;\n  ppcVar23[1] = local_128;\n  *(char ***)((long)pvVar24 + (ulong)local_fc * 8) = ppcVar23;\n  local_fc = local_fc + 1;\n  goto LAB_00110345;\n}\n\n",
            "called": [
                "FUN_00109a32",
                "cplus_demangle_init_info",
                "FUN_00113bfa",
                "FUN_001129f4",
                "FUN_00113df2",
                "FUN_00108fb9",
                "cplus_demangle_mangled_name",
                "strcmp",
                "FUN_00113d3a",
                "FUN_00109022",
                "FUN_00108fe8",
                "xmalloc",
                "strspn",
                "xrealloc",
                "strcat",
                "FUN_00113e5e",
                "FUN_00113e17",
                "strtol",
                "FUN_0010d559",
                "FUN_00113c43",
                "strlen",
                "FUN_00112b6e",
                "strcpy",
                "FUN_00113b4a",
                "strstr",
                "FUN_00109ab1",
                "concat",
                "FUN_0010afd5",
                "FUN_00113fb0",
                "dcgettext",
                "FUN_00113dfe",
                "fprintf",
                "strncmp",
                "FUN_00113ce0",
                "FUN_00109be3",
                "FUN_00113cb9",
                "FUN_0010911f",
                "sprintf",
                "malloc",
                "FUN_0010ee3f",
                "strchr",
                "FUN_0010d21c",
                "FUN_00113b71",
                "FUN_00108e76",
                "FUN_0010b6ea",
                "FUN_0010c2d2",
                "FUN_00113da9",
                "FUN_00113d6e",
                "free",
                "FUN_00112904",
                "FUN_0010d882",
                "FUN_00113b98",
                "FUN_0010914e",
                "FUN_00109a0b"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0010ee3f",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "FUNC_0010ee3f"
        },
        "strerror": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104890",
            "calling": [
                "FUN_00116b90",
                "FUN_00108200",
                "FUN_0010543c",
                "FUN_00107880",
                "FUN_00104966",
                "FUN_00114460",
                "FUN_00104ea2",
                "FUN_001199d0",
                "FUN_0010882c",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "strerror"
        },
        "bfd_decode_symclass": {
            "renaming": {},
            "code": "\nvoid bfd_decode_symclass(void)\n\n{\n  bfd_decode_symclass();\n  return;\n}\n\n",
            "called": [
                "bfd_decode_symclass"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104490",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_decode_symclass"
        },
        "FUN_00108b3e": {
            "renaming": {
                "FUN_00108b3e": "print_stabs_entries_00108b3e",
                "__format": "format_str",
                "lVar1": "stab_name",
                "lVar2": "iteration",
                "lVar3": "offset",
                "piVar4": "ptr_entry",
                "iVar5": "counter"
            },
            "code": "\n\n\nundefined8 print_stabs_entries_00108b3e(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  char *format_str;\n  long stab_name;\n  long iteration;\n  long offset;\n  int *ptr_entry;\n  int counter;\n  \n  format_str = (char *)dcgettext(0,\"Last stabs entries before error:\\n\",5);\n  fprintf(_stderr,format_str);\n  fwrite(\"n_type n_desc n_value  string\\n\",1,0x1e,_stderr);\n  counter = DAT_001278c0;\n  do {\n    iteration = (long)counter;\n    offset = iteration * 0x18;\n    ptr_entry = (int *)(&DAT_00127740 + offset);\n    if ((&DAT_00127750)[iteration * 3] != 0) {\n      stab_name = bfd_get_stab_name(*ptr_entry);\n      if (stab_name == 0) {\n        if (*ptr_entry == 0) {\n          fwrite(\"HdrSym\",1,6,_stderr);\n        }\n        else {\n          fprintf(_stderr,\"%-6d\");\n        }\n      }\n      else {\n        fprintf(_stderr,\"%-6s\",stab_name);\n      }\n      fprintf(_stderr,\" %-6d \",(ulong)*(uint *)(&DAT_00127744 + offset));\n      fprintf(_stderr,\"%08lx\",*(undefined8 *)(&DAT_00127748 + offset));\n      if (*ptr_entry != 0) {\n        fprintf(_stderr,\" %s\",(&DAT_00127750)[iteration * 3]);\n      }\n      fputc(10,_stderr);\n    }\n    counter = (counter + 1) % 0x10;\n  } while (DAT_001278c0 != counter);\n  return param_3;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "fputc",
                "bfd_get_stab_name",
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108b3e",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "print_stabs_entries_00108b3e"
        },
        "FUN_0010a083": {
            "renaming": {
                "FUN_0010a083": "initialize_data_0010a083",
                "param_1": "dataPointer"
            },
            "code": "\nvoid initializeData_0010a083(long dataPointer)\n\n{\n  FUN_00109ed3(dataPointer,0x2a,4,dataPointer + 0x178,dataPointer + 0x180);\n  return;\n}\n\n",
            "called": [
                "FUN_00109ed3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a083",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_data_0010a083"
        },
        "strstr": {
            "renaming": {},
            "code": "\n\n\nchar * strstr(char *__haystack,char *__needle)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strstr(__haystack,__needle);\n  return pcVar1;\n}\n\n",
            "called": [
                "strstr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048c0",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "strstr"
        },
        "FUN_00109c2e": {
            "renaming": {
                "FUN_00109c2e": "resize_and_initialize_array_00109c2e",
                "param_1": "arrayPointer",
                "param_2": "newValue",
                "param_3": "arrayLength",
                "param_4": "flag",
                "param_5": "outputPointer",
                "param_6": "returnValue",
                "lVar1": "newArrayPointer",
                "plVar2": "currentElement",
                "lVar3": "remainingSize",
                "puVar4": "currentByte",
                "uVar5": "currentSize",
                "bVar6": "zeroByte",
                "auVar7": "result"
            },
            "code": "\nundefined  [16]\nresizeAndInitializeArray_00109c2e(long arrayPointer,long newValue,ulong arrayLength,int flag,undefined4 *outputPointer,\n            undefined8 returnValue)\n\n{\n  long newArrayPointer;\n  long *currentElement;\n  long remainingSize;\n  undefined *currentByte;\n  ulong currentSize;\n  byte zeroByte;\n  undefined result [16];\n  \n  zeroByte = 0;\n  arrayLength = arrayLength & 0xffffffff;\n  currentSize = *(ulong *)(arrayPointer + 0x1b0);\n  if (currentSize <= arrayLength) {\n    if (currentSize == 0) {\n      currentSize = 10;\n    }\n    for (; currentSize <= arrayLength; currentSize = currentSize * 2) {\n    }\n    newArrayPointer = xrealloc(*(undefined8 *)(arrayPointer + 0x1a8),currentSize * 0x18);\n    *(long *)(arrayPointer + 0x1a8) = newArrayPointer;\n    currentByte = (undefined *)(*(long *)(arrayPointer + 0x1b0) * 0x18 + newArrayPointer);\n    for (remainingSize = (currentSize - *(long *)(arrayPointer + 0x1b0)) * 0x18; remainingSize != 0; remainingSize = remainingSize + -1) {\n      *currentByte = 0;\n      currentByte = currentByte + (ulong)zeroByte * -2 + 1;\n    }\n    *(ulong *)(arrayPointer + 0x1b0) = currentSize;\n  }\n  currentElement = (long *)(arrayLength * 0x18 + *(long *)(arrayPointer + 0x1a8));\n  if (*currentElement == 0) {\n    newArrayPointer = *(long *)(arrayPointer + 0x68);\n    *currentElement = newArrayPointer;\n    *(long *)(arrayPointer + 0x68) = newArrayPointer + 1;\n    currentElement[1] = newValue;\n    *(int *)(currentElement + 2) = flag;\n  }\n  if (flag == 0) {\n    *(undefined4 *)(currentElement + 2) = 0;\n    *(undefined4 *)((long)currentElement + 0x14) = *outputPointer;\n  }\n  else {\n    *outputPointer = *(undefined4 *)((long)currentElement + 0x14);\n  }\n  result._8_8_ = returnValue;\n  result._0_8_ = *currentElement;\n  return result;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109c2e",
            "calling": [
                "FUN_0010a69a",
                "FUN_00109d5c"
            ],
            "imported": false,
            "current_name": "resize_and_initialize_array_00109c2e"
        },
        "FUN_001053b5": {
            "renaming": {
                "FUN_001053b5": "display_bad_format_error_001053b5",
                "uVar1": "errorMessage",
                "dcgettext": "getTranslatedMessage"
            },
            "code": "\nvoid displayBadFormatError_001053b5(void)\n\n{\n  undefined8 errorMessage;\n  \n  errorMessage = dcgettext(0,\"bad format for %s\",5);\n                    \n  FUN_00119dd0(errorMessage);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00119dd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053b5",
            "calling": [
                "FUN_00114c80"
            ],
            "imported": false,
            "current_name": "display_bad_format_error_001053b5"
        },
        "FUN_00112996": {
            "renaming": {
                "FUN_00112996": "add_debug_info_to_current_namespace_00112996",
                "param_1": "namespaceInfo",
                "param_2": "param2",
                "param_3": "param3",
                "uVar1": "result",
                "lVar2": "address"
            },
            "code": "\n\n\nundefined8 addDebugInfoToCurrentNamespace_00112996(long namespaceInfo,undefined8 param2,undefined8 param3)\n\n{\n  undefined8 result;\n  long address;\n  \n  if ((*(long *)(namespaceInfo + 8) != 0) && (*(long *)(namespaceInfo + 0x10) != 0)) {\n    address = *(long *)(namespaceInfo + 0x10) + 0x10;\n    if (*(long *)(namespaceInfo + 0x20) != 0) {\n      address = *(long *)(namespaceInfo + 0x20) + 0x28;\n    }\n    result = FUN_00112925(address,param2,param3,3);\n    return result;\n  }\n  result = dcgettext(0,\"debug_add_to_current_namespace: no current file\",5);\n  fprintf(_stderr,\"%s\\n\",result);\n  return 0;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "FUN_00112925"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112996",
            "calling": [
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "add_debug_info_to_current_namespace_00112996"
        },
        "FUN_0010c7a0": {
            "renaming": {
                "FUN_0010c7a0": "debug_set_class_id_0010c7a0",
                "param_1": "class_id",
                "param_2": "class_name",
                "param_3": "type_kind",
                "uVar1": "result",
                "uVar2": "new_type_kind",
                "lVar3": "type_info",
                "piVar4": "piVar",
                "__s1": "existing_class_name",
                "cVar5": "compare_result",
                "iVar6": "incremented_value",
                "puVar7": "new_node",
                "auVar8": "return_value"
            },
            "code": "\nundefined  [16] debug_set_class_id_0010c7a0(long class_id,char *class_name,int *type_kind,undefined8 param_4)\n\n{\n  undefined8 result;\n  uint new_type_kind;\n  long type_info;\n  int *piVar;\n  char *existing_class_name;\n  char compare_result;\n  int incremented_value;\n  undefined8 *new_node;\n  undefined return_value [16];\n  \n  if (3 < *type_kind - 7U) {\n                    \n    __assert_fail(\"type->kind == DEBUG_KIND_STRUCT || type->kind == DEBUG_KIND_UNION || type->kind == DEBUG_KIND_CLASS || type->kind == DEBUG_KIND_UNION_CLASS\"\n                  ,\"../../binutils/debug.c\",0xb87,\"debug_set_class_id_0010c7a0\");\n  }\n  type_info = *(long *)(type_kind + 4);\n  new_node = (undefined8 *)(ulong)*(uint *)(type_info + 0xc);\n  if (*(uint *)(type_info + 0xc) <= *(uint *)(class_id + 0x38)) {\n    for (new_node = *(undefined8 **)(class_id + 0x50); new_node != (undefined8 *)0x0;\n        new_node = (undefined8 *)*new_node) {\n      piVar = (int *)new_node[1];\n      if (*piVar == *type_kind) {\n        existing_class_name = (char *)new_node[2];\n        if (class_name == (char *)0x0) {\n          if (existing_class_name == (char *)0x0) {\nLAB_0010c82c:\n            compare_result = FUN_0010922b(class_id,piVar,type_kind);\n            if (compare_result != '\\0') {\n              new_type_kind = *(uint *)(*(long *)(new_node[1] + 0x10) + 0xc);\n              new_node = (undefined8 *)(ulong)new_type_kind;\n              *(uint *)(type_info + 0xc) = new_type_kind;\n              goto LAB_0010c884;\n            }\n          }\n        }\n        else if (((existing_class_name != (char *)0x0) && (*existing_class_name == *class_name)) &&\n                (incremented_value = strcmp(existing_class_name,class_name), incremented_value == 0)) goto LAB_0010c82c;\n      }\n    }\n    incremented_value = *(int *)(class_id + 0x34) + 1;\n    *(int *)(class_id + 0x34) = incremented_value;\n    *(int *)(type_info + 0xc) = incremented_value;\n    new_node = (undefined8 *)xmalloc(0x18);\n    result = *(undefined8 *)(class_id + 0x50);\n    new_node[2] = class_name;\n    *(undefined8 **)(class_id + 0x50) = new_node;\n    *new_node = result;\n    new_node[1] = type_kind;\n  }\nLAB_0010c884:\n  return_value._1_7_ = (undefined7)((ulong)new_node >> 8);\n  return_value[0] = 1;\n  return_value._8_8_ = param_4;\n  return return_value;\n}\n\n",
            "called": [
                "xmalloc",
                "strcmp",
                "FUN_0010922b",
                "__assert_fail"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c7a0",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "debug_set_class_id_0010c7a0"
        },
        "htab_create_alloc": {
            "renaming": {},
            "code": "\nvoid htab_create_alloc(void)\n\n{\n  htab_create_alloc();\n  return;\n}\n\n",
            "called": [
                "htab_create_alloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104720",
            "calling": [
                "FUN_00116b90",
                "FUN_00113f20"
            ],
            "imported": false,
            "current_name": "htab_create_alloc"
        },
        "FUN_0010922b": {
            "renaming": {
                "FUN_0010922b": "compare_parameters_0010922b",
                "param_1": "functionContext",
                "param_2": "param1",
                "param_3": "param2",
                "uVar1": "typeParam1",
                "uVar2": "typeParam2",
                "pplVar3": "ptrToPtr",
                "ppcVar4": "ptrToChar1",
                "ppcVar5": "ptrToChar2",
                "lVar6": "intVar1",
                "lVar7": "intVar2",
                "lVar8": "intVar3",
                "pcVar9": "charPtr1",
                "pcVar10": "charPtr2",
                "cVar11": "result",
                "bVar12": "isMatch",
                "iVar13": "comparisonResult",
                "uVar14": "uintVar1",
                "uVar15": "uintVar2",
                "puVar16": "ptrToUInt1",
                "puVar17": "ptrToUInt2",
                "plVar18": "param2Copy",
                "lVar19": "offset",
                "plVar20": "ptrParam1",
                "plVar21": "ptrParam2",
                "lVar22": "offsetCopy",
                "local_70": "ptrToLong1",
                "local_58": "ptrToPtrToUInt",
                "plStack_50": "stackParam",
                "local_48": "ptrParam"
            },
            "code": "\nbyte compareParameters_0010922b(long functionContext,long *param1,long *param2)\n\n{\n  uint typeParam1;\n  uint typeParam2;\n  long **ptrToPtr;\n  char **ptrToChar1;\n  char **ptrToChar2;\n  long intVar1;\n  long intVar2;\n  long intVar3;\n  char *charPtr1;\n  char *charPtr2;\n  char result;\n  byte isMatch;\n  int comparisonResult;\n  undefined8 uintVar1;\n  undefined8 uintVar2;\n  undefined8 *ptrToUInt1;\n  undefined8 *ptrToUInt2;\n  long *param2Copy;\n  long offset;\n  long *ptrParam1;\n  long *ptrParam2;\n  long offsetCopy;\n  long *ptrToLong1;\n  undefined8 *ptrToPtrToUInt;\n  long *stackParam;\n  long *ptrParam;\n  \n  param2Copy = param2;\n  if (param1 == (long *)0x0) {\nLAB_00109241:\n    return param2 == (long *)0x0;\n  }\njoined_r0x00109255:\n  if (param2Copy == (long *)0x0) {\n    return false;\n  }\n  while( true ) {\n    typeParam1 = *(uint *)param1;\n    if (typeParam1 == 1) goto code_r0x00109263;\n    while (typeParam2 = *(uint *)param2, typeParam2 == 1) {\n      param2 = **(long ***)param2[2];\n      if (param2 == (long *)0x0) {\n        return false;\n      }\n    }\n    if (param1 == param2) {\n      return true;\n    }\n    if (typeParam1 != 0x16) break;\n    if (typeParam2 != 0x17) goto LAB_001092cb;\n    param1 = *(long **)(param1[2] + 8);\n    if (param1 == (long *)0x0) goto LAB_00109241;\n  }\n  if ((typeParam1 == 0x17) && (typeParam2 == 0x16)) {\n    param2 = *(long **)(param2[2] + 8);\n    param2Copy = param2;\n    goto joined_r0x00109255;\n  }\nLAB_001092cb:\n  if (*param1 != *param2) {\n    return false;\n  }\n  if (typeParam1 == 3) {\n    return *(char *)(param1 + 2) == *(char *)(param2 + 2);\n  }\n  if (typeParam1 < 4) {\n    if (typeParam1 == 2) {\n      return true;\n    }\n  }\n  else if (typeParam1 - 4 < 3) {\n    return true;\n  }\n  ptrToPtrToUInt = *(undefined8 **)(functionContext + 0x58);\n  for (ptrToUInt2 = ptrToPtrToUInt; ptrToUInt2 != (undefined8 *)0x0; ptrToUInt2 = (undefined8 *)*ptrToUInt2) {\n    if (((long *)ptrToUInt2[1] == param1) && ((long *)ptrToUInt2[2] == param2)) {\n      return true;\n    }\n  }\n  *(undefined8 ***)(functionContext + 0x58) = &ptrToPtrToUInt;\n  stackParam = param1;\n  ptrParam = param2;\n  switch(typeParam1) {\n  case 7:\n  case 8:\n  case 9:\n  case 10:\n    param2Copy = (long *)param1[2];\n    ptrToPtr = (long **)param2[2];\n    if (param2Copy == (long *)0x0) {\n      isMatch = ptrToPtr == (long **)0x0;\n      goto LAB_001099c4;\n    }\n    if (ptrToPtr == (long **)0x0) goto LAB_00109382;\n    if ((*(uint *)(functionContext + 0x38) < *(uint *)((long)param2Copy + 0xc)) &&\n       (*(uint *)((long)param2Copy + 0xc) == *(uint *)((long)ptrToPtr + 0xc))) goto LAB_001097af;\n    ptrToUInt2 = (undefined8 *)*param2Copy;\n    ptrToLong1 = *ptrToPtr;\n    if (((ptrToUInt2 == (undefined8 *)0x0) == (ptrToLong1 == (long *)0x0)) &&\n       ((((param2Copy[2] == 0) == (ptrToPtr[2] == (long *)0x0) &&\n         ((param2Copy[3] == 0) == (ptrToPtr[3] == (long *)0x0))) &&\n        ((param2Copy[4] == 0) == (ptrToPtr[4] == (long *)0x0))))) {\n      if (ptrToUInt2 == (undefined8 *)0x0) {\nLAB_001093fd:\n        if ((param2Copy[4] != 0) &&\n           (result = compareParameters_0010922b(functionContext,param2Copy[4],ptrToPtr[4]), result == '\\0'))\n        goto LAB_00109382;\n        ptrParam2 = (long *)param2Copy[2];\n        if (ptrParam2 == (long *)0x0) {\nLAB_00109540:\n          ptrToUInt2 = (undefined8 *)param2Copy[3];\n          if (ptrToUInt2 == (undefined8 *)0x0) goto LAB_001097af;\n          param2Copy = ptrToPtr[3];\n          while( true ) {\n            ptrToChar2 = (char **)*ptrToUInt2;\n            if (ptrToChar2 == (char **)0x0) {\n              isMatch = *param2Copy == 0;\n              goto LAB_001099c4;\n            }\n            ptrToChar1 = (char **)*param2Copy;\n            if (ptrToChar1 == (char **)0x0) break;\n            if ((**ptrToChar2 != **ptrToChar1) || (comparisonResult = strcmp(*ptrToChar2,*ptrToChar1), comparisonResult != 0))\n            break;\n            charPtr1 = ptrToChar2[1];\n            charPtr2 = ptrToChar1[1];\n            if ((charPtr1 == (char *)0x0) != (charPtr2 == (char *)0x0)) break;\n            if (charPtr1 != (char *)0x0) {\n              offsetCopy = 0;\n              while( true ) {\n                ptrToChar2 = *(char ***)(charPtr1 + offsetCopy);\n                ptrToChar1 = *(char ***)(charPtr2 + offsetCopy);\n                if (ptrToChar2 == (char **)0x0) break;\n                if (ptrToChar1 == (char **)0x0) goto LAB_00109382;\n                if ((((**ptrToChar2 != **ptrToChar1) ||\n                     ((((ulong)ptrToChar2[2] ^ (ulong)ptrToChar1[2]) & 0xffffffffffff) != 0)) ||\n                    ((ptrToChar2[3] != ptrToChar1[3] ||\n                     ((((ptrToChar2[4] == (char *)0x0) != (ptrToChar1[4] == (char *)0x0) ||\n                       (comparisonResult = strcmp(*ptrToChar2,*ptrToChar1), comparisonResult != 0)) ||\n                      (result = compareParameters_0010922b(functionContext,ptrToChar2[1],ptrToChar1[1]), result == '\\0')))))) ||\n                   ((ptrToChar2[4] != (char *)0x0 &&\n                    (result = compareParameters_0010922b(functionContext,ptrToChar2[4],ptrToChar1[4]), result == '\\0'))))\n                goto LAB_00109382;\n                offsetCopy = offsetCopy + 8;\n              }\n              if (ptrToChar1 == (char **)0x0) goto LAB_001095f1;\n              break;\n            }\nLAB_001095f1:\n            ptrToUInt2 = ptrToUInt2 + 1;\n            param2Copy = param2Copy + 1;\n          }\n        }\n        else {\n          ptrParam1 = ptrToPtr[2];\n          for (; ptrToUInt2 = (undefined8 *)*ptrParam2, ptrToUInt2 != (undefined8 *)0x0;\n              ptrParam2 = ptrParam2 + 1) {\n            ptrToUInt1 = (undefined8 *)*ptrParam1;\n            if ((((ptrToUInt1 == (undefined8 *)0x0) ||\n                 (((ptrToUInt2[1] ^ ptrToUInt1[1]) & 0xffffffffff) != 0)) ||\n                (*(int *)(ptrToUInt2 + 2) != *(int *)(ptrToUInt1 + 2))) ||\n               (result = compareParameters_0010922b(functionContext,*ptrToUInt2,*ptrToUInt1), result == '\\0'))\n            goto LAB_00109382;\n            ptrParam1 = ptrParam1 + 1;\n          }\n          if (*ptrParam1 == 0) goto LAB_00109540;\n        }\n      }\n      else {\n        for (; ptrToChar2 = (char **)*ptrToUInt2, ptrToChar2 != (char **)0x0; ptrToUInt2 = ptrToUInt2 + 1) {\n          ptrToChar1 = (char **)*ptrToLong1;\n          if (ptrToChar1 == (char **)0x0) goto LAB_00109382;\n          charPtr1 = *ptrToChar1;\n          charPtr2 = *ptrToChar2;\n          if ((*charPtr2 != *charPtr1) ||\n             ((((ulong)ptrToChar2[2] ^ (ulong)ptrToChar1[2]) & 0xffffffffff) != 0)) goto LAB_00109382;\n          if (*(char *)((long)ptrToChar2 + 0x14) == '\\0') {\n            if (ptrToChar2[3] == ptrToChar1[3]) goto LAB_00109480;\n            goto LAB_00109382;\n          }\n          comparisonResult = strcmp(ptrToChar2[3],ptrToChar1[3]);\n          if (comparisonResult != 0) goto LAB_00109382;\nLAB_00109480:\n          comparisonResult = strcmp(charPtr2,charPtr1);\n          if (((comparisonResult != 0) || (ptrToChar2[1] == (char *)0x0)) || (ptrToChar1[1] == (char *)0x0))\n          goto LAB_00109382;\n          uintVar1 = FUN_00112b6e(ptrToChar1[1],0);\n          uintVar2 = FUN_00112b6e(ptrToChar2[1],0);\n          result = compareParameters_0010922b(functionContext,uintVar2,uintVar1);\n          if (result == '\\0') goto LAB_00109382;\n          ptrToLong1 = ptrToLong1 + 1;\n        }\n        if (*ptrToLong1 == 0) goto LAB_001093fd;\n      }\n    }\n    goto LAB_00109382;\n  case 0xb:\n    param2Copy = (long *)param1[2];\n    ptrParam2 = (long *)param2[2];\n    if (param2Copy == (long *)0x0) {\n      isMatch = ptrParam2 == (long *)0x0;\n      goto LAB_001099c4;\n    }\n    if (ptrParam2 == (long *)0x0) goto LAB_00109382;\n    offsetCopy = *param2Copy;\n    intVar1 = *ptrParam2;\n    offset = 0;\n    intVar2 = param2Copy[1];\n    intVar3 = ptrParam2[1];\n    do {\n      charPtr1 = *(char **)(offsetCopy + offset);\n      if (charPtr1 == (char *)0x0) {\n        isMatch = *(long *)(intVar1 + offset) == 0;\n        goto LAB_001099c1;\n      }\n      charPtr2 = *(char **)(intVar1 + offset);\n      if (((charPtr2 == (char *)0x0) || (*charPtr1 != *charPtr2)) ||\n         (*(long *)(intVar2 + offset) != *(long *)(intVar3 + offset))) break;\n      comparisonResult = strcmp(charPtr1,charPtr2);\n      offset = offset + 8;\n    } while (comparisonResult == 0);\nLAB_00109964:\n    isMatch = 0;\n    break;\n  case 0xc:\n  case 0xe:\n  case 0x14:\n  case 0x15:\n    isMatch = compareParameters_0010922b(functionContext,param1[2],param2[2]);\n    goto LAB_001099c4;\n  case 0xd:\n    if ((*(char *)((undefined8 *)param1[2] + 2) == *(char *)((undefined8 *)param2[2] + 2)) &&\n       (result = compareParameters_0010922b(functionContext,*(undefined8 *)param1[2],*(undefined8 *)param2[2]),\n       result != '\\0')) {\n      param2Copy = *(long **)(param1[2] + 8);\n      ptrParam2 = *(long **)(param2[2] + 8);\n      if ((param2Copy == (long *)0x0) == (ptrParam2 == (long *)0x0)) {\n        if (param2Copy == (long *)0x0) goto LAB_001097af;\n        while (((*param2Copy != 0 && (*ptrParam2 != 0)) &&\n               (result = compareParameters_0010922b(functionContext), result != '\\0'))) {\n          param2Copy = param2Copy + 1;\n          ptrParam2 = ptrParam2 + 1;\n        }\nLAB_0010995d:\n        if (*param2Copy != 0) goto LAB_00109964;\n        isMatch = *ptrParam2 == 0;\n        break;\n      }\n    }\n    goto LAB_00109382;\n  case 0xf:\n    ptrToUInt2 = (undefined8 *)param2[2];\n    ptrToUInt1 = (undefined8 *)param1[2];\n    isMatch = 0;\n    if ((ptrToUInt1[1] == ptrToUInt2[1]) && (ptrToUInt1[2] == ptrToUInt2[2])) {\nLAB_00109862:\n      isMatch = compareParameters_0010922b(functionContext,*ptrToUInt1,*ptrToUInt2);\n    }\n    break;\n  case 0x10:\n    ptrToUInt2 = (undefined8 *)param2[2];\n    ptrToUInt1 = (undefined8 *)param1[2];\n    isMatch = 0;\n    if (((ptrToUInt1[2] == ptrToUInt2[2]) && (ptrToUInt1[3] == ptrToUInt2[3])) &&\n       (*(char *)(ptrToUInt1 + 4) == *(char *)(ptrToUInt2 + 4))) goto LAB_00109862;\n    break;\n  case 0x11:\n    ptrToUInt2 = (undefined8 *)param2[2];\n    ptrToUInt1 = (undefined8 *)param1[2];\n    isMatch = 0;\n    if (*(char *)(ptrToUInt1 + 1) == *(char *)(ptrToUInt2 + 1)) goto LAB_00109862;\n    break;\n  case 0x12:\n    result = compareParameters_0010922b(functionContext,*(undefined8 *)param1[2],*(undefined8 *)param2[2]);\n    isMatch = 0;\n    if (result != '\\0') {\n      isMatch = compareParameters_0010922b(functionContext,*(undefined8 *)(param1[2] + 8),*(undefined8 *)(param2[2] + 8))\n      ;\n    }\n    break;\n  case 0x13:\n    if (((*(char *)((undefined8 *)param1[2] + 3) == *(char *)((undefined8 *)param2[2] + 3)) &&\n        (result = compareParameters_0010922b(functionContext,*(undefined8 *)param1[2],*(undefined8 *)param2[2]),\n        result != '\\0')) &&\n       (result = compareParameters_0010922b(functionContext,*(undefined8 *)(param1[2] + 8),\n                              *(undefined8 *)(param2[2] + 8)), result != '\\0')) {\n      param2Copy = *(long **)(param1[2] + 0x10);\n      ptrParam2 = *(long **)(param2[2] + 0x10);\n      if ((param2Copy == (long *)0x0) == (ptrParam2 == (long *)0x0)) {\n        if (param2Copy != (long *)0x0) {\n          while (((*param2Copy != 0 && (*ptrParam2 != 0)) &&\n                 (result = compareParameters_0010922b(functionContext), result != '\\0'))) {\n            param2Copy = param2Copy + 1;\n            ptrParam2 = ptrParam2 + 1;\n          }\n          goto LAB_0010995d;\n        }\nLAB_001097af:\n        isMatch = 1;\n        goto LAB_001099c4;\n      }\n    }\nLAB_00109382:\n    isMatch = 0;\n    goto LAB_001099c4;\n  case 0x16:\n  case 0x17:\n    param2Copy = (long *)param2[2];\n    ptrParam2 = (long *)param1[2];\n    comparisonResult = strcmp(*(char **)(*ptrParam2 + 8),*(char **)(*param2Copy + 8));\n    isMatch = 0;\n    if (comparisonResult == 0) {\n      isMatch = compareParameters_0010922b(functionContext,ptrParam2[1],param2Copy[1]);\n    }\n    break;\n  default:\n                    \n    abort();\n  }\nLAB_001099c1:\n  isMatch = isMatch & 1;\nLAB_001099c4:\n  *(undefined8 **)(functionContext + 0x58) = ptrToPtrToUInt;\n  return isMatch;\ncode_r0x00109263:\n  param1 = **(long ***)param1[2];\n  param2Copy = param1;\n  goto joined_r0x00109255;\n}\n\n",
            "called": [
                "strcmp",
                "abort",
                "FUN_0010922b",
                "FUN_00112b6e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010922b",
            "calling": [
                "FUN_0010c7a0",
                "FUN_0010922b"
            ],
            "imported": false,
            "current_name": "compare_parameters_0010922b"
        },
        "mkstemp": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104640",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "mkstemp"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044c0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "FUN_001052a2": {
            "renaming": {
                "FUN_001052a2": "extract_and_copy_archive_001052a2",
                "cVar1": "formatCheck",
                "iVar2": "formatCode",
                "iVar3": "statResult",
                "lVar5": "readResult",
                "__format": "errorMsgFormat",
                "puVar7": "ptrStruct",
                "piVar8": "ptrErrno",
                "uVar9": "errorMsg",
                "in_RAX": "ptrSrcPath",
                "pcVar10": "curChar",
                "ppcVar11": "archivedFiles",
                "lVar12": "fileSize",
                "pvVar13": "fileData",
                "pcVar14": "bfdCloseFunc",
                "lVar15": "bytesRemaining",
                "pcVar16": "nextChar",
                "psVar17": "statStruct",
                "unaff_R14": "copyData",
                "unaff_R15": "currFile",
                "bVar18": "zeroByte",
                "unaff_retaddr": "retAddr",
                "in_stack_00000008": "destPath",
                "in_stack_00000010": "ptrHandle",
                "in_stack_00000018": "tempDir",
                "in_stack_00000020": "srcPath",
                "in_stack_00000028": "accessMode",
                "in_stack_00000030": "useDefaultAccess",
                "in_stack_000000f8": "accessPermissions",
                "in_stack_00000110": "totalSize"
            },
            "code": "\nvoid extractAndCopyArchive_001052a2(undefined8 param_1,undefined8 param_2,char *param_3)\n\n{\n  char formatCheck;\n  int formatCode;\n  int statResult;\n  char **ppcVar4;\n  long readResult;\n  undefined8 uVar6;\n  char *errorMsgFormat;\n  undefined8 *ptrStruct;\n  int *ptrErrno;\n  undefined8 errorMsg;\n  long ptrSrcPath;\n  char *curChar;\n  char **archivedFiles;\n  long fileSize;\n  void *fileData;\n  code *bfdCloseFunc;\n  long bytesRemaining;\n  char *nextChar;\n  stat *statStruct;\n  undefined8 *copyData;\n  char **currFile;\n  byte zeroByte;\n  undefined8 retAddr;\n  undefined8 *destPath;\n  long *ptrHandle;\n  char *tempDir;\n  undefined8 *srcPath;\n  undefined8 accessMode;\n  undefined8 useDefaultAccess;\n  uint accessPermissions;\n  long totalSize;\n  \n  zeroByte = 0;\n  curChar = (char *)(ptrSrcPath + 1);\n  do {\n    if (*curChar == '/') {\n      extractAndCopyArchive_001052a2();\n      return;\n    }\n    while (*curChar == '\\0') {\n      curChar = (char *)concat(tempDir,&DAT_0011b47d);\n      statResult = stat(curChar,(stat *)&stack0x00000050);\n      ptrStruct = copyData;\n      if (-1 < statResult) {\n        fileSize = FUN_0011a0e0(curChar);\n        free(curChar);\n        if (fileSize == 0) {\n          ptrErrno = __errno_location();\n          curChar = strerror(*ptrErrno);\n          errorMsg = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n          FUN_00119ed0(errorMsg,curChar);\n          goto LAB_00104e93;\n        }\n        ptrStruct = (undefined8 *)xmalloc(0x18);\n        curChar = *currFile;\n        *ptrStruct = copyData;\n        ptrStruct[2] = 0;\n        ptrStruct[1] = fileSize;\n        curChar = (char *)concat(fileSize,&DAT_0011b47d,curChar);\n      }\n      statResult = 0;\n      if (DAT_001279eb != '\\0') {\n        statStruct = (stat *)&stack0x00000050;\n        for (fileSize = 0x24; fileSize != 0; fileSize = fileSize + -1) {\n          *(undefined4 *)&statStruct->st_dev = 0;\n          statStruct = (stat *)((long)statStruct + (ulong)zeroByte * -8 + 4);\n        }\n        archivedFiles = (char **)currFile[0x1d];\n        if ((char **)currFile[0x1d] == (char **)0x0) {\n          archivedFiles = currFile;\n        }\n        statResult = (**(code **)(archivedFiles[1] + 0x1e8))(currFile,(stat *)&stack0x00000050);\n        if (statResult != 0) {\n          nextChar = *currFile;\n          errorMsg = dcgettext(0,\"internal stat error on %s\",5);\n          FUN_00119ed0(errorMsg,nextChar);\n        }\n      }\n      copyData = (undefined8 *)xmalloc(0x18);\n      copyData[1] = curChar;\n      *copyData = ptrStruct;\n      copyData[2] = 0;\n      formatCheck = bfd_check_format(currFile,1);\n      if (formatCheck == '\\0') {\n        errorMsg = dcgettext(0,\"Unable to recognise the format of file\",5);\n        FUN_001126c0(0,currFile,0,errorMsg);\n        archivedFiles = (char **)bfd_openw(curChar,accessMode);\n        if (archivedFiles == (char **)0x0) goto LAB_00104e80;\nLAB_00104d75:\n        ppcVar4 = (char **)currFile[0x1d];\n        if ((char **)currFile[0x1d] == (char **)0x0) {\n          ppcVar4 = currFile;\n        }\n        formatCode = (**(code **)(ppcVar4[1] + 0x1e8))(currFile,&stack0x000000e0);\n        fileSize = totalSize;\n        if (formatCode == 0) {\n          if (totalSize < 0) {\n            errorMsg = FUN_001125fa(currFile);\n            uVar6 = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n            FUN_00119ed0(uVar6,errorMsg);\n          }\n          else {\n            formatCode = bfd_seek(currFile,0,0);\n            if (formatCode == 0) {\n              if (DAT_001279e9 != '\\0') {\n                nextChar = *archivedFiles;\n                errorMsg = FUN_001125fa(currFile);\n                errorMsgFormat = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n                printf(errorMsgFormat,errorMsg,nextChar);\n              }\n              fileData = (void *)xmalloc(0x2000);\n              for (; fileSize != 0; fileSize = fileSize - bytesRemaining) {\n                bytesRemaining = 0x2000;\n                if (fileSize < 0x2001) {\n                  bytesRemaining = fileSize;\n                }\n                readResult = bfd_bread(fileData,bytesRemaining,currFile);\n                ppcVar4 = currFile;\n                if ((bytesRemaining != readResult) ||\n                   (readResult = bfd_bwrite(fileData,bytesRemaining,archivedFiles), ppcVar4 = archivedFiles, bytesRemaining != readResult\n                   )) {\n                  FUN_001126c0(0,ppcVar4,0,0);\n                  free(fileData);\n                  goto LAB_00104f00;\n                }\n              }\n              chmod(*archivedFiles,accessPermissions | 0x100);\n              free(fileData);\n              formatCheck = bfd_close_all_done(archivedFiles);\n              if (formatCheck == '\\0') {\n                FUN_001126c0(curChar,0,0,0);\n                DAT_00127a40 = 1;\n              }\n              goto LAB_00114a86;\n            }\n            errorMsg = FUN_001125fa(currFile);\n            FUN_0011a110(errorMsg);\n          }\n        }\n        else {\n          FUN_001126c0(0,currFile,0,0);\n        }\nLAB_00104f00:\n        formatCheck = bfd_close_all_done(archivedFiles);\n        if (formatCheck == '\\0') {\n          FUN_001126c0(curChar,0,0,0);\n        }\nLAB_00104ec9:\n        unlink(curChar);\n        DAT_00127a40 = 1;\n      }\n      else {\n        if (useDefaultAccess._7_1_ == '\\0') {\n          archivedFiles = (char **)bfd_openw(curChar,*(undefined8 *)currFile[1]);\n        }\n        else {\n          archivedFiles = (char **)bfd_openw(curChar,accessMode);\n        }\n        if (archivedFiles == (char **)0x0) {\nLAB_00104e80:\n          FUN_001126c0(curChar,0,0,0);\n          goto LAB_00104e93;\n        }\n        formatCheck = FUNC_00114e50(currFile,archivedFiles,retAddr);\n        if (formatCheck == '\\0') {\n          formatCode = bfd_get_arch(currFile);\n          if (formatCode == 0) goto LAB_00104d75;\n          formatCheck = bfd_close_all_done(archivedFiles);\n          if (formatCheck == '\\0') {\n            FUN_001126c0(curChar,0,0,0);\n          }\n          goto LAB_00104ec9;\n        }\n        formatCheck = bfd_close(archivedFiles);\n        if (formatCheck == '\\0') {\n          FUN_001126c0(curChar,0,0,0);\n          DAT_00127a40 = 1;\n        }\nLAB_00114a86:\n        if ((DAT_001279eb != '\\0') && (statResult == 0)) {\n          FUN_0011a350(curChar,(stat *)&stack0x00000050);\n        }\n        fileSize = bfd_openr(curChar,accessMode);\n        copyData[2] = fileSize;\n        *ptrHandle = fileSize;\n        ptrHandle = (long *)(fileSize + 0xf0);\n        archivedFiles = (char **)bfd_openr_next_archived_file(srcPath,currFile);\n        bfd_close(currFile);\n        currFile = archivedFiles;\n      }\n      if ((DAT_00127a40 != 0) || (currFile == (char **)0x0)) {\n        *ptrHandle = 0;\n        fileData = (void *)xstrdup(*destPath);\n        if (DAT_00127a40 == 0) {\n          bfdCloseFunc = bfd_close;\n        }\n        else {\n          bfdCloseFunc = bfd_close_all_done;\n        }\n        formatCheck = (*bfdCloseFunc)(destPath);\n        if (formatCheck == '\\0') {\n          DAT_00127a40 = 1;\n          FUN_001126c0(fileData,0,0,0);\n        }\n        free(fileData);\n        fileData = (void *)xstrdup(*srcPath);\n        formatCheck = bfd_close(srcPath);\n        if (formatCheck == '\\0') {\n          DAT_00127a40 = 1;\n          FUN_001126c0(fileData,0,0,0);\n        }\n        free(fileData);\n        goto LAB_00114b4b;\n      }\n      curChar = *currFile;\n      param_3 = curChar;\n      if (*curChar == '/') goto LAB_0010527d;\n    }\n    nextChar = curChar;\n    if ((*curChar == '.') && (nextChar = curChar + 1, curChar[1] == '.')) {\n      nextChar = curChar + 2;\n      if ((curChar[2] == '\\0') || (curChar[2] == '/')) {\nLAB_0010527d:\n        errorMsg = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n        FUN_00119ed0(errorMsg,param_3);\nLAB_00104e93:\n        DAT_00127a40 = 1;\nLAB_00114b4b:\n        while (copyData != (undefined8 *)0x0) {\n          if (copyData[2] == 0) {\n            rmdir((char *)copyData[1]);\n          }\n          else {\n            bfd_close();\n            unlink((char *)copyData[1]);\n          }\n          free((void *)copyData[1]);\n          ptrStruct = (undefined8 *)*copyData;\n          free(copyData);\n          copyData = ptrStruct;\n        }\n        rmdir(tempDir);\n        free(tempDir);\n        return;\n      }\n    }\n    for (; (curChar = nextChar, *nextChar != '\\0' && (*nextChar != '/')); nextChar = nextChar + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a2",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "extract_and_copy_archive_001052a2"
        },
        "FUN_0010e453": {
            "renaming": {
                "FUN_0010e453": "reverse_and_send_data_0010e453",
                "param_1": "dataSize",
                "param_2": "inputData",
                "param_3": "dataList",
                "lVar1": "length",
                "cVar2": "result",
                "sVar3": "strLength",
                "__s": "formattedStr",
                "uVar4": "returnValue",
                "lVar5": "requiredSize",
                "ppcVar6": "dataPtr",
                "lVar7": "offset"
            },
            "code": "\nundefined8 reverseAndSendData_0010e453(long dataSize,char *inputData,char **dataList)\n\n{\n  long length;\n  char result;\n  size_t strLength;\n  undefined2 *formattedStr;\n  undefined8 returnValue;\n  long requiredSize;\n  char **dataPtr;\n  long offset;\n  \n  if (dataList == (char **)0x0) {\n    if (inputData != (char *)0x0) {\n      strLength = strlen(inputData);\n      formattedStr = (undefined2 *)xmalloc(strLength + 10);\n      sprintf((char *)formattedStr,\"xe%s:\",inputData);\nLAB_0010e578:\n      result = FUN_00109b52(dataSize,formattedStr,0,0,4);\n      if (result != '\\0') goto LAB_0010e58b;\n    }\nLAB_0010e475:\n    returnValue = 0;\n  }\n  else {\n    requiredSize = 10;\n    dataPtr = dataList;\n    if (inputData != (char *)0x0) {\n      strLength = strlen(inputData);\n      requiredSize = strLength + 10;\n    }\n    for (; *dataPtr != (char *)0x0; dataPtr = dataPtr + 1) {\n      strLength = strlen(*dataPtr);\n      requiredSize = requiredSize + 0x14 + strLength;\n    }\n    formattedStr = (undefined2 *)xmalloc(requiredSize);\n    if (inputData == (char *)0x0) {\n      *formattedStr = 0x65;\n      requiredSize = 0;\n    }\n    else {\n      requiredSize = *(long *)(dataSize + 0x68);\n      *(long *)(dataSize + 0x68) = requiredSize + 1;\n      sprintf((char *)formattedStr,\"%s:T%ld=e\",inputData,requiredSize);\n    }\n    offset = 0;\n    while( true ) {\n      length = *(long *)((long)dataList + offset);\n      strLength = strlen((char *)formattedStr);\n      if (length == 0) break;\n      offset = offset + 8;\n      sprintf((char *)(undefined2 *)((long)formattedStr + strLength),\"%s:%ld,\");\n    }\n    *(undefined2 *)((long)formattedStr + strLength) = 0x3b;\n    if (inputData == (char *)0x0) goto LAB_0010e578;\n    result = FUN_0010e2f0(dataSize,0x80,0,0,formattedStr);\n    if ((result == '\\0') || (result = FUN_00109cf4(dataSize,requiredSize,4), result == '\\0'))\n    goto LAB_0010e475;\nLAB_0010e58b:\n    free(formattedStr);\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00109b52",
                "free",
                "FUN_0010e2f0",
                "sprintf",
                "FUN_00109cf4",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e453",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "reverse_and_send_data_0010e453"
        },
        "FUN_00109d5c": {
            "renaming": {
                "FUN_00109d5c": "check_and_call_function_00109d5c",
                "param_1": "input_value",
                "lVar1": "result",
                "uVar2": "output_value"
            },
            "code": "\nundefined8 check_and_call_function_00109d5c(undefined8 input_value)\n\n{\n  long result;\n  undefined8 output_value;\n  \n  result = FUN_00109c2e();\n  if (-1 < result) {\n    output_value = FUN_00109cf4(input_value,result,0);\n    return output_value;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00109c2e",
                "FUN_00109cf4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d5c",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "check_and_call_function_00109d5c"
        },
        "FUN_0010ed2c": {
            "renaming": {
                "FUN_0010ed2c": "update_max_value_0010ed2c",
                "param_1": "ptr1",
                "param_2": "value",
                "param_3": "ptr3",
                "cVar1": "result",
                "iVar2": "count",
                "extraout_RDX": "extra_RDX",
                "uVar3": "flag",
                "in_R10": "ptr2",
                "auVar4": "returnValue"
            },
            "code": "\nundefined  [16] updateMaxValue_0010ed2c(long ptr1,ulong value,undefined8 ptr3)\n\n{\n  char result;\n  int count;\n  undefined8 extra_RDX;\n  ulong flag;\n  undefined8 ptr2;\n  undefined returnValue [16];\n  \n  if (*(ulong *)(ptr1 + 0x1f0) < value) {\n    *(ulong *)(ptr1 + 0x1f0) = value;\n  }\n  if (*(long *)(ptr1 + 0x208) == -1) {\nLAB_0010ed78:\n    if (*(int *)(ptr1 + 0x1f8) != 0) {\n      count = *(int *)(ptr1 + 0x1f8) + -1;\n      flag = CONCAT71((int7)((ulong)ptr3 >> 8),1);\n      *(int *)(ptr1 + 0x1f8) = count;\n      if (count != 0) {\n        returnValue = FUN_0010e2f0(ptr1,0xe0,0,value - *(long *)(ptr1 + 0x200),0,ptr2);\n        return returnValue;\n      }\n      goto LAB_0010edae;\n    }\n  }\n  else {\n    result = FUN_0010e2f0(ptr1,0xc0,0,*(long *)(ptr1 + 0x208),0);\n    if (result != '\\0') {\n      *(undefined8 *)(ptr1 + 0x208) = 0xffffffffffffffff;\n      ptr3 = extra_RDX;\n      goto LAB_0010ed78;\n    }\n  }\n  flag = 0;\nLAB_0010edae:\n  returnValue._0_8_ = flag & 0xffffffff;\n  returnValue._8_8_ = ptr2;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ed2c",
            "calling": [
                "FUN_00113a4d"
            ],
            "imported": false,
            "current_name": "update_max_value_0010ed2c"
        },
        "FUN_0011a1b0": {
            "renaming": {
                "FUN_0011a1b0": "compare_memory_and_values_0011a1b0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "value1",
                "param_4": "value2",
                "uVar1": "maxValue1",
                "uVar2": "maxValue2",
                "iVar3": "comparisonResult",
                "uVar4": "overallResult",
                "auVar5": "returnValue"
            },
            "code": "\nundefined  [16] compareMemoryAndValues_0011a1b0(ulong *input1,ulong *input2,undefined8 value1,undefined8 value2)\n\n{\n  ulong maxValue1;\n  ulong maxValue2;\n  int comparisonResult;\n  undefined4 extraout_var;\n  ulong overallResult;\n  undefined returnValue [16];\n  \n  overallResult = *input1;\n  if (*input2 <= *input1) {\n    overallResult = *input2;\n  }\n  comparisonResult = memcmp((void *)(input1[3] + 3),(void *)(input2[3] + 3),overallResult - 3);\n  overallResult = CONCAT44(extraout_var,comparisonResult);\n  if (comparisonResult == 0) {\n    maxValue1 = input1[8];\n    if (maxValue1 < input2[7]) {\n      overallResult = 0xffffffff;\n    }\n    else {\n      maxValue2 = input2[8];\n      if (maxValue2 < input1[7]) {\n        overallResult = 1;\n      }\n      else {\n        overallResult = 0xffffffff;\n        if (input2[7] <= input1[7]) {\n          if (maxValue2 < maxValue1) {\n            overallResult = 1;\n          }\n          else {\n            overallResult = 0xffffffff;\n            if (maxValue2 <= maxValue1) {\n              if (input1[2] == 0x100) {\n                overallResult = (ulong)-(uint)(input2[2] != 0x100);\n              }\n              else {\n                overallResult = (ulong)(input2[2] == 0x100);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  returnValue._8_8_ = value2;\n  returnValue._0_8_ = overallResult;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_001087da",
                "memcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a1b0",
            "calling": [
                "FUN_001086af"
            ],
            "imported": false,
            "current_name": "compare_memory_and_values_0011a1b0"
        },
        "FUN_001163d0": {
            "renaming": {
                "FUN_001163d0": "process_build_attribute_notes_001163d0",
                "param_1": "param_elf_handle",
                "param_2": "param_section",
                "param_3": "param_num_notes",
                "param_4": "param_output",
                "uVar1": "result",
                "uVar2": "elf_handle",
                "uVar3": "section",
                "bVar4": "flag",
                "puVar5": "p",
                "iVar6": "i",
                "uVar7": "msg",
                "lVar8": "note_size",
                "__ptr": "reloc_buffer",
                "uVar9": "note_description_size",
                "uVar10": "note_name_size",
                "uVar11": "note_type",
                "uVar12": "min_size",
                "uVar13": "aligned_size",
                "__ptr_00": "temp_buffer",
                "uVar14": "tmp_result",
                "uVar15": "tmp_min_size",
                "uVar16": "remaining_size",
                "puVar17": "note_ptr",
                "puVar18": "description_ptr",
                "cVar19": "version",
                "puVar20": "temp_ptr",
                "iVar21": "counter",
                "puVar22": "current_ptr",
                "puVar23": "notes_buffer",
                "puVar25": "previous_note_ptr",
                "uVar24": "tmp_note_size",
                "__nmemb": "num_notes",
                "bVar26": "signed_flag",
                "local_88": "version_2_base_address",
                "uStack_80": "version_3_base_address",
                "local_70": "current_base_address",
                "local_68": "result_size",
                "local_60": "notes_array"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001166ef) */\n/* WARNING: Removing unreachable block (ram,0x001166df) */\n/* WARNING: Removing unreachable block (ram,0x001166d7) */\n/* WARNING: Removing unreachable block (ram,0x001166ea) */\n/* WARNING: Removing unreachable block (ram,0x00116716) */\n/* WARNING: Removing unreachable block (ram,0x0010858b) */\n\n\nulong process_build_attribute_notes_001163d0(undefined8 *param_elf_handle,undefined8 *param_section,ulong param_num_notes,undefined *param_output)\n\n{\n  ulong result;\n  undefined8 elf_handle;\n  undefined8 section;\n  bool flag;\n  ulong *p;\n  int i;\n  undefined8 msg;\n  long note_size;\n  void *reloc_buffer;\n  ulong note_description_size;\n  ulong note_name_size;\n  ulong note_type;\n  ulong min_size;\n  undefined *temp_buffer;\n  ulong aligned_size;\n  ulong tmp_result;\n  ulong tmp_min_size;\n  ulong remaining_size;\n  ulong *note_ptr;\n  undefined *description_ptr;\n  char version;\n  undefined *temp_ptr;\n  int counter;\n  undefined *current_ptr;\n  ulong *notes_buffer;\n  ulong tmp_note_size;\n  size_t num_notes;\n  ulong *previous_note_ptr;\n  byte signed_flag;\n  ulong version_2_base_address;\n  ulong version_3_base_address;\n  ulong current_base_address;\n  ulong result_size;\n  ulong *notes_array;\n  \n  signed_flag = 0;\n  note_size = bfd_get_reloc_upper_bound();\n  result_size = param_num_notes;\n  if (0 < note_size) {\n    reloc_buffer = (void *)xmalloc(note_size);\n    note_size = bfd_canonicalize_reloc(param_elf_handle,param_section,reloc_buffer,DAT_001278d0);\n    free(reloc_buffer);\n    if (note_size != 0) {\n      if (_DAT_001264c0 == 0) {\n        elf_handle = *param_elf_handle;\n        section = *param_section;\n        msg = dcgettext(0,\"%s[%s]: Cannot merge - there are relocations against this section\",5);\n        FUN_00119ed0(msg,elf_handle,section);\n      }\n      notes_array = (ulong *)0x0;\n      goto LAB_001166f8;\n    }\n  }\n  notes_array = (ulong *)xcalloc(param_num_notes / 0xc,0x48,param_num_notes % 0xc);\n  version_2_base_address = 0;\n  current_base_address = 0;\n  remaining_size = param_num_notes;\n  tmp_min_size = 0;\n  notes_buffer = notes_array;\n  tmp_result = 0;\n  current_ptr = param_output;\n  while (0xb < remaining_size) {\n    note_name_size = (**(code **)(param_elf_handle[1] + 0x40))(current_ptr);\n    *notes_buffer = note_name_size;\n    note_name_size = (**(code **)(param_elf_handle[1] + 0x40))(current_ptr + 4);\n    notes_buffer[1] = note_name_size;\n    note_type = (**(code **)(param_elf_handle[1] + 0x40))(current_ptr + 8);\n    note_name_size = *notes_buffer;\n    notes_buffer[2] = note_type;\n    min_size = notes_buffer[1];\n    aligned_size = note_name_size + 3 & 0xfffffffffffffffc;\n    notes_buffer[6] = aligned_size;\n    if (min_size != (min_size + 3 & 0xfffffffffffffffc)) {\n      note_size = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5);\n      goto LAB_0010849a;\n    }\n    if (1 < note_type - 0x100) {\n      note_size = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n      goto LAB_0010849a;\n    }\n    result = aligned_size + min_size + 0xc;\n    if (remaining_size < result) {\n      note_size = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n      goto LAB_0010849a;\n    }\n    if (note_name_size < 2) {\n      note_size = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n      goto LAB_0010849a;\n    }\n    notes_buffer[3] = (ulong)(current_ptr + 0xc);\n    notes_buffer[4] = (ulong)(current_ptr + aligned_size + 0xc);\n    remaining_size = remaining_size + (-0xc - (aligned_size + min_size));\n    if (note_name_size != 2) {\n      if (current_ptr[0xc] == '$') {\n        if ((current_ptr[0xd] == '\\x01') && (current_ptr[0xe] == '1')) {\n          remaining_size = FUN_00116490();\n          return remaining_size;\n        }\n      }\n      else if ((((4 < note_name_size) && (current_ptr[0xc] == 'G')) && (current_ptr[0xd] == 'A')) &&\n              ((current_ptr[0xe] == '$' && (current_ptr[0xf] == '\\x01')))) {\n        if (current_ptr[0x10] == '2') {\n          remaining_size = FUN_00116490();\n          return remaining_size;\n        }\n        if (current_ptr[0x10] == '3') {\n          remaining_size = FUN_00116490();\n          return remaining_size;\n        }\n        note_size = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n        goto LAB_0010849a;\n      }\n    }\n    note_description_size = tmp_min_size;\n    tmp_note_size = tmp_result;\n    if (min_size == 0) {\n      if (note_type == 0x100) {\n        notes_buffer[7] = version_2_base_address;\nLAB_001164af:\n        min_size = tmp_result;\n        tmp_note_size = tmp_result;\n      }\n      else {\n        notes_buffer[7] = current_base_address;\nLAB_0011669e:\n        note_description_size = tmp_min_size;\n        min_size = tmp_min_size;\n      }\n    }\n    else {\n      if (min_size != 0x10) {\n        if (min_size < 0x11) {\n          if (min_size == 4) {\n            note_type = (**(code **)(param_elf_handle[1] + 0x40))();\n            min_size = 0xffffffffffffffff;\n            goto LAB_00116631;\n          }\n          if (min_size == 8) {\n            remaining_size = FUN_001086af();\n            return remaining_size;\n          }\n        }\n        note_size = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n        goto LAB_0010849a;\n      }\n      note_type = (**(code **)(param_elf_handle[1] + 0x28))(current_ptr + aligned_size + 0xc);\n      min_size = (**(code **)(param_elf_handle[1] + 0x28))();\n      if (min_size < note_type) {\n        note_type = min_size;\n      }\nLAB_00116631:\n      if (notes_buffer[2] == 0x100) {\n        if (note_type == 0) {\n          note_type = version_2_base_address;\n        }\n        note_name_size = *notes_buffer;\n        notes_buffer[7] = note_type;\n        tmp_note_size = min_size;\n        version_2_base_address = note_type;\n        if (min_size == 0) goto LAB_001164af;\n      }\n      else {\n        if (note_type == 0) {\n          note_type = current_base_address;\n        }\n        note_name_size = *notes_buffer;\n        notes_buffer[7] = note_type;\n        note_description_size = min_size;\n        current_base_address = note_type;\n        if (min_size == 0) goto LAB_0011669e;\n      }\n    }\n    notes_buffer[8] = min_size;\n    if (*(char *)((notes_buffer[3] - 1) + note_name_size) != '\\0') {\n      note_size = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    notes_buffer = notes_buffer + 9;\n    tmp_min_size = note_description_size;\n    tmp_result = tmp_note_size;\n    current_ptr = current_ptr + result;\n  }\n  if (remaining_size == 0) {\n    elf_handle = *param_elf_handle;\n    section = *param_section;\n    msg = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n    FUN_00119ed0(msg,elf_handle,section);\n    num_notes = ((long)notes_buffer - (long)notes_array >> 3) * -0x71c71c71c71c71c7;\n    qsort(notes_array,num_notes,0x48,FUN_0011a1b0);\n    for (note_ptr = notes_array; note_ptr < notes_buffer; note_ptr = note_ptr + 9) {\n      remaining_size = note_ptr[2];\n      if (remaining_size != 0) {\n        tmp_min_size = note_ptr[7];\n        tmp_result = note_ptr[8];\n        previous_note_ptr = note_ptr;\n        counter = 0;\n        if (tmp_min_size == tmp_result) {\n          note_ptr[2] = 0;\n        }\n        else {\n          do {\n            do {\n              p = previous_note_ptr;\n              previous_note_ptr = p + -9;\n              if (previous_note_ptr < notes_array) goto LAB_001167f5;\n              note_name_size = p[-7];\n            } while (note_name_size == 0);\n            if ((*previous_note_ptr != *note_ptr) ||\n               (i = memcmp((void *)p[-6],(void *)note_ptr[3],*note_ptr), i != 0)) break;\n            min_size = p[-2];\n            note_type = p[-1];\n            if (tmp_min_size == min_size) {\n              if (tmp_result == note_type) {\n                note_ptr[2] = 0;\n                break;\n              }\nLAB_001167a6:\n              if (tmp_result <= note_type) {\n                note_ptr[2] = 0;\n                break;\n              }\n              if (note_type < tmp_min_size) {\nLAB_0010852c:\n                if ((0xfffffffffffffff0 < note_type) || (tmp_min_size <= (note_type + 0xf & 0xfffffffffffffff0))\n                   ) goto FUN_00116852;\n              }\nLAB_001167b8:\n              if ((remaining_size == 0x101) == (note_name_size == 0x101)) {\n                if (note_type <= tmp_result) {\n                  note_type = tmp_result;\n                }\n                if (min_size < tmp_min_size) {\n                  tmp_min_size = min_size;\n                }\n                p[-1] = note_type;\n                p[-2] = tmp_min_size;\n                note_ptr[2] = 0;\n                break;\n              }\n            }\n            else {\n              if (min_size <= tmp_min_size) goto LAB_001167a6;\n              if (note_type < tmp_min_size) goto LAB_0010852c;\n              if (tmp_result < tmp_min_size) {\n                if ((0xfffffffffffffff0 < tmp_result) || (min_size <= (tmp_result + 0xf & 0xfffffffffffffff0))\n                   ) goto FUN_00116852;\n                goto LAB_001167b8;\n              }\n              if (tmp_result != note_type) goto LAB_001167b8;\n            }\nFUN_00116852:\n            flag = counter < 0x11;\n            counter = counter + 1;\n          } while (flag);\n        }\n      }\nLAB_001167f5:\n    }\n    qsort(notes_array,num_notes,0x48,FUN_0011a250);\n    temp_buffer = (undefined *)xmalloc(param_num_notes * 2);\n    version_3_base_address = 0;\n    current_base_address = 0;\n    current_ptr = temp_buffer;\n    for (note_ptr = notes_array; note_ptr < notes_buffer; note_ptr = note_ptr + 9) {\n      if (note_ptr[2] != 0) {\n        description_ptr = current_ptr + 0xc;\n        if ((note_ptr[7] == current_base_address) && (note_ptr[8] == version_3_base_address)) {\n          (**(code **)(param_elf_handle[1] + 0x50))(*note_ptr,current_ptr);\n          (**(code **)(param_elf_handle[1] + 0x50))(0,current_ptr + 4);\n          (**(code **)(param_elf_handle[1] + 0x50))(note_ptr[2],current_ptr + 8);\n          tmp_min_size = note_ptr[6];\n          remaining_size = *note_ptr;\n          current_ptr = (undefined *)note_ptr[3];\n          temp_ptr = description_ptr;\n          for (tmp_result = remaining_size; tmp_result != 0; tmp_result = tmp_result - 1) {\n            *temp_ptr = *current_ptr;\n            current_ptr = current_ptr + (ulong)signed_flag * -2 + 1;\n            temp_ptr = temp_ptr + (ulong)signed_flag * -2 + 1;\n          }\n          if (remaining_size < tmp_min_size) {\n            for (note_size = tmp_min_size - remaining_size; note_size != 0; note_size = note_size + -1) {\n              *temp_ptr = 0;\n              temp_ptr = temp_ptr + (ulong)signed_flag * -2 + 1;\n            }\n          }\n          current_ptr = description_ptr + tmp_min_size;\n        }\n        else {\n          (**(code **)(param_elf_handle[1] + 0x50))();\n          if (*(int *)(param_elf_handle[1] + 8) == 5) {\n            version = (*(char *)(param_elf_handle[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n          }\n          else {\n            version = '\\b';\n          }\n          (**(code **)(param_elf_handle[1] + 0x50))(version,current_ptr + 4);\n          (**(code **)(param_elf_handle[1] + 0x50))(note_ptr[2],current_ptr + 8);\n          remaining_size = *note_ptr;\n          current_ptr = (undefined *)note_ptr[3];\n          temp_ptr = description_ptr;\n          for (tmp_min_size = remaining_size; tmp_min_size != 0; tmp_min_size = tmp_min_size - 1) {\n            *temp_ptr = *current_ptr;\n            current_ptr = current_ptr + (ulong)signed_flag * -2 + 1;\n            temp_ptr = temp_ptr + (ulong)signed_flag * -2 + 1;\n          }\n          tmp_min_size = note_ptr[6];\n          if (remaining_size < tmp_min_size) {\n            for (note_size = tmp_min_size - remaining_size; note_size != 0; note_size = note_size + -1) {\n              *temp_ptr = 0;\n              temp_ptr = temp_ptr + (ulong)signed_flag * -2 + 1;\n            }\n          }\n          note_size = param_elf_handle[1];\n          description_ptr = description_ptr + tmp_min_size;\n          current_ptr = description_ptr + 8;\n          if ((*(int *)(note_size + 8) == 5) && (*(char *)(param_elf_handle[0x22] + 4) == '\\x02')) {\n            (**(code **)(note_size + 0x38))(note_ptr[7],description_ptr);\n            (**(code **)(param_elf_handle[1] + 0x38))(note_ptr[8],current_ptr);\n            current_ptr = description_ptr + 0x10;\n          }\n          else {\n            (**(code **)(note_size + 0x50))(note_ptr[7],description_ptr);\n            (**(code **)(param_elf_handle[1] + 0x50))(note_ptr[8],description_ptr + 4);\n          }\n          current_base_address = note_ptr[7];\n          version_3_base_address = note_ptr[8];\n        }\n      }\n    }\n    tmp_min_size = (long)current_ptr - (long)temp_buffer;\n    remaining_size = tmp_min_size;\n    current_ptr = temp_buffer;\n    result_size = param_num_notes;\n    if (tmp_min_size < param_num_notes) {\n      for (; result_size = tmp_min_size, remaining_size != 0; remaining_size = remaining_size - 1) {\n        *param_output = *current_ptr;\n        current_ptr = current_ptr + (ulong)signed_flag * -2 + 1;\n        param_output = param_output + (ulong)signed_flag * -2 + 1;\n      }\n    }\n    free(temp_buffer);\n  }\n  else {\n    note_size = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\nLAB_0010849a:\n    if (note_size != 0) {\n      bfd_set_error(0x11);\n      FUN_001126c0(0,param_elf_handle,param_section,note_size);\n      DAT_00127a40 = 1;\n    }\n  }\nLAB_001166f8:\n  free(notes_array);\n  return result_size;\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "free",
                "FUN_00119ed0",
                "xcalloc",
                "bfd_canonicalize_reloc",
                "bfd_get_reloc_upper_bound"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001163d0",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "process_build_attribute_notes_001163d0"
        },
        "FUN_00108a2a": {
            "renaming": {
                "FUN_00108a2a": "print_usage_00108a2a",
                "param_1": "outputFile",
                "param_2": "status",
                "uVar1": "programName",
                "pcVar2": "message"
            },
            "code": "\nvoid printUsage_00108a2a(FILE *outputFile,int status)\n\n{\n  undefined8 programName;\n  char *message;\n  \n  programName = DAT_00127600;\n  message = (char *)dcgettext(0,\"Usage: %s <option(s)> in-file(s)\\n\",5);\n  fprintf(outputFile,message,programName);\n  message = (char *)dcgettext(0,\" Removes symbols and sections from files\\n\",5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \"  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\\n  -O --output-target=<bfdname>     Create an output file in format <bfdname>\\n  -F --target=<bfdname>            Set both input and output format to <bfdname>\\n  -p --preserve-dates              Copy modified/access timestamps to the output\\n\"\n                             ,5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \"  -D --enable-deterministic-archives\\n                                   Produce deterministic output when stripping archives (default)\\n  -U --disable-deterministic-archives\\n                                   Disable -D behavior\\n\"\n                             ,5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \"  -R --remove-section=<name>       Also remove section <name> from the output\\n     --remove-relocations <name>   Remove relocations from section <name>\\n  -s --strip-all                   Remove all symbol and relocation information\\n  -g -S -d --strip-debug           Remove all debugging symbols & sections\\n     --strip-dwo                   Remove all DWO sections\\n     --strip-unneeded              Remove all symbols not needed by relocations\\n     --only-keep-debug             Strip everything but the debug information\\n  -M  --merge-notes                Remove redundant entries in note sections (default)\\n      --no-merge-notes             Do not attempt to remove redundant notes\\n  -N --strip-symbol=<name>         Do not copy symbol <name>\\n     --keep-section=<name>         Do not strip section <name>\\n  -K --keep-symbol=<name>          Do not strip symbol <name>\\n     --keep-section-symbols        Do not strip section symbols\\n     --keep-file-symbols           Do not strip file symbol(s)\\n  -w --wildcard                    Permit wildcard in symbol comparison\\n  -x --discard-all                 Remove all non-global symbols\\n  -X --discard-locals              Remove any compiler-generated symbols\\n  -v --verbose                     List all object files modified\\n  -V --version                     Display this program\\'s version number\\n  -h --help                        Display this output\\n     --info                        List object formats & architectures supported\\n  -o <file>                        Place stripped output into <file>\\n\"\n                             ,5);\n  fprintf(outputFile,message);\n  FUN_00104a35(DAT_00127600,outputFile);\n  if (status == 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputFile,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(status);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00104a35",
                "fprintf",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108a2a",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "print_usage_00108a2a"
        },
        "FUN_00108c86": {
            "renaming": {
                "FUN_00108c86": "parse_and_convert_architecture_00108c86",
                "param_1": "input_pointer",
                "cVar1": "found_match",
                "iVar2": "comparison_result",
                "sVar3": "input_length",
                "puVar4": "output_buffer",
                "lVar5": "current_position",
                "__s": "input_string",
                "__s1": "arch_identifier",
                "puVar6": "buffer_pointer",
                "uVar7": "return_value",
                "bVar8": "is_negative"
            },
            "code": "\nundefined8 parse_and_convert_architecture_00108c86(long *input_pointer)\n\n{\n  char found_match;\n  int comparison_result;\n  size_t input_length;\n  undefined2 *output_buffer;\n  long current_position;\n  char *input_string;\n  char *arch_identifier;\n  undefined2 *buffer_pointer;\n  undefined8 return_value;\n  byte is_negative;\n  \n  is_negative = 0;\n  current_position = *input_pointer;\n  input_string = (char *)(current_position + 4);\n  found_match = FUN_00113fb0(input_string,&DAT_0011b73b);\n  if (found_match == '\\0') {\n    found_match = FUN_00113fb0(input_string,\"bsdrv-\");\n    if (found_match == '\\0') {\n      found_match = FUN_00113fb0(input_string,\"rtdrv-\");\n      if (found_match == '\\0') {\n        return 0xffffffff;\n      }\n      input_string = (char *)(current_position + 6);\n      return_value = 0xc;\n    }\n    else {\n      input_string = (char *)(current_position + 6);\n      return_value = 0xb;\n    }\n  }\n  else {\n    return_value = 10;\n  }\n  input_length = strlen(input_string);\n  output_buffer = (undefined2 *)xmalloc(input_length + 8);\n  arch_identifier = input_string + 4;\n  buffer_pointer = output_buffer;\n  for (current_position = input_length + 1; current_position != 0; current_position = current_position + -1) {\n    *(char *)buffer_pointer = *input_string;\n    input_string = input_string + (ulong)is_negative * -2 + 1;\n    buffer_pointer = (undefined2 *)((long)buffer_pointer + (ulong)is_negative * -2 + 1);\n  }\n  *(undefined *)(output_buffer + 1) = 0x69;\n  *output_buffer = 0x6570;\n  comparison_result = strcmp(arch_identifier,\"ia32\");\n  if (comparison_result == 0) {\n    *(undefined *)((long)output_buffer + 7) = 0x36;\n    *(undefined2 *)((long)output_buffer + 5) = 0x3833;\n  }\n  else {\n    comparison_result = strcmp(arch_identifier,\"x86_64\");\n    if (comparison_result == 0) {\n      *(undefined *)((long)output_buffer + 7) = 0x2d;\n    }\n    else {\n      comparison_result = strcmp(arch_identifier,\"aarch64\");\n      if (comparison_result == 0) {\n        *(undefined8 *)((long)output_buffer + 0xb) = 0x656c7474696c2d;\n      }\n    }\n  }\n  *input_pointer = (long)output_buffer;\n  return return_value;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "xmalloc",
                "strcmp",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108c86",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "parse_and_convert_architecture_00108c86"
        },
        "FUN_0010911f": {
            "renaming": {
                "FUN_0010911f": "print_error_message_0010911f",
                "param_1": "errorMessage",
                "__format": "errorFormat"
            },
            "code": "\n\n\nvoid printErrorMessage_0010911f(undefined8 errorMessage)\n\n{\n  char *errorFormat;\n  \n  errorFormat = (char *)dcgettext(0,\"bad mangled name `%s\\'\\n\",5);\n  fprintf(_stderr,errorFormat,errorMessage);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010911f",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010d21c",
                "FUN_0010d882",
                "FUN_0010c95e",
                "FUN_0010d559"
            ],
            "imported": false,
            "current_name": "print_error_message_0010911f"
        },
        "bfd_get_stab_name": {
            "renaming": {},
            "code": "\nvoid bfd_get_stab_name(void)\n\n{\n  bfd_get_stab_name();\n  return;\n}\n\n",
            "called": [
                "bfd_get_stab_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104110",
            "calling": [
                "FUN_00108b3e"
            ],
            "imported": false,
            "current_name": "bfd_get_stab_name"
        },
        "FUN_001053d5": {
            "renaming": {
                "FUN_001053d5": "cleanup_and_close_001053d5",
                "unaff_R12": "dataPointer",
                "unaff_R14": "functionPointer"
            },
            "code": "\nundefined4 cleanupAndClose_001053d5(void)\n\n{\n  long dataPointer;\n  undefined8 *functionPointer;\n  \n  FUN_0011a110(*functionPointer);\n  *(undefined4 *)(dataPointer + 8) = 1;\n  bfd_close_all_done();\n  return *(undefined4 *)(dataPointer + 8);\n}\n\n",
            "called": [
                "FUN_0011a110"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001053d5",
            "calling": [
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "cleanup_and_close_001053d5"
        },
        "FUN_00104bba": {
            "renaming": {
                "FUN_00104bba": "validate_and_set_permissions_00104bba",
                "in_EAX": "eaxValue",
                "uVar1": "errorString",
                "unaff_EBP": "ebpValue",
                "unaff_R14": "r14Value"
            },
            "code": "\nvoid validateAndSetPermissions_00104bba(void)\n\n{\n  uint eaxValue;\n  undefined8 errorString;\n  uint ebpValue;\n  long r14Value;\n  \n  if ((eaxValue & 2) != 0) {\n    errorString = dcgettext(0,\"error: %s both copied and removed\",5);\n                    \n    FUN_00119dd0(errorString);\n  }\n  if ((((eaxValue & 8) == 0) || ((ebpValue & 0x10) == 0)) && ((ebpValue & 0x18) != 0x18)) {\n    if ((((eaxValue & 0x20) == 0) || ((ebpValue & 0x40) == 0)) && ((ebpValue & 0x60) != 0x60)) {\n      *(uint *)(r14Value + 0x14) = eaxValue | ebpValue;\n      return;\n    }\n    errorString = dcgettext(0,\"error: %s both sets and alters LMA\",5);\n                    \n    FUN_00119dd0(errorString);\n  }\n  errorString = dcgettext(0,\"error: %s both sets and alters VMA\",5);\n                    \n  FUN_00119dd0(errorString);\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104bba",
            "calling": [
                "FUN_00114190"
            ],
            "imported": false,
            "current_name": "validate_and_set_permissions_00104bba"
        },
        "FUN_00109a0b": {
            "renaming": {
                "FUN_00109a0b": "copy_and_null_terminate_00109a0b",
                "param_1": "source",
                "param_2": "length",
                "puVar1": "destination",
                "lVar2": "i",
                "puVar3": "destPointer",
                "bVar4": "offset"
            },
            "code": "\nvoid copyAndNullTerminate_00109a0b(undefined *source,int length)\n\n{\n  undefined *destination;\n  long i;\n  undefined *destPointer;\n  byte offset;\n  \n  offset = 0;\n  destination = (undefined *)xmalloc((long)(length + 1));\n  destPointer = destination;\n  for (i = (long)length; i != 0; i = i + -1) {\n    *destPointer = *source;\n    source = source + (ulong)offset * -2 + 1;\n    destPointer = destPointer + (ulong)offset * -2 + 1;\n  }\n  destination[length] = 0;\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109a0b",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010d21c",
                "FUN_0010c95e",
                "FUN_0010afd5",
                "FUN_0011173a",
                "FUN_0010d559"
            ],
            "imported": false,
            "current_name": "copy_and_null_terminate_00109a0b"
        },
        "bfd_coff_get_syment": {
            "renaming": {},
            "code": "\nvoid bfd_coff_get_syment(void)\n\n{\n  bfd_coff_get_syment();\n  return;\n}\n\n",
            "called": [
                "bfd_coff_get_syment"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046a0",
            "calling": [
                "FUN_0010e07c",
                "FUN_0010554f",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "bfd_coff_get_syment"
        },
        "FUN_0010da0b": {
            "renaming": {
                "FUN_0010da0b": "allocate_memory_0010da0b",
                "param_1": "memoryBlock",
                "param_2": "slotIndex",
                "param_3": "unusedArg1",
                "param_4": "unusedArg2",
                "uVar1": "errorMessage",
                "plVar2": "newMemoryBlock",
                "lVar3": "adjustedSlotIndex",
                "lVar4": "counter",
                "uVar5": "tempIndex",
                "bVar6": "flag",
                "auVar7": "result"
            },
            "code": "\nundefined  [16] allocateMemory_0010da0b(long **memoryBlock,ulong slotIndex,undefined8 unusedArg1,undefined8 unusedArg2)\n\n{\n  undefined8 errorMessage;\n  long *newMemoryBlock;\n  long adjustedSlotIndex;\n  long counter;\n  ulong tempIndex;\n  byte flag;\n  undefined result [16];\n  \n  flag = 0;\n  tempIndex = slotIndex;\n  if ((long)slotIndex < 0x3e90) {\n    for (; 0xf < (long)tempIndex; tempIndex = tempIndex - 0x10) {\n      if (*memoryBlock == (long *)0x0) {\n        newMemoryBlock = (long *)xmalloc(0x88);\n        *memoryBlock = newMemoryBlock;\n        for (adjustedSlotIndex = 0x22; adjustedSlotIndex != 0; adjustedSlotIndex = adjustedSlotIndex + -1) {\n          *(undefined4 *)newMemoryBlock = 0;\n          newMemoryBlock = (long *)((long)newMemoryBlock + (ulong)flag * -8 + 4);\n        }\n      }\n      memoryBlock = (long **)*memoryBlock;\n    }\n    adjustedSlotIndex = (slotIndex >> 4) * -0x10;\n    if ((long)slotIndex < 0) {\n      adjustedSlotIndex = 0;\n    }\n    if (*memoryBlock == (long *)0x0) {\n      newMemoryBlock = (long *)xmalloc(0x88);\n      *memoryBlock = newMemoryBlock;\n      for (counter = 0x22; counter != 0; counter = counter + -1) {\n        *(undefined4 *)newMemoryBlock = 0;\n        newMemoryBlock = (long *)((long)newMemoryBlock + (ulong)flag * -8 + 4);\n      }\n    }\n    result._8_8_ = unusedArg2;\n    result._0_8_ = *memoryBlock + slotIndex + adjustedSlotIndex + 1;\n    return result;\n  }\n  errorMessage = dcgettext(0,\"Excessively large slot index: %lx\",5);\n                    \n  FUN_00119dd0(errorMessage,slotIndex);\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "FUN_00119dd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010da0b",
            "calling": [
                "FUN_0010dac0",
                "FUN_00112a33"
            ],
            "imported": false,
            "current_name": "allocate_memory_0010da0b"
        },
        "FUN_00112894": {
            "renaming": {
                "FUN_00112894": "initialize_data_structure_00112894",
                "param_1": "dataPointer",
                "puVar1": "allocatedMemory",
                "puVar2": "currentMemory",
                "lVar3": "loopCounter",
                "bVar4": "byteCounter"
            },
            "code": "\nundefined8 *\ninitializeDataStructure_00112894(undefined8 dataPointer,undefined param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  undefined8 *allocatedMemory;\n  undefined8 *currentMemory;\n  long loopCounter;\n  byte byteCounter;\n  \n  byteCounter = 0;\n  allocatedMemory = (undefined8 *)xmalloc(0x1b0);\n  currentMemory = allocatedMemory;\n  for (loopCounter = 0x6c; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *(undefined4 *)currentMemory = 0;\n    currentMemory = (undefined8 *)((long)currentMemory + (ulong)byteCounter * -8 + 4);\n  }\n  *allocatedMemory = dataPointer;\n  *(undefined *)(allocatedMemory + 1) = param_2;\n  allocatedMemory[2] = param_3;\n  allocatedMemory[3] = param_4;\n  *(undefined4 *)(allocatedMemory + 0x10) = 1;\n  currentMemory = (undefined8 *)xmalloc(8);\n  allocatedMemory[0xd] = 0xffffffffffffffff;\n  allocatedMemory[0x11] = currentMemory;\n  *currentMemory = 0;\n  return allocatedMemory;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112894",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_00112894"
        },
        "FUN_00109b2f": {
            "renaming": {
                "FUN_00109b2f": "extract_and_free_ptr_00109b2f",
                "param_1": "ptr_address",
                "__ptr": "ptr",
                "puVar1": "extracted_ptr"
            },
            "code": "\nundefined8 * extract_and_free_ptr_00109b2f(long ptr_address)\n\n{\n  undefined8 *ptr;\n  undefined8 *extracted_ptr;\n  \n  ptr = *(undefined8 **)(ptr_address + 0x60);\n  if (ptr != (undefined8 *)0x0) {\n    extracted_ptr = (undefined8 *)ptr[1];\n    *(undefined8 *)(ptr_address + 0x60) = *ptr;\n    free(ptr);\n    return extracted_ptr;\n  }\n  return ptr;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109b2f",
            "calling": [
                "FUN_0010abdd",
                "FUN_0010ebb0",
                "FUN_00109ed3",
                "FUN_0010aa53",
                "FUN_0010a181",
                "FUN_0010a83e",
                "FUN_0010b948",
                "FUN_0010e6a8",
                "FUN_0010a424",
                "FUN_0010a94e",
                "FUN_0010e5db",
                "FUN_0010a0e9",
                "FUN_0010a2b9",
                "FUN_0010e918",
                "FUN_0010a377",
                "FUN_0010a77a",
                "FUN_0010eafe",
                "FUN_0010e7c2",
                "FUN_0010e9a0",
                "FUN_0010ba08"
            ],
            "imported": false,
            "current_name": "extract_and_free_ptr_00109b2f"
        },
        "strdup": {
            "renaming": {},
            "code": "\n\n\nchar * strdup(char *__s)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strdup(__s);\n  return pcVar1;\n}\n\n",
            "called": [
                "strdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104880",
            "calling": [
                "FUN_00108d9a"
            ],
            "imported": false,
            "current_name": "strdup"
        },
        "FUN_00108d9a": {
            "renaming": {
                "FUN_00108d9a": "validate_and_store_symbol_00108d9a",
                "param_1": "fileIdentifier",
                "param_2": "symbolName",
                "param_3": "targetSymbol",
                "ppcVar1": "symbolArray",
                "pcVar2": "duplicateSymbolName",
                "lVar3": "symbolIndex",
                "uVar4": "errorMessage",
                "plVar5": "symbolSlot"
            },
            "code": "\nundefined8 validateAndStoreSymbol_00108d9a(undefined8 fileIdentifier,char *symbolName,char *targetSymbol,undefined8 param_4)\n\n{\n  char **symbolArray;\n  char *duplicateSymbolName;\n  long symbolIndex;\n  undefined8 errorMessage;\n  long *symbolSlot;\n  \n  symbolArray = (char **)xmalloc(0x10);\n  duplicateSymbolName = strdup(symbolName);\n  *symbolArray = duplicateSymbolName;\n  duplicateSymbolName = strdup(targetSymbol);\n  errorMessage = DAT_001278f0;\n  symbolArray[1] = duplicateSymbolName;\n  symbolIndex = htab_find(errorMessage,symbolArray);\n  if (symbolIndex != 0) {\n    errorMessage = dcgettext(0,\"%s: Multiple redefinition of symbol \\\"%s\\\"\",5);\n                    \n    FUN_00119dd0(errorMessage,fileIdentifier,symbolName);\n  }\n  symbolIndex = htab_find(DAT_001278e8,targetSymbol);\n  if (symbolIndex != 0) {\n    errorMessage = dcgettext(0,\"%s: Symbol \\\"%s\\\" is target of more than one redefinition\",5);\n                    \n    FUN_00119dd0(errorMessage,fileIdentifier,targetSymbol);\n  }\n  symbolSlot = (long *)htab_find_slot(DAT_001278f0,symbolArray,1);\n  errorMessage = DAT_001278e8;\n  *symbolSlot = (long)symbolArray;\n  duplicateSymbolName = symbolArray[1];\n  symbolArray = (char **)htab_find_slot(errorMessage,duplicateSymbolName,1);\n  *symbolArray = duplicateSymbolName;\n  return param_4;\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "htab_find_slot",
                "strdup",
                "FUN_00119dd0",
                "htab_find"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108d9a",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "validate_and_store_symbol_00108d9a"
        },
        "FUN_0010e9a0": {
            "renaming": {
                "FUN_0010e9a0": "process_string_0010e9a0",
                "param_1": "inputPointer",
                "param_2": "inputString",
                "param_3": "option",
                "param_4": "outputParam",
                "lVar1": "counter",
                "uVar2": "returnValue",
                "__s": "randomString",
                "__s_00": "newString1",
                "sVar3": "inputStringLength",
                "sVar4": "randomStringLength",
                "__s_01": "newString2",
                "pcVar5": "prefix",
                "uVar6": "value",
                "sprintf": "formatString"
            },
            "code": "\nundefined4 processString_0010e9a0(long inputPointer,char *inputString,undefined4 option,undefined8 outputParam)\n\n{\n  long counter;\n  undefined4 returnValue;\n  byte *randomString;\n  byte *newString1;\n  size_t inputStringLength;\n  size_t randomStringLength;\n  char *newString2;\n  char *prefix;\n  undefined8 value;\n  \n  randomString = (byte *)FUN_00109b2f();\n  switch(option) {\n  case 1:\n    prefix = \"G\";\n    value = 0x20;\n    break;\n  case 2:\n    prefix = \"S\";\n    value = 0x26;\n    break;\n  case 3:\n    prefix = \"V\";\n    value = 0x26;\n    break;\n  case 4:\n    prefix = \"\";\n    value = 0x80;\n    if (((&_sch_istable)[(ulong)*randomString * 2] & 4) == 0) {\n      counter = *(long *)(inputPointer + 0x68);\n      *(long *)(inputPointer + 0x68) = counter + 1;\n      inputStringLength = strlen((char *)randomString);\n      newString1 = (byte *)xmalloc(inputStringLength + 0x14);\n      sprintf((char *)newString1,\"%ld=%s\",counter,randomString);\n      free(randomString);\n      randomString = newString1;\n    }\n    break;\n  case 5:\n    prefix = \"r\";\n    value = 0x40;\n    break;\n  default:\n                    \n    abort();\n  }\n  inputStringLength = strlen(inputString);\n  randomStringLength = strlen((char *)randomString);\n  newString2 = (char *)xmalloc(inputStringLength + 3 + randomStringLength);\n  sprintf(newString2,\"%s:%s%s\",inputString,prefix,randomString);\n  free(randomString);\n  returnValue = FUN_0010e2f0(inputPointer,value,0,outputParam,newString2);\n  if ((char)returnValue != '\\0') {\n    free(newString2);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_0010e2f0",
                "abort",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e9a0",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_string_0010e9a0"
        },
        "FUN_0010827b": {
            "renaming": {
                "FUN_0010827b": "print_section_error_0010827b",
                "unaff_RBX": "sectionPointer",
                "uVar1": "sectionValue",
                "uVar2": "errorMessage"
            },
            "code": "\nvoid printSectionError_0010827b(void)\n\n{\n  undefined8 sectionValue;\n  undefined8 errorMessage;\n  undefined8 *sectionPointer;\n  \n  sectionValue = *sectionPointer;\n  errorMessage = dcgettext(0,\"error: section %s matches both remove and copy options\",5);\n                    \n  FUN_00119dd0(errorMessage,sectionValue);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00119dd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010827b",
            "calling": [
                "FUN_00115b70"
            ],
            "imported": false,
            "current_name": "print_section_error_0010827b"
        },
        "bfd_set_symtab": {
            "renaming": {},
            "code": "\nvoid bfd_set_symtab(void)\n\n{\n  bfd_set_symtab();\n  return;\n}\n\n",
            "called": [
                "bfd_set_symtab"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104460",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_set_symtab"
        },
        "FUN_00104920": {
            "renaming": {
                "FUN_00104920": "validate_number_00104920",
                "uVar1": "errorMessage"
            },
            "code": "\nvoid validateNumber_00104920(void)\n\n{\n  undefined8 errorMessage;\n  \n  errorMessage = dcgettext(0,\"%s: bad number: %s\",5);\n                    \n  FUN_00119dd0(errorMessage);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00119dd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104920",
            "calling": [
                "FUN_00119940"
            ],
            "imported": false,
            "current_name": "validate_number_00104920"
        },
        "FUN_00113f20": {
            "renaming": {
                "FUN_00113f20": "create_symbol_table_00113f20",
                "htab_create_alloc": "createHashtable",
                "htab_hash_string": "hashString",
                "htab_eq_string": "compareStrings",
                "xcalloc": "allocateMemory",
                "free": "releaseMemory"
            },
            "code": "\nvoid createSymbolTable_00113f20(void)\n\n{\n  htab_create_alloc(0x10,htab_hash_string,compareStrings,0,xcalloc,free);\n  return;\n}\n\n",
            "called": [
                "htab_eq_string",
                "htab_create_alloc",
                "htab_hash_string",
                "xcalloc",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113f20",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "create_symbol_table_00113f20"
        },
        "htab_find_slot": {
            "renaming": {},
            "code": "\nvoid htab_find_slot(void)\n\n{\n  htab_find_slot();\n  return;\n}\n\n",
            "called": [
                "htab_find_slot"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044a0",
            "calling": [
                "FUN_00104cc1",
                "FUN_00108d9a",
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "htab_find_slot"
        },
        "mkdtemp": {
            "renaming": {},
            "code": "\n\n\nchar * mkdtemp(char *__template)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = mkdtemp(__template);\n  return pcVar1;\n}\n\n",
            "called": [
                "mkdtemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104670",
            "calling": [
                "FUN_0011a0e0"
            ],
            "imported": false,
            "current_name": "mkdtemp"
        },
        "vfprintf": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104770",
            "calling": [
                "FUN_00119e70",
                "FUN_001126c0"
            ],
            "imported": false,
            "current_name": "vfprintf"
        },
        "bfd_set_default_target": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104150",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bfd_set_default_target"
        },
        "write": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041c0",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "write"
        },
        "FUN_00108179": {
            "renaming": {
                "FUN_00108179": "set_alignment_00108179",
                "unaff_RBX": "rbxValue",
                "unaff_RBP": "rbpValue",
                "unaff_R12": "r12Value",
                "unaff_R14B": "r14bValue",
                "unaff_R15": "r15Value",
                "lVar1": "var1",
                "lVar2": "var2",
                "cVar3": "charVar",
                "lVar4": "var4",
                "lVar5": "var5"
            },
            "code": "\nvoid setAlignment_00108179(void)\n\n{\n  long var1;\n  long var2;\n  char charVar;\n  long var4;\n  long var5;\n  long rbxValue;\n  long rbpValue;\n  long r12Value;\n  char r14bValue;\n  long r15Value;\n  \n  var4 = dcgettext(0,\"failed to set alignment\",5);\n  *(undefined4 *)(r15Value + 0xb4) = *(undefined4 *)(rbxValue + 0xb4);\n  *(byte *)(r15Value + 0x28) =\n       *(byte *)(r15Value + 0x28) & 0xcf | *(byte *)(rbxValue + 0x28) & 0x30;\n  *(long *)(rbxValue + 0x60) = r15Value;\n  *(undefined8 *)(rbxValue + 0x58) = 0;\n  if ((*(byte *)(rbxValue + 0x27) & 2) != 0) {\n    var1 = *(long *)(rbxValue + 0xd0);\n    var5 = FUN_00115d00(var1,*(undefined8 *)(rbxValue + 0xe0));\n    if ((var5 != 0) &&\n       (var2 = *(long *)(r12Value + 8), *(uint *)(var5 + 0x18) = *(uint *)(var5 + 0x18) | 0x20,\n       *(int *)(var2 + 8) == 5)) {\n      *(long *)(var1 + 0xb0) = var5;\n      charVar = (**(code **)(*(long *)(rbpValue + 8) + 0x158))();\n      if (charVar == '\\0') {\n        FUN_0010808f();\n        return;\n      }\n      goto LAB_0011571e;\n    }\n  }\n  charVar = (**(code **)(*(long *)(rbpValue + 8) + 0x158))();\n  if (charVar == '\\0') {\n    FUN_0010808f();\n    return;\n  }\nLAB_0011571e:\n  if (r14bValue != '\\0') {\n    *(undefined4 *)(*(long *)(r15Value + 0xd0) + 4) = 8;\n  }\n  if (var4 != 0) {\n    DAT_00127a40 = 1;\n    FUN_001126c0(0);\n  }\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00115d00",
                "FUN_0010808f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108179",
            "calling": [
                "FUN_00108072"
            ],
            "imported": false,
            "current_name": "set_alignment_00108179"
        },
        "FUN_00109022": {
            "renaming": {
                "FUN_00109022": "type_file_number_out_of_range_00109022",
                "param_1": "fileIndex",
                "param_2": "typeIndices",
                "param_3": "unusedParam1",
                "param_4": "unusedParam2",
                "uVar1": "typeIndex",
                "pcVar2": "errorMessage",
                "plVar3": "result",
                "lVar4": "loopCounter",
                "uVar5": "currentIndex",
                "pplVar6": "typeDataPtr",
                "bVar7": "byteVar",
                "auVar8": "returnVal"
            },
            "code": "\n\n\nundefined  [16] typeFileNumberOutOfRange_00109022(long fileIndex,uint *typeIndices,undefined8 unusedParam1,undefined8 unusedParam2)\n\n{\n  uint typeIndex;\n  char *errorMessage;\n  long *result;\n  long loopCounter;\n  uint currentIndex;\n  long **typeDataPtr;\n  byte byteVar;\n  undefined returnVal [16];\n  \n  byteVar = 0;\n  currentIndex = *typeIndices;\n  typeIndex = typeIndices[1];\n  if (((int)currentIndex < 0) || (*(uint *)(fileIndex + 0x80) <= currentIndex)) {\n    errorMessage = (char *)dcgettext(0,\"Type file number %d out of range\\n\",5);\n    fprintf(_stderr,errorMessage,(ulong)currentIndex);\n  }\n  else {\n    if (-1 < (int)typeIndex) {\n      typeDataPtr = (long **)(*(long *)(fileIndex + 0x88) + (long)(int)currentIndex * 8);\n      for (currentIndex = typeIndex; 0xf < (int)currentIndex; currentIndex = currentIndex - 0x10) {\n        if (*typeDataPtr == (long *)0x0) {\n          result = (long *)xmalloc(0x88);\n          *typeDataPtr = result;\n          for (loopCounter = 0x22; loopCounter != 0; loopCounter = loopCounter + -1) {\n            *(undefined4 *)result = 0;\n            result = (long *)((long)result + (ulong)byteVar * -8 + 4);\n          }\n        }\n        typeDataPtr = (long **)*typeDataPtr;\n      }\n      if (*typeDataPtr == (long *)0x0) {\n        result = (long *)xmalloc(0x88);\n        *typeDataPtr = result;\n        for (loopCounter = 0x22; loopCounter != 0; loopCounter = loopCounter + -1) {\n          *(undefined4 *)result = 0;\n          result = (long *)((long)result + (ulong)byteVar * -8 + 4);\n        }\n      }\n      result = *typeDataPtr + (long)(int)((typeIndex >> 4) * -0x10 + typeIndex) + 1;\n      goto LAB_00109117;\n    }\n    errorMessage = (char *)dcgettext(0,\"Type index number %d out of range\\n\",5);\n    fprintf(_stderr,errorMessage,(ulong)typeIndex);\n  }\n  result = (long *)0x0;\nLAB_00109117:\n  returnVal._8_8_ = unusedParam2;\n  returnVal._0_8_ = result;\n  return returnVal;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109022",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "type_file_number_out_of_range_00109022"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104910",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "FUN_0010c05d": {
            "renaming": {
                "FUN_0010c05d": "debug_record_variable_0010c05d",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "param_5": "arg5",
                "param_6": "arg6",
                "auVar1": "result1",
                "auVar9": "result2",
                "piVar3": "ptr1",
                "cVar4": "var1",
                "lVar5": "var2",
                "lVar6": "var3",
                "piVar7": "ptr2",
                "bVar8": "var4",
                "uVar2": "returnValue",
                "dcgettext": "get_debug_message",
                "_stderr": "debug_output_stream",
                "fprintf": "print_debug_message",
                "xmalloc": "allocate_memory"
            },
            "code": "\n\n\nundefined  [16]\ndebug_record_variable_0010c05d(long arg1,long arg2,ulong arg3,int arg4,undefined8 arg5,\n            undefined8 arg6)\n\n{\n  undefined result1 [16];\n  undefined8 returnValue;\n  int *ptr1;\n  char var1;\n  long var2;\n  long var3;\n  int *ptr2;\n  byte var4;\n  undefined result2 [16];\n  \n  var4 = 0;\n  if (arg2 == 0) {\n    result1._8_8_ = 0;\n    result1._0_8_ = arg3;\n    return result1 << 0x40;\n  }\n  if (arg3 != 0) {\n    if ((*(long *)(arg1 + 8) == 0) || (var3 = *(long *)(arg1 + 0x10), var3 == 0)) {\n      returnValue = dcgettext(0,\"debug_record_variable_0010c05d: no current file\",5);\n      fprintf(debug_output_stream,\"%s\\n\",returnValue);\n    }\n    else {\n      if (arg4 - 1U < 2) {\n        var3 = var3 + 0x10;\n        var1 = (arg4 == 1) + '\\x01';\n      }\n      else if (*(long *)(arg1 + 0x20) == 0) {\n        var3 = var3 + 0x10;\n        var1 = '\\0';\n      }\n      else {\n        var3 = *(long *)(arg1 + 0x20) + 0x28;\n        var1 = '\\0';\n      }\n      var3 = FUN_00112925(var3,arg2,2,var1);\n      if (var3 != 0) {\n        ptr1 = (int *)xmalloc(0x18);\n        ptr2 = ptr1 + 1;\n        for (var2 = 5; var2 != 0; var2 = var2 + -1) {\n          *ptr2 = 0;\n          ptr2 = ptr2 + (ulong)var4 * -2 + 1;\n        }\n        *ptr1 = arg4;\n        returnValue = 1;\n        *(ulong *)(ptr1 + 2) = arg3;\n        *(undefined8 *)(ptr1 + 4) = arg5;\n        *(int **)(var3 + 0x20) = ptr1;\n        goto LAB_0010c12e;\n      }\n    }\n  }\n  returnValue = 0;\nLAB_0010c12e:\n  result2._8_8_ = arg6;\n  result2._0_8_ = returnValue;\n  return result2;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc",
                "FUN_00112925"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c05d",
            "calling": [
                "FUN_0010c139",
                "FUN_0010c1c6",
                "FUN_0011173a",
                "FUN_00112a33"
            ],
            "imported": false,
            "current_name": "debug_record_variable_0010c05d"
        },
        "FUN_00109d97": {
            "renaming": {
                "FUN_00109d97": "process_data_00109d97",
                "param_1": "data",
                "lVar1": "count",
                "local_40": "message"
            },
            "code": "\nvoid processData_00109d97(long data)\n\n{\n  long count;\n  char message [40];\n  \n  if (*(long *)(data + 0x70) != 0) {\n    FUN_00109cf4(data,*(long *)(data + 0x70),0);\n    return;\n  }\n  count = *(long *)(data + 0x68);\n  *(long *)(data + 0x68) = count + 1;\n  sprintf(message,\"%ld=%ld\",count,count);\n  FUN_00109b52(data,message,count,0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109b52",
                "sprintf",
                "FUN_00109cf4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109d97",
            "calling": [
                "FUN_0010a424",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_data_00109d97"
        },
        "FUN_001086af": {
            "renaming": {
                "FUN_001086af": "extract_build_attribute_notes_001086af",
                "param_7": "param7",
                "uVar1": "result",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "bVar4": "flag",
                "puVar5": "pointerVar",
                "iVar6": "indexVar",
                "lVar7": "longVar",
                "uVar8": "temp3",
                "uVar9": "minValue",
                "uVar10": "maxValue",
                "uVar11": "param7Copy",
                "__ptr": "ptr1",
                "in_RCX": "inRCX",
                "uVar12": "param9Copy",
                "uVar13": "param9Copy2",
                "uVar14": "var14",
                "unaff_RBX": "unaffRBX",
                "unaff_RBP": "unaffRBP",
                "unaff_R12": "unaffR12",
                "unaff_R13": "unaffR13",
                "unaff_retaddr": "unaffRetAddr",
                "param_8": "param8",
                "param_9": "param9",
                "param_10": "param10",
                "param_11": "param11",
                "param_13": "param13",
                "param_14": "param14",
                "bVar22": "byteVar",
                "iVar23": "temp4",
                "in_stack_00000030": "stackVar1",
                "in_stack_00000038": "stackVar2"
            },
            "code": "\nulong extractBuildAttributeNotes_001086af(void)\n\n{\n  ulong result;\n  undefined8 temp1;\n  undefined8 temp2;\n  bool flag;\n  ulong *pointerVar;\n  int indexVar;\n  long longVar;\n  undefined8 temp3;\n  ulong minValue;\n  ulong maxValue;\n  ulong param7Copy;\n  undefined *ptr1;\n  ulong inRCX;\n  ulong param9Copy;\n  ulong param9Copy2;\n  ulong var14;\n  ulong unaffRBX;\n  ulong unaffRBP;\n  ulong *presult5;\n  undefined *presult6;\n  char cVar17;\n  undefined *presult8;\n  undefined *presult9;\n  ulong *unaffR12;\n  ulong unaffR13;\n  ulong temp10;\n  size_t __nmemb;\n  undefined8 *unaff_R14;\n  ulong *ptemp11;\n  byte byteVar;\n  int temp4;\n  ulong unaffRetAddr;\n  ulong param7;\n  uint param8;\n  ulong param9;\n  ulong param10;\n  ulong *param11;\n  undefined *stackVar1;\n  uint stackVar2;\n  uint param13;\n  undefined8 *param14;\n  \n  byteVar = 0;\n  param7 = inRCX;\n  minValue = (**(code **)(unaff_R14[1] + 0x40))();\n  maxValue = (**(code **)(unaff_R14[1] + 0x40))(unaffR12[4] + 4);\nLAB_0011662a:\n  param9Copy2 = unaffRBP;\n  temp10 = unaffR13;\n  if (maxValue < minValue) {\n    minValue = maxValue;\n  }\n  do {\n    param7Copy = param7;\n    param9Copy = param7;\n    presult5 = unaffR12;\n    if (unaffR12[2] == 0x100) {\n      if (minValue == 0) {\n        minValue = unaffRetAddr;\n      }\n      var14 = *unaffR12;\n      unaffR12[7] = minValue;\n      unaffRBP = param9Copy2;\n      unaffR13 = maxValue;\n      unaffRetAddr = minValue;\n      if (maxValue == 0) goto LAB_001164af;\n    }\n    else {\n      if (minValue == 0) {\n        minValue = param9;\n      }\n      var14 = *unaffR12;\n      unaffR12[7] = minValue;\n      unaffRBP = maxValue;\n      unaffR13 = temp10;\n      param9 = minValue;\n      if (maxValue == 0) goto LAB_0011669e;\n    }\nLAB_001164bb:\n    presult5[8] = maxValue;\n    if (*(char *)((presult5[3] - 1) + var14) != '\\0') {\n      longVar = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    unaffR12 = presult5 + 9;\n    if (unaffRBX < 0xc) {\n      if (unaffRBX != 0) {\n        longVar = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n        goto LAB_0010849a;\n      }\n      if ((stackVar2 | param13 | param8) != 0) {\n        if (((param13 | param8) == 0) || (stackVar2 == 0)) {\n          if (param13 == 0) {\n            if (param8 != 0) goto LAB_0011671b;\n            goto LAB_001166f8;\n          }\n          if (param8 == 0) goto LAB_001166f8;\n        }\n        longVar = dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n        goto LAB_0010849a;\n      }\n      temp1 = *unaff_R14;\n      temp2 = *param14;\n      temp3 = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      FUN_00119ed0(temp3,temp1,temp2);\nLAB_0011671b:\n      __nmemb = ((long)unaffR12 - (long)param11 >> 3) * -0x71c71c71c71c71c7;\n      qsort(param11,__nmemb,0x48,FUN_0011a1b0);\n      presult5 = param11;\n      goto LAB_001167f9;\n    }\n    maxValue = (**(code **)(unaff_R14[1] + 0x40))(param9Copy);\n    *unaffR12 = maxValue;\n    maxValue = (**(code **)(unaff_R14[1] + 0x40))(param9Copy + 4);\n    presult5[10] = maxValue;\n    minValue = (**(code **)(unaff_R14[1] + 0x40))(param9Copy + 8);\n    var14 = *unaffR12;\n    presult5[0xb] = minValue;\n    maxValue = presult5[10];\n    param9Copy2 = var14 + 3 & 0xfffffffffffffffc;\n    presult5[0xf] = param9Copy2;\n    if (maxValue != (maxValue + 3 & 0xfffffffffffffffc)) {\n      longVar = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5);\n      goto LAB_0010849a;\n    }\n    if (1 < minValue - 0x100) {\n      longVar = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n      goto LAB_0010849a;\n    }\n    param7Copy = param9Copy2 + maxValue + 0xc;\n    if (unaffRBX < param7Copy) {\n      longVar = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n      goto LAB_0010849a;\n    }\n    if (var14 < 2) {\n      longVar = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n      goto LAB_0010849a;\n    }\n    presult5[0xc] = param9Copy + 0xc;\n    result = param9Copy + 0xc + param9Copy2;\n    presult5[0xd] = result;\n    unaffRBX = unaffRBX + (-0xc - (param9Copy2 + maxValue));\n    param7Copy = param9Copy + param7Copy;\n    if (var14 != 2) {\n      if (*(char *)(param9Copy + 0xc) == '$') {\n        if ((*(char *)(param9Copy + 0xd) == '\\x01') && (*(char *)(param9Copy + 0xe) == '1')) {\n          maxValue = FUN_00116490();\n          return maxValue;\n        }\n      }\n      else if ((((4 < var14) && (*(char *)(param9Copy + 0xc) == 'G')) &&\n               (*(char *)(param9Copy + 0xd) == 'A')) &&\n              ((*(char *)(param9Copy + 0xe) == '$' && (*(char *)(param9Copy + 0xf) == '\\x01')))) {\n        if (*(char *)(param9Copy + 0x10) == '2') {\n          maxValue = FUN_00116490();\n          return maxValue;\n        }\n        if (*(char *)(param9Copy + 0x10) == '3') {\n          maxValue = FUN_00116490();\n          return maxValue;\n        }\n        longVar = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n        goto LAB_0010849a;\n      }\n    }\n    param9Copy2 = unaffRBP;\n    temp10 = unaffR13;\n    if (maxValue == 0) {\n      if (minValue == 0x100) {\n        presult5[0x10] = unaffRetAddr;\nLAB_001164af:\n        param9Copy = param7Copy;\n        maxValue = temp10;\n        presult5 = unaffR12;\n        unaffR13 = temp10;\n      }\n      else {\n        presult5[0x10] = param9;\nLAB_0011669e:\n        unaffRBP = param9Copy2;\n        param9Copy = param7Copy;\n        maxValue = param9Copy2;\n        presult5 = unaffR12;\n        unaffR13 = temp10;\n      }\n      goto LAB_001164bb;\n    }\n    if (maxValue == 0x10) break;\n    if (0x10 < maxValue) {\nLAB_00116679:\n      longVar = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\nLAB_0010849a:\n      if (longVar != 0) {\n        bfd_set_error(0x11);\n        FUN_001126c0(0,unaff_R14,param14,longVar);\n        DAT_00127a40 = 1;\n      }\n      goto LAB_001166f8;\n    }\n    if (maxValue != 4) {\n      if (maxValue == 8) {\n        maxValue = extractBuildAttributeNotes_001086af();\n        return maxValue;\n      }\n      goto LAB_00116679;\n    }\n    param7 = param7Copy;\n    minValue = (**(code **)(unaff_R14[1] + 0x40))();\n    maxValue = 0xffffffffffffffff;\n  } while( true );\n  param7 = param7Copy;\n  minValue = (**(code **)(unaff_R14[1] + 0x28))(result);\n  maxValue = (**(code **)(unaff_R14[1] + 0x28))();\n  goto LAB_0011662a;\nLAB_001167f9:\n  if (unaffR12 <= presult5) {\n    qsort(param11,__nmemb,0x48,FUN_0011a250);\n    ptr1 = (undefined *)xmalloc(param10 * 2);\n    param7 = 0;\n    param9 = 0;\n    presult9 = ptr1;\n    for (presult5 = param11; presult5 < unaffR12; presult5 = presult5 + 9) {\n      if (presult5[2] != 0) {\n        presult8 = presult9 + 4;\n        presult6 = presult9 + 0xc;\n        if ((presult5[7] == param9) && (presult5[8] == param7)) {\n          (**(code **)(unaff_R14[1] + 0x50))(*presult5,presult9);\n          (**(code **)(unaff_R14[1] + 0x50))(0,presult8);\n          (**(code **)(unaff_R14[1] + 0x50))(presult5[2],presult9 + 8);\n          minValue = presult5[6];\n          maxValue = *presult5;\n          presult9 = (undefined *)presult5[3];\n          presult8 = presult6;\n          for (param9Copy2 = maxValue; param9Copy2 != 0; param9Copy2 = param9Copy2 - 1) {\n            *presult8 = *presult9;\n            presult9 = presult9 + (ulong)byteVar * -2 + 1;\n            presult8 = presult8 + (ulong)byteVar * -2 + 1;\n          }\n          if (maxValue < minValue) {\n            for (longVar = minValue - maxValue; longVar != 0; longVar = longVar + -1) {\n              *presult8 = 0;\n              presult8 = presult8 + (ulong)byteVar * -2 + 1;\n            }\n          }\n          presult9 = presult6 + minValue;\n        }\n        else {\n          (**(code **)(unaff_R14[1] + 0x50))();\n          if (*(int *)(unaff_R14[1] + 8) == 5) {\n            cVar17 = (*(char *)(unaff_R14[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n          }\n          else {\n            cVar17 = '\\b';\n          }\n          (**(code **)(unaff_R14[1] + 0x50))(cVar17,presult8);\n          (**(code **)(unaff_R14[1] + 0x50))(presult5[2],presult9 + 8);\n          maxValue = *presult5;\n          presult9 = (undefined *)presult5[3];\n          presult8 = presult6;\n          for (minValue = maxValue; minValue != 0; minValue = minValue - 1) {\n            *presult8 = *presult9;\n            presult9 = presult9 + (ulong)byteVar * -2 + 1;\n            presult8 = presult8 + (ulong)byteVar * -2 + 1;\n          }\n          minValue = presult5[6];\n          if (maxValue < minValue) {\n            for (longVar = minValue - maxValue; longVar != 0; longVar = longVar + -1) {\n              *presult8 = 0;\n              presult8 = presult8 + (ulong)byteVar * -2 + 1;\n            }\n          }\n          longVar = unaff_R14[1];\n          presult6 = presult6 + minValue;\n          presult9 = presult6 + 8;\n          if ((*(int *)(longVar + 8) == 5) && (*(char *)(unaff_R14[0x22] + 4) == '\\x02')) {\n            (**(code **)(longVar + 0x38))(presult5[7],presult6);\n            (**(code **)(unaff_R14[1] + 0x38))(presult5[8],presult9);\n            presult9 = presult6 + 0x10;\n          }\n          else {\n            (**(code **)(longVar + 0x50))(presult5[7],presult6);\n            (**(code **)(unaff_R14[1] + 0x50))(presult5[8],presult6 + 4);\n          }\n          param9 = presult5[7];\n          param7 = presult5[8];\n        }\n      }\n    }\n    minValue = (long)presult9 - (long)ptr1;\n    maxValue = minValue;\n    presult9 = ptr1;\n    if (minValue < param10) {\n      for (; param10 = minValue, maxValue != 0; maxValue = maxValue - 1) {\n        *stackVar1 = *presult9;\n        presult9 = presult9 + (ulong)byteVar * -2 + 1;\n        stackVar1 = stackVar1 + (ulong)byteVar * -2 + 1;\n      }\n    }\n    free(ptr1);\nLAB_001166f8:\n    free(param11);\n    return param10;\n  }\n  if (presult5[2] != 0) {\n    maxValue = presult5[7];\n    minValue = presult5[8];\n    param9Copy2 = presult5[2];\n    ptemp11 = presult5;\n    temp4 = 0;\n    if (maxValue == minValue) {\n      presult5[2] = 0;\n    }\n    else {\n      do {\n        do {\n          pointerVar = ptemp11;\n          ptemp11 = pointerVar + -9;\n          if (ptemp11 < param11) goto LAB_001167f5;\n          temp10 = pointerVar[-7];\n        } while (temp10 == 0);\n        param7 = param9Copy2;\n        if ((*ptemp11 != *presult5) ||\n           (indexVar = memcmp((void *)pointerVar[-6],(void *)presult5[3],*presult5), indexVar != 0)) break;\n        param9Copy2 = pointerVar[-2];\n        param7Copy = pointerVar[-1];\n        if (maxValue == param9Copy2) {\n          if (minValue == param7Copy) {\n            presult5[2] = 0;\n            break;\n          }\nLAB_001167a6:\n          if (minValue <= param7Copy) {\n            presult5[2] = 0;\n            break;\n          }\n          if (param7Copy < maxValue) {\nLAB_0010852c:\n            if ((0xfffffffffffffff0 < param7Copy) || (maxValue <= (param7Copy + 0xf & 0xfffffffffffffff0)))\n            goto FUN_00116852;\n          }\nLAB_001167b8:\n          if ((param7 == 0x101) == (temp10 == 0x101)) {\n            if (param7Copy <= minValue) {\n              param7Copy = minValue;\n            }\n            if (param9Copy2 < maxValue) {\n              maxValue = param9Copy2;\n            }\n            pointerVar[-1] = param7Copy;\n            pointerVar[-2] = maxValue;\n            presult5[2] = 0;\n            break;\n          }\n        }\n        else {\n          if (param9Copy2 <= maxValue) goto LAB_001167a6;\n          if (param7Copy < maxValue) goto LAB_0010852c;\n          if (minValue < maxValue) {\n            if ((0xfffffffffffffff0 < minValue) || (param9Copy2 <= (minValue + 0xf & 0xfffffffffffffff0)))\n            goto FUN_00116852;\n            goto LAB_001167b8;\n          }\n          if (minValue != param7Copy) goto LAB_001167b8;\n        }\nFUN_00116852:\n        flag = temp4 < 0x11;\n        param9Copy2 = param7;\n        temp4 = temp4 + 1;\n      } while (flag);\n    }\n  }\nLAB_001167f5:\n  presult5 = presult5 + 9;\n  goto LAB_001167f9;\n}\n\n",
            "called": [
                "dcgettext",
                "bfd_set_error",
                "FUN_00119ed0",
                "FUN_0011a1b0",
                "FUN_0010847a",
                "FUN_00116490",
                "qsort",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001086af",
            "calling": [
                "FUN_00116490"
            ],
            "imported": false,
            "current_name": "extract_build_attribute_notes_001086af"
        },
        "bfd_octets_per_byte": {
            "renaming": {},
            "code": "\nvoid bfd_octets_per_byte(void)\n\n{\n  bfd_octets_per_byte();\n  return;\n}\n\n",
            "called": [
                "bfd_octets_per_byte"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104520",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_octets_per_byte"
        },
        "FUN_0010add5": {
            "renaming": {
                "FUN_0010add5": "initialize_system_0010add5"
            },
            "code": "\nvoid initializeSystem_0010add5(void)\n\n{\n  FUN_0010abdd();\n  return;\n}\n\n",
            "called": [
                "FUN_0010abdd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010add5",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_system_0010add5"
        },
        "FUN_00113e17": {
            "renaming": {
                "FUN_00113e17": "initialize_components_00113e17"
            },
            "code": "\nvoid initializeComponents_00113e17(void)\n\n{\n  FUN_00112904(2,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e17",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_components_00113e17"
        },
        "FUN_00109b52": {
            "renaming": {
                "FUN_00109b52": "initialize_data_structure_00109b52",
                "param_1": "dataStructureAddress",
                "param_2": "sourceString",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "uVar1": "tempVar1",
                "puVar2": "allocatedMemory",
                "uVar3": "duplicatedString"
            },
            "code": "\nundefined initializeDataStructure_00109b52(long dataStructureAddress,undefined8 sourceString,undefined8 param3,undefined param4,\n                      undefined4 param5)\n\n{\n  undefined8 tempVar1;\n  undefined8 *allocatedMemory;\n  undefined8 duplicatedString;\n  \n  allocatedMemory = (undefined8 *)xmalloc(0x40);\n  duplicatedString = xstrdup(sourceString);\n  allocatedMemory[2] = param3;\n  *(undefined (*) [16])(allocatedMemory + 4) = ZEXT816(0);\n  *(undefined (*) [16])(allocatedMemory + 6) = ZEXT816(0);\n  tempVar1 = *(undefined8 *)(dataStructureAddress + 0x60);\n  *(undefined *)((long)allocatedMemory + 0x1c) = param4;\n  *(undefined4 *)(allocatedMemory + 3) = param5;\n  *(undefined8 **)(dataStructureAddress + 0x60) = allocatedMemory;\n  *allocatedMemory = tempVar1;\n  allocatedMemory[1] = duplicatedString;\n  return 1;\n}\n\n",
            "called": [
                "xmalloc",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109b52",
            "calling": [
                "FUN_0010e453",
                "FUN_0010a69a",
                "FUN_00109ed3",
                "FUN_00109e76",
                "FUN_0010a181",
                "FUN_0010b948",
                "FUN_00109cf4",
                "FUN_0010a424",
                "FUN_00109d97",
                "FUN_0010b800",
                "FUN_0010a0e9",
                "FUN_0010a2b9",
                "FUN_0010a377",
                "FUN_0010a77a",
                "FUN_00109dfe"
            ],
            "imported": false,
            "current_name": "initialize_data_structure_00109b52"
        },
        "FUN_00109a32": {
            "renaming": {
                "FUN_00109a32": "parse_and_convert_string_00109a32",
                "param_1": "string_ptr",
                "param_2": "conversion_error_ptr",
                "param_3": "end_of_string",
                "param_4": "unused_param_4",
                "param_5": "unused_param_5",
                "__nptr": "current_position",
                "piVar1": "errno_ptr",
                "uVar2": "converted_value",
                "uVar3": "error_message",
                "auVar4": "result"
            },
            "code": "\nundefined  [16]\nparse_and_convert_string_00109a32(char **string_ptr,undefined *conversion_error_ptr,char *end_of_string,undefined8 unused_param_4,undefined8 unused_param_5)\n\n{\n  char *current_position;\n  int *errno_ptr;\n  ulong converted_value;\n  undefined8 error_message;\n  undefined result [16];\n  \n  if (conversion_error_ptr != (undefined *)0x0) {\n    *conversion_error_ptr = 0;\n  }\n  current_position = *string_ptr;\n  if ((current_position < end_of_string) && (*current_position != '\\0')) {\n    errno_ptr = __errno_location();\n    *errno_ptr = 0;\n    converted_value = strtoul(current_position,string_ptr,0);\n    if ((converted_value != 0xffffffffffffffff) || (*errno_ptr == 0)) goto LAB_00109aa9;\n    if (conversion_error_ptr == (undefined *)0x0) {\n      error_message = dcgettext(0,\"numeric overflow\",5);\n      FUN_00108fe8(current_position,error_message);\n    }\n    else {\n      *conversion_error_ptr = 1;\n    }\n  }\n  converted_value = 0;\nLAB_00109aa9:\n  result._8_8_ = unused_param_5;\n  result._0_8_ = converted_value;\n  return result;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00108fe8",
                "__errno_location",
                "strtoul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109a32",
            "calling": [
                "FUN_0010ee3f",
                "FUN_00109ab1"
            ],
            "imported": false,
            "current_name": "parse_and_convert_string_00109a32"
        },
        "FUN_0010c6be": {
            "renaming": {
                "FUN_0010c6be": "process_debug_tag_0010c6be",
                "param_1": "file_handle",
                "param_2": "tag_name",
                "param_3": "tag_ptr",
                "iVar1": "comparison_result",
                "uVar2": "localized_message",
                "piVar3": "tag_result",
                "pauVar4": "tag_data",
                "lVar5": "offset",
                "pcVar6": "error_message"
            },
            "code": "\n\n\nint * process_debug_tag_0010c6be(long file_handle,char *tag_name,int *tag_ptr)\n\n{\n  int comparison_result;\n  undefined8 localized_message;\n  int *tag_result;\n  undefined (*tag_data) [16];\n  long offset;\n  char *error_message;\n  \n  if ((tag_name != (char *)0x0) && (tag_ptr != (int *)0x0)) {\n    if (*(long *)(file_handle + 0x10) == 0) {\n      error_message = \"debug_tag_type: no current file\";\n    }\n    else {\n      if (*tag_ptr != 0x17) {\n        tag_result = (int *)FUN_00112904(0x17,0);\n        if (tag_result == (int *)0x0) {\n          return (int *)0x0;\n        }\n        tag_data = (undefined (*) [16])xmalloc(0x10);\n        offset = *(long *)(file_handle + 0x10);\n        *tag_data = ZEXT816(0);\n        *(int **)(*tag_data + 8) = tag_ptr;\n        *(undefined (**) [16])(tag_result + 4) = tag_data;\n        offset = FUN_00112925(offset + 0x10,tag_name,1,3);\n        if (offset == 0) {\n          return (int *)0x0;\n        }\n        *(int **)(offset + 0x20) = tag_result;\n        *(long *)*tag_data = offset;\n        return tag_result;\n      }\n      comparison_result = strcmp(*(char **)(**(long **)(tag_ptr + 4) + 8),tag_name);\n      error_message = \"debug_tag_type: extra tag attempted\";\n      if (comparison_result == 0) {\n        return tag_ptr;\n      }\n    }\n    localized_message = dcgettext(0,error_message,5);\n    fprintf(_stderr,\"%s\\n\",localized_message);\n  }\n  return (int *)0x0;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc",
                "FUN_00112904",
                "FUN_00112925",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c6be",
            "calling": [
                "FUN_0010c892",
                "FUN_0011173a",
                "FUN_00112a33"
            ],
            "imported": false,
            "current_name": "process_debug_tag_0010c6be"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047f0",
            "calling": [
                "FUN_00119970",
                "FUN_00108a2a",
                "FUN_00108916"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "FUN_0010b6ea": {
            "renaming": {
                "FUN_0010b6ea": "demangler_0010b6ea",
                "param_1": "input_param1",
                "param_2": "input_param2",
                "param_3": "arg_list",
                "param_4": "error_flag",
                "__ptr": "result_list",
                "__format": "error_message",
                "lVar1": "temp_result",
                "uVar2": "result_count",
                "uVar3": "result_capacity",
                "uVar4": "temp_counter",
                "local_39": "temp_array"
            },
            "code": "\n\n\nvoid * demangler_0010b6ea(undefined8 input_param1,undefined8 input_param2,int *arg_list,undefined *error_flag)\n\n{\n  void *result_list;\n  char *error_message;\n  long temp_result;\n  ulong result_count;\n  ulong result_capacity;\n  uint temp_counter;\n  char temp_array [9];\n  \n  result_capacity = 10;\n  result_count = 0;\n  result_list = (void *)xmalloc(0x50);\n  *error_flag = 0;\n  for (; arg_list != (int *)0x0; arg_list = *(int **)(arg_list + 6)) {\n    if (*arg_list != 0x2e) {\n      error_message = (char *)dcgettext(0,\"Unexpected type in v3 arglist demangling\\n\",5);\n      fprintf(_stderr,error_message);\n      free(result_list);\n      return (void *)0x0;\n    }\n    if (*(long *)(arg_list + 4) == 0) break;\n    temp_result = FUN_0010b0fa(input_param1,input_param2,*(long *)(arg_list + 4),0,temp_array);\n    if (temp_result == 0) {\n      if (temp_array[0] == '\\0') {\n        free(result_list);\n        return (void *)0x0;\n      }\n      *error_flag = 1;\n    }\n    else {\n      temp_counter = (int)result_count + 1;\n      if ((uint)result_capacity <= temp_counter) {\n        result_capacity = (ulong)((uint)result_capacity + 10);\n        result_list = (void *)xrealloc(result_list,result_capacity << 3);\n      }\n      *(long *)((long)result_list + result_count * 8) = temp_result;\n      result_count = (ulong)temp_counter;\n    }\n  }\n  *(undefined8 *)((long)result_list + result_count * 8) = 0;\n  return result_list;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc",
                "free",
                "xrealloc",
                "FUN_0010b0fa"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b6ea",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "demangler_0010b6ea"
        },
        "FUN_0011a2e0": {
            "renaming": {
                "FUN_0011a2e0": "extract_section_from_binary_0011a2e0",
                "param_1": "binary_header",
                "param_2": "binary_file",
                "uVar1": "section_header",
                "uVar2": "error_message",
                "lVar3": "section_info",
                "lVar4": "section_address"
            },
            "code": "\nlong extract_section_from_binary_0011a2e0(long binary_header,long binary_file)\n\n{\n  undefined8 section_header;\n  undefined8 error_message;\n  long section_info;\n  long section_address;\n  \n  section_info = (**(code **)(*(long *)(binary_file + 8) + 0x208))(binary_file);\n  section_address = *(long *)(binary_header + 0x20);\n  *(undefined8 *)(section_info + 8) = *(undefined8 *)(binary_header + 8);\n  *(undefined8 *)(section_info + 0x10) = *(undefined8 *)(binary_header + 0x10);\n  *(undefined4 *)(section_info + 0x18) = *(undefined4 *)(binary_header + 0x18);\n  if (section_address == 0) {\n    section_address = 0x128598;\n  }\n  else {\n    section_address = bfd_get_section_by_name(binary_file);\n    if (section_address == 0) {\n      section_header = *(undefined8 *)(binary_header + 0x20);\n      error_message = dcgettext(0,\"Section %s not found\",5);\n                    \n      FUN_00119dd0(error_message,section_header);\n    }\n  }\n  *(long *)(section_info + 0x20) = section_address;\n  return section_info;\n}\n\n",
            "called": [
                "FUN_00108808",
                "bfd_get_section_by_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a2e0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "extract_section_from_binary_0011a2e0"
        },
        "FUN_0010e8a9": {
            "renaming": {
                "FUN_0010e8a9": "format_and_send_data_0010e8a9",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "inputString",
                "uVar1": "returnValue",
                "sVar2": "inputStringLength",
                "__s": "formattedData"
            },
            "code": "\nundefined4 formatAndSendData_0010e8a9(undefined8 data1,undefined8 data2,char *inputString)\n\n{\n  undefined4 returnValue;\n  size_t inputStringLength;\n  char *formattedData;\n  \n  inputStringLength = strlen(inputString);\n  formattedData = (char *)xmalloc(inputStringLength + 0x14);\n  sprintf(formattedData,\"%s:c=f%g\",data1,inputString);\n  returnValue = FUN_0010e2f0(data2,0x80,0,0,formattedData);\n  if ((char)returnValue != '\\0') {\n    free(formattedData);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_0010e2f0",
                "sprintf",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e8a9",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "format_and_send_data_0010e8a9"
        },
        "FUN_00104ad6": {
            "renaming": {
                "FUN_00104ad6": "parse_section_flags_00104ad6",
                "unaff_R14D": "sectionFlags",
                "unaff_R15": "sectionFlag",
                "unaff_RBP": "sectionString",
                "__s": "currentString",
                "sVar4": "length",
                "iVar1": "comparisonResult",
                "iVar5": "stringLength",
                "pcVar3": "delimiter",
                "uVar2": "errorMessage"
            },
            "code": "\nundefined  [16] parseSectionFlags_00104ad6(void)\n\n{\n  int comparisonResult;\n  undefined8 errorMessage;\n  char *delimiter;\n  char *sectionString;\n  char *currentString;\n  size_t length;\n  int stringLength;\n  uint sectionFlags;\n  char *sectionFlag;\n  undefined auVar6 [16];\n  undefined8 unaff_retaddr;\n  \n  do {\n    sectionFlags = sectionFlags | 0x2000;\n    currentString = sectionString;\n    while( true ) {\n      while( true ) {\n        while( true ) {\n          while( true ) {\n            while( true ) {\n              if (currentString == (char *)0x0) {\n                auVar6._4_4_ = 0;\n                auVar6._0_4_ = sectionFlags;\n                auVar6._8_8_ = unaff_retaddr;\n                return auVar6;\n              }\n              delimiter = strchr(currentString,0x2c);\n              if (delimiter == (char *)0x0) {\n                length = strlen(currentString);\n                stringLength = (int)length;\n                sectionString = (char *)0x0;\n              }\n              else {\n                sectionString = delimiter + 1;\n                stringLength = (int)delimiter - (int)currentString;\n              }\n              length = (size_t)stringLength;\n              comparisonResult = strncasecmp(sectionFlag,currentString,length);\n              if (comparisonResult != 0) break;\n              sectionFlags = sectionFlags | 1;\n              currentString = sectionString;\n            }\n            comparisonResult = strncasecmp(\"load\",currentString,length);\n            if (comparisonResult != 0) break;\n            sectionFlags = sectionFlags | 2;\n            currentString = sectionString;\n          }\n          comparisonResult = strncasecmp(\"noload\",currentString,length);\n          if (comparisonResult != 0) break;\n          sectionFlags = sectionFlags | 0x200;\n          currentString = sectionString;\n        }\n        comparisonResult = strncasecmp(\"readonly\",currentString,length);\n        if (comparisonResult != 0) break;\n        sectionFlags = sectionFlags | 8;\n        currentString = sectionString;\n      }\n      comparisonResult = strncasecmp(\"debug\",currentString,length);\n      if (comparisonResult == 0) break;\n      comparisonResult = strncasecmp(\"code\",currentString,length);\n      if (comparisonResult == 0) {\n        sectionFlags = sectionFlags | 0x10;\n        currentString = sectionString;\n      }\n      else {\n        comparisonResult = strncasecmp(\"data\",currentString,length);\n        if (comparisonResult == 0) {\n          sectionFlags = sectionFlags | 0x20;\n          currentString = sectionString;\n        }\n        else {\n          comparisonResult = strncasecmp(\"rom\",currentString,length);\n          if (comparisonResult == 0) {\n            sectionFlags = sectionFlags | 0x40;\n            currentString = sectionString;\n          }\n          else {\n            comparisonResult = strncasecmp(\"exclude\",currentString,length);\n            if (comparisonResult == 0) {\n              sectionFlags = sectionFlags | 0x8000;\n              currentString = sectionString;\n            }\n            else {\n              comparisonResult = strncasecmp(\"share\",currentString,length);\n              if (comparisonResult == 0) {\n                sectionFlags = sectionFlags | 0x8000000;\n                currentString = sectionString;\n              }\n              else {\n                comparisonResult = strncasecmp(\"contents\",currentString,length);\n                if (comparisonResult == 0) {\n                  sectionFlags = sectionFlags | 0x100;\n                  currentString = sectionString;\n                }\n                else {\n                  comparisonResult = strncasecmp(\"merge\",currentString,length);\n                  if (comparisonResult == 0) {\n                    sectionFlags = sectionFlags | 0x800000;\n                    currentString = sectionString;\n                  }\n                  else {\n                    comparisonResult = strncasecmp(\"strings\",currentString,length);\n                    if (comparisonResult != 0) {\n                      delimiter = (char *)xmalloc((long)(stringLength + 1));\n                      strncpy(delimiter,currentString,length);\n                      delimiter[length] = '\\0';\n                      errorMessage = dcgettext(0,\"unrecognized section flag `%s\\'\",5);\n                      FUN_00119ed0(errorMessage,delimiter);\n                      errorMessage = dcgettext(0,\"supported flags: %s\",5);\n                    \n                      FUN_00119dd0(errorMessage,\n                                   \"alloc, load, noload, readonly, debug, code, data, rom, exclude, share, contents, merge, strings\"\n                                  );\n                    }\n                    sectionFlags = sectionFlags | 0x1000000;\n                    currentString = sectionString;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "strncasecmp",
                "strncpy",
                "strchr",
                "FUN_00119ed0",
                "FUN_00104ad6",
                "FUN_00119dd0",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104ad6",
            "calling": [
                "FUN_00104ad6"
            ],
            "imported": false,
            "current_name": "parse_section_flags_00104ad6"
        },
        "htab_find": {
            "renaming": {},
            "code": "\nvoid htab_find(void)\n\n{\n  htab_find();\n  return;\n}\n\n",
            "called": [
                "htab_find"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047d0",
            "calling": [
                "FUN_00108d9a",
                "FUN_0010554f",
                "FUN_00115d70"
            ],
            "imported": false,
            "current_name": "htab_find"
        },
        "FUN_001087da": {
            "renaming": {
                "FUN_001087da": "check_rax_value_001087da",
                "in_RAX": "inputValue",
                "auVar1": "result",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] checkRAXValue_001087da(void)\n\n{\n  long inputValue;\n  undefined result [16];\n  undefined8 returnAddress;\n  \n  result._1_7_ = 0;\n  result[0] = inputValue == 0x100;\n  result._8_8_ = returnAddress;\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001087da",
            "calling": [
                "FUN_0011a1b0"
            ],
            "imported": false,
            "current_name": "check_rax_value_001087da"
        },
        "__assert_fail": {
            "renaming": {},
            "code": "\n\n\nvoid __assert_fail(char *__assertion,char *__file,uint __line,char *__function)\n\n{\n                    \n  __assert_fail(__assertion,__file,__line,__function);\n}\n\n",
            "called": [
                "__assert_fail"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104300",
            "calling": [
                "FUN_001125fa",
                "FUN_0010c7a0",
                "FUN_0010bbd3",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "__assert_fail"
        },
        "FUN_0010914e": {
            "renaming": {
                "FUN_0010914e": "find_named_type_0010914e",
                "param_1": "compilation_unit",
                "param_2": "type_name",
                "param_3": "arg_3",
                "param_4": "arg_4",
                "lVar1": "current_compilation",
                "iVar2": "comparison_result",
                "uVar3": "error_message",
                "puVar4": "ptr_4",
                "puVar6": "ptr_6",
                "auVar7": "result"
            },
            "code": "\n\n\nundefined  [16] find_named_type_0010914e(long compilation_unit,char *type_name,undefined8 arg_3,undefined8 arg_4)\n\n{\n  long current_compilation;\n  int comparison_result;\n  undefined8 error_message;\n  undefined8 *ptr_4;\n  long lVar5;\n  undefined8 *ptr_6;\n  undefined result [16];\n  \n  current_compilation = *(long *)(compilation_unit + 8);\n  if (current_compilation == 0) {\n    error_message = dcgettext(0,\"debug_find_named_type_0010914e: no current compilation unit\",5);\n    fprintf(_stderr,\"%s\\n\",error_message);\n  }\n  else {\n    for (lVar5 = *(long *)(compilation_unit + 0x20); lVar5 != 0; lVar5 = *(long *)(lVar5 + 8)) {\n      if (*(undefined8 **)(lVar5 + 0x28) != (undefined8 *)0x0) {\n        for (ptr_4 = (undefined8 *)**(undefined8 **)(lVar5 + 0x28); ptr_4 != (undefined8 *)0x0;\n            ptr_4 = (undefined8 *)*ptr_4) {\n          if (*(int *)((long)ptr_4 + 0x14) == 0) {\n            if (*(char *)ptr_4[1] == *type_name) {\n              comparison_result = strcmp((char *)ptr_4[1],type_name);\n              if (comparison_result == 0) goto LAB_00109216;\n            }\n          }\n        }\n      }\n    }\n    for (ptr_6 = *(undefined8 **)(current_compilation + 8); ptr_6 != (undefined8 *)0x0;\n        ptr_6 = (undefined8 *)*ptr_6) {\n      if ((undefined8 *)ptr_6[2] != (undefined8 *)0x0) {\n        for (ptr_4 = *(undefined8 **)(undefined8 *)ptr_6[2]; ptr_4 != (undefined8 *)0x0;\n            ptr_4 = (undefined8 *)*ptr_4) {\n          if (*(int *)((long)ptr_4 + 0x14) == 0) {\n            if (*(char *)ptr_4[1] == *type_name) {\n              comparison_result = strcmp((char *)ptr_4[1],type_name);\n              if (comparison_result == 0) goto LAB_00109216;\n            }\n          }\n        }\n      }\n    }\n  }\n  error_message = 0;\nLAB_00109223:\n  result._8_8_ = arg_4;\n  result._0_8_ = error_message;\n  return result;\nLAB_00109216:\n  error_message = ptr_4[4];\n  goto LAB_00109223;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010914e",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010c95e",
                "FUN_0010d559"
            ],
            "imported": false,
            "current_name": "find_named_type_0010914e"
        },
        "FUN_0010829e": {
            "renaming": {
                "FUN_0010829e": "check_condition_0010829e",
                "unaff_EBP": "condition",
                "uVar1": "result"
            },
            "code": "\nundefined8 checkCondition_0010829e(void)\n\n{\n  undefined8 result;\n  int condition;\n  \n  if (condition == 5) {\n    result = FUN_00113ede();\n    return result;\n  }\n  if ((condition != 4) && (condition == 6)) {\n    result = FUN_001082b3();\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_001082b3",
                "FUN_00113ede"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010829e",
            "calling": [
                "FUN_00115b70"
            ],
            "imported": false,
            "current_name": "check_condition_0010829e"
        },
        "bfd_set_error": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043a0",
            "calling": [
                "FUN_0010554f",
                "FUN_001086af",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_set_error"
        },
        "bindtextdomain": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104220",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bindtextdomain"
        },
        "filename_cmp": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041a0",
            "calling": [
                "FUN_00116b90",
                "FUN_0010edb4",
                "FUN_00108f08"
            ],
            "imported": false,
            "current_name": "filename_cmp"
        },
        "FUN_00104943": {
            "renaming": {
                "FUN_00104943": "print_reverse_arch_mach_00104943",
                "in_RAX": "inputString",
                "lVar3": "convertedNumber",
                "iVar1": "defaultValue",
                "iVar2": "strcmpResult",
                "iVar7": "archIter",
                "iVar9": "stringIter",
                "param_7": "maxStringLength",
                "uStack000000000000000c": "indentationWidth",
                "param_11": "programData",
                "param_13": "stringArray",
                "unaff_R15D": "initialStringOffset",
                "uVar10": "stringLength",
                "uVar11": "archIndex",
                "pcVar5": "archName",
                "lVar8": "stringOffset",
                "sVar4": "stringLen",
                "uVar6": "printableArchMach"
            },
            "code": "\n\n\nvoid printReverseArchMach_00104943(void)\n\n{\n  int defaultValue;\n  int strcmpResult;\n  char *inputString;\n  long convertedNumber;\n  size_t stringLen;\n  char *archName;\n  undefined8 printableArchMach;\n  int archIter;\n  long stringOffset;\n  int stringIter;\n  uint initialStringOffset;\n  ulong stringLength;\n  uint archIndex;\n  int maxStringLength;\n  uint indentationWidth;\n  undefined8 programData;\n  long stringArray;\n  \n  convertedNumber = strtol(inputString,(char **)0x0,10);\n  defaultValue = (int)convertedNumber;\n  stringIter = maxStringLength;\n  indentationWidth = initialStringOffset;\n  if (defaultValue == 0) {\n    defaultValue = 0x50;\n  }\n  do {\n    maxStringLength = stringIter;\n    if (programData._4_4_ <= maxStringLength) {\n      return;\n    }\n    stringOffset = (long)maxStringLength;\n    archIter = (defaultValue - indentationWidth) + -1;\n    convertedNumber = stringOffset;\n    do {\n      stringIter = (int)convertedNumber;\n      if (programData._4_4_ <= stringIter) break;\n      stringLen = strlen(*(char **)(stringArray + convertedNumber * 0x60));\n      convertedNumber = convertedNumber + 1;\n      archIter = (archIter - (int)stringLen) + -1;\n    } while (-1 < archIter);\n    printf(\"\\n%*s\",(ulong)(indentationWidth + 1),&DAT_0011b4a1);\n    for (convertedNumber = stringOffset * 0x60; ((ulong)(uint)(stringIter - maxStringLength) + stringOffset) * 0x60 - convertedNumber != 0;\n        convertedNumber = convertedNumber + 0x60) {\n      printf(\"%s \",*(undefined8 *)(stringArray + convertedNumber));\n    }\n    archIter = 2;\n    putc(10,_stdout);\n    do {\n      archName = (char *)bfd_printable_arch_mach(archIter,0);\n      strcmpResult = strcmp(archName,\"UNKNOWN!\");\n      if (strcmpResult != 0) {\n        printableArchMach = bfd_printable_arch_mach(archIter,0);\n        printf(\"%*s \",(ulong)indentationWidth,printableArchMach);\n        archIndex = archIter - 2;\n        convertedNumber = stringOffset * 0x60;\n        strcmpResult = maxStringLength;\n        while (stringIter != strcmpResult) {\n          archName = *(char **)(stringArray + convertedNumber);\n          if (*(char *)((long)(char **)(stringArray + convertedNumber) + (ulong)archIndex + 8) == '\\0') {\n            stringLen = strlen(archName);\n            for (stringLength = stringLen & 0xffffffff; (int)stringLength != 0; stringLength = (ulong)((int)stringLength - 1)) {\n              putc(0x2d,_stdout);\n            }\n          }\n          else {\n            fputs(archName,_stdout);\n          }\n          strcmpResult = strcmpResult + 1;\n          if (stringIter != strcmpResult) {\n            putc(0x20,_stdout);\n          }\n          convertedNumber = convertedNumber + 0x60;\n        }\n        putc(10,_stdout);\n      }\n      archIter = archIter + 1;\n    } while (archIter != 0x57);\n  } while( true );\n}\n\n",
            "called": [
                "strcmp",
                "printf",
                "fputs",
                "bfd_printable_arch_mach",
                "strtol",
                "putc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104943",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "print_reverse_arch_mach_00104943"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046e0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "FUN_00113e23": {
            "renaming": {
                "FUN_00113e23": "store_parameters_in_memory_00113e23",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "lVar1": "memoryAddress",
                "puVar2": "newMemoryBlock"
            },
            "code": "\nlong storeParametersInMemory_00113e23(undefined8 inputParam1,undefined8 inputParam2)\n\n{\n  long memoryAddress;\n  undefined8 *newMemoryBlock;\n  \n  memoryAddress = FUN_00112904(1,0);\n  if (memoryAddress != 0) {\n    newMemoryBlock = (undefined8 *)xmalloc(0x10);\n    *newMemoryBlock = inputParam1;\n    newMemoryBlock[1] = inputParam2;\n    *(undefined8 **)(memoryAddress + 0x10) = newMemoryBlock;\n  }\n  return memoryAddress;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e23",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010afd5",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "store_parameters_in_memory_00113e23"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043f0",
            "calling": [
                "FUN_00104a35",
                "FUN_00108b3e",
                "FUN_0011256b"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "bfd_scan_arch": {
            "renaming": {},
            "code": "\nvoid bfd_scan_arch(void)\n\n{\n  bfd_scan_arch();\n  return;\n}\n\n",
            "called": [
                "bfd_scan_arch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104710",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bfd_scan_arch"
        },
        "FUN_00108fb9": {
            "renaming": {
                "FUN_00108fb9": "print_bad_stab_error_message_00108fb9",
                "param_1": "errorMessage",
                "__format": "formatString"
            },
            "code": "\n\n\nvoid printBadStabErrorMessage_00108fb9(undefined8 errorMessage)\n\n{\n  char *formatString;\n  \n  formatString = (char *)dcgettext(0,\"Bad stab: %s\\n\",5);\n  fprintf(_stderr,formatString,errorMessage);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108fb9",
            "calling": [
                "FUN_0010ee3f",
                "FUN_00109ab1",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "print_bad_stab_error_message_00108fb9"
        },
        "xcalloc": {
            "renaming": {},
            "code": "\nvoid xcalloc(void)\n\n{\n  xcalloc();\n  return;\n}\n\n",
            "called": [
                "xcalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104918",
            "calling": [
                "FUN_001163d0"
            ],
            "imported": false,
            "current_name": "xcalloc"
        },
        "FUN_00108ea1": {
            "renaming": {
                "FUN_00108ea1": "parse_integer_00108ea1",
                "param_1": "input_pointer",
                "param_2": "parsed_integer",
                "iVar1": "current_digit",
                "pbVar2": "current_byte",
                "pbVar3": "next_byte",
                "uVar4": "result"
            },
            "code": "\nulong parse_integer_00108ea1(byte **input_pointer,int *parsed_integer)\n\n{\n  int current_digit;\n  byte *current_byte;\n  byte *next_byte;\n  ulong result;\n  \n  current_byte = *input_pointer;\n  result = 0;\n  if (((&_sch_istable)[(ulong)*current_byte * 2] & 4) != 0) {\n    next_byte = current_byte + 1;\n    current_digit = (char)*current_byte + -0x30;\n    *parsed_integer = current_digit;\n    *input_pointer = next_byte;\n    if (((&_sch_istable)[(ulong)current_byte[1] * 2] & 4) != 0) {\n      do {\n        current_byte = next_byte;\n        current_digit = current_digit * 10 + -0x30 + (int)(char)*current_byte;\n        next_byte = current_byte + 1;\n      } while (((&_sch_istable)[(ulong)current_byte[1] * 2] & 4) != 0);\n      if (current_byte[1] == 0x5f) {\n        next_byte = current_byte + 2;\n        *input_pointer = next_byte;\n        *parsed_integer = current_digit;\n      }\n    }\n    result = CONCAT71((int7)((ulong)next_byte >> 8),1);\n  }\n  return result & 0xffffffff;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108ea1",
            "calling": [
                "FUN_0010d21c",
                "FUN_0010d882",
                "FUN_0010c95e"
            ],
            "imported": false,
            "current_name": "parse_integer_00108ea1"
        },
        "FUN_00108072": {
            "renaming": {
                "FUN_00108072": "set_and_initialize_memory_00108072",
                "bVar1": "flag",
                "uVar2": "result",
                "cVar3": "flag2",
                "uVar4": "value",
                "lVar5": "errorMessage",
                "lVar6": "tempValue1",
                "lVar7": "tempValue2",
                "unaff_RBX": "registers",
                "unaff_RBP": "basePointer",
                "unaff_R12": "register12",
                "lVar8": "offset",
                "unaff_R14B": "flag3",
                "unaff_R15": "register15"
            },
            "code": "\n\n\nvoid setAndInitializeMemory_00108072(void)\n\n{\n  byte flag;\n  undefined8 result;\n  char flag2;\n  uint value;\n  long errorMessage;\n  long tempValue1;\n  long tempValue2;\n  undefined8 *registers;\n  long basePointer;\n  long register12;\n  long offset;\n  char flag3;\n  long register15;\n  \n  errorMessage = dcgettext(0,\"failed to set size\",5);\n  offset = registers[6];\n  tempValue1 = FUN_00114190(*registers,0,0x18);\n  if (tempValue1 == 0) {\n    *(byte *)(register15 + 0x28) = *(byte *)(register15 + 0x28) | 1;\n    result = *registers;\n    offset = offset + _DAT_001279b0;\n    *(long *)(register15 + 0x30) = offset;\n    *(long *)(register15 + 0x38) = offset;\n    offset = registers[7];\n    tempValue1 = FUN_00114190(result,0,0x60);\n    if (tempValue1 == 0) goto LAB_00115695;\nLAB_00115860:\n    tempValue2 = *(long *)(tempValue1 + 0x20);\n    if ((*(byte *)(tempValue1 + 0x14) & 0x40) != 0) {\n      tempValue2 = tempValue2 + offset;\n    }\n    *(long *)(register15 + 0x38) = tempValue2;\n    offset = FUN_00114190(*registers,0,0x200);\n    if (offset != 0) goto LAB_00115889;\nLAB_001156b8:\n    value = *(uint *)((long)registers + 0x7c);\n    if (value < 0x3f) goto LAB_001156c4;\n    errorMessage = dcgettext(0,\"failed to set alignment\",5);\n    *(undefined4 *)(register15 + 0xb4) = *(undefined4 *)((long)registers + 0xb4);\n    *(byte *)(register15 + 0x28) =\n         *(byte *)(register15 + 0x28) & 0xcf | *(byte *)(registers + 5) & 0x30;\n    registers[0xc] = register15;\n    registers[0xb] = 0;\n    flag = *(byte *)((long)registers + 0x27);\n  }\n  else {\n    tempValue2 = *(long *)(tempValue1 + 0x18);\n    if ((*(byte *)(tempValue1 + 0x14) & 8) == 0) {\n      tempValue2 = tempValue2 + offset;\n    }\n    *(byte *)(register15 + 0x28) = *(byte *)(register15 + 0x28) | 1;\n    result = *registers;\n    *(long *)(register15 + 0x30) = tempValue2;\n    *(long *)(register15 + 0x38) = tempValue2;\n    offset = registers[7];\n    tempValue1 = FUN_00114190(result,0,0x60);\n    if (tempValue1 != 0) goto LAB_00115860;\nLAB_00115695:\n    result = *registers;\n    *(long *)(register15 + 0x38) = offset + _DAT_001279b0;\n    offset = FUN_00114190(result,0,0x200);\n    if (offset == 0) goto LAB_001156b8;\nLAB_00115889:\n    value = *(uint *)(offset + 0x2c);\n    if (0x3e < value) {\n      FUN_00108179();\n      return;\n    }\nLAB_001156c4:\n    *(uint *)(register15 + 0x7c) = value;\n    *(undefined4 *)(register15 + 0xb4) = *(undefined4 *)((long)registers + 0xb4);\n    *(byte *)(register15 + 0x28) =\n         *(byte *)(register15 + 0x28) & 0xcf | *(byte *)(registers + 5) & 0x30;\n    registers[0xc] = register15;\n    registers[0xb] = 0;\n    flag = *(byte *)((long)registers + 0x27);\n  }\n  if ((flag & 2) != 0) {\n    offset = registers[0x1a];\n    tempValue1 = FUN_00115d00(offset,registers[0x1c]);\n    if ((tempValue1 != 0) &&\n       (tempValue2 = *(long *)(register12 + 8), *(uint *)(tempValue1 + 0x18) = *(uint *)(tempValue1 + 0x18) | 0x20,\n       *(int *)(tempValue2 + 8) == 5)) {\n      *(long *)(offset + 0xb0) = tempValue1;\n      flag2 = (**(code **)(*(long *)(basePointer + 8) + 0x158))();\n      if (flag2 == '\\0') {\n        FUN_0010808f();\n        return;\n      }\n      goto LAB_0011571e;\n    }\n  }\n  flag2 = (**(code **)(*(long *)(basePointer + 8) + 0x158))();\n  if (flag2 == '\\0') {\n    FUN_0010808f();\n    return;\n  }\nLAB_0011571e:\n  if (flag3 != '\\0') {\n    *(undefined4 *)(*(long *)(register15 + 0xd0) + 4) = 8;\n  }\n  if (errorMessage != 0) {\n    DAT_00127a40 = 1;\n    FUN_001126c0(0);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00114190",
                "dcgettext",
                "FUN_00108179"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108072",
            "calling": [
                "FUN_00115530"
            ],
            "imported": false,
            "current_name": "set_and_initialize_memory_00108072"
        },
        "htab_hash_string": {
            "renaming": {},
            "code": "\nvoid htab_hash_string(void)\n\n{\n  htab_hash_string();\n  return;\n}\n\n",
            "called": [
                "htab_hash_string"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048f8",
            "calling": [
                "FUN_00108800"
            ],
            "imported": false,
            "current_name": "htab_hash_string"
        },
        "FUN_0010a2b9": {
            "renaming": {
                "FUN_0010a2b9": "generate_output_0010a2b9",
                "param_1": "inputAddress",
                "param_2": "flag",
                "param_3": "data1",
                "param_4": "data2",
                "cVar1": "charValue",
                "__s": "string1",
                "sVar2": "length1",
                "__s_00": "string2",
                "lVar3": "counter",
                "auVar4": "result"
            },
            "code": "\nundefined  [16] generateOutput_0010a2b9(long inputAddress,char flag,undefined8 data1,undefined8 data2)\n\n{\n  char charValue;\n  char *string1;\n  size_t length1;\n  char *string2;\n  long counter;\n  undefined result [16];\n  \n  charValue = *(char *)(*(long *)(inputAddress + 0x60) + 0x1c);\n  string1 = (char *)FUN_00109b2f();\n  length1 = strlen(string1);\n  string2 = (char *)xmalloc(length1 + 0x1e);\n  if (flag == '\\0') {\n    *string2 = '\\0';\n    counter = 0;\n    flag = charValue;\n  }\n  else {\n    counter = *(long *)(inputAddress + 0x68);\n    *(long *)(inputAddress + 0x68) = counter + 1;\n    sprintf(string2,\"%ld=@S;\",counter);\n  }\n  length1 = strlen(string2);\n  sprintf(string2 + length1,\"S%s\",string1);\n  free(string1);\n  result._0_4_ = FUN_00109b52(inputAddress,string2,counter,flag,0);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(string2);\n  }\n  result._8_8_ = data2;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00109b52",
                "free",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a2b9",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "generate_output_0010a2b9"
        },
        "bfd_set_section_contents": {
            "renaming": {},
            "code": "\nvoid bfd_set_section_contents(void)\n\n{\n  bfd_set_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_set_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104330",
            "calling": [
                "FUN_00116110",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_set_section_contents"
        },
        "malloc": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045c0",
            "calling": [
                "FUN_00116b90",
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "malloc"
        },
        "FUN_00116ad0": {
            "renaming": {
                "FUN_00116ad0": "FUNC_00116ad0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00116ae3) */\n/* WARNING: Removing unreachable block (ram,0x00116aef) */\n\nvoid FUNC_00116ad0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116ad0",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00116ad0"
        },
        "FUN_0010ec73": {
            "renaming": {
                "FUN_0010ec73": "execute_operation_0010ec73",
                "param_1": "pointers",
                "param_2": "value",
                "param_3": "data1",
                "param_4": "data2",
                "param_5": "data3",
                "param_6": "data4",
                "iVar1": "counter",
                "cVar2": "condition",
                "param_1[0x3c]": "value1",
                "param_1[0x3d]": "value2",
                "param_1[1]": "pointer_value2",
                "param_1[0x40]": "result1",
                "param_1[0x41]": "result2"
            },
            "code": "\nundefined executeOperation_0010ec73(long *pointers,long value,undefined8 data1,undefined8 data2,\n                      undefined8 data3,undefined8 data4)\n\n{\n  int counter;\n  char condition;\n  \n  if (value1 != -1) {\n    (**(code **)(*(long *)(*pointers + 8) + 0x50))(value,pointer_value2 + 8 + value1);\n    value1 = -1;\n  }\n  if (value2 != -1) {\n    (**(code **)(*(long *)(*pointers + 8) + 0x50))(value,pointer_value2 + 8 + value2);\n    value2 = -1;\n  }\n  counter = *(int *)(pointers + 0x3f);\n  *(int *)(pointers + 0x3f) = counter + 1;\n  if (counter == 0) {\n    result1 = value;\n  }\n  else {\n    if ((result2 != -1) &&\n       (condition = FUN_0010e2f0(pointers,0xc0,0,result2,0,data4,data2), condition == '\\0')) {\n      return 0;\n    }\n    result2 = value - result1;\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ec73",
            "calling": [
                "FUN_00113a4d"
            ],
            "imported": false,
            "current_name": "execute_operation_0010ec73"
        },
        "FUN_00114e00": {
            "renaming": {
                "FUN_00114e00": "print_endianness_00114e00",
                "param_1": "endiannessFlag",
                "dcgettext": "translateText"
            },
            "code": "\nvoid printEndianness_00114e00(int endiannessFlag)\n\n{\n  if (endiannessFlag == 0) {\n    dcgettext(0,\"big endian\",5);\n    return;\n  }\n  if (endiannessFlag == 1) {\n    dcgettext(0,\"little endian\",5);\n    return;\n  }\n  dcgettext(0,\"endianness unknown\",5);\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114e00",
            "calling": [
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "print_endianness_00114e00"
        },
        "FUN_00115970": {
            "renaming": {
                "FUN_00115970": "copy_and_unlink_file_00115970",
                "param_1": "source_file",
                "param_2": "destination_file",
                "param_3": "flags",
                "param_4": "mode",
                "param_5": "copy_flag",
                "param_6": "return_value",
                "uVar1": "copy_result",
                "piVar2": "errno_pointer",
                "pcVar3": "error_message",
                "uVar4": "translated_error_message",
                "uVar5": "copy_success",
                "auVar6": "result"
            },
            "code": "\nundefined  [16]\ncopy_and_unlink_file_00115970(char *source_file,char *destination_file,undefined4 flags,undefined8 mode,char copy_flag,\n            undefined8 return_value)\n\n{\n  uint copy_result;\n  int *errno_pointer;\n  char *error_message;\n  undefined8 translated_error_message;\n  ulong copy_success;\n  undefined result [16];\n  \n  if (destination_file == source_file) {\n    copy_success = 0;\n  }\n  else {\n    copy_result = FUN_00115a90(flags,destination_file,mode);\n    copy_success = (ulong)copy_result;\n    if (copy_result != 0) {\n      errno_pointer = __errno_location();\n      error_message = strerror(*errno_pointer);\n      translated_error_message = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      FUN_00119ed0(translated_error_message,destination_file,error_message);\n    }\n    unlink(source_file);\n  }\n  if (copy_flag != '\\0') {\n    FUN_0011a350(destination_file,mode);\n  }\n  result._8_8_ = return_value;\n  result._0_8_ = copy_success;\n  return result;\n}\n\n",
            "called": [
                "FUN_00115a90",
                "FUN_00108200"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115970",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "copy_and_unlink_file_00115970"
        },
        "FUN_0010adf2": {
            "renaming": {
                "FUN_0010adf2": "initialize_system_0010adf2"
            },
            "code": "\nvoid initializeSystem_0010adf2(void)\n\n{\n  FUN_0010abdd();\n  return;\n}\n\n",
            "called": [
                "FUN_0010abdd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010adf2",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_system_0010adf2"
        },
        "fputs": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104310",
            "calling": [
                "FUN_00104943",
                "FUN_001126c0"
            ],
            "imported": false,
            "current_name": "fputs"
        },
        "FUN_0010d7d4": {
            "renaming": {
                "FUN_0010d7d4": "extract_data_0010d7d4",
                "param_1": "input_param",
                "param_2": "output_param",
                "param_3": "data_size",
                "param_4": "data_count",
                "param_5": "max_data_count",
                "uVar1": "input_value",
                "cVar2": "result",
                "uVar3": "processed_result",
                "lVar4": "temp_var",
                "plVar5": "temp_ptr",
                "local_40": "data_buffer",
                "uVar6": "index"
            },
            "code": "\nundefined4\nextract_data_0010d7d4(undefined8 input_param,undefined8 *output_param,long *data_size,uint *data_count,uint *max_data_count)\n\n{\n  undefined8 input_value;\n  char result;\n  undefined4 processed_result;\n  long temp_var;\n  long *temp_ptr;\n  uint index;\n  long data_buffer [2];\n  \n  input_value = *output_param;\n  temp_ptr = data_buffer;\n  if (data_size == (long *)0x0) {\n    temp_ptr = (long *)0x0;\n  }\n  result = FUN_0010c95e(input_param,output_param,temp_ptr);\n  if ((result != '\\0') &&\n     (processed_result = FUN_00109be3(input_param,input_value,(int)*output_param - (int)input_value), (char)processed_result != '\\0')) {\n    if (data_size == (long *)0x0) {\n      return processed_result;\n    }\n    if (data_buffer[0] != 0) {\n      if (*max_data_count <= *data_count + 1) {\n        index = *max_data_count + 10;\n        temp_var = *data_size;\n        *max_data_count = index;\n        temp_var = xrealloc(temp_var,(ulong)index << 3);\n        *data_size = temp_var;\n      }\n      index = *data_count;\n      *(long *)(*data_size + (ulong)index * 8) = data_buffer[0];\n      *data_count = index + 1;\n      return processed_result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "xrealloc",
                "FUN_00109be3",
                "FUN_0010c95e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d7d4",
            "calling": [
                "FUN_0010d882"
            ],
            "imported": false,
            "current_name": "extract_data_0010d7d4"
        },
        "FUN_00113f50": {
            "renaming": {
                "FUN_00113f50": "check_file_00113f50",
                "param_1": "filePath",
                "iVar1": "result",
                "piVar2": "error",
                "uVar3": "errorMessage",
                "pcVar4": "errorDescription",
                "sStack_a8": "fileStats"
            },
            "code": "\nlong checkFile_00113f50(char *filePath)\n\n{\n  int result;\n  int *error;\n  undefined8 errorMessage;\n  char *errorDescription;\n  stat fileStats;\n  \n  if (filePath != (char *)0x0) {\n    result = stat(filePath,&fileStats);\n    if (result < 0) {\n      error = __errno_location();\n      if (*error == 2) {\n        errorMessage = dcgettext(0,\"\\'%s\\': No such file\",5);\n        FUN_00119ed0(errorMessage,filePath);\n      }\n      else {\n        errorDescription = strerror(*error);\n        errorMessage = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        FUN_00119ed0(errorMessage,filePath,errorDescription);\n      }\n    }\n    else if ((fileStats.st_mode & 0xf000) == 0x4000) {\n      errorMessage = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      FUN_00119ed0(errorMessage,filePath);\n    }\n    else if ((fileStats.st_mode & 0xf000) == 0x8000) {\n      if (-1 < fileStats.st_size) {\n        return fileStats.st_size;\n      }\n      errorMessage = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      FUN_00119ed0(errorMessage,filePath);\n    }\n    else {\n      errorMessage = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      FUN_00119ed0(errorMessage,filePath);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "dcgettext",
                "stat",
                "FUN_00119ed0",
                "FUN_00104966"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113f50",
            "calling": [
                "FUN_00116b90",
                "FUN_00114460",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "check_file_00113f50"
        },
        "FUN_001087fd": {
            "renaming": {
                "FUN_001087fd": "initialize_and_return_zero_001087fd"
            },
            "code": "\nundefined8 initialize_and_return_zero_001087fd(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001087fd",
            "calling": [
                "FUN_0011a250"
            ],
            "imported": false,
            "current_name": "initialize_and_return_zero_001087fd"
        },
        "FUN_0011256b": {
            "renaming": {
                "FUN_0011256b": "print_matching_formats_0011256b",
                "param_1": "formats",
                "uVar1": "dataPointer",
                "__format": "formatString",
                "plVar2": "currentFormat"
            },
            "code": "\n\n\nvoid printMatchingFormats_0011256b(long *formats)\n\n{\n  undefined8 dataPointer;\n  char *formatString;\n  long *currentFormat;\n  \n  fflush(_stdout);\n  dataPointer = DAT_00127600;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,formatString,dataPointer);\n  for (currentFormat = formats; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(formats);\n  fputc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "fputc",
                "free",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011256b",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "print_matching_formats_0011256b"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045e0",
            "calling": [
                "FUN_0010871c",
                "FUN_00119e70",
                "FUN_0011256b",
                "FUN_001126c0"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "FUN_0011378f": {
            "renaming": {
                "FUN_0011378f": "deobfuscate_and_extract_info_0011378f",
                "param_1": "input_ptr",
                "param_2": "output_ptr",
                "param_3": "output_len_ptr",
                "param_4": "output_hash_ptr",
                "param_5": "output_strings_ptr",
                "param_6": "output_unique_ptr",
                "auVar1": "temp_array",
                "cVar2": "result",
                "uVar3": "error_code",
                "uVar4": "error_msg",
                "puVar5": "output_strings",
                "sVar6": "string_len",
                "lVar7": "loop_counter",
                "puVar8": "temp_ptr",
                "puVar9": "temp_var_ptr",
                "__dest": "dest_ptr",
                "puVar10": "temp_var_ptr2",
                "plVar11": "temp_long_ptr",
                "bVar12": "flag",
                "local_258": "input_ptr",
                "local_250": "allocated_mem",
                "local_248": "var1",
                "uStack_244": "var2",
                "uStack_240": "var3",
                "uStack_23c": "var4",
                "local_238": "temp_array2",
                "local_228": "var5",
                "local_220": "temp_array3",
                "local_1f8": "var6",
                "local_1f0": "var7",
                "local_1e8": "temp_array4",
                "local_a0": "temp_array5",
                "local_78": "var8",
                "uStack_70": "var9",
                "local_68": "var10",
                "local_60": "var11",
                "local_58": "var12",
                "uStack_54": "var13",
                "uStack_50": "var14",
                "uStack_4c": "var15",
                "unique0x100000e9": "constant1",
                "unique0x100000ed": "constant2"
            },
            "code": "\nundefined4\ndeobfuscate_and_extract_info_0011378f(undefined8 *input_ptr,undefined8 *output_ptr,long *output_len_ptr,undefined8 *output_hash_ptr,\n            undefined8 *output_strings_ptr,undefined8 *output_unique_ptr)\n\n{\n  undefined temp_array [16];\n  char result;\n  undefined4 error_code;\n  undefined8 error_msg;\n  undefined *output_strings;\n  size_t string_len;\n  long loop_counter;\n  undefined8 *temp_ptr;\n  undefined4 *temp_var_ptr;\n  char *dest_ptr;\n  undefined8 *temp_var_ptr2;\n  long *temp_long_ptr;\n  byte flag;\n  undefined8 *input_ptr;\n  long allocated_mem;\n  undefined4 var1;\n  undefined4 var2;\n  undefined4 var3;\n  undefined4 var4;\n  undefined temp_array2 [16];\n  undefined8 var5;\n  undefined temp_array3 [40];\n  undefined8 var6;\n  undefined8 var7;\n  undefined4 temp_array4 [82];\n  undefined temp_array5 [40];\n  undefined var8 [8];\n  undefined8 var9;\n  undefined8 var10;\n  undefined4 var11;\n  undefined4 var12;\n  undefined4 var13;\n  undefined4 var14;\n  undefined4 var15;\n  \n  flag = 0;\n  var1 = 0;\n  var2 = 0;\n  var3 = 500;\n  var4 = 0;\n  input_ptr = input_ptr;\n  allocated_mem = xmalloc(500);\n  var5 = 1;\n  temp_array2 = ZEXT816(0);\n  result = bfd_hash_table_init(temp_array3,FUN_0010bb52,0x30);\n  if ((result == '\\0') || (result = bfd_hash_table_init(temp_array5,FUN_0010bb52,0x30), result == '\\0')) {\n    error_code = bfd_get_error();\n    error_msg = bfd_errmsg(error_code);\n    FUN_00119ed0(\"bfd_hash_table_init_failed: %s\",error_msg);\n  }\n  else {\n    var6 = 0;\n    constant1 = 0xffffffff;\n    var8 = (undefined  [8])0xffffffffffffffff;\n    constant2 = 0xffffffff;\n    temp_var_ptr = temp_array4;\n    for (loop_counter = 0x52; loop_counter != 0; loop_counter = loop_counter + -1) {\n      *temp_var_ptr = 0;\n      temp_var_ptr = temp_var_ptr + (ulong)flag * -2 + 1;\n    }\n    var10 = 0;\n    var11 = 0;\n    var7 = 1;\n    var12 = 0;\n    var13 = 0;\n    var14 = 0xffffffff;\n    var15 = 0xffffffff;\n    result = FUN_0010e2f0(&input_ptr,0,0,0,0);\n    temp_array = _var8;\n    if (result != '\\0') {\n      var8._4_4_ = var2;\n      var8._0_4_ = var1;\n      var9 = temp_array._8_8_;\n      result = FUN_0010e2f0(&input_ptr,100,0,0,*input_ptr);\n      if (result != '\\0') {\n        *(int *)(output_ptr + 6) = *(int *)(output_ptr + 6) + 1;\n        output_ptr[10] = 0;\n        temp_var_ptr2 = (undefined8 *)*output_ptr;\n        *(undefined4 *)(output_ptr + 7) = *(undefined4 *)((long)output_ptr + 0x34);\n        for (; temp_var_ptr2 != (undefined8 *)0x0; temp_var_ptr2 = (undefined8 *)*temp_var_ptr2) {\n          output_ptr[8] = temp_var_ptr2[2];\n          *(undefined4 *)(output_ptr + 9) = 0;\n          result = thunk_FUN_0010e439(&input_ptr,*(undefined8 *)(temp_var_ptr2[1] + 8));\n          if (result == '\\0') {\n            return 0;\n          }\n          temp_long_ptr = (long *)temp_var_ptr2[1];\n          if (temp_long_ptr != (long *)0x0) {\n            while( true ) {\n              if ((undefined8 *)temp_long_ptr[2] != (undefined8 *)0x0) {\n                for (temp_ptr = *(undefined8 **)(undefined8 *)temp_long_ptr[2]; temp_ptr != (undefined8 *)0x0;\n                    temp_ptr = (undefined8 *)*temp_ptr) {\n                  result = FUN_001135a5(output_ptr,&input_ptr);\n                  if (result == '\\0') {\n                    return 0;\n                  }\n                }\n              }\n              temp_long_ptr = (long *)*temp_long_ptr;\n              if (temp_long_ptr == (long *)0x0) break;\n              result = FUN_0010e439(&input_ptr,temp_long_ptr[1]);\n              if (result == '\\0') {\n                return 0;\n              }\n            }\n          }\n          result = FUN_00112502(output_ptr,&input_ptr,0xffffffffffffffff);\n          if (result == '\\0') {\n            return 0;\n          }\n        }\n        if ((CONCAT44(var15,var14) == -1) &&\n           (error_code = FUN_0010e2f0(&input_ptr,100,0,var10,0), (char)error_code != '\\0')) {\n          (**(code **)(input_ptr[1] + 0x50))(var5,allocated_mem + 8);\n          *output_len_ptr = allocated_mem;\n          *output_hash_ptr = CONCAT44(var2,var1);\n          *output_unique_ptr = var5;\n          output_strings = (undefined *)xmalloc();\n          *output_strings = 0;\n          dest_ptr = output_strings + 1;\n          *output_strings_ptr = output_strings;\n          for (loop_counter = temp_array2._0_8_; loop_counter != 0; loop_counter = *(long *)(loop_counter + 0x18)) {\n            strcpy(dest_ptr,*(char **)(loop_counter + 8));\n            string_len = strlen(dest_ptr);\n            dest_ptr = dest_ptr + string_len + 1;\n          }\n          return error_code;\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_001135a5",
                "xmalloc",
                "FUN_00119ed0",
                "bfd_errmsg",
                "thunk_FUN_0010e439",
                "bfd_hash_table_init",
                "FUN_0010e439",
                "strlen",
                "strcpy",
                "FUN_00112502",
                "bfd_get_error",
                "FUN_0010e2f0",
                "FUN_0010bb52"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011378f",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "deobfuscate_and_extract_info_0011378f"
        },
        "FUN_00104966": {
            "renaming": {
                "FUN_00104966": "handle_file_error_00104966",
                "piVar1": "errPtr",
                "uVar2": "errorMessage"
            },
            "code": "\nundefined8 handleFileError_00104966(void)\n\n{\n  int *errPtr;\n  undefined8 errorMessage;\n  \n  errPtr = __errno_location();\n  if (*errPtr == 2) {\n    errorMessage = dcgettext(0,\"\\'%s\\': No such file\",5);\n    FUN_00119ed0(errorMessage);\n  }\n  else {\n    strerror(*errPtr);\n    errorMessage = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    FUN_00119ed0(errorMessage);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "dcgettext",
                "__errno_location",
                "FUN_00119ed0",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104966",
            "calling": [
                "FUN_00113f50"
            ],
            "imported": false,
            "current_name": "handle_file_error_00104966"
        },
        "FUN_0010a0a0": {
            "renaming": {
                "FUN_0010a0a0": "initialize_data_0010a0a0",
                "param_1": "inputData"
            },
            "code": "\nvoid initializeData_0010a0a0(long inputData)\n\n{\n  FUN_00109ed3(inputData,0x26,4,inputData + 0x198,inputData + 0x1a0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109ed3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0a0",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "initialize_data_0010a0a0"
        },
        "FUN_00119ed0": {
            "renaming": {
                "FUN_00119ed0": "process_data_00119ed0",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "param_4": "data4",
                "param_5": "data5",
                "param_6": "data6",
                "param_7": "data7",
                "param_8": "data8",
                "param_9": "pointer1",
                "param_10": "pointer2",
                "param_11": "pointer3",
                "param_12": "pointer4",
                "param_13": "pointer5",
                "param_14": "pointer6",
                "in_AL": "condition",
                "local_d8": "bufferSize",
                "local_d4": "localVar1",
                "local_d0": "localVar2",
                "local_c8": "localVar3",
                "local_b8": "localArray",
                "local_b0": "pointer7",
                "local_a8": "pointer8",
                "local_a0": "pointer9",
                "local_98": "pointer10",
                "local_90": "pointer11",
                "local_88": "localVar4",
                "local_78": "localVar5",
                "local_68": "localVar6",
                "local_58": "localVar7",
                "local_48": "localVar8",
                "local_38": "localVar9",
                "local_28": "localVar10",
                "local_18": "localVar11"
            },
            "code": "\nvoid processData_00119ed0(undefined4 data1,undefined4 data2,undefined4 data3,undefined4 data4,\n                 undefined4 data5,undefined4 data6,undefined4 data7,undefined4 data8,\n                 undefined8 pointer1,undefined8 pointer2,undefined8 pointer3,undefined8 pointer4,\n                 undefined8 pointer5,undefined8 pointer6)\n\n{\n  char condition;\n  undefined4 bufferSize;\n  undefined4 localVar1;\n  undefined *localVar2;\n  undefined *localVar3;\n  undefined localArray [8];\n  undefined8 pointer7;\n  undefined8 pointer8;\n  undefined8 pointer9;\n  undefined8 pointer10;\n  undefined8 pointer11;\n  undefined4 localVar4;\n  undefined4 localVar5;\n  undefined4 localVar6;\n  undefined4 localVar7;\n  undefined4 localVar8;\n  undefined4 localVar9;\n  undefined4 localVar10;\n  undefined4 localVar11;\n  \n  if (condition != '\\0') {\n    localVar4 = data1;\n    localVar5 = data2;\n    localVar6 = data3;\n    localVar7 = data4;\n    localVar8 = data5;\n    localVar9 = data6;\n    localVar10 = data7;\n    localVar11 = data8;\n  }\n  localVar2 = &stack0x00000008;\n  bufferSize = 8;\n  localVar3 = localArray;\n  localVar1 = 0x30;\n  pointer7 = pointer2;\n  pointer8 = pointer3;\n  pointer9 = pointer4;\n  pointer10 = pointer5;\n  pointer11 = pointer6;\n  FUN_00119e70(pointer1,&bufferSize);\n  return;\n}\n\n",
            "called": [
                "FUN_00119e70"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119ed0",
            "calling": [
                "FUN_00104cc1",
                "FUN_00108375",
                "FUN_00116b90",
                "FUN_001163d0",
                "FUN_00104966",
                "FUN_00104ea2",
                "FUN_00113f50",
                "FUN_001086af",
                "FUN_0010882c",
                "FUN_00105828",
                "FUN_0010e6a8",
                "FUN_0010b800",
                "FUN_00108200",
                "FUN_00107880",
                "FUN_0010e07c",
                "FUN_00104ad6",
                "FUN_0011378f",
                "FUN_0010e2f0",
                "FUN_0010554f",
                "FUN_001152b6",
                "FUN_0010dac0",
                "FUN_00114690",
                "FUN_00114e50",
                "FUN_0010ba08"
            ],
            "imported": false,
            "current_name": "process_data_00119ed0"
        },
        "FUN_00112c1f": {
            "renaming": {
                "FUN_00112c1f": "reverse_and_improve_00112c1f",
                "param_1": "param_address",
                "param_2": "param_value",
                "param_3": "param_array",
                "param_4": "param_value_2",
                "plVar1": "pointer_value_1",
                "lVar2": "long_value",
                "puVar3": "pointer_value_2",
                "puVar4": "pointer_value_3",
                "cVar5": "char_value",
                "piVar6": "pi_value",
                "uVar7": "return_value",
                "local_3c": "local_value"
            },
            "code": "\n\n\nundefined8 reverse_and_improve_00112c1f(ulong param_address,undefined8 param_value,int *param_array,long param_value_2)\n\n{\n  long *pointer_value_1;\n  long long_value;\n  undefined8 *pointer_value_2;\n  undefined8 *pointer_value_3;\n  char char_value;\n  int *pi_value;\n  undefined8 return_value;\n  undefined8 uVar8;\n  int iVar9;\n  undefined4 uVar10;\n  undefined8 uVar11;\n  ulong uVar12;\n  uint uVar13;\n  bool bVar14;\n  uint local_value;\n  \n  uVar12 = param_address;\nLAB_00112c39:\n  if (param_array != (int *)0x0) {\n    iVar9 = *param_array;\n    if (iVar9 - 0x16U < 2) {\n      do {\n        pointer_value_1 = *(long **)(param_array + 4);\n        uVar13 = *(uint *)(param_address + 0x30);\n        uVar12 = (ulong)uVar13;\n        long_value = *pointer_value_1;\n        if (*(uint *)(long_value + 0x10) == uVar13) {\n          if (iVar9 == 0x16) {\n            return_value = FUN_0010bba1(param_value,*(undefined8 *)(long_value + 8));\n            return return_value;\n          }\nLAB_00112c94:\n          pi_value = (int *)FUN_00112b6e(param_array,0);\n          if (pi_value == (int *)0x0) goto LAB_00112dd6;\n          if ((*pi_value - 7U < 4) && (*(long *)(pi_value + 4) != 0)) {\n            if ((*(uint *)(*(long *)(pi_value + 4) + 0xc) <= *(uint *)(param_address + 0x38)) &&\n               (char_value = FUN_0010c7a0(param_address,*(undefined8 *)(**(long **)(param_array + 4) + 8),pi_value),\n               char_value == '\\0')) {\n              return 0;\n            }\n            uVar13 = *(uint *)(*(long *)(pi_value + 4) + 0xc);\n          }\n          else {\n            uVar13 = 0;\n          }\n          iVar9 = *pi_value;\n          return_value = *(undefined8 *)(**(long **)(param_array + 4) + 8);\n          goto LAB_00112ed2;\n        }\n        if (iVar9 == 0x17) {\n          if (long_value != param_value_2) goto LAB_00112c94;\n          *(uint *)(param_value_2 + 0x10) = uVar13;\n          param_value_2 = *pointer_value_1;\n          param_array = (int *)pointer_value_1[1];\n          goto LAB_00112c39;\n        }\n        if (param_value_2 != 0) {\n          *(uint *)(param_value_2 + 0x10) = uVar13;\n        }\n        param_array = (int *)pointer_value_1[1];\n        if (param_array == (int *)0x0) goto LAB_00112dd6;\n        iVar9 = *param_array;\n        param_value_2 = 0;\n      } while (iVar9 - 0x16U < 2);\nLAB_00112d74:\n      return_value = 0;\n    }\n    else {\n      if (param_value_2 == 0) goto LAB_00112d74;\n      *(undefined4 *)(param_value_2 + 0x10) = *(undefined4 *)(param_address + 0x30);\n      if (*(int *)(param_value_2 + 0x14) != 1) {\n                    \n        __assert_fail(\"name->kind == DEBUG_OBJECT_TAG\",\"../../binutils/debug.c\",0x9b3,\n                      \"debug_write_type\");\n      }\n      return_value = *(undefined8 *)(param_value_2 + 8);\n    }\n    switch(iVar9) {\n    case 0:\n      return_value = dcgettext(0,\"debug_write_type: illegal type encountered\",5);\n      fprintf(_stderr,\"%s\\n\",return_value);\n      return 0;\n    case 1:\n      goto switchD_00112d8e_caseD_1;\n    case 2:\n      return_value = FUN_00109dfe(param_value);\n      return return_value;\n    case 3:\n      return_value = FUN_0010b800(param_value,param_array[1],*(undefined *)(param_array + 4));\n      return return_value;\n    case 4:\n      return_value = FUN_0010b948(param_value,param_array[1]);\n      return return_value;\n    case 5:\n      return_value = FUN_00109e76(param_value,param_array[1]);\n      return return_value;\n    case 6:\n      return_value = FUN_00109d3e(param_value,param_array[1]);\n      return return_value;\n    case 7:\n    case 8:\n      if (*(long *)(param_array + 4) != 0) {\n        if ((*(uint *)(*(long *)(param_array + 4) + 0xc) <= *(uint *)(param_address + 0x38)) &&\n           (char_value = FUN_0010c7a0(param_address,return_value,param_array), char_value == '\\0')) {\n          return 0;\n        }\n        long_value = *(long *)(param_array + 4);\n        if (*(int *)(param_address + 0x30) == *(int *)(long_value + 8)) {\n          uVar13 = *(uint *)(long_value + 0xc);\n          if (uVar13 <= *(uint *)(param_address + 0x38)) {\n                    \n            __assert_fail(\"type->u.kclass->id > info->base_id\",\"../../binutils/debug.c\",0x9db,\n                          \"debug_write_type\");\n          }\n          iVar9 = *param_array;\nLAB_00112ed2:\n          return_value = FUN_00109d5c(param_value,return_value,uVar13,iVar9);\n          return return_value;\n        }\n        *(int *)(long_value + 8) = *(int *)(param_address + 0x30);\n      }\n      uVar10 = 0;\n      if (*(long *)(param_array + 4) != 0) {\n        uVar10 = *(undefined4 *)(*(long *)(param_array + 4) + 0xc);\n      }\n      char_value = FUN_0010a69a(param_value,return_value,uVar10,*param_array == 7,param_array[1]);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      if ((*(long **)(param_array + 4) != (long *)0x0) && (uVar12 = 0, **(long **)(param_array + 4) != 0)) {\n        while( true ) {\n          pointer_value_3 = *(undefined8 **)(**(long **)(param_array + 4) + uVar12 * 8);\n          if (pointer_value_3 == (undefined8 *)0x0) break;\n          char_value = reverse_and_improve_00112c1f(param_address,param_value,pointer_value_3[1],0);\n          if (char_value == '\\0') {\n            return 0;\n          }\n          char_value = FUN_0010ba08(param_value,*pointer_value_3,*(undefined4 *)(pointer_value_3 + 3),\n                               *(undefined4 *)((long)pointer_value_3 + 0x1c),*(undefined4 *)(pointer_value_3 + 2));\n          if (char_value == '\\0') {\n            return 0;\n          }\n          uVar12 = (ulong)((int)uVar12 + 1);\n        }\n      }\n      return_value = FUN_0010a77a(param_value);\n      return return_value;\n    case 9:\n    case 10:\n      if (*(long *)(param_array + 4) == 0) {\n        uVar13 = 0;\n        pi_value = (int *)0x0;\n      }\n      else {\n        if ((*(uint *)(*(long *)(param_array + 4) + 0xc) <= *(uint *)(param_address + 0x38)) &&\n           (uVar12 = param_address, char_value = FUN_0010c7a0(param_address,return_value,param_array), char_value == '\\0')) {\n          return 0;\n        }\n        long_value = *(long *)(param_array + 4);\n        uVar13 = *(uint *)(long_value + 0xc);\n        if (*(int *)(param_address + 0x30) == *(int *)(long_value + 8)) {\n          if (uVar13 <= *(uint *)(param_address + 0x38)) {\n                    \n            __assert_fail(\"type->u.kclass->id > info->base_id\",\"../../binutils/debug.c\",0xa87,\n                          \"debug_write_class_type\");\n          }\n          iVar9 = *param_array;\n          goto LAB_00112ed2;\n        }\n        pi_value = *(int **)(long_value + 0x20);\n        *(int *)(long_value + 8) = *(int *)(param_address + 0x30);\n        if (((pi_value != (int *)0x0) && (param_array != pi_value)) &&\n           (uVar12 = param_address, char_value = reverse_and_improve_00112c1f(param_address,param_value,pi_value,0), char_value == '\\0')) {\n          return 0;\n        }\n      }\n      char_value = FUN_0010a83e(param_value,return_value,uVar13,*param_array == 9,param_array[1],pi_value != (int *)0x0,\n                           param_array == pi_value,uVar12);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      if (*(long **)(param_array + 4) != (long *)0x0) {\n        uVar13 = 0;\n        if (**(long **)(param_array + 4) != 0) {\n          while (pointer_value_3 = *(undefined8 **)(**(long **)(param_array + 4) + (ulong)uVar13 * 8),\n                pointer_value_3 != (undefined8 *)0x0) {\n            char_value = reverse_and_improve_00112c1f(param_address,param_value,pointer_value_3[1],0);\n            if (char_value == '\\0') {\n              return 0;\n            }\n            if (*(char *)((long)pointer_value_3 + 0x14) == '\\0') {\n              char_value = FUN_0010ba08(param_value,*pointer_value_3,*(undefined4 *)(pointer_value_3 + 3));\n            }\n            else {\n              char_value = FUN_0010a94e(param_value,*pointer_value_3,pointer_value_3[3]);\n            }\n            if (char_value == '\\0') {\n              return 0;\n            }\n            uVar13 = uVar13 + 1;\n          }\n        }\n        uVar13 = 0;\n        if (*(long *)(*(long *)(param_array + 4) + 0x10) != 0) {\n          while (pointer_value_3 = *(undefined8 **)\n                           (*(long *)(*(long *)(param_array + 4) + 0x10) + (ulong)uVar13 * 8),\n                pointer_value_3 != (undefined8 *)0x0) {\n            char_value = reverse_and_improve_00112c1f(param_address,param_value,*pointer_value_3,0);\n            if (char_value == '\\0') {\n              return 0;\n            }\n            char_value = FUN_0010aa53(param_value,*(undefined4 *)(pointer_value_3 + 1),\n                                 *(undefined *)((long)pointer_value_3 + 0xc));\n            if (char_value == '\\0') {\n              return 0;\n            }\n            uVar13 = uVar13 + 1;\n          }\n        }\n        local_value = 0;\n        if (*(long *)(*(long *)(param_array + 4) + 0x18) != 0) {\n          while (pointer_value_3 = *(undefined8 **)\n                           (*(long *)(*(long *)(param_array + 4) + 0x18) + (ulong)local_value * 8),\n                pointer_value_3 != (undefined8 *)0x0) {\n            char_value = FUN_0010ab4d(param_value,*pointer_value_3);\n            if (char_value == '\\0') {\n              return 0;\n            }\n            uVar13 = 0;\n            while (pointer_value_2 = *(undefined8 **)(pointer_value_3[1] + (ulong)uVar13 * 8),\n                  pointer_value_2 != (undefined8 *)0x0) {\n              if ((pointer_value_2[4] != 0) &&\n                 (char_value = reverse_and_improve_00112c1f(param_address,param_value,pointer_value_2[4],0), char_value == '\\0')) {\n                return 0;\n              }\n              char_value = reverse_and_improve_00112c1f(param_address,param_value,pointer_value_2[1],0);\n              if (char_value == '\\0') {\n                return 0;\n              }\n              if (pointer_value_2[3] == -1) {\n                char_value = FUN_0010adf2(param_value,*pointer_value_2,*(undefined4 *)(pointer_value_2 + 2),\n                                     *(undefined *)((long)pointer_value_2 + 0x14),\n                                     *(undefined *)((long)pointer_value_2 + 0x15));\n              }\n              else {\n                char_value = FUN_0010add5(param_value);\n              }\n              if (char_value == '\\0') {\n                return 0;\n              }\n              uVar13 = uVar13 + 1;\n            }\n            char_value = FUN_00109bbb(param_value);\n            if (char_value == '\\0') {\n              return 0;\n            }\n            local_value = local_value + 1;\n          }\n        }\n      }\n      return_value = FUN_0010ae0e(param_value);\n      return return_value;\n    case 0xb:\n      pointer_value_3 = *(undefined8 **)(param_array + 4);\n      if (pointer_value_3 == (undefined8 *)0x0) {\n        uVar8 = 0;\n        uVar11 = 0;\n      }\n      else {\n        uVar8 = pointer_value_3[1];\n        uVar11 = *pointer_value_3;\n      }\n      return_value = FUN_0010e453(param_value,return_value,uVar11,uVar8);\n      return return_value;\n    case 0xc:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,*(undefined8 *)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      return_value = FUN_0010a083(param_value);\n      return return_value;\n    case 0xd:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,**(undefined8 **)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      uVar12 = 0;\n      if (*(long *)(*(long *)(param_array + 4) + 8) == 0) {\n        uVar12 = 0xffffffff;\n      }\n      else {\n        while (long_value = *(long *)(*(long *)(*(long *)(param_array + 4) + 8) + uVar12 * 8), long_value != 0) {\n          uVar12 = uVar12 + 1;\n          char_value = reverse_and_improve_00112c1f(param_address,param_value,long_value,0);\n          if (char_value == '\\0') {\n            return 0;\n          }\n        }\n        uVar12 = uVar12 & 0xffffffff;\n      }\n      return_value = FUN_0010e5db(param_value,uVar12,*(undefined *)(*(long *)(param_array + 4) + 0x10));\n      return return_value;\n    case 0xe:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,*(undefined8 *)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      return_value = FUN_0010a0a0(param_value);\n      return return_value;\n    case 0xf:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,**(undefined8 **)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      return_value = FUN_0010a0e9(param_value,*(undefined8 *)(*(long *)(param_array + 4) + 8),\n                           *(undefined8 *)(*(long *)(param_array + 4) + 0x10));\n      return return_value;\n    case 0x10:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,**(undefined8 **)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,*(undefined8 *)(*(long *)(param_array + 4) + 8),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      long_value = *(long *)(param_array + 4);\n      return_value = FUN_0010a181(param_value,*(undefined8 *)(long_value + 0x10),*(undefined8 *)(long_value + 0x18),\n                           *(undefined *)(long_value + 0x20));\n      return return_value;\n    case 0x11:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,**(undefined8 **)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      return_value = FUN_0010a2b9(param_value,*(undefined *)(*(long *)(param_array + 4) + 8));\n      return return_value;\n    case 0x12:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,**(undefined8 **)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,*(undefined8 *)(*(long *)(param_array + 4) + 8),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      return_value = FUN_0010a377(param_value);\n      return return_value;\n    case 0x13:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,**(undefined8 **)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      uVar12 = 0;\n      if (*(long *)(*(long *)(param_array + 4) + 0x10) == 0) {\n        uVar12 = 0xffffffff;\n      }\n      else {\n        while (long_value = *(long *)(*(long *)(*(long *)(param_array + 4) + 0x10) + uVar12 * 8), long_value != 0)\n        {\n          uVar12 = uVar12 + 1;\n          char_value = reverse_and_improve_00112c1f(param_address,param_value,long_value,0);\n          if (char_value == '\\0') {\n            return 0;\n          }\n        }\n      }\n      if ((*(long *)(*(long *)(param_array + 4) + 8) != 0) &&\n         (char_value = reverse_and_improve_00112c1f(param_address,param_value,*(long *)(*(long *)(param_array + 4) + 8),0),\n         char_value == '\\0')) {\n        return 0;\n      }\n      return_value = FUN_0010a424(param_value,*(long *)(*(long *)(param_array + 4) + 8) != 0,uVar12 & 0xffffffff,\n                           *(undefined *)(*(long *)(param_array + 4) + 0x18));\n      return return_value;\n    case 0x14:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,*(undefined8 *)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      return_value = FUNC_0010a0bd(param_value);\n      return return_value;\n    case 0x15:\n      char_value = reverse_and_improve_00112c1f(param_address,param_value,*(undefined8 *)(param_array + 4),0);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      return_value = FUN_0010a0d3(param_value);\n      return return_value;\n    default:\n                    \n      abort();\n    }\n  }\n  goto LAB_00112dd6;\nswitchD_00112d8e_caseD_1:\n  bVar14 = *(int **)**(undefined8 **)(param_array + 4) == param_array;\n  param_array = *(int **)**(undefined8 **)(param_array + 4);\n  if (bVar14) {\nLAB_00112dd6:\n    return_value = FUN_00109d97(param_value);\n    return return_value;\n  }\n  goto LAB_00112c39;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_0010c7a0",
                "FUN_0010a181",
                "FUN_00109e76",
                "FUN_00109d3e",
                "FUN_00109d5c",
                "FUN_0010bba1",
                "FUN_0010b948",
                "fprintf",
                "FUN_00109d97",
                "FUN_0010a2b9",
                "FUN_0010a77a",
                "FUN_0010adf2",
                "FUN_00109dfe",
                "__assert_fail",
                "FUN_0010ba08",
                "FUN_0010e453",
                "FUN_0010a0bd",
                "FUN_0010a69a",
                "FUN_0010aa53",
                "FUN_0010a83e",
                "FUN_00109bbb",
                "FUN_0010ae0e",
                "FUN_00112b6e",
                "FUN_0010a94e",
                "FUN_0010a424",
                "FUN_0010b800",
                "FUN_0010e5db",
                "FUN_0010a0e9",
                "FUN_0010add5",
                "FUN_0010a377",
                "abort",
                "FUN_0010a083",
                "FUN_0010a0d3",
                "FUN_00112c1f",
                "FUN_0010a0a0",
                "FUN_0010ab4d"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112c1f",
            "calling": [
                "FUN_001135a5",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "reverse_and_improve_00112c1f"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043b0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "bfd_malloc_and_get_section": {
            "renaming": {},
            "code": "\nvoid bfd_malloc_and_get_section(void)\n\n{\n  bfd_malloc_and_get_section();\n  return;\n}\n\n",
            "called": [
                "bfd_malloc_and_get_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041e0",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_malloc_and_get_section"
        },
        "FUN_0010808f": {
            "renaming": {
                "FUN_0010808f": "copy_private_data_0010808f",
                "unaff_R14B": "copySucceed",
                "unaff_R15": "dataPtr",
                "lVar1": "errorMessage"
            },
            "code": "\nvoid copyPrivateData_0010808f(void)\n\n{\n  long errorMessage;\n  char copySucceed;\n  long dataPtr;\n  \n  errorMessage = dcgettext(0,\"failed to copy private data\",5);\n  if (copySucceed != '\\0') {\n    *(undefined4 *)(*(long *)(dataPtr + 0xd0) + 4) = 8;\n  }\n  if (errorMessage != 0) {\n    DAT_00127a40 = 1;\n    FUN_001126c0(0);\n  }\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010808f",
            "calling": [
                "FUN_00108179"
            ],
            "imported": false,
            "current_name": "copy_private_data_0010808f"
        },
        "read": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104410",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "read"
        },
        "FUN_00108fe8": {
            "renaming": {
                "FUN_00108fe8": "print_warning_00108fe8",
                "param_1": "message1",
                "param_2": "message2",
                "in_RAX": "formatSpecifier",
                "__format": "warningFormat"
            },
            "code": "\n\n\nvoid printWarning_00108fe8(undefined8 message1,undefined8 message2)\n\n{\n  undefined8 formatSpecifier;\n  char *warningFormat;\n  \n  warningFormat = (char *)dcgettext(0,\"Warning: %s: %s\\n\",5);\n  fprintf(_stderr,warningFormat,message2,message1,formatSpecifier);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108fe8",
            "calling": [
                "FUN_0010ee3f",
                "FUN_00109a32",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "print_warning_00108fe8"
        },
        "bfd_alloc": {
            "renaming": {},
            "code": "\nvoid bfd_alloc(void)\n\n{\n  bfd_alloc();\n  return;\n}\n\n",
            "called": [
                "bfd_alloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104250",
            "calling": [
                "FUN_00115dc0"
            ],
            "imported": false,
            "current_name": "bfd_alloc"
        },
        "FUN_00105828": {
            "renaming": {
                "FUN_00105828": "identify_architecture_00105828",
                "iVar1": "architecture",
                "uVar2": "machine",
                "uVar3": "inputFile",
                "uVar4": "errorMessage"
            },
            "code": "\nundefined8 identifyArchitecture_00105828(void)\n\n{\n  int architecture;\n  undefined4 machine;\n  undefined8 inputFile;\n  undefined8 errorMessage;\n  \n  architecture = bfd_get_arch();\n  if (architecture == 0) {\n    inputFile = FUN_001125fa();\n    errorMessage = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n    FUN_00119ed0(errorMessage,inputFile);\n  }\n  else {\n    inputFile = bfd_get_mach();\n    machine = bfd_get_arch();\n    inputFile = bfd_printable_arch_mach(machine,inputFile);\n    errorMessage = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n    FUN_00119ed0(errorMessage,inputFile);\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_001125fa",
                "dcgettext",
                "FUN_00119ed0",
                "bfd_get_mach",
                "bfd_printable_arch_mach",
                "bfd_get_arch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105828",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "identify_architecture_00105828"
        },
        "memset": {
            "renaming": {},
            "code": "\n\n\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memset(__s,__c,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memset"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104360",
            "calling": [
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "memset"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUNC_00116b90,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00116b90",
                "__libc_start_main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116aa0",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "FUN_0011a0e0": {
            "renaming": {
                "FUN_0011a0e0": "create_temporary_directory_0011a0e0",
                "__template": "templatePath",
                "pcVar1": "tempDirPath"
            },
            "code": "\nchar * createTemporaryDirectory_0011a0e0(void)\n\n{\n  char *templatePath;\n  char *tempDirPath;\n  \n  templatePath = (char *)FUN_00114cf0();\n  tempDirPath = mkdtemp(templatePath);\n  if (tempDirPath == (char *)0x0) {\n    free(templatePath);\n  }\n  return tempDirPath;\n}\n\n",
            "called": [
                "FUN_00114cf0",
                "mkdtemp",
                "FUN_001081e9"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a0e0",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "create_temporary_directory_0011a0e0"
        },
        "FUN_0010bba1": {
            "renaming": {
                "FUN_0010bba1": "lookup_and_execute_0010bba1",
                "param_1": "hash_table",
                "param_2": "key",
                "lVar1": "hash_entry",
                "uVar2": "result"
            },
            "code": "\nundefined8 lookup_and_execute_0010bba1(long hash_table,undefined8 key)\n\n{\n  long hash_entry;\n  undefined8 result;\n  \n  hash_entry = bfd_hash_lookup(hash_table + 0x1b8,key,0,0);\n  if ((hash_entry != 0) && (0 < *(long *)(hash_entry + 0x20))) {\n    result = FUN_00109cf4(hash_table,*(long *)(hash_entry + 0x20),*(undefined4 *)(hash_entry + 0x28));\n    return result;\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_hash_lookup",
                "FUN_00109cf4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bba1",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "lookup_and_execute_0010bba1"
        },
        "bfd_check_format_matches": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104780",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_check_format_matches"
        },
        "FUN_0010e6a8": {
            "renaming": {
                "FUN_0010e6a8": "process_string_0010e6a8",
                "param_1": "data",
                "param_2": "inputString",
                "param_3": "param1",
                "param_4": "param2",
                "__s": "tempString",
                "sVar3": "inputLength",
                "sVar4": "tempLength",
                "__s_00": "combinedString",
                "lVar5": "lookupResult",
                "lVar8": "counter",
                "uVar1": "returnValue",
                "uVar2": "errorCode",
                "uVar6": "errorMsg",
                "uVar7": "errorMessage",
                "uVar9": "status",
                "auVar10": "result"
            },
            "code": "\nundefined  [16] processString_0010e6a8(long data,char *inputString,undefined8 param1,undefined8 param2)\n\n{\n  uint returnValue;\n  undefined4 errorCode;\n  char *tempString;\n  size_t inputLength;\n  size_t tempLength;\n  char *combinedString;\n  long lookupResult;\n  undefined8 errorMsg;\n  undefined8 errorMessage;\n  long counter;\n  ulong status;\n  undefined result [16];\n  \n  counter = *(long *)(*(long *)(data + 0x60) + 0x10);\n  errorCode = *(undefined4 *)(*(long *)(data + 0x60) + 0x18);\n  tempString = (char *)FUN_00109b2f();\n  inputLength = strlen(inputString);\n  tempLength = strlen(tempString);\n  combinedString = (char *)xmalloc(inputLength + 0x14 + tempLength);\n  if (counter < 1) {\n    counter = *(long *)(data + 0x68);\n    *(long *)(data + 0x68) = counter + 1;\n    sprintf(combinedString,\"%s:t%ld=%s\",inputString,counter,tempString);\n  }\n  else {\n    sprintf(combinedString,\"%s:t%s\",inputString,tempString);\n  }\n  free(tempString);\n  returnValue = FUN_0010e2f0(data,0x80,0,0,combinedString);\n  status = (ulong)returnValue;\n  if ((char)returnValue != '\\0') {\n    free(combinedString);\n    lookupResult = bfd_hash_lookup(data + 0x1b8,inputString,1,0);\n    if (lookupResult != 0) {\n      *(long *)(lookupResult + 0x20) = counter;\n      *(undefined4 *)(lookupResult + 0x28) = errorCode;\n      goto LAB_0010e7b3;\n    }\n    errorCode = bfd_get_error();\n    errorMsg = bfd_errmsg(errorCode);\n    errorMessage = dcgettext(0,\"string_hash_lookup failed: %s\",5);\n    FUN_00119ed0(errorMessage,errorMsg);\n  }\n  status = 0;\nLAB_0010e7b3:\n  result._8_8_ = param2;\n  result._0_8_ = status;\n  return result;\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "free",
                "bfd_get_error",
                "FUN_00119ed0",
                "FUN_0010e2f0",
                "bfd_hash_lookup",
                "sprintf",
                "bfd_errmsg",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e6a8",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_string_0010e6a8"
        },
        "FUN_0010e7c2": {
            "renaming": {
                "FUN_0010e7c2": "concatenate_strings_and_send_0010e7c2",
                "param_1": "input_parameter1",
                "param_2": "input_parameter2",
                "param_3": "input_parameter3",
                "param_4": "input_parameter4",
                "__s": "string1",
                "sVar1": "len_input_parameter2",
                "sVar2": "len_string1",
                "__s_00": "concatenated_string",
                "auVar3": "result"
            },
            "code": "\nundefined  [16] concatenateStringsAndSend_0010e7c2(undefined8 input_parameter1,char *input_parameter2,undefined8 input_parameter3,undefined8 input_parameter4)\n\n{\n  char *string1;\n  size_t len_input_parameter2;\n  size_t len_string1;\n  char *concatenated_string;\n  undefined result [16];\n  \n  string1 = (char *)FUN_00109b2f();\n  len_input_parameter2 = strlen(input_parameter2);\n  len_string1 = strlen(string1);\n  concatenated_string = (char *)xmalloc(len_input_parameter2 + 3 + len_string1);\n  sprintf(concatenated_string,\"%s:T%s\",input_parameter2,string1);\n  free(string1);\n  result._0_4_ = FUN_0010e2f0(input_parameter1,0x80,0,0,concatenated_string);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(concatenated_string);\n  }\n  result._8_8_ = input_parameter4;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_0010e2f0",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e7c2",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "concatenate_strings_and_send_0010e7c2"
        },
        "FUN_00119dd0": {
            "renaming": {
                "FUN_00119dd0": "initialize_function_00119dd0",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "data3",
                "param_4": "data4",
                "param_5": "data5",
                "param_6": "data6",
                "param_7": "data7",
                "param_8": "data8",
                "param_9": "pointer1",
                "param_10": "pointer2",
                "param_11": "pointer3",
                "param_12": "pointer4",
                "param_13": "pointer5",
                "param_14": "pointer6",
                "in_AL": "flag",
                "local_d8": "size",
                "local_d4": "length",
                "local_d0": "pointer7",
                "local_c8": "buffer",
                "local_b8": "temporary_buffer",
                "local_b0": "pointer2",
                "local_a8": "pointer3",
                "local_a0": "pointer4",
                "local_98": "pointer5",
                "local_90": "pointer6",
                "local_88": "variable1",
                "local_78": "variable2",
                "local_68": "variable3",
                "local_58": "variable4",
                "local_48": "variable5",
                "local_38": "variable6",
                "local_28": "variable7",
                "local_18": "variable8",
                "xexit": "exit_program"
            },
            "code": "\nvoid initialize_function_00119dd0(undefined4 data1,undefined4 data2,undefined4 data3,undefined4 data4,\n                 undefined4 data5,undefined4 data6,undefined4 data7,undefined4 data8,\n                 undefined8 pointer1,undefined8 pointer2,undefined8 pointer3,undefined8 pointer4,\n                 undefined8 pointer5,undefined8 pointer6)\n\n{\n  char flag;\n  undefined4 size;\n  undefined4 length;\n  undefined *pointer7;\n  undefined *buffer;\n  undefined temporary_buffer [8];\n  undefined8 pointer2;\n  undefined8 pointer3;\n  undefined8 pointer4;\n  undefined8 pointer5;\n  undefined8 pointer6;\n  undefined4 variable1;\n  undefined4 variable2;\n  undefined4 variable3;\n  undefined4 variable4;\n  undefined4 variable5;\n  undefined4 variable6;\n  undefined4 variable7;\n  undefined4 variable8;\n  \n  if (flag != '\\0') {\n    variable1 = data1;\n    variable2 = data2;\n    variable3 = data3;\n    variable4 = data4;\n    variable5 = data5;\n    variable6 = data6;\n    variable7 = data7;\n    variable8 = data8;\n  }\n  pointer7 = &stack0x00000008;\n  size = 8;\n  buffer = temporary_buffer;\n  length = 0x30;\n  pointer2 = pointer2;\n  pointer3 = pointer3;\n  pointer4 = pointer4;\n  pointer5 = pointer5;\n  pointer6 = pointer6;\n  FUN_00119e70(pointer1,&size);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_00119e70",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119dd0",
            "calling": [
                "FUN_00114190",
                "FUN_00116b90",
                "FUN_0010827b",
                "FUN_00114dc7",
                "FUN_001053b5",
                "FUN_00115b70",
                "FUN_00108d9a",
                "FUN_0010543c",
                "FUN_0010da0b",
                "FUN_00108808",
                "FUN_00114460",
                "FUN_00104920",
                "FUN_00104ad6",
                "FUN_0010554f",
                "FUN_00114690",
                "FUN_001083de"
            ],
            "imported": false,
            "current_name": "initialize_function_00119dd0"
        },
        "bfd_iterate_over_targets": {
            "renaming": {},
            "code": "\nvoid bfd_iterate_over_targets(void)\n\n{\n  bfd_iterate_over_targets();\n  return;\n}\n\n",
            "called": [
                "bfd_iterate_over_targets"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104620",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "bfd_iterate_over_targets"
        },
        "bfd_get_full_section_contents": {
            "renaming": {},
            "code": "\nvoid bfd_get_full_section_contents(void)\n\n{\n  bfd_get_full_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_get_full_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104440",
            "calling": [
                "FUN_00116110",
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_get_full_section_contents"
        },
        "bfd_hash_newfunc": {
            "renaming": {},
            "code": "\nvoid bfd_hash_newfunc(void)\n\n{\n  bfd_hash_newfunc();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_newfunc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104200",
            "calling": [
                "FUN_0010bb52"
            ],
            "imported": false,
            "current_name": "bfd_hash_newfunc"
        },
        "FUN_001083b7": {
            "renaming": {
                "FUN_001083b7": "handle_error_001083b7",
                "param_1": "errorCode",
                "iVar1": "bfdError",
                "unaff_RBP": "ptrUnaffRBP",
                "unaff_retaddr": "returnValue"
            },
            "code": "\nundefined8 handleError_001083b7(long errorCode)\n\n{\n  int bfdError;\n  undefined8 *ptrUnaffRBP;\n  undefined8 returnValue;\n  \n  if (errorCode == -1) {\n    bfdError = bfd_get_error();\n    if (bfdError == 5) {\n      return returnValue;\n    }\n  }\n  FUN_0011a110(*ptrUnaffRBP);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_0011a110",
                "bfd_get_error",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001083b7",
            "calling": [
                "FUN_00116030"
            ],
            "imported": false,
            "current_name": "handle_error_001083b7"
        },
        "FUN_00116852": {
            "renaming": {
                "FUN_00116852": "process_data_00116852",
                "in_RCX": "dataSize",
                "in_R10": "counter",
                "unaff_RBX": "minValue",
                "unaff_RBP": "data",
                "in_R11": "condition",
                "unaff_R13": "start",
                "unaff_R14": "current",
                "unaff_R15": "maxValue",
                "param_7": "param1",
                "param_9": "param2",
                "param_10": "result",
                "param_11": "dataBuffer",
                "param_12": "outputBuffer",
                "param_13": "param3",
                "param_14": "dataCount",
                "sVar1": "size",
                "pcVar2": "function",
                "iVar3": "result",
                "uVar4": "counter",
                "__ptr": "output",
                "puVar9": "dest",
                "cVar10": "charVar",
                "puVar11": "tempVar1",
                "puVar12": "tempVar2",
                "uVar5": "tempVar3",
                "uVar6": "tempVar4",
                "lVar7": "loopVar",
                "uVar8": "tempVar5",
                "bVar14": "byteVar",
                "psVar13": "currentData"
            },
            "code": "\nulong processData_00116852(void)\n\n{\n  size_t size;\n  code *function;\n  int result;\n  uint counter;\n  undefined *output;\n  size_t *dataSize;\n  ulong tempVar3;\n  ulong tempVar4;\n  long loopVar;\n  ulong tempVar5;\n  size_t minValue;\n  size_t *data;\n  undefined *dest;\n  char charVar;\n  undefined *tempVar1;\n  ulong counter;\n  undefined *tempVar2;\n  size_t condition;\n  size_t *start;\n  size_t *current;\n  size_t maxValue;\n  size_t *currentData;\n  byte byteVar;\n  size_t param1;\n  size_t param2;\n  ulong result;\n  size_t *dataBuffer;\n  undefined *outputBuffer;\n  long param3;\n  size_t dataCount;\n  \n  byteVar = 0;\ncode_r0x00116852:\n  counter = (int)counter + 1;\n  if (0x10 < (int)counter) goto LAB_001167f5;\nLAB_00116863:\n  current = current + -9;\n  do {\n    if (start <= current) {\n      size = current[2];\n      if (size == 0) goto LAB_00116863;\n      tempVar5 = (ulong)counter;\n      if ((*current == *data) &&\n         (result = memcmp((void *)current[3],(void *)data[3],*data), result == 0)) {\n        tempVar4 = current[7];\n        tempVar3 = current[8];\n        counter = tempVar5 & 0xffffffff;\n        if (maxValue == tempVar4) {\n          if (minValue != tempVar3) goto LAB_001167a6;\n          data[2] = 0;\n        }\n        else {\n          if (maxValue < tempVar4) {\n            if (tempVar3 < maxValue) {\nLAB_0010852c:\n              if ((0xfffffffffffffff0 < tempVar3) || (maxValue <= (tempVar3 + 0xf & 0xfffffffffffffff0)))\n              goto code_r0x00116852;\n            }\n            else if (minValue < maxValue) {\n              if ((0xfffffffffffffff0 < minValue) ||\n                 (tempVar4 <= (minValue + 0xf & 0xfffffffffffffff0))) goto code_r0x00116852;\n            }\n            else if (minValue == tempVar3) goto code_r0x00116852;\n          }\n          else {\nLAB_001167a6:\n            if (minValue <= tempVar3) {\n              data[2] = 0;\n              goto LAB_001167f5;\n            }\n            if (tempVar3 < maxValue) goto LAB_0010852c;\n          }\n          if ((condition == 0x101) != (size == 0x101)) goto code_r0x00116852;\n          if (tempVar3 <= minValue) {\n            tempVar3 = minValue;\n          }\n          if (tempVar4 < maxValue) {\n            maxValue = tempVar4;\n          }\n          current[8] = tempVar3;\n          current[7] = maxValue;\n          data[2] = 0;\n        }\n      }\n    }\nLAB_001167f5:\n    while( true ) {\n      do {\n        current = data;\n        data = current + 9;\n        if (dataSize <= data) {\n          qsort(dataBuffer,dataCount,0x48,FUN_0011a250);\n          output = (undefined *)xmalloc(result * 2);\n          param1 = 0;\n          tempVar2 = output;\n          for (currentData = dataBuffer; currentData < dataSize; currentData = currentData + 9) {\n            if (currentData[2] != 0) {\n              tempVar1 = tempVar2 + 4;\n              dest = tempVar2 + 0xc;\n              function = *(code **)(*(long *)(param3 + 8) + 0x50);\n              if ((currentData[7] == param2) && (currentData[8] == param1)) {\n                (*function)(*currentData,tempVar2);\n                (**(code **)(*(long *)(param3 + 8) + 0x50))(0,tempVar1);\n                (**(code **)(*(long *)(param3 + 8) + 0x50))(currentData[2],tempVar2 + 8);\n                tempVar4 = currentData[6];\n                tempVar5 = *currentData;\n                tempVar2 = (undefined *)currentData[3];\n                tempVar1 = dest;\n                for (tempVar3 = tempVar5; tempVar3 != 0; tempVar3 = tempVar3 - 1) {\n                  *tempVar1 = *tempVar2;\n                  tempVar2 = tempVar2 + (ulong)byteVar * -2 + 1;\n                  tempVar1 = tempVar1 + (ulong)byteVar * -2 + 1;\n                }\n                if (tempVar5 < tempVar4) {\n                  for (loopVar = tempVar4 - tempVar5; loopVar != 0; loopVar = loopVar + -1) {\n                    *tempVar1 = 0;\n                    tempVar1 = tempVar1 + (ulong)byteVar * -2 + 1;\n                  }\n                }\n                tempVar2 = dest + tempVar4;\n              }\n              else {\n                (*function)();\n                if (*(int *)(*(long *)(param3 + 8) + 8) == 5) {\n                  charVar = (*(char *)(*(long *)(param3 + 0x110) + 4) == '\\x02') * '\\b' + '\\b';\n                }\n                else {\n                  charVar = '\\b';\n                }\n                (**(code **)(*(long *)(param3 + 8) + 0x50))(charVar,tempVar1);\n                (**(code **)(*(long *)(param3 + 8) + 0x50))(currentData[2],tempVar2 + 8);\n                tempVar5 = *currentData;\n                tempVar2 = (undefined *)currentData[3];\n                tempVar1 = dest;\n                for (tempVar4 = tempVar5; tempVar4 != 0; tempVar4 = tempVar4 - 1) {\n                  *tempVar1 = *tempVar2;\n                  tempVar2 = tempVar2 + (ulong)byteVar * -2 + 1;\n                  tempVar1 = tempVar1 + (ulong)byteVar * -2 + 1;\n                }\n                tempVar4 = currentData[6];\n                if (tempVar5 < tempVar4) {\n                  for (loopVar = tempVar4 - tempVar5; loopVar != 0; loopVar = loopVar + -1) {\n                    *tempVar1 = 0;\n                    tempVar1 = tempVar1 + (ulong)byteVar * -2 + 1;\n                  }\n                }\n                loopVar = *(long *)(param3 + 8);\n                dest = dest + tempVar4;\n                tempVar2 = dest + 8;\n                if ((*(int *)(loopVar + 8) == 5) &&\n                   (*(char *)(*(long *)(param3 + 0x110) + 4) == '\\x02')) {\n                  (**(code **)(loopVar + 0x38))(currentData[7],dest);\n                  (**(code **)(*(long *)(param3 + 8) + 0x38))(currentData[8],tempVar2);\n                  tempVar2 = dest + 0x10;\n                }\n                else {\n                  (**(code **)(loopVar + 0x50))(currentData[7],dest);\n                  (**(code **)(*(long *)(param3 + 8) + 0x50))(currentData[8],dest + 4);\n                }\n                param2 = currentData[7];\n                param1 = currentData[8];\n              }\n            }\n          }\n          tempVar4 = (long)tempVar2 - (long)output;\n          tempVar5 = tempVar4;\n          tempVar2 = output;\n          if (tempVar4 < result) {\n            for (; result = tempVar4, tempVar5 != 0; tempVar5 = tempVar5 - 1) {\n              *outputBuffer = *tempVar2;\n              tempVar2 = tempVar2 + (ulong)byteVar * -2 + 1;\n              outputBuffer = outputBuffer + (ulong)byteVar * -2 + 1;\n            }\n          }\n          free(output);\n          free(dataBuffer);\n          return result;\n        }\n        condition = current[0xb];\n      } while (condition == 0);\n      maxValue = current[0x10];\n      minValue = current[0x11];\n      counter = 0;\n      if (maxValue != minValue) break;\n      current[0xb] = 0;\n    }\n  } while( true );\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_0011a250",
                "free",
                "qsort",
                "memcmp",
                "FUN_00116852"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116852",
            "calling": [
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "process_data_00116852"
        },
        "FUN_00113d3a": {
            "renaming": {
                "FUN_00113d3a": "find_next_node_00113d3a",
                "param_1": "currentNode",
                "lVar1": "nextNode"
            },
            "code": "\nlong findNextNode_00113d3a(long currentNode)\n\n{\n  long nextNode;\n  \n  if (currentNode != 0) {\n    nextNode = *(long *)(currentNode + 8);\n    if (nextNode == 0) {\n      nextNode = FUN_00112904(0xc,0);\n      if (nextNode == 0) {\n        nextNode = 0;\n      }\n      else {\n        *(long *)(nextNode + 0x10) = currentNode;\n        *(long *)(currentNode + 8) = nextNode;\n      }\n    }\n    return nextNode;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113d3a",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_0010dac0",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "find_next_node_00113d3a"
        },
        "bfd_hash_lookup": {
            "renaming": {},
            "code": "\nvoid bfd_hash_lookup(void)\n\n{\n  bfd_hash_lookup();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_lookup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104560",
            "calling": [
                "FUN_0010e6a8",
                "FUN_0010e2f0",
                "FUN_0010bba1"
            ],
            "imported": false,
            "current_name": "bfd_hash_lookup"
        },
        "chmod": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046d0",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "chmod"
        },
        "htab_delete": {
            "renaming": {},
            "code": "\nvoid htab_delete(void)\n\n{\n  htab_delete();\n  return;\n}\n\n",
            "called": [
                "htab_delete"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104090",
            "calling": [
                "FUN_001054af"
            ],
            "imported": false,
            "current_name": "htab_delete"
        },
        "htab_traverse": {
            "renaming": {},
            "code": "\nvoid htab_traverse(void)\n\n{\n  htab_traverse();\n  return;\n}\n\n",
            "called": [
                "htab_traverse"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104580",
            "calling": [
                "FUN_0010554f",
                "FUN_00115d70"
            ],
            "imported": false,
            "current_name": "htab_traverse"
        },
        "FUN_0010a0d3": {
            "renaming": {
                "FUN_0010a0d3": "execute_task_0010a0d3",
                "param_1": "taskParameter"
            },
            "code": "\nvoid executeTask_0010a0d3(long taskParameter)\n\n{\n  FUN_00109ed3(taskParameter,0x42,*(undefined4 *)(*(long *)(taskParameter + 0x60) + 0x18),0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109ed3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0d3",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "execute_task_0010a0d3"
        },
        "FUN_00115530": {
            "renaming": {
                "FUN_00115530": "create_output_section_00115530",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "lVar1": "temp1",
                "pcVar2": "temp2",
                "ppcVar3": "temp3",
                "cVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "temp6",
                "sVar7": "temp7",
                "sVar8": "temp8",
                "lVar9": "temp9",
                "pcVar10": "temp10",
                "pcVar11": "temp11",
                "pcVar12": "temp12",
                "uVar13": "temp13",
                "bVar14": "temp14",
                "local_50": "local1",
                "local_48": "local2",
                "local_40": "local3"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\n\nvoid createOutputSection_00115530(long param1,char **param2,long param3)\n\n{\n  long temp1;\n  char *temp2;\n  char **temp3;\n  char temp4;\n  int temp5;\n  uint temp6;\n  size_t temp7;\n  size_t temp8;\n  long temp9;\n  char *temp10;\n  char *temp11;\n  char *temp12;\n  uint temp13;\n  bool temp14;\n  long local1;\n  char *local2;\n  long local3 [2];\n  \n  temp4 = FUN_001159d0(param2);\n  if (temp4 != '\\0') {\n    return;\n  }\n  temp10 = *param2;\n  temp13 = *(uint *)((long)param2 + 0x24);\n  local2 = temp10;\n  temp3 = DAT_001278f8;\n  if (*(int *)(*(long *)(param1 + 8) + 8) != *(int *)(*(long *)(param3 + 8) + 8)) {\n    temp13 = temp13 & *(uint *)(*(long *)(param1 + 8) + 0x18) &\n             *(uint *)(*(long *)(param3 + 8) + 0x18);\n  }\n  for (; temp3 != (char **)0x0; temp3 = (char **)temp3[3]) {\n    temp5 = strcmp(*temp3,temp10);\n    if (temp5 == 0) {\n      if (*(uint *)(temp3 + 2) != 0xffffffff) {\n        temp13 = *(uint *)(temp3 + 2);\n      }\n      if (temp10 != temp3[1]) {\n        local2 = temp3[1];\n        temp13 = FUN_00115f30(temp13,param3);\n      }\n      break;\n    }\n  }\n  if (((DAT_00127918 != (char *)0x0) &&\n      (temp10 = DAT_00127918, (*(byte *)((long)param2 + 0x24) & 1) != 0)) ||\n     (temp10 = DAT_00127920, DAT_00127920 != (char *)0x0)) {\n    temp7 = strlen(temp10);\n    temp8 = strlen(local2);\n    temp12 = (char *)xmalloc(temp7 + 1 + temp8);\n    temp10 = strcpy(temp12,temp10);\n    local2 = strcat(temp10,local2);\n  }\n  temp9 = FUN_00114190(*param2,0,0x80);\n  temp14 = false;\n  if (temp9 == 0) {\n    if ((DAT_00127a48 == 4) && ((temp13 & 0x2000001) != 0)) {\n      temp5 = *(int *)(*(long *)(param1 + 8) + 8);\n      if (temp5 == 5) {\n        if (*(int *)(param2[0x1a] + 4) != 7) {\nLAB_00115771:\n          if (*(int *)(*(long *)(param3 + 8) + 8) == 5) {\n            temp14 = (temp13 & 0x2000000) == 0;\n            temp6 = ~((-(uint)((temp13 & 0x2000000) == 0) & 0x2000100) + 2);\n            *(uint *)((long)param2 + 0x24) = *(uint *)((long)param2 + 0x24) & temp6;\n          }\n          else {\n            temp6 = 0xfdfffefd;\n          }\n          temp13 = temp13 & temp6;\n        }\n      }\n      else if ((temp5 != 2) || (temp5 = strcmp(*param2,\".buildid\"), temp5 != 0)) goto LAB_00115771;\n    }\n  }\n  else {\n    temp13 = FUN_00115f30(temp13 & 0x104 | *(uint *)(temp9 + 0x28),param3,*param2);\n  }\n  temp4 = bfd_convert_section_setup(param1,param2,param3,&local2,local3);\n  if (temp4 == '\\0') {\n    temp10 = (char *)0x0;\n    local1 = dcgettext(0,\"failed to create output section\",5);\n    goto LAB_001080d1;\n  }\n  temp10 = (char *)bfd_make_section_anyway_with_flags(param3,local2,temp13);\n  if (temp10 == (char *)0x0) {\n    local1 = dcgettext(0,\"failed to create output section\",5);\n    goto LAB_001080d1;\n  }\n  if (DAT_001264bc < 0) {\n    if (DAT_0012790c != '\\0') {\n      local3[0] = 0;\n      goto LAB_001158e7;\n    }\n    temp4 = bfd_set_section_size(temp10,local3[0]);\n    if (temp4 == '\\0') {\n      FUN_00108072();\n      return;\n    }\n  }\n  else {\n    local3[0] = ((((long)DAT_00127a3c - 1U) + local3[0]) / (ulong)(long)DAT_00127a3c) *\n                  (long)DAT_001264b8;\nLAB_001158e7:\n    temp4 = bfd_set_section_size(temp10);\n    if (temp4 == '\\0') {\n      FUN_00108072();\n      return;\n    }\n  }\n  local1 = 0;\n  temp12 = param2[6];\n  temp9 = FUN_00114190(*param2,0,0x18);\n  if (temp9 == 0) {\n    temp10[0x28] = temp10[0x28] | 1;\n    temp11 = *param2;\n    temp12 = temp12 + _DAT_001279b0;\n    *(char **)(temp10 + 0x30) = temp12;\n    *(char **)(temp10 + 0x38) = temp12;\n    temp12 = param2[7];\n    temp9 = FUN_00114190(temp11,0,0x60);\n    if (temp9 == 0) goto LAB_00115695;\nLAB_00115860:\n    temp11 = *(char **)(temp9 + 0x20);\n    if ((*(byte *)(temp9 + 0x14) & 0x40) != 0) {\n      temp11 = temp11 + (long)temp12;\n    }\n    *(char **)(temp10 + 0x38) = temp11;\n    temp9 = FUN_00114190(*param2,0,0x200);\n    if (temp9 != 0) goto LAB_00115889;\nLAB_001156b8:\n    temp13 = *(uint *)((long)param2 + 0x7c);\n    if (temp13 < 0x3f) goto LAB_001156c4;\n    local1 = dcgettext(0,\"failed to set alignment\",5);\n    *(undefined4 *)(temp10 + 0xb4) = *(undefined4 *)((long)param2 + 0xb4);\n    temp10[0x28] = temp10[0x28] & 0xcfU | *(byte *)(param2 + 5) & 0x30;\n    param2[0xc] = temp10;\n    param2[0xb] = (char *)0x0;\n    if ((*(byte *)((long)param2 + 0x27) & 2) != 0) goto LAB_001157c8;\nLAB_00115700:\n    temp4 = (**(code **)(*(long *)(param3 + 8) + 0x158))(param1,param2,param3,temp10);\n    if (temp4 == '\\0') {\n      FUN_0010808f();\n      return;\n    }\n  }\n  else {\n    temp11 = *(char **)(temp9 + 0x18);\n    if ((*(byte *)(temp9 + 0x14) & 8) == 0) {\n      temp11 = temp11 + (long)temp12;\n    }\n    temp10[0x28] = temp10[0x28] | 1;\n    temp2 = *param2;\n    *(char **)(temp10 + 0x30) = temp11;\n    *(char **)(temp10 + 0x38) = temp11;\n    temp12 = param2[7];\n    temp9 = FUN_00114190(temp2,0,0x60);\n    if (temp9 != 0) goto LAB_00115860;\nLAB_00115695:\n    temp11 = *param2;\n    *(char **)(temp10 + 0x38) = temp12 + _DAT_001279b0;\n    temp9 = FUN_00114190(temp11,0,0x200);\n    if (temp9 == 0) goto LAB_001156b8;\nLAB_00115889:\n    temp13 = *(uint *)(temp9 + 0x2c);\n    if (0x3e < temp13) {\n      FUN_00108179();\n      return;\n    }\nLAB_001156c4:\n    *(uint *)(temp10 + 0x7c) = temp13;\n    *(undefined4 *)(temp10 + 0xb4) = *(undefined4 *)((long)param2 + 0xb4);\n    temp10[0x28] = temp10[0x28] & 0xcfU | *(byte *)(param2 + 5) & 0x30;\n    param2[0xc] = temp10;\n    param2[0xb] = (char *)0x0;\n    if ((*(byte *)((long)param2 + 0x27) & 2) == 0) goto LAB_00115700;\nLAB_001157c8:\n    temp12 = param2[0x1a];\n    temp9 = FUN_00115d00(temp12,param2[0x1c]);\n    if ((temp9 == 0) ||\n       (temp1 = *(long *)(param1 + 8), *(uint *)(temp9 + 0x18) = *(uint *)(temp9 + 0x18) | 0x20,\n       *(int *)(temp1 + 8) != 5)) goto LAB_00115700;\n    *(long *)(temp12 + 0xb0) = temp9;\n    temp4 = (**(code **)(*(long *)(param3 + 8) + 0x158))(param1,param2,param3,temp10);\n    if (temp4 == '\\0') {\n      FUN_0010808f();\n      return;\n    }\n  }\n  if (temp14) {\n    *(undefined4 *)(*(long *)(temp10 + 0xd0) + 4) = 8;\n  }\n  if (local1 == 0) {\n    return;\n  }\nLAB_001080d1:\n  DAT_00127a40 = 1;\n  FUN_001126c0(0,param3,temp10,local1);\n  return;\n}\n\n",
            "called": [
                "FUN_00114190",
                "dcgettext",
                "FUN_00115f30",
                "xmalloc",
                "bfd_set_section_size",
                "strcat",
                "bfd_make_section_anyway_with_flags",
                "bfd_convert_section_setup",
                "strlen",
                "strcpy",
                "FUN_00108072",
                "strcmp",
                "FUN_001159d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115530",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "create_output_section_00115530"
        },
        "FUN_0010a0bd": {
            "renaming": {
                "FUN_0010a0bd": "FUNC_0010a0bd"
            },
            "code": "\nvoid FUNC_0010a0bd(long param_1)\n\n{\n  FUN_00109ed3(param_1,0x6b,*(undefined4 *)(*(long *)(param_1 + 0x60) + 0x18),0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109ed3"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x0010a0bd",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "FUNC_0010a0bd"
        },
        "FUN_00113e5e": {
            "renaming": {
                "FUN_00113e5e": "check_function_name_00113e5e",
                "param_1": "input",
                "param_2": "argv",
                "param_3": "length",
                "cVar1": "result"
            },
            "code": "\nundefined8 check_function_name_00113e5e(undefined8 input,char **argv,long length)\n\n{\n  char result;\n  char *local_20 [2];\n  \n  local_20[0] = *argv;\n  *argv = (char *)(length + 2);\n  if ((((long)(char *)(length + 2) - (long)local_20[0] < 5) ||\n      (result = FUN_00113fb0(local_20[0],\"type\"), result == '\\0')) ||\n     ((local_20[0][4] != '$' && (local_20[0][4] != '.')))) {\n    if (*local_20[0] != '_') {\n      return 1;\n    }\n    if (local_20[0][1] != '_') {\n      return 1;\n    }\n    if (local_20[0][2] != 'o') {\n      return 1;\n    }\n    if (local_20[0][3] != 'p') {\n      return 1;\n    }\n    local_20[0] = local_20[0] + 4;\n  }\n  else {\n    local_20[0] = local_20[0] + 5;\n  }\n  result = FUN_0010c95e(input,local_20,0);\n  if (result != '\\0') {\n    return 1;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "FUN_0010c95e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113e5e",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "check_function_name_00113e5e"
        },
        "FUN_0010abdd": {
            "renaming": {
                "FUN_0010abdd": "process_data_0010abdd",
                "param_1": "input",
                "param_2": "string1",
                "param_3": "length",
                "param_4": "flag1",
                "param_5": "flag2",
                "param_6": "flag3",
                "param_7": "number",
                "param_8": "flag4",
                "lVar1": "dataStructPtr",
                "pcVar2": "ptr1",
                "bVar3": "byteVal",
                "pcVar4": "ptr2",
                "__s": "ptr3",
                "sVar5": "length1",
                "sVar6": "length2",
                "sVar7": "length3",
                "sVar8": "length4",
                "uVar9": "result",
                "cVar10": "char1",
                "cVar11": "char2",
                "local_52": "localByte"
            },
            "code": "\nundefined8\nprocessData_0010abdd(long input,char *string1,uint length,char flag1,char flag2,char flag3,\n            undefined8 number,char flag4)\n\n{\n  long dataStructPtr;\n  char *ptr1;\n  byte byteVal;\n  char *ptr2;\n  char *ptr3;\n  size_t length1;\n  size_t length2;\n  size_t length3;\n  size_t length4;\n  undefined8 result;\n  char char1;\n  char char2;\n  byte localByte;\n  \n  ptr3 = (char *)0x0;\n  localByte = *(byte *)(*(long *)(input + 0x60) + 0x1c);\n  ptr2 = (char *)FUN_00109b2f();\n  if (flag4 != '\\0') {\n    byteVal = 1;\n    if (localByte == 0) {\n      byteVal = *(byte *)(*(long *)(input + 0x60) + 0x1c);\n    }\n    localByte = byteVal & 1;\n    ptr3 = (char *)FUN_00109b2f(input);\n  }\n  dataStructPtr = *(long *)(input + 0x60);\n  if ((dataStructPtr == 0) || (ptr1 = *(char **)(dataStructPtr + 0x30), ptr1 == (char *)0x0)) {\n    result = 0;\n  }\n  else {\n    if (2 < length) {\n                    \n      abort();\n    }\n    if (flag2 == '\\0') {\n      char2 = (-(flag3 == '\\0') & 0xfeU) + 0x43;\n    }\n    else {\n      char2 = (-(flag3 == '\\0') & 0xfeU) + 0x44;\n    }\n    char1 = '?';\n    if (flag1 == '\\0') {\n      char1 = (-(flag4 == '\\0') & 4U) + 0x2a;\n    }\n    length1 = strlen(ptr1);\n    length2 = strlen(ptr2);\n    length3 = strlen(string1);\n    length4 = 0;\n    if (flag4 != '\\0') {\n      length4 = strlen(ptr3);\n    }\n    result = xrealloc(ptr1,length3 + length1 + 0x28 + length2 + length4);\n    *(undefined8 *)(dataStructPtr + 0x30) = result;\n    ptr1 = *(char **)(*(long *)(input + 0x60) + 0x30);\n    length1 = strlen(ptr1);\n    sprintf(ptr1 + length1,\"%s:%s;%c%c%c\",ptr2,string1,(ulong)(byte)(0x32 - (char)length),\n            (ulong)(uint)(int)char2,(ulong)(uint)(int)char1,length1);\n    free(ptr2);\n    if (flag4 != '\\0') {\n      ptr2 = *(char **)(*(long *)(input + 0x60) + 0x30);\n      length1 = strlen(ptr2);\n      sprintf(ptr2 + length1,\"%ld;%s;\",number,ptr3);\n      free(ptr3);\n    }\n    if (localByte != 0) {\n      *(undefined *)(*(long *)(input + 0x60) + 0x1c) = 1;\n    }\n    result = 1;\n  }\n  return result;\n}\n\n",
            "called": [
                "free",
                "xrealloc",
                "abort",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010abdd",
            "calling": [
                "FUN_0010add5",
                "FUN_0010adf2"
            ],
            "imported": false,
            "current_name": "process_data_0010abdd"
        },
        "FUN_00115f30": {
            "renaming": {
                "FUN_00115f30": "drop_share_flag_if_not_coff_00115f30",
                "param_1": "inputFlags",
                "param_2": "params",
                "param_3": "outputFormat",
                "uVar1": "firstParam",
                "uVar2": "errorString"
            },
            "code": "\nuint dropShareFlagIfNotCOFF_00115f30(uint inputFlags,undefined8 *params,undefined8 outputFormat)\n\n{\n  undefined8 firstParam;\n  undefined8 errorString;\n  \n  if (((inputFlags & 0x8000000) != 0) && (*(int *)(params[1] + 8) != 2)) {\n    firstParam = *params;\n    inputFlags = inputFlags & 0xf7ffffff;\n    errorString = dcgettext(0,\"%s[%s]: Note - dropping \\'share\\' flag as output format is not COFF\",5);\n    FUN_00119ed0(errorString,firstParam,outputFormat);\n  }\n  return inputFlags;\n}\n\n",
            "called": [
                "FUN_00108375"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115f30",
            "calling": [
                "FUN_00107880",
                "FUN_00115530"
            ],
            "imported": false,
            "current_name": "drop_share_flag_if_not_coff_00115f30"
        },
        "dup": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042d0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "dup"
        },
        "cplus_demangle_print": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_print(void)\n\n{\n  cplus_demangle_print();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_print"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104050",
            "calling": [
                "FUN_0010b0fa"
            ],
            "imported": false,
            "current_name": "cplus_demangle_print"
        },
        "bfd_close": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104908",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_close"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_001275e0 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_00126468);\n  FUNC_00116ad0();\n  DAT_001275e0 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00116ad0",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116b40",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "FUN_001129f4": {
            "renaming": {
                "FUN_001129f4": "get_value_from_pointer_001129f4",
                "param_1": "input",
                "puVar1": "ptrToValue",
                "piVar2": "ptrToNext"
            },
            "code": "\nundefined8 getValueFromPointer_001129f4(int *input)\n\n{\n  undefined8 *ptrToValue;\n  int *ptrToNext;\n  \n  do {\n    if (*input != 1) {\n      if (1 < *input - 0x16U) {\n        return 0;\n      }\n      return *(undefined8 *)(**(long **)(input + 4) + 8);\n    }\n    ptrToValue = (undefined8 *)(input + 4);\n    ptrToNext = **(int ***)(undefined8 *)*ptrToValue;\n  } while ((input != ptrToNext) && (input = ptrToNext, ptrToNext != (int *)0x0));\n  return ((undefined8 *)*ptrToValue)[1];\n}\n\n",
            "called": [
                "FUN_001129f4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001129f4",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_001129f4",
                "FUN_0010d559",
                "FUN_00112b6e"
            ],
            "imported": false,
            "current_name": "get_value_from_pointer_001129f4"
        },
        "strchr": {
            "renaming": {},
            "code": "\n\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104290",
            "calling": [
                "FUN_0010ee3f",
                "FUN_00116b90",
                "FUN_00104ad6",
                "FUN_00114c80",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "strchr"
        },
        "rmdir": {
            "renaming": {},
            "code": "\n\n\nint rmdir(char *__path)\n\n{\n  int iVar1;\n  \n  iVar1 = rmdir(__path);\n  return iVar1;\n}\n\n",
            "called": [
                "rmdir"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104230",
            "calling": [
                "FUN_00114b84",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "rmdir"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104660",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "FUN_001082b3": {
            "renaming": {
                "FUN_001082b3": "invert_and_increment_001082b3",
                "uVar1": "result"
            },
            "code": "\nuint invertAndIncrement_001082b3(void)\n\n{\n  uint result;\n  \n  result = FUN_00113ede();\n  return result ^ 1;\n}\n\n",
            "called": [
                "FUN_00113ede"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082b3",
            "calling": [
                "FUN_0010829e"
            ],
            "imported": false,
            "current_name": "invert_and_increment_001082b3"
        },
        "FUN_00114690": {
            "renaming": {
                "FUN_00114690": "extract_and_copy_archive_00114690",
                "param_1": "input_file",
                "param_2": "output_file",
                "param_3": "file_descriptor",
                "param_4": "stat_struct",
                "param_5": "bfd_flags",
                "param_6": "target_file_size",
                "param_7": "compilation_date",
                "bVar1": "byte_var",
                "cVar2": "char_var1",
                "cVar3": "char_var2",
                "iVar4": "int_var1",
                "iVar5": "int_var2",
                "ppcVar6": "char_ptr_ptr",
                "pvVar7": "void_ptr",
                "lVar8": "long_var1",
                "puVar9": "undefined8_ptr",
                "piVar10": "int_ptr",
                "uVar11": "undefined8_var1",
                "uVar12": "undefined8_var2",
                "lVar13": "long_var2",
                "puVar14": "bfd_file_ptr",
                "pcVar15": "temp_dir",
                "pcVar17": "path_name1",
                "pcVar18": "path_name2",
                "pcVar19": "path_name3",
                "ppcVar16": "bfd_archive_file_ptr",
                "ppcVar19": "bfd_archive_file_ptr_temp",
                "lVar21": "long_var3",
                "uVar22": "uint_var",
                "pcVar23": "path_name4",
                "psVar24": "stat_ptr",
                "bVar25": "bool_var",
                "bVar26": "byte_var2",
                "local_1a0": "output_file_ptr",
                "local_198": "long_ptr",
                "local_c8": "void_ptr_array",
                "uStack_b0": "Uint_stack_var",
                "lStack_98": "long_stack_var"
            },
            "code": "\n\n\nvoid extract_and_copy_archive_00114690(undefined8 input_file,undefined8 output_file,int file_descriptor,undefined8 stat_struct,\n                 undefined8 bfd_flags,long target_file_size,undefined8 compilation_date)\n\n{\n  byte byte_var;\n  char char_var1;\n  char char_var2;\n  int int_var1;\n  int int_var2;\n  char **char_ptr_ptr;\n  void *void_ptr;\n  long long_var1;\n  undefined8 *undefined8_ptr;\n  int *int_ptr;\n  undefined8 undefined8_var1;\n  undefined8 undefined8_var2;\n  long long_var2;\n  undefined8 *bfd_file_ptr;\n  char *temp_dir;\n  char **bfd_archive_file_ptr;\n  char *path_name1;\n  char *path_name2;\n  undefined8 *__ptr;\n  char **bfd_archive_file_ptr_temp;\n  code *pchar_var10;\n  long long_var3;\n  uint uint_var;\n  char *path_name4;\n  stat *stat_ptr;\n  bool bool_var;\n  byte byte_var2;\n  undefined8 *output_file_ptr;\n  long *long_ptr;\n  stat local_158;\n  void *void_ptr_array [3];\n  uint Uint_stack_var;\n  long long_stack_var;\n  \n  byte_var2 = 0;\n  long_var2 = FUN_00113f50();\n  if (long_var2 < 1) {\n    if (long_var2 == 0) {\n      undefined8_var2 = dcgettext(0,\"error: the input file \\'%s\\' is empty\",5);\n      FUN_00119ed0(undefined8_var2,input_file);\n    }\n    DAT_00127a40 = 1;\n    return;\n  }\n  bfd_file_ptr = (undefined8 *)bfd_openr(input_file,bfd_flags);\n  if ((bfd_file_ptr == (undefined8 *)0x0) || (int_var2 = bfd_stat(bfd_file_ptr,stat_struct), int_var2 != 0)) {\n    FUN_001126c0(input_file,0,0,0);\n    DAT_00127a40 = 1;\n    return;\n  }\n  switch(DAT_001279a4) {\n  case 1:\n  case 3:\n  case 9:\n    *(uint *)((long)bfd_file_ptr + 0x44) = *(uint *)((long)bfd_file_ptr + 0x44) | 0x24000;\n    break;\n  case 5:\n    *(uint *)((long)bfd_file_ptr + 0x44) = *(uint *)((long)bfd_file_ptr + 0x44) | 0x4000;\n    break;\n  case 0x11:\n    *(uint *)((long)bfd_file_ptr + 0x44) = *(uint *)((long)bfd_file_ptr + 0x44) | 0x424000;\n    break;\n  case 0x20:\n    *(uint *)((long)bfd_file_ptr + 0x44) = *(uint *)((long)bfd_file_ptr + 0x44) | 0x8000;\n  }\n  if (DAT_0012799c == 1) {\n    *(uint *)((long)bfd_file_ptr + 0x44) = *(uint *)((long)bfd_file_ptr + 0x44) | 0xc0000;\n  }\n  else if (DAT_0012799c == 2) {\n    *(uint *)((long)bfd_file_ptr + 0x44) = *(uint *)((long)bfd_file_ptr + 0x44) | 0x40000;\n  }\n  char_var1 = bfd_check_format(bfd_file_ptr,2);\n  if (char_var1 != '\\0') {\n    if (target_file_size == 0) {\n      char_var1 = '\\0';\n      target_file_size = *(long *)bfd_file_ptr[1];\n    }\n    if (file_descriptor < 0) {\n      output_file_ptr = (undefined8 *)bfd_openw(output_file,target_file_size);\n    }\n    else {\n      output_file_ptr = (undefined8 *)bfd_fdopenw(output_file,target_file_size,file_descriptor);\n    }\n    if (output_file_ptr != (undefined8 *)0x0) {\n      if (DAT_00127a30 != 0) {\n        undefined8_var2 = *bfd_file_ptr;\n        undefined8_var1 = dcgettext(0,\"--add-gnu-debuglink ignored for archive %s\",5);\n        FUN_00119ed0(undefined8_var1,undefined8_var2);\n        DAT_00127a30 = 0;\n      }\n      FUN_00114d50(output_file_ptr,bfd_file_ptr,DAT_001264b4);\n      long_ptr = output_file_ptr + 0x1f;\n      if ((*(byte *)((long)bfd_file_ptr + 0x49) & 0x10) != 0) {\n        DAT_00127a40 = 1;\n        bfd_set_error(5);\n        undefined8_var2 = dcgettext(0,\"sorry: copying thin archives is not currently supported\",5);\n        FUN_001126c0(0,bfd_file_ptr,0,undefined8_var2);\n        return;\n      }\n      temp_dir = (char *)FUN_0011a0e0(*output_file_ptr);\n      if (temp_dir == (char *)0x0) {\n        int_ptr = __errno_location();\n        temp_dir = strerror(*int_ptr);\n        undefined8_var2 = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n                    \n        FUN_00119dd0(undefined8_var2,temp_dir);\n      }\n      if (DAT_00127a48 == 7) {\n        byte_var = *(byte *)((long)bfd_file_ptr + 0x49);\n        uint_var = 0;\n      }\n      else {\n        byte_var = *(byte *)((long)bfd_file_ptr + 0x49);\n        uint_var = byte_var >> 3 & 1;\n      }\n      bool_var = _DAT_001264b0 != 0;\n      *(byte *)((long)output_file_ptr + 0x49) =\n           byte_var & 0x10 | (byte)(uint_var << 3) | *(byte *)((long)output_file_ptr + 0x49) & 0xe7;\n      if (bool_var) {\n        *(uint *)((long)output_file_ptr + 0x44) = *(uint *)((long)output_file_ptr + 0x44) | 0x2000;\n      }\n      __ptr = (undefined8 *)0x0;\n      bfd_archive_file_ptr = (char **)bfd_openr_next_archived_file(bfd_file_ptr,0);\n      char_var2 = bfd_set_format(output_file_ptr,*(byte *)(bfd_file_ptr + 9) & 7);\n      if (char_var2 == '\\0') {\n        DAT_00127a40 = 1;\n        FUN_001126c0(0,output_file_ptr,0,0);\n        FUN_00114b84();\n        return;\n      }\n      while ((DAT_00127a40 == 0 && (bfd_archive_file_ptr != (char **)0x0))) {\n        path_name2 = *bfd_archive_file_ptr;\n        path_name1 = path_name2;\n        if (*path_name2 == '/') {\nLAB_0010527d:\n          undefined8_var2 = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n          FUN_00119ed0(undefined8_var2,path_name2);\nLAB_00104e93:\n          DAT_00127a40 = 1;\n          goto LAB_00114b4b;\n        }\n        while (*path_name1 != '\\0') {\n          path_name4 = path_name1;\n          if ((*path_name1 == '.') && (path_name4 = path_name1 + 1, path_name1[1] == '.')) {\n            path_name4 = path_name1 + 2;\n            if ((path_name1[2] == '\\0') || (path_name1[2] == '/')) goto LAB_0010527d;\n          }\n          for (; (*path_name4 != '\\0' && (*path_name4 != '/')); path_name4 = path_name4 + 1) {\n          }\n          path_name1 = path_name4;\n          if (*path_name4 == '/') {\n            FUN_001052a2();\n            return;\n          }\n        }\n        path_name2 = (char *)concat(temp_dir,&DAT_0011b47d);\n        int_var2 = stat(path_name2,&local_158);\n        undefined8_ptr = __ptr;\n        if (-1 < int_var2) {\n          long_var2 = FUN_0011a0e0(path_name2);\n          free(path_name2);\n          if (long_var2 == 0) {\n            int_ptr = __errno_location();\n            path_name2 = strerror(*int_ptr);\n            undefined8_var2 = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n            FUN_00119ed0(undefined8_var2,path_name2);\n            goto LAB_00104e93;\n          }\n          undefined8_ptr = (undefined8 *)xmalloc(0x18);\n          path_name2 = *bfd_archive_file_ptr;\n          *undefined8_ptr = __ptr;\n          undefined8_ptr[2] = 0;\n          undefined8_ptr[1] = long_var2;\n          path_name2 = (char *)concat(long_var2,&DAT_0011b47d,path_name2);\n        }\n        int_var2 = 0;\n        if (DAT_001279eb != '\\0') {\n          stat_ptr = &local_158;\n          for (long_var2 = 0x24; long_var2 != 0; long_var2 = long_var2 + -1) {\n            *(undefined4 *)&stat_ptr->st_dev = 0;\n            stat_ptr = (stat *)((long)stat_ptr + (ulong)byte_var2 * -8 + 4);\n          }\n          bfd_archive_file_ptr_temp = (char **)bfd_archive_file_ptr[0x1d];\n          if ((char **)bfd_archive_file_ptr[0x1d] == (char **)0x0) {\n            bfd_archive_file_ptr_temp = bfd_archive_file_ptr;\n          }\n          int_var2 = (**(code **)(bfd_archive_file_ptr_temp[1] + 0x1e8))(bfd_archive_file_ptr,&local_158);\n          if (int_var2 != 0) {\n            path_name1 = *bfd_archive_file_ptr;\n            undefined8_var2 = dcgettext(0,\"internal stat error on %s\",5);\n            FUN_00119ed0(undefined8_var2,path_name1);\n          }\n        }\n        __ptr = (undefined8 *)xmalloc(0x18);\n        __ptr[1] = path_name2;\n        *__ptr = undefined8_ptr;\n        __ptr[2] = 0;\n        char_var2 = bfd_check_format(bfd_archive_file_ptr,1);\n        if (char_var2 == '\\0') {\n          undefined8_var2 = dcgettext(0,\"Unable to recognise the format of file\",5);\n          FUN_001126c0(0,bfd_archive_file_ptr,0,undefined8_var2);\n          bfd_archive_file_ptr_temp = (char **)bfd_openw(path_name2,target_file_size);\n          if (bfd_archive_file_ptr_temp == (char **)0x0) {\nLAB_00104e80:\n            FUN_001126c0(path_name2,0,0,0);\n            goto LAB_00104e93;\n          }\nLAB_00104d75:\n          char_ptr_ptr = (char **)bfd_archive_file_ptr[0x1d];\n          if ((char **)bfd_archive_file_ptr[0x1d] == (char **)0x0) {\n            char_ptr_ptr = bfd_archive_file_ptr;\n          }\n          int_var1 = (**(code **)(char_ptr_ptr[1] + 0x1e8))(bfd_archive_file_ptr);\n          long_var2 = long_stack_var;\n          if (int_var1 == 0) {\n            if (long_stack_var < 0) {\n              FUN_001125fa(bfd_archive_file_ptr);\n              undefined8_var2 = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n              FUN_00119ed0(undefined8_var2);\n            }\n            else {\n              int_var1 = bfd_seek(bfd_archive_file_ptr,0,0);\n              if (int_var1 == 0) {\n                if (DAT_001279e9 != '\\0') {\n                  path_name1 = *bfd_archive_file_ptr_temp;\n                  undefined8_var2 = FUN_001125fa(bfd_archive_file_ptr);\n                  path_name4 = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n                  printf(path_name4,undefined8_var2,path_name1);\n                }\n                void_ptr = (void *)xmalloc(0x2000);\n                for (; long_var2 != 0; long_var2 = long_var2 - long_var3) {\n                  long_var3 = 0x2000;\n                  if (long_var2 < 0x2001) {\n                    long_var3 = long_var2;\n                  }\n                  long_var1 = bfd_bread(void_ptr,long_var3,bfd_archive_file_ptr);\n                  char_ptr_ptr = bfd_archive_file_ptr;\n                  if ((long_var3 != long_var1) ||\n                     (long_var1 = bfd_bwrite(void_ptr,long_var3,bfd_archive_file_ptr_temp), char_ptr_ptr = bfd_archive_file_ptr_temp,\n                     long_var3 != long_var1)) {\n                    FUN_001126c0(0,char_ptr_ptr,0,0);\n                    free(void_ptr);\n                    goto LAB_00104f00;\n                  }\n                }\n                chmod(*bfd_archive_file_ptr_temp,Uint_stack_var | 0x100);\n                free(void_ptr);\n                char_var2 = bfd_close_all_done(bfd_archive_file_ptr_temp);\n                if (char_var2 == '\\0') {\n                  FUN_001126c0(path_name2,0,0,0);\n                  DAT_00127a40 = 1;\n                }\n                goto LAB_00114a86;\n              }\n              undefined8_var2 = FUN_001125fa(bfd_archive_file_ptr);\n              FUN_0011a110(undefined8_var2);\n            }\n          }\n          else {\n            FUN_001126c0(0,bfd_archive_file_ptr,0,0);\n          }\nLAB_00104f00:\n          char_var2 = bfd_close_all_done(bfd_archive_file_ptr_temp);\n          if (char_var2 == '\\0') {\n            FUN_001126c0(path_name2,0,0,0);\n          }\nLAB_00104ec9:\n          unlink(path_name2);\n          DAT_00127a40 = 1;\n        }\n        else {\n          if (char_var1 == '\\0') {\n            bfd_archive_file_ptr_temp = (char **)bfd_openw(path_name2,*(undefined8 *)bfd_archive_file_ptr[1]);\n          }\n          else {\n            bfd_archive_file_ptr_temp = (char **)bfd_openw(path_name2,target_file_size);\n          }\n          if (bfd_archive_file_ptr_temp == (char **)0x0) goto LAB_00104e80;\n          char_var2 = FUNC_00114e50(bfd_archive_file_ptr,bfd_archive_file_ptr_temp,compilation_date);\n          if (char_var2 == '\\0') {\n            int_var1 = bfd_get_arch(bfd_archive_file_ptr);\n            if (int_var1 == 0) goto LAB_00104d75;\n            char_var2 = bfd_close_all_done(bfd_archive_file_ptr_temp);\n            if (char_var2 == '\\0') {\n              FUN_001126c0(path_name2,0,0,0);\n            }\n            goto LAB_00104ec9;\n          }\n          char_var2 = bfd_close(bfd_archive_file_ptr_temp);\n          if (char_var2 == '\\0') {\n            FUN_001126c0(path_name2,0,0,0);\n            DAT_00127a40 = 1;\n          }\nLAB_00114a86:\n          if ((DAT_001279eb != '\\0') && (int_var2 == 0)) {\n            FUN_0011a350(path_name2,&local_158);\n          }\n          long_var2 = bfd_openr(path_name2,target_file_size);\n          __ptr[2] = long_var2;\n          *long_ptr = long_var2;\n          long_ptr = (long *)(long_var2 + 0xf0);\n          bfd_archive_file_ptr_temp = (char **)bfd_openr_next_archived_file(bfd_file_ptr);\n          bfd_close(bfd_archive_file_ptr);\n          bfd_archive_file_ptr = bfd_archive_file_ptr_temp;\n        }\n      }\n      *long_ptr = 0;\n      void_ptr = (void *)xstrdup(*output_file_ptr);\n      if (DAT_00127a40 == 0) {\n        pchar_var10 = bfd_close;\n      }\n      else {\n        pchar_var10 = bfd_close_all_done;\n      }\n      char_var1 = (*pchar_var10)(output_file_ptr);\n      if (char_var1 == '\\0') {\n        DAT_00127a40 = 1;\n        FUN_001126c0(void_ptr,0,0,0);\n      }\n      free(void_ptr);\n      void_ptr = (void *)xstrdup(*bfd_file_ptr);\n      char_var1 = bfd_close(bfd_file_ptr);\n      if (char_var1 == '\\0') {\n        DAT_00127a40 = 1;\n        FUN_001126c0(void_ptr,0,0,0);\n      }\n      free(void_ptr);\nLAB_00114b4b:\n      while (__ptr != (undefined8 *)0x0) {\n        if (__ptr[2] == 0) {\n          rmdir((char *)__ptr[1]);\n        }\n        else {\n          bfd_close();\n          unlink((char *)__ptr[1]);\n        }\n        free((void *)__ptr[1]);\n        bfd_file_ptr = (undefined8 *)*__ptr;\n        free(__ptr);\n        __ptr = bfd_file_ptr;\n      }\n      rmdir(temp_dir);\n      free(temp_dir);\n      return;\n    }\nLAB_00105231:\n    close(file_descriptor);\n    FUN_001126c0(output_file,0,0,0);\n    DAT_00127a40 = 1;\n    return;\n  }\n  char_var1 = bfd_check_format_matches(bfd_file_ptr,1,void_ptr_array);\n  if (char_var1 == '\\0') {\n    int_var2 = bfd_get_error();\n    char_var1 = bfd_check_format_matches(bfd_file_ptr,3,&local_158);\n    if (char_var1 == '\\0') {\n      int_var1 = bfd_get_error();\n      if (int_var2 != int_var1) {\n        bfd_set_error(int_var2);\n      }\n      FUN_001126c0(input_file,0,0,0);\n      if (int_var2 == 0xd) {\n        FUN_0011256b(void_ptr_array[0]);\n      }\n      if (int_var1 != 0xd) {\n        DAT_00127a40 = 1;\n        return;\n      }\n      FUN_0011256b(local_158.st_dev);\n      DAT_00127a40 = 1;\n      return;\n    }\n    if (int_var2 == 0xd) {\n      free(void_ptr_array[0]);\n    }\n  }\n  if (target_file_size == 0) {\n    target_file_size = *(long *)bfd_file_ptr[1];\n  }\n  if (file_descriptor < 0) {\n    long_var2 = bfd_openw(output_file,target_file_size);\n  }\n  else {\n    long_var2 = bfd_fdopenw(output_file,target_file_size,file_descriptor);\n  }\n  if (long_var2 == 0) goto LAB_00105231;\n  FUN_00114d50(long_var2,bfd_file_ptr,DAT_001264b4);\n  char_var1 = FUNC_00114e50(bfd_file_ptr,long_var2,compilation_date);\n  if (char_var1 == '\\0') {\n    DAT_00127a40 = 1;\n  }\n  else if (DAT_00127a40 == 0) {\n    char_var1 = bfd_close(long_var2);\n    goto LAB_001147d5;\n  }\n  char_var1 = bfd_close_all_done(long_var2);\nLAB_001147d5:\n  if (char_var1 != '\\x01') {\n    DAT_00127a40 = 1;\n    FUN_001126c0(output_file,0,0,0);\n    return;\n  }\n  char_var1 = bfd_close(bfd_file_ptr);\n  if (char_var1 == '\\0') {\n    DAT_00127a40 = 1;\n    FUN_001126c0(input_file,0,0,0);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00113f50",
                "strerror",
                "FUN_0011256b",
                "FUN_001126c0",
                "bfd_openr_next_archived_file",
                "bfd_set_format",
                "bfd_get_error",
                "FUN_00104d25",
                "FUN_00119dd0",
                "bfd_openr",
                "FUN_00114d50",
                "bfd_fdopenw",
                "bfd_set_error",
                "bfd_stat",
                "FUN_00119ed0",
                "bfd_close_all_done",
                "bfd_check_format",
                "bfd_check_format_matches",
                "bfd_openw",
                "FUN_0011a0e0",
                "__errno_location",
                "free",
                "close",
                "bfd_close",
                "FUN_00114e50"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114690",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "extract_and_copy_archive_00114690"
        },
        "FUN_0010b800": {
            "renaming": {
                "FUN_0010b800": "process_stab_int_type_0010b800",
                "param_1": "baseAddress",
                "param_2": "size",
                "param_3": "isNegative",
                "plVar1": "pointer",
                "uVar2": "returnValue",
                "sVar3": "strLength",
                "lVar4": "tempVar1",
                "lVar5": "tempVar2",
                "local_8c": "outputString",
                "auStack_8a": "buffer"
            },
            "code": "\nundefined8 processStabIntType_0010b800(long baseAddress,int size,char isNegative)\n\n{\n  long *pointer;\n  undefined8 returnValue;\n  size_t strLength;\n  long tempVar1;\n  long tempVar2;\n  undefined2 outputString;\n  undefined4 buffer [24];\n  \n  if (size - 1U < 8) {\n    tempVar1 = baseAddress + 0xb8;\n    if (isNegative != '\\0') {\n      tempVar1 = baseAddress + 0x78;\n    }\n    pointer = (long *)(tempVar1 + (ulong)(size - 1U) * 8);\n    tempVar1 = *pointer;\n    if (tempVar1 != 0) {\n      returnValue = FUN_00109cf4(baseAddress,tempVar1,size);\n      return returnValue;\n    }\n    tempVar1 = *(long *)(baseAddress + 0x68);\n    *(long *)(baseAddress + 0x68) = tempVar1 + 1;\n    *pointer = tempVar1;\n    sprintf((char *)&outputString,\"%ld=r%ld;\",tempVar1,tempVar1);\n    if (isNegative == '\\0') {\n      tempVar2 = 1L << ((char)size * '\\b' - 1U & 0x3f);\n      strLength = strlen((char *)&outputString);\n      sprintf((char *)((long)&outputString + strLength),\"%ld;%ld;\",-tempVar2,tempVar2 + -1);\n    }\n    else {\n      strLength = strlen((char *)&outputString);\n      *(undefined2 *)((long)&outputString + strLength) = 0x3b30;\n      *(undefined *)((long)&outputString + strLength + 2) = 0;\n      if (size == 8) {\n        *(undefined4 *)((long)&outputString + strLength + 2) = 0x3b312d;\n      }\n      else {\n        sprintf((char *)((long)&outputString + strLength + 2),\"%ld;\",\n                (1L << ((char)size * '\\b' & 0x3fU)) + -1);\n      }\n    }\n    returnValue = FUN_00109b52(baseAddress,&outputString,tempVar1,1,size);\n  }\n  else {\n    returnValue = dcgettext(0,\"stab_int_type: bad size %u\",5);\n    FUN_00119ed0(returnValue,size);\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00109b52",
                "FUN_00119ed0",
                "sprintf",
                "FUN_00109cf4",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b800",
            "calling": [
                "FUN_0010b948",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_stab_int_type_0010b800"
        },
        "FUN_00109ed3": {
            "renaming": {
                "FUN_00109ed3": "process_data_00109ed3",
                "param_1": "inputData",
                "param_2": "code",
                "param_3": "flag",
                "param_4": "outputData",
                "param_5": "outputSize",
                "uVar1": "size",
                "uVar2": "newSize",
                "cVar3": "result",
                "pcVar4": "stringPtr",
                "sVar5": "stringLength",
                "__s": "newString",
                "lVar6": "iterator",
                "__ptr": "tempPtr",
                "uVar7": "returnValue",
                "uVar8": "isNew",
                "lVar9": "remainingSize",
                "uVar10": "currentSize",
                "puVar11": "ptr",
                "bVar12": "flag2"
            },
            "code": "\nundefined8 processData_00109ed3(long inputData,uint code,undefined4 flag,long *outputData,ulong *outputSize)\n\n{\n  ulong size;\n  ulong newSize;\n  char result;\n  char *stringPtr;\n  size_t stringLength;\n  char *newString;\n  long iterator;\n  void *tempPtr;\n  undefined8 returnValue;\n  undefined isNew;\n  long remainingSize;\n  ulong currentSize;\n  undefined *ptr;\n  byte flag2;\n  \n  flag2 = 0;\n  iterator = *(long *)(inputData + 0x60);\n  if (iterator != 0) {\n    size = *(ulong *)(iterator + 0x10);\n    if (((long)size < 1) || (outputData == (long *)0x0)) {\n      isNew = *(undefined *)(iterator + 0x1c);\n      stringPtr = (char *)FUN_00109b2f(inputData);\n      stringLength = strlen(stringPtr);\n      newString = (char *)xmalloc(stringLength + 2);\n      sprintf(newString,\"%c%s\",(ulong)code,stringPtr);\n      free(stringPtr);\n      iterator = 0;\n    }\n    else {\n      currentSize = *outputSize;\n      if (currentSize <= size) {\n        if (currentSize == 0) {\n          currentSize = 10;\n        }\n        for (; currentSize <= size; currentSize = currentSize * 2) {\n        }\n        iterator = xrealloc(*outputData,currentSize * 8);\n        newSize = *outputSize;\n        *outputData = iterator;\n        ptr = (undefined *)(iterator + newSize * 8);\n        for (remainingSize = (currentSize - newSize) * 8; remainingSize != 0; remainingSize = remainingSize + -1) {\n          *ptr = 0;\n          ptr = ptr + (ulong)flag2 * -2 + 1;\n        }\n        *outputSize = currentSize;\n      }\n      iterator = *(long *)(*outputData + size * 8);\n      if ((iterator != 0) && (*(char *)(*(long *)(inputData + 0x60) + 0x1c) == '\\0')) {\n        tempPtr = (void *)FUN_00109b2f(inputData);\n        free(tempPtr);\n        returnValue = FUN_00109cf4(inputData,iterator,flag);\n        return returnValue;\n      }\n      iterator = *(long *)(inputData + 0x68);\n      *(long *)(inputData + 0x68) = iterator + 1;\n      stringPtr = (char *)FUN_00109b2f(inputData);\n      stringLength = strlen(stringPtr);\n      newString = (char *)xmalloc(stringLength + 0x14);\n      sprintf(newString,\"%ld=%c%s\",iterator,(ulong)code,stringPtr);\n      free(stringPtr);\n      isNew = 1;\n      *(long *)(*outputData + size * 8) = iterator;\n    }\n    result = FUN_00109b52(inputData,newString,iterator,isNew,flag);\n    if (result != '\\0') {\n      free(newString);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00109b52",
                "free",
                "xrealloc",
                "sprintf",
                "FUN_00109cf4",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109ed3",
            "calling": [
                "FUN_0010e5db",
                "FUN_0010a0bd",
                "FUN_0010a083",
                "FUN_0010a0d3",
                "FUN_0010a0a0"
            ],
            "imported": false,
            "current_name": "process_data_00109ed3"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104390",
            "calling": [
                "FUN_001125fa",
                "FUN_00116b90",
                "FUN_0010c05d",
                "FUN_0010c7a0",
                "FUN_001163d0",
                "FUN_0010bd62",
                "FUN_00108f08",
                "FUN_00113bfa",
                "FUN_00108c86",
                "FUN_0010e6a8",
                "FUN_00108d9a",
                "FUN_0010c139",
                "FUN_0010a2b9",
                "FUN_0010e918",
                "FUN_00114460",
                "FUN_0010a77a",
                "FUN_0010554f",
                "FUN_0010e7c2",
                "FUN_0010dac0",
                "FUN_0010ba08",
                "FUN_0010e8a9",
                "FUN_00109022",
                "FUN_00114190",
                "FUN_0010e453",
                "FUN_0010c218",
                "FUN_00116110",
                "FUN_0010bbd3",
                "FUN_0010ebb0",
                "FUN_00115530",
                "FUN_0010c6be",
                "FUN_0010a83e",
                "FUN_0010e842",
                "FUN_00113c43",
                "FUN_00116852",
                "FUN_0010ae0e",
                "FUN_00113e23",
                "FUN_0010a94e",
                "FUN_0010e5db",
                "FUN_00109b52",
                "FUN_00114cf0",
                "FUN_00112925",
                "FUN_00107880",
                "FUN_0011a480",
                "FUN_0010afd5",
                "FUN_0010ab4d",
                "FUN_0010a181",
                "FUN_0011173a",
                "FUN_00112894",
                "FUN_00113ce0",
                "FUN_0010e07c",
                "FUN_00114d60",
                "FUN_001199d0",
                "FUN_0011378f",
                "FUN_0010eafe",
                "FUN_0010e9a0",
                "FUN_0010ee3f",
                "FUN_0010a69a",
                "FUN_00116030",
                "FUN_00109ed3",
                "FUN_0010aa53",
                "FUN_00104ea2",
                "FUN_00114c80",
                "FUN_0010b6ea",
                "FUN_0010bf86",
                "FUN_0010a424",
                "FUN_00113da9",
                "FUN_00113d6e",
                "FUN_00112904",
                "FUN_0010a0e9",
                "FUN_0010da0b",
                "FUN_0010a377",
                "FUN_0010bc80",
                "FUN_0010d882",
                "FUN_00104ad6",
                "FUN_0010be88",
                "FUN_00113b98",
                "FUN_00109a0b"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "FUN_0010bbd3": {
            "renaming": {
                "FUN_0010bbd3": "initialize_debug_info_0010bbd3",
                "param_1": "debugInfo",
                "param_2": "filename",
                "param_3": "param3",
                "param_4": "param4",
                "puVar1": "prevDebugInfo",
                "puVar2": "units",
                "puVar3": "newDebugInfo",
                "lVar4": "loopCounter",
                "puVar5": "pointer",
                "pcVar6": "tempFilename",
                "bVar7": "flag",
                "auVar8": "returnValue"
            },
            "code": "\nundefined  [16] initializeDebugInfo_0010bbd3(long *debugInfo,char *filename,undefined8 param3,undefined8 param4)\n\n{\n  undefined8 *prevDebugInfo;\n  undefined4 *units;\n  undefined4 *newDebugInfo;\n  long loopCounter;\n  undefined4 *pointer;\n  char *tempFilename;\n  byte flag;\n  undefined returnValue [16];\n  \n  flag = 0;\n  tempFilename = \"\";\n  if (filename != (char *)0x0) {\n    tempFilename = filename;\n  }\n  units = (undefined4 *)xmalloc(0x18);\n  pointer = units;\n  for (loopCounter = 6; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *pointer = 0;\n    pointer = pointer + (ulong)flag * -2 + 1;\n  }\n  *(char **)(units + 2) = tempFilename;\n  newDebugInfo = (undefined4 *)xmalloc(0x18);\n  debugInfo[2] = (long)units;\n  pointer = newDebugInfo;\n  for (loopCounter = 6; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *pointer = 0;\n    pointer = pointer + (ulong)flag * -2 + 1;\n  }\n  prevDebugInfo = (undefined8 *)debugInfo[1];\n  *(undefined4 **)(newDebugInfo + 2) = units;\n  if (prevDebugInfo == (undefined8 *)0x0) {\n    if (*debugInfo != 0) {\n                    \n      __assert_fail(\"info->units == NULL\",\"../../binutils/debug.c\",699,\"debug_set_filename\");\n    }\n    *debugInfo = (long)newDebugInfo;\n  }\n  else {\n    *prevDebugInfo = newDebugInfo;\n  }\n  debugInfo[1] = (long)newDebugInfo;\n  debugInfo[5] = 0;\n  *(undefined (*) [16])(debugInfo + 3) = ZEXT816(0);\n  returnValue._8_8_ = param4;\n  returnValue._0_8_ = 1;\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "__assert_fail"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bbd3",
            "calling": [
                "FUN_0010554f",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "initialize_debug_info_0010bbd3"
        },
        "FUN_00114e50": {
            "renaming": {
                "FUN_00114e50": "FUNC_00114e50"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00114e50(undefined8 *param_1,long param_2,long param_3)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  ushort uVar9;\n  char cVar10;\n  char cVar11;\n  int iVar12;\n  int iVar13;\n  undefined4 uVar14;\n  long *plVar15;\n  long lVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar22;\n  long lVar23;\n  ulong uVar24;\n  int *piVar25;\n  ulong uVar26;\n  FILE *__s_00;\n  long **pplVar27;\n  uint uVar28;\n  long **__ptr_01;\n  char *pcVar29;\n  undefined8 *puVar30;\n  ulong uVar31;\n  int iVar32;\n  long **pplVar33;\n  char *pcVar34;\n  long lVar35;\n  undefined4 *puVar36;\n  ulong *puVar37;\n  undefined8 *puVar38;\n  uint uVar39;\n  char **ppcVar40;\n  void *pvVar41;\n  undefined **ppuVar42;\n  bool bVar43;\n  byte bVar44;\n  ulong uStack_1f8;\n  ulong local_1f0;\n  undefined4 *puStack_1e8;\n  char *pcStack_1d0;\n  int *piStack_1c0;\n  long lStack_190;\n  long lStack_180;\n  char *pcStack_178;\n  long lStack_168;\n  long *plStack_148;\n  ulong uStack_140;\n  long lStack_138;\n  long lStack_130;\n  void *apvStack_128 [2];\n  long lStack_118;\n  ushort uStack_10a;\n  byte bStack_108;\n  byte bStack_107;\n  undefined8 uStack_f8;\n  ushort uStack_f0;\n  char *pcStack_c8;\n  ulong uStack_c0;\n  char *pcStack_b8;\n  undefined uStack_b0;\n  short sStack_ae;\n  \n  bVar44 = 0;\n  iVar13 = *(int *)(*(long *)(param_2 + 8) + 0xc);\n  local_1f0._0_1_ =\n       (*(int *)(param_1[1] + 0xc) != iVar13 && *(int *)(param_1[1] + 0xc) != 2) && iVar13 != 2;\n  if ((bool)(char)local_1f0) {\n    uVar18 = FUN_001125fa();\n    uVar17 = dcgettext(0,\"unable to change endianness of \\'%s\\'\",5);\n    FUN_00119ed0(uVar17,uVar18);\n    return 0;\n  }\n  if ((*(byte *)((long)param_1 + 0x4a) & 0x20) != 0) {\n    uVar18 = FUN_001125fa();\n    uVar17 = dcgettext(0,\"unable to modify \\'%s\\' due to errors\",5);\n    FUN_00119ed0(uVar17,uVar18);\n    return 0;\n  }\n  cVar11 = bfd_set_format(param_2,*(byte *)(param_1 + 9) & 7);\n  if (cVar11 == '\\0') {\n    FUN_001126c0(0,param_2,0,0);\n    return 0;\n  }\n  if (param_1[0x12] == 0) {\n    uVar18 = FUN_001125fa(param_1);\n    uVar17 = dcgettext(0,\"error: the input file \\'%s\\' has no sections\",5);\n    FUN_00119ed0(uVar17,uVar18);\n    return 0;\n  }\n  _VerilogDataEndianness = *(undefined4 *)(param_1[1] + 0xc);\n  if (*(int *)(param_1[1] + 8) == 5) {\n    if (DAT_001279e9 != '\\0') {\n      uVar26 = FUNC_00107976();\n      return uVar26;\n    }\n  }\n  else {\n    if ((DAT_001279a4 != 1) && ((DAT_001279a4 & 1) != 0)) {\n      uVar18 = FUN_001125fa(param_1);\n      uVar17 = dcgettext(0,\n                         \"--compress-debug-sections=[zlib|zlib-gnu|zlib-gabi|zstd] is unsupported on `%s\\'\"\n                         ,5);\n      FUN_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    if (DAT_0012799c != 0) {\n      uVar18 = FUN_001125fa(param_1);\n      uVar17 = dcgettext(0,\"--elf-stt-common=[yes|no] is unsupported on `%s\\'\",5);\n      FUN_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    if (DAT_001279e9 != '\\0') {\n      uVar26 = FUNC_00107976();\n      return uVar26;\n    }\n  }\n  if (DAT_0012790c == '\\0') {\n    if (DAT_00127978 == '\\0') {\n      lVar35 = DAT_001279b8 + param_1[0x17];\n    }\n    else {\n      lVar35 = DAT_001279b8 + _DAT_00127980;\n    }\n  }\n  else {\n    lVar35 = 0;\n  }\n  if ((*(byte *)(param_2 + 0x48) & 7) == 3) {\n    iVar13 = bfd_get_arch(param_1,lVar35);\n    uVar14 = bfd_get_mach(param_1);\n    if (param_3 != 0) {\n      uVar26 = FUNC_001152b6();\n      return uVar26;\n    }\n    goto LAB_00114f9a;\n  }\n  uVar28 = ~DAT_00127910 & *(uint *)(*(long *)(param_2 + 8) + 0x14) &\n           (DAT_00127914 | *(uint *)((long)param_1 + 0x44));\n  if (DAT_00127a48 == 7) {\n    uVar28 = uVar28 & 0xfffffffe;\n    cVar11 = bfd_set_start_address(param_2);\n  }\n  else {\n    cVar11 = bfd_set_start_address(param_2);\n  }\n  if ((cVar11 == '\\0') || (cVar11 = bfd_set_file_flags(param_2,uVar28), cVar11 == '\\0'))\n  goto LAB_00107a82;\n  iVar13 = bfd_get_arch(param_1);\n  uVar14 = bfd_get_mach(param_1);\n  if (param_3 == 0) {\nLAB_00114f9a:\n    if (((iVar13 == 0) && (*(int *)(param_1[1] + 8) != 5)) &&\n       (*(int *)(*(long *)(param_2 + 8) + 8) == 5)) {\n      uVar26 = FUNC_00107880();\n      return uVar26;\n    }\n  }\n  else {\n    if (iVar13 == 0) {\n      iVar13 = *(int *)(param_3 + 0xc);\n      uVar14 = *(undefined4 *)(param_3 + 0x10);\n      goto LAB_00114f9a;\n    }\n    uVar18 = FUN_001125fa(param_1);\n    uVar17 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    FUN_00119ed0(uVar17,uVar18);\n  }\n  cVar11 = (**(code **)(*(long *)(param_2 + 8) + 0x2a0))(param_2,iVar13,uVar14);\n  if (cVar11 == '\\0') {\n    if ((*(byte *)(param_1 + 9) & 0x40) != 0) {\n      iVar13 = bfd_get_arch(param_1);\n      if (iVar13 == 0) {\n        uVar18 = FUN_001125fa(param_1);\n        uVar17 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        FUN_00119ed0(uVar17,uVar18);\n        return 0;\n      }\n      uVar18 = bfd_get_mach(param_1);\n      uVar14 = bfd_get_arch(param_1);\n      uVar18 = bfd_printable_arch_mach(uVar14,uVar18);\n      uVar17 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      FUN_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    iVar13 = bfd_get_arch(param_1);\n    iVar32 = bfd_get_arch(param_2);\n    if (iVar13 != iVar32) {\n      uVar26 = FUN_00105828();\n      return uVar26;\n    }\n  }\n  cVar11 = bfd_set_format(param_2,*(byte *)(param_1 + 9) & 7);\n  if (cVar11 == '\\0') {\nLAB_00107a82:\n    FUN_001126c0(0,param_1,0,0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_2 + 8) + 1) == 2) &&\n     (cVar11 = FUN_00113fb0(**(undefined8 **)(param_2 + 8),&DAT_0011b503), cVar11 != '\\0')) {\n    lVar35 = *(long *)(param_2 + 0x110);\n    if ((*(int *)((undefined8 *)param_1[1] + 1) == 2) &&\n       (cVar11 = FUN_00113fb0(*(undefined8 *)param_1[1],&DAT_0011b503), cVar11 != '\\0')) {\n      lVar16 = param_1[0x22];\n      bVar43 = DAT_001279eb == '\\0';\n      puVar30 = (undefined8 *)(lVar16 + 200);\n      puVar38 = (undefined8 *)(lVar35 + 200);\n      for (lVar23 = 0x32; lVar23 != 0; lVar23 = lVar23 + -1) {\n        *puVar38 = *puVar30;\n        puVar30 = puVar30 + (ulong)bVar44 * -2 + 1;\n        puVar38 = puVar38 + (ulong)bVar44 * -2 + 1;\n      }\n      if (bVar43) {\n        *(undefined4 *)(lVar35 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar35 + 0x2a4) = (int)*(undefined8 *)(lVar16 + 0xa8);\n      }\n    }\n    uVar26 = DAT_001264a8;\n    if (DAT_001264a8 == 0xffffffffffffffff) {\n      DAT_001264a8 = 0x200;\n      uVar26 = 0x200;\n    }\n    else {\n      *(int *)(lVar35 + 0x10c) = (int)DAT_001264a8;\n    }\n    if (DAT_00126498 != -1) {\n      *(long *)(lVar35 + 0x148) = DAT_00126498;\n    }\n    if (DAT_001264a0 != -1) {\n      *(long *)(lVar35 + 0x148) = DAT_001264a0;\n    }\n    if (DAT_00126490 != -1) {\n      *(long *)(lVar35 + 0x100) = DAT_00126490;\n    }\n    uVar22 = DAT_00126488;\n    if (DAT_00126488 == 0xffffffffffffffff) {\n      DAT_00126488 = 0x1000;\n      uVar22 = 0x1000;\n    }\n    else {\n      *(int *)(lVar35 + 0x108) = (int)DAT_00126488;\n    }\n    if (DAT_00126478 != -1) {\n      *(long *)(lVar35 + 0x138) = DAT_00126478;\n    }\n    if (DAT_00126480 != -1) {\n      *(long *)(lVar35 + 0x138) = DAT_00126480;\n    }\n    if (DAT_00126474 != -1) {\n      *(short *)(lVar35 + 300) = DAT_00126474;\n    }\n    if (DAT_00126472 != -1) {\n      *(short *)(lVar35 + 0x118) = DAT_00126472;\n    }\n    if (DAT_00126470 != -1) {\n      *(short *)(lVar35 + 0x11a) = DAT_00126470;\n    }\n    if (uVar22 < uVar26) {\n      uVar18 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      FUN_00119ed0(uVar18,uVar26,uVar22);\n    }\n  }\n  plVar6 = DAT_001278d0;\n  free(DAT_001278d0);\n  if (plVar6 == DAT_001278c8) {\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n    lVar35 = (**(code **)(param_1[1] + 0x1f8))(param_1);\n  }\n  else {\n    free(DAT_001278c8);\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n    lVar35 = (**(code **)(param_1[1] + 0x1f8))(param_1);\n  }\n  if (lVar35 < 0) goto LAB_00107a82;\n  DAT_001278c8 = (long *)xmalloc();\n  DAT_001278d0 = DAT_001278c8;\n  uStack_1f8 = (**(code **)(param_1[1] + 0x200))(param_1,DAT_001278c8);\n  if ((long)uStack_1f8 < 0) goto LAB_00107a82;\n  if (uStack_1f8 == 0) {\n    free(DAT_001278d0);\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n  }\n  bfd_map_over_sections(param_1,FUN_00115530,param_2);\n  puVar30 = DAT_001279e0;\n  if ((DAT_0012790c == '\\0') &&\n     (cVar11 = (**(code **)(*(long *)(param_2 + 8) + 0x168))(param_1), puVar30 = DAT_001279e0,\n     cVar11 == '\\0')) {\n    DAT_00127a40 = 1;\n    dcgettext(0,\"error in private header data\",5);\n    FUN_001126c0(0,param_1,0);\n    puVar30 = DAT_001279e0;\n  }\n  for (; puVar38 = DAT_001279d8, puVar30 != (undefined8 *)0x0; puVar30 = (undefined8 *)*puVar30) {\n    uVar28 = 0x128;\n    lVar35 = FUN_00114190(puVar30[1],0,0x80);\n    if (lVar35 != 0) {\n      uVar28 = FUN_00115f30(*(uint *)(lVar35 + 0x28) | 0x100,param_2,puVar30[1]);\n    }\n    lVar35 = bfd_get_section_by_name(param_2,puVar30[1]);\n    if (lVar35 != 0) {\n      uVar18 = puVar30[1];\n      uVar17 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      FUN_001126c0(0,param_2,0,uVar17,uVar18);\n      return 0;\n    }\n    lVar35 = bfd_make_section_with_flags(param_2,puVar30[1],uVar28 | 0x100000);\n    puVar30[5] = lVar35;\n    if (lVar35 == 0) {\n      uVar18 = puVar30[1];\n      uVar17 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      FUN_001126c0(0,param_2,0,uVar17,uVar18);\n      return 0;\n    }\n    cVar11 = bfd_set_section_size();\n    if (cVar11 == '\\0') {\n      FUN_001126c0(0,param_2,puVar30[5],0);\n      return 0;\n    }\n    lVar35 = FUN_00114190(puVar30[1],0,0x18);\n    if (lVar35 != 0) {\n      uVar18 = *(undefined8 *)(lVar35 + 0x18);\n      lVar35 = puVar30[5];\n      *(byte *)(lVar35 + 0x28) = *(byte *)(lVar35 + 0x28) | 1;\n      *(undefined8 *)(lVar35 + 0x30) = uVar18;\n      *(undefined8 *)(lVar35 + 0x38) = uVar18;\n    }\n    lVar35 = FUN_00114190(puVar30[1],0,0x60);\n    if (lVar35 != 0) {\n      lVar16 = puVar30[5];\n      *(undefined8 *)(lVar16 + 0x38) = *(undefined8 *)(lVar35 + 0x20);\n      if (0x3e < *(uint *)(lVar16 + 0x7c)) {\n        FUN_001126c0(0,param_2,lVar16,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n    lVar35 = bfd_get_section_by_name(param_1,puVar38[1]);\n    puVar38[5] = lVar35;\n    if (lVar35 == 0) {\n      uVar18 = puVar38[1];\n      uVar17 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      FUN_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    uVar18 = *(undefined8 *)(lVar35 + 0x60);\n    cVar11 = bfd_set_section_size(uVar18);\n    if (cVar11 == '\\0') {\n      FUN_001126c0(0,param_2,uVar18,0);\n      return 0;\n    }\n  }\n  puVar30 = DAT_001279d0;\n  if (DAT_00127a20 == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar33 = (long **)param_1[0x12];\n    __ptr_01 = pplVar33;\n    if (pplVar33 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (DAT_00127a20 != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar33[1]; puVar30 = DAT_001279d0, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar30 != (undefined8 *)0x0; puVar30 = (undefined8 *)*puVar30) {\n    lVar35 = bfd_get_section_by_name(param_1,puVar30[1]);\n    if (lVar35 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      FUN_001126c0(0,param_1,0);\n    }\n    else if ((*(byte *)(lVar35 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      FUN_001126c0(0,param_1,lVar35);\n    }\n    else {\n      sVar19 = *(size_t *)(lVar35 + 0x40);\n      __s_00 = fopen((char *)puVar30[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        FUN_001126c0(puVar30[2],0,0);\n      }\n      else {\n        cVar11 = bfd_malloc_and_get_section(param_1,lVar35,&pcStack_c8);\n        if (cVar11 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          FUN_001126c0(0,param_1,lVar35);\n        }\n        else if ((sVar19 != 0) && (sVar20 = fwrite(pcStack_c8,1,sVar19,__s_00), sVar20 != sVar19)) {\n          piVar25 = __errno_location();\n          pcVar34 = strerror(*piVar25);\n          uVar18 = puVar30[2];\n          uVar17 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          FUN_00119ed0(uVar17,uVar18,pcVar34);\n          free(pcStack_c8);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(pcStack_c8);\n      }\n    }\n  }\n  if (DAT_00127a30 == 0) {\nLAB_0010790a:\n    lStack_190 = 0;\n  }\n  else {\n    lVar35 = bfd_get_section_by_name(param_2,\".gnu_debuglink\");\n    if (lVar35 != 0) {\n      uVar18 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      FUN_00119ed0(uVar18);\n      DAT_00127a30 = 0;\n      goto LAB_0010790a;\n    }\n    lStack_190 = bfd_create_gnu_debuglink_section(param_2);\n    lVar35 = DAT_00127a30;\n    if (lStack_190 == 0) {\n      uVar18 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      FUN_001126c0(0,param_2,0,uVar18,lVar35);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_2 + 8) + 8) == 2) {\n      uVar22 = 0;\n      for (uVar26 = *(ulong *)(param_2 + 0x90); uVar26 != 0; uVar26 = *(ulong *)(uVar26 + 8)) {\n        uVar24 = *(ulong *)(uVar26 + 0x30);\n        uVar31 = uVar22;\n        uVar7 = uVar26;\n        uVar8 = uVar22;\n        if (uVar24 != 0) {\n          while ((uVar31 = uVar7, uVar8 != 0 &&\n                 (uVar31 = uVar26, uVar24 <= *(ulong *)(uVar22 + 0x30)))) {\n            uVar26 = *(ulong *)(uVar26 + 8);\n            if (uVar26 == 0) goto LAB_00107db8;\n            uVar24 = *(ulong *)(uVar26 + 0x30);\n            uVar7 = uVar22;\n            uVar8 = uVar24;\n          }\n        }\n        uVar22 = uVar31;\n      }\nLAB_00107db8:\n      if (uVar22 == 0) {\n        uVar26 = 0x1000;\n      }\n      else {\n        uVar22 = *(long *)(uVar22 + 0x40) + *(long *)(uVar22 + 0x30);\n        uVar26 = 0xffffffffffffffff;\n        if (uVar22 < 0xfffffffffffff001) {\n          uVar26 = uVar22 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack_190 + 0x28) = *(byte *)(lStack_190 + 0x28) | 1;\n      *(ulong *)(lStack_190 + 0x30) = uVar26;\n      *(ulong *)(lStack_190 + 0x38) = uVar26;\n    }\n  }\n  plVar6 = DAT_001278d0;\n  if (*(int *)(param_2 + 0xa0) != 0) {\n    uVar26 = FUN_0010554f();\n    return uVar26;\n  }\n  if (DAT_001279a0 == '\\0') {\nLAB_00105588:\n    puStack_1e8 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar42 = &PTR_s__stab_00125c60;\n    puStack_1e8 = (undefined4 *)xmalloc(0x60);\n    puVar36 = puStack_1e8;\n    for (lVar35 = 0x18; lVar35 != 0; lVar35 = lVar35 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar44 * -2 + 1;\n    }\n    pcStack_1d0 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar42;\n      lVar35 = bfd_get_section_by_name(param_1,puVar3);\n      lVar16 = bfd_get_section_by_name();\n      if ((lVar35 != 0) && (lVar16 != 0)) {\n        lVar23 = *(long *)(lVar35 + 0x40);\n        __ptr = (void *)xmalloc(lVar23);\n        cVar11 = bfd_get_section_contents(param_1,lVar35,__ptr,0,lVar23);\n        if (cVar11 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*param_1);\n          free(pcStack_1d0);\n          free(__ptr);\n        }\n        else {\n          uVar26 = *(ulong *)(lVar16 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar26 + 1);\n          local_1f0._0_1_ = bfd_get_section_contents(param_1,lVar16,__ptr_00,0);\n          if ((char)local_1f0 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*param_1);\n            free(pcStack_1d0);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar26) = 0;\n            if ((pcStack_1d0 != (char *)0x0) ||\n               (pcStack_1d0 = (char *)FUN_00112894(param_1,1,plVar6), pcStack_1d0 != (char *)0x0)) {\n              lStack_168 = 0;\n              lStack_180 = 0;\n              for (pvVar41 = __ptr; pvVar41 <= (void *)((long)__ptr + lVar23 + -0xc);\n                  pvVar41 = (void *)((long)pvVar41 + 0xc)) {\n                uVar22 = (**(code **)(param_1[1] + 0x40))(pvVar41);\n                bVar2 = *(byte *)((long)pvVar41 + 4);\n                uVar14 = (**(code **)(param_1[1] + 0x58))((long)pvVar41 + 6);\n                lVar35 = (**(code **)(param_1[1] + 0x40))((long)pvVar41 + 8);\n                if (bVar2 == 0) {\n                  lStack_180 = lStack_168;\n                  lStack_168 = lStack_168 + lVar35;\n                }\n                else {\n                  uVar24 = (uVar22 & 0xffffffff) + lStack_180;\n                  if (uVar24 < uVar26) {\n                    pcVar34 = (char *)((long)__ptr_00 + uVar24);\n                    pcStack_178 = (char *)0x0;\n                    while( true ) {\n                      sVar19 = strlen(pcVar34);\n                      if (((sVar19 == 0) || (pcVar29 = pcVar34 + (sVar19 - 1), *pcVar29 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar23) < (long)pvVar41 + 0x10U)) goto LAB_001077fb;\n                      *pcVar29 = '\\0';\n                      pvVar41 = (void *)((long)pvVar41 + 0xc);\n                      iVar13 = (**(code **)(param_1[1] + 0x40))(pvVar41);\n                      uVar22 = (ulong)(uint)(iVar13 + (int)lStack_180);\n                      if (uVar26 <= uVar22) break;\n                      pcVar34 = (char *)concat(pcVar34,(long)__ptr_00 + uVar22,0);\n                      *pcVar29 = '\\\\';\n                      free(pcStack_178);\n                      pcStack_178 = pcVar34;\n                    }\n                    uVar18 = *param_1;\n                    pcVar29 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar29,uVar18,puVar3,((long)pvVar41 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    FUN_001088ae((ulong)bVar2,uVar14,lVar35,pcVar34);\n                    cVar11 = FUN_0011173a(puStack_1e8,pcStack_1d0,bVar2);\n                    if (cVar11 == '\\0') {\n                      FUN_00108b3e();\n                      FUN_00108863();\n                      free(pcStack_178);\n                      free(pcStack_1d0);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar18 = *param_1;\n                    pcVar34 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar34,uVar18,puVar3,((long)pvVar41 - (long)__ptr) / 0xc,\n                            uVar22 & 0xffffffff,(ulong)bVar2,((long)pvVar41 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              FUN_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar42 = ppuVar42 + 2;\n    } while (ppuVar42 != (undefined **)&DAT_00125c90);\n    if ((pcStack_1d0 != (char *)0x0) && (cVar11 = FUN_0010c892(), cVar11 == '\\0')) {\nLAB_00105981:\n      free(puStack_1e8);\n      goto LAB_00105588;\n    }\n    if (*(int *)(param_1[1] + 8) == 1) {\n      lVar35 = 0;\n      for (plVar15 = plVar6; plVar15 < plVar6 + uStack_1f8; plVar15 = plVar15 + 1) {\n        (**(code **)(param_1[1] + 0x218))(param_1,*plVar15,&pcStack_c8);\n        if ((char)uStack_c0 == '-') {\n          if (((lVar35 == 0) && (lVar35 = FUN_00112894(param_1,0,plVar6), lVar35 == 0)) ||\n             ((pcStack_b8 == (char *)0x0 || (*pcStack_b8 == '\\0')))) goto LAB_00105981;\n          pcVar34 = (char *)0x0;\n          pcVar29 = pcStack_b8;\n          while (((*pcVar29 != '\\0' && (sVar19 = strlen(pcVar29), pcVar29[sVar19 - 1] == '\\\\')) &&\n                 (plVar15 + 1 < plVar6 + uStack_1f8))) {\n            pcVar21 = (char *)xstrdup(pcVar29);\n            sVar19 = strlen(pcVar21);\n            pcVar21[sVar19 - 1] = '\\0';\n            pcVar29 = (char *)concat(pcVar21,*(undefined8 *)(plVar15[1] + 8),0);\n            free(pcVar21);\n            free(pcVar34);\n            plVar15 = plVar15 + 1;\n            pcVar34 = pcVar29;\n          }\n          FUN_001088ae(uStack_b0,(int)sStack_ae,pcStack_c8,pcVar29);\n          local_1f0._0_1_ = FUN_0011173a(puStack_1e8,lVar35,uStack_b0);\n          if ((char)local_1f0 == '\\0') {\n            FUN_00108b3e();\n            FUN_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      FUN_00108863();\n      if ((lVar35 != 0) && (cVar11 = FUN_0010c892(), cVar11 == '\\0')) goto LAB_00105981;\n    }\n    if ((char)local_1f0 == '\\0') {\n      if ((*(int *)(param_1[1] + 8) == 2) && (uStack_1f8 != 0)) {\n        pcStack_c8 = (char *)0x0;\n        plStack_148 = plVar6;\n        lStack_138 = 0;\n        lStack_130 = 0;\n        puVar37 = &uStack_c0;\n        for (lVar35 = 0x22; lVar35 != 0; lVar35 = lVar35 + -1) {\n          *(undefined4 *)puVar37 = 0;\n          puVar37 = (ulong *)((long)puVar37 + (ulong)bVar44 * -8 + 4);\n        }\n        cVar11 = '\\0';\n        piStack_1c0 = (int *)0x0;\n        uVar28 = 0;\n        pcStack_1d0 = (char *)0x0;\n        pcStack_178 = (char *)0xffffffffffffffff;\n        uStack_140 = uStack_1f8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)uStack_1f8 <= lStack_138) goto LAB_00105590;\n            lVar35 = plVar6[lStack_138];\n            cVar10 = bfd_coff_get_syment(param_1,lVar35,apvStack_128);\n            lVar16 = lStack_130;\n            if (cVar10 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar34 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar34 = *(char **)(lVar35 + 8);\n            puVar30 = (undefined8 *)0x0;\n            lStack_138 = lStack_138 + 1;\n            lStack_130 = (ulong)bStack_107 + 1 + lStack_130;\n            if (bStack_107 != 0) {\n              puVar30 = &uStack_f8;\n              cVar10 = bfd_coff_get_auxent(param_1,lVar35,0);\n              if (cVar10 == '\\0') {\n                uVar14 = bfd_get_error();\n                bfd_errmsg(uVar14);\n                pcVar34 = \"bfd_coff_get_auxent failed: %s\";\n                goto LAB_00105968;\n              }\n            }\n            if (pcStack_178 != (char *)lVar16) break;\n            if (bStack_108 != 0x67) {\n              cVar10 = FUN_0010bbd3(puStack_1e8);\n              if (cVar10 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack_178 = (char *)lStack_118;\n            cVar10 = FUN_0010bbd3(puStack_1e8);\n            if (cVar10 == '\\0') goto LAB_00105981;\n          }\n          uVar9 = uStack_10a;\n          if ((char)bStack_108 < '\\0') {\n            if (bStack_108 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 = FUN_0010dac0(param_1,&plStack_148,&pcStack_c8);\n            if (lVar23 == 0) break;\n            cVar10 = FUN_00112a33(&pcStack_c8,lVar35,lVar16);\n          }\n          else {\n            if (bStack_108 < 100) {\n              switch(bStack_108) {\n              case 3:\n                if (uStack_10a == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)uStack_10a & *(uint *)(param_1[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(param_1[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                piStack_1c0 = (int *)(**(code **)(param_1[1] + 0x238))(param_1);\n                uVar28 = (uint)uVar9;\n                pcStack_1d0 = pcVar34;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack_108) {\n            case 100:\n              iVar13 = strcmp(pcVar34,\".bb\");\n              if (iVar13 == 0) {\n                cVar10 = FUN_0010be88(puStack_1e8);\n              }\n              else {\n                iVar13 = strcmp(pcVar34,\".eb\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                cVar10 = FUN_0010bf20(puStack_1e8);\n              }\n              break;\n            case 0x65:\n              iVar13 = strcmp(pcVar34,\".bf\");\n              if (iVar13 == 0) {\n                if (pcStack_1d0 != (char *)0x0) {\n                  uVar39 = (int)uVar28 >> ((byte)*(undefined4 *)(param_1[0x22] + 0x44) & 0x1f);\n                  lVar16 = FUN_0010dac0(param_1,&plStack_148,&pcStack_c8,lVar16,\n                                        uVar39 ^ (uVar28 ^ uVar39) & *(uint *)(param_1[0x22] + 0x38)\n                                        ,puVar30,0,puStack_1e8);\n                  if ((lVar16 == 0) || (cVar11 = FUN_0010bc80(puStack_1e8), cVar11 == '\\0'))\n                  goto LAB_00105981;\n                  if (piStack_1c0 != (int *)0x0) {\n                    iVar13 = 0;\n                    if (bStack_107 != 0) {\n                      iVar13 = uStack_f0 - 1;\n                    }\n                    lVar35 = *(long *)(*(long *)(lVar35 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar32 = piStack_1c0[4];\n                      if (iVar32 == 0) break;\n                      cVar10 = FUN_0010bf86(puStack_1e8,iVar13 + iVar32,\n                                            *(long *)(piStack_1c0 + 6) + lVar35);\n                      piStack_1c0 = piStack_1c0 + 4;\n                      if (cVar10 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  uVar28 = 0;\n                  piStack_1c0 = (int *)0x0;\n                  pcStack_1d0 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar34 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar13 = strcmp(pcVar34,\".ef\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar11 != '\\0') {\n                  cVar11 = FUN_0010be1a(puStack_1e8);\n                  if (cVar11 == '\\0') goto LAB_00105981;\n                  cVar11 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar34 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar18 = dcgettext(0,pcVar34,5);\n              FUN_00119ed0(uVar18);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar10 != '\\0');\n      }\n      else {\n        pcVar34 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar18 = dcgettext(0,pcVar34,5);\n        FUN_00119ed0(uVar18);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_2 + 0x44) & 0x42) != 0) && ((*(uint *)(param_2 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_2 + 8) + 0x20) == '\\0') && (DAT_00127959 == '\\0')) {\n      if (uStack_1f8 != 0) {\n        plVar6 = DAT_001278d0 + uStack_1f8;\n        plVar15 = DAT_001278d0;\n        do {\n          uVar28 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar28 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar28 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (plVar6 != plVar15);\n      }\n    }\n    else {\n      for (lVar35 = *(long *)(param_2 + 0x90); lVar35 != 0; lVar35 = *(long *)(lVar35 + 8)) {\n        if (*(long *)(lVar35 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar35 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a48 == 2) || (DAT_00127a48 == 7)) {\nLAB_001059fe:\n    if (DAT_00127a48 == 7) {\nLAB_00105a3b:\n      plVar15 = (long *)xmalloc();\n      plVar6 = DAT_001278d0;\n      piStack_1c0._0_4_ = *(uint *)((long)param_1 + 0x44) & 0x42;\n      DAT_001278c8 = plVar15;\n      if (uStack_1f8 == 0) {\n        uVar26 = 0;\n      }\n      else {\n        uVar26 = 0;\n        local_1f0 = 0;\n        do {\n          iVar13 = DAT_001279c0;\n          plVar4 = (long *)plVar6[local_1f0];\n          pcVar5 = (code *)plVar4[4];\n          uVar28 = *(uint *)(plVar4 + 3);\n          pcVar34 = (char *)plVar4[1];\n          pcVar29 = pcVar34;\n          if (DAT_001279c8 != (undefined8 *)0x0) {\n            iVar32 = 0;\n            puVar30 = DAT_001279c8;\n            while ((iVar32 < iVar13 && (pcVar21 = (char *)puVar30[5], pcVar21 != (char *)0x0))) {\n              if (pcVar21 != \"\") {\n                iVar12 = strcmp(pcVar21,pcVar34);\n                if (iVar12 == 0) {\n                  free(pcVar21);\n                  uVar22 = uVar26 + 1;\n                  puVar30[5] = \"\";\n                  lVar35 = FUN_0011a2e0(puVar30);\n                  uVar18 = DAT_001278f0;\n                  plVar15[uVar26] = lVar35;\n                  lVar35 = htab_elements(uVar18);\n                  if ((lVar35 != 0) || (DAT_001278f8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar30 = (undefined8 *)*puVar30;\n              }\n              iVar32 = iVar32 + 1;\n            }\n          }\n          lVar35 = htab_elements(DAT_001278f0);\n          uVar22 = uVar26;\n          if ((lVar35 != 0) || (DAT_001278f8 != (char **)0x0)) {\n            if (pcVar34 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar34 == '_') && (pcVar34[1] == '_')) &&\n                 (iVar13 = strcmp(pcVar34 + (pcVar34[2] == '_'),\"__gnu_lto_slim\"), iVar13 == 0)) {\n                uVar18 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                FUN_00119dd0(uVar18);\n              }\n            }\n            uStack_c0 = 0;\n            pcStack_c8 = pcVar34;\n            lVar35 = htab_find(DAT_001278f0);\n            if (((lVar35 == 0) || (pcVar29 = *(char **)(lVar35 + 8), pcVar34 == pcVar29)) &&\n               (pcVar29 = pcVar34, ppcVar40 = DAT_001278f8, (uVar28 & 0x100) != 0)) {\n              for (; ppcVar40 != (char **)0x0; ppcVar40 = (char **)ppcVar40[3]) {\n                iVar13 = strcmp(*ppcVar40,pcVar34);\n                if (iVar13 == 0) {\n                  pcVar29 = ppcVar40[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar29;\n            cVar11 = *pcVar29;\n            if (cVar11 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar34 = DAT_00127928;\n            if ((DAT_001279a8 != '\\0') && (*(char *)(*(long *)(param_2 + 8) + 0x1c) != '\\0')) {\n              lVar35 = param_1[1];\n              cVar11 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar11 = *pcVar34;\n          if (cVar11 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar34 = DAT_00127928;\n          lVar35 = param_1[1];\n          if (*(char *)(lVar35 + 0x1c) == cVar11) {\n            if (DAT_001279a8 == '\\0') {\n              if ((DAT_00127988 == '\\0') ||\n                 ((((uVar28 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar29 = pcVar29 + 1;\n              plVar4[1] = (long)pcVar29;\n              goto joined_r0x00106565;\n            }\n            cVar11 = *(char *)(*(long *)(param_2 + 8) + 0x1c);\n            if (cVar11 == '\\0') goto LAB_0010677d;\n            if (DAT_00127928 != (char *)0x0) {\n              pcVar29 = pcVar29 + 1;\n              plVar4[1] = (long)pcVar29;\n              sVar19 = strlen(pcVar29);\n              lVar35 = sVar19 + 2;\nLAB_001066bc:\n              sVar19 = strlen(pcVar34);\n              pcVar34 = (char *)xmalloc(sVar19 + lVar35);\n              goto LAB_001066d0;\n            }\n            *pcVar29 = cVar11;\n            plVar4[1] = (long)pcVar29;\n            uVar26 = uVar22;\n          }\n          else {\n            if ((DAT_001279a8 == '\\0') || (*(char *)(*(long *)(param_2 + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar26 = uVar22;\n              if (pcVar34 == (char *)0x0) goto LAB_00105b32;\n              sVar19 = strlen(pcVar29);\n              sVar20 = strlen(pcVar34);\n              pcVar21 = (char *)xmalloc(sVar20 + sVar19 + 1);\n              pcVar34 = pcVar21;\n            }\n            else {\nLAB_0010668d:\n              pcVar34 = DAT_00127928;\n              if ((*(char *)(lVar35 + 0x1c) != '\\0') && (cVar11 != *(char *)(lVar35 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar19 = strlen(pcVar29);\n              lVar35 = sVar19 + 2;\n              if (pcVar34 != (char *)0x0) goto LAB_001066bc;\n              pcVar34 = (char *)xmalloc(lVar35);\nLAB_001066d0:\n              pcVar21 = pcVar34 + 1;\n              *pcVar34 = *(char *)(*(long *)(param_2 + 8) + 0x1c);\n            }\n            __s = DAT_00127928;\n            if (DAT_00127928 != (char *)0x0) {\n              strcpy(pcVar21,DAT_00127928);\n              sVar19 = strlen(__s);\n              pcVar21 = pcVar21 + sVar19;\n            }\n            strcpy(pcVar21,pcVar29);\n            plVar4[1] = (long)pcVar34;\n            pcVar29 = pcVar34;\n            uVar26 = uVar22;\n          }\nLAB_00105b32:\n          if (DAT_00127a48 == 7) goto LAB_001067a8;\n          if (((uVar28 & 0x20) == 0) &&\n             (((uVar28 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if ((((uint)piStack_1c0 == 0) &&\n                (((uVar28 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar13 = bfd_decode_symclass(plVar4), iVar13 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ea == '\\0') {\n                lVar35 = htab_find();\n                if (lVar35 == 0) goto LAB_00105c07;\n              }\n              else {\n                uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n                pcStack_c8 = pcVar29;\n                htab_traverse(DAT_00127a18,FUN_0011a170,&pcStack_c8);\n                if ((char)uStack_c0 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar28 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar28 & 4) == 0) {\n                if (((*(int *)(param_1[1] + 8) != 2) ||\n                    (lVar35 = *(long *)(plVar4[4] + 0xd0), lVar35 == 0)) ||\n                   (*(long *)(lVar35 + 0x40) == 0)) {\n                  if ((DAT_00127a48 == 3) || (DAT_00127a44 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a44 == 1) {\n                    cVar11 = bfd_is_local_label(param_1);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar11 = DAT_001279a0;\n              if (1 < DAT_00127a48 - 2U) {\njoined_r0x00106a11:\n                if (cVar11 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a48 != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ea == '\\0') {\n            lVar35 = htab_find();\n            if (lVar35 != 0) {\nLAB_0010687f:\n              uVar18 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              FUN_00119ed0(uVar18);\n              DAT_00127a40 = 1;\n            }\n          }\n          else {\n            uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n            pcStack_c8 = pcVar29;\n            htab_traverse(DAT_00127a18,FUN_0011a170,&pcStack_c8);\n            if ((char)uStack_c0 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar28 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ea != '\\0') {\n              uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n              pcStack_c8 = pcVar29;\n              htab_traverse(DAT_00127a10,FUN_0011a170,&pcStack_c8);\n              if ((char)uStack_c0 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar35 = htab_find();\n            if (lVar35 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a38 != '\\0') && ((uVar28 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ea == '\\0') {\n              lVar35 = htab_find();\n              if (lVar35 != 0) goto LAB_00105c2c;\n            }\n            else {\n              uStack_c0 = uStack_c0 & 0xffffffffffffff00;\n              pcStack_c8 = pcVar29;\n              htab_traverse(DAT_00127a28,FUN_0011a170,&pcStack_c8);\n              if ((char)uStack_c0 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar11 = FUN_001159d0(plVar4[4]);\n            if (cVar11 == '\\0') {\n              if (((uVar28 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar28 & 0x82) != 0) {\n                  cVar11 = FUN_00115d70(pcVar29);\n                  if ((cVar11 == '\\0') &&\n                     ((lVar35 = htab_elements(DAT_001279f8), lVar35 == 0 ||\n                      (cVar11 = FUN_00115d70(pcVar29), cVar11 != '\\0')))) {\n                    if (((((DAT_00127958 == '\\0') ||\n                          (uVar39 = *(uint *)(plVar4 + 3), (uVar39 & 0x200000) != 0)) ||\n                         (lVar35 = *plVar4, lVar35 == 0)) ||\n                        ((*(int *)(*(long *)(lVar35 + 8) + 8) != 5 ||\n                         (*(long *)(lVar35 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar39 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar39 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar28 & 1) != 0) && (cVar11 = FUN_00115d70(pcVar29), cVar11 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279e8 != '\\0') || (cVar11 = FUN_00115d70(pcVar29), cVar11 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar15[uVar26] = (long)plVar4;\n              uVar26 = uVar26 + 1;\n            }\n          }\n          local_1f0 = local_1f0 + 1;\n        } while (uStack_1f8 != local_1f0);\n      }\n      if (DAT_001279c8 != (undefined8 *)0x0) {\n        puVar30 = DAT_001279c8;\n        iVar13 = DAT_001279c0;\n        for (lVar35 = 0; lVar35 < iVar13; lVar35 = lVar35 + 1) {\n          pcVar34 = (char *)puVar30[5];\n          if (pcVar34 == (char *)0x0) {\n            plVar6 = plVar15 + uVar26;\n            uVar26 = uVar26 + 1;\n            lVar16 = FUN_0011a2e0(puVar30,param_2);\n            *plVar6 = lVar16;\n            iVar13 = DAT_001279c0;\n          }\n          else if (pcVar34 != \"\") {\n            uVar18 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            FUN_00119dd0(uVar18,pcVar34);\n          }\n          puVar30 = (undefined8 *)*puVar30;\n        }\n      }\n      bVar43 = DAT_001279a0 == '\\0';\n      plVar15[uVar26] = 0;\n      if ((bVar43) || (puStack_1e8 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        uStack_1f8 = uVar26 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar13 = *(int *)(*(undefined8 **)(param_2 + 8) + 1);\n      if ((iVar13 == 5) || (iVar13 == 2)) {\n        apvStack_128[0] = (void *)0x0;\n        cVar11 = FUN_0011378f(param_2,puStack_1e8,&plStack_148,&uStack_f8,apvStack_128,&pcStack_c8);\n        if (cVar11 != '\\0') {\n          lVar35 = bfd_make_section_with_flags(param_2,\".stab\",0x2108);\n          lVar16 = bfd_make_section_with_flags(param_2,\".stabstr\",0x2108);\n          if ((((lVar35 == 0) || (lVar16 == 0)) ||\n              (cVar11 = bfd_set_section_size(lVar35,uStack_f8), cVar11 == '\\0')) ||\n             (cVar11 = bfd_set_section_size(lVar16,pcStack_c8), cVar11 == '\\0')) {\n            pcVar34 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar35 + 0x7c) = 2;\n            *(undefined4 *)(lVar16 + 0x7c) = 0;\n            cVar11 = bfd_set_section_contents(param_2,lVar35,plStack_148,0,uStack_f8);\n            if ((cVar11 != '\\0') &&\n               (cVar11 = bfd_set_section_contents(param_2,lVar16,apvStack_128[0],0,pcStack_c8),\n               cVar11 != '\\0')) {\n              free(puStack_1e8);\n              goto LAB_00105cfa;\n            }\n            pcVar34 = \"can\\'t set debugging section contents\";\n          }\n          uVar18 = dcgettext(0,pcVar34,5);\n          FUN_001126c0(0,param_2,0,uVar18);\n          free(apvStack_128[0]);\n          free(puStack_1e8);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar18 = **(undefined8 **)(param_2 + 8);\n        uVar17 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        FUN_001126c0(0,param_2,0,uVar17,uVar18);\n      }\n      free(puStack_1e8);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections(param_1,FUN_00116030,DAT_001278d0);\n      iVar13 = bfd_get_error();\n      if (iVar13 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a40 = 1;\n  }\n  else {\n    if ((DAT_00127a48 - 3U < 4) || ((DAT_00127a44 != 0 || (DAT_00127958 != '\\0'))))\n    goto LAB_00105a07;\n    lVar35 = htab_elements(DAT_00127a18);\n    if (((lVar35 != 0) ||\n        (((((((lVar35 = htab_elements(DAT_00127a28), lVar35 != 0 ||\n              (lVar35 = htab_elements(DAT_00127a08), lVar35 != 0)) ||\n             (lVar35 = htab_elements(DAT_00127a00), lVar35 != 0)) ||\n            ((lVar35 = htab_elements(DAT_001279f8), lVar35 != 0 ||\n             (lVar35 = htab_elements(DAT_001279f0), lVar35 != 0)))) ||\n           (lVar35 = htab_elements(DAT_001278f0), lVar35 != 0)) ||\n          (((DAT_00127928 != (char *)0x0 || (DAT_001278d8 != '\\0')) ||\n           ((DAT_00127a39 != '\\0' ||\n            (((DAT_001279a0 != '\\0' || (DAT_001279a8 != '\\0')) || (DAT_00127988 != '\\0')))))))) ||\n         ((DAT_001278f8 != (char **)0x0 || (DAT_001279e8 != '\\0')))))) || (DAT_001279c0 != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_2,DAT_001278c8,uStack_1f8 & 0xffffffff);\n    bfd_map_over_sections(param_1,FUN_00115dc0,param_2);\n    bfd_map_over_sections(param_1,FUN_00116110,param_2);\n    for (puVar30 = DAT_001279e0; puVar38 = DAT_001279d8, puVar30 != (undefined8 *)0x0;\n        puVar30 = (undefined8 *)*puVar30) {\n      cVar11 = bfd_set_section_contents(param_2,puVar30[5],puVar30[4],0,puVar30[3]);\n      if (cVar11 == '\\0') {\n        FUN_001126c0(0,param_2,puVar30[5],0);\n        return 0;\n      }\n    }\n    for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n      uVar18 = *(undefined8 *)(puVar38[5] + 0x60);\n      cVar11 = bfd_set_section_contents(param_2,uVar18,puVar38[4],0,puVar38[3]);\n      if (cVar11 == '\\0') {\n        FUN_001126c0(0,param_2,uVar18,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((DAT_00127a20 != '\\0') && (_DAT_001264c0 == 0)) {\n        uVar18 = *param_1;\n        uVar17 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        FUN_00119ed0(uVar17,uVar18);\n      }\n    }\n    else {\n      pplVar33 = (long **)0x0;\n      for (puVar30 = *(undefined8 **)(param_2 + 0x90); puVar30 != (undefined8 *)0x0;\n          puVar30 = (undefined8 *)puVar30[1]) {\n        if (((DAT_00127a20 != '\\0') && (*(int *)(*(long *)(param_2 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar30[0x1a] + 4) == 7 &&\n            (cVar11 = FUN_00113fb0(*puVar30,\".gnu.build.attributes\"), cVar11 != '\\0')))) {\n          if (pplVar33 == (long **)0x0) {\n            pplVar33 = __ptr_01;\n          }\n          pplVar27 = __ptr_01;\n          if ((undefined8 *)(*pplVar33)[0xc] == puVar30) {\nLAB_0010625f:\n            pcVar34 = \"error: failed to merge notes\";\n            if (pplVar33[1] != (long *)0x0) {\n              cVar11 = bfd_set_section_contents(param_2,puVar30,pplVar33[1],0,pplVar33[2]);\n              if (cVar11 == '\\0') {\n                uVar18 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                FUN_001126c0(0,param_2,puVar30,uVar18);\n                return 0;\n              }\n              pplVar33 = (long **)pplVar33[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar33 = pplVar27;\n              if ((undefined8 *)(*pplVar27)[0xc] == puVar30) goto LAB_0010625f;\n              pplVar33 = (long **)pplVar27[3];\n              pplVar27 = pplVar33;\n            } while (pplVar33 != (long **)0x0);\n            pcVar34 = \"error: failed to locate merged notes\";\n          }\n          uVar18 = dcgettext(0,pcVar34,5);\n          FUN_001126c0(0,param_2,puVar30,uVar18);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar33 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar33;\n      } while (pplVar33 != (long **)0x0);\n    }\n    if ((DAT_00127a30 == 0) ||\n       (cVar11 = bfd_fill_in_gnu_debuglink_section(param_2,lStack_190), lVar35 = DAT_00127a30,\n       cVar11 != '\\0')) {\n      uVar28 = (**(code **)(*(long *)(param_2 + 8) + 0x140))(param_1);\n      uVar26 = (ulong)uVar28;\n      if ((char)uVar28 != '\\0') {\n        if (DAT_00127930 == 0) {\n          return uVar26;\n        }\n        cVar11 = bfd_alt_mach_code(param_2,DAT_00127930 & 0xffffffff);\n        uVar22 = DAT_00127930;\n        if (cVar11 == '\\0') {\n          uVar18 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          FUN_00119ed0(uVar18,uVar22);\n          if (*(int *)(*(long *)(param_2 + 8) + 8) == 5) {\n            uVar18 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            FUN_00119ed0(uVar18);\n            *(short *)(*(long *)(param_2 + 0x110) + 0x3a) = (short)DAT_00127930;\n            return uVar26;\n          }\n          uVar18 = dcgettext(0,\"ignoring the alternative value\",5);\n          FUN_00119ed0(uVar18);\n          return uVar26;\n        }\n        return uVar26;\n      }\n      uVar18 = dcgettext(0,\"error copying private BFD data\",5);\n      FUN_001126c0(0,param_2,0,uVar18);\n    }\n    else {\n      uVar18 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      FUN_001126c0(0,param_2,0,uVar18,lVar35);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(param_1[1] + 8) == 5) && (*(int *)((long)pplVar33[0x1a] + 4) == 7)) &&\n      (cVar11 = FUN_00113fb0(*pplVar33), cVar11 != '\\0')) &&\n     ((pplVar33[0xc] != (long *)0x0 && (plVar6 = pplVar33[8], plVar6 != (long *)0x0)))) {\n    pplVar27 = (long **)xmalloc(0x20);\n    pplVar27[1] = (long *)0x0;\n    cVar11 = bfd_get_full_section_contents(param_1,pplVar33,pplVar27 + 1);\n    if (cVar11 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      FUN_001126c0(0,param_1,pplVar33);\n      free(pplVar27);\n    }\n    else {\n      plVar15 = (long *)FUN_001163d0(param_1,pplVar33,plVar6);\n      pplVar27[2] = plVar15;\n      if ((plVar15 == plVar6) || (cVar11 = bfd_set_section_size(pplVar33[0xc]), cVar11 != '\\0')) {\n        pplVar27[3] = (long *)__ptr_01;\n        *pplVar27 = (long *)pplVar33;\n        __ptr_01 = pplVar27;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        FUN_001126c0(0,param_2,pplVar33);\n        free(pplVar27[1]);\n        free(pplVar27);\n      }\n    }\n  }\n  pplVar33 = (long **)pplVar33[1];\n  puVar30 = DAT_001279d0;\n  if (pplVar33 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_001125fa",
                "bfd_set_format",
                "FUN_00119ed0",
                "FUN_001126c0",
                "FUN_00107976"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00114e50",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "FUNC_00114e50"
        },
        "FUN_00115d00": {
            "renaming": {
                "FUN_00115d00": "get_matching_value_00115d00",
                "param_1": "value1",
                "param_2": "value2",
                "uVar1": "tempVar1",
                "lVar2": "matchingValue"
            },
            "code": "\nlong getMatchingValue_00115d00(long value1,long value2)\n\n{\n  uint tempVar1;\n  long matchingValue;\n  \n  matchingValue = DAT_001278d0;\n  if (DAT_001278d0 != 0) {\n    if (*(int *)(*(long *)(value2 + 8) + 8) == 5) {\n      if (*(int *)(value1 + 0x28) == *(int *)(*(long *)(value2 + 0x110) + 0xd40)) {\n        tempVar1 = *(uint *)(value1 + 0x2c);\n        if (tempVar1 == 0) {\n          matchingValue = 0;\n        }\n        else if ((ulong)tempVar1 <\n                 *(ulong *)(*(long *)(value2 + 0x110) + 0x88) /\n                 (ulong)*(byte *)(*(long *)(*(long *)(*(long *)(value2 + 8) + 0x380) + 0x340) + 5))\n        {\n          matchingValue = *(long *)(DAT_001278d0 + (ulong)(tempVar1 - 1) * 8);\n        }\n        else {\n          matchingValue = 0;\n        }\n      }\n      else {\n        matchingValue = 0;\n      }\n    }\n    else {\n      matchingValue = 0;\n    }\n  }\n  return matchingValue;\n}\n\n",
            "called": [
                "FUN_001082c3"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115d00",
            "calling": [
                "FUN_00108179",
                "FUN_001159d0"
            ],
            "imported": false,
            "current_name": "get_matching_value_00115d00"
        },
        "FUN_00113c43": {
            "renaming": {
                "FUN_00113c43": "allocate_and_initialize_data_00113c43",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "param_5": "input_5",
                "param_6": "input_6",
                "lVar1": "memory_address",
                "plVar2": "allocated_memory",
                "auVar3": "function_result"
            },
            "code": "\nundefined  [16]\nallocate_and_initialize_data_00113c43(long input_1,long input_2,long input_3,long input_4,undefined input_5,\n            undefined8 input_6)\n\n{\n  long memory_address;\n  long *allocated_memory;\n  undefined function_result [16];\n  \n  if ((input_1 != 0) && (input_2 != 0)) {\n    memory_address = FUN_00112904(0x10,0);\n    if (memory_address != 0) {\n      allocated_memory = (long *)xmalloc(0x28);\n      *(undefined4 *)((long)allocated_memory + 0x21) = 0;\n      *allocated_memory = input_1;\n      *(undefined4 *)((long)allocated_memory + 0x24) = 0;\n      allocated_memory[1] = input_2;\n      allocated_memory[2] = input_3;\n      allocated_memory[3] = input_4;\n      *(undefined *)(allocated_memory + 4) = input_5;\n      *(long **)(memory_address + 0x10) = allocated_memory;\n      goto LAB_00113caa;\n    }\n  }\n  memory_address = 0;\nLAB_00113caa:\n  function_result._8_8_ = input_6;\n  function_result._0_8_ = memory_address;\n  return function_result;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113c43",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010c95e",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "allocate_and_initialize_data_00113c43"
        },
        "FUN_00112a33": {
            "renaming": {
                "FUN_00112a33": "process_input_00112a33",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "inputType",
                "param_5": "arg5",
                "param_6": "arg6",
                "param_7": "flag",
                "uVar1": "result",
                "lVar2": "value",
                "plVar3": "ptrValue"
            },
            "code": "\nbool processInput_00112a33(undefined8 arg1,long arg2,undefined8 arg3,byte inputType,undefined8 arg5\n                 ,undefined8 arg6,uint flag)\n\n{\n  undefined result;\n  long value;\n  long *ptrValue;\n  \n  if (inputType < 0x12) {\n    if (inputType != 0) {\n      switch(inputType) {\n      case 1:\n        result = FUN_0010c05d(arg5,*(undefined8 *)(arg2 + 8),arg6,4,\n                             *(long *)(arg2 + 0x10) + *(long *)(*(long *)(arg2 + 0x20) + 0x30)\n                            );\n        return (bool)result;\n      case 2:\n        goto switchD_00112a73_caseD_2;\n      case 3:\n        result = FUN_0010c05d(arg5,*(undefined8 *)(arg2 + 8),arg6,(flag & 0xff) + 2,\n                             *(long *)(arg2 + 0x10) + *(long *)(*(long *)(arg2 + 0x20) + 0x30)\n                            );\n        return (bool)result;\n      case 4:\n        result = FUN_0010c05d(arg5,*(undefined8 *)(arg2 + 8),arg6,5,\n                             *(long *)(arg2 + 0x10) + *(long *)(*(long *)(arg2 + 0x20) + 0x30)\n                            );\n        return (bool)result;\n      case 9:\n        result = FUN_0010bd62(arg5,*(undefined8 *)(arg2 + 8),arg6,1,\n                             *(long *)(arg2 + 0x10) + *(long *)(*(long *)(arg2 + 0x20) + 0x30)\n                            );\n        return (bool)result;\n      case 10:\n      case 0xc:\n      case 0xf:\n        value = FUN_0010c6be(arg5,*(undefined8 *)(arg2 + 8));\n        if (value == 0) {\n          return false;\n        }\n        ptrValue = (long *)FUN_0010da0b(arg1,arg3);\n        *ptrValue = value;\n        break;\n      case 0xd:\n        value = FUN_0010c218(arg5,*(undefined8 *)(arg2 + 8));\n        return value != 0;\n      case 0x11:\n        result = FUN_0010bd62(arg5,*(undefined8 *)(arg2 + 8),arg6,2,\n                             *(long *)(arg2 + 0x10) + *(long *)(*(long *)(arg2 + 0x20) + 0x30)\n                            );\n        return (bool)result;\n      }\n    }\n  }\n  else if (inputType == 0x7f) {\nswitchD_00112a73_caseD_2:\n    result = FUN_0010c05d(arg5,*(undefined8 *)(arg2 + 8),arg6,1,\n                         *(long *)(arg2 + 0x10) + *(long *)(*(long *)(arg2 + 0x20) + 0x30));\n    return (bool)result;\n  }\n  return true;\n}\n\n",
            "called": [
                "FUN_0010c05d",
                "FUN_0010c218",
                "FUN_0010da0b",
                "FUN_0010c6be",
                "FUN_0010bd62"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112a33",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_input_00112a33"
        },
        "bfd_hash_table_init": {
            "renaming": {},
            "code": "\nvoid bfd_hash_table_init(void)\n\n{\n  bfd_hash_table_init();\n  return;\n}\n\n",
            "called": [
                "bfd_hash_table_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104830",
            "calling": [
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "bfd_hash_table_init"
        },
        "FUN_0010c2d2": {
            "renaming": {
                "FUN_0010c2d2": "get_type_from_xcoff_0010c2d2",
                "param_1": "input",
                "param_2": "data",
                "param_3": "typeInfo",
                "uVar1": "typeCode",
                "pcVar2": "typeName",
                "uVar3": "result",
                "lVar4": "returnValue",
                "plVar5": "ptrToValue",
                "uVar6": "unsignedTypeCode"
            },
            "code": "\n\n\nlong getTypeFromXCOFF_0010c2d2(undefined8 input,long data,int *typeInfo)\n\n{\n  uint typeCode;\n  char *typeName;\n  undefined8 result;\n  long returnValue;\n  long *ptrToValue;\n  uint unsignedTypeCode;\n  \n  if ((*typeInfo == 0) && (typeCode = typeInfo[1], (int)typeCode < 0)) {\n    unsignedTypeCode = ~typeCode;\n    if (unsignedTypeCode < 0x22) {\n      returnValue = *(long *)(data + 0x90 + (ulong)unsignedTypeCode * 8);\n      if (returnValue == 0) {\n        switch(unsignedTypeCode) {\n        case 1:\n          result = FUN_00113dfe(1,0);\n          typeName = \"char\";\n          break;\n        case 2:\n          result = FUN_00113dfe(2,0);\n          typeName = \"short\";\n          break;\n        case 3:\n          result = FUN_00113dfe(4,0);\n          typeName = \"long\";\n          break;\n        case 4:\n          result = FUN_00113dfe(1,1);\n          typeName = \"unsigned char\";\n          break;\n        case 5:\n          result = FUN_00113dfe(1,0);\n          typeName = \"signed char\";\n          break;\n        case 6:\n          result = FUN_00113dfe(2,1);\n          typeName = \"unsigned short\";\n          break;\n        case 7:\n          result = FUN_00113dfe(4,1);\n          typeName = \"unsigned int\";\n          break;\n        case 8:\n          result = FUN_00113dfe(4,1);\n          typeName = \"unsigned\";\n          break;\n        case 9:\n          result = FUN_00113dfe(4,1);\n          typeName = \"unsigned long\";\n          break;\n        case 10:\n          result = FUN_00113e17();\n          typeName = \"void\";\n          break;\n        case 0xb:\n          result = FUN_00113df2(4);\n          typeName = \"float\";\n          break;\n        case 0xc:\n          result = FUN_00113df2(8);\n          typeName = \"double\";\n          break;\n        case 0xd:\n          result = FUN_00113df2(8);\n          typeName = \"long double\";\n          break;\n        case 0xe:\n          result = FUN_00113dfe(4,0);\n          typeName = \"integer\";\n          break;\n        case 0xf:\n          result = FUN_00112904(6,4);\n          typeName = \"boolean\";\n          break;\n        case 0x10:\n          result = FUN_00113df2(4);\n          typeName = \"short real\";\n          break;\n        case 0x11:\n          result = FUN_00113df2(8);\n          typeName = \"real\";\n          break;\n        case 0x12:\n          typeName = \"stringptr\";\n          result = 0;\n          break;\n        case 0x13:\n          result = FUN_00113dfe(1,1);\n          typeName = \"character\";\n          break;\n        case 0x14:\n          result = FUN_00112904(6,1);\n          typeName = \"logical*1\";\n          break;\n        case 0x15:\n          result = FUN_00112904(6,2);\n          typeName = \"logical*2\";\n          break;\n        case 0x16:\n          result = FUN_00112904(6,4);\n          typeName = \"logical*4\";\n          break;\n        case 0x17:\n          result = FUN_00112904(6,4);\n          typeName = \"logical\";\n          break;\n        case 0x18:\n          result = FUN_00112904(5,8);\n          typeName = \"complex\";\n          break;\n        case 0x19:\n          result = FUN_00112904(5,0x10);\n          typeName = \"double complex\";\n          break;\n        case 0x1a:\n          result = FUN_00113dfe(1,0);\n          typeName = \"integer*1\";\n          break;\n        case 0x1b:\n          result = FUN_00113dfe(2,0);\n          typeName = \"integer*2\";\n          break;\n        case 0x1c:\n          result = FUN_00113dfe(4,0);\n          typeName = \"integer*4\";\n          break;\n        case 0x1d:\n          result = FUN_00113dfe(2,0);\n          typeName = \"wchar\";\n          break;\n        case 0x1e:\n          result = FUN_00113dfe(8,0);\n          typeName = \"long long\";\n          break;\n        case 0x1f:\n          result = FUN_00113dfe(8,1);\n          typeName = \"unsigned long long\";\n          break;\n        case 0x20:\n          result = FUN_00112904(6,8);\n          typeName = \"logical*8\";\n          break;\n        case 0x21:\n          result = FUN_00113dfe(8,0);\n          typeName = \"integer*8\";\n          break;\n        default:\n          result = FUN_00113dfe(4,0);\n          typeName = \"int\";\n        }\n        returnValue = FUN_0010c218(input,typeName,result);\n        *(long *)(data + 0x90 + (ulong)unsignedTypeCode * 8) = returnValue;\n        return returnValue;\n      }\n      return returnValue;\n    }\n    typeName = (char *)dcgettext(0,\"Unrecognized XCOFF type %d\\n\",5);\n    fprintf(_stderr,typeName,(ulong)typeCode);\n  }\n  else {\n    ptrToValue = (long *)FUN_00109022(data);\n    if (ptrToValue != (long *)0x0) {\n      if (*ptrToValue == 0) {\n        returnValue = FUN_00113e23(ptrToValue,0);\n        return returnValue;\n      }\n      return *ptrToValue;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00113df2",
                "FUN_00109022",
                "fprintf",
                "FUN_0010c218",
                "FUN_00112904",
                "FUN_00113dfe",
                "FUN_00113e17",
                "FUN_00113e23"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c2d2",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "get_type_from_xcoff_0010c2d2"
        },
        "FUN_0010e07c": {
            "renaming": {
                "FUN_0010e07c": "extract_symbols_0010e07c",
                "param_2": "symbolTable",
                "param_5": "symbolTableHeader",
                "lVar1": "symbolTableEnd",
                "lVar2": "symbolTableEntry",
                "lVar3": "numSymbolsProcessed",
                "cVar4": "coffResult",
                "uVar5": "bfdError",
                "__ptr": "symbolData",
                "uVar6": "symbolValue",
                "uVar7": "result",
                "puVar8": "symbolEntry",
                "pcVar9": "errorMsg",
                "puVar10": "auxData",
                "uVar11": "index",
                "lVar12": "newSymbolIndex",
                "iVar13": "auxValue",
                "iVar14": "symbolArraySize",
                "local_a8": "auxValue0",
                "uStack_a4": "auxValue1",
                "uStack_a0": "paramValue0",
                "uStack_9c": "paramValue1",
                "local_88": "symbolName",
                "local_68": "auxType",
                "local_67": "auxCount",
                "local_60": "auxDataBuffer",
                "local_56": "auxVariable"
            },
            "code": "\nundefined8\nextractSymbols_0010e07c(undefined8 param_1,long *symbolTable,undefined8 param_3,int param_4,long symbolTableHeader,\n            undefined8 param_6)\n\n{\n  long symbolTableEnd;\n  long symbolTableEntry;\n  long numSymbolsProcessed;\n  char coffResult;\n  undefined4 bfdError;\n  void *symbolData;\n  undefined8 symbolValue;\n  undefined8 result;\n  undefined4 *symbolEntry;\n  char *errorMsg;\n  undefined *auxData;\n  uint index;\n  long newSymbolIndex;\n  int auxValue;\n  int symbolArraySize;\n  undefined4 auxValue0;\n  undefined4 auxValue1;\n  undefined4 paramValue0;\n  undefined4 paramValue1;\n  undefined symbolName [30];\n  undefined2 local_6a;\n  byte auxType;\n  byte auxCount;\n  undefined auxDataBuffer [10];\n  ushort auxVariable;\n  \n  symbolArraySize = 10;\n  newSymbolIndex = 0;\n  symbolTableEnd = *(long *)(symbolTableHeader + 0x18);\n  symbolData = (void *)xmalloc(0x50);\n  while ((symbolTable[3] < symbolTableEnd && (symbolTable[2] < symbolTable[1]))) {\n    symbolTableEntry = *(long *)(*symbolTable + symbolTable[2] * 8);\n    coffResult = bfd_coff_get_syment(param_1,symbolTableEntry,symbolName);\n    if (coffResult == '\\0') {\n      bfdError = bfd_get_error();\n      symbolValue = bfd_errmsg(bfdError);\n      errorMsg = \"bfd_coff_get_syment failed: %s\";\nLAB_0010e18d:\n      result = dcgettext(0,errorMsg,5);\n      FUN_00119ed0(result,symbolValue);\n      free(symbolData);\n      return 0;\n    }\n    numSymbolsProcessed = symbolTable[3];\n    auxData = (undefined *)0x0;\n    symbolTable[2] = symbolTable[2] + 1;\n    symbolTable[3] = numSymbolsProcessed + 1 + (ulong)auxCount;\n    if (auxCount != 0) {\n      auxData = auxDataBuffer;\n      coffResult = bfd_coff_get_auxent(param_1,symbolTableEntry,0,auxData);\n      if (coffResult == '\\0') {\n        bfdError = bfd_get_error();\n        symbolValue = bfd_errmsg(bfdError);\n        errorMsg = \"bfd_coff_get_auxent failed: %s\";\n        goto LAB_0010e18d;\n      }\n    }\n    if (auxType == 0x12) {\n      index = (uint)auxVariable;\n      auxValue = (int)*(undefined8 *)(symbolTableEntry + 0x10) +\n               (int)*(undefined8 *)(*(long *)(symbolTableEntry + 0x20) + 0x30);\n    }\n    else {\n      if (auxType < 0x13) {\n        if ((auxType == 8) || (auxType == 0xb)) {\n          index = 0;\n          auxValue = ((int)*(undefined8 *)(symbolTableEntry + 0x10) +\n                   (int)*(undefined8 *)(*(long *)(symbolTableEntry + 0x20) + 0x30)) * 8;\n          goto LAB_0010e214;\n        }\n      }\n      else if (auxType == 0x66) break;\n      index = 0;\n      auxValue = 0;\n    }\nLAB_0010e214:\n    result = FUN_0010dac0(param_1,symbolTable,param_3,numSymbolsProcessed,local_6a,auxData,1);\n    symbolValue = *(undefined8 *)(symbolTableEntry + 8);\n    symbolEntry = (undefined4 *)xmalloc(0x20);\n    auxValue0 = (undefined4)symbolValue;\n    auxValue1 = (undefined4)((ulong)symbolValue >> 0x20);\n    paramValue0 = (undefined4)result;\n    paramValue1 = (undefined4)((ulong)result >> 0x20);\n    *(undefined8 *)(symbolEntry + 5) = 0;\n    symbolEntry[6] = auxValue;\n    symbolEntry[7] = index;\n    symbolEntry[4] = 0;\n    *symbolEntry = auxValue0;\n    symbolEntry[1] = auxValue1;\n    symbolEntry[2] = paramValue0;\n    symbolEntry[3] = paramValue1;\n    if (symbolArraySize <= (int)newSymbolIndex + 1) {\n      symbolArraySize = symbolArraySize + 10;\n      symbolData = (void *)xrealloc(symbolData,(long)symbolArraySize << 3,symbolEntry,0,param_6);\n    }\n    *(undefined4 **)((long)symbolData + newSymbolIndex * 8) = symbolEntry;\n    newSymbolIndex = newSymbolIndex + 1;\n  }\n  *(undefined8 *)((long)symbolData + (long)(int)newSymbolIndex * 8) = 0;\n  symbolValue = FUN_00113da9(param_4 == 8,*(undefined2 *)(symbolTableHeader + 10),symbolData);\n  return symbolValue;\n}\n\n",
            "called": [
                "dcgettext",
                "bfd_coff_get_auxent",
                "FUN_00113da9",
                "xmalloc",
                "bfd_get_error",
                "free",
                "FUN_00119ed0",
                "xrealloc",
                "bfd_errmsg",
                "FUN_0010dac0",
                "bfd_coff_get_syment"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e07c",
            "calling": [
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "extract_symbols_0010e07c"
        },
        "bfd_is_local_label": {
            "renaming": {},
            "code": "\nvoid bfd_is_local_label(void)\n\n{\n  bfd_is_local_label();\n  return;\n}\n\n",
            "called": [
                "bfd_is_local_label"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048a0",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_is_local_label"
        },
        "FUN_001082c3": {
            "renaming": {
                "FUN_001082c3": "zero_return_value_001082c3"
            },
            "code": "\nundefined8 zeroReturnValue_001082c3(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082c3",
            "calling": [
                "FUN_00115d00"
            ],
            "imported": false,
            "current_name": "zero_return_value_001082c3"
        },
        "FUN_00114460": {
            "renaming": {
                "FUN_00114460": "read_and_process_file_00114460",
                "param_1": "filename",
                "param_2": "hashTable",
                "param_3": "fileData",
                "iVar1": "lineNumber",
                "piVar2": "errnoLocation",
                "pcVar3": "errorMessage",
                "uVar4": "translatedString",
                "__n": "fileSize",
                "__ptr": "buffer",
                "__stream": "file",
                "sVar5": "bytesRead",
                "ppbVar6": "slotPointer",
                "pbVar7": "currentByte",
                "bVar8": "currentChar",
                "pbVar9": "nextByte",
                "pbVar10": "currentPosition",
                "pbVar11": "startPosition",
                "pbVar12": "endPosition"
            },
            "code": "\nvoid readAndProcessFile_00114460(char *filename,undefined8 hashTable,byte **fileData)\n\n{\n  int lineNumber;\n  int *errnoLocation;\n  char *errorMessage;\n  undefined8 translatedString;\n  size_t fileSize;\n  byte *buffer;\n  FILE *file;\n  size_t bytesRead;\n  byte **slotPointer;\n  byte *currentByte;\n  byte currentChar;\n  byte *nextByte;\n  byte *currentPosition;\n  byte *startPosition;\n  byte *endPosition;\n  \n  fileSize = FUN_00113f50();\n  if (fileSize == 0) {\n    DAT_00127a40 = 1;\n  }\n  else {\n    buffer = (byte *)xmalloc(fileSize + 2);\n    file = fopen(filename,\"r\");\n    if (file == (FILE *)0x0) {\n      errnoLocation = __errno_location();\n      errorMessage = strerror(*errnoLocation);\n      translatedString = dcgettext(0,\"cannot open \\'%s\\': %s\",5);\n                    \n      FUN_00119dd0(translatedString,filename,errorMessage);\n    }\n    bytesRead = fread(buffer,1,fileSize,file);\n    if ((bytesRead == 0) || (lineNumber = ferror(file), lineNumber != 0)) {\n      translatedString = dcgettext(0,\"%s: fread failed\",5);\n                    \n      FUN_00119dd0(translatedString,filename);\n    }\n    lineNumber = 1;\n    fclose(file);\n    *(undefined2 *)(buffer + fileSize) = 10;\n    currentChar = *buffer;\n    endPosition = buffer;\n    while (currentPosition = endPosition, currentChar != 0) {\n      for (; currentChar = *currentPosition, startPosition = currentPosition, currentChar != 10; currentPosition = currentPosition + 1) {\n        if ((char)currentChar < '\\v') {\n          if (currentChar == 0) {\n            nextByte = currentPosition + 1;\n            goto LAB_00114553;\n          }\n        }\n        else {\n          if (currentChar == 0xd) {\n            *currentPosition = 0;\n            nextByte = currentPosition + 1;\n            if (currentPosition[1] == 10) {\n              nextByte = currentPosition + 2;\n              startPosition = currentPosition + 1;\n            }\n            goto LAB_00114553;\n          }\n          if (currentChar == 0x23) {\n            FUN_00104d1c();\n            return;\n          }\n        }\n      }\n      *currentPosition = 0;\n      if (currentPosition[1] == 0xd) {\n        startPosition = currentPosition + 1;\n        nextByte = currentPosition + 2;\n      }\n      else {\n        nextByte = currentPosition + 1;\n      }\nLAB_00114553:\n      currentChar = *endPosition;\n      while ((currentChar == 0x20 || (currentPosition = endPosition, currentChar == 9))) {\n        currentPosition = endPosition + 1;\n        endPosition = endPosition + 1;\n        currentChar = *currentPosition;\n      }\n      do {\n        if ((currentChar == 10) || (currentChar == 0xd)) goto LAB_00114676;\n        if (currentChar == 0) goto LAB_00114599;\n        currentChar = currentPosition[1];\n        currentPosition = currentPosition + 1;\n      } while ((currentChar != 0x20) && (currentChar != 9));\n      if ((char)currentChar < '\\x0e') {\nLAB_00114676:\n        if ((-0x2402L >> (currentChar & 0x3f) & 1U) != 0) goto LAB_001145e6;\n      }\n      else {\nLAB_001145e6:\n        currentChar = currentPosition[1];\n        if ((((((currentChar == 9) || (currentChar == 0x20)) &&\n              ((currentChar = currentPosition[2], currentChar == 9 || (currentChar == 0x20)))) &&\n             ((currentChar = currentPosition[3], currentChar == 9 || (currentChar == 0x20)))) &&\n            ((currentChar = currentPosition[4], currentChar == 9 || (currentChar == 0x20)))) &&\n           ((currentChar = currentPosition[5], currentChar == 9 || (currentChar == 0x20)))) {\n          currentChar = currentPosition[6];\n          currentByte = currentPosition + 6;\n          if ((currentChar == 9) || (currentChar == 0x20)) {\n            do {\n              do {\n                currentChar = currentByte[1];\n                currentByte = currentByte + 1;\n              } while (currentChar == 0x20);\n            } while (currentChar == 9);\n          }\n        }\n        if ((0xd < currentChar) || ((-0x2402L >> (currentChar & 0x3f) & 1U) != 0)) {\n          translatedString = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n          FUN_00119ed0(translatedString,filename,lineNumber);\n        }\n      }\nLAB_00114599:\n      *currentPosition = 0;\n      if (endPosition < currentPosition) {\n        slotPointer = (byte **)htab_find_slot(hashTable,endPosition,1);\n        *slotPointer = endPosition;\n      }\n      lineNumber = lineNumber + 1;\n      endPosition = nextByte;\n      currentChar = startPosition[1];\n    }\n    *fileData = buffer;\n  }\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "__errno_location",
                "FUN_00113f50",
                "FUN_00119dd0",
                "fclose",
                "strerror",
                "ferror",
                "fread",
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114460",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "read_and_process_file_00114460"
        },
        "FUN_0010a94e": {
            "renaming": {
                "FUN_0010a94e": "build_query_string_0010a94e",
                "param_1": "paramPointer1",
                "param_2": "paramString1",
                "param_3": "paramString2",
                "param_4": "paramFlag",
                "cVar1": "conditionFlag",
                "lVar2": "localVar1",
                "__s": "dynamicString",
                "sVar3": "len1",
                "sVar4": "len2",
                "sVar5": "len3",
                "sVar6": "len4",
                "pcVar7": "resultString",
                "uVar8": "returnValue",
                "pcVar9": "flagString"
            },
            "code": "\nundefined8 buildQueryString_0010a94e(long paramPointer1,char *paramString1,char *paramString2,int paramFlag)\n\n{\n  char conditionFlag;\n  long localVar1;\n  char *dynamicString;\n  size_t len1;\n  size_t len2;\n  size_t len3;\n  size_t len4;\n  char *resultString;\n  undefined8 returnValue;\n  char *flagString;\n  \n  conditionFlag = *(char *)(*(long *)(paramPointer1 + 0x60) + 0x1c);\n  dynamicString = (char *)FUN_00109b2f();\n  resultString = *(char **)(*(long *)(paramPointer1 + 0x60) + 0x20);\n  if (resultString == (char *)0x0) {\n    returnValue = 0;\n  }\n  else {\n    len1 = strlen(resultString);\n    len2 = strlen(paramString1);\n    len3 = strlen(dynamicString);\n    len4 = strlen(paramString2);\n    resultString = (char *)xmalloc(len1 + 10 + len2 + len3 + len4);\n    if (paramFlag == 1) {\n      flagString = \"/1\";\n    }\n    else {\n      flagString = \"/0\";\n      if ((paramFlag != 2) && (flagString = \"\", paramFlag != 0)) {\n                    \n        abort();\n      }\n    }\n    sprintf(resultString,\"%s%s:%s%s:%s;\",*(undefined8 *)(*(long *)(paramPointer1 + 0x60) + 0x20),paramString1,flagString,\n            dynamicString,paramString2,*(long *)(paramPointer1 + 0x60));\n    free(*(void **)(*(long *)(paramPointer1 + 0x60) + 0x20));\n    localVar1 = *(long *)(paramPointer1 + 0x60);\n    *(char **)(localVar1 + 0x20) = resultString;\n    if (conditionFlag != '\\0') {\n      *(undefined *)(localVar1 + 0x1c) = 1;\n    }\n    returnValue = CONCAT71((int7)((ulong)localVar1 >> 8),1);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "abort",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a94e",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "build_query_string_0010a94e"
        },
        "bfd_set_file_flags": {
            "renaming": {},
            "code": "\nvoid bfd_set_file_flags(void)\n\n{\n  bfd_set_file_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_set_file_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104630",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "bfd_set_file_flags"
        },
        "bfd_create_gnu_debuglink_section": {
            "renaming": {},
            "code": "\nvoid bfd_create_gnu_debuglink_section(void)\n\n{\n  bfd_create_gnu_debuglink_section();\n  return;\n}\n\n",
            "called": [
                "bfd_create_gnu_debuglink_section"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104180",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "bfd_create_gnu_debuglink_section"
        },
        "FUN_00113b1e": {
            "renaming": {
                "FUN_00113b1e": "extract_data_from_binary_00113b1e",
                "param_1": "binary_ptr",
                "param_2": "unknown_1",
                "param_3": "data_offset",
                "param_4": "unknown_2",
                "auVar1": "result_ptr",
                "piVar2": "data_ptr",
                "uVar3": "extracted_data",
                "auVar4": "final_result"
            },
            "code": "\nundefined  [16] extract_data_from_binary_00113b1e(long binary_ptr,undefined8 unknown_1,ulong data_offset,undefined8 unknown_2)\n\n{\n  undefined result_ptr [16];\n  int *data_ptr;\n  undefined8 extracted_data;\n  undefined final_result [16];\n  \n  if (binary_ptr != 0) {\n    data_ptr = (int *)FUN_00112b6e(binary_ptr,0);\n    if ((data_ptr == (int *)0x0) || (3 < *data_ptr - 7U)) {\n      extracted_data = 0;\n    }\n    else {\n      extracted_data = **(undefined8 **)(data_ptr + 4);\n    }\n    final_result._8_8_ = unknown_2;\n    final_result._0_8_ = extracted_data;\n    return final_result;\n  }\n  result_ptr._8_8_ = 0;\n  result_ptr._0_8_ = data_offset;\n  return result_ptr << 0x40;\n}\n\n",
            "called": [
                "FUN_00112b6e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b1e",
            "calling": [
                "FUN_0010b0fa",
                "FUN_0010d559"
            ],
            "imported": false,
            "current_name": "extract_data_from_binary_00113b1e"
        },
        "FUN_0010a0e9": {
            "renaming": {
                "FUN_0010a0e9": "execute_remote_command_0010a0e9",
                "param_1": "remoteConnection",
                "param_2": "commandID",
                "param_3": "paramValue",
                "uVar1": "ptrValue",
                "uVar2": "returnValue",
                "__s": "remoteCommand",
                "sVar3": "commandLength",
                "__s_00": "formattedCommand"
            },
            "code": "\nundefined4 executeRemoteCommand_0010a0e9(long remoteConnection,undefined8 commandID,undefined8 paramValue)\n\n{\n  undefined ptrValue;\n  undefined4 returnValue;\n  char *remoteCommand;\n  size_t commandLength;\n  char *formattedCommand;\n  \n  ptrValue = *(undefined *)(*(long *)(remoteConnection + 0x60) + 0x1c);\n  returnValue = *(undefined4 *)(*(long *)(remoteConnection + 0x60) + 0x18);\n  remoteCommand = (char *)FUN_00109b2f();\n  commandLength = strlen(remoteCommand);\n  formattedCommand = (char *)xmalloc(commandLength + 100);\n  sprintf(formattedCommand,\"r%s;%ld;%ld;\",remoteCommand,commandID,paramValue);\n  free(remoteCommand);\n  returnValue = FUN_00109b52(remoteConnection,formattedCommand,0,ptrValue,returnValue);\n  if ((char)returnValue != '\\0') {\n    free(formattedCommand);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00109b52",
                "free",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a0e9",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "execute_remote_command_0010a0e9"
        },
        "FUN_00114c20": {
            "renaming": {
                "FUN_00114c20": "initialize_data_00114c20",
                "param_1": "dataPointer",
                "cVar1": "flag",
                "pcVar2": "charPointer"
            },
            "code": "\nvoid initializeData_00114c20(long dataPointer)\n\n{\n  char flag;\n  char *charPointer;\n  \n  FUN_00114190(dataPointer,1,1);\n  flag = FUN_00113fb0(dataPointer,&DAT_0011b499);\n  if (flag != '\\0') {\n    charPointer = (char *)(dataPointer + 5);\n    if (*(char *)(dataPointer + 4) != 'a') {\n      charPointer = (char *)(dataPointer + 4);\n    }\n    if (*charPointer != '\\0') {\n      FUN_00114190(charPointer,1,0x100);\n    }\n  }\n  DAT_001278d8 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00114190",
                "FUN_00113fb0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114c20",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "initialize_data_00114c20"
        },
        "FUN_00115f50": {
            "renaming": {
                "FUN_00115f50": "check_duplicate_param_00115f50",
                "param_1": "file_offset",
                "param_2": "cmd_args",
                "param_3": "flag",
                "__s1": "command",
                "uVar1": "comparison_result",
                "uVar2": "temp",
                "extraout_EDX": "temp2",
                "plVar3": "linked_list",
                "auVar4": "result"
            },
            "code": "\nuint check_duplicate_param_00115f50(long file_offset,char **cmd_args,char flag)\n\n{\n  char *command;\n  uint comparison_result;\n  undefined4 temp;\n  undefined4 temp2;\n  long *linked_list;\n  undefined result [12];\n  \n  if ((DAT_00127a40 != 0) || (DAT_0012790c != '\\0')) {\n    return 1;\n  }\n  result = FUN_001159d0(cmd_args);\n  if (result[0] == '\\0') {\n    if (DAT_001279d8 != (long *)0x0) {\n      command = *cmd_args;\n      linked_list = DAT_001279d8;\n      do {\n        comparison_result = strcmp(command,(char *)linked_list[1]);\n        result._4_4_ = 0;\n        result._0_4_ = comparison_result;\n        result._8_4_ = temp2;\n        if (comparison_result == 0) {\n          return 1;\n        }\n        linked_list = (long *)*linked_list;\n      } while (linked_list != (long *)0x0);\n    }\n    temp = result._8_4_;\n    if (((((flag == '\\0') || (DAT_00127a20 == '\\0')) ||\n         (result._8_4_ = temp, result._0_8_ = *(long *)(file_offset + 8),\n         *(int *)(*(long *)(file_offset + 8) + 8) != 5)) ||\n        ((result._0_8_ = (ulong)cmd_args[0x1a], *(int *)(cmd_args[0x1a] + 4) != 7 ||\n         (result = FUN_00113fb0(*cmd_args,\".gnu.build.attributes\"), result[0] == '\\0')))) &&\n       ((*(byte *)((long)cmd_args + 0x27) & 2) == 0)) {\n      return (uint)CONCAT71(result._1_7_,cmd_args[8] == (char *)0x0) |\n             CONCAT31(result._9_3_,cmd_args[0xc] == (char *)0x0);\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "strcmp",
                "FUN_001159d0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115f50",
            "calling": [
                "FUN_00115dc0",
                "FUN_00116110"
            ],
            "imported": false,
            "current_name": "check_duplicate_param_00115f50"
        },
        "FUN_001083de": {
            "renaming": {
                "FUN_001083de": "reverse_bytes_in_section_001083de",
                "unaff_RBX": "sectionPointer",
                "unaff_EBP": "sectionLength",
                "uVar1": "sectionValue",
                "uVar2": "errorMessage"
            },
            "code": "\nvoid reverseBytesInSection_001083de(void)\n\n{\n  undefined8 sectionValue;\n  undefined8 errorMessage;\n  undefined8 *sectionPointer;\n  undefined4 sectionLength;\n  \n  sectionValue = *sectionPointer;\n  errorMessage = dcgettext(0,\"cannot reverse bytes: length of section %s must be evenly divisible by %d\",5)\n  ;\n                    \n  FUN_00119dd0(errorMessage,sectionValue,sectionLength);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00119dd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001083de",
            "calling": [
                "FUN_00116110"
            ],
            "imported": false,
            "current_name": "reverse_bytes_in_section_001083de"
        },
        "bfd_get_section_by_name": {
            "renaming": {},
            "code": "\nvoid bfd_get_section_by_name(void)\n\n{\n  bfd_get_section_by_name();\n  return;\n}\n\n",
            "called": [
                "bfd_get_section_by_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104400",
            "calling": [
                "FUN_00107880",
                "FUN_0011a2e0",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_get_section_by_name"
        },
        "FUN_0010b948": {
            "renaming": {
                "FUN_0010b948": "process_data_0010b948",
                "param_1": "dataAddress",
                "param_2": "dataSize",
                "lVar1": "tempVar1",
                "cVar2": "charVar",
                "__ptr": "ptr",
                "uVar3": "dataSizeUL",
                "uVar4": "dataSizeMinusOne",
                "local_5a": "messageBuffer"
            },
            "code": "\nvoid processData_0010b948(long dataAddress,uint dataSize)\n\n{\n  long tempVar1;\n  char charVar;\n  void *ptr;\n  ulong dataSizeUL;\n  uint dataSizeMinusOne;\n  char messageBuffer [50];\n  \n  dataSizeMinusOne = dataSize - 1;\n  dataSizeUL = (ulong)dataSize;\n  if ((dataSizeMinusOne < 0x10) && (tempVar1 = *(long *)(dataAddress + 0xf8 + (ulong)dataSizeMinusOne * 8), tempVar1 != 0)) {\n    FUN_00109cf4(dataAddress,tempVar1,dataSizeUL);\n    return;\n  }\n  charVar = FUN_0010b800(dataAddress,4,0);\n  if (charVar != '\\0') {\n    ptr = (void *)FUN_00109b2f(dataAddress);\n    tempVar1 = *(long *)(dataAddress + 0x68);\n    *(long *)(dataAddress + 0x68) = tempVar1 + 1;\n    if (dataSizeMinusOne < 0x10) {\n      *(long *)(dataAddress + 0xf8 + (ulong)dataSizeMinusOne * 8) = tempVar1;\n    }\n    sprintf(messageBuffer,\"%ld=r%s;%u;0;\",tempVar1,ptr,dataSizeUL);\n    free(ptr);\n    FUN_00109b52(dataAddress,messageBuffer,tempVar1,1,dataSizeUL);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_0010b800",
                "FUN_00109b52",
                "free",
                "sprintf",
                "FUN_00109cf4",
                "FUN_00109b2f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b948",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_data_0010b948"
        },
        "access": {
            "renaming": {},
            "code": "\n\n\nint access(char *__name,int __type)\n\n{\n  int iVar1;\n  \n  iVar1 = access(__name,__type);\n  return iVar1;\n}\n\n",
            "called": [
                "access"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104740",
            "calling": [
                "FUN_0011283f"
            ],
            "imported": false,
            "current_name": "access"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104240",
            "calling": [
                "FUN_00104cc1",
                "FUN_00116b90",
                "FUN_0010c05d",
                "FUN_0010827b",
                "FUN_001163d0",
                "FUN_0010bd62",
                "FUN_00113f50",
                "FUN_00109a32",
                "FUN_00108f08",
                "FUN_0010bf20",
                "FUN_0011256b",
                "FUN_00105828",
                "FUN_00104a35",
                "FUN_001053b5",
                "FUN_0010e6a8",
                "FUN_00108d9a",
                "FUN_0010551d",
                "FUN_00108fb9",
                "FUN_00114460",
                "FUN_0010554f",
                "FUN_00108a2a",
                "FUN_001152b6",
                "FUN_00114e00",
                "FUN_0010dac0",
                "FUN_0010ba08",
                "FUN_00114190",
                "FUN_00109022",
                "FUN_00108fe8",
                "FUN_0010c218",
                "FUN_00115530",
                "FUN_0010c6be",
                "FUN_00116490",
                "FUN_00119f70",
                "FUN_00112b6e",
                "FUN_0010c892",
                "FUN_00115b70",
                "FUN_00108072",
                "FUN_00115dc0",
                "FUN_0010543c",
                "FUN_0010be1a",
                "FUN_00107880",
                "FUN_00108808",
                "FUN_0010e2f0",
                "FUN_0010b0fa",
                "FUN_00114690",
                "FUN_00112c1f",
                "FUN_00108375",
                "FUN_00108179",
                "FUN_001086af",
                "FUN_001126c0",
                "FUN_0011173a",
                "FUN_00119970",
                "FUN_0010e07c",
                "FUN_001199d0",
                "FUN_00104920",
                "FUN_0010911f",
                "FUN_00108916",
                "FUN_001083de",
                "FUN_0010808f",
                "FUN_0010ee3f",
                "FUN_0010871c",
                "FUN_00104966",
                "FUN_00114dc7",
                "FUN_00104ea2",
                "FUN_00112996",
                "FUN_0010882c",
                "FUN_0010b6ea",
                "FUN_00107976",
                "FUN_0010c2d2",
                "FUN_0010bf86",
                "FUN_0010b800",
                "FUN_00108b3e",
                "FUN_00108200",
                "FUN_0010da0b",
                "FUN_0010bc80",
                "FUN_00104ad6",
                "FUN_0010be88",
                "FUN_0010914e",
                "FUN_00114e50"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_format": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104500",
            "calling": [
                "FUN_00107880",
                "FUN_00114690",
                "FUN_00119f70",
                "FUN_00114e50"
            ],
            "imported": false,
            "current_name": "bfd_set_format"
        },
        "FUN_00112b6e": {
            "renaming": {
                "FUN_00112b6e": "check_debug_type_circularity_00112b6e",
                "param_1": "input_array",
                "param_2": "debug_info_array",
                "iVar1": "array_length",
                "uVar2": "error_message",
                "__format": "message_format",
                "piVar3": "result_array",
                "plVar4": "current_debug_info",
                "bVar5": "is_circular",
                "local_18": "previous_debug_info",
                "local_10": "current_input"
            },
            "code": "\n\n\nint * check_debug_type_circularity_00112b6e(int *input_array,long *debug_info_array)\n\n{\n  int array_length;\n  undefined8 error_message;\n  char *message_format;\n  int *result_array;\n  long *current_debug_info;\n  bool is_circular;\n  long *previous_debug_info;\n  int *current_input;\n  \n  array_length = *input_array;\n  if ((array_length != 1) && (1 < array_length - 0x16U)) {\n    return input_array;\n  }\n  current_debug_info = debug_info_array;\n  while (current_debug_info != (long *)0x0) {\n    if ((input_array == (int *)current_debug_info[1]) ||\n       (is_circular = current_debug_info == (long *)*current_debug_info, current_debug_info = (long *)*current_debug_info, is_circular)) {\n      error_message = FUN_001129f4(input_array,\"debug_get_real_type: circular debug information for %s\\n\");\n      message_format = (char *)dcgettext(0);\n      fprintf(_stderr,message_format,error_message);\n      return (int *)0x0;\n    }\n  }\n  previous_debug_info = debug_info_array;\n  current_input = input_array;\n  if (array_length - 0x16U < 2) {\n    result_array = (int *)check_debug_type_circularity_00112b6e((*(undefined8 **)(input_array + 4))[1],&previous_debug_info);\n    return result_array;\n  }\n  result_array = *(int **)**(undefined8 **)(input_array + 4);\n  if (input_array == result_array) {\n    return input_array;\n  }\n  if (result_array == (int *)0x0) {\n    return input_array;\n  }\n  result_array = (int *)check_debug_type_circularity_00112b6e(result_array,&previous_debug_info);\n  return result_array;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "FUN_001129f4",
                "FUN_00112b6e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112b6e",
            "calling": [
                "FUN_0010ee3f",
                "FUN_00113b1e",
                "FUN_0010922b",
                "FUN_00112c1f",
                "FUN_00112b6e"
            ],
            "imported": false,
            "current_name": "check_debug_type_circularity_00112b6e"
        },
        "FUN_0010a83e": {
            "renaming": {
                "FUN_0010a83e": "reverse_string_0010a83e",
                "param_1": "source",
                "param_2": "param2",
                "param_3": "length",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "isFlagSet",
                "param_7": "isValueZero",
                "uVar1": "result",
                "__s": "string1",
                "__s_00": "string2",
                "sVar2": "stringLength",
                "cVar3": "flagValue"
            },
            "code": "\nundefined4\nreverseString_0010a83e(long source,undefined8 param2,ulong length,undefined param4,ulong param5,\n            byte isFlagSet,byte isValueZero)\n\n{\n  undefined4 result;\n  char *string1;\n  char *string2;\n  size_t stringLength;\n  char flagValue;\n  \n  if (((isValueZero ^ 1) & isFlagSet) == 0) {\n    string1 = (char *)0x0;\n    flagValue = '\\0';\n  }\n  else {\n    flagValue = *(char *)(*(long *)(source + 0x60) + 0x1c);\n    string1 = (char *)FUN_00109b2f();\n    param5 = param5 & 0xffffffff;\n    length = length & 0xffffffff;\n  }\n  result = FUN_0010a69a(source,param2,length,param4,param5);\n  if ((char)result != '\\0') {\n    if (isFlagSet == 0) {\n      return result;\n    }\n    if (isValueZero == 0) {\n      if (string1 == (char *)0x0) {\n        return 0;\n      }\n      stringLength = strlen(string1);\n      string2 = (char *)xmalloc(stringLength + 3);\n      sprintf(string2,\"~%%%s\",string1);\n      free(string1);\n      if (flagValue != '\\0') {\n        *(undefined *)(*(long *)(source + 0x60) + 0x1c) = 1;\n      }\n    }\n    else {\n      if (*(long *)(*(long *)(source + 0x60) + 0x10) < 1) {\n        return 0;\n      }\n      string2 = (char *)xmalloc(0x14);\n      sprintf(string2,\"~%%%ld\",*(undefined8 *)(*(long *)(source + 0x60) + 0x10));\n    }\n    *(char **)(*(long *)(source + 0x60) + 0x38) = string2;\n    return result;\n  }\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_0010a69a",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a83e",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "reverse_string_0010a83e"
        },
        "FUN_00113d6e": {
            "renaming": {
                "FUN_00113d6e": "add_data_to_storage_00113d6e",
                "param_1": "data1",
                "param_2": "data2",
                "lVar1": "storageAddress",
                "puVar2": "newDataAddress"
            },
            "code": "\nlong addDataToStorage_00113d6e(undefined8 data1,undefined8 data2)\n\n{\n  long storageAddress;\n  undefined8 *newDataAddress;\n  \n  storageAddress = FUN_00112904(0xb,0);\n  if (storageAddress != 0) {\n    newDataAddress = (undefined8 *)xmalloc(0x10);\n    *newDataAddress = data1;\n    newDataAddress[1] = data2;\n    *(undefined8 **)(storageAddress + 0x10) = newDataAddress;\n  }\n  return storageAddress;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113d6e",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "add_data_to_storage_00113d6e"
        },
        "bfd_make_section_with_flags": {
            "renaming": {},
            "code": "\nvoid bfd_make_section_with_flags(void)\n\n{\n  bfd_make_section_with_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_make_section_with_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104120",
            "calling": [
                "FUN_00107880",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_make_section_with_flags"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048f0",
            "calling": [
                "FUN_001125fa",
                "FUN_00116b90",
                "FUN_001163d0",
                "FUN_0010abdd",
                "FUN_00108863",
                "FUN_0011256b",
                "FUN_0010e6a8",
                "FUN_00104a35",
                "FUN_0010551d",
                "FUN_0010a2b9",
                "FUN_0010e918",
                "FUN_0010a77a",
                "FUN_0010554f",
                "FUN_0010e7c2",
                "FUN_0010dac0",
                "FUN_001088ae",
                "FUN_0010ba08",
                "FUN_0010e8a9",
                "FUN_0010e453",
                "FUN_00116110",
                "FUN_0010ebb0",
                "FUN_0010c1c6",
                "FUN_0010a83e",
                "FUN_0010e842",
                "FUN_0010d559",
                "FUN_00116852",
                "FUN_0010ae0e",
                "FUN_0010a94e",
                "FUN_0010e5db",
                "FUN_00107880",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_0010afd5",
                "FUN_00114690",
                "FUN_00114b84",
                "FUN_0010a181",
                "FUN_0010b948",
                "FUN_0011173a",
                "FUN_0010e07c",
                "FUN_001199d0",
                "FUN_0010eafe",
                "FUN_0010e9a0",
                "FUN_0010ee3f",
                "FUN_00116030",
                "FUN_00109ed3",
                "FUN_0010aa53",
                "FUN_0010d21c",
                "FUN_00104ea2",
                "FUN_00108466",
                "FUN_00109b2f",
                "FUN_0010b6ea",
                "FUN_0010a424",
                "FUN_0010a0e9",
                "FUN_001081e9",
                "FUN_0010a377"
            ],
            "imported": false,
            "current_name": "free"
        },
        "FUN_00114d50": {
            "renaming": {
                "FUN_00114d50": "execute_function_00114d50",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "flag"
            },
            "code": "\nvoid executeFunction_00114d50(long input1,long input2,uint flag)\n\n{\n  if (*(int *)(*(long *)(input1 + 8) + 8) != 2) {\n    return;\n  }\n  if ((flag == 2) && (*(int *)(*(long *)(input2 + 8) + 8) == 2)) {\n    flag = (uint)*(byte *)(*(long *)(*(long *)(input2 + 8) + 0x380) + 0x71);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00105422. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(*(long *)(input1 + 8) + 0x380) + 0x78))(input1,flag != 0);\n  return;\n}\n\n",
            "called": [
                "FUN_0010540e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114d50",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "execute_function_00114d50"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104750",
            "calling": [
                "FUN_00116b90",
                "FUN_00107880",
                "FUN_00114460",
                "FUN_00114d60"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044f0",
            "calling": [
                "FUN_00116b90",
                "FUN_00104ea2",
                "FUN_0011283f",
                "FUN_00113f50"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "FUN_00108916": {
            "renaming": {
                "FUN_00108916": "print_binary_file_options_00108916",
                "param_1": "file",
                "param_2": "exitCode",
                "uVar1": "usageMessage",
                "pcVar2": "localizedString"
            },
            "code": "\nvoid printBinaryFileOptions_00108916(FILE *file,int exitCode)\n\n{\n  undefined8 usageMessage;\n  char *localizedString;\n  \n  usageMessage = DAT_00127600;\n  localizedString = (char *)dcgettext(0,\"Usage: %s [option(s)] in-file [out-file]\\n\",5);\n  fprintf(file,localizedString,usageMessage);\n  localizedString = (char *)dcgettext(0,\" Copies a binary file, possibly transforming it in the process\\n\",5)\n  ;\n  fprintf(file,localizedString);\n  localizedString = (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(file,localizedString);\n  localizedString = (char *)dcgettext(0,\n                             \"  -I --input-target <bfdname>      Assume input file is in format <bfdname>\\n  -O --output-target <bfdname>     Create an output file in format <bfdname>\\n  -B --binary-architecture <arch>  Set output arch, when input is arch-less\\n  -F --target <bfdname>            Set both input and output format to <bfdname>\\n     --debugging                   Convert debugging information, if possible\\n  -p --preserve-dates              Copy modified/access timestamps to the output\\n\"\n                             ,5);\n  fprintf(file,localizedString);\n  localizedString = (char *)dcgettext(0,\n                             \"  -D --enable-deterministic-archives\\n                                   Produce deterministic output when stripping archives (default)\\n  -U --disable-deterministic-archives\\n                                   Disable -D behavior\\n\"\n                             ,5);\n  fprintf(file,localizedString);\n  localizedString = (char *)dcgettext(0,\n                             \"  -j --only-section <name>         Only copy section <name> into the output\\n     --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>\\n  -R --remove-section <name>       Remove section <name> from the output\\n     --remove-relocations <name>   Remove relocations from section <name>\\n  -S --strip-all                   Remove all symbol and relocation information\\n  -g --strip-debug                 Remove all debugging symbols & sections\\n     --strip-dwo                   Remove all DWO sections\\n     --strip-unneeded              Remove all symbols not needed by relocations\\n  -N --strip-symbol <name>         Do not copy symbol <name>\\n     --strip-unneeded-symbol <name>\\n                                   Do not copy symbol <name> unless needed by\\n                                     relocations\\n     --only-keep-debug             Strip everything but the debug information\\n     --extract-dwo                 Copy only DWO sections\\n     --extract-symbol              Remove section contents but keep symbols\\n     --keep-section <name>         Do not strip section <name>\\n  -K --keep-symbol <name>          Do not strip symbol <name>\\n     --keep-section-symbols        Do not strip section symbols\\n     --keep-file-symbols           Do not strip file symbol(s)\\n     --localize-hidden             Turn all ELF hidden symbols into locals\\n  -L --localize-symbol <name>      Force symbol <name> to be marked as a local\\n     --globalize-symbol <name>     Force symbol <name> to be marked as a global\\n  -G --keep-global-symbol <name>   Localize all symbols except <name>\\n  -W --weaken-symbol <name>        Force symbol <name> to be marked as a weak\\n     --weaken                      Force all global symbols to be marked as weak\\n  -w --wildcard                    Permit wildcard in symbol comparison\\n  -x --discard-all                 Remove all non-global symbols\\n  -X --discard-locals              Remove any compiler-generated symbols\\n  -i --interleave[=<number>]       Only copy N out of every <number> bytes\\n     --interlea...\" /* TRUNCATED STRING LITERAL */\n                             ,5);\n  fprintf(file,localizedString);\n  FUN_00104a35(DAT_00127600,file);\n  if (exitCode == 0) {\n    localizedString = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(file,localizedString,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exitCode);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00104a35",
                "fprintf",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108916",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "print_binary_file_options_00108916"
        },
        "FUN_001126c0": {
            "renaming": {
                "FUN_001126c0": "handle_error_001126c0",
                "param_1": "errorType",
                "param_2": "errorCode",
                "param_3": "param1",
                "param_4": "param2",
                "param_5": "param3",
                "param_6": "param4",
                "param_7": "param5",
                "param_8": "param6",
                "param_9": "errorMessage",
                "param_10": "errorFlag",
                "param_11": "errorCodeArray",
                "param_12": "errorString",
                "param_13": "param7",
                "param_14": "param8",
                "in_AL": "errorFlagValue",
                "iVar1": "bfdError",
                "uVar2": "errorMsg",
                "local_100": "bufferSize",
                "local_fc": "maxLength",
                "local_f8": "printBuffer",
                "local_f0": "localBuffer",
                "local_e8": "errorBuffer",
                "local_c8": "param7_copy",
                "local_c0": "param8_copy",
                "local_b8": "param1_copy",
                "local_a8": "param2_copy",
                "local_98": "param3_copy",
                "local_88": "param4_copy",
                "local_78": "param5_copy",
                "local_68": "param6_copy",
                "local_58": "param7_copy2",
                "local_48": "param8_copy2"
            },
            "code": "\n\n\nvoid handleError_001126c0(undefined4 errorType,undefined4 errorCode,undefined4 param1,undefined4 param2,\n                 undefined4 param3,undefined4 param4,undefined4 param5,undefined4 param6,\n                 long errorMessage,long errorFlag,long *errorCodeArray,char *errorString,undefined8 param7,\n                 undefined8 param8)\n\n{\n  char errorFlagValue;\n  int bfdError;\n  undefined8 errorMsg;\n  undefined4 bufferSize;\n  undefined4 maxLength;\n  undefined *printBuffer;\n  undefined *localBuffer;\n  undefined errorBuffer [32];\n  undefined8 param7_copy;\n  undefined8 param8_copy;\n  undefined4 param1_copy;\n  undefined4 param2_copy;\n  undefined4 param3_copy;\n  undefined4 param4_copy;\n  undefined4 param5_copy;\n  undefined4 param6_copy;\n  undefined4 param7_copy2;\n  undefined4 param8_copy2;\n  \n  if (errorFlagValue != '\\0') {\n    param1_copy = errorType;\n    param2_copy = errorCode;\n    param3_copy = param1;\n    param4_copy = param2;\n    param5_copy = param3;\n    param6_copy = param4;\n    param7_copy2 = param5;\n    param8_copy2 = param6;\n  }\n  param7_copy = param7;\n  param8_copy = param8;\n  bfdError = bfd_get_error();\n  if (bfdError == 0) {\n    errorMsg = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMsg = bfd_errmsg();\n  }\n  fflush(_stdout);\n  fputs(DAT_00127600,_stderr);\n  if (errorFlag != 0) {\n    if (errorMessage == 0) {\n      errorMessage = FUN_001125fa(errorFlag);\n    }\n    if ((errorCodeArray != (long *)0x0) && (*errorCodeArray != 0)) {\n      fprintf(_stderr,\": %s[%s]\",errorMessage);\n      goto LAB_001127c1;\n    }\n  }\n  fprintf(_stderr,\": %s\",errorMessage);\nLAB_001127c1:\n  if (errorString != (char *)0x0) {\n    printBuffer = &stack0x00000008;\n    localBuffer = errorBuffer;\n    bufferSize = 0x20;\n    maxLength = 0x30;\n    fwrite(&DAT_0011b4a0,1,2,_stderr);\n    vfprintf(_stderr,errorString,&bufferSize);\n  }\n  fprintf(_stderr,\": %s\\n\",errorMsg);\n  return;\n}\n\n",
            "called": [
                "FUN_001125fa",
                "dcgettext",
                "fprintf",
                "bfd_get_error",
                "fwrite",
                "fputs",
                "fflush",
                "bfd_errmsg",
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001126c0",
            "calling": [
                "FUN_00116b90",
                "FUN_00116110",
                "FUN_00104ea2",
                "FUN_001086af",
                "FUN_00108466",
                "FUN_0010551d",
                "FUN_00115dc0",
                "FUN_00107880",
                "FUN_00104d25",
                "FUN_0010554f",
                "FUN_00114690",
                "FUN_00114e50",
                "FUN_0010808f"
            ],
            "imported": false,
            "current_name": "handle_error_001126c0"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043d0",
            "calling": [
                "FUN_00116b90",
                "FUN_00109b52",
                "FUN_00104ea2",
                "FUN_0010554f",
                "FUN_0011173a",
                "FUN_001088ae"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "FUN_00113b4a": {
            "renaming": {
                "FUN_00113b4a": "initialize_data_00113b4a",
                "param_1": "inputValue",
                "lVar1": "dataPointer"
            },
            "code": "\nlong initializeData_00113b4a(long inputValue)\n\n{\n  long dataPointer;\n  \n  if (inputValue != 0) {\n    dataPointer = FUN_00112904(0x15,0);\n    if (dataPointer == 0) {\n      dataPointer = 0;\n    }\n    else {\n      *(long *)(dataPointer + 0x10) = inputValue;\n    }\n    return dataPointer;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b4a",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e"
            ],
            "imported": false,
            "current_name": "initialize_data_00113b4a"
        },
        "FUN_0010edb4": {
            "renaming": {
                "FUN_0010edb4": "update_file_info_0010edb4",
                "param_1": "file_info",
                "param_2": "file_name",
                "param_3": "file_type",
                "param_4": "file_size",
                "cVar1": "success_flag",
                "iVar2": "comparison_result",
                "uVar3": "result",
                "in_R10": "auxiliary_variable"
            },
            "code": "\nundefined8 update_file_info_0010edb4(long file_info,undefined8 file_name,undefined4 file_type,ulong file_size)\n\n{\n  char success_flag;\n  int comparison_result;\n  undefined8 result;\n  undefined8 auxiliary_variable;\n  \n  if (*(long *)(file_info + 0x210) == 0) {\n    return 0;\n  }\n  if (*(ulong *)(file_info + 0x1f0) < file_size) {\n    *(ulong *)(file_info + 0x1f0) = file_size;\n  }\n  comparison_result = filename_cmp(file_name);\n  if (comparison_result != 0) {\n    success_flag = FUN_0010e2f0(file_info,0x84,0,file_size,file_name);\n    if (success_flag == '\\0') {\n      return 0;\n    }\n    *(undefined8 *)(file_info + 0x210) = file_name;\n  }\n  result = FUN_0010e2f0(file_info,0x44,file_type,file_size - *(long *)(file_info + 0x200),0,auxiliary_variable);\n  return result;\n}\n\n",
            "called": [
                "filename_cmp",
                "FUN_0010e2f0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010edb4",
            "calling": [
                "FUN_00112502"
            ],
            "imported": false,
            "current_name": "update_file_info_0010edb4"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044b0",
            "calling": [
                "FUN_00116b90",
                "FUN_0010c05d",
                "FUN_00119e70",
                "FUN_0010bd62",
                "FUN_00108f08",
                "FUN_0010bf20",
                "FUN_0011256b",
                "FUN_001126c0",
                "FUN_0011173a",
                "FUN_00104a35",
                "FUN_00108fb9",
                "FUN_001199d0",
                "FUN_0010911f",
                "FUN_0010554f",
                "FUN_00108a2a",
                "FUN_00108916",
                "FUN_00109022",
                "FUN_0010ee3f",
                "FUN_00108fe8",
                "FUN_0010c218",
                "FUN_0010871c",
                "FUN_0010c6be",
                "FUN_00112996",
                "FUN_0010b6ea",
                "FUN_00112b6e",
                "FUN_0010c892",
                "FUN_0010c2d2",
                "FUN_0010bf86",
                "FUN_00108b3e",
                "FUN_0010be1a",
                "FUN_0010bc80",
                "FUN_0010be88",
                "FUN_0010914e",
                "FUN_0010b0fa",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "FUN_0010e5db": {
            "renaming": {
                "FUN_0010e5db": "reverse_and_improve_0010e5db",
                "param_1": "address",
                "param_2": "limit",
                "cVar1": "result",
                "__ptr": "ptr",
                "__s": "string",
                "sVar2": "length",
                "__s_00": "new_string",
                "in_R10": "constant",
                "iVar3": "count",
                "auVar4": "returnValue"
            },
            "code": "\nundefined  [16] reverse_and_improve_0010e5db(long address,int limit)\n\n{\n  char result;\n  void *ptr;\n  char *string;\n  size_t length;\n  char *new_string;\n  ulong constant;\n  int count;\n  undefined returnValue [16];\n  \n  count = 0;\n  do {\n    if (limit <= count) {\n      returnValue = FUN_00109ed3(address,0x66,0,address + 0x188,address + 400,constant);\n      return returnValue;\n    }\n    if (*(char *)(*(long *)(address + 0x60) + 0x1c) == '\\0') {\n      ptr = (void *)FUN_00109b2f(address);\n      free(ptr);\n    }\n    else {\n      string = (char *)FUN_00109b2f(address);\n      length = strlen(string);\n      new_string = (char *)xmalloc(length + 3);\n      sprintf(new_string,\":t%s\",string);\n      free(string);\n      result = FUN_0010e2f0(address,0x80,0,0,new_string);\n      if (result == '\\0') {\n        returnValue._8_8_ = 0;\n        returnValue._0_8_ = constant;\n        return returnValue << 0x40;\n      }\n      free(new_string);\n    }\n    count = count + 1;\n  } while( true );\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_00109ed3",
                "FUN_0010e2f0",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e5db",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "reverse_and_improve_0010e5db"
        },
        "FUN_00104d25": {
            "renaming": {
                "FUN_00104d25": "initialize_data_00104d25",
                "param_7": "parameter_7"
            },
            "code": "\nvoid initializeData_00104d25(void)\n\n{\n  undefined8 parameter_7;\n  \n  DAT_00127a40 = 1;\n  FUN_001126c0(0,parameter_7,0,0);\n  FUN_00114b84();\n  return;\n}\n\n",
            "called": [
                "FUN_00114b84",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104d25",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "initialize_data_00104d25"
        },
        "FUN_0010551d": {
            "renaming": {
                "FUN_0010551d": "merge_and_dump_debug_info_0010551d",
                "puVar1": "sectionContentsPointer",
                "bVar2": "byteValue",
                "puVar3": "ptrVar",
                "pcVar4": "sectionName",
                "puVar5": "ptrVar2",
                "plVar15": "sectionIterator",
                "lVar21": "sizeValue",
                "uVar6": "tempVar2",
                "uVar7": "tempVar3",
                "__s": "tempString",
                "cVar8": "charValue",
                "cVar9": "returnValue",
                "uVar10": "tempVar4",
                "iVar11": "tempVar5",
                "uVar12": "tempVar6",
                "iVar14": "tempVar7",
                "sVar18": "lengthValue",
                "sVar26": "writeSize",
                "pcVar19": "allocatedString",
                "__ptr": "sectionContents",
                "__ptr_00": "sectionContents2",
                "uVar16": "tempVar8",
                "uVar17": "tempVar9",
                "lVar27": "tempVar10",
                "plVar32": "mergedSectionPointer",
                "ppuVar37": "pointerPointer",
                "ppcVar35": "pointerPointer2",
                "bVar38": "boolValue",
                "bVar39": "byteValue2",
                "unaff_RBX": "allocatedMemoryPointer",
                "unaff_R13": "noteSectionPointer",
                "unaff_R14": "fileObjectPointer"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong mergeAndDumpDebugInfo_0010551d(void)\n\n{\n  uint *sectionContentsPointer;\n  byte byteValue;\n  undefined *ptrVar;\n  code *sectionName;\n  undefined8 *ptrVar2;\n  ulong tempVar2;\n  ulong tempVar3;\n  char *tempString;\n  char charValue;\n  char returnValue;\n  uint tempVar4;\n  int tempVar5;\n  uint tempVar6;\n  undefined4 uVar13;\n  int tempVar7;\n  long *sectionIterator;\n  undefined8 tempVar8;\n  undefined8 tempVar9;\n  size_t lengthValue;\n  char *allocatedString;\n  void *sectionContents;\n  void *sectionContents2;\n  ulong uVar20;\n  long sizeValue;\n  ulong uVar22;\n  int *piVar23;\n  ulong uVar24;\n  long lVar25;\n  FILE *tempString_00;\n  size_t writeSize;\n  long tempVar10;\n  long *allocatedMemoryPointer;\n  char *pcVar28;\n  undefined8 *puVar29;\n  ulong uVar30;\n  int iVar31;\n  long unaff_RBP;\n  long *mergedSectionPointer;\n  char *pcVar33;\n  undefined4 *ptrVar4;\n  char **pointerPointer2;\n  long *noteSectionPointer;\n  void *pvVar36;\n  undefined8 *fileObjectPointer;\n  undefined **pointerPointer;\n  bool boolValue;\n  byte byteValue2;\n  long in_stack_00000008;\n  ulong in_stack_00000010;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  byteValue2 = 0;\ncode_r0x0010551d:\n  dcgettext(0,\"warning: could not load note section\",5);\n  FUN_001126c0(0);\n  free(allocatedMemoryPointer);\nLAB_001151a2:\n  unaff_RBP = *(long *)(unaff_RBP + 8);\n  puVar29 = DAT_001279d0;\n  if (unaff_RBP == 0) goto joined_r0x001151c7;\n  if (DAT_00127a20 != '\\0') {\n    if ((((*(int *)(fileObjectPointer[1] + 8) != 5) || (*(int *)(*(long *)(unaff_RBP + 0xd0) + 4) != 7)) ||\n        (returnValue = FUN_00113fb0(), returnValue == '\\0')) ||\n       ((*(long *)(unaff_RBP + 0x60) == 0 || (lVar25 = *(long *)(unaff_RBP + 0x40), lVar25 == 0))))\n    goto LAB_001151a2;\n    allocatedMemoryPointer = (long *)xmalloc(0x20);\n    allocatedMemoryPointer[1] = 0;\n    returnValue = bfd_get_full_section_contents();\n    if (returnValue != '\\0') {\n      tempVar10 = FUN_001163d0();\n      allocatedMemoryPointer[2] = tempVar10;\n      if ((tempVar10 == lVar25) || (returnValue = bfd_set_section_size(), returnValue != '\\0')) {\n        allocatedMemoryPointer[3] = (long)noteSectionPointer;\n        *allocatedMemoryPointer = unaff_RBP;\n        noteSectionPointer = allocatedMemoryPointer;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        FUN_001126c0(0,in_stack_00000008,unaff_RBP);\n        free((void *)allocatedMemoryPointer[1]);\n        free(allocatedMemoryPointer);\n      }\n      goto LAB_001151a2;\n    }\n    goto code_r0x0010551d;\n  }\n  for (lVar25 = *(long *)(unaff_RBP + 8); lVar25 != 0; lVar25 = *(long *)(lVar25 + 8)) {\n  }\njoined_r0x001151c7:\n  for (; puVar29 != (undefined8 *)0x0; puVar29 = (undefined8 *)*puVar29) {\n    lVar25 = bfd_get_section_by_name();\n    if (lVar25 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      FUN_001126c0(0);\n    }\n    else if ((*(byte *)(lVar25 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      FUN_001126c0(0);\n    }\n    else {\n      lengthValue = *(size_t *)(lVar25 + 0x40);\n      tempString_00 = fopen((char *)puVar29[2],\"w\");\n      if (tempString_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        FUN_001126c0(puVar29[2],0,0);\n      }\n      else {\n        returnValue = bfd_malloc_and_get_section();\n        if (returnValue == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          FUN_001126c0(0);\n        }\n        else if ((lengthValue != 0) &&\n                (writeSize = fwrite(in_stack_00000140,1,lengthValue,tempString_00), writeSize != lengthValue)) {\n          piVar23 = __errno_location();\n          pcVar33 = strerror(*piVar23);\n          tempVar9 = puVar29[2];\n          tempVar8 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          FUN_00119ed0(tempVar8,tempVar9,pcVar33);\n          free(in_stack_00000140);\n          fclose(tempString_00);\n          return 0;\n        }\n        fclose(tempString_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (DAT_00127a30 == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    lVar25 = bfd_get_section_by_name(in_stack_00000008,\".gnu_debuglink\");\n    if (lVar25 != 0) {\n      tempVar9 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      FUN_00119ed0(tempVar9);\n      DAT_00127a30 = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(in_stack_00000008);\n    lVar25 = DAT_00127a30;\n    if (lStack0000000000000078 == 0) {\n      tempVar9 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      FUN_001126c0(0,in_stack_00000008,0,tempVar9,lVar25);\n      return 0;\n    }\n    if (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) == 2) {\n      uVar20 = 0;\n      for (uVar24 = *(ulong *)(in_stack_00000008 + 0x90); uVar24 != 0;\n          uVar24 = *(ulong *)(uVar24 + 8)) {\n        uVar22 = *(ulong *)(uVar24 + 0x30);\n        uVar30 = uVar20;\n        tempVar2 = uVar24;\n        tempVar3 = uVar20;\n        if (uVar22 != 0) {\n          while ((uVar30 = tempVar2, tempVar3 != 0 &&\n                 (uVar30 = uVar24, uVar22 <= *(ulong *)(uVar20 + 0x30)))) {\n            uVar24 = *(ulong *)(uVar24 + 8);\n            if (uVar24 == 0) goto LAB_00107db8;\n            uVar22 = *(ulong *)(uVar24 + 0x30);\n            tempVar2 = uVar20;\n            tempVar3 = uVar22;\n          }\n        }\n        uVar20 = uVar30;\n      }\nLAB_00107db8:\n      if (uVar20 == 0) {\n        uVar24 = 0x1000;\n      }\n      else {\n        uVar20 = *(long *)(uVar20 + 0x40) + *(long *)(uVar20 + 0x30);\n        uVar24 = 0xffffffffffffffff;\n        if (uVar20 < 0xfffffffffffff001) {\n          uVar24 = uVar20 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = uVar24;\n      *(ulong *)(lStack0000000000000078 + 0x38) = uVar24;\n    }\n  }\n  mergedSectionPointer = DAT_001278d0;\n  iStack000000000000006c = *(int *)(in_stack_00000008 + 0xa0);\n  if (iStack000000000000006c != 0) {\n    uVar24 = FUN_0010554f();\n    return uVar24;\n  }\n  if (DAT_001279a0 == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    pointerPointer = &PTR_stempStringtab_00125c60;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    ptrVar4 = puStack0000000000000020;\n    for (lVar25 = 0x18; lVar25 != 0; lVar25 = lVar25 + -1) {\n      *ptrVar4 = 0;\n      ptrVar4 = ptrVar4 + (ulong)byteValue2 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      ptrVar = *pointerPointer;\n      lVar25 = bfd_get_section_by_name();\n      tempVar10 = bfd_get_section_by_name();\n      if ((lVar25 != 0) && (tempVar10 != 0)) {\n        lVar25 = *(long *)(lVar25 + 0x40);\n        sectionContents = (void *)xmalloc(lVar25);\n        returnValue = bfd_get_section_contents();\n        if (returnValue == '\\0') {\n          uVar13 = bfd_get_error();\n          bfd_errmsg(uVar13);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*fileObjectPointer);\n          free(pcStack0000000000000038);\n          free(sectionContents);\n        }\n        else {\n          uVar24 = *(ulong *)(tempVar10 + 0x40);\n          sectionContents2 = (void *)xmalloc(uVar24 + 1);\n          in_stack_00000018 = bfd_get_section_contents();\n          if (in_stack_00000018 == '\\0') {\n            uVar13 = bfd_get_error();\n            bfd_errmsg(uVar13);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*fileObjectPointer);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)sectionContents2 + uVar24) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)FUN_00112894(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar36 = sectionContents; pvVar36 <= (void *)((long)sectionContents + lVar25 + -0xc);\n                  pvVar36 = (void *)((long)pvVar36 + 0xc)) {\n                uVar20 = (**(code **)(fileObjectPointer[1] + 0x40))(pvVar36);\n                byteValue = *(byte *)((long)pvVar36 + 4);\n                uVar13 = (**(code **)(fileObjectPointer[1] + 0x58))((long)pvVar36 + 6);\n                tempVar10 = (**(code **)(fileObjectPointer[1] + 0x40))((long)pvVar36 + 8);\n                if (byteValue == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + tempVar10;\n                }\n                else {\n                  uVar22 = (uVar20 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar22 < uVar24) {\n                    pcVar33 = (char *)((long)sectionContents2 + uVar22);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      lengthValue = strlen(pcVar33);\n                      if (((lengthValue == 0) || (pcVar28 = pcVar33 + (lengthValue - 1), *pcVar28 != '\\')) ||\n                         ((ulong)((long)sectionContents + lVar25) < (long)pvVar36 + 0x10U)) goto LAB_001077fb;\n                      *pcVar28 = '\\0';\n                      pvVar36 = (void *)((long)pvVar36 + 0xc);\n                      tempVar5 = (**(code **)(fileObjectPointer[1] + 0x40))(pvVar36);\n                      uVar20 = (ulong)(uint)(tempVar5 + (int)lStack0000000000000088);\n                      if (uVar24 <= uVar20) break;\n                      pcVar33 = (char *)concat(pcVar33,(long)sectionContents2 + uVar20,0);\n                      *pcVar28 = '\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar33;\n                    }\n                    tempVar9 = *fileObjectPointer;\n                    pcVar28 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar28,tempVar9,ptrVar,((long)pvVar36 - (long)sectionContents) / 0xc);\nLAB_001077fb:\n                    FUN_001088ae((ulong)byteValue,uVar13,tempVar10,pcVar33);\n                    returnValue = FUN_0011173a(puStack0000000000000020,pcStack0000000000000038,byteValue);\n                    if (returnValue == '\\0') {\n                      FUN_00108b3e();\n                      FUN_00108863();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(sectionContents);\n                      free(sectionContents2);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    tempVar9 = *fileObjectPointer;\n                    pcVar33 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar33,tempVar9,ptrVar,((long)pvVar36 - (long)sectionContents) / 0xc,\n                            uVar20 & 0xffffffff,(ulong)byteValue,((long)pvVar36 - (long)sectionContents) % 0xc);\n                  }\n                }\n              }\n              FUN_00108863();\n              free(sectionContents);\n              goto LAB_001058eb;\n            }\n          }\n          free(sectionContents2);\n          free(sectionContents);\n        }\nLAB_00105981:\n        free(puStack0000000000000020);\n        goto LAB_00105588;\n      }\nLAB_001058eb:\n      pointerPointer = pointerPointer + 2;\n    } while (pointerPointer != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (returnValue = FUN_0010c892(), returnValue == '\\0'))\n    goto LAB_00105981;\n    if (*(int *)(fileObjectPointer[1] + 8) == 1) {\n      lVar25 = 0;\n      for (sectionIterator = mergedSectionPointer; sectionIterator < mergedSectionPointer + in_stack_00000010; sectionIterator = sectionIterator + 1) {\n        (**(code **)(fileObjectPointer[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar25 != 0) || (lVar25 = FUN_00112894(), lVar25 != 0)) &&\n             ((in_stack_00000150 != (char *)0x0 && (*in_stack_00000150 != '\\0')))) {\n            pcVar33 = (char *)0x0;\n            pcVar28 = in_stack_00000150;\n            while (((*pcVar28 != '\\0' && (lengthValue = strlen(pcVar28), pcVar28[lengthValue - 1] == '\\')) &&\n                   (sectionIterator + 1 < mergedSectionPointer + in_stack_00000010))) {\n              allocatedString = (char *)xstrdup(pcVar28);\n              lengthValue = strlen(allocatedString);\n              allocatedString[lengthValue - 1] = '\\0';\n              pcVar28 = (char *)concat(allocatedString,*(undefined8 *)(sectionIterator[1] + 8),0);\n              free(allocatedString);\n              free(pcVar33);\n              sectionIterator = sectionIterator + 1;\n              pcVar33 = pcVar28;\n            }\n            FUN_001088ae(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,\n                         pcVar28);\n            in_stack_00000018 = FUN_0011173a(puStack0000000000000020,lVar25,uStack0000000000000158);\n            if (in_stack_00000018 != '\\0') goto LAB_00106cac;\n            FUN_00108b3e();\n            FUN_00108863();\n          }\n          goto LAB_00105981;\n        }\nLAB_00106cac:\n      }\n      FUN_00108863();\n      if ((lVar25 != 0) && (returnValue = FUN_0010c892(), returnValue == '\\0')) goto LAB_00105981;\n    }\n    if (in_stack_00000018 == '\\0') {\n      if ((*(int *)(fileObjectPointer[1] + 8) != 2) || (in_stack_00000010 == 0)) {\n        pcVar33 = \"%s: no recognized debugging information\";\n        goto LAB_00105968;\n      }\n      in_stack_00000140 = (char *)0x0;\n      in_stack_000000c0 = mergedSectionPointer;\n      in_stack_000000d0 = 0;\n      in_stack_000000c8 = in_stack_00000010;\n      in_stack_000000d8 = 0;\n      puVar29 = (undefined8 *)&stack0x00000148;\n      for (lVar25 = 0x22; lVar25 != 0; lVar25 = lVar25 + -1) {\n        *(undefined4 *)puVar29 = 0;\n        puVar29 = (undefined8 *)((long)puVar29 + (ulong)byteValue2 * -8 + 4);\n      }\n      returnValue = '\\0';\n      _uStack0000000000000048 = (int *)0x0;\n      pcStack0000000000000038 = (char *)0x0;\n      pcStack0000000000000090 = (char *)0xffffffffffffffff;\nswitchD_00106e1a_caseD_68:\n      do {\n        if ((long)in_stack_00000010 <= in_stack_000000d0) break;\n        lVar25 = mergedSectionPointer[in_stack_000000d0];\n        charValue = bfd_coff_get_syment();\n        tempVar10 = in_stack_000000d8;\n        if (charValue == '\\0') {\n          uVar13 = bfd_get_error();\n          bfd_errmsg(uVar13);\n          pcVar33 = \"bfd_coff_get_syment failed: %s\";\nLAB_00105968:\n          tempVar9 = dcgettext(0,pcVar33,5);\n          FUN_00119ed0(tempVar9);\n          goto LAB_00105981;\n        }\n        pcVar33 = *(char **)(lVar25 + 8);\n        in_stack_000000d0 = in_stack_000000d0 + 1;\n        in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n        if ((bStack0000000000000101 != 0) && (charValue = bfd_coff_get_auxent(), charValue == '\\0')) {\n          uVar13 = bfd_get_error();\n          bfd_errmsg(uVar13);\n          pcVar33 = \"bfd_coff_get_auxent failed: %s\";\n          goto LAB_00105968;\n        }\n        if (pcStack0000000000000090 == (char *)tempVar10) {\n          if (bStack0000000000000100 != 0x67) {\n            charValue = FUN_0010bbd3(puStack0000000000000020);\n            if (charValue == '\\0') goto LAB_00105981;\n            goto LAB_00106de4;\n          }\nswitchD_00106e1a_caseD_67:\n          pcStack0000000000000090 = (char *)in_stack_000000f0;\n          charValue = FUN_0010bbd3(puStack0000000000000020);\n        }\n        else {\nLAB_00106de4:\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\n          }\n          else if (bStack0000000000000100 < 100) {\n            switch(bStack0000000000000100) {\n            case 3:\n              if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n            case 2:\nswitchD_00106e1a_caseD_7f:\n              if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(fileObjectPointer[0x22] + 0x40)) ==\n                  2L << ((byte)*(undefined4 *)(fileObjectPointer[0x22] + 0x3c) & 0x3f)) {\n                _uStack0000000000000048 = (int *)(**(code **)(fileObjectPointer[1] + 0x238))();\n                pcStack0000000000000038 = pcVar33;\n                goto switchD_00106e1a_caseD_68;\n              }\n              break;\n            default:\n              break;\n            case 5:\n            case 7:\n            case 0xe:\n              goto switchD_00106e1a_caseD_68;\n            }\n          }\n          else {\n            switch(bStack0000000000000100) {\n            case 100:\n              tempVar5 = strcmp(pcVar33,\".bb\");\n              if (tempVar5 == 0) {\n                charValue = FUN_0010be88(puStack0000000000000020);\n                goto joined_r0x00107247;\n              }\n              tempVar5 = strcmp(pcVar33,\".eb\");\n              if (tempVar5 == 0) {\n                charValue = FUN_0010bf20(puStack0000000000000020);\n                goto joined_r0x00107247;\n              }\n              goto switchD_00106e1a_caseD_68;\n            case 0x65:\n              tempVar5 = strcmp(pcVar33,\".bf\");\n              if (tempVar5 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  tempVar10 = FUN_0010dac0();\n                  if ((tempVar10 == 0) ||\n                     (returnValue = FUN_0010bc80(puStack0000000000000020), returnValue == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    tempVar5 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      tempVar5 = in_stack_00000118 - 1;\n                    }\n                    lVar25 = *(long *)(*(long *)(lVar25 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar31 = _uStack0000000000000048[4];\n                      if (iVar31 == 0) break;\n                      charValue = FUN_0010bf86(puStack0000000000000020,tempVar5 + iVar31,\n                                           *(long *)(_uStack0000000000000048 + 6) + lVar25);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (charValue == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar33 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                tempVar5 = strcmp(pcVar33,\".ef\");\n                if (tempVar5 != 0) goto switchD_00106e1a_caseD_68;\n                if (returnValue != '\\0') {\n                  returnValue = FUN_0010be1a(puStack0000000000000020);\n                  if (returnValue == '\\0') goto LAB_00105981;\n                  returnValue = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar33 = \"%ld: unexpected .ef\\n\";\n              }\n              tempVar9 = dcgettext(0,pcVar33,5);\n              FUN_00119ed0(tempVar9);\n              goto LAB_00105981;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n          sizeValue = FUN_0010dac0();\n          if (sizeValue == 0) goto LAB_00105981;\n          charValue = FUN_00112a33(&stack0x00000140,lVar25,tempVar10);\n        }\njoined_r0x00107247:\n        if (charValue == '\\0') goto LAB_00105981;\n      } while( true );\n    }\n  }\n  if (((*(uint *)(in_stack_00000008 + 0x44) & 0x42) != 0) &&\n     ((*(uint *)(in_stack_00000008 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(in_stack_00000008 + 8) + 0x20) == '\\0') && (DAT_00127959 == '\\0')) {\n      if (in_stack_00000010 != 0) {\n        mergedSectionPointer = DAT_001278d0 + in_stack_00000010;\n        sectionIterator = DAT_001278d0;\n        do {\n          tempVar4 = *(uint *)(*sectionIterator + 0x18);\n          if ((tempVar4 & 0x1000000) != 0) {\n            *(uint *)(*sectionIterator + 0x18) = tempVar4 & 0xfeffffff;\n          }\n          sectionIterator = sectionIterator + 1;\n        } while (mergedSectionPointer != sectionIterator);\n      }\n    }\n    else {\n      for (lVar25 = *(long *)(in_stack_00000008 + 0x90); lVar25 != 0; lVar25 = *(long *)(lVar25 + 8)\n          ) {\n        if (*(long *)(lVar25 + 0xe8) != 0) {\n          sectionContentsPointer = (uint *)(*(long *)(lVar25 + 0xe8) + 0x18);\n          *sectionContentsPointer = *sectionContentsPointer | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a48 == 2) || (DAT_00127a48 == 7)) {\nLAB_001059fe:\n    if (DAT_00127a48 != 7) {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      tempVar5 = bfd_get_error();\n      if (tempVar5 != 0) {\n        DAT_00127a40 = 1;\n        return 0;\n      }\n    }\n    lVar25 = xmalloc();\n    mergedSectionPointer = DAT_001278d0;\n    uStack0000000000000048 = *(uint *)((long)fileObjectPointer + 0x44) & 0x42;\n    DAT_001278c8 = lVar25;\n    if (in_stack_00000010 == 0) {\n      uVar24 = 0;\n    }\n    else {\n      uVar24 = 0;\n      _in_stack_00000018 = 0;\n      do {\n        tempVar5 = DAT_001279c0;\n        sectionIterator = (long *)mergedSectionPointer[_in_stack_00000018];\n        sectionName = (code *)sectionIterator[4];\n        tempVar4 = *(uint *)(sectionIterator + 3);\n        pcVar33 = (char *)sectionIterator[1];\n        pcVar28 = pcVar33;\n        if (DAT_001279c8 != (undefined8 *)0x0) {\n          iVar31 = 0;\n          puVar29 = DAT_001279c8;\n          while( true ) {\n            if ((tempVar5 <= iVar31) || (allocatedString = (char *)puVar29[5], allocatedString == (char *)0x0))\n            goto LAB_00105ad5;\n            if (allocatedString != \"\") break;\nLAB_0010750b:\n            iVar31 = iVar31 + 1;\n          }\n          tempVar7 = strcmp(allocatedString,pcVar33);\n          if (tempVar7 != 0) {\n            puVar29 = (undefined8 *)*puVar29;\n            goto LAB_0010750b;\n          }\n          free(allocatedString);\n          uVar20 = uVar24 + 1;\n          puVar29[5] = \"\";\n          tempVar8 = FUN_0011a2e0(puVar29);\n          tempVar9 = DAT_001278f0;\n          *(undefined8 *)(lVar25 + uVar24 * 8) = tempVar8;\n          tempVar10 = htab_elements(tempVar9);\n          if ((tempVar10 != 0) || (DAT_001278f8 != (char **)0x0)) goto LAB_001064eb;\nLAB_00105af8:\n          returnValue = *pcVar33;\n          if (returnValue != '\\0') goto LAB_00105b11;\nLAB_00106557:\n          pcVar33 = DAT_00127928;\n          if ((DAT_001279a8 != '\\0') && (*(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c) != '\\0')\n             ) {\n            tempVar10 = fileObjectPointer[1];\n            returnValue = '\\0';\n            goto LAB_0010668d;\n          }\n          goto joined_r0x00106565;\n        }\nLAB_00105ad5:\n        tempVar10 = htab_elements(DAT_001278f0);\n        uVar20 = uVar24;\n        if ((tempVar10 == 0) && (DAT_001278f8 == (char **)0x0)) goto LAB_00105af8;\n        if (pcVar33 != (char *)0x0) {\nLAB_001064eb:\n          if (((*pcVar33 == '_') && (pcVar33[1] == '_')) &&\n             (tempVar5 = strcmp(pcVar33 + (pcVar33[2] == '_'),\"__gnu_lto_slim\"), tempVar5 == 0)) {\n            tempVar9 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\",5);\n                    \n            FUN_00119dd0(tempVar9);\n          }\n        }\n        _cStack0000000000000148 = 0;\n        in_stack_00000140 = pcVar33;\n        tempVar10 = htab_find(DAT_001278f0);\n        if (((tempVar10 == 0) || (pcVar28 = *(char **)(tempVar10 + 8), pcVar33 == pcVar28)) &&\n           (pcVar28 = pcVar33, pointerPointer2 = DAT_001278f8, (tempVar4 & 0x100) != 0)) {\n          for (; pointerPointer2 != (char **)0x0; pointerPointer2 = (char **)pointerPointer2[3]) {\n            tempVar5 = strcmp(*pointerPointer2,pcVar33);\n            if (tempVar5 == 0) {\n              pcVar28 = pointerPointer2[1];\n              break;\n            }\n          }\n        }\n        sectionIterator[1] = (long)pcVar28;\n        returnValue = *pcVar28;\n        if (returnValue == '\\0') goto LAB_00106557;\nLAB_00105b11:\n        pcVar33 = DAT_00127928;\n        tempVar10 = fileObjectPointer[1];\n        if (*(char *)(tempVar10 + 0x1c) == returnValue) {\n          if (DAT_001279a8 == '\\0') {\n            if ((DAT_00127988 == '\\0') ||\n               ((((tempVar4 & 0x82) == 0 && (sectionName != bfd_map_over_sections)) &&\n                ((*(byte *)(sectionIterator[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n            pcVar28 = pcVar28 + 1;\n            sectionIterator[1] = (long)pcVar28;\n            goto joined_r0x00106565;\n          }\n          returnValue = *(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c);\n          if (returnValue == '\\0') goto LAB_0010677d;\n          if (DAT_00127928 != (char *)0x0) {\n            pcVar28 = pcVar28 + 1;\n            sectionIterator[1] = (long)pcVar28;\n            lengthValue = strlen(pcVar28);\n            tempVar10 = lengthValue + 2;\n            goto LAB_001066bc;\n          }\n          *pcVar28 = returnValue;\n          sectionIterator[1] = (long)pcVar28;\n          uVar24 = uVar20;\n        }\n        else {\n          if ((DAT_001279a8 == '\\0') || (*(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c) == '\\0')\n             ) {\njoined_r0x00106565:\n            uVar24 = uVar20;\n            if (pcVar33 == (char *)0x0) goto LAB_00105b32;\n            lengthValue = strlen(pcVar28);\n            writeSize = strlen(pcVar33);\n            pcVar33 = (char *)xmalloc(writeSize + lengthValue + 1);\n            allocatedString = pcVar33;\n          }\n          else {\nLAB_0010668d:\n            pcVar33 = DAT_00127928;\n            if ((*(char *)(tempVar10 + 0x1c) != '\\0') && (returnValue != *(char *)(tempVar10 + 0x1c)))\n            goto joined_r0x00106565;\n            lengthValue = strlen(pcVar28);\n            tempVar10 = lengthValue + 2;\n            if (pcVar33 == (char *)0x0) {\n              allocatedString = (char *)xmalloc(tempVar10);\n            }\n            else {\nLAB_001066bc:\n              lengthValue = strlen(pcVar33);\n              allocatedString = (char *)xmalloc(lengthValue + tempVar10);\n            }\n            pcVar33 = allocatedString + 1;\n            *allocatedString = *(char *)(*(long *)(in_stack_00000008 + 8) + 0x1c);\n          }\n          tempString = DAT_00127928;\n          if (DAT_00127928 != (char *)0x0) {\n            strcpy(pcVar33,DAT_00127928);\n            lengthValue = strlen(tempString);\n            pcVar33 = pcVar33 + lengthValue;\n          }\n          strcpy(pcVar33,pcVar28);\n          sectionIterator[1] = (long)allocatedString;\n          pcVar28 = allocatedString;\n          uVar24 = uVar20;\n        }\nLAB_00105b32:\n        if (DAT_00127a48 == 7) goto LAB_001067a8;\n        if (((tempVar4 & 0x20) == 0) &&\n           (((tempVar4 & 0x100) == 0 ||\n            ((*(byte *)(**(long **)(sectionIterator[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n          if (((uStack0000000000000048 == 0) &&\n              (((tempVar4 & 0x82) != 0 || ((*(byte *)(sectionIterator[4] + 0x25) & 0x10) != 0)))) ||\n             (tempVar5 = bfd_decode_symclass(sectionIterator), tempVar5 == 0x49)) {\nLAB_00105be2:\n            if (DAT_001279ea == '\\0') {\n              tempVar10 = htab_find();\n              if (tempVar10 == 0) goto LAB_00105c07;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar28;\n              htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n            }\n          }\n          else if ((((tempVar4 & 0x82) == 0) && (sectionName != bfd_map_over_sections)) &&\n                  ((*(byte *)(sectionIterator[4] + 0x25) & 0x10) == 0)) {\n            if ((tempVar4 & 4) == 0) {\n              if (((*(int *)(fileObjectPointer[1] + 8) != 2) ||\n                  (tempVar10 = *(long *)(sectionIterator[4] + 0xd0), tempVar10 == 0)) ||\n                 (*(long *)(tempVar10 + 0x40) == 0)) {\n                if ((DAT_00127a48 == 3) || (DAT_00127a44 == 2)) goto LAB_001067a8;\n                if (DAT_00127a44 == 1) {\n                  returnValue = bfd_is_local_label(fileObjectPointer);\n                  goto joined_r0x00106a11;\n                }\n              }\n              goto LAB_00105be2;\n            }\n            returnValue = DAT_001279a0;\n            if (1 < DAT_00127a48 - 2U) {\njoined_r0x00106a11:\n              if (returnValue == '\\0') goto LAB_00105be2;\n            }\n          }\n          else if (DAT_00127a48 != 3) goto LAB_00105be2;\n          goto LAB_001067a8;\n        }\n        if (DAT_001279ea == '\\0') {\n          tempVar10 = htab_find();\n          if (tempVar10 != 0) {\nLAB_0010687f:\n            tempVar9 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",5)\n            ;\n            FUN_00119ed0(tempVar9);\n            DAT_00127a40 = 1;\n          }\n        }\n        else {\n          _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n          in_stack_00000140 = pcVar28;\n          htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n          if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n        }\n        if ((tempVar4 & 0x20) == 0) {\nLAB_00105c07:\n          if (DAT_001279ea != '\\0') {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar28;\n            htab_traverse(DAT_00127a10,FUN_0011a170,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n            goto LAB_00105c2c;\n          }\n          tempVar10 = htab_find();\n          if (tempVar10 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n          if ((DAT_00127a38 != '\\0') && ((tempVar4 & 0x4000) != 0)) goto LAB_00105c2c;\n          if (DAT_001279ea == '\\0') {\n            tempVar10 = htab_find();\n            if (tempVar10 != 0) goto LAB_00105c2c;\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar28;\n            htab_traverse(DAT_00127a28,FUN_0011a170,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n          }\n        }\n        else {\nLAB_00105c2c:\n          returnValue = FUN_001159d0(sectionIterator[4]);\n          if (returnValue == '\\0') {\n            if (((tempVar4 & 0x800002) == 0) && (sectionName != bfd_map_over_sections)) {\nLAB_00105c5f:\n              if ((tempVar4 & 0x82) != 0) {\n                returnValue = FUN_00115d70(pcVar28);\n                if ((returnValue == '\\0') &&\n                   ((tempVar10 = htab_elements(DAT_001279f8), tempVar10 == 0 ||\n                    (returnValue = FUN_00115d70(pcVar28), returnValue != '\\0')))) {\n                  if (((((DAT_00127958 == '\\0') ||\n                        (tempVar6 = *(uint *)(sectionIterator + 3), (tempVar6 & 0x200000) != 0)) ||\n                       (tempVar10 = *sectionIterator, tempVar10 == 0)) ||\n                      ((*(int *)(*(long *)(tempVar10 + 8) + 8) != 5 || (*(long *)(tempVar10 + 0x110) == 0)\n                       ))) || (1 < (*(byte *)((long)sectionIterator + 0x49) & 3) - 1))\n                  goto joined_r0x00105ca2;\n                }\n                else {\n                  tempVar6 = *(uint *)(sectionIterator + 3);\n                }\n                *(uint *)(sectionIterator + 3) = tempVar6 & 0xffffff7d | 1;\n              }\njoined_r0x00105ca2:\n              if (((tempVar4 & 1) != 0) && (returnValue = FUN_00115d70(pcVar28), returnValue != '\\0')) {\n                *(uint *)(sectionIterator + 3) = *(uint *)(sectionIterator + 3) & 0xfffffffe | 2;\n              }\n            }\n            else {\n              if ((DAT_001279e8 != '\\0') || (returnValue = FUN_00115d70(pcVar28), returnValue != '\\0')) {\n                *(uint *)(sectionIterator + 3) = *(uint *)(sectionIterator + 3) & 0xff7ffffd | 0x80;\n              }\n              if (sectionName != bfd_map_over_sections) goto LAB_00105c5f;\n            }\n            *(long **)(lVar25 + uVar24 * 8) = sectionIterator;\n            uVar24 = uVar24 + 1;\n          }\n        }\n        _in_stack_00000018 = _in_stack_00000018 + 1;\n      } while (in_stack_00000010 != _in_stack_00000018);\n    }\n    if (DAT_001279c8 != (undefined8 *)0x0) {\n      puVar29 = DAT_001279c8;\n      tempVar5 = DAT_001279c0;\n      for (tempVar10 = 0; tempVar10 < tempVar5; tempVar10 = tempVar10 + 1) {\n        pcVar33 = (char *)puVar29[5];\n        if (pcVar33 == (char *)0x0) {\n          sizeValue = uVar24 * 8;\n          uVar24 = uVar24 + 1;\n          tempVar9 = FUN_0011a2e0(puVar29,in_stack_00000008);\n          *(undefined8 *)(lVar25 + sizeValue) = tempVar9;\n          tempVar5 = DAT_001279c0;\n        }\n        else if (pcVar33 != \"\") {\n          tempVar9 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n          FUN_00119dd0(tempVar9,pcVar33);\n        }\n        puVar29 = (undefined8 *)*puVar29;\n      }\n    }\n    boolValue = DAT_001279a0 != '\\0';\n    *(undefined8 *)(lVar25 + uVar24 * 8) = 0;\n    if ((boolValue) && (puStack0000000000000020 != (undefined4 *)0x0)) {\n      tempVar5 = *(int *)(*(undefined8 **)(in_stack_00000008 + 8) + 1);\n      if ((tempVar5 != 5) && (tempVar5 != 2)) {\n        tempVar9 = **(undefined8 **)(in_stack_00000008 + 8);\n        tempVar8 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        FUN_001126c0(0,in_stack_00000008,0,tempVar8,tempVar9);\nLAB_00105d8c:\n        free(puStack0000000000000020);\n        DAT_00127a40 = 1;\n        return 0;\n      }\n      in_stack_000000e0 = (void *)0x0;\n      returnValue = FUN_0011378f(in_stack_00000008,puStack0000000000000020,&stack0x000000c0,\n                           &stack0x00000110,&stack0x000000e0,&stack0x00000140);\n      if (returnValue == '\\0') goto LAB_00105d8c;\n      lVar25 = bfd_make_section_with_flags(in_stack_00000008,\".stab\",0x2108);\n      tempVar10 = bfd_make_section_with_flags(in_stack_00000008,\".stabstr\",0x2108);\n      if ((((lVar25 == 0) || (tempVar10 == 0)) ||\n          (returnValue = bfd_set_section_size(lVar25,in_stack_00000110), returnValue == '\\0')) ||\n         (returnValue = bfd_set_section_size(tempVar10,in_stack_00000140), returnValue == '\\0')) {\n        pcVar33 = \"can\\'t create debugging section\";\nLAB_00105eb4:\n        tempVar9 = dcgettext(0,pcVar33,5);\n        FUN_001126c0(0,in_stack_00000008,0,tempVar9);\n        free(in_stack_000000e0);\n        free(puStack0000000000000020);\n        DAT_00127a40 = 1;\n        return 0;\n      }\n      *(undefined4 *)(lVar25 + 0x7c) = 2;\n      *(undefined4 *)(tempVar10 + 0x7c) = 0;\n      returnValue = bfd_set_section_contents\n                        (in_stack_00000008,lVar25,in_stack_000000c0,0,in_stack_00000110);\n      if ((returnValue == '\\0') ||\n         (returnValue = bfd_set_section_contents\n                            (in_stack_00000008,tempVar10,in_stack_000000e0,0,in_stack_00000140),\n         returnValue == '\\0')) {\n        pcVar33 = \"can\\'t set debugging section contents\";\n        goto LAB_00105eb4;\n      }\n      free(puStack0000000000000020);\n    }\n    in_stack_00000010 = uVar24 & 0xffffffff;\n  }\n  else {\n    if ((DAT_00127a48 - 3U < 4) || ((DAT_00127a44 != 0 || (DAT_00127958 != '\\0'))))\n    goto LAB_00105a07;\n    lVar25 = htab_elements(DAT_00127a18);\n    if (((lVar25 != 0) ||\n        (((((((lVar25 = htab_elements(DAT_00127a28), lVar25 != 0 ||\n              (lVar25 = htab_elements(DAT_00127a08), lVar25 != 0)) ||\n             (lVar25 = htab_elements(DAT_00127a00), lVar25 != 0)) ||\n            ((lVar25 = htab_elements(DAT_001279f8), lVar25 != 0 ||\n             (lVar25 = htab_elements(DAT_001279f0), lVar25 != 0)))) ||\n           (lVar25 = htab_elements(DAT_001278f0), lVar25 != 0)) ||\n          (((DAT_00127928 != (char *)0x0 || (DAT_001278d8 != '\\0')) ||\n           ((DAT_00127a39 != '\\0' ||\n            (((DAT_001279a0 != '\\0' || (DAT_001279a8 != '\\0')) || (DAT_00127988 != '\\0')))))))) ||\n         ((DAT_001278f8 != (char **)0x0 || (DAT_001279e8 != '\\0')))))) || (DAT_001279c0 != 0))\n    goto LAB_001059fe;\n  }\n  bfd_set_symtab(in_stack_00000008,DAT_001278c8,in_stack_00000010 & 0xffffffff);\n  bfd_map_over_sections(fileObjectPointer,FUN_00115dc0,in_stack_00000008);\n  bfd_map_over_sections(fileObjectPointer,FUN_00116110,in_stack_00000008);\n  for (puVar29 = DAT_001279e0; ptrVar2 = DAT_001279d8, puVar29 != (undefined8 *)0x0;\n      puVar29 = (undefined8 *)*puVar29) {\n    returnValue = bfd_set_section_contents(in_stack_00000008,puVar29[5],puVar29[4],0,puVar29[3]);\n    if (returnValue == '\\0') {\n      FUN_001126c0(0,in_stack_00000008,puVar29[5],0);\n      return 0;\n    }\n  }\n  for (; ptrVar2 != (undefined8 *)0x0; ptrVar2 = (undefined8 *)*ptrVar2) {\n    tempVar9 = *(undefined8 *)(ptrVar2[5] + 0x60);\n    returnValue = bfd_set_section_contents(in_stack_00000008,tempVar9,ptrVar2[4],0,ptrVar2[3]);\n    if (returnValue == '\\0') {\n      FUN_001126c0(0,in_stack_00000008,tempVar9,0);\n      return 0;\n    }\n  }\n  if (noteSectionPointer == (long *)0x0) {\n    if ((DAT_00127a20 != '\\0') && (_DAT_001264c0 == 0)) {\n      tempVar9 = *fileObjectPointer;\n      tempVar8 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n      FUN_00119ed0(tempVar8,tempVar9);\n    }\nLAB_0010578f:\n    if ((DAT_00127a30 == 0) ||\n       (returnValue = bfd_fill_in_gnu_debuglink_section(in_stack_00000008,lStack0000000000000078),\n       lVar25 = DAT_00127a30, returnValue != '\\0')) {\n      tempVar4 = (**(code **)(*(long *)(in_stack_00000008 + 8) + 0x140))(fileObjectPointer);\n      uVar24 = (ulong)tempVar4;\n      if ((char)tempVar4 != '\\0') {\n        if (DAT_00127930 == 0) {\n          return uVar24;\n        }\n        returnValue = bfd_alt_mach_code(in_stack_00000008,DAT_00127930 & 0xffffffff);\n        uVar20 = DAT_00127930;\n        if (returnValue != '\\0') {\n          return uVar24;\n        }\n        tempVar9 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n        FUN_00119ed0(tempVar9,uVar20);\n        if (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) != 5) {\n          tempVar9 = dcgettext(0,\"ignoring the alternative value\",5);\n          FUN_00119ed0(tempVar9);\n          return uVar24;\n        }\n        tempVar9 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n        FUN_00119ed0(tempVar9);\n        *(short *)(*(long *)(in_stack_00000008 + 0x110) + 0x3a) = (short)DAT_00127930;\n        return uVar24;\n      }\n      tempVar9 = dcgettext(0,\"error copying private BFD data\",5);\n      FUN_001126c0(0,in_stack_00000008,0,tempVar9);\n    }\n    else {\n      tempVar9 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      FUN_001126c0(0,in_stack_00000008,0,tempVar9,lVar25);\n    }\n    return 0;\n  }\n  mergedSectionPointer = (long *)0x0;\n  puVar29 = *(undefined8 **)(in_stack_00000008 + 0x90);\n  do {\n    if (puVar29 == (undefined8 *)0x0) {\n      do {\n        mergedSectionPointer = (long *)noteSectionPointer[3];\n        free((void *)noteSectionPointer[1]);\n        free(noteSectionPointer);\n        noteSectionPointer = mergedSectionPointer;\n      } while (mergedSectionPointer != (long *)0x0);\n      goto LAB_0010578f;\n    }\n    if ((((DAT_00127a20 != '\\0') && (*(int *)(*(long *)(in_stack_00000008 + 8) + 8) == 5)) &&\n        (*(int *)(puVar29[0x1a] + 4) == 7)) &&\n       (returnValue = FUN_00113fb0(*puVar29,\".gnu.build.attributes\"), returnValue != '\\0')) {\n      if (mergedSectionPointer == (long *)0x0) {\n        mergedSectionPointer = noteSectionPointer;\n      }\n      sectionIterator = noteSectionPointer;\n      if (*(undefined8 **)(*mergedSectionPointer + 0x60) == puVar29) {\nLAB_0010625f:\n        pcVar33 = \"error: failed to merge notes\";\n        if (mergedSectionPointer[1] != 0) {\n          returnValue = bfd_set_section_contents(in_stack_00000008,puVar29,mergedSectionPointer[1],0,mergedSectionPointer[2]);\n          if (returnValue == '\\0') {\n            tempVar9 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n            FUN_001126c0(0,in_stack_00000008,puVar29,tempVar9);\n            return 0;\n          }\n          mergedSectionPointer = (long *)mergedSectionPointer[3];\n          goto LAB_001061be;\n        }\n      }\n      else {\n        do {\n          mergedSectionPointer = sectionIterator;\n          if (*(undefined8 **)(*sectionIterator + 0x60) == puVar29) goto LAB_0010625f;\n          mergedSectionPointer = (long *)sectionIterator[3];\n          sectionIterator = mergedSectionPointer;\n        } while (mergedSectionPointer != (long *)0x0);\n        pcVar33 = \"error: failed to locate merged notes\";\n      }\n      tempVar9 = dcgettext(0,pcVar33,5);\n      FUN_001126c0(0,in_stack_00000008,puVar29,tempVar9);\n    }\nLAB_001061be:\n    puVar29 = (undefined8 *)puVar29[1];\n  } while( true );\n}\n\n",
            "called": [
                "dcgettext",
                "free",
                "FUN_001126c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010551d",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "merge_and_dump_debug_info_0010551d"
        },
        "bfd_printable_arch_mach": {
            "renaming": {},
            "code": "\nvoid bfd_printable_arch_mach(void)\n\n{\n  bfd_printable_arch_mach();\n  return;\n}\n\n",
            "called": [
                "bfd_printable_arch_mach"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045a0",
            "calling": [
                "FUN_001199d0",
                "FUN_00104943",
                "FUN_00105828",
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "bfd_printable_arch_mach"
        },
        "FUN_00108800": {
            "renaming": {
                "FUN_00108800": "hash_string_00108800",
                "param_1": "input_string"
            },
            "code": "\nvoid hash_string_00108800(undefined8 *input_string)\n\n{\n  htab_hash_string_00108800(*input_string);\n  return;\n}\n\n",
            "called": [
                "htab_hash_string"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108800",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "hash_string_00108800"
        },
        "FUN_0010c1c6": {
            "renaming": {
                "FUN_0010c1c6": "deallocate_linked_list_0010c1c6",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "param_5": "arg5",
                "param_6": "arg6",
                "puVar1": "nextNode",
                "cVar2": "result",
                "__ptr": "currentNode"
            },
            "code": "\nundefined deallocateLinkedList_0010c1c6(undefined8 arg1,long arg2,undefined8 arg3,undefined8 arg4,\n                      undefined8 arg5,undefined8 arg6)\n\n{\n  undefined8 *nextNode;\n  char result;\n  undefined8 *currentNode;\n  \n  currentNode = *(undefined8 **)(arg2 + 0x78);\n  while( true ) {\n    if (currentNode == (undefined8 *)0x0) {\n      *(undefined8 *)(arg2 + 0x78) = 0;\n      return 1;\n    }\n    result = FUN_0010c05d(arg1,currentNode[1],currentNode[2],*(undefined4 *)(currentNode + 3),currentNode[4],arg6,\n                         arg5);\n    if (result == '\\0') break;\n    nextNode = (undefined8 *)*currentNode;\n    free(currentNode);\n    currentNode = nextNode;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_0010c05d",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c1c6",
            "calling": [
                "FUN_0010c892",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "deallocate_linked_list_0010c1c6"
        },
        "FUN_001082df": {
            "renaming": {
                "FUN_001082df": "process_data_001082df",
                "unaff_RBX": "baseAddress",
                "unaff_RBP": "framePointer",
                "unaff_R13": "dataPointer",
                "uVar1": "count",
                "lVar2": "value",
                "cVar3": "result",
                "puVar4": "outputArray",
                "puVar5": "nextOutput",
                "uVar6": "index"
            },
            "code": "\nvoid processData_001082df(void)\n\n{\n  uint count;\n  long value;\n  char result;\n  long baseAddress;\n  undefined8 *outputArray;\n  undefined8 *nextOutput;\n  long framePointer;\n  ulong index;\n  undefined8 *dataPointer;\n  \n  count = *(uint *)(baseAddress + 0x78);\n  if (DAT_00127a48 == 7) {\n    outputArray = dataPointer;\n    for (index = 0; index != count; index = index + 1) {\n      nextOutput = outputArray;\n      if (((*(long **)dataPointer[index] != (long *)0x0) &&\n          (value = **(long **)dataPointer[index], value != 0)) &&\n         (result = FUN_00115d70(*(undefined8 *)(value + 8),DAT_00127a28), result != '\\0')) {\n        nextOutput = outputArray + 1;\n        *outputArray = dataPointer[index];\n      }\n      outputArray = nextOutput;\n    }\n    *outputArray = 0;\n  }\n                    /* WARNING: Could not recover jumptable at 0x00115eae. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(framePointer + 8) + 0x288))();\n  return;\n}\n\n",
            "called": [
                "FUN_00115d70"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001082df",
            "calling": [
                "FUN_00115dc0"
            ],
            "imported": false,
            "current_name": "process_data_001082df"
        },
        "open": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104730",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "open"
        },
        "FUN_00114d60": {
            "renaming": {
                "FUN_00114d60": "read_file_and_store_data_00114d60",
                "param_1": "fileInfo",
                "iVar1": "isEndOfFile",
                "piVar2": "errnoPtr",
                "pcVar3": "errorString",
                "__stream": "filePointer",
                "uVar4": "errorMessage",
                "__errno_location": "getErrnoLocation",
                "uVar5": "tempVariable",
                "sVar6": "bytesRead",
                "lVar7": "totalBytesRead",
                "lVar8": "bufferSize"
            },
            "code": "\nvoid readFileAndStoreData_00114d60(long fileInfo)\n\n{\n  int isEndOfFile;\n  int *errnoPtr;\n  char *errorString;\n  undefined8 errorMessage;\n  FILE *filePointer;\n  undefined8 tempVariable;\n  size_t bytesRead;\n  long totalBytesRead;\n  long bufferSize;\n  \n  filePointer = fopen(*(char **)(fileInfo + 0x10),\"r\");\n  if (filePointer == (FILE *)0x0) {\n    errnoPtr = __errno_location();\n    errorString = strerror(*errnoPtr);\n    tempVariable = *(undefined8 *)(fileInfo + 0x10);\n    errorMessage = dcgettext(0,\"cannot open: %s: %s\",5);\n                    \n    FUN_00119dd0(errorMessage,tempVariable,errorString);\n  }\n  bufferSize = 0x1000;\n  totalBytesRead = 0;\n  tempVariable = xmalloc(0x1000);\n  *(undefined8 *)(fileInfo + 0x20) = tempVariable;\n  while( true ) {\n    isEndOfFile = feof(filePointer);\n    if (isEndOfFile != 0) {\n      *(long *)(fileInfo + 0x18) = totalBytesRead;\n      fclose(filePointer);\n      return;\n    }\n    if (totalBytesRead == bufferSize) {\n      bufferSize = totalBytesRead * 2;\n      tempVariable = xrealloc(*(undefined8 *)(fileInfo + 0x20),bufferSize);\n      *(undefined8 *)(fileInfo + 0x20) = tempVariable;\n    }\n    bytesRead = fread((void *)(*(long *)(fileInfo + 0x20) + totalBytesRead),1,bufferSize - totalBytesRead,filePointer);\n    isEndOfFile = ferror(filePointer);\n    if (isEndOfFile != 0) break;\n    totalBytesRead = totalBytesRead + bytesRead;\n  }\n  tempVariable = *(undefined8 *)(fileInfo + 0x10);\n  errorMessage = dcgettext(0,\"%s: fread failed\",5);\n                    \n  FUN_00119dd0(errorMessage,tempVariable);\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_0010543c",
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114d60",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "read_file_and_store_data_00114d60"
        },
        "FUN_00108808": {
            "renaming": {
                "FUN_00108808": "check_section_and_print_message_00108808",
                "unaff_RBP": "stackBase",
                "uVar1": "sectionAddress",
                "uVar2": "localizedMessage"
            },
            "code": "\nvoid checkSectionAndPrintMessage_00108808(void)\n\n{\n  undefined8 sectionAddress;\n  undefined8 localizedMessage;\n  long stackBase;\n  \n  sectionAddress = *(undefined8 *)(stackBase + 0x20);\n  localizedMessage = dcgettext(0,\"Section %s not found\",5);\n                    \n  FUN_00119dd0(localizedMessage,sectionAddress);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00119dd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108808",
            "calling": [
                "FUN_0011a2e0"
            ],
            "imported": false,
            "current_name": "check_section_and_print_message_00108808"
        },
        "bfd_openr_next_archived_file": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104820",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_openr_next_archived_file"
        },
        "FUN_00104d1c": {
            "renaming": {
                "FUN_00104d1c": "process_lines_00104d1c",
                "unaff_EBP": "lineCount",
                "unaff_R13": "errorMessage",
                "unaff_R14": "currentLine",
                "unaff_R15": "currentChar",
                "in_stack_00000008": "filename",
                "in_stack_00000010": "returnAddress",
                "ppbVar2": "hashTableEntry",
                "pbVar3": "spaceCount",
                "pbVar5": "nextLine",
                "pbVar6": "nextChar",
                "pbVar7": "prevLine",
                "uVar1": "errorFormat"
            },
            "code": "\nvoid processLines_00104d1c(void)\n\n{\n  undefined8 errorFormat;\n  byte **hashTableEntry;\n  byte *spaceCount;\n  byte bVar4;\n  byte *nextLine;\n  int lineCount;\n  byte *nextChar;\n  undefined8 errorMessage;\n  byte *prevLine;\n  byte *currentLine;\n  byte *currentChar;\n  undefined8 filename;\n  undefined8 *returnAddress;\n  \n  *currentLine = 0;\nLAB_00114520:\n  currentLine = currentLine + 1;\n  do {\n    bVar4 = *currentLine;\n    prevLine = currentLine;\n    if (bVar4 == 10) {\n      *currentLine = 0;\n      if (currentLine[1] == 0xd) {\n        prevLine = currentLine + 1;\n        nextLine = currentLine + 2;\n      }\n      else {\n        nextLine = currentLine + 1;\n      }\n    }\n    else if ((char)bVar4 < '\\v') {\n      if (bVar4 != 0) goto LAB_00114520;\n      nextLine = currentLine + 1;\n    }\n    else {\n      if (bVar4 != 0xd) break;\n      *currentLine = 0;\n      nextLine = currentLine + 1;\n      if (currentLine[1] == 10) {\n        nextLine = currentLine + 2;\n        prevLine = currentLine + 1;\n      }\n    }\n    bVar4 = *currentChar;\n    while ((bVar4 == 0x20 || (nextChar = currentChar, bVar4 == 9))) {\n      nextChar = currentChar + 1;\n      currentChar = currentChar + 1;\n      bVar4 = *nextChar;\n    }\n    do {\n      if ((bVar4 == 10) || (bVar4 == 0xd)) goto LAB_00114676;\n      if (bVar4 == 0) goto LAB_00114599;\n      bVar4 = nextChar[1];\n      nextChar = nextChar + 1;\n    } while ((bVar4 != 0x20) && (bVar4 != 9));\n    if ((char)bVar4 < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (bVar4 & 0x3f) & 1U) != 0) goto LAB_001145e6;\n    }\n    else {\nLAB_001145e6:\n      bVar4 = nextChar[1];\n      if ((((((bVar4 == 9) || (bVar4 == 0x20)) &&\n            ((bVar4 = nextChar[2], bVar4 == 9 || (bVar4 == 0x20)))) &&\n           ((bVar4 = nextChar[3], bVar4 == 9 || (bVar4 == 0x20)))) &&\n          ((bVar4 = nextChar[4], bVar4 == 9 || (bVar4 == 0x20)))) &&\n         ((bVar4 = nextChar[5], bVar4 == 9 || (bVar4 == 0x20)))) {\n        bVar4 = nextChar[6];\n        spaceCount = nextChar + 6;\n        if ((bVar4 == 9) || (bVar4 == 0x20)) {\n          do {\n            do {\n              bVar4 = spaceCount[1];\n              spaceCount = spaceCount + 1;\n            } while (bVar4 == 0x20);\n          } while (bVar4 == 9);\n        }\n      }\n      if ((0xd < bVar4) || ((-0x2402L >> (bVar4 & 0x3f) & 1U) != 0)) {\n        errorFormat = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n        FUN_00119ed0(errorFormat,filename,lineCount);\n      }\n    }\nLAB_00114599:\n    *nextChar = 0;\n    if (currentChar < nextChar) {\n      hashTableEntry = (byte **)htab_find_slot();\n      *hashTableEntry = currentChar;\n    }\n    lineCount = lineCount + 1;\n    currentLine = nextLine;\n    currentChar = nextLine;\n    if (prevLine[1] == 0) {\n      *returnAddress = errorMessage;\n      return;\n    }\n  } while( true );\n  if (bVar4 == 0x23) {\n    processLines_00104d1c();\n    return;\n  }\n  goto LAB_00114520;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104d1c",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "process_lines_00104d1c"
        },
        "FUN_00119940": {
            "renaming": {
                "FUN_00119940": "validate_and_log_number_00119940",
                "param_1": "vma_address",
                "param_2": "bad_number",
                "uVar1": "error_message",
                "local_20": "scan_results"
            },
            "code": "\nvoid validate_and_log_number_00119940(undefined8 vma_address,undefined8 bad_number)\n\n{\n  undefined8 error_message;\n  char *scan_results [2];\n  \n  bfd_scan_vma(vma_address,scan_results,0);\n  if (*scan_results[0] == '\\0') {\n    return;\n  }\n  error_message = dcgettext(0,\"%s: bad number: %s\",5);\n                    \n  FUN_00119dd0(error_message,bad_number,vma_address);\n}\n\n",
            "called": [
                "bfd_scan_vma",
                "FUN_00104920"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119940",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "validate_and_log_number_00119940"
        },
        "bfd_map_over_sections": {
            "renaming": {},
            "code": "\nvoid bfd_map_over_sections(void)\n\n{\n  bfd_map_over_sections();\n  return;\n}\n\n",
            "called": [
                "bfd_map_over_sections"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104850",
            "calling": [
                "FUN_00107880",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_map_over_sections"
        },
        "FUN_0010540e": {
            "renaming": {
                "FUN_0010540e": "execute_function_with_param_0010540e",
                "param_1": "funcParam1",
                "param_2": "funcParam2",
                "param_3": "funcParam3",
                "in_RAX": "tempVar"
            },
            "code": "\nvoid executeFunctionWithParam_0010540e(undefined8 funcParam1,long funcParam2,uint funcParam3)\n\n{\n  long tempVar;\n  \n  if ((funcParam3 == 2) && (*(int *)(*(long *)(funcParam2 + 8) + 8) == 2)) {\n    funcParam3 = (uint)*(byte *)(*(long *)(*(long *)(funcParam2 + 8) + 0x380) + 0x71);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00105422. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (**(code **)(*(long *)(tempVar + 0x380) + 0x78))(funcParam1,funcParam3 != 0);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010540e",
            "calling": [
                "FUN_00114d50"
            ],
            "imported": false,
            "current_name": "execute_function_with_param_0010540e"
        },
        "bfd_stat": {
            "renaming": {},
            "code": "\nvoid bfd_stat(void)\n\n{\n  bfd_stat();\n  return;\n}\n\n",
            "called": [
                "bfd_stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041b0",
            "calling": [
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_stat"
        },
        "bfd_scan_vma": {
            "renaming": {},
            "code": "\nvoid bfd_scan_vma(void)\n\n{\n  bfd_scan_vma();\n  return;\n}\n\n",
            "called": [
                "bfd_scan_vma"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104070",
            "calling": [
                "FUN_00119940"
            ],
            "imported": false,
            "current_name": "bfd_scan_vma"
        },
        "FUN_00113a4d": {
            "renaming": {
                "FUN_00113a4d": "process_nested_structures_00113a4d",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "structure",
                "param_4": "input_4",
                "param_5": "input_5",
                "cVar1": "result",
                "uVar2": "output",
                "puVar3": "ptr",
                "auVar4": "temp"
            },
            "code": "\nundefined8\nprocessNestedStructures_00113a4d(undefined8 input_1,undefined8 input_2,long structure,undefined8 input_4,\n            undefined8 input_5)\n\n{\n  char result;\n  undefined8 output;\n  undefined8 *ptr;\n  undefined temp [16];\n  \n  result = FUN_00112502(input_1,input_2,*(undefined8 *)(structure + 0x18));\n  if ((result != '\\0') &&\n     (((*(long *)(structure + 0x28) == 0 && (*(long *)(structure + 8) != 0)) ||\n      (result = FUN_0010ec73(input_2,*(undefined8 *)(structure + 0x18)), result != '\\0')))) {\n    if (*(undefined8 **)(structure + 0x28) != (undefined8 *)0x0) {\n      for (ptr = (undefined8 *)**(undefined8 **)(structure + 0x28); ptr != (undefined8 *)0x0;\n          ptr = (undefined8 *)*ptr) {\n        result = FUN_001135a5(input_1,input_2,ptr);\n        if (result == '\\0') {\n          return 0;\n        }\n      }\n    }\n    for (ptr = *(undefined8 **)(structure + 0x10); ptr != (undefined8 *)0x0;\n        ptr = (undefined8 *)*ptr) {\n      result = processNestedStructures_00113a4d(input_1,input_2,ptr);\n      if (result == '\\0') {\n        return 0;\n      }\n    }\n    temp = FUN_00112502(input_1,input_2,*(undefined8 *)(structure + 0x20));\n    if (temp[0] != '\\0') {\n      if ((*(long *)(structure + 0x28) == 0) && (*(long *)(structure + 8) != 0)) {\n        return temp._0_8_;\n      }\n      output = FUN_0010ed2c(input_2,*(undefined8 *)(structure + 0x20),temp._8_8_,input_5);\n      return output;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_001135a5",
                "FUN_00112502",
                "FUN_00113a4d",
                "FUN_0010ec73",
                "FUN_0010ed2c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113a4d",
            "calling": [
                "FUN_001135a5",
                "FUN_00113a4d"
            ],
            "imported": false,
            "current_name": "process_nested_structures_00113a4d"
        },
        "FUN_001081e9": {
            "renaming": {
                "FUN_001081e9": "free_memory_001081e9",
                "in_RAX": "returnValue",
                "unaff_RBX": "memoryPointer",
                "param_7": "returnValue"
            },
            "code": "\nundefined8 freeMemory_001081e9(void)\n\n{\n  undefined8 returnValue;\n  void *memoryPointer;\n  undefined8 returnValue;\n  \n  returnValue = returnValue;\n  free(memoryPointer);\n  return returnValue;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001081e9",
            "calling": [
                "FUN_0011a0e0"
            ],
            "imported": false,
            "current_name": "free_memory_001081e9"
        },
        "bfd_init": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104430",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "bfd_init"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104130",
            "calling": [
                "FUN_00116b90",
                "FUN_00114460",
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "bfd_seek": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048e0",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "bfd_seek"
        },
        "abort": {
            "renaming": {},
            "code": "\n\n\nvoid abort(void)\n\n{\n                    \n  abort();\n}\n\n",
            "called": [
                "abort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040a0",
            "calling": [
                "FUN_001135a5",
                "FUN_0010a94e",
                "FUN_0010abdd",
                "FUN_0010ebb0",
                "FUN_0010aa53",
                "FUN_0010d21c",
                "FUN_001199d0",
                "FUN_0010b0fa",
                "FUN_0010922b",
                "FUN_00112c1f",
                "FUN_0010e9a0",
                "FUN_0010ba08"
            ],
            "imported": false,
            "current_name": "abort"
        },
        "FUN_00113b71": {
            "renaming": {
                "FUN_00113b71": "initialize_memory_block_00113b71",
                "param_1": "memorySize",
                "lVar1": "memoryBlockAddress"
            },
            "code": "\nlong initializeMemoryBlock_00113b71(long memorySize)\n\n{\n  long memoryBlockAddress;\n  \n  if (memorySize != 0) {\n    memoryBlockAddress = FUN_00112904(0x14,0);\n    if (memoryBlockAddress == 0) {\n      memoryBlockAddress = 0;\n    }\n    else {\n      *(long *)(memoryBlockAddress + 0x10) = memorySize;\n    }\n    return memoryBlockAddress;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b71",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e"
            ],
            "imported": false,
            "current_name": "initialize_memory_block_00113b71"
        },
        "FUN_00109dfe": {
            "renaming": {
                "FUN_00109dfe": "process_param_00109dfe",
                "param_1": "inputParam",
                "lVar1": "counter",
                "local_40": "outputString"
            },
            "code": "\nvoid processParam_00109dfe(long inputParam)\n\n{\n  long counter;\n  char outputString [40];\n  \n  if (*(long *)(inputParam + 0x70) != 0) {\n    FUN_00109cf4(inputParam,*(long *)(inputParam + 0x70),0);\n    return;\n  }\n  counter = *(long *)(inputParam + 0x68);\n  *(long *)(inputParam + 0x68) = counter + 1;\n  *(long *)(inputParam + 0x70) = counter;\n  sprintf(outputString,\"%ld=%ld\",counter,counter);\n  FUN_00109b52(inputParam,outputString,counter,1,0);\n  return;\n}\n\n",
            "called": [
                "FUN_00109b52",
                "sprintf",
                "FUN_00109cf4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109dfe",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_param_00109dfe"
        },
        "FUN_00109bbb": {
            "renaming": {
                "FUN_00109bbb": "append_semicolon_if_not_null_00109bbb",
                "param_1": "address",
                "__s": "string",
                "sVar1": "stringLength"
            },
            "code": "\nbool appendSemicolonIfNotNull_00109bbb(long address)\n\n{\n  char *string;\n  size_t stringLength;\n  \n  if (*(long *)(address + 0x60) != 0) {\n    string = *(char **)(*(long *)(address + 0x60) + 0x30);\n    if (string != (char *)0x0) {\n      stringLength = strlen(string);\n      *(undefined2 *)(string + stringLength) = 0x3b;\n    }\n    return string != (char *)0x0;\n  }\n  return false;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109bbb",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "append_semicolon_if_not_null_00109bbb"
        },
        "cplus_demangle_mangled_name": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_mangled_name(void)\n\n{\n  cplus_demangle_mangled_name();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_mangled_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104700",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "cplus_demangle_mangled_name"
        },
        "lseek": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042e0",
            "calling": [
                "FUN_00115a90"
            ],
            "imported": false,
            "current_name": "lseek"
        },
        "FUN_0010ae0e": {
            "renaming": {
                "FUN_0010ae0e": "construct_final_string_0010ae0e",
                "param_1": "inputData",
                "lVar1": "structurePointer",
                "lVar2": "loopVar1",
                "__ptr": "loopVar2",
                "pcVar3": "tempString",
                "sVar4": "length1",
                "sVar5": "length2",
                "pcVar6": "finalString",
                "uVar7": "returnValue",
                "lVar8": "totalLength",
                "uVar9": "loopVar3",
                "uVar10": "loopVar4"
            },
            "code": "\nundefined8 constructFinalString_0010ae0e(long inputData)\n\n{\n  long structurePointer;\n  long loopVar1;\n  void *loopVar2;\n  char *tempString;\n  size_t length1;\n  size_t length2;\n  char *finalString;\n  undefined8 returnValue;\n  long totalLength;\n  uint loopVar3;\n  ulong loopVar4;\n  \n  returnValue = 0;\n  structurePointer = *(long *)(inputData + 0x60);\n  if (((structurePointer != 0) && (*(char **)(structurePointer + 8) != (char *)0x0)) &&\n     (finalString = *(char **)(structurePointer + 0x20), finalString != (char *)0x0)) {\n    length1 = strlen(*(char **)(structurePointer + 8));\n    length2 = strlen(finalString);\n    loopVar1 = *(long *)(structurePointer + 0x28);\n    if (loopVar1 == 0) {\n      totalLength = length1 + length2 + 10;\n      loopVar4 = 0;\n    }\n    else {\n      totalLength = length1 + length2 + 0x1e;\n      loopVar4 = 0;\n      while( true ) {\n        finalString = *(char **)(loopVar1 + loopVar4 * 8);\n        if (finalString == (char *)0x0) break;\n        length1 = strlen(finalString);\n        loopVar4 = (ulong)((int)loopVar4 + 1);\n        totalLength = totalLength + length1;\n      }\n    }\n    if (*(char **)(structurePointer + 0x30) != (char *)0x0) {\n      length1 = strlen(*(char **)(structurePointer + 0x30));\n      totalLength = totalLength + length1;\n    }\n    if (*(char **)(structurePointer + 0x38) != (char *)0x0) {\n      length1 = strlen(*(char **)(structurePointer + 0x38));\n      totalLength = totalLength + length1;\n    }\n    finalString = (char *)xmalloc(totalLength);\n    structurePointer = *(long *)(inputData + 0x60);\n    strcpy(finalString,*(char **)(structurePointer + 8));\n    if (*(long *)(structurePointer + 0x28) != 0) {\n      loopVar3 = 0;\n      length1 = strlen(finalString);\n      sprintf(finalString + length1,\"!%u,\",loopVar4);\n      while( true ) {\n        structurePointer = *(long *)(inputData + 0x60);\n        loopVar4 = (ulong)loopVar3;\n        loopVar2 = *(void **)(structurePointer + 0x28);\n        tempString = *(char **)((long)loopVar2 + loopVar4 * 8);\n        if (tempString == (char *)0x0) break;\n        loopVar3 = loopVar3 + 1;\n        strcat(finalString,tempString);\n        free(*(void **)(*(long *)(structurePointer + 0x28) + loopVar4 * 8));\n      }\n      free(loopVar2);\n      *(undefined8 *)(*(long *)(inputData + 0x60) + 0x28) = 0;\n    }\n    structurePointer = *(long *)(inputData + 0x60);\n    strcat(finalString,*(char **)(structurePointer + 0x20));\n    free(*(void **)(structurePointer + 0x20));\n    structurePointer = *(long *)(inputData + 0x60);\n    *(undefined8 *)(structurePointer + 0x20) = 0;\n    if (*(char **)(structurePointer + 0x30) != (char *)0x0) {\n      strcat(finalString,*(char **)(structurePointer + 0x30));\n      free(*(void **)(structurePointer + 0x30));\n      *(undefined8 *)(*(long *)(inputData + 0x60) + 0x30) = 0;\n    }\n    length1 = strlen(finalString);\n    structurePointer = *(long *)(inputData + 0x60);\n    *(undefined2 *)(finalString + length1) = 0x3b;\n    tempString = *(char **)(structurePointer + 0x38);\n    if (tempString != (char *)0x0) {\n      strcpy(finalString + length1 + 1,tempString);\n      free(*(void **)(structurePointer + 0x38));\n      *(undefined8 *)(*(long *)(inputData + 0x60) + 0x38) = 0;\n    }\n    free(*(void **)(*(long *)(inputData + 0x60) + 8));\n    structurePointer = *(long *)(inputData + 0x60);\n    *(char **)(structurePointer + 8) = finalString;\n    returnValue = CONCAT71((int7)((ulong)structurePointer >> 8),1);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "strcpy",
                "xmalloc",
                "free",
                "strcat",
                "sprintf",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ae0e",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "construct_final_string_0010ae0e"
        },
        "FUN_001135a5": {
            "renaming": {
                "FUN_001135a5": "process_data_001135a5",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "data",
                "iVar1": "count",
                "cVar2": "result",
                "uVar3": "output",
                "puVar4": "ptr1",
                "puVar5": "ptr2"
            },
            "code": "\nundefined8 processData_001135a5(undefined8 input1,undefined8 input2,long data)\n\n{\n  int count;\n  char result;\n  undefined8 output;\n  undefined8 *ptr1;\n  undefined8 *ptr2;\n  \n  if (6 < *(uint *)(data + 0x14)) {\n                    \n    abort();\n  }\n  switch(*(undefined4 *)(data + 0x14)) {\n  case 0:\n    result = FUN_00112c1f(input1,input2,*(undefined8 *)(data + 0x20),data);\n    if (result != '\\0') {\n      output = FUN_0010e6a8(input2,*(undefined8 *)(data + 8));\n      return output;\n    }\n    break;\n  case 1:\n    result = FUN_00112c1f(input1,input2,*(undefined8 *)(data + 0x20),data);\n    if (result != '\\0') {\n      output = FUN_0010e7c2(input2,*(undefined8 *)(data + 8));\n      return output;\n    }\n    break;\n  case 2:\n    result = FUN_00112c1f(input1,input2,*(undefined8 *)(*(long *)(data + 0x20) + 8),0);\n    if (result != '\\0') {\n      output = FUN_0010e9a0(input2,*(undefined8 *)(data + 8),**(undefined4 **)(data + 0x20),\n                           *(undefined8 *)(*(undefined4 **)(data + 0x20) + 4));\n      return output;\n    }\n    break;\n  case 3:\n    ptr2 = *(undefined8 **)(data + 0x20);\n    count = *(int *)(data + 0x18);\n    output = *(undefined8 *)(data + 8);\n    result = FUN_00112502(input1,input2,*(undefined8 *)(ptr2[2] + 0x18));\n    if (((result != '\\0') && (result = FUN_00112c1f(input1,input2,*ptr2,0), result != '\\0')) &&\n       (result = FUN_0010eafe(input2,output,count == 2), result != '\\0')) {\n      for (ptr1 = (undefined8 *)ptr2[1]; ptr1 != (undefined8 *)0x0;\n          ptr1 = (undefined8 *)*ptr1) {\n        result = FUN_00112c1f(input1,input2,ptr1[2],0);\n        if (result == '\\0') {\n          return 0;\n        }\n        result = FUN_0010ebb0(input2,ptr1[1],*(undefined4 *)(ptr1 + 3));\n        if (result == '\\0') {\n          return 0;\n        }\n      }\n      ptr2 = (undefined8 *)ptr2[2];\n      while( true ) {\n        if (ptr2 == (undefined8 *)0x0) {\n          output = FUN_00108f05(input2);\n          return output;\n        }\n        result = FUN_00113a4d(input1,input2,ptr2);\n        if (result == '\\0') break;\n        ptr2 = (undefined8 *)*ptr2;\n      }\n    }\n    break;\n  case 4:\n    output = FUN_0010e842(input2,*(undefined8 *)(data + 8),*(undefined8 *)(data + 0x20));\n    return output;\n  case 5:\n    output = FUN_0010e8a9(*(undefined8 *)(data + 0x20),input2,*(undefined8 *)(data + 8));\n    return output;\n  case 6:\n    result = FUN_00112c1f(input1,input2,**(undefined8 **)(data + 0x20),0);\n    if (result != '\\0') {\n      output = FUN_0010e918(input2,*(undefined8 *)(data + 8),\n                           *(undefined8 *)(*(long *)(data + 0x20) + 8));\n      return output;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_0010ebb0",
                "FUN_00108f05",
                "FUN_0010e842",
                "FUN_0010e6a8",
                "FUN_00112502",
                "FUN_0010e918",
                "FUN_00113a4d",
                "FUN_0010eafe",
                "abort",
                "FUN_0010e7c2",
                "FUN_00112c1f",
                "FUN_0010e9a0",
                "FUN_0010e8a9"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001135a5",
            "calling": [
                "FUN_00113a4d",
                "FUN_0011378f"
            ],
            "imported": false,
            "current_name": "process_data_001135a5"
        },
        "FUN_00107976": {
            "renaming": {
                "FUN_00107976": "FUNC_00107976"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00107976(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  int iVar13;\n  undefined4 uVar14;\n  long *plVar15;\n  long lVar16;\n  undefined8 uVar17;\n  undefined8 uVar18;\n  size_t sVar19;\n  size_t sVar20;\n  char *pcVar21;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar22;\n  long lVar23;\n  ulong uVar24;\n  undefined8 *in_RAX;\n  undefined8 uVar25;\n  char *pcVar26;\n  int *piVar27;\n  long lVar28;\n  ulong uVar29;\n  FILE *__s_00;\n  long **pplVar30;\n  uint uVar31;\n  long **__ptr_01;\n  char *pcVar32;\n  undefined8 *puVar33;\n  ulong uVar34;\n  int iVar35;\n  long **pplVar36;\n  long unaff_RBP;\n  undefined4 *puVar37;\n  undefined8 *puVar38;\n  char **ppcVar39;\n  void *pvVar40;\n  undefined8 *unaff_R14;\n  undefined **ppuVar41;\n  bool bVar42;\n  byte bVar43;\n  undefined8 *param_7;\n  ulong param_8;\n  char in_stack_00000018;\n  undefined4 *puStack0000000000000020;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int iStack000000000000006c;\n  long lStack0000000000000078;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *in_stack_00000140;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar43 = 0;\n  uVar18 = *in_RAX;\n  uVar17 = *param_7;\n  uVar25 = FUN_001125fa();\n  pcVar26 = (char *)dcgettext(0,\"copy from `%s\\' [%s] to `%s\\' [%s]\\n\",5);\n  printf(pcVar26,uVar25,uVar18,uVar17);\n  if ((*(byte *)(param_7 + 9) & 7) == 3) {\n    iVar13 = bfd_get_arch();\n    uVar14 = bfd_get_mach();\n    if (unaff_RBP != 0) {\n      uVar29 = FUNC_001152b6();\n      return uVar29;\n    }\n    goto LAB_00114f9a;\n  }\n  uVar31 = ~DAT_00127910 & *(uint *)(param_7[1] + 0x14) &\n           (DAT_00127914 | *(uint *)((long)unaff_R14 + 0x44));\n  if (DAT_00127a48 == 7) {\n    uVar31 = uVar31 & 0xfffffffe;\n    cVar10 = bfd_set_start_address(param_7);\n  }\n  else {\n    cVar10 = bfd_set_start_address(param_7);\n  }\n  if ((cVar10 == '\\0') || (cVar10 = bfd_set_file_flags(param_7,uVar31), cVar10 == '\\0'))\n  goto LAB_00107a82;\n  iVar13 = bfd_get_arch();\n  uVar14 = bfd_get_mach();\n  if (unaff_RBP == 0) {\nLAB_00114f9a:\n    if (((iVar13 == 0) && (*(int *)(unaff_R14[1] + 8) != 5)) && (*(int *)(param_7[1] + 8) == 5)) {\n      uVar29 = FUNC_00107880();\n      return uVar29;\n    }\n  }\n  else {\n    if (iVar13 == 0) {\n      iVar13 = *(int *)(unaff_RBP + 0xc);\n      uVar14 = *(undefined4 *)(unaff_RBP + 0x10);\n      goto LAB_00114f9a;\n    }\n    uVar18 = FUN_001125fa();\n    uVar17 = dcgettext(0,\"Input file `%s\\' ignores binary architecture parameter.\",5);\n    FUN_00119ed0(uVar17,uVar18);\n  }\n  cVar10 = (**(code **)(param_7[1] + 0x2a0))(param_7,iVar13,uVar14);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar13 = bfd_get_arch();\n      if (iVar13 == 0) {\n        uVar18 = FUN_001125fa();\n        uVar17 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        FUN_00119ed0(uVar17,uVar18);\n        return 0;\n      }\n      uVar18 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar18 = bfd_printable_arch_mach(uVar14,uVar18);\n      uVar17 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      FUN_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    iVar13 = bfd_get_arch();\n    iVar35 = bfd_get_arch(param_7);\n    if (iVar13 != iVar35) {\n      uVar29 = FUN_00105828();\n      return uVar29;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    FUN_001126c0(0);\n    return 0;\n  }\n  if ((*(int *)((undefined8 *)param_7[1] + 1) == 2) &&\n     (cVar10 = FUN_00113fb0(*(undefined8 *)param_7[1],&DAT_0011b503), cVar10 != '\\0')) {\n    lVar28 = param_7[0x22];\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = FUN_00113fb0(*(undefined8 *)unaff_R14[1],&DAT_0011b503), cVar10 != '\\0')) {\n      lVar16 = unaff_R14[0x22];\n      bVar42 = DAT_001279eb == '\\0';\n      puVar33 = (undefined8 *)(lVar16 + 200);\n      puVar38 = (undefined8 *)(lVar28 + 200);\n      for (lVar23 = 0x32; lVar23 != 0; lVar23 = lVar23 + -1) {\n        *puVar38 = *puVar33;\n        puVar33 = puVar33 + (ulong)bVar43 * -2 + 1;\n        puVar38 = puVar38 + (ulong)bVar43 * -2 + 1;\n      }\n      if (bVar42) {\n        *(undefined4 *)(lVar28 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar28 + 0x2a4) = (int)*(undefined8 *)(lVar16 + 0xa8);\n      }\n    }\n    uVar29 = DAT_001264a8;\n    if (DAT_001264a8 == 0xffffffffffffffff) {\n      DAT_001264a8 = 0x200;\n      uVar29 = 0x200;\n    }\n    else {\n      *(int *)(lVar28 + 0x10c) = (int)DAT_001264a8;\n    }\n    if (DAT_00126498 != -1) {\n      *(long *)(lVar28 + 0x148) = DAT_00126498;\n    }\n    if (DAT_001264a0 != -1) {\n      *(long *)(lVar28 + 0x148) = DAT_001264a0;\n    }\n    if (DAT_00126490 != -1) {\n      *(long *)(lVar28 + 0x100) = DAT_00126490;\n    }\n    uVar22 = DAT_00126488;\n    if (DAT_00126488 == 0xffffffffffffffff) {\n      DAT_00126488 = 0x1000;\n      uVar22 = 0x1000;\n    }\n    else {\n      *(int *)(lVar28 + 0x108) = (int)DAT_00126488;\n    }\n    if (DAT_00126478 != -1) {\n      *(long *)(lVar28 + 0x138) = DAT_00126478;\n    }\n    if (DAT_00126480 != -1) {\n      *(long *)(lVar28 + 0x138) = DAT_00126480;\n    }\n    if (DAT_00126474 != -1) {\n      *(short *)(lVar28 + 300) = DAT_00126474;\n    }\n    if (DAT_00126472 != -1) {\n      *(short *)(lVar28 + 0x118) = DAT_00126472;\n    }\n    if (DAT_00126470 != -1) {\n      *(short *)(lVar28 + 0x11a) = DAT_00126470;\n    }\n    if (uVar22 < uVar29) {\n      uVar18 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      FUN_00119ed0(uVar18,uVar29,uVar22);\n    }\n  }\n  plVar6 = DAT_001278d0;\n  free(DAT_001278d0);\n  if (plVar6 == DAT_001278c8) {\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n    lVar28 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(DAT_001278c8);\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n    lVar28 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar28 < 0) goto LAB_00107a82;\n  DAT_001278c8 = (long *)xmalloc();\n  DAT_001278d0 = DAT_001278c8;\n  param_8 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)param_8 < 0) goto LAB_00107a82;\n  if (param_8 == 0) {\n    free(DAT_001278d0);\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar33 = DAT_001279e0;\n  if ((DAT_0012790c == '\\0') &&\n     (cVar10 = (**(code **)(param_7[1] + 0x168))(), puVar33 = DAT_001279e0, cVar10 == '\\0')) {\n    DAT_00127a40 = 1;\n    dcgettext(0,\"error in private header data\",5);\n    FUN_001126c0(0);\n    puVar33 = DAT_001279e0;\n  }\n  for (; puVar38 = DAT_001279d8, puVar33 != (undefined8 *)0x0; puVar33 = (undefined8 *)*puVar33) {\n    uVar31 = 0x128;\n    lVar28 = FUN_00114190(puVar33[1],0,0x80);\n    if (lVar28 != 0) {\n      uVar31 = FUN_00115f30(*(uint *)(lVar28 + 0x28) | 0x100,param_7,puVar33[1]);\n    }\n    lVar28 = bfd_get_section_by_name(param_7,puVar33[1]);\n    if (lVar28 != 0) {\n      uVar18 = puVar33[1];\n      uVar17 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar17,uVar18);\n      return 0;\n    }\n    lVar28 = bfd_make_section_with_flags(param_7,puVar33[1],uVar31 | 0x100000);\n    puVar33[5] = lVar28;\n    if (lVar28 == 0) {\n      uVar18 = puVar33[1];\n      uVar17 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar17,uVar18);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      FUN_001126c0(0,param_7,puVar33[5],0);\n      return 0;\n    }\n    lVar28 = FUN_00114190(puVar33[1],0,0x18);\n    if (lVar28 != 0) {\n      uVar18 = *(undefined8 *)(lVar28 + 0x18);\n      lVar28 = puVar33[5];\n      *(byte *)(lVar28 + 0x28) = *(byte *)(lVar28 + 0x28) | 1;\n      *(undefined8 *)(lVar28 + 0x30) = uVar18;\n      *(undefined8 *)(lVar28 + 0x38) = uVar18;\n    }\n    lVar28 = FUN_00114190(puVar33[1],0,0x60);\n    if (lVar28 != 0) {\n      lVar16 = puVar33[5];\n      *(undefined8 *)(lVar16 + 0x38) = *(undefined8 *)(lVar28 + 0x20);\n      if (0x3e < *(uint *)(lVar16 + 0x7c)) {\n        FUN_001126c0(0,param_7,lVar16,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n    lVar28 = bfd_get_section_by_name();\n    puVar38[5] = lVar28;\n    if (lVar28 == 0) {\n      uVar18 = puVar38[1];\n      uVar17 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      FUN_00119ed0(uVar17,uVar18);\n      return 0;\n    }\n    uVar18 = *(undefined8 *)(lVar28 + 0x60);\n    cVar10 = bfd_set_section_size(uVar18);\n    if (cVar10 == '\\0') {\n      FUN_001126c0(0,param_7,uVar18,0);\n      return 0;\n    }\n  }\n  puVar33 = DAT_001279d0;\n  if (DAT_00127a20 == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar36 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar36;\n    if (pplVar36 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (DAT_00127a20 != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar36[1]; puVar33 = DAT_001279d0, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar33 != (undefined8 *)0x0; puVar33 = (undefined8 *)*puVar33) {\n    lVar28 = bfd_get_section_by_name();\n    if (lVar28 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      FUN_001126c0(0);\n    }\n    else if ((*(byte *)(lVar28 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      FUN_001126c0(0);\n    }\n    else {\n      sVar19 = *(size_t *)(lVar28 + 0x40);\n      __s_00 = fopen((char *)puVar33[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        FUN_001126c0(puVar33[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          FUN_001126c0(0);\n        }\n        else if ((sVar19 != 0) &&\n                (sVar20 = fwrite(in_stack_00000140,1,sVar19,__s_00), sVar20 != sVar19)) {\n          piVar27 = __errno_location();\n          pcVar26 = strerror(*piVar27);\n          uVar18 = puVar33[2];\n          uVar17 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          FUN_00119ed0(uVar17,uVar18,pcVar26);\n          free(in_stack_00000140);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(in_stack_00000140);\n      }\n    }\n  }\n  if (DAT_00127a30 == 0) {\nLAB_0010790a:\n    lStack0000000000000078 = 0;\n  }\n  else {\n    lVar28 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar28 != 0) {\n      uVar18 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      FUN_00119ed0(uVar18);\n      DAT_00127a30 = 0;\n      goto LAB_0010790a;\n    }\n    lStack0000000000000078 = bfd_create_gnu_debuglink_section(param_7);\n    lVar28 = DAT_00127a30;\n    if (lStack0000000000000078 == 0) {\n      uVar18 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar18,lVar28);\n      return 0;\n    }\n    if (*(int *)(param_7[1] + 8) == 2) {\n      uVar22 = 0;\n      for (uVar29 = param_7[0x12]; uVar29 != 0; uVar29 = *(ulong *)(uVar29 + 8)) {\n        uVar24 = *(ulong *)(uVar29 + 0x30);\n        uVar34 = uVar22;\n        uVar7 = uVar29;\n        uVar8 = uVar22;\n        if (uVar24 != 0) {\n          while ((uVar34 = uVar7, uVar8 != 0 &&\n                 (uVar34 = uVar29, uVar24 <= *(ulong *)(uVar22 + 0x30)))) {\n            uVar29 = *(ulong *)(uVar29 + 8);\n            if (uVar29 == 0) goto LAB_00107db8;\n            uVar24 = *(ulong *)(uVar29 + 0x30);\n            uVar7 = uVar22;\n            uVar8 = uVar24;\n          }\n        }\n        uVar22 = uVar34;\n      }\nLAB_00107db8:\n      if (uVar22 == 0) {\n        uVar29 = 0x1000;\n      }\n      else {\n        uVar22 = *(long *)(uVar22 + 0x40) + *(long *)(uVar22 + 0x30);\n        uVar29 = 0xffffffffffffffff;\n        if (uVar22 < 0xfffffffffffff001) {\n          uVar29 = uVar22 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(lStack0000000000000078 + 0x28) = *(byte *)(lStack0000000000000078 + 0x28) | 1;\n      *(ulong *)(lStack0000000000000078 + 0x30) = uVar29;\n      *(ulong *)(lStack0000000000000078 + 0x38) = uVar29;\n    }\n  }\n  plVar6 = DAT_001278d0;\n  iStack000000000000006c = *(int *)(param_7 + 0x14);\n  if (iStack000000000000006c != 0) {\n    uVar29 = FUN_0010554f();\n    return uVar29;\n  }\n  if (DAT_001279a0 == '\\0') {\nLAB_00105588:\n    puStack0000000000000020 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar41 = &PTR_s__stab_00125c60;\n    puStack0000000000000020 = (undefined4 *)xmalloc(0x60);\n    puVar37 = puStack0000000000000020;\n    for (lVar28 = 0x18; lVar28 != 0; lVar28 = lVar28 + -1) {\n      *puVar37 = 0;\n      puVar37 = puVar37 + (ulong)bVar43 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar41;\n      lVar28 = bfd_get_section_by_name();\n      lVar16 = bfd_get_section_by_name();\n      if ((lVar28 != 0) && (lVar16 != 0)) {\n        lVar28 = *(long *)(lVar28 + 0x40);\n        __ptr = (void *)xmalloc(lVar28);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar29 = *(ulong *)(lVar16 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar29 + 1);\n          in_stack_00000018 = bfd_get_section_contents();\n          if (in_stack_00000018 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar29) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)FUN_00112894(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar40 = __ptr; pvVar40 <= (void *)((long)__ptr + lVar28 + -0xc);\n                  pvVar40 = (void *)((long)pvVar40 + 0xc)) {\n                uVar22 = (**(code **)(unaff_R14[1] + 0x40))(pvVar40);\n                bVar2 = *(byte *)((long)pvVar40 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar40 + 6);\n                lVar16 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar40 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar16;\n                }\n                else {\n                  uVar24 = (uVar22 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar24 < uVar29) {\n                    pcVar26 = (char *)((long)__ptr_00 + uVar24);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar19 = strlen(pcVar26);\n                      if (((sVar19 == 0) || (pcVar32 = pcVar26 + (sVar19 - 1), *pcVar32 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar28) < (long)pvVar40 + 0x10U)) goto LAB_001077fb;\n                      *pcVar32 = '\\0';\n                      pvVar40 = (void *)((long)pvVar40 + 0xc);\n                      iVar13 = (**(code **)(unaff_R14[1] + 0x40))(pvVar40);\n                      uVar22 = (ulong)(uint)(iVar13 + (int)lStack0000000000000088);\n                      if (uVar29 <= uVar22) break;\n                      pcVar26 = (char *)concat(pcVar26,(long)__ptr_00 + uVar22,0);\n                      *pcVar32 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar26;\n                    }\n                    uVar18 = *unaff_R14;\n                    pcVar32 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar32,uVar18,puVar3,((long)pvVar40 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    FUN_001088ae((ulong)bVar2,uVar14,lVar16,pcVar26);\n                    cVar10 = FUN_0011173a(puStack0000000000000020,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      FUN_00108b3e();\n                      FUN_00108863();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar18 = *unaff_R14;\n                    pcVar26 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar26,uVar18,puVar3,((long)pvVar40 - (long)__ptr) / 0xc,\n                            uVar22 & 0xffffffff,(ulong)bVar2,((long)pvVar40 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              FUN_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar41 = ppuVar41 + 2;\n    } while (ppuVar41 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = FUN_0010c892(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(puStack0000000000000020);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar28 = 0;\n      for (plVar15 = plVar6; plVar15 < plVar6 + param_8; plVar15 = plVar15 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar28 == 0) && (lVar28 = FUN_00112894(), lVar28 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar26 = (char *)0x0;\n          pcVar32 = in_stack_00000150;\n          while (((*pcVar32 != '\\0' && (sVar19 = strlen(pcVar32), pcVar32[sVar19 - 1] == '\\\\')) &&\n                 (plVar15 + 1 < plVar6 + param_8))) {\n            pcVar21 = (char *)xstrdup(pcVar32);\n            sVar19 = strlen(pcVar21);\n            pcVar21[sVar19 - 1] = '\\0';\n            pcVar32 = (char *)concat(pcVar21,*(undefined8 *)(plVar15[1] + 8),0);\n            free(pcVar21);\n            free(pcVar26);\n            plVar15 = plVar15 + 1;\n            pcVar26 = pcVar32;\n          }\n          FUN_001088ae(uStack0000000000000158,(int)sStack000000000000015a,in_stack_00000140,pcVar32)\n          ;\n          in_stack_00000018 = FUN_0011173a(puStack0000000000000020,lVar28,uStack0000000000000158);\n          if (in_stack_00000018 == '\\0') {\n            FUN_00108b3e();\n            FUN_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      FUN_00108863();\n      if ((lVar28 != 0) && (cVar10 = FUN_0010c892(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (in_stack_00000018 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (param_8 != 0)) {\n        in_stack_00000140 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar33 = (undefined8 *)&stack0x00000148;\n        for (lVar28 = 0x22; lVar28 != 0; lVar28 = lVar28 + -1) {\n          *(undefined4 *)puVar33 = 0;\n          puVar33 = (undefined8 *)((long)puVar33 + (ulong)bVar43 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = param_8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 <= in_stack_000000d0) goto LAB_00105590;\n            lVar28 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar16 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar26 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar26 = *(char **)(lVar28 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar26 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar16) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = FUN_0010bbd3(puStack0000000000000020);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = FUN_0010bbd3(puStack0000000000000020);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar23 = FUN_0010dac0();\n            if (lVar23 == 0) break;\n            cVar9 = FUN_00112a33(&stack0x00000140,lVar28,lVar16);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar26;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar13 = strcmp(pcVar26,\".bb\");\n              if (iVar13 == 0) {\n                cVar9 = FUN_0010be88(puStack0000000000000020);\n              }\n              else {\n                iVar13 = strcmp(pcVar26,\".eb\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = FUN_0010bf20(puStack0000000000000020);\n              }\n              break;\n            case 0x65:\n              iVar13 = strcmp(pcVar26,\".bf\");\n              if (iVar13 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar16 = FUN_0010dac0();\n                  if ((lVar16 == 0) ||\n                     (cVar10 = FUN_0010bc80(puStack0000000000000020), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar13 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar13 = in_stack_00000118 - 1;\n                    }\n                    lVar28 = *(long *)(*(long *)(lVar28 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar35 = _uStack0000000000000048[4];\n                      if (iVar35 == 0) break;\n                      cVar9 = FUN_0010bf86(puStack0000000000000020,iVar13 + iVar35,\n                                           *(long *)(_uStack0000000000000048 + 6) + lVar28);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar26 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar13 = strcmp(pcVar26,\".ef\");\n                if (iVar13 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = FUN_0010be1a(puStack0000000000000020);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar26 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar18 = dcgettext(0,pcVar26,5);\n              FUN_00119ed0(uVar18);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar26 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar18 = dcgettext(0,pcVar26,5);\n        FUN_00119ed0(uVar18);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)((long)param_7 + 0x44) & 0x42) != 0) &&\n     ((*(uint *)((long)param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(param_7[1] + 0x20) == '\\0') && (DAT_00127959 == '\\0')) {\n      if (param_8 != 0) {\n        plVar6 = DAT_001278d0 + param_8;\n        plVar15 = DAT_001278d0;\n        do {\n          uVar31 = *(uint *)(*plVar15 + 0x18);\n          if ((uVar31 & 0x1000000) != 0) {\n            *(uint *)(*plVar15 + 0x18) = uVar31 & 0xfeffffff;\n          }\n          plVar15 = plVar15 + 1;\n        } while (plVar6 != plVar15);\n      }\n    }\n    else {\n      for (lVar28 = param_7[0x12]; lVar28 != 0; lVar28 = *(long *)(lVar28 + 8)) {\n        if (*(long *)(lVar28 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar28 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a48 == 2) || (DAT_00127a48 == 7)) {\nLAB_001059fe:\n    if (DAT_00127a48 == 7) {\nLAB_00105a3b:\n      plVar15 = (long *)xmalloc();\n      plVar6 = DAT_001278d0;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      DAT_001278c8 = plVar15;\n      if (param_8 == 0) {\n        uVar29 = 0;\n      }\n      else {\n        uVar29 = 0;\n        _in_stack_00000018 = 0;\n        do {\n          iVar13 = DAT_001279c0;\n          plVar4 = (long *)plVar6[_in_stack_00000018];\n          pcVar5 = (code *)plVar4[4];\n          uVar31 = *(uint *)(plVar4 + 3);\n          pcVar26 = (char *)plVar4[1];\n          pcVar32 = pcVar26;\n          if (DAT_001279c8 != (undefined8 *)0x0) {\n            iVar35 = 0;\n            puVar33 = DAT_001279c8;\n            while ((iVar35 < iVar13 && (pcVar21 = (char *)puVar33[5], pcVar21 != (char *)0x0))) {\n              if (pcVar21 != \"\") {\n                iVar12 = strcmp(pcVar21,pcVar26);\n                if (iVar12 == 0) {\n                  free(pcVar21);\n                  uVar22 = uVar29 + 1;\n                  puVar33[5] = \"\";\n                  lVar28 = FUN_0011a2e0(puVar33);\n                  uVar18 = DAT_001278f0;\n                  plVar15[uVar29] = lVar28;\n                  lVar28 = htab_elements(uVar18);\n                  if ((lVar28 != 0) || (DAT_001278f8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar33 = (undefined8 *)*puVar33;\n              }\n              iVar35 = iVar35 + 1;\n            }\n          }\n          lVar28 = htab_elements(DAT_001278f0);\n          uVar22 = uVar29;\n          if ((lVar28 == 0) && (DAT_001278f8 == (char **)0x0)) {\nLAB_00105af8:\n            cVar10 = *pcVar26;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar26 = DAT_00127928;\n            if ((DAT_001279a8 != '\\0') && (*(char *)(param_7[1] + 0x1c) != '\\0')) {\n              lVar28 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\n          if (pcVar26 != (char *)0x0) {\nLAB_001064eb:\n            if (((*pcVar26 == '_') && (pcVar26[1] == '_')) &&\n               (iVar13 = strcmp(pcVar26 + (pcVar26[2] == '_'),\"__gnu_lto_slim\"), iVar13 == 0)) {\n              uVar18 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\",5\n                                );\n                    \n              FUN_00119dd0(uVar18);\n            }\n          }\n          _cStack0000000000000148 = 0;\n          in_stack_00000140 = pcVar26;\n          lVar28 = htab_find(DAT_001278f0);\n          if (((lVar28 == 0) || (pcVar32 = *(char **)(lVar28 + 8), pcVar26 == pcVar32)) &&\n             (pcVar32 = pcVar26, ppcVar39 = DAT_001278f8, (uVar31 & 0x100) != 0)) {\n            for (; ppcVar39 != (char **)0x0; ppcVar39 = (char **)ppcVar39[3]) {\n              iVar13 = strcmp(*ppcVar39,pcVar26);\n              if (iVar13 == 0) {\n                pcVar32 = ppcVar39[1];\n                break;\n              }\n            }\n          }\n          plVar4[1] = (long)pcVar32;\n          cVar10 = *pcVar32;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar26 = DAT_00127928;\n          lVar28 = unaff_R14[1];\n          if (*(char *)(lVar28 + 0x1c) == cVar10) {\n            if (DAT_001279a8 == '\\0') {\n              if ((DAT_00127988 == '\\0') ||\n                 ((((uVar31 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar32 = pcVar32 + 1;\n              plVar4[1] = (long)pcVar32;\n              goto joined_r0x00106565;\n            }\n            if (*(char *)(param_7[1] + 0x1c) == '\\0') goto LAB_0010677d;\n            if (DAT_00127928 != (char *)0x0) {\n              pcVar32 = pcVar32 + 1;\n              plVar4[1] = (long)pcVar32;\n              sVar19 = strlen(pcVar32);\n              lVar28 = sVar19 + 2;\nLAB_001066bc:\n              sVar19 = strlen(pcVar26);\n              pcVar26 = (char *)xmalloc(sVar19 + lVar28);\n              goto LAB_001066d0;\n            }\n            *pcVar32 = *(char *)(param_7[1] + 0x1c);\n            plVar4[1] = (long)pcVar32;\n            uVar29 = uVar22;\n          }\n          else {\n            if ((DAT_001279a8 == '\\0') || (*(char *)(param_7[1] + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar29 = uVar22;\n              if (pcVar26 == (char *)0x0) goto LAB_00105b32;\n              sVar19 = strlen(pcVar32);\n              sVar20 = strlen(pcVar26);\n              pcVar21 = (char *)xmalloc(sVar20 + sVar19 + 1);\n              pcVar26 = pcVar21;\n            }\n            else {\nLAB_0010668d:\n              pcVar26 = DAT_00127928;\n              if ((*(char *)(lVar28 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar28 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar19 = strlen(pcVar32);\n              lVar28 = sVar19 + 2;\n              if (pcVar26 != (char *)0x0) goto LAB_001066bc;\n              pcVar26 = (char *)xmalloc(lVar28);\nLAB_001066d0:\n              pcVar21 = pcVar26 + 1;\n              *pcVar26 = *(char *)(param_7[1] + 0x1c);\n            }\n            __s = DAT_00127928;\n            if (DAT_00127928 != (char *)0x0) {\n              strcpy(pcVar21,DAT_00127928);\n              sVar19 = strlen(__s);\n              pcVar21 = pcVar21 + sVar19;\n            }\n            strcpy(pcVar21,pcVar32);\n            plVar4[1] = (long)pcVar26;\n            pcVar32 = pcVar26;\n            uVar29 = uVar22;\n          }\nLAB_00105b32:\n          if (DAT_00127a48 == 7) goto LAB_001067a8;\n          if (((uVar31 & 0x20) == 0) &&\n             (((uVar31 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar31 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar13 = bfd_decode_symclass(plVar4), iVar13 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ea == '\\0') {\n                lVar28 = htab_find();\n                if (lVar28 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                in_stack_00000140 = pcVar32;\n                htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar31 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar31 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar28 = *(long *)(plVar4[4] + 0xd0), lVar28 == 0)) ||\n                   (*(long *)(lVar28 + 0x40) == 0)) {\n                  if ((DAT_00127a48 == 3) || (DAT_00127a44 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a44 == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = DAT_001279a0;\n              if (1 < DAT_00127a48 - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a48 != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ea == '\\0') {\n            lVar28 = htab_find();\n            if (lVar28 != 0) {\nLAB_0010687f:\n              uVar18 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              FUN_00119ed0(uVar18);\n              DAT_00127a40 = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            in_stack_00000140 = pcVar32;\n            htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar31 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ea != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar32;\n              htab_traverse(DAT_00127a10,FUN_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar28 = htab_find();\n            if (lVar28 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a38 != '\\0') && ((uVar31 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ea == '\\0') {\n              lVar28 = htab_find();\n              if (lVar28 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              in_stack_00000140 = pcVar32;\n              htab_traverse(DAT_00127a28,FUN_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = FUN_001159d0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar31 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar31 & 0x82) != 0) {\n                  cVar10 = FUN_00115d70(pcVar32);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar28 = htab_elements(DAT_001279f8), lVar28 == 0 ||\n                      (cVar10 = FUN_00115d70(pcVar32), cVar10 != '\\0')))) {\n                    if (((((DAT_00127958 == '\\0') ||\n                          (uVar11 = *(uint *)(plVar4 + 3), (uVar11 & 0x200000) != 0)) ||\n                         (lVar28 = *plVar4, lVar28 == 0)) ||\n                        ((*(int *)(*(long *)(lVar28 + 8) + 8) != 5 ||\n                         (*(long *)(lVar28 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar11 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar11 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar31 & 1) != 0) && (cVar10 = FUN_00115d70(pcVar32), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279e8 != '\\0') || (cVar10 = FUN_00115d70(pcVar32), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar15[uVar29] = (long)plVar4;\n              uVar29 = uVar29 + 1;\n            }\n          }\n          _in_stack_00000018 = _in_stack_00000018 + 1;\n        } while (param_8 != _in_stack_00000018);\n      }\n      if (DAT_001279c8 != (undefined8 *)0x0) {\n        puVar33 = DAT_001279c8;\n        iVar13 = DAT_001279c0;\n        for (lVar28 = 0; lVar28 < iVar13; lVar28 = lVar28 + 1) {\n          pcVar26 = (char *)puVar33[5];\n          if (pcVar26 == (char *)0x0) {\n            plVar6 = plVar15 + uVar29;\n            uVar29 = uVar29 + 1;\n            lVar16 = FUN_0011a2e0(puVar33,param_7);\n            *plVar6 = lVar16;\n            iVar13 = DAT_001279c0;\n          }\n          else if (pcVar26 != \"\") {\n            uVar18 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            FUN_00119dd0(uVar18,pcVar26);\n          }\n          puVar33 = (undefined8 *)*puVar33;\n        }\n      }\n      bVar42 = DAT_001279a0 == '\\0';\n      plVar15[uVar29] = 0;\n      if ((bVar42) || (puStack0000000000000020 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 = uVar29 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar13 = *(int *)((undefined8 *)param_7[1] + 1);\n      if ((iVar13 == 5) || (iVar13 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = FUN_0011378f(param_7,puStack0000000000000020,&stack0x000000c0,&stack0x00000110,\n                              &stack0x000000e0,&stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar28 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar16 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar28 == 0) || (lVar16 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar28,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar16,in_stack_00000140), cVar10 == '\\0')) {\n            pcVar26 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar28 + 0x7c) = 2;\n            *(undefined4 *)(lVar16 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar28,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents\n                                   (param_7,lVar16,in_stack_000000e0,0,in_stack_00000140),\n               cVar10 != '\\0')) {\n              free(puStack0000000000000020);\n              goto LAB_00105cfa;\n            }\n            pcVar26 = \"can\\'t set debugging section contents\";\n          }\n          uVar18 = dcgettext(0,pcVar26,5);\n          FUN_001126c0(0,param_7,0,uVar18);\n          free(in_stack_000000e0);\n          free(puStack0000000000000020);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar18 = *(undefined8 *)param_7[1];\n        uVar17 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        FUN_001126c0(0,param_7,0,uVar17,uVar18);\n      }\n      free(puStack0000000000000020);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar13 = bfd_get_error();\n      if (iVar13 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a40 = 1;\n  }\n  else {\n    if ((DAT_00127a48 - 3U < 4) || ((DAT_00127a44 != 0 || (DAT_00127958 != '\\0'))))\n    goto LAB_00105a07;\n    lVar28 = htab_elements(DAT_00127a18);\n    if (((lVar28 != 0) ||\n        (((((((lVar28 = htab_elements(DAT_00127a28), lVar28 != 0 ||\n              (lVar28 = htab_elements(DAT_00127a08), lVar28 != 0)) ||\n             (lVar28 = htab_elements(DAT_00127a00), lVar28 != 0)) ||\n            ((lVar28 = htab_elements(DAT_001279f8), lVar28 != 0 ||\n             (lVar28 = htab_elements(DAT_001279f0), lVar28 != 0)))) ||\n           (lVar28 = htab_elements(DAT_001278f0), lVar28 != 0)) ||\n          (((DAT_00127928 != (char *)0x0 || (DAT_001278d8 != '\\0')) ||\n           ((DAT_00127a39 != '\\0' ||\n            (((DAT_001279a0 != '\\0' || (DAT_001279a8 != '\\0')) || (DAT_00127988 != '\\0')))))))) ||\n         ((DAT_001278f8 != (char **)0x0 || (DAT_001279e8 != '\\0')))))) || (DAT_001279c0 != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,DAT_001278c8,param_8 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,FUN_00115dc0,param_7);\n    bfd_map_over_sections(unaff_R14,FUN_00116110,param_7);\n    for (puVar33 = DAT_001279e0; puVar38 = DAT_001279d8, puVar33 != (undefined8 *)0x0;\n        puVar33 = (undefined8 *)*puVar33) {\n      cVar10 = bfd_set_section_contents(param_7,puVar33[5],puVar33[4],0,puVar33[3]);\n      if (cVar10 == '\\0') {\n        FUN_001126c0(0,param_7,puVar33[5],0);\n        return 0;\n      }\n    }\n    for (; puVar38 != (undefined8 *)0x0; puVar38 = (undefined8 *)*puVar38) {\n      uVar18 = *(undefined8 *)(puVar38[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar18,puVar38[4],0,puVar38[3]);\n      if (cVar10 == '\\0') {\n        FUN_001126c0(0,param_7,uVar18,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((DAT_00127a20 != '\\0') && (_DAT_001264c0 == 0)) {\n        uVar18 = *unaff_R14;\n        uVar17 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        FUN_00119ed0(uVar17,uVar18);\n      }\n    }\n    else {\n      pplVar36 = (long **)0x0;\n      for (puVar33 = (undefined8 *)param_7[0x12]; puVar33 != (undefined8 *)0x0;\n          puVar33 = (undefined8 *)puVar33[1]) {\n        if (((DAT_00127a20 != '\\0') && (*(int *)(param_7[1] + 8) == 5)) &&\n           ((*(int *)(puVar33[0x1a] + 4) == 7 &&\n            (cVar10 = FUN_00113fb0(*puVar33,\".gnu.build.attributes\"), cVar10 != '\\0')))) {\n          if (pplVar36 == (long **)0x0) {\n            pplVar36 = __ptr_01;\n          }\n          pplVar30 = __ptr_01;\n          if ((undefined8 *)(*pplVar36)[0xc] == puVar33) {\nLAB_0010625f:\n            pcVar26 = \"error: failed to merge notes\";\n            if (pplVar36[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar33,pplVar36[1],0,pplVar36[2]);\n              if (cVar10 == '\\0') {\n                uVar18 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                FUN_001126c0(0,param_7,puVar33,uVar18);\n                return 0;\n              }\n              pplVar36 = (long **)pplVar36[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar36 = pplVar30;\n              if ((undefined8 *)(*pplVar30)[0xc] == puVar33) goto LAB_0010625f;\n              pplVar36 = (long **)pplVar30[3];\n              pplVar30 = pplVar36;\n            } while (pplVar36 != (long **)0x0);\n            pcVar26 = \"error: failed to locate merged notes\";\n          }\n          uVar18 = dcgettext(0,pcVar26,5);\n          FUN_001126c0(0,param_7,puVar33,uVar18);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar36 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar36;\n      } while (pplVar36 != (long **)0x0);\n    }\n    if ((DAT_00127a30 == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,lStack0000000000000078),\n       lVar28 = DAT_00127a30, cVar10 != '\\0')) {\n      uVar31 = (**(code **)(param_7[1] + 0x140))(unaff_R14);\n      uVar29 = (ulong)uVar31;\n      if ((char)uVar31 != '\\0') {\n        if (DAT_00127930 == 0) {\n          return uVar29;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,DAT_00127930 & 0xffffffff);\n        uVar22 = DAT_00127930;\n        if (cVar10 == '\\0') {\n          uVar18 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          FUN_00119ed0(uVar18,uVar22);\n          if (*(int *)(param_7[1] + 8) == 5) {\n            uVar18 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            FUN_00119ed0(uVar18);\n            *(short *)(param_7[0x22] + 0x3a) = (short)DAT_00127930;\n            return uVar29;\n          }\n          uVar18 = dcgettext(0,\"ignoring the alternative value\",5);\n          FUN_00119ed0(uVar18);\n          return uVar29;\n        }\n        return uVar29;\n      }\n      uVar18 = dcgettext(0,\"error copying private BFD data\",5);\n      FUN_001126c0(0,param_7,0,uVar18);\n    }\n    else {\n      uVar18 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar18,lVar28);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar36[0x1a] + 4) == 7)) &&\n      (cVar10 = FUN_00113fb0(*pplVar36), cVar10 != '\\0')) &&\n     ((pplVar36[0xc] != (long *)0x0 && (plVar6 = pplVar36[8], plVar6 != (long *)0x0)))) {\n    pplVar30 = (long **)xmalloc(0x20);\n    pplVar30[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      FUN_001126c0(0);\n      free(pplVar30);\n    }\n    else {\n      plVar15 = (long *)FUN_001163d0();\n      pplVar30[2] = plVar15;\n      if ((plVar15 == plVar6) || (cVar10 = bfd_set_section_size(pplVar36[0xc]), cVar10 != '\\0')) {\n        pplVar30[3] = (long *)__ptr_01;\n        *pplVar30 = (long *)pplVar36;\n        __ptr_01 = pplVar30;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        FUN_001126c0(0,param_7,pplVar36);\n        free(pplVar30[1]);\n        free(pplVar30);\n      }\n    }\n  }\n  pplVar36 = (long **)pplVar36[1];\n  puVar33 = DAT_001279d0;\n  if (pplVar36 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "FUN_001125fa",
                "dcgettext",
                "bfd_get_mach",
                "bfd_set_start_address",
                "FUN_001152b6",
                "bfd_set_file_flags",
                "printf",
                "bfd_get_arch"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107976",
            "calling": [
                "FUN_00114e50"
            ],
            "imported": false,
            "current_name": "FUNC_00107976"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042a0",
            "calling": [
                "FUN_00119970",
                "FUN_00104ea2",
                "FUN_001199d0",
                "FUN_00104943",
                "FUN_00119f70",
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "strcat": {
            "renaming": {},
            "code": "\n\n\nchar * strcat(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strcat(__dest,__src);\n  return pcVar1;\n}\n\n",
            "called": [
                "strcat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047c0",
            "calling": [
                "FUN_0010ee3f",
                "FUN_00115530",
                "FUN_0010ae0e"
            ],
            "imported": false,
            "current_name": "strcat"
        },
        "FUN_0010b0fa": {
            "renaming": {
                "FUN_0010b0fa": "extract_type_info_0010b0fa",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "typeInfo",
                "param_4": "param",
                "param_5": "errorFlag",
                "uVar1": "typeCode",
                "iVar2": "comparisonResult",
                "pcVar3": "resultString",
                "plVar4": "pointerList",
                "pcVar5": "errorString",
                "sVar6": "stringLength",
                "__ptr": "ptr",
                "lVar7": "size",
                "local_40": "localBuffer"
            },
            "code": "\n\n\nchar * extractTypeInfo_0010b0fa(undefined8 input1,undefined8 input2,uint *typeInfo,long param,\n                   undefined *errorFlag)\n\n{\n  uint typeCode;\n  int comparisonResult;\n  char *resultString;\n  long *pointerList;\n  char *errorString;\n  size_t stringLength;\n  void *ptr;\n  long size;\n  undefined localBuffer [16];\n  \n  if (errorFlag != (undefined *)0x0) {\n    *errorFlag = 0;\n  }\n  while( true ) {\n    typeCode = *typeInfo;\n    if (0x29 < typeCode) break;\n    if (0x17 < typeCode) {\n      switch(typeCode) {\n      case 0x18:\n        goto switchD_0010b158_caseD_18;\n      case 0x19:\n      case 0x1a:\n      case 0x1b:\n      case 0x22:\n      case 0x23:\n        resultString = (char *)extractTypeInfo_0010b0fa(input1,input2,*(undefined8 *)(typeInfo + 4),0,0);\n        if (resultString != (char *)0x0) {\n          switch(*typeInfo) {\n          case 0x19:\n            goto switchD_0010b2de_caseD_19;\n          case 0x1a:\n            resultString = (char *)FUN_00113b4a(resultString);\n            return resultString;\n          case 0x1b:\n            resultString = (char *)FUN_00113b71(resultString);\n            return resultString;\n          default:\n                    \n            abort();\n          case 0x22:\n            resultString = (char *)FUN_00113d3a(resultString);\n            return resultString;\n          case 0x23:\n            resultString = (char *)FUN_00113cb9(resultString);\n            return resultString;\n          }\n        }\n        goto LAB_0010b38c;\n      case 0x27:\n        resultString = (char *)cplus_demangle_print(3,typeInfo,0x14,localBuffer);\n        if (resultString == (char *)0x0) {\n          errorString = \"Couldn\\'t get demangled builtin type\\n\";\n          resultString = (char *)0x0;\n          goto LAB_0010b3d3;\n        }\n        comparisonResult = strcmp(resultString,\"signed char\");\n        if (comparisonResult == 0) {\nLAB_0010b406:\n          errorString = (char *)FUN_00113dfe(1,0);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"bool\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00112904(6,1);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"char\");\n        if (comparisonResult == 0) goto LAB_0010b406;\n        comparisonResult = strcmp(resultString,\"double\");\n        if ((comparisonResult == 0) || (comparisonResult = strcmp(resultString,\"long double\"), comparisonResult == 0)) {\n          errorString = (char *)FUN_00113df2(8);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"float\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113df2(4);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"__float128\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113df2(0x10);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"unsigned char\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113dfe(1,1);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"int\");\n        if (comparisonResult == 0) {\nLAB_0010b504:\n          errorString = (char *)FUN_00113dfe(4,0);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"unsigned int\");\n        if (comparisonResult == 0) {\nLAB_0010b528:\n          errorString = (char *)FUN_00113dfe(4,1);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"long\");\n        if (comparisonResult == 0) goto LAB_0010b504;\n        comparisonResult = strcmp(resultString,\"unsigned long\");\n        if (comparisonResult == 0) goto LAB_0010b528;\n        comparisonResult = strcmp(resultString,\"__int128\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113dfe(0x10,0);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"unsigned __int128\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113dfe(0x10,1);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"short\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113dfe(2,0);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"unsigned short\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113dfe(2,1);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"void\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113e17();\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"wchar_t\");\n        if (comparisonResult == 0) goto LAB_0010b528;\n        comparisonResult = strcmp(resultString,\"long long\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113dfe(8,0);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"unsigned long long\");\n        if (comparisonResult == 0) {\n          errorString = (char *)FUN_00113dfe(8,1);\n          goto LAB_0010b6c6;\n        }\n        comparisonResult = strcmp(resultString,\"...\");\n        if (comparisonResult == 0) {\n          errorString = \"Unexpected demangled varargs\\n\";\n          if (errorFlag == (undefined *)0x0) goto LAB_0010b6a9;\n          *errorFlag = 1;\n        }\n        else {\n          errorString = \"Unrecognized demangled builtin type\\n\";\nLAB_0010b6a9:\n          errorString = (char *)dcgettext(0,errorString,5);\n          fprintf(_stderr,errorString);\n        }\n        errorString = (char *)0x0;\nLAB_0010b6c6:\n        free(resultString);\n        return errorString;\n      case 0x29:\n        if (*(long *)(typeInfo + 4) == 0) {\n          ptr = (void *)FUN_00113e17();\n        }\n        else {\n          ptr = (void *)extractTypeInfo_0010b0fa(input1,input2,*(long *)(typeInfo + 4),0,0);\n        }\n        if (ptr != (void *)0x0) {\n          size = FUN_0010b6ea(input1,input2,*(undefined8 *)(typeInfo + 6),localBuffer);\n          if (size != 0) {\n            resultString = (char *)FUN_00113ce0(ptr,size,localBuffer[0]);\n            return resultString;\n          }\n          free(ptr);\n        }\n        goto LAB_0010b38c;\n      }\n      break;\n    }\n    if (typeCode != 1) {\n      if (typeCode == 4) {\n        resultString = (char *)cplus_demangle_print(3,typeInfo,0x14,localBuffer);\n        errorString = \"Failed to print demangled template\\n\";\n        if (resultString != (char *)0x0) {\n          stringLength = strlen(resultString);\n          errorString = (char *)FUN_0010afd5(input1,input2,resultString,stringLength & 0xffffffff,9);\n          free(resultString);\n          return errorString;\n        }\nLAB_0010b3d3:\n        errorString = (char *)dcgettext(0,errorString,5);\n        fprintf(_stderr,errorString);\n        return resultString;\n      }\n      if (typeCode == 0) {\n        if ((param == 0) || (pointerList = (long *)FUN_00113b1e(param), pointerList == (long *)0x0))\n        goto switchD_0010b158_caseD_18;\n        goto LAB_0010b1a5;\n      }\n      break;\n    }\n    param = extractTypeInfo_0010b0fa(input1,input2,*(undefined8 *)(typeInfo + 4),param,0);\n    if (param == 0) goto LAB_0010b38c;\n    typeInfo = *(uint **)(typeInfo + 6);\n    errorFlag = (undefined *)0x0;\n  }\n  resultString = (char *)dcgettext(0,\"Unrecognized demangle component %d\\n\",5);\n  fprintf(_stderr,resultString,(ulong)typeCode);\nLAB_0010b38c:\n  resultString = (char *)0x0;\nswitchD_0010b2de_caseD_19:\n  return resultString;\nLAB_0010b1a5:\n  if (*pointerList == 0) {\nswitchD_0010b158_caseD_18:\n    resultString = (char *)FUN_0010afd5(input1,input2,*(undefined8 *)(typeInfo + 4),typeInfo[6],0);\n    return resultString;\n  }\n  resultString = *(char **)(*pointerList + 8);\n  if (resultString == (char *)0x0) goto LAB_0010b38c;\n  errorString = (char *)FUN_001129f4(resultString);\n  if (errorString != (char *)0x0) {\n    stringLength = strlen(errorString);\n    if ((typeInfo[6] == (uint)stringLength) &&\n       (comparisonResult = strncmp(errorString,*(char **)(typeInfo + 4),(long)(int)typeInfo[6]), comparisonResult == 0)) {\n      return resultString;\n    }\n  }\n  pointerList = pointerList + 1;\n  goto LAB_0010b1a5;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00113dfe",
                "FUN_00113b1e",
                "FUN_00113b71",
                "FUN_00113e17",
                "FUN_001129f4",
                "FUN_0010b6ea",
                "cplus_demangle_print",
                "strlen",
                "FUN_00113df2",
                "fprintf",
                "FUN_00113b4a",
                "strncmp",
                "FUN_00112904",
                "free",
                "FUN_00113ce0",
                "strcmp",
                "FUN_00113cb9",
                "abort",
                "FUN_0010b0fa",
                "FUN_0010afd5",
                "FUN_00113d3a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010b0fa",
            "calling": [
                "FUN_0010b0fa",
                "FUN_0010b6ea"
            ],
            "imported": false,
            "current_name": "extract_type_info_0010b0fa"
        },
        "FUN_00104c36": {
            "renaming": {
                "FUN_00104c36": "parse_lines_00104c36",
                "unaff_RBX": "current_line",
                "unaff_EBP": "line_number",
                "unaff_R13": "file_name",
                "unaff_R14": "current_char",
                "unaff_R15": "line_start",
                "in_stack_00000008": "error_message",
                "in_stack_00000010": "return_address",
                "uVar1": "warning_message",
                "ppbVar2": "slot",
                "pbVar3": "next_char",
                "pbVar5": "ptr",
                "in_CL": "current_char_code",
                "bVar4": "next_char_code"
            },
            "code": "\nvoid parse_lines_00104c36(void)\n\n{\n  undefined8 warning_message;\n  byte **slot;\n  byte *next_char;\n  byte current_char_code;\n  byte next_char_code;\n  byte *current_line;\n  int line_number;\n  byte *ptr;\n  undefined8 file_name;\n  byte *current_char;\n  byte *line_start;\n  undefined8 error_message;\n  undefined8 *return_address;\n  \n  do {\n    ptr = line_start;\n    if (current_char_code == 9) goto LAB_00104c3f;\n    do {\n      if ((current_char_code == 10) || (current_char_code == 0xd)) goto LAB_00114676;\n      if (current_char_code == 0) goto LAB_00114599;\n      current_char_code = ptr[1];\n      ptr = ptr + 1;\n    } while ((current_char_code != 0x20) && (current_char_code != 9));\n    if ((char)current_char_code < '\\x0e') {\nLAB_00114676:\n      if ((-0x2402L >> (current_char_code & 0x3f) & 1U) != 0) goto LAB_001145e6;\n    }\n    else {\nLAB_001145e6:\n      next_char_code = ptr[1];\n      if ((((((next_char_code == 9) || (next_char_code == 0x20)) &&\n            ((next_char_code = ptr[2], next_char_code == 9 || (next_char_code == 0x20)))) &&\n           ((next_char_code = ptr[3], next_char_code == 9 || (next_char_code == 0x20)))) &&\n          ((next_char_code = ptr[4], next_char_code == 9 || (next_char_code == 0x20)))) &&\n         ((next_char_code = ptr[5], next_char_code == 9 || (next_char_code == 0x20)))) {\n        next_char_code = ptr[6];\n        next_char = ptr + 6;\n        if ((next_char_code == 9) || (next_char_code == 0x20)) {\n          do {\n            do {\n              next_char_code = next_char[1];\n              next_char = next_char + 1;\n            } while (next_char_code == 0x20);\n          } while (next_char_code == 9);\n        }\n      }\n      if ((0xd < next_char_code) || ((-0x2402L >> (next_char_code & 0x3f) & 1U) != 0)) {\n        warning_message = dcgettext(0,\"%s:%d: Ignoring rubbish found on this line\",5);\n        FUN_00119ed0(warning_message,error_message,line_number);\n      }\n    }\nLAB_00114599:\n    *ptr = 0;\n    if (line_start < ptr) {\n      slot = (byte **)htab_find_slot();\n      *slot = line_start;\n    }\n    line_number = line_number + 1;\n    ptr = current_line;\n    if (current_char[1] == 0) {\n      *return_address = file_name;\n      return;\n    }\n    for (; next_char_code = *ptr, current_char = ptr, next_char_code != 10; ptr = ptr + 1) {\n      if ((char)next_char_code < '\\v') {\n        if (next_char_code == 0) {\n          next_char = ptr + 1;\n          goto LAB_00114553;\n        }\n      }\n      else {\n        if (next_char_code == 0xd) {\n          *ptr = 0;\n          next_char = ptr + 1;\n          if (ptr[1] == 10) {\n            next_char = ptr + 2;\n            current_char = ptr + 1;\n          }\n          goto LAB_00114553;\n        }\n        if (next_char_code == 0x23) {\n          FUN_00104d1c();\n          return;\n        }\n      }\n    }\n    *ptr = 0;\n    if (ptr[1] == 0xd) {\n      current_char = ptr + 1;\n      next_char = ptr + 2;\n    }\n    else {\n      next_char = ptr + 1;\n    }\nLAB_00114553:\n    current_char_code = *current_line;\n    line_start = current_line;\n    while (current_line = next_char, current_char_code == 0x20) {\nLAB_00104c3f:\n      ptr = line_start + 1;\n      line_start = line_start + 1;\n      next_char = current_line;\n      current_char_code = *ptr;\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104c36",
            "calling": [
                "FUN_00104cc1"
            ],
            "imported": false,
            "current_name": "parse_lines_00104c36"
        },
        "FUN_0010554f": {
            "renaming": {
                "FUN_0010554f": "improved_binary_section_processing_0010554f",
                "puVar1": "sectionPtr",
                "bVar2": "byteValue",
                "pcVar3": "codingFunction",
                "puVar4": "ptrValue",
                "uVar5": "undefinedValue",
                "uVar6": "ushortValue",
                "cVar7": "charValue",
                "cVar8": "charValue2",
                "uVar9": "returnValue",
                "iVar10": "intValue",
                "iVar11": "intValue2",
                "uVar12": "uintValue",
                "uVar13": "uintValue2",
                "lVar14": "longValue4",
                "lVar23": "longValue2",
                "lVar37": "longValue3",
                "plVar15": "pointerValue",
                "plVar20": "pointerValue2",
                "plVar25": "pointerValue3",
                "puVar26": "pointerValue4",
                "puVar30": "pointerValue5",
                "pcVar31": "stringValue",
                "pcVar22": "stringValue2",
                "uVar17": "returnValue2",
                "sVar18": "sizeValue",
                "sVar19": "sizeValue2",
                "__ptr": "pointerValue6",
                "unaff_R14": "registerValue3",
                "ppuVar36": "pointerPointerValue",
                "plVar28": "pointerValue7",
                "param_7": "paramValue1",
                "param_8": "paramValue2",
                "param_12": "paramValue3",
                "param_14": "paramValue4",
                "param_17": "paramValue5",
                "uVar29": "uintValue3",
                "param_30": "paramValue6",
                "param_36": "paramValue7",
                "param_37": "paramValue8",
                "param_40": "paramValue9",
                "param_41": "paramValue10",
                "param_42": "paramValue11",
                "param_43": "paramValue12",
                "param_44": "paramValue13"
            },
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\n\nundefined4 improved_binary_section_processing_0010554f(void)\n\n{\n  uint *sectionPtr;\n  byte byteValue;\n  code *codingFunction;\n  undefined8 *ptrValue;\n  undefined undefinedValue;\n  ushort ushortValue;\n  char charValue;\n  char charValue2;\n  undefined4 returnValue;\n  int intValue;\n  int intValue2;\n  uint uintValue;\n  uint uintValue2;\n  long longValue4;\n  long *pointerValue;\n  undefined8 uVar16;\n  undefined *pointerValue6;\n  undefined8 returnValue2;\n  size_t sizeValue;\n  size_t sizeValue2;\n  long *__dest;\n  long *pointerValue2;\n  void *pointerValue6_00;\n  void *pointerValue6_01;\n  ulong uVar21;\n  char *__s;\n  char *stringValue2;\n  long longValue2;\n  ulong uVar24;\n  long *pointerValue3;\n  undefined8 *pointerValue4;\n  int iVar27;\n  long *pointerValue7;\n  ulong uintValue3;\n  ulong *pointerValue5;\n  char *stringValue;\n  undefined4 *puVar32;\n  undefined *puVar33;\n  long *in_R10;\n  char **pcodingFunction4;\n  void *pvVar35;\n  undefined8 *registerValue3;\n  undefined **pointerPointerValue;\n  long longValue3;\n  bool bVar38;\n  byte bVar39;\n  long paramValue1;\n  ulong paramValue2;\n  char param_9;\n  undefined4 *pointerValue6_02;\n  ulong paramValue3;\n  char *param_13;\n  undefined *paramValue4;\n  uint param_15;\n  long *paramValue5;\n  undefined8 in_stack_00000068;\n  undefined8 param_21;\n  long param_23;\n  char *param_24;\n  long param_26;\n  long *paramValue6;\n  ulong param_31;\n  long param_32;\n  long in_stack_000000d8;\n  void *param_33;\n  long param_34;\n  undefined8 in_stack_000000f8;\n  byte paramValue7;\n  byte paramValue8;\n  undefined8 param_38;\n  ushort param_39;\n  long *paramValue9;\n  char paramValue10;\n  char *paramValue11;\n  undefined paramValue12;\n  short paramValue13;\n  \n  bVar39 = 0;\n  if ((DAT_00127998 == '\\0') && (DAT_00127989 == '\\0')) {\n    paramValue3 = 0;\n    paramValue4 = (undefined *)0x0;\n    paramValue5 = (long *)0x0;\n    uintValue3 = paramValue3;\n  }\n  else {\n    longValue4 = (ulong)in_stack_00000068._4_4_ * 8;\n    paramValue5 = (long *)xmalloc(longValue4);\n    paramValue9 = paramValue5;\n    bfd_map_over_sections(paramValue1,FUN_0010870e,&stack0x00000140);\n    qsort(paramValue5,(ulong)in_stack_00000068._4_4_,8,FUN_0010875d);\n    paramValue4 = (undefined *)xmalloc(longValue4);\n    bVar38 = DAT_00127998 != '\\0';\n    puVar33 = paramValue4;\n    for (; longValue4 != 0; longValue4 = longValue4 + -1) {\n      *puVar33 = 0;\n      puVar33 = puVar33 + (ulong)bVar39 * -2 + 1;\n    }\n    if (bVar38) {\n      uintValue3 = 0;\n      paramValue3 = 0;\n      do {\n        pointerValue5 = (ulong *)(paramValue4 + uintValue3 * 8);\n        pointerValue7 = paramValue5 + uintValue3;\n        uVar21 = paramValue3;\n        do {\n          paramValue3 = uVar21;\n          if (in_stack_00000068._4_4_ - 1 <= (uint)uintValue3) goto LAB_00107cd1;\n          uintValue3 = (ulong)((uint)uintValue3 + 1);\n          uintValue = bfd_octets_per_byte(paramValue1,*pointerValue7);\n          uintValue2 = bfd_octets_per_byte(paramValue1);\n          longValue4 = *pointerValue7;\n          if ((*(uint *)(longValue4 + 0x24) & 0x102) != 0x102) break;\n          uVar21 = (ulong)uintValue2 * *(long *)(pointerValue7[1] + 0x38);\n          uVar24 = (ulong)uintValue * *(long *)(longValue4 + 0x38) + *(long *)(longValue4 + 0x40);\n          if (uVar21 <= uVar24) break;\n          uVar21 = uVar21 - uVar24;\n          charValue = bfd_set_section_size();\n          if (charValue == '\\0') {\n            dcgettext(0,\"Can\\'t fill gap after section\",5);\n            FUN_001126c0(0,paramValue1,*pointerValue7);\n            DAT_00127a40 = 1;\n            goto LAB_00107cd1;\n          }\n          *pointerValue5 = uVar21;\n          pointerValue7 = pointerValue7 + 1;\n          pointerValue5 = pointerValue5 + 1;\n        } while (paramValue3 < uVar21);\n      } while( true );\n    }\n    paramValue3 = 0;\nLAB_00107cd1:\n    uintValue3 = paramValue3;\n    if (DAT_00127989 != '\\0') {\n      uintValue = bfd_octets_per_byte(paramValue1);\n      longValue4 = paramValue5[in_stack_00000068._4_4_ - 1];\n      uVar21 = DAT_00127990 * (ulong)uintValue;\n      uVar24 = *(long *)(longValue4 + 0x40) + (ulong)uintValue * *(long *)(longValue4 + 0x38);\n      if (uVar24 < uVar21) {\n        charValue = bfd_set_section_size();\n        if (charValue == '\\0') {\n          dcgettext(0,\"can\\'t add padding\",5);\n          FUN_001126c0(0,paramValue1,paramValue5[in_stack_00000068._4_4_ - 1]);\n          DAT_00127a40 = 1;\n        }\n        else {\n          uintValue3 = uVar21 - uVar24;\n          *(ulong *)(paramValue4 + (ulong)(in_stack_00000068._4_4_ - 1) * 8) = uintValue3;\n          if (uintValue3 <= paramValue3) {\n            uintValue3 = paramValue3;\n          }\n        }\n      }\n    }\n  }\n  paramValue3 = uintValue3;\n  pointerValue7 = DAT_001278d0;\n  if (DAT_001279a0 == '\\0') {\nLAB_00105588:\n    pointerValue6_02 = (undefined4 *)0x0;\n  }\n  else {\n    pointerPointerValue = &PTR_s__stab_00125c60;\n    pointerValue6_02 = (undefined4 *)xmalloc(0x60);\n    puVar32 = pointerValue6_02;\n    for (longValue4 = 0x18; longValue4 != 0; longValue4 = longValue4 + -1) {\n      *puVar32 = 0;\n      puVar32 = puVar32 + (ulong)bVar39 * -2 + 1;\n    }\n    param_13 = (char *)0x0;\n    do {\n      puVar33 = *pointerPointerValue;\n      longValue4 = bfd_get_section_by_name(registerValue3,puVar33);\n      longValue3 = bfd_get_section_by_name();\n      if ((longValue4 != 0) && (longValue3 != 0)) {\n        longValue2 = *(long *)(longValue4 + 0x40);\n        pointerValue6_00 = (void *)xmalloc(longValue2);\n        charValue = bfd_get_section_contents(registerValue3,longValue4,pointerValue6_00,0,longValue2);\n        if (charValue == '\\0') {\n          returnValue = bfd_get_error();\n          bfd_errmsg(returnValue);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*registerValue3);\n          free(param_13);\n          free(pointerValue6_00);\n        }\n        else {\n          uintValue3 = *(ulong *)(longValue3 + 0x40);\n          pointerValue6_01 = (void *)xmalloc(uintValue3 + 1);\n          param_9 = bfd_get_section_contents(registerValue3,longValue3,pointerValue6_01,0);\n          if (param_9 == '\\0') {\n            returnValue = bfd_get_error();\n            bfd_errmsg(returnValue);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*registerValue3);\n            free(param_13);\n          }\n          else {\n            *(undefined *)((long)pointerValue6_01 + uintValue3) = 0;\n            if ((param_13 != (char *)0x0) ||\n               (param_13 = (char *)FUN_00112894(registerValue3,1,pointerValue7), param_13 != (char *)0x0)) {\n              param_26 = 0;\n              param_23 = 0;\n              for (pvVar35 = pointerValue6_00; pvVar35 <= (void *)((long)pointerValue6_00 + longValue2 + -0xc);\n                  pvVar35 = (void *)((long)pvVar35 + 0xc)) {\n                uVar21 = (**(code **)(registerValue3[1] + 0x40))(pvVar35);\n                byteValue = *(byte *)((long)pvVar35 + 4);\n                returnValue = (**(code **)(registerValue3[1] + 0x58))((long)pvVar35 + 6);\n                longValue4 = (**(code **)(registerValue3[1] + 0x40))((long)pvVar35 + 8);\n                if (byteValue == 0) {\n                  param_23 = param_26;\n                  param_26 = param_26 + longValue4;\n                }\n                else {\n                  uVar24 = (uVar21 & 0xffffffff) + param_23;\n                  if (uVar24 < uintValue3) {\n                    stringValue = (char *)((long)pointerValue6_01 + uVar24);\n                    param_24 = (char *)0x0;\n                    while( true ) {\n                      sizeValue = strlen(stringValue);\n                      if (((sizeValue == 0) || (stringValue2 = stringValue + (sizeValue - 1), *stringValue2 != '\\')) ||\n                         ((ulong)((long)pointerValue6_00 + longValue2) < (long)pvVar35 + 0x10U))\n                      goto LAB_001077fb;\n                      *stringValue2 = '\\0';\n                      pvVar35 = (void *)((long)pvVar35 + 0xc);\n                      intValue = (**(code **)(registerValue3[1] + 0x40))(pvVar35);\n                      uVar21 = (ulong)(uint)(intValue + (int)param_23);\n                      if (uintValue3 <= uVar21) break;\n                      stringValue = (char *)concat(stringValue,(long)pointerValue6_01 + uVar21,0);\n                      *stringValue2 = '\\';\n                      free(param_24);\n                      param_24 = stringValue;\n                    }\n                    returnValue2 = *registerValue3;\n                    stringValue2 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,stringValue2,returnValue2,puVar33,((long)pvVar35 - (long)pointerValue6_00) / 0xc);\nLAB_001077fb:\n                    FUN_001088ae((ulong)byteValue,returnValue,longValue4,stringValue);\n                    charValue = FUN_0011173a(pointerValue6_02,param_13,byteValue);\n                    if (charValue == '\\0') {\n                      FUN_00108b3e();\n                      FUN_00108863();\n                      free(param_24);\n                      free(param_13);\n                      free(pointerValue6_00);\n                      free(pointerValue6_01);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    returnValue2 = *registerValue3;\n                    stringValue = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,stringValue,returnValue2,puVar33,((long)pvVar35 - (long)pointerValue6_00) / 0xc,\n                            uVar21 & 0xffffffff,(ulong)byteValue,((long)pvVar35 - (long)pointerValue6_00) % 0xc)\n                    ;\n                  }\n                }\n              }\n              FUN_00108863();\n              free(pointerValue6_00);\n              goto LAB_001058eb;\n            }\n          }\n          free(pointerValue6_01);\n          free(pointerValue6_00);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      pointerPointerValue = pointerPointerValue + 2;\n    } while (pointerPointerValue != (undefined **)&DAT_00125c90);\n    if ((param_13 != (char *)0x0) && (charValue = FUN_0010c892(), charValue == '\\0')) {\nLAB_00105981:\n      free(pointerValue6_02);\n      goto LAB_00105588;\n    }\n    if (*(int *)(registerValue3[1] + 8) == 1) {\n      longValue4 = 0;\n      for (pointerValue = pointerValue7; pointerValue < pointerValue7 + paramValue2; pointerValue = pointerValue + 1) {\n        (**(code **)(registerValue3[1] + 0x218))(registerValue3,*pointerValue,&stack0x00000140);\n        if (paramValue10 == '-') {\n          if (((longValue4 == 0) && (longValue4 = FUN_00112894(registerValue3,0,pointerValue7), longValue4 == 0)) ||\n             ((paramValue11 == (char *)0x0 || (*paramValue11 == '\\0')))) goto LAB_00105981;\n          stringValue = (char *)0x0;\n          stringValue2 = paramValue11;\n          while (((*stringValue2 != '\\0' && (sizeValue = strlen(stringValue2), stringValue2[sizeValue - 1] == '\\')) &&\n                 (pointerValue + 1 < pointerValue7 + paramValue2))) {\n            __s = (char *)xstrdup(stringValue2);\n            sizeValue = strlen(__s);\n            __s[sizeValue - 1] = '\\0';\n            stringValue2 = (char *)concat(__s,*(undefined8 *)(pointerValue[1] + 8),0);\n            free(__s);\n            free(stringValue);\n            pointerValue = pointerValue + 1;\n            stringValue = stringValue2;\n          }\n          FUN_001088ae(paramValue12,(int)paramValue13,paramValue9,stringValue2);\n          param_9 = FUN_0011173a(pointerValue6_02,longValue4,paramValue12);\n          if (param_9 == '\\0') {\n            FUN_00108b3e();\n            FUN_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      FUN_00108863();\n      if ((longValue4 != 0) && (charValue = FUN_0010c892(), charValue == '\\0')) goto LAB_00105981;\n    }\n    if (param_9 == '\\0') {\n      if ((*(int *)(registerValue3[1] + 8) == 2) && (paramValue2 != 0)) {\n        paramValue9 = (long *)0x0;\n        paramValue6 = pointerValue7;\n        param_32 = 0;\n        param_31 = paramValue2;\n        in_stack_000000d8 = 0;\n        pointerValue4 = (undefined8 *)&stack0x00000148;\n        for (longValue4 = 0x22; longValue4 != 0; longValue4 = longValue4 + -1) {\n          *(undefined4 *)pointerValue4 = 0;\n          pointerValue4 = (undefined8 *)((long)pointerValue4 + (ulong)bVar39 * -8 + 4);\n        }\n        charValue = '\\0';\n        _param_15 = (int *)0x0;\n        uintValue = 0;\n        param_13 = (char *)0x0;\n        param_24 = (char *)0xffffffffffffffff;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)paramValue2 <= param_32) goto LAB_00105590;\n            longValue4 = pointerValue7[param_32];\n            charValue2 = bfd_coff_get_syment(registerValue3,longValue4,&stack0x000000e0);\n            longValue3 = in_stack_000000d8;\n            if (charValue2 == '\\0') {\n              returnValue = bfd_get_error();\n              bfd_errmsg(returnValue);\n              stringValue = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            stringValue = *(char **)(longValue4 + 8);\n            pointerValue4 = (undefined8 *)0x0;\n            param_32 = param_32 + 1;\n            in_stack_000000d8 = (ulong)paramValue8 + 1 + in_stack_000000d8;\n            if (paramValue8 != 0) {\n              pointerValue4 = &stack0x00000110;\n              charValue2 = bfd_coff_get_auxent(registerValue3,longValue4,0);\n              if (charValue2 == '\\0') {\n                returnValue = bfd_get_error();\n                bfd_errmsg(returnValue);\n                stringValue = \"bfd_coff_get_auxent failed: %s\";\n                goto LAB_00105968;\n              }\n            }\n            if (param_24 != (char *)longValue3) break;\n            if (paramValue7 != 0x67) {\n              charValue2 = FUN_0010bbd3(pointerValue6_02);\n              if (charValue2 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            param_24 = (char *)param_34;\n            charValue2 = FUN_0010bbd3(pointerValue6_02);\n            if (charValue2 == '\\0') goto LAB_00105981;\n          }\n          ushortValue = in_stack_000000f8._6_2_;\n          if ((char)paramValue7 < '\\0') {\n            if (paramValue7 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            longValue2 = FUN_0010dac0(registerValue3,&stack0x000000c0,&stack0x00000140);\n            if (longValue2 == 0) break;\n            charValue2 = FUN_00112a33(&stack0x00000140,longValue4,longValue3);\n          }\n          else {\n            if (paramValue7 < 100) {\n              switch(paramValue7) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(registerValue3[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(registerValue3[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _param_15 = (int *)(**(code **)(registerValue3[1] + 0x238))(registerValue3);\n                uintValue = (uint)ushortValue;\n                param_13 = stringValue;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(paramValue7) {\n            case 100:\n              intValue = strcmp(stringValue,\".bb\");\n              if (intValue == 0) {\n                charValue2 = FUN_0010be88(pointerValue6_02);\n              }\n              else {\n                intValue = strcmp(stringValue,\".eb\");\n                if (intValue != 0) goto switchD_00106e1a_caseD_68;\n                charValue2 = FUN_0010bf20(pointerValue6_02);\n              }\n              break;\n            case 0x65:\n              intValue = strcmp(stringValue,\".bf\");\n              if (intValue == 0) {\n                if (param_13 != (char *)0x0) {\n                  uintValue2 = (int)uintValue >> ((byte)*(undefined4 *)(registerValue3[0x22] + 0x44) & 0x1f);\n                  longValue3 = FUN_0010dac0(registerValue3,&stack0x000000c0,&stack0x00000140,longValue3,\n                                        uintValue2 ^ (uintValue ^ uintValue2) &\n                                                 *(uint *)(registerValue3[0x22] + 0x38),pointerValue4,0,\n                                        pointerValue6_02);\n                  if ((longValue3 == 0) || (charValue = FUN_0010bc80(pointerValue6_02), charValue == '\\0'))\n                  goto LAB_00105981;\n                  if (_param_15 != (int *)0x0) {\n                    intValue = 0;\n                    if (paramValue8 != 0) {\n                      intValue = param_39 - 1;\n                    }\n                    longValue4 = *(long *)(*(long *)(longValue4 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar27 = _param_15[4];\n                      if (iVar27 == 0) break;\n                      charValue2 = FUN_0010bf86(pointerValue6_02,intValue + iVar27,\n                                           *(long *)(_param_15 + 6) + longValue4);\n                      _param_15 = _param_15 + 4;\n                      if (charValue2 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  uintValue = 0;\n                  _param_15 = (int *)0x0;\n                  param_13 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                stringValue = \"%ld: .bf without preceding function\";\n              }\n              else {\n                intValue = strcmp(stringValue,\".ef\");\n                if (intValue != 0) goto switchD_00106e1a_caseD_68;\n                if (charValue != '\\0') {\n                  charValue = FUN_0010be1a(pointerValue6_02);\n                  if (charValue == '\\0') goto LAB_00105981;\n                  charValue = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                stringValue = \"%ld: unexpected .ef\\n\";\n              }\n              returnValue2 = dcgettext(0,stringValue,5);\n              FUN_00119ed0(returnValue2);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (charValue2 != '\\0');\n      }\n      else {\n        stringValue = \"%s: no recognized debugging information\";\nLAB_00105968:\n        returnValue2 = dcgettext(0,stringValue,5);\n        FUN_00119ed0(returnValue2);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(paramValue1 + 0x44) & 0x42) != 0) && ((*(uint *)(paramValue1 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(paramValue1 + 8) + 0x20) == '\\0') && (DAT_00127959 == '\\0')) {\n      if (paramValue2 != 0) {\n        pointerValue7 = DAT_001278d0 + paramValue2;\n        pointerValue = DAT_001278d0;\n        do {\n          uintValue = *(uint *)(*pointerValue + 0x18);\n          if ((uintValue & 0x1000000) != 0) {\n            *(uint *)(*pointerValue + 0x18) = uintValue & 0xfeffffff;\n          }\n          pointerValue = pointerValue + 1;\n        } while (pointerValue7 != pointerValue);\n      }\n    }\n    else {\n      for (longValue4 = *(long *)(paramValue1 + 0x90); longValue4 != 0; longValue4 = *(long *)(longValue4 + 8)) {\n        if (*(long *)(longValue4 + 0xe8) != 0) {\n          sectionPtr = (uint *)(*(long *)(longValue4 + 0xe8) + 0x18);\n          *sectionPtr = *sectionPtr | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a48 == 2) || (DAT_00127a48 == 7)) {\nLAB_001059fe:\n    if (DAT_00127a48 == 7) {\nLAB_00105a3b:\n      longValue4 = xmalloc();\n      pointerValue7 = DAT_001278d0;\n      param_15 = *(uint *)((long)registerValue3 + 0x44) & 0x42;\n      DAT_001278c8 = longValue4;\n      if (paramValue2 == 0) {\n        uintValue3 = 0;\n      }\n      else {\n        uintValue3 = 0;\n        _param_9 = 0;\n        do {\n          intValue = DAT_001279c0;\n          pointerValue = (long *)pointerValue7[_param_9];\n          codingFunction = (code *)pointerValue[4];\n          uintValue = *(uint *)(pointerValue + 3);\n          pointerValue2 = (long *)pointerValue[1];\n          pointerValue3 = pointerValue2;\n          if (DAT_001279c8 != (undefined8 *)0x0) {\n            iVar27 = 0;\n            pointerValue4 = DAT_001279c8;\n            while ((iVar27 < intValue && (stringValue = (char *)pointerValue4[5], stringValue != (char *)0x0))) {\n              if (stringValue != \"\") {\n                intValue2 = strcmp(stringValue,(char *)pointerValue2);\n                if (intValue2 == 0) {\n                  free(stringValue);\n                  uVar21 = uintValue3 + 1;\n                  pointerValue4[5] = \"\";\n                  uVar16 = FUN_0011a2e0(pointerValue4);\n                  returnValue2 = DAT_001278f0;\n                  *(undefined8 *)(longValue4 + uintValue3 * 8) = uVar16;\n                  longValue3 = htab_elements(returnValue2);\n                  if ((longValue3 != 0) || (DAT_001278f8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                pointerValue4 = (undefined8 *)*pointerValue4;\n              }\n              iVar27 = iVar27 + 1;\n            }\n          }\n          longValue3 = htab_elements(DAT_001278f0);\n          uVar21 = uintValue3;\n          if ((longValue3 != 0) || (DAT_001278f8 != (char **)0x0)) {\n            if (pointerValue2 != (long *)0x0) {\nLAB_001064eb:\n              if (((*(char *)pointerValue2 == '_') && (*(char *)((long)pointerValue2 + 1) == '_')) &&\n                 (intValue = strcmp((char *)((ulong)(*(char *)((long)pointerValue2 + 2) == '_') +\n                                          (long)pointerValue2),\"__gnu_lto_slim\"), intValue == 0)) {\n                returnValue2 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                FUN_00119dd0(returnValue2);\n              }\n            }\n            _paramValue10 = 0;\n            paramValue9 = pointerValue2;\n            longValue3 = htab_find(DAT_001278f0);\n            if (((longValue3 == 0) || (pointerValue3 = *(long **)(longValue3 + 8), pointerValue2 == pointerValue3)) &&\n               (pointerValue3 = pointerValue2, pcodingFunction4 = DAT_001278f8, (uintValue & 0x100) != 0)) {\n              for (; pcodingFunction4 != (char **)0x0; pcodingFunction4 = (char **)pcodingFunction4[3]) {\n                intValue = strcmp(*pcodingFunction4,(char *)pointerValue2);\n                if (intValue == 0) {\n                  pointerValue3 = (long *)pcodingFunction4[1];\n                  break;\n                }\n              }\n            }\n            pointerValue[1] = (long)pointerValue3;\n            charValue = *(char *)pointerValue3;\n            if (charValue != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            stringValue = DAT_00127928;\n            if ((DAT_001279a8 != '\\0') && (*(char *)(*(long *)(paramValue1 + 8) + 0x1c) != '\\0')) {\n              longValue3 = registerValue3[1];\n              charValue = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          charValue = *(char *)pointerValue2;\n          if (charValue == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          stringValue = DAT_00127928;\n          longValue3 = registerValue3[1];\n          if (*(char *)(longValue3 + 0x1c) == charValue) {\n            if (DAT_001279a8 == '\\0') {\n              if ((DAT_00127988 == '\\0') ||\n                 ((((uintValue & 0x82) == 0 && (codingFunction != bfd_map_over_sections)) &&\n                  ((*(byte *)(pointerValue[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pointerValue3 = (long *)((long)pointerValue3 + 1);\n              pointerValue[1] = (long)pointerValue3;\n              goto joined_r0x00106565;\n            }\n            charValue = *(char *)(*(long *)(paramValue1 + 8) + 0x1c);\n            if (charValue == '\\0') goto LAB_0010677d;\n            if (DAT_00127928 != (char *)0x0) {\n              pointerValue3 = (long *)((long)pointerValue3 + 1);\n              pointerValue[1] = (long)pointerValue3;\n              sizeValue = strlen((char *)pointerValue3);\n              longValue3 = sizeValue + 2;\nLAB_001066bc:\n              sizeValue = strlen(stringValue);\n              pointerValue2 = (long *)xmalloc(sizeValue + longValue3);\n              goto LAB_001066d0;\n            }\n            *(char *)pointerValue3 = charValue;\n            pointerValue[1] = (long)pointerValue3;\n            uintValue3 = uVar21;\n          }\n          else {\n            if ((DAT_001279a8 == '\\0') || (*(char *)(*(long *)(paramValue1 + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uintValue3 = uVar21;\n              if (stringValue == (char *)0x0) goto LAB_00105b32;\n              sizeValue = strlen((char *)pointerValue3);\n              sizeValue2 = strlen(stringValue);\n              __dest = (long *)xmalloc(sizeValue2 + sizeValue + 1);\n              pointerValue2 = __dest;\n            }\n            else {\nLAB_0010668d:\n              stringValue = DAT_00127928;\n              if ((*(char *)(longValue3 + 0x1c) != '\\0') && (charValue != *(char *)(longValue3 + 0x1c)))\n              goto joined_r0x00106565;\n              sizeValue = strlen((char *)pointerValue3);\n              longValue3 = sizeValue + 2;\n              if (stringValue != (char *)0x0) goto LAB_001066bc;\n              pointerValue2 = (long *)xmalloc(longValue3);\nLAB_001066d0:\n              __dest = (long *)((long)pointerValue2 + 1);\n              *(char *)pointerValue2 = *(char *)(*(long *)(paramValue1 + 8) + 0x1c);\n            }\n            stringValue = DAT_00127928;\n            if (DAT_00127928 != (char *)0x0) {\n              strcpy((char *)__dest,DAT_00127928);\n              sizeValue = strlen(stringValue);\n              __dest = (long *)((long)__dest + sizeValue);\n            }\n            strcpy((char *)__dest,(char *)pointerValue3);\n            pointerValue[1] = (long)pointerValue2;\n            pointerValue3 = pointerValue2;\n            uintValue3 = uVar21;\n          }\nLAB_00105b32:\n          if (DAT_00127a48 == 7) goto LAB_001067a8;\n          if (((uintValue & 0x20) == 0) &&\n             (((uintValue & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(pointerValue[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((param_15 == 0) &&\n                (((uintValue & 0x82) != 0 || ((*(byte *)(pointerValue[4] + 0x25) & 0x10) != 0)))) ||\n               (intValue = bfd_decode_symclass(pointerValue), intValue == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ea == '\\0') {\n                longValue3 = htab_find();\n                if (longValue3 == 0) goto LAB_00105c07;\n              }\n              else {\n                _paramValue10 = _paramValue10 & 0xffffffffffffff00;\n                paramValue9 = pointerValue3;\n                htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n                if (paramValue10 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uintValue & 0x82) == 0) && (codingFunction != bfd_map_over_sections)) &&\n                    ((*(byte *)(pointerValue[4] + 0x25) & 0x10) == 0)) {\n              if ((uintValue & 4) == 0) {\n                if (((*(int *)(registerValue3[1] + 8) != 2) ||\n                    (longValue3 = *(long *)(pointerValue[4] + 0xd0), longValue3 == 0)) ||\n                   (*(long *)(longValue3 + 0x40) == 0)) {\n                  if ((DAT_00127a48 == 3) || (DAT_00127a44 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a44 == 1) {\n                    charValue = bfd_is_local_label(registerValue3);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              charValue = DAT_001279a0;\n              if (1 < DAT_00127a48 - 2U) {\njoined_r0x00106a11:\n                if (charValue == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a48 != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ea == '\\0') {\n            longValue3 = htab_find();\n            if (longValue3 != 0) {\nLAB_0010687f:\n              returnValue2 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              FUN_00119ed0(returnValue2);\n              DAT_00127a40 = 1;\n            }\n          }\n          else {\n            _paramValue10 = _paramValue10 & 0xffffffffffffff00;\n            paramValue9 = pointerValue3;\n            htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n            if (paramValue10 != '\\0') goto LAB_0010687f;\n          }\n          if ((uintValue & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ea != '\\0') {\n              _paramValue10 = _paramValue10 & 0xffffffffffffff00;\n              paramValue9 = pointerValue3;\n              htab_traverse(DAT_00127a10,FUN_0011a170,&stack0x00000140);\n              if (paramValue10 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            longValue3 = htab_find();\n            if (longValue3 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a38 != '\\0') && ((uintValue & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ea == '\\0') {\n              longValue3 = htab_find();\n              if (longValue3 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _paramValue10 = _paramValue10 & 0xffffffffffffff00;\n              paramValue9 = pointerValue3;\n              htab_traverse(DAT_00127a28,FUN_0011a170,&stack0x00000140);\n              if (paramValue10 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            charValue = FUN_001159d0(pointerValue[4]);\n            if (charValue == '\\0') {\n              if (((uintValue & 0x800002) == 0) && (codingFunction != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uintValue & 0x82) != 0) {\n                  charValue = FUN_00115d70(pointerValue3);\n                  if ((charValue == '\\0') &&\n                     ((longValue3 = htab_elements(DAT_001279f8), longValue3 == 0 ||\n                      (charValue = FUN_00115d70(pointerValue3), charValue != '\\0')))) {\n                    if (((((DAT_00127958 == '\\0') ||\n                          (uintValue2 = *(uint *)(pointerValue + 3), (uintValue2 & 0x200000) != 0)) ||\n                         (longValue3 = *pointerValue, longValue3 == 0)) ||\n                        ((*(int *)(*(long *)(longValue3 + 8) + 8) != 5 ||\n                         (*(long *)(longValue3 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)pointerValue + 0x49) & 3) - 1)) goto joined_r0x00106920;\n                  }\n                  else {\n                    uintValue2 = *(uint *)(pointerValue + 3);\n                  }\n                  *(uint *)(pointerValue + 3) = uintValue2 & 0xffffff7d | 1;\n                }\njoined_r0x00106920:\n                if (((uintValue & 1) != 0) && (charValue = FUN_00115d70(pointerValue3), charValue != '\\0')) {\n                  *(uint *)(pointerValue + 3) = *(uint *)(pointerValue + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279e8 != '\\0') || (charValue = FUN_00115d70(pointerValue3), charValue != '\\0')) {\n                  *(uint *)(pointerValue + 3) = *(uint *)(pointerValue + 3) & 0xff7ffffd | 0x80;\n                }\n                if (codingFunction != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              *(long **)(longValue4 + uintValue3 * 8) = pointerValue;\n              uintValue3 = uintValue3 + 1;\n            }\n          }\n          _param_9 = _param_9 + 1;\n        } while (paramValue2 != _param_9);\n      }\n      if (DAT_001279c8 != (undefined8 *)0x0) {\n        pointerValue4 = DAT_001279c8;\n        intValue = DAT_001279c0;\n        for (longValue3 = 0; longValue3 < intValue; longValue3 = longValue3 + 1) {\n          stringValue = (char *)pointerValue4[5];\n          if (stringValue == (char *)0x0) {\n            longValue2 = uintValue3 * 8;\n            uintValue3 = uintValue3 + 1;\n            returnValue2 = FUN_0011a2e0(pointerValue4,paramValue1);\n            *(undefined8 *)(longValue4 + longValue2) = returnValue2;\n            intValue = DAT_001279c0;\n          }\n          else if (stringValue != \"\") {\n            returnValue2 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            FUN_00119dd0(returnValue2,stringValue);\n          }\n          pointerValue4 = (undefined8 *)*pointerValue4;\n        }\n      }\n      bVar38 = DAT_001279a0 == '\\0';\n      *(undefined8 *)(longValue4 + uintValue3 * 8) = 0;\n      if ((bVar38) || (pointerValue6_02 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        paramValue2 = uintValue3 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      intValue = *(int *)(*(undefined8 **)(paramValue1 + 8) + 1);\n      if ((intValue == 5) || (intValue == 2)) {\n        param_33 = (void *)0x0;\n        charValue = FUN_0011378f(paramValue1,pointerValue6_02,&stack0x000000c0,&stack0x00000110,&stack0x000000e0,\n                             &stack0x00000140);\n        if (charValue != '\\0') {\n          longValue4 = bfd_make_section_with_flags(paramValue1,\".stab\",0x2108);\n          longValue3 = bfd_make_section_with_flags(paramValue1,\".stabstr\",0x2108);\n          if ((((longValue4 == 0) || (longValue3 == 0)) ||\n              (charValue = bfd_set_section_size(longValue4,param_38), charValue == '\\0')) ||\n             (charValue = bfd_set_section_size(longValue3,paramValue9), charValue == '\\0')) {\n            stringValue = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(longValue4 + 0x7c) = 2;\n            *(undefined4 *)(longValue3 + 0x7c) = 0;\n            charValue = bfd_set_section_contents(paramValue1,longValue4,paramValue6,0,param_38);\n            if ((charValue != '\\0') &&\n               (charValue = bfd_set_section_contents(paramValue1,longValue3,param_33,0,paramValue9), charValue != '\\0')\n               ) {\n              free(pointerValue6_02);\n              goto LAB_00105cfa;\n            }\n            stringValue = \"can\\'t set debugging section contents\";\n          }\n          returnValue2 = dcgettext(0,stringValue,5);\n          FUN_001126c0(0,paramValue1,0,returnValue2);\n          free(param_33);\n          free(pointerValue6_02);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        returnValue2 = **(undefined8 **)(paramValue1 + 8);\n        uVar16 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        FUN_001126c0(0,paramValue1,0,uVar16,returnValue2);\n      }\n      free(pointerValue6_02);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections(registerValue3,FUN_00116030,DAT_001278d0);\n      intValue = bfd_get_error();\n      if (intValue == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a40 = 1;\n  }\n  else {\n    if ((DAT_00127a48 - 3U < 4) || ((DAT_00127a44 != 0 || (DAT_00127958 != '\\0'))))\n    goto LAB_00105a07;\n    longValue4 = htab_elements(DAT_00127a18);\n    if (((longValue4 != 0) ||\n        ((((longValue4 = htab_elements(DAT_00127a28), longValue4 != 0 ||\n           (longValue4 = htab_elements(DAT_00127a08), longValue4 != 0)) ||\n          (longValue4 = htab_elements(DAT_00127a00), longValue4 != 0)) ||\n         ((longValue4 = htab_elements(DAT_001279f8), longValue4 != 0 ||\n          (longValue4 = htab_elements(DAT_001279f0), longValue4 != 0)))))) ||\n       ((((longValue4 = htab_elements(DAT_001278f0), longValue4 != 0 ||\n          ((DAT_00127928 != (char *)0x0 || (DAT_001278d8 != '\\0')))) || (DAT_00127a39 != '\\0')) ||\n        ((((DAT_001279a0 != '\\0' || (DAT_001279a8 != '\\0')) || (DAT_00127988 != '\\0')) ||\n         (((DAT_001278f8 != (char **)0x0 || (DAT_001279e8 != '\\0')) || (DAT_001279c0 != 0))))))))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(paramValue1,DAT_001278c8,paramValue2 & 0xffffffff);\n    bfd_map_over_sections(registerValue3,FUN_00115dc0,paramValue1);\n    bfd_map_over_sections(registerValue3,FUN_00116110,paramValue1);\n    for (pointerValue4 = DAT_001279e0; ptrValue = DAT_001279d8, pointerValue4 != (undefined8 *)0x0;\n        pointerValue4 = (undefined8 *)*pointerValue4) {\n      charValue = bfd_set_section_contents(paramValue1,pointerValue4[5],pointerValue4[4],0,pointerValue4[3]);\n      if (charValue == '\\0') {\n        FUN_001126c0(0,paramValue1,pointerValue4[5],0);\n        return 0;\n      }\n    }\n    for (; ptrValue != (undefined8 *)0x0; ptrValue = (undefined8 *)*ptrValue) {\n      returnValue2 = *(undefined8 *)(ptrValue[5] + 0x60);\n      charValue = bfd_set_section_contents(paramValue1,returnValue2,ptrValue[4],0,ptrValue[3]);\n      if (charValue == '\\0') {\n        FUN_001126c0(0,paramValue1,returnValue2,0);\n        return 0;\n      }\n    }\n    if (in_R10 == (long *)0x0) {\n      if ((DAT_00127a20 != '\\0') && (_DAT_001264c0 == 0)) {\n        returnValue2 = *registerValue3;\n        uVar16 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        FUN_00119ed0(uVar16,returnValue2);\n      }\n    }\n    else {\n      pointerValue7 = (long *)0x0;\n      for (pointerValue4 = *(undefined8 **)(paramValue1 + 0x90); pointerValue4 != (undefined8 *)0x0;\n          pointerValue4 = (undefined8 *)pointerValue4[1]) {\n        if (((DAT_00127a20 != '\\0') && (*(int *)(*(long *)(paramValue1 + 8) + 8) == 5)) &&\n           ((*(int *)(pointerValue4[0x1a] + 4) == 7 &&\n            (charValue = FUN_00113fb0(*pointerValue4,\".gnu.build.attributes\"), charValue != '\\0')))) {\n          if (pointerValue7 == (long *)0x0) {\n            pointerValue7 = in_R10;\n          }\n          pointerValue = in_R10;\n          if (*(undefined8 **)(*pointerValue7 + 0x60) == pointerValue4) {\nLAB_0010625f:\n            stringValue = \"error: failed to merge notes\";\n            if (pointerValue7[1] != 0) {\n              charValue = bfd_set_section_contents(paramValue1,pointerValue4,pointerValue7[1],0,pointerValue7[2]);\n              if (charValue == '\\0') {\n                returnValue2 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                FUN_001126c0(0,paramValue1,pointerValue4,returnValue2);\n                return 0;\n              }\n              pointerValue7 = (long *)pointerValue7[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pointerValue7 = pointerValue;\n              if (*(undefined8 **)(*pointerValue + 0x60) == pointerValue4) goto LAB_0010625f;\n              pointerValue7 = (long *)pointerValue[3];\n              pointerValue = pointerValue7;\n            } while (pointerValue7 != (long *)0x0);\n            stringValue = \"error: failed to locate merged notes\";\n          }\n          returnValue2 = dcgettext(0,stringValue,5);\n          FUN_001126c0(0,paramValue1,pointerValue4,returnValue2);\n        }\nLAB_001061be:\n      }\n      do {\n        pointerValue7 = (long *)in_R10[3];\n        free((void *)in_R10[1]);\n        free(in_R10);\n        in_R10 = pointerValue7;\n      } while (pointerValue7 != (long *)0x0);\n    }\n    if ((DAT_00127a30 == 0) ||\n       (charValue = bfd_fill_in_gnu_debuglink_section(paramValue1,param_21), longValue4 = DAT_00127a30,\n       charValue != '\\0')) {\n      if (paramValue4 != (undefined *)0x0) {\n        if (0x2000 < paramValue3) {\n          paramValue3 = 0x2000;\n        }\n        longValue4 = 0;\n        pointerValue6 = (undefined *)xmalloc(paramValue3);\n        undefinedValue = DAT_00127999;\n        puVar33 = pointerValue6;\n        for (paramValue3 = paramValue3 & 0xffffffff; paramValue3 != 0; paramValue3 = paramValue3 - 1) {\n          *puVar33 = undefinedValue;\n          puVar33 = puVar33 + (ulong)bVar39 * -2 + 1;\n        }\n        for (; (uint)longValue4 < in_stack_00000068._4_4_; longValue4 = longValue4 + 1) {\n          uintValue3 = *(ulong *)(paramValue4 + longValue4 * 8);\n          if (uintValue3 != 0) {\n            longValue3 = *(long *)(*paramValue5 + 0x40) - uintValue3;\n            do {\n              uVar21 = 0x2000;\n              if (uintValue3 < 0x2001) {\n                uVar21 = uintValue3;\n              }\n              charValue = bfd_set_section_contents(paramValue1,*paramValue5,pointerValue6,longValue3,uVar21);\n              if (charValue == '\\0') {\n                FUN_001126c0(0,paramValue1,*paramValue5,0);\n                free(pointerValue6);\n                return 0;\n              }\n              longValue3 = longValue3 + uVar21;\n              uintValue3 = uintValue3 - uVar21;\n            } while (uintValue3 != 0);\n          }\n          paramValue5 = paramValue5 + 1;\n        }\n        free(pointerValue6);\n        free(paramValue4);\n      }\n      returnValue = (**(code **)(*(long *)(paramValue1 + 8) + 0x140))(registerValue3);\n      if ((char)returnValue != '\\0') {\n        if (DAT_00127930 == 0) {\n          return returnValue;\n        }\n        charValue = bfd_alt_mach_code(paramValue1,DAT_00127930 & 0xffffffff);\n        uintValue3 = DAT_00127930;\n        if (charValue == '\\0') {\n          returnValue2 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          FUN_00119ed0(returnValue2,uintValue3);\n          if (*(int *)(*(long *)(paramValue1 + 8) + 8) == 5) {\n            returnValue2 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            FUN_00119ed0(returnValue2);\n            *(short *)(*(long *)(paramValue1 + 0x110) + 0x3a) = (short)DAT_00127930;\n            return returnValue;\n          }\n          returnValue2 = dcgettext(0,\"ignoring the alternative value\",5);\n          FUN_00119ed0(returnValue2);\n          return returnValue;\n        }\n        return returnValue;\n      }\n      returnValue2 = dcgettext(0,\"error copying private BFD data\",5);\n      FUN_001126c0(0,paramValue1,0,returnValue2);\n    }\n    else {\n      returnValue2 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      FUN_001126c0(0,paramValue1,0,returnValue2,longValue4);\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "bfd_alt_mach_code",
                "bfd_set_section_size",
                "FUN_0010870e",
                "FUN_0010bf20",
                "FUN_00108863",
                "bfd_set_section_contents",
                "bfd_map_over_sections",
                "strcmp",
                "FUN_00119dd0",
                "FUN_0010dac0",
                "FUN_001088ae",
                "bfd_coff_get_syment",
                "bfd_coff_get_auxent",
                "xmalloc",
                "htab_traverse",
                "bfd_set_error",
                "FUN_00116110",
                "FUN_0010bbd3",
                "bfd_decode_symclass",
                "bfd_get_section_by_name",
                "bfd_errmsg",
                "bfd_make_section_with_flags",
                "strlen",
                "FUN_0010c892",
                "strcpy",
                "bfd_is_local_label",
                "bfd_get_section_contents",
                "FUN_00115dc0",
                "FUN_0010be1a",
                "htab_find",
                "FUN_001159d0",
                "concat",
                "dcgettext",
                "FUN_00113fb0",
                "xstrdup",
                "qsort",
                "FUN_001126c0",
                "FUN_0011173a",
                "FUN_00112894",
                "FUN_00112a33",
                "FUN_0011a170",
                "fprintf",
                "bfd_get_error",
                "htab_elements",
                "FUN_0010875d",
                "FUN_0011378f",
                "bfd_octets_per_byte",
                "bfd_set_symtab",
                "FUN_00116030",
                "FUN_00119ed0",
                "FUN_00115d70",
                "bfd_map_over_sections",
                "bfd_fill_in_gnu_debuglink_section",
                "FUN_0010bf86",
                "FUN_00108b3e",
                "free",
                "FUN_0010bc80",
                "FUN_0011a2e0",
                "FUN_0010be88"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010554f",
            "calling": [
                "FUN_00107880"
            ],
            "imported": false,
            "current_name": "improved_binary_section_processing_0010554f"
        },
        "FUN_00109cf4": {
            "renaming": {
                "FUN_00109cf4": "convert_and_process_data_00109cf4",
                "param_1": "data",
                "param_2": "value",
                "param_3": "flag",
                "local_3c": "stringValue"
            },
            "code": "\nvoid convertAndProcessData_00109cf4(undefined8 data,undefined8 value,undefined4 flag)\n\n{\n  char stringValue [28];\n  \n  sprintf(stringValue,\"%ld\",value);\n  FUN_00109b52(data,stringValue,value,0,flag);\n  return;\n}\n\n",
            "called": [
                "FUN_00109b52",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109cf4",
            "calling": [
                "FUN_0010e453",
                "FUN_00109d97",
                "FUN_0010b800",
                "FUN_00109ed3",
                "FUN_00109d3e",
                "FUN_00109d5c",
                "FUN_0010bba1",
                "FUN_0010b948",
                "FUN_00109dfe"
            ],
            "imported": false,
            "current_name": "convert_and_process_data_00109cf4"
        },
        "FUN_00109ab1": {
            "renaming": {
                "FUN_00109ab1": "extract_params_00109ab1",
                "param_1": "input_str",
                "param_2": "output",
                "param_3": "arg1",
                "param_4": "arg2",
                "param_5": "arg3",
                "uVar1": "result1",
                "pcVar2": "current_char",
                "uVar3": "result2",
                "auVar4": "output_var"
            },
            "code": "\nundefined  [16]\nextract_params_00109ab1(char **input_str,undefined4 *output,undefined8 arg1,undefined8 arg2,\n            undefined8 arg3)\n\n{\n  undefined4 result1;\n  char *current_char;\n  undefined8 result2;\n  undefined output_var [16];\n  \n  current_char = *input_str;\n  if (*current_char == '(') {\n    *input_str = current_char + 1;\n    result1 = FUN_00109a32(input_str,0);\n    *output = result1;\n    if (**input_str == ',') {\n      *input_str = *input_str + 1;\n      result1 = FUN_00109a32(input_str,0,arg1);\n      output[1] = result1;\n      if (**input_str == ')') {\n        current_char = *input_str + 1;\n        *input_str = current_char;\n        goto LAB_00109b25;\n      }\n    }\n    FUN_00108fb9(current_char);\n    result2 = 0;\n  }\n  else {\n    *output = 0;\n    current_char = (char *)FUN_00109a32(input_str,0);\n    output[1] = (int)current_char;\nLAB_00109b25:\n    result2 = CONCAT71((int7)((ulong)current_char >> 8),1);\n  }\n  output_var._8_8_ = arg3;\n  output_var._0_8_ = result2;\n  return output_var;\n}\n\n",
            "called": [
                "FUN_00108fb9",
                "FUN_00109a32"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109ab1",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "extract_params_00109ab1"
        },
        "FUN_001159d0": {
            "renaming": {
                "FUN_001159d0": "check_data_validity_001159d0",
                "param_1": "data",
                "uVar1": "result",
                "cVar2": "isValid",
                "uVar3": "status",
                "lVar4": "ptr1",
                "lVar5": "ptr2"
            },
            "code": "\nundefined4 checkDataValidity_001159d0(long data)\n\n{\n  undefined8 result;\n  char isValid;\n  undefined4 status;\n  long ptr1;\n  long ptr2;\n  \n  status = FUN_00115b70();\n  if ((char)status == '\\0') {\n    if ((*(byte *)(data + 0x27) & 2) == 0) {\n      return status;\n    }\n    ptr1 = FUN_00115d00(*(undefined8 *)(data + 0xd0),*(undefined8 *)(data + 0xe0));\n    if ((ptr1 != 0) &&\n       (((result = *(undefined8 *)(ptr1 + 8), DAT_00127a48 != 7 ||\n         (isValid = FUN_00115d70(result,DAT_00127a28), isValid != '\\0')) &&\n        (isValid = FUN_00115d70(result,DAT_00127a18), isValid == '\\0')))) {\n      ptr1 = *(long *)(*(long *)(data + 0xd0) + 0xc0);\n      ptr2 = ptr1;\n      do {\n        if (ptr2 == 0) {\n          return 1;\n        }\n        isValid = FUN_00115b70(ptr2);\n        if (isValid == '\\0') {\n          return status;\n        }\n        ptr2 = *(long *)(*(long *)(ptr2 + 0xd0) + 0xc0);\n      } while (ptr1 != ptr2);\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "FUN_00115b70",
                "FUN_00115d00",
                "FUN_00115d70"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001159d0",
            "calling": [
                "FUN_00115f50",
                "FUN_00115530",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "check_data_validity_001159d0"
        },
        "FUN_0010a77a": {
            "renaming": {
                "FUN_0010a77a": "process_data_0010a77a",
                "param_1": "input",
                "uVar1": "flag",
                "lVar2": "structPtr",
                "__s": "string1",
                "uVar3": "value1",
                "uVar4": "result",
                "__s_00": "string2",
                "sVar5": "length1",
                "sVar6": "length2",
                "__s_01": "resultString"
            },
            "code": "\nundefined4 processData_0010a77a(long input)\n\n{\n  undefined flag;\n  long structPtr;\n  char *string1;\n  undefined8 value1;\n  undefined4 result;\n  char *string2;\n  size_t length1;\n  size_t length2;\n  char *resultString;\n  \n  structPtr = *(long *)(input + 0x60);\n  if ((structPtr != 0) && (string1 = *(char **)(structPtr + 0x20), string1 != (char *)0x0)) {\n    result = *(undefined4 *)(structPtr + 0x18);\n    flag = *(undefined *)(structPtr + 0x1c);\n    value1 = *(undefined8 *)(structPtr + 0x10);\n    string2 = (char *)FUN_00109b2f();\n    length1 = strlen(string2);\n    length2 = strlen(string1);\n    resultString = (char *)xmalloc(length1 + 2 + length2);\n    sprintf(resultString,\"%s%s;\",string2,string1);\n    free(string2);\n    free(string1);\n    result = FUN_00109b52(input,resultString,value1,flag,result);\n    if ((char)result != '\\0') {\n      free(resultString);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00109b52",
                "free",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a77a",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "process_data_0010a77a"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104210",
            "calling": [
                "FUN_00116b90",
                "FUN_00107880",
                "FUN_00114460",
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "FUN_0010543c": {
            "renaming": {
                "FUN_0010543c": "print_error_message_0010543c",
                "piVar2": "errorNumberPtr",
                "pcVar3": "errorMessagePtr",
                "uVar1": "fileDescriptor",
                "uVar4": "errorString",
                "unaff_RBP": "stackPointer"
            },
            "code": "\nvoid printErrorMessage_0010543c(void)\n\n{\n  undefined8 fileDescriptor;\n  int *errorNumberPtr;\n  char *errorMessagePtr;\n  undefined8 errorString;\n  long stackPointer;\n  \n  errorNumberPtr = __errno_location();\n  errorMessagePtr = strerror(*errorNumberPtr);\n  fileDescriptor = *(undefined8 *)(stackPointer + 0x10);\n  errorString = dcgettext(0,\"cannot open: %s: %s\",5);\n                    \n  FUN_00119dd0(errorString,fileDescriptor,errorMessagePtr);\n}\n\n",
            "called": [
                "dcgettext",
                "__errno_location",
                "FUN_00119dd0",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010543c",
            "calling": [
                "FUN_00114d60"
            ],
            "imported": false,
            "current_name": "print_error_message_0010543c"
        },
        "bfd_coff_get_auxent": {
            "renaming": {},
            "code": "\nvoid bfd_coff_get_auxent(void)\n\n{\n  bfd_coff_get_auxent();\n  return;\n}\n\n",
            "called": [
                "bfd_coff_get_auxent"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045b0",
            "calling": [
                "FUN_0010e07c",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_coff_get_auxent"
        },
        "FUN_0010a424": {
            "renaming": {
                "FUN_0010a424": "create_improved_code_0010a424",
                "param_1": "input1",
                "param_2": "flag1",
                "param_3": "count",
                "param_4": "flag2",
                "cVar1": "result1",
                "bVar2": "byteVar",
                "iVar3": "tempVar",
                "uVar4": "returnValue",
                "pcVar5": "stringVar1",
                "__ptr": "dynamicArray",
                "uVar6": "result2",
                "__s": "stringVar2",
                "sVar7": "length1",
                "sVar8": "length2",
                "__s_00": "finalString",
                "lVar9": "index",
                "bVar10": "byteVar2",
                "lVar11": "index2",
                "uVar12": "result3"
            },
            "code": "\nundefined4 createImprovedCode_0010a424(long input1,char flag1,int count,char flag2)\n\n{\n  char result1;\n  byte byteVar;\n  int tempVar;\n  undefined4 returnValue;\n  char *stringVar1;\n  undefined8 *dynamicArray;\n  undefined8 result2;\n  char *stringVar2;\n  size_t length1;\n  size_t length2;\n  char *finalString;\n  long index;\n  byte byteVar2;\n  long index2;\n  undefined result3;\n  \n  if ((flag1 == '\\0') && (result1 = FUN_00109d97(), result1 == '\\0')) {\n    return 0;\n  }\n  byteVar2 = *(byte *)(*(long *)(input1 + 0x60) + 0x1c);\n  stringVar1 = (char *)FUN_00109b2f(input1);\n  if (count < 0) {\n    dynamicArray = (undefined8 *)0x0;\n    count = 0;\nLAB_0010a582:\n    result3 = 1;\n    if (byteVar2 != 0) goto LAB_0010a596;\n  }\n  else {\n    if (count != 0) {\n      tempVar = count + 1;\n      dynamicArray = (undefined8 *)xmalloc((long)tempVar * 8);\n      index = (long)(count + -1);\n      do {\n        byteVar = 1;\n        if (byteVar2 == 0) {\n          byteVar = *(byte *)(*(long *)(input1 + 0x60) + 0x1c);\n        }\n        result2 = FUN_00109b2f(input1);\n        byteVar2 = byteVar & 1;\n        dynamicArray[index] = result2;\n        index = index + -1;\n      } while ((int)index != -1);\n      if (flag2 == '\\0') {\n        result1 = FUN_00109d97(input1);\n        if (result1 == '\\0') {\n          return 0;\n        }\n        byteVar = 1;\n        if (byteVar2 == 0) {\n          byteVar = *(byte *)(*(long *)(input1 + 0x60) + 0x1c);\n        }\n        byteVar2 = byteVar & 1;\n        result2 = FUN_00109b2f(input1);\n        dynamicArray[(long)tempVar + -1] = result2;\n        count = tempVar;\n      }\n      goto LAB_0010a582;\n    }\n    dynamicArray = (undefined8 *)0x0;\n    if (flag2 != '\\0') goto LAB_0010a582;\n    dynamicArray = (undefined8 *)xmalloc(8);\n    result1 = FUN_00109d97(input1);\n    if (result1 == '\\0') {\n      return 0;\n    }\n    if ((byteVar2 != 0) || (*(char *)(*(long *)(input1 + 0x60) + 0x1c) != '\\0')) {\n      result2 = FUN_00109b2f(input1);\n      count = 1;\n      result3 = 1;\n      *dynamicArray = result2;\n      goto LAB_0010a596;\n    }\n    result2 = FUN_00109b2f(input1);\n    count = 1;\n    *dynamicArray = result2;\n  }\n  result3 = *(undefined *)(*(long *)(input1 + 0x60) + 0x1c);\nLAB_0010a596:\n  stringVar2 = (char *)FUN_00109b2f(input1);\n  length1 = strlen(stringVar1);\n  length2 = strlen(stringVar2);\n  index = length1 + 10 + length2;\n  for (index2 = 0; (int)index2 < count; index2 = index2 + 1) {\n    length1 = strlen((char *)dynamicArray[index2]);\n    index = index + length1;\n  }\n  finalString = (char *)xmalloc(index);\n  sprintf(finalString,\"#%s,%s\",stringVar1,stringVar2);\n  index = 0;\n  free(stringVar1);\n  free(stringVar2);\n  while( true ) {\n    length1 = strlen(finalString);\n    if (count <= (int)index) break;\n    *(undefined2 *)(finalString + length1) = 0x2c;\n    stringVar1 = (char *)dynamicArray[index];\n    index = index + 1;\n    strcpy(finalString + length1 + 1,stringVar1);\n    free(stringVar1);\n  }\n  *(undefined2 *)(finalString + length1) = 0x3b;\n  free(dynamicArray);\n  returnValue = FUN_00109b52(input1,finalString,0,result3,0);\n  if ((char)returnValue == '\\0') {\n    return 0;\n  }\n  free(finalString);\n  return returnValue;\n}\n\n",
            "called": [
                "strcpy",
                "FUN_00109d97",
                "xmalloc",
                "FUN_00109b52",
                "free",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a424",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "create_improved_code_0010a424"
        },
        "FUN_00119970": {
            "renaming": {
                "FUN_00119970": "print_gnu_version_and_exit_00119970",
                "param_1": "version",
                "pcVar1": "copyrightMessage"
            },
            "code": "\nvoid printGnuVersionAndExit_00119970(undefined8 version)\n\n{\n  char *copyrightMessage;\n  \n  printf(\"GNU %s %s\\n\",version,\"(GNU Binutils for Debian) 2.40\");\n  copyrightMessage = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(copyrightMessage);\n  copyrightMessage = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(copyrightMessage);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "dcgettext",
                "printf",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119970",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "print_gnu_version_and_exit_00119970"
        },
        "FUN_00114c80": {
            "renaming": {
                "FUN_00114c80": "parse_param_00114c80",
                "param_1": "input_string",
                "param_2": "default_value",
                "param_3": "error_message",
                "param_4": "extra_data",
                "pcVar1": "equal_sign",
                "uVar2": "parsed_value",
                "auVar3": "result"
            },
            "code": "\nundefined  [16] parse_param_00114c80(char *input_string,undefined8 default_value,undefined8 error_message,undefined8 extra_data)\n\n{\n  char *equal_sign;\n  undefined8 parsed_value;\n  undefined result [16];\n  \n  equal_sign = strchr(input_string,0x3d);\n  if (equal_sign != (char *)0x0) {\n    result._0_8_ = (undefined8 *)xmalloc(0x30);\n    parsed_value = FUN_0011a480(input_string,(long)equal_sign - (long)input_string);\n    result._0_8_[2] = equal_sign + 1;\n    result._0_8_[1] = parsed_value;\n    result._0_8_[4] = 0;\n    result._0_8_[3] = 0;\n    *result._0_8_ = default_value;\n    result._8_8_ = extra_data;\n    return result;\n  }\n  parsed_value = dcgettext(0,\"bad format for %s\",5);\n                    \n  FUN_00119dd0(parsed_value,error_message);\n}\n\n",
            "called": [
                "FUN_001053b5",
                "xmalloc",
                "strchr",
                "FUN_0011a480"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114c80",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "parse_param_00114c80"
        },
        "FUN_0010870e": {
            "renaming": {
                "FUN_0010870e": "update_pointer_0010870e",
                "param_1": "dataPointer",
                "param_2": "newValue",
                "param_3": "pointerToPointer",
                "puVar1": "ptrToValue"
            },
            "code": "\nvoid updatePointer_0010870e(undefined8 dataPointer,undefined8 newValue,long *pointerToPointer)\n\n{\n  undefined8 *ptrToValue;\n  \n  ptrToValue = (undefined8 *)*pointerToPointer;\n  *ptrToValue = newValue;\n  *pointerToPointer = (long)(ptrToValue + 1);\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010870e",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "update_pointer_0010870e"
        },
        "unlink_if_ordinary": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104610",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "unlink_if_ordinary"
        },
        "FUN_0010dac0": {
            "renaming": {
                "FUN_0010dac0": "parse_coff_type_0010dac0",
                "param_1": "data",
                "param_2": "coff_symbols",
                "param_3": "coff_sections",
                "param_5": "type_code",
                "param_6": "types",
                "param_7": "flag",
                "param_8": "errmsg",
                "lVar1": "temp1",
                "cVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "lVar5": "result",
                "uVar6": "temp5",
                "plVar7": "ptr1",
                "__ptr": "ptr2",
                "__ptr_00": "ptr3",
                "bVar8": "byteVar",
                "iVar9": "intVar",
                "pcVar10": "stringVar",
                "uVar11": "ulongVar",
                "lVar12": "temp6",
                "uVar13": "temp7",
                "uVar14": "temp8",
                "uVar15": "temp9",
                "local_68": "buffer",
                "local_48": "charVar",
                "local_47": "byteVar2"
            },
            "code": "\nlong parse_coff_type_0010dac0(long data,long *coff_symbols,long coff_sections,undefined8 param_4,uint type_code,\n                 long *types,char flag,undefined8 errmsg)\n\n{\n  long temp1;\n  char temp2;\n  undefined4 temp3;\n  undefined8 temp4;\n  long result;\n  undefined8 temp5;\n  long *ptr1;\n  void *ptr2;\n  void *ptr3;\n  byte byteVar;\n  int intVar;\n  char *stringVar;\n  ulong ulongVar;\n  long temp6;\n  uint temp7;\n  uint temp8;\n  undefined8 temp9;\n  undefined buffer [32];\n  char charVar;\n  byte byteVar2;\n  \n  result = *(long *)(data + 0x110);\n  if ((~*(uint *)(result + 0x38) & type_code) != 0) {\n    temp7 = (int)type_code >> ((byte)*(undefined4 *)(result + 0x44) & 0x1f);\n    ulongVar = (ulong)(type_code & *(uint *)(result + 0x40));\n    byteVar = (byte)*(undefined4 *)(result + 0x3c);\n    temp7 = (temp7 ^ type_code) & *(uint *)(result + 0x38) ^ temp7;\n    if (ulongVar == 1L << (byteVar & 0x3f)) {\n      temp4 = parse_coff_type_0010dac0(data,coff_symbols,coff_sections,param_4,temp7,types,flag,errmsg);\n      result = FUN_00113d3a(temp4);\n      return result;\n    }\n    if (ulongVar != 2L << (byteVar & 0x3f)) {\n      if (ulongVar != 3L << (byteVar & 0x3f)) {\n        temp4 = dcgettext(0,\"parse_coff_type_0010dac0: Bad type code 0x%x\",5,*(undefined4 *)(result + 0x3c),\n                          temp7);\n        FUN_00119ed0(temp4,type_code);\n        return 0;\n      }\n      temp8 = 0;\n      if (types != (long *)0x0) {\n        temp8 = (uint)*(ushort *)(types + 2);\n        ptr1 = types + 2;\n        for (intVar = 0; (*(short *)ptr1 != 0 && (intVar != 3)); intVar = intVar + 1) {\n          *(short *)ptr1 = *(short *)((long)ptr1 + 2);\n          ptr1 = (long *)((long)ptr1 + 2);\n        }\n        *(short *)ptr1 = 0;\n      }\n      temp9 = 0;\n      temp4 = errmsg;\n      temp5 = parse_coff_type_0010dac0(data,coff_symbols,coff_sections,param_4,temp7,types,0);\n      result = *(long *)(coff_sections + 0x28);\n      if (result == 0) {\n        temp4 = FUN_00113dfe(4,0,temp9,temp4);\n        result = FUN_0010c218(errmsg,\"int\",temp4);\n        *(long *)(coff_sections + 0x28) = result;\n      }\n      result = FUN_00113c43(temp5,result,0,(long)(int)(temp8 - 1),0);\n      return result;\n    }\n    temp4 = parse_coff_type_0010dac0(data,coff_symbols,coff_sections,param_4,temp7,types,flag,errmsg);\n    result = FUN_00113ce0(temp4,0,0);\n    return result;\n  }\n  if ((types != (long *)0x0) && (0 < *types)) {\n    ptr1 = (long *)FUN_0010da0b(coff_sections);\n    if (*ptr1 != 0) {\n      return *ptr1;\n    }\n    result = FUN_00113e23(ptr1,0);\n    return result;\n  }\n  if (flag == '\\0') {\n    types = (long *)0x0;\n  }\n  if (0x10 < type_code) {\n    result = FUN_00113e17();\n    return result;\n  }\n  result = *(long *)(coff_sections + 8 + (long)(int)type_code * 8);\n  if (result != 0) {\n    return result;\n  }\n  switch(type_code) {\n  default:\n    temp4 = FUN_00113e17();\n    stringVar = \"void\";\n    break;\n  case 2:\n    temp4 = FUN_00113dfe(1,0);\n    stringVar = \"char\";\n    break;\n  case 3:\n    temp4 = FUN_00113dfe(2,0);\n    stringVar = \"short\";\n    break;\n  case 4:\n    temp4 = FUN_00113dfe(4,0);\n    stringVar = \"int\";\n    break;\n  case 5:\n    temp4 = FUN_00113dfe(4,0);\n    stringVar = \"long\";\n    break;\n  case 6:\n    temp4 = FUN_00113df2(4);\n    stringVar = \"float\";\n    break;\n  case 7:\n    temp4 = FUN_00113df2(8);\n    stringVar = \"double\";\n    break;\n  case 8:\n    if (types == (long *)0x0) {\n      result = FUN_00113da9(1,0,0);\n      goto LAB_0010e046;\n    }\n    temp4 = 8;\n    goto LAB_0010de7a;\n  case 9:\n    if (types == (long *)0x0) {\n      result = FUN_00113da9(0,0,0);\n      goto LAB_0010e046;\n    }\n    temp4 = 9;\nLAB_0010de7a:\n    result = FUN_0010e07c(data,coff_symbols,coff_sections,temp4,types,errmsg);\nLAB_0010e046:\n    ptr1 = (long *)FUN_0010da0b(coff_sections,param_4);\n    *ptr1 = result;\n    return result;\n  case 10:\n    if (types == (long *)0x0) {\n      result = FUN_00113d6e(0,0);\n    }\n    else {\n      result = types[3];\n      ptr2 = (void *)xmalloc(0x50);\n      ptr3 = (void *)xmalloc(0x50);\n      temp6 = 0;\n      do {\n        while( true ) {\n          if ((result <= coff_symbols[3]) || (coff_symbols[1] <= coff_symbols[2])) goto LAB_0010e032;\n          intVar = (int)temp6;\n          temp1 = *(long *)(*coff_symbols + coff_symbols[2] * 8);\n          temp2 = bfd_coff_get_syment(data,temp1,buffer);\n          temp6 = (long)intVar;\n          if (temp2 == '\\0') {\n            temp3 = bfd_get_error();\n            temp4 = bfd_errmsg(temp3);\n            temp5 = dcgettext(0,\"bfd_coff_get_syment failed: %s\",5);\n            FUN_00119ed0(temp5,temp4);\n            free(ptr2);\n            free(ptr3);\n            result = 0;\n            goto LAB_0010e046;\n          }\n          coff_symbols[2] = coff_symbols[2] + 1;\n          coff_symbols[3] = (ulong)byteVar2 + 1 + coff_symbols[3];\n          if (charVar != '\\x10') break;\n          if ((int)type_code <= intVar + 1) {\n            type_code = type_code + 10;\n            ptr2 = (void *)xrealloc(ptr2);\n            ptr3 = (void *)xrealloc(ptr3,(long)(int)type_code << 3);\n          }\n          temp6 = *(long *)(temp1 + 0x20);\n          *(undefined8 *)((long)ptr2 + (long)intVar * 8) = *(undefined8 *)(temp1 + 8);\n          *(long *)((long)ptr3 + (long)intVar * 8) =\n               *(long *)(temp1 + 0x10) + *(long *)(temp6 + 0x30);\n          temp6 = (long)(intVar + 1);\n        }\n      } while (charVar != 'f');\nLAB_0010e032:\n      *(undefined8 *)((long)ptr2 + temp6 * 8) = 0;\n      result = FUN_00113d6e(ptr2,ptr3);\n    }\n    goto LAB_0010e046;\n  case 0xb:\n    result = FUN_00113e17();\n    goto LAB_0010e065;\n  case 0xc:\n    temp4 = FUN_00113dfe(1,1);\n    stringVar = \"unsigned char\";\n    break;\n  case 0xd:\n    temp4 = FUN_00113dfe(2,1);\n    stringVar = \"unsigned short\";\n    break;\n  case 0xe:\n    temp4 = FUN_00113dfe(4,1);\n    stringVar = \"unsigned int\";\n    break;\n  case 0xf:\n    temp4 = FUN_00113dfe(4,1);\n    stringVar = \"unsigned long\";\n    break;\n  case 0x10:\n    temp4 = FUN_00113df2(0xc);\n    stringVar = \"long double\";\n  }\n  result = FUN_0010c218(errmsg,stringVar,temp4);\nLAB_0010e065:\n  *(long *)(coff_sections + 8 + (long)(int)type_code * 8) = result;\n  return result;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_0010c218",
                "xmalloc",
                "FUN_00119ed0",
                "xrealloc",
                "FUN_00113dfe",
                "FUN_00113e17",
                "bfd_errmsg",
                "FUN_00113c43",
                "FUN_00113e23",
                "FUN_00113df2",
                "FUN_00113d6e",
                "FUN_00113da9",
                "bfd_get_error",
                "free",
                "FUN_00113ce0",
                "FUN_0010da0b",
                "FUN_0010e07c",
                "FUN_0010dac0",
                "bfd_coff_get_syment",
                "FUN_00113d3a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010dac0",
            "calling": [
                "FUN_0010e07c",
                "FUN_0010554f",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "parse_coff_type_0010dac0"
        },
        "FUN_00113fb0": {
            "renaming": {
                "FUN_00113fb0": "compare_strings_00113fb0",
                "param_1": "string1",
                "param_2": "string2",
                "iVar1": "comparison_result",
                "in_RAX": "return_value",
                "__n": "string2_length",
                "extraout_var": "extra_out_variable",
                "auVar2": "result"
            },
            "code": "\nundefined  [16] compare_strings_00113fb0(char *string1,char *string2)\n\n{\n  int comparison_result;\n  undefined8 return_value;\n  size_t string2_length;\n  undefined4 extra_out_variable;\n  undefined result [16];\n  \n  string2_length = strlen(string2);\n  comparison_result = strncmp(string1,string2,string2_length);\n  result._1_7_ = (undefined7)(CONCAT44(extra_out_variable,comparison_result) >> 8);\n  result[0] = comparison_result == 0;\n  result._8_8_ = return_value;\n  return result;\n}\n\n",
            "called": [
                "strncmp",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113fb0",
            "calling": [
                "FUN_00115f50",
                "FUN_00116b90",
                "FUN_0010ee3f",
                "FUN_00107880",
                "FUN_00113ede",
                "FUN_0010554f",
                "FUN_00113e5e",
                "FUN_00114c20",
                "FUN_00108c86"
            ],
            "imported": false,
            "current_name": "compare_strings_00113fb0"
        },
        "FUN_0010882c": {
            "renaming": {
                "FUN_0010882c": "display_time_error_0010882c",
                "piVar1": "errorCode",
                "uVar2": "errorString"
            },
            "code": "\nvoid displayTimeError_0010882c(void)\n\n{\n  int *errorCode;\n  undefined8 errorString;\n  \n  errorCode = __errno_location();\n  strerror(*errorCode);\n  errorString = dcgettext(0,\"%s: cannot set time: %s\",5);\n  FUN_00119ed0(errorString);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "__errno_location",
                "FUN_00119ed0",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010882c",
            "calling": [
                "FUN_0011a350"
            ],
            "imported": false,
            "current_name": "display_time_error_0010882c"
        },
        "FUN_0010ebb0": {
            "renaming": {
                "FUN_0010ebb0": "process_message_0010ebb0",
                "param_1": "input_data",
                "param_2": "string_param",
                "param_3": "string_length",
                "param_4": "additional_data",
                "__s": "dynamic_string_1",
                "uVar2": "remaining_length",
                "uVar3": "result",
                "__s_00": "dynamic_string_2",
                "cVar1": "character",
                "sVar4": "string_param_length",
                "sVar5": "dynamic_string_1_length"
            },
            "code": "\nundefined4 processMessage_0010ebb0(undefined8 input_data,char *string_param,int string_length,undefined8 additional_data)\n\n{\n  char character;\n  uint remaining_length;\n  undefined4 result;\n  char *dynamic_string_1;\n  size_t string_param_length;\n  size_t dynamic_string_1_length;\n  char *dynamic_string_2;\n  \n  dynamic_string_1 = (char *)FUN_00109b2f();\n  remaining_length = string_length - 1;\n  if (remaining_length < 4) {\n    result = *(undefined4 *)(&DAT_00121340 + (ulong)remaining_length * 4);\n    character = (&DAT_00121334)[remaining_length];\n    string_param_length = strlen(string_param);\n    dynamic_string_1_length = strlen(dynamic_string_1);\n    dynamic_string_2 = (char *)xmalloc(string_param_length + 3 + dynamic_string_1_length);\n    sprintf(dynamic_string_2,\"%s:%c%s\",string_param,(ulong)(uint)(int)character,dynamic_string_1);\n    free(dynamic_string_1);\n    result = FUN_0010e2f0(input_data,result,0,additional_data,dynamic_string_2);\n    if ((char)result != '\\0') {\n      free(dynamic_string_2);\n    }\n    return result;\n  }\n                    \n  abort();\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_0010e2f0",
                "abort",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010ebb0",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_message_0010ebb0"
        },
        "feof": {
            "renaming": {},
            "code": "\n\n\nint feof(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = feof(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "feof"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044d0",
            "calling": [
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "feof"
        },
        "FUN_00116b00": {
            "renaming": {
                "FUN_00116b00": "FUNC_00116b00"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00116b24) */\n/* WARNING: Removing unreachable block (ram,0x00116b30) */\n\nvoid FUNC_00116b00(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00116b00",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00116b00"
        },
        "FUN_00113b98": {
            "renaming": {
                "FUN_00113b98": "allocate_and_store_data_00113b98",
                "param_1": "data_1",
                "param_2": "data_2",
                "param_3": "data_3",
                "param_4": "data_4",
                "lVar1": "allocated_memory",
                "plVar2": "allocated_data"
            },
            "code": "\nlong allocate_and_store_data_00113b98(long data_1,long data_2,long data_3,undefined data_4)\n\n{\n  long allocated_memory;\n  long *allocated_data;\n  \n  if ((data_1 != 0) && (allocated_memory = FUN_00112904(0x13,0), allocated_memory != 0)) {\n    allocated_data = (long *)xmalloc(0x20);\n    *(undefined4 *)((long)allocated_data + 0x19) = 0;\n    *allocated_data = data_1;\n    *(undefined4 *)((long)allocated_data + 0x1c) = 0;\n    allocated_data[1] = data_2;\n    allocated_data[2] = data_3;\n    *(undefined *)(allocated_data + 3) = data_4;\n    *(long **)(allocated_memory + 0x10) = allocated_data;\n    return allocated_memory;\n  }\n  return 0;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113b98",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010c95e"
            ],
            "imported": false,
            "current_name": "allocate_and_store_data_00113b98"
        },
        "FUN_00115d70": {
            "renaming": {
                "FUN_00115d70": "check_hash_table_00115d70",
                "param_1": "inputKey",
                "param_2": "hashTable",
                "lVar1": "result",
                "local_18": "currentKey",
                "local_10": "isFound"
            },
            "code": "\nundefined checkHashTable_00115d70(undefined8 inputKey,undefined8 hashTable)\n\n{\n  long result;\n  undefined8 currentKey;\n  undefined isFound;\n  \n  if (DAT_001279ea == '\\0') {\n    result = htab_find(hashTable,inputKey);\n    isFound = result != 0;\n  }\n  else {\n    isFound = 0;\n    currentKey = inputKey;\n    htab_traverse(hashTable,FUN_0011a170,&currentKey);\n  }\n  return isFound;\n}\n\n",
            "called": [
                "htab_traverse",
                "htab_find",
                "FUN_0011a170"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115d70",
            "calling": [
                "FUN_001082df",
                "FUN_0010554f",
                "FUN_001159d0"
            ],
            "imported": false,
            "current_name": "check_hash_table_00115d70"
        },
        "FUN_00109be3": {
            "renaming": {
                "FUN_00109be3": "resize_array_00109be3",
                "param_1": "array",
                "param_2": "value",
                "param_3": "size",
                "uVar1": "newArray",
                "puVar2": "nextElement",
                "uVar3": "currentSize"
            },
            "code": "\nundefined8 resizeArray_00109be3(long array,undefined8 value,undefined4 size)\n\n{\n  undefined8 newArray;\n  undefined8 *nextElement;\n  uint currentSize;\n  \n  if (*(uint *)(array + 0x2c) <= *(uint *)(array + 0x28)) {\n    currentSize = *(uint *)(array + 0x2c) + 10;\n    *(uint *)(array + 0x2c) = currentSize;\n    newArray = xrealloc(*(undefined8 *)(array + 0x20),(ulong)currentSize << 4);\n    *(undefined8 *)(array + 0x20) = newArray;\n  }\n  currentSize = *(uint *)(array + 0x28);\n  nextElement = (undefined8 *)((ulong)currentSize * 0x10 + *(long *)(array + 0x20));\n  *nextElement = value;\n  *(undefined4 *)(nextElement + 1) = size;\n  *(uint *)(array + 0x28) = currentSize + 1;\n  return CONCAT71((int7)((ulong)nextElement >> 8),1);\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00109be3",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010d7d4"
            ],
            "imported": false,
            "current_name": "resize_array_00109be3"
        },
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104480",
            "calling": [
                "FUN_00119e70",
                "FUN_00104943"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "FUN_0011a480": {
            "renaming": {
                "FUN_0011a480": "copy_string_with_length_0011a480",
                "param_1": "sourceString",
                "param_2": "maxLength",
                "__n": "stringLength",
                "__dest": "destinationString"
            },
            "code": "\nvoid copyStringWithLength_0011a480(char *sourceString,size_t maxLength)\n\n{\n  size_t stringLength;\n  void *destinationString;\n  \n  stringLength = strnlen(sourceString,maxLength);\n  destinationString = (void *)xmalloc(stringLength + 1);\n  *(undefined *)((long)destinationString + stringLength) = 0;\n  memcpy(destinationString,sourceString,stringLength);\n  return;\n}\n\n",
            "called": [
                "strnlen",
                "xmalloc",
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a480",
            "calling": [
                "FUN_00116b90",
                "FUN_00114c80"
            ],
            "imported": false,
            "current_name": "copy_string_with_length_0011a480"
        },
        "FUN_0010e918": {
            "renaming": {
                "FUN_0010e918": "send_data_to_server_0010e918",
                "param_1": "socket",
                "param_2": "data",
                "param_3": "length",
                "__s": "randomString",
                "sVar2": "dataLength",
                "sVar3": "randomStringLength",
                "__s_00": "formattedMessage",
                "uVar1": "result"
            },
            "code": "\nundefined4 sendDataToServer_0010e918(undefined8 socket,char *data,undefined8 length)\n\n{\n  undefined4 result;\n  char *randomString;\n  size_t dataLength;\n  size_t randomStringLength;\n  char *formattedMessage;\n  \n  randomString = (char *)FUN_00109b2f();\n  dataLength = strlen(data);\n  randomStringLength = strlen(randomString);\n  formattedMessage = (char *)xmalloc(dataLength + 0x14 + randomStringLength);\n  sprintf(formattedMessage,\"%s:c=e%s,%ld\",data,randomString,length);\n  free(randomString);\n  result = FUN_0010e2f0(socket,0x80,0,0,formattedMessage);\n  if ((char)result != '\\0') {\n    free(formattedMessage);\n  }\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_0010e2f0",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e918",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "send_data_to_server_0010e918"
        },
        "bfd_bread": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104870",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "bfd_bread"
        },
        "strcpy": {
            "renaming": {},
            "code": "\n\n\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strcpy(__dest,__src);\n  return pcVar1;\n}\n\n",
            "called": [
                "strcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104100",
            "calling": [
                "FUN_0010a424",
                "FUN_0010ee3f",
                "FUN_00116b90",
                "FUN_00115530",
                "FUN_001199d0",
                "FUN_0011378f",
                "FUN_0010554f",
                "FUN_0010ae0e"
            ],
            "imported": false,
            "current_name": "strcpy"
        },
        "FUN_00116110": {
            "renaming": {
                "FUN_00116110": "process_section_00116110",
                "param_1": "binary",
                "param_2": "section",
                "param_3": "output",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "lVar3": "length",
                "iVar4": "iVar1",
                "iVar5": "iVar2",
                "cVar6": "flag",
                "uVar7": "message",
                "__ptr": "buffer",
                "lVar8": "i",
                "uVar9": "j",
                "iVar10": "divisor",
                "uVar11": "offset",
                "puVar12": "ptr",
                "lVar13": "remaining",
                "puVar14": "ptr2",
                "puVar15": "ptr3",
                "pvVar16": "ptr4",
                "uVar17": "index1",
                "uVar18": "index2",
                "uVar19": "index3",
                "bVar20": "flag2",
                "local_38": "sectionSize",
                "local_30": "sectionContent"
            },
            "code": "\nvoid processSection_00116110(undefined8 binary,undefined8 *section,undefined8 output)\n\n{\n  undefined temp1;\n  undefined8 temp2;\n  long length;\n  int iVar1;\n  int iVar2;\n  char flag;\n  undefined8 message;\n  undefined8 *buffer;\n  long i;\n  ulong j;\n  int divisor;\n  ulong offset;\n  undefined *ptr;\n  long remaining;\n  undefined8 *ptr2;\n  undefined8 *ptr3;\n  void *ptr4;\n  ulong index1;\n  ulong index2;\n  ulong index3;\n  byte flag2;\n  ulong sectionSize;\n  void *sectionContent;\n  \n  flag2 = 0;\n  flag = FUN_00115f50(binary,section,1);\n  if (flag != '\\0') {\n    return;\n  }\n  sectionSize = section[8];\n  length = section[0xc];\n  if (((*(byte *)((long)section + 0x25) & 1) == 0) || ((*(byte *)(length + 0x25) & 1) == 0)) {\n    remaining = FUN_00114190(*section,0,0x80);\n    if (remaining == 0) {\n      return;\n    }\n    if ((*(byte *)(remaining + 0x29) & 1) == 0) {\n      return;\n    }\n    buffer = (undefined8 *)xmalloc(sectionSize);\n    ptr3 = buffer;\n    if (7 < sectionSize) {\n      for (index2 = sectionSize >> 3; index2 != 0; index2 = index2 - 1) {\n        *ptr3 = 0;\n        ptr3 = ptr3 + (ulong)flag2 * -2 + 1;\n      }\n    }\n    ptr2 = ptr3;\n    if ((sectionSize & 4) != 0) {\n      ptr2 = (undefined8 *)((long)ptr3 + (ulong)flag2 * -8 + 4);\n      *(undefined4 *)ptr3 = 0;\n    }\n    ptr3 = ptr2;\n    if ((sectionSize & 2) != 0) {\n      ptr3 = (undefined8 *)((long)ptr2 + (ulong)flag2 * -4 + 2);\n      *(undefined2 *)ptr2 = 0;\n    }\n    if ((sectionSize & 1) != 0) {\n      *(undefined *)ptr3 = 0;\n    }\n    flag = bfd_set_section_contents(output,length,buffer,0);\n    if (flag != '\\0') {\n      free(buffer);\n      return;\n    }\n    DAT_00127a40 = 1;\n    FUN_001126c0(0,output,length,0);\n    free(buffer);\n    return;\n  }\n  sectionContent = (void *)0x0;\n  flag = bfd_get_full_section_contents(binary,section,&sectionContent);\n  if ((flag == '\\0') ||\n     (flag = bfd_convert_section_contents(binary,section,output,&sectionContent,&sectionSize),\n     divisor = DAT_00127908, flag == '\\0')) {\n    bfd_set_section_size(length,0);\n    DAT_00127a40 = 1;\n    FUN_001126c0(0,binary,section,0);\n    free(sectionContent);\n    return;\n  }\n  iVar1 = DAT_001264b8;\n  iVar2 = DAT_001264bc;\n  if (DAT_00127908 != 0) {\n    index2 = (ulong)DAT_00127908;\n    if (sectionSize % index2 != 0) {\n      temp2 = *section;\n      message = dcgettext(0,\n                        \"cannot reverse bytes: length of section %s must be evenly divisible by %d\",\n                        5);\n                    \n      FUN_00119dd0(message,temp2,divisor);\n    }\n    divisor = DAT_00127908 / 2;\n    offset = 0;\n    while (index3 = offset, iVar1 = DAT_001264b8, iVar2 = DAT_001264bc, index3 < sectionSize) {\n      offset = index2 + index3;\n      index1 = offset;\n      for (j = 0; j < (ulong)(long)divisor; j = j + 1) {\n        index1 = index1 - 1;\n        ptr = (undefined *)(index3 + j + (long)sectionContent);\n        temp1 = *ptr;\n        *ptr = *(undefined *)((long)sectionContent + index1);\n        *(undefined *)((long)sectionContent + index1) = temp1;\n      }\n    }\n  }\n  DAT_001264b8 = iVar1;\n  DAT_001264bc = iVar2;\n  if (-1 < iVar2) {\n    index2 = (ulong)DAT_00127a3c;\n    divisor = (int)((ulong)section[7] % index2);\n    offset = ((long)iVar2 - (long)divisor) + (long)sectionContent;\n    if (iVar2 < divisor) {\n      offset = offset + index2;\n    }\n    remaining = (sectionSize + (long)sectionContent) - offset;\n    ptr4 = sectionContent;\n    for (; offset < sectionSize + (long)sectionContent; offset = offset + index2) {\n      for (i = 0; ((int)i < iVar1 && (i != remaining)); i = i + 1) {\n        *(undefined *)((long)ptr4 + i) = *(undefined *)(offset + i);\n      }\n      ptr4 = (void *)((long)ptr4 + i);\n      remaining = remaining - index2;\n    }\n    sectionSize = ((((index2 - 1) + sectionSize) - (long)iVar2) / index2) * (long)iVar1;\n    index2 = *(ulong *)(length + 0x38) / index2;\n    *(ulong *)(length + 0x38) = index2;\n    if (iVar2 < divisor) {\n      *(ulong *)(length + 0x38) = index2 + 1;\n      flag = bfd_set_section_contents(output,length,sectionContent,0,sectionSize);\n      if (flag == '\\0') {\n        FUN_00108466();\n        return;\n      }\n      goto LAB_001161d8;\n    }\n  }\n  flag = bfd_set_section_contents(output,length,sectionContent,0,sectionSize);\n  if (flag == '\\0') {\n    FUN_00108466();\n    return;\n  }\nLAB_001161d8:\n  free(sectionContent);\n  return;\n}\n\n",
            "called": [
                "FUN_00114190",
                "FUN_00115f50",
                "xmalloc",
                "free",
                "bfd_set_section_size",
                "bfd_convert_section_contents",
                "bfd_set_section_contents",
                "FUN_00108466",
                "FUN_001126c0",
                "FUN_001083de",
                "bfd_get_full_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116110",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_section_00116110"
        },
        "FUN_0010871c": {
            "renaming": {
                "FUN_0010871c": "print_error_message_0010871c",
                "uVar1": "errorMessage",
                "unaff_RBX": "errorType",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\n\n\nvoid printErrorMessage_0010871c(void)\n\n{\n  undefined8 errorMessage;\n  long errorType;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (errorType != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_00127600);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_00127600,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010871c",
            "calling": [
                "FUN_0011a110"
            ],
            "imported": false,
            "current_name": "print_error_message_0010871c"
        },
        "FUN_0010bf20": {
            "renaming": {
                "FUN_0010bf20": "debug_end_block_0010bf20",
                "param_1": "block_ptr",
                "param_2": "new_block_ptr",
                "param_3": "unused_param",
                "param_4": "result",
                "lVar1": "current_block_ptr",
                "uVar2": "error_msg",
                "pcVar3": "error_str",
                "auVar4": "output"
            },
            "code": "\n\n\nundefined  [16] debug_end_block_0010bf20(long block_ptr,undefined8 new_block_ptr,undefined8 unused_param,undefined8 result)\n\n{\n  long current_block_ptr;\n  undefined8 error_msg;\n  char *error_str;\n  undefined output [16];\n  \n  if ((*(long *)(block_ptr + 8) == 0) || (current_block_ptr = *(long *)(block_ptr + 0x20), current_block_ptr == 0)) {\n    error_str = \"debug_end_block_0010bf20: no current block\";\n  }\n  else {\n    if (*(long *)(current_block_ptr + 8) != 0) {\n      *(undefined8 *)(current_block_ptr + 0x20) = new_block_ptr;\n      error_msg = CONCAT71((int7)((ulong)current_block_ptr >> 8),1);\n      *(long *)(block_ptr + 0x20) = *(long *)(current_block_ptr + 8);\n      goto LAB_0010bf84;\n    }\n    error_str = \"debug_end_block_0010bf20: attempt to close top level block\";\n  }\n  error_msg = dcgettext(0,error_str,5);\n  fprintf(_stderr,\"%s\\n\",error_msg);\n  error_msg = 0;\nLAB_0010bf84:\n  output._8_8_ = result;\n  output._0_8_ = error_msg;\n  return output;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bf20",
            "calling": [
                "FUN_0010554f",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "debug_end_block_0010bf20"
        },
        "bfd_make_section_anyway_with_flags": {
            "renaming": {},
            "code": "\nvoid bfd_make_section_anyway_with_flags(void)\n\n{\n  bfd_make_section_anyway_with_flags();\n  return;\n}\n\n",
            "called": [
                "bfd_make_section_anyway_with_flags"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104190",
            "calling": [
                "FUN_00115530"
            ],
            "imported": false,
            "current_name": "bfd_make_section_anyway_with_flags"
        },
        "FUN_0010c95e": {
            "renaming": {
                "FUN_0010c95e": "parse_data_type_0010c95e",
                "param_1": "param_array",
                "param_2": "param_ptr",
                "param_3": "param_length",
                "bVar1": "byte_value",
                "bVar2": "next_byte",
                "pbVar3": "current_ptr",
                "bVar4": "is_unsigned",
                "bVar5": "is_signed",
                "bVar6": "is_float",
                "cVar7": "char_value",
                "uVar8": "uint_value",
                "pbVar9": "next_ptr",
                "lVar10": "result",
                "uVar11": "return_val",
                "pcVar12": "ptr_char",
                "sVar13": "length",
                "uVar14": "ulong_value",
                "__ptr": "data_ptr",
                "lVar15": "new_result",
                "pcVar19": "ptr_string",
                "ppcVar18": "ptr_array_str",
                "puVar16": "ptr_ulong",
                "puVar17": "ptr_undefined",
                "pbVar20": "data_ptr",
                "local_49": "undefined_val",
                "local_48": "ulong_val",
                "local_40": "array_str"
            },
            "code": "\nundefined8 parseDataType_0010c95e(undefined8 *param_array,byte **param_ptr,long *param_length)\n\n{\n  byte byte_value;\n  byte next_byte;\n  byte *current_ptr;\n  bool is_unsigned;\n  bool is_signed;\n  bool is_float;\n  char char_value;\n  uint uint_value;\n  byte *next_ptr;\n  long result;\n  undefined8 return_val;\n  char *ptr_char;\n  size_t length;\n  ulong ulong_value;\n  void *data_ptr;\n  long new_result;\n  ulong *ptr_ulong;\n  undefined *ptr_undefined;\n  char **ptr_array_str;\n  char *ptr_string;\n  byte *data_ptr;\n  undefined undefined_val;\n  ulong ulong_val;\n  char *array_str [2];\n  \n  while( true ) {\n    data_ptr = *param_ptr;\n    byte_value = *data_ptr;\n    if ('T' < (char)byte_value) break;\n    if ((char)byte_value < 'A') goto switchD_0010c9b2_caseD_42;\n    switch(byte_value) {\n    case 0x41:\n      new_result = 0;\n      current_ptr = data_ptr;\n      goto LAB_0010ca26;\n    default:\n      goto switchD_0010c9b2_caseD_42;\n    case 0x43:\n      *param_ptr = data_ptr + 1;\n      char_value = parseDataType_0010c95e(param_array,param_ptr,param_length);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      if (param_length == (long *)0x0) {\n        return 1;\n      }\n      new_result = FUN_00113b71(*param_length);\n      *param_length = new_result;\n      return 1;\n    case 0x46:\n      *param_ptr = data_ptr + 1;\n      if (param_length == (long *)0x0) {\n        ptr_ulong = (ulong *)0x0;\n        ptr_array_str = (char **)0x0;\n      }\n      else {\n        ptr_ulong = &ulong_val;\n        ptr_array_str = array_str;\n      }\n      char_value = FUN_0010d882(param_array,param_ptr,ptr_array_str,ptr_ulong);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      if (**param_ptr == 0x5f) {\n        *param_ptr = *param_ptr + 1;\n        char_value = parseDataType_0010c95e(param_array,param_ptr,param_length);\n        if (char_value == '\\0') {\n          return 0;\n        }\n        if (param_length == (long *)0x0) {\n          return 1;\n        }\n        new_result = FUN_00113ce0(*param_length,array_str[0],ulong_val & 0xff);\n        *param_length = new_result;\n        return 1;\n      }\n      goto switchD_0010cdf9_caseD_60;\n    case 0x47:\n      *param_ptr = data_ptr + 1;\n      break;\n    case 0x4d:\n    case 0x4f:\n      undefined_val = 0;\n      array_str[0] = (char *)0x0;\n      ulong_val = 0;\n      *param_ptr = data_ptr + 1;\n      if (((&_sch_istable)[(ulong)data_ptr[1] * 2] & 4) == 0) {\n        if (data_ptr[1] != 0x51) goto switchD_0010cdf9_caseD_60;\n        ptr_array_str = array_str;\n        if (param_length == (long *)0x0) {\n          ptr_array_str = (char **)0x0;\n        }\n        char_value = FUN_0010d559(param_array,param_ptr,ptr_array_str);\n        if (char_value == '\\0') {\n          return 0;\n        }\n      }\n      else {\n        uint_value = FUN_00108e76(param_ptr);\n        current_ptr = *param_ptr;\n        length = strlen((char *)current_ptr);\n        if (length < uint_value) goto switchD_0010cdf9_caseD_60;\n        *param_ptr = current_ptr + uint_value;\n        if ((param_length != (long *)0x0) &&\n           (array_str[0] = (char *)FUN_0010afd5(*param_array,param_array[1],current_ptr,uint_value,9),\n           array_str[0] == (char *)0x0)) {\n          return 0;\n        }\n      }\n      next_byte = **param_ptr;\n      if (byte_value == 0x4d) {\n        if ((next_byte == 0x43) || (next_byte == 0x56)) {\n          *param_ptr = *param_ptr + 1;\n        }\n        if (**param_ptr != 0x46) goto switchD_0010cdf9_caseD_60;\n        *param_ptr = *param_ptr + 1;\n        if (param_length == (long *)0x0) {\n          ptr_undefined = (undefined *)0x0;\n          ptr_ulong = (ulong *)0x0;\n        }\n        else {\n          ptr_undefined = &undefined_val;\n          ptr_ulong = &ulong_val;\n        }\n        char_value = FUN_0010d882(param_array,param_ptr,ptr_ulong,ptr_undefined);\n        if (char_value == '\\0') {\n          return 0;\n        }\n      }\n      if (**param_ptr == 0x5f) {\n        *param_ptr = *param_ptr + 1;\n        char_value = parseDataType_0010c95e(param_array,param_ptr,param_length);\n        if (char_value == '\\0') {\n          return 0;\n        }\n        if (param_length == (long *)0x0) {\n          return 1;\n        }\n        if (byte_value != 0x4d) {\n          new_result = FUN_00113bfa(array_str[0],*param_length);\n          *param_length = new_result;\n          return 1;\n        }\n        new_result = FUN_00113b98(*param_length,array_str[0],ulong_val,undefined_val);\n        *param_length = new_result;\n        return 1;\n      }\n      goto switchD_0010cdf9_caseD_60;\n    case 0x50:\n      goto switchD_0010c9b2_caseD_50;\n    case 0x51:\n      return_val = FUN_0010d559(param_array,param_ptr,param_length);\n      return return_val;\n    case 0x52:\n      *param_ptr = data_ptr + 1;\n      char_value = parseDataType_0010c95e(param_array,param_ptr,param_length);\n      if (char_value == '\\0') {\n        return 0;\n      }\n      if (param_length == (long *)0x0) {\n        return 1;\n      }\n      new_result = FUN_00113cb9(*param_length);\n      *param_length = new_result;\n      return 1;\n    case 0x54:\n      *param_ptr = data_ptr + 1;\n      char_value = FUN_00108ea1(param_ptr,&ulong_val);\n      if (char_value != '\\0') {\n        if ((uint)ulong_val < *(uint *)(param_array + 5)) {\n          array_str[0] = *(char **)((ulong_val & 0xffffffff) * 0x10 + param_array[4]);\n          char_value = parseDataType_0010c95e(param_array,array_str,param_length);\n          if (char_value == '\\0') {\n            return 0;\n          }\n          return 1;\n        }\n      }\n      goto switchD_0010cdf9_caseD_60;\n    }\n  }\n  if (byte_value == 0x70) {\nswitchD_0010c9b2_caseD_50:\n    *param_ptr = data_ptr + 1;\n    char_value = parseDataType_0010c95e(param_array,param_ptr,param_length);\n    if (char_value == '\\0') {\n      return 0;\n    }\n    if (param_length == (long *)0x0) {\n      return 1;\n    }\n    new_result = FUN_00113d3a(*param_length);\n    *param_length = new_result;\n    return 1;\n  }\nswitchD_0010c9b2_caseD_42:\n  is_float = false;\n  is_unsigned = false;\n  char_value = '\\0';\n  is_signed = false;\n  do {\n    current_ptr = *param_ptr;\n    byte_value = *current_ptr;\n    if (byte_value == 0x55) {\n      char_value = '\\x01';\n      goto LAB_0010cd84;\n    }\n    if ('U' < (char)byte_value) {\n      if (byte_value == 0x56) {\n        is_float = true;\n        goto LAB_0010cd84;\n      }\n      if ('x' < (char)byte_value) goto switchD_0010cdf9_caseD_60;\n      if ((char)byte_value < '_') goto LAB_0010cdfb;\n      switch(byte_value) {\n      case 0x5f:\n        goto switchD_0010cdf9_caseD_5f;\n      default:\n        goto switchD_0010cdf9_caseD_60;\n      case 0x62:\n        if (param_length == (long *)0x0) {\nLAB_0010d0aa:\n          *param_ptr = current_ptr + 1;\n          return 1;\n        }\n        new_result = FUN_0010914e(*param_array,&DAT_00120436);\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00112904(6,4);\n          *param_length = new_result;\n          *param_ptr = *param_ptr + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 99:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        ptr_string = \"unsigned char\";\n        if ((char_value == '\\0') && (ptr_string = \"char\", is_unsigned)) {\n          ptr_string = \"signed char\";\n        }\n        new_result = FUN_0010914e(*param_array,ptr_string);\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00113dfe(1,char_value);\n          *param_length = new_result;\n          *param_ptr = *param_ptr + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 100:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        ptr_string = \"double\";\n        goto LAB_0010d046;\n      case 0x66:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        new_result = FUN_0010914e(*param_array,\"float\");\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00113df2(4);\n          *param_length = new_result;\n          *param_ptr = *param_ptr + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x69:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        ptr_string = \"unsigned int\";\n        ptr_char = \"int\";\n        goto LAB_0010ced2;\n      case 0x6c:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        ptr_string = \"long unsigned int\";\n        ptr_char = \"long int\";\nLAB_0010ced2:\n        if (char_value == '\\0') {\n          ptr_string = ptr_char;\n        }\n        new_result = FUN_0010914e(*param_array,ptr_string);\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00113dfe(4,char_value);\n          *param_length = new_result;\n          *param_ptr = *param_ptr + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x72:\n        ptr_string = \"long double\";\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\nLAB_0010d046:\n        new_result = FUN_0010914e(*param_array,ptr_string);\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00113df2(8);\n          *param_length = new_result;\n          *param_ptr = *param_ptr + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x73:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        ptr_string = \"short unsigned int\";\n        if (char_value == '\\0') {\n          ptr_string = \"short int\";\n        }\n        new_result = FUN_0010914e(*param_array,ptr_string);\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00113dfe(2,char_value);\n          *param_length = new_result;\n          *param_ptr = *param_ptr + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x74:\n        ptr_array_str = array_str;\n        if (param_length == (long *)0x0) {\n          ptr_array_str = (char **)0x0;\n        }\n        char_value = FUN_0010d21c(param_array,param_ptr,ptr_array_str);\n        if (char_value == '\\0') {\n          return 0;\n        }\n        if (param_length == (long *)0x0) {\n          return 1;\n        }\n        length = strlen(array_str[0]);\n        new_result = FUN_0010afd5(*param_array,param_array[1],array_str[0],length & 0xffffffff,9);\n        *param_length = new_result;\n        free(array_str[0]);\n        new_result = *param_length;\n        goto joined_r0x0010d1d8;\n      case 0x76:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        new_result = FUN_0010914e(*param_array,&DAT_00120495);\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00113e17();\n          *param_length = new_result;\n          *param_ptr = *param_ptr + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x77:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        new_result = FUN_0010914e(*param_array,\"__wchar_t\");\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00113dfe(2,1);\n          *param_length = new_result;\n          *param_ptr = *param_ptr + 1;\n          goto LAB_0010d1de;\n        }\n        break;\n      case 0x78:\n        if (param_length == (long *)0x0) goto LAB_0010d0aa;\n        ptr_string = \"long long unsigned int\";\n        if (char_value == '\\0') {\n          ptr_string = \"long long int\";\n        }\n        new_result = FUN_0010914e(*param_array,ptr_string);\n        *param_length = new_result;\n        if (new_result == 0) {\n          new_result = FUN_00113dfe(8,char_value);\n          *param_length = new_result;\n        }\n      }\n      *param_ptr = *param_ptr + 1;\n      goto LAB_0010d1de;\n    }\n    if (byte_value == 0x43) {\n      is_signed = true;\n      goto LAB_0010cd84;\n    }\n    if (byte_value != 0x53) goto LAB_0010cdc5;\n    is_unsigned = true;\nLAB_0010cd84:\n    *param_ptr = current_ptr + 1;\n  } while( true );\nLAB_0010ca26:\n  next_ptr = current_ptr + 1;\n  *param_ptr = next_ptr;\n  byte_value = *next_ptr;\n  if (byte_value == 0) goto switchD_0010cdf9_caseD_60;\n  if (byte_value == 0x5f) {\n    *param_ptr = current_ptr + 2;\n    char_value = parseDataType_0010c95e(param_array,param_ptr,param_length);\n    if (char_value == '\\0') {\n      return 0;\n    }\n    if (param_length == (long *)0x0) {\n      return 1;\n    }\n    result = FUN_0010914e(*param_array,\"int\");\n    if (result == 0) {\n      result = FUN_00113dfe(4,0);\n    }\n    new_result = FUN_00113c43(*param_length,result,0,new_result,0);\n    *param_length = new_result;\n    return 1;\n  }\n  if (((&_sch_istable)[(ulong)byte_value * 2] & 4) == 0) goto switchD_0010cdf9_caseD_60;\n  new_result = new_result * 10 + (long)((char)byte_value + -0x30);\n  current_ptr = next_ptr;\n  goto LAB_0010ca26;\nLAB_0010cdc5:\n  if ((char)byte_value < ':') {\n    if ((char)byte_value < '0') {\n      if (byte_value != 0) goto switchD_0010cdf9_caseD_60;\nswitchD_0010cdf9_caseD_5f:\n      FUN_0010911f(data_ptr);\n      if (param_length == (long *)0x0) {\n        return 1;\n      }\n      goto LAB_0010d1de;\n    }\n  }\n  else {\nLAB_0010cdfb:\n    if ((byte_value != 0x47) || (*param_ptr = current_ptr + 1, ((&_sch_istable)[(ulong)current_ptr[1] * 2] & 4) == 0)\n       ) goto switchD_0010cdf9_caseD_60;\n  }\n  data_ptr = *param_ptr;\n  uint_value = FUN_00108e76(param_ptr);\n  current_ptr = *param_ptr;\n  length = strlen((char *)current_ptr);\n  ulong_value = (ulong)uint_value;\n  if (ulong_value <= length) {\n    *param_ptr = current_ptr + ulong_value;\n    if (param_length == (long *)0x0) {\n      return 1;\n    }\n    data_ptr = (void *)FUN_00109a0b(current_ptr,ulong_value);\n    new_result = FUN_0010914e(*param_array,data_ptr);\n    *param_length = new_result;\n    free(data_ptr);\n    if (*param_length == 0) {\n      new_result = FUN_0010afd5(*param_array,param_array[1],current_ptr,(int)*param_ptr - (int)current_ptr,0);\n      *param_length = new_result;\njoined_r0x0010d1d8:\n      if (new_result == 0) {\n        return 0;\n      }\n    }\nLAB_0010d1de:\n    if (is_signed) {\n      new_result = FUN_00113b71(*param_length);\n      *param_length = new_result;\n    }\n    if (is_float) {\n      new_result = FUN_00113b4a(*param_length);\n      *param_length = new_result;\n    }\n    return 1;\n  }\nswitchD_0010cdf9_caseD_60:\n  FUN_0010911f(data_ptr);\n  return 0;\n}\n\n",
            "called": [
                "FUN_0010d21c",
                "FUN_00113dfe",
                "FUN_00108e76",
                "FUN_00113b71",
                "FUN_00113e17",
                "FUN_0010d559",
                "FUN_00113bfa",
                "FUN_00113c43",
                "strlen",
                "FUN_00113df2",
                "FUN_00113b4a",
                "free",
                "FUN_00112904",
                "FUN_00113ce0",
                "FUN_0010d882",
                "FUN_0010911f",
                "FUN_00113cb9",
                "FUN_0010914e",
                "FUN_00113b98",
                "FUN_0010c95e",
                "FUN_00108ea1",
                "FUN_00109a0b",
                "FUN_0010afd5",
                "FUN_00113d3a"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c95e",
            "calling": [
                "FUN_0010d21c",
                "FUN_00113e5e",
                "FUN_0010c95e",
                "FUN_0010d7d4"
            ],
            "imported": false,
            "current_name": "parse_data_type_0010c95e"
        },
        "FUN_00107880": {
            "renaming": {
                "FUN_00107880": "FUNC_00107880"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x001062da) */\n/* WARNING: Removing unreachable block (ram,0x001062e7) */\n/* WARNING: Removing unreachable block (ram,0x001062eb) */\n/* WARNING: Removing unreachable block (ram,0x00106314) */\n/* WARNING: Removing unreachable block (ram,0x00106316) */\n/* WARNING: Removing unreachable block (ram,0x00106323) */\n/* WARNING: Removing unreachable block (ram,0x00106331) */\n/* WARNING: Removing unreachable block (ram,0x0010633b) */\n/* WARNING: Removing unreachable block (ram,0x00106354) */\n/* WARNING: Removing unreachable block (ram,0x00106358) */\n/* WARNING: Removing unreachable block (ram,0x001075c4) */\n/* WARNING: Removing unreachable block (ram,0x0010636d) */\n/* WARNING: Removing unreachable block (ram,0x00106375) */\n/* WARNING: Removing unreachable block (ram,0x00106490) */\n/* WARNING: Type propagation algorithm not settling */\n\n\nulong FUNC_00107880(void)\n\n{\n  uint *puVar1;\n  byte bVar2;\n  undefined *puVar3;\n  long *plVar4;\n  code *pcVar5;\n  long *plVar6;\n  ulong uVar7;\n  ulong uVar8;\n  char *__s;\n  char cVar9;\n  char cVar10;\n  uint uVar11;\n  int iVar12;\n  uint uVar13;\n  undefined4 uVar14;\n  int iVar15;\n  long *plVar16;\n  long lVar17;\n  undefined8 uVar18;\n  undefined8 uVar19;\n  size_t sVar20;\n  size_t sVar21;\n  char *pcVar22;\n  void *__ptr;\n  void *__ptr_00;\n  ulong uVar23;\n  long lVar24;\n  ulong uVar25;\n  long in_RAX;\n  int *piVar26;\n  long lVar27;\n  ulong uVar28;\n  FILE *__s_00;\n  long **pplVar29;\n  long **__ptr_01;\n  char *pcVar30;\n  undefined8 *puVar31;\n  ulong uVar32;\n  int iVar33;\n  long **pplVar34;\n  char *pcVar35;\n  undefined4 *puVar36;\n  undefined8 *puVar37;\n  char **ppcVar38;\n  void *pvVar39;\n  undefined8 *unaff_R14;\n  undefined **ppuVar40;\n  bool bVar41;\n  byte bVar42;\n  long param_7;\n  ulong param_8;\n  char param_9;\n  undefined4 *param_10;\n  char *pcStack0000000000000038;\n  uint uStack0000000000000048;\n  int param_11;\n  long param_12;\n  long lStack0000000000000088;\n  char *pcStack0000000000000090;\n  long lStack00000000000000a0;\n  long *in_stack_000000c0;\n  ulong in_stack_000000c8;\n  long in_stack_000000d0;\n  long in_stack_000000d8;\n  void *in_stack_000000e0;\n  long in_stack_000000f0;\n  undefined8 in_stack_000000f8;\n  byte bStack0000000000000100;\n  byte bStack0000000000000101;\n  undefined8 in_stack_00000110;\n  ushort in_stack_00000118;\n  char *param_13;\n  char cStack0000000000000148;\n  char *in_stack_00000150;\n  undefined uStack0000000000000158;\n  short sStack000000000000015a;\n  \n  bVar42 = 0;\n  cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x2a0))\n                     (param_7,**(undefined4 **)(in_RAX + 0x380),0);\n  if (cVar10 == '\\0') {\n    if ((*(byte *)(unaff_R14 + 9) & 0x40) != 0) {\n      iVar12 = bfd_get_arch();\n      if (iVar12 == 0) {\n        uVar19 = FUN_001125fa();\n        uVar18 = dcgettext(0,\"Unable to recognise the format of the input file `%s\\'\",5);\n        FUN_00119ed0(uVar18,uVar19);\n        return 0;\n      }\n      uVar19 = bfd_get_mach();\n      uVar14 = bfd_get_arch();\n      uVar19 = bfd_printable_arch_mach(uVar14,uVar19);\n      uVar18 = dcgettext(0,\"Output file cannot represent architecture `%s\\'\",5);\n      FUN_00119ed0(uVar18,uVar19);\n      return 0;\n    }\n    iVar12 = bfd_get_arch();\n    iVar33 = bfd_get_arch(param_7);\n    if (iVar12 != iVar33) {\n      uVar28 = FUN_00105828();\n      return uVar28;\n    }\n  }\n  cVar10 = bfd_set_format(param_7,*(byte *)(unaff_R14 + 9) & 7);\n  if (cVar10 == '\\0') {\nLAB_00107a82:\n    FUN_001126c0(0);\n    return 0;\n  }\n  if ((*(int *)(*(undefined8 **)(param_7 + 8) + 1) == 2) &&\n     (cVar10 = FUN_00113fb0(**(undefined8 **)(param_7 + 8),&DAT_0011b503), cVar10 != '\\0')) {\n    lVar27 = *(long *)(param_7 + 0x110);\n    if ((*(int *)((undefined8 *)unaff_R14[1] + 1) == 2) &&\n       (cVar10 = FUN_00113fb0(*(undefined8 *)unaff_R14[1],&DAT_0011b503), cVar10 != '\\0')) {\n      lVar17 = unaff_R14[0x22];\n      bVar41 = DAT_001279eb == '\\0';\n      puVar31 = (undefined8 *)(lVar17 + 200);\n      puVar37 = (undefined8 *)(lVar27 + 200);\n      for (lVar24 = 0x32; lVar24 != 0; lVar24 = lVar24 + -1) {\n        *puVar37 = *puVar31;\n        puVar31 = puVar31 + (ulong)bVar42 * -2 + 1;\n        puVar37 = puVar37 + (ulong)bVar42 * -2 + 1;\n      }\n      if (bVar41) {\n        *(undefined4 *)(lVar27 + 0x2a4) = 0xffffffff;\n      }\n      else {\n        *(int *)(lVar27 + 0x2a4) = (int)*(undefined8 *)(lVar17 + 0xa8);\n      }\n    }\n    uVar28 = DAT_001264a8;\n    if (DAT_001264a8 == 0xffffffffffffffff) {\n      DAT_001264a8 = 0x200;\n      uVar28 = 0x200;\n    }\n    else {\n      *(int *)(lVar27 + 0x10c) = (int)DAT_001264a8;\n    }\n    if (DAT_00126498 != -1) {\n      *(long *)(lVar27 + 0x148) = DAT_00126498;\n    }\n    if (DAT_001264a0 != -1) {\n      *(long *)(lVar27 + 0x148) = DAT_001264a0;\n    }\n    if (DAT_00126490 != -1) {\n      *(long *)(lVar27 + 0x100) = DAT_00126490;\n    }\n    uVar23 = DAT_00126488;\n    if (DAT_00126488 == 0xffffffffffffffff) {\n      DAT_00126488 = 0x1000;\n      uVar23 = 0x1000;\n    }\n    else {\n      *(int *)(lVar27 + 0x108) = (int)DAT_00126488;\n    }\n    if (DAT_00126478 != -1) {\n      *(long *)(lVar27 + 0x138) = DAT_00126478;\n    }\n    if (DAT_00126480 != -1) {\n      *(long *)(lVar27 + 0x138) = DAT_00126480;\n    }\n    if (DAT_00126474 != -1) {\n      *(short *)(lVar27 + 300) = DAT_00126474;\n    }\n    if (DAT_00126472 != -1) {\n      *(short *)(lVar27 + 0x118) = DAT_00126472;\n    }\n    if (DAT_00126470 != -1) {\n      *(short *)(lVar27 + 0x11a) = DAT_00126470;\n    }\n    if (uVar23 < uVar28) {\n      uVar19 = dcgettext(0,\"warning: file alignment (0x%lx) > section alignment (0x%lx)\",5);\n      FUN_00119ed0(uVar19,uVar28,uVar23);\n    }\n  }\n  plVar6 = DAT_001278d0;\n  free(DAT_001278d0);\n  if (plVar6 == DAT_001278c8) {\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  else {\n    free(DAT_001278c8);\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n    lVar27 = (**(code **)(unaff_R14[1] + 0x1f8))();\n  }\n  if (lVar27 < 0) goto LAB_00107a82;\n  DAT_001278c8 = (long *)xmalloc();\n  DAT_001278d0 = DAT_001278c8;\n  param_8 = (**(code **)(unaff_R14[1] + 0x200))();\n  if ((long)param_8 < 0) goto LAB_00107a82;\n  if (param_8 == 0) {\n    free(DAT_001278d0);\n    DAT_001278d0 = (long *)0x0;\n    DAT_001278c8 = (long *)0x0;\n  }\n  bfd_map_over_sections();\n  puVar31 = DAT_001279e0;\n  if ((DAT_0012790c == '\\0') &&\n     (cVar10 = (**(code **)(*(long *)(param_7 + 8) + 0x168))(), puVar31 = DAT_001279e0,\n     cVar10 == '\\0')) {\n    DAT_00127a40 = 1;\n    dcgettext(0,\"error in private header data\",5);\n    FUN_001126c0(0);\n    puVar31 = DAT_001279e0;\n  }\n  for (; puVar37 = DAT_001279d8, puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    uVar11 = 0x128;\n    lVar27 = FUN_00114190(puVar31[1],0,0x80);\n    if (lVar27 != 0) {\n      uVar11 = FUN_00115f30(*(uint *)(lVar27 + 0x28) | 0x100,param_7,puVar31[1]);\n    }\n    lVar27 = bfd_get_section_by_name(param_7,puVar31[1]);\n    if (lVar27 != 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t add section \\'%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    lVar27 = bfd_make_section_with_flags(param_7,puVar31[1],uVar11 | 0x100000);\n    puVar31[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar31[1];\n      uVar18 = dcgettext(0,\"can\\'t create section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar18,uVar19);\n      return 0;\n    }\n    cVar10 = bfd_set_section_size();\n    if (cVar10 == '\\0') {\n      FUN_001126c0(0,param_7,puVar31[5],0);\n      return 0;\n    }\n    lVar27 = FUN_00114190(puVar31[1],0,0x18);\n    if (lVar27 != 0) {\n      uVar19 = *(undefined8 *)(lVar27 + 0x18);\n      lVar27 = puVar31[5];\n      *(byte *)(lVar27 + 0x28) = *(byte *)(lVar27 + 0x28) | 1;\n      *(undefined8 *)(lVar27 + 0x30) = uVar19;\n      *(undefined8 *)(lVar27 + 0x38) = uVar19;\n    }\n    lVar27 = FUN_00114190(puVar31[1],0,0x60);\n    if (lVar27 != 0) {\n      lVar17 = puVar31[5];\n      *(undefined8 *)(lVar17 + 0x38) = *(undefined8 *)(lVar27 + 0x20);\n      if (0x3e < *(uint *)(lVar17 + 0x7c)) {\n        FUN_001126c0(0,param_7,lVar17,0);\n        return 0;\n      }\n    }\n  }\n  for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n    lVar27 = bfd_get_section_by_name();\n    puVar37[5] = lVar27;\n    if (lVar27 == 0) {\n      uVar19 = puVar37[1];\n      uVar18 = dcgettext(0,\"error: %s not found, can\\'t be updated\",5);\n      FUN_00119ed0(uVar18,uVar19);\n      return 0;\n    }\n    uVar19 = *(undefined8 *)(lVar27 + 0x60);\n    cVar10 = bfd_set_section_size(uVar19);\n    if (cVar10 == '\\0') {\n      FUN_001126c0(0,param_7,uVar19,0);\n      return 0;\n    }\n  }\n  puVar31 = DAT_001279d0;\n  if (DAT_00127a20 == '\\0') {\n    __ptr_01 = (long **)0x0;\n  }\n  else {\n    pplVar34 = (long **)unaff_R14[0x12];\n    __ptr_01 = pplVar34;\n    if (pplVar34 != (long **)0x0) {\n      __ptr_01 = (long **)0x0;\nLAB_001151ab:\n      if (DAT_00127a20 != '\\0') goto LAB_00115187;\n      for (plVar6 = pplVar34[1]; puVar31 = DAT_001279d0, plVar6 != (long *)0x0;\n          plVar6 = (long *)plVar6[1]) {\n      }\n    }\n  }\njoined_r0x001151c7:\n  for (; puVar31 != (undefined8 *)0x0; puVar31 = (undefined8 *)*puVar31) {\n    lVar27 = bfd_get_section_by_name();\n    if (lVar27 == 0) {\n      dcgettext(0,\"can\\'t dump section \\'%s\\' - it does not exist\",5);\n      FUN_001126c0(0);\n    }\n    else if ((*(byte *)(lVar27 + 0x25) & 1) == 0) {\n      dcgettext(0,\"can\\'t dump section - it has no contents\",5);\n      FUN_001126c0(0);\n    }\n    else {\n      sVar20 = *(size_t *)(lVar27 + 0x40);\n      __s_00 = fopen((char *)puVar31[2],\"w\");\n      if (__s_00 == (FILE *)0x0) {\n        dcgettext(0,\"could not open section dump file\",5);\n        FUN_001126c0(puVar31[2],0,0);\n      }\n      else {\n        cVar10 = bfd_malloc_and_get_section();\n        if (cVar10 == '\\0') {\n          dcgettext(0,\"could not retrieve section contents\",5);\n          FUN_001126c0(0);\n        }\n        else if ((sVar20 != 0) && (sVar21 = fwrite(param_13,1,sVar20,__s_00), sVar21 != sVar20)) {\n          piVar26 = __errno_location();\n          pcVar35 = strerror(*piVar26);\n          uVar19 = puVar31[2];\n          uVar18 = dcgettext(0,\"error writing section contents to %s (error: %s)\",5);\n          FUN_00119ed0(uVar18,uVar19,pcVar35);\n          free(param_13);\n          fclose(__s_00);\n          return 0;\n        }\n        fclose(__s_00);\n        free(param_13);\n      }\n    }\n  }\n  if (DAT_00127a30 == 0) {\nLAB_0010790a:\n    param_12 = 0;\n  }\n  else {\n    lVar27 = bfd_get_section_by_name(param_7,\".gnu_debuglink\");\n    if (lVar27 != 0) {\n      uVar19 = dcgettext(0,\"%s: debuglink section already exists\",5);\n      FUN_00119ed0(uVar19);\n      DAT_00127a30 = 0;\n      goto LAB_0010790a;\n    }\n    param_12 = bfd_create_gnu_debuglink_section(param_7);\n    lVar27 = DAT_00127a30;\n    if (param_12 == 0) {\n      uVar19 = dcgettext(0,\"cannot create debug link section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar19,lVar27);\n      return 0;\n    }\n    if (*(int *)(*(long *)(param_7 + 8) + 8) == 2) {\n      uVar23 = 0;\n      for (uVar28 = *(ulong *)(param_7 + 0x90); uVar28 != 0; uVar28 = *(ulong *)(uVar28 + 8)) {\n        uVar25 = *(ulong *)(uVar28 + 0x30);\n        uVar32 = uVar23;\n        uVar7 = uVar28;\n        uVar8 = uVar23;\n        if (uVar25 != 0) {\n          while ((uVar32 = uVar7, uVar8 != 0 &&\n                 (uVar32 = uVar28, uVar25 <= *(ulong *)(uVar23 + 0x30)))) {\n            uVar28 = *(ulong *)(uVar28 + 8);\n            if (uVar28 == 0) goto LAB_00107db8;\n            uVar25 = *(ulong *)(uVar28 + 0x30);\n            uVar7 = uVar23;\n            uVar8 = uVar25;\n          }\n        }\n        uVar23 = uVar32;\n      }\nLAB_00107db8:\n      if (uVar23 == 0) {\n        uVar28 = 0x1000;\n      }\n      else {\n        uVar23 = *(long *)(uVar23 + 0x40) + *(long *)(uVar23 + 0x30);\n        uVar28 = 0xffffffffffffffff;\n        if (uVar23 < 0xfffffffffffff001) {\n          uVar28 = uVar23 + 0xfff & 0xfffffffffffff000;\n        }\n      }\n      *(byte *)(param_12 + 0x28) = *(byte *)(param_12 + 0x28) | 1;\n      *(ulong *)(param_12 + 0x30) = uVar28;\n      *(ulong *)(param_12 + 0x38) = uVar28;\n    }\n  }\n  plVar6 = DAT_001278d0;\n  param_11 = *(int *)(param_7 + 0xa0);\n  if (param_11 != 0) {\n    uVar28 = FUN_0010554f();\n    return uVar28;\n  }\n  if (DAT_001279a0 == '\\0') {\nLAB_00105588:\n    param_10 = (undefined4 *)0x0;\n  }\n  else {\n    ppuVar40 = &PTR_s__stab_00125c60;\n    param_10 = (undefined4 *)xmalloc(0x60);\n    puVar36 = param_10;\n    for (lVar27 = 0x18; lVar27 != 0; lVar27 = lVar27 + -1) {\n      *puVar36 = 0;\n      puVar36 = puVar36 + (ulong)bVar42 * -2 + 1;\n    }\n    pcStack0000000000000038 = (char *)0x0;\n    do {\n      puVar3 = *ppuVar40;\n      lVar27 = bfd_get_section_by_name();\n      lVar17 = bfd_get_section_by_name();\n      if ((lVar27 != 0) && (lVar17 != 0)) {\n        lVar27 = *(long *)(lVar27 + 0x40);\n        __ptr = (void *)xmalloc(lVar27);\n        cVar10 = bfd_get_section_contents();\n        if (cVar10 == '\\0') {\n          uVar14 = bfd_get_error();\n          bfd_errmsg(uVar14);\n          fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n          free(pcStack0000000000000038);\n          free(__ptr);\n        }\n        else {\n          uVar28 = *(ulong *)(lVar17 + 0x40);\n          __ptr_00 = (void *)xmalloc(uVar28 + 1);\n          param_9 = bfd_get_section_contents();\n          if (param_9 == '\\0') {\n            uVar14 = bfd_get_error();\n            bfd_errmsg(uVar14);\n            fprintf(_stderr,\"%s: %s: %s\\n\",*unaff_R14);\n            free(pcStack0000000000000038);\n          }\n          else {\n            *(undefined *)((long)__ptr_00 + uVar28) = 0;\n            if ((pcStack0000000000000038 != (char *)0x0) ||\n               (pcStack0000000000000038 = (char *)FUN_00112894(),\n               pcStack0000000000000038 != (char *)0x0)) {\n              lStack00000000000000a0 = 0;\n              lStack0000000000000088 = 0;\n              for (pvVar39 = __ptr; pvVar39 <= (void *)((long)__ptr + lVar27 + -0xc);\n                  pvVar39 = (void *)((long)pvVar39 + 0xc)) {\n                uVar23 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                bVar2 = *(byte *)((long)pvVar39 + 4);\n                uVar14 = (**(code **)(unaff_R14[1] + 0x58))((long)pvVar39 + 6);\n                lVar17 = (**(code **)(unaff_R14[1] + 0x40))((long)pvVar39 + 8);\n                if (bVar2 == 0) {\n                  lStack0000000000000088 = lStack00000000000000a0;\n                  lStack00000000000000a0 = lStack00000000000000a0 + lVar17;\n                }\n                else {\n                  uVar25 = (uVar23 & 0xffffffff) + lStack0000000000000088;\n                  if (uVar25 < uVar28) {\n                    pcVar35 = (char *)((long)__ptr_00 + uVar25);\n                    pcStack0000000000000090 = (char *)0x0;\n                    while( true ) {\n                      sVar20 = strlen(pcVar35);\n                      if (((sVar20 == 0) || (pcVar30 = pcVar35 + (sVar20 - 1), *pcVar30 != '\\\\')) ||\n                         ((ulong)((long)__ptr + lVar27) < (long)pvVar39 + 0x10U)) goto LAB_001077fb;\n                      *pcVar30 = '\\0';\n                      pvVar39 = (void *)((long)pvVar39 + 0xc);\n                      iVar12 = (**(code **)(unaff_R14[1] + 0x40))(pvVar39);\n                      uVar23 = (ulong)(uint)(iVar12 + (int)lStack0000000000000088);\n                      if (uVar28 <= uVar23) break;\n                      pcVar35 = (char *)concat(pcVar35,(long)__ptr_00 + uVar23,0);\n                      *pcVar30 = '\\\\';\n                      free(pcStack0000000000000090);\n                      pcStack0000000000000090 = pcVar35;\n                    }\n                    uVar19 = *unaff_R14;\n                    pcVar30 = (char *)dcgettext(0,\"%s: %s: stab entry %ld is corrupt\\n\",5);\n                    fprintf(_stderr,pcVar30,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc);\nLAB_001077fb:\n                    FUN_001088ae((ulong)bVar2,uVar14,lVar17,pcVar35);\n                    cVar10 = FUN_0011173a(param_10,pcStack0000000000000038,bVar2);\n                    if (cVar10 == '\\0') {\n                      FUN_00108b3e();\n                      FUN_00108863();\n                      free(pcStack0000000000000090);\n                      free(pcStack0000000000000038);\n                      free(__ptr);\n                      free(__ptr_00);\n                      goto LAB_00105981;\n                    }\n                  }\n                  else {\n                    uVar19 = *unaff_R14;\n                    pcVar35 = (char *)dcgettext(0,\n                                                \"%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\\n\"\n                                                ,5);\n                    fprintf(_stderr,pcVar35,uVar19,puVar3,((long)pvVar39 - (long)__ptr) / 0xc,\n                            uVar23 & 0xffffffff,(ulong)bVar2,((long)pvVar39 - (long)__ptr) % 0xc);\n                  }\n                }\n              }\n              FUN_00108863();\n              free(__ptr);\n              goto LAB_001058eb;\n            }\n          }\n          free(__ptr_00);\n          free(__ptr);\n        }\n        goto LAB_00105981;\n      }\nLAB_001058eb:\n      ppuVar40 = ppuVar40 + 2;\n    } while (ppuVar40 != (undefined **)&DAT_00125c90);\n    if ((pcStack0000000000000038 != (char *)0x0) && (cVar10 = FUN_0010c892(), cVar10 == '\\0')) {\nLAB_00105981:\n      free(param_10);\n      goto LAB_00105588;\n    }\n    if (*(int *)(unaff_R14[1] + 8) == 1) {\n      lVar27 = 0;\n      for (plVar16 = plVar6; plVar16 < plVar6 + param_8; plVar16 = plVar16 + 1) {\n        (**(code **)(unaff_R14[1] + 0x218))();\n        if (cStack0000000000000148 == '-') {\n          if (((lVar27 == 0) && (lVar27 = FUN_00112894(), lVar27 == 0)) ||\n             ((in_stack_00000150 == (char *)0x0 || (*in_stack_00000150 == '\\0'))))\n          goto LAB_00105981;\n          pcVar35 = (char *)0x0;\n          pcVar30 = in_stack_00000150;\n          while (((*pcVar30 != '\\0' && (sVar20 = strlen(pcVar30), pcVar30[sVar20 - 1] == '\\\\')) &&\n                 (plVar16 + 1 < plVar6 + param_8))) {\n            pcVar22 = (char *)xstrdup(pcVar30);\n            sVar20 = strlen(pcVar22);\n            pcVar22[sVar20 - 1] = '\\0';\n            pcVar30 = (char *)concat(pcVar22,*(undefined8 *)(plVar16[1] + 8),0);\n            free(pcVar22);\n            free(pcVar35);\n            plVar16 = plVar16 + 1;\n            pcVar35 = pcVar30;\n          }\n          FUN_001088ae(uStack0000000000000158,(int)sStack000000000000015a,param_13,pcVar30);\n          param_9 = FUN_0011173a(param_10,lVar27,uStack0000000000000158);\n          if (param_9 == '\\0') {\n            FUN_00108b3e();\n            FUN_00108863();\n            goto LAB_00105981;\n          }\n        }\n      }\n      FUN_00108863();\n      if ((lVar27 != 0) && (cVar10 = FUN_0010c892(), cVar10 == '\\0')) goto LAB_00105981;\n    }\n    if (param_9 == '\\0') {\n      if ((*(int *)(unaff_R14[1] + 8) == 2) && (param_8 != 0)) {\n        param_13 = (char *)0x0;\n        in_stack_000000c0 = plVar6;\n        in_stack_000000d0 = 0;\n        in_stack_000000d8 = 0;\n        puVar31 = (undefined8 *)&stack0x00000148;\n        for (lVar27 = 0x22; lVar27 != 0; lVar27 = lVar27 + -1) {\n          *(undefined4 *)puVar31 = 0;\n          puVar31 = (undefined8 *)((long)puVar31 + (ulong)bVar42 * -8 + 4);\n        }\n        cVar10 = '\\0';\n        _uStack0000000000000048 = (int *)0x0;\n        pcStack0000000000000038 = (char *)0x0;\n        pcStack0000000000000090 = (char *)0xffffffffffffffff;\n        in_stack_000000c8 = param_8;\nswitchD_00106e1a_caseD_68:\n        do {\n          while( true ) {\n            if ((long)param_8 <= in_stack_000000d0) goto LAB_00105590;\n            lVar27 = plVar6[in_stack_000000d0];\n            cVar9 = bfd_coff_get_syment();\n            lVar17 = in_stack_000000d8;\n            if (cVar9 == '\\0') {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_syment failed: %s\";\n              goto LAB_00105968;\n            }\n            pcVar35 = *(char **)(lVar27 + 8);\n            in_stack_000000d0 = in_stack_000000d0 + 1;\n            in_stack_000000d8 = (ulong)bStack0000000000000101 + 1 + in_stack_000000d8;\n            if ((bStack0000000000000101 != 0) && (cVar9 = bfd_coff_get_auxent(), cVar9 == '\\0')) {\n              uVar14 = bfd_get_error();\n              bfd_errmsg(uVar14);\n              pcVar35 = \"bfd_coff_get_auxent failed: %s\";\n              goto LAB_00105968;\n            }\n            if (pcStack0000000000000090 != (char *)lVar17) break;\n            if (bStack0000000000000100 != 0x67) {\n              cVar9 = FUN_0010bbd3(param_10);\n              if (cVar9 != '\\0') break;\n              goto LAB_00105981;\n            }\nswitchD_00106e1a_caseD_67:\n            pcStack0000000000000090 = (char *)in_stack_000000f0;\n            cVar9 = FUN_0010bbd3(param_10);\n            if (cVar9 == '\\0') goto LAB_00105981;\n          }\n          if ((char)bStack0000000000000100 < '\\0') {\n            if (bStack0000000000000100 == 0xff) goto switchD_00106e1a_caseD_68;\nLAB_0010700a:\n            lVar24 = FUN_0010dac0();\n            if (lVar24 == 0) break;\n            cVar9 = FUN_00112a33(&stack0x00000140,lVar27,lVar17);\n          }\n          else {\n            if (bStack0000000000000100 < 100) {\n              switch(bStack0000000000000100) {\n              case 3:\n                if (in_stack_000000f8._6_2_ == 0) goto switchD_00106e1a_caseD_68;\n              case 2:\nswitchD_00106e1a_caseD_7f:\n                if ((ulong)((uint)in_stack_000000f8._6_2_ & *(uint *)(unaff_R14[0x22] + 0x40)) !=\n                    2L << ((byte)*(undefined4 *)(unaff_R14[0x22] + 0x3c) & 0x3f)) goto LAB_0010700a;\n                _uStack0000000000000048 = (int *)(**(code **)(unaff_R14[1] + 0x238))();\n                pcStack0000000000000038 = pcVar35;\n                goto switchD_00106e1a_caseD_68;\n              default:\n                goto LAB_0010700a;\n              case 5:\n              case 7:\n              case 0xe:\n                goto switchD_00106e1a_caseD_68;\n              }\n            }\n            switch(bStack0000000000000100) {\n            case 100:\n              iVar12 = strcmp(pcVar35,\".bb\");\n              if (iVar12 == 0) {\n                cVar9 = FUN_0010be88(param_10);\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".eb\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                cVar9 = FUN_0010bf20(param_10);\n              }\n              break;\n            case 0x65:\n              iVar12 = strcmp(pcVar35,\".bf\");\n              if (iVar12 == 0) {\n                if (pcStack0000000000000038 != (char *)0x0) {\n                  lVar17 = FUN_0010dac0();\n                  if ((lVar17 == 0) || (cVar10 = FUN_0010bc80(param_10), cVar10 == '\\0'))\n                  goto LAB_00105981;\n                  if (_uStack0000000000000048 != (int *)0x0) {\n                    iVar12 = 0;\n                    if (bStack0000000000000101 != 0) {\n                      iVar12 = in_stack_00000118 - 1;\n                    }\n                    lVar27 = *(long *)(*(long *)(lVar27 + 0x20) + 0x30);\n                    while( true ) {\n                      iVar33 = _uStack0000000000000048[4];\n                      if (iVar33 == 0) break;\n                      cVar9 = FUN_0010bf86(param_10,iVar12 + iVar33,\n                                           *(long *)(_uStack0000000000000048 + 6) + lVar27);\n                      _uStack0000000000000048 = _uStack0000000000000048 + 4;\n                      if (cVar9 == '\\0') goto LAB_00105981;\n                    }\n                  }\n                  _uStack0000000000000048 = (int *)0x0;\n                  pcStack0000000000000038 = (char *)0x0;\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: .bf without preceding function\";\n              }\n              else {\n                iVar12 = strcmp(pcVar35,\".ef\");\n                if (iVar12 != 0) goto switchD_00106e1a_caseD_68;\n                if (cVar10 != '\\0') {\n                  cVar10 = FUN_0010be1a(param_10);\n                  if (cVar10 == '\\0') goto LAB_00105981;\n                  cVar10 = '\\0';\n                  goto switchD_00106e1a_caseD_68;\n                }\n                pcVar35 = \"%ld: unexpected .ef\\n\";\n              }\n              uVar19 = dcgettext(0,pcVar35,5);\n              FUN_00119ed0(uVar19);\n              goto LAB_00105981;\n            default:\n              goto LAB_0010700a;\n            case 0x67:\n              goto switchD_00106e1a_caseD_67;\n            case 0x68:\n            case 0x69:\n            case 0x6a:\n              goto switchD_00106e1a_caseD_68;\n            case 0x7f:\n              goto switchD_00106e1a_caseD_7f;\n            }\n          }\n        } while (cVar9 != '\\0');\n      }\n      else {\n        pcVar35 = \"%s: no recognized debugging information\";\nLAB_00105968:\n        uVar19 = dcgettext(0,pcVar35,5);\n        FUN_00119ed0(uVar19);\n      }\n      goto LAB_00105981;\n    }\n  }\nLAB_00105590:\n  if (((*(uint *)(param_7 + 0x44) & 0x42) != 0) && ((*(uint *)(param_7 + 0x44) & 1) == 0)) {\n    if ((*(char *)(*(long *)(param_7 + 8) + 0x20) == '\\0') && (DAT_00127959 == '\\0')) {\n      if (param_8 != 0) {\n        plVar6 = DAT_001278d0 + param_8;\n        plVar16 = DAT_001278d0;\n        do {\n          uVar11 = *(uint *)(*plVar16 + 0x18);\n          if ((uVar11 & 0x1000000) != 0) {\n            *(uint *)(*plVar16 + 0x18) = uVar11 & 0xfeffffff;\n          }\n          plVar16 = plVar16 + 1;\n        } while (plVar6 != plVar16);\n      }\n    }\n    else {\n      for (lVar27 = *(long *)(param_7 + 0x90); lVar27 != 0; lVar27 = *(long *)(lVar27 + 8)) {\n        if (*(long *)(lVar27 + 0xe8) != 0) {\n          puVar1 = (uint *)(*(long *)(lVar27 + 0xe8) + 0x18);\n          *puVar1 = *puVar1 | 0x1000000;\n        }\n      }\n    }\n  }\n  if ((DAT_00127a48 == 2) || (DAT_00127a48 == 7)) {\nLAB_001059fe:\n    if (DAT_00127a48 == 7) {\nLAB_00105a3b:\n      plVar16 = (long *)xmalloc();\n      plVar6 = DAT_001278d0;\n      uStack0000000000000048 = *(uint *)((long)unaff_R14 + 0x44) & 0x42;\n      DAT_001278c8 = plVar16;\n      if (param_8 == 0) {\n        uVar28 = 0;\n      }\n      else {\n        uVar28 = 0;\n        _param_9 = 0;\n        do {\n          iVar12 = DAT_001279c0;\n          plVar4 = (long *)plVar6[_param_9];\n          pcVar5 = (code *)plVar4[4];\n          uVar11 = *(uint *)(plVar4 + 3);\n          pcVar35 = (char *)plVar4[1];\n          pcVar30 = pcVar35;\n          if (DAT_001279c8 != (undefined8 *)0x0) {\n            iVar33 = 0;\n            puVar31 = DAT_001279c8;\n            while ((iVar33 < iVar12 && (pcVar22 = (char *)puVar31[5], pcVar22 != (char *)0x0))) {\n              if (pcVar22 != \"\") {\n                iVar15 = strcmp(pcVar22,pcVar35);\n                if (iVar15 == 0) {\n                  free(pcVar22);\n                  uVar23 = uVar28 + 1;\n                  puVar31[5] = \"\";\n                  lVar27 = FUN_0011a2e0(puVar31);\n                  uVar19 = DAT_001278f0;\n                  plVar16[uVar28] = lVar27;\n                  lVar27 = htab_elements(uVar19);\n                  if ((lVar27 != 0) || (DAT_001278f8 != (char **)0x0)) goto LAB_001064eb;\n                  goto LAB_00105af8;\n                }\n                puVar31 = (undefined8 *)*puVar31;\n              }\n              iVar33 = iVar33 + 1;\n            }\n          }\n          lVar27 = htab_elements(DAT_001278f0);\n          uVar23 = uVar28;\n          if ((lVar27 != 0) || (DAT_001278f8 != (char **)0x0)) {\n            if (pcVar35 != (char *)0x0) {\nLAB_001064eb:\n              if (((*pcVar35 == '_') && (pcVar35[1] == '_')) &&\n                 (iVar12 = strcmp(pcVar35 + (pcVar35[2] == '_'),\"__gnu_lto_slim\"), iVar12 == 0)) {\n                uVar19 = dcgettext(0,\"redefining symbols does not work on LTO-compiled object files\"\n                                   ,5);\n                    \n                FUN_00119dd0(uVar19);\n              }\n            }\n            _cStack0000000000000148 = 0;\n            param_13 = pcVar35;\n            lVar27 = htab_find(DAT_001278f0);\n            if (((lVar27 == 0) || (pcVar30 = *(char **)(lVar27 + 8), pcVar35 == pcVar30)) &&\n               (pcVar30 = pcVar35, ppcVar38 = DAT_001278f8, (uVar11 & 0x100) != 0)) {\n              for (; ppcVar38 != (char **)0x0; ppcVar38 = (char **)ppcVar38[3]) {\n                iVar12 = strcmp(*ppcVar38,pcVar35);\n                if (iVar12 == 0) {\n                  pcVar30 = ppcVar38[1];\n                  break;\n                }\n              }\n            }\n            plVar4[1] = (long)pcVar30;\n            cVar10 = *pcVar30;\n            if (cVar10 != '\\0') goto LAB_00105b11;\nLAB_00106557:\n            pcVar35 = DAT_00127928;\n            if ((DAT_001279a8 != '\\0') && (*(char *)(*(long *)(param_7 + 8) + 0x1c) != '\\0')) {\n              lVar27 = unaff_R14[1];\n              cVar10 = '\\0';\n              goto LAB_0010668d;\n            }\n            goto joined_r0x00106565;\n          }\nLAB_00105af8:\n          cVar10 = *pcVar35;\n          if (cVar10 == '\\0') goto LAB_00106557;\nLAB_00105b11:\n          pcVar35 = DAT_00127928;\n          lVar27 = unaff_R14[1];\n          if (*(char *)(lVar27 + 0x1c) == cVar10) {\n            if (DAT_001279a8 == '\\0') {\n              if ((DAT_00127988 == '\\0') ||\n                 ((((uVar11 & 0x82) == 0 && (pcVar5 != bfd_map_over_sections)) &&\n                  ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)))) goto joined_r0x00106565;\nLAB_0010677d:\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              goto joined_r0x00106565;\n            }\n            cVar10 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            if (cVar10 == '\\0') goto LAB_0010677d;\n            if (DAT_00127928 != (char *)0x0) {\n              pcVar30 = pcVar30 + 1;\n              plVar4[1] = (long)pcVar30;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\nLAB_001066bc:\n              sVar20 = strlen(pcVar35);\n              pcVar35 = (char *)xmalloc(sVar20 + lVar27);\n              goto LAB_001066d0;\n            }\n            *pcVar30 = cVar10;\n            plVar4[1] = (long)pcVar30;\n            uVar28 = uVar23;\n          }\n          else {\n            if ((DAT_001279a8 == '\\0') || (*(char *)(*(long *)(param_7 + 8) + 0x1c) == '\\0')) {\njoined_r0x00106565:\n              uVar28 = uVar23;\n              if (pcVar35 == (char *)0x0) goto LAB_00105b32;\n              sVar20 = strlen(pcVar30);\n              sVar21 = strlen(pcVar35);\n              pcVar22 = (char *)xmalloc(sVar21 + sVar20 + 1);\n              pcVar35 = pcVar22;\n            }\n            else {\nLAB_0010668d:\n              pcVar35 = DAT_00127928;\n              if ((*(char *)(lVar27 + 0x1c) != '\\0') && (cVar10 != *(char *)(lVar27 + 0x1c)))\n              goto joined_r0x00106565;\n              sVar20 = strlen(pcVar30);\n              lVar27 = sVar20 + 2;\n              if (pcVar35 != (char *)0x0) goto LAB_001066bc;\n              pcVar35 = (char *)xmalloc(lVar27);\nLAB_001066d0:\n              pcVar22 = pcVar35 + 1;\n              *pcVar35 = *(char *)(*(long *)(param_7 + 8) + 0x1c);\n            }\n            __s = DAT_00127928;\n            if (DAT_00127928 != (char *)0x0) {\n              strcpy(pcVar22,DAT_00127928);\n              sVar20 = strlen(__s);\n              pcVar22 = pcVar22 + sVar20;\n            }\n            strcpy(pcVar22,pcVar30);\n            plVar4[1] = (long)pcVar35;\n            pcVar30 = pcVar35;\n            uVar28 = uVar23;\n          }\nLAB_00105b32:\n          if (DAT_00127a48 == 7) goto LAB_001067a8;\n          if (((uVar11 & 0x20) == 0) &&\n             (((uVar11 & 0x100) == 0 ||\n              ((*(byte *)(**(long **)(plVar4[4] + 0xf0) + 0x18) & 0x20) == 0)))) {\n            if (((uStack0000000000000048 == 0) &&\n                (((uVar11 & 0x82) != 0 || ((*(byte *)(plVar4[4] + 0x25) & 0x10) != 0)))) ||\n               (iVar12 = bfd_decode_symclass(plVar4), iVar12 == 0x49)) {\nLAB_00105be2:\n              if (DAT_001279ea == '\\0') {\n                lVar27 = htab_find();\n                if (lVar27 == 0) goto LAB_00105c07;\n              }\n              else {\n                _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n                param_13 = pcVar30;\n                htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n                if (cStack0000000000000148 == '\\0') goto LAB_00105c07;\n              }\n            }\n            else if ((((uVar11 & 0x82) == 0) && (pcVar5 != bfd_map_over_sections)) &&\n                    ((*(byte *)(plVar4[4] + 0x25) & 0x10) == 0)) {\n              if ((uVar11 & 4) == 0) {\n                if (((*(int *)(unaff_R14[1] + 8) != 2) ||\n                    (lVar27 = *(long *)(plVar4[4] + 0xd0), lVar27 == 0)) ||\n                   (*(long *)(lVar27 + 0x40) == 0)) {\n                  if ((DAT_00127a48 == 3) || (DAT_00127a44 == 2)) goto LAB_001067a8;\n                  if (DAT_00127a44 == 1) {\n                    cVar10 = bfd_is_local_label(unaff_R14);\n                    goto joined_r0x00106a11;\n                  }\n                }\n                goto LAB_00105be2;\n              }\n              cVar10 = DAT_001279a0;\n              if (1 < DAT_00127a48 - 2U) {\njoined_r0x00106a11:\n                if (cVar10 == '\\0') goto LAB_00105be2;\n              }\n            }\n            else if (DAT_00127a48 != 3) goto LAB_00105be2;\n            goto LAB_001067a8;\n          }\n          if (DAT_001279ea == '\\0') {\n            lVar27 = htab_find();\n            if (lVar27 != 0) {\nLAB_0010687f:\n              uVar19 = dcgettext(0,\"not stripping symbol `%s\\' because it is named in a relocation\",\n                                 5);\n              FUN_00119ed0(uVar19);\n              DAT_00127a40 = 1;\n            }\n          }\n          else {\n            _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n            param_13 = pcVar30;\n            htab_traverse(DAT_00127a18,FUN_0011a170,&stack0x00000140);\n            if (cStack0000000000000148 != '\\0') goto LAB_0010687f;\n          }\n          if ((uVar11 & 0x20) == 0) {\nLAB_00105c07:\n            if (DAT_001279ea != '\\0') {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              param_13 = pcVar30;\n              htab_traverse(DAT_00127a10,FUN_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_001067a8;\n              goto LAB_00105c2c;\n            }\n            lVar27 = htab_find();\n            if (lVar27 == 0) goto LAB_00105c2c;\nLAB_001067a8:\n            if ((DAT_00127a38 != '\\0') && ((uVar11 & 0x4000) != 0)) goto LAB_00105c2c;\n            if (DAT_001279ea == '\\0') {\n              lVar27 = htab_find();\n              if (lVar27 != 0) goto LAB_00105c2c;\n            }\n            else {\n              _cStack0000000000000148 = _cStack0000000000000148 & 0xffffffffffffff00;\n              param_13 = pcVar30;\n              htab_traverse(DAT_00127a28,FUN_0011a170,&stack0x00000140);\n              if (cStack0000000000000148 != '\\0') goto LAB_00105c2c;\n            }\n          }\n          else {\nLAB_00105c2c:\n            cVar10 = FUN_001159d0(plVar4[4]);\n            if (cVar10 == '\\0') {\n              if (((uVar11 & 0x800002) == 0) && (pcVar5 != bfd_map_over_sections)) {\nLAB_00105c5f:\n                if ((uVar11 & 0x82) != 0) {\n                  cVar10 = FUN_00115d70(pcVar30);\n                  if ((cVar10 == '\\0') &&\n                     ((lVar27 = htab_elements(DAT_001279f8), lVar27 == 0 ||\n                      (cVar10 = FUN_00115d70(pcVar30), cVar10 != '\\0')))) {\n                    if (((((DAT_00127958 == '\\0') ||\n                          (uVar13 = *(uint *)(plVar4 + 3), (uVar13 & 0x200000) != 0)) ||\n                         (lVar27 = *plVar4, lVar27 == 0)) ||\n                        ((*(int *)(*(long *)(lVar27 + 8) + 8) != 5 ||\n                         (*(long *)(lVar27 + 0x110) == 0)))) ||\n                       (1 < (*(byte *)((long)plVar4 + 0x49) & 3) - 1)) goto joined_r0x00105ca2;\n                  }\n                  else {\n                    uVar13 = *(uint *)(plVar4 + 3);\n                  }\n                  *(uint *)(plVar4 + 3) = uVar13 & 0xffffff7d | 1;\n                }\njoined_r0x00105ca2:\n                if (((uVar11 & 1) != 0) && (cVar10 = FUN_00115d70(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xfffffffe | 2;\n                }\n              }\n              else {\n                if ((DAT_001279e8 != '\\0') || (cVar10 = FUN_00115d70(pcVar30), cVar10 != '\\0')) {\n                  *(uint *)(plVar4 + 3) = *(uint *)(plVar4 + 3) & 0xff7ffffd | 0x80;\n                }\n                if (pcVar5 != bfd_map_over_sections) goto LAB_00105c5f;\n              }\n              plVar16[uVar28] = (long)plVar4;\n              uVar28 = uVar28 + 1;\n            }\n          }\n          _param_9 = _param_9 + 1;\n        } while (param_8 != _param_9);\n      }\n      if (DAT_001279c8 != (undefined8 *)0x0) {\n        puVar31 = DAT_001279c8;\n        iVar12 = DAT_001279c0;\n        for (lVar27 = 0; lVar27 < iVar12; lVar27 = lVar27 + 1) {\n          pcVar35 = (char *)puVar31[5];\n          if (pcVar35 == (char *)0x0) {\n            plVar6 = plVar16 + uVar28;\n            uVar28 = uVar28 + 1;\n            lVar17 = FUN_0011a2e0(puVar31,param_7);\n            *plVar6 = lVar17;\n            iVar12 = DAT_001279c0;\n          }\n          else if (pcVar35 != \"\") {\n            uVar19 = dcgettext(0,\"\\'before=%s\\' not found\",5);\n                    \n            FUN_00119dd0(uVar19,pcVar35);\n          }\n          puVar31 = (undefined8 *)*puVar31;\n        }\n      }\n      bVar41 = DAT_001279a0 == '\\0';\n      plVar16[uVar28] = 0;\n      if ((bVar41) || (param_10 == (undefined4 *)0x0)) {\nLAB_00105cfa:\n        param_8 = uVar28 & 0xffffffff;\n        goto LAB_00105710;\n      }\n      iVar12 = *(int *)(*(undefined8 **)(param_7 + 8) + 1);\n      if ((iVar12 == 5) || (iVar12 == 2)) {\n        in_stack_000000e0 = (void *)0x0;\n        cVar10 = FUN_0011378f(param_7,param_10,&stack0x000000c0,&stack0x00000110,&stack0x000000e0,\n                              &stack0x00000140);\n        if (cVar10 != '\\0') {\n          lVar27 = bfd_make_section_with_flags(param_7,\".stab\",0x2108);\n          lVar17 = bfd_make_section_with_flags(param_7,\".stabstr\",0x2108);\n          if ((((lVar27 == 0) || (lVar17 == 0)) ||\n              (cVar10 = bfd_set_section_size(lVar27,in_stack_00000110), cVar10 == '\\0')) ||\n             (cVar10 = bfd_set_section_size(lVar17,param_13), cVar10 == '\\0')) {\n            pcVar35 = \"can\\'t create debugging section\";\n          }\n          else {\n            *(undefined4 *)(lVar27 + 0x7c) = 2;\n            *(undefined4 *)(lVar17 + 0x7c) = 0;\n            cVar10 = bfd_set_section_contents(param_7,lVar27,in_stack_000000c0,0,in_stack_00000110);\n            if ((cVar10 != '\\0') &&\n               (cVar10 = bfd_set_section_contents(param_7,lVar17,in_stack_000000e0,0,param_13),\n               cVar10 != '\\0')) {\n              free(param_10);\n              goto LAB_00105cfa;\n            }\n            pcVar35 = \"can\\'t set debugging section contents\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          FUN_001126c0(0,param_7,0,uVar19);\n          free(in_stack_000000e0);\n          free(param_10);\n          goto LAB_00105d96;\n        }\n      }\n      else {\n        uVar19 = **(undefined8 **)(param_7 + 8);\n        uVar18 = dcgettext(0,\"don\\'t know how to write debugging information for %s\",5);\n        FUN_001126c0(0,param_7,0,uVar18,uVar19);\n      }\n      free(param_10);\n    }\n    else {\nLAB_00105a07:\n      bfd_set_error(0);\n      bfd_map_over_sections();\n      iVar12 = bfd_get_error();\n      if (iVar12 == 0) goto LAB_00105a3b;\n    }\nLAB_00105d96:\n    DAT_00127a40 = 1;\n  }\n  else {\n    if ((DAT_00127a48 - 3U < 4) || ((DAT_00127a44 != 0 || (DAT_00127958 != '\\0'))))\n    goto LAB_00105a07;\n    lVar27 = htab_elements(DAT_00127a18);\n    if (((lVar27 != 0) ||\n        (((((((lVar27 = htab_elements(DAT_00127a28), lVar27 != 0 ||\n              (lVar27 = htab_elements(DAT_00127a08), lVar27 != 0)) ||\n             (lVar27 = htab_elements(DAT_00127a00), lVar27 != 0)) ||\n            ((lVar27 = htab_elements(DAT_001279f8), lVar27 != 0 ||\n             (lVar27 = htab_elements(DAT_001279f0), lVar27 != 0)))) ||\n           (lVar27 = htab_elements(DAT_001278f0), lVar27 != 0)) ||\n          (((DAT_00127928 != (char *)0x0 || (DAT_001278d8 != '\\0')) ||\n           ((DAT_00127a39 != '\\0' ||\n            (((DAT_001279a0 != '\\0' || (DAT_001279a8 != '\\0')) || (DAT_00127988 != '\\0')))))))) ||\n         ((DAT_001278f8 != (char **)0x0 || (DAT_001279e8 != '\\0')))))) || (DAT_001279c0 != 0))\n    goto LAB_001059fe;\nLAB_00105710:\n    bfd_set_symtab(param_7,DAT_001278c8,param_8 & 0xffffffff);\n    bfd_map_over_sections(unaff_R14,FUN_00115dc0,param_7);\n    bfd_map_over_sections(unaff_R14,FUN_00116110,param_7);\n    for (puVar31 = DAT_001279e0; puVar37 = DAT_001279d8, puVar31 != (undefined8 *)0x0;\n        puVar31 = (undefined8 *)*puVar31) {\n      cVar10 = bfd_set_section_contents(param_7,puVar31[5],puVar31[4],0,puVar31[3]);\n      if (cVar10 == '\\0') {\n        FUN_001126c0(0,param_7,puVar31[5],0);\n        return 0;\n      }\n    }\n    for (; puVar37 != (undefined8 *)0x0; puVar37 = (undefined8 *)*puVar37) {\n      uVar19 = *(undefined8 *)(puVar37[5] + 0x60);\n      cVar10 = bfd_set_section_contents(param_7,uVar19,puVar37[4],0,puVar37[3]);\n      if (cVar10 == '\\0') {\n        FUN_001126c0(0,param_7,uVar19,0);\n        return 0;\n      }\n    }\n    if (__ptr_01 == (long **)0x0) {\n      if ((DAT_00127a20 != '\\0') && (_DAT_001264c0 == 0)) {\n        uVar19 = *unaff_R14;\n        uVar18 = dcgettext(0,\"%s: Could not find any mergeable note sections\",5);\n        FUN_00119ed0(uVar18,uVar19);\n      }\n    }\n    else {\n      pplVar34 = (long **)0x0;\n      for (puVar31 = *(undefined8 **)(param_7 + 0x90); puVar31 != (undefined8 *)0x0;\n          puVar31 = (undefined8 *)puVar31[1]) {\n        if (((DAT_00127a20 != '\\0') && (*(int *)(*(long *)(param_7 + 8) + 8) == 5)) &&\n           ((*(int *)(puVar31[0x1a] + 4) == 7 &&\n            (cVar10 = FUN_00113fb0(*puVar31,\".gnu.build.attributes\"), cVar10 != '\\0')))) {\n          if (pplVar34 == (long **)0x0) {\n            pplVar34 = __ptr_01;\n          }\n          pplVar29 = __ptr_01;\n          if ((undefined8 *)(*pplVar34)[0xc] == puVar31) {\nLAB_0010625f:\n            pcVar35 = \"error: failed to merge notes\";\n            if (pplVar34[1] != (long *)0x0) {\n              cVar10 = bfd_set_section_contents(param_7,puVar31,pplVar34[1],0,pplVar34[2]);\n              if (cVar10 == '\\0') {\n                uVar19 = dcgettext(0,\"error: failed to copy merged notes into output\",5);\n                FUN_001126c0(0,param_7,puVar31,uVar19);\n                return 0;\n              }\n              pplVar34 = (long **)pplVar34[3];\n              goto LAB_001061be;\n            }\n          }\n          else {\n            do {\n              pplVar34 = pplVar29;\n              if ((undefined8 *)(*pplVar29)[0xc] == puVar31) goto LAB_0010625f;\n              pplVar34 = (long **)pplVar29[3];\n              pplVar29 = pplVar34;\n            } while (pplVar34 != (long **)0x0);\n            pcVar35 = \"error: failed to locate merged notes\";\n          }\n          uVar19 = dcgettext(0,pcVar35,5);\n          FUN_001126c0(0,param_7,puVar31,uVar19);\n        }\nLAB_001061be:\n      }\n      do {\n        pplVar34 = (long **)__ptr_01[3];\n        free(__ptr_01[1]);\n        free(__ptr_01);\n        __ptr_01 = pplVar34;\n      } while (pplVar34 != (long **)0x0);\n    }\n    if ((DAT_00127a30 == 0) ||\n       (cVar10 = bfd_fill_in_gnu_debuglink_section(param_7,param_12), lVar27 = DAT_00127a30,\n       cVar10 != '\\0')) {\n      uVar11 = (**(code **)(*(long *)(param_7 + 8) + 0x140))(unaff_R14);\n      uVar28 = (ulong)uVar11;\n      if ((char)uVar11 != '\\0') {\n        if (DAT_00127930 == 0) {\n          return uVar28;\n        }\n        cVar10 = bfd_alt_mach_code(param_7,DAT_00127930 & 0xffffffff);\n        uVar23 = DAT_00127930;\n        if (cVar10 == '\\0') {\n          uVar19 = dcgettext(0,\"this target does not support %lu alternative machine codes\",5);\n          FUN_00119ed0(uVar19,uVar23);\n          if (*(int *)(*(long *)(param_7 + 8) + 8) == 5) {\n            uVar19 = dcgettext(0,\"treating that number as an absolute e_machine value instead\",5);\n            FUN_00119ed0(uVar19);\n            *(short *)(*(long *)(param_7 + 0x110) + 0x3a) = (short)DAT_00127930;\n            return uVar28;\n          }\n          uVar19 = dcgettext(0,\"ignoring the alternative value\",5);\n          FUN_00119ed0(uVar19);\n          return uVar28;\n        }\n        return uVar28;\n      }\n      uVar19 = dcgettext(0,\"error copying private BFD data\",5);\n      FUN_001126c0(0,param_7,0,uVar19);\n    }\n    else {\n      uVar19 = dcgettext(0,\"cannot fill debug link section `%s\\'\",5);\n      FUN_001126c0(0,param_7,0,uVar19,lVar27);\n    }\n  }\n  return 0;\nLAB_00115187:\n  if ((((*(int *)(unaff_R14[1] + 8) == 5) && (*(int *)((long)pplVar34[0x1a] + 4) == 7)) &&\n      (cVar10 = FUN_00113fb0(*pplVar34), cVar10 != '\\0')) &&\n     ((pplVar34[0xc] != (long *)0x0 && (plVar6 = pplVar34[8], plVar6 != (long *)0x0)))) {\n    pplVar29 = (long **)xmalloc(0x20);\n    pplVar29[1] = (long *)0x0;\n    cVar10 = bfd_get_full_section_contents();\n    if (cVar10 == '\\0') {\n      dcgettext(0,\"warning: could not load note section\",5);\n      FUN_001126c0(0);\n      free(pplVar29);\n    }\n    else {\n      plVar16 = (long *)FUN_001163d0();\n      pplVar29[2] = plVar16;\n      if ((plVar16 == plVar6) || (cVar10 = bfd_set_section_size(pplVar34[0xc]), cVar10 != '\\0')) {\n        pplVar29[3] = (long *)__ptr_01;\n        *pplVar29 = (long *)pplVar34;\n        __ptr_01 = pplVar29;\n      }\n      else {\n        dcgettext(0,\"warning: failed to set merged notes size\",5);\n        FUN_001126c0(0,param_7,pplVar34);\n        free(pplVar29[1]);\n        free(pplVar29);\n      }\n    }\n  }\n  pplVar34 = (long **)pplVar34[1];\n  puVar31 = DAT_001279d0;\n  if (pplVar34 == (long **)0x0) goto joined_r0x001151c7;\n  goto LAB_001151ab;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "dcgettext",
                "FUN_001163d0",
                "bfd_set_section_size",
                "fwrite",
                "strerror",
                "FUN_001126c0",
                "FUN_00105828",
                "bfd_get_full_section_contents",
                "bfd_set_format",
                "FUN_0010551d",
                "bfd_map_over_sections",
                "FUN_0010554f",
                "bfd_get_arch",
                "FUN_00114190",
                "FUN_00115f30",
                "xmalloc",
                "FUN_00119ed0",
                "FUN_00115530",
                "bfd_malloc_and_get_section",
                "bfd_get_section_by_name",
                "bfd_make_section_with_flags",
                "bfd_create_gnu_debuglink_section",
                "fopen",
                "free",
                "__errno_location",
                "fclose"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107880",
            "calling": [
                "FUN_001152b6"
            ],
            "imported": false,
            "current_name": "FUNC_00107880"
        },
        "FUN_0011a350": {
            "renaming": {
                "FUN_0011a350": "set_file_modified_time_0011a350",
                "param_1": "filePath",
                "param_2": "fileInfoPtr",
                "iVar1": "result",
                "piVar2": "errNumPtr",
                "pcVar3": "errMsg",
                "uVar4": "translatedErrMsg",
                "local_38": "modificationTime",
                "uStack_34": "local_4C",
                "uStack_30": "local_50",
                "uStack_2c": "local_54",
                "local_28": "filePermissions",
                "uStack_24": "local_5C",
                "uStack_20": "local_60",
                "uStack_1c": "local_64"
            },
            "code": "\nvoid setFileModifiedTime_0011a350(char *filePath,long fileInfoPtr)\n\n{\n  int result;\n  int *errNumPtr;\n  char *errMsg;\n  undefined8 translatedErrMsg;\n  undefined4 modificationTime;\n  undefined4 local_4C;\n  undefined4 local_50;\n  undefined4 local_54;\n  undefined4 filePermissions;\n  undefined4 local_5C;\n  undefined4 local_60;\n  undefined4 local_64;\n  \n  filePermissions = *(undefined4 *)(fileInfoPtr + 0x58);\n  local_5C = *(undefined4 *)(fileInfoPtr + 0x5c);\n  local_60 = *(undefined4 *)(fileInfoPtr + 0x60);\n  local_64 = *(undefined4 *)(fileInfoPtr + 100);\n  modificationTime = *(undefined4 *)(fileInfoPtr + 0x48);\n  local_4C = *(undefined4 *)(fileInfoPtr + 0x4c);\n  local_50 = *(undefined4 *)(fileInfoPtr + 0x50);\n  local_54 = *(undefined4 *)(fileInfoPtr + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&modificationTime,0);\n  if (result != 0) {\n    errNumPtr = __errno_location();\n    errMsg = strerror(*errNumPtr);\n    translatedErrMsg = dcgettext(0,\"%s: cannot set time: %s\",5);\n    FUN_00119ed0(translatedErrMsg,filePath,errMsg);\n  }\n  return;\n}\n\n",
            "called": [
                "utimensat",
                "FUN_0010882c"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a350",
            "calling": [
                "FUN_00108200",
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "set_file_modified_time_0011a350"
        },
        "FUN_0011a110": {
            "renaming": {
                "FUN_0011a110": "print_error_message_0011a110",
                "param_1": "errorType",
                "iVar1": "error",
                "uVar2": "errorMessage",
                "in_R10": "additionalInfo"
            },
            "code": "\n\n\nvoid printErrorMessage_0011a110(long errorType)\n\n{\n  int error;\n  undefined8 errorMessage;\n  undefined8 additionalInfo;\n  \n  error = bfd_get_error();\n  if (error == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(error);\n  }\n  fflush(_stdout);\n  if (errorType != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_00127600,errorType,errorMessage,additionalInfo);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_00127600,errorMessage,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "FUN_0010871c",
                "bfd_get_error",
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a110",
            "calling": [
                "FUN_00115dc0",
                "FUN_001083b7",
                "FUN_00116030",
                "FUN_00104ea2",
                "FUN_00119f70",
                "FUN_001053d5"
            ],
            "imported": false,
            "current_name": "print_error_message_0011a110"
        },
        "FUN_0010e2f0": {
            "renaming": {
                "FUN_0010e2f0": "process_hash_lookup_0010e2f0",
                "param_1": "hashTable",
                "param_2": "undefinedParam",
                "param_3": "paramSize",
                "param_4": "paramValue",
                "param_5": "string",
                "lVar1": "tempVar1",
                "uVar2": "errorType",
                "lVar3": "tempVar2",
                "uVar4": "errorMsg",
                "uVar5": "translatedMsg",
                "sVar6": "stringLength",
                "lVar7": "hashTableEntry",
                "local_44": "localVar1",
                "uStack_40": "stackVar1",
                "uStack_3f": "stackVar2",
                "uStack_3e": "stackVar3",
                "local_3c": "localVar2"
            },
            "code": "\nundefined8\nprocessHashLookup_0010e2f0(long *hashTable,undefined undefinedParam,int paramSize,undefined8 paramValue,char *string)\n\n{\n  long tempVar1;\n  undefined4 errorType;\n  long tempVar2;\n  undefined8 errorMsg;\n  undefined8 translatedMsg;\n  size_t stringLength;\n  long hashTableEntry;\n  undefined4 localVar1;\n  undefined stackVar1;\n  undefined stackVar2;\n  undefined2 stackVar3;\n  undefined4 localVar2 [3];\n  \n  if (string == (char *)0x0) {\n    hashTableEntry = 0;\n  }\n  else {\n    tempVar2 = bfd_hash_lookup(hashTable + 7,string,1,1);\n    if (tempVar2 == 0) {\n      errorType = bfd_get_error();\n      errorMsg = bfd_errmsg(errorType);\n      translatedMsg = dcgettext(0,\"string_hash_lookup failed: %s\",5);\n      FUN_00119ed0(translatedMsg,errorMsg);\n      return 0;\n    }\n    hashTableEntry = *(long *)(tempVar2 + 0x20);\n    if (hashTableEntry == -1) {\n      hashTableEntry = hashTable[6];\n      tempVar1 = hashTable[5];\n      *(long *)(tempVar2 + 0x20) = hashTableEntry;\n      if (tempVar1 == 0) {\n        hashTable[4] = tempVar2;\n      }\n      else {\n        *(long *)(tempVar1 + 0x18) = tempVar2;\n      }\n      hashTable[5] = tempVar2;\n      stringLength = strlen(string);\n      hashTable[6] = hashTableEntry + 1 + stringLength;\n    }\n  }\n  (**(code **)(*(long *)(*hashTable + 8) + 0x50))(hashTableEntry,&localVar1);\n  stackVar2 = 0;\n  stackVar1 = undefinedParam;\n  (**(code **)(*(long *)(*hashTable + 8) + 0x68))((long)paramSize,&stackVar3);\n  (**(code **)(*(long *)(*hashTable + 8) + 0x50))(paramValue,localVar2);\n  if ((ulong)hashTable[3] < hashTable[2] + 0xcU) {\n    hashTable[3] = hashTable[3] * 2;\n    hashTableEntry = xrealloc(hashTable[1]);\n    hashTable[1] = hashTableEntry;\n  }\n  hashTableEntry = hashTable[2];\n  tempVar2 = hashTable[1];\n  *(ulong *)(tempVar2 + hashTableEntry) = CONCAT26(stackVar3,CONCAT15(stackVar2,CONCAT14(stackVar1,localVar1)));\n  *(undefined4 *)(tempVar2 + 8 + hashTableEntry) = localVar2[0];\n  hashTable[2] = hashTable[2] + 0xc;\n  return CONCAT71((int7)((ulong)hashTableEntry >> 8),1);\n}\n\n",
            "called": [
                "dcgettext",
                "bfd_get_error",
                "xrealloc",
                "FUN_00119ed0",
                "bfd_hash_lookup",
                "bfd_errmsg",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2f0",
            "calling": [
                "FUN_0010e453",
                "FUN_0010ebb0",
                "FUN_0010edb4",
                "FUN_0010e842",
                "FUN_0010ed2c",
                "FUN_0010e439",
                "FUN_0010e6a8",
                "FUN_0010e5db",
                "FUN_0010e918",
                "FUN_0011378f",
                "FUN_0010eafe",
                "FUN_0010e7c2",
                "FUN_0010ec73",
                "FUN_0010e9a0",
                "FUN_0010e8a9"
            ],
            "imported": false,
            "current_name": "process_hash_lookup_0010e2f0"
        },
        "FUN_00113fe0": {
            "renaming": {
                "FUN_00113fe0": "parse_section_flags_00113fe0",
                "param_1": "sectionFlags",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "result",
                "uVar2": "msg",
                "pcVar3": "commaPtr",
                "pcVar4": "nextSectionFlag",
                "sVar5": "sectionFlagLength",
                "iVar6": "sectionFlagIndex",
                "uVar7": "flagValue",
                "auVar8": "resultStruct"
            },
            "code": "\nundefined  [16] parseSectionFlags_00113fe0(char *sectionFlags,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  int result;\n  undefined8 msg;\n  char *commaPtr;\n  char *nextSectionFlag;\n  size_t sectionFlagLength;\n  int sectionFlagIndex;\n  uint flagValue;\n  undefined resultStruct [16];\n  \n  flagValue = 0;\n  do {\n    commaPtr = strchr(sectionFlags,0x2c);\n    if (commaPtr == (char *)0x0) {\n      sectionFlagLength = strlen(sectionFlags);\n      sectionFlagIndex = (int)sectionFlagLength;\n      nextSectionFlag = (char *)0x0;\n    }\n    else {\n      nextSectionFlag = commaPtr + 1;\n      sectionFlagIndex = (int)commaPtr - (int)sectionFlags;\n    }\n    sectionFlagLength = (size_t)sectionFlagIndex;\n    result = strncasecmp(\"alloc\",sectionFlags,sectionFlagLength);\n    if (result == 0) {\n      flagValue = flagValue | 1;\n    }\n    else {\n      result = strncasecmp(\"load\",sectionFlags,sectionFlagLength);\n      if (result == 0) {\n        flagValue = flagValue | 2;\n      }\n      else {\n        result = strncasecmp(\"noload\",sectionFlags,sectionFlagLength);\n        if (result == 0) {\n          flagValue = flagValue | 0x200;\n        }\n        else {\n          result = strncasecmp(\"readonly\",sectionFlags,sectionFlagLength);\n          if (result == 0) {\n            flagValue = flagValue | 8;\n          }\n          else {\n            result = strncasecmp(\"debug\",sectionFlags,sectionFlagLength);\n            if (result == 0) {\n              flagValue = flagValue | 0x2000;\n            }\n            else {\n              result = strncasecmp(\"code\",sectionFlags,sectionFlagLength);\n              if (result == 0) {\n                flagValue = flagValue | 0x10;\n              }\n              else {\n                result = strncasecmp(\"data\",sectionFlags,sectionFlagLength);\n                if (result == 0) {\n                  flagValue = flagValue | 0x20;\n                }\n                else {\n                  result = strncasecmp(\"rom\",sectionFlags,sectionFlagLength);\n                  if (result == 0) {\n                    flagValue = flagValue | 0x40;\n                  }\n                  else {\n                    result = strncasecmp(\"exclude\",sectionFlags,sectionFlagLength);\n                    if (result == 0) {\n                      flagValue = flagValue | 0x8000;\n                    }\n                    else {\n                      result = strncasecmp(\"share\",sectionFlags,sectionFlagLength);\n                      if (result == 0) {\n                        flagValue = flagValue | 0x8000000;\n                      }\n                      else {\n                        result = strncasecmp(\"contents\",sectionFlags,sectionFlagLength);\n                        if (result == 0) {\n                          flagValue = flagValue | 0x100;\n                        }\n                        else {\n                          result = strncasecmp(\"merge\",sectionFlags,sectionFlagLength);\n                          if (result == 0) {\n                            flagValue = flagValue | 0x800000;\n                          }\n                          else {\n                            result = strncasecmp(\"strings\",sectionFlags,sectionFlagLength);\n                            if (result != 0) {\n                              commaPtr = (char *)xmalloc((long)(sectionFlagIndex + 1));\n                              strncpy(commaPtr,sectionFlags,sectionFlagLength);\n                              commaPtr[sectionFlagLength] = '\\0';\n                              msg = dcgettext(0,\"unrecognized section flag `%s\\'\",5);\n                              FUN_00119ed0(msg,commaPtr);\n                              msg = dcgettext(0,\"supported flags: %s\",5);\n                    \n                              FUN_00119dd0(msg,\n                                           \"alloc, load, noload, readonly, debug, code, data, rom, exclude, share, contents, merge, strings\"\n                                          );\n                            }\n                            flagValue = flagValue | 0x1000000;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    sectionFlags = nextSectionFlag;\n  } while (nextSectionFlag != (char *)0x0);\n  resultStruct._4_4_ = 0;\n  resultStruct._0_4_ = flagValue;\n  resultStruct._8_8_ = param4;\n  return resultStruct;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113fe0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "parse_section_flags_00113fe0"
        },
        "textdomain": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041d0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "textdomain"
        },
        "bfd_set_start_address": {
            "renaming": {},
            "code": "\nvoid bfd_set_start_address(void)\n\n{\n  bfd_set_start_address();\n  return;\n}\n\n",
            "called": [
                "bfd_set_start_address"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104860",
            "calling": [
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "bfd_set_start_address"
        },
        "FUN_001125fa": {
            "renaming": {
                "FUN_001125fa": "format_archive_filename_001125fa",
                "param_1": "archiveFilePath",
                "__s": "formattedFilename",
                "ppcVar2": "archiveInfo",
                "sVar3": "archivePathLength",
                "sVar4": "originalFilenameLength",
                "uVar1": "formattedFilenameLength"
            },
            "code": "\nchar * formatArchiveFilename_001125fa(char **archiveFilePath)\n\n{\n  ulong formattedFilenameLength;\n  char **archiveInfo;\n  size_t archivePathLength;\n  size_t originalFilenameLength;\n  char *formattedFilename;\n  \n  if (archiveFilePath == (char **)0x0) {\n                    \n    __assert_fail(\"abfd != NULL\",\"../../binutils/bucomm.c\",0x298,\"bfd_get_archive_filename\");\n  }\n  archiveInfo = (char **)archiveFilePath[0x1d];\n  formattedFilename = *archiveFilePath;\n  if ((archiveInfo != (char **)0x0) && ((*(byte *)((long)archiveInfo + 0x49) & 0x10) == 0)) {\n    archivePathLength = strlen(*archiveInfo);\n    originalFilenameLength = strlen(formattedFilename);\n    formattedFilenameLength = archivePathLength + 3 + originalFilenameLength;\n    if (DAT_00127a58 < formattedFilenameLength) {\n      if (DAT_00127a58 != 0) {\n        free(DAT_00127a50);\n      }\n      DAT_00127a58 = (formattedFilenameLength >> 1) + formattedFilenameLength;\n      DAT_00127a50 = (char *)xmalloc();\n    }\n    sprintf(DAT_00127a50,\"%s(%s)\",*(undefined8 *)archiveFilePath[0x1d],*archiveFilePath);\n    formattedFilename = DAT_00127a50;\n  }\n  return formattedFilename;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "sprintf",
                "__assert_fail",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001125fa",
            "calling": [
                "FUN_00104ea2",
                "FUN_001152b6",
                "FUN_001126c0",
                "FUN_00105828",
                "FUN_00114e50",
                "FUN_00107976"
            ],
            "imported": false,
            "current_name": "format_archive_filename_001125fa"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104160",
            "calling": [
                "FUN_00116b90",
                "FUN_00114460",
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "bfd_check_format": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104810",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_check_format"
        },
        "strspn": {
            "renaming": {},
            "code": "\n\n\nsize_t strspn(char *__s,char *__accept)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strspn(__s,__accept);\n  return sVar1;\n}\n\n",
            "called": [
                "strspn"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001043e0",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "strspn"
        },
        "FUN_00108f05": {
            "renaming": {
                "FUN_00108f05": "get_return_value_00108f05"
            },
            "code": "\nundefined getReturnValue_00108f05(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108f05",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "get_return_value_00108f05"
        },
        "bfd_convert_section_setup": {
            "renaming": {},
            "code": "\nvoid bfd_convert_section_setup(void)\n\n{\n  bfd_convert_section_setup();\n  return;\n}\n\n",
            "called": [
                "bfd_convert_section_setup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040f0",
            "calling": [
                "FUN_00115530"
            ],
            "imported": false,
            "current_name": "bfd_convert_section_setup"
        },
        "FUN_00108863": {
            "renaming": {
                "FUN_00108863": "free_and_reset_pointers_00108863",
                "puVar1": "dataArrayPtr",
                "puVar2": "nextDataArrayPtr"
            },
            "code": "\nvoid freeAndResetPointers_00108863(void)\n\n{\n  undefined4 *dataArrayPtr;\n  undefined4 *nextDataArrayPtr;\n  \n  dataArrayPtr = (undefined4 *)&DAT_00127740;\n  do {\n    nextDataArrayPtr = dataArrayPtr + 6;\n    free(*(void **)(dataArrayPtr + 4));\n    *(undefined8 *)(dataArrayPtr + 4) = 0;\n    dataArrayPtr = nextDataArrayPtr;\n  } while (nextDataArrayPtr != &DAT_001278c0);\n  DAT_001278c0 = 0;\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108863",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "free_and_reset_pointers_00108863"
        },
        "FUN_00104020": {
            "renaming": {
                "FUN_00104020": "execute_external_code_00104020"
            },
            "code": "\nvoid execute_external_code_00104020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104020",
            "calling": [],
            "imported": false,
            "current_name": "execute_external_code_00104020"
        },
        "FUN_00108f08": {
            "renaming": {
                "FUN_00108f08": "find_source_file_00108f08",
                "param_1": "sourceFileData",
                "param_2": "filename",
                "iVar1": "comparisonResult",
                "uVar2": "success",
                "puVar3": "currentNode",
                "puVar4": "previousNode",
                "lVar5": "loopCounter",
                "puVar6": "listHead",
                "pcVar7": "sourceFilename",
                "puVar8": "newNode",
                "bVar9": "flag"
            },
            "code": "\n\n\nundefined8 findSourceFile_00108f08(long sourceFileData,char *filename)\n\n{\n  int comparisonResult;\n  undefined8 success;\n  undefined8 *currentNode;\n  undefined8 *previousNode;\n  long loopCounter;\n  undefined8 *listHead;\n  char *sourceFilename;\n  undefined8 *newNode;\n  byte flag;\n  \n  flag = 0;\n  sourceFilename = \"\";\n  if (filename != (char *)0x0) {\n    sourceFilename = filename;\n  }\n  if (*(long *)(sourceFileData + 8) == 0) {\n    success = dcgettext(0,\"debug_start_source: no debug_set_filename call\",5);\n    fprintf(_stderr,\"%s\\n\",success);\n    success = 0;\n  }\n  else {\n    for (currentNode = *(undefined8 **)(*(long *)(sourceFileData + 8) + 8); currentNode != (undefined8 *)0x0;\n        currentNode = (undefined8 *)*currentNode) {\n      comparisonResult = filename_cmp(currentNode[1],sourceFilename);\n      if (comparisonResult == 0) goto LAB_00108fad;\n    }\n    currentNode = (undefined8 *)xmalloc(0x18);\n    listHead = *(undefined8 **)(sourceFileData + 0x10);\n    newNode = currentNode;\n    for (loopCounter = 6; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *(undefined4 *)newNode = 0;\n      newNode = (undefined8 *)((long)newNode + (ulong)flag * -8 + 4);\n    }\n    currentNode[1] = sourceFilename;\n    newNode = (undefined8 *)*listHead;\n    while (previousNode = newNode, previousNode != (undefined8 *)0x0) {\n      listHead = previousNode;\n      newNode = (undefined8 *)*previousNode;\n    }\n    *listHead = currentNode;\nLAB_00108fad:\n    *(undefined8 **)(sourceFileData + 0x10) = currentNode;\n    success = 1;\n  }\n  return success;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc",
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108f08",
            "calling": [
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "find_source_file_00108f08"
        },
        "FUN_00114b84": {
            "renaming": {
                "FUN_00114b84": "remove_directory_00114b84",
                "param_9": "directoryPath"
            },
            "code": "\nvoid removeDirectory_00114b84(void)\n\n{\n  char *directoryPath;\n  \n  rmdir(directoryPath);\n  free(directoryPath);\n  return;\n}\n\n",
            "called": [
                "free",
                "rmdir"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114b84",
            "calling": [
                "FUN_00104ea2",
                "FUN_00104d25"
            ],
            "imported": false,
            "current_name": "remove_directory_00114b84"
        },
        "strnlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strnlen(char *__string,size_t __maxlen)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strnlen(__string,__maxlen);\n  return sVar1;\n}\n\n",
            "called": [
                "strnlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104380",
            "calling": [
                "FUN_0011a480"
            ],
            "imported": false,
            "current_name": "strnlen"
        },
        "FUN_00114190": {
            "renaming": {
                "FUN_00114190": "process_entries_00114190",
                "param_1": "entries",
                "param_2": "isMatchByFilename",
                "param_3": "flags",
                "uVar1": "flagsAndMatch",
                "plVar2": "currentEntry",
                "pplVar3": "prevEntry",
                "iVar4": "compareResult",
                "uVar5": "errorMessage",
                "pplVar6": "nextEntry",
                "pplVar7": "currentEntry",
                "pplVar8": "nextEntry"
            },
            "code": "\nlong ** processEntries_00114190(long *entries,char isMatchByFilename,uint flags)\n\n{\n  uint flagsAndMatch;\n  long *currentEntry;\n  long **prevEntry;\n  int compareResult;\n  undefined8 errorMessage;\n  long **nextEntry;\n  long **currentEntry;\n  long **nextEntry;\n  \n  currentEntry = DAT_00127900;\n  if (DAT_00127900 == (long **)0x0) {\n    if (isMatchByFilename == '\\0') {\n      return (long **)0x0;\n    }\n    goto LAB_001142a9;\n  }\n  if (isMatchByFilename == '\\0') {\n    if ((flags & *(uint *)((long)DAT_00127900 + 0x14)) == 0) {\nLAB_001141e5:\n      nextEntry = (long **)*currentEntry;\n      if (nextEntry == (long **)0x0) {\n        return (long **)0x0;\n      }\n      currentEntry = (long **)0x0;\n    }\n    else {\n      currentEntry = DAT_00127900[1];\n      if (*(char *)currentEntry == '!') {\n        compareResult = fnmatch((char *)((long)currentEntry + 1),(char *)entries,0);\n        nextEntry = currentEntry;\n        if (compareResult == 0) goto LAB_0011438e;\n        goto LAB_001141e5;\n      }\n      compareResult = fnmatch((char *)currentEntry,(char *)entries,0);\n      if (compareResult != 0) goto LAB_001141e5;\n      nextEntry = (long **)*currentEntry;\n      if (nextEntry == (long **)0x0) goto LAB_00114245;\n    }\n    if ((flags & *(uint *)((long)nextEntry + 0x14)) != 0) {\n      currentEntry = nextEntry[1];\n      if (*(char *)currentEntry == '!') {\n        compareResult = fnmatch((char *)((long)currentEntry + 1),(char *)entries,0);\n        if (compareResult == 0) {\nLAB_0011438e:\n          *(undefined *)(nextEntry + 2) = 1;\n          return (long **)0x0;\n        }\n      }\n      else {\n        compareResult = fnmatch((char *)currentEntry,(char *)entries,0);\n        if ((currentEntry == (long **)0x0) && (compareResult == 0)) {\n          nextEntry = (long **)*nextEntry;\n          currentEntry = nextEntry;\n          if (nextEntry == (long **)0x0) goto LAB_00114245;\n          goto LAB_00114288;\n        }\n      }\n    }\n    nextEntry = (long **)*nextEntry;\n    nextEntry = currentEntry;\n    if (nextEntry != (long **)0x0) goto LAB_00114288;\n  }\n  else {\n    compareResult = strcmp((char *)DAT_00127900[1],(char *)entries);\n    if (compareResult == 0) {\nLAB_001143cd:\n      flagsAndMatch = *(uint *)((long)currentEntry + 0x14);\n      if ((((flagsAndMatch & 1) != 0) && ((flags & 2) != 0)) ||\n         (((flags & 1) != 0 && ((flagsAndMatch & 2) != 0)))) {\n        errorMessage = dcgettext(0,\"error: %s both copied and removed\",5);\n                    \n        FUN_00119dd0(errorMessage,entries);\n      }\n      if ((((flagsAndMatch & 8) != 0) && ((flags & 0x10) != 0)) || ((flags & 0x18) == 0x18)) {\n        errorMessage = dcgettext(0,\"error: %s both sets and alters VMA\",5);\n                    \n        FUN_00119dd0(errorMessage,entries);\n      }\n      if ((((flagsAndMatch & 0x20) == 0) || ((flags & 0x40) == 0)) && ((flags & 0x60) != 0x60)) {\n        *(uint *)((long)currentEntry + 0x14) = flagsAndMatch | flags;\n        return currentEntry;\n      }\n      errorMessage = dcgettext(0,\"error: %s both sets and alters LMA\",5);\n                    \n      FUN_00119dd0(errorMessage,entries);\n    }\n    currentEntry = (long **)*currentEntry;\n    if (currentEntry == (long **)0x0) goto LAB_001142a9;\n    compareResult = strcmp((char *)currentEntry[1],(char *)entries);\n    if (compareResult == 0) goto LAB_001143cd;\n    nextEntry = (long **)*currentEntry;\n    nextEntry = (long **)0x0;\n    if (nextEntry == (long **)0x0) goto LAB_001142a9;\nLAB_00114288:\n    do {\n      currentEntry = nextEntry;\n      if (isMatchByFilename == '\\0') {\n        while (nextEntry = nextEntry, prevEntry = currentEntry, nextEntry = nextEntry,\n              (flags & *(uint *)((long)nextEntry + 0x14)) != 0) {\n          currentEntry = nextEntry[1];\n          if (*(char *)currentEntry == '!') {\n            compareResult = fnmatch((char *)((long)currentEntry + 1),(char *)entries,0);\n            if (compareResult == 0) goto LAB_0011438e;\n            nextEntry = (long **)*nextEntry;\n            if ((long **)*nextEntry == (long **)0x0) goto LAB_001142a1;\n          }\n          else {\n            compareResult = fnmatch((char *)currentEntry,(char *)entries,0);\n            if ((currentEntry == (long **)0x0) && (compareResult == 0)) {\n              currentEntry = nextEntry;\n              nextEntry = (long **)*nextEntry;\n              if ((long **)*nextEntry == (long **)0x0) goto LAB_00114245;\n            }\n            else {\n              nextEntry = (long **)*nextEntry;\n              if ((long **)*nextEntry == (long **)0x0) goto LAB_00114212;\n            }\n          }\n        }\n      }\n      else {\n        compareResult = strcmp((char *)nextEntry[1],(char *)entries);\n        prevEntry = nextEntry;\n        currentEntry = nextEntry;\n        if (compareResult == 0) goto LAB_001143cd;\n      }\n      nextEntry = prevEntry;\n      nextEntry = (long **)*nextEntry;\n      currentEntry = nextEntry;\n    } while (nextEntry != (long **)0x0);\nLAB_001142a1:\n    if (isMatchByFilename != '\\0') {\nLAB_001142a9:\n      nextEntry = (long **)xmalloc(0x30);\n      *(undefined (*) [16])(nextEntry + 3) = (undefined  [16])0x0;\n      *(undefined *)(nextEntry + 2) = 0;\n      *(uint *)((long)nextEntry + 0x14) = flags;\n      nextEntry[5] = (long *)0x0;\n      currentEntry = nextEntry;\n      *nextEntry = (long *)DAT_00127900;\n      DAT_00127900 = currentEntry;\n      nextEntry[1] = entries;\n      return nextEntry;\n    }\n  }\nLAB_00114212:\n  if (currentEntry == (long **)0x0) {\n    return (long **)0x0;\n  }\nLAB_00114245:\n  *(undefined *)(currentEntry + 2) = 1;\n  return currentEntry;\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "fnmatch",
                "strcmp",
                "FUN_00119dd0",
                "FUN_00104bba"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114190",
            "calling": [
                "FUN_00115b70",
                "FUN_00116b90",
                "FUN_00108072",
                "FUN_00115dc0",
                "FUN_00116110",
                "FUN_00107880",
                "FUN_00115530",
                "FUN_00114c20"
            ],
            "imported": false,
            "current_name": "process_entries_00114190"
        },
        "FUN_00116490": {
            "renaming": {
                "FUN_00116490": "extract_attributes_00116490",
                "param_1": "param1",
                "param_2": "attributeSize",
                "param_3": "attributeName",
                "param_4": "numAttributes",
                "uVar1": "tmp1",
                "uVar2": "tmp2",
                "uVar3": "tmp3",
                "bVar4": "flag",
                "puVar5": "ptr",
                "iVar6": "i",
                "lVar7": "length",
                "uVar8": "attributeOffset",
                "in_RAX": "version",
                "uVar9": "tmp4",
                "uVar10": "tmp5",
                "uVar11": "tmp6",
                "uVar12": "tmp7",
                "uVar13": "tmp8",
                "unaff_RBX": "totalSize",
                "unaff_RBP": "attributeValue",
                "puVar14": "attributeList",
                "puVar15": "ptr1",
                "cVar16": "char1",
                "puVar17": "ptr2",
                "puVar18": "ptr3",
                "unaff_R13": "attributeDescription",
                "puVar19": "attributePtr",
                "unaff_R12": "attributeHeader",
                "unaff_R14": "strings",
                "unaff_retaddr": "retAddress",
                "param_7": "resultSize",
                "param_8": "flag1",
                "param_9": "assignValue",
                "in_stack_00000020": "result",
                "in_stack_00000028": "sortedAttributes",
                "in_stack_00000030": "resultPtr",
                "in_stack_00000038": "flag2",
                "in_stack_00000040": "flag3",
                "in_stack_00000048": "warningMessage"
            },
            "code": "\nulong extractAttributes_00116490(undefined8 param1,ulong attributeSize,ulong attributeName,long numAttributes)\n\n{\n  undefined8 tmp1;\n  undefined8 tmp2;\n  ulong tmp3;\n  bool flag;\n  ulong *ptr;\n  int i;\n  long length;\n  undefined8 attributeOffset;\n  ulong version;\n  ulong tmp4;\n  ulong tmp5;\n  ulong tmp6;\n  ulong tmp7;\n  undefined *__ptr;\n  ulong tmp8;\n  ulong totalSize;\n  ulong attributeValue;\n  ulong *attributeList;\n  undefined *ptr1;\n  char char1;\n  undefined *ptr2;\n  undefined *ptr3;\n  ulong in_R11;\n  ulong *attributeHeader;\n  ulong *attributePtr;\n  ulong attributeDescription;\n  size_t __nmemb;\n  undefined8 *strings;\n  ulong *ptmp20;\n  byte bVar21;\n  int iVar22;\n  ulong retAddress;\n  ulong resultSize;\n  uint flag1;\n  ulong assignValue;\n  ulong result;\n  ulong *sortedAttributes;\n  undefined *resultPtr;\n  uint flag2;\n  uint flag3;\n  undefined8 *warningMessage;\n  \n  bVar21 = 0;\ncode_r0x00116490:\n  length = numAttributes;\n  tmp5 = attributeValue;\n  tmp8 = attributeDescription;\n  if (version == 0) {\n    if (attributeSize == 0x100) {\n      attributeHeader[7] = retAddress;\n      tmp6 = retAddress;\nLAB_001164af:\n      tmp4 = attributeDescription;\n      tmp8 = attributeDescription;\n      retAddress = tmp6;\n    }\n    else {\n      attributeHeader[7] = assignValue;\nLAB_0011669e:\n      tmp5 = attributeValue;\n      tmp4 = attributeValue;\n    }\nLAB_001164bb:\n    attributeHeader[8] = tmp4;\n    if (*(char *)((attributeHeader[3] - 1) + attributeName) != '\\0') {\n      length = dcgettext(0,\"corrupt GNU build attribute note: name not NUL terminated\",5);\n      goto LAB_0010849a;\n    }\n    attributePtr = attributeHeader + 9;\n    if (0xb < totalSize) {\n      tmp4 = (**(code **)(strings[1] + 0x40))(length);\n      *attributePtr = tmp4;\n      tmp4 = (**(code **)(strings[1] + 0x40))(length + 4);\n      attributeHeader[10] = tmp4;\n      attributeSize = (**(code **)(strings[1] + 0x40))(length + 8);\n      attributeName = *attributePtr;\n      attributeHeader[0xb] = attributeSize;\n      version = attributeHeader[10];\n      tmp4 = attributeName + 3 & 0xfffffffffffffffc;\n      attributeHeader[0xf] = tmp4;\n      if (version != (version + 3 & 0xfffffffffffffffc)) {\n        length = dcgettext(0,\"corrupt GNU build attribute note: description size not a factor of 4\",5\n                         );\n        goto LAB_0010849a;\n      }\n      if (1 < attributeSize - 0x100) {\n        length = dcgettext(0,\"corrupt GNU build attribute note: wrong note type\",5);\n        goto LAB_0010849a;\n      }\n      tmp6 = tmp4 + version + 0xc;\n      if (totalSize < tmp6) {\n        length = dcgettext(0,\"corrupt GNU build attribute note: note too big\",5);\n        goto LAB_0010849a;\n      }\n      if (attributeName < 2) {\n        length = dcgettext(0,\"corrupt GNU build attribute note: name too small\",5);\n        goto LAB_0010849a;\n      }\n      attributeHeader[0xc] = length + 0xc;\n      in_R11 = length + 0xc + tmp4;\n      attributeHeader[0xd] = in_R11;\n      totalSize = totalSize + (-0xc - (tmp4 + version));\n      numAttributes = length + tmp6;\n      attributeValue = tmp5;\n      attributeHeader = attributePtr;\n      attributeDescription = tmp8;\n      if (attributeName != 2) {\n        if (*(char *)(length + 0xc) == '$') {\n          if ((*(char *)(length + 0xd) == '\\x01') && (*(char *)(length + 0xe) == '1')) {\n            tmp5 = extractAttributes_00116490();\n            return tmp5;\n          }\n        }\n        else if ((((4 < attributeName) && (*(char *)(length + 0xc) == 'G')) &&\n                 (*(char *)(length + 0xd) == 'A')) &&\n                ((*(char *)(length + 0xe) == '$' && (*(char *)(length + 0xf) == '\\x01')))) {\n          if (*(char *)(length + 0x10) == '2') {\n            tmp5 = extractAttributes_00116490();\n            return tmp5;\n          }\n          if (*(char *)(length + 0x10) == '3') {\n            tmp5 = extractAttributes_00116490();\n            return tmp5;\n          }\n          length = dcgettext(0,\"corrupt GNU build attribute note: unsupported version\",5);\n          goto LAB_0010849a;\n        }\n      }\n      goto code_r0x00116490;\n    }\n    if (totalSize != 0) {\n      length = dcgettext(0,\"corrupt GNU build attribute notes: excess data at end\",5);\n      goto LAB_0010849a;\n    }\n    if ((flag2 | flag3 | flag1) == 0) {\n      tmp1 = *strings;\n      tmp2 = *warningMessage;\n      attributeOffset = dcgettext(0,\"%s[%s]: Warning: version note missing - assuming version 3\",5);\n      FUN_00119ed0(attributeOffset,tmp1,tmp2);\nLAB_0011671b:\n      __nmemb = ((long)attributePtr - (long)sortedAttributes >> 3) * -0x71c71c71c71c71c7;\n      qsort(sortedAttributes,__nmemb,0x48,FUN_0011a1b0);\n      for (attributeList = sortedAttributes; attributeList < attributePtr; attributeList = attributeList + 9) {\n        tmp5 = attributeList[2];\n        if (tmp5 != 0) {\n          tmp8 = attributeList[7];\n          tmp4 = attributeList[8];\n          ptmp20 = attributeList;\n          iVar22 = 0;\n          if (tmp8 == tmp4) {\n            attributeList[2] = 0;\n          }\n          else {\n            do {\n              do {\n                ptr = ptmp20;\n                ptmp20 = ptr + -9;\n                if (ptmp20 < sortedAttributes) goto LAB_001167f5;\n                tmp6 = ptr[-7];\n              } while (tmp6 == 0);\n              if ((*ptmp20 != *attributeList) ||\n                 (i = memcmp((void *)ptr[-6],(void *)attributeList[3],*attributeList), i != 0))\n              break;\n              tmp3 = ptr[-2];\n              tmp7 = ptr[-1];\n              if (tmp8 == tmp3) {\n                if (tmp4 == tmp7) {\n                  attributeList[2] = 0;\n                  break;\n                }\nLAB_001167a6:\n                if (tmp4 <= tmp7) {\n                  attributeList[2] = 0;\n                  break;\n                }\n                if (tmp7 < tmp8) {\nLAB_0010852c:\n                  if ((0xfffffffffffffff0 < tmp7) ||\n                     (tmp8 <= (tmp7 + 0xf & 0xfffffffffffffff0))) goto FUN_00116852;\n                }\nLAB_001167b8:\n                if ((tmp5 == 0x101) == (tmp6 == 0x101)) {\n                  if (tmp7 <= tmp4) {\n                    tmp7 = tmp4;\n                  }\n                  if (tmp3 < tmp8) {\n                    tmp8 = tmp3;\n                  }\n                  ptr[-1] = tmp7;\n                  ptr[-2] = tmp8;\n                  attributeList[2] = 0;\n                  break;\n                }\n              }\n              else {\n                if (tmp3 <= tmp8) goto LAB_001167a6;\n                if (tmp7 < tmp8) goto LAB_0010852c;\n                if (tmp4 < tmp8) {\n                  if ((0xfffffffffffffff0 < tmp4) || (tmp3 <= (tmp4 + 0xf & 0xfffffffffffffff0)))\n                  goto FUN_00116852;\n                  goto LAB_001167b8;\n                }\n                if (tmp4 != tmp7) goto LAB_001167b8;\n              }\nFUN_00116852:\n              flag = iVar22 < 0x11;\n              iVar22 = iVar22 + 1;\n            } while (flag);\n          }\n        }\nLAB_001167f5:\n      }\n      qsort(sortedAttributes,__nmemb,0x48,FUN_0011a250);\n      __ptr = (undefined *)xmalloc(result * 2);\n      resultSize = 0;\n      assignValue = 0;\n      ptr3 = __ptr;\n      for (attributeList = sortedAttributes; attributeList < attributePtr; attributeList = attributeList + 9) {\n        if (attributeList[2] != 0) {\n          ptr2 = ptr3 + 4;\n          ptr1 = ptr3 + 0xc;\n          if ((attributeList[7] == assignValue) && (attributeList[8] == resultSize)) {\n            (**(code **)(strings[1] + 0x50))(*attributeList,ptr3);\n            (**(code **)(strings[1] + 0x50))(0,ptr2);\n            (**(code **)(strings[1] + 0x50))(attributeList[2],ptr3 + 8);\n            tmp8 = attributeList[6];\n            tmp5 = *attributeList;\n            ptr3 = (undefined *)attributeList[3];\n            ptr2 = ptr1;\n            for (tmp4 = tmp5; tmp4 != 0; tmp4 = tmp4 - 1) {\n              *ptr2 = *ptr3;\n              ptr3 = ptr3 + (ulong)bVar21 * -2 + 1;\n              ptr2 = ptr2 + (ulong)bVar21 * -2 + 1;\n            }\n            if (tmp5 < tmp8) {\n              for (length = tmp8 - tmp5; length != 0; length = length + -1) {\n                *ptr2 = 0;\n                ptr2 = ptr2 + (ulong)bVar21 * -2 + 1;\n              }\n            }\n            ptr3 = ptr1 + tmp8;\n          }\n          else {\n            (**(code **)(strings[1] + 0x50))();\n            if (*(int *)(strings[1] + 8) == 5) {\n              char1 = (*(char *)(strings[0x22] + 4) == '\\x02') * '\\b' + '\\b';\n            }\n            else {\n              char1 = '\\b';\n            }\n            (**(code **)(strings[1] + 0x50))(char1,ptr2);\n            (**(code **)(strings[1] + 0x50))(attributeList[2],ptr3 + 8);\n            tmp5 = *attributeList;\n            ptr3 = (undefined *)attributeList[3];\n            ptr2 = ptr1;\n            for (tmp8 = tmp5; tmp8 != 0; tmp8 = tmp8 - 1) {\n              *ptr2 = *ptr3;\n              ptr3 = ptr3 + (ulong)bVar21 * -2 + 1;\n              ptr2 = ptr2 + (ulong)bVar21 * -2 + 1;\n            }\n            tmp8 = attributeList[6];\n            if (tmp5 < tmp8) {\n              for (length = tmp8 - tmp5; length != 0; length = length + -1) {\n                *ptr2 = 0;\n                ptr2 = ptr2 + (ulong)bVar21 * -2 + 1;\n              }\n            }\n            length = strings[1];\n            ptr1 = ptr1 + tmp8;\n            ptr3 = ptr1 + 8;\n            if ((*(int *)(length + 8) == 5) && (*(char *)(strings[0x22] + 4) == '\\x02')) {\n              (**(code **)(length + 0x38))(attributeList[7],ptr1);\n              (**(code **)(strings[1] + 0x38))(attributeList[8],ptr3);\n              ptr3 = ptr1 + 0x10;\n            }\n            else {\n              (**(code **)(length + 0x50))(attributeList[7],ptr1);\n              (**(code **)(strings[1] + 0x50))(attributeList[8],ptr1 + 4);\n            }\n            assignValue = attributeList[7];\n            resultSize = attributeList[8];\n          }\n        }\n      }\n      tmp8 = (long)ptr3 - (long)__ptr;\n      tmp5 = tmp8;\n      ptr3 = __ptr;\n      if (tmp8 < result) {\n        for (; result = tmp8, tmp5 != 0; tmp5 = tmp5 - 1) {\n          *resultPtr = *ptr3;\n          ptr3 = ptr3 + (ulong)bVar21 * -2 + 1;\n          resultPtr = resultPtr + (ulong)bVar21 * -2 + 1;\n        }\n      }\n      free(__ptr);\nLAB_001166f8:\n      free(sortedAttributes);\n      return result;\n    }\n    if (((flag3 | flag1) == 0) || (flag2 == 0)) {\n      if (flag3 == 0) {\n        if (flag1 != 0) goto LAB_0011671b;\n        goto LAB_001166f8;\n      }\n      if (flag1 == 0) goto LAB_001166f8;\n    }\n    length = dcgettext(0,\"bad GNU build attribute notes: multiple different versions\",5);\n  }\n  else {\n    if (version == 0x10) {\n      tmp6 = (**(code **)(strings[1] + 0x28))(in_R11);\n      tmp4 = (**(code **)(strings[1] + 0x28))(attributeHeader[4] + 8);\n      if (tmp4 < tmp6) {\n        tmp6 = tmp4;\n      }\nLAB_00116631:\n      if (attributeHeader[2] == 0x100) {\n        if (tmp6 == 0) {\n          tmp6 = retAddress;\n        }\n        attributeName = *attributeHeader;\n        attributeHeader[7] = tmp6;\n        tmp8 = tmp4;\n        retAddress = tmp6;\n        if (tmp4 == 0) goto LAB_001164af;\n      }\n      else {\n        if (tmp6 == 0) {\n          tmp6 = assignValue;\n        }\n        attributeName = *attributeHeader;\n        attributeHeader[7] = tmp6;\n        tmp5 = tmp4;\n        assignValue = tmp6;\n        if (tmp4 == 0) goto LAB_0011669e;\n      }\n      goto LAB_001164bb;\n    }\n    if (version < 0x11) {\n      if (version == 4) {\n        tmp6 = (**(code **)(strings[1] + 0x40))(in_R11);\n        tmp4 = 0xffffffffffffffff;\n        goto LAB_00116631;\n      }\n      if (version == 8) {\n        tmp5 = FUN_001086af();\n        return tmp5;\n      }\n    }\n    length = dcgettext(0,\"corrupt GNU build attribute note: bad description size\",5);\n  }\nLAB_0010849a:\n  if (length != 0) {\n    bfd_set_error(0x11);\n    FUN_001126c0(0,strings,warningMessage,length);\n    DAT_00127a40 = 1;\n  }\n  goto LAB_001166f8;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_001086af"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116490",
            "calling": [
                "FUN_0010847a",
                "FUN_001086af"
            ],
            "imported": false,
            "current_name": "extract_attributes_00116490"
        },
        "strncasecmp": {
            "renaming": {},
            "code": "\n\n\nint strncasecmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 = strncasecmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
            "called": [
                "strncasecmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001045d0",
            "calling": [
                "FUN_00116b90",
                "FUN_00104ad6"
            ],
            "imported": false,
            "current_name": "strncasecmp"
        },
        "bfd_openw": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104690",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690",
                "FUN_00119f70"
            ],
            "imported": false,
            "current_name": "bfd_openw"
        },
        "FUN_00104a35": {
            "renaming": {
                "FUN_00104a35": "print_supported_targets_00104a35",
                "param_1": "target",
                "param_2": "outputFile",
                "lVar1": "currentTarget",
                "pcVar2": "titleMsg",
                "__ptr": "targetList",
                "plVar3": "currentPtr"
            },
            "code": "\nvoid printSupportedTargets_00104a35(long target,FILE *outputFile)\n\n{\n  long currentTarget;\n  char *titleMsg;\n  long *targetList;\n  long *currentPtr;\n  \n  if (target == 0) {\n    titleMsg = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,titleMsg);\n  }\n  else {\n    titleMsg = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,titleMsg,target);\n  }\n  targetList = (long *)bfd_target_list();\n  currentPtr = targetList;\n  while( true ) {\n    currentTarget = *currentPtr;\n    currentPtr = currentPtr + 1;\n    if (currentTarget == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "fputc",
                "free",
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104a35",
            "calling": [
                "FUN_00108a2a",
                "FUN_00108916"
            ],
            "imported": false,
            "current_name": "print_supported_targets_00104a35"
        },
        "FUN_0010be1a": {
            "renaming": {
                "FUN_0010be1a": "check_and_set_current_function_0010be1a",
                "param_1": "function_ptr",
                "param_2": "new_function_start",
                "param_3": "unused_param",
                "param_4": "debug_level",
                "lVar1": "current_function_ptr",
                "uVar2": "error_message",
                "pcVar3": "error_string",
                "auVar4": "return_value"
            },
            "code": "\n\n\nundefined  [16] check_and_set_current_function_0010be1a(long function_ptr,undefined8 new_function_start,undefined8 unused_param,undefined8 debug_level)\n\n{\n  long current_function_ptr;\n  undefined8 error_message;\n  char *error_string;\n  undefined return_value [16];\n  \n  if (((*(long *)(function_ptr + 8) == 0) || (current_function_ptr = *(long *)(function_ptr + 0x20), current_function_ptr == 0)) ||\n     (*(long *)(function_ptr + 0x18) == 0)) {\n    error_string = \"debug_end_function: no current function\";\n  }\n  else {\n    if (*(long *)(current_function_ptr + 8) == 0) {\n      *(undefined8 *)(current_function_ptr + 0x20) = new_function_start;\n      error_message = CONCAT71((int7)((ulong)current_function_ptr >> 8),1);\n      *(undefined (*) [16])(function_ptr + 0x18) = ZEXT816(0);\n      goto LAB_0010be86;\n    }\n    error_string = \"debug_end_function: some blocks were not closed\";\n  }\n  error_message = dcgettext(0,error_string,5);\n  fprintf(_stderr,\"%s\\n\",error_message);\n  error_message = 0;\nLAB_0010be86:\n  return_value._8_8_ = debug_level;\n  return_value._0_8_ = error_message;\n  return return_value;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010be1a",
            "calling": [
                "FUN_0010c892",
                "FUN_0010554f",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "check_and_set_current_function_0010be1a"
        },
        "bfd_openr": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001041f0",
            "calling": [
                "FUN_00104ea2",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "bfd_openr"
        },
        "strtol": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104510",
            "calling": [
                "FUN_0010ee3f",
                "FUN_00116b90",
                "FUN_00104943",
                "FUN_0010d559",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "strtol"
        },
        "bfd_target_list": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104350",
            "calling": [
                "FUN_00104a35"
            ],
            "imported": false,
            "current_name": "bfd_target_list"
        },
        "cplus_demangle_init_info": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_init_info(void)\n\n{\n  cplus_demangle_init_info();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_init_info"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104550",
            "calling": [
                "FUN_0010ee3f"
            ],
            "imported": false,
            "current_name": "cplus_demangle_init_info"
        },
        "bfd_canonicalize_reloc": {
            "renaming": {},
            "code": "\nvoid bfd_canonicalize_reloc(void)\n\n{\n  bfd_canonicalize_reloc();\n  return;\n}\n\n",
            "called": [
                "bfd_canonicalize_reloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047b0",
            "calling": [
                "FUN_001163d0",
                "FUN_00115dc0",
                "FUN_00116030"
            ],
            "imported": false,
            "current_name": "bfd_canonicalize_reloc"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104760",
            "calling": [
                "FUN_00116b90",
                "FUN_00115dc0",
                "FUN_001083b7",
                "FUN_00116030",
                "FUN_00119dd0"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "FUN_00113da9": {
            "renaming": {
                "FUN_00113da9": "initialize_memory_00113da9",
                "param_1": "byte_offset",
                "param_3": "source_data",
                "puVar1": "memory_block",
                "lVar2": "loop_counter",
                "puVar3": "current_address",
                "bVar4": "byte_value",
                "auVar5": "return_value"
            },
            "code": "\nundefined  [16] initialize_memory_00113da9(byte byte_offset,undefined8 param_2,undefined8 source_data,undefined8 param_4)\n\n{\n  undefined8 *memory_block;\n  long loop_counter;\n  undefined8 *current_address;\n  byte byte_value;\n  undefined return_value [16];\n  \n  byte_value = 0;\n  return_value._0_8_ = FUN_00112904(8 - (uint)byte_offset);\n  if (return_value._0_8_ != 0) {\n    memory_block = (undefined8 *)xmalloc(0x28);\n    current_address = memory_block + 1;\n    for (loop_counter = 8; loop_counter != 0; loop_counter = loop_counter + -1) {\n      *(undefined4 *)current_address = 0;\n      current_address = (undefined8 *)((long)current_address + (ulong)byte_value * -8 + 4);\n    }\n    *memory_block = source_data;\n    *(undefined8 **)(return_value._0_8_ + 0x10) = memory_block;\n  }\n  return_value._8_8_ = param_4;\n  return return_value;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113da9",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010e07c",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_memory_00113da9"
        },
        "FUN_0011a250": {
            "renaming": {
                "FUN_0011a250": "compare_records_0011a250",
                "param_1": "record1",
                "param_2": "record2",
                "uVar1": "record1Timestamp",
                "param_2[2]": "record2Timestamp",
                "param_2[7]": "record2Size",
                "param_1[7]": "record1Size",
                "param_2[8]": "record2Priority",
                "param_1[8]": "record1Priority",
                "param_1[3]": "record1Data",
                "param_2[3]": "record2Data"
            },
            "code": "\nint compareRecords_0011a250(ulong *record1,ulong *record2)\n\n{\n  ulong record1Timestamp;\n  \n  record1Timestamp = record1[2];\n  if (record1Timestamp == record2Timestamp) {\n    if (record2Size <= record1Size) {\n      if (record1Size <= record2Size) {\n        if (record2Priority < record1Priority) {\n          return -1;\n        }\n        if (record2Priority <= record1Priority) {\n          if ((4 < *record1) && (4 < *record2)) {\n            if (*(char *)(record1Data + 3) != *(char *)(record2Data + 3)) {\n              return (int)*(char *)(record1Data + 3) - (int)*(char *)(record2Data + 3);\n            }\n          }\n          return 0;\n        }\n      }\n      return 1;\n    }\n  }\n  else if ((record1Timestamp == 0) || ((record1Timestamp != 0x100 && (record2Timestamp != 0)))) {\n    return 1;\n  }\n  return -1;\n}\n\n",
            "called": [
                "FUN_001087fd"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a250",
            "calling": [
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "compare_records_0011a250"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104280",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "FUN_0010a69a": {
            "renaming": {
                "FUN_0010a69a": "update_data_0010a69a",
                "param_1": "data_ptr",
                "param_2": "param_ptr",
                "param_3": "flag",
                "param_4": "char_flag",
                "param_5": "uint_value",
                "uVar1": "result",
                "lVar2": "length",
                "sVar3": "str_length",
                "uVar4": "allocated_ptr",
                "uVar5": "should_allocate",
                "local_60": "str_buffer"
            },
            "code": "\nundefined4 updateData_0010a69a(long data_ptr,undefined8 param_ptr,int flag,char char_flag,uint uint_value)\n\n{\n  undefined4 result;\n  long length;\n  size_t str_length;\n  undefined8 allocated_ptr;\n  undefined should_allocate;\n  char str_buffer [48];\n  \n  if (flag == 0) {\n    str_buffer[0] = '\\0';\n    should_allocate = 0;\n    length = 0;\n  }\n  else {\n    length = FUN_00109c2e();\n    if (length < 0) {\n      return 0;\n    }\n    should_allocate = 1;\n    sprintf(str_buffer,\"%ld=\",length);\n  }\n  str_length = strlen(str_buffer);\n  sprintf(str_buffer + str_length,\"%c%u\",(ulong)((-(uint)(char_flag == '\\0') & 2) + 0x73),(ulong)uint_value);\n  result = FUN_00109b52(data_ptr,str_buffer,length,should_allocate,uint_value);\n  if ((char)result == '\\0') {\n    return 0;\n  }\n  length = *(long *)(data_ptr + 0x60);\n  allocated_ptr = xmalloc(1);\n  *(undefined8 *)(length + 0x20) = allocated_ptr;\n  **(undefined **)(*(long *)(data_ptr + 0x60) + 0x20) = 0;\n  return result;\n}\n\n",
            "called": [
                "FUN_00109c2e",
                "xmalloc",
                "FUN_00109b52",
                "sprintf",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a69a",
            "calling": [
                "FUN_0010a83e",
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "update_data_0010a69a"
        },
        "FUN_00115b70": {
            "renaming": {
                "FUN_00115b70": "validate_section_00115b70",
                "param_1": "sections",
                "pcVar1": "currentSection",
                "iVar2": "comparisonResult",
                "iVar3": "sectionType",
                "lVar4": "result1",
                "lVar5": "result2",
                "uVar6": "errorMessage",
                "plVar7": "linkedSections"
            },
            "code": "\nundefined8 validateSection_00115b70(char **sections)\n\n{\n  char *currentSection;\n  int comparisonResult;\n  int sectionType;\n  long result1;\n  long result2;\n  undefined8 errorMessage;\n  long *linkedSections;\n  \n  result1 = FUN_00114190(*sections,0,4);\n  if (result1 == 0) {\n    if ((DAT_001278d8 != '\\0') || (DAT_00127a39 != '\\0')) {\n      result1 = FUN_00114190(*sections,0,1);\n      result2 = FUN_00114190(*sections,0,2);\n      if (result1 != 0) {\n        if (result2 != 0) {\n          currentSection = *sections;\n          errorMessage = dcgettext(0,\"error: section %s matches both remove and copy options\",5);\n                    \n          FUN_00119dd0(errorMessage,currentSection);\n        }\n        if (result1 != 0) {\n          if (DAT_001279d8 == (long *)0x0) {\n            return 1;\n          }\n          currentSection = *sections;\n          linkedSections = DAT_001279d8;\n          do {\n            sectionType = strcmp(currentSection,(char *)linkedSections[1]);\n            if (sectionType == 0) {\n              errorMessage = dcgettext(0,\"error: section %s matches both update and remove options\",5);\n                    \n              FUN_00119dd0(errorMessage,currentSection);\n            }\n            linkedSections = (long *)*linkedSections;\n          } while (linkedSections != (long *)0x0);\n          return 1;\n        }\n      }\n      if ((DAT_00127a39 != '\\0') && (result2 == 0)) {\n        return 1;\n      }\n    }\n    sectionType = DAT_00127a48;\n    if ((*(byte *)((long)sections + 0x25) & 0x20) != 0) {\n      if ((((DAT_00127a48 - 2U < 2) || (DAT_00127a48 == 7)) || (DAT_00127a44 == 2)) ||\n         (DAT_001279a0 != '\\0')) {\n        currentSection = *sections;\n        comparisonResult = strcmp(currentSection,\".gnu_debugaltlink\");\n        if ((comparisonResult != 0) && (comparisonResult = strcmp(currentSection,\".gnu_debuglink\"), comparisonResult != 0)) {\n          sectionType = strcmp(currentSection,\".reloc\");\n          if (sectionType != 0) {\n            return 1;\n          }\n          errorMessage = FUN_0010829e();\n          return errorMessage;\n        }\n      }\n      if (sectionType == 5) {\n        errorMessage = FUN_00113ede(sections);\n        return errorMessage;\n      }\n      if (sectionType == 4) {\n        return 0;\n      }\n    }\n    if (sectionType == 6) {\n      errorMessage = FUN_001082b3();\n      return errorMessage;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00114190",
                "dcgettext",
                "FUN_0010827b",
                "FUN_0010829e",
                "strcmp",
                "FUN_00119dd0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115b70",
            "calling": [
                "FUN_001159d0"
            ],
            "imported": false,
            "current_name": "validate_section_00115b70"
        },
        "strrchr": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042c0",
            "calling": [
                "FUN_00114cf0"
            ],
            "imported": false,
            "current_name": "strrchr"
        },
        "bfd_get_reloc_upper_bound": {
            "renaming": {},
            "code": "\nvoid bfd_get_reloc_upper_bound(void)\n\n{\n  bfd_get_reloc_upper_bound();\n  return;\n}\n\n",
            "called": [
                "bfd_get_reloc_upper_bound"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104840",
            "calling": [
                "FUN_001163d0",
                "FUN_00115dc0",
                "FUN_00116030"
            ],
            "imported": false,
            "current_name": "bfd_get_reloc_upper_bound"
        },
        "FUN_00116030": {
            "renaming": {
                "FUN_00116030": "process_binary_00116030",
                "param_1": "param_array",
                "param_2": "param_size",
                "plVar1": "ptr_array",
                "lVar2": "value",
                "lVar3": "constant1",
                "lVar4": "constant2",
                "iVar5": "error_code",
                "in_RAX": "result",
                "lVar6": "fwrite_ptr",
                "lVar7": "reloc_result",
                "__ptr": "reloc_ptr",
                "lVar8": "index",
                "uStack_28": "return_value"
            },
            "code": "\n\n\nundefined8 processBinary_00116030(undefined8 *param_array,long param_size)\n\n{\n  long *ptr_array;\n  long value;\n  long constant1;\n  long constant2;\n  int error_code;\n  undefined8 result;\n  long fwrite_ptr;\n  void *reloc_ptr;\n  long reloc_result;\n  undefined8 extraout_RAX;\n  long index;\n  undefined8 return_value;\n  \n  if (*(long *)(param_size + 0x60) == 0) {\n    return result;\n  }\n  fwrite_ptr = bfd_get_reloc_upper_bound();\n  if (fwrite_ptr < 0) {\n    if ((fwrite_ptr != -1) || (error_code = bfd_get_error(), error_code != 5)) {\n      FUN_0011a110(*param_array);\n                    \n      xexit(1);\n    }\n  }\n  else if (fwrite_ptr != 0) {\n    reloc_ptr = (void *)xmalloc();\n    reloc_result = bfd_canonicalize_reloc(param_array,param_size,reloc_ptr);\n    constant2 = _DAT_00128680;\n    constant1 = _DAT_00128568;\n    fwrite_ptr = _fwrite;\n    if (reloc_result < 0) {\n      FUN_0011a110(*param_array);\n                    \n      xexit(1);\n    }\n    if (reloc_result != 0) {\n      index = 0;\n      do {\n        ptr_array = **(long ***)((long)reloc_ptr + index * 8);\n        if ((((ptr_array != (long *)0x0) && (value = *ptr_array, value != 0)) && (value != fwrite_ptr)) &&\n           ((value != constant2 && (value != constant1)))) {\n          *(uint *)(value + 0x18) = *(uint *)(value + 0x18) | 0x20;\n        }\n        index = index + 1;\n      } while (reloc_result != index);\n    }\n    free(reloc_ptr);\n    return extraout_RAX;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_0011a110",
                "FUN_001083b7",
                "free",
                "fwrite",
                "bfd_canonicalize_reloc",
                "bfd_get_reloc_upper_bound",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116030",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_binary_00116030"
        },
        "FUN_00113ede": {
            "renaming": {
                "FUN_00113ede": "extract_and_process_data_00113ede",
                "param_1": "data_ptr",
                "__s": "data_string",
                "sVar1": "string_length",
                "uVar2": "result"
            },
            "code": "\nundefined8 extract_and_process_data_00113ede(char **data_ptr)\n\n{\n  char *data_string;\n  size_t string_length;\n  undefined8 result;\n  \n  if (data_ptr == (char **)0x0) {\n    return 0;\n  }\n  data_string = *data_ptr;\n  if (data_string != (char *)0x0) {\n    string_length = strlen(data_string);\n    if (4 < (int)string_length) {\n      result = FUN_00113fb0(data_string + (long)(int)string_length + -4,&DAT_0012142b);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00113fb0",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113ede",
            "calling": [
                "FUN_001082b3",
                "FUN_0010829e"
            ],
            "imported": false,
            "current_name": "extract_and_process_data_00113ede"
        },
        "bfd_convert_section_contents": {
            "renaming": {},
            "code": "\nvoid bfd_convert_section_contents(void)\n\n{\n  bfd_convert_section_contents();\n  return;\n}\n\n",
            "called": [
                "bfd_convert_section_contents"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001042f0",
            "calling": [
                "FUN_00116110"
            ],
            "imported": false,
            "current_name": "bfd_convert_section_contents"
        },
        "FUN_0010875d": {
            "renaming": {
                "FUN_0010875d": "compare_records_0010875d",
                "param_1": "record1",
                "param_2": "record2",
                "lVar1": "value1",
                "lVar2": "value2",
                "iVar3": "result",
                "uVar4": "flag"
            },
            "code": "\nint compareRecords_0010875d(long *record1,long *record2)\n\n{\n  long value1;\n  long value2;\n  int result;\n  uint flag;\n  \n  value1 = *record1;\n  value2 = *record2;\n  flag = *(uint *)(value2 + 0x24) & 0x102;\n  if ((*(uint *)(value1 + 0x24) & 0x102) == 0x102) {\n    if (flag != 0x102) {\n      return 1;\n    }\n  }\n  else if (flag == 0x102) {\n    return -1;\n  }\n  result = 1;\n  if (*(ulong *)(value1 + 0x38) <= *(ulong *)(value2 + 0x38)) {\n    result = -1;\n    if (*(ulong *)(value2 + 0x38) <= *(ulong *)(value1 + 0x38)) {\n      if (*(ulong *)(value2 + 0x40) < *(ulong *)(value1 + 0x40)) {\n        result = 1;\n      }\n      else {\n        result = -1;\n        if (*(ulong *)(value2 + 0x40) <= *(ulong *)(value1 + 0x40)) {\n          result = 1;\n          if (*(uint *)(value1 + 0x18) <= *(uint *)(value2 + 0x18)) {\n            return -(uint)(*(uint *)(value1 + 0x18) < *(uint *)(value2 + 0x18));\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010875d",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "compare_records_0010875d"
        },
        "cplus_demangle": {
            "renaming": {},
            "code": "\nvoid cplus_demangle(void)\n\n{\n  cplus_demangle();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046b0",
            "calling": [
                "FUN_0010d21c"
            ],
            "imported": false,
            "current_name": "cplus_demangle"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00116b00();\n  return;\n}\n\n",
            "called": [
                "FUN_00116b00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00116b80",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "FUN_0010c892": {
            "renaming": {
                "FUN_0010c892": "process_data_0010c892",
                "param_1": "data",
                "param_2": "address",
                "cVar1": "result",
                "lVar2": "tempValue",
                "lVar3": "storedValue",
                "uVar4": "returnValue",
                "puVar5": "ptr",
                "iVar6": "kind"
            },
            "code": "\n\n\nundefined8 processData_0010c892(undefined8 data,long address)\n\n{\n  char result;\n  long tempValue;\n  long storedValue;\n  undefined8 returnValue;\n  undefined8 *ptr;\n  int kind;\n  \n  if (*(char *)(address + 0x60) == '\\0') {\nLAB_0010c8c7:\n    for (ptr = *(undefined8 **)(address + 0x1a0); ptr != (undefined8 *)0x0;\n        ptr = (undefined8 *)*ptr) {\n      kind = *(int *)(ptr + 2);\n      storedValue = ptr[1];\n      if (kind != 0) {\n        if (storedValue != 0) {\n          if (kind - 7U < 5) goto LAB_0010c8d5;\n          returnValue = dcgettext(0,\"debug_make_undefined_type: unsupported kind\",5);\n          fprintf(_stderr,\"%s\\n\",returnValue);\n        }\nLAB_0010c910:\n        ptr[3] = 0;\n        goto LAB_0010c916;\n      }\n      if (storedValue == 0) goto LAB_0010c910;\n      kind = 7;\nLAB_0010c8d5:\n      tempValue = FUN_00112904(kind,0);\n      if (tempValue == 0) goto LAB_0010c910;\n      storedValue = FUN_0010c6be(data,storedValue,tempValue);\n      ptr[3] = storedValue;\n      if (storedValue == 0) goto LAB_0010c916;\n    }\n    returnValue = 1;\n  }\n  else {\n    result = FUN_0010c1c6();\n    if (result != '\\0') {\n      result = FUN_0010be1a(data,*(undefined8 *)(address + 0x68));\n      if (result != '\\0') {\n        *(undefined *)(address + 0x60) = 0;\n        *(undefined8 *)(address + 0x68) = 0xffffffffffffffff;\n        goto LAB_0010c8c7;\n      }\n    }\nLAB_0010c916:\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "FUN_00112904",
                "FUN_0010be1a",
                "FUN_0010c1c6",
                "FUN_0010c6be"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010c892",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "process_data_0010c892"
        },
        "FUN_00112904": {
            "renaming": {
                "FUN_00112904": "initialize_memory_00112904",
                "param_1": "value1",
                "param_2": "value2",
                "puVar1": "memoryBlock"
            },
            "code": "\nvoid initializeMemory_00112904(undefined4 value1,undefined4 value2)\n\n{\n  undefined4 *memoryBlock;\n  \n  memoryBlock = (undefined4 *)xmalloc(0x18);\n  *memoryBlock = value1;\n  memoryBlock[1] = value2;\n  *(undefined (*) [16])(memoryBlock + 2) = ZEXT816(0);\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112904",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010c218",
                "FUN_0010c6be",
                "FUN_00113dfe",
                "FUN_00113b71",
                "FUN_00113e17",
                "FUN_00113bfa",
                "FUN_00113c43",
                "FUN_00113e23",
                "FUN_0010c892",
                "FUN_00113df2",
                "FUN_0010c2d2",
                "FUN_00113b4a",
                "FUN_00113da9",
                "FUN_00113d6e",
                "FUN_00113ce0",
                "FUN_00113b98",
                "FUN_00113cb9",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_00113d3a"
            ],
            "imported": false,
            "current_name": "initialize_memory_00112904"
        },
        "FUN_00108898": {
            "renaming": {
                "FUN_00108898": "compare_strings_00108898",
                "param_1": "string1",
                "param_2": "string2",
                "iVar1": "comparisonResult",
                "in_RAX": "returnValue",
                "auVar2": "result"
            },
            "code": "\nundefined  [16] compareStrings_00108898(char **string1,char **string2)\n\n{\n  int comparisonResult;\n  undefined8 returnValue;\n  undefined result [16];\n  \n  comparisonResult = strcmp(*string1,*string2);\n  result._1_7_ = 0;\n  result[0] = comparisonResult == 0;\n  result._8_8_ = returnValue;\n  return result;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108898",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "compare_strings_00108898"
        },
        "__errno_location": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040b0",
            "calling": [
                "FUN_00116b90",
                "FUN_00104966",
                "FUN_00104ea2",
                "FUN_00109a32",
                "FUN_0010882c",
                "FUN_00108237",
                "FUN_00115a90",
                "FUN_00108200",
                "FUN_0010543c",
                "FUN_00107880",
                "FUN_00114460",
                "FUN_001199d0",
                "FUN_00114690"
            ],
            "imported": false,
            "current_name": "__errno_location"
        },
        "strcasecmp": {
            "renaming": {},
            "code": "\n\n\nint strcasecmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcasecmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcasecmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104080",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "strcasecmp"
        },
        "strcmp": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104470",
            "calling": [
                "FUN_00114190",
                "FUN_00115f50",
                "FUN_00116b90",
                "FUN_0010ee3f",
                "FUN_0010c7a0",
                "FUN_00115530",
                "FUN_0010c6be",
                "FUN_0011173a",
                "FUN_00108c86",
                "FUN_0010d559",
                "FUN_00115b70",
                "FUN_00108898",
                "FUN_0010914e",
                "FUN_00104943",
                "FUN_0010554f",
                "FUN_0010b0fa",
                "FUN_0010afd5",
                "FUN_0010922b"
            ],
            "imported": false,
            "current_name": "strcmp"
        },
        "FUN_0011a390": {
            "renaming": {
                "FUN_0011a390": "execute_and_iterate_0011a390",
                "lVar1": "index",
                "lVar2": "prev_index",
                "lVar3": "temp_index",
                "plVar4": "function_pointers",
                "uVar5": "count"
            },
            "code": "\nvoid execute_and_iterate_0011a390(void)\n\n{\n  long index;\n  long prev_index;\n  long temp_index;\n  long *function_pointers;\n  uint count;\n  \n  function_pointers = (long *)PTR_DAT_001264e0;\n  if (PTR_DAT_001264e0 != (undefined *)0x0) {\n    do {\n      count = *(int *)(function_pointers + 1) - 1;\n      if (-1 < (int)count) {\n        index = (long)(int)count;\n        count = count & 7;\n        (*(code *)function_pointers[index + 2])();\n        prev_index = index + -1;\n        if (-1 < (int)prev_index) {\n          temp_index = prev_index;\n          if (count != 0) {\n            if (count != 1) {\n              if (count != 2) {\n                if (count != 3) {\n                  if (count != 4) {\n                    if (count != 5) {\n                      if (count != 6) {\n                        (*(code *)function_pointers[index + 1])();\n                        prev_index = index + -2;\n                      }\n                      (*(code *)function_pointers[prev_index + 2])();\n                      prev_index = prev_index + -1;\n                    }\n                    (*(code *)function_pointers[prev_index + 2])();\n                    prev_index = prev_index + -1;\n                  }\n                  (*(code *)function_pointers[prev_index + 2])();\n                  prev_index = prev_index + -1;\n                }\n                (*(code *)function_pointers[prev_index + 2])();\n                prev_index = prev_index + -1;\n              }\n              (*(code *)function_pointers[prev_index + 2])();\n              prev_index = prev_index + -1;\n            }\n            (*(code *)function_pointers[prev_index + 2])();\n            temp_index = prev_index + -1;\n            if ((int)(prev_index + -1) < 0) goto LAB_0011a466;\n          }\n          do {\n            (*(code *)function_pointers[temp_index + 2])();\n            index = temp_index + -1;\n            (*(code *)function_pointers[temp_index + 1])();\n            (*(code *)function_pointers[temp_index])();\n            (*(code *)function_pointers[index])();\n            (*(code *)function_pointers[temp_index + -2])();\n            (*(code *)function_pointers[temp_index + -3])();\n            (*(code *)function_pointers[temp_index + -4])();\n            (*(code *)function_pointers[temp_index + -5])();\n            temp_index = temp_index + -8;\n          } while (-1 < (int)index + -7);\n        }\n      }\nLAB_0011a466:\n      function_pointers = (long *)*function_pointers;\n    } while (function_pointers != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a390",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "execute_and_iterate_0011a390"
        },
        "FUN_0010e842": {
            "renaming": {
                "FUN_0010e842": "create_formatted_string_0010e842",
                "param_1": "arg1",
                "param_2": "inputString",
                "param_3": "value",
                "param_4": "arg2",
                "sVar1": "stringLength",
                "__s": "formattedString",
                "auVar2": "result"
            },
            "code": "\nundefined  [16] createFormattedString_0010e842(undefined8 arg1,char *inputString,undefined8 value,undefined8 arg2)\n\n{\n  size_t stringLength;\n  char *formattedString;\n  undefined result [16];\n  \n  stringLength = strlen(inputString);\n  formattedString = (char *)xmalloc(stringLength + 0x14);\n  sprintf(formattedString,\"%s:c=i%ld\",inputString,value);\n  result._0_4_ = FUN_0010e2f0(arg1,0x80,0,0,formattedString);\n  result._4_4_ = 0;\n  if ((char)result._0_4_ != '\\0') {\n    free(formattedString);\n  }\n  result._8_8_ = arg2;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_0010e2f0",
                "sprintf",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e842",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "create_formatted_string_0010e842"
        },
        "strtod": {
            "renaming": {},
            "code": "\n\n\ndouble strtod(char *__nptr,char **__endptr)\n\n{\n  double dVar1;\n  \n  dVar1 = strtod(__nptr,__endptr);\n  return dVar1;\n}\n\n",
            "called": [
                "strtod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104170",
            "calling": [
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "strtod"
        },
        "htab_elements": {
            "renaming": {},
            "code": "\nvoid htab_elements(void)\n\n{\n  htab_elements();\n  return;\n}\n\n",
            "called": [
                "htab_elements"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001044e0",
            "calling": [
                "FUN_00116b90",
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "htab_elements"
        },
        "FUN_00113cb9": {
            "renaming": {
                "FUN_00113cb9": "initialize_memory_00113cb9",
                "param_1": "inputValue",
                "lVar1": "memoryAddress"
            },
            "code": "\nlong initializeMemory_00113cb9(long inputValue)\n\n{\n  long memoryAddress;\n  \n  if (inputValue != 0) {\n    memoryAddress = FUN_00112904(0xe,0);\n    if (memoryAddress == 0) {\n      memoryAddress = 0;\n    }\n    else {\n      *(long *)(memoryAddress + 0x10) = inputValue;\n    }\n    return memoryAddress;\n  }\n  return 0;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113cb9",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e"
            ],
            "imported": false,
            "current_name": "initialize_memory_00113cb9"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001046f0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "FUN_0010eafe": {
            "renaming": {
                "FUN_0010eafe": "process_data_0010eafe",
                "param_1": "data",
                "param_2": "string1",
                "param_3": "character",
                "__s": "resultString",
                "sVar2": "string1Length",
                "sVar3": "resultStringLength",
                "__s_00": "newString",
                "uVar1": "returnValue"
            },
            "code": "\nundefined4 processData_0010eafe(long data,char *string1,char character)\n\n{\n  undefined4 returnValue;\n  char *resultString;\n  size_t string1Length;\n  size_t resultStringLength;\n  char *newString;\n  \n  if ((*(int *)(data + 0x1f8) == 0) && (*(long *)(data + 0x1e8) == -1)) {\n    resultString = (char *)FUN_00109b2f();\n    string1Length = strlen(string1);\n    resultStringLength = strlen(resultString);\n    newString = (char *)xmalloc(string1Length + 3 + resultStringLength);\n    sprintf(newString,\"%s:%c%s\",string1,(ulong)((-(uint)(character == '\\0') & 0x20) + 0x46),resultString);\n    *(undefined8 *)(data + 0x1e8) = *(undefined8 *)(data + 0x10);\n    returnValue = FUN_0010e2f0(data,0x24,0,0,newString);\n    if ((char)returnValue != '\\0') {\n      free(newString);\n      return returnValue;\n    }\n  }\n  return 0;\n}\n\n",
            "called": [
                "xmalloc",
                "free",
                "FUN_0010e2f0",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010eafe",
            "calling": [
                "FUN_001135a5"
            ],
            "imported": false,
            "current_name": "process_data_0010eafe"
        },
        "FUN_00113df2": {
            "renaming": {
                "FUN_00113df2": "initialize_data_00113df2",
                "param_1": "data"
            },
            "code": "\nvoid initializeData_00113df2(undefined4 data)\n\n{\n  FUN_00112904(4,data);\n  return;\n}\n\n",
            "called": [
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113df2",
            "calling": [
                "FUN_0010c2d2",
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "initialize_data_00113df2"
        },
        "FUN_0010a377": {
            "renaming": {
                "FUN_0010a377": "prepare_data_0010a377",
                "param_1": "inputData",
                "__s": "str1",
                "__s_00": "str2",
                "sVar3": "length1",
                "sVar4": "length2",
                "__s_01": "resultStr",
                "uVar2": "returnValue",
                "cVar1": "flag",
                "uVar5": "extraFlag"
            },
            "code": "\nundefined4 prepareData_0010a377(long inputData)\n\n{\n  char flag;\n  undefined4 returnValue;\n  char *str1;\n  char *str2;\n  size_t length1;\n  size_t length2;\n  char *resultStr;\n  undefined extraFlag;\n  \n  extraFlag = 1;\n  flag = *(char *)(*(long *)(inputData + 0x60) + 0x1c);\n  str1 = (char *)FUN_00109b2f();\n  if (flag == '\\0') {\n    extraFlag = *(undefined *)(*(long *)(inputData + 0x60) + 0x1c);\n  }\n  str2 = (char *)FUN_00109b2f(inputData);\n  length1 = strlen(str1);\n  length2 = strlen(str2);\n  resultStr = (char *)xmalloc(length1 + 3 + length2);\n  sprintf(resultStr,\"@%s,%s\",str2,str1);\n  free(str2);\n  free(str1);\n  returnValue = FUN_00109b52(inputData,resultStr,0,extraFlag,0);\n  if ((char)returnValue != '\\0') {\n    free(resultStr);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00109b52",
                "free",
                "sprintf",
                "FUN_00109b2f",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010a377",
            "calling": [
                "FUN_00112c1f"
            ],
            "imported": false,
            "current_name": "prepare_data_0010a377"
        },
        "FUN_0010d882": {
            "renaming": {
                "FUN_0010d882": "process_data_0010d882",
                "param_1": "input_ptr",
                "param_2": "input_strings",
                "param_3": "output_ptr",
                "param_4": "flag",
                "iVar1": "iteration_count",
                "pcVar2": "current_string",
                "cVar3": "current_char",
                "lVar4": "allocated_memory",
                "pcVar5": "updated_string",
                "uVar6": "index",
                "bVar7": "is_valid",
                "local_50": "current_index",
                "local_4c": "constant_1",
                "local_48": "temp_value",
                "local_44": "loop_count",
                "local_40": "temp_data"
            },
            "code": "\nundefined8 process_data_0010d882(long input_ptr,char **input_strings,long *output_ptr,undefined *flag)\n\n{\n  int iteration_count;\n  char *current_string;\n  char current_char;\n  long allocated_memory;\n  char *updated_string;\n  ulong index;\n  bool is_valid;\n  uint current_index;\n  undefined4 constant_1;\n  uint temp_value;\n  int loop_count;\n  undefined8 temp_data [2];\n  \n  current_string = *input_strings;\n  constant_1 = 10;\n  if (output_ptr != (long *)0x0) {\n    allocated_memory = xmalloc();\n    *output_ptr = allocated_memory;\n    *flag = 0;\n  }\n  current_index = 0;\n  while( true ) {\n    updated_string = *input_strings;\n    current_char = *updated_string;\n    if ((current_char == '_' || current_char == '\\0') || (current_char == 'e')) break;\n    if ((current_char == 'N') || (current_char == 'T')) {\n      *input_strings = updated_string + 1;\n      if (current_char == 'T') {\n        loop_count = 1;\n      }\n      else {\n        current_char = FUN_00108ea1(input_strings,&loop_count);\n        if (current_char == '\\0') goto LAB_0010d958;\n      }\n      current_char = FUN_00108ea1(input_strings,&temp_value);\n      if ((current_char == '\\0') || (*(uint *)(input_ptr + 0x28) <= temp_value)) {\nLAB_0010d958:\n        FUN_0010911f(current_string);\n        return 0;\n      }\n      index = (ulong)temp_value;\n      while (iteration_count = loop_count + -1, is_valid = loop_count != 0, loop_count = iteration_count, is_valid) {\n        temp_data[0] = *(undefined8 *)(*(long *)(input_ptr + 0x20) + index * 0x10);\n        current_char = FUN_0010d7d4(input_ptr,temp_data,output_ptr,&current_index,&constant_1);\n        if (current_char == '\\0') {\n          return 0;\n        }\n      }\n    }\n    else {\n      current_char = FUN_0010d7d4(input_ptr,input_strings,output_ptr,&current_index,&constant_1);\n      if (current_char == '\\0') {\n        return 0;\n      }\n    }\n  }\n  if (output_ptr == (long *)0x0) {\n    if (current_char != 'e') goto LAB_0010d9fa;\n  }\n  else {\n    *(undefined8 *)(*output_ptr + (ulong)current_index * 8) = 0;\n    if (*updated_string != 'e') goto LAB_0010d9fa;\n    *flag = 1;\n  }\n  updated_string = updated_string + 1;\n  *input_strings = updated_string;\nLAB_0010d9fa:\n  return CONCAT71((int7)((ulong)updated_string >> 8),1);\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_0010911f",
                "FUN_00108ea1",
                "FUN_0010d7d4"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010d882",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010c95e"
            ],
            "imported": false,
            "current_name": "process_data_0010d882"
        },
        "strtoul": {
            "renaming": {},
            "code": "\n\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 = strtoul(__nptr,__endptr,__base);\n  return uVar1;\n}\n\n",
            "called": [
                "strtoul"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104790",
            "calling": [
                "FUN_00116b90",
                "FUN_00109a32"
            ],
            "imported": false,
            "current_name": "strtoul"
        },
        "FUN_00112925": {
            "renaming": {
                "FUN_00112925": "initialize_memory_00112925",
                "param_1": "memory",
                "param_2": "value",
                "param_3": "size",
                "param_4": "offset",
                "puVar1": "memoryBlock",
                "pauVar2": "existingBlock",
                "lVar3": "loopCount",
                "puVar4": "currentMemoryBlock",
                "bVar5": "isFirstBlock"
            },
            "code": "\nundefined4 *\ninitializeMemory_00112925(undefined (**memory) [16],undefined8 value,undefined4 size,undefined4 offset)\n\n{\n  undefined4 *memoryBlock;\n  undefined (*existingBlock) [16];\n  long loopCount;\n  undefined4 *currentMemoryBlock;\n  byte isFirstBlock;\n  \n  isFirstBlock = 0;\n  memoryBlock = (undefined4 *)xmalloc(0x28);\n  currentMemoryBlock = memoryBlock;\n  for (loopCount = 10; loopCount != 0; loopCount = loopCount + -1) {\n    *currentMemoryBlock = 0;\n    currentMemoryBlock = currentMemoryBlock + (ulong)isFirstBlock * -2 + 1;\n  }\n  existingBlock = *memory;\n  *(undefined8 *)(memoryBlock + 2) = value;\n  memoryBlock[5] = size;\n  memoryBlock[6] = offset;\n  if (existingBlock == (undefined (*) [16])0x0) {\n    existingBlock = (undefined (*) [16])xmalloc(0x10);\n    *existingBlock = ZEXT816(0);\n    *memory = existingBlock;\n    *(undefined (**) [16])(*existingBlock + 8) = existingBlock;\n  }\n  **(undefined8 **)(*existingBlock + 8) = memoryBlock;\n  *(undefined4 **)(*existingBlock + 8) = memoryBlock;\n  return memoryBlock;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00112925",
            "calling": [
                "FUN_0010c05d",
                "FUN_0010c218",
                "FUN_0010bc80",
                "FUN_0010c6be",
                "FUN_00112996"
            ],
            "imported": false,
            "current_name": "initialize_memory_00112925"
        },
        "FUN_0010bf86": {
            "renaming": {
                "FUN_0010bf86": "update_record_line_0010bf86",
                "param_1": "recordUnit",
                "param_2": "newParam1",
                "param_3": "newParam2",
                "uVar1": "result",
                "puVar2": "currentRecord",
                "uVar3": "counter",
                "puVar4": "newRecord",
                "lVar5": "index",
                "puVar6": "pointer",
                "bVar7": "flag"
            },
            "code": "\n\n\nundefined8 updateRecordLine_0010bf86(long recordUnit,undefined8 newParam1,undefined8 newParam2)\n\n{\n  undefined8 result;\n  undefined8 *currentRecord;\n  ulong counter;\n  undefined4 *newRecord;\n  long index;\n  undefined4 *pointer;\n  byte flag;\n  \n  flag = 0;\n  if (*(long *)(recordUnit + 8) == 0) {\n    result = dcgettext(0,\"debug_record_line: no current unit\",5);\n    fprintf(_stderr,\"%s\\n\",result);\n    result = 0;\n  }\n  else {\n    index = *(long *)(recordUnit + 0x28);\n    if ((index != 0) && (*(long *)(index + 8) == *(long *)(recordUnit + 0x10))) {\n      counter = 0;\n      do {\n        if (*(long *)(index + 0x10 + counter * 8) == -1) {\n          currentRecord = (undefined8 *)(counter & 0xffffffff);\n          *(undefined8 *)(index + 0x10 + (long)currentRecord * 8) = newParam1;\n          *(undefined8 *)(index + 0x60 + (long)currentRecord * 8) = newParam2;\n          goto LAB_0010c056;\n        }\n        counter = counter + 1;\n      } while (counter != 10);\n    }\n    newRecord = (undefined4 *)xmalloc(0xb0);\n    pointer = newRecord;\n    for (index = 0x2c; index != 0; index = index + -1) {\n      *pointer = 0;\n      pointer = pointer + (ulong)flag * -2 + 1;\n    }\n    result = *(undefined8 *)(recordUnit + 0x10);\n    *(undefined8 *)(newRecord + 4) = newParam1;\n    *(undefined8 *)(newRecord + 2) = result;\n    *(undefined8 *)(newRecord + 0x18) = newParam2;\n    pointer = newRecord + 6;\n    for (index = 0x48; index != 0; index = index + -1) {\n      *(undefined *)pointer = 0xff;\n      pointer = (undefined4 *)((long)pointer + (ulong)flag * -2 + 1);\n    }\n    currentRecord = *(undefined8 **)(recordUnit + 0x28);\n    if (currentRecord == (undefined8 *)0x0) {\n      currentRecord = *(undefined8 **)(recordUnit + 8);\n      currentRecord[2] = newRecord;\n    }\n    else {\n      *currentRecord = newRecord;\n    }\n    *(undefined4 **)(recordUnit + 0x28) = newRecord;\nLAB_0010c056:\n    result = CONCAT71((int7)((ulong)currentRecord >> 8),1);\n  }\n  return result;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bf86",
            "calling": [
                "FUN_0010554f",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "update_record_line_0010bf86"
        },
        "qsort": {
            "renaming": {},
            "code": "\n\n\nvoid qsort(void *__base,size_t __nmemb,size_t __size,__compar_fn_t __compar)\n\n{\n  qsort(__base,__nmemb,__size,__compar);\n  return;\n}\n\n",
            "called": [
                "qsort"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104140",
            "calling": [
                "FUN_0010554f",
                "FUN_001086af",
                "FUN_00116852"
            ],
            "imported": false,
            "current_name": "qsort"
        },
        "FUN_0011a170": {
            "renaming": {
                "FUN_0011a170": "match_pattern_0011a170",
                "param_1": "pattern",
                "param_2": "inputStr",
                "__pattern": "currentPattern",
                "iVar1": "matchResult"
            },
            "code": "\nint matchPattern_0011a170(char **pattern,char **inputStr)\n\n{\n  char *currentPattern;\n  int matchResult;\n  \n  currentPattern = *pattern;\n  if (*currentPattern == '!') {\n    matchResult = fnmatch(currentPattern + 1,*inputStr,0);\n    if (matchResult == 0) {\n      *(undefined *)(inputStr + 1) = 0;\n      return matchResult;\n    }\n  }\n  else {\n    matchResult = fnmatch(currentPattern,*inputStr,0);\n    if (matchResult == 0) {\n      *(undefined *)(inputStr + 1) = 1;\n    }\n  }\n  return 1;\n}\n\n",
            "called": [
                "fnmatch"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0011a170",
            "calling": [
                "FUN_0010554f",
                "FUN_00115d70"
            ],
            "imported": false,
            "current_name": "match_pattern_0011a170"
        },
        "FUN_0010bd62": {
            "renaming": {
                "FUN_0010bd62": "record_parameter_0010bd62",
                "param_1": "functionPointer",
                "param_2": "size",
                "param_3": "length",
                "param_4": "paramCode",
                "param_5": "paramPointer",
                "puVar1": "current",
                "uVar2": "errorMsg",
                "puVar3": "newParam",
                "puVar4": "temp",
                "lVar5": "tempLength",
                "puVar6": "lastParam",
                "puVar7": "paramArray",
                "bVar8": "flag"
            },
            "code": "\n\n\nundefined8\nrecordParameter_0010bd62(long functionPointer,long size,long length,undefined4 paramCode,undefined8 paramPointer)\n\n{\n  undefined8 *current;\n  undefined8 errorMsg;\n  undefined4 *newParam;\n  undefined8 *temp;\n  long tempLength;\n  undefined8 *lastParam;\n  undefined4 *paramArray;\n  byte flag;\n  \n  flag = 0;\n  if (size == 0) {\n    return 0;\n  }\n  if (length != 0) {\n    if ((*(long *)(functionPointer + 8) != 0) && (*(long *)(functionPointer + 0x18) != 0)) {\n      newParam = (undefined4 *)xmalloc(0x28);\n      paramArray = newParam;\n      for (tempLength = 10; tempLength != 0; tempLength = tempLength + -1) {\n        *paramArray = 0;\n        paramArray = paramArray + (ulong)flag * -2 + 1;\n      }\n      tempLength = *(long *)(functionPointer + 0x18);\n      *(long *)(newParam + 2) = size;\n      *(long *)(newParam + 4) = length;\n      newParam[6] = paramCode;\n      current = *(undefined8 **)(tempLength + 8);\n      *(undefined8 *)(newParam + 8) = paramPointer;\n      lastParam = (undefined8 *)(tempLength + 8);\n      while (temp = current, temp != (undefined8 *)0x0) {\n        lastParam = temp;\n        current = (undefined8 *)*temp;\n      }\n      *lastParam = newParam;\n      return 1;\n    }\n    errorMsg = dcgettext(0,\"debug_record_parameter: no current function\",5);\n    fprintf(_stderr,\"%s\\n\",errorMsg);\n  }\n  return 0;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010bd62",
            "calling": [
                "FUN_0011173a",
                "FUN_00112a33"
            ],
            "imported": false,
            "current_name": "record_parameter_0010bd62"
        },
        "FUN_00104ea2": {
            "renaming": {
                "FUN_00104ea2": "copy_archive_00104ea2",
                "unaff_EBX": "errorCode",
                "unaff_RBP": "fileStatus",
                "unaff_R12": "archivePath",
                "unaff_R13": "tempDirs",
                "unaff_R15": "archiveFiles",
                "param_7": "outputFileName",
                "param_8": "fileSize",
                "param_9": "tempDir",
                "param_10": "inputFileName",
                "param_11": "permissions",
                "param_18": "permissionsMask",
                "param_19": "numFiles"
            },
            "code": "\nvoid copyArchive_00104ea2(void)\n\n{\n  char cVar1;\n  int iVar2;\n  char **ppcVar3;\n  void *pvVar4;\n  long lVar5;\n  char **ppcVar6;\n  char *pcVar7;\n  undefined8 *puVar8;\n  int *piVar9;\n  char *pcVar10;\n  undefined8 uVar11;\n  long lVar12;\n  code *pcVar13;\n  long lVar14;\n  int errorCode;\n  stat *fileStatus;\n  char *pcVar15;\n  stat *psVar16;\n  char *archivePath;\n  undefined8 *tempDirs;\n  char **archiveFiles;\n  byte bVar17;\n  undefined8 unaff_retaddr;\n  undefined8 *outputFileName;\n  long *fileSize;\n  char *tempDir;\n  undefined8 *inputFileName;\n  undefined8 permissions;\n  undefined8 in_stack_00000030;\n  uint permissionsMask;\n  long numFiles;\n  \n  bVar17 = 0;\ncode_r0x00104ea2:\n  ppcVar6 = (char **)bfd_openw(archivePath,permissions);\n  if (ppcVar6 == (char **)0x0) {\nLAB_00104e80:\n    FUN_001126c0(archivePath,0,0,0);\nLAB_00104e93:\n    DAT_00127a40 = 1;\n  }\n  else {\nLAB_00114a5f:\n    cVar1 = FUNC_00114e50(archiveFiles,ppcVar6,unaff_retaddr);\n    if (cVar1 == '\\0') {\n      iVar2 = bfd_get_arch(archiveFiles);\n      if (iVar2 == 0) goto LAB_00104d75;\n      cVar1 = bfd_close_all_done(ppcVar6);\n      if (cVar1 != '\\0') goto LAB_00104ec9;\n      FUN_001126c0(archivePath,0,0,0);\n      goto LAB_00104ec9;\n    }\n    cVar1 = bfd_close(ppcVar6);\n    ppcVar6 = archiveFiles;\n    if (cVar1 == '\\0') {\n      FUN_001126c0(archivePath,0,0,0);\n      DAT_00127a40 = 1;\n    }\nLAB_00114a86:\n    if ((DAT_001279eb != '\\0') && (errorCode == 0)) {\n      FUN_0011a350(archivePath,fileStatus);\n    }\n    lVar12 = bfd_openr(archivePath,permissions);\n    tempDirs[2] = lVar12;\n    *fileSize = lVar12;\n    fileSize = (long *)(lVar12 + 0xf0);\n    archiveFiles = (char **)bfd_openr_next_archived_file(inputFileName,ppcVar6);\n    bfd_close(ppcVar6);\n    while ((DAT_00127a40 == 0 && (archiveFiles != (char **)0x0))) {\n      pcVar10 = *archiveFiles;\n      pcVar7 = pcVar10;\n      if (*pcVar10 == '/') {\nLAB_0010527d:\n        uVar11 = dcgettext(0,\"illegal pathname found in archive member: %s\",5);\n        FUN_00119ed0(uVar11,pcVar10);\n        goto LAB_00104e93;\n      }\n      while (*pcVar7 != '\\0') {\n        pcVar15 = pcVar7;\n        if ((*pcVar7 == '.') && (pcVar15 = pcVar7 + 1, pcVar7[1] == '.')) {\n          pcVar15 = pcVar7 + 2;\n          if ((pcVar7[2] == '\\0') || (pcVar7[2] == '/')) goto LAB_0010527d;\n        }\n        for (; (*pcVar15 != '\\0' && (*pcVar15 != '/')); pcVar15 = pcVar15 + 1) {\n        }\n        pcVar7 = pcVar15;\n        if (*pcVar15 == '/') {\n          FUN_001052a2();\n          return;\n        }\n      }\n      fileStatus = (stat *)&stack0x00000050;\n      archivePath = (char *)concat(tempDir,&DAT_0011b47d);\n      iVar2 = stat(archivePath,fileStatus);\n      puVar8 = tempDirs;\n      if (-1 < iVar2) {\n        lVar12 = FUN_0011a0e0(archivePath);\n        free(archivePath);\n        if (lVar12 == 0) {\n          piVar9 = __errno_location();\n          pcVar10 = strerror(*piVar9);\n          uVar11 = dcgettext(0,\"cannot create tempdir for archive copying (error: %s)\",5);\n          FUN_00119ed0(uVar11,pcVar10);\n          goto LAB_00104e93;\n        }\n        puVar8 = (undefined8 *)xmalloc(0x18);\n        pcVar10 = *archiveFiles;\n        *puVar8 = tempDirs;\n        puVar8[2] = 0;\n        puVar8[1] = lVar12;\n        archivePath = (char *)concat(lVar12,&DAT_0011b47d,pcVar10);\n      }\n      errorCode = 0;\n      if (DAT_001279eb != '\\0') {\n        psVar16 = fileStatus;\n        for (lVar12 = 0x24; lVar12 != 0; lVar12 = lVar12 + -1) {\n          *(undefined4 *)&psVar16->st_dev = 0;\n          psVar16 = (stat *)((long)psVar16 + (ulong)bVar17 * -8 + 4);\n        }\n        ppcVar6 = (char **)archiveFiles[0x1d];\n        if ((char **)archiveFiles[0x1d] == (char **)0x0) {\n          ppcVar6 = archiveFiles;\n        }\n        errorCode = (**(code **)(ppcVar6[1] + 0x1e8))(archiveFiles,fileStatus);\n        if (errorCode != 0) {\n          pcVar10 = *archiveFiles;\n          uVar11 = dcgettext(0,\"internal stat error on %s\",5);\n          FUN_00119ed0(uVar11,pcVar10);\n        }\n      }\n      tempDirs = (undefined8 *)xmalloc(0x18);\n      tempDirs[1] = archivePath;\n      *tempDirs = puVar8;\n      tempDirs[2] = 0;\n      cVar1 = bfd_check_format(archiveFiles,1);\n      if (cVar1 != '\\0') {\n        if (in_stack_00000030._7_1_ != '\\0') goto code_r0x00104ea2;\n        ppcVar6 = (char **)bfd_openw(archivePath,*(undefined8 *)archiveFiles[1]);\n        if (ppcVar6 == (char **)0x0) goto LAB_00104e80;\n        goto LAB_00114a5f;\n      }\n      uVar11 = dcgettext(0,\"Unable to recognise the format of file\",5);\n      FUN_001126c0(0,archiveFiles,0,uVar11);\n      ppcVar6 = (char **)bfd_openw(archivePath,permissions);\n      if (ppcVar6 == (char **)0x0) goto LAB_00104e80;\nLAB_00104d75:\n      ppcVar3 = (char **)archiveFiles[0x1d];\n      if ((char **)archiveFiles[0x1d] == (char **)0x0) {\n        ppcVar3 = archiveFiles;\n      }\n      iVar2 = (**(code **)(ppcVar3[1] + 0x1e8))(archiveFiles);\n      lVar12 = numFiles;\n      if (iVar2 == 0) {\n        if (numFiles < 0) {\n          FUN_001125fa(archiveFiles);\n          uVar11 = dcgettext(0,\"stat returns negative size for `%s\\'\",5);\n          FUN_00119ed0(uVar11);\n        }\n        else {\n          iVar2 = bfd_seek(archiveFiles,0,0);\n          if (iVar2 == 0) {\n            if (DAT_001279e9 != '\\0') {\n              pcVar10 = *ppcVar6;\n              uVar11 = FUN_001125fa(archiveFiles);\n              pcVar7 = (char *)dcgettext(0,\"copy from `%s\\' [unknown] to `%s\\' [unknown]\\n\",5);\n              printf(pcVar7,uVar11,pcVar10);\n            }\n            pvVar4 = (void *)xmalloc(0x2000);\n            while( true ) {\n              if (lVar12 == 0) {\n                chmod(*ppcVar6,permissionsMask | 0x100);\n                free(pvVar4);\n                cVar1 = bfd_close_all_done(ppcVar6);\n                ppcVar6 = archiveFiles;\n                if (cVar1 == '\\0') {\n                  FUN_001126c0(archivePath,0,0,0);\n                  DAT_00127a40 = 1;\n                }\n                goto LAB_00114a86;\n              }\n              lVar14 = 0x2000;\n              if (lVar12 < 0x2001) {\n                lVar14 = lVar12;\n              }\n              lVar5 = bfd_bread(pvVar4,lVar14,archiveFiles);\n              ppcVar3 = archiveFiles;\n              if ((lVar14 != lVar5) ||\n                 (lVar5 = bfd_bwrite(pvVar4,lVar14,ppcVar6), ppcVar3 = ppcVar6, lVar14 != lVar5))\n              break;\n              lVar12 = lVar12 - lVar14;\n            }\n            FUN_001126c0(0,ppcVar3,0,0);\n            free(pvVar4);\n          }\n          else {\n            uVar11 = FUN_001125fa(archiveFiles);\n            FUN_0011a110(uVar11);\n          }\n        }\n      }\n      else {\n        FUN_001126c0(0,archiveFiles,0,0);\n      }\n      cVar1 = bfd_close_all_done(ppcVar6);\n      if (cVar1 == '\\0') {\n        FUN_001126c0(archivePath,0,0,0);\n      }\nLAB_00104ec9:\n      unlink(archivePath);\n      DAT_00127a40 = 1;\n    }\n    *fileSize = 0;\n    pvVar4 = (void *)xstrdup(*outputFileName);\n    if (DAT_00127a40 == 0) {\n      pcVar13 = bfd_close;\n    }\n    else {\n      pcVar13 = bfd_close_all_done;\n    }\n    cVar1 = (*pcVar13)(outputFileName);\n    if (cVar1 == '\\0') {\n      DAT_00127a40 = 1;\n      FUN_001126c0(pvVar4,0,0,0);\n    }\n    free(pvVar4);\n    pvVar4 = (void *)xstrdup(*inputFileName);\n    cVar1 = bfd_close(inputFileName);\n    if (cVar1 == '\\0') {\n      DAT_00127a40 = 1;\n      FUN_001126c0(pvVar4,0,0,0);\n    }\n    free(pvVar4);\n  }\n  while (tempDirs != (undefined8 *)0x0) {\n    if (tempDirs[2] == 0) {\n      rmdir((char *)tempDirs[1]);\n    }\n    else {\n      bfd_close();\n      unlink((char *)tempDirs[1]);\n    }\n    free((void *)tempDirs[1]);\n    puVar8 = (undefined8 *)*tempDirs;\n    free(tempDirs);\n    tempDirs = puVar8;\n  }\n  rmdir(tempDir);\n  free(tempDir);\n  return;\n}\n\n",
            "called": [
                "FUN_001125fa",
                "dcgettext",
                "bfd_bwrite",
                "FUN_00114b84",
                "FUN_001052a2",
                "xstrdup",
                "strerror",
                "FUN_001126c0",
                "bfd_openr_next_archived_file",
                "FUN_0011a350",
                "bfd_bread",
                "bfd_openr",
                "bfd_seek",
                "bfd_close",
                "bfd_get_arch",
                "stat",
                "xmalloc",
                "FUN_0011a110",
                "FUN_00119ed0",
                "FUN_00104ea2",
                "bfd_close_all_done",
                "bfd_check_format",
                "bfd_openw",
                "FUN_0011a0e0",
                "free",
                "__errno_location",
                "unlink",
                "bfd_close_all_done",
                "printf",
                "bfd_close",
                "concat",
                "rmdir",
                "chmod",
                "FUN_00114e50"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104ea2",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "copy_archive_00104ea2"
        },
        "bfd_errmsg": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001047a0",
            "calling": [
                "FUN_0010e6a8",
                "FUN_00116b90",
                "FUN_0011a110",
                "FUN_0010e07c",
                "FUN_0011378f",
                "FUN_0010e2f0",
                "FUN_0010554f",
                "FUN_001126c0",
                "FUN_0010dac0"
            ],
            "imported": false,
            "current_name": "bfd_errmsg"
        },
        "fwrite": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104800",
            "calling": [
                "FUN_00108b3e",
                "FUN_00107880",
                "FUN_001126c0"
            ],
            "imported": false,
            "current_name": "fwrite"
        },
        "FUN_00113ce0": {
            "renaming": {
                "FUN_00113ce0": "allocate_and_set_data_00113ce0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "unused_param1",
                "param_5": "unused_param2",
                "lVar1": "allocation_result",
                "plVar2": "allocated_buffer",
                "auVar3": "return_value"
            },
            "code": "\nundefined  [16]\nallocate_and_set_data_00113ce0(long input1,long input2,undefined input3,undefined8 unused_param1,undefined8 unused_param2)\n\n{\n  long allocation_result;\n  long *allocated_buffer;\n  undefined return_value [16];\n  \n  if (input1 != 0) {\n    allocation_result = FUN_00112904(0xd,0);\n    if (allocation_result != 0) {\n      allocated_buffer = (long *)xmalloc(0x18);\n      *(undefined4 *)((long)allocated_buffer + 0x11) = 0;\n      *allocated_buffer = input1;\n      *(undefined4 *)((long)allocated_buffer + 0x14) = 0;\n      allocated_buffer[1] = input2;\n      *(undefined *)(allocated_buffer + 2) = input3;\n      *(long **)(allocation_result + 0x10) = allocated_buffer;\n      goto LAB_00113d2f;\n    }\n  }\n  allocation_result = 0;\nLAB_00113d2f:\n  return_value._8_8_ = unused_param2;\n  return_value._0_8_ = allocation_result;\n  return return_value;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00112904"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00113ce0",
            "calling": [
                "FUN_0010ee3f",
                "FUN_0010b0fa",
                "FUN_0010c95e",
                "FUN_0010dac0",
                "FUN_0011173a"
            ],
            "imported": false,
            "current_name": "allocate_and_set_data_00113ce0"
        },
        "FUN_00114dc7": {
            "renaming": {
                "FUN_00114dc7": "read_and_resize_buffer_00114dc7",
                "unaff_RBX": "filePointer",
                "unaff_RBP": "bufferPointer",
                "unaff_R12": "currentOffset",
                "unaff_R14": "maxOffset",
                "iVar1": "errorFlag",
                "uVar2": "errorString",
                "uVar3": "errorMessage",
                "sVar4": "bytesRead"
            },
            "code": "\nvoid readAndResizeBuffer_00114dc7(void)\n\n{\n  int errorFlag;\n  undefined8 errorString;\n  undefined8 errorMessage;\n  size_t bytesRead;\n  FILE *filePointer;\n  long bufferPointer;\n  long currentOffset;\n  long maxOffset;\n  \n  while( true ) {\n    bytesRead = fread((void *)(*(long *)(bufferPointer + 0x20) + currentOffset),1,maxOffset - currentOffset,\n                  filePointer);\n    errorFlag = ferror(filePointer);\n    if (errorFlag != 0) {\n      errorMessage = *(undefined8 *)(bufferPointer + 0x10);\n      errorString = dcgettext(0,\"%s: fread failed\",5);\n                    \n      FUN_00119dd0(errorString,errorMessage);\n    }\n    currentOffset = currentOffset + bytesRead;\n    errorFlag = feof(filePointer);\n    if (errorFlag != 0) break;\n    if (currentOffset == maxOffset) {\n      maxOffset = currentOffset * 2;\n      errorMessage = xrealloc(*(undefined8 *)(bufferPointer + 0x20),maxOffset);\n      *(undefined8 *)(bufferPointer + 0x20) = errorMessage;\n    }\n  }\n  *(long *)(bufferPointer + 0x18) = currentOffset;\n  fclose(filePointer);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "xrealloc",
                "FUN_00114dc7",
                "fclose",
                "FUN_00119dd0",
                "feof",
                "ferror",
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00114dc7",
            "calling": [
                "FUN_00114dc7"
            ],
            "imported": false,
            "current_name": "read_and_resize_buffer_00114dc7"
        },
        "FUN_00119f70": {
            "renaming": {
                "FUN_00119f70": "process_data_00119f70",
                "param_1": "headerData",
                "param_2": "outputData",
                "uVar1": "formatValue",
                "cVar2": "charFlag",
                "iVar3": "counter",
                "uVar4": "formatValue2",
                "uVar5": "formatValue3",
                "__format": "formatString",
                "lVar6": "allocatedSize",
                "uVar7": "printableValue",
                "lVar8": "reallocSize"
            },
            "code": "\nundefined4 processData_00119f70(undefined8 *headerData,undefined8 *outputData)\n\n{\n  undefined4 formatValue;\n  char charFlag;\n  int counter;\n  undefined8 formatValue2;\n  undefined8 formatValue3;\n  char *formatString;\n  long allocatedSize;\n  undefined8 printableValue;\n  long reallocSize;\n  \n  counter = *(int *)((long)outputData + 0xc) + 1;\n  *(int *)((long)outputData + 0xc) = counter;\n  if ((ulong)outputData[2] < (ulong)((long)counter * 0x60)) {\n    allocatedSize = 0x3000;\n    if (0x3f < counter) {\n      allocatedSize = (long)counter * 0xc0;\n    }\n    reallocSize = xrealloc(outputData[3]);\n    outputData[3] = reallocSize;\n    memset((void *)(reallocSize + outputData[2]),0,allocatedSize - outputData[2]);\n    outputData[2] = allocatedSize;\n  }\n  formatValue = *(undefined4 *)((long)headerData + 0xc);\n  *(undefined8 *)((long)*(int *)((long)outputData + 0xc) * 0x60 + outputData[3] + -0x60) = *headerData;\n  formatValue2 = FUN_00114e00(formatValue);\n  formatValue3 = FUN_00114e00(*(undefined4 *)(headerData + 2));\n  printableValue = *headerData;\n  formatString = (char *)dcgettext(0,\"%s\\n (header %s, data %s)\\n\",5);\n  printf(formatString,printableValue,formatValue3,formatValue2);\n  allocatedSize = bfd_openw(*outputData,*headerData);\n  if (allocatedSize == 0) {\n    FUN_0011a110(*outputData);\n    *(undefined4 *)(outputData + 1) = 1;\n  }\n  else {\n    counter = 2;\n    charFlag = bfd_set_format(allocatedSize,1);\n    if (charFlag == '\\0') {\n      counter = bfd_get_error();\n      if (counter != 5) {\n        FUN_0011a110(*headerData);\n        *(undefined4 *)(outputData + 1) = 1;\n      }\n    }\n    else {\n      do {\n        charFlag = (**(code **)(*(long *)(allocatedSize + 8) + 0x2a0))(allocatedSize,counter,0);\n        if (charFlag != '\\0') {\n          printableValue = bfd_printable_arch_mach(counter,0);\n          printf(\"  %s\\n\",printableValue);\n          *(undefined *)\n           ((long)*(int *)((long)outputData + 0xc) * 0x60 + outputData[3] + -0x58 + (ulong)(counter - 2)) =\n               1;\n        }\n        counter = counter + 1;\n      } while (counter != 0x57);\n    }\n    bfd_close_all_done(allocatedSize);\n  }\n  return *(undefined4 *)(outputData + 1);\n}\n\n",
            "called": [
                "dcgettext",
                "bfd_set_format",
                "FUN_0011a110",
                "bfd_openw",
                "bfd_get_error",
                "xrealloc",
                "memset",
                "bfd_close_all_done",
                "printf",
                "FUN_00114e00",
                "bfd_printable_arch_mach",
                "FUN_001053d5"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00119f70",
            "calling": [
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "process_data_00119f70"
        },
        "unlink": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040c0",
            "calling": [
                "FUN_00108200",
                "FUN_00104ea2",
                "FUN_001199d0"
            ],
            "imported": false,
            "current_name": "unlink"
        },
        "FUN_00115a90": {
            "renaming": {
                "FUN_00115a90": "extract_file_contents_00115a90",
                "param_1": "file_descriptor",
                "param_2": "file_path",
                "param_3": "permissions",
                "iVar1": "original_errno",
                "__fd": "extracted_file_descriptor",
                "iVar2": "read_result",
                "_Var3": "current_offset",
                "uVar4": "total_bytes_read",
                "sVar5": "bytes_written",
                "piVar6": "errno_ptr",
                "local_2038": "buffer"
            },
            "code": "\nulong extract_file_contents_00115a90(int file_descriptor,char *file_path,long permissions)\n\n{\n  int original_errno;\n  int extracted_file_descriptor;\n  int read_result;\n  __off_t current_offset;\n  ulong total_bytes_read;\n  size_t bytes_written;\n  int *errno_ptr;\n  undefined buffer [8200];\n  \n  if ((-1 < file_descriptor) && (current_offset = lseek(file_descriptor,0,0), current_offset == 0)) {\n    extracted_file_descriptor = open(file_path,0x201);\n    if (extracted_file_descriptor < 0) {\n      total_bytes_read = FUN_00108237();\n      return total_bytes_read;\n    }\n    do {\n      total_bytes_read = read(file_descriptor,buffer,0x2000);\n      read_result = (int)total_bytes_read;\n      if (read_result < 1) {\n        errno_ptr = __errno_location();\n        original_errno = *errno_ptr;\n        fchmod(extracted_file_descriptor,*(__mode_t *)(permissions + 0x18));\n        close(file_descriptor);\n        close(extracted_file_descriptor);\n        if (read_result != 0) {\n          *errno_ptr = original_errno;\n          return 0xffffffff;\n        }\n        return total_bytes_read & 0xffffffff;\n      }\n      bytes_written = write(extracted_file_descriptor,buffer,(long)read_result);\n    } while (bytes_written == (long)read_result);\n    errno_ptr = __errno_location();\n    read_result = *errno_ptr;\n    close(file_descriptor);\n    close(extracted_file_descriptor);\n    *errno_ptr = read_result;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "read",
                "lseek",
                "__errno_location",
                "write",
                "open",
                "close",
                "FUN_00108237",
                "fchmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00115a90",
            "calling": [
                "FUN_00115970"
            ],
            "imported": false,
            "current_name": "extract_file_contents_00115a90"
        },
        "strncpy": {
            "renaming": {},
            "code": "\n\n\nchar * strncpy(char *__dest,char *__src,size_t __n)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strncpy(__dest,__src,__n);\n  return pcVar1;\n}\n\n",
            "called": [
                "strncpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001040d0",
            "calling": [
                "FUN_00116b90",
                "FUN_00104ad6"
            ],
            "imported": false,
            "current_name": "strncpy"
        },
        "bfd_bwrite": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104530",
            "calling": [
                "FUN_00104ea2"
            ],
            "imported": false,
            "current_name": "bfd_bwrite"
        },
        "utimensat": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104060",
            "calling": [
                "FUN_0011a350"
            ],
            "imported": false,
            "current_name": "utimensat"
        },
        "getc": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001048b0",
            "calling": [
                "FUN_00116b90"
            ],
            "imported": false,
            "current_name": "getc"
        },
        "FUN_00108200": {
            "renaming": {
                "FUN_00108200": "copy_file_and_handle_errors_00108200",
                "unaff_RBP": "sourcePath",
                "unaff_R12B": "shouldDeleteSource",
                "unaff_R13": "errorFlag",
                "unaff_retaddr": "returnAddress",
                "piVar1": "errorPtr",
                "uVar2": "errorMessage",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16] copyFileAndHandleErrors_00108200(void)\n\n{\n  int *errorPtr;\n  undefined8 errorMessage;\n  char *sourcePath;\n  char shouldDeleteSource;\n  ulong errorFlag;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  errorPtr = __errno_location();\n  strerror(*errorPtr);\n  errorMessage = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  FUN_00119ed0(errorMessage);\n  unlink(sourcePath);\n  if (shouldDeleteSource != '\\0') {\n    FUN_0011a350();\n  }\n  returnValue._0_8_ = errorFlag & 0xffffffff;\n  returnValue._8_8_ = returnAddress;\n  return returnValue;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_0011a350",
                "__errno_location",
                "FUN_00119ed0",
                "unlink",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00108200",
            "calling": [
                "FUN_00115970"
            ],
            "imported": false,
            "current_name": "copy_file_and_handle_errors_00108200"
        },
        "bfd_alt_mach_code": {
            "renaming": {},
            "code": "\nvoid bfd_alt_mach_code(void)\n\n{\n  bfd_alt_mach_code();\n  return;\n}\n\n",
            "called": [
                "bfd_alt_mach_code"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00104590",
            "calling": [
                "FUN_0010554f"
            ],
            "imported": false,
            "current_name": "bfd_alt_mach_code"
        }
    },
    "used_tokens": 288948,
    "layers": [
        [
            "FUN_00113dfe",
            "FUN_0010ab4d",
            "FUN_0010c218",
            "FUN_0010be88",
            "FUN_0010ba08",
            "FUN_0010aa53",
            "FUN_0011173a",
            "FUN_00115dc0",
            "FUN_0010d559",
            "FUN_00119e70",
            "FUN_00108466",
            "FUN_00108e76",
            "FUN_0010bb52",
            "thunk_FUN_0010e439",
            "FUN_0011283f",
            "FUN_00108237",
            "FUN_0010bc80",
            "FUN_00114cf0",
            "FUN_0010a181",
            "FUN_001199d0",
            "FUN_0010847a",
            "FUN_0010d21c",
            "FUN_001054af",
            "FUN_0010c139",
            "FUN_0010e439",
            "FUN_00109d3e",
            "FUN_00112502",
            "FUN_00104cc1",
            "FUN_00113bfa",
            "FUN_00108375",
            "FUN_00109e76",
            "FUN_001088ae",
            "FUN_0010afd5",
            "FUN_00108b3e",
            "FUN_0010a083",
            "FUN_00109c2e",
            "FUN_001053b5",
            "FUN_00112996",
            "FUN_0010c7a0",
            "FUN_0010922b",
            "FUN_001052a2",
            "FUN_0010e453",
            "FUN_00109d5c",
            "FUN_0010ed2c",
            "FUN_0011a1b0",
            "FUN_001163d0",
            "FUN_00108a2a",
            "FUN_00108c86",
            "FUN_0010911f",
            "FUN_001053d5",
            "FUN_00104bba",
            "FUN_00109a0b",
            "FUN_0010da0b",
            "FUN_00112894",
            "FUN_00109b2f",
            "FUN_00108d9a",
            "FUN_0010e9a0",
            "FUN_0010827b",
            "FUN_00104920",
            "FUN_00113f20",
            "FUN_00108179",
            "FUN_00109022",
            "FUN_0010c05d",
            "FUN_00109d97",
            "FUN_001086af",
            "FUN_0010add5",
            "FUN_00113e17",
            "FUN_00109b52",
            "FUN_00109a32",
            "FUN_0010c6be",
            "FUN_0010b6ea",
            "FUN_0011a2e0",
            "FUN_0010e8a9",
            "FUN_00104ad6",
            "FUN_001087da",
            "FUN_0010914e",
            "FUN_0010829e",
            "FUN_00104943",
            "FUN_00113e23",
            "FUN_00108fb9",
            "FUN_00108ea1",
            "FUN_00108072",
            "FUN_0010a2b9",
            "FUN_0010ec73",
            "FUN_00114e00",
            "FUN_00115970",
            "FUN_0010adf2",
            "FUN_0010d7d4",
            "FUN_00113f50",
            "FUN_001087fd",
            "FUN_0011256b",
            "FUN_0011378f",
            "FUN_00104966",
            "FUN_0010a0a0",
            "FUN_00119ed0",
            "FUN_00112c1f",
            "FUN_0010808f",
            "FUN_00108fe8",
            "FUN_00105828",
            "FUN_0011a0e0",
            "FUN_0010bba1",
            "FUN_0010e6a8",
            "FUN_0010e7c2",
            "FUN_00119dd0",
            "FUN_001083b7",
            "FUN_00116852",
            "FUN_00113d3a",
            "FUN_0010a0d3",
            "FUN_00115530",
            "FUN_0010a0bd",
            "FUN_00113e5e",
            "FUN_0010abdd",
            "FUN_00115f30",
            "FUN_001129f4",
            "FUN_001082b3",
            "FUN_00114690",
            "FUN_0010b800",
            "FUN_00109ed3",
            "FUN_0010bbd3",
            "FUN_00115d00",
            "FUN_00113c43",
            "FUN_00112a33",
            "FUN_0010c2d2",
            "FUN_0010e07c",
            "FUN_001082c3",
            "FUN_00114460",
            "FUN_0010a94e",
            "FUN_00113b1e",
            "FUN_0010a0e9",
            "FUN_00114c20",
            "FUN_00115f50",
            "FUN_001083de",
            "FUN_0010b948",
            "FUN_00112b6e",
            "FUN_0010a83e",
            "FUN_00113d6e",
            "FUN_00114d50",
            "FUN_00108916",
            "FUN_001126c0",
            "FUN_00113b4a",
            "FUN_0010edb4",
            "FUN_0010e5db",
            "FUN_00104d25",
            "FUN_0010551d",
            "FUN_00108800",
            "FUN_0010c1c6",
            "FUN_001082df",
            "FUN_00114d60",
            "FUN_00108808",
            "FUN_00104d1c",
            "FUN_00119940",
            "FUN_0010540e",
            "FUN_00113a4d",
            "FUN_001081e9",
            "FUN_00113b71",
            "FUN_00109dfe",
            "FUN_00109bbb",
            "FUN_0010ae0e",
            "FUN_001135a5",
            "FUN_0010b0fa",
            "FUN_00104c36",
            "FUN_0010554f",
            "FUN_00109cf4",
            "FUN_00109ab1",
            "FUN_001159d0",
            "FUN_0010a77a",
            "FUN_0010543c",
            "FUN_0010a424",
            "FUN_00119970",
            "FUN_00114c80",
            "FUN_0010870e",
            "FUN_0010dac0",
            "FUN_00113fb0",
            "FUN_0010882c",
            "FUN_0010ebb0",
            "FUN_00113b98",
            "FUN_00115d70",
            "FUN_00109be3",
            "FUN_0011a480",
            "FUN_0010e918",
            "FUN_00116110",
            "FUN_0010871c",
            "FUN_0010bf20",
            "FUN_0010c95e",
            "FUN_0011a350",
            "FUN_0011a110",
            "FUN_0010e2f0",
            "FUN_00113fe0",
            "FUN_001125fa",
            "FUN_00108f05",
            "FUN_00108863",
            "FUN_00104020",
            "FUN_00108f08",
            "FUN_00114b84",
            "FUN_00114190",
            "FUN_00116490",
            "FUN_00104a35",
            "FUN_0010be1a",
            "FUN_00113da9",
            "FUN_0011a250",
            "FUN_0010a69a",
            "FUN_00115b70",
            "FUN_00116030",
            "FUN_00113ede",
            "FUN_0010875d",
            "FUN_0010c892",
            "FUN_00112904",
            "FUN_00108898",
            "FUN_0011a390",
            "FUN_0010e842",
            "FUN_00113cb9",
            "FUN_0010eafe",
            "FUN_00113df2",
            "FUN_0010a377",
            "FUN_0010d882",
            "FUN_00112925",
            "FUN_0010bf86",
            "FUN_0011a170",
            "FUN_0010bd62",
            "FUN_00104ea2",
            "FUN_00113ce0",
            "FUN_00114dc7",
            "FUN_00119f70",
            "FUN_00115a90",
            "FUN_00108200"
        ]
    ],
    "locked_functions": []
}