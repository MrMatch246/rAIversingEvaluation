{
    "functions": {
        "bfd_fdopenr": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenr(void)\n\n{\n  bfd_fdopenr();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_fdopenr"
        },
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "FUN_00102cd9": {
            "renaming": {
                "FUN_00102cd9": "find_matching_record_00102cd9",
                "in_EAX": "searchType",
                "iVar1": "comparisonResult",
                "unaff_RBX": "recordPointer",
                "param_7": "searchString"
            },
            "code": "\nlong * findMatchingRecord_00102cd9(void)\n\n{\n  int searchType;\n  int comparisonResult;\n  long *recordPointer;\n  undefined8 searchString;\n  \n  searchString = DAT_0010d638;\n  if (searchType == 3) {\n    for (; *recordPointer != 0; recordPointer = (long *)(*recordPointer + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*recordPointer != (undefined8 *)0x0; recordPointer = (long *)(*recordPointer + 0xf0)) {\n      comparisonResult = filename_cmp(*(undefined8 *)*recordPointer,searchString);\n      if (comparisonResult == 0) {\n        if (searchType != 2) {\n          return recordPointer;\n        }\n        return (long *)(*recordPointer + 0xf0);\n      }\n    }\n  }\n  return recordPointer;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102cd9",
            "calling": [
                "FUN_00105870"
            ],
            "imported": false,
            "current_name": "find_matching_record_00102cd9"
        },
        "bfd_close": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102490",
            "calling": [
                "FUN_00105300",
                "FUN_00102710",
                "FUN_00102d2f",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_close"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_0010d400 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_0010d2c8);\n  FUNC_00105cf0();\n  DAT_0010d400 = 1;\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize",
                "FUN_00105cf0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105d60",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "lbasename": {
            "renaming": {},
            "code": "\nvoid lbasename(void)\n\n{\n  lbasename();\n  return;\n}\n\n",
            "called": [
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "FUN_001028ed",
                "FUN_00105830",
                "FUN_00102e6f",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "lbasename"
        },
        "bfd_bread": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102540",
            "calling": [
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "bfd_bread"
        },
        "FUN_001079c0": {
            "renaming": {
                "FUN_001079c0": "print_file_info_001079c0",
                "param_1": "file",
                "param_2": "fileInfo",
                "param_3": "showPermissions",
                "param_4": "showAddress",
                "iVar1": "result",
                "ppcVar2": "ptr",
                "pcVar3": "timeString",
                "uVar4": "fileType",
                "local_100": "currentTime",
                "uStack_f3": "permission",
                "cStack_f2": "readOwner",
                "cStack_f1": "writeOwner",
                "cStack_f0": "executeOwner",
                "cStack_ef": "readGroup",
                "cStack_ee": "writeGroup",
                "cStack_ed": "executeGroup",
                "cStack_ec": "readOthers",
                "cStack_eb": "writeOthers",
                "cStack_ea": "executeOthers",
                "local_e8": "formattedTime",
                "local_b8": "buffer",
                "uStack_a0": "fileMode",
                "uStack_9c": "userId",
                "uStack_98": "groupId",
                "uStack_88": "fileSize",
                "local_60": "fileTime"
            },
            "code": "\nvoid printFileInfo_001079c0(FILE *file,char **fileInfo,char showPermissions,char showAddress)\n\n{\n  int result;\n  char **ptr;\n  char *timeString;\n  uint fileType;\n  time_t currentTime;\n  undefined permission;\n  char readOwner;\n  char writeOwner;\n  char executeOwner;\n  char readGroup;\n  char writeGroup;\n  char executeGroup;\n  char readOthers;\n  char writeOthers;\n  char executeOthers;\n  undefined uStack_e9;\n  char formattedTime [48];\n  undefined buffer [24];\n  uint fileMode;\n  uint userId;\n  uint groupId;\n  undefined8 fileSize;\n  time_t fileTime;\n  \n  if (showPermissions != '\\0') {\n    ptr = (char **)fileInfo[0x1d];\n    if ((char **)fileInfo[0x1d] == (char **)0x0) {\n      ptr = fileInfo;\n    }\n    result = (**(code **)(ptr[1] + 0x1e8))(fileInfo,buffer);\n    if (result == 0) {\n      currentTime = fileTime;\n      timeString = ctime(&currentTime);\n      if (timeString == (char *)0x0) {\n        timeString = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(formattedTime,timeString);\n      }\n      else {\n        sprintf(formattedTime,\"%.12s %.4s\",timeString + 4);\n      }\n      fileType = fileMode & 0xf000;\n      if (fileType == 0x4000) {\n        permission = 100;\n      }\n      else if (fileType == 0xa000) {\n        permission = 0x6c;\n      }\n      else if (fileType == 0x6000) {\n        permission = 0x62;\n      }\n      else if (fileType == 0x2000) {\n        permission = 99;\n      }\n      else if (fileType == 0xc000) {\n        permission = 0x73;\n      }\n      else {\n        permission = 0x70;\n        if (fileType != 0x1000) {\n          permission = 0x2d;\n        }\n      }\n      readOwner = (-((fileMode & 0x100) == 0) & 0xbbU) + 0x72;\n      writeOwner = (-((fileMode & 0x80) == 0) & 0xb6U) + 0x77;\n      executeOwner = (-((fileMode & 0x40) == 0) & 0xb5U) + 0x78;\n      readGroup = (-((fileMode & 0x20) == 0) & 0xbbU) + 0x72;\n      writeGroup = (-((fileMode & 0x10) == 0) & 0xb6U) + 0x77;\n      executeGroup = (-((fileMode & 8) == 0) & 0xb5U) + 0x78;\n      readOthers = (-((fileMode & 4) == 0) & 0xbbU) + 0x72;\n      writeOthers = (-((fileMode & 2) == 0) & 0xb6U) + 0x77;\n      executeOthers = (-((fileMode & 1) == 0) & 0xb5U) + 0x78;\n      if ((fileMode & 0x800) != 0) {\n        if (executeOwner == 'x') {\n          executeOwner = 's';\n        }\n        else {\n          executeOwner = 'S';\n        }\n      }\n      if ((fileMode & 0x400) != 0) {\n        if (executeGroup == 'x') {\n          executeGroup = 's';\n        }\n        else {\n          executeGroup = 'S';\n        }\n      }\n      if ((fileMode & 0x200) != 0) {\n        if (executeOthers == 'x') {\n          executeOthers = 't';\n        }\n        else {\n          executeOthers = 'T';\n        }\n      }\n      uStack_e9 = 0;\n      fprintf(file,\"%s %ld/%ld %6lu %s \",&readOwner,(ulong)userId,(ulong)groupId,fileSize,\n              formattedTime,(ulong)fileMode);\n    }\n  }\n  fputs(*fileInfo,file);\n  if (showAddress != '\\0') {\n    if ((*(byte *)((long)fileInfo + 0x49) & 0x10) == 0) {\n      if (fileInfo[0xb] != (char *)0x0) {\n        fprintf(file,\" 0x%lx\");\n      }\n    }\n    else if (fileInfo[0xc] != (char *)0x0) {\n      fprintf(file,\" 0x%lx\");\n    }\n  }\n  fputc(10,file);\n  return;\n}\n\n",
            "called": [
                "FUN_00102d8c",
                "ctime",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001079c0",
            "calling": [
                "FUN_00103ddc",
                "FUN_00107890"
            ],
            "imported": false,
            "current_name": "print_file_info_001079c0"
        },
        "FUN_00105a68": {
            "renaming": {
                "FUN_00105a68": "initialize_file_00105a68",
                "pcVar1": "directoryPath",
                "pFVar2": "filePointer",
                "sVar3": "pathLength"
            },
            "code": "\nvoid initializeFile_00105a68(void)\n\n{\n  char *directoryPath;\n  FILE *filePointer;\n  size_t pathLength;\n  \n  directoryPath = DAT_0010d5e8;\n  if (DAT_0010d5e8 != (char *)0x0) {\n    pathLength = strlen(DAT_0010d5e8);\n    if (pathLength != 0) {\n      if (directoryPath[pathLength - 1] == '/') {\n        DAT_0010d618 = (char *)concat(directoryPath,DAT_0010d618,0);\n      }\n      else {\n        DAT_0010d618 = (char *)concat(directoryPath,&DAT_00108260,DAT_0010d618,0);\n      }\n    }\n  }\n  if (DAT_0010d60c != 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  filePointer = fopen(DAT_0010d618,\"w\");\n  if (filePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "FUN_00102e57",
                "concat",
                "strlen",
                "perror",
                "printf",
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a68",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "initialize_file_00105a68"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "FUN_001032a8": {
            "renaming": {
                "FUN_001032a8": "extract_files_from_archive_001032a8",
                "param_1": "fileEntries",
                "param_2": "processFileCallback",
                "param_3": "entryNames",
                "param_4": "return_value",
                "lVar1": "nextEntry",
                "uVar2": "currentEntry",
                "bVar3": "foundEntry",
                "plVar4": "currentEntryPtr",
                "iVar5": "comparisonResult",
                "__format": "errorMsgFormat",
                "plVar6": "nextEntryPtr",
                "lVar7": "currentEntry",
                "plVar8": "previousEntryPtr"
            },
            "code": "\n\n\nundefined8 extractFilesFromArchive_001032a8(long *fileEntries,code *processFileCallback,undefined8 *entryNames,undefined8 return_value)\n\n{\n  long nextEntry;\n  undefined8 currentEntry;\n  bool foundEntry;\n  long *currentEntryPtr;\n  int comparisonResult;\n  char *errorMsgFormat;\n  long *nextEntryPtr;\n  long currentEntry;\n  long *previousEntryPtr;\n  \n  currentEntry = fileEntries[0x1e];\n  if (entryNames == (undefined8 *)0x0) {\n    while (currentEntry != 0) {\n      nextEntry = *(long *)(currentEntry + 0xf0);\n      (*processFileCallback)(currentEntry,0);\n      currentEntry = nextEntry;\n    }\n  }\n  else {\n    do {\n      foundEntry = false;\n      currentEntryPtr = (long *)fileEntries[0x1e];\n      previousEntryPtr = fileEntries;\n      while (nextEntryPtr = currentEntryPtr, nextEntryPtr != (long *)0x0) {\n        if (*nextEntryPtr != 0) {\n          comparisonResult = filename_cmp(*entryNames);\n          if (comparisonResult == 0) {\n            foundEntry = true;\n            (*processFileCallback)(nextEntryPtr,previousEntryPtr);\n          }\n        }\n        previousEntryPtr = nextEntryPtr;\n        currentEntryPtr = (long *)nextEntryPtr[0x1e];\n      }\n      if (!foundEntry) {\n        currentEntry = *entryNames;\n        errorMsgFormat = (char *)dcgettext(0,\"No entry %s in archive.\\n\",5);\n        fprintf(_stderr,errorMsgFormat,currentEntry);\n      }\n      entryNames = (undefined8 *)entryNames[1];\n    } while (entryNames != (undefined8 *)0x0);\n  }\n  return return_value;\n}\n\n",
            "called": [
                "filename_cmp",
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001032a8",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "extract_files_from_archive_001032a8"
        },
        "FUN_0010285f": {
            "renaming": {
                "FUN_0010285f": "print_archive_entry_not_found_error_0010285f",
                "__format": "formatString",
                "lVar2": "currentEntry",
                "plVar3": "nextEntry",
                "uVar4": "entry",
                "plVar5": "entryPointer",
                "unaff_RBP": "callback",
                "unaff_R12": "archivePtr",
                "unaff_R13D": "entryCount",
                "unaff_R14": "entryList",
                "iStack000000000000000c": "loopCounter"
            },
            "code": "\n\n\nvoid printArchiveEntryNotFoundError_0010285f(void)\n\n{\n  int iVar1;\n  char *formatString;\n  long currentEntry;\n  long *nextEntry;\n  undefined8 entry;\n  long *entryPointer;\n  code *callback;\n  long archivePtr;\n  int entryCount;\n  undefined8 *entryList;\n  int loopCounter;\n  \ncode_r0x0010285f:\n  entry = *entryList;\n  formatString = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n  fprintf(_stderr,formatString,entry);\nLAB_0010553e:\n  entryList = entryList + 1;\n  entryCount = entryCount + -1;\n  if (entryCount == 0) {\n    return;\n  }\n  entryPointer = *(long **)(archivePtr + 0xf0);\n  loopCounter = 0;\n  do {\n    if (entryPointer == (long *)0x0) goto code_r0x0010285f;\n    if (*(int *)((long)entryPointer + 0xac) == 0) {\n      currentEntry = *entryPointer;\n      if (currentEntry == 0) {\n        nextEntry = (long *)entryPointer[0x1d];\n        if ((long *)entryPointer[0x1d] == (long *)0x0) {\n          nextEntry = entryPointer;\n        }\n        (**(code **)(nextEntry[1] + 0x1e8))(entryPointer,&stack0x00000010);\n      }\n      else if (((*(byte *)(archivePtr + 0x49) & 0x10) == 0) || (currentEntry = FUN_00105830(), currentEntry != 0))\n      {\n        entry = FUN_00105830(*entryList);\n        iVar1 = filename_cmp(entry,currentEntry);\n        if ((iVar1 == 0) &&\n           ((DAT_0010d634 == '\\0' ||\n            (loopCounter = loopCounter + 1,\n            loopCounter == _DAT_0010d630)))) break;\n      }\n    }\n    entryPointer = (long *)entryPointer[0x1e];\n  } while( true );\n  (*callback)();\n  *(undefined4 *)((long)entryPointer + 0xac) = 1;\n  goto LAB_0010553e;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010285f",
            "calling": [
                "FUN_00105480"
            ],
            "imported": false,
            "current_name": "print_archive_entry_not_found_error_0010285f"
        },
        "bfd_set_archive_head": {
            "renaming": {},
            "code": "\nvoid bfd_set_archive_head(void)\n\n{\n  bfd_set_archive_head();\n  return;\n}\n\n",
            "called": [
                "bfd_set_archive_head"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "bfd_set_archive_head"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00102bb0",
                "FUN_00102c25",
                "FUN_00103a78",
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "vfprintf": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024b0",
            "calling": [
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "vfprintf"
        },
        "FUN_00102f96": {
            "renaming": {
                "FUN_00102f96": "print_error_message_00102f96",
                "uVar1": "errorString",
                "unaff_RBX": "errorCode",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\n\n\nvoid printErrorMessage_00102f96(void)\n\n{\n  undefined8 errorString;\n  long errorCode;\n  undefined8 returnAddress;\n  \n  errorString = dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (errorCode != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010d660);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010d660,errorString,returnAddress);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fflush",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f96",
            "calling": [
                "FUN_00107c20"
            ],
            "imported": false,
            "current_name": "print_error_message_00102f96"
        },
        "FUN_0010342d": {
            "renaming": {
                "FUN_0010342d": "print_usage_0010342d",
                "param_1": "verbosity",
                "uVar1": "format",
                "pcVar2": "localizedText",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid printUsage_0010342d(uint verbosity)\n\n{\n  undefined8 format;\n  char *localizedText;\n  FILE *outputStream;\n  \n  localizedText = (char *)dcgettext(0,\n                             \"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV] [--plugin <name>] [member-name] [count] archive-file file...\\n\"\n                             ,5);\n  outputStream = _stderr;\n  if (verbosity != 0) {\n    outputStream = _stdout;\n  }\n  fprintf(outputStream,localizedText,DAT_0010d660);\n  format = DAT_0010d660;\n  localizedText = (char *)dcgettext(0,\"       %s -M [<mri-script]\\n\",5);\n  fprintf(outputStream,localizedText,format);\n  localizedText = (char *)dcgettext(0,\" commands:\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  d            - delete file(s) from the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  m[ab]        - move file(s) in the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  p            - print file(s) found in the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  q[f]         - quick append file(s) to the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\n                             \"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\\n\"\n                             ,5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  s            - act as ranlib\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  t[O][v]      - display contents of the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  x[o]         - extract file(s) from the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\" command specific modifiers:\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [a]          - put file(s) after [member-name]\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [b]          - put file(s) before [member-name] (same as [i])\\n\",5\n                            );\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [D]          - use zero for timestamps and uids/gids (default)\\n\",\n                             5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [U]          - use actual timestamps and uids/gids\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [N]          - use instance [count] of name\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [f]          - truncate inserted file names\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [P]          - use full path names when matching\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [o]          - preserve original dates\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [O]          - display offsets of files in the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\n                             \"  [u]          - only replace files that are newer than current archive contents\\n\"\n                             ,5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\" generic modifiers:\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [c]          - do not warn if the library had to be created\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [s]          - create an archive index (cf. ranlib)\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [l <text> ]  - specify the dependencies of this library\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [S]          - do not build a symbol table\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [T]          - deprecated, use --thin instead\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [v]          - be verbose\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [V]          - display the version number\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  @<file>      - read options from <file>\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  --target=BFDNAME - specify the target object format as BFDNAME\\n\",\n                             5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\n                             \"  --output=DIRNAME - specify the output directory for extraction operations\\n\"\n                             ,5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\n                             \"  --record-libdeps=<text> - specify the dependencies of this library\\n\"\n                             ,5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  --thin       - make a thin archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\" optional:\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  --plugin <p> - load the specified plugin\\n\",5);\n  fprintf(outputStream,localizedText);\n  FUN_0010336b(outputStream);\n  FUN_0010266f(DAT_0010d660,outputStream);\n  if (verbosity != 0) {\n    localizedText = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,localizedText,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(verbosity ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "FUN_0010336b",
                "FUN_0010266f",
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010342d",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_usage_0010342d"
        },
        "FUN_0010394a": {
            "renaming": {
                "FUN_0010394a": "print_usage_0010394a",
                "param_1": "option",
                "uVar1": "message",
                "__stream": "output",
                "pcVar2": "text",
                "_stderr": "errorStream",
                "_stdout": "standardOut"
            },
            "code": "\n\n\nvoid printUsage_0010394a(uint option)\n\n{\n  undefined8 message;\n  char *text;\n  FILE *output;\n  \n  message = DAT_0010d660;\n  output = errorStream;\n  if (option != 0) {\n    output = standardOut;\n  }\n  text = (char *)dcgettext(0,\"Usage: %s [options] archive\\n\",5);\n  fprintf(output,text,message);\n  text = (char *)dcgettext(0,\" Generate an index to speed access to archives\\n\",5);\n  fprintf(output,text);\n  text = (char *)dcgettext(0,\n                             \" The options are:\\n  @<file>                      Read options from <file>\\n\"\n                             ,5);\n  fprintf(output,text);\n  text = (char *)dcgettext(0,\"  --plugin <name>              Load the specified plugin\\n\",5);\n  fprintf(output,text);\n  text = (char *)dcgettext(0,\n                             \"  -D                           Use zero for symbol map timestamp (default)\\n  -U                           Use an actual symbol map timestamp\\n\"\n                             ,5);\n  fprintf(output,text);\n  text = (char *)dcgettext(0,\n                             \"  -t                           Update the archive\\'s symbol map timestamp\\n  -h --help                    Print this help message\\n  -v --version                 Print version information\\n\"\n                             ,5);\n  fprintf(output,text);\n  FUN_0010266f(DAT_0010d660,output);\n  if (option != 0) {\n    text = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(output,text,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(option ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "FUN_0010266f",
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010394a",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_usage_0010394a"
        },
        "FUN_00107920": {
            "renaming": {
                "FUN_00107920": "process_data_00107920",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "param_6": "input6",
                "param_7": "input7",
                "param_8": "input8",
                "param_9": "input9",
                "param_10": "input10",
                "param_11": "input11",
                "param_12": "input12",
                "param_13": "input13",
                "param_14": "input14",
                "in_AL": "condition",
                "local_d8": "size",
                "local_d4": "length",
                "local_d0": "buffer",
                "local_c8": "localArray",
                "local_b8": "temporary",
                "local_b0": "param10_copy",
                "local_a8": "param11_copy",
                "local_a0": "param12_copy",
                "local_98": "param13_copy",
                "local_90": "param14_copy",
                "local_88": "input1_copy",
                "local_78": "input2_copy",
                "local_68": "input3_copy",
                "local_58": "input4_copy",
                "local_48": "input5_copy",
                "local_38": "input6_copy",
                "local_28": "input7_copy",
                "local_18": "input8_copy"
            },
            "code": "\nvoid processData_00107920(undefined4 input1,undefined4 input2,undefined4 input3,undefined4 input4,\n                 undefined4 input5,undefined4 input6,undefined4 input7,undefined4 input8,\n                 undefined8 input9,undefined8 input10,undefined8 input11,undefined8 input12,\n                 undefined8 input13,undefined8 input14)\n\n{\n  char condition;\n  undefined4 size;\n  undefined4 length;\n  undefined *buffer;\n  undefined *localArray;\n  undefined temporary [8];\n  undefined8 param10_copy;\n  undefined8 param11_copy;\n  undefined8 param12_copy;\n  undefined8 param13_copy;\n  undefined8 param14_copy;\n  undefined4 input1_copy;\n  undefined4 input2_copy;\n  undefined4 input3_copy;\n  undefined4 input4_copy;\n  undefined4 input5_copy;\n  undefined4 input6_copy;\n  undefined4 input7_copy;\n  undefined4 input8_copy;\n  \n  if (condition != '\\0') {\n    input1_copy = input1;\n    input2_copy = input2;\n    input3_copy = input3;\n    input4_copy = input4;\n    input5_copy = input5;\n    input6_copy = input6;\n    input7_copy = input7;\n    input8_copy = input8;\n  }\n  buffer = &stack0x00000008;\n  size = 8;\n  localArray = temporary;\n  length = 0x30;\n  param10_copy = input10;\n  param11_copy = input11;\n  param12_copy = input12;\n  param13_copy = input13;\n  param14_copy = input14;\n  FUN_001078c0(input9,&size);\n  return;\n}\n\n",
            "called": [
                "FUN_001078c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107920",
            "calling": [
                "FUN_00105300",
                "FUN_001052a0",
                "FUN_001025a0",
                "FUN_00102fd7",
                "FUN_00102e6f",
                "FUN_00105db0",
                "FUN_00102f1e"
            ],
            "imported": false,
            "current_name": "process_data_00107920"
        },
        "ctime": {
            "renaming": {},
            "code": "\n\n\nchar * ctime(time_t *__timer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = ctime(__timer);\n  return pcVar1;\n}\n\n",
            "called": [
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "ctime"
        },
        "bfd_set_default_target": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_default_target"
        },
        "bfd_get_error": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "FUN_00105300",
                "FUN_00107c20",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_get_error"
        },
        "bfd_fdopenw": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102570",
            "calling": [
                "FUN_00103c60",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "bfd_fdopenw"
        },
        "write": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "write"
        },
        "FUN_00105bb0": {
            "renaming": {
                "FUN_00105bb0": "initialize_00105bb0"
            },
            "code": "\nundefined8 initialize_00105bb0(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bb0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_00105bb0"
        },
        "FUN_00107640": {
            "renaming": {
                "FUN_00107640": "initialize_default_00107640"
            },
            "code": "\nundefined8 initializeDefault_00107640(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107640",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "initialize_default_00107640"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102590",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "FUN_00102e6f": {
            "renaming": {
                "FUN_00102e6f": "extract_file_path_00102e6f",
                "pcVar1": "baseFilePath",
                "in_RAX": "filePath",
                "uVar2": "baseName",
                "uVar3": "errorMsg",
                "pFVar4": "filePtr",
                "sVar5": "filePathLength",
                "pcVar6": "currentChar"
            },
            "code": "\nvoid extractFilePath_00102e6f(void)\n\n{\n  char *baseFilePath;\n  char *filePath;\n  undefined8 baseName;\n  undefined8 errorMsg;\n  FILE *filePtr;\n  size_t filePathLength;\n  char *currentChar;\n  \n  baseFilePath = DAT_0010d5e8;\n  do {\n    filePath = filePath + 1;\n    while (*filePath != '/') {\n      if (*filePath == '\\0') {\n        if ((DAT_0010d5e8 != (char *)0x0) && (filePathLength = strlen(DAT_0010d5e8), filePathLength != 0)) {\n          if (baseFilePath[filePathLength - 1] == '/') {\n            DAT_0010d618 = (char *)concat(baseFilePath,DAT_0010d618,0);\n          }\n          else {\n            DAT_0010d618 = (char *)concat(baseFilePath,&DAT_00108260,DAT_0010d618,0);\n          }\n        }\n        if (DAT_0010d60c != 0) {\n          printf(\"x - %s\\n\",DAT_0010d618);\n        }\n        filePtr = fopen(DAT_0010d618,\"w\");\n        if (filePtr == (FILE *)0x0) {\n          perror(DAT_0010d618);\n                    \n          xexit(1);\n        }\n        return;\n      }\n      currentChar = filePath;\n      if ((*filePath == '.') && (currentChar = filePath + 1, filePath[1] == '.')) {\n        currentChar = filePath + 2;\n        if ((filePath[2] == '/') || (filePath[2] == '\\0')) {\n          baseName = lbasename();\n          baseFilePath = DAT_0010d618;\n          errorMsg = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\"\n                            ,5);\n          FUN_00107920(errorMsg,baseFilePath,baseName);\n          DAT_0010d618 = (char *)baseName;\n          FUN_00105a68();\n          return;\n        }\n      }\n      for (; (filePath = currentChar, *currentChar != '\\0' && (*currentChar != '/')); currentChar = currentChar + 1) {\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00105a68",
                "FUN_00107920",
                "FUN_00102e6f",
                "lbasename",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e6f",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "extract_file_path_00102e6f"
        },
        "FUN_0010315d": {
            "renaming": {
                "FUN_0010315d": "check_and_exit_if_zero_0010315d",
                "xexit": "forceExit"
            },
            "code": "\n\n\nvoid checkAndExitIfZero_0010315d(void)\n\n{\n  if (_DAT_0010d608 == 0) {\n                    \n    xexit(9);\n  }\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010315d",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_and_exit_if_zero_0010315d"
        },
        "textdomain": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "textdomain"
        },
        "concat": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_00105a68",
                "FUN_00102e57"
            ],
            "imported": false,
            "current_name": "concat"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "FUN_00107890": {
            "renaming": {
                "FUN_00107890": "print_formatted_output_00107890",
                "param_1": "output",
                "_stdout": "standardOutput"
            },
            "code": "\n\n\nvoid printFormattedOutput_00107890(undefined8 output)\n\n{\n  FUN_001079c0(standardOutput,output,DAT_0010d60c != 0,_DAT_0010d5fc != 0);\n  return;\n}\n\n",
            "called": [
                "FUN_001079c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107890",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_formatted_output_00107890"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102500",
            "calling": [
                "FUN_001075e0",
                "FUN_001033b0"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "bfd_check_format": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102520",
            "calling": [
                "FUN_00103c60",
                "FUN_00102710",
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "bfd_check_format"
        },
        "FUN_001033d6": {
            "renaming": {
                "FUN_001033d6": "allocate_buffer_001033d6",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "pvVar1": "buffer",
                "pvVar2": "aux_buffer",
                "auVar3": "result"
            },
            "code": "\nundefined  [16]\nallocate_buffer_001033d6(undefined8 arg1,undefined8 arg2,undefined8 arg3,undefined8 arg4)\n\n{\n  void *buffer;\n  void *aux_buffer;\n  undefined result [16];\n  \n  buffer = malloc(0x40);\n  if (buffer != (void *)0x0) goto LAB_001033f7;\n  do {\n    buffer = (void *)FUN_001033b0(\"out of dynamic memory in yy_create_buffer()\");\nLAB_001033f7:\n    *(undefined4 *)((long)buffer + 0x18) = 0x4000;\n    aux_buffer = malloc(0x4002);\n    *(void **)((long)buffer + 8) = aux_buffer;\n  } while (aux_buffer == (void *)0x0);\n  *(undefined4 *)((long)buffer + 0x20) = 1;\n  FUN_001031cf(buffer,arg1);\n  result._8_8_ = arg4;\n  result._0_8_ = buffer;\n  return result;\n}\n\n",
            "called": [
                "FUN_001031cf",
                "malloc",
                "FUN_001033b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033d6",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "allocate_buffer_001033d6"
        },
        "fileno": {
            "renaming": {},
            "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "FUN_00105db0",
                "FUN_001031cf"
            ],
            "imported": false,
            "current_name": "fileno"
        },
        "FUN_00103172": {
            "renaming": {
                "FUN_00103172": "update_and_print_00103172",
                "param_1": "source_ptr",
                "param_2": "target_ptr",
                "param_3": "flag",
                "param_4": "data",
                "uVar1": "source_value",
                "auVar2": "result"
            },
            "code": "\nundefined  [16]\nupdate_and_print_00103172(undefined8 *source_ptr,undefined8 *target_ptr,char flag,undefined8 data)\n\n{\n  undefined8 source_value;\n  undefined result [16];\n  \n  if (flag != '\\0') {\n    printf(\"r - %s\\n\",*target_ptr);\n  }\n  source_value = *source_ptr;\n  target_ptr[0x1e] = source_value;\n  result._1_7_ = (undefined7)((ulong)source_value >> 8);\n  result[0] = 1;\n  *source_ptr = target_ptr;\n  result._8_8_ = data;\n  return result;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103172",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "update_and_print_00103172"
        },
        "FUN_00105870": {
            "renaming": {
                "FUN_00105870": "find_last_match_00105870",
                "param_1": "array",
                "param_2": "size",
                "param_3": "target",
                "iVar1": "cmp_result",
                "iVar3": "search_mode",
                "uVar2": "default_target"
            },
            "code": "\nlong * find_last_match_00105870(long *array,int size,undefined8 target)\n\n{\n  int cmp_result;\n  undefined8 default_target;\n  int search_mode;\n  \n  default_target = DAT_0010d638;\n  search_mode = DAT_0010d640;\n  if (DAT_0010d640 == 0) {\n    default_target = target;\n    search_mode = size;\n  }\n  if (search_mode == 3) {\n    for (; *array != 0; array = (long *)(*array + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*array != (undefined8 *)0x0; array = (long *)(*array + 0xf0)) {\n      cmp_result = filename_cmp(*(undefined8 *)*array,default_target);\n      if (cmp_result == 0) {\n        if (search_mode != 2) {\n          return array;\n        }\n        return (long *)(*array + 0xf0);\n      }\n    }\n  }\n  return array;\n}\n\n",
            "called": [
                "FUN_00102cd9"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105870",
            "calling": [
                "FUN_001028ed",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "find_last_match_00105870"
        },
        "FUN_001030ed": {
            "renaming": {
                "FUN_001030ed": "initialize_data_001030ed",
                "puVar1": "dataPointer"
            },
            "code": "\nvoid initializeData_001030ed(void)\n\n{\n  undefined8 *dataPointer;\n  \n  dataPointer = *(undefined8 **)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n  DAT_0010d598 = *(undefined4 *)((long)dataPointer + 0x1c);\n  DAT_0010d5b0 = (undefined *)dataPointer[2];\n  DAT_0010d5c8 = DAT_0010d5b0;\n  DAT_0010d590 = *dataPointer;\n  DAT_0010d588 = *DAT_0010d5b0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001030ed",
            "calling": [
                "FUN_001031cf",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "initialize_data_001030ed"
        },
        "FUN_00105bc0": {
            "renaming": {
                "FUN_00105bc0": "copy_file_and_unlink_00105bc0",
                "param_1": "sourceFilePath",
                "param_2": "destinationFilePath",
                "param_3": "flags",
                "param_4": "result",
                "uVar1": "copyResult",
                "piVar2": "errnoPtr",
                "pcVar3": "errorString",
                "uVar4": "errorMessage",
                "uVar5": "unlinkResult",
                "auVar6": "returnValue"
            },
            "code": "\nundefined  [16] copyFileAndUnlink_00105bc0(char *sourceFilePath,char *destinationFilePath,undefined4 flags,undefined8 result)\n\n{\n  uint copyResult;\n  int *errnoPtr;\n  char *errorString;\n  undefined8 errorMessage;\n  ulong unlinkResult;\n  undefined returnValue [16];\n  \n  if (destinationFilePath == sourceFilePath) {\n    unlinkResult = 0;\n  }\n  else {\n    copyResult = FUN_00105c00(flags);\n    unlinkResult = (ulong)copyResult;\n    if (copyResult != 0) {\n      errnoPtr = __errno_location();\n      errorString = strerror(*errnoPtr);\n      errorMessage = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      FUN_00107920(errorMessage,destinationFilePath,errorString);\n    }\n    unlink(sourceFilePath);\n  }\n  returnValue._8_8_ = result;\n  returnValue._0_8_ = unlinkResult;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_00105c00",
                "FUN_00102f1e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bc0",
            "calling": [
                "FUN_00102d2f",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "copy_file_and_unlink_00105bc0"
        },
        "FUN_00107650": {
            "renaming": {
                "FUN_00107650": "check_and_execute_function_00107650",
                "param_1": "input_parameter",
                "uVar1": "return_value",
                "lVar2": "result"
            },
            "code": "\nundefined8 check_and_execute_function_00107650(undefined8 input_parameter)\n\n{\n  undefined8 return_value;\n  long result;\n  \n  result = FUN_001052a0();\n  if (result < 1) {\n    return_value = 1;\n  }\n  else {\n    DAT_0010d648 = 1;\n    result = FUN_00105300(input_parameter,0);\n    if (result == 0) {\n                    \n      xexit(1);\n    }\n    FUN_001058b0(result);\n    return_value = 0;\n  }\n  return return_value;\n}\n\n",
            "called": [
                "FUN_001052a0",
                "FUN_00105300",
                "xexit",
                "FUN_001058b0",
                "FUN_0010284b"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107650",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "check_and_execute_function_00107650"
        },
        "setlocale": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "setlocale"
        },
        "FUN_00102f1e": {
            "renaming": {
                "FUN_00102f1e": "copy_file_with_reason_00102f1e",
                "piVar1": "errorCode",
                "uVar2": "errorString",
                "unaff_RBP": "fileSize",
                "unaff_R12": "filePath",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16] copyFileWithReason_00102f1e(void)\n\n{\n  int *errorCode;\n  undefined8 errorString;\n  ulong fileSize;\n  char *filePath;\n  undefined returnValue [16];\n  undefined8 unaff_retaddr;\n  \n  errorCode = __errno_location();\n  strerror(*errorCode);\n  errorString = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  FUN_00107920(errorString);\n  unlink(filePath);\n  returnValue._0_8_ = fileSize & 0xffffffff;\n  returnValue._8_8_ = unaff_retaddr;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_00107920",
                "__errno_location",
                "strerror",
                "dcgettext",
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f1e",
            "calling": [
                "FUN_00105bc0"
            ],
            "imported": false,
            "current_name": "copy_file_with_reason_00102f1e"
        },
        "bfd_set_error": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_error"
        },
        "FUN_00102fd7": {
            "renaming": {
                "FUN_00102fd7": "handle_set_time_error_00102fd7",
                "piVar1": "errnoLocation",
                "uVar2": "errorString"
            },
            "code": "\nvoid handleSetTimeError_00102fd7(void)\n\n{\n  int *errnoLocation;\n  undefined8 errorString;\n  \n  errnoLocation = __errno_location();\n  strerror(*errnoLocation);\n  errorString = dcgettext(0,\"%s: cannot set time: %s\",5);\n  FUN_00107920(errorString);\n  return;\n}\n\n",
            "called": [
                "FUN_00107920",
                "__errno_location",
                "strerror",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd7",
            "calling": [
                "FUN_00107c80"
            ],
            "imported": false,
            "current_name": "handle_set_time_error_00102fd7"
        },
        "FUN_00103ba8": {
            "renaming": {
                "FUN_00103ba8": "check_ar_status_00103ba8",
                "printf": "displayMessage",
                "fflush": "flushOutput"
            },
            "code": "\n\n\nvoid checkARStatus_00103ba8(void)\n\n{\n  if (_DAT_0010d608 != 0) {\n    printf(\"AR >\");\n    fflush(_stdout);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ba8",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_ar_status_00103ba8"
        },
        "bindtextdomain": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bindtextdomain"
        },
        "filename_cmp": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "FUN_00102cd9",
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_001032a8",
                "FUN_00105480"
            ],
            "imported": false,
            "current_name": "filename_cmp"
        },
        "bfd_make_readable": {
            "renaming": {},
            "code": "\nvoid bfd_make_readable(void)\n\n{\n  bfd_make_readable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_readable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_make_readable"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "FUN_00105300",
                "FUN_00103bd1",
                "FUN_001025a0",
                "FUN_00102d8c",
                "FUN_0010394a",
                "FUN_0010336b",
                "FUN_00102c25",
                "FUN_0010266f",
                "FUN_00102f96",
                "FUN_00102f1e",
                "FUN_0010285f",
                "FUN_001052a0",
                "FUN_0010342d",
                "FUN_00103c60",
                "FUN_001028ed",
                "FUN_001058b0",
                "FUN_00102fd7",
                "FUN_00102e6f",
                "FUN_001031a5",
                "FUN_00105db0",
                "FUN_001075e0",
                "FUN_00103a78",
                "FUN_00103e95",
                "FUN_001032a8"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_format": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_001058b0",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_set_format"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "FUN_00103bd1",
                "FUN_00102d8c",
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "bfd_openw": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "FUN_00105300",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_openw"
        },
        "FUN_00103ddc": {
            "renaming": {
                "FUN_00103ddc": "initialize_data_00103ddc",
                "param_1": "data"
            },
            "code": "\nvoid initializeData_00103ddc(undefined8 data)\n\n{\n  FUN_001079c0(DAT_0010d578,data,DAT_0010d60c != 0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_001079c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ddc",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "initialize_data_00103ddc"
        },
        "FUN_001078c0": {
            "renaming": {
                "FUN_001078c0": "print_error_message_001078c0",
                "param_1": "message",
                "param_2": "args",
                "fflush": "clearOutputBuffer",
                "fprintf": "printFormattedErrorMessage",
                "vfprintf": "printFormattedErrorMessageWithArgs",
                "putc": "putCharacterToOutput"
            },
            "code": "\n\n\nvoid printErrorMessage_001078c0(char *message,__gnuc_va_list args)\n\n{\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",DAT_0010d660);\n  vfprintf(_stderr,message,args);\n  putc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "vfprintf",
                "putc",
                "fflush",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001078c0",
            "calling": [
                "FUN_00107920",
                "FUN_00107690"
            ],
            "imported": false,
            "current_name": "print_error_message_001078c0"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "bfd_openr": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00102710",
                "FUN_001028ed",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_openr"
        },
        "FUN_001075e0": {
            "renaming": {
                "FUN_001075e0": "print_version_info_001075e0",
                "param_1": "binutilsVersion",
                "pcVar1": "licenseText"
            },
            "code": "\nvoid printVersionInfo_001075e0(undefined8 binutilsVersion)\n\n{\n  char *licenseText;\n  \n  printf(\"GNU %s %s\\n\",binutilsVersion,\"(GNU Binutils for Debian) 2.40\");\n  licenseText = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(licenseText);\n  licenseText = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(licenseText);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "printf",
                "dcgettext",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001075e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_version_info_001075e0"
        },
        "FUN_00105480": {
            "renaming": {
                "FUN_00105480": "process_archive_00105480",
                "param_1": "archive_handle",
                "param_2": "callback_function",
                "param_3": "entry_names",
                "param_4": "num_entries",
                "iVar1": "comparison_result",
                "__format": "format_string",
                "lVar2": "current_entry",
                "plVar3": "temp_pointer",
                "uVar4": "result",
                "plVar5": "entry_list",
                "local_cc": "count",
                "local_c8": "buffer"
            },
            "code": "\n\n\nvoid processArchive_00105480(long archive_handle,code *callback_function,undefined8 *entry_names,int num_entries)\n\n{\n  int comparison_result;\n  char *format_string;\n  long current_entry;\n  long *temp_pointer;\n  undefined8 result;\n  long *entry_list;\n  int count;\n  undefined buffer [152];\n  \n  current_entry = *(long *)(archive_handle + 0xf0);\n  if (num_entries == 0) {\n    for (; current_entry != 0; current_entry = *(long *)(current_entry + 0xf0)) {\n      (*callback_function)(current_entry);\n    }\n  }\n  else {\n    for (; current_entry != 0; current_entry = *(long *)(current_entry + 0xf0)) {\n      *(undefined4 *)(current_entry + 0xac) = 0;\n    }\n    do {\n      entry_list = *(long **)(archive_handle + 0xf0);\n      count = 0;\n      for (; entry_list != (long *)0x0; entry_list = (long *)entry_list[0x1e]) {\n        if (*(int *)((long)entry_list + 0xac) == 0) {\n          current_entry = *entry_list;\n          if (current_entry == 0) {\n            temp_pointer = (long *)entry_list[0x1d];\n            if ((long *)entry_list[0x1d] == (long *)0x0) {\n              temp_pointer = entry_list;\n            }\n            (**(code **)(temp_pointer[1] + 0x1e8))(entry_list,buffer);\n          }\n          else if (((*(byte *)(archive_handle + 0x49) & 0x10) == 0) ||\n                  (current_entry = FUN_00105830(current_entry,archive_handle), current_entry != 0)) {\n            result = FUN_00105830(*entry_names,archive_handle);\n            comparison_result = filename_cmp(result,current_entry);\n            if ((comparison_result == 0) &&\n               ((DAT_0010d634 == '\\0' || (count = count + 1, count == _DAT_0010d630)))) {\n              (*callback_function)();\n              *(undefined4 *)((long)entry_list + 0xac) = 1;\n              goto LAB_0010553e;\n            }\n          }\n        }\n      }\n      result = *entry_names;\n      format_string = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n      fprintf(_stderr,format_string,result);\nLAB_0010553e:\n      entry_names = entry_names + 1;\n      num_entries = num_entries + -1;\n    } while (num_entries != 0);\n  }\n  return;\n}\n\n",
            "called": [
                "filename_cmp",
                "FUN_00105830",
                "FUN_0010285f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105480",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "process_archive_00105480"
        },
        "FUN_00105cf0": {
            "renaming": {
                "FUN_00105cf0": "FUNC_00105cf0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d03) */\n/* WARNING: Removing unreachable block (ram,0x00105d0f) */\n\nvoid FUNC_00105cf0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105cf0",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105cf0"
        },
        "FUN_001031a5": {
            "renaming": {
                "FUN_001031a5": "print_syntax_error_001031a5",
                "__format": "errorMessageFormat",
                "uVar1": "incrementedValue"
            },
            "code": "\nvoid printSyntaxError_001031a5(void)\n\n{\n  uint incrementedValue;\n  char *errorMessageFormat;\n  \n  incrementedValue = DAT_0010d554 + 1;\n  errorMessageFormat = (char *)dcgettext(0,\"Syntax error in archive script, line %d\\n\",5);\n  printf(errorMessageFormat,(ulong)incrementedValue);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031a5",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "print_syntax_error_001031a5"
        },
        "bfd_make_writable": {
            "renaming": {},
            "code": "\nvoid bfd_make_writable(void)\n\n{\n  bfd_make_writable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_writable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_make_writable"
        },
        "strtol": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "strtol"
        },
        "bfd_create": {
            "renaming": {},
            "code": "\nvoid bfd_create(void)\n\n{\n  bfd_create();\n  return;\n}\n\n",
            "called": [
                "bfd_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_create"
        },
        "bfd_target_list": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "bfd_target_list"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "FUN_00103bd1",
                "FUN_00102d2f",
                "FUN_00105db0",
                "FUN_00102c25",
                "FUN_0010266f",
                "FUN_00103a78",
                "FUN_00103e95",
                "FUN_00102ba1"
            ],
            "imported": false,
            "current_name": "free"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102480",
            "calling": [
                "FUN_00105300",
                "FUN_0010315d",
                "FUN_0010342d",
                "FUN_0010394a",
                "FUN_00105a68",
                "FUN_00102d2f",
                "FUN_00107650",
                "FUN_00105db0",
                "FUN_00107690",
                "FUN_00107c10"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "close": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "FUN_001058b0",
                "FUN_00102f55",
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "close"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102470",
            "calling": [
                "FUN_00105a68",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "malloc": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "FUN_001033d6",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "malloc"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "FUN_001052a0",
                "FUN_00105300",
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "FUN_00103df9": {
            "renaming": {
                "FUN_00103df9": "ensure_buffer_stack_00103df9",
                "in_RCX": "input_parameter",
                "lVar1": "loop_counter",
                "lVar2": "new_buffer_size",
                "puVar3": "buffer_ptr",
                "bVar4": "zero_byte",
                "__size": "buffer_size"
            },
            "code": "\nundefined8 ensure_buffer_stack_00103df9(void)\n\n{\n  size_t buffer_size;\n  undefined8 input_parameter;\n  long loop_counter;\n  long new_buffer_size;\n  undefined4 *buffer_ptr;\n  byte zero_byte;\n  \n  zero_byte = 0;\n  if (DAT_0010d5a8 == (void *)0x0) {\n    DAT_0010d5a8 = calloc(8,1);\n    if (DAT_0010d5a8 != (void *)0x0) {\n      DAT_0010d580 = 1;\n      DAT_0010d5a0 = 0;\n      return input_parameter;\n    }\n  }\n  else {\n    if (DAT_0010d5a0 < DAT_0010d580 - 1U) {\n      return input_parameter;\n    }\n    new_buffer_size = DAT_0010d580 + 8;\n    buffer_size = new_buffer_size * 8;\n    DAT_0010d5a8 = realloc(DAT_0010d5a8,buffer_size);\n    if (DAT_0010d5a8 != (void *)0x0) {\n      buffer_ptr = (undefined4 *)((long)DAT_0010d5a8 + (buffer_size - 0x40));\n      DAT_0010d580 = new_buffer_size;\n      for (loop_counter = 0x10; loop_counter != 0; loop_counter = loop_counter + -1) {\n        *buffer_ptr = 0;\n        buffer_ptr = buffer_ptr + (ulong)zero_byte * -2 + 1;\n      }\n      return input_parameter;\n    }\n  }\n  FUN_001033b0(\"out of dynamic memory in yyensure_buffer_stack_00103df9()\");\n  DAT_0010d5a0 = 0;\n  DAT_0010d580 = 1;\n  return input_parameter;\n}\n\n",
            "called": [
                "calloc",
                "realloc",
                "FUN_001033b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103df9",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "ensure_buffer_stack_00103df9"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "FUN_00103c60",
                "FUN_001058b0",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "extract_and_print_archive_00103a78",
                "param_1": "archive",
                "iVar1": "result",
                "__ptr": "buffer",
                "puVar2": "ptr",
                "uVar3": "bytesRead",
                "uVar4": "errorMsg",
                "sVar5": "bytesWritten",
                "piVar6": "errnoPtr",
                "unaff_RBP": "bufferSize",
                "pcVar7": "errMsg",
                "unaff_R13": "totalBytesRead",
                "unaff_R14": "archiveSize",
                "auStack_b8": "localBuffer",
                "local_88": "remainingBytes"
            },
            "code": "\n\n\nvoid extractAndPrintArchive_00103a78(undefined8 *archive)\n\n{\n  int result;\n  void *buffer;\n  undefined8 *ptr;\n  ulong bytesRead;\n  undefined8 errorMsg;\n  size_t bytesWritten;\n  int *errnoPtr;\n  size_t bufferSize;\n  char *errMsg;\n  ulong totalBytesRead;\n  ulong archiveSize;\n  undefined localBuffer [48];\n  ulong remainingBytes;\n  \n  buffer = (void *)xmalloc(0x2000);\n  ptr = (undefined8 *)archive[0x1d];\n  if ((undefined8 *)archive[0x1d] == (undefined8 *)0x0) {\n    ptr = archive;\n  }\n  result = (**(code **)(ptr[1] + 0x1e8))(archive,localBuffer);\n  if (result == 0) {\n    if (DAT_0010d60c != 0) {\n      printf(\"\\n<%s>\\n\\n\",*archive);\n    }\n    totalBytesRead = 0;\n    bfd_seek(archive,0,0);\n    goto LAB_00103afd;\n  }\n  archive = (undefined8 *)*archive;\n  errMsg = \"internal stat error on %s\";\n  do {\n    errorMsg = dcgettext(0,errMsg,5);\n    FUN_00107690(errorMsg,archive);\n    remainingBytes = archiveSize;\n    do {\n      bytesWritten = fwrite(buffer,1,bufferSize,_stdout);\n      if (bytesWritten != bufferSize) {\n        errnoPtr = __errno_location();\n        errMsg = strerror(*errnoPtr);\n        FUN_00107690(\"stdout: %s\",errMsg);\nLAB_00103b91:\n        free(buffer);\n        return;\n      }\n      totalBytesRead = totalBytesRead + bytesWritten;\nLAB_00103afd:\n      if (remainingBytes <= totalBytesRead) goto LAB_00103b91;\n      bufferSize = remainingBytes - totalBytesRead;\n      if (0x2000 < bufferSize) {\n        bufferSize = 0x2000;\n      }\n      bytesRead = bfd_bread(buffer,bufferSize,archive);\n    } while (bufferSize == bytesRead);\n    errMsg = \"%s is not a valid archive\";\n    archive = *(undefined8 **)archive[0x1d];\n    archiveSize = remainingBytes;\n  } while( true );\n}\n\n",
            "called": [
                "bfd_bread",
                "free",
                "bfd_seek",
                "fwrite",
                "__errno_location",
                "xmalloc",
                "printf",
                "strerror",
                "dcgettext",
                "FUN_00107690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_and_print_archive_00103a78"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "FUN_00105300",
                "FUN_00103bd1",
                "FUN_00102d8c",
                "FUN_0010394a",
                "FUN_0010336b",
                "FUN_0010266f",
                "FUN_00102f96",
                "FUN_001033b0",
                "FUN_0010285f",
                "FUN_0010342d",
                "FUN_00103c60",
                "FUN_001078c0",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_001032a8"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "strrchr": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "strrchr"
        },
        "FUN_001058b0": {
            "renaming": {
                "FUN_001058b0": "extract_archive_contents_001058b0",
                "param_1": "archiveFilePath",
                "uVar4": "archiveFileDescriptor",
                "__format": "corruptTimeDataMessage",
                "__ptr": "duplicatedFilePath",
                "__stream": "fileStream",
                "ppcVar5": "formattedArchiveContent",
                "uStack0000000000000020": "fileMetadata",
                "in_stack_00000028": "inodeNumber",
                "in_stack_00000038": "timestamp",
                "local_3c": "fileDescriptorArray",
                "uStack_33": "fileTypeChar",
                "cStack_32": "isSetuid",
                "cStack_31": "isSetgid"
            },
            "code": "\n\n\nvoid extractArchiveContents_001058b0(undefined8 *archiveFilePath)\n\n{\n  char cVar1;\n  uint uVar2;\n  int iVar3;\n  undefined8 archiveFileDescriptor;\n  char *corruptTimeDataMessage;\n  void *duplicatedFilePath;\n  FILE *fileStream;\n  char **formattedArchiveContent;\n  uint fileMetadata;\n  uint inodeNumber;\n  undefined8 timestamp;\n  int fileDescriptorArray [2];\n  undefined fileTypeChar;\n  char isSetuid;\n  char isSetgid;\n  \n  archiveFileDescriptor = archiveFilePath[0x1e];\n  fileDescriptorArray[0] = -1;\n  duplicatedFilePath = (void *)xstrdup(*archiveFilePath);\n  fileStream = (FILE *)FUN_001057a0(duplicatedFilePath,fileDescriptorArray);\n  iVar3 = fileDescriptorArray[0];\n  if (fileStream != (FILE *)0x0) {\n    DAT_0010d618 = fileStream;\n    formattedArchiveContent = (char **)bfd_fdopenw(fileStream,*(undefined8 *)archiveFilePath[1],fileDescriptorArray[0]);\n    if (formattedArchiveContent != (char **)0x0) {\n      DAT_0010d5e0 = formattedArchiveContent;\n      bfd_set_format(formattedArchiveContent,2);\n      uVar2 = (~DAT_0010d648 >> 0x1f) << 3 | *(byte *)((long)formattedArchiveContent + 0x49) & 0xfffffff7;\n      *(char *)((long)formattedArchiveContent + 0x49) = (char)uVar2;\n      if (DAT_0010d5fa != '\\0') {\n        *(uint *)((long)formattedArchiveContent + 0x44) = *(uint *)((long)formattedArchiveContent + 0x44) | 0x400;\n      }\n      if (_DAT_0010d2d0 != 0) {\n        *(uint *)((long)formattedArchiveContent + 0x44) = *(uint *)((long)formattedArchiveContent + 0x44) | 0x2000;\n      }\n      if (DAT_0010d5f9 != '\\0') goto LAB_00102d37;\n      while( true ) {\n        if ((DAT_0010d5f8 != '\\0') || ((*(byte *)((long)archiveFilePath + 0x49) & 0x10) != 0)) {\n          *(byte *)((long)formattedArchiveContent + 0x49) = (byte)uVar2 | 0x10;\n        }\n        cVar1 = bfd_set_archive_head(formattedArchiveContent,archiveFileDescriptor);\n        if (cVar1 != '\\0') break;\n        uVar2 = FUN_00107c10(duplicatedFilePath);\nLAB_00102d37:\n        *(uint *)((long)formattedArchiveContent + 0x44) = *(uint *)((long)formattedArchiveContent + 0x44) | 0x100000;\n      }\n      iVar3 = dup(iVar3);\n      cVar1 = bfd_close(formattedArchiveContent);\n      if (cVar1 == '\\0') {\n        FUN_00107c10(duplicatedFilePath);\n        corruptTimeDataMessage = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(&stack0xffffffffffffffd8,corruptTimeDataMessage);\n        uVar2 = fileMetadata & 0xf000;\n        if (uVar2 == 0x4000) {\n          fileTypeChar = 100;\n        }\n        else if (uVar2 == 0xa000) {\n          fileTypeChar = 0x6c;\n        }\n        else if (uVar2 == 0x6000) {\n          fileTypeChar = 0x62;\n        }\n        else if (uVar2 == 0x2000) {\n          fileTypeChar = 99;\n        }\n        else if (uVar2 == 0xc000) {\n          fileTypeChar = 0x73;\n        }\n        else {\n          fileTypeChar = 0x70;\n          if (uVar2 != 0x1000) {\n            fileTypeChar = 0x2d;\n          }\n        }\n        isSetuid = (-((_fileMetadata & 0x100) == 0) & 0xbbU) + 0x72;\n        isSetgid = (-((_fileMetadata & 0x80) == 0) & 0xb6U) + 0x77;\n        fprintf(fileStream,\"%s %ld/%ld %6lu %s \",&isSetuid,_fileMetadata >> 0x20,\n                (ulong)inodeNumber,timestamp,&stack0xffffffffffffffd8,\n                _fileMetadata & 0xffffffff);\n        fputs(*formattedArchiveContent,fileStream);\n        if ((char)archiveFilePath != '\\0') {\n          if ((*(byte *)((long)formattedArchiveContent + 0x49) & 0x10) == 0) {\n            if (formattedArchiveContent[0xb] != (char *)0x0) {\n              fprintf(fileStream,\" 0x%lx\");\n            }\n          }\n          else if (formattedArchiveContent[0xc] != (char *)0x0) {\n            fprintf(fileStream,\" 0x%lx\");\n          }\n        }\n        fputc(10,fileStream);\n        return;\n      }\n      DAT_0010d5e0 = (char **)0x0;\n      DAT_0010d618 = (FILE *)0x0;\n      bfd_close(archiveFilePath);\n      iVar3 = FUN_00105bc0(fileStream,duplicatedFilePath,iVar3);\n      if (iVar3 == 0) {\n        free(duplicatedFilePath);\n        free(fileStream);\n        return;\n      }\n      goto LAB_00102d7a;\n    }\n    close(iVar3);\n    FUN_00107c10(duplicatedFilePath);\n  }\n  archiveFileDescriptor = dcgettext(0,\"could not create temporary file whilst writing archive\",5);\n  FUN_00107c10(archiveFileDescriptor);\nLAB_00102d7a:\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "bfd_set_format",
                "close",
                "bfd_fdopenw",
                "xstrdup",
                "dcgettext",
                "FUN_001057a0",
                "FUN_00107c10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001058b0",
            "calling": [
                "FUN_001028ed",
                "FUN_00107650",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_archive_contents_001058b0"
        },
        "fputs": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "FUN_00102d8c"
            ],
            "imported": false,
            "current_name": "fputs"
        },
        "perror": {
            "renaming": {},
            "code": "\n\n\nvoid perror(char *__s)\n\n{\n  perror(__s);\n  return;\n}\n\n",
            "called": [
                "perror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024a0",
            "calling": [
                "FUN_00105300",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "perror"
        },
        "FUN_00102bf5": {
            "renaming": {
                "FUN_00102bf5": "cleanup_resources_00102bf5"
            },
            "code": "\nvoid cleanupResources_00102bf5(void)\n\n{\n  if (DAT_0010d5e0 != 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 != (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary",
                "bfd_cache_close",
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bf5",
            "calling": [
                "FUN_00107730"
            ],
            "imported": false,
            "current_name": "cleanup_resources_00102bf5"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_indirect_jump_00102020"
            },
            "code": "\nvoid executeIndirectJump_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_jump_00102020"
        },
        "open": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102460",
            "calling": [
                "FUN_00105c00",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "open"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "FUN_00103bd1",
                "FUN_001078c0",
                "FUN_00103ba8",
                "FUN_00102f96"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "FUN_00102943": {
            "renaming": {
                "FUN_00102943": "initialize_data_00102943"
            },
            "code": "\nvoid initializeData_00102943(void)\n\n{\n  DAT_0010d618 = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102943",
            "calling": [
                "FUN_001028ed",
                "FUN_00105570"
            ],
            "imported": false,
            "current_name": "initialize_data_00102943"
        },
        "bfd_openr_next_archived_file": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102530",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "bfd_openr_next_archived_file"
        },
        "realloc": {
            "renaming": {},
            "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "FUN_00103e95",
                "FUN_00103df9"
            ],
            "imported": false,
            "current_name": "realloc"
        },
        "FUN_00107c80": {
            "renaming": {
                "FUN_00107c80": "set_file_timestamp_00107c80",
                "param_1": "filename",
                "param_2": "fileInfo",
                "iVar1": "result",
                "piVar2": "errnoPtr",
                "pcVar3": "errorString",
                "uVar4": "translatedErrorMessage",
                "local_38": "fileTimestamp",
                "uStack_34": "fileTimestampPtr",
                "uStack_30": "fileTimestampPtr2",
                "uStack_2c": "fileTimestampPtr3",
                "local_28": "fileMode",
                "uStack_24": "fileModePtr",
                "uStack_20": "fileModePtr2",
                "uStack_1c": "fileModePtr3"
            },
            "code": "\nvoid setFileTimestamp_00107c80(char *filename,long fileInfo)\n\n{\n  int result;\n  int *errnoPtr;\n  char *errorString;\n  undefined8 translatedErrorMessage;\n  undefined4 fileTimestamp;\n  undefined4 fileTimestampPtr;\n  undefined4 fileTimestampPtr2;\n  undefined4 fileTimestampPtr3;\n  undefined4 fileMode;\n  undefined4 fileModePtr;\n  undefined4 fileModePtr2;\n  undefined4 fileModePtr3;\n  \n  fileMode = *(undefined4 *)(fileInfo + 0x58);\n  fileModePtr = *(undefined4 *)(fileInfo + 0x5c);\n  fileModePtr2 = *(undefined4 *)(fileInfo + 0x60);\n  fileModePtr3 = *(undefined4 *)(fileInfo + 100);\n  fileTimestamp = *(undefined4 *)(fileInfo + 0x48);\n  fileTimestampPtr = *(undefined4 *)(fileInfo + 0x4c);\n  fileTimestampPtr2 = *(undefined4 *)(fileInfo + 0x50);\n  fileTimestampPtr3 = *(undefined4 *)(fileInfo + 0x54);\n  result = utimensat(-100,filename,(timespec *)&fileTimestamp,0);\n  if (result != 0) {\n    errnoPtr = __errno_location();\n    errorString = strerror(*errnoPtr);\n    translatedErrorMessage = dcgettext(0,\"%s: cannot set time: %s\",5);\n    FUN_00107920(translatedErrorMessage,filename,errorString);\n  }\n  return;\n}\n\n",
            "called": [
                "utimensat",
                "FUN_00102fd7"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c80",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "set_file_timestamp_00107c80"
        },
        "isatty": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "FUN_00105db0",
                "FUN_001031cf"
            ],
            "imported": false,
            "current_name": "isatty"
        },
        "FUN_00105a20": {
            "renaming": {
                "FUN_00105a20": "extract_archive_member_00105a20",
                "param_1": "path",
                "pcVar1": "baseDir",
                "pcVar2": "currPath",
                "uVar3": "baseName",
                "uVar4": "errorMsg",
                "pFVar5": "filePtr",
                "sVar6": "pathLen"
            },
            "code": "\nvoid extractArchiveMember_00105a20(char *path)\n\n{\n  char *baseDir;\n  char *currPath;\n  undefined8 baseName;\n  undefined8 errorMsg;\n  FILE *filePtr;\n  size_t pathLen;\n  \n  baseDir = DAT_0010d5e8;\n  DAT_0010d618 = path;\n  if (*path == '/') {\nLAB_00102e9a:\n    baseName = lbasename();\n    baseDir = DAT_0010d618;\n    errorMsg = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\",5);\n    FUN_00107920(errorMsg,baseDir,baseName);\n    DAT_0010d618 = (char *)baseName;\n    FUN_00105a68();\n    return;\n  }\n  do {\n    if (*path == '\\0') {\n      if ((DAT_0010d5e8 != (char *)0x0) && (pathLen = strlen(DAT_0010d5e8), pathLen != 0)) {\n        if (baseDir[pathLen - 1] == '/') {\n          DAT_0010d618 = (char *)concat(baseDir,DAT_0010d618,0);\n        }\n        else {\n          DAT_0010d618 = (char *)concat(baseDir,&DAT_00108260,DAT_0010d618,0);\n        }\n      }\n      if (DAT_0010d60c != 0) {\n        printf(\"x - %s\\n\",DAT_0010d618);\n      }\n      filePtr = fopen(DAT_0010d618,\"w\");\n      if (filePtr == (FILE *)0x0) {\n        perror(DAT_0010d618);\n                    \n        xexit(1);\n      }\n      return;\n    }\n    currPath = path;\n    if ((*path == '.') && (currPath = path + 1, path[1] == '.')) {\n      currPath = path + 2;\n      if ((path[2] == '/') || (path[2] == '\\0')) goto LAB_00102e9a;\n    }\n    for (; (*currPath != '\\0' && (*currPath != '/')); currPath = currPath + 1) {\n    }\n    for (; path = currPath, *currPath == '/'; currPath = currPath + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a20",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "extract_archive_member_00105a20"
        },
        "sprintf": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024f0",
            "calling": [
                "FUN_00102d8c",
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "sprintf"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00105d20();\n  return;\n}\n\n",
            "called": [
                "FUN_00105d20"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105da0",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "FUN_00105a68",
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00102bb0"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "FUN_00102f55": {
            "renaming": {
                "FUN_00102f55": "close_file_and_set_error_00102f55",
                "piVar2": "errorPointer",
                "iVar1": "originalError",
                "unaff_R12D": "fileDescriptor"
            },
            "code": "\nundefined8 closeFileAndSetError_00102f55(void)\n\n{\n  int originalError;\n  int *errorPointer;\n  int fileDescriptor;\n  \n  errorPointer = __errno_location();\n  originalError = *errorPointer;\n  close(fileDescriptor);\n  *errorPointer = originalError;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f55",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "close_file_and_set_error_00102f55"
        },
        "FUN_001057a0": {
            "renaming": {
                "FUN_001057a0": "allocate_file_path_001057a0",
                "param_1": "inputPath",
                "param_2": "fileDescriptor",
                "param_3": "value1",
                "param_4": "value2",
                "iVar1": "result",
                "pcVar2": "lastSlash",
                "lVar3": "lastSlashPos",
                "lVar4": "loopVar",
                "lVar5": "backslashPos",
                "pcVar6": "newFilePath",
                "bVar7": "loopVar2",
                "auVar8": "returnValue"
            },
            "code": "\nundefined  [16] allocateFilePath_001057a0(char *inputPath,int *fileDescriptor,undefined8 value1,undefined8 value2)\n\n{\n  int result;\n  char *lastSlash;\n  long lastSlashPos;\n  long loopVar;\n  long backslashPos;\n  char *newFilePath;\n  byte loopVar2;\n  undefined returnValue [16];\n  \n  loopVar2 = 0;\n  lastSlash = strrchr(inputPath,0x2f);\n  if (lastSlash == (char *)0x0) {\n    lastSlash = (char *)xmalloc(9);\n    lastSlashPos = 0;\n  }\n  else {\n    backslashPos = (long)lastSlash - (long)inputPath;\n    lastSlash = (char *)xmalloc(backslashPos + 0xb);\n    lastSlashPos = backslashPos + 1;\n    newFilePath = lastSlash;\n    for (loopVar = backslashPos; loopVar != 0; loopVar = loopVar + -1) {\n      *newFilePath = *inputPath;\n      inputPath = inputPath + (ulong)loopVar2 * -2 + 1;\n      newFilePath = newFilePath + (ulong)loopVar2 * -2 + 1;\n    }\n    lastSlash[backslashPos] = '/';\n  }\n  *(undefined8 *)(lastSlash + lastSlashPos) = 0x5858585858587473;\n  *(undefined *)((long)(lastSlash + lastSlashPos) + 8) = 0;\n  result = mkstemp(lastSlash);\n  if (result == -1) {\n    newFilePath = (char *)0x0;\n    free(lastSlash);\n  }\n  else {\n    *fileDescriptor = result;\n    newFilePath = lastSlash;\n  }\n  returnValue._8_8_ = value2;\n  returnValue._0_8_ = newFilePath;\n  return returnValue;\n}\n\n",
            "called": [
                "mkstemp",
                "strrchr",
                "xmalloc",
                "FUN_00102ba1"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001057a0",
            "calling": [
                "FUN_00103c60",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "allocate_file_path_001057a0"
        },
        "bfd_cache_close": {
            "renaming": {},
            "code": "\nvoid bfd_cache_close(void)\n\n{\n  bfd_cache_close();\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "FUN_00102bf5",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_cache_close"
        },
        "FUN_00102d8c": {
            "renaming": {
                "FUN_00102d8c": "format_and_print_file_info_00102d8c",
                "unaff_RBX": "filePaths",
                "unaff_RBP": "outputFile",
                "unaff_R12B": "isHexadecimal",
                "param_9": "permissionString",
                "param_19": "filePermission",
                "param_20": "fileSize",
                "param_22": "timestamp",
                "__format": "corruptTimeFormat",
                "uVar1": "fileType",
                "cStack0000000000000016": "permissionChar1",
                "cStack0000000000000017": "permissionChar2",
                "cStack0000000000000019": "permissionChar3",
                "cStack000000000000001a": "permissionChar4",
                "cStack000000000000001b": "permissionChar5",
                "cStack000000000000001c": "permissionChar6",
                "cStack000000000000001d": "permissionChar7",
                "cStack000000000000001e": "permissionChar8",
                "uStack000000000000006c": "fileUid"
            },
            "code": "\nvoid formatAndPrintFileInfo_00102d8c(void)\n\n{\n  char *corruptTimeFormat;\n  uint fileType;\n  char **filePaths;\n  FILE *outputFile;\n  char isHexadecimal;\n  undefined uStack0000000000000015;\n  char permissionChar1;\n  char permissionChar2;\n  char permissionString;\n  char permissionChar3;\n  char permissionChar4;\n  char permissionChar5;\n  char permissionChar6;\n  char permissionChar7;\n  char permissionChar8;\n  undefined uStack000000000000001f;\n  uint filePermission;\n  uint fileUid;\n  uint fileSize;\n  undefined8 timestamp;\n  \n  corruptTimeFormat = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,corruptTimeFormat);\n  fileType = filePermission & 0xf000;\n  if (fileType == 0x4000) {\n    uStack0000000000000015 = 100;\n  }\n  else if (fileType == 0xa000) {\n    uStack0000000000000015 = 0x6c;\n  }\n  else if (fileType == 0x6000) {\n    uStack0000000000000015 = 0x62;\n  }\n  else if (fileType == 0x2000) {\n    uStack0000000000000015 = 99;\n  }\n  else if (fileType == 0xc000) {\n    uStack0000000000000015 = 0x73;\n  }\n  else {\n    uStack0000000000000015 = 0x70;\n    if (fileType != 0x1000) {\n      uStack0000000000000015 = 0x2d;\n    }\n  }\n  permissionChar1 = (-((filePermission & 0x100) == 0) & 0xbbU) + 0x72;\n  permissionChar2 = (-((filePermission & 0x80) == 0) & 0xb6U) + 0x77;\n  permissionString = (-((filePermission & 0x40) == 0) & 0xb5U) + 0x78;\n  permissionChar3 = (-((filePermission & 0x20) == 0) & 0xbbU) + 0x72;\n  permissionChar4 = (-((filePermission & 0x10) == 0) & 0xb6U) + 0x77;\n  permissionChar5 = (-((filePermission & 8) == 0) & 0xb5U) + 0x78;\n  permissionChar6 = (-((filePermission & 4) == 0) & 0xbbU) + 0x72;\n  permissionChar7 = (-((filePermission & 2) == 0) & 0xb6U) + 0x77;\n  permissionChar8 = (-((filePermission & 1) == 0) & 0xb5U) + 0x78;\n  if ((filePermission & 0x800) != 0) {\n    if (permissionString == 'x') {\n      permissionString = 's';\n    }\n    else {\n      permissionString = 'S';\n    }\n  }\n  if ((filePermission & 0x400) != 0) {\n    if (permissionChar5 == 'x') {\n      permissionChar5 = 's';\n    }\n    else {\n      permissionChar5 = 'S';\n    }\n  }\n  if ((filePermission & 0x200) != 0) {\n    if (permissionChar8 == 'x') {\n      permissionChar8 = 't';\n    }\n    else {\n      permissionChar8 = 'T';\n    }\n  }\n  uStack000000000000001f = 0;\n  fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)fileUid,\n          (ulong)fileSize,timestamp,&stack0x00000020,(ulong)filePermission);\n  fputs(*filePaths,outputFile);\n  if (isHexadecimal != '\\0') {\n    if ((*(byte *)((long)filePaths + 0x49) & 0x10) == 0) {\n      if (filePaths[0xb] != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (filePaths[0xc] != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "fputs",
                "sprintf",
                "dcgettext",
                "fprintf",
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d8c",
            "calling": [
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "format_and_print_file_info_00102d8c"
        },
        "bfd_plugin_set_plugin": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_plugin"
        },
        "__errno_location": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_001025a0",
                "FUN_001028ed",
                "FUN_00102fd7",
                "FUN_00102f55",
                "FUN_00105c00",
                "FUN_00102c25",
                "FUN_001031cf",
                "FUN_00103a78",
                "FUN_00102f1e",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "__errno_location"
        },
        "FUN_00105300": {
            "renaming": {
                "FUN_00105300": "convert_existing_library_00105300",
                "param_1": "file_path",
                "param_2": "result_array",
                "plVar1": "archived_file",
                "pcVar2": "error_message",
                "bVar3": "thin_library_flag",
                "cVar4": "conversion_error",
                "iVar5": "stat_result",
                "uVar6": "error_message",
                "uVar7": "library",
                "piVar8": "errno_location",
                "lVar9": "archived_file_address",
                "puVar10": "new_result_array",
                "local_b0": "message",
                "local_a8": "file_stats"
            },
            "code": "\n\n\nundefined8 * convert_existing_library_00105300(char *file_path,undefined8 *result_array)\n\n{\n  long *archived_file;\n  char *error_message;\n  byte thin_library_flag;\n  char conversion_error;\n  int stat_result;\n  undefined8 error_message;\n  undefined8 library;\n  int *errno_location;\n  long archived_file_address;\n  undefined8 *new_result_array;\n  undefined8 message;\n  stat file_stats;\n  \n  bfd_set_error(0);\n  if (DAT_0010d5f0 == (char *)0x0) {\n    DAT_0010d5f0 = \"plugin\";\n  }\n  stat_result = stat(file_path,&file_stats);\n  error_message = DAT_0010d618;\n  if (stat_result == 0) goto LAB_001053be;\n  errno_location = __errno_location();\n  if (*errno_location == 2) {\n    if (DAT_0010d604 == '\\0') {\n      fprintf(_stderr,\"%s: \",DAT_0010d660);\n      perror(file_path);\n      FUN_0010315d();\n      return (undefined8 *)0x0;\n    }\n    if ((DAT_0010d5f0 == (char *)0x0) && (result_array != (undefined8 *)0x0)) {\n      new_result_array = (undefined8 *)FUN_00102710();\n      return new_result_array;\n    }\n    result_array = (undefined8 *)bfd_openw(file_path,DAT_0010d5f0);\n    if (((result_array != (undefined8 *)0x0) && (conversion_error = bfd_set_format(result_array,2), conversion_error != '\\0')) &&\n       (conversion_error = bfd_close(result_array), conversion_error != '\\0')) {\n      error_message = file_path;\n      if (_DAT_0010d610 == 0) goto LAB_00102826;\n      goto LAB_001053be;\n    }\n  }\n  FUN_00107c10(file_path);\n  do {\n    thin_library_flag = *(byte *)((long)result_array + 0x49) >> 4 & 1;\n    if (DAT_0010d5f8 == '\\0') {\n      if (thin_library_flag != 0) {\n        library = *result_array;\n        error_message = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        FUN_00107690(error_message,library);\n        goto LAB_00102812;\n      }\n    }\n    else if (thin_library_flag == 0) {\n      library = *result_array;\n      error_message = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      FUN_00107690(error_message,library);\nLAB_001027cb:\n      FUN_00107c20(file_path);\n      stat_result = bfd_get_error();\n      if (stat_result == 0xd) {\nLAB_00102812:\n        FUN_00103bd1(message);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      archived_file = result_array + 0x1e;\n      for (archived_file_address = bfd_openr_next_archived_file(result_array,0); archived_file_address != 0;\n          archived_file_address = bfd_openr_next_archived_file(result_array,archived_file_address)) {\n        *archived_file = archived_file_address;\n        archived_file = (long *)(archived_file_address + 0xf0);\n      }\n      *archived_file = 0;\n      stat_result = bfd_get_error();\n      if (stat_result == 9) {\n        return result_array;\n      }\n      do {\n        FUN_00107c10(file_path);\nLAB_00102826:\n        library = dcgettext(0,\"creating %s\",5);\n        FUN_00107920(library,file_path);\n        error_message = file_path;\nLAB_001053be:\n        DAT_0010d618 = error_message;\n        result_array = (undefined8 *)bfd_openr(file_path,DAT_0010d5f0);\n      } while (result_array == (undefined8 *)0x0);\n      conversion_error = bfd_check_format_matches(result_array,2,&message);\n      if (conversion_error == '\\0') goto LAB_001027cb;\n    } while (((DAT_0010d64c != 2) && (DAT_0010d64c != 7)) ||\n            (archived_file_address = bfd_openr_next_archived_file(result_array,0), archived_file_address == 0));\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00103bd1",
                "bfd_set_format",
                "bfd_openr_next_archived_file",
                "FUN_00102710",
                "xexit",
                "bfd_close",
                "__errno_location",
                "bfd_openw",
                "bfd_openr",
                "bfd_set_error",
                "dcgettext",
                "stat",
                "fprintf",
                "FUN_0010315d",
                "FUN_00107c20",
                "bfd_get_error",
                "bfd_check_format_matches",
                "FUN_00107920",
                "perror",
                "FUN_00107690",
                "FUN_00107c10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105300",
            "calling": [
                "FUN_00107650",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "convert_existing_library_00105300"
        },
        "FUN_00105db0": {
            "renaming": {
                "FUN_00105db0": "parse_options_00105db0",
                "param_1": "argc",
                "param_2": "argv",
                "pbVar1": "bytePointer",
                "puVar2": "uintPointer",
                "bVar3": "byteVariable",
                "plVar4": "longPointer",
                "puVar5": "undefined8Pointer",
                "uVar6": "uintVariable",
                "uVar7": "uintVariable",
                "bVar8": "boolVariable",
                "bVar9": "boolVariable",
                "ppcVar10": "charPointerPointer",
                "piVar11": "intPointer",
                "puVar12": "undefinedPointer",
                "bVar13": "byteVariable",
                "cVar14": "charVariable",
                "iVar15": "intVariable",
                "uVar16": "uintVariable",
                "uVar17": "uintVariable",
                "pFVar18": "filePointer",
                "sVar19": "size_tVariable",
                "sVar20": "size_tVariable",
                "__ptr": "bytePointer",
                "plVar21": "longPointer",
                "pFVar22": "filePointer",
                "pcVar23": "charVariable",
                "lVar24": "longVariable",
                "uVar25": "ulongVariable",
                "puVar26": "undefined8Pointer",
                "uVar27": "undefined8Variable",
                "pFVar28": "filePointer",
                "pplVar29": "longPointerPointer",
                "uVar30": "undefined8Variable",
                "uVar44": "uintVariable",
                "iVar45": "intVariable",
                "pcVar46": "charPointer",
                "bVar47": "boolVariable",
                "bVar48": "byteVariable"
            },
            "code": "\n\n\nvoid parseOptions_00105db0(uint argc,FILE *argv)\n\n{\n  byte *bytePointer;\n  uint *uintPointer;\n  byte byteVariable;\n  long *longPointer;\n  undefined8 *undefined8Pointer;\n  undefined4 uintVariable;\n  undefined4 uintVariable;\n  bool boolVariable;\n  bool boolVariable;\n  char **charPointerPointer;\n  int *intPointer;\n  undefined *undefinedPointer;\n  byte byteVariable;\n  char charVariable;\n  int intVariable;\n  uint uintVariable;\n  undefined4 uintVariable;\n  FILE *filePointer;\n  size_t size_tVariable;\n  size_t size_tVariable;\n  byte *bytePointer;\n  long *longPointer;\n  FILE *filePointer;\n  char *charVariable;\n  long longVariable;\n  ulong ulongVariable;\n  undefined8 *undefined8Pointer;\n  undefined8 undefined8Variable;\n  FILE *filePointer;\n  long **longPointerPointer;\n  undefined8 undefined8Variable;\n  char **ppcVar31;\n  uint extraout_EDX;\n  char **ppcVar32;\n  byte *pbyteVariable3;\n  long lVar34;\n  long lVar35;\n  undefined **ppuVar36;\n  uint uVar37;\n  char *unaff_RBP;\n  byte *pbyteVariable8;\n  char *pcVar39;\n  ulong uVar40;\n  ulong uVar41;\n  ulong uVar42;\n  FILE *unaff_R12;\n  char *pcVar43;\n  uint uintVariable;\n  int intVariable;\n  char *charPointer;\n  bool boolVariable;\n  byte byteVariable;\n  undefined8 local_130;\n  FILE *local_128;\n  byte *local_118;\n  char **local_110;\n  size_t local_108;\n  long local_100;\n  undefined local_c8 [2];\n  undefined uStack_c6;\n  undefined5 uStack_c5;\n  uint local_b0;\n  \n  byteVariable = 0;\n  charPointer = (char *)(ulong)argc;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_0010d660 = *(long **)argv;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010d660);\n  bfd_plugin_set_program_name(DAT_0010d660);\n  pcVar43 = (char *)argv;\n  filePointer = argv;\n  if ((int)argc < 2) goto LAB_001062c6;\n  local_110 = (char **)0x7d0;\n  unaff_R12 = (FILE *)0x1;\n  local_128 = (FILE *)0x0;\n  filePointer = argv;\n  do {\n    uintVariable = (uint)unaff_R12;\n    unaff_RBP = (char *)(long)(int)uintVariable;\n    local_130 = (FILE *)((long)unaff_RBP * 8);\n    pcVar43 = (char *)filePointer;\n    if (**(char **)(&filePointer->_flags + (long)unaff_RBP * 2) == '@') {\n      uintVariable = (int)local_110 - 1;\n      local_110 = (char **)(ulong)uintVariable;\n      if (uintVariable == 0) {\n        longPointer = *(long **)filePointer;\n        charPointer = \"%s: error: too many @-files encountered\\n\";\nLAB_00106ffe:\n        fprintf(_stderr,charPointer,longPointer);\nLAB_0010700f:\n                    \n        xexit(1);\n      }\n      pcVar39 = *(char **)(&filePointer->_flags + (long)unaff_RBP * 2) + 1;\n      intVariable = stat(pcVar39,(stat *)local_c8);\n      if (-1 < intVariable) {\n        if ((local_b0 & 0xf000) == 0x4000) {\n          longPointer = *(long **)filePointer;\n          charPointer = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00106ffe;\n        }\n        filePointer = fopen(pcVar39,\"r\");\n        if (filePointer != (FILE *)0x0) {\n          intVariable = fseek(filePointer,0,2);\n          if (((intVariable != -1) && (size_tVariable = ftell(filePointer), size_tVariable != 0xffffffffffffffff)) &&\n             (intVariable = fseek(filePointer,0,0), intVariable != -1)) {\n            local_118 = (byte *)xmalloc(size_tVariable + 1);\n            size_tVariable = fread(local_118,1,size_tVariable,filePointer);\n            if ((size_tVariable == size_tVariable) || (intVariable = ferror(filePointer), intVariable == 0)) {\n              local_118[size_tVariable] = 0;\n              byteVariable = *local_118;\n              pbyteVariable3 = local_118;\n              while( true ) {\n                if (byteVariable == 0) goto LAB_00106814;\n                if (((&_sch_istable)[(ulong)byteVariable * 2] & 0x40) == 0) break;\n                byteVariable = pbyteVariable3[1];\n                pbyteVariable3 = pbyteVariable3 + 1;\n              }\n              size_tVariable = strlen((char *)local_118);\n              bytePointer = (byte *)xmalloc(size_tVariable + 1);\n              filePointer = (FILE *)0x0;\n              intVariable = 0;\n              boolVariable = false;\n              boolVariable = false;\n              boolVariable = false;\n              local_100 = 0;\n              pbyteVariable3 = local_118;\n              do {\n                while (((&_sch_istable)[(ulong)*pbyteVariable3 * 2] & 0x40) != 0) {\n                  pbyteVariable3 = pbyteVariable3 + 1;\n                }\n                if ((intVariable == 0) || (intVariable + -1 <= (int)local_100)) {\n                  if (filePointer == (FILE *)0x0) {\n                    intVariable = 8;\n                    filePointer = (FILE *)xmalloc(0x40);\n                    ppcVar31 = (char **)((long)&filePointer->_flags + local_100 * 8);\n                    *ppcVar31 = (char *)0x0;\n                  }\n                  else {\n                    intVariable = intVariable * 2;\n                    filePointer = (FILE *)xrealloc(filePointer,(long)intVariable << 3);\n                    ppcVar31 = (char **)((long)&filePointer->_flags + local_100 * 8);\n                    *ppcVar31 = (char *)0x0;\n                  }\n                }\n                else {\n                  ppcVar31 = (char **)((long)&filePointer->_flags + local_100 * 8);\n                }\n                byteVariable = *pbyteVariable3;\n                pbyteVariable8 = bytePointer;\n                while (byteVariable != 0) {\n                  while( true ) {\n                    if ((((&_sch_istable)[(ulong)byteVariable * 2] & 0x40) != 0) &&\n                       (!(bool)(boolVariable | boolVariable | boolVariable))) {\n                      boolVariable = false;\n                      boolVariable = false;\n                      boolVariable = false;\n                      goto LAB_0010606f;\n                    }\n                    if (!boolVariable) break;\n                    pbyteVariable3 = pbyteVariable3 + 1;\n                    *pbyteVariable8 = byteVariable;\n                    pbyteVariable8 = pbyteVariable8 + 1;\n                    boolVariable = false;\n                    byteVariable = *pbyteVariable3;\n                    if (byteVariable == 0) goto LAB_0010606f;\n                  }\n                  if (byteVariable == 0x5c) {\n                    boolVariable = true;\n                  }\n                  else if (boolVariable) {\n                    if (byteVariable == 0x27) {\n                      boolVariable = false;\n                    }\n                    else {\nLAB_001061f1:\n                      *pbyteVariable8 = byteVariable;\n                      pbyteVariable8 = pbyteVariable8 + 1;\n                    }\n                  }\n                  else if (boolVariable) {\n                    if (byteVariable != 0x22) goto LAB_001061f1;\n                    boolVariable = false;\n                  }\n                  else if (byteVariable == 0x27) {\n                    boolVariable = true;\n                  }\n                  else {\n                    if (byteVariable != 0x22) goto LAB_001061f1;\n                    boolVariable = true;\n                  }\n                  bytePointer = pbyteVariable3 + 1;\n                  pbyteVariable3 = pbyteVariable3 + 1;\n                  byteVariable = *bytePointer;\n                }\nLAB_0010606f:\n                *pbyteVariable8 = 0;\n                longPointer = (long *)xstrdup(bytePointer);\n                *ppcVar31 = (char *)longPointer;\n                *(undefined8 *)(filePointer->_shortbuf + local_100 * 8 + -0x7b) = 0;\n                byteVariable = *pbyteVariable3;\n                byteVariable = (&_sch_istable)[(ulong)byteVariable * 2];\n                while ((byteVariable & 0x40) != 0) {\n                  byteVariable = pbyteVariable3[1];\n                  pbyteVariable3 = pbyteVariable3 + 1;\n                  byteVariable = (&_sch_istable)[(ulong)byteVariable * 2];\n                }\n                local_100 = local_100 + 1;\n                if (byteVariable == 0) {\n                  free(bytePointer);\n                  if (filePointer == argv) goto LAB_00106834;\n                  goto LAB_0010610a;\n                }\n              } while( true );\n            }\n            free(local_118);\n          }\n          fclose(filePointer);\n        }\n      }\n    }\n    if ((int)charPointer <= (int)(uintVariable + 1)) {\nLAB_001062c6:\n      do {\n        if (_DAT_0010d65c < 0) goto LAB_001073cc;\nLAB_001062d3:\n        uintVariable = (uint)unaff_R12;\n        intVariable = bfd_init();\n        pcVar39 = \"fatal error: libbfd ABI mismatch\";\n        if (intVariable != 0x118) goto LAB_00106803;\n        pcVar39 = \"x86_64-pc-linux-gnu\";\n        uintVariable = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n        undefinedPointer = PTR_DAT_0010d2e0;\n        unaff_R12 = (FILE *)(ulong)uintVariable;\n        if ((char)uintVariable != '\\0') {\n          if (__xexit_cleanup == (code *)0x0) {\n            __xexit_cleanup = FUN_00107cc0;\n          }\n          if (*(int *)(PTR_DAT_0010d2e0 + 8) < 0x20) {\nLAB_0010632b:\n            undefinedPointer = PTR_DAT_0010d2e0;\n            intVariable = *(int *)(PTR_DAT_0010d2e0 + 8);\n            *(int *)(PTR_DAT_0010d2e0 + 8) = intVariable + 1;\n            *(code **)(undefinedPointer + (long)intVariable * 8 + 0x10) = FUN_00107730;\n          }\n          else {\n            undefined8Pointer = (undefined8 *)malloc(0x110);\n            if (undefined8Pointer != (undefined8 *)0x0) {\n              *undefined8Pointer = undefinedPointer;\n              *(undefined4 *)(undefined8Pointer + 1) = 0;\n              PTR_DAT_0010d2e0 = (undefined *)undefined8Pointer;\n              goto LAB_0010632b;\n            }\n          }\n          longVariable = 1;\n          do {\n            lVar35 = longVariable;\n            intVariable = (int)charPointer;\n            if (intVariable <= (int)lVar35) break;\n            charVariable = FUN_00107640(*(undefined8 *)((int *)pcVar43 + lVar35 * 2));\n            longVariable = lVar35 + 1;\n          } while (charVariable != '\\0');\n          charPointer = (char *)((long)pcVar43 + lVar35 * 8 + -8);\n          uintVariable = intVariable - ((int)lVar35 + -1);\n          filePointer = (FILE *)(ulong)uintVariable;\n          if (_DAT_0010d65c != 0) {\n            pcVar43 = \"DhHUvVt\";\n            uVar37 = 0;\n            while (intVariable = getopt_long(filePointer,charPointer,\"DhHUvVt\",&PTR_DAT_0010d300), intVariable != -1)\n            {\n              if (intVariable < 0x77) {\n                if (0x43 < intVariable) {\n                  switch(intVariable) {\n                  case 0x44:\n                    _DAT_0010d2d0 = 1;\n                    break;\n                  case 0x48:\n                  case 0x68:\n                    _DAT_0010d658 = 1;\n                    break;\n                  case 0x55:\n                    _DAT_0010d2d0 = 0;\n                    break;\n                  case 0x56:\n                  case 0x76:\n                    _DAT_0010d654 = 1;\n                    break;\n                  case 0x74:\n                    uVar37 = uintVariable;\n                  }\n                }\n              }\n              else if (intVariable == 0xc9) {\n                bfd_plugin_set_plugin(_optarg);\n              }\n            }\n            if ((int)uintVariable < 2) {\nLAB_00107125:\n              pcVar39 = (char *)0x0;\n              FUN_0010394a();\n            }\n            else {\n              if (_DAT_0010d658 != 0) {\nLAB_0010711b:\n                FUN_0010394a();\n                goto LAB_00107125;\n              }\n              if (_DAT_0010d654 != 0) {\n                FUN_001075e0(\"ranlib\");\n                goto LAB_0010711b;\n              }\n              if (_DAT_0010d2d0 < 0) {\n                _DAT_0010d2d0 = 1;\n              }\n              unaff_R12 = (FILE *)0x0;\n              pcVar43 = (char *)(long)_optind;\n              while( true ) {\n                if ((int)uintVariable <= (int)pcVar43) goto LAB_00106f8b;\n                pcVar39 = *(char **)((int *)charPointer + (long)pcVar43 * 2);\n                if ((char)uVar37 != '\\0') break;\n                uintVariable = FUN_00107650();\n                pcVar43 = (char *)((long)(int *)pcVar43 + 1);\n                unaff_R12 = (FILE *)(ulong)((uint)unaff_R12 | uintVariable);\n              }\n            }\n            while (longVariable = FUN_001052a0(pcVar39), longVariable < 1) {\n              uintVariable = 1;\nLAB_001071c4:\n              intPointer = (int *)pcVar43;\n              pcVar43 = (char *)((long)intPointer + 1);\n              unaff_R12 = (FILE *)(ulong)((uint)unaff_R12 | uintVariable);\n              if ((int)uintVariable <= (int)pcVar43) {\nLAB_00106f8b:\n                    \n                xexit(unaff_R12);\n              }\n              pcVar39 = *(char **)((char *)((long)charPointer + 0x83) + (long)intPointer * 8 + -0x7b);\n            }\n            intVariable = open(pcVar39,2,0);\n            if (intVariable < 0) {\n              bfd_set_error(1);\n              FUN_00107c10(pcVar39);\nLAB_0010737f:\n              FUN_00107c10(pcVar39);\nLAB_00107387:\n              FUN_00107c20(pcVar39);\n              intVariable = bfd_get_error();\n              if (intVariable == 0xd) {\n                FUN_00103bd1(CONCAT53(uStack_c5,\n                                      CONCAT12(uStack_c6,CONCAT11(local_c8[1],local_c8[0]))));\n              }\n              goto LAB_0010700f;\n            }\n            unaff_RBP = (char *)bfd_fdopenr(pcVar39,0);\n            if ((FILE *)unaff_RBP == (FILE *)0x0) goto LAB_0010737f;\n            charVariable = bfd_check_format_matches(unaff_RBP,2,local_c8);\n            if (charVariable == '\\0') goto LAB_00107387;\n            if ((*(byte *)((long)((long)unaff_RBP + 0x48) + 1) & 8) != 0) {\n              if (_DAT_0010d2d0 != 0) {\n                uintPointer = (uint *)((long)((long)unaff_RBP + 0x40) + 4);\n                *uintPointer = *uintPointer | 0x2000;\n              }\n              (**(code **)(*(char **)((long)unaff_RBP + 8) + 0x1f0))(unaff_RBP);\n              charVariable = bfd_close(unaff_RBP);\n              if (charVariable != '\\0') {\n                uintVariable = 0;\n                goto LAB_001071c4;\n              }\n              goto LAB_0010737f;\n            }\n            undefined8Variable = dcgettext(0,\"%s: no archive map to update\",5);\n            FUN_00107690(undefined8Variable,pcVar39);\nLAB_001073cc:\n            pcVar39 = (char *)lbasename(DAT_0010d660);\n            size_tVariable = strlen(pcVar39);\n            if ((size_tVariable < 6) ||\n               (intVariable = filename_cmp(pcVar39 + (size_tVariable - 6),\"ranlib\"), intVariable != 0)) {\n              _DAT_0010d65c = 0;\n            }\n            else {\n              _DAT_0010d65c = 1;\n            }\n            goto LAB_001062d3;\n          }\n          ppuVar36 = &PTR_DAT_0010d300;\n          unaff_RBP = \"hdmpqrtxl:coOVsSuvabiMNfPTDU\";\n          pcVar43 = (char *)&DAT_001096a0;\n          filePointer = (FILE *)unaff_RBP;\n          filePointer = filePointer;\n          if ((int)uintVariable < 2) goto switchD_00107462_caseD_1;\n          local_130 = (FILE *)CONCAT71(local_130._1_7_,(char)uintVariable);\nLAB_001063a3:\n          filePointer = (FILE *)unaff_RBP;\n          if (**(char **)((long)charPointer + 8) != '-') {\n            local_c8[0] = 0x2d;\n            uStack_c6 = 0;\n            size_tVariable = strlen(*(char **)((long)charPointer + 8));\n            intVariable = (int)size_tVariable + (int)filePointer;\n            unaff_R12 = (FILE *)xmalloc((long)intVariable * 8);\n            uintVariable = *(undefined4 *)((long)charPointer + 4);\n            unaff_R12->_flags = *(int *)charPointer;\n            *(undefined4 *)&unaff_R12->field_0x4 = uintVariable;\n            ppcVar31 = *(char ***)((long)charPointer + 8);\n            local_128 = (FILE *)((long)charPointer + 0x10);\n            local_110 = ppcVar31;\n            if (*(char *)ppcVar31 == '\\0') {\n              ppcVar32 = &unaff_R12->_IO_read_ptr;\n            }\n            else {\n              local_118 = local_c8;\n              local_c8[1] = *(char *)ppcVar31;\n              pcVar39 = (char *)xstrdup();\n              ppcVar32 = &unaff_R12->_IO_read_end;\n              unaff_R12->_IO_read_ptr = pcVar39;\n              if (*(char *)((long)ppcVar31 + 1) != '\\0') {\n                local_c8[1] = *(char *)((long)ppcVar31 + 1);\n                pcVar39 = (char *)xstrdup(local_118);\n                ppcVar32 = &unaff_R12->_IO_read_base;\n                unaff_R12->_IO_read_end = pcVar39;\n                if (*(char *)((long)ppcVar31 + 2) != '\\0') {\n                  local_c8[1] = *(char *)((long)ppcVar31 + 2);\n                  pcVar39 = (char *)xstrdup(local_118);\n                  ppcVar32 = &unaff_R12->_IO_write_base;\n                  unaff_R12->_IO_read_base = pcVar39;\n                  if (*(char *)((long)ppcVar31 + 3) != '\\0') {\n                    ppcVar32 = &unaff_R12->_IO_write_ptr;\n                    local_c8[1] = *(char *)((long)ppcVar31 + 3);\n                    pcVar39 = (char *)xstrdup(local_118);\n                    unaff_R12->_IO_write_base = pcVar39;\n                    charVariable = *(char *)((long)ppcVar31 + 4);\n                    local_110 = ppcVar32;\n                    if (charVariable != '\\0') {\n                      pcVar39 = (char *)((long)ppcVar31 + 4);\n                      ppcVar31 = ppcVar32;\n                      do {\n                        ppcVar32 = ppcVar31 + 1;\n                        local_c8[1] = charVariable;\n                        charVariable = (char *)xstrdup(local_118);\n                        pcVar39 = pcVar39 + 1;\n                        *ppcVar31 = charVariable;\n                        charVariable = *pcVar39;\n                        ppcVar31 = ppcVar32;\n                        local_110 = ppcVar32;\n                      } while (charVariable != '\\0');\n                    }\n                  }\n                }\n              }\n            }\n            longVariable = (long)(int)filePointer;\n            intPointer = (int *)charPointer + longVariable * 2;\n            if (local_128 < intPointer) {\n              ulongVariable = longVariable * 8 - 0x11;\n              if ((ulongVariable < 0x18) || (ppcVar32 == (char **)((long)charPointer + 0x18))) {\n                *ppcVar32 = *(char **)((long)charPointer + 0x10);\n                if (((char **)((long)charPointer + 0x18) < intPointer) &&\n                   ((((ppcVar32[1] = *(char **)((long)charPointer + 0x18),\n                      (char **)((long)charPointer + 0x20) < intPointer &&\n                      (ppcVar32[2] = *(char **)((long)charPointer + 0x20),\n                      (char **)((long)charPointer + 0x28) < intPointer)) &&\n                     (ppcVar32[3] = *(char **)((long)charPointer + 0x28),\n                     (char **)((long)charPointer + 0x30) < intPointer)) &&\n                    (ppcVar32[4] = *(char **)((long)charPointer + 0x30),\n                    (char **)((long)charPointer + 0x38) < intPointer)))) {\n                  ppcVar32[5] = *(char **)((long)charPointer + 0x38);\n                  charPointerPointer = ppcVar32 + 6;\n                  for (ppcVar31 = (char **)((long)charPointer + 0x40); ppcVar31 < intPointer;\n                      ppcVar31 = ppcVar31 + (ulong)byteVariable * -2 + 1) {\n                    *charPointerPointer = *ppcVar31;\n                    charPointerPointer = charPointerPointer + (ulong)byteVariable * -2 + 1;\n                  }\n                }\n              }\n              else {\n                uintVariable = *(undefined4 *)((long)((long)charPointer + 0x10) + 4);\n                uintVariable = *(undefined4 *)((long)charPointer + 0x18);\n                uintVariable = *(undefined4 *)((long)((long)charPointer + 0x18) + 4);\n                uVar40 = (ulongVariable >> 3) + 1;\n                *(undefined4 *)ppcVar32 = *(undefined4 *)((long)charPointer + 0x10);\n                *(undefined4 *)((long)ppcVar32 + 4) = uintVariable;\n                *(undefined4 *)(ppcVar32 + 1) = uintVariable;\n                *(undefined4 *)((long)ppcVar32 + 0xc) = uintVariable;\n                uintVariable = *(undefined4 *)((long)((long)charPointer + 0x20) + 4);\n                uintVariable = *(undefined4 *)((long)charPointer + 0x28);\n                uintVariable = *(undefined4 *)((long)((long)charPointer + 0x28) + 4);\n                ulongVariable = uVar40 >> 1;\n                *(undefined4 *)(ppcVar32 + 2) = *(undefined4 *)((long)charPointer + 0x20);\n                *(undefined4 *)((long)ppcVar32 + 0x14) = uintVariable;\n                *(undefined4 *)(ppcVar32 + 3) = uintVariable;\n                *(undefined4 *)((long)ppcVar32 + 0x1c) = uintVariable;\n                if (ulongVariable != 2) {\n                  uintVariable = *(undefined4 *)((long)((long)charPointer + 0x30) + 4);\n                  uintVariable = *(undefined4 *)((long)charPointer + 0x38);\n                  uintVariable = *(undefined4 *)((long)((long)charPointer + 0x38) + 4);\n                  *(undefined4 *)(ppcVar32 + 4) = *(undefined4 *)((long)charPointer + 0x30);\n                  *(undefined4 *)((long)ppcVar32 + 0x24) = uintVariable;\n                  *(undefined4 *)(ppcVar32 + 5) = uintVariable;\n                  *(undefined4 *)((long)ppcVar32 + 0x2c) = uintVariable;\n                  if (ulongVariable != 3) {\n                    uVar41 = 3;\n                    do {\n                      uVar42 = uVar41 + 1;\n                      pcVar39 = (char *)((long)charPointer + 0x83) + uVar41 * 0x10 + -0x73;\n                      uintVariable = *(undefined4 *)(pcVar39 + 4);\n                      uintVariable = *(undefined4 *)(pcVar39 + 8);\n                      uintVariable = *(undefined4 *)(pcVar39 + 0xc);\n                      ppcVar31 = ppcVar32 + uVar41 * 2;\n                      *(undefined4 *)ppcVar31 = *(undefined4 *)pcVar39;\n                      *(undefined4 *)((long)ppcVar31 + 4) = uintVariable;\n                      *(undefined4 *)(ppcVar31 + 1) = uintVariable;\n                      *(undefined4 *)((long)ppcVar31 + 0xc) = uintVariable;\n                      uVar41 = uVar42;\n                    } while (uVar42 != ulongVariable);\n                  }\n                }\n                if ((uVar40 & 1) != 0) {\n                  ppcVar32[uVar40 & 0xfffffffffffffffe] =\n                       *(char **)((long)local_128 + (uVar40 & 0xfffffffffffffffe) * 8);\n                }\n              }\n              ppcVar32 = ppcVar32 + longVariable + -2;\n            }\n            filePointer = (FILE *)(ulong)(intVariable - 1);\n            *ppcVar32 = (char *)0x0;\n            charPointer = (char *)unaff_R12;\n          }\nLAB_001065a2:\n          while( true ) {\n            uintVariable = (uint)unaff_R12;\n            uintVariable = getopt_long((ulong)filePointer & 0xffffffff,charPointer,filePointer,ppuVar36,0);\n            unaff_RBP = (char *)filePointer;\n            if (uintVariable == 0xffffffff) break;\n            if (((uintVariable - 100 < 0x15) && ((0x117201UL >> ((ulong)(uintVariable - 100) & 0x3f) & 1) != 0))\n               && (DAT_0010d64c != 0)) goto LAB_001067f7;\n            filePointer = (FILE *)charPointer;\n            if (uintVariable < 0xcc) {\n                    /* WARNING: Could not recover jumptable at 0x001065eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              (*(code *)((long)(int *)pcVar43 + (long)((int *)pcVar43)[uintVariable]))();\n              return;\n            }\nswitchD_00107462_caseD_1:\n            FUN_0010342d(0);\n            charPointer = (char *)filePointer;\nswitchD_00107462_caseD_68:\n            _DAT_0010d658 = 1;\n          }\nLAB_00106680:\n          uintVariable = DAT_0010d64c;\n          filePointer = (FILE *)unaff_RBP;\n          if (DAT_0010d64c == 0) {\n            if (((DAT_0010d648 == 1) || (_DAT_0010d650 != 0)) ||\n               (((int)filePointer <= _optind || (_optind < 1)))) {\n              uintVariable = 0;\n              goto LAB_001066aa;\n            }\n            charPointer = (char *)((long)charPointer + (long)_optind * 8 + -8);\n            uintVariable = (int)filePointer - (_optind + -1);\n            filePointer = (FILE *)(ulong)uintVariable;\n            _optind = 0;\n            if (1 < (int)uintVariable) goto LAB_001063a3;\n            goto LAB_001065a2;\n          }\nLAB_001066aa:\n          unaff_R12 = (FILE *)((ulong)local_130 & 0xff);\n          uintVariable = (uint)unaff_R12;\n          ppuVar36 = (undefined **)((int *)charPointer + (long)_optind * 2);\n          if (_DAT_0010d658 == 0) {\n            if (_DAT_0010d654 != 0) {\n              FUN_001075e0(&DAT_0010807c);\n              goto LAB_00107591;\n            }\n            if (_DAT_0010d650 == 0) {\n              filePointer = (FILE *)charPointer;\n              if (*ppuVar36 == (undefined *)0x0) goto switchD_00107462_caseD_1;\n              if (DAT_0010d64c == 7) {\n                if (DAT_0010d648 == 0) {\n                  if (uintVariable == 3) goto LAB_00106abc;\n                  if (uintVariable != 0) goto LAB_00106700;\nLAB_00106eff:\n                  pcVar39 = \"no operation specified\";\n                  goto LAB_00106803;\n                }\n                DAT_0010d64c = 2;\n                if (_DAT_0010d644 != 0) goto LAB_0010704f;\n              }\n              else if ((uintVariable == 3) || (uintVariable == 0)) {\n                if (DAT_0010d648 == 1) {\n                  uintVariable = FUN_00107650();\n                    \n                  xexit(uintVariable);\n                }\nLAB_00106abc:\n                if (uintVariable == 0) goto LAB_00106eff;\n                if (_DAT_0010d644 != 0) {\nLAB_00106ad1:\n                  pcVar39 = \"`u\\' is only meaningful with the `r\\' option.\";\n                  goto LAB_00106803;\n                }\n              }\n              else {\nLAB_00106700:\n                if (_DAT_0010d644 != 0) goto LAB_00107548;\n              }\nLAB_0010670d:\n              if (_DAT_0010d2d0 < 0) {\n                _DAT_0010d2d0 = 1;\n              }\nLAB_00106720:\n              unaff_RBP = (char *)0x0;\n              if (DAT_0010d640 != 0) {\n                DAT_0010d638 = (long)*ppuVar36;\n                unaff_RBP = (char *)0x1;\n                pcVar39 = \"missing position arg.\";\n                if (DAT_0010d638 == 0) goto LAB_00106803;\n              }\n              if (DAT_0010d634 != '\\0') {\n                pcVar39 = \"`N\\' is only meaningful with the `x\\' and `d\\' options.\";\n                if ((DAT_0010d64c & 0xfffffffb) == 1) {\n                  intVariable = (int)unaff_RBP;\n                  if (*(char **)((long)ppuVar36 + (long)intVariable * 2 * 4) == (char *)0x0) {\n                    undefined8Variable = dcgettext(0,\"`N\\' missing value.\",5);\n                    FUN_00107690(undefined8Variable);\n                    uintVariable = extraout_EDX;\nLAB_00107548:\n                    if (uintVariable == 2) {\nLAB_0010704f:\n                      pcVar39 = \"`u\\' is not meaningful with the `D\\' option.\";\n                      if (_DAT_0010d2d0 < 1) goto code_r0x00107068;\n                      goto LAB_00106803;\n                    }\n                    goto LAB_00106ad1;\n                  }\n                  unaff_RBP = (char *)(ulong)(intVariable + 1);\n                  longVariable = strtol(*(char **)((long)ppuVar36 + (long)intVariable * 2 * 4),(char **)0x0,10)\n                  ;\n                  pcVar39 = \"Value for `N\\' must be positive.\";\n                  _DAT_0010d630 = (int)longVariable;\n                  if (0 < _DAT_0010d630) goto LAB_0010673c;\n                }\n                goto LAB_00106803;\n              }\nLAB_0010673c:\n              longVariable = (long)(int)unaff_RBP;\n              filePointer = (FILE *)unaff_RBP;\n              if (*(long *)(int *)((long)ppuVar36 + longVariable * 2 * 4) == 0)\n              goto switchD_00107462_caseD_1;\n              filePointer = (FILE *)((long)ppuVar36 + (longVariable + 1) * 2 * 4);\n              if (*(FILE **)filePointer == (FILE *)0x0) {\n                pcVar43 = (char *)0x0;\n                filePointer = (FILE *)0x0;\n              }\n              else if (*(long *)((long)ppuVar36 + (longVariable + 2) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x1;\n              }\n              else if (*(long *)((long)ppuVar36 + (longVariable + 3) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x2;\n              }\n              else if (*(long *)((long)ppuVar36 + (longVariable + 4) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x3;\n              }\n              else if (*(long *)((long)ppuVar36 + (longVariable + 5) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x4;\n              }\n              else {\n                filePointer = (FILE *)0x5;\n                do {\n                  pcVar43 = (char *)filePointer;\n                  filePointer = (FILE *)((long)(int *)pcVar43 + 1);\n                } while (*(long *)((int *)((long)ppuVar36 + longVariable * 2 * 4) + (long)filePointer * 2) !=\n                         0);\n              }\n              undefined8Pointer = (undefined8 *)FUN_00105300();\n              filePointer = filePointer;\n              if (DAT_0010d64c == 5) {\n                pcVar39 = \"`x\\' cannot be used on thin archives.\";\n                if ((*(byte *)((long)undefined8Pointer + 0x49) & 0x10) == 0) {\n                  unaff_RBP = (char *)filePointer;\n                  if (DAT_0010d628 != (char *)0x0) goto LAB_00106d5c;\nswitchD_00106ed8_caseD_5:\n                  FUN_00105480(undefined8Pointer,FUN_00107740,unaff_RBP,(ulong)pcVar43 & 0xffffffff);\n                  goto LAB_0010696c;\n                }\n                goto LAB_00106803;\n              }\n              if (DAT_0010d628 != (char *)0x0) {\nLAB_00106d5c:\n                size_tVariable = strlen(DAT_0010d628);\n                charPointer = \"__.LIBDEP\";\n                unaff_RBP = (char *)(size_tVariable + 1);\n                DAT_0010d620 = bfd_create(\"__.LIBDEP\",undefined8Pointer);\n                if (DAT_0010d620 == 0) {\n                  pcVar39 = \"Cannot create libdeps record.\";\n                }\n                else {\n                  longVariable = bfd_find_target(\"binary\",DAT_0010d620);\n                  pcVar39 = \"Cannot set libdeps record type to binary.\";\n                  if (longVariable != 0) {\n                    charVariable = bfd_set_format(DAT_0010d620,1,5);\n                    pcVar39 = \"Cannot set libdeps object format.\";\n                    if (charVariable == '\\0') goto LAB_00106803;\n                    charVariable = bfd_make_writable(DAT_0010d620,\"Cannot set libdeps object format.\",5);\n                    pcVar39 = \"Cannot make libdeps object writable.\";\n                    if (charVariable == '\\0') goto LAB_00106803;\n                    filePointer = (FILE *)bfd_bwrite(DAT_0010d628,unaff_RBP,DAT_0010d620);\n                    pcVar39 = \"Cannot write libdeps record.\";\n                    if (filePointer != (FILE *)unaff_RBP) goto LAB_00106803;\n                    charVariable = bfd_make_readable(DAT_0010d620,\"Cannot write libdeps record.\",5);\n                    pcVar39 = \"Cannot make libdeps object readable.\";\n                    if (charVariable == '\\0') goto LAB_00106803;\n                    longVariable = bfd_find_target(\"plugin\",DAT_0010d620,5);\n                    pcVar39 = \"Cannot reset libdeps record type.\";\n                    if (longVariable == 0) goto LAB_00106803;\n                    intVariable = (int)pcVar43;\n                    local_130 = (FILE *)((long)(intVariable + 2) * 8);\n                    unaff_RBP = (char *)xmalloc(local_130,\"Cannot reset libdeps record type.\");\n                    if (intVariable == 0) {\n                      longVariable = 0;\n                    }\n                    else {\n                      uintVariable = *(undefined4 *)&filePointer->field_0x4;\n                      *(int *)unaff_RBP = filePointer->_flags;\n                      *(undefined4 *)((long)unaff_RBP + 4) = uintVariable;\n                      longVariable = 8;\n                      ppcVar31 = (char **)((long)unaff_RBP + 8);\n                      for (pcVar43 = local_130[-1]._unused2 + 4; pcVar43 != (char *)0x0;\n                          pcVar43 = pcVar43 + -1) {\n                        *(undefined *)ppcVar31 = *(undefined *)&filePointer->_flags;\n                        filePointer = (FILE *)((long)filePointer + (ulong)byteVariable * -2 + 1);\n                        ppcVar31 = (char **)((long)ppcVar31 + (ulong)byteVariable * -2 + 1);\n                      }\n                    }\n                    *(char **)((long)(char **)unaff_RBP + longVariable) = \"__.LIBDEP\";\n                    pcVar43 = (char *)(ulong)(intVariable + 1);\n                    *(undefined8 *)\n                     (((FILE *)((long)unaff_RBP + -0xd8))->_unused2 + 0xc + (long)local_130) = 0;\n                    switch(DAT_0010d64c) {\n                    case 1:\n                      goto switchD_00106ed8_caseD_1;\n                    case 2:\n                    case 7:\n                      break;\n                    case 3:\n                      goto switchD_00106ed8_caseD_3;\n                    case 4:\n                      goto switchD_00106ed8_caseD_4;\n                    case 5:\n                      goto switchD_00106ed8_caseD_5;\n                    case 6:\n                      filePointer = (FILE *)unaff_RBP;\n                      if (_DAT_0010d610 == 0) goto LAB_00106afb;\n                      break;\n                    default:\n                      goto switchD_001067e8_caseD_5;\n                    }\n                    goto switchD_00106ed8_caseD_2;\n                  }\n                }\n                goto LAB_00106803;\n              }\n              switch(DAT_0010d64c) {\n              case 1:\n                unaff_RBP = (char *)filePointer;\n                if (filePointer == (FILE *)0x0) break;\nswitchD_00106ed8_caseD_1:\n                filePointer = (FILE *)0x0;\n                goto LAB_00106b89;\n              case 2:\n              case 7:\nswitchD_001067e8_caseD_2:\n                unaff_RBP = (char *)filePointer;\n                if ((filePointer != (FILE *)0x0) || (0 < DAT_0010d648)) {\nswitchD_00106ed8_caseD_2:\n                  FUN_00105570(undefined8Pointer,unaff_RBP,DAT_0010d64c == 7);\n                  goto LAB_0010696c;\n                }\n                break;\n              case 3:\n                unaff_RBP = (char *)filePointer;\nswitchD_00106ed8_caseD_3:\n                FUN_00105480(undefined8Pointer,FUN_00107890,unaff_RBP,(ulong)pcVar43 & 0xffffffff);\n                goto LAB_0010696c;\n              case 4:\n                unaff_RBP = (char *)filePointer;\nswitchD_00106ed8_caseD_4:\n                FUN_00105480(undefined8Pointer,FUN_00103a78,unaff_RBP,(ulong)pcVar43 & 0xffffffff);\n                goto LAB_0010696c;\n              default:\nswitchD_001067e8_caseD_5:\n                pcVar39 = \"internal error -- this option not implemented\";\n                goto LAB_00106803;\n              case 6:\n                if (_DAT_0010d610 != 0) goto switchD_001067e8_caseD_2;\n                if (filePointer == (FILE *)0x0) break;\nLAB_00106afb:\n                filePointer = (FILE *)(undefined8Pointer + 0x1e);\n                do {\n                  unaff_R12 = filePointer;\n                  if (*(FILE **)filePointer == (FILE *)0x0) {\nLAB_00106b9f:\n                    FUN_001058b0(undefined8Pointer);\n                    goto LAB_0010696c;\n                  }\n                  while( true ) {\n                    longPointer = *(long **)unaff_R12;\n                    charPointer = *(char **)filePointer;\n                    if (longPointer == (long *)0x0) {\n                      undefined8Variable = *undefined8Pointer;\n                      undefined8Variable = dcgettext(0,\"no entry %s in archive %s!\",5);\n                      FUN_00107690(undefined8Variable,charPointer,undefined8Variable);\n                      pcVar43 = (char *)0x0;\n                      goto LAB_00107293;\n                    }\n                    longVariable = *longPointer;\n                    undefined8Variable = FUN_00105830(charPointer,undefined8Pointer);\n                    intVariable = filename_cmp(undefined8Variable,longVariable);\n                    if (intVariable == 0) break;\n                    unaff_R12 = (FILE *)(*(long **)unaff_R12 + 0x1e);\n                  }\n                  *(long **)unaff_R12 = (long *)longPointer[0x1e];\n                  longPointerPointer = (long **)FUN_00105870(filePointer,3,0);\n                  boolVariable = DAT_0010d60c != 0;\n                  longPointer = *longPointerPointer;\n                  *longPointerPointer = longPointer;\n                  longPointer[0x1e] = (long)longPointer;\n                  if (boolVariable) {\n                    printf(\"m - %s\\n\",*(FILE **)filePointer);\n                  }\n                  filePointer = (FILE *)&filePointer->_IO_read_ptr;\n                } while( true );\n              }\n              goto LAB_00106d4e;\n            }\n            if (-1 < _DAT_0010d2d0) goto LAB_0010755f;\n          }\n          else {\nLAB_00107591:\n            FUN_0010342d(1);\n          }\n          _DAT_0010d2d0 = 1;\nLAB_0010755f:\n          intVariable = fileno(_stdin);\n          _DAT_0010d608 = isatty(intVariable);\n          FUN_00103e95();\nLAB_0010696c:\n                    \n          xexit(0);\n        }\n        uintVariable = bfd_get_error();\n        filePointer = (FILE *)bfd_errmsg(uintVariable);\n        undefined8Variable = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n        intVariable = FUN_00107690(undefined8Variable,\"x86_64-pc-linux-gnu\",filePointer);\nLAB_0010751b:\n        if (DAT_0010d64c == 0) {\nLAB_00107447:\n          ppuVar36 = (undefined **)pcVar39;\n          filePointer = (FILE *)charPointer;\n          switch(intVariable) {\n          case 0:\n            goto switchD_00107462_caseD_0;\n          default:\n            goto switchD_00107462_caseD_1;\n          case 0x44:\n            _DAT_0010d2d0 = 1;\n            goto LAB_001065a2;\n          case 0x4d:\n            _DAT_0010d650 = 1;\n            goto LAB_001065a2;\n          case 0x4e:\n            DAT_0010d634 = '\\x01';\n            goto LAB_001065a2;\n          case 0x4f:\n            _DAT_0010d5fc = 1;\n            goto LAB_001065a2;\n          case 0x50:\n            DAT_0010d5f9 = 1;\n            goto LAB_001065a2;\n          case 0x53:\n            DAT_0010d648 = -1;\n            goto LAB_001065a2;\n          case 0x54:\n            DAT_0010d5f8 = 1;\n            goto LAB_001065a2;\n          case 0x55:\n            _DAT_0010d2d0 = 0;\n            goto LAB_001065a2;\n          case 0x56:\n            _DAT_0010d654 = 1;\n            goto LAB_001065a2;\n          case 0x61:\n            DAT_0010d640 = 2;\n            goto LAB_001065a2;\n          case 0x62:\n          case 0x69:\n            DAT_0010d640 = 1;\n            goto LAB_001065a2;\n          case 99:\n            _DAT_0010d610 = 1;\n            goto LAB_001065a2;\n          case 100:\n            DAT_0010d64c = 1;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x66:\n            DAT_0010d5fa = 1;\n            goto LAB_001065a2;\n          case 0x68:\n            goto switchD_00107462_caseD_68;\n          case 0x6c:\n            if (DAT_0010d628 == (char *)0x0) {\n              DAT_0010d628 = _optarg;\n              goto LAB_001065a2;\n            }\nLAB_00107293:\n            uintVariable = (uint)unaff_R12;\n            pcVar39 = \"libdeps specified more than once\";\n            unaff_RBP = (char *)filePointer;\n            break;\n          case 0x6d:\n            DAT_0010d64c = 6;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x6f:\n            _DAT_0010d600 = 1;\n            goto LAB_001065a2;\n          case 0x70:\n            DAT_0010d64c = 4;\n            goto LAB_001065a2;\n          case 0x71:\n            DAT_0010d64c = 7;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x72:\n            DAT_0010d64c = 2;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x73:\n            DAT_0010d648 = 1;\n            goto LAB_001065a2;\n          case 0x74:\n            DAT_0010d64c = 3;\n            goto LAB_001065a2;\n          case 0x75:\n            _DAT_0010d644 = 1;\n            goto LAB_001065a2;\n          case 0x76:\n            DAT_0010d60c = 1;\n            goto LAB_001065a2;\n          case 0x78:\n            DAT_0010d64c = 5;\n            goto LAB_001065a2;\n          case 0xc9:\n            bfd_plugin_set_plugin(_optarg);\n            goto LAB_001065a2;\n          case 0xca:\n            DAT_0010d5f0 = _optarg;\n            goto LAB_001065a2;\n          case 0xcb:\n            DAT_0010d5e8 = _optarg;\n            goto LAB_001065a2;\n          }\n          goto LAB_00106803;\n        }\nLAB_001067f7:\n        pcVar39 = \"two different operation options specified\";\n        unaff_RBP = (char *)filePointer;\nLAB_00106803:\n        undefined8Variable = dcgettext(0,pcVar39,5);\n        FUN_00107690(undefined8Variable);\nLAB_00106814:\n        intVariable = (int)charPointer;\n        filePointer = (FILE *)xmalloc(8);\n        *(long **)filePointer = (long *)0x0;\n        if ((FILE *)pcVar43 == argv) {\nLAB_00106834:\n          if (*(long **)pcVar43 == (long *)0x0) {\n            intVariable = 0;\n          }\n          else {\n            longVariable = 1;\n            do {\n              intVariable = (int)longVariable;\n              lVar35 = longVariable * 2;\n              longVariable = longVariable + 1;\n            } while (*(long *)((int *)pcVar43 + lVar35) != 0);\n          }\n          filePointer = (FILE *)xmalloc((long)(intVariable + 1) << 3);\n          longPointer = *(long **)pcVar43;\n          longVariable = 0;\n          while (longPointer != (long *)0x0) {\n            undefined8Variable = xstrdup();\n            *(undefined8 *)((long)&filePointer->_flags + longVariable) = undefined8Variable;\n            longPointer = *(long **)((char *)((long)pcVar43 + 0x83) + longVariable + -0x7b);\n            longVariable = longVariable + 8;\n          }\n          *(undefined8 *)((long)&filePointer->_flags + longVariable) = 0;\nLAB_0010610a:\n          intVariable = (int)charPointer;\n          pcVar43 = (char *)filePointer;\n          if (*(long **)filePointer == (long *)0x0) goto LAB_00106a80;\n          longVariable = 0;\n          do {\n            lVar34 = longVariable + 1;\n            lVar35 = longVariable * 8;\n            longVariable = lVar34;\n          } while (*(long *)(filePointer->_shortbuf + lVar35 + -0x7b) != 0);\n          local_108 = lVar34 * 8;\n        }\n        else {\nLAB_00106a80:\n          lVar34 = 0;\n          local_108 = 0;\n        }\n        longVariable = (long)unaff_RBP * 2;\n        unaff_RBP = (char *)((long)(char **)unaff_RBP + lVar34);\n        free(*(void **)((int *)pcVar43 + longVariable));\n        filePointer = (FILE *)xrealloc(pcVar43,(lVar34 + 1 + (long)intVariable) * 8);\n        uintVariable = intVariable + -1 + (int)lVar34;\n        charPointer = (char *)(ulong)uintVariable;\n        memmove(&filePointer->_flags + (long)unaff_RBP * 2,\n                (void *)((long)&filePointer->_IO_read_ptr + (long)local_130),\n                (long)(int)(intVariable - uintVariable) << 3);\n        memcpy((void *)((long)&local_130->_flags + (long)&filePointer->_flags),filePointer,local_108);\n        free(filePointer);\n        free(local_118);\n        fclose(filePointer);\n        uintVariable = (int)local_128 + 1;\n        unaff_R12 = local_130;\n        pcVar43 = (char *)filePointer;\n        local_130 = filePointer;\n        if ((int)uintVariable < (int)uintVariable) goto LAB_001061ce;\n      } while( true );\n    }\n    uintVariable = uintVariable + 1;\n    local_128 = unaff_R12;\nLAB_001061ce:\n    unaff_R12 = (FILE *)(ulong)uintVariable;\n  } while( true );\nswitchD_00107462_caseD_0:\n  intVariable = getopt_long((ulong)filePointer & 0xffffffff,charPointer,filePointer,\"x86_64-pc-linux-gnu\");\n  unaff_RBP = (char *)filePointer;\n  if (intVariable == -1) goto LAB_00106680;\n  if ((0x14 < intVariable - 100U) || ((0x117201UL >> ((byte)(intVariable - 100U) & 0x3f) & 1) == 0))\n  goto LAB_00107447;\n  goto LAB_0010751b;\ncode_r0x00107068:\n  if (_DAT_0010d2d0 != 0) goto code_r0x0010706e;\n  goto LAB_00106720;\ncode_r0x0010706e:\n  undefined8Variable = dcgettext(0,\"`u\\' modifier ignored since `D\\' is the default (see `U\\')\",5);\n  FUN_00107920(undefined8Variable);\n  goto LAB_0010670d;\nLAB_00106b89:\n  if (*(FILE **)unaff_RBP == (FILE *)0x0) {\n    if ((char)filePointer != '\\0') goto LAB_00106b9f;\nLAB_00106d4e:\n    DAT_0010d618 = 0;\n    goto LAB_0010696c;\n  }\n  intVariable = 0;\n  intVariable = strcmp((char *)*(FILE **)unaff_RBP,\"__.SYMDEF\");\n  undefined8Pointer = undefined8Pointer;\n  if (intVariable == 0) {\n    *(byte *)((long)undefined8Pointer + 0x49) = *(byte *)((long)undefined8Pointer + 0x49) & 0xf7;\n    DAT_0010d648 = -1;\n  }\n  else {\n    while( true ) {\n      longPointer = undefined8Pointer + 0x1e;\n      if ((undefined8 *)*longPointer == (undefined8 *)0x0) break;\n      undefined8Variable = *(undefined8 *)*longPointer;\n      undefined8Variable = FUN_00105830(*(FILE **)unaff_RBP,undefined8Pointer);\n      intVariable = filename_cmp(undefined8Variable,undefined8Variable);\n      if ((intVariable == 0) &&\n         ((DAT_0010d634 == '\\0' || (intVariable = intVariable + 1, intVariable == _DAT_0010d630)))) {\n        if (DAT_0010d60c != 0) {\n          printf(\"d - %s\\n\",*(FILE **)unaff_RBP);\n        }\n        *longPointer = *(long *)(*longPointer + 0xf0);\n        filePointer = unaff_R12;\n        goto LAB_00106d38;\n      }\n      undefined8Pointer = (undefined8 *)*longPointer;\n    }\n    if (DAT_0010d60c != 0) {\n      filePointer = *(FILE **)unaff_RBP;\n      charPointer = (char *)dcgettext(0,\"No member named `%s\\'\\n\",5);\n      printf(charPointer,filePointer);\n    }\n  }\nLAB_00106d38:\n  unaff_RBP = (char *)((long)unaff_RBP + 8);\n  goto LAB_00106b89;\n}\n\n",
            "called": [
                "bfd_errmsg",
                "FUN_00105870",
                "fileno",
                "bfd_set_error_program_name",
                "FUN_0010342d",
                "textdomain",
                "filename_cmp",
                "bfd_check_format_matches",
                "memcpy",
                "strlen",
                "bfd_plugin_set_plugin",
                "FUN_001075e0",
                "FUN_00107c10",
                "FUN_00105300",
                "xmalloc_set_program_name",
                "FUN_00105570",
                "bfd_close",
                "strtol",
                "isatty",
                "FUN_00107cc0",
                "FUN_00107730",
                "fread",
                "ferror",
                "bfd_set_error",
                "dcgettext",
                "fopen",
                "bindtextdomain",
                "FUN_00107c20",
                "free",
                "FUN_00105830",
                "FUN_00107650",
                "lbasename",
                "FUN_00103a78",
                "xstrdup",
                "FUN_00105480",
                "bfd_find_target",
                "FUN_0010394a",
                "open",
                "bfd_make_writable",
                "fseek",
                "fprintf",
                "stat",
                "FUN_001052a0",
                "xrealloc",
                "bfd_make_readable",
                "bfd_set_default_target",
                "FUN_00107740",
                "FUN_00107920",
                "getopt_long",
                "ftell",
                "printf",
                "FUN_00103e95",
                "FUN_00107890",
                "FUN_00107690",
                "fclose",
                "FUN_00103bd1",
                "bfd_set_format",
                "setlocale",
                "xexit",
                "xmalloc",
                "bfd_fdopenr",
                "FUN_00107640",
                "bfd_bwrite",
                "bfd_get_error",
                "FUN_001058b0",
                "bfd_init",
                "strcmp",
                "bfd_create",
                "bfd_plugin_set_program_name",
                "malloc",
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105db0",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "parse_options_00105db0"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "FUN_00103bd1": {
            "renaming": {
                "FUN_00103bd1": "print_matching_formats_00103bd1",
                "param_1": "formatArray",
                "__format": "formatString",
                "plVar2": "currentFormat",
                "uVar1": "defaultFormat",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103bd1(long *formatArray)\n\n{\n  undefined8 defaultFormat;\n  char *formatString;\n  long *currentFormat;\n  \n  fflush(standardOutput);\n  defaultFormat = DAT_0010d660;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(standardError,formatString,defaultFormat);\n  for (currentFormat = formatArray; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(standardError,\" %s\");\n  }\n  free(formatArray);\n  fputc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "free",
                "dcgettext",
                "fflush",
                "fprintf",
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bd1",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103bd1"
        },
        "strcmp": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "strcmp"
        },
        "FUN_00107c10": {
            "renaming": {
                "FUN_00107c10": "terminate_program_00107c10",
                "xexit": "exitStatus"
            },
            "code": "\nvoid terminateProgram_00107c10(void)\n\n{\n  FUN_00107c20();\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_00107c20",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c10",
            "calling": [
                "FUN_00105300",
                "FUN_001028ed",
                "FUN_001058b0",
                "FUN_00102d2f",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "terminate_program_00107c10"
        },
        "read": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "read"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107da8",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "FUN_00102710": {
            "renaming": {
                "FUN_00102710": "analyze_binary_00102710",
                "plVar1": "next_archived_file",
                "cVar2": "format_matches",
                "bVar3": "convert_existing",
                "iVar4": "error",
                "lVar5": "file",
                "uVar6": "error_message",
                "uVar7": "library_name",
                "puVar8": "output_file",
                "unaff_RBP": "reserved_register",
                "in_stack_00000008": "stack_parameter",
                "stack0x00000008": "stack_parameter2"
            },
            "code": "\n\n\nundefined8 * analyze_binary_00102710(void)\n\n{\n  long *next_archived_file;\n  char format_matches;\n  byte convert_existing;\n  int error;\n  long file;\n  undefined8 error_message;\n  undefined8 library_name;\n  undefined8 *output_file;\n  undefined8 reserved_register;\n  undefined8 stack_parameter;\n  \n  file = bfd_openr();\n  if (file != 0) {\n    format_matches = bfd_check_format(file,1);\n    if (format_matches != '\\0') {\n      DAT_0010d5f0 = **(undefined8 **)(file + 8);\n    }\n    bfd_close(file);\n  }\n  output_file = (undefined8 *)bfd_openw();\n  if (((output_file != (undefined8 *)0x0) && (format_matches = bfd_set_format(output_file,2), format_matches != '\\0')) &&\n     (format_matches = bfd_close(output_file), format_matches != '\\0')) {\n    if (_DAT_0010d610 == 0) goto LAB_00102826;\n    goto LAB_001053b7;\n  }\n  FUN_00107c10();\n  do {\n    convert_existing = *(byte *)((long)output_file + 0x49) >> 4 & 1;\n    if (DAT_0010d5f8 == '\\0') {\n      if (convert_existing != 0) {\n        library_name = *output_file;\n        error_message = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        FUN_00107690(error_message,library_name);\n        goto LAB_00102812;\n      }\n    }\n    else if (convert_existing == 0) {\n      library_name = *output_file;\n      error_message = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      FUN_00107690(error_message,library_name);\nLAB_001027cb:\n      FUN_00107c20();\n      error = bfd_get_error();\n      if (error == 0xd) {\nLAB_00102812:\n        FUN_00103bd1(stack_parameter);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      next_archived_file = output_file + 0x1e;\n      for (file = bfd_openr_next_archived_file(output_file,0); file != 0;\n          file = bfd_openr_next_archived_file(output_file,file)) {\n        *next_archived_file = file;\n        next_archived_file = (long *)(file + 0xf0);\n      }\n      *next_archived_file = 0;\n      error = bfd_get_error();\n      if (error == 9) {\n        return output_file;\n      }\n      do {\n        FUN_00107c10();\nLAB_00102826:\n        library_name = dcgettext(0,\"creating %s\",5);\n        FUN_00107920(library_name);\nLAB_001053b7:\n        DAT_0010d618 = reserved_register;\n        output_file = (undefined8 *)bfd_openr();\n      } while (output_file == (undefined8 *)0x0);\n      format_matches = bfd_check_format_matches(output_file,2,&stack_parameter2);\n      if (format_matches == '\\0') goto LAB_001027cb;\n    } while (((DAT_0010d64c != 2) && (DAT_0010d64c != 7)) ||\n            (file = bfd_openr_next_archived_file(output_file,0), file == 0));\n  } while( true );\n}\n\n",
            "called": [
                "bfd_close",
                "bfd_check_format",
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102710",
            "calling": [
                "FUN_00105300"
            ],
            "imported": false,
            "current_name": "analyze_binary_00102710"
        },
        "FUN_00103e95": {
            "renaming": {
                "FUN_00103e95": "decompress_and_print_file_00103e95",
                "pplVar1": "doublePointer",
                "cVar2": "character",
                "ppFVar3": "doublePointerToFile",
                "pFVar4": "filePointer",
                "plVar5": "longPointer",
                "uVar6": "unsignedLong",
                "pbVar7": "bytePointer",
                "iVar8": "integer",
                "pcVar10": "characterPointer",
                "pcVar15": "characterPointer2",
                "pcVar16": "characterPointer3",
                "lVar17": "long",
                "lVar18": "length",
                "lVar21": "long2",
                "puVar22": "unsignedLongPointer",
                "puVar23": "unsignedLongPointer2",
                "uVar24": "unsignedInteger",
                "iVar25": "integer2",
                "uVar26": "unsignedLong2",
                "ppcVar27": "doubleCharacterPointer",
                "bVar28": "boolean",
                "ppcVar29": "doubleCharacterPointer2",
                "bVar30": "byte",
                "lVar31": "long3",
                "pbVar32": "bytePointer2",
                "pbVar33": "bytePointer3",
                "piVar34": "integerPointer",
                "pbVar35": "bytePointer4",
                "iVar37": "integer3",
                "uVar36": "unsignedInteger2",
                "uVar20": "unsignedInteger3",
                "uVar19": "unsignedLong",
                "local_828": "local_string",
                "local_820": "original_string",
                "local_818": "string_size",
                "local_810": "local_string_array",
                "local_800": "integer4",
                "local_7fc": "unsignedInteger4",
                "local_7f8": "bytePointer6",
                "local_7d0": "stat_structure",
                "local_740": "buffer",
                "local_678": "local_string_array2",
                "bVar39": "byte2",
                "auVar40": "anonymousVariable_40",
                "auVar41": "anonymousVariable_41",
                "ppcVar38": "doubleCharacterPointer3"
            },
            "code": "\n\n\nvoid decompressAndPrintFile_00103e95(void)\n\n{\n  long **doublePointer;\n  char character;\n  FILE **doublePointerToFile;\n  FILE *filePointer;\n  long *longPointer;\n  undefined8 unsignedLong;\n  byte *bytePointer;\n  int integer;\n  char *characterPointer;\n  undefined8 uVar11;\n  int iVar9;\n  long *plVar12;\n  size_t sVar13;\n  void *pvVar14;\n  char *characterPointer2;\n  char *characterPointer3;\n  long long;\n  long length;\n  ulong unsignedLong;\n  uint unsignedInteger3;\n  long long2;\n  undefined8 *unsignedLongPointer;\n  undefined8 *unsignedLongPointer2;\n  uint unsignedInteger;\n  int integer2;\n  ulong unsignedLong2;\n  char **doubleCharacterPointer;\n  bool boolean;\n  char **doubleCharacterPointer2;\n  byte byte;\n  long long3;\n  byte *bytePointer2;\n  byte *bytePointer3;\n  int *integerPointer;\n  byte *bytePointer4;\n  uint unsignedInteger2;\n  int integer3;\n  char **doubleCharacterPointer3;\n  byte byte2;\n  undefined anonymousVariable_40 [16];\n  undefined anonymousVariable_41 [16];\n  char *local_string;\n  char *original_string;\n  long string_size;\n  char **local_string_array;\n  int integer4;\n  uint unsignedInteger4;\n  byte *bytePointer6;\n  stat stat_structure;\n  char buffer [200];\n  char *local_string_array2 [201];\n  \n  byte2 = 0;\n  length = 0;\n  DAT_0010d550 = -2;\n  doubleCharacterPointer2 = local_string_array2;\n  integer4 = 0;\n  local_string = buffer;\n  string_size = 200;\n  original_string = local_string;\n  local_string_array = doubleCharacterPointer2;\nLAB_00103ee9:\n  *local_string = (char)length;\n  if (original_string + string_size + -1 <= local_string) {\n    long2 = (long)local_string - (long)original_string;\n    long = long2 + 1;\n    if (string_size < 10000) {\n      long3 = string_size * 2;\n      string_size = 10000;\n      if (long3 < 0x2711) {\n        string_size = long3;\n      }\n      characterPointer = (char *)malloc(string_size * 9 + 7);\n      if (characterPointer != (char *)0x0) {\n        long3 = long * 8;\n        characterPointer2 = original_string;\n        characterPointer3 = characterPointer;\n        for (; long != 0; long = long + -1) {\n          *characterPointer3 = *characterPointer2;\n          characterPointer2 = characterPointer2 + (ulong)byte2 * -2 + 1;\n          characterPointer3 = characterPointer3 + (ulong)byte2 * -2 + 1;\n        }\n        doubleCharacterPointer3 = (char **)(characterPointer + string_size);\n        doubleCharacterPointer2 = doubleCharacterPointer3;\n        for (; long3 != 0; long3 = long3 + -1) {\n          *(undefined *)doubleCharacterPointer2 = *(undefined *)local_string_array;\n          local_string_array = (char **)((long)local_string_array + (ulong)byte2 * -2 + 1);\n          doubleCharacterPointer2 = (char **)((long)doubleCharacterPointer2 + (ulong)byte2 * -2 + 1);\n        }\n        if (original_string != buffer) {\n          free(original_string);\n        }\n        local_string = characterPointer + long2;\n        doubleCharacterPointer2 = doubleCharacterPointer3 + long2;\n        original_string = characterPointer;\n        local_string_array = doubleCharacterPointer3;\n        if (characterPointer + string_size + -1 <= local_string) goto LAB_00105265;\n        goto LAB_00103fd8;\n      }\n    }\n    FUN_001031a5();\nLAB_0010524c:\n    characterPointer = original_string;\n    if (original_string == buffer) {\n      return;\n    }\nLAB_00105265:\n    free(characterPointer);\n    return;\n  }\nLAB_00103fd8:\n  integer3 = (int)length;\n  if (integer3 == 3) goto LAB_0010524c;\n  character = (&DAT_0010a200)[integer3];\n  if (character != -0xe) {\n    if (DAT_0010d550 == -2) {\n      if (_DAT_0010d540 == 0) {\n        _DAT_0010d540 = 1;\n        if (DAT_0010d5d0 == 0) {\n          DAT_0010d5d0 = 1;\n        }\n        if (DAT_0010d590 == (FILE *)0x0) {\n          DAT_0010d590 = _stdin;\n        }\n        if (DAT_0010d538 == (FILE *)0x0) {\n          DAT_0010d538 = _stdout;\n        }\n        if ((DAT_0010d5a8 == 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) == 0)) {\n          FUN_00103df9();\n          unsignedLongPointer = (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          uVar11 = FUN_001033d6(DAT_0010d590);\n          *unsignedLongPointer = uVar11;\n        }\n        FUN_001030ed();\n      }\nLAB_001040b1:\n      *DAT_0010d5b0 = DAT_0010d588;\n      bytePointer2 = DAT_0010d5b0;\n      bytePointer4 = DAT_0010d5b0;\n      unsignedInteger3 = DAT_0010d5d0;\nLAB_001040d4:\n      unsignedLong = (ulong)unsignedInteger3;\n      unsignedLong2 = (ulong)unsignedInteger4;\n      boolean = false;\n      do {\n        byte = (&DAT_0010ab00)[*bytePointer4];\n        if (*(short *)(&DAT_0010a980 + (long)(int)unsignedLong * 2) != 0) {\n          boolean = true;\n          unsignedLong2 = unsignedLong & 0xffffffff;\n          bytePointer6 = bytePointer4;\n        }\n        while( true ) {\n          integer = (int)unsignedLong;\n          length = (long)(int)((int)*(short *)(&DAT_0010a640 + (long)integer * 2) + (uint)byte);\n          if (integer == *(short *)(&DAT_0010a440 + length * 2)) break;\n          unsignedLong = (ulong)(uint)(int)*(short *)(&DAT_0010a800 + (long)integer * 2);\n          if (0xb0 < *(short *)(&DAT_0010a800 + (long)integer * 2)) {\n            byte = (&DAT_0010a7c0)[(int)(uint)byte];\n          }\n        }\n        bytePointer4 = bytePointer4 + 1;\n        unsignedLong = (ulong)*(short *)(&DAT_0010a240 + length * 2);\n      } while (*(short *)(&DAT_0010a640 + unsignedLong * 2) != 0xc2);\n      unsignedInteger4 = (uint)unsignedLong2;\n      bytePointer3 = bytePointer2;\n      if (boolean) {\n        DAT_0010d5b8 = bytePointer6;\n        DAT_0010d5c0 = unsignedInteger4;\n      }\nLAB_0010419f:\n      integer = (int)*(short *)(&DAT_0010a980 + (long)(int)unsignedLong * 2);\n      if (integer == 0) {\n        integer = (int)*(short *)(&DAT_0010a980 + (long)(int)DAT_0010d5c0 * 2);\n        bytePointer4 = DAT_0010d5b8;\n      }\n      DAT_0010d530 = (int)bytePointer4 - (int)bytePointer3;\n      DAT_0010d588 = *bytePointer4;\n      DAT_0010d5b0 = bytePointer4;\n      DAT_0010d5c8 = bytePointer3;\n      *bytePointer4 = 0;\nLAB_001041f0:\n      bytePointer2 = DAT_0010d5c8;\n      length = DAT_0010d5a0;\n      switch(integer) {\n      case 0:\n        goto switchD_00104200_caseD_0;\n      case 1:\n      case 0x10:\n        DAT_0010d550 = 0x105;\n        break;\n      case 2:\n      case 0x11:\n        DAT_0010d550 = 0x107;\n        break;\n      case 3:\n      case 0x12:\n        DAT_0010d550 = 0x108;\n        break;\n      case 4:\n      case 0x13:\n        DAT_0010d550 = 0x109;\n        break;\n      case 5:\n      case 0x14:\n        DAT_0010d550 = 0x10a;\n        break;\n      case 6:\n      case 0x15:\n        DAT_0010d550 = 0x10b;\n        break;\n      case 7:\n      case 0x16:\n        DAT_0010d550 = 0x10c;\n        break;\n      case 8:\n      case 0x17:\n        DAT_0010d550 = 0x10d;\n        break;\n      case 9:\n      case 0x18:\n        DAT_0010d550 = 0x10e;\n        break;\n      case 10:\n      case 0x19:\n        DAT_0010d550 = 0x10f;\n        break;\n      case 0xb:\n      case 0x1a:\n        DAT_0010d550 = 0x106;\n        break;\n      case 0xc:\n      case 0x1b:\n        DAT_0010d550 = 0x113;\n        break;\n      case 0xd:\n      case 0x1c:\n        DAT_0010d550 = 0x111;\n        break;\n      case 0xe:\n      case 0x1d:\n        DAT_0010d550 = 0x103;\n        break;\n      case 0x1f:\n        DAT_0010d554 = DAT_0010d554 + 1;\n        goto LAB_001040b1;\n      case 0x20:\n        DAT_0010d550 = 0x28;\n        break;\n      case 0x21:\n        DAT_0010d550 = 0x29;\n        break;\n      case 0x22:\n        DAT_0010d550 = 0x2c;\n        break;\n      case 0x23:\n        DAT_0010d548 = (char *)xstrdup(DAT_0010d5c8);\n        DAT_0010d550 = 0x104;\n        break;\n      case 0x24:\n      case 0x25:\n      case 0x26:\n        goto LAB_001040b1;\n      case 0x27:\n        DAT_0010d554 = DAT_0010d554 + 1;\n        DAT_0010d550 = 0x102;\n        break;\n      case 0x28:\n        fwrite(DAT_0010d5c8,(long)DAT_0010d530,1,DAT_0010d538);\n        goto LAB_001040b1;\n      case 0x29:\n        goto switchD_00104200_caseD_29;\n      case 0x2a:\n        DAT_0010d550 = 0;\n        break;\n      default:\n        FUN_001033b0(\"fatal flex scanner internal error--no action found\");\n      case 0xf:\n      case 0x1e:\n        DAT_0010d550 = 0x112;\n      }\n      length = (long)integer3;\n    }\n    if (0 < DAT_0010d550) {\n      if (DAT_0010d550 != 0x100) {\n        integer3 = 2;\n        if (DAT_0010d550 < 0x114) {\n          integer3 = (int)(char)(&DAT_0010a0e0)[DAT_0010d550];\n        }\n        goto LAB_0010497d;\n      }\n      DAT_0010d550 = 0x101;\n      goto LAB_001051f0;\n    }\n    integer3 = 0;\n    DAT_0010d550 = 0;\nLAB_0010497d:\n    unsignedInteger3 = character + integer3;\n    if ((0x22 < unsignedInteger3) || (integer3 != (char)(&DAT_0010a0a0)[(int)unsignedInteger3])) goto LAB_001049db;\n    character = (&DAT_0010a060)[(int)unsignedInteger3];\n    length = (long)character;\n    if (character < '\\x01') {\n      integer3 = -(int)character;\n      goto LAB_00104a0a;\n    }\n    DAT_0010d550 = -2;\n    integer4 = integer4 + -1 + (uint)(integer4 == 0);\n    doubleCharacterPointer2 = doubleCharacterPointer2 + 1;\n    *doubleCharacterPointer2 = DAT_0010d548;\n    goto LAB_001049d1;\n  }\nLAB_001049db:\n  integer3 = (int)(char)(&DAT_0010a020)[(int)length];\n  if ((&DAT_0010a020)[(int)length] == '\\0') {\n    if (integer4 == 0) {\n      _DAT_0010d544 = _DAT_0010d544 + 1;\n      FUN_001031a5();\nLAB_001051f0:\n      do {\n        if (((((char)(&DAT_0010a200)[length] != -0xe) &&\n             (unsignedInteger3 = (int)(char)(&DAT_0010a200)[length] + 1, unsignedInteger3 < 0x23)) &&\n            ((&DAT_0010a0a0)[(int)unsignedInteger3] == '\\x01')) &&\n           (length = (long)(char)(&DAT_0010a060)[(int)unsignedInteger3],\n           '\\0' < (char)(&DAT_0010a060)[(int)unsignedInteger3])) goto LAB_00105227;\n        if (original_string == local_string) goto LAB_0010524c;\n        local_string = local_string + -1;\n        doubleCharacterPointer2 = doubleCharacterPointer2 + -1;\n        length = (long)*local_string;\n      } while( true );\n    }\n    if (integer4 != 3) goto LAB_001051f0;\n    if (0 < DAT_0010d550) {\n      DAT_0010d550 = -2;\n      goto LAB_001051f0;\n    }\n    if (DAT_0010d550 != 0) goto LAB_001051f0;\n    goto LAB_0010524c;\n  }\nLAB_00104a0a:\n  uVar11 = DAT_0010d660;\n  doubleCharacterPointer = DAT_0010d558;\n  character = (&DAT_00109fe0)[integer3];\n  doubleCharacterPointer3 = (char **)doubleCharacterPointer2[1 - character];\n  switch(integer3) {\n  case 2:\n  case 6:\n    FUN_00103ba8();\n    break;\n  case 0x13:\n    if (DAT_0010d558 == (char **)0x0) {\n      return;\n    }\n    bfd_cache_close();\n    unlink(*DAT_0010d558);\n    return;\n  case 0x15:\n    FUN_001031a5();\n    break;\n  case 0x17:\n    unsignedLongPointer = (undefined8 *)*doubleCharacterPointer2;\n    if (DAT_0010d558 == (char **)0x0) {\n      characterPointer = \"%s: no open archive\\n\";\nLAB_00104b62:\n      characterPointer = (char *)dcgettext(0,characterPointer,5);\n      fprintf(_stderr,characterPointer,uVar11);\n      FUN_0010315d();\n    }\n    else {\n      for (; unsignedLongPointer != (undefined8 *)0x0; unsignedLongPointer = (undefined8 *)unsignedLongPointer[1]) {\n        for (unsignedLongPointer2 = (undefined8 *)DAT_0010d558[0x1f]; unsignedLongPointer2 != (undefined8 *)0x0;\n            unsignedLongPointer2 = (undefined8 *)unsignedLongPointer2[0x1e]) {\n          integer = filename_cmp(*unsignedLongPointer2);\n          if (integer == 0) {\n            FUN_00107740();\n            goto LAB_00104adf;\n          }\n        }\n        bfd_openr(*unsignedLongPointer,0);\n        unsignedLong = DAT_0010d660;\n        uVar11 = *unsignedLongPointer;\n        characterPointer = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,characterPointer,unsignedLong,uVar11);\nLAB_00104adf:\n      }\n    }\n    break;\n  case 0x18:\n    unsignedLongPointer = (undefined8 *)*doubleCharacterPointer2;\n    if (DAT_0010d558 == (char **)0x0) {\nLAB_00104b4f:\n      characterPointer = \"%s: no open output archive\\n\";\n      goto LAB_00104b62;\n    }\n    for (; unsignedLongPointer != (undefined8 *)0x0; unsignedLongPointer = (undefined8 *)unsignedLongPointer[1]) {\n      boolean = false;\n      doubleCharacterPointer = DAT_0010d558 + 0x1f;\n      for (characterPointer = DAT_0010d558[0x1f]; characterPointer != (char *)0x0;\n          characterPointer = *(char **)(characterPointer + 0xf0)) {\n        integer = filename_cmp();\n        if (integer == 0) {\n          characterPointer2 = (char *)bfd_openr(*unsignedLongPointer,0);\n          uVar11 = DAT_0010d660;\n          if (characterPointer2 == (char *)0x0) {\n            unsignedLong = *unsignedLongPointer;\n            characterPointer2 = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n            fprintf(_stderr,characterPointer2,uVar11,unsignedLong);\n            FUN_0010315d();\n          }\n          else {\n            *doubleCharacterPointer = characterPointer2;\n            boolean = true;\n            *(undefined8 *)(characterPointer2 + 0xf0) = *(undefined8 *)(characterPointer + 0xf0);\n          }\n        }\n        else {\n          doubleCharacterPointer = (char **)(characterPointer + 0xf0);\n        }\n      }\n      if (!boolean) {\n        characterPointer = (char *)bfd_openr(*unsignedLongPointer,0);\n        unsignedLong = DAT_0010d660;\n        uVar11 = *unsignedLongPointer;\n        characterPointer2 = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,characterPointer2,unsignedLong,uVar11);\n        uVar11 = DAT_0010d660;\n        if (characterPointer == (char *)0x0) {\n          unsignedLong = *unsignedLongPointer;\n          characterPointer = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n          fprintf(_stderr,characterPointer,uVar11,unsignedLong);\n          FUN_0010315d();\n        }\n        else {\n          *doubleCharacterPointer = characterPointer;\n        }\n      }\n    }\n    break;\n  case 0x19:\n    if (DAT_0010d558 != (char **)0x0) {\n      DAT_0010d558[0x1f] = (char *)0x0;\n    }\n    break;\n  case 0x1a:\n    unsignedLongPointer = (undefined8 *)*doubleCharacterPointer2;\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    for (; unsignedLongPointer != (undefined8 *)0x0; unsignedLongPointer = (undefined8 *)unsignedLongPointer[1]) {\n      boolean = false;\n      doubleCharacterPointer = DAT_0010d558 + 0x1f;\n      for (unsignedLongPointer2 = (undefined8 *)DAT_0010d558[0x1f]; uVar11 = DAT_0010d660,\n          unsignedLongPointer2 != (undefined8 *)0x0; unsignedLongPointer2 = (undefined8 *)unsignedLongPointer2[0x1e]) {\n        integer = filename_cmp(*unsignedLongPointer2,*unsignedLongPointer);\n        if (integer == 0) {\n          boolean = true;\n          *doubleCharacterPointer = (char *)unsignedLongPointer2[0x1e];\n        }\n        else {\n          doubleCharacterPointer = (char **)(unsignedLongPointer2 + 0x1e);\n        }\n      }\n      if (!boolean) {\n        unsignedLong = *unsignedLongPointer;\n        characterPointer = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,characterPointer,uVar11,unsignedLong);\n        FUN_0010315d();\n      }\n    }\n    break;\n  case 0x1b:\n    unsignedLongPointer = (undefined8 *)*doubleCharacterPointer2;\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    for (; unsignedLongPointer != (undefined8 *)0x0; unsignedLongPointer = (undefined8 *)unsignedLongPointer[1]) {\n      characterPointer = (char *)bfd_openr(*unsignedLongPointer,\"plugin\");\n      uVar11 = DAT_0010d660;\n      doubleCharacterPointer = DAT_0010d558;\n      if (characterPointer == (char *)0x0) {\n        unsignedLong = *unsignedLongPointer;\n        characterPointer = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n        fprintf(_stderr,characterPointer,uVar11,unsignedLong);\n        FUN_0010315d();\n      }\n      else {\n        *(char **)(characterPointer + 0xf0) = DAT_0010d558[0x1f];\n        doubleCharacterPointer[0x1f] = characterPointer;\n      }\n    }\n    break;\n  case 0x1c:\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    characterPointer = *DAT_0010d558;\n    DAT_0010d60c = 1;\n    DAT_0010d578 = _stdout;\n    characterPointer2 = (char *)dcgettext(0,\"Current open archive is %s\\n\",5);\n    printf(characterPointer2,characterPointer);\n    for (characterPointer = DAT_0010d558[0x1f]; characterPointer != (char *)0x0; characterPointer = *(char **)(characterPointer + 0xf0))\n    {\n      FUN_00103ddc(characterPointer,0);\n    }\n    break;\n  case 0x1d:\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    if (0 < _DAT_0010d2d0) {\n      *(uint *)((long)DAT_0010d558 + 0x44) = *(uint *)((long)DAT_0010d558 + 0x44) | 0x2000;\n    }\n    DAT_0010d568 = dup(DAT_0010d568);\n    bfd_close(doubleCharacterPointer);\n    characterPointer = DAT_0010d570;\n    integer = stat(DAT_0010d570,&stat_structure);\n    if ((integer != 0) && (DAT_0010d558 = (char **)bfd_openw(characterPointer,0), DAT_0010d558 != (char **)0x0)\n       ) {\n      bfd_set_format(DAT_0010d558,2);\n      bfd_close(DAT_0010d558);\n    }\n    FUN_00105bc0(DAT_0010d560,DAT_0010d570,DAT_0010d568);\n    DAT_0010d558 = (char **)0x0;\n    free(DAT_0010d560);\n    free(DAT_0010d570);\n    break;\n  case 0x1e:\n    FUN_00103c60(*doubleCharacterPointer2,0);\n    break;\n  case 0x1f:\n    FUN_00103c60(*doubleCharacterPointer2,1);\n    break;\n  case 0x20:\n    characterPointer = *doubleCharacterPointer2;\n    if (DAT_0010d558 == (char **)0x0) {\n      characterPointer = \"%s: no output archive specified yet\\n\";\n      goto LAB_00104b62;\n    }\n    length = FUN_00105300(doubleCharacterPointer2[-1],0);\n    if (length != 0) {\n      FUN_001032a8(length,FUN_0010312d,characterPointer);\n    }\n    break;\n  case 0x21:\n    characterPointer = *doubleCharacterPointer2;\n    characterPointer2 = doubleCharacterPointer2[-1];\n    uVar11 = FUN_00105300(doubleCharacterPointer2[-2],0);\n    if (characterPointer == (char *)0x0) {\n      DAT_0010d578 = _stdout;\n    }\n    else {\n      DAT_0010d578 = fopen(characterPointer,\"w\");\n      if (DAT_0010d578 != (FILE *)0x0) {\n        FUN_001032a8(uVar11,FUN_00103ddc,characterPointer2);\n        bfd_close(uVar11);\n        fclose(DAT_0010d578);\n        break;\n      }\n      DAT_0010d578 = _stdout;\n      characterPointer3 = (char *)dcgettext(0,\"Can\\'t open file %s\\n\",5);\n      fprintf(_stderr,characterPointer3,characterPointer);\n    }\n    FUN_001032a8(uVar11,FUN_00103ddc,characterPointer2);\n    bfd_close(uVar11);\n    break;\n  case 0x22:\n    doubleCharacterPointer3 = (char **)*doubleCharacterPointer2;\n    break;\n  case 0x23:\n  case 0x25:\n  case 0x27:\n    doubleCharacterPointer3 = (char **)0x0;\n    break;\n  case 0x24:\n    doubleCharacterPointer3 = (char **)doubleCharacterPointer2[-1];\n    break;\n  case 0x26:\n    doubleCharacterPointer3 = (char **)malloc(0x10);\n    characterPointer = doubleCharacterPointer2[-2];\n    *doubleCharacterPointer3 = *doubleCharacterPointer2;\n    doubleCharacterPointer3[1] = characterPointer;\n    break;\n  case 0x2a:\n    DAT_0010d60c = (uint)(DAT_0010d60c == 0);\n  }\n  length = (long)character;\n  local_string = local_string + -length;\n  doubleCharacterPointer2[1 - length] = (char *)doubleCharacterPointer3;\n  doubleCharacterPointer2 = doubleCharacterPointer2 + (1 - length);\n  unsignedInteger3 = (int)(char)(&DAT_00109f80)[(char)(&DAT_00109fa0)[integer3] + -0x18] + (int)*local_string;\n  if ((unsignedInteger3 < 0x23) && (*local_string == (&DAT_0010a0a0)[(int)unsignedInteger3])) {\n    length = (long)(char)(&DAT_0010a060)[(int)unsignedInteger3];\n  }\n  else {\n    length = (long)(char)(&DAT_00109f60)[(char)(&DAT_00109fa0)[integer3] + -0x18];\n  }\n  goto LAB_001049d1;\nswitchD_00104200_caseD_29:\n  integer = ((int)bytePointer4 - (int)DAT_0010d5c8) + -1;\n  *bytePointer4 = DAT_0010d588;\n  doublePointer = (long **)(DAT_0010d5a8 + length * 8);\n  doublePointerToFile = (FILE **)*doublePointer;\n  if (*(int *)(doublePointerToFile + 7) == 0) {\n    DAT_0010d598 = *(uint *)((long)doublePointerToFile + 0x1c);\n    *(undefined4 *)(doublePointerToFile + 7) = 1;\n    *doublePointerToFile = DAT_0010d590;\n  }\n  bytePointer = DAT_0010d5b0;\n  filePointer = doublePointerToFile[1];\n  anonymousVariable_40._8_8_ = filePointer;\n  anonymousVariable_40._0_8_ = doublePointerToFile;\n  if ((byte *)((long)&filePointer->_flags + (long)(int)DAT_0010d598) < DAT_0010d5b0) {\n    if ((byte *)((long)&filePointer->_flags + (long)(int)DAT_0010d598 + 1) < DAT_0010d5b0) {\n      anonymousVariable_40 = FUN_001033b0();\n    }\n    if (*(int *)(anonymousVariable_40._0_8_ + 0x34) != 0) {\n      unsignedInteger3 = (int)((long)bytePointer - (long)bytePointer2) - 1;\n      for (length = 0; (int)length < (int)unsignedInteger3; length = length + 1) {\n        *(byte *)(anonymousVariable_40._8_8_ + length) = bytePointer2[length];\n      }\n      plVar12 = *doublePointer;\n      if (*(int *)(plVar12 + 7) == 2) {\n        DAT_0010d598 = 0;\n        *(undefined4 *)((long)plVar12 + 0x1c) = 0;\nLAB_0010475e:\n        filePointer = DAT_0010d590;\n        if (unsignedInteger3 == 0) {\n          if ((DAT_0010d5a8 == 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) == 0)) {\n            FUN_00103df9();\n            unsignedLongPointer = (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n            uVar11 = FUN_001033d6(filePointer);\n            *unsignedLongPointer = uVar11;\n          }\n          length = DAT_0010d5a8;\n          if (DAT_0010d5a8 != 0) {\n            length = *(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          }\n          iVar9 = 1;\n          FUN_001031cf(length);\n          FUN_001030ed();\n        }\n        else {\n          iVar9 = 2;\n          *(undefined4 *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x38) = 2;\n        }\n      }\n      else {\n        while( true ) {\n          longPointer = *doublePointer;\n          unsignedInteger = ~unsignedInteger3 + *(int *)(plVar12 + 3);\n          if (0 < (int)unsignedInteger) break;\n          unsignedInteger = (int)DAT_0010d5b0 - (int)(void *)longPointer[1];\n          if (*(int *)(longPointer + 4) == 0) {\n            longPointer[1] = 0;\nLAB_00104626:\n            FUN_001033b0();\n            break;\n          }\n          iVar9 = *(int *)(longPointer + 3);\n          integer2 = iVar9;\n          if (iVar9 < 1) {\n            integer2 = iVar9 / 8;\n          }\n          *(int *)(longPointer + 3) = integer2 + iVar9;\n          pvVar14 = realloc((void *)longPointer[1],(long)(integer2 + iVar9 + 2));\n          longPointer[1] = (long)pvVar14;\n          if (pvVar14 == (void *)0x0) goto LAB_00104626;\n          DAT_0010d5b0 = (byte *)((long)pvVar14 + (long)(int)unsignedInteger);\n          plVar12 = *doublePointer;\n        }\n        if (0x2000 < (int)unsignedInteger) {\n          unsignedInteger = 0x2000;\n        }\n        unsignedLong2 = (ulong)unsignedInteger;\n        if (*(int *)((long)longPointer + 0x24) == 0) {\n          integerPointer = __errno_location();\n          unsignedLong2 = (ulong)(int)unsignedInteger;\n          unsignedLong = (ulong)(int)unsignedInteger3;\n          *integerPointer = 0;\n          goto LAB_001046c7;\n        }\n        unsignedLong = 0;\n        integerPointer = (int *)(long)(int)unsignedInteger3;\n        do {\n          iVar9 = getc(DAT_0010d590);\n          unsignedInteger2 = (uint)unsignedLong;\n          if (iVar9 == -1) {\n            iVar9 = ferror(DAT_0010d590);\n            unsignedInteger = unsignedInteger2;\n            if (iVar9 != 0) {\n              do {\n                characterPointer = \"input in flex scanner failed\";\n                FUN_001033b0();\n                do {\n                  *integerPointer = 0;\n                  clearerr((FILE *)characterPointer);\nLAB_001046c7:\n                  sVar13 = fread((void *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)\n                                         + unsignedLong),1,unsignedLong2,DAT_0010d590);\n                  characterPointer = (char *)DAT_0010d590;\n                  DAT_0010d598 = (uint)sVar13;\n                  unsignedInteger = DAT_0010d598;\n                  if ((DAT_0010d598 != 0) ||\n                     (iVar9 = ferror(DAT_0010d590), unsignedInteger = DAT_0010d598, iVar9 == 0))\n                  goto LAB_00104738;\n                } while (*integerPointer == 4);\n              } while( true );\n            }\n            break;\n          }\n          if (iVar9 == 10) {\n            *(undefined *)\n             ((long)(int *)(long)(int)unsignedInteger3 +\n             (long)(int)unsignedInteger2 + *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)) = 10;\n            unsignedInteger = unsignedInteger2 + 1;\n            break;\n          }\n          unsignedLong = (ulong)(unsignedInteger2 + 1);\n          *(char *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8) + (long)integerPointer) =\n               (char)iVar9;\n          integerPointer = (int *)((long)integerPointer + 1);\n        } while (unsignedInteger != unsignedInteger2 + 1);\nLAB_00104738:\n        DAT_0010d598 = unsignedInteger;\n        unsignedInteger = DAT_0010d598;\n        iVar9 = 0;\n        *(uint *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x1c) = DAT_0010d598;\n        if (unsignedInteger == 0) goto LAB_0010475e;\n      }\n      plVar12 = (long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n      length = *plVar12;\n      unsignedInteger3 = unsignedInteger3 + DAT_0010d598;\n      if (*(int *)(length + 0x18) < (int)unsignedInteger3) {\n        integer2 = ((int)DAT_0010d598 >> 1) + unsignedInteger3;\n        pvVar14 = realloc(*(void **)(length + 8),(long)integer2);\n        *(void **)(length + 8) = pvVar14;\n        anonymousVariable_41._8_8_ = plVar12;\n        anonymousVariable_41._0_8_ = *plVar12;\n        if (*(long *)(*plVar12 + 8) == 0) {\n          anonymousVariable_41 = FUN_001033b0();\n        }\n        plVar12 = anonymousVariable_41._8_8_;\n        *(int *)(anonymousVariable_41._0_8_ + 0x18) = integer2 + -2;\n      }\n      DAT_0010d598 = unsignedInteger3;\n      *(undefined *)(*(long *)(*plVar12 + 8) + (long)(int)unsignedInteger3) = 0;\n      *(undefined *)(*(long *)(*plVar12 + 8) + 1 + (long)(int)unsignedInteger3) = 0;\n      bytePointer2 = *(byte **)(*plVar12 + 8);\n      DAT_0010d5c8 = bytePointer2;\n      if (iVar9 == 1) goto LAB_001048a4;\n      if (iVar9 == 2) goto LAB_001048ca;\n      bytePointer4 = bytePointer2 + integer;\n      DAT_0010d5b0 = bytePointer4;\n      unsignedInteger3 = FUN_0010300e();\n      goto LAB_001040d4;\n    }\n    if ((long)bytePointer - (long)bytePointer2 == 1) goto LAB_001048a4;\nLAB_001048ca:\n    bytePointer4 = (byte *)((long)(int)DAT_0010d598 +\n                      *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8));\n    DAT_0010d5b0 = bytePointer4;\n    unsignedLong = FUN_0010300e();\n    bytePointer3 = DAT_0010d5c8;\n    goto LAB_0010419f;\n  }\n  bytePointer4 = bytePointer2 + integer;\n  DAT_0010d5b0 = bytePointer4;\n  unsignedLong = FUN_0010300e();\n  if (*(short *)(&DAT_0010a980 + (long)(int)(uint)unsignedLong * 2) != 0) {\n    DAT_0010d5b8 = bytePointer4;\n    DAT_0010d5c0 = (uint)unsignedLong;\n  }\n  unsignedLong2 = unsignedLong & 0xffffffff;\n  while( true ) {\n    integer = (int)unsignedLong2;\n    if (integer == *(short *)(&DAT_0010a440 +\n                           (long)(*(short *)(&DAT_0010a640 + (long)integer * 2) + 1) * 2)) break;\n    unsignedLong2 = (ulong)(uint)(int)*(short *)(&DAT_0010a800 + (long)integer * 2);\n  }\n  unsignedInteger3 = (uint)*(short *)(&DAT_0010a240 +\n                           (long)(*(short *)(&DAT_0010a640 + (long)integer * 2) + 1) * 2);\n  bytePointer3 = bytePointer2;\n  if ((*(short *)(&DAT_0010a240 + (long)(*(short *)(&DAT_0010a640 + (long)integer * 2) + 1) * 2) == 0)\n     || (unsignedInteger3 == 0xb0)) goto LAB_0010419f;\n  bytePointer4 = bytePointer4 + 1;\n  goto LAB_001040d4;\nLAB_001048a4:\n  DAT_0010d5b0 = DAT_0010d5c8;\n  integer = (int)(DAT_0010d5d0 - 1) / 2 + 0x2a;\n  goto LAB_001041f0;\nswitchD_00104200_caseD_0:\n  *bytePointer4 = DAT_0010d588;\n  unsignedLong = (ulong)DAT_0010d5c0;\n  bytePointer4 = DAT_0010d5b8;\n  goto LAB_0010419f;\nLAB_00105227:\n  doubleCharacterPointer2 = doubleCharacterPointer2 + 1;\n  integer4 = 3;\n  *doubleCharacterPointer2 = DAT_0010d548;\nLAB_001049d1:\n  local_string = local_string + 1;\n  goto LAB_00103ee9;\n}\n\n",
            "called": [
                "realloc",
                "FUN_0010312d",
                "bfd_openw",
                "FUN_001031cf",
                "dup",
                "fprintf",
                "stat",
                "FUN_001033d6",
                "FUN_00107740",
                "filename_cmp",
                "FUN_001031a5",
                "FUN_00103ba8",
                "FUN_0010300e",
                "clearerr",
                "printf",
                "fclose",
                "FUN_00105300",
                "bfd_set_format",
                "bfd_close",
                "getc",
                "fwrite",
                "__errno_location",
                "fread",
                "bfd_openr",
                "ferror",
                "dcgettext",
                "FUN_001033b0",
                "fopen",
                "FUN_00103df9",
                "FUN_001030ed",
                "bfd_cache_close",
                "FUN_0010315d",
                "FUN_00105bc0",
                "FUN_00103c60",
                "free",
                "FUN_00103ddc",
                "xstrdup",
                "malloc",
                "FUN_001032a8",
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103e95",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "decompress_and_print_file_00103e95"
        },
        "bfd_init": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_init"
        },
        "strerror": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102550",
            "calling": [
                "FUN_00103c60",
                "FUN_001025a0",
                "FUN_00102fd7",
                "FUN_00102c25",
                "FUN_00103a78",
                "FUN_00102f1e"
            ],
            "imported": false,
            "current_name": "strerror"
        },
        "FUN_00107cc0": {
            "renaming": {
                "FUN_00107cc0": "execute_reverse_order_functions_00107cc0",
                "lVar1": "index",
                "lVar2": "prevIndex",
                "lVar3": "tempIndex",
                "plVar4": "functionPointerArray",
                "uVar5": "functionCount"
            },
            "code": "\nvoid executeReverseOrderFunctions_00107cc0(void)\n\n{\n  long index;\n  long prevIndex;\n  long tempIndex;\n  long *functionPointerArray;\n  uint functionCount;\n  \n  functionPointerArray = (long *)PTR_DAT_0010d2e0;\n  if (PTR_DAT_0010d2e0 != (undefined *)0x0) {\n    do {\n      functionCount = *(int *)(functionPointerArray + 1) - 1;\n      if (-1 < (int)functionCount) {\n        index = (long)(int)functionCount;\n        functionCount = functionCount & 7;\n        (*(code *)functionPointerArray[index + 2])();\n        prevIndex = index + -1;\n        if (-1 < (int)prevIndex) {\n          tempIndex = prevIndex;\n          if (functionCount != 0) {\n            if (functionCount != 1) {\n              if (functionCount != 2) {\n                if (functionCount != 3) {\n                  if (functionCount != 4) {\n                    if (functionCount != 5) {\n                      if (functionCount != 6) {\n                        (*(code *)functionPointerArray[index + 1])();\n                        prevIndex = index + -2;\n                      }\n                      (*(code *)functionPointerArray[prevIndex + 2])();\n                      prevIndex = prevIndex + -1;\n                    }\n                    (*(code *)functionPointerArray[prevIndex + 2])();\n                    prevIndex = prevIndex + -1;\n                  }\n                  (*(code *)functionPointerArray[prevIndex + 2])();\n                  prevIndex = prevIndex + -1;\n                }\n                (*(code *)functionPointerArray[prevIndex + 2])();\n                prevIndex = prevIndex + -1;\n              }\n              (*(code *)functionPointerArray[prevIndex + 2])();\n              prevIndex = prevIndex + -1;\n            }\n            (*(code *)functionPointerArray[prevIndex + 2])();\n            tempIndex = prevIndex + -1;\n            if ((int)(prevIndex + -1) < 0) goto LAB_00107d96;\n          }\n          do {\n            (*(code *)functionPointerArray[tempIndex + 2])();\n            index = tempIndex + -1;\n            (*(code *)functionPointerArray[tempIndex + 1])();\n            (*(code *)functionPointerArray[tempIndex])();\n            (*(code *)functionPointerArray[index])();\n            (*(code *)functionPointerArray[tempIndex + -2])();\n            (*(code *)functionPointerArray[tempIndex + -3])();\n            (*(code *)functionPointerArray[tempIndex + -4])();\n            (*(code *)functionPointerArray[tempIndex + -5])();\n            tempIndex = tempIndex + -8;\n          } while (-1 < (int)index + -7);\n        }\n      }\nLAB_00107d96:\n      functionPointerArray = (long *)*functionPointerArray;\n    } while (functionPointerArray != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107cc0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "execute_reverse_order_functions_00107cc0"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "FUN_00105ae0": {
            "renaming": {
                "FUN_00105ae0": "execute_function_00105ae0",
                "param_1": "argument1",
                "param_2": "argument2",
                "param_3": "parameter3",
                "param_4": "parameter4"
            },
            "code": "\nvoid executeFunction_00105ae0(undefined8 argument1,undefined8 argument2,undefined parameter3,undefined parameter4)\n\n{\n  FUN_00105af0(argument1,argument2,parameter3,parameter4);\n  return;\n}\n\n",
            "called": [
                "FUN_00105af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105ae0",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "execute_function_00105ae0"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_00105db0,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "__libc_start_main",
                "FUN_00105db0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105cc0",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "FUN_00107690": {
            "renaming": {
                "FUN_00107690": "process_data_00107690",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "param_6": "input6",
                "param_7": "input7",
                "param_8": "input8",
                "param_9": "param1",
                "param_10": "param2",
                "param_11": "param3",
                "param_12": "param4",
                "param_13": "param5",
                "param_14": "param6",
                "in_AL": "condition",
                "local_d8": "length",
                "local_d4": "offset",
                "local_d0": "buffer",
                "local_c8": "localBuffer",
                "local_b8": "temporaryBuffer",
                "local_b0": "value1",
                "local_a8": "value2",
                "local_a0": "value3",
                "local_98": "value4",
                "local_90": "value5",
                "local_88": "local1",
                "local_78": "local2",
                "local_68": "local3",
                "local_58": "local4",
                "local_48": "local5",
                "local_38": "local6",
                "local_28": "local7",
                "local_18": "local8"
            },
            "code": "\nvoid processData_00107690(undefined4 input1,undefined4 input2,undefined4 input3,undefined4 input4,\n                 undefined4 input5,undefined4 input6,undefined4 input7,undefined4 input8,\n                 undefined8 param1,undefined8 param2,undefined8 param3,undefined8 param4,\n                 undefined8 param5,undefined8 param6)\n\n{\n  char condition;\n  undefined4 length;\n  undefined4 offset;\n  undefined *buffer;\n  undefined *localBuffer;\n  undefined temporaryBuffer [8];\n  undefined8 value1;\n  undefined8 value2;\n  undefined8 value3;\n  undefined8 value4;\n  undefined8 value5;\n  undefined4 local1;\n  undefined4 local2;\n  undefined4 local3;\n  undefined4 local4;\n  undefined4 local5;\n  undefined4 local6;\n  undefined4 local7;\n  undefined4 local8;\n  \n  if (condition != '\\0') {\n    local1 = input1;\n    local2 = input2;\n    local3 = input3;\n    local4 = input4;\n    local5 = input5;\n    local6 = input6;\n    local7 = input7;\n    local8 = input8;\n  }\n  buffer = &stack0x00000008;\n  length = 8;\n  localBuffer = temporaryBuffer;\n  offset = 0x30;\n  value1 = param2;\n  value2 = param3;\n  value3 = param4;\n  value4 = param5;\n  value5 = param6;\n  FUN_001078c0(param1,&length);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_001078c0",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107690",
            "calling": [
                "FUN_00105300",
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "process_data_00107690"
        },
        "bfd_seek": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102580",
            "calling": [
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "bfd_seek"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "FUN_0010266f": {
            "renaming": {
                "FUN_0010266f": "print_supported_targets_0010266f",
                "param_1": "targetName",
                "param_2": "outputFile",
                "lVar1": "target",
                "pcVar2": "targetString",
                "__ptr": "targetList",
                "plVar3": "ptrTarget",
                "fprintf": "printFormatted",
                "fputc": "printCharacter",
                "dcgettext": "getTranslatedText",
                "bfd_target_list": "getTargetList",
                "free": "releaseMemory"
            },
            "code": "\nvoid printSupportedTargets_0010266f(long targetName,FILE *outputFile)\n\n{\n  long target;\n  char *targetString;\n  long *targetList;\n  long *ptrTarget;\n  \n  if (targetName == 0) {\n    targetString = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,targetString);\n  }\n  else {\n    targetString = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,targetString,targetName);\n  }\n  targetList = (long *)bfd_target_list();\n  ptrTarget = targetList;\n  while( true ) {\n    target = *ptrTarget;\n    ptrTarget = ptrTarget + 1;\n    if (target == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "free",
                "bfd_target_list",
                "dcgettext",
                "fprintf",
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010266f",
            "calling": [
                "FUN_0010342d",
                "FUN_0010394a"
            ],
            "imported": false,
            "current_name": "print_supported_targets_0010266f"
        },
        "FUN_00105830": {
            "renaming": {
                "FUN_00105830": "extract_filename_00105830",
                "param_1": "output",
                "param_2": "structPtr",
                "param_3": "unused1",
                "param_4": "unused2",
                "lVar1": "structAddress",
                "sVar2": "filenameLength",
                "__s": "input",
                "uVar3": "extractLength",
                "pcVar4": "outputPtr",
                "bVar5": "increment",
                "auVar6": "result"
            },
            "code": "\nundefined  [16] extractFilename_00105830(char *output,long structPtr,undefined8 unused1,undefined8 unused2)\n\n{\n  long structAddress;\n  size_t filenameLength;\n  char *input;\n  ulong extractLength;\n  char *outputPtr;\n  byte increment;\n  undefined result [16];\n  \n  increment = 0;\n  if (DAT_0010d5f9 == '\\0') {\n    input = (char *)lbasename();\n    output = input;\n    if ((DAT_0010d5fa != '\\0') && (structPtr != 0)) {\n      filenameLength = strlen(input);\n      extractLength = (ulong)*(byte *)(*(long *)(structPtr + 8) + 0x1e);\n      if (extractLength < filenameLength) {\n        output = (char *)xmalloc(extractLength + 1);\n        structAddress = *(long *)(structPtr + 8);\n        outputPtr = output;\n        for (extractLength = (ulong)*(byte *)(structAddress + 0x1e); extractLength != 0; extractLength = extractLength - 1) {\n          *outputPtr = *input;\n          input = input + (ulong)increment * -2 + 1;\n          outputPtr = outputPtr + (ulong)increment * -2 + 1;\n        }\n        output[*(byte *)(structAddress + 0x1e)] = '\\0';\n      }\n    }\n  }\n  result._8_8_ = unused2;\n  result._0_8_ = output;\n  return result;\n}\n\n",
            "called": [
                "lbasename",
                "FUN_00102bb0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105830",
            "calling": [
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00105480"
            ],
            "imported": false,
            "current_name": "extract_filename_00105830"
        },
        "bfd_find_target": {
            "renaming": {},
            "code": "\nvoid bfd_find_target(void)\n\n{\n  bfd_find_target();\n  return;\n}\n\n",
            "called": [
                "bfd_find_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_find_target"
        },
        "bfd_check_format_matches": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024c0",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_check_format_matches"
        },
        "FUN_00107730": {
            "renaming": {
                "FUN_00107730": "cleanup_and_close_file_00107730"
            },
            "code": "\nvoid cleanupAndCloseFile_00107730(void)\n\n{\n  if (DAT_0010d618 == 0) {\n    return;\n  }\n  if (DAT_0010d5e0 != 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 != (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
            "called": [
                "FUN_00102bf5"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107730",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "cleanup_and_close_file_00107730"
        },
        "mkstemp": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "mkstemp"
        },
        "FUN_00107c20": {
            "renaming": {
                "FUN_00107c20": "print_error_00107c20",
                "param_1": "errorMessage",
                "iVar1": "errorType",
                "uVar2": "errorMsg",
                "in_R10": "placeholder",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printError_00107c20(long errorMessage)\n\n{\n  int errorType;\n  undefined8 errorMsg;\n  undefined8 placeholder;\n  \n  errorType = bfd_get_error();\n  if (errorType == 0) {\n    errorMsg = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMsg = bfd_errmsg(errorType);\n  }\n  fflush(standardOutput);\n  if (errorMessage != 0) {\n    fprintf(standardError,\"%s: %s: %s\\n\",DAT_0010d660,errorMessage,errorMsg,placeholder);\n    return;\n  }\n  fprintf(standardError,\"%s: %s\\n\",DAT_0010d660,errorMsg,placeholder);\n  return;\n}\n\n",
            "called": [
                "bfd_get_error",
                "bfd_errmsg",
                "FUN_00102f96"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c20",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_00107c10"
            ],
            "imported": false,
            "current_name": "print_error_00107c20"
        },
        "lseek": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "lseek"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "FUN_001031cf": {
            "renaming": {
                "FUN_001031cf": "initialize_file_001031cf",
                "param_1": "outputFile",
                "param_2": "inputFile",
                "iVar1": "errnoValue",
                "uVar2": "isInputTTY",
                "iVar3": "isInputTTYValue",
                "piVar4": "errnoLocation",
                "lVar5": "fileStructureAddress",
                "LAB_00103263": "checkInputFilePointer",
                "param_1[2]": "param1Plus2",
                "fileno(param_2)": "getFileDescriptor",
                "isatty(iVar3)": "checkIfTTY"
            },
            "code": "\n\n\nundefined8\ninitializeFile_001031cf(FILE **outputFile,FILE *inputFile,undefined8 param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  int errnoValue;\n  uint isInputTTY;\n  int isInputTTYValue;\n  int *errnoLocation;\n  long fileStructureAddress;\n  \n  errnoLocation = __errno_location();\n  fileStructureAddress = DAT_0010d5a8;\n  errnoValue = *errnoLocation;\n  if (outputFile == (FILE **)0x0) {\n    _DAT_00000034 = 1;\n    _DAT_00000000 = inputFile;\n    if (DAT_0010d5a8 != 0) {\ncheckInputFilePointer:\n      if (outputFile == *(FILE ***)(fileStructureAddress + DAT_0010d5a0 * 8)) goto LAB_0010327b;\n    }\n  }\n  else {\n    *(undefined4 *)((long)outputFile + 0x1c) = 0;\n    *(undefined *)&outputFile[1]->_flags = 0;\n    *(undefined *)((long)&outputFile[1]->_flags + 1) = 0;\n    *(undefined4 *)(outputFile + 5) = 1;\n    param1Plus2 = outputFile[1];\n    *(undefined4 *)(outputFile + 7) = 0;\n    if (fileStructureAddress != 0) {\n      if (outputFile == *(FILE ***)(fileStructureAddress + DAT_0010d5a0 * 8)) {\n        FUN_001030ed();\n      }\n      *outputFile = inputFile;\n      *(undefined4 *)((long)outputFile + 0x34) = 1;\n      goto checkInputFilePointer;\n    }\n    *outputFile = inputFile;\n    *(undefined4 *)((long)outputFile + 0x34) = 1;\n  }\n  *(undefined8 *)((long)outputFile + 0x2c) = 1;\nLAB_0010327b:\n  isInputTTY = 0;\n  if (inputFile != (FILE *)0x0) {\n    isInputTTYValue = getFileDescriptor;\n    isInputTTYValue = checkIfTTY;\n    isInputTTY = (uint)(0 < isInputTTYValue);\n  }\n  *(uint *)((long)outputFile + 0x24) = isInputTTY;\n  *errnoLocation = errnoValue;\n  return param_5;\n}\n\n",
            "called": [
                "isatty",
                "__errno_location",
                "fileno",
                "FUN_001030ed"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031cf",
            "calling": [
                "FUN_001033d6",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "initialize_file_001031cf"
        },
        "FUN_0010312d": {
            "renaming": {
                "FUN_0010312d": "copy_and_swap_pointers_0010312d",
                "param_1": "sourcePointer",
                "param_2": "destinationPointer",
                "lVar1": "tempPointer"
            },
            "code": "\nvoid copyAndSwapPointers_0010312d(long sourcePointer,long destinationPointer)\n\n{\n  long tempPointer;\n  \n  if (destinationPointer != 0) {\n    *(undefined8 *)(destinationPointer + 0xf0) = *(undefined8 *)(sourcePointer + 0xf0);\n  }\n  tempPointer = DAT_0010d558;\n  *(undefined8 *)(sourcePointer + 0xf0) = *(undefined8 *)(DAT_0010d558 + 0xf8);\n  *(long *)(tempPointer + 0xf8) = sourcePointer;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010312d",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "copy_and_swap_pointers_0010312d"
        },
        "FUN_00105c00": {
            "renaming": {
                "FUN_00105c00": "copy_file_00105c00",
                "param_1": "sourceFileDescriptor",
                "param_2": "destinationFilePath",
                "iVar1": "originalErrno",
                "__fd": "destinationFileDescriptor",
                "iVar2": "readResult",
                "_Var3": "sourceFileOffset",
                "uVar4": "bytesCopied",
                "sVar5": "writeResult",
                "piVar6": "errnoPointer",
                "auStack_2038": "buffer"
            },
            "code": "\nulong copyFile_00105c00(int sourceFileDescriptor,char *destinationFilePath)\n\n{\n  int originalErrno;\n  int destinationFileDescriptor;\n  int readResult;\n  __off_t sourceFileOffset;\n  ulong bytesCopied;\n  size_t writeResult;\n  int *errnoPointer;\n  undefined buffer [8200];\n  \n  if ((-1 < sourceFileDescriptor) && (sourceFileOffset = lseek(sourceFileDescriptor,0,0), sourceFileOffset == 0)) {\n    destinationFileDescriptor = open(destinationFilePath,0x201);\n    if (destinationFileDescriptor < 0) {\n      bytesCopied = FUN_00102f55();\n      return bytesCopied;\n    }\n    do {\n      bytesCopied = read(sourceFileDescriptor,buffer,0x2000);\n      readResult = (int)bytesCopied;\n      if (readResult < 1) {\n        errnoPointer = __errno_location();\n        originalErrno = *errnoPointer;\n        close(sourceFileDescriptor);\n        close(destinationFileDescriptor);\n        if (readResult != 0) {\n          *errnoPointer = originalErrno;\n          return 0xffffffff;\n        }\n        return bytesCopied & 0xffffffff;\n      }\n      writeResult = write(destinationFileDescriptor,buffer,(long)readResult);\n    } while (writeResult == (long)readResult);\n    errnoPointer = __errno_location();\n    readResult = *errnoPointer;\n    close(sourceFileDescriptor);\n    close(destinationFileDescriptor);\n    *errnoPointer = readResult;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "write",
                "close",
                "open",
                "FUN_00102f55",
                "__errno_location",
                "lseek",
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105c00",
            "calling": [
                "FUN_00105bc0"
            ],
            "imported": false,
            "current_name": "copy_file_00105c00"
        },
        "calloc": {
            "renaming": {},
            "code": "\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(__nmemb,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "FUN_00103df9"
            ],
            "imported": false,
            "current_name": "calloc"
        },
        "FUN_00105d20": {
            "renaming": {
                "FUN_00105d20": "FUNC_00105d20"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d44) */\n/* WARNING: Removing unreachable block (ram,0x00105d50) */\n\nvoid FUNC_00105d20(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105d20",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105d20"
        },
        "FUN_001052a0": {
            "renaming": {
                "FUN_001052a0": "file_information_001052a0",
                "param_1": "filePath",
                "iVar1": "result",
                "piVar2": "errnoPtr",
                "uVar3": "errorMessage",
                "pcVar4": "errorString",
                "sStack_a8": "fileStats"
            },
            "code": "\nlong fileInformation_001052a0(char *filePath)\n\n{\n  int result;\n  int *errnoPtr;\n  undefined8 errorMessage;\n  char *errorString;\n  stat fileStats;\n  \n  if (filePath != (char *)0x0) {\n    result = stat(filePath,&fileStats);\n    if (result < 0) {\n      errnoPtr = __errno_location();\n      if (*errnoPtr == 2) {\n        errorMessage = dcgettext(0,\"\\'%s\\': No such file\",5);\n        FUN_00107920(errorMessage,filePath);\n      }\n      else {\n        errorString = strerror(*errnoPtr);\n        errorMessage = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        FUN_00107920(errorMessage,filePath,errorString);\n      }\n    }\n    else if ((fileStats.st_mode & 0xf000) == 0x4000) {\n      errorMessage = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      FUN_00107920(errorMessage,filePath);\n    }\n    else if ((fileStats.st_mode & 0xf000) == 0x8000) {\n      if (-1 < fileStats.st_size) {\n        return fileStats.st_size;\n      }\n      errorMessage = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      FUN_00107920(errorMessage,filePath);\n    }\n    else {\n      errorMessage = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      FUN_00107920(errorMessage,filePath);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "FUN_001025a0",
                "FUN_00107920",
                "dcgettext",
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a0",
            "calling": [
                "FUN_00107650",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "file_information_001052a0"
        },
        "FUN_0010336b": {
            "renaming": {
                "FUN_0010336b": "print_emulation_options_0010336b",
                "param_1": "filePtr",
                "pcVar1": "emulationOptionsText"
            },
            "code": "\nvoid printEmulationOptions_0010336b(FILE *filePtr)\n\n{\n  char *emulationOptionsText;\n  \n  emulationOptionsText = (char *)dcgettext(0,\" emulation options: \\n\",5);\n  fprintf(filePtr,emulationOptionsText);\n  emulationOptionsText = (char *)dcgettext(0,\"  No emulation specific options\\n\",5);\n  fprintf(filePtr,emulationOptionsText);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010336b",
            "calling": [
                "FUN_0010342d"
            ],
            "imported": false,
            "current_name": "print_emulation_options_0010336b"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "FUN_00105a68",
                "FUN_00103ba8",
                "FUN_001031a5",
                "FUN_00105db0",
                "FUN_001075e0",
                "FUN_00103172",
                "FUN_00103a78",
                "FUN_00103e95",
                "FUN_00102f08"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "FUN_00103c60": {
            "renaming": {
                "FUN_00103c60": "process_archives_00103c60",
                "param_1": "input_file_name",
                "param_2": "is_output_archive",
                "cVar1": "format_check_result",
                "piVar2": "error_number",
                "pcVar3": "error_message",
                "lVar4": "input_file_descriptor",
                "lVar5": "archive_file_descriptor",
                "uVar6": "program_name",
                "plVar7": "archive_file_list"
            },
            "code": "\n\n\nvoid process_archives_00103c60(char *input_file_name,int is_output_archive)\n\n{\n  char format_check_result;\n  int *error_number;\n  char *error_message;\n  long input_file_descriptor;\n  long archive_file_descriptor;\n  undefined8 program_name;\n  long *archive_file_list;\n  \n  DAT_0010d570 = xstrdup();\n  DAT_0010d560 = (char *)FUN_001057a0(DAT_0010d570,&DAT_0010d568);\n  if (DAT_0010d560 == (char *)0x0) {\n    error_number = __errno_location();\n    input_file_name = strerror(*error_number);\n    program_name = DAT_0010d660;\n    error_message = (char *)dcgettext(0,\"%s: Can\\'t open temporary file (%s)\\n\",5);\n  }\n  else {\n    DAT_0010d558 = bfd_fdopenw(DAT_0010d560,0,DAT_0010d568);\n    if (DAT_0010d558 == 0) {\n      error_message = \"%s: Can\\'t open output archive %s\\n\";\n      input_file_name = DAT_0010d560;\n    }\n    else {\n      if (is_output_archive != 0) {\nLAB_00103d02:\n        bfd_set_format(DAT_0010d558,2);\n        *(byte *)(DAT_0010d558 + 0x49) = *(byte *)(DAT_0010d558 + 0x49) & 0xe7 | 8;\n        return;\n      }\n      input_file_descriptor = bfd_openr(input_file_name,\"plugin\");\n      if (input_file_descriptor == 0) {\n        error_message = \"%s: Can\\'t open input archive %s\\n\";\n      }\n      else {\n        format_check_result = bfd_check_format(input_file_descriptor,2);\n        if (format_check_result != '\\0') {\n          archive_file_list = (long *)(DAT_0010d558 + 0xf8);\n          for (archive_file_descriptor = bfd_openr_next_archived_file(input_file_descriptor,0); archive_file_descriptor != 0;\n              archive_file_descriptor = bfd_openr_next_archived_file(input_file_descriptor,archive_file_descriptor)) {\n            *archive_file_list = archive_file_descriptor;\n            archive_file_list = (long *)(archive_file_descriptor + 0xf0);\n          }\n          goto LAB_00103d02;\n        }\n        error_message = \"%s: file %s is not an archive\\n\";\n      }\n    }\n    program_name = DAT_0010d660;\n    error_message = (char *)dcgettext(0,error_message,5);\n  }\n  fprintf(_stderr,error_message,program_name,input_file_name);\n  FUN_0010315d();\n  return;\n}\n\n",
            "called": [
                "FUN_0010315d",
                "bfd_set_format",
                "bfd_openr_next_archived_file",
                "__errno_location",
                "bfd_check_format",
                "bfd_openr",
                "strerror",
                "bfd_fdopenw",
                "xstrdup",
                "dcgettext",
                "fprintf",
                "FUN_001057a0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c60",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "process_archives_00103c60"
        },
        "FUN_00102e57": {
            "renaming": {
                "FUN_00102e57": "write_to_file_00102e57",
                "pFVar1": "filePointer"
            },
            "code": "\nvoid writeToFile_00102e57(void)\n\n{\n  FILE *filePointer;\n  \n  DAT_0010d618 = (char *)concat();\n  if (DAT_0010d60c != 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  filePointer = fopen(DAT_0010d618,\"w\");\n  if (filePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e57",
            "calling": [
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "write_to_file_00102e57"
        },
        "FUN_00105af0": {
            "renaming": {
                "FUN_00105af0": "extract_archived_files_00105af0",
                "param_1": "file_list",
                "param_2": "archive_file",
                "param_3": "check_format",
                "param_4": "extract_archives",
                "cVar1": "format_valid",
                "uVar2": "extracted_files_count",
                "lVar3": "archived_file",
                "uVar4": "result"
            },
            "code": "\nulong extract_archived_files_00105af0(long *file_list,long archive_file,char check_format,char extract_archives)\n\n{\n  char format_valid;\n  uint extracted_files_count;\n  long archived_file;\n  ulong result;\n  \n  if (extract_archives == '\\0') {\n    if (check_format != '\\0') {\n      result = FUN_00102f08();\n      return result;\n    }\n  }\n  else {\n    format_valid = bfd_check_format(archive_file,2);\n    if (format_valid != '\\0') {\n      result = 0;\n      for (archived_file = bfd_openr_next_archived_file(archive_file,0); archived_file != 0;\n          archived_file = bfd_openr_next_archived_file(archive_file,archived_file)) {\n        extracted_files_count = extract_archived_files_00105af0(file_list,archived_file,check_format,1);\n        if ((char)extracted_files_count != '\\0') {\n          result = (ulong)extracted_files_count;\n          file_list = (long *)(*file_list + 0xf0);\n        }\n      }\n      return result;\n    }\n    if (check_format != '\\0') {\n      result = FUN_00102f08();\n      return result;\n    }\n  }\n  *(long *)(archive_file + 0xf0) = *file_list;\n  *file_list = archive_file;\n  return 1;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file",
                "bfd_check_format",
                "FUN_00105af0",
                "FUN_00102f08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105af0",
            "calling": [
                "FUN_00105ae0",
                "FUN_001028ed",
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "extract_archived_files_00105af0"
        },
        "FUN_0010300e": {
            "renaming": {
                "FUN_0010300e": "find_matching_pattern_0010300e",
                "bVar1": "hasMatch",
                "iVar2": "currentPatternIndex",
                "lVar3": "nextPatternIndex",
                "bVar4": "patternOffset",
                "pbVar5": "patternData",
                "in_R9": "matchingPatternData",
                "in_R10D": "matchingPatternIndex"
            },
            "code": "\nvoid findMatchingPattern_0010300e(void)\n\n{\n  bool hasMatch;\n  int currentPatternIndex;\n  long nextPatternIndex;\n  byte patternOffset;\n  byte *patternData;\n  byte *matchingPatternData;\n  int matchingPatternIndex;\n  \n  hasMatch = false;\n  currentPatternIndex = DAT_0010d5d0;\n  for (patternData = DAT_0010d5c8; patternData < DAT_0010d5b0; patternData = patternData + 1) {\n    patternOffset = 1;\n    if (*patternData != 0) {\n      patternOffset = (&DAT_0010ab00)[*patternData];\n    }\n    if (*(short *)(&DAT_0010a980 + (long)currentPatternIndex * 2) != 0) {\n      hasMatch = true;\n      matchingPatternData = patternData;\n      matchingPatternIndex = currentPatternIndex;\n    }\n    while( true ) {\n      nextPatternIndex = (long)(int)((int)*(short *)(&DAT_0010a640 + (long)currentPatternIndex * 2) + (uint)patternOffset);\n      if (*(short *)(&DAT_0010a440 + nextPatternIndex * 2) == currentPatternIndex) break;\n      currentPatternIndex = (int)*(short *)(&DAT_0010a800 + (long)currentPatternIndex * 2);\n      if (0xb0 < currentPatternIndex) {\n        patternOffset = (&DAT_0010a7c0)[(int)(uint)patternOffset];\n      }\n    }\n    currentPatternIndex = (int)*(short *)(&DAT_0010a240 + nextPatternIndex * 2);\n  }\n  if (hasMatch) {\n    DAT_0010d5b8 = matchingPatternData;\n    DAT_0010d5c0 = matchingPatternIndex;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010300e",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "find_matching_pattern_0010300e"
        },
        "chmod": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "chmod"
        },
        "FUN_00102ba1": {
            "renaming": {
                "FUN_00102ba1": "deallocate_memory_00102ba1",
                "unaff_RBP": "memoryBlock",
                "unaff_retaddr": "returnAddress",
                "auVar1": "returnValue"
            },
            "code": "\nundefined  [16] deallocateMemory_00102ba1(void)\n\n{\n  undefined returnValue [16];\n  void *memoryBlock;\n  ulong returnAddress;\n  \n  free(memoryBlock);\n  returnValue._8_8_ = 0;\n  returnValue._0_8_ = returnAddress;\n  return returnValue << 0x40;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102ba1",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "deallocate_memory_00102ba1"
        },
        "FUN_00107740": {
            "renaming": {
                "FUN_00107740": "extract_valid_archive_00107740",
                "param_1": "archivePtr",
                "iVar1": "comparisonResult",
                "iVar2": "statResult",
                "piVar3": "errnoPtr",
                "pcVar4": "errorMessage",
                "uVar5": "errorString",
                "pplVar6": "fileListPtr",
                "__ptr": "bufferPtr",
                "__n": "bytesRead",
                "lVar7": "loopVariable",
                "plVar8": "currentFilePtr",
                "puVar9": "localVarsPtr",
                "uVar10": "totalBytesRead",
                "sVar11": "bytesToRead",
                "local_c8": "localVarsArray",
                "_Stack_b0": "filePermission",
                "uStack_98": "fileSize",
                "uStack_80": "stackVar1",
                "uStack_70": "stackVar2"
            },
            "code": "\n\n\nlong * extractValidArchive_00107740(long **archivePtr)\n\n{\n  int comparisonResult;\n  int statResult;\n  int *errnoPtr;\n  char *errorMessage;\n  undefined8 errorString;\n  long **fileListPtr;\n  void *bufferPtr;\n  size_t bytesRead;\n  long loopVariable;\n  long *currentFilePtr;\n  undefined4 *localVarsPtr;\n  ulong totalBytesRead;\n  size_t bytesToRead;\n  undefined4 localVarsArray [6];\n  __mode_t filePermission;\n  ulong fileSize;\n  undefined8 stackVar1;\n  undefined8 stackVar2;\n  \n  if (_DAT_0010d600 != 0) {\n    localVarsPtr = localVarsArray;\n    for (loopVariable = 0x24; loopVariable != 0; loopVariable = loopVariable + -1) {\n      *localVarsPtr = 0;\n      localVarsPtr = localVarsPtr + 1;\n    }\n  }\n  fileListPtr = (long **)archivePtr[0x1d];\n  if ((long **)archivePtr[0x1d] == (long **)0x0) {\n    fileListPtr = archivePtr;\n  }\n  statResult = (*(code *)fileListPtr[1][0x3d])(archivePtr,localVarsArray);\n  if (statResult != 0) {\n    currentFilePtr = *archivePtr;\n    errorString = dcgettext(0,\"internal stat error on %s\",5);\n    statResult = FUN_00107690(errorString,currentFilePtr);\n    errorString = DAT_0010d638;\n    if (statResult == 3) {\n      for (; *currentFilePtr != 0; currentFilePtr = (long *)(*currentFilePtr + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*currentFilePtr != (undefined8 *)0x0; currentFilePtr = (long *)(*currentFilePtr + 0xf0)) {\n        comparisonResult = filename_cmp(*(undefined8 *)*currentFilePtr,errorString);\n        if (comparisonResult == 0) {\n          if (statResult != 2) {\n            return currentFilePtr;\n          }\n          return (long *)(*currentFilePtr + 0xf0);\n        }\n      }\n    }\n    return currentFilePtr;\n  }\n  bfd_seek(archivePtr,0,0);\n  DAT_0010d5d8 = (FILE *)0x0;\n  if (fileSize == 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 = (FILE *)FUN_00105a20(*archivePtr);\n  }\n  else {\n    totalBytesRead = 0;\n    bufferPtr = (void *)xmalloc(0x2000);\n    do {\n      bytesToRead = fileSize - totalBytesRead;\n      if (0x2000 < bytesToRead) {\n        bytesToRead = 0x2000;\n      }\n      bytesRead = bfd_bread(bufferPtr,bytesToRead,archivePtr);\n      if (bytesToRead != bytesRead) {\nLAB_00102c78:\n        archivePtr = (long **)*archivePtr[0x1d];\n        errorString = dcgettext(0,\"%s is not a valid archive\",5);\n        FUN_00107690(errorString,archivePtr);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 == (FILE *)0x0) {\n        DAT_0010d5d8 = (FILE *)FUN_00105a20(*archivePtr);\n      }\n      bytesToRead = fwrite(bufferPtr,1,bytesRead,DAT_0010d5d8);\n      if (bytesToRead != bytesRead) {\n        errnoPtr = __errno_location();\n        errorMessage = strerror(*errnoPtr);\n        FUN_00107690(\"%s: %s\",DAT_0010d618,errorMessage);\n        goto LAB_00102c78;\n      }\n      totalBytesRead = totalBytesRead + bytesRead;\n    } while (totalBytesRead < fileSize);\n    free(bufferPtr);\n  }\n  fclose(DAT_0010d5d8);\n  errorMessage = DAT_0010d618;\n  DAT_0010d5d8 = (FILE *)0x0;\n  chmod(DAT_0010d618,filePermission);\n  if (_DAT_0010d600 != 0) {\n    stackVar1 = stackVar2;\n    FUN_00107c80(errorMessage,localVarsArray);\n  }\n  DAT_0010d618 = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "FUN_00102c25"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107740",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "extract_valid_archive_00107740"
        },
        "FUN_00102d2f": {
            "renaming": {
                "FUN_00102d2f": "print_file_info_00102d2f",
                "__format": "timeErrorMsg",
                "bVar1": "byteValue",
                "cVar2": "result",
                "iVar3": "errorCode",
                "unaff_RBX": "fileInfo",
                "unaff_RBP": "outputFile",
                "unaff_R12": "flag",
                "unaff_R13": "fileName",
                "unaff_R14D": "fileDescriptor",
                "uStack0000000000000015": "fileType",
                "cStack0000000000000016": "isExecutable",
                "cStack0000000000000017": "isWritable",
                "in_stack_00000018": "isReadable",
                "cStack0000000000000019": "isSetuid",
                "cStack000000000000001a": "isSetgid",
                "cStack000000000000001b": "isSticky",
                "cStack000000000000001c": "ownerExecute",
                "cStack000000000000001d": "ownerWrite",
                "cStack000000000000001e": "ownerRead",
                "uStack000000000000001f": "unused",
                "uStack0000000000000068": "permissions",
                "uStack000000000000006c": "inodeValue",
                "in_stack_00000070": "deviceNumber",
                "in_stack_00000080": "fileSize"
            },
            "code": "\nvoid printFileInfo_00102d2f(void)\n\n{\n  byte byteValue;\n  char result;\n  int errorCode;\n  char *timeErrorMsg;\n  uint uVar4;\n  char **fileInfo;\n  FILE *outputFile;\n  long flag;\n  void *fileName;\n  int fileDescriptor;\n  undefined fileType;\n  char isExecutable;\n  char isWritable;\n  char isReadable;\n  char isSetuid;\n  char isSetgid;\n  char isSticky;\n  char ownerExecute;\n  char ownerWrite;\n  char ownerRead;\n  undefined unused;\n  uint permissions;\n  uint inodeValue;\n  uint deviceNumber;\n  undefined8 fileSize;\n  \n  do {\n    byteValue = FUN_00107c10();\n    *(uint *)((long)fileInfo + 0x44) = *(uint *)((long)fileInfo + 0x44) | 0x100000;\n    if ((DAT_0010d5f8 != '\\0') || ((*(byte *)(flag + 0x49) & 0x10) != 0)) {\n      *(byte *)((long)fileInfo + 0x49) = byteValue | 0x10;\n    }\n    result = bfd_set_archive_head();\n  } while (result == '\\0');\n  dup(fileDescriptor);\n  result = bfd_close();\n  if (result != '\\0') {\n    DAT_0010d5e0 = 0;\n    DAT_0010d618 = 0;\n    bfd_close();\n    errorCode = FUN_00105bc0();\n    if (errorCode == 0) {\n      free(fileName);\n      free(outputFile);\n      return;\n    }\n                    \n    xexit(1);\n  }\n  FUN_00107c10();\n  timeErrorMsg = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,timeErrorMsg);\n  uVar4 = permissions & 0xf000;\n  if (uVar4 == 0x4000) {\n    fileType = 100;\n  }\n  else if (uVar4 == 0xa000) {\n    fileType = 0x6c;\n  }\n  else if (uVar4 == 0x6000) {\n    fileType = 0x62;\n  }\n  else if (uVar4 == 0x2000) {\n    fileType = 99;\n  }\n  else if (uVar4 == 0xc000) {\n    fileType = 0x73;\n  }\n  else {\n    fileType = 0x70;\n    if (uVar4 != 0x1000) {\n      fileType = 0x2d;\n    }\n  }\n  isExecutable = (-((permissions & 0x100) == 0) & 0xbbU) + 0x72;\n  isWritable = (-((permissions & 0x80) == 0) & 0xb6U) + 0x77;\n  isReadable = (-((permissions & 0x40) == 0) & 0xb5U) + 0x78;\n  isSetuid = (-((permissions & 0x20) == 0) & 0xbbU) + 0x72;\n  isSetgid = (-((permissions & 0x10) == 0) & 0xb6U) + 0x77;\n  isSticky = (-((permissions & 8) == 0) & 0xb5U) + 0x78;\n  ownerExecute = (-((permissions & 4) == 0) & 0xbbU) + 0x72;\n  ownerWrite = (-((permissions & 2) == 0) & 0xb6U) + 0x77;\n  ownerRead = (-((permissions & 1) == 0) & 0xb5U) + 0x78;\n  if ((permissions & 0x800) != 0) {\n    if (isReadable == 'x') {\n      isReadable = 's';\n    }\n    else {\n      isReadable = 'S';\n    }\n  }\n  if ((permissions & 0x400) != 0) {\n    if (isSticky == 'x') {\n      isSticky = 's';\n    }\n    else {\n      isSticky = 'S';\n    }\n  }\n  if ((permissions & 0x200) != 0) {\n    if (ownerRead == 'x') {\n      ownerRead = 't';\n    }\n    else {\n      ownerRead = 'T';\n    }\n  }\n  unused = 0;\n  fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)inodeValue,\n          (ulong)deviceNumber,fileSize,&stack0x00000020,(ulong)permissions)\n  ;\n  fputs(*fileInfo,outputFile);\n  if ((char)flag != '\\0') {\n    if ((*(byte *)((long)fileInfo + 0x49) & 0x10) == 0) {\n      if (fileInfo[0xb] != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (fileInfo[0xc] != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "FUN_00105bc0",
                "bfd_set_archive_head",
                "xexit",
                "bfd_close",
                "free",
                "FUN_00102d2f",
                "dup",
                "FUN_00107c10"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d2f",
            "calling": [
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "print_file_info_00102d2f"
        },
        "FUN_001028ed": {
            "renaming": {
                "FUN_001028ed": "process_binary_001028ed",
                "param_1": "param_filepath",
                "param_2": "bfd_object",
                "uVar1": "undefined_var1",
                "bVar2": "byte_var2",
                "iVar3": "int_var3",
                "sVar4": "size_var4",
                "piVar5": "int_ptr_var5",
                "pcVar6": "char_ptr_var6",
                "pcVar7": "char_ptr_var7",
                "ppcVar8": "char_ptr_ptr_var8",
                "uVar9": "undefined_var9",
                "lVar10": "long_var10",
                "__s": "char_ptr_var_s",
                "__s_00": "char_ptr_var_s_00",
                "lVar11": "long_var11",
                "uVar12": "undefined_var12",
                "uVar13": "ulong_var13",
                "unaff_RBX": "char_ptr_var_unaff_RBX",
                "ppcVar14": "char_ptr_ptr_var_ppcVar14",
                "unaff_RBP": "char_ptr_ptr_var_unaff_RBP",
                "unaff_R12": "char_ptr_ptr_var_unaff_R12",
                "unaff_R13D": "uint_var_unaff_R13D",
                "ppcVar15": "char_ptr_ptr_var_ppcVar15",
                "unaff_R14": "long_var_unaff_R14",
                "bVar16": "bool_var16",
                "bVar17": "byte_var17",
                "param_7": "char_ptr_ptr_param_7",
                "param_9": "undefined_var_param_9",
                "in_stack_00000078": "long_var_in_stack_00000078",
                "in_stack_00000108": "long_var_in_stack_00000108"
            },
            "code": "\n\n\nundefined8 processBinary_001028ed(undefined8 param_filepath,long bfd_object)\n\n{\n  undefined undefined_var1;\n  byte byte_var2;\n  int int_var3;\n  size_t size_var4;\n  int *int_ptr_var5;\n  char *char_ptr_var6;\n  char *char_ptr_var7;\n  char **char_ptr_ptr_var8;\n  undefined8 undefined_var9;\n  long long_var10;\n  char *char_ptr_var_s;\n  char *char_ptr_var_s_00;\n  long long_var11;\n  undefined8 undefined_var12;\n  ulong ulong_var13;\n  char *char_ptr_var_unaff_RBX;\n  char **char_ptr_ptr_var_ppcVar14;\n  char **char_ptr_ptr_var_unaff_RBP;\n  char **char_ptr_ptr_var_unaff_R12;\n  uint uint_var_unaff_R13D;\n  char **char_ptr_ptr_var_ppcVar15;\n  long long_var_unaff_R14;\n  bool bool_var16;\n  byte byte_var17;\n  char **char_ptr_ptr_param_7;\n  undefined8 undefined_var_param_9;\n  long long_var_in_stack_00000078;\n  long long_var_in_stack_00000108;\n  \n  byte_var17 = 0;\ncode_r0x001028ed:\n  FUN_00107c10(char_ptr_var_unaff_RBX,bfd_object);\nLAB_001028f5:\n  undefined_var12 = DAT_0010d638;\n  if (uint_var_unaff_R13D != 3) {\n    while( true ) {\n      if ((undefined8 *)*char_ptr_ptr_var_unaff_R12 == (undefined8 *)0x0) goto LAB_0010571f;\n      int_var3 = filename_cmp(*(undefined8 *)*char_ptr_ptr_var_unaff_R12,undefined_var12);\n      if (int_var3 == 0) break;\n      char_ptr_ptr_var_unaff_R12 = (char **)(*char_ptr_ptr_var_unaff_R12 + 0xf0);\n    }\n    if (uint_var_unaff_R13D != 2) goto LAB_0010571f;\n    char_ptr_ptr_var_unaff_R12 = (char **)(*char_ptr_ptr_var_unaff_R12 + 0xf0);\n    goto LAB_0010571f;\n  }\n  long_var10 = *(long *)(long_var_unaff_R14 + 0xf0);\n  if (*(long *)(long_var_unaff_R14 + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n  do {\n    long_var11 = long_var10;\n    long_var10 = *(long *)(long_var11 + 0xf0);\n  } while (long_var10 != 0);\n  char_ptr_ptr_var_unaff_R12 = (char **)(long_var11 + 0xf0);\n  char_ptr_var_unaff_RBX = *char_ptr_ptr_var_unaff_RBP;\n  if (DAT_0010d620 != 0) goto LAB_00105731;\nLAB_00105698:\n  undefined_var1 = DAT_0010d5f8;\n  uint_var_unaff_R13D = (uint)(DAT_0010d60c != 0);\n  bfd_object = bfd_openr(char_ptr_var_unaff_RBX,DAT_0010d5f0);\n  if (bfd_object != 0) {\n    char_ptr_ptr_var_unaff_RBP = char_ptr_ptr_var_unaff_RBP + 1;\n    byte_var2 = FUN_00105af0(char_ptr_ptr_var_unaff_R12,bfd_object,uint_var_unaff_R13D,undefined_var1);\n    undefined_var_param_9._6_1_ = undefined_var_param_9._6_1_ | byte_var2;\n    char_ptr_var6 = *char_ptr_ptr_var_unaff_RBP;\n    do {\n      if (char_ptr_var6 == (char *)0x0) {\n        if (undefined_var_param_9._6_1_ == 0) {\n          DAT_0010d618 = 0;\n          return 0;\n        }\n        undefined_var12 = FUN_001058b0();\n        return undefined_var12;\n      }\n      char_ptr_ptr_var_ppcVar14 = *(char ***)(long_var_unaff_R14 + 0xf0);\n      char_ptr_ptr_var_unaff_R12 = char_ptr_ptr_param_7;\n      if (undefined_var_param_9._7_1_ == '\\0') {\n        char_ptr_ptr_var_ppcVar15 = char_ptr_ptr_param_7;\n        if (char_ptr_ptr_var_ppcVar14 != (char **)0x0) {\n          do {\n            if (DAT_0010d5f9 == '\\0') {\n              char_ptr_var_s = (char *)lbasename(*char_ptr_ptr_var_ppcVar14);\n              char_ptr_var7 = char_ptr_var_s;\n              if (DAT_0010d5fa != '\\0') {\n                size_var4 = strlen(char_ptr_var_s);\n                ulong_var13 = (ulong)*(byte *)(*(long *)(long_var_unaff_R14 + 8) + 0x1e);\n                if (ulong_var13 < size_var4) {\n                  char_ptr_var7 = (char *)xmalloc(ulong_var13 + 1);\n                  long_var10 = *(long *)(long_var_unaff_R14 + 8);\n                  char_ptr_var6 = char_ptr_var7;\n                  for (ulong_var13 = (ulong)*(byte *)(long_var10 + 0x1e); ulong_var13 != 0; ulong_var13 = ulong_var13 - 1) {\n                    *char_ptr_var6 = *char_ptr_var_s;\n                    char_ptr_var_s = char_ptr_var_s + (ulong)byte_var17 * -2 + 1;\n                    char_ptr_var6 = char_ptr_var6 + (ulong)byte_var17 * -2 + 1;\n                  }\n                  char_ptr_var7[*(byte *)(long_var10 + 0x1e)] = '\\0';\n                }\n                char_ptr_var6 = *char_ptr_ptr_var_unaff_RBP;\n                char_ptr_var_s = char_ptr_var7;\n                if (DAT_0010d5f9 == '\\0') goto LAB_00105611;\n                goto LAB_00102980;\n              }\n              char_ptr_var6 = *char_ptr_ptr_var_unaff_RBP;\n              if (DAT_0010d5f9 != '\\0') goto LAB_00102980;\nLAB_00105611:\n              char_ptr_var_s_00 = (char *)lbasename(char_ptr_var6);\n              if (DAT_0010d5fa != '\\0') {\n                size_var4 = strlen(char_ptr_var_s_00);\n                ulong_var13 = (ulong)*(byte *)(*(long *)(long_var_unaff_R14 + 8) + 0x1e);\n                char_ptr_var6 = char_ptr_var_s_00;\n                char_ptr_var_s = char_ptr_var7;\n                if (ulong_var13 < size_var4) {\n                  char_ptr_var6 = (char *)xmalloc(ulong_var13 + 1);\n                  long_var10 = *(long *)(long_var_unaff_R14 + 8);\n                  char_ptr_var7 = char_ptr_var6;\n                  for (ulong_var13 = (ulong)*(byte *)(long_var10 + 0x1e); ulong_var13 != 0; ulong_var13 = ulong_var13 - 1) {\n                    *char_ptr_var7 = *char_ptr_var_s_00;\n                    char_ptr_var_s_00 = char_ptr_var_s_00 + (ulong)byte_var17 * -2 + 1;\n                    char_ptr_var7 = char_ptr_var7 + (ulong)byte_var17 * -2 + 1;\n                  }\n                  char_ptr_var6[*(byte *)(long_var10 + 0x1e)] = '\\0';\n                }\n                goto LAB_00102980;\n              }\n              int_var3 = filename_cmp(char_ptr_var_s_00,char_ptr_var7);\n            }\n            else {\n              char_ptr_var6 = *char_ptr_ptr_var_unaff_RBP;\n              char_ptr_var_s = *char_ptr_ptr_var_ppcVar14;\nLAB_00102980:\n              int_var3 = filename_cmp(char_ptr_var6,char_ptr_var_s);\n            }\n            if ((int_var3 == 0) && (char_ptr_ptr_var_ppcVar14[0x1c] != (char *)0x0)) {\n              if (_DAT_0010d644 != 0) {\n                int_var3 = stat(*char_ptr_ptr_var_unaff_RBP,(stat *)&stack0x000000b0);\n                if (int_var3 != 0) {\n                  int_ptr_var5 = __errno_location();\n                  if (*int_ptr_var5 != 2) {\n                    FUN_00107c10(*char_ptr_ptr_var_unaff_RBP);\nLAB_00102b7e:\n                    char_ptr_var6 = *char_ptr_ptr_var_ppcVar14;\n                    undefined_var12 = dcgettext(0,\"internal stat error on %s\",5);\n                    FUN_00107690(undefined_var12,char_ptr_var6);\n                    free(char_ptr_ptr_var_unaff_RBP);\n                    return 0;\n                  }\n                  goto LAB_0010577e;\n                }\n                char_ptr_ptr_var8 = (char **)char_ptr_ptr_var_ppcVar14[0x1d];\n                if ((char **)char_ptr_ptr_var_ppcVar14[0x1d] == (char **)0x0) {\n                  char_ptr_ptr_var8 = char_ptr_ptr_var_ppcVar14;\n                }\n                int_var3 = (**(code **)(char_ptr_ptr_var8[1] + 0x1e8))(char_ptr_ptr_var_ppcVar14,&stack0x00000020);\n                if (int_var3 != 0) goto LAB_00102b7e;\n                if (long_var_in_stack_00000108 <= long_var_in_stack_00000078) goto LAB_0010577e;\n              }\n              undefined_var12 = FUN_00105870(char_ptr_ptr_param_7,2,*char_ptr_ptr_var_ppcVar14);\n              if (DAT_0010d620 == 0) {\nLAB_00102ae2:\n                char_ptr_var6 = *char_ptr_ptr_var_unaff_RBP;\n                bool_var16 = DAT_0010d60c != 0;\n                long_var10 = bfd_openr(char_ptr_var6,DAT_0010d5f0);\n                if (long_var10 == 0) {\n                  FUN_00107c10(char_ptr_var6,0);\n                  goto LAB_00102b3e;\n                }\n                byte_var2 = FUN_00103172(undefined_var12,long_var10,bool_var16);\n              }\n              else {\n                undefined_var9 = FUN_00105830(*char_ptr_ptr_var_unaff_RBP);\n                int_var3 = filename_cmp(undefined_var9,\"__.LIBDEP\");\n                if (int_var3 != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n                byte_var2 = FUN_00103172(undefined_var12,DAT_0010d620,DAT_0010d60c != 0);\n              }\n              if (byte_var2 != 0) {\n                *char_ptr_ptr_var_ppcVar15 = *(char **)(*char_ptr_ptr_var_ppcVar15 + 0xf0);\n                undefined_var_param_9._6_1_ = byte_var2;\n              }\n              goto LAB_0010577e;\n            }\n            char_ptr_ptr_var_ppcVar15 = char_ptr_ptr_var_ppcVar14 + 0x1e;\n            char_ptr_ptr_var_ppcVar14 = (char **)char_ptr_ptr_var_ppcVar14[0x1e];\n          } while (char_ptr_ptr_var_ppcVar14 != (char **)0x0);\n          goto LAB_0010564c;\n        }\n        uint_var_unaff_R13D = DAT_0010d640;\n        if (DAT_0010d640 != 0) goto LAB_001028f5;\n      }\n      else {\nLAB_0010564c:\n        uint_var_unaff_R13D = DAT_0010d640;\n        if (DAT_0010d640 != 0) goto LAB_001028f5;\n        long_var10 = *(long *)(long_var_unaff_R14 + 0xf0);\n        if (*(long *)(long_var_unaff_R14 + 0xf0) != 0) goto LAB_00105670;\n      }\nLAB_0010571f:\n      char_ptr_var_unaff_RBX = *char_ptr_ptr_var_unaff_RBP;\n      if (DAT_0010d620 == 0) goto LAB_00105698;\nLAB_00105731:\n      undefined_var12 = FUN_00105830(char_ptr_var_unaff_RBX);\n      int_var3 = filename_cmp(undefined_var12,\"__.LIBDEP\");\n      if (int_var3 != 0) goto code_r0x0010574f;\n      byte_var2 = FUN_00105ae0(char_ptr_ptr_var_unaff_R12,DAT_0010d620,DAT_0010d60c != 0,DAT_0010d5f8);\n      undefined_var_param_9._6_1_ = byte_var2 | undefined_var_param_9._6_1_;\nLAB_0010577e:\n      char_ptr_ptr_var_unaff_RBP = char_ptr_ptr_var_unaff_RBP + 1;\n      char_ptr_var6 = *char_ptr_ptr_var_unaff_RBP;\n    } while( true );\n  }\n  goto code_r0x001028ed;\ncode_r0x0010574f:\n  char_ptr_var_unaff_RBX = *char_ptr_ptr_var_unaff_RBP;\n  goto LAB_00105698;\n}\n\n",
            "called": [
                "__errno_location",
                "bfd_openr",
                "xmalloc",
                "FUN_00102943",
                "FUN_00105870",
                "FUN_00103172",
                "dcgettext",
                "stat",
                "FUN_00105ae0",
                "FUN_001058b0",
                "filename_cmp",
                "FUN_001028ed",
                "FUN_00105830",
                "strlen",
                "lbasename",
                "FUN_00105af0",
                "FUN_00107c10",
                "FUN_00107690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001028ed",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "process_binary_001028ed"
        },
        "clearerr": {
            "renaming": {},
            "code": "\n\n\nvoid clearerr(FILE *__stream)\n\n{\n  clearerr(__stream);\n  return;\n}\n\n",
            "called": [
                "clearerr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "clearerr"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "FUN_00102bf5",
                "FUN_00105db0",
                "FUN_00102c25",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "bfd_errmsg": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024d0",
            "calling": [
                "FUN_00107c20",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_errmsg"
        },
        "FUN_001033b0": {
            "renaming": {
                "FUN_001033b0": "print_and_exit_001033b0",
                "param_1": "errorMessage"
            },
            "code": "\n\n\nvoid printAndExit_001033b0(undefined8 errorMessage)\n\n{\n  fprintf(_stderr,\"%s\\n\",errorMessage);\n                    \n  exit(2);\n}\n\n",
            "called": [
                "fprintf",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033b0",
            "calling": [
                "FUN_001033d6",
                "FUN_00103e95",
                "FUN_00103df9"
            ],
            "imported": false,
            "current_name": "print_and_exit_001033b0"
        },
        "fwrite": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102510",
            "calling": [
                "FUN_00102c25",
                "FUN_00103a78",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fwrite"
        },
        "unlink": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "FUN_00102f1e",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "unlink"
        },
        "unlink_if_ordinary": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "FUN_00102bf5"
            ],
            "imported": false,
            "current_name": "unlink_if_ordinary"
        },
        "FUN_001025a0": {
            "renaming": {
                "FUN_001025a0": "check_file_existence_001025a0",
                "piVar1": "errnoPointer",
                "uVar2": "errorMessage"
            },
            "code": "\nundefined8 checkFileExistence_001025a0(void)\n\n{\n  int *errnoPointer;\n  undefined8 errorMessage;\n  \n  errnoPointer = __errno_location();\n  if (*errnoPointer == 2) {\n    errorMessage = dcgettext(0,\"\\'%s\\': No such file\",5);\n    FUN_00107920(errorMessage);\n  }\n  else {\n    strerror(*errnoPointer);\n    errorMessage = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    FUN_00107920(errorMessage);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "FUN_00107920",
                "__errno_location",
                "strerror",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001025a0",
            "calling": [
                "FUN_001052a0"
            ],
            "imported": false,
            "current_name": "check_file_existence_001025a0"
        },
        "FUN_0010284b": {
            "renaming": {
                "FUN_0010284b": "get_return_value_0010284b"
            },
            "code": "\nundefined8 getReturnValue_0010284b(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010284b",
            "calling": [
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "get_return_value_0010284b"
        },
        "FUN_00102c25": {
            "renaming": {
                "FUN_00102c25": "extract_archive_contents_00102c25",
                "param_7": "filePermissions",
                "param_11": "targetPermissions",
                "param_12": "archiveSize",
                "iVar1": "comparisonResult",
                "iVar2": "errorCode",
                "piVar3": "errorNumber",
                "pcVar4": "errorMessage",
                "uVar5": "message",
                "pplVar6": "pointerToPointer",
                "__ptr": "buffer",
                "__n": "bytesRead",
                "lVar7": "loopCounter",
                "unaff_RBX": "pointerToRBX",
                "plVar8": "pointerToResult",
                "puVar9": "paramPointer",
                "uVar10": "accumulatedSize",
                "sVar11": "size"
            },
            "code": "\n\n\nlong * extractArchiveContents_00102c25(void)\n\n{\n  int comparisonResult;\n  int errorCode;\n  int *errorNumber;\n  char *errorMessage;\n  undefined8 message;\n  long **pointerToPointer;\n  void *buffer;\n  size_t bytesRead;\n  long loopCounter;\n  long **pointerToRBX;\n  long *pointerToResult;\n  undefined4 *paramPointer;\n  ulong accumulatedSize;\n  size_t size;\n  undefined4 *filePermissions;\n  __mode_t targetPermissions;\n  ulong archiveSize;\n  \n  paramPointer = filePermissions;\n  for (loopCounter = 0x24; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *paramPointer = 0;\n    paramPointer = paramPointer + 1;\n  }\n  pointerToPointer = (long **)pointerToRBX[0x1d];\n  if ((long **)pointerToRBX[0x1d] == (long **)0x0) {\n    pointerToPointer = pointerToRBX;\n  }\n  errorCode = (*(code *)pointerToPointer[1][0x3d])();\n  if (errorCode != 0) {\n    pointerToResult = *pointerToRBX;\n    message = dcgettext(0,\"internal stat error on %s\",5);\n    errorCode = FUN_00107690(message,pointerToResult);\n    message = DAT_0010d638;\n    if (errorCode == 3) {\n      for (; *pointerToResult != 0; pointerToResult = (long *)(*pointerToResult + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*pointerToResult != (undefined8 *)0x0; pointerToResult = (long *)(*pointerToResult + 0xf0)) {\n        comparisonResult = filename_cmp(*(undefined8 *)*pointerToResult,message);\n        if (comparisonResult == 0) {\n          if (errorCode != 2) {\n            return pointerToResult;\n          }\n          return (long *)(*pointerToResult + 0xf0);\n        }\n      }\n    }\n    return pointerToResult;\n  }\n  bfd_seek();\n  DAT_0010d5d8 = (FILE *)0x0;\n  if (archiveSize == 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 = (FILE *)FUN_00105a20(*pointerToRBX);\n  }\n  else {\n    accumulatedSize = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      size = archiveSize - accumulatedSize;\n      if (0x2000 < size) {\n        size = 0x2000;\n      }\n      bytesRead = bfd_bread(buffer,size);\n      if (size != bytesRead) {\nLAB_00102c78:\n        pointerToRBX = (long **)*pointerToRBX[0x1d];\n        message = dcgettext(0,\"%s is not a valid archive\",5);\n        FUN_00107690(message,pointerToRBX);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 == (FILE *)0x0) {\n        DAT_0010d5d8 = (FILE *)FUN_00105a20(*pointerToRBX);\n      }\n      size = fwrite(buffer,1,bytesRead,DAT_0010d5d8);\n      if (size != bytesRead) {\n        errorNumber = __errno_location();\n        errorMessage = strerror(*errorNumber);\n        FUN_00107690(\"%s: %s\",DAT_0010d618,errorMessage);\n        goto LAB_00102c78;\n      }\n      accumulatedSize = accumulatedSize + bytesRead;\n    } while (accumulatedSize < archiveSize);\n    free(buffer);\n  }\n  fclose(DAT_0010d5d8);\n  errorMessage = DAT_0010d618;\n  DAT_0010d5d8 = (FILE *)0x0;\n  chmod(DAT_0010d618,targetPermissions);\n  if (_DAT_0010d600 != 0) {\n    FUN_00107c80(errorMessage,filePermissions);\n  }\n  DAT_0010d618 = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "chmod",
                "FUN_00105a20",
                "bfd_seek",
                "fwrite",
                "__errno_location",
                "xmalloc",
                "strerror",
                "dcgettext",
                "bfd_bread",
                "free",
                "FUN_00107c80",
                "fclose",
                "FUN_00107690"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c25",
            "calling": [
                "FUN_00107740"
            ],
            "imported": false,
            "current_name": "extract_archive_contents_00102c25"
        },
        "bfd_plugin_set_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_program_name"
        },
        "bfd_bwrite": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_bwrite"
        },
        "FUN_00102bb0": {
            "renaming": {
                "FUN_00102bb0": "copy_string_limited_00102bb0",
                "in_RAX": "sourceString",
                "sVar2": "sourceStringLength",
                "puVar3": "copiedString",
                "uVar4": "limit",
                "unaff_RBX": "sourcePointer",
                "unaff_RBP": "basePointer",
                "puVar5": "copiedStringPointer",
                "bVar6": "isCharacterCopied",
                "auVar7": "returnValue"
            },
            "code": "\nundefined  [16] copyStringLimited_00102bb0(void)\n\n{\n  long lVar1;\n  char *sourceString;\n  size_t sourceStringLength;\n  undefined *copiedString;\n  ulong limit;\n  undefined *sourcePointer;\n  long basePointer;\n  undefined *copiedStringPointer;\n  byte isCharacterCopied;\n  undefined returnValue [16];\n  undefined8 unaff_retaddr;\n  \n  isCharacterCopied = 0;\n  sourceStringLength = strlen(sourceString);\n  limit = (ulong)*(byte *)(*(long *)(basePointer + 8) + 0x1e);\n  copiedString = sourcePointer;\n  if (limit < sourceStringLength) {\n    copiedString = (undefined *)xmalloc(limit + 1);\n    lVar1 = *(long *)(basePointer + 8);\n    copiedStringPointer = copiedString;\n    for (limit = (ulong)*(byte *)(lVar1 + 0x1e); limit != 0; limit = limit - 1) {\n      *copiedStringPointer = *sourcePointer;\n      sourcePointer = sourcePointer + (ulong)isCharacterCopied * -2 + 1;\n      copiedStringPointer = copiedStringPointer + (ulong)isCharacterCopied * -2 + 1;\n    }\n    copiedString[*(byte *)(lVar1 + 0x1e)] = 0;\n  }\n  returnValue._8_8_ = unaff_retaddr;\n  returnValue._0_8_ = copiedString;\n  return returnValue;\n}\n\n",
            "called": [
                "strlen",
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bb0",
            "calling": [
                "FUN_00105830"
            ],
            "imported": false,
            "current_name": "copy_string_limited_00102bb0"
        },
        "utimensat": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "FUN_00107c80"
            ],
            "imported": false,
            "current_name": "utimensat"
        },
        "getc": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102560",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "getc"
        },
        "dup": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "FUN_00102d2f",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "dup"
        },
        "FUN_00102f08": {
            "renaming": {
                "FUN_00102f08": "print_and_assign_value_00102f08",
                "unaff_RBX": "array",
                "unaff_R12": "pointer"
            },
            "code": "\nundefined8 print_and_assign_value_00102f08(void)\n\n{\n  undefined8 *array;\n  undefined8 *pointer;\n  \n  printf(\"a - %s\\n\",*array);\n  array[0x1e] = *pointer;\n  *pointer = array;\n  return 1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f08",
            "calling": [
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "print_and_assign_value_00102f08"
        },
        "FUN_00105570": {
            "renaming": {
                "FUN_00105570": "extract_and_process_files_00105570",
                "param_1": "file_extraction_info",
                "param_2": "file_list",
                "param_3": "process_flag",
                "ppcVar1": "extracted_files",
                "uVar2": "undefined_value",
                "bVar3": "byte_value",
                "iVar4": "temp_integer",
                "sVar5": "length",
                "piVar6": "error_number",
                "pcVar7": "temp_pointer",
                "pcVar8": "temp_pointer_2",
                "uVar9": "undefined_value_2",
                "pcVar10": "current_file",
                "__s": "basename",
                "lVar11": "temp_long_1",
                "lVar12": "temp_long_2",
                "uVar13": "return_value",
                "uVar14": "ulong_value",
                "ppcVar15": "current_file_list",
                "ppcVar16": "temp_pointer_3",
                "uVar17": "uint_value",
                "ppcVar18": "temp_pointer_4",
                "bVar19": "bool_value",
                "bVar20": "byte_value_2",
                "local_15a": "local_byte",
                "auStack_158": "large_stack_array",
                "lStack_100": "large_long_value",
                "sStack_c8": "stat_struct"
            },
            "code": "\n\n\nundefined8 extract_and_process_files_00105570(long file_extraction_info,char **file_list,char process_flag)\n\n{\n  char **extracted_files;\n  undefined undefined_value;\n  byte byte_value;\n  int temp_integer;\n  size_t length;\n  int *error_number;\n  char *temp_pointer;\n  char *temp_pointer_2;\n  undefined8 undefined_value_2;\n  char *current_file;\n  char *basename;\n  long temp_long_1;\n  long temp_long_2;\n  undefined8 return_value;\n  ulong ulong_value;\n  char **current_file_list;\n  char **temp_pointer_3;\n  uint uint_value;\n  char **temp_pointer_4;\n  bool bool_value;\n  byte byte_value_2;\n  byte local_byte;\n  undefined large_stack_array [88];\n  long large_long_value;\n  stat stat_struct;\n  \n  byte_value_2 = 0;\n  extracted_files = (char **)(file_extraction_info + 0xf0);\n  local_byte = 0;\n  if (file_list == (char **)0x0) {\n    return_value = FUN_00102943();\n    return return_value;\n  }\n  do {\n    current_file = *file_list;\njoined_r0x001055aa:\n    if (current_file == (char *)0x0) {\n      if (local_byte != 0) {\n        return_value = FUN_001058b0(file_extraction_info);\n        return return_value;\n      }\n      DAT_0010d618 = 0;\n      return 0;\n    }\n    current_file_list = *(char ***)(file_extraction_info + 0xf0);\n    temp_pointer_3 = extracted_files;\n    if (process_flag != '\\0') {\nLAB_0010564c:\n      uint_value = DAT_0010d640;\n      if (DAT_0010d640 != 0) goto LAB_001028f5;\n      temp_long_2 = *(long *)(file_extraction_info + 0xf0);\n      if (*(long *)(file_extraction_info + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n      do {\n        temp_long_1 = temp_long_2;\n        temp_long_2 = *(long *)(temp_long_1 + 0xf0);\n      } while (temp_long_2 != 0);\n      temp_pointer_3 = (char **)(temp_long_1 + 0xf0);\n      current_file = *file_list;\n      do {\n        if (DAT_0010d620 != 0) {\n          return_value = FUN_00105830(current_file,file_extraction_info);\n          temp_integer = filename_cmp(return_value,\"__.LIBDEP\");\n          if (temp_integer == 0) {\n            byte_value = FUN_00105ae0(temp_pointer_3,DAT_0010d620,DAT_0010d60c != 0,DAT_0010d5f8);\n            local_byte = byte_value | local_byte;\n            goto LAB_0010577e;\n          }\n          current_file = *file_list;\n        }\n        undefined_value = DAT_0010d5f8;\n        bool_value = DAT_0010d60c != 0;\n        temp_long_2 = bfd_openr(current_file,DAT_0010d5f0);\n        if (temp_long_2 != 0) {\n          file_list = file_list + 1;\n          byte_value = FUN_00105af0(temp_pointer_3,temp_long_2,(uint)bool_value,undefined_value);\n          local_byte = local_byte | byte_value;\n          current_file = *file_list;\n          goto joined_r0x001055aa;\n        }\n        FUN_00107c10(current_file,0);\n        uint_value = (uint)bool_value;\nLAB_001028f5:\n        return_value = DAT_0010d638;\n        if (uint_value == 3) {\n          temp_long_2 = *(long *)(file_extraction_info + 0xf0);\n          if (*(long *)(file_extraction_info + 0xf0) != 0) goto LAB_00105670;\n        }\n        else {\n          for (; (undefined8 *)*temp_pointer_3 != (undefined8 *)0x0;\n              temp_pointer_3 = (char **)(*temp_pointer_3 + 0xf0)) {\n            temp_integer = filename_cmp(*(undefined8 *)*temp_pointer_3,return_value);\n            if (temp_integer == 0) {\n              if (uint_value == 2) {\n                temp_pointer_3 = (char **)(*temp_pointer_3 + 0xf0);\n              }\n              break;\n            }\n          }\n        }\nLAB_0010571f:\n        current_file = *file_list;\n      } while( true );\n    }\n    temp_pointer_4 = extracted_files;\n    if (current_file_list == (char **)0x0) {\n      uint_value = DAT_0010d640;\n      if (DAT_0010d640 == 0) goto LAB_0010571f;\n      goto LAB_001028f5;\n    }\nLAB_001055d8:\n    if (DAT_0010d5f9 == '\\0') {\n      current_file = (char *)lbasename(*current_file_list);\n      temp_pointer_2 = current_file;\n      if (DAT_0010d5fa != '\\0') {\n        length = strlen(current_file);\n        ulong_value = (ulong)*(byte *)(*(long *)(file_extraction_info + 8) + 0x1e);\n        if (ulong_value < length) {\n          temp_pointer_2 = (char *)xmalloc(ulong_value + 1);\n          temp_long_2 = *(long *)(file_extraction_info + 8);\n          temp_pointer = temp_pointer_2;\n          for (ulong_value = (ulong)*(byte *)(temp_long_2 + 0x1e); ulong_value != 0; ulong_value = ulong_value - 1) {\n            *temp_pointer = *current_file;\n            current_file = current_file + (ulong)byte_value_2 * -2 + 1;\n            temp_pointer = temp_pointer + (ulong)byte_value_2 * -2 + 1;\n          }\n          temp_pointer_2[*(byte *)(temp_long_2 + 0x1e)] = '\\0';\n        }\n        temp_pointer = *file_list;\n        current_file = temp_pointer_2;\n        if (DAT_0010d5f9 == '\\0') goto LAB_00105611;\n        goto LAB_00102980;\n      }\n      temp_pointer = *file_list;\n      if (DAT_0010d5f9 != '\\0') goto LAB_00102980;\nLAB_00105611:\n      basename = (char *)lbasename(temp_pointer);\n      if (DAT_0010d5fa != '\\0') {\n        length = strlen(basename);\n        ulong_value = (ulong)*(byte *)(*(long *)(file_extraction_info + 8) + 0x1e);\n        temp_pointer = basename;\n        current_file = temp_pointer_2;\n        if (ulong_value < length) {\n          temp_pointer = (char *)xmalloc(ulong_value + 1);\n          temp_long_2 = *(long *)(file_extraction_info + 8);\n          temp_pointer_2 = temp_pointer;\n          for (ulong_value = (ulong)*(byte *)(temp_long_2 + 0x1e); ulong_value != 0; ulong_value = ulong_value - 1) {\n            *temp_pointer_2 = *basename;\n            basename = basename + (ulong)byte_value_2 * -2 + 1;\n            temp_pointer_2 = temp_pointer_2 + (ulong)byte_value_2 * -2 + 1;\n          }\n          temp_pointer[*(byte *)(temp_long_2 + 0x1e)] = '\\0';\n        }\n        goto LAB_00102980;\n      }\n      temp_integer = filename_cmp(basename,temp_pointer_2);\n      if (temp_integer == 0) goto LAB_00102993;\nLAB_00105639:\n      temp_pointer_4 = current_file_list + 0x1e;\n      current_file_list = (char **)current_file_list[0x1e];\n      if (current_file_list == (char **)0x0) goto LAB_0010564c;\n      goto LAB_001055d8;\n    }\n    temp_pointer = *file_list;\n    current_file = *current_file_list;\nLAB_00102980:\n    temp_integer = filename_cmp(temp_pointer,current_file);\n    if (temp_integer != 0) goto LAB_00105639;\nLAB_00102993:\n    if (current_file_list[0x1c] == (char *)0x0) goto LAB_00105639;\n    if (_DAT_0010d644 != 0) {\n      temp_integer = stat(*file_list,&stat_struct);\n      if (temp_integer != 0) {\n        error_number = __errno_location();\n        if (*error_number != 2) {\n          FUN_00107c10(*file_list);\nLAB_00102b7e:\n          current_file = *current_file_list;\n          return_value = dcgettext(0,\"internal stat error on %s\",5);\n          FUN_00107690(return_value,current_file);\n          free(file_list);\n          return 0;\n        }\n        goto LAB_0010577e;\n      }\n      temp_pointer_3 = (char **)current_file_list[0x1d];\n      if ((char **)current_file_list[0x1d] == (char **)0x0) {\n        temp_pointer_3 = current_file_list;\n      }\n      temp_integer = (**(code **)(temp_pointer_3[1] + 0x1e8))(current_file_list,large_stack_array);\n      if (temp_integer != 0) goto LAB_00102b7e;\n      if (stat_struct.st_mtim.tv_sec <= large_long_value) goto LAB_0010577e;\n    }\n    return_value = FUN_00105870(extracted_files,2,*current_file_list);\n    if (DAT_0010d620 == 0) {\nLAB_00102ae2:\n      current_file = *file_list;\n      bool_value = DAT_0010d60c != 0;\n      temp_long_2 = bfd_openr(current_file,DAT_0010d5f0);\n      if (temp_long_2 == 0) {\n        FUN_00107c10(current_file,0);\n        goto LAB_00102b3e;\n      }\n      byte_value = FUN_00103172(return_value,temp_long_2,bool_value);\n    }\n    else {\n      undefined_value_2 = FUN_00105830(*file_list,file_extraction_info);\n      temp_integer = filename_cmp(undefined_value_2,\"__.LIBDEP\");\n      if (temp_integer != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n      byte_value = FUN_00103172(return_value,DAT_0010d620,DAT_0010d60c != 0);\n    }\n    if (byte_value != 0) {\n      *temp_pointer_4 = *(char **)(*temp_pointer_4 + 0xf0);\n      local_byte = byte_value;\n    }\nLAB_0010577e:\n    file_list = file_list + 1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00102943"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105570",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_and_process_files_00105570"
        }
    },
    "used_tokens": 80593,
    "layers": [
        [
            "FUN_00102cd9",
            "FUN_001079c0",
            "FUN_00105a68",
            "FUN_001032a8",
            "FUN_0010285f",
            "FUN_00102f96",
            "FUN_0010342d",
            "FUN_0010394a",
            "FUN_00107920",
            "FUN_00105bb0",
            "FUN_00107640",
            "FUN_00102e6f",
            "FUN_0010315d",
            "FUN_00107890",
            "FUN_001033d6",
            "FUN_00103172",
            "FUN_00105870",
            "FUN_001030ed",
            "FUN_00105bc0",
            "FUN_00107650",
            "FUN_00102f1e",
            "FUN_00102fd7",
            "FUN_00103ba8",
            "FUN_00103ddc",
            "FUN_001078c0",
            "FUN_001075e0",
            "FUN_00105480",
            "FUN_001031a5",
            "FUN_00103df9",
            "FUN_00103a78",
            "FUN_001058b0",
            "FUN_00102bf5",
            "FUN_00102020",
            "FUN_00102943",
            "FUN_00107c80",
            "FUN_00105a20",
            "FUN_00102f55",
            "FUN_001057a0",
            "FUN_00102d8c",
            "FUN_00105300",
            "FUN_00105db0",
            "FUN_00103bd1",
            "FUN_00107c10",
            "FUN_00102710",
            "FUN_00103e95",
            "FUN_00107cc0",
            "FUN_00105ae0",
            "FUN_00107690",
            "FUN_0010266f",
            "FUN_00105830",
            "FUN_00107730",
            "FUN_00107c20",
            "FUN_001031cf",
            "FUN_0010312d",
            "FUN_00105c00",
            "FUN_001052a0",
            "FUN_0010336b",
            "FUN_00103c60",
            "FUN_00102e57",
            "FUN_00105af0",
            "FUN_0010300e",
            "FUN_00102ba1",
            "FUN_00107740",
            "FUN_00102d2f",
            "FUN_001028ed",
            "FUN_001033b0",
            "FUN_001025a0",
            "FUN_0010284b",
            "FUN_00102c25",
            "FUN_00102bb0",
            "FUN_00102f08",
            "FUN_00105570"
        ]
    ],
    "locked_functions": []
}