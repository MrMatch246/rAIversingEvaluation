{
    "functions": {
        "bfd_fdopenr": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenr(void)\n\n{\n  bfd_fdopenr();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_fdopenr"
        },
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "FUN_00102cd9": {
            "renaming": {
                "FUN_00102cd9": "find_matching_filename_00102cd9",
                "in_EAX": "counter",
                "iVar1": "comparisonResult",
                "unaff_RBX": "currentPtr",
                "param_7": "filenameToFind"
            },
            "code": "\nlong * findMatchingFilename_00102cd9(void)\n\n{\n  int counter;\n  int comparisonResult;\n  long *currentPtr;\n  undefined8 filenameToFind;\n  \n  filenameToFind = DAT_0010d638;\n  if (counter == 3) {\n    for (; *currentPtr != 0; currentPtr = (long *)(*currentPtr + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*currentPtr != (undefined8 *)0x0; currentPtr = (long *)(*currentPtr + 0xf0)) {\n      comparisonResult = filename_cmp(*(undefined8 *)*currentPtr,filenameToFind);\n      if (comparisonResult == 0) {\n        if (counter != 2) {\n          return currentPtr;\n        }\n        return (long *)(*currentPtr + 0xf0);\n      }\n    }\n  }\n  return currentPtr;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102cd9",
            "calling": [
                "FUN_00105870"
            ],
            "imported": false,
            "current_name": "find_matching_filename_00102cd9"
        },
        "bfd_close": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102490",
            "calling": [
                "FUN_00105300",
                "FUN_00102d2f",
                "FUN_00105db0",
                "FUN_00102710",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_close"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_0010d400 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_0010d2c8);\n  FUNC_00105cf0();\n  DAT_0010d400 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00105cf0",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105d60",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "lbasename": {
            "renaming": {},
            "code": "\nvoid lbasename(void)\n\n{\n  lbasename();\n  return;\n}\n\n",
            "called": [
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "FUN_00105830",
                "FUN_00105db0",
                "FUN_00102e6f",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "lbasename"
        },
        "bfd_bread": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102540",
            "calling": [
                "FUN_00103a78",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "bfd_bread"
        },
        "FUN_001079c0": {
            "renaming": {
                "FUN_001079c0": "print_file_info_001079c0",
                "param_1": "file",
                "param_2": "args",
                "param_3": "isVerbose",
                "param_4": "showAddress",
                "iVar1": "result",
                "ppcVar2": "funcPtr",
                "pcVar3": "timestamp",
                "uVar4": "filePermissions",
                "local_100": "currentTime",
                "uStack_f3": "fileType",
                "cStack_f2": "isSetuid",
                "cStack_f1": "isSetgid",
                "cStack_f0": "isSticky",
                "cStack_ef": "isOwnerRead",
                "cStack_ee": "isOwnerWrite",
                "cStack_ed": "isOwnerExecute",
                "cStack_ec": "isGroupRead",
                "cStack_eb": "isGroupWrite",
                "cStack_ea": "isGroupExecute",
                "local_e8": "formattedTimestamp",
                "local_b8": "buffer",
                "uStack_a0": "fileSize",
                "uStack_9c": "majorDevice",
                "uStack_98": "minorDevice",
                "uStack_88": "inodeNumber",
                "local_60": "lastModified",
                "(ulong)uStack_9c": "majorDeviceNumber",
                "(ulong)uStack_98": "minorDeviceNumber"
            },
            "code": "\nvoid printFileInfo_001079c0(FILE *file,char **args,char isVerbose,char showAddress)\n\n{\n  int result;\n  char **funcPtr;\n  char *timestamp;\n  uint filePermissions;\n  time_t currentTime;\n  undefined fileType;\n  char isSetuid;\n  char isSetgid;\n  char isSticky;\n  char isOwnerRead;\n  char isOwnerWrite;\n  char isOwnerExecute;\n  char isGroupRead;\n  char isGroupWrite;\n  char isGroupExecute;\n  undefined uStack_e9;\n  char formattedTimestamp [48];\n  undefined buffer [24];\n  uint fileSize;\n  uint majorDevice;\n  uint minorDevice;\n  undefined8 inodeNumber;\n  time_t lastModified;\n  \n  if (isVerbose != '\\0') {\n    funcPtr = (char **)args[0x1d];\n    if ((char **)args[0x1d] == (char **)0x0) {\n      funcPtr = args;\n    }\n    result = (**(code **)(funcPtr[1] + 0x1e8))(args,buffer);\n    if (result == 0) {\n      currentTime = lastModified;\n      timestamp = ctime(&currentTime);\n      if (timestamp == (char *)0x0) {\n        timestamp = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(formattedTimestamp,timestamp);\n      }\n      else {\n        sprintf(formattedTimestamp,\"%.12s %.4s\",timestamp + 4);\n      }\n      filePermissions = fileSize & 0xf000;\n      if (filePermissions == 0x4000) {\n        fileType = 100;\n      }\n      else if (filePermissions == 0xa000) {\n        fileType = 0x6c;\n      }\n      else if (filePermissions == 0x6000) {\n        fileType = 0x62;\n      }\n      else if (filePermissions == 0x2000) {\n        fileType = 99;\n      }\n      else if (filePermissions == 0xc000) {\n        fileType = 0x73;\n      }\n      else {\n        fileType = 0x70;\n        if (filePermissions != 0x1000) {\n          fileType = 0x2d;\n        }\n      }\n      isSetuid = (-((fileSize & 0x100) == 0) & 0xbbU) + 0x72;\n      isSetgid = (-((fileSize & 0x80) == 0) & 0xb6U) + 0x77;\n      isSticky = (-((fileSize & 0x40) == 0) & 0xb5U) + 0x78;\n      isOwnerRead = (-((fileSize & 0x20) == 0) & 0xbbU) + 0x72;\n      isOwnerWrite = (-((fileSize & 0x10) == 0) & 0xb6U) + 0x77;\n      isOwnerExecute = (-((fileSize & 8) == 0) & 0xb5U) + 0x78;\n      isGroupRead = (-((fileSize & 4) == 0) & 0xbbU) + 0x72;\n      isGroupWrite = (-((fileSize & 2) == 0) & 0xb6U) + 0x77;\n      isGroupExecute = (-((fileSize & 1) == 0) & 0xb5U) + 0x78;\n      if ((fileSize & 0x800) != 0) {\n        if (isSticky == 'x') {\n          isSticky = 's';\n        }\n        else {\n          isSticky = 'S';\n        }\n      }\n      if ((fileSize & 0x400) != 0) {\n        if (isOwnerExecute == 'x') {\n          isOwnerExecute = 's';\n        }\n        else {\n          isOwnerExecute = 'S';\n        }\n      }\n      if ((fileSize & 0x200) != 0) {\n        if (isGroupExecute == 'x') {\n          isGroupExecute = 't';\n        }\n        else {\n          isGroupExecute = 'T';\n        }\n      }\n      uStack_e9 = 0;\n      fprintf(file,\"%s %ld/%ld %6lu %s \",&isSetuid,majorDeviceNumber,minorDeviceNumber,inodeNumber,\n              formattedTimestamp,(ulong)fileSize);\n    }\n  }\n  fputs(*args,file);\n  if (showAddress != '\\0') {\n    if ((*(byte *)((long)args + 0x49) & 0x10) == 0) {\n      if (args[0xb] != (char *)0x0) {\n        fprintf(file,\" 0x%lx\");\n      }\n    }\n    else if (args[0xc] != (char *)0x0) {\n      fprintf(file,\" 0x%lx\");\n    }\n  }\n  fputc(10,file);\n  return;\n}\n\n",
            "called": [
                "ctime",
                "FUN_00102d8c",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001079c0",
            "calling": [
                "FUN_00103ddc",
                "FUN_00107890"
            ],
            "imported": false,
            "current_name": "print_file_info_001079c0"
        },
        "FUN_00105a68": {
            "renaming": {
                "FUN_00105a68": "write_to_file_00105a68",
                "pcVar1": "filePath",
                "pFVar2": "filePointer",
                "sVar3": "filePathLength"
            },
            "code": "\nvoid writeToFile_00105a68(void)\n\n{\n  char *filePath;\n  FILE *filePointer;\n  size_t filePathLength;\n  \n  filePath = DAT_0010d5e8;\n  if (DAT_0010d5e8 != (char *)0x0) {\n    filePathLength = strlen(DAT_0010d5e8);\n    if (filePathLength != 0) {\n      if (filePath[filePathLength - 1] == '/') {\n        DAT_0010d618 = (char *)concat(filePath,DAT_0010d618,0);\n      }\n      else {\n        DAT_0010d618 = (char *)concat(filePath,&DAT_00108260,DAT_0010d618,0);\n      }\n    }\n  }\n  if (DAT_0010d60c != 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  filePointer = fopen(DAT_0010d618,\"w\");\n  if (filePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "perror",
                "concat",
                "printf",
                "fopen",
                "strlen",
                "xexit",
                "FUN_00102e57"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a68",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "write_to_file_00105a68"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "FUN_001032a8": {
            "renaming": {
                "FUN_001032a8": "extract_files_from_archive_001032a8",
                "param_1": "archive",
                "param_2": "fileCallback",
                "param_3": "entries",
                "param_4": "result",
                "lVar1": "nextEntry",
                "uVar2": "currentEntry",
                "bVar3": "entryFound",
                "plVar4": "currentEntryPtr",
                "iVar5": "cmpResult",
                "__format": "errorMsgFormat",
                "plVar6": "nextEntryPtr",
                "lVar7": "currentEntryIndex",
                "plVar8": "prevEntryPtr"
            },
            "code": "\n\n\nundefined8 extractFilesFromArchive_001032a8(long *archive,code *fileCallback,undefined8 *entries,undefined8 result)\n\n{\n  long nextEntry;\n  undefined8 currentEntry;\n  bool entryFound;\n  long *currentEntryPtr;\n  int cmpResult;\n  char *errorMsgFormat;\n  long *nextEntryPtr;\n  long currentEntryIndex;\n  long *prevEntryPtr;\n  \n  currentEntryIndex = archive[0x1e];\n  if (entries == (undefined8 *)0x0) {\n    while (currentEntryIndex != 0) {\n      nextEntry = *(long *)(currentEntryIndex + 0xf0);\n      (*fileCallback)(currentEntryIndex,0);\n      currentEntryIndex = nextEntry;\n    }\n  }\n  else {\n    do {\n      entryFound = false;\n      currentEntryPtr = (long *)archive[0x1e];\n      prevEntryPtr = archive;\n      while (nextEntryPtr = currentEntryPtr, nextEntryPtr != (long *)0x0) {\n        if (*nextEntryPtr != 0) {\n          cmpResult = filename_cmp(*entries);\n          if (cmpResult == 0) {\n            entryFound = true;\n            (*fileCallback)(nextEntryPtr,prevEntryPtr);\n          }\n        }\n        prevEntryPtr = nextEntryPtr;\n        currentEntryPtr = (long *)nextEntryPtr[0x1e];\n      }\n      if (!entryFound) {\n        currentEntry = *entries;\n        errorMsgFormat = (char *)dcgettext(0,\"No entry %s in archive.\\n\",5);\n        fprintf(_stderr,errorMsgFormat,currentEntry);\n      }\n      entries = (undefined8 *)entries[1];\n    } while (entries != (undefined8 *)0x0);\n  }\n  return result;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001032a8",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "extract_files_from_archive_001032a8"
        },
        "FUN_0010285f": {
            "renaming": {
                "FUN_0010285f": "print_archive_entry_not_found_0010285f",
                "__format": "messageFormat",
                "lVar2": "currentEntry",
                "plVar3": "nextEntry",
                "uVar4": "currentEntryName",
                "plVar5": "entryList",
                "unaff_RBP": "functionPointer",
                "unaff_R12": "basePointer",
                "unaff_R13D": "remainingIterations",
                "unaff_R14": "entryNamesList",
                "iStack000000000000000c": "counter"
            },
            "code": "\n\n\nvoid printArchiveEntryNotFound_0010285f(void)\n\n{\n  int iVar1;\n  char *messageFormat;\n  long currentEntry;\n  long *nextEntry;\n  undefined8 currentEntryName;\n  long *entryList;\n  code *functionPointer;\n  long basePointer;\n  int remainingIterations;\n  undefined8 *entryNamesList;\n  int counter;\n  \ncode_r0x0010285f:\n  currentEntryName = *entryNamesList;\n  messageFormat = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n  fprintf(_stderr,messageFormat,currentEntryName);\nLAB_0010553e:\n  entryNamesList = entryNamesList + 1;\n  remainingIterations = remainingIterations + -1;\n  if (remainingIterations == 0) {\n    return;\n  }\n  entryList = *(long **)(basePointer + 0xf0);\n  counter = 0;\n  do {\n    if (entryList == (long *)0x0) goto code_r0x0010285f;\n    if (*(int *)((long)entryList + 0xac) == 0) {\n      currentEntry = *entryList;\n      if (currentEntry == 0) {\n        nextEntry = (long *)entryList[0x1d];\n        if ((long *)entryList[0x1d] == (long *)0x0) {\n          nextEntry = entryList;\n        }\n        (**(code **)(nextEntry[1] + 0x1e8))(entryList,&stack0x00000010);\n      }\n      else if (((*(byte *)(basePointer + 0x49) & 0x10) == 0) || (currentEntry = FUN_00105830(), currentEntry != 0))\n      {\n        currentEntryName = FUN_00105830(*entryNamesList);\n        iVar1 = filename_cmp(currentEntryName,currentEntry);\n        if ((iVar1 == 0) &&\n           ((DAT_0010d634 == '\\0' ||\n            (counter = counter + 1,\n            counter == _DAT_0010d630)))) break;\n      }\n    }\n    entryList = (long *)entryList[0x1e];\n  } while( true );\n  (*functionPointer)();\n  *(undefined4 *)((long)entryList + 0xac) = 1;\n  goto LAB_0010553e;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010285f",
            "calling": [
                "FUN_00105480"
            ],
            "imported": false,
            "current_name": "print_archive_entry_not_found_0010285f"
        },
        "bfd_set_archive_head": {
            "renaming": {},
            "code": "\nvoid bfd_set_archive_head(void)\n\n{\n  bfd_set_archive_head();\n  return;\n}\n\n",
            "called": [
                "bfd_set_archive_head"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "bfd_set_archive_head"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "FUN_00102bb0",
                "FUN_001057a0",
                "FUN_00103a78",
                "FUN_00105db0",
                "FUN_001028ed",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "vfprintf": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024b0",
            "calling": [
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "vfprintf"
        },
        "FUN_00102f96": {
            "renaming": {
                "FUN_00102f96": "print_error_message_00102f96",
                "unaff_RBX": "errorCode",
                "unaff_retaddr": "returnAddress",
                "uVar1": "errorMessage",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printErrorMessage_00102f96(void)\n\n{\n  undefined8 errorMessage;\n  long errorCode;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(standardOutput);\n  if (errorCode != 0) {\n    fprintf(standardError,\"%s: %s: %s\\n\",DAT_0010d660);\n    return;\n  }\n  fprintf(standardError,\"%s: %s\\n\",DAT_0010d660,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f96",
            "calling": [
                "FUN_00107c20"
            ],
            "imported": false,
            "current_name": "print_error_message_00102f96"
        },
        "FUN_0010342d": {
            "renaming": {
                "FUN_0010342d": "print_usage_0010342d",
                "param_1": "isVerbose",
                "uVar1": "version",
                "pcVar2": "message",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid printUsage_0010342d(uint isVerbose)\n\n{\n  undefined8 version;\n  char *message;\n  FILE *outputStream;\n  \n  message = (char *)dcgettext(0,\n                             \"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV] [--plugin <name>] [member-name] [count] archive-file file...\\n\"\n                             ,5);\n  outputStream = _stderr;\n  if (isVerbose != 0) {\n    outputStream = _stdout;\n  }\n  fprintf(outputStream,message,DAT_0010d660);\n  version = DAT_0010d660;\n  message = (char *)dcgettext(0,\"       %s -M [<mri-script]\\n\",5);\n  fprintf(outputStream,message,version);\n  message = (char *)dcgettext(0,\" commands:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  d            - delete file(s) from the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  m[ab]        - move file(s) in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  p            - print file(s) found in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  q[f]         - quick append file(s) to the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  s            - act as ranlib\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  t[O][v]      - display contents of the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  x[o]         - extract file(s) from the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" command specific modifiers:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [a]          - put file(s) after [member-name]\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [b]          - put file(s) before [member-name] (same as [i])\\n\",5\n                            );\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [D]          - use zero for timestamps and uids/gids (default)\\n\",\n                             5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [U]          - use actual timestamps and uids/gids\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [N]          - use instance [count] of name\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [f]          - truncate inserted file names\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [P]          - use full path names when matching\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [o]          - preserve original dates\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [O]          - display offsets of files in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  [u]          - only replace files that are newer than current archive contents\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" generic modifiers:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [c]          - do not warn if the library had to be created\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [s]          - create an archive index (cf. ranlib)\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [l <text> ]  - specify the dependencies of this library\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [S]          - do not build a symbol table\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [T]          - deprecated, use --thin instead\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [v]          - be verbose\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [V]          - display the version number\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  @<file>      - read options from <file>\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --target=BFDNAME - specify the target object format as BFDNAME\\n\",\n                             5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  --output=DIRNAME - specify the output directory for extraction operations\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  --record-libdeps=<text> - specify the dependencies of this library\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --thin       - make a thin archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" optional:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --plugin <p> - load the specified plugin\\n\",5);\n  fprintf(outputStream,message);\n  FUN_0010336b(outputStream);\n  FUN_0010266f(DAT_0010d660,outputStream);\n  if (isVerbose != 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(isVerbose ^ 1);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_0010336b",
                "fprintf",
                "FUN_0010266f",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010342d",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_usage_0010342d"
        },
        "FUN_0010394a": {
            "renaming": {
                "FUN_0010394a": "print_usage_0010394a",
                "param_1": "isError",
                "uVar1": "defaultTimestamp",
                "__stream": "outputFile",
                "pcVar2": "message",
                "fprintf": "printMessage",
                "dcgettext": "getMessage",
                "xexit": "exitProgram"
            },
            "code": "\n\n\nvoid printUsage_0010394a(uint isError)\n\n{\n  undefined8 defaultTimestamp;\n  char *message;\n  FILE *outputFile;\n  \n  defaultTimestamp = DAT_0010d660;\n  outputFile = _stderr;\n  if (isError != 0) {\n    outputFile = _stdout;\n  }\n  message = (char *)dcgettext(0,\"Usage: %s [options] archive\\n\",5);\n  fprintf(outputFile,message,defaultTimestamp);\n  message = (char *)dcgettext(0,\" Generate an index to speed access to archives\\n\",5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \" The options are:\\n  @<file>                      Read options from <file>\\n\"\n                             ,5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\"  --plugin <name>              Load the specified plugin\\n\",5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \"  -D                           Use zero for symbol map timestamp (default)\\n  -U                           Use an actual symbol map timestamp\\n\"\n                             ,5);\n  fprintf(outputFile,message);\n  message = (char *)dcgettext(0,\n                             \"  -t                           Update the archive\\'s symbol map timestamp\\n  -h --help                    Print this help message\\n  -v --version                 Print version information\\n\"\n                             ,5);\n  fprintf(outputFile,message);\n  FUN_0010266f(DAT_0010d660,outputFile);\n  if (isError != 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputFile,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(isError ^ 1);\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf",
                "FUN_0010266f",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010394a",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_usage_0010394a"
        },
        "FUN_00107920": {
            "renaming": {
                "FUN_00107920": "initialize_data_00107920",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "param_5": "arg5",
                "param_6": "arg6",
                "param_7": "arg7",
                "param_8": "arg8",
                "param_9": "input1",
                "param_10": "input2",
                "param_11": "input3",
                "param_12": "input4",
                "param_13": "input5",
                "param_14": "input6",
                "in_AL": "flag",
                "local_d8": "size",
                "local_d4": "constant",
                "local_d0": "pointer1",
                "local_c8": "pointer2",
                "local_b8": "buffer",
                "local_b0": "address1",
                "local_a8": "address2",
                "local_a0": "address3",
                "local_98": "address4",
                "local_90": "address5",
                "local_88": "local1",
                "local_78": "local2",
                "local_68": "local3",
                "local_58": "local4",
                "local_48": "local5",
                "local_38": "local6",
                "local_28": "local7",
                "local_18": "local8"
            },
            "code": "\nvoid initializeData_00107920(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4,\n                 undefined4 arg5,undefined4 arg6,undefined4 arg7,undefined4 arg8,\n                 undefined8 input1,undefined8 input2,undefined8 input3,undefined8 input4,\n                 undefined8 input5,undefined8 input6)\n\n{\n  char flag;\n  undefined4 size;\n  undefined4 constant;\n  undefined *pointer1;\n  undefined *pointer2;\n  undefined buffer [8];\n  undefined8 address1;\n  undefined8 address2;\n  undefined8 address3;\n  undefined8 address4;\n  undefined8 address5;\n  undefined4 local1;\n  undefined4 local2;\n  undefined4 local3;\n  undefined4 local4;\n  undefined4 local5;\n  undefined4 local6;\n  undefined4 local7;\n  undefined4 local8;\n  \n  if (flag != '\\0') {\n    local1 = arg1;\n    local2 = arg2;\n    local3 = arg3;\n    local4 = arg4;\n    local5 = arg5;\n    local6 = arg6;\n    local7 = arg7;\n    local8 = arg8;\n  }\n  pointer1 = &stack0x00000008;\n  size = 8;\n  pointer2 = buffer;\n  constant = 0x30;\n  address1 = input2;\n  address2 = input3;\n  address3 = input4;\n  address4 = input5;\n  address5 = input6;\n  FUN_001078c0(input1,&size);\n  return;\n}\n\n",
            "called": [
                "FUN_001078c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107920",
            "calling": [
                "FUN_001025a0",
                "FUN_00105300",
                "FUN_00102fd7",
                "FUN_00102f1e",
                "FUN_00105db0",
                "FUN_001052a0",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "initialize_data_00107920"
        },
        "ctime": {
            "renaming": {},
            "code": "\n\n\nchar * ctime(time_t *__timer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = ctime(__timer);\n  return pcVar1;\n}\n\n",
            "called": [
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "ctime"
        },
        "bfd_set_default_target": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_default_target"
        },
        "bfd_get_error": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_00107c20"
            ],
            "imported": false,
            "current_name": "bfd_get_error"
        },
        "bfd_fdopenw": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102570",
            "calling": [
                "FUN_001058b0",
                "FUN_00103c60"
            ],
            "imported": false,
            "current_name": "bfd_fdopenw"
        },
        "write": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "write"
        },
        "FUN_00105bb0": {
            "renaming": {
                "FUN_00105bb0": "get_one_00105bb0",
                "undefined8": "uint64_t"
            },
            "code": "\nuint64_t getOne_00105bb0(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bb0",
            "calling": [],
            "imported": false,
            "current_name": "get_one_00105bb0"
        },
        "FUN_00107640": {
            "renaming": {
                "FUN_00107640": "initialize_00107640"
            },
            "code": "\nundefined8 initialize_00107640(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107640",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "initialize_00107640"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102590",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "FUN_00102e6f": {
            "renaming": {
                "FUN_00102e6f": "extract_file_path_00102e6f",
                "pcVar1": "currentPath",
                "in_RAX": "filePath",
                "uVar2": "baseName",
                "uVar3": "errorMessage",
                "pFVar4": "filePtr",
                "sVar5": "pathLength",
                "pcVar6": "tempPath"
            },
            "code": "\nvoid extractFilePath_00102e6f(void)\n\n{\n  char *currentPath;\n  char *filePath;\n  undefined8 baseName;\n  undefined8 errorMessage;\n  FILE *filePtr;\n  size_t pathLength;\n  char *tempPath;\n  \n  currentPath = DAT_0010d5e8;\n  do {\n    filePath = filePath + 1;\n    while (*filePath != '/') {\n      if (*filePath == '\\0') {\n        if ((DAT_0010d5e8 != (char *)0x0) && (pathLength = strlen(DAT_0010d5e8), pathLength != 0)) {\n          if (currentPath[pathLength - 1] == '/') {\n            DAT_0010d618 = (char *)concat(currentPath,DAT_0010d618,0);\n          }\n          else {\n            DAT_0010d618 = (char *)concat(currentPath,&DAT_00108260,DAT_0010d618,0);\n          }\n        }\n        if (DAT_0010d60c != 0) {\n          printf(\"x - %s\\n\",DAT_0010d618);\n        }\n        filePtr = fopen(DAT_0010d618,\"w\");\n        if (filePtr == (FILE *)0x0) {\n          perror(DAT_0010d618);\n                    \n          xexit(1);\n        }\n        return;\n      }\n      tempPath = filePath;\n      if ((*filePath == '.') && (tempPath = filePath + 1, filePath[1] == '.')) {\n        tempPath = filePath + 2;\n        if ((filePath[2] == '/') || (filePath[2] == '\\0')) {\n          baseName = lbasename();\n          currentPath = DAT_0010d618;\n          errorMessage = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\"\n                            ,5);\n          FUN_00107920(errorMessage,currentPath,baseName);\n          DAT_0010d618 = (char *)baseName;\n          FUN_00105a68();\n          return;\n        }\n      }\n      for (; (filePath = tempPath, *tempPath != '\\0' && (*tempPath != '/')); tempPath = tempPath + 1) {\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00107920",
                "lbasename",
                "FUN_00105a68",
                "FUN_00102e6f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e6f",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "extract_file_path_00102e6f"
        },
        "FUN_0010315d": {
            "renaming": {
                "FUN_0010315d": "check_if_initialized_0010315d",
                "xexit": "exitGracefully"
            },
            "code": "\n\n\nvoid checkIfInitialized_0010315d(void)\n\n{\n  if (_DAT_0010d608 == 0) {\n                    \n    xexit(9);\n  }\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010315d",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_if_initialized_0010315d"
        },
        "textdomain": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "textdomain"
        },
        "concat": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_00105a68",
                "FUN_00102e57"
            ],
            "imported": false,
            "current_name": "concat"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "FUN_00107890": {
            "renaming": {
                "FUN_00107890": "print_with_flags_00107890",
                "param_1": "message",
                "_stdout": "outputStream"
            },
            "code": "\n\n\nvoid printWithFlags_00107890(undefined8 message)\n\n{\n  FUN_001079c0(outputStream,message,DAT_0010d60c != 0,_DAT_0010d5fc != 0);\n  return;\n}\n\n",
            "called": [
                "FUN_001079c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107890",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_with_flags_00107890"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102500",
            "calling": [
                "FUN_001033b0",
                "FUN_001075e0"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "bfd_check_format": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102520",
            "calling": [
                "FUN_00105af0",
                "FUN_00103c60",
                "FUN_00102710"
            ],
            "imported": false,
            "current_name": "bfd_check_format"
        },
        "FUN_001033d6": {
            "renaming": {
                "FUN_001033d6": "create_buffer_001033d6",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "pvVar1": "buffer",
                "pvVar2": "dynamicMemory",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16]\ncreateBuffer_001033d6(undefined8 input1,undefined8 input2,undefined8 input3,undefined8 input4)\n\n{\n  void *buffer;\n  void *dynamicMemory;\n  undefined returnValue [16];\n  \n  buffer = malloc(0x40);\n  if (buffer != (void *)0x0) goto LAB_001033f7;\n  do {\n    buffer = (void *)FUN_001033b0(\"out of dynamic memory in yy_create_buffer()\");\nLAB_001033f7:\n    *(undefined4 *)((long)buffer + 0x18) = 0x4000;\n    dynamicMemory = malloc(0x4002);\n    *(void **)((long)buffer + 8) = dynamicMemory;\n  } while (dynamicMemory == (void *)0x0);\n  *(undefined4 *)((long)buffer + 0x20) = 1;\n  FUN_001031cf(buffer,input1);\n  returnValue._8_8_ = input4;\n  returnValue._0_8_ = buffer;\n  return returnValue;\n}\n\n",
            "called": [
                "malloc",
                "FUN_001033b0",
                "FUN_001031cf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033d6",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "create_buffer_001033d6"
        },
        "fileno": {
            "renaming": {},
            "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "FUN_00105db0",
                "FUN_001031cf"
            ],
            "imported": false,
            "current_name": "fileno"
        },
        "FUN_00103172": {
            "renaming": {
                "FUN_00103172": "copy_string_to_param_00103172",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "copyConditional",
                "param_4": "paramValue",
                "uVar1": "valueToCopy",
                "auVar2": "resultBuffer"
            },
            "code": "\nundefined  [16]\ncopyStringToParam_00103172(undefined8 *source,undefined8 *destination,char copyConditional,undefined8 paramValue)\n\n{\n  undefined8 valueToCopy;\n  undefined resultBuffer [16];\n  \n  if (copyConditional != '\\0') {\n    printf(\"r - %s\\n\",*destination);\n  }\n  valueToCopy = *source;\n  destination[0x1e] = valueToCopy;\n  resultBuffer._1_7_ = (undefined7)((ulong)valueToCopy >> 8);\n  resultBuffer[0] = 1;\n  *source = destination;\n  resultBuffer._8_8_ = paramValue;\n  return resultBuffer;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103172",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "copy_string_to_param_00103172"
        },
        "FUN_00105870": {
            "renaming": {
                "FUN_00105870": "find_matching_function_00105870",
                "param_1": "list",
                "param_2": "searchType",
                "param_3": "searchValue",
                "iVar1": "comparisonResult",
                "iVar3": "loopType",
                "uVar2": "searchCriteria"
            },
            "code": "\nlong * findMatchingFunction_00105870(long *list,int searchType,undefined8 searchValue)\n\n{\n  int comparisonResult;\n  undefined8 searchCriteria;\n  int loopType;\n  \n  searchCriteria = DAT_0010d638;\n  loopType = DAT_0010d640;\n  if (DAT_0010d640 == 0) {\n    searchCriteria = searchValue;\n    loopType = searchType;\n  }\n  if (loopType == 3) {\n    for (; *list != 0; list = (long *)(*list + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*list != (undefined8 *)0x0; list = (long *)(*list + 0xf0)) {\n      comparisonResult = filename_cmp(*(undefined8 *)*list,searchCriteria);\n      if (comparisonResult == 0) {\n        if (loopType != 2) {\n          return list;\n        }\n        return (long *)(*list + 0xf0);\n      }\n    }\n  }\n  return list;\n}\n\n",
            "called": [
                "FUN_00102cd9"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105870",
            "calling": [
                "FUN_00105db0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "find_matching_function_00105870"
        },
        "FUN_001030ed": {
            "renaming": {
                "FUN_001030ed": "extract_data_001030ed",
                "puVar1": "dataPointer"
            },
            "code": "\nvoid extractData_001030ed(void)\n\n{\n  undefined8 *dataPointer;\n  \n  dataPointer = *(undefined8 **)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n  DAT_0010d598 = *(undefined4 *)((long)dataPointer + 0x1c);\n  DAT_0010d5b0 = (undefined *)dataPointer[2];\n  DAT_0010d5c8 = DAT_0010d5b0;\n  DAT_0010d590 = *dataPointer;\n  DAT_0010d588 = *DAT_0010d5b0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001030ed",
            "calling": [
                "FUN_001031cf",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "extract_data_001030ed"
        },
        "FUN_00105bc0": {
            "renaming": {
                "FUN_00105bc0": "copy_and_unlink_file_00105bc0",
                "param_1": "sourceFile",
                "param_2": "destinationFile",
                "param_3": "flags",
                "param_4": "result",
                "uVar1": "copyResult",
                "piVar2": "errnoLocation",
                "pcVar3": "errorMsg",
                "uVar4": "errorString",
                "uVar5": "unlinkResult",
                "auVar6": "returnValue"
            },
            "code": "\nundefined  [16] copyAndUnlinkFile_00105bc0(char *sourceFile,char *destinationFile,undefined4 flags,undefined8 result)\n\n{\n  uint copyResult;\n  int *errnoLocation;\n  char *errorMsg;\n  undefined8 errorString;\n  ulong unlinkResult;\n  undefined returnValue [16];\n  \n  if (destinationFile == sourceFile) {\n    unlinkResult = 0;\n  }\n  else {\n    copyResult = FUN_00105c00(flags);\n    unlinkResult = (ulong)copyResult;\n    if (copyResult != 0) {\n      errnoLocation = __errno_location();\n      errorMsg = strerror(*errnoLocation);\n      errorString = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      FUN_00107920(errorString,destinationFile,errorMsg);\n    }\n    unlink(sourceFile);\n  }\n  returnValue._8_8_ = result;\n  returnValue._0_8_ = unlinkResult;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_00102f1e",
                "FUN_00105c00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bc0",
            "calling": [
                "FUN_00102d2f",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "copy_and_unlink_file_00105bc0"
        },
        "FUN_00107650": {
            "renaming": {
                "FUN_00107650": "validate_and_process_data_00107650",
                "param_1": "input_data",
                "lVar2": "data_count",
                "uVar1": "result"
            },
            "code": "\nundefined8 validate_and_process_data_00107650(undefined8 input_data)\n\n{\n  undefined8 result;\n  long data_count;\n  \n  data_count = FUN_001052a0();\n  if (data_count < 1) {\n    result = 1;\n  }\n  else {\n    DAT_0010d648 = 1;\n    data_count = FUN_00105300(input_data,0);\n    if (data_count == 0) {\n                    \n      xexit(1);\n    }\n    FUN_001058b0(data_count);\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_0010284b",
                "FUN_001058b0",
                "FUN_00105300",
                "FUN_001052a0",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107650",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "validate_and_process_data_00107650"
        },
        "setlocale": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "setlocale"
        },
        "FUN_00102f1e": {
            "renaming": {
                "FUN_00102f1e": "copy_and_delete_file_00102f1e",
                "unaff_RBP": "fileOffset",
                "unaff_R12": "filePath",
                "unaff_retaddr": "returnAddress",
                "piVar1": "errnoLocation",
                "auVar3": "returnValue",
                "uVar2": "errorString"
            },
            "code": "\nundefined  [16] copyAndDeleteFile_00102f1e(void)\n\n{\n  int *errnoLocation;\n  undefined8 errorString;\n  ulong fileOffset;\n  char *filePath;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  errnoLocation = __errno_location();\n  strerror(*errnoLocation);\n  errorString = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  FUN_00107920(errorString);\n  unlink(filePath);\n  returnValue._0_8_ = fileOffset & 0xffffffff;\n  returnValue._8_8_ = returnAddress;\n  return returnValue;\n}\n\n",
            "called": [
                "dcgettext",
                "unlink",
                "__errno_location",
                "FUN_00107920",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f1e",
            "calling": [
                "FUN_00105bc0"
            ],
            "imported": false,
            "current_name": "copy_and_delete_file_00102f1e"
        },
        "bfd_set_error": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_error"
        },
        "FUN_00102fd7": {
            "renaming": {
                "FUN_00102fd7": "print_time_set_error_message_00102fd7",
                "piVar1": "errorPointer",
                "uVar2": "errorMessage"
            },
            "code": "\nvoid printTimeSetErrorMessage_00102fd7(void)\n\n{\n  int *errorPointer;\n  undefined8 errorMessage;\n  \n  errorPointer = __errno_location();\n  strerror(*errorPointer);\n  errorMessage = dcgettext(0,\"%s: cannot set time: %s\",5);\n  FUN_00107920(errorMessage);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "__errno_location",
                "FUN_00107920",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd7",
            "calling": [
                "FUN_00107c80"
            ],
            "imported": false,
            "current_name": "print_time_set_error_message_00102fd7"
        },
        "FUN_00103ba8": {
            "renaming": {
                "FUN_00103ba8": "check_and_print_ar_status_00103ba8"
            },
            "code": "\n\n\nvoid checkAndPrintARStatus_00103ba8(void)\n\n{\n  if (_DAT_0010d608 != 0) {\n    printf(\"AR >\");\n    fflush(_stdout);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ba8",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_and_print_ar_status_00103ba8"
        },
        "bindtextdomain": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bindtextdomain"
        },
        "filename_cmp": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "FUN_00105480",
                "FUN_001032a8",
                "FUN_00105db0",
                "FUN_00102cd9",
                "FUN_00103e95",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "filename_cmp"
        },
        "bfd_make_readable": {
            "renaming": {},
            "code": "\nvoid bfd_make_readable(void)\n\n{\n  bfd_make_readable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_readable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_make_readable"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "FUN_001025a0",
                "FUN_00103bd1",
                "FUN_0010336b",
                "FUN_00105300",
                "FUN_00102d8c",
                "FUN_00102f1e",
                "FUN_00105db0",
                "FUN_0010394a",
                "FUN_001052a0",
                "FUN_00102c25",
                "FUN_001058b0",
                "FUN_0010285f",
                "FUN_001031a5",
                "FUN_00103a78",
                "FUN_00102fd7",
                "FUN_001032a8",
                "FUN_00102f96",
                "FUN_0010342d",
                "FUN_0010266f",
                "FUN_00103c60",
                "FUN_001075e0",
                "FUN_00103e95",
                "FUN_00102e6f",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_format": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "FUN_001058b0",
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_00103c60",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_set_format"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "FUN_00103bd1",
                "FUN_00102d8c",
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "bfd_openw": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "FUN_00105300",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_openw"
        },
        "FUN_00103ddc": {
            "renaming": {
                "FUN_00103ddc": "initialize_data_00103ddc",
                "param_1": "data"
            },
            "code": "\nvoid initializeData_00103ddc(undefined8 data)\n\n{\n  FUN_001079c0(DAT_0010d578,data,DAT_0010d60c != 0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_001079c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ddc",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "initialize_data_00103ddc"
        },
        "FUN_001078c0": {
            "renaming": {
                "FUN_001078c0": "print_error_message_001078c0",
                "param_1": "message",
                "param_2": "arguments"
            },
            "code": "\n\n\nvoid printErrorMessage_001078c0(char *message,__gnuc_va_list arguments)\n\n{\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",DAT_0010d660);\n  vfprintf(_stderr,message,arguments);\n  putc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "putc",
                "fprintf",
                "vfprintf",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001078c0",
            "calling": [
                "FUN_00107920",
                "FUN_00107690"
            ],
            "imported": false,
            "current_name": "print_error_message_001078c0"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "bfd_openr": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00102710",
                "FUN_00103e95",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "bfd_openr"
        },
        "FUN_001075e0": {
            "renaming": {
                "FUN_001075e0": "print_binutils_version_001075e0",
                "param_1": "distroName",
                "pcVar1": "copyrightMsg"
            },
            "code": "\nvoid printBinutilsVersion_001075e0(undefined8 distroName)\n\n{\n  char *copyrightMsg;\n  \n  printf(\"GNU %s %s\\n\",distroName,\"(GNU Binutils for Debian) 2.40\");\n  copyrightMsg = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(copyrightMsg);\n  copyrightMsg = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(copyrightMsg);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "dcgettext",
                "printf",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001075e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_binutils_version_001075e0"
        },
        "FUN_00105480": {
            "renaming": {
                "FUN_00105480": "process_entries_00105480",
                "param_1": "entries",
                "param_2": "callback",
                "param_3": "archive_entries",
                "param_4": "num_entries",
                "iVar1": "comparison_result",
                "__format": "error_message",
                "lVar2": "current_entry",
                "plVar3": "next_entry",
                "uVar4": "archive_entry",
                "plVar5": "entry",
                "local_cc": "count",
                "local_c8": "data_buffer"
            },
            "code": "\n\n\nvoid process_entries_00105480(long entries,code *callback,undefined8 *archive_entries,int num_entries)\n\n{\n  int comparison_result;\n  char *error_message;\n  long current_entry;\n  long *next_entry;\n  undefined8 archive_entry;\n  long *entry;\n  int count;\n  undefined data_buffer [152];\n  \n  current_entry = *(long *)(entries + 0xf0);\n  if (num_entries == 0) {\n    for (; current_entry != 0; current_entry = *(long *)(current_entry + 0xf0)) {\n      (*callback)(current_entry);\n    }\n  }\n  else {\n    for (; current_entry != 0; current_entry = *(long *)(current_entry + 0xf0)) {\n      *(undefined4 *)(current_entry + 0xac) = 0;\n    }\n    do {\n      entry = *(long **)(entries + 0xf0);\n      count = 0;\n      for (; entry != (long *)0x0; entry = (long *)entry[0x1e]) {\n        if (*(int *)((long)entry + 0xac) == 0) {\n          current_entry = *entry;\n          if (current_entry == 0) {\n            next_entry = (long *)entry[0x1d];\n            if ((long *)entry[0x1d] == (long *)0x0) {\n              next_entry = entry;\n            }\n            (**(code **)(next_entry[1] + 0x1e8))(entry,data_buffer);\n          }\n          else if (((*(byte *)(entries + 0x49) & 0x10) == 0) ||\n                  (current_entry = FUN_00105830(current_entry,entries), current_entry != 0)) {\n            archive_entry = FUN_00105830(*archive_entries,entries);\n            comparison_result = filename_cmp(archive_entry,current_entry);\n            if ((comparison_result == 0) &&\n               ((DAT_0010d634 == '\\0' || (count = count + 1, count == _DAT_0010d630)))) {\n              (*callback)();\n              *(undefined4 *)((long)entry + 0xac) = 1;\n              goto LAB_0010553e;\n            }\n          }\n        }\n      }\n      archive_entry = *archive_entries;\n      error_message = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n      fprintf(_stderr,error_message,archive_entry);\nLAB_0010553e:\n      archive_entries = archive_entries + 1;\n      num_entries = num_entries + -1;\n    } while (num_entries != 0);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_0010285f",
                "FUN_00105830",
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105480",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "process_entries_00105480"
        },
        "FUN_00105cf0": {
            "renaming": {
                "FUN_00105cf0": "FUNC_00105cf0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d03) */\n/* WARNING: Removing unreachable block (ram,0x00105d0f) */\n\nvoid FUNC_00105cf0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105cf0",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105cf0"
        },
        "FUN_001031a5": {
            "renaming": {
                "FUN_001031a5": "print_syntax_error_in_archive_script_line_001031a5",
                "__format": "errorMessage",
                "uVar1": "lineNumber"
            },
            "code": "\nvoid printSyntaxErrorInArchiveScriptLine_001031a5(void)\n\n{\n  uint lineNumber;\n  char *errorMessage;\n  \n  lineNumber = DAT_0010d554 + 1;\n  errorMessage = (char *)dcgettext(0,\"Syntax error in archive script, line %d\\n\",5);\n  printf(errorMessage,(ulong)lineNumber);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031a5",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "print_syntax_error_in_archive_script_line_001031a5"
        },
        "bfd_make_writable": {
            "renaming": {},
            "code": "\nvoid bfd_make_writable(void)\n\n{\n  bfd_make_writable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_writable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_make_writable"
        },
        "strtol": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "strtol"
        },
        "bfd_create": {
            "renaming": {},
            "code": "\nvoid bfd_create(void)\n\n{\n  bfd_create();\n  return;\n}\n\n",
            "called": [
                "bfd_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_create"
        },
        "bfd_target_list": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "bfd_target_list"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "FUN_00103bd1",
                "FUN_00103a78",
                "FUN_00102ba1",
                "FUN_00102d2f",
                "FUN_00105db0",
                "FUN_0010266f",
                "FUN_00103e95",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "free"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102480",
            "calling": [
                "FUN_00107c10",
                "FUN_00105300",
                "FUN_00102d2f",
                "FUN_0010315d",
                "FUN_00105db0",
                "FUN_0010342d",
                "FUN_0010394a",
                "FUN_00107690",
                "FUN_00105a68",
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "close": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "FUN_001058b0",
                "FUN_00102f55",
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "close"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102470",
            "calling": [
                "FUN_00105db0",
                "FUN_00105a68",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "malloc": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "FUN_001033d6",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "malloc"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_001052a0",
                "FUN_00103e95",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "FUN_00103df9": {
            "renaming": {
                "FUN_00103df9": "ensure_buffer_stack_00103df9",
                "in_RCX": "result",
                "__size": "buffer_size",
                "lVar1": "loop_counter",
                "lVar2": "new_buffer_size",
                "puVar3": "buffer_ptr",
                "bVar4": "byte_var"
            },
            "code": "\nundefined8 ensure_buffer_stack_00103df9(void)\n\n{\n  size_t buffer_size;\n  undefined8 result;\n  long loop_counter;\n  long new_buffer_size;\n  undefined4 *buffer_ptr;\n  byte byte_var;\n  \n  byte_var = 0;\n  if (DAT_0010d5a8 == (void *)0x0) {\n    DAT_0010d5a8 = calloc(8,1);\n    if (DAT_0010d5a8 != (void *)0x0) {\n      DAT_0010d580 = 1;\n      DAT_0010d5a0 = 0;\n      return result;\n    }\n  }\n  else {\n    if (DAT_0010d5a0 < DAT_0010d580 - 1U) {\n      return result;\n    }\n    new_buffer_size = DAT_0010d580 + 8;\n    buffer_size = new_buffer_size * 8;\n    DAT_0010d5a8 = realloc(DAT_0010d5a8,buffer_size);\n    if (DAT_0010d5a8 != (void *)0x0) {\n      buffer_ptr = (undefined4 *)((long)DAT_0010d5a8 + (buffer_size - 0x40));\n      DAT_0010d580 = new_buffer_size;\n      for (loop_counter = 0x10; loop_counter != 0; loop_counter = loop_counter + -1) {\n        *buffer_ptr = 0;\n        buffer_ptr = buffer_ptr + (ulong)byte_var * -2 + 1;\n      }\n      return result;\n    }\n  }\n  FUN_001033b0(\"out of dynamic memory in yyensure_buffer_stack_00103df9()\");\n  DAT_0010d5a0 = 0;\n  DAT_0010d580 = 1;\n  return result;\n}\n\n",
            "called": [
                "realloc",
                "calloc",
                "FUN_001033b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103df9",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "ensure_buffer_stack_00103df9"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "FUN_001058b0",
                "FUN_00105db0",
                "FUN_00103c60",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "extract_and_print_data_00103a78",
                "param_1": "inputData",
                "iVar1": "resultCode",
                "__ptr": "buffer",
                "puVar2": "optionalInput",
                "uVar3": "readSize",
                "uVar4": "errorMsg",
                "sVar5": "writeSize",
                "piVar6": "errnoLocation",
                "unaff_RBP": "remainingSize",
                "pcVar7": "errorMessage",
                "unaff_R13": "totalReadSize",
                "unaff_R14": "fileSize",
                "auStack_b8": "stackBuffer",
                "local_88": "totalFileSize"
            },
            "code": "\n\n\nvoid extractAndPrintData_00103a78(undefined8 *inputData)\n\n{\n  int resultCode;\n  void *buffer;\n  undefined8 *optionalInput;\n  ulong readSize;\n  undefined8 errorMsg;\n  size_t writeSize;\n  int *errnoLocation;\n  size_t remainingSize;\n  char *errorMessage;\n  ulong totalReadSize;\n  ulong fileSize;\n  undefined stackBuffer [48];\n  ulong totalFileSize;\n  \n  buffer = (void *)xmalloc(0x2000);\n  optionalInput = (undefined8 *)inputData[0x1d];\n  if ((undefined8 *)inputData[0x1d] == (undefined8 *)0x0) {\n    optionalInput = inputData;\n  }\n  resultCode = (**(code **)(optionalInput[1] + 0x1e8))(inputData,stackBuffer);\n  if (resultCode == 0) {\n    if (DAT_0010d60c != 0) {\n      printf(\"\\n<%s>\\n\\n\",*inputData);\n    }\n    totalReadSize = 0;\n    bfd_seek(inputData,0,0);\n    goto LAB_00103afd;\n  }\n  inputData = (undefined8 *)*inputData;\n  errorMessage = \"internal stat error on %s\";\n  do {\n    errorMsg = dcgettext(0,errorMessage,5);\n    FUN_00107690(errorMsg,inputData);\n    totalFileSize = fileSize;\n    do {\n      writeSize = fwrite(buffer,1,remainingSize,_stdout);\n      if (writeSize != remainingSize) {\n        errnoLocation = __errno_location();\n        errorMessage = strerror(*errnoLocation);\n        FUN_00107690(\"stdout: %s\",errorMessage);\nLAB_00103b91:\n        free(buffer);\n        return;\n      }\n      totalReadSize = totalReadSize + writeSize;\nLAB_00103afd:\n      if (totalFileSize <= totalReadSize) goto LAB_00103b91;\n      remainingSize = totalFileSize - totalReadSize;\n      if (0x2000 < remainingSize) {\n        remainingSize = 0x2000;\n      }\n      readSize = bfd_bread(buffer,remainingSize,inputData);\n    } while (remainingSize == readSize);\n    errorMessage = \"%s is not a valid archive\";\n    inputData = *(undefined8 **)inputData[0x1d];\n    fileSize = totalFileSize;\n  } while( true );\n}\n\n",
            "called": [
                "dcgettext",
                "xmalloc",
                "printf",
                "bfd_seek",
                "bfd_bread",
                "__errno_location",
                "free",
                "FUN_00107690",
                "fwrite",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_and_print_data_00103a78"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "FUN_00103bd1",
                "FUN_0010336b",
                "FUN_00105300",
                "FUN_00102d8c",
                "FUN_00105db0",
                "FUN_0010394a",
                "FUN_001078c0",
                "FUN_001033b0",
                "FUN_0010285f",
                "FUN_001032a8",
                "FUN_0010342d",
                "FUN_00102f96",
                "FUN_0010266f",
                "FUN_00103c60",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "strrchr": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "strrchr"
        },
        "FUN_001058b0": {
            "renaming": {
                "FUN_001058b0": "extract_archive_metadata_001058b0",
                "param_1": "archiveData",
                "cVar1": "result",
                "uVar2": "flags",
                "uVar4": "format",
                "__format": "timeErrorMessage",
                "__ptr": "archivePath",
                "__stream": "fileStream",
                "ppcVar5": "filePtr",
                "uStack0000000000000020": "fileMode",
                "in_stack_00000028": "fileUID",
                "in_stack_00000038": "fileGID",
                "local_3c": "errorCodes",
                "uStack_33": "fileType",
                "cStack_32": "setUserReadPermission",
                "cStack_31": "setUserWritePermission",
                "stack0xffffffffffffffd8": "errorDescription"
            },
            "code": "\n\n\nvoid extractArchiveMetadata_001058b0(undefined8 *archiveData)\n\n{\n  char result;\n  uint flags;\n  int iVar3;\n  undefined8 format;\n  char *timeErrorMessage;\n  void *archivePath;\n  FILE *fileStream;\n  char **filePtr;\n  uint fileMode;\n  uint fileUID;\n  undefined8 fileGID;\n  int errorCodes [2];\n  undefined fileType;\n  char setUserReadPermission;\n  char setUserWritePermission;\n  \n  format = archiveData[0x1e];\n  errorCodes[0] = -1;\n  archivePath = (void *)xstrdup(*archiveData);\n  fileStream = (FILE *)FUN_001057a0(archivePath,errorCodes);\n  iVar3 = errorCodes[0];\n  if (fileStream != (FILE *)0x0) {\n    DAT_0010d618 = fileStream;\n    filePtr = (char **)bfd_fdopenw(fileStream,*(undefined8 *)archiveData[1],errorCodes[0]);\n    if (filePtr != (char **)0x0) {\n      DAT_0010d5e0 = filePtr;\n      bfd_set_format(filePtr,2);\n      flags = (~DAT_0010d648 >> 0x1f) << 3 | *(byte *)((long)filePtr + 0x49) & 0xfffffff7;\n      *(char *)((long)filePtr + 0x49) = (char)flags;\n      if (DAT_0010d5fa != '\\0') {\n        *(uint *)((long)filePtr + 0x44) = *(uint *)((long)filePtr + 0x44) | 0x400;\n      }\n      if (_DAT_0010d2d0 != 0) {\n        *(uint *)((long)filePtr + 0x44) = *(uint *)((long)filePtr + 0x44) | 0x2000;\n      }\n      if (DAT_0010d5f9 != '\\0') goto LAB_00102d37;\n      while( true ) {\n        if ((DAT_0010d5f8 != '\\0') || ((*(byte *)((long)archiveData + 0x49) & 0x10) != 0)) {\n          *(byte *)((long)filePtr + 0x49) = (byte)flags | 0x10;\n        }\n        result = bfd_set_archive_head(filePtr,format);\n        if (result != '\\0') break;\n        flags = FUN_00107c10(archivePath);\nLAB_00102d37:\n        *(uint *)((long)filePtr + 0x44) = *(uint *)((long)filePtr + 0x44) | 0x100000;\n      }\n      iVar3 = dup(iVar3);\n      result = bfd_close(filePtr);\n      if (result == '\\0') {\n        FUN_00107c10(archivePath);\n        timeErrorMessage = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(&errorDescription,timeErrorMessage);\n        flags = fileMode & 0xf000;\n        if (flags == 0x4000) {\n          fileType = 100;\n        }\n        else if (flags == 0xa000) {\n          fileType = 0x6c;\n        }\n        else if (flags == 0x6000) {\n          fileType = 0x62;\n        }\n        else if (flags == 0x2000) {\n          fileType = 99;\n        }\n        else if (flags == 0xc000) {\n          fileType = 0x73;\n        }\n        else {\n          fileType = 0x70;\n          if (flags != 0x1000) {\n            fileType = 0x2d;\n          }\n        }\n        setUserReadPermission = (-((_fileMode & 0x100) == 0) & 0xbbU) + 0x72;\n        setUserWritePermission = (-((_fileMode & 0x80) == 0) & 0xb6U) + 0x77;\n        fprintf(fileStream,\"%s %ld/%ld %6lu %s \",&setUserReadPermission,_fileMode >> 0x20,\n                (ulong)fileUID,fileGID,&errorDescription,\n                _fileMode & 0xffffffff);\n        fputs(*filePtr,fileStream);\n        if ((char)archiveData != '\\0') {\n          if ((*(byte *)((long)filePtr + 0x49) & 0x10) == 0) {\n            if (filePtr[0xb] != (char *)0x0) {\n              fprintf(fileStream,\" 0x%lx\");\n            }\n          }\n          else if (filePtr[0xc] != (char *)0x0) {\n            fprintf(fileStream,\" 0x%lx\");\n          }\n        }\n        fputc(10,fileStream);\n        return;\n      }\n      DAT_0010d5e0 = (char **)0x0;\n      DAT_0010d618 = (FILE *)0x0;\n      bfd_close(archiveData);\n      iVar3 = FUN_00105bc0(fileStream,archivePath,iVar3);\n      if (iVar3 == 0) {\n        free(archivePath);\n        free(fileStream);\n        return;\n      }\n      goto LAB_00102d7a;\n    }\n    close(iVar3);\n    FUN_00107c10(archivePath);\n  }\n  format = dcgettext(0,\"could not create temporary file whilst writing archive\",5);\n  FUN_00107c10(format);\nLAB_00102d7a:\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_00107c10",
                "close",
                "bfd_fdopenw",
                "FUN_001057a0",
                "xstrdup",
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001058b0",
            "calling": [
                "FUN_00105db0",
                "FUN_00107650",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "extract_archive_metadata_001058b0"
        },
        "fputs": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "FUN_00102d8c"
            ],
            "imported": false,
            "current_name": "fputs"
        },
        "perror": {
            "renaming": {},
            "code": "\n\n\nvoid perror(char *__s)\n\n{\n  perror(__s);\n  return;\n}\n\n",
            "called": [
                "perror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024a0",
            "calling": [
                "FUN_00105300",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "perror"
        },
        "FUN_00102bf5": {
            "renaming": {
                "FUN_00102bf5": "cleanup_function_00102bf5"
            },
            "code": "\nvoid cleanupFunction_00102bf5(void)\n\n{\n  if (DAT_0010d5e0 != 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 != (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close",
                "fclose",
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bf5",
            "calling": [
                "FUN_00107730"
            ],
            "imported": false,
            "current_name": "cleanup_function_00102bf5"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_pointer_function_00102020"
            },
            "code": "\nvoid executePointerFunction_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_pointer_function_00102020"
        },
        "open": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102460",
            "calling": [
                "FUN_00105db0",
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "open"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "FUN_00103bd1",
                "FUN_00102f96",
                "FUN_00103ba8",
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "FUN_00102943": {
            "renaming": {
                "FUN_00102943": "initialize_data_00102943"
            },
            "code": "\nvoid initializeData_00102943(void)\n\n{\n  DAT_0010d618 = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102943",
            "calling": [
                "FUN_00105570",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "initialize_data_00102943"
        },
        "bfd_openr_next_archived_file": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102530",
            "calling": [
                "FUN_00105af0",
                "FUN_00105300",
                "FUN_00103c60"
            ],
            "imported": false,
            "current_name": "bfd_openr_next_archived_file"
        },
        "realloc": {
            "renaming": {},
            "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "FUN_00103df9",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "realloc"
        },
        "FUN_00107c80": {
            "renaming": {
                "FUN_00107c80": "set_file_times_00107c80",
                "param_1": "filePath",
                "param_2": "binaryData",
                "iVar1": "result",
                "piVar2": "errnoLocation",
                "pcVar3": "errorMessage",
                "uVar4": "errorString",
                "local_38": "timeData1",
                "uStack_34": "timeData2",
                "uStack_30": "timeData3",
                "uStack_2c": "timeData4",
                "local_28": "timeData5"
            },
            "code": "\nvoid setFileTimes_00107c80(char *filePath,long binaryData)\n\n{\n  int result;\n  int *errnoLocation;\n  char *errorMessage;\n  undefined8 errorString;\n  undefined4 timeData1;\n  undefined4 timeData2;\n  undefined4 timeData3;\n  undefined4 timeData4;\n  undefined4 timeData5;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  \n  timeData5 = *(undefined4 *)(binaryData + 0x58);\n  uStack_24 = *(undefined4 *)(binaryData + 0x5c);\n  uStack_20 = *(undefined4 *)(binaryData + 0x60);\n  uStack_1c = *(undefined4 *)(binaryData + 100);\n  timeData1 = *(undefined4 *)(binaryData + 0x48);\n  timeData2 = *(undefined4 *)(binaryData + 0x4c);\n  timeData3 = *(undefined4 *)(binaryData + 0x50);\n  timeData4 = *(undefined4 *)(binaryData + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&timeData1,0);\n  if (result != 0) {\n    errnoLocation = __errno_location();\n    errorMessage = strerror(*errnoLocation);\n    errorString = dcgettext(0,\"%s: cannot set time: %s\",5);\n    FUN_00107920(errorString,filePath,errorMessage);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00102fd7",
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c80",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "set_file_times_00107c80"
        },
        "isatty": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "FUN_00105db0",
                "FUN_001031cf"
            ],
            "imported": false,
            "current_name": "isatty"
        },
        "FUN_00105a20": {
            "renaming": {
                "FUN_00105a20": "extract_file_from_archive_00105a20",
                "param_1": "outputPath",
                "pcVar1": "basePath",
                "pcVar2": "currentPath",
                "uVar3": "extractedPath",
                "uVar4": "errorMsg",
                "pFVar5": "filePtr"
            },
            "code": "\nvoid extractFileFromArchive_00105a20(char *outputPath)\n\n{\n  char *basePath;\n  char *currentPath;\n  undefined8 extractedPath;\n  undefined8 errorMsg;\n  FILE *filePtr;\n  size_t sVar6;\n  \n  basePath = DAT_0010d5e8;\n  DAT_0010d618 = outputPath;\n  if (*outputPath == '/') {\nLAB_00102e9a:\n    extractedPath = lbasename();\n    basePath = DAT_0010d618;\n    errorMsg = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\",5);\n    FUN_00107920(errorMsg,basePath,extractedPath);\n    DAT_0010d618 = (char *)extractedPath;\n    FUN_00105a68();\n    return;\n  }\n  do {\n    if (*outputPath == '\\0') {\n      if ((DAT_0010d5e8 != (char *)0x0) && (sVar6 = strlen(DAT_0010d5e8), sVar6 != 0)) {\n        if (basePath[sVar6 - 1] == '/') {\n          DAT_0010d618 = (char *)concat(basePath,DAT_0010d618,0);\n        }\n        else {\n          DAT_0010d618 = (char *)concat(basePath,&DAT_00108260,DAT_0010d618,0);\n        }\n      }\n      if (DAT_0010d60c != 0) {\n        printf(\"x - %s\\n\",DAT_0010d618);\n      }\n      filePtr = fopen(DAT_0010d618,\"w\");\n      if (filePtr == (FILE *)0x0) {\n        perror(DAT_0010d618);\n                    \n        xexit(1);\n      }\n      return;\n    }\n    currentPath = outputPath;\n    if ((*outputPath == '.') && (currentPath = outputPath + 1, outputPath[1] == '.')) {\n      currentPath = outputPath + 2;\n      if ((outputPath[2] == '/') || (outputPath[2] == '\\0')) goto LAB_00102e9a;\n    }\n    for (; (*currentPath != '\\0' && (*currentPath != '/')); currentPath = currentPath + 1) {\n    }\n    for (; outputPath = currentPath, *currentPath == '/'; currentPath = currentPath + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a20",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "extract_file_from_archive_00105a20"
        },
        "sprintf": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024f0",
            "calling": [
                "FUN_00102d8c",
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "sprintf"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00105d20();\n  return;\n}\n\n",
            "called": [
                "FUN_00105d20"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105da0",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "FUN_00102bb0",
                "FUN_00105db0",
                "FUN_00105a68",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "FUN_00102f55": {
            "renaming": {
                "FUN_00102f55": "close_file_and_set_errno_00102f55",
                "unaff_R12D": "fileDescriptor",
                "piVar2": "errnoLocation",
                "iVar1": "originalErrno"
            },
            "code": "\nundefined8 closeFileAndSetErrno_00102f55(void)\n\n{\n  int originalErrno;\n  int *errnoLocation;\n  int fileDescriptor;\n  \n  errnoLocation = __errno_location();\n  originalErrno = *errnoLocation;\n  close(fileDescriptor);\n  *errnoLocation = originalErrno;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f55",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "close_file_and_set_errno_00102f55"
        },
        "FUN_001057a0": {
            "renaming": {
                "FUN_001057a0": "allocate_filepath_001057a0",
                "param_1": "originalFilePath",
                "param_2": "fileDescriptor",
                "param_3": "unusedParam1",
                "param_4": "unusedParam2",
                "iVar1": "result",
                "pcVar2": "filename",
                "lVar3": "originalFilenameLength",
                "lVar4": "currentLength",
                "lVar5": "filenameOffset",
                "pcVar6": "newFilePath",
                "bVar7": "increment",
                "auVar8": "returnValue"
            },
            "code": "\nundefined  [16] allocateFilepath_001057a0(char *originalFilePath,int *fileDescriptor,undefined8 unusedParam1,undefined8 unusedParam2)\n\n{\n  int result;\n  char *filename;\n  long originalFilenameLength;\n  long currentLength;\n  long filenameOffset;\n  char *newFilePath;\n  byte increment;\n  undefined returnValue [16];\n  \n  increment = 0;\n  filename = strrchr(originalFilePath,0x2f);\n  if (filename == (char *)0x0) {\n    filename = (char *)xmalloc(9);\n    originalFilenameLength = 0;\n  }\n  else {\n    filenameOffset = (long)filename - (long)originalFilePath;\n    filename = (char *)xmalloc(filenameOffset + 0xb);\n    originalFilenameLength = filenameOffset + 1;\n    newFilePath = filename;\n    for (currentLength = filenameOffset; currentLength != 0; currentLength = currentLength + -1) {\n      *newFilePath = *originalFilePath;\n      originalFilePath = originalFilePath + (ulong)increment * -2 + 1;\n      newFilePath = newFilePath + (ulong)increment * -2 + 1;\n    }\n    filename[filenameOffset] = '/';\n  }\n  *(undefined8 *)(filename + originalFilenameLength) = 0x5858585858587473;\n  *(undefined *)((long)(filename + originalFilenameLength) + 8) = 0;\n  result = mkstemp(filename);\n  if (result == -1) {\n    newFilePath = (char *)0x0;\n    free(filename);\n  }\n  else {\n    *fileDescriptor = result;\n    newFilePath = filename;\n  }\n  returnValue._8_8_ = unusedParam2;\n  returnValue._0_8_ = newFilePath;\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00102ba1",
                "mkstemp",
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001057a0",
            "calling": [
                "FUN_001058b0",
                "FUN_00103c60"
            ],
            "imported": false,
            "current_name": "allocate_filepath_001057a0"
        },
        "bfd_cache_close": {
            "renaming": {},
            "code": "\nvoid bfd_cache_close(void)\n\n{\n  bfd_cache_close();\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "FUN_00103e95",
                "FUN_00102bf5"
            ],
            "imported": false,
            "current_name": "bfd_cache_close"
        },
        "FUN_00102d8c": {
            "renaming": {
                "FUN_00102d8c": "print_file_info_00102d8c",
                "param_19": "filePermissions",
                "unaff_RBP": "outputFile",
                "unaff_RBX": "fileData",
                "unaff_R12B": "hasExtension",
                "__format": "corruptTimeFormat",
                "uVar1": "upperBits",
                "uStack0000000000000015": "permissionChar",
                "cStack0000000000000016": "cStack16",
                "cStack0000000000000017": "cStack17",
                "param_9": "cStack9",
                "cStack0000000000000019": "cStack19",
                "cStack000000000000001a": "cStack1A",
                "cStack000000000000001b": "cStack1B",
                "cStack000000000000001c": "cStack1C",
                "cStack000000000000001d": "cStack1D",
                "cStack000000000000001e": "cStack1E",
                "uStack000000000000001f": "zero",
                "uStack000000000000006c": "count",
                "param_20": "size",
                "param_22": "timeStamp"
            },
            "code": "\nvoid printFileInfo_00102d8c(void)\n\n{\n  char *corruptTimeFormat;\n  uint upperBits;\n  char **fileData;\n  FILE *outputFile;\n  char hasExtension;\n  undefined permissionChar;\n  char cStack16;\n  char cStack17;\n  char cStack9;\n  char cStack19;\n  char cStack1A;\n  char cStack1B;\n  char cStack1C;\n  char cStack1D;\n  char cStack1E;\n  undefined zero;\n  uint filePermissions;\n  uint count;\n  uint size;\n  undefined8 timeStamp;\n  \n  corruptTimeFormat = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,corruptTimeFormat);\n  upperBits = filePermissions & 0xf000;\n  if (upperBits == 0x4000) {\n    permissionChar = 100;\n  }\n  else if (upperBits == 0xa000) {\n    permissionChar = 0x6c;\n  }\n  else if (upperBits == 0x6000) {\n    permissionChar = 0x62;\n  }\n  else if (upperBits == 0x2000) {\n    permissionChar = 99;\n  }\n  else if (upperBits == 0xc000) {\n    permissionChar = 0x73;\n  }\n  else {\n    permissionChar = 0x70;\n    if (upperBits != 0x1000) {\n      permissionChar = 0x2d;\n    }\n  }\n  cStack16 = (-((filePermissions & 0x100) == 0) & 0xbbU) + 0x72;\n  cStack17 = (-((filePermissions & 0x80) == 0) & 0xb6U) + 0x77;\n  cStack9 = (-((filePermissions & 0x40) == 0) & 0xb5U) + 0x78;\n  cStack19 = (-((filePermissions & 0x20) == 0) & 0xbbU) + 0x72;\n  cStack1A = (-((filePermissions & 0x10) == 0) & 0xb6U) + 0x77;\n  cStack1B = (-((filePermissions & 8) == 0) & 0xb5U) + 0x78;\n  cStack1C = (-((filePermissions & 4) == 0) & 0xbbU) + 0x72;\n  cStack1D = (-((filePermissions & 2) == 0) & 0xb6U) + 0x77;\n  cStack1E = (-((filePermissions & 1) == 0) & 0xb5U) + 0x78;\n  if ((filePermissions & 0x800) != 0) {\n    if (cStack9 == 'x') {\n      cStack9 = 's';\n    }\n    else {\n      cStack9 = 'S';\n    }\n  }\n  if ((filePermissions & 0x400) != 0) {\n    if (cStack1B == 'x') {\n      cStack1B = 's';\n    }\n    else {\n      cStack1B = 'S';\n    }\n  }\n  if ((filePermissions & 0x200) != 0) {\n    if (cStack1E == 'x') {\n      cStack1E = 't';\n    }\n    else {\n      cStack1E = 'T';\n    }\n  }\n  zero = 0;\n  fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)count,\n          (ulong)size,timeStamp,&stack0x00000020,(ulong)filePermissions);\n  fputs(*fileData,outputFile);\n  if (hasExtension != '\\0') {\n    if ((*(byte *)((long)fileData + 0x49) & 0x10) == 0) {\n      if (fileData[0xb] != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (fileData[0xc] != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fputs",
                "fprintf",
                "fputc",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d8c",
            "calling": [
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "print_file_info_00102d8c"
        },
        "bfd_plugin_set_plugin": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_plugin"
        },
        "__errno_location": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "FUN_001025a0",
                "FUN_00103a78",
                "FUN_00102f55",
                "FUN_00102fd7",
                "FUN_00105300",
                "FUN_00102f1e",
                "FUN_00103c60",
                "FUN_001031cf",
                "FUN_00103e95",
                "FUN_001028ed",
                "FUN_00105c00",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "__errno_location"
        },
        "FUN_00105300": {
            "renaming": {
                "FUN_00105300": "process_binary_00105300",
                "param_1": "filePath",
                "param_2": "outputFiles",
                "plVar1": "filePointer",
                "pcVar2": "defaultPlugin",
                "bVar3": "isThinLibrary",
                "cVar4": "conversionError",
                "iVar5": "statResult",
                "uVar6": "errorString",
                "uVar7": "fileName",
                "piVar8": "errnoLocation",
                "lVar9": "archivedFilePointer",
                "puVar10": "newOutputFiles",
                "local_b0": "statBuffer",
                "local_a8": "fileStat"
            },
            "code": "\n\n\nundefined8 * processBinary_00105300(char *filePath,undefined8 *outputFiles)\n\n{\n  long *filePointer;\n  char *defaultPlugin;\n  byte isThinLibrary;\n  char conversionError;\n  int statResult;\n  undefined8 errorString;\n  undefined8 fileName;\n  int *errnoLocation;\n  long archivedFilePointer;\n  undefined8 *newOutputFiles;\n  undefined8 statBuffer;\n  stat fileStat;\n  \n  bfd_set_error(0);\n  if (DAT_0010d5f0 == (char *)0x0) {\n    DAT_0010d5f0 = \"plugin\";\n  }\n  statResult = stat(filePath,&fileStat);\n  defaultPlugin = DAT_0010d618;\n  if (statResult == 0) goto LAB_001053be;\n  errnoLocation = __errno_location();\n  if (*errnoLocation == 2) {\n    if (DAT_0010d604 == '\\0') {\n      fprintf(_stderr,\"%s: \",DAT_0010d660);\n      perror(filePath);\n      FUN_0010315d();\n      return (undefined8 *)0x0;\n    }\n    if ((DAT_0010d5f0 == (char *)0x0) && (outputFiles != (undefined8 *)0x0)) {\n      newOutputFiles = (undefined8 *)FUN_00102710();\n      return newOutputFiles;\n    }\n    outputFiles = (undefined8 *)bfd_openw(filePath,DAT_0010d5f0);\n    if (((outputFiles != (undefined8 *)0x0) && (conversionError = bfd_set_format(outputFiles,2), conversionError != '\\0')) &&\n       (conversionError = bfd_close(outputFiles), conversionError != '\\0')) {\n      defaultPlugin = filePath;\n      if (_DAT_0010d610 == 0) goto LAB_00102826;\n      goto LAB_001053be;\n    }\n  }\n  FUN_00107c10(filePath);\n  do {\n    isThinLibrary = *(byte *)((long)outputFiles + 0x49) >> 4 & 1;\n    if (DAT_0010d5f8 == '\\0') {\n      if (isThinLibrary != 0) {\n        fileName = *outputFiles;\n        errorString = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        FUN_00107690(errorString,fileName);\n        goto LAB_00102812;\n      }\n    }\n    else if (isThinLibrary == 0) {\n      fileName = *outputFiles;\n      errorString = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      FUN_00107690(errorString,fileName);\nLAB_001027cb:\n      FUN_00107c20(filePath);\n      statResult = bfd_get_error();\n      if (statResult == 0xd) {\nLAB_00102812:\n        FUN_00103bd1(statBuffer);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      filePointer = outputFiles + 0x1e;\n      for (archivedFilePointer = bfd_openr_next_archived_file(outputFiles,0); archivedFilePointer != 0;\n          archivedFilePointer = bfd_openr_next_archived_file(outputFiles,archivedFilePointer)) {\n        *filePointer = archivedFilePointer;\n        filePointer = (long *)(archivedFilePointer + 0xf0);\n      }\n      *filePointer = 0;\n      statResult = bfd_get_error();\n      if (statResult == 9) {\n        return outputFiles;\n      }\n      do {\n        FUN_00107c10(filePath);\nLAB_00102826:\n        fileName = dcgettext(0,\"creating %s\",5);\n        FUN_00107920(fileName,filePath);\n        defaultPlugin = filePath;\nLAB_001053be:\n        DAT_0010d618 = defaultPlugin;\n        outputFiles = (undefined8 *)bfd_openr(filePath,DAT_0010d5f0);\n      } while (outputFiles == (undefined8 *)0x0);\n      conversionError = bfd_check_format_matches(outputFiles,2,&statBuffer);\n      if (conversionError == '\\0') goto LAB_001027cb;\n    } while (((DAT_0010d64c != 2) && (DAT_0010d64c != 7)) ||\n            (archivedFilePointer = bfd_openr_next_archived_file(outputFiles,0), archivedFilePointer == 0));\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00107c10",
                "dcgettext",
                "bfd_openr",
                "bfd_openr_next_archived_file",
                "FUN_00103bd1",
                "bfd_get_error",
                "bfd_check_format_matches",
                "bfd_close",
                "__errno_location",
                "FUN_00107920",
                "bfd_set_error",
                "FUN_00107690",
                "stat",
                "fprintf",
                "bfd_openw",
                "FUN_00107c20",
                "FUN_00102710",
                "perror",
                "FUN_0010315d",
                "xexit",
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105300",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "process_binary_00105300"
        },
        "FUN_00105db0": {
            "renaming": {
                "FUN_00105db0": "process_files_00105db0",
                "param_1": "argc",
                "param_2": "argv",
                "pbVar1": "bytePtr1",
                "puVar2": "uintPtr2",
                "bVar3": "byteVar3",
                "plVar4": "longPtr4",
                "puVar5": "ulongPtr5",
                "bVar8": "boolVar8",
                "bVar9": "boolVar9",
                "ppcVar10": "charPtrPtr10",
                "piVar11": "intPtr11",
                "puVar12": "dataPtr12",
                "bVar13": "byteVar13",
                "cVar14": "charVar14",
                "iVar15": "intVar15",
                "uVar16": "uintVar16",
                "pFVar18": "filePtr18",
                "sVar19": "size_tVar19",
                "sVar20": "size_tVar20",
                "__ptr": "bytePtr",
                "plVar21": "longPtr21",
                "pFVar22": "filePtr22",
                "pcVar23": "charPtr23",
                "lVar24": "longVar24",
                "uVar25": "ulongVar25",
                "puVar26": "ulongPtr26",
                "pFVar28": "filePtr28",
                "plVar29": "longPtr29",
                "ppcVar31": "charPtrPtr31",
                "ppcVar32": "charPtrPtr32",
                "pbVar33": "bytePtr33",
                "lVar34": "longVar34",
                "lVar35": "longVar35",
                "ppuVar36": "uintPtrPtr36",
                "uVar37": "uintVar37",
                "unaff_RBP": "charPtrUnaff_RBP",
                "pbVar38": "bytePtr38",
                "pcVar39": "charPtr39",
                "unaff_R12": "FILEPtrUnaff_R12",
                "pcVar43": "charPtr43",
                "uVar44": "uintVar44",
                "iVar45": "intVar45",
                "bVar47": "boolVar47",
                "bVar48": "byteVar48",
                "local_130": "filePtr_local_130",
                "local_128": "filePtr_local_128",
                "local_118": "bytePtr_local_118",
                "local_110": "charPtrPtr_local_110",
                "local_108": "size_t_local_108",
                "local_100": "long_local_100",
                "local_c8": "char_local_c8",
                "local_b0": "uint_local_b0"
            },
            "code": "\n\n\nvoid processFiles_00105db0(uint argc,FILE *argv)\n\n{\n  byte *bytePtr1;\n  uint *uintPtr2;\n  byte byteVar3;\n  long *longPtr4;\n  undefined8 *ulongPtr5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  bool boolVar8;\n  bool boolVar9;\n  char **charPtrPtr10;\n  int *intPtr11;\n  undefined *dataPtr12;\n  byte byteVar13;\n  char charVar14;\n  int intVar15;\n  uint uintVar16;\n  undefined4 uVar17;\n  FILE *filePtr18;\n  size_t size_tVar19;\n  size_t size_tVar20;\n  byte *bytePtr;\n  long *longPtr21;\n  FILE *filePtr22;\n  char *charPtr23;\n  long longVar24;\n  ulong ulongVar25;\n  undefined8 *ulongPtr26;\n  undefined8 uVar27;\n  FILE *filePtr28;\n  long **plongPtr29;\n  undefined8 uVar30;\n  char **charPtrPtr31;\n  uint extraout_EDX;\n  char **charPtrPtr32;\n  byte *bytePtr33;\n  long longVar34;\n  long longVar35;\n  undefined **uintPtrPtr36;\n  uint uintVar37;\n  char *charPtrUnaff_RBP;\n  byte *bytePtr38;\n  char *charPtr39;\n  ulong uVar40;\n  ulong uVar41;\n  ulong uVar42;\n  FILE *FILEPtrUnaff_R12;\n  char *charPtr43;\n  uint uintVar44;\n  int intVar45;\n  char *pcVar46;\n  bool boolVar47;\n  byte byteVar48;\n  undefined8 filePtr_local_130;\n  FILE *filePtr_local_128;\n  byte *bytePtr_local_118;\n  char **charPtrPtr_local_110;\n  size_t size_t_local_108;\n  long long_local_100;\n  undefined char_local_c8 [2];\n  undefined uStack_c6;\n  undefined5 uStack_c5;\n  uint uint_local_b0;\n  \n  byteVar48 = 0;\n  pcVar46 = (char *)(ulong)argc;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_0010d660 = *(long **)argv;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010d660);\n  bfd_plugin_set_program_name(DAT_0010d660);\n  charPtr43 = (char *)argv;\n  filePtr18 = argv;\n  if ((int)argc < 2) goto LAB_001062c6;\n  charPtrPtr_local_110 = (char **)0x7d0;\n  FILEPtrUnaff_R12 = (FILE *)0x1;\n  filePtr_local_128 = (FILE *)0x0;\n  filePtr22 = argv;\n  do {\n    uintVar16 = (uint)FILEPtrUnaff_R12;\n    charPtrUnaff_RBP = (char *)(long)(int)uintVar16;\n    filePtr_local_130 = (FILE *)((long)charPtrUnaff_RBP * 8);\n    charPtr43 = (char *)filePtr22;\n    if (**(char **)(&filePtr22->_flags + (long)charPtrUnaff_RBP * 2) == '@') {\n      uintVar44 = (int)charPtrPtr_local_110 - 1;\n      charPtrPtr_local_110 = (char **)(ulong)uintVar44;\n      if (uintVar44 == 0) {\n        longPtr21 = *(long **)filePtr22;\n        pcVar46 = \"%s: error: too many @-files encountered\\n\";\nLAB_00106ffe:\n        fprintf(_stderr,pcVar46,longPtr21);\nLAB_0010700f:\n                    \n        xexit(1);\n      }\n      charPtr39 = *(char **)(&filePtr22->_flags + (long)charPtrUnaff_RBP * 2) + 1;\n      intVar15 = stat(charPtr39,(stat *)char_local_c8);\n      if (-1 < intVar15) {\n        if ((uint_local_b0 & 0xf000) == 0x4000) {\n          longPtr21 = *(long **)filePtr22;\n          pcVar46 = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00106ffe;\n        }\n        filePtr18 = fopen(charPtr39,\"r\");\n        if (filePtr18 != (FILE *)0x0) {\n          intVar15 = fseek(filePtr18,0,2);\n          if (((intVar15 != -1) && (size_tVar19 = ftell(filePtr18), size_tVar19 != 0xffffffffffffffff)) &&\n             (intVar15 = fseek(filePtr18,0,0), intVar15 != -1)) {\n            bytePtr_local_118 = (byte *)xmalloc(size_tVar19 + 1);\n            size_tVar20 = fread(bytePtr_local_118,1,size_tVar19,filePtr18);\n            if ((size_tVar19 == size_tVar20) || (intVar15 = ferror(filePtr18), intVar15 == 0)) {\n              bytePtr_local_118[size_tVar20] = 0;\n              byteVar13 = *bytePtr_local_118;\n              bytePtr33 = bytePtr_local_118;\n              while( true ) {\n                if (byteVar13 == 0) goto LAB_00106814;\n                if (((&_sch_istable)[(ulong)byteVar13 * 2] & 0x40) == 0) break;\n                byteVar13 = bytePtr33[1];\n                bytePtr33 = bytePtr33 + 1;\n              }\n              size_tVar19 = strlen((char *)bytePtr_local_118);\n              bytePtr = (byte *)xmalloc(size_tVar19 + 1);\n              filePtr28 = (FILE *)0x0;\n              intVar15 = 0;\n              boolVar9 = false;\n              boolVar47 = false;\n              boolVar8 = false;\n              long_local_100 = 0;\n              bytePtr33 = bytePtr_local_118;\n              do {\n                while (((&_sch_istable)[(ulong)*bytePtr33 * 2] & 0x40) != 0) {\n                  bytePtr33 = bytePtr33 + 1;\n                }\n                if ((intVar15 == 0) || (intVar15 + -1 <= (int)long_local_100)) {\n                  if (filePtr28 == (FILE *)0x0) {\n                    intVar15 = 8;\n                    filePtr28 = (FILE *)xmalloc(0x40);\n                    charPtrPtr31 = (char **)((long)&filePtr28->_flags + long_local_100 * 8);\n                    *charPtrPtr31 = (char *)0x0;\n                  }\n                  else {\n                    intVar15 = intVar15 * 2;\n                    filePtr28 = (FILE *)xrealloc(filePtr28,(long)intVar15 << 3);\n                    charPtrPtr31 = (char **)((long)&filePtr28->_flags + long_local_100 * 8);\n                    *charPtrPtr31 = (char *)0x0;\n                  }\n                }\n                else {\n                  charPtrPtr31 = (char **)((long)&filePtr28->_flags + long_local_100 * 8);\n                }\n                byteVar13 = *bytePtr33;\n                bytePtr38 = bytePtr;\n                while (byteVar13 != 0) {\n                  while( true ) {\n                    if ((((&_sch_istable)[(ulong)byteVar13 * 2] & 0x40) != 0) &&\n                       (!(bool)(boolVar9 | boolVar8 | boolVar47))) {\n                      boolVar8 = false;\n                      boolVar9 = false;\n                      boolVar47 = false;\n                      goto LAB_0010606f;\n                    }\n                    if (!boolVar8) break;\n                    bytePtr33 = bytePtr33 + 1;\n                    *bytePtr38 = byteVar13;\n                    bytePtr38 = bytePtr38 + 1;\n                    boolVar8 = false;\n                    byteVar13 = *bytePtr33;\n                    if (byteVar13 == 0) goto LAB_0010606f;\n                  }\n                  if (byteVar13 == 0x5c) {\n                    boolVar8 = true;\n                  }\n                  else if (boolVar47) {\n                    if (byteVar13 == 0x27) {\n                      boolVar47 = false;\n                    }\n                    else {\nLAB_001061f1:\n                      *bytePtr38 = byteVar13;\n                      bytePtr38 = bytePtr38 + 1;\n                    }\n                  }\n                  else if (boolVar9) {\n                    if (byteVar13 != 0x22) goto LAB_001061f1;\n                    boolVar9 = false;\n                  }\n                  else if (byteVar13 == 0x27) {\n                    boolVar47 = true;\n                  }\n                  else {\n                    if (byteVar13 != 0x22) goto LAB_001061f1;\n                    boolVar9 = true;\n                  }\n                  bytePtr1 = bytePtr33 + 1;\n                  bytePtr33 = bytePtr33 + 1;\n                  byteVar13 = *bytePtr1;\n                }\nLAB_0010606f:\n                *bytePtr38 = 0;\n                longPtr21 = (long *)xstrdup(bytePtr);\n                *charPtrPtr31 = (char *)longPtr21;\n                *(undefined8 *)(filePtr28->_shortbuf + long_local_100 * 8 + -0x7b) = 0;\n                byteVar13 = *bytePtr33;\n                byteVar3 = (&_sch_istable)[(ulong)byteVar13 * 2];\n                while ((byteVar3 & 0x40) != 0) {\n                  byteVar13 = bytePtr33[1];\n                  bytePtr33 = bytePtr33 + 1;\n                  byteVar3 = (&_sch_istable)[(ulong)byteVar13 * 2];\n                }\n                long_local_100 = long_local_100 + 1;\n                if (byteVar13 == 0) {\n                  free(bytePtr);\n                  if (filePtr22 == argv) goto LAB_00106834;\n                  goto LAB_0010610a;\n                }\n              } while( true );\n            }\n            free(bytePtr_local_118);\n          }\n          fclose(filePtr18);\n        }\n      }\n    }\n    if ((int)pcVar46 <= (int)(uintVar16 + 1)) {\nLAB_001062c6:\n      do {\n        if (_DAT_0010d2d4 < 0) goto LAB_001073cc;\nLAB_001062d3:\n        uintVar16 = (uint)FILEPtrUnaff_R12;\n        intVar15 = bfd_init();\n        charPtr39 = \"fatal error: libbfd ABI mismatch\";\n        if (intVar15 != 0x118) goto LAB_00106803;\n        charPtr39 = \"x86_64-pc-linux-gnu\";\n        uintVar16 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n        dataPtr12 = PTR_DAT_0010d2e0;\n        FILEPtrUnaff_R12 = (FILE *)(ulong)uintVar16;\n        if ((char)uintVar16 != '\\0') {\n          if (__xexit_cleanup == (code *)0x0) {\n            __xexit_cleanup = FUN_00107cc0;\n          }\n          if (*(int *)(PTR_DAT_0010d2e0 + 8) < 0x20) {\nLAB_0010632b:\n            dataPtr12 = PTR_DAT_0010d2e0;\n            intVar15 = *(int *)(PTR_DAT_0010d2e0 + 8);\n            *(int *)(PTR_DAT_0010d2e0 + 8) = intVar15 + 1;\n            *(code **)(dataPtr12 + (long)intVar15 * 8 + 0x10) = FUN_00107730;\n          }\n          else {\n            ulongPtr26 = (undefined8 *)malloc(0x110);\n            if (ulongPtr26 != (undefined8 *)0x0) {\n              *ulongPtr26 = dataPtr12;\n              *(undefined4 *)(ulongPtr26 + 1) = 0;\n              PTR_DAT_0010d2e0 = (undefined *)ulongPtr26;\n              goto LAB_0010632b;\n            }\n          }\n          longVar24 = 1;\n          do {\n            longVar35 = longVar24;\n            intVar15 = (int)pcVar46;\n            if (intVar15 <= (int)longVar35) break;\n            charVar14 = FUN_00107640(*(undefined8 *)((int *)charPtr43 + longVar35 * 2));\n            longVar24 = longVar35 + 1;\n          } while (charVar14 != '\\0');\n          pcVar46 = (char *)((long)charPtr43 + longVar35 * 8 + -8);\n          uintVar44 = intVar15 - ((int)longVar35 + -1);\n          filePtr18 = (FILE *)(ulong)uintVar44;\n          if (_DAT_0010d2d4 != 0) {\n            charPtr43 = \"DhHUvVt\";\n            uintVar37 = 0;\n            while (intVar15 = getopt_long(filePtr18,pcVar46,\"DhHUvVt\",&PTR_DAT_0010d300), intVar15 != -1)\n            {\n              if (intVar15 < 0x77) {\n                if (0x43 < intVar15) {\n                  switch(intVar15) {\n                  case 0x44:\n                    _DAT_0010d2d0 = 1;\n                    break;\n                  case 0x48:\n                  case 0x68:\n                    _DAT_0010d658 = 1;\n                    break;\n                  case 0x55:\n                    _DAT_0010d2d0 = 0;\n                    break;\n                  case 0x56:\n                  case 0x76:\n                    _DAT_0010d654 = 1;\n                    break;\n                  case 0x74:\n                    uintVar37 = uintVar16;\n                  }\n                }\n              }\n              else if (intVar15 == 0xc9) {\n                bfd_plugin_set_plugin(_optarg);\n              }\n            }\n            if ((int)uintVar44 < 2) {\nLAB_00107125:\n              charPtr39 = (char *)0x0;\n              FUN_0010394a();\n            }\n            else {\n              if (_DAT_0010d658 != 0) {\nLAB_0010711b:\n                FUN_0010394a();\n                goto LAB_00107125;\n              }\n              if (_DAT_0010d654 != 0) {\n                FUN_001075e0(\"ranlib\");\n                goto LAB_0010711b;\n              }\n              if (_DAT_0010d2d0 < 0) {\n                _DAT_0010d2d0 = 1;\n              }\n              FILEPtrUnaff_R12 = (FILE *)0x0;\n              charPtr43 = (char *)(long)_optind;\n              while( true ) {\n                if ((int)uintVar44 <= (int)charPtr43) goto LAB_00106f8b;\n                charPtr39 = *(char **)((int *)pcVar46 + (long)charPtr43 * 2);\n                if ((char)uintVar37 != '\\0') break;\n                uintVar16 = FUN_00107650();\n                charPtr43 = (char *)((long)(int *)charPtr43 + 1);\n                FILEPtrUnaff_R12 = (FILE *)(ulong)((uint)FILEPtrUnaff_R12 | uintVar16);\n              }\n            }\n            while (longVar24 = FUN_001052a0(charPtr39), longVar24 < 1) {\n              uintVar16 = 1;\nLAB_001071c4:\n              intPtr11 = (int *)charPtr43;\n              charPtr43 = (char *)((long)intPtr11 + 1);\n              FILEPtrUnaff_R12 = (FILE *)(ulong)((uint)FILEPtrUnaff_R12 | uintVar16);\n              if ((int)uintVar44 <= (int)charPtr43) {\nLAB_00106f8b:\n                    \n                xexit(FILEPtrUnaff_R12);\n              }\n              charPtr39 = *(char **)((char *)((long)pcVar46 + 0x83) + (long)intPtr11 * 8 + -0x7b);\n            }\n            intVar15 = open(charPtr39,2,0);\n            if (intVar15 < 0) {\n              bfd_set_error(1);\n              FUN_00107c10(charPtr39);\nLAB_0010737f:\n              FUN_00107c10(charPtr39);\nLAB_00107387:\n              FUN_00107c20(charPtr39);\n              intVar15 = bfd_get_error();\n              if (intVar15 == 0xd) {\n                FUN_00103bd1(CONCAT53(uStack_c5,\n                                      CONCAT12(uStack_c6,CONCAT11(char_local_c8[1],char_local_c8[0]))));\n              }\n              goto LAB_0010700f;\n            }\n            charPtrUnaff_RBP = (char *)bfd_fdopenr(charPtr39,0);\n            if ((FILE *)charPtrUnaff_RBP == (FILE *)0x0) goto LAB_0010737f;\n            charVar14 = bfd_check_format_matches(charPtrUnaff_RBP,2,char_local_c8);\n            if (charVar14 == '\\0') goto LAB_00107387;\n            if ((*(byte *)((long)((long)charPtrUnaff_RBP + 0x48) + 1) & 8) != 0) {\n              if (_DAT_0010d2d0 != 0) {\n                uintPtr2 = (uint *)((long)((long)charPtrUnaff_RBP + 0x40) + 4);\n                *uintPtr2 = *uintPtr2 | 0x2000;\n              }\n              (**(code **)(*(char **)((long)charPtrUnaff_RBP + 8) + 0x1f0))(charPtrUnaff_RBP);\n              charVar14 = bfd_close(charPtrUnaff_RBP);\n              if (charVar14 != '\\0') {\n                uintVar16 = 0;\n                goto LAB_001071c4;\n              }\n              goto LAB_0010737f;\n            }\n            uVar27 = dcgettext(0,\"%s: no archive map to update\",5);\n            FUN_00107690(uVar27,charPtr39);\nLAB_001073cc:\n            charPtr39 = (char *)lbasename(DAT_0010d660);\n            size_tVar19 = strlen(charPtr39);\n            if ((size_tVar19 < 6) ||\n               (intVar15 = filename_cmp(charPtr39 + (size_tVar19 - 6),\"ranlib\"), intVar15 != 0)) {\n              _DAT_0010d2d4 = 0;\n            }\n            else {\n              _DAT_0010d2d4 = 1;\n            }\n            goto LAB_001062d3;\n          }\n          uintPtrPtr36 = &PTR_DAT_0010d300;\n          charPtrUnaff_RBP = \"hdmpqrtxl:coOVsSuvabiMNfPTDU\";\n          charPtr43 = (char *)&DAT_001096a0;\n          filePtr22 = (FILE *)charPtrUnaff_RBP;\n          filePtr28 = filePtr18;\n          if ((int)uintVar44 < 2) goto switchD_00107462_caseD_1;\n          filePtr_local_130 = (FILE *)CONCAT71(filePtr_local_130._1_7_,(char)uintVar16);\nLAB_001063a3:\n          filePtr22 = (FILE *)charPtrUnaff_RBP;\n          if (**(char **)((long)pcVar46 + 8) != '-') {\n            char_local_c8[0] = 0x2d;\n            uStack_c6 = 0;\n            size_tVar19 = strlen(*(char **)((long)pcVar46 + 8));\n            intVar15 = (int)size_tVar19 + (int)filePtr18;\n            FILEPtrUnaff_R12 = (FILE *)xmalloc((long)intVar15 * 8);\n            uVar17 = *(undefined4 *)((long)pcVar46 + 4);\n            FILEPtrUnaff_R12->_flags = *(int *)pcVar46;\n            *(undefined4 *)&FILEPtrUnaff_R12->field_0x4 = uVar17;\n            charPtrPtr31 = *(char ***)((long)pcVar46 + 8);\n            filePtr_local_128 = (FILE *)((long)pcVar46 + 0x10);\n            charPtrPtr_local_110 = charPtrPtr31;\n            if (*(char *)charPtrPtr31 == '\\0') {\n              charPtrPtr32 = &FILEPtrUnaff_R12->_IO_read_ptr;\n            }\n            else {\n              bytePtr_local_118 = char_local_c8;\n              char_local_c8[1] = *(char *)charPtrPtr31;\n              charPtr39 = (char *)xstrdup();\n              charPtrPtr32 = &FILEPtrUnaff_R12->_IO_read_end;\n              FILEPtrUnaff_R12->_IO_read_ptr = charPtr39;\n              if (*(char *)((long)charPtrPtr31 + 1) != '\\0') {\n                char_local_c8[1] = *(char *)((long)charPtrPtr31 + 1);\n                charPtr39 = (char *)xstrdup(bytePtr_local_118);\n                charPtrPtr32 = &FILEPtrUnaff_R12->_IO_read_base;\n                FILEPtrUnaff_R12->_IO_read_end = charPtr39;\n                if (*(char *)((long)charPtrPtr31 + 2) != '\\0') {\n                  char_local_c8[1] = *(char *)((long)charPtrPtr31 + 2);\n                  charPtr39 = (char *)xstrdup(bytePtr_local_118);\n                  charPtrPtr32 = &FILEPtrUnaff_R12->_IO_write_base;\n                  FILEPtrUnaff_R12->_IO_read_base = charPtr39;\n                  if (*(char *)((long)charPtrPtr31 + 3) != '\\0') {\n                    charPtrPtr32 = &FILEPtrUnaff_R12->_IO_write_ptr;\n                    char_local_c8[1] = *(char *)((long)charPtrPtr31 + 3);\n                    charPtr39 = (char *)xstrdup(bytePtr_local_118);\n                    FILEPtrUnaff_R12->_IO_write_base = charPtr39;\n                    charVar14 = *(char *)((long)charPtrPtr31 + 4);\n                    charPtrPtr_local_110 = charPtrPtr32;\n                    if (charVar14 != '\\0') {\n                      charPtr39 = (char *)((long)charPtrPtr31 + 4);\n                      charPtrPtr31 = charPtrPtr32;\n                      do {\n                        charPtrPtr32 = charPtrPtr31 + 1;\n                        char_local_c8[1] = charVar14;\n                        charPtr23 = (char *)xstrdup(bytePtr_local_118);\n                        charPtr39 = charPtr39 + 1;\n                        *charPtrPtr31 = charPtr23;\n                        charVar14 = *charPtr39;\n                        charPtrPtr31 = charPtrPtr32;\n                        charPtrPtr_local_110 = charPtrPtr32;\n                      } while (charVar14 != '\\0');\n                    }\n                  }\n                }\n              }\n            }\n            longVar24 = (long)(int)filePtr18;\n            intPtr11 = (int *)pcVar46 + longVar24 * 2;\n            if (filePtr_local_128 < intPtr11) {\n              ulongVar25 = longVar24 * 8 - 0x11;\n              if ((ulongVar25 < 0x18) || (charPtrPtr32 == (char **)((long)pcVar46 + 0x18))) {\n                *charPtrPtr32 = *(char **)((long)pcVar46 + 0x10);\n                if (((char **)((long)pcVar46 + 0x18) < intPtr11) &&\n                   ((((charPtrPtr32[1] = *(char **)((long)pcVar46 + 0x18),\n                      (char **)((long)pcVar46 + 0x20) < intPtr11 &&\n                      (charPtrPtr32[2] = *(char **)((long)pcVar46 + 0x20),\n                      (char **)((long)pcVar46 + 0x28) < intPtr11)) &&\n                     (charPtrPtr32[3] = *(char **)((long)pcVar46 + 0x28),\n                     (char **)((long)pcVar46 + 0x30) < intPtr11)) &&\n                    (charPtrPtr32[4] = *(char **)((long)pcVar46 + 0x30),\n                    (char **)((long)pcVar46 + 0x38) < intPtr11)))) {\n                  charPtrPtr32[5] = *(char **)((long)pcVar46 + 0x38);\n                  charPtrPtr10 = charPtrPtr32 + 6;\n                  for (charPtrPtr31 = (char **)((long)pcVar46 + 0x40); charPtrPtr31 < intPtr11;\n                      charPtrPtr31 = charPtrPtr31 + (ulong)byteVar48 * -2 + 1) {\n                    *charPtrPtr10 = *charPtrPtr31;\n                    charPtrPtr10 = charPtrPtr10 + (ulong)byteVar48 * -2 + 1;\n                  }\n                }\n              }\n              else {\n                uVar17 = *(undefined4 *)((long)((long)pcVar46 + 0x10) + 4);\n                uVar6 = *(undefined4 *)((long)pcVar46 + 0x18);\n                uVar7 = *(undefined4 *)((long)((long)pcVar46 + 0x18) + 4);\n                uVar40 = (ulongVar25 >> 3) + 1;\n                *(undefined4 *)charPtrPtr32 = *(undefined4 *)((long)pcVar46 + 0x10);\n                *(undefined4 *)((long)charPtrPtr32 + 4) = uVar17;\n                *(undefined4 *)(charPtrPtr32 + 1) = uVar6;\n                *(undefined4 *)((long)charPtrPtr32 + 0xc) = uVar7;\n                uVar17 = *(undefined4 *)((long)((long)pcVar46 + 0x20) + 4);\n                uVar6 = *(undefined4 *)((long)pcVar46 + 0x28);\n                uVar7 = *(undefined4 *)((long)((long)pcVar46 + 0x28) + 4);\n                ulongVar25 = uVar40 >> 1;\n                *(undefined4 *)(charPtrPtr32 + 2) = *(undefined4 *)((long)pcVar46 + 0x20);\n                *(undefined4 *)((long)charPtrPtr32 + 0x14) = uVar17;\n                *(undefined4 *)(charPtrPtr32 + 3) = uVar6;\n                *(undefined4 *)((long)charPtrPtr32 + 0x1c) = uVar7;\n                if (ulongVar25 != 2) {\n                  uVar17 = *(undefined4 *)((long)((long)pcVar46 + 0x30) + 4);\n                  uVar6 = *(undefined4 *)((long)pcVar46 + 0x38);\n                  uVar7 = *(undefined4 *)((long)((long)pcVar46 + 0x38) + 4);\n                  *(undefined4 *)(charPtrPtr32 + 4) = *(undefined4 *)((long)pcVar46 + 0x30);\n                  *(undefined4 *)((long)charPtrPtr32 + 0x24) = uVar17;\n                  *(undefined4 *)(charPtrPtr32 + 5) = uVar6;\n                  *(undefined4 *)((long)charPtrPtr32 + 0x2c) = uVar7;\n                  if (ulongVar25 != 3) {\n                    uVar41 = 3;\n                    do {\n                      uVar42 = uVar41 + 1;\n                      charPtr39 = (char *)((long)pcVar46 + 0x83) + uVar41 * 0x10 + -0x73;\n                      uVar17 = *(undefined4 *)(charPtr39 + 4);\n                      uVar6 = *(undefined4 *)(charPtr39 + 8);\n                      uVar7 = *(undefined4 *)(charPtr39 + 0xc);\n                      charPtrPtr31 = charPtrPtr32 + uVar41 * 2;\n                      *(undefined4 *)charPtrPtr31 = *(undefined4 *)charPtr39;\n                      *(undefined4 *)((long)charPtrPtr31 + 4) = uVar17;\n                      *(undefined4 *)(charPtrPtr31 + 1) = uVar6;\n                      *(undefined4 *)((long)charPtrPtr31 + 0xc) = uVar7;\n                      uVar41 = uVar42;\n                    } while (uVar42 != ulongVar25);\n                  }\n                }\n                if ((uVar40 & 1) != 0) {\n                  charPtrPtr32[uVar40 & 0xfffffffffffffffe] =\n                       *(char **)((long)filePtr_local_128 + (uVar40 & 0xfffffffffffffffe) * 8);\n                }\n              }\n              charPtrPtr32 = charPtrPtr32 + longVar24 + -2;\n            }\n            filePtr18 = (FILE *)(ulong)(intVar15 - 1);\n            *charPtrPtr32 = (char *)0x0;\n            pcVar46 = (char *)FILEPtrUnaff_R12;\n          }\nLAB_001065a2:\n          while( true ) {\n            uintVar16 = (uint)FILEPtrUnaff_R12;\n            uintVar44 = getopt_long((ulong)filePtr18 & 0xffffffff,pcVar46,filePtr22,uintPtrPtr36,0);\n            charPtrUnaff_RBP = (char *)filePtr22;\n            if (uintVar44 == 0xffffffff) break;\n            if (((uintVar44 - 100 < 0x15) && ((0x117201UL >> ((ulong)(uintVar44 - 100) & 0x3f) & 1) != 0))\n               && (DAT_0010d64c != 0)) goto LAB_001067f7;\n            filePtr28 = (FILE *)pcVar46;\n            if (uintVar44 < 0xcc) {\n                    /* WARNING: Could not recover jumptable at 0x001065eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              (*(code *)((long)(int *)charPtr43 + (long)((int *)charPtr43)[uintVar44]))();\n              return;\n            }\nswitchD_00107462_caseD_1:\n            FUN_0010342d(0);\n            pcVar46 = (char *)filePtr28;\nswitchD_00107462_caseD_68:\n            _DAT_0010d658 = 1;\n          }\nLAB_00106680:\n          uintVar44 = DAT_0010d64c;\n          filePtr22 = (FILE *)charPtrUnaff_RBP;\n          if (DAT_0010d64c == 0) {\n            if (((DAT_0010d648 == 1) || (_DAT_0010d650 != 0)) ||\n               (((int)filePtr18 <= _optind || (_optind < 1)))) {\n              uintVar44 = 0;\n              goto LAB_001066aa;\n            }\n            pcVar46 = (char *)((long)pcVar46 + (long)_optind * 8 + -8);\n            uintVar16 = (int)filePtr18 - (_optind + -1);\n            filePtr18 = (FILE *)(ulong)uintVar16;\n            _optind = 0;\n            if (1 < (int)uintVar16) goto LAB_001063a3;\n            goto LAB_001065a2;\n          }\nLAB_001066aa:\n          FILEPtrUnaff_R12 = (FILE *)((ulong)filePtr_local_130 & 0xff);\n          uintVar16 = (uint)FILEPtrUnaff_R12;\n          uintPtrPtr36 = (undefined **)((int *)pcVar46 + (long)_optind * 2);\n          if (_DAT_0010d658 == 0) {\n            if (_DAT_0010d654 != 0) {\n              FUN_001075e0(&DAT_0010807c);\n              goto LAB_00107591;\n            }\n            if (_DAT_0010d650 == 0) {\n              filePtr28 = (FILE *)pcVar46;\n              if (*uintPtrPtr36 == (undefined *)0x0) goto switchD_00107462_caseD_1;\n              if (DAT_0010d64c == 7) {\n                if (DAT_0010d648 == 0) {\n                  if (uintVar44 == 3) goto LAB_00106abc;\n                  if (uintVar44 != 0) goto LAB_00106700;\nLAB_00106eff:\n                  charPtr39 = \"no operation specified\";\n                  goto LAB_00106803;\n                }\n                DAT_0010d64c = 2;\n                if (_DAT_0010d644 != 0) goto LAB_0010704f;\n              }\n              else if ((uintVar44 == 3) || (uintVar44 == 0)) {\n                if (DAT_0010d648 == 1) {\n                  uVar17 = FUN_00107650();\n                    \n                  xexit(uVar17);\n                }\nLAB_00106abc:\n                if (uintVar44 == 0) goto LAB_00106eff;\n                if (_DAT_0010d644 != 0) {\nLAB_00106ad1:\n                  charPtr39 = \"`u\\' is only meaningful with the `r\\' option.\";\n                  goto LAB_00106803;\n                }\n              }\n              else {\nLAB_00106700:\n                if (_DAT_0010d644 != 0) goto LAB_00107548;\n              }\nLAB_0010670d:\n              if (_DAT_0010d2d0 < 0) {\n                _DAT_0010d2d0 = 1;\n              }\nLAB_00106720:\n              charPtrUnaff_RBP = (char *)0x0;\n              if (DAT_0010d640 != 0) {\n                DAT_0010d638 = (long)*uintPtrPtr36;\n                charPtrUnaff_RBP = (char *)0x1;\n                charPtr39 = \"missing position arg.\";\n                if (DAT_0010d638 == 0) goto LAB_00106803;\n              }\n              if (DAT_0010d634 != '\\0') {\n                charPtr39 = \"`N\\' is only meaningful with the `x\\' and `d\\' options.\";\n                if ((DAT_0010d64c & 0xfffffffb) == 1) {\n                  intVar15 = (int)charPtrUnaff_RBP;\n                  if (*(char **)((long)uintPtrPtr36 + (long)intVar15 * 2 * 4) == (char *)0x0) {\n                    uVar27 = dcgettext(0,\"`N\\' missing value.\",5);\n                    FUN_00107690(uVar27);\n                    uintVar44 = extraout_EDX;\nLAB_00107548:\n                    if (uintVar44 == 2) {\nLAB_0010704f:\n                      charPtr39 = \"`u\\' is not meaningful with the `D\\' option.\";\n                      if (_DAT_0010d2d0 < 1) goto code_r0x00107068;\n                      goto LAB_00106803;\n                    }\n                    goto LAB_00106ad1;\n                  }\n                  charPtrUnaff_RBP = (char *)(ulong)(intVar15 + 1);\n                  longVar24 = strtol(*(char **)((long)uintPtrPtr36 + (long)intVar15 * 2 * 4),(char **)0x0,10)\n                  ;\n                  charPtr39 = \"Value for `N\\' must be positive.\";\n                  _DAT_0010d630 = (int)longVar24;\n                  if (0 < _DAT_0010d630) goto LAB_0010673c;\n                }\n                goto LAB_00106803;\n              }\nLAB_0010673c:\n              longVar24 = (long)(int)charPtrUnaff_RBP;\n              filePtr22 = (FILE *)charPtrUnaff_RBP;\n              if (*(long *)(int *)((long)uintPtrPtr36 + longVar24 * 2 * 4) == 0)\n              goto switchD_00107462_caseD_1;\n              filePtr22 = (FILE *)((long)uintPtrPtr36 + (longVar24 + 1) * 2 * 4);\n              if (*(FILE **)filePtr22 == (FILE *)0x0) {\n                charPtr43 = (char *)0x0;\n                filePtr22 = (FILE *)0x0;\n              }\n              else if (*(long *)((long)uintPtrPtr36 + (longVar24 + 2) * 2 * 4) == 0) {\n                charPtr43 = (char *)0x1;\n              }\n              else if (*(long *)((long)uintPtrPtr36 + (longVar24 + 3) * 2 * 4) == 0) {\n                charPtr43 = (char *)0x2;\n              }\n              else if (*(long *)((long)uintPtrPtr36 + (longVar24 + 4) * 2 * 4) == 0) {\n                charPtr43 = (char *)0x3;\n              }\n              else if (*(long *)((long)uintPtrPtr36 + (longVar24 + 5) * 2 * 4) == 0) {\n                charPtr43 = (char *)0x4;\n              }\n              else {\n                filePtr18 = (FILE *)0x5;\n                do {\n                  charPtr43 = (char *)filePtr18;\n                  filePtr18 = (FILE *)((long)(int *)charPtr43 + 1);\n                } while (*(long *)((int *)((long)uintPtrPtr36 + longVar24 * 2 * 4) + (long)filePtr18 * 2) !=\n                         0);\n              }\n              ulongPtr26 = (undefined8 *)FUN_00105300();\n              filePtr18 = filePtr22;\n              if (DAT_0010d64c == 5) {\n                charPtr39 = \"`x\\' cannot be used on thin archives.\";\n                if ((*(byte *)((long)ulongPtr26 + 0x49) & 0x10) == 0) {\n                  charPtrUnaff_RBP = (char *)filePtr22;\n                  if (DAT_0010d628 != (char *)0x0) goto LAB_00106d5c;\nswitchD_00106ed8_caseD_5:\n                  FUN_00105480(ulongPtr26,FUN_00107740,charPtrUnaff_RBP,(ulong)charPtr43 & 0xffffffff);\n                  goto LAB_0010696c;\n                }\n                goto LAB_00106803;\n              }\n              if (DAT_0010d628 != (char *)0x0) {\nLAB_00106d5c:\n                size_tVar19 = strlen(DAT_0010d628);\n                pcVar46 = \"__.LIBDEP\";\n                charPtrUnaff_RBP = (char *)(size_tVar19 + 1);\n                DAT_0010d620 = bfd_create(\"__.LIBDEP\",ulongPtr26);\n                if (DAT_0010d620 == 0) {\n                  charPtr39 = \"Cannot create libdeps record.\";\n                }\n                else {\n                  longVar24 = bfd_find_target(\"binary\",DAT_0010d620);\n                  charPtr39 = \"Cannot set libdeps record type to binary.\";\n                  if (longVar24 != 0) {\n                    charVar14 = bfd_set_format(DAT_0010d620,1,5);\n                    charPtr39 = \"Cannot set libdeps object format.\";\n                    if (charVar14 == '\\0') goto LAB_00106803;\n                    charVar14 = bfd_make_writable(DAT_0010d620,\"Cannot set libdeps object format.\",5);\n                    charPtr39 = \"Cannot make libdeps object writable.\";\n                    if (charVar14 == '\\0') goto LAB_00106803;\n                    filePtr28 = (FILE *)bfd_bwrite(DAT_0010d628,charPtrUnaff_RBP,DAT_0010d620);\n                    charPtr39 = \"Cannot write libdeps record.\";\n                    if (filePtr28 != (FILE *)charPtrUnaff_RBP) goto LAB_00106803;\n                    charVar14 = bfd_make_readable(DAT_0010d620,\"Cannot write libdeps record.\",5);\n                    charPtr39 = \"Cannot make libdeps object readable.\";\n                    if (charVar14 == '\\0') goto LAB_00106803;\n                    longVar24 = bfd_find_target(\"plugin\",DAT_0010d620,5);\n                    charPtr39 = \"Cannot reset libdeps record type.\";\n                    if (longVar24 == 0) goto LAB_00106803;\n                    intVar15 = (int)charPtr43;\n                    filePtr_local_130 = (FILE *)((long)(intVar15 + 2) * 8);\n                    charPtrUnaff_RBP = (char *)xmalloc(filePtr_local_130,\"Cannot reset libdeps record type.\");\n                    if (intVar15 == 0) {\n                      longVar24 = 0;\n                    }\n                    else {\n                      uVar17 = *(undefined4 *)&filePtr22->field_0x4;\n                      *(int *)charPtrUnaff_RBP = filePtr22->_flags;\n                      *(undefined4 *)((long)charPtrUnaff_RBP + 4) = uVar17;\n                      longVar24 = 8;\n                      charPtrPtr31 = (char **)((long)charPtrUnaff_RBP + 8);\n                      for (charPtr43 = filePtr_local_130[-1]._unused2 + 4; charPtr43 != (char *)0x0;\n                          charPtr43 = charPtr43 + -1) {\n                        *(undefined *)charPtrPtr31 = *(undefined *)&filePtr22->_flags;\n                        filePtr22 = (FILE *)((long)filePtr22 + (ulong)byteVar48 * -2 + 1);\n                        charPtrPtr31 = (char **)((long)charPtrPtr31 + (ulong)byteVar48 * -2 + 1);\n                      }\n                    }\n                    *(char **)((long)(char **)charPtrUnaff_RBP + longVar24) = \"__.LIBDEP\";\n                    charPtr43 = (char *)(ulong)(intVar15 + 1);\n                    *(undefined8 *)\n                     (((FILE *)((long)charPtrUnaff_RBP + -0xd8))->_unused2 + 0xc + (long)filePtr_local_130) = 0;\n                    switch(DAT_0010d64c) {\n                    case 1:\n                      goto switchD_00106ed8_caseD_1;\n                    case 2:\n                    case 7:\n                      break;\n                    case 3:\n                      goto switchD_00106ed8_caseD_3;\n                    case 4:\n                      goto switchD_00106ed8_caseD_4;\n                    case 5:\n                      goto switchD_00106ed8_caseD_5;\n                    case 6:\n                      filePtr22 = (FILE *)charPtrUnaff_RBP;\n                      if (_DAT_0010d610 == 0) goto LAB_00106afb;\n                      break;\n                    default:\n                      goto switchD_001067e8_caseD_5;\n                    }\n                    goto switchD_00106ed8_caseD_2;\n                  }\n                }\n                goto LAB_00106803;\n              }\n              switch(DAT_0010d64c) {\n              case 1:\n                charPtrUnaff_RBP = (char *)filePtr22;\n                if (filePtr22 == (FILE *)0x0) break;\nswitchD_00106ed8_caseD_1:\n                filePtr18 = (FILE *)0x0;\n                goto LAB_00106b89;\n              case 2:\n              case 7:\nswitchD_001067e8_caseD_2:\n                charPtrUnaff_RBP = (char *)filePtr22;\n                if ((filePtr22 != (FILE *)0x0) || (0 < DAT_0010d648)) {\nswitchD_00106ed8_caseD_2:\n                  FUN_00105570(ulongPtr26,charPtrUnaff_RBP,DAT_0010d64c == 7);\n                  goto LAB_0010696c;\n                }\n                break;\n              case 3:\n                charPtrUnaff_RBP = (char *)filePtr22;\nswitchD_00106ed8_caseD_3:\n                FUN_00105480(ulongPtr26,FUN_00107890,charPtrUnaff_RBP,(ulong)charPtr43 & 0xffffffff);\n                goto LAB_0010696c;\n              case 4:\n                charPtrUnaff_RBP = (char *)filePtr22;\nswitchD_00106ed8_caseD_4:\n                FUN_00105480(ulongPtr26,FUN_00103a78,charPtrUnaff_RBP,(ulong)charPtr43 & 0xffffffff);\n                goto LAB_0010696c;\n              default:\nswitchD_001067e8_caseD_5:\n                charPtr39 = \"internal error -- this option not implemented\";\n                goto LAB_00106803;\n              case 6:\n                if (_DAT_0010d610 != 0) goto switchD_001067e8_caseD_2;\n                if (filePtr22 == (FILE *)0x0) break;\nLAB_00106afb:\n                filePtr18 = (FILE *)(ulongPtr26 + 0x1e);\n                do {\n                  FILEPtrUnaff_R12 = filePtr18;\n                  if (*(FILE **)filePtr22 == (FILE *)0x0) {\nLAB_00106b9f:\n                    FUN_001058b0(ulongPtr26);\n                    goto LAB_0010696c;\n                  }\n                  while( true ) {\n                    longPtr21 = *(long **)FILEPtrUnaff_R12;\n                    pcVar46 = *(char **)filePtr22;\n                    if (longPtr21 == (long *)0x0) {\n                      uVar27 = *ulongPtr26;\n                      uVar30 = dcgettext(0,\"no entry %s in archive %s!\",5);\n                      FUN_00107690(uVar30,pcVar46,uVar27);\n                      charPtr43 = (char *)0x0;\n                      goto LAB_00107293;\n                    }\n                    longVar24 = *longPtr21;\n                    uVar27 = FUN_00105830(pcVar46,ulongPtr26);\n                    intVar15 = filename_cmp(uVar27,longVar24);\n                    if (intVar15 == 0) break;\n                    FILEPtrUnaff_R12 = (FILE *)(*(long **)FILEPtrUnaff_R12 + 0x1e);\n                  }\n                  *(long **)FILEPtrUnaff_R12 = (long *)longPtr21[0x1e];\n                  plongPtr29 = (long **)FUN_00105870(filePtr18,3,0);\n                  boolVar47 = DAT_0010d60c != 0;\n                  longPtr4 = *plongPtr29;\n                  *plongPtr29 = longPtr21;\n                  longPtr21[0x1e] = (long)longPtr4;\n                  if (boolVar47) {\n                    printf(\"m - %s\\n\",*(FILE **)filePtr22);\n                  }\n                  filePtr22 = (FILE *)&filePtr22->_IO_read_ptr;\n                } while( true );\n              }\n              goto LAB_00106d4e;\n            }\n            if (-1 < _DAT_0010d2d0) goto LAB_0010755f;\n          }\n          else {\nLAB_00107591:\n            FUN_0010342d(1);\n          }\n          _DAT_0010d2d0 = 1;\nLAB_0010755f:\n          intVar15 = fileno(_stdin);\n          _DAT_0010d608 = isatty(intVar15);\n          FUN_00103e95();\nLAB_0010696c:\n                    \n          xexit(0);\n        }\n        uVar17 = bfd_get_error();\n        filePtr22 = (FILE *)bfd_errmsg(uVar17);\n        uVar27 = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n        intVar15 = FUN_00107690(uVar27,\"x86_64-pc-linux-gnu\",filePtr22);\nLAB_0010751b:\n        if (DAT_0010d64c == 0) {\nLAB_00107447:\n          uintPtrPtr36 = (undefined **)charPtr39;\n          filePtr28 = (FILE *)pcVar46;\n          switch(intVar15) {\n          case 0:\n            goto switchD_00107462_caseD_0;\n          default:\n            goto switchD_00107462_caseD_1;\n          case 0x44:\n            _DAT_0010d2d0 = 1;\n            goto LAB_001065a2;\n          case 0x4d:\n            _DAT_0010d650 = 1;\n            goto LAB_001065a2;\n          case 0x4e:\n            DAT_0010d634 = '\\x01';\n            goto LAB_001065a2;\n          case 0x4f:\n            _DAT_0010d5fc = 1;\n            goto LAB_001065a2;\n          case 0x50:\n            DAT_0010d5f9 = 1;\n            goto LAB_001065a2;\n          case 0x53:\n            DAT_0010d648 = -1;\n            goto LAB_001065a2;\n          case 0x54:\n            DAT_0010d5f8 = 1;\n            goto LAB_001065a2;\n          case 0x55:\n            _DAT_0010d2d0 = 0;\n            goto LAB_001065a2;\n          case 0x56:\n            _DAT_0010d654 = 1;\n            goto LAB_001065a2;\n          case 0x61:\n            DAT_0010d640 = 2;\n            goto LAB_001065a2;\n          case 0x62:\n          case 0x69:\n            DAT_0010d640 = 1;\n            goto LAB_001065a2;\n          case 99:\n            _DAT_0010d610 = 1;\n            goto LAB_001065a2;\n          case 100:\n            DAT_0010d64c = 1;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x66:\n            DAT_0010d5fa = 1;\n            goto LAB_001065a2;\n          case 0x68:\n            goto switchD_00107462_caseD_68;\n          case 0x6c:\n            if (DAT_0010d628 == (char *)0x0) {\n              DAT_0010d628 = _optarg;\n              goto LAB_001065a2;\n            }\nLAB_00107293:\n            uintVar16 = (uint)FILEPtrUnaff_R12;\n            charPtr39 = \"libdeps specified more than once\";\n            charPtrUnaff_RBP = (char *)filePtr22;\n            break;\n          case 0x6d:\n            DAT_0010d64c = 6;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x6f:\n            _DAT_0010d600 = 1;\n            goto LAB_001065a2;\n          case 0x70:\n            DAT_0010d64c = 4;\n            goto LAB_001065a2;\n          case 0x71:\n            DAT_0010d64c = 7;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x72:\n            DAT_0010d64c = 2;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x73:\n            DAT_0010d648 = 1;\n            goto LAB_001065a2;\n          case 0x74:\n            DAT_0010d64c = 3;\n            goto LAB_001065a2;\n          case 0x75:\n            _DAT_0010d644 = 1;\n            goto LAB_001065a2;\n          case 0x76:\n            DAT_0010d60c = 1;\n            goto LAB_001065a2;\n          case 0x78:\n            DAT_0010d64c = 5;\n            goto LAB_001065a2;\n          case 0xc9:\n            bfd_plugin_set_plugin(_optarg);\n            goto LAB_001065a2;\n          case 0xca:\n            DAT_0010d5f0 = _optarg;\n            goto LAB_001065a2;\n          case 0xcb:\n            DAT_0010d5e8 = _optarg;\n            goto LAB_001065a2;\n          }\n          goto LAB_00106803;\n        }\nLAB_001067f7:\n        charPtr39 = \"two different operation options specified\";\n        charPtrUnaff_RBP = (char *)filePtr22;\nLAB_00106803:\n        uVar27 = dcgettext(0,charPtr39,5);\n        FUN_00107690(uVar27);\nLAB_00106814:\n        intVar15 = (int)pcVar46;\n        filePtr28 = (FILE *)xmalloc(8);\n        *(long **)filePtr28 = (long *)0x0;\n        if ((FILE *)charPtr43 == argv) {\nLAB_00106834:\n          if (*(long **)charPtr43 == (long *)0x0) {\n            intVar15 = 0;\n          }\n          else {\n            longVar24 = 1;\n            do {\n              intVar15 = (int)longVar24;\n              longVar35 = longVar24 * 2;\n              longVar24 = longVar24 + 1;\n            } while (*(long *)((int *)charPtr43 + longVar35) != 0);\n          }\n          filePtr22 = (FILE *)xmalloc((long)(intVar15 + 1) << 3);\n          longPtr21 = *(long **)charPtr43;\n          longVar24 = 0;\n          while (longPtr21 != (long *)0x0) {\n            uVar27 = xstrdup();\n            *(undefined8 *)((long)&filePtr22->_flags + longVar24) = uVar27;\n            longPtr21 = *(long **)((char *)((long)charPtr43 + 0x83) + longVar24 + -0x7b);\n            longVar24 = longVar24 + 8;\n          }\n          *(undefined8 *)((long)&filePtr22->_flags + longVar24) = 0;\nLAB_0010610a:\n          intVar15 = (int)pcVar46;\n          charPtr43 = (char *)filePtr22;\n          if (*(long **)filePtr28 == (long *)0x0) goto LAB_00106a80;\n          longVar24 = 0;\n          do {\n            longVar34 = longVar24 + 1;\n            longVar35 = longVar24 * 8;\n            longVar24 = longVar34;\n          } while (*(long *)(filePtr28->_shortbuf + longVar35 + -0x7b) != 0);\n          size_t_local_108 = longVar34 * 8;\n        }\n        else {\nLAB_00106a80:\n          longVar34 = 0;\n          size_t_local_108 = 0;\n        }\n        longVar24 = (long)charPtrUnaff_RBP * 2;\n        charPtrUnaff_RBP = (char *)((long)(char **)charPtrUnaff_RBP + longVar34);\n        free(*(void **)((int *)charPtr43 + longVar24));\n        filePtr22 = (FILE *)xrealloc(charPtr43,(longVar34 + 1 + (long)intVar15) * 8);\n        uintVar44 = intVar15 + -1 + (int)longVar34;\n        pcVar46 = (char *)(ulong)uintVar44;\n        memmove(&filePtr22->_flags + (long)charPtrUnaff_RBP * 2,\n                (void *)((long)&filePtr22->_IO_read_ptr + (long)filePtr_local_130),\n                (long)(int)(intVar15 - uintVar16) << 3);\n        memcpy((void *)((long)&filePtr_local_130->_flags + (long)&filePtr22->_flags),filePtr28,size_t_local_108);\n        free(filePtr28);\n        free(bytePtr_local_118);\n        fclose(filePtr18);\n        uintVar16 = (int)filePtr_local_128 + 1;\n        FILEPtrUnaff_R12 = filePtr_local_130;\n        charPtr43 = (char *)filePtr22;\n        filePtr_local_130 = filePtr28;\n        if ((int)uintVar16 < (int)uintVar44) goto LAB_001061ce;\n      } while( true );\n    }\n    uintVar16 = uintVar16 + 1;\n    filePtr_local_128 = FILEPtrUnaff_R12;\nLAB_001061ce:\n    FILEPtrUnaff_R12 = (FILE *)(ulong)uintVar16;\n  } while( true );\nswitchD_00107462_caseD_0:\n  intVar15 = getopt_long((ulong)filePtr18 & 0xffffffff,pcVar46,filePtr22,\"x86_64-pc-linux-gnu\");\n  charPtrUnaff_RBP = (char *)filePtr22;\n  if (intVar15 == -1) goto LAB_00106680;\n  if ((0x14 < intVar15 - 100U) || ((0x117201UL >> ((byte)(intVar15 - 100U) & 0x3f) & 1) == 0))\n  goto LAB_00107447;\n  goto LAB_0010751b;\ncode_r0x00107068:\n  if (_DAT_0010d2d0 != 0) goto code_r0x0010706e;\n  goto LAB_00106720;\ncode_r0x0010706e:\n  uVar27 = dcgettext(0,\"`u\\' modifier ignored since `D\\' is the default (see `U\\')\",5);\n  FUN_00107920(uVar27);\n  goto LAB_0010670d;\nLAB_00106b89:\n  if (*(FILE **)charPtrUnaff_RBP == (FILE *)0x0) {\n    if ((char)filePtr18 != '\\0') goto LAB_00106b9f;\nLAB_00106d4e:\n    DAT_0010d618 = 0;\n    goto LAB_0010696c;\n  }\n  intVar45 = 0;\n  intVar15 = strcmp((char *)*(FILE **)charPtrUnaff_RBP,\"__.SYMDEF\");\n  ulongPtr5 = ulongPtr26;\n  if (intVar15 == 0) {\n    *(byte *)((long)ulongPtr26 + 0x49) = *(byte *)((long)ulongPtr26 + 0x49) & 0xf7;\n    DAT_0010d648 = -1;\n  }\n  else {\n    while( true ) {\n      longPtr21 = ulongPtr5 + 0x1e;\n      if ((undefined8 *)*longPtr21 == (undefined8 *)0x0) break;\n      uVar27 = *(undefined8 *)*longPtr21;\n      uVar30 = FUN_00105830(*(FILE **)charPtrUnaff_RBP,ulongPtr26);\n      intVar15 = filename_cmp(uVar30,uVar27);\n      if ((intVar15 == 0) &&\n         ((DAT_0010d634 == '\\0' || (intVar45 = intVar45 + 1, intVar45 == _DAT_0010d630)))) {\n        if (DAT_0010d60c != 0) {\n          printf(\"d - %s\\n\",*(FILE **)charPtrUnaff_RBP);\n        }\n        *longPtr21 = *(long *)(*longPtr21 + 0xf0);\n        filePtr18 = FILEPtrUnaff_R12;\n        goto LAB_00106d38;\n      }\n      ulongPtr5 = (undefined8 *)*longPtr21;\n    }\n    if (DAT_0010d60c != 0) {\n      filePtr22 = *(FILE **)charPtrUnaff_RBP;\n      pcVar46 = (char *)dcgettext(0,\"No member named `%s\\'\\n\",5);\n      printf(pcVar46,filePtr22);\n    }\n  }\nLAB_00106d38:\n  charPtrUnaff_RBP = (char *)((long)charPtrUnaff_RBP + 8);\n  goto LAB_00106b89;\n}\n\n",
            "called": [
                "bfd_close",
                "FUN_00105300",
                "FUN_00105830",
                "stat",
                "memmove",
                "bfd_init",
                "FUN_00103a78",
                "strlen",
                "getopt_long",
                "ferror",
                "FUN_00107890",
                "xexit",
                "FUN_001075e0",
                "FUN_00105870",
                "FUN_00107c10",
                "strtol",
                "bfd_get_error",
                "bfd_check_format_matches",
                "bfd_errmsg",
                "bfd_find_target",
                "bfd_set_error",
                "bindtextdomain",
                "setlocale",
                "fprintf",
                "FUN_00107c20",
                "bfd_bwrite",
                "fseek",
                "bfd_fdopenr",
                "textdomain",
                "bfd_create",
                "printf",
                "xrealloc",
                "FUN_00107730",
                "fclose",
                "FUN_00107740",
                "FUN_0010342d",
                "xstrdup",
                "strcmp",
                "FUN_00103e95",
                "FUN_00105570",
                "fileno",
                "fopen",
                "FUN_00107cc0",
                "lbasename",
                "bfd_plugin_set_program_name",
                "FUN_0010394a",
                "filename_cmp",
                "FUN_001058b0",
                "bfd_plugin_set_plugin",
                "free",
                "isatty",
                "malloc",
                "bfd_set_format",
                "FUN_00107650",
                "dcgettext",
                "memcpy",
                "xmalloc",
                "FUN_00103bd1",
                "FUN_00105480",
                "FUN_00107920",
                "fread",
                "bfd_make_readable",
                "FUN_001052a0",
                "FUN_00107690",
                "xmalloc_set_program_name",
                "bfd_make_writable",
                "bfd_set_error_program_name",
                "open",
                "FUN_00107640",
                "bfd_set_default_target",
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105db0",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "process_files_00105db0"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "FUN_00103bd1": {
            "renaming": {
                "FUN_00103bd1": "print_matching_formats_00103bd1",
                "param_1": "formatList",
                "uVar1": "dataPointer",
                "__format": "formatString",
                "plVar2": "formatPointer"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103bd1(long *formatList)\n\n{\n  undefined8 dataPointer;\n  char *formatString;\n  long *formatPointer;\n  \n  fflush(_stdout);\n  dataPointer = DAT_0010d660;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,formatString,dataPointer);\n  for (formatPointer = formatList; *formatPointer != 0; formatPointer = formatPointer + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(formatList);\n  fputc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "free",
                "fprintf",
                "fputc",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bd1",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103bd1"
        },
        "strcmp": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "strcmp"
        },
        "FUN_00107c10": {
            "renaming": {
                "FUN_00107c10": "exit_with_error_00107c10",
                "xexit": "exit"
            },
            "code": "\nvoid exitWithError_00107c10(void)\n\n{\n  FUN_00107c20();\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_00107c20",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c10",
            "calling": [
                "FUN_001058b0",
                "FUN_00105300",
                "FUN_00102d2f",
                "FUN_00105db0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "exit_with_error_00107c10"
        },
        "read": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "read"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107da8",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "FUN_00102710": {
            "renaming": {
                "FUN_00102710": "extract_and_convert_archives_00102710",
                "plVar1": "nextFilePointer",
                "cVar2": "formatStatus",
                "bVar3": "isThinLibrary",
                "iVar4": "bfdError",
                "lVar5": "filePointer",
                "uVar6": "errorMessage",
                "uVar7": "libraryName",
                "puVar8": "outputFilePointer",
                "unaff_RBP": "outputFilePath",
                "in_stack_00000008": "inputFilePath"
            },
            "code": "\n\n\nundefined8 * extractAndConvertArchives_00102710(void)\n\n{\n  long *nextFilePointer;\n  char formatStatus;\n  byte isThinLibrary;\n  int bfdError;\n  long filePointer;\n  undefined8 errorMessage;\n  undefined8 libraryName;\n  undefined8 *outputFilePointer;\n  undefined8 outputFilePath;\n  undefined8 inputFilePath;\n  \n  filePointer = bfd_openr();\n  if (filePointer != 0) {\n    formatStatus = bfd_check_format(filePointer,1);\n    if (formatStatus != '\\0') {\n      DAT_0010d5f0 = **(undefined8 **)(filePointer + 8);\n    }\n    bfd_close(filePointer);\n  }\n  outputFilePointer = (undefined8 *)bfd_openw();\n  if (((outputFilePointer != (undefined8 *)0x0) && (formatStatus = bfd_set_format(outputFilePointer,2), formatStatus != '\\0')) &&\n     (formatStatus = bfd_close(outputFilePointer), formatStatus != '\\0')) {\n    if (_DAT_0010d610 == 0) goto LAB_00102826;\n    goto LAB_001053b7;\n  }\n  FUN_00107c10();\n  do {\n    isThinLibrary = *(byte *)((long)outputFilePointer + 0x49) >> 4 & 1;\n    if (DAT_0010d5f8 == '\\0') {\n      if (isThinLibrary != 0) {\n        libraryName = *outputFilePointer;\n        errorMessage = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        FUN_00107690(errorMessage,libraryName);\n        goto LAB_00102812;\n      }\n    }\n    else if (isThinLibrary == 0) {\n      libraryName = *outputFilePointer;\n      errorMessage = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      FUN_00107690(errorMessage,libraryName);\nLAB_001027cb:\n      FUN_00107c20();\n      bfdError = bfd_get_error();\n      if (bfdError == 0xd) {\nLAB_00102812:\n        FUN_00103bd1(inputFilePath);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      nextFilePointer = outputFilePointer + 0x1e;\n      for (filePointer = bfd_openr_next_archived_file(outputFilePointer,0); filePointer != 0;\n          filePointer = bfd_openr_next_archived_file(outputFilePointer,filePointer)) {\n        *nextFilePointer = filePointer;\n        nextFilePointer = (long *)(filePointer + 0xf0);\n      }\n      *nextFilePointer = 0;\n      bfdError = bfd_get_error();\n      if (bfdError == 9) {\n        return outputFilePointer;\n      }\n      do {\n        FUN_00107c10();\nLAB_00102826:\n        libraryName = dcgettext(0,\"creating %s\",5);\n        FUN_00107920(libraryName);\nLAB_001053b7:\n        DAT_0010d618 = outputFilePath;\n        outputFilePointer = (undefined8 *)bfd_openr();\n      } while (outputFilePointer == (undefined8 *)0x0);\n      formatStatus = bfd_check_format_matches(outputFilePointer,2,&stack0x00000008);\n      if (formatStatus == '\\0') goto LAB_001027cb;\n    } while (((DAT_0010d64c != 2) && (DAT_0010d64c != 7)) ||\n            (filePointer = bfd_openr_next_archived_file(outputFilePointer,0), filePointer == 0));\n  } while( true );\n}\n\n",
            "called": [
                "bfd_openr",
                "bfd_check_format",
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102710",
            "calling": [
                "FUN_00105300"
            ],
            "imported": false,
            "current_name": "extract_and_convert_archives_00102710"
        },
        "FUN_00103e95": {
            "renaming": {
                "FUN_00103e95": "decompile_and_improve_00103e95"
            },
            "code": "\n\n\nvoid decompile_and_improve_00103e95(void)\n\n{\n  long **pplVar1;\n  char cVar2;\n  FILE **ppFVar3;\n  FILE *pFVar4;\n  long *plVar5;\n  undefined8 uVar6;\n  byte *pbVar7;\n  int iVar8;\n  char *pcVar10;\n  undefined8 uVar11;\n  int iVar9;\n  long *plVar12;\n  size_t sVar13;\n  void *pvVar14;\n  char *pcVar15;\n  char *pcVar16;\n  long lVar17;\n  long lVar18;\n  ulong uVar19;\n  uint uVar20;\n  long lVar21;\n  undefined8 *puVar22;\n  undefined8 *puVar23;\n  uint uVar24;\n  int iVar25;\n  ulong uVar26;\n  char **ppcVar27;\n  bool bVar28;\n  char **ppcVar29;\n  byte bVar30;\n  long lVar31;\n  byte *pbVar32;\n  byte *pbVar33;\n  int *piVar34;\n  byte *pbVar35;\n  uint uVar36;\n  int iVar37;\n  char **ppcVar38;\n  byte bVar39;\n  undefined auVar40 [16];\n  undefined auVar41 [16];\n  char *local_828;\n  char *local_820;\n  long local_818;\n  char **local_810;\n  int local_800;\n  uint local_7fc;\n  byte *local_7f8;\n  stat local_7d0;\n  char local_740 [200];\n  char *local_678 [201];\n  \n  bVar39 = 0;\n  lVar18 = 0;\n  DAT_0010d550 = -2;\n  ppcVar29 = local_678;\n  local_800 = 0;\n  local_828 = local_740;\n  local_818 = 200;\n  local_820 = local_828;\n  local_810 = ppcVar29;\nLAB_00103ee9:\n  *local_828 = (char)lVar18;\n  if (local_820 + local_818 + -1 <= local_828) {\n    lVar21 = (long)local_828 - (long)local_820;\n    lVar17 = lVar21 + 1;\n    if (local_818 < 10000) {\n      lVar31 = local_818 * 2;\n      local_818 = 10000;\n      if (lVar31 < 0x2711) {\n        local_818 = lVar31;\n      }\n      pcVar10 = (char *)malloc(local_818 * 9 + 7);\n      if (pcVar10 != (char *)0x0) {\n        lVar31 = lVar17 * 8;\n        pcVar15 = local_820;\n        pcVar16 = pcVar10;\n        for (; lVar17 != 0; lVar17 = lVar17 + -1) {\n          *pcVar16 = *pcVar15;\n          pcVar15 = pcVar15 + (ulong)bVar39 * -2 + 1;\n          pcVar16 = pcVar16 + (ulong)bVar39 * -2 + 1;\n        }\n        ppcVar38 = (char **)(pcVar10 + local_818);\n        ppcVar29 = ppcVar38;\n        for (; lVar31 != 0; lVar31 = lVar31 + -1) {\n          *(undefined *)ppcVar29 = *(undefined *)local_810;\n          local_810 = (char **)((long)local_810 + (ulong)bVar39 * -2 + 1);\n          ppcVar29 = (char **)((long)ppcVar29 + (ulong)bVar39 * -2 + 1);\n        }\n        if (local_820 != local_740) {\n          free(local_820);\n        }\n        local_828 = pcVar10 + lVar21;\n        ppcVar29 = ppcVar38 + lVar21;\n        local_820 = pcVar10;\n        local_810 = ppcVar38;\n        if (pcVar10 + local_818 + -1 <= local_828) goto LAB_00105265;\n        goto LAB_00103fd8;\n      }\n    }\n    FUN_001031a5();\nLAB_0010524c:\n    pcVar10 = local_820;\n    if (local_820 == local_740) {\n      return;\n    }\nLAB_00105265:\n    free(pcVar10);\n    return;\n  }\nLAB_00103fd8:\n  iVar37 = (int)lVar18;\n  if (iVar37 == 3) goto LAB_0010524c;\n  cVar2 = (&DAT_0010a200)[iVar37];\n  if (cVar2 != -0xe) {\n    if (DAT_0010d550 == -2) {\n      if (_DAT_0010d540 == 0) {\n        _DAT_0010d540 = 1;\n        if (DAT_0010d5d0 == 0) {\n          DAT_0010d5d0 = 1;\n        }\n        if (DAT_0010d590 == (FILE *)0x0) {\n          DAT_0010d590 = _stdin;\n        }\n        if (DAT_0010d538 == (FILE *)0x0) {\n          DAT_0010d538 = _stdout;\n        }\n        if ((DAT_0010d5a8 == 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) == 0)) {\n          FUN_00103df9();\n          puVar22 = (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          uVar11 = FUN_001033d6(DAT_0010d590);\n          *puVar22 = uVar11;\n        }\n        FUN_001030ed();\n      }\nLAB_001040b1:\n      *DAT_0010d5b0 = DAT_0010d588;\n      pbVar32 = DAT_0010d5b0;\n      pbVar35 = DAT_0010d5b0;\n      uVar20 = DAT_0010d5d0;\nLAB_001040d4:\n      uVar19 = (ulong)uVar20;\n      uVar26 = (ulong)local_7fc;\n      bVar28 = false;\n      do {\n        bVar30 = (&DAT_0010ab00)[*pbVar35];\n        if (*(short *)(&DAT_0010a980 + (long)(int)uVar19 * 2) != 0) {\n          bVar28 = true;\n          uVar26 = uVar19 & 0xffffffff;\n          local_7f8 = pbVar35;\n        }\n        while( true ) {\n          iVar8 = (int)uVar19;\n          lVar18 = (long)(int)((int)*(short *)(&DAT_0010a640 + (long)iVar8 * 2) + (uint)bVar30);\n          if (iVar8 == *(short *)(&DAT_0010a440 + lVar18 * 2)) break;\n          uVar19 = (ulong)(uint)(int)*(short *)(&DAT_0010a800 + (long)iVar8 * 2);\n          if (0xb0 < *(short *)(&DAT_0010a800 + (long)iVar8 * 2)) {\n            bVar30 = (&DAT_0010a7c0)[(int)(uint)bVar30];\n          }\n        }\n        pbVar35 = pbVar35 + 1;\n        uVar19 = (ulong)*(short *)(&DAT_0010a240 + lVar18 * 2);\n      } while (*(short *)(&DAT_0010a640 + uVar19 * 2) != 0xc2);\n      local_7fc = (uint)uVar26;\n      pbVar33 = pbVar32;\n      if (bVar28) {\n        DAT_0010d5b8 = local_7f8;\n        DAT_0010d5c0 = local_7fc;\n      }\nLAB_0010419f:\n      iVar8 = (int)*(short *)(&DAT_0010a980 + (long)(int)uVar19 * 2);\n      if (iVar8 == 0) {\n        iVar8 = (int)*(short *)(&DAT_0010a980 + (long)(int)DAT_0010d5c0 * 2);\n        pbVar35 = DAT_0010d5b8;\n      }\n      DAT_0010d530 = (int)pbVar35 - (int)pbVar33;\n      DAT_0010d588 = *pbVar35;\n      DAT_0010d5b0 = pbVar35;\n      DAT_0010d5c8 = pbVar33;\n      *pbVar35 = 0;\nLAB_001041f0:\n      pbVar32 = DAT_0010d5c8;\n      lVar18 = DAT_0010d5a0;\n      switch(iVar8) {\n      case 0:\n        goto switchD_00104200_caseD_0;\n      case 1:\n      case 0x10:\n        DAT_0010d550 = 0x105;\n        break;\n      case 2:\n      case 0x11:\n        DAT_0010d550 = 0x107;\n        break;\n      case 3:\n      case 0x12:\n        DAT_0010d550 = 0x108;\n        break;\n      case 4:\n      case 0x13:\n        DAT_0010d550 = 0x109;\n        break;\n      case 5:\n      case 0x14:\n        DAT_0010d550 = 0x10a;\n        break;\n      case 6:\n      case 0x15:\n        DAT_0010d550 = 0x10b;\n        break;\n      case 7:\n      case 0x16:\n        DAT_0010d550 = 0x10c;\n        break;\n      case 8:\n      case 0x17:\n        DAT_0010d550 = 0x10d;\n        break;\n      case 9:\n      case 0x18:\n        DAT_0010d550 = 0x10e;\n        break;\n      case 10:\n      case 0x19:\n        DAT_0010d550 = 0x10f;\n        break;\n      case 0xb:\n      case 0x1a:\n        DAT_0010d550 = 0x106;\n        break;\n      case 0xc:\n      case 0x1b:\n        DAT_0010d550 = 0x113;\n        break;\n      case 0xd:\n      case 0x1c:\n        DAT_0010d550 = 0x111;\n        break;\n      case 0xe:\n      case 0x1d:\n        DAT_0010d550 = 0x103;\n        break;\n      case 0x1f:\n        DAT_0010d554 = DAT_0010d554 + 1;\n        goto LAB_001040b1;\n      case 0x20:\n        DAT_0010d550 = 0x28;\n        break;\n      case 0x21:\n        DAT_0010d550 = 0x29;\n        break;\n      case 0x22:\n        DAT_0010d550 = 0x2c;\n        break;\n      case 0x23:\n        DAT_0010d548 = (char *)xstrdup(DAT_0010d5c8);\n        DAT_0010d550 = 0x104;\n        break;\n      case 0x24:\n      case 0x25:\n      case 0x26:\n        goto LAB_001040b1;\n      case 0x27:\n        DAT_0010d554 = DAT_0010d554 + 1;\n        DAT_0010d550 = 0x102;\n        break;\n      case 0x28:\n        fwrite(DAT_0010d5c8,(long)DAT_0010d530,1,DAT_0010d538);\n        goto LAB_001040b1;\n      case 0x29:\n        goto switchD_00104200_caseD_29;\n      case 0x2a:\n        DAT_0010d550 = 0;\n        break;\n      default:\n        FUN_001033b0(\"fatal flex scanner internal error--no action found\");\n      case 0xf:\n      case 0x1e:\n        DAT_0010d550 = 0x112;\n      }\n      lVar18 = (long)iVar37;\n    }\n    if (0 < DAT_0010d550) {\n      if (DAT_0010d550 != 0x100) {\n        iVar37 = 2;\n        if (DAT_0010d550 < 0x114) {\n          iVar37 = (int)(char)(&DAT_0010a0e0)[DAT_0010d550];\n        }\n        goto LAB_0010497d;\n      }\n      DAT_0010d550 = 0x101;\n      goto LAB_001051f0;\n    }\n    iVar37 = 0;\n    DAT_0010d550 = 0;\nLAB_0010497d:\n    uVar20 = cVar2 + iVar37;\n    if ((0x22 < uVar20) || (iVar37 != (char)(&DAT_0010a0a0)[(int)uVar20])) goto LAB_001049db;\n    cVar2 = (&DAT_0010a060)[(int)uVar20];\n    lVar18 = (long)cVar2;\n    if (cVar2 < '\\x01') {\n      iVar37 = -(int)cVar2;\n      goto LAB_00104a0a;\n    }\n    DAT_0010d550 = -2;\n    local_800 = local_800 + -1 + (uint)(local_800 == 0);\n    ppcVar29 = ppcVar29 + 1;\n    *ppcVar29 = DAT_0010d548;\n    goto LAB_001049d1;\n  }\nLAB_001049db:\n  iVar37 = (int)(char)(&DAT_0010a020)[(int)lVar18];\n  if ((&DAT_0010a020)[(int)lVar18] == '\\0') {\n    if (local_800 == 0) {\n      _DAT_0010d544 = _DAT_0010d544 + 1;\n      FUN_001031a5();\nLAB_001051f0:\n      do {\n        if (((((char)(&DAT_0010a200)[lVar18] != -0xe) &&\n             (uVar20 = (int)(char)(&DAT_0010a200)[lVar18] + 1, uVar20 < 0x23)) &&\n            ((&DAT_0010a0a0)[(int)uVar20] == '\\x01')) &&\n           (lVar18 = (long)(char)(&DAT_0010a060)[(int)uVar20],\n           '\\0' < (char)(&DAT_0010a060)[(int)uVar20])) goto LAB_00105227;\n        if (local_820 == local_828) goto LAB_0010524c;\n        local_828 = local_828 + -1;\n        ppcVar29 = ppcVar29 + -1;\n        lVar18 = (long)*local_828;\n      } while( true );\n    }\n    if (local_800 != 3) goto LAB_001051f0;\n    if (0 < DAT_0010d550) {\n      DAT_0010d550 = -2;\n      goto LAB_001051f0;\n    }\n    if (DAT_0010d550 != 0) goto LAB_001051f0;\n    goto LAB_0010524c;\n  }\nLAB_00104a0a:\n  uVar11 = DAT_0010d660;\n  ppcVar27 = DAT_0010d558;\n  cVar2 = (&DAT_00109fe0)[iVar37];\n  ppcVar38 = (char **)ppcVar29[1 - cVar2];\n  switch(iVar37) {\n  case 2:\n  case 6:\n    FUN_00103ba8();\n    break;\n  case 0x13:\n    if (DAT_0010d558 == (char **)0x0) {\n      return;\n    }\n    bfd_cache_close();\n    unlink(*DAT_0010d558);\n    return;\n  case 0x15:\n    FUN_001031a5();\n    break;\n  case 0x17:\n    puVar22 = (undefined8 *)*ppcVar29;\n    if (DAT_0010d558 == (char **)0x0) {\n      pcVar10 = \"%s: no open archive\\n\";\nLAB_00104b62:\n      pcVar10 = (char *)dcgettext(0,pcVar10,5);\n      fprintf(_stderr,pcVar10,uVar11);\n      FUN_0010315d();\n    }\n    else {\n      for (; puVar22 != (undefined8 *)0x0; puVar22 = (undefined8 *)puVar22[1]) {\n        for (puVar23 = (undefined8 *)DAT_0010d558[0x1f]; puVar23 != (undefined8 *)0x0;\n            puVar23 = (undefined8 *)puVar23[0x1e]) {\n          iVar8 = filename_cmp(*puVar23);\n          if (iVar8 == 0) {\n            FUN_00107740();\n            goto LAB_00104adf;\n          }\n        }\n        bfd_openr(*puVar22,0);\n        uVar6 = DAT_0010d660;\n        uVar11 = *puVar22;\n        pcVar10 = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pcVar10,uVar6,uVar11);\nLAB_00104adf:\n      }\n    }\n    break;\n  case 0x18:\n    puVar22 = (undefined8 *)*ppcVar29;\n    if (DAT_0010d558 == (char **)0x0) {\nLAB_00104b4f:\n      pcVar10 = \"%s: no open output archive\\n\";\n      goto LAB_00104b62;\n    }\n    for (; puVar22 != (undefined8 *)0x0; puVar22 = (undefined8 *)puVar22[1]) {\n      bVar28 = false;\n      ppcVar27 = DAT_0010d558 + 0x1f;\n      for (pcVar10 = DAT_0010d558[0x1f]; pcVar10 != (char *)0x0;\n          pcVar10 = *(char **)(pcVar10 + 0xf0)) {\n        iVar8 = filename_cmp();\n        if (iVar8 == 0) {\n          pcVar15 = (char *)bfd_openr(*puVar22,0);\n          uVar11 = DAT_0010d660;\n          if (pcVar15 == (char *)0x0) {\n            uVar6 = *puVar22;\n            pcVar15 = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n            fprintf(_stderr,pcVar15,uVar11,uVar6);\n            FUN_0010315d();\n          }\n          else {\n            *ppcVar27 = pcVar15;\n            bVar28 = true;\n            *(undefined8 *)(pcVar15 + 0xf0) = *(undefined8 *)(pcVar10 + 0xf0);\n          }\n        }\n        else {\n          ppcVar27 = (char **)(pcVar10 + 0xf0);\n        }\n      }\n      if (!bVar28) {\n        pcVar10 = (char *)bfd_openr(*puVar22,0);\n        uVar6 = DAT_0010d660;\n        uVar11 = *puVar22;\n        pcVar15 = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pcVar15,uVar6,uVar11);\n        uVar11 = DAT_0010d660;\n        if (pcVar10 == (char *)0x0) {\n          uVar6 = *puVar22;\n          pcVar10 = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n          fprintf(_stderr,pcVar10,uVar11,uVar6);\n          FUN_0010315d();\n        }\n        else {\n          *ppcVar27 = pcVar10;\n        }\n      }\n    }\n    break;\n  case 0x19:\n    if (DAT_0010d558 != (char **)0x0) {\n      DAT_0010d558[0x1f] = (char *)0x0;\n    }\n    break;\n  case 0x1a:\n    puVar22 = (undefined8 *)*ppcVar29;\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    for (; puVar22 != (undefined8 *)0x0; puVar22 = (undefined8 *)puVar22[1]) {\n      bVar28 = false;\n      ppcVar27 = DAT_0010d558 + 0x1f;\n      for (puVar23 = (undefined8 *)DAT_0010d558[0x1f]; uVar11 = DAT_0010d660,\n          puVar23 != (undefined8 *)0x0; puVar23 = (undefined8 *)puVar23[0x1e]) {\n        iVar8 = filename_cmp(*puVar23,*puVar22);\n        if (iVar8 == 0) {\n          bVar28 = true;\n          *ppcVar27 = (char *)puVar23[0x1e];\n        }\n        else {\n          ppcVar27 = (char **)(puVar23 + 0x1e);\n        }\n      }\n      if (!bVar28) {\n        uVar6 = *puVar22;\n        pcVar10 = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pcVar10,uVar11,uVar6);\n        FUN_0010315d();\n      }\n    }\n    break;\n  case 0x1b:\n    puVar22 = (undefined8 *)*ppcVar29;\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    for (; puVar22 != (undefined8 *)0x0; puVar22 = (undefined8 *)puVar22[1]) {\n      pcVar10 = (char *)bfd_openr(*puVar22,\"plugin\");\n      uVar11 = DAT_0010d660;\n      ppcVar27 = DAT_0010d558;\n      if (pcVar10 == (char *)0x0) {\n        uVar6 = *puVar22;\n        pcVar10 = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n        fprintf(_stderr,pcVar10,uVar11,uVar6);\n        FUN_0010315d();\n      }\n      else {\n        *(char **)(pcVar10 + 0xf0) = DAT_0010d558[0x1f];\n        ppcVar27[0x1f] = pcVar10;\n      }\n    }\n    break;\n  case 0x1c:\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    pcVar10 = *DAT_0010d558;\n    DAT_0010d60c = 1;\n    DAT_0010d578 = _stdout;\n    pcVar15 = (char *)dcgettext(0,\"Current open archive is %s\\n\",5);\n    printf(pcVar15,pcVar10);\n    for (pcVar10 = DAT_0010d558[0x1f]; pcVar10 != (char *)0x0; pcVar10 = *(char **)(pcVar10 + 0xf0))\n    {\n      FUN_00103ddc(pcVar10,0);\n    }\n    break;\n  case 0x1d:\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    if (0 < _DAT_0010d2d0) {\n      *(uint *)((long)DAT_0010d558 + 0x44) = *(uint *)((long)DAT_0010d558 + 0x44) | 0x2000;\n    }\n    DAT_0010d568 = dup(DAT_0010d568);\n    bfd_close(ppcVar27);\n    pcVar10 = DAT_0010d570;\n    iVar8 = stat(DAT_0010d570,&local_7d0);\n    if ((iVar8 != 0) && (DAT_0010d558 = (char **)bfd_openw(pcVar10,0), DAT_0010d558 != (char **)0x0)\n       ) {\n      bfd_set_format(DAT_0010d558,2);\n      bfd_close(DAT_0010d558);\n    }\n    FUN_00105bc0(DAT_0010d560,DAT_0010d570,DAT_0010d568);\n    DAT_0010d558 = (char **)0x0;\n    free(DAT_0010d560);\n    free(DAT_0010d570);\n    break;\n  case 0x1e:\n    FUN_00103c60(*ppcVar29,0);\n    break;\n  case 0x1f:\n    FUN_00103c60(*ppcVar29,1);\n    break;\n  case 0x20:\n    pcVar10 = *ppcVar29;\n    if (DAT_0010d558 == (char **)0x0) {\n      pcVar10 = \"%s: no output archive specified yet\\n\";\n      goto LAB_00104b62;\n    }\n    lVar18 = FUN_00105300(ppcVar29[-1],0);\n    if (lVar18 != 0) {\n      FUN_001032a8(lVar18,FUN_0010312d,pcVar10);\n    }\n    break;\n  case 0x21:\n    pcVar10 = *ppcVar29;\n    pcVar15 = ppcVar29[-1];\n    uVar11 = FUN_00105300(ppcVar29[-2],0);\n    if (pcVar10 == (char *)0x0) {\n      DAT_0010d578 = _stdout;\n    }\n    else {\n      DAT_0010d578 = fopen(pcVar10,\"w\");\n      if (DAT_0010d578 != (FILE *)0x0) {\n        FUN_001032a8(uVar11,FUN_00103ddc,pcVar15);\n        bfd_close(uVar11);\n        fclose(DAT_0010d578);\n        break;\n      }\n      DAT_0010d578 = _stdout;\n      pcVar16 = (char *)dcgettext(0,\"Can\\'t open file %s\\n\",5);\n      fprintf(_stderr,pcVar16,pcVar10);\n    }\n    FUN_001032a8(uVar11,FUN_00103ddc,pcVar15);\n    bfd_close(uVar11);\n    break;\n  case 0x22:\n    ppcVar38 = (char **)*ppcVar29;\n    break;\n  case 0x23:\n  case 0x25:\n  case 0x27:\n    ppcVar38 = (char **)0x0;\n    break;\n  case 0x24:\n    ppcVar38 = (char **)ppcVar29[-1];\n    break;\n  case 0x26:\n    ppcVar38 = (char **)malloc(0x10);\n    pcVar10 = ppcVar29[-2];\n    *ppcVar38 = *ppcVar29;\n    ppcVar38[1] = pcVar10;\n    break;\n  case 0x2a:\n    DAT_0010d60c = (uint)(DAT_0010d60c == 0);\n  }\n  lVar18 = (long)cVar2;\n  local_828 = local_828 + -lVar18;\n  ppcVar29[1 - lVar18] = (char *)ppcVar38;\n  ppcVar29 = ppcVar29 + (1 - lVar18);\n  uVar20 = (int)(char)(&DAT_00109f80)[(char)(&DAT_00109fa0)[iVar37] + -0x18] + (int)*local_828;\n  if ((uVar20 < 0x23) && (*local_828 == (&DAT_0010a0a0)[(int)uVar20])) {\n    lVar18 = (long)(char)(&DAT_0010a060)[(int)uVar20];\n  }\n  else {\n    lVar18 = (long)(char)(&DAT_00109f60)[(char)(&DAT_00109fa0)[iVar37] + -0x18];\n  }\n  goto LAB_001049d1;\nswitchD_00104200_caseD_29:\n  iVar8 = ((int)pbVar35 - (int)DAT_0010d5c8) + -1;\n  *pbVar35 = DAT_0010d588;\n  pplVar1 = (long **)(DAT_0010d5a8 + lVar18 * 8);\n  ppFVar3 = (FILE **)*pplVar1;\n  if (*(int *)(ppFVar3 + 7) == 0) {\n    DAT_0010d598 = *(uint *)((long)ppFVar3 + 0x1c);\n    *(undefined4 *)(ppFVar3 + 7) = 1;\n    *ppFVar3 = DAT_0010d590;\n  }\n  pbVar7 = DAT_0010d5b0;\n  pFVar4 = ppFVar3[1];\n  auVar40._8_8_ = pFVar4;\n  auVar40._0_8_ = ppFVar3;\n  if ((byte *)((long)&pFVar4->_flags + (long)(int)DAT_0010d598) < DAT_0010d5b0) {\n    if ((byte *)((long)&pFVar4->_flags + (long)(int)DAT_0010d598 + 1) < DAT_0010d5b0) {\n      auVar40 = FUN_001033b0();\n    }\n    if (*(int *)(auVar40._0_8_ + 0x34) != 0) {\n      uVar20 = (int)((long)pbVar7 - (long)pbVar32) - 1;\n      for (lVar18 = 0; (int)lVar18 < (int)uVar20; lVar18 = lVar18 + 1) {\n        *(byte *)(auVar40._8_8_ + lVar18) = pbVar32[lVar18];\n      }\n      plVar12 = *pplVar1;\n      if (*(int *)(plVar12 + 7) == 2) {\n        DAT_0010d598 = 0;\n        *(undefined4 *)((long)plVar12 + 0x1c) = 0;\nLAB_0010475e:\n        pFVar4 = DAT_0010d590;\n        if (uVar20 == 0) {\n          if ((DAT_0010d5a8 == 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) == 0)) {\n            FUN_00103df9();\n            puVar22 = (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n            uVar11 = FUN_001033d6(pFVar4);\n            *puVar22 = uVar11;\n          }\n          lVar18 = DAT_0010d5a8;\n          if (DAT_0010d5a8 != 0) {\n            lVar18 = *(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          }\n          iVar9 = 1;\n          FUN_001031cf(lVar18);\n          FUN_001030ed();\n        }\n        else {\n          iVar9 = 2;\n          *(undefined4 *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x38) = 2;\n        }\n      }\n      else {\n        while( true ) {\n          plVar5 = *pplVar1;\n          uVar24 = ~uVar20 + *(int *)(plVar12 + 3);\n          if (0 < (int)uVar24) break;\n          uVar24 = (int)DAT_0010d5b0 - (int)(void *)plVar5[1];\n          if (*(int *)(plVar5 + 4) == 0) {\n            plVar5[1] = 0;\nLAB_00104626:\n            FUN_001033b0();\n            break;\n          }\n          iVar9 = *(int *)(plVar5 + 3);\n          iVar25 = iVar9;\n          if (iVar9 < 1) {\n            iVar25 = iVar9 / 8;\n          }\n          *(int *)(plVar5 + 3) = iVar25 + iVar9;\n          pvVar14 = realloc((void *)plVar5[1],(long)(iVar25 + iVar9 + 2));\n          plVar5[1] = (long)pvVar14;\n          if (pvVar14 == (void *)0x0) goto LAB_00104626;\n          DAT_0010d5b0 = (byte *)((long)pvVar14 + (long)(int)uVar24);\n          plVar12 = *pplVar1;\n        }\n        if (0x2000 < (int)uVar24) {\n          uVar24 = 0x2000;\n        }\n        uVar26 = (ulong)uVar24;\n        if (*(int *)((long)plVar5 + 0x24) == 0) {\n          piVar34 = __errno_location();\n          uVar26 = (ulong)(int)uVar24;\n          uVar19 = (ulong)(int)uVar20;\n          *piVar34 = 0;\n          goto LAB_001046c7;\n        }\n        uVar19 = 0;\n        piVar34 = (int *)(long)(int)uVar20;\n        do {\n          iVar9 = getc(DAT_0010d590);\n          uVar36 = (uint)uVar19;\n          if (iVar9 == -1) {\n            iVar9 = ferror(DAT_0010d590);\n            uVar24 = uVar36;\n            if (iVar9 != 0) {\n              do {\n                pcVar10 = \"input in flex scanner failed\";\n                FUN_001033b0();\n                do {\n                  *piVar34 = 0;\n                  clearerr((FILE *)pcVar10);\nLAB_001046c7:\n                  sVar13 = fread((void *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)\n                                         + uVar19),1,uVar26,DAT_0010d590);\n                  pcVar10 = (char *)DAT_0010d590;\n                  DAT_0010d598 = (uint)sVar13;\n                  uVar24 = DAT_0010d598;\n                  if ((DAT_0010d598 != 0) ||\n                     (iVar9 = ferror(DAT_0010d590), uVar24 = DAT_0010d598, iVar9 == 0))\n                  goto LAB_00104738;\n                } while (*piVar34 == 4);\n              } while( true );\n            }\n            break;\n          }\n          if (iVar9 == 10) {\n            *(undefined *)\n             ((long)(int *)(long)(int)uVar20 +\n             (long)(int)uVar36 + *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)) = 10;\n            uVar24 = uVar36 + 1;\n            break;\n          }\n          uVar19 = (ulong)(uVar36 + 1);\n          *(char *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8) + (long)piVar34) =\n               (char)iVar9;\n          piVar34 = (int *)((long)piVar34 + 1);\n        } while (uVar24 != uVar36 + 1);\nLAB_00104738:\n        DAT_0010d598 = uVar24;\n        uVar24 = DAT_0010d598;\n        iVar9 = 0;\n        *(uint *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x1c) = DAT_0010d598;\n        if (uVar24 == 0) goto LAB_0010475e;\n      }\n      plVar12 = (long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n      lVar18 = *plVar12;\n      uVar20 = uVar20 + DAT_0010d598;\n      if (*(int *)(lVar18 + 0x18) < (int)uVar20) {\n        iVar25 = ((int)DAT_0010d598 >> 1) + uVar20;\n        pvVar14 = realloc(*(void **)(lVar18 + 8),(long)iVar25);\n        *(void **)(lVar18 + 8) = pvVar14;\n        auVar41._8_8_ = plVar12;\n        auVar41._0_8_ = *plVar12;\n        if (*(long *)(*plVar12 + 8) == 0) {\n          auVar41 = FUN_001033b0();\n        }\n        plVar12 = auVar41._8_8_;\n        *(int *)(auVar41._0_8_ + 0x18) = iVar25 + -2;\n      }\n      DAT_0010d598 = uVar20;\n      *(undefined *)(*(long *)(*plVar12 + 8) + (long)(int)uVar20) = 0;\n      *(undefined *)(*(long *)(*plVar12 + 8) + 1 + (long)(int)uVar20) = 0;\n      pbVar32 = *(byte **)(*plVar12 + 8);\n      DAT_0010d5c8 = pbVar32;\n      if (iVar9 == 1) goto LAB_001048a4;\n      if (iVar9 == 2) goto LAB_001048ca;\n      pbVar35 = pbVar32 + iVar8;\n      DAT_0010d5b0 = pbVar35;\n      uVar20 = FUN_0010300e();\n      goto LAB_001040d4;\n    }\n    if ((long)pbVar7 - (long)pbVar32 == 1) goto LAB_001048a4;\nLAB_001048ca:\n    pbVar35 = (byte *)((long)(int)DAT_0010d598 +\n                      *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8));\n    DAT_0010d5b0 = pbVar35;\n    uVar19 = FUN_0010300e();\n    pbVar33 = DAT_0010d5c8;\n    goto LAB_0010419f;\n  }\n  pbVar35 = pbVar32 + iVar8;\n  DAT_0010d5b0 = pbVar35;\n  uVar19 = FUN_0010300e();\n  if (*(short *)(&DAT_0010a980 + (long)(int)(uint)uVar19 * 2) != 0) {\n    DAT_0010d5b8 = pbVar35;\n    DAT_0010d5c0 = (uint)uVar19;\n  }\n  uVar26 = uVar19 & 0xffffffff;\n  while( true ) {\n    iVar8 = (int)uVar26;\n    if (iVar8 == *(short *)(&DAT_0010a440 +\n                           (long)(*(short *)(&DAT_0010a640 + (long)iVar8 * 2) + 1) * 2)) break;\n    uVar26 = (ulong)(uint)(int)*(short *)(&DAT_0010a800 + (long)iVar8 * 2);\n  }\n  uVar20 = (uint)*(short *)(&DAT_0010a240 +\n                           (long)(*(short *)(&DAT_0010a640 + (long)iVar8 * 2) + 1) * 2);\n  pbVar33 = pbVar32;\n  if ((*(short *)(&DAT_0010a240 + (long)(*(short *)(&DAT_0010a640 + (long)iVar8 * 2) + 1) * 2) == 0)\n     || (uVar20 == 0xb0)) goto LAB_0010419f;\n  pbVar35 = pbVar35 + 1;\n  goto LAB_001040d4;\nLAB_001048a4:\n  DAT_0010d5b0 = DAT_0010d5c8;\n  iVar8 = (int)(DAT_0010d5d0 - 1) / 2 + 0x2a;\n  goto LAB_001041f0;\nswitchD_00104200_caseD_0:\n  *pbVar35 = DAT_0010d588;\n  uVar19 = (ulong)DAT_0010d5c0;\n  pbVar35 = DAT_0010d5b8;\n  goto LAB_0010419f;\nLAB_00105227:\n  ppcVar29 = ppcVar29 + 1;\n  local_800 = 3;\n  *ppcVar29 = DAT_0010d548;\nLAB_001049d1:\n  local_828 = local_828 + 1;\n  goto LAB_00103ee9;\n}\n\n",
            "called": [
                "fopen",
                "bfd_close",
                "FUN_00105300",
                "bfd_cache_close",
                "FUN_00103df9",
                "FUN_00103ddc",
                "stat",
                "filename_cmp",
                "fwrite",
                "FUN_0010312d",
                "FUN_001033d6",
                "unlink",
                "malloc",
                "free",
                "ferror",
                "FUN_00103c60",
                "bfd_set_format",
                "FUN_001031cf",
                "dcgettext",
                "realloc",
                "bfd_openr",
                "getc",
                "__errno_location",
                "fread",
                "FUN_00103ba8",
                "fprintf",
                "bfd_openw",
                "FUN_001030ed",
                "FUN_001033b0",
                "dup",
                "FUN_001031a5",
                "printf",
                "FUN_00105bc0",
                "clearerr",
                "fclose",
                "FUN_0010315d",
                "FUN_001032a8",
                "FUN_00107740",
                "xstrdup",
                "FUN_0010300e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103e95",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "decompile_and_improve_00103e95"
        },
        "bfd_init": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_init"
        },
        "strerror": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102550",
            "calling": [
                "FUN_001025a0",
                "FUN_00103a78",
                "FUN_00102fd7",
                "FUN_00102f1e",
                "FUN_00103c60",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "strerror"
        },
        "FUN_00107cc0": {
            "renaming": {
                "FUN_00107cc0": "execute_function_chain_00107cc0",
                "lVar1": "index",
                "lVar2": "prevIndex",
                "lVar3": "tempIndex",
                "plVar4": "functionChain",
                "uVar5": "subIndex"
            },
            "code": "\nvoid executeFunctionChain_00107cc0(void)\n\n{\n  long index;\n  long prevIndex;\n  long tempIndex;\n  long *functionChain;\n  uint subIndex;\n  \n  functionChain = (long *)PTR_DAT_0010d2e0;\n  if (PTR_DAT_0010d2e0 != (undefined *)0x0) {\n    do {\n      subIndex = *(int *)(functionChain + 1) - 1;\n      if (-1 < (int)subIndex) {\n        index = (long)(int)subIndex;\n        subIndex = subIndex & 7;\n        (*(code *)functionChain[index + 2])();\n        prevIndex = index + -1;\n        if (-1 < (int)prevIndex) {\n          tempIndex = prevIndex;\n          if (subIndex != 0) {\n            if (subIndex != 1) {\n              if (subIndex != 2) {\n                if (subIndex != 3) {\n                  if (subIndex != 4) {\n                    if (subIndex != 5) {\n                      if (subIndex != 6) {\n                        (*(code *)functionChain[index + 1])();\n                        prevIndex = index + -2;\n                      }\n                      (*(code *)functionChain[prevIndex + 2])();\n                      prevIndex = prevIndex + -1;\n                    }\n                    (*(code *)functionChain[prevIndex + 2])();\n                    prevIndex = prevIndex + -1;\n                  }\n                  (*(code *)functionChain[prevIndex + 2])();\n                  prevIndex = prevIndex + -1;\n                }\n                (*(code *)functionChain[prevIndex + 2])();\n                prevIndex = prevIndex + -1;\n              }\n              (*(code *)functionChain[prevIndex + 2])();\n              prevIndex = prevIndex + -1;\n            }\n            (*(code *)functionChain[prevIndex + 2])();\n            tempIndex = prevIndex + -1;\n            if ((int)(prevIndex + -1) < 0) goto LAB_00107d96;\n          }\n          do {\n            (*(code *)functionChain[tempIndex + 2])();\n            index = tempIndex + -1;\n            (*(code *)functionChain[tempIndex + 1])();\n            (*(code *)functionChain[tempIndex])();\n            (*(code *)functionChain[index])();\n            (*(code *)functionChain[tempIndex + -2])();\n            (*(code *)functionChain[tempIndex + -3])();\n            (*(code *)functionChain[tempIndex + -4])();\n            (*(code *)functionChain[tempIndex + -5])();\n            tempIndex = tempIndex + -8;\n          } while (-1 < (int)index + -7);\n        }\n      }\nLAB_00107d96:\n      functionChain = (long *)*functionChain;\n    } while (functionChain != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107cc0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "execute_function_chain_00107cc0"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "FUN_00105ae0": {
            "renaming": {
                "FUN_00105ae0": "execute_function_00105ae0",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "param_3": "dataParam1",
                "param_4": "dataParam2"
            },
            "code": "\nvoid executeFunction_00105ae0(undefined8 inputParam1,undefined8 inputParam2,undefined dataParam1,undefined dataParam2)\n\n{\n  FUN_00105af0(inputParam1,inputParam2,dataParam1,dataParam2);\n  return;\n}\n\n",
            "called": [
                "FUN_00105af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105ae0",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "execute_function_00105ae0"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_00105db0,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00105db0",
                "__libc_start_main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105cc0",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "FUN_00107690": {
            "renaming": {
                "FUN_00107690": "initialize_and_exit_00107690",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "param_5": "input_5",
                "param_6": "input_6",
                "param_7": "input_7",
                "param_8": "input_8",
                "param_9": "address_1",
                "param_10": "address_2",
                "param_11": "address_3",
                "param_12": "address_4",
                "param_13": "address_5",
                "param_14": "address_6",
                "in_AL": "is_input_valid",
                "local_d8": "bytes_to_copy",
                "local_d4": "copy_buffer_size",
                "local_d0": "copy_buffer",
                "local_c8": "local_buffer",
                "local_b8": "temporary_buffer",
                "local_b0": "address_2_copy",
                "local_a8": "address_3_copy",
                "local_a0": "address_4_copy",
                "local_98": "address_5_copy",
                "local_90": "address_6_copy",
                "local_88": "input_1_copy",
                "local_78": "input_2_copy",
                "local_68": "input_3_copy",
                "local_58": "input_4_copy",
                "local_48": "input_5_copy",
                "local_38": "input_6_copy",
                "local_28": "input_7_copy",
                "local_18": "input_8_copy"
            },
            "code": "\nvoid initializeAndExit_00107690(undefined4 input_1,undefined4 input_2,undefined4 input_3,undefined4 input_4,\n                 undefined4 input_5,undefined4 input_6,undefined4 input_7,undefined4 input_8,\n                 undefined8 address_1,undefined8 address_2,undefined8 address_3,undefined8 address_4,\n                 undefined8 address_5,undefined8 address_6)\n\n{\n  char is_input_valid;\n  undefined4 bytes_to_copy;\n  undefined4 copy_buffer_size;\n  undefined *copy_buffer;\n  undefined *local_buffer;\n  undefined temporary_buffer [8];\n  undefined8 address_2_copy;\n  undefined8 address_3_copy;\n  undefined8 address_4_copy;\n  undefined8 address_5_copy;\n  undefined8 address_6_copy;\n  undefined4 input_1_copy;\n  undefined4 input_2_copy;\n  undefined4 input_3_copy;\n  undefined4 input_4_copy;\n  undefined4 input_5_copy;\n  undefined4 input_6_copy;\n  undefined4 input_7_copy;\n  undefined4 input_8_copy;\n  \n  if (is_input_valid != '\\0') {\n    input_1_copy = input_1;\n    input_2_copy = input_2;\n    input_3_copy = input_3;\n    input_4_copy = input_4;\n    input_5_copy = input_5;\n    input_6_copy = input_6;\n    input_7_copy = input_7;\n    input_8_copy = input_8;\n  }\n  copy_buffer = &stack0x00000008;\n  bytes_to_copy = 8;\n  local_buffer = temporary_buffer;\n  copy_buffer_size = 0x30;\n  address_2_copy = address_2;\n  address_3_copy = address_3;\n  address_4_copy = address_4;\n  address_5_copy = address_5;\n  address_6_copy = address_6;\n  FUN_001078c0(address_1,&bytes_to_copy);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "FUN_001078c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107690",
            "calling": [
                "FUN_00103a78",
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_001028ed",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "initialize_and_exit_00107690"
        },
        "bfd_seek": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102580",
            "calling": [
                "FUN_00103a78",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "bfd_seek"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "FUN_0010266f": {
            "renaming": {
                "FUN_0010266f": "print_supported_targets_0010266f",
                "param_1": "target",
                "param_2": "file",
                "lVar1": "targetAddr",
                "pcVar2": "message",
                "__ptr": "targetList",
                "plVar3": "currentTarget"
            },
            "code": "\nvoid printSupportedTargets_0010266f(long target,FILE *file)\n\n{\n  long targetAddr;\n  char *message;\n  long *targetList;\n  long *currentTarget;\n  \n  if (target == 0) {\n    message = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(file,message);\n  }\n  else {\n    message = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(file,message,target);\n  }\n  targetList = (long *)bfd_target_list();\n  currentTarget = targetList;\n  while( true ) {\n    targetAddr = *currentTarget;\n    currentTarget = currentTarget + 1;\n    if (targetAddr == 0) break;\n    fprintf(file,\" %s\");\n  }\n  fputc(10,file);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "free",
                "fprintf",
                "fputc",
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010266f",
            "calling": [
                "FUN_0010342d",
                "FUN_0010394a"
            ],
            "imported": false,
            "current_name": "print_supported_targets_0010266f"
        },
        "FUN_00105830": {
            "renaming": {
                "FUN_00105830": "extracted_string_00105830",
                "param_1": "inputString",
                "param_2": "structAddress",
                "param_3": "unused1",
                "param_4": "unused2",
                "lVar1": "structValue",
                "sVar2": "stringLength",
                "__s": "baseName",
                "uVar3": "maxLength",
                "pcVar4": "outputString",
                "bVar5": "flag",
                "auVar6": "result"
            },
            "code": "\nundefined  [16] extractedString_00105830(char *inputString,long structAddress,undefined8 unused1,undefined8 unused2)\n\n{\n  long structValue;\n  size_t stringLength;\n  char *baseName;\n  ulong maxLength;\n  char *outputString;\n  byte flag;\n  undefined result [16];\n  \n  flag = 0;\n  if (DAT_0010d5f9 == '\\0') {\n    baseName = (char *)lbasename();\n    inputString = baseName;\n    if ((DAT_0010d5fa != '\\0') && (structAddress != 0)) {\n      stringLength = strlen(baseName);\n      maxLength = (ulong)*(byte *)(*(long *)(structAddress + 8) + 0x1e);\n      if (maxLength < stringLength) {\n        inputString = (char *)xmalloc(maxLength + 1);\n        structValue = *(long *)(structAddress + 8);\n        outputString = inputString;\n        for (maxLength = (ulong)*(byte *)(structValue + 0x1e); maxLength != 0; maxLength = maxLength - 1) {\n          *outputString = *baseName;\n          baseName = baseName + (ulong)flag * -2 + 1;\n          outputString = outputString + (ulong)flag * -2 + 1;\n        }\n        inputString[*(byte *)(structValue + 0x1e)] = '\\0';\n      }\n    }\n  }\n  result._8_8_ = unused2;\n  result._0_8_ = inputString;\n  return result;\n}\n\n",
            "called": [
                "FUN_00102bb0",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105830",
            "calling": [
                "FUN_00105480",
                "FUN_00105db0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "extracted_string_00105830"
        },
        "bfd_find_target": {
            "renaming": {},
            "code": "\nvoid bfd_find_target(void)\n\n{\n  bfd_find_target();\n  return;\n}\n\n",
            "called": [
                "bfd_find_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_find_target"
        },
        "bfd_check_format_matches": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024c0",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_check_format_matches"
        },
        "FUN_00107730": {
            "renaming": {
                "FUN_00107730": "cleanup_and_delete_file_00107730",
                "unlink_if_ordinary": "deleteFile",
                "fclose": "closeFile"
            },
            "code": "\nvoid cleanupAndDeleteFile_00107730(void)\n\n{\n  if (DAT_0010d618 == 0) {\n    return;\n  }\n  if (DAT_0010d5e0 != 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 != (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
            "called": [
                "FUN_00102bf5"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107730",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "cleanup_and_delete_file_00107730"
        },
        "mkstemp": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "mkstemp"
        },
        "FUN_00107c20": {
            "renaming": {
                "FUN_00107c20": "print_bfd_error_message_00107c20",
                "param_1": "errorType",
                "iVar1": "errorCode",
                "uVar2": "errorMessage",
                "in_R10": "additionalInfo"
            },
            "code": "\n\n\nvoid printBfdErrorMessage_00107c20(long errorType)\n\n{\n  int errorCode;\n  undefined8 errorMessage;\n  undefined8 additionalInfo;\n  \n  errorCode = bfd_get_error();\n  if (errorCode == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(errorCode);\n  }\n  fflush(_stdout);\n  if (errorType != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010d660,errorType,errorMessage,additionalInfo);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010d660,errorMessage,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "bfd_get_error",
                "bfd_errmsg",
                "FUN_00102f96"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c20",
            "calling": [
                "FUN_00107c10",
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_bfd_error_message_00107c20"
        },
        "lseek": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "lseek"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "FUN_001031cf": {
            "renaming": {
                "FUN_001031cf": "initialize_file_001031cf",
                "param_1": "outputFile",
                "param_2": "inputFile",
                "param_3": "param1",
                "param_4": "param2",
                "param_5": "param3",
                "iVar1": "error",
                "uVar2": "isTerminal",
                "iVar3": "fileNumber",
                "piVar4": "errnoLocation",
                "lVar5": "globalData"
            },
            "code": "\n\n\nundefined8\ninitializeFile_001031cf(FILE **outputFile,FILE *inputFile,undefined8 param1,undefined8 param2,undefined8 param3)\n\n{\n  int error;\n  uint isTerminal;\n  int fileNumber;\n  int *errnoLocation;\n  long globalData;\n  \n  errnoLocation = __errno_location();\n  globalData = DAT_0010d5a8;\n  error = *errnoLocation;\n  if (outputFile == (FILE **)0x0) {\n    _DAT_00000034 = 1;\n    _DAT_00000000 = inputFile;\n    if (DAT_0010d5a8 != 0) {\nLAB_00103263:\n      if (outputFile == *(FILE ***)(globalData + DAT_0010d5a0 * 8)) goto LAB_0010327b;\n    }\n  }\n  else {\n    *(undefined4 *)((long)outputFile + 0x1c) = 0;\n    *(undefined *)&outputFile[1]->_flags = 0;\n    *(undefined *)((long)&outputFile[1]->_flags + 1) = 0;\n    *(undefined4 *)(outputFile + 5) = 1;\n    outputFile[2] = outputFile[1];\n    *(undefined4 *)(outputFile + 7) = 0;\n    if (globalData != 0) {\n      if (outputFile == *(FILE ***)(globalData + DAT_0010d5a0 * 8)) {\n        FUN_001030ed();\n      }\n      *outputFile = inputFile;\n      *(undefined4 *)((long)outputFile + 0x34) = 1;\n      goto LAB_00103263;\n    }\n    *outputFile = inputFile;\n    *(undefined4 *)((long)outputFile + 0x34) = 1;\n  }\n  *(undefined8 *)((long)outputFile + 0x2c) = 1;\nLAB_0010327b:\n  isTerminal = 0;\n  if (inputFile != (FILE *)0x0) {\n    fileNumber = fileno(inputFile);\n    fileNumber = isatty(fileNumber);\n    isTerminal = (uint)(0 < fileNumber);\n  }\n  *(uint *)((long)outputFile + 0x24) = isTerminal;\n  *errnoLocation = error;\n  return param3;\n}\n\n",
            "called": [
                "fileno",
                "__errno_location",
                "isatty",
                "FUN_001030ed"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031cf",
            "calling": [
                "FUN_001033d6",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "initialize_file_001031cf"
        },
        "FUN_0010312d": {
            "renaming": {
                "FUN_0010312d": "copy_data_0010312d",
                "param_1": "dst",
                "param_2": "src",
                "lVar1": "temp"
            },
            "code": "\nvoid copyData_0010312d(long dst,long src)\n\n{\n  long temp;\n  \n  if (src != 0) {\n    *(undefined8 *)(src + 0xf0) = *(undefined8 *)(dst + 0xf0);\n  }\n  temp = DAT_0010d558;\n  *(undefined8 *)(dst + 0xf0) = *(undefined8 *)(DAT_0010d558 + 0xf8);\n  *(long *)(temp + 0xf8) = dst;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010312d",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "copy_data_0010312d"
        },
        "FUN_00105c00": {
            "renaming": {
                "FUN_00105c00": "reverse_and_copy_to_file_00105c00",
                "param_1": "fileDescriptor",
                "param_2": "filename",
                "iVar1": "errnoValue",
                "__fd": "destinationFileDescriptor",
                "iVar2": "readResult",
                "_Var3": "fileOffset",
                "uVar4": "returnValue",
                "sVar5": "writeResult",
                "piVar6": "errnoPointer",
                "auStack_2038": "buffer"
            },
            "code": "\nulong reverseAndCopyToFile_00105c00(int fileDescriptor,char *filename)\n\n{\n  int errnoValue;\n  int destinationFileDescriptor;\n  int readResult;\n  __off_t fileOffset;\n  ulong returnValue;\n  size_t writeResult;\n  int *errnoPointer;\n  undefined buffer [8200];\n  \n  if ((-1 < fileDescriptor) && (fileOffset = lseek(fileDescriptor,0,0), fileOffset == 0)) {\n    destinationFileDescriptor = open(filename,0x201);\n    if (destinationFileDescriptor < 0) {\n      returnValue = FUN_00102f55();\n      return returnValue;\n    }\n    do {\n      returnValue = read(fileDescriptor,buffer,0x2000);\n      readResult = (int)returnValue;\n      if (readResult < 1) {\n        errnoPointer = __errno_location();\n        errnoValue = *errnoPointer;\n        close(fileDescriptor);\n        close(destinationFileDescriptor);\n        if (readResult != 0) {\n          *errnoPointer = errnoValue;\n          return 0xffffffff;\n        }\n        return returnValue & 0xffffffff;\n      }\n      writeResult = write(destinationFileDescriptor,buffer,(long)readResult);\n    } while (writeResult == (long)readResult);\n    errnoPointer = __errno_location();\n    readResult = *errnoPointer;\n    close(fileDescriptor);\n    close(destinationFileDescriptor);\n    *errnoPointer = readResult;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "read",
                "FUN_00102f55",
                "__errno_location",
                "open",
                "write",
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105c00",
            "calling": [
                "FUN_00105bc0"
            ],
            "imported": false,
            "current_name": "reverse_and_copy_to_file_00105c00"
        },
        "calloc": {
            "renaming": {},
            "code": "\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(__nmemb,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "FUN_00103df9"
            ],
            "imported": false,
            "current_name": "calloc"
        },
        "FUN_00105d20": {
            "renaming": {
                "FUN_00105d20": "FUNC_00105d20"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d44) */\n/* WARNING: Removing unreachable block (ram,0x00105d50) */\n\nvoid FUNC_00105d20(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105d20",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105d20"
        },
        "FUN_001052a0": {
            "renaming": {
                "FUN_001052a0": "check_file_status_001052a0",
                "param_1": "file_path",
                "iVar1": "status",
                "piVar2": "errno_location",
                "uVar3": "error_message",
                "pcVar4": "error_reason",
                "sStack_a8": "file_status"
            },
            "code": "\nlong check_file_status_001052a0(char *file_path)\n\n{\n  int status;\n  int *errno_location;\n  undefined8 error_message;\n  char *error_reason;\n  stat file_status;\n  \n  if (file_path != (char *)0x0) {\n    status = stat(file_path,&file_status);\n    if (status < 0) {\n      errno_location = __errno_location();\n      if (*errno_location == 2) {\n        error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n        FUN_00107920(error_message,file_path);\n      }\n      else {\n        error_reason = strerror(*errno_location);\n        error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        FUN_00107920(error_message,file_path,error_reason);\n      }\n    }\n    else if ((file_status.st_mode & 0xf000) == 0x4000) {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      FUN_00107920(error_message,file_path);\n    }\n    else if ((file_status.st_mode & 0xf000) == 0x8000) {\n      if (-1 < file_status.st_size) {\n        return file_status.st_size;\n      }\n      error_message = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      FUN_00107920(error_message,file_path);\n    }\n    else {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      FUN_00107920(error_message,file_path);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "dcgettext",
                "FUN_001025a0",
                "FUN_00107920",
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a0",
            "calling": [
                "FUN_00105db0",
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "check_file_status_001052a0"
        },
        "FUN_0010336b": {
            "renaming": {
                "FUN_0010336b": "print_emulation_options_0010336b",
                "param_1": "outputFile",
                "pcVar1": "emulationText"
            },
            "code": "\nvoid printEmulationOptions_0010336b(FILE *outputFile)\n\n{\n  char *emulationText;\n  \n  emulationText = (char *)dcgettext(0,\" emulation options: \\n\",5);\n  fprintf(outputFile,emulationText);\n  emulationText = (char *)dcgettext(0,\"  No emulation specific options\\n\",5);\n  fprintf(outputFile,emulationText);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010336b",
            "calling": [
                "FUN_0010342d"
            ],
            "imported": false,
            "current_name": "print_emulation_options_0010336b"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "FUN_00103a78",
                "FUN_001031a5",
                "FUN_00105db0",
                "FUN_00103ba8",
                "FUN_00105a68",
                "FUN_001075e0",
                "FUN_00103e95",
                "FUN_00103172",
                "FUN_00102f08"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "FUN_00103c60": {
            "renaming": {
                "FUN_00103c60": "process_file_00103c60",
                "param_1": "inputFileName",
                "param_2": "flag",
                "cVar1": "formatCheck",
                "piVar2": "errnoPtr",
                "pcVar3": "errorMessage",
                "lVar4": "inputFile",
                "lVar5": "archivedFile",
                "uVar6": "programName",
                "plVar7": "archivedFilePtr"
            },
            "code": "\n\n\nvoid processFile_00103c60(char *inputFileName,int flag)\n\n{\n  char formatCheck;\n  int *errnoPtr;\n  char *errorMessage;\n  long inputFile;\n  long archivedFile;\n  undefined8 programName;\n  long *archivedFilePtr;\n  \n  DAT_0010d570 = xstrdup();\n  DAT_0010d560 = (char *)FUN_001057a0(DAT_0010d570,&DAT_0010d568);\n  if (DAT_0010d560 == (char *)0x0) {\n    errnoPtr = __errno_location();\n    inputFileName = strerror(*errnoPtr);\n    programName = DAT_0010d660;\n    errorMessage = (char *)dcgettext(0,\"%s: Can\\'t open temporary file (%s)\\n\",5);\n  }\n  else {\n    DAT_0010d558 = bfd_fdopenw(DAT_0010d560,0,DAT_0010d568);\n    if (DAT_0010d558 == 0) {\n      errorMessage = \"%s: Can\\'t open output archive %s\\n\";\n      inputFileName = DAT_0010d560;\n    }\n    else {\n      if (flag != 0) {\nLAB_00103d02:\n        bfd_set_format(DAT_0010d558,2);\n        *(byte *)(DAT_0010d558 + 0x49) = *(byte *)(DAT_0010d558 + 0x49) & 0xe7 | 8;\n        return;\n      }\n      inputFile = bfd_openr(inputFileName,\"plugin\");\n      if (inputFile == 0) {\n        errorMessage = \"%s: Can\\'t open input archive %s\\n\";\n      }\n      else {\n        formatCheck = bfd_check_format(inputFile,2);\n        if (formatCheck != '\\0') {\n          archivedFilePtr = (long *)(DAT_0010d558 + 0xf8);\n          for (archivedFile = bfd_openr_next_archived_file(inputFile,0); archivedFile != 0;\n              archivedFile = bfd_openr_next_archived_file(inputFile,archivedFile)) {\n            *archivedFilePtr = archivedFile;\n            archivedFilePtr = (long *)(archivedFile + 0xf0);\n          }\n          goto LAB_00103d02;\n        }\n        errorMessage = \"%s: file %s is not an archive\\n\";\n      }\n    }\n    programName = DAT_0010d660;\n    errorMessage = (char *)dcgettext(0,errorMessage,5);\n  }\n  fprintf(_stderr,errorMessage,programName,inputFileName);\n  FUN_0010315d();\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "bfd_openr",
                "bfd_fdopenw",
                "FUN_001057a0",
                "bfd_check_format",
                "bfd_openr_next_archived_file",
                "__errno_location",
                "FUN_0010315d",
                "fprintf",
                "xstrdup",
                "bfd_set_format",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c60",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "process_file_00103c60"
        },
        "FUN_00102e57": {
            "renaming": {
                "FUN_00102e57": "create_output_file_00102e57",
                "pFVar1": "outputFile",
                "xexit": "terminateProgram"
            },
            "code": "\nvoid createOutputFile_00102e57(void)\n\n{\n  FILE *outputFile;\n  \n  DAT_0010d618 = (char *)concat();\n  if (DAT_0010d60c != 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  outputFile = fopen(DAT_0010d618,\"w\");\n  if (outputFile != (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e57",
            "calling": [
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "create_output_file_00102e57"
        },
        "FUN_00105af0": {
            "renaming": {
                "FUN_00105af0": "extract_and_open_files_00105af0",
                "param_1": "file_list",
                "param_2": "archive_ptr",
                "param_3": "flag_1",
                "param_4": "flag_2",
                "cVar1": "check_result",
                "uVar2": "recursive_result",
                "lVar3": "file_ptr",
                "uVar4": "result"
            },
            "code": "\nulong extract_and_open_files_00105af0(long *file_list,long archive_ptr,char flag_1,char flag_2)\n\n{\n  char check_result;\n  uint recursive_result;\n  long file_ptr;\n  ulong result;\n  \n  if (flag_2 == '\\0') {\n    if (flag_1 != '\\0') {\n      result = FUN_00102f08();\n      return result;\n    }\n  }\n  else {\n    check_result = bfd_check_format(archive_ptr,2);\n    if (check_result != '\\0') {\n      result = 0;\n      for (file_ptr = bfd_openr_next_archived_file(archive_ptr,0); file_ptr != 0;\n          file_ptr = bfd_openr_next_archived_file(archive_ptr,file_ptr)) {\n        recursive_result = extract_and_open_files_00105af0(file_list,file_ptr,flag_1,1);\n        if ((char)recursive_result != '\\0') {\n          result = (ulong)recursive_result;\n          file_list = (long *)(*file_list + 0xf0);\n        }\n      }\n      return result;\n    }\n    if (flag_1 != '\\0') {\n      result = FUN_00102f08();\n      return result;\n    }\n  }\n  *(long *)(archive_ptr + 0xf0) = *file_list;\n  *file_list = archive_ptr;\n  return 1;\n}\n\n",
            "called": [
                "bfd_check_format",
                "bfd_openr_next_archived_file",
                "FUN_00105af0",
                "FUN_00102f08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105af0",
            "calling": [
                "FUN_00105ae0",
                "FUN_00105af0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "extract_and_open_files_00105af0"
        },
        "FUN_0010300e": {
            "renaming": {
                "FUN_0010300e": "check_and_update_values_0010300e",
                "bVar1": "foundMatch",
                "iVar2": "currentValue",
                "lVar3": "newValue",
                "bVar4": "offset",
                "pbVar5": "currentByte",
                "in_R9": "matchingByte",
                "in_R10D": "matchingValue"
            },
            "code": "\nvoid checkAndUpdateValues_0010300e(void)\n\n{\n  bool foundMatch;\n  int currentValue;\n  long newValue;\n  byte offset;\n  byte *currentByte;\n  byte *matchingByte;\n  int matchingValue;\n  \n  foundMatch = false;\n  currentValue = DAT_0010d5d0;\n  for (currentByte = DAT_0010d5c8; currentByte < DAT_0010d5b0; currentByte = currentByte + 1) {\n    offset = 1;\n    if (*currentByte != 0) {\n      offset = (&DAT_0010ab00)[*currentByte];\n    }\n    if (*(short *)(&DAT_0010a980 + (long)currentValue * 2) != 0) {\n      foundMatch = true;\n      matchingByte = currentByte;\n      matchingValue = currentValue;\n    }\n    while( true ) {\n      newValue = (long)(int)((int)*(short *)(&DAT_0010a640 + (long)currentValue * 2) + (uint)offset);\n      if (*(short *)(&DAT_0010a440 + newValue * 2) == currentValue) break;\n      currentValue = (int)*(short *)(&DAT_0010a800 + (long)currentValue * 2);\n      if (0xb0 < currentValue) {\n        offset = (&DAT_0010a7c0)[(int)(uint)offset];\n      }\n    }\n    currentValue = (int)*(short *)(&DAT_0010a240 + newValue * 2);\n  }\n  if (foundMatch) {\n    DAT_0010d5b8 = matchingByte;\n    DAT_0010d5c0 = matchingValue;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010300e",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_and_update_values_0010300e"
        },
        "chmod": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "chmod"
        },
        "FUN_00102ba1": {
            "renaming": {
                "FUN_00102ba1": "free_and_return_zero_extended_00102ba1",
                "unaff_RBP": "ptrToBeFreed",
                "unaff_retaddr": "returnedAddress",
                "auVar1": "returnValue"
            },
            "code": "\nundefined  [16] freeAndReturnZeroExtended_00102ba1(void)\n\n{\n  undefined returnValue [16];\n  void *ptrToBeFreed;\n  ulong returnedAddress;\n  \n  free(ptrToBeFreed);\n  returnValue._8_8_ = 0;\n  returnValue._0_8_ = returnedAddress;\n  return returnValue << 0x40;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102ba1",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "free_and_return_zero_extended_00102ba1"
        },
        "FUN_00107740": {
            "renaming": {
                "FUN_00107740": "extract_files_from_archive_00107740",
                "param_1": "inputArchive",
                "iVar1": "comparisonResult",
                "iVar2": "errorCode",
                "piVar3": "errnoPtr",
                "pcVar4": "errorString",
                "uVar5": "errorMessage",
                "pplVar6": "currentEntry",
                "__ptr": "buffer",
                "__n": "bytesRead",
                "lVar7": "fileOffset",
                "plVar8": "currentFile",
                "puVar9": "localArrayPtr",
                "uVar10": "totalBytesRead",
                "sVar11": "chunkSize",
                "local_c8": "localArray",
                "_Stack_b0": "filePermissions",
                "uStack_98": "archiveSize",
                "uStack_80": "tmpValue1",
                "uStack_70": "tmpValue2"
            },
            "code": "\n\n\nlong * extractFilesFromArchive_00107740(long **inputArchive)\n\n{\n  int comparisonResult;\n  int errorCode;\n  int *errnoPtr;\n  char *errorString;\n  undefined8 errorMessage;\n  long **currentEntry;\n  void *buffer;\n  size_t bytesRead;\n  long fileOffset;\n  long *currentFile;\n  undefined4 *localArrayPtr;\n  ulong totalBytesRead;\n  size_t chunkSize;\n  undefined4 localArray [6];\n  __mode_t filePermissions;\n  ulong archiveSize;\n  undefined8 tmpValue1;\n  undefined8 tmpValue2;\n  \n  if (_DAT_0010d600 != 0) {\n    localArrayPtr = localArray;\n    for (fileOffset = 0x24; fileOffset != 0; fileOffset = fileOffset + -1) {\n      *localArrayPtr = 0;\n      localArrayPtr = localArrayPtr + 1;\n    }\n  }\n  currentEntry = (long **)inputArchive[0x1d];\n  if ((long **)inputArchive[0x1d] == (long **)0x0) {\n    currentEntry = inputArchive;\n  }\n  errorCode = (*(code *)currentEntry[1][0x3d])(inputArchive,localArray);\n  if (errorCode != 0) {\n    currentFile = *inputArchive;\n    errorMessage = dcgettext(0,\"internal stat error on %s\",5);\n    errorCode = FUN_00107690(errorMessage,currentFile);\n    errorMessage = DAT_0010d638;\n    if (errorCode == 3) {\n      for (; *currentFile != 0; currentFile = (long *)(*currentFile + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*currentFile != (undefined8 *)0x0; currentFile = (long *)(*currentFile + 0xf0)) {\n        comparisonResult = filename_cmp(*(undefined8 *)*currentFile,errorMessage);\n        if (comparisonResult == 0) {\n          if (errorCode != 2) {\n            return currentFile;\n          }\n          return (long *)(*currentFile + 0xf0);\n        }\n      }\n    }\n    return currentFile;\n  }\n  bfd_seek(inputArchive,0,0);\n  DAT_0010d5d8 = (FILE *)0x0;\n  if (archiveSize == 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 = (FILE *)FUN_00105a20(*inputArchive);\n  }\n  else {\n    totalBytesRead = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      chunkSize = archiveSize - totalBytesRead;\n      if (0x2000 < chunkSize) {\n        chunkSize = 0x2000;\n      }\n      bytesRead = bfd_bread(buffer,chunkSize,inputArchive);\n      if (chunkSize != bytesRead) {\nLAB_00102c78:\n        inputArchive = (long **)*inputArchive[0x1d];\n        errorMessage = dcgettext(0,\"%s is not a valid archive\",5);\n        FUN_00107690(errorMessage,inputArchive);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 == (FILE *)0x0) {\n        DAT_0010d5d8 = (FILE *)FUN_00105a20(*inputArchive);\n      }\n      chunkSize = fwrite(buffer,1,bytesRead,DAT_0010d5d8);\n      if (chunkSize != bytesRead) {\n        errnoPtr = __errno_location();\n        errorString = strerror(*errnoPtr);\n        FUN_00107690(\"%s: %s\",DAT_0010d618,errorString);\n        goto LAB_00102c78;\n      }\n      totalBytesRead = totalBytesRead + bytesRead;\n    } while (totalBytesRead < archiveSize);\n    free(buffer);\n  }\n  fclose(DAT_0010d5d8);\n  errorString = DAT_0010d618;\n  DAT_0010d5d8 = (FILE *)0x0;\n  chmod(DAT_0010d618,filePermissions);\n  if (_DAT_0010d600 != 0) {\n    tmpValue1 = tmpValue2;\n    FUN_00107c80(errorString,localArray);\n  }\n  DAT_0010d618 = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "FUN_00102c25"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107740",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "extract_files_from_archive_00107740"
        },
        "FUN_00102d2f": {
            "renaming": {
                "FUN_00102d2f": "print_file_info_00102d2f",
                "unaff_RBX": "fileInfo",
                "unaff_RBP": "file",
                "unaff_R12": "options",
                "unaff_R13": "memory1",
                "unaff_R14D": "duplication",
                "uStack0000000000000068": "fileFlags",
                "uStack000000000000006c": "filePermissions",
                "in_stack_00000070": "fileSize",
                "in_stack_00000080": "timestamp",
                "uStack0000000000000015": "fileType",
                "cStack0000000000000016": "flag1",
                "cStack0000000000000017": "flag2",
                "in_stack_00000018": "flag3",
                "cStack0000000000000019": "flag4",
                "cStack000000000000001a": "flag5",
                "cStack000000000000001b": "flag6",
                "cStack000000000000001c": "flag7",
                "cStack000000000000001d": "flag8",
                "cStack000000000000001e": "flag9"
            },
            "code": "\nvoid printFileInfo_00102d2f(void)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  char *__format;\n  uint uVar4;\n  char **fileInfo;\n  FILE *file;\n  long options;\n  void *memory1;\n  int duplication;\n  undefined fileType;\n  char flag1;\n  char flag2;\n  char flag3;\n  char flag4;\n  char flag5;\n  char flag6;\n  char flag7;\n  char flag8;\n  char flag9;\n  undefined uStack000000000000001f;\n  uint fileFlags;\n  uint filePermissions;\n  uint fileSize;\n  undefined8 timestamp;\n  \n  do {\n    bVar1 = FUN_00107c10();\n    *(uint *)((long)fileInfo + 0x44) = *(uint *)((long)fileInfo + 0x44) | 0x100000;\n    if ((DAT_0010d5f8 != '\\0') || ((*(byte *)(options + 0x49) & 0x10) != 0)) {\n      *(byte *)((long)fileInfo + 0x49) = bVar1 | 0x10;\n    }\n    cVar2 = bfd_set_archive_head();\n  } while (cVar2 == '\\0');\n  dup(duplication);\n  cVar2 = bfd_close();\n  if (cVar2 != '\\0') {\n    DAT_0010d5e0 = 0;\n    DAT_0010d618 = 0;\n    bfd_close();\n    iVar3 = FUN_00105bc0();\n    if (iVar3 == 0) {\n      free(memory1);\n      free(file);\n      return;\n    }\n                    \n    xexit(1);\n  }\n  FUN_00107c10();\n  __format = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,__format);\n  uVar4 = fileFlags & 0xf000;\n  if (uVar4 == 0x4000) {\n    fileType = 100;\n  }\n  else if (uVar4 == 0xa000) {\n    fileType = 0x6c;\n  }\n  else if (uVar4 == 0x6000) {\n    fileType = 0x62;\n  }\n  else if (uVar4 == 0x2000) {\n    fileType = 99;\n  }\n  else if (uVar4 == 0xc000) {\n    fileType = 0x73;\n  }\n  else {\n    fileType = 0x70;\n    if (uVar4 != 0x1000) {\n      fileType = 0x2d;\n    }\n  }\n  flag1 = (-((fileFlags & 0x100) == 0) & 0xbbU) + 0x72;\n  flag2 = (-((fileFlags & 0x80) == 0) & 0xb6U) + 0x77;\n  flag3 = (-((fileFlags & 0x40) == 0) & 0xb5U) + 0x78;\n  flag4 = (-((fileFlags & 0x20) == 0) & 0xbbU) + 0x72;\n  flag5 = (-((fileFlags & 0x10) == 0) & 0xb6U) + 0x77;\n  flag6 = (-((fileFlags & 8) == 0) & 0xb5U) + 0x78;\n  flag7 = (-((fileFlags & 4) == 0) & 0xbbU) + 0x72;\n  flag8 = (-((fileFlags & 2) == 0) & 0xb6U) + 0x77;\n  flag9 = (-((fileFlags & 1) == 0) & 0xb5U) + 0x78;\n  if ((fileFlags & 0x800) != 0) {\n    if (flag3 == 'x') {\n      flag3 = 's';\n    }\n    else {\n      flag3 = 'S';\n    }\n  }\n  if ((fileFlags & 0x400) != 0) {\n    if (flag6 == 'x') {\n      flag6 = 's';\n    }\n    else {\n      flag6 = 'S';\n    }\n  }\n  if ((fileFlags & 0x200) != 0) {\n    if (flag9 == 'x') {\n      flag9 = 't';\n    }\n    else {\n      flag9 = 'T';\n    }\n  }\n  uStack000000000000001f = 0;\n  fprintf(file,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)filePermissions,\n          (ulong)fileSize,timestamp,&stack0x00000020,(ulong)fileFlags)\n  ;\n  fputs(*fileInfo,file);\n  if ((char)options != '\\0') {\n    if ((*(byte *)((long)fileInfo + 0x49) & 0x10) == 0) {\n      if (fileInfo[0xb] != (char *)0x0) {\n        fprintf(file,\" 0x%lx\");\n      }\n    }\n    else if (fileInfo[0xc] != (char *)0x0) {\n      fprintf(file,\" 0x%lx\");\n    }\n  }\n  fputc(10,file);\n  return;\n}\n\n",
            "called": [
                "FUN_00107c10",
                "FUN_00105bc0",
                "bfd_close",
                "free",
                "FUN_00102d2f",
                "xexit",
                "dup",
                "bfd_set_archive_head"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d2f",
            "calling": [
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "print_file_info_00102d2f"
        },
        "FUN_001028ed": {
            "renaming": {
                "FUN_001028ed": "FUNC_001028ed"
            },
            "code": "\n\n\nundefined8 FUNC_001028ed(undefined8 param_1,long param_2)\n\n{\n  undefined uVar1;\n  byte bVar2;\n  int iVar3;\n  size_t sVar4;\n  int *piVar5;\n  char *pcVar6;\n  char *pcVar7;\n  char **ppcVar8;\n  undefined8 uVar9;\n  long lVar10;\n  char *__s;\n  char *__s_00;\n  long lVar11;\n  undefined8 uVar12;\n  ulong uVar13;\n  char *unaff_RBX;\n  char **ppcVar14;\n  char **unaff_RBP;\n  char **unaff_R12;\n  uint unaff_R13D;\n  char **ppcVar15;\n  long unaff_R14;\n  bool bVar16;\n  byte bVar17;\n  char **param_7;\n  undefined8 param_9;\n  long in_stack_00000078;\n  long in_stack_00000108;\n  \n  bVar17 = 0;\ncode_r0x001028ed:\n  FUN_00107c10(unaff_RBX,param_2);\nLAB_001028f5:\n  uVar12 = DAT_0010d638;\n  if (unaff_R13D != 3) {\n    while( true ) {\n      if ((undefined8 *)*unaff_R12 == (undefined8 *)0x0) goto LAB_0010571f;\n      iVar3 = filename_cmp(*(undefined8 *)*unaff_R12,uVar12);\n      if (iVar3 == 0) break;\n      unaff_R12 = (char **)(*unaff_R12 + 0xf0);\n    }\n    if (unaff_R13D != 2) goto LAB_0010571f;\n    unaff_R12 = (char **)(*unaff_R12 + 0xf0);\n    goto LAB_0010571f;\n  }\n  lVar10 = *(long *)(unaff_R14 + 0xf0);\n  if (*(long *)(unaff_R14 + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n  do {\n    lVar11 = lVar10;\n    lVar10 = *(long *)(lVar11 + 0xf0);\n  } while (lVar10 != 0);\n  unaff_R12 = (char **)(lVar11 + 0xf0);\n  unaff_RBX = *unaff_RBP;\n  if (DAT_0010d620 != 0) goto LAB_00105731;\nLAB_00105698:\n  uVar1 = DAT_0010d5f8;\n  unaff_R13D = (uint)(DAT_0010d60c != 0);\n  param_2 = bfd_openr(unaff_RBX,DAT_0010d5f0);\n  if (param_2 != 0) {\n    unaff_RBP = unaff_RBP + 1;\n    bVar2 = FUN_00105af0(unaff_R12,param_2,unaff_R13D,uVar1);\n    param_9._6_1_ = param_9._6_1_ | bVar2;\n    pcVar6 = *unaff_RBP;\n    do {\n      if (pcVar6 == (char *)0x0) {\n        if (param_9._6_1_ == 0) {\n          DAT_0010d618 = 0;\n          return 0;\n        }\n        uVar12 = FUN_001058b0();\n        return uVar12;\n      }\n      ppcVar14 = *(char ***)(unaff_R14 + 0xf0);\n      unaff_R12 = param_7;\n      if (param_9._7_1_ == '\\0') {\n        ppcVar15 = param_7;\n        if (ppcVar14 != (char **)0x0) {\n          do {\n            if (DAT_0010d5f9 == '\\0') {\n              __s = (char *)lbasename(*ppcVar14);\n              pcVar7 = __s;\n              if (DAT_0010d5fa != '\\0') {\n                sVar4 = strlen(__s);\n                uVar13 = (ulong)*(byte *)(*(long *)(unaff_R14 + 8) + 0x1e);\n                if (uVar13 < sVar4) {\n                  pcVar7 = (char *)xmalloc(uVar13 + 1);\n                  lVar10 = *(long *)(unaff_R14 + 8);\n                  pcVar6 = pcVar7;\n                  for (uVar13 = (ulong)*(byte *)(lVar10 + 0x1e); uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *pcVar6 = *__s;\n                    __s = __s + (ulong)bVar17 * -2 + 1;\n                    pcVar6 = pcVar6 + (ulong)bVar17 * -2 + 1;\n                  }\n                  pcVar7[*(byte *)(lVar10 + 0x1e)] = '\\0';\n                }\n                pcVar6 = *unaff_RBP;\n                __s = pcVar7;\n                if (DAT_0010d5f9 == '\\0') goto LAB_00105611;\n                goto LAB_00102980;\n              }\n              pcVar6 = *unaff_RBP;\n              if (DAT_0010d5f9 != '\\0') goto LAB_00102980;\nLAB_00105611:\n              __s_00 = (char *)lbasename(pcVar6);\n              if (DAT_0010d5fa != '\\0') {\n                sVar4 = strlen(__s_00);\n                uVar13 = (ulong)*(byte *)(*(long *)(unaff_R14 + 8) + 0x1e);\n                pcVar6 = __s_00;\n                __s = pcVar7;\n                if (uVar13 < sVar4) {\n                  pcVar6 = (char *)xmalloc(uVar13 + 1);\n                  lVar10 = *(long *)(unaff_R14 + 8);\n                  pcVar7 = pcVar6;\n                  for (uVar13 = (ulong)*(byte *)(lVar10 + 0x1e); uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *pcVar7 = *__s_00;\n                    __s_00 = __s_00 + (ulong)bVar17 * -2 + 1;\n                    pcVar7 = pcVar7 + (ulong)bVar17 * -2 + 1;\n                  }\n                  pcVar6[*(byte *)(lVar10 + 0x1e)] = '\\0';\n                }\n                goto LAB_00102980;\n              }\n              iVar3 = filename_cmp(__s_00,pcVar7);\n            }\n            else {\n              pcVar6 = *unaff_RBP;\n              __s = *ppcVar14;\nLAB_00102980:\n              iVar3 = filename_cmp(pcVar6,__s);\n            }\n            if ((iVar3 == 0) && (ppcVar14[0x1c] != (char *)0x0)) {\n              if (_DAT_0010d644 != 0) {\n                iVar3 = stat(*unaff_RBP,(stat *)&stack0x000000b0);\n                if (iVar3 != 0) {\n                  piVar5 = __errno_location();\n                  if (*piVar5 != 2) {\n                    FUN_00107c10(*unaff_RBP);\nLAB_00102b7e:\n                    pcVar6 = *ppcVar14;\n                    uVar12 = dcgettext(0,\"internal stat error on %s\",5);\n                    FUN_00107690(uVar12,pcVar6);\n                    free(unaff_RBP);\n                    return 0;\n                  }\n                  goto LAB_0010577e;\n                }\n                ppcVar8 = (char **)ppcVar14[0x1d];\n                if ((char **)ppcVar14[0x1d] == (char **)0x0) {\n                  ppcVar8 = ppcVar14;\n                }\n                iVar3 = (**(code **)(ppcVar8[1] + 0x1e8))(ppcVar14,&stack0x00000020);\n                if (iVar3 != 0) goto LAB_00102b7e;\n                if (in_stack_00000108 <= in_stack_00000078) goto LAB_0010577e;\n              }\n              uVar12 = FUN_00105870(param_7,2,*ppcVar14);\n              if (DAT_0010d620 == 0) {\nLAB_00102ae2:\n                pcVar6 = *unaff_RBP;\n                bVar16 = DAT_0010d60c != 0;\n                lVar10 = bfd_openr(pcVar6,DAT_0010d5f0);\n                if (lVar10 == 0) {\n                  FUN_00107c10(pcVar6,0);\n                  goto LAB_00102b3e;\n                }\n                bVar2 = FUN_00103172(uVar12,lVar10,bVar16);\n              }\n              else {\n                uVar9 = FUN_00105830(*unaff_RBP);\n                iVar3 = filename_cmp(uVar9,\"__.LIBDEP\");\n                if (iVar3 != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n                bVar2 = FUN_00103172(uVar12,DAT_0010d620,DAT_0010d60c != 0);\n              }\n              if (bVar2 != 0) {\n                *ppcVar15 = *(char **)(*ppcVar15 + 0xf0);\n                param_9._6_1_ = bVar2;\n              }\n              goto LAB_0010577e;\n            }\n            ppcVar15 = ppcVar14 + 0x1e;\n            ppcVar14 = (char **)ppcVar14[0x1e];\n          } while (ppcVar14 != (char **)0x0);\n          goto LAB_0010564c;\n        }\n        unaff_R13D = DAT_0010d640;\n        if (DAT_0010d640 != 0) goto LAB_001028f5;\n      }\n      else {\nLAB_0010564c:\n        unaff_R13D = DAT_0010d640;\n        if (DAT_0010d640 != 0) goto LAB_001028f5;\n        lVar10 = *(long *)(unaff_R14 + 0xf0);\n        if (*(long *)(unaff_R14 + 0xf0) != 0) goto LAB_00105670;\n      }\nLAB_0010571f:\n      unaff_RBX = *unaff_RBP;\n      if (DAT_0010d620 == 0) goto LAB_00105698;\nLAB_00105731:\n      uVar12 = FUN_00105830(unaff_RBX);\n      iVar3 = filename_cmp(uVar12,\"__.LIBDEP\");\n      if (iVar3 != 0) goto code_r0x0010574f;\n      bVar2 = FUN_00105ae0(unaff_R12,DAT_0010d620,DAT_0010d60c != 0,DAT_0010d5f8);\n      param_9._6_1_ = bVar2 | param_9._6_1_;\nLAB_0010577e:\n      unaff_RBP = unaff_RBP + 1;\n      pcVar6 = *unaff_RBP;\n    } while( true );\n  }\n  goto code_r0x001028ed;\ncode_r0x0010574f:\n  unaff_RBX = *unaff_RBP;\n  goto LAB_00105698;\n}\n\n",
            "called": [
                "bfd_openr",
                "FUN_00107c10",
                "dcgettext",
                "FUN_00105ae0",
                "xmalloc",
                "__errno_location",
                "FUN_00105af0",
                "lbasename",
                "FUN_00105830",
                "FUN_00107690",
                "stat",
                "filename_cmp",
                "FUN_00102943",
                "FUN_001058b0",
                "strlen",
                "FUN_00103172",
                "FUN_00105870",
                "FUN_001028ed"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001028ed",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "FUNC_001028ed"
        },
        "clearerr": {
            "renaming": {},
            "code": "\n\n\nvoid clearerr(FILE *__stream)\n\n{\n  clearerr(__stream);\n  return;\n}\n\n",
            "called": [
                "clearerr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "clearerr"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_00102bf5",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "bfd_errmsg": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024d0",
            "calling": [
                "FUN_00105db0",
                "FUN_00107c20"
            ],
            "imported": false,
            "current_name": "bfd_errmsg"
        },
        "FUN_001033b0": {
            "renaming": {
                "FUN_001033b0": "print_error_message_and_exit_001033b0",
                "param_1": "errorMessage"
            },
            "code": "\n\n\nvoid printErrorMessageAndExit_001033b0(undefined8 errorMessage)\n\n{\n  fprintf(_stderr,\"%s\\n\",errorMessage);\n                    \n  exit(2);\n}\n\n",
            "called": [
                "exit",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033b0",
            "calling": [
                "FUN_001033d6",
                "FUN_00103df9",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "print_error_message_and_exit_001033b0"
        },
        "fwrite": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102510",
            "calling": [
                "FUN_00103a78",
                "FUN_00103e95",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "fwrite"
        },
        "unlink": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "FUN_00102f1e",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "unlink"
        },
        "unlink_if_ordinary": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "FUN_00102bf5"
            ],
            "imported": false,
            "current_name": "unlink_if_ordinary"
        },
        "FUN_001025a0": {
            "renaming": {
                "FUN_001025a0": "find_file_error_001025a0",
                "piVar1": "errorPointer",
                "uVar2": "errorMessage"
            },
            "code": "\nundefined8 findFileError_001025a0(void)\n\n{\n  int *errorPointer;\n  undefined8 errorMessage;\n  \n  errorPointer = __errno_location();\n  if (*errorPointer == 2) {\n    errorMessage = dcgettext(0,\"\\'%s\\': No such file\",5);\n    FUN_00107920(errorMessage);\n  }\n  else {\n    strerror(*errorPointer);\n    errorMessage = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    FUN_00107920(errorMessage);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "dcgettext",
                "__errno_location",
                "FUN_00107920",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001025a0",
            "calling": [
                "FUN_001052a0"
            ],
            "imported": false,
            "current_name": "find_file_error_001025a0"
        },
        "FUN_0010284b": {
            "renaming": {
                "FUN_0010284b": "initialize_application_0010284b",
                "undefined8": "void"
            },
            "code": "\nvoid initializeApplication_0010284b(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010284b",
            "calling": [
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "initialize_application_0010284b"
        },
        "FUN_00102c25": {
            "renaming": {
                "FUN_00102c25": "extract_and_write_archive_00102c25",
                "puVar9": "param_7",
                "pplVar6": "archivePointer",
                "unaff_RBX": "fileData",
                "iVar2": "result",
                "plVar8": "currentFile",
                "uVar5": "errorMessage",
                "lVar7": "loopCounter",
                "iVar1": "comparisonResult",
                "__ptr": "buffer",
                "__n": "readBytes",
                "param_11": "filePermissions",
                "param_12": "fileSize",
                "uVar10": "bytesProcessed",
                "sVar11": "bytesToProcess",
                "piVar3": "errorNumber",
                "pcVar4": "errorString"
            },
            "code": "\n\n\nlong * extractAndWriteArchive_00102c25(void)\n\n{\n  int comparisonResult;\n  int result;\n  int *errorNumber;\n  char *errorString;\n  undefined8 errorMessage;\n  long **archivePointer;\n  void *buffer;\n  size_t readBytes;\n  long loopCounter;\n  long **fileData;\n  long *currentFile;\n  undefined4 *param_7;\n  ulong bytesProcessed;\n  size_t bytesToProcess;\n  undefined4 *param_7;\n  __mode_t filePermissions;\n  ulong fileSize;\n  \n  param_7 = param_7;\n  for (loopCounter = 0x24; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *param_7 = 0;\n    param_7 = param_7 + 1;\n  }\n  archivePointer = (long **)fileData[0x1d];\n  if ((long **)fileData[0x1d] == (long **)0x0) {\n    archivePointer = fileData;\n  }\n  result = (*(code *)archivePointer[1][0x3d])();\n  if (result != 0) {\n    currentFile = *fileData;\n    errorMessage = dcgettext(0,\"internal stat error on %s\",5);\n    result = FUN_00107690(errorMessage,currentFile);\n    errorMessage = DAT_0010d638;\n    if (result == 3) {\n      for (; *currentFile != 0; currentFile = (long *)(*currentFile + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*currentFile != (undefined8 *)0x0; currentFile = (long *)(*currentFile + 0xf0)) {\n        comparisonResult = filename_cmp(*(undefined8 *)*currentFile,errorMessage);\n        if (comparisonResult == 0) {\n          if (result != 2) {\n            return currentFile;\n          }\n          return (long *)(*currentFile + 0xf0);\n        }\n      }\n    }\n    return currentFile;\n  }\n  bfd_seek();\n  DAT_0010d5d8 = (FILE *)0x0;\n  if (fileSize == 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 = (FILE *)FUN_00105a20(*fileData);\n  }\n  else {\n    bytesProcessed = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      bytesToProcess = fileSize - bytesProcessed;\n      if (0x2000 < bytesToProcess) {\n        bytesToProcess = 0x2000;\n      }\n      readBytes = bfd_bread(buffer,bytesToProcess);\n      if (bytesToProcess != readBytes) {\nLAB_00102c78:\n        fileData = (long **)*fileData[0x1d];\n        errorMessage = dcgettext(0,\"%s is not a valid archive\",5);\n        FUN_00107690(errorMessage,fileData);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 == (FILE *)0x0) {\n        DAT_0010d5d8 = (FILE *)FUN_00105a20(*fileData);\n      }\n      bytesToProcess = fwrite(buffer,1,readBytes,DAT_0010d5d8);\n      if (bytesToProcess != readBytes) {\n        errorNumber = __errno_location();\n        errorString = strerror(*errorNumber);\n        FUN_00107690(\"%s: %s\",DAT_0010d618,errorString);\n        goto LAB_00102c78;\n      }\n      bytesProcessed = bytesProcessed + readBytes;\n    } while (bytesProcessed < fileSize);\n    free(buffer);\n  }\n  fclose(DAT_0010d5d8);\n  errorString = DAT_0010d618;\n  DAT_0010d5d8 = (FILE *)0x0;\n  chmod(DAT_0010d618,filePermissions);\n  if (_DAT_0010d600 != 0) {\n    FUN_00107c80(errorString,param_7);\n  }\n  DAT_0010d618 = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "FUN_00107c80",
                "dcgettext",
                "FUN_00105a20",
                "xmalloc",
                "__errno_location",
                "bfd_bread",
                "FUN_00107690",
                "fwrite",
                "bfd_seek",
                "fclose",
                "free",
                "chmod",
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c25",
            "calling": [
                "FUN_00107740"
            ],
            "imported": false,
            "current_name": "extract_and_write_archive_00102c25"
        },
        "bfd_plugin_set_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_program_name"
        },
        "bfd_bwrite": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_bwrite"
        },
        "FUN_00102bb0": {
            "renaming": {
                "FUN_00102bb0": "extract_substring_00102bb0",
                "in_RAX": "inputString",
                "sVar2": "inputStringLen",
                "puVar3": "resultString",
                "uVar4": "lengthToExtract",
                "unaff_RBX": "sourcePtr",
                "unaff_RBP": "stackBase",
                "puVar5": "resultPtr",
                "bVar6": "isBackward",
                "auVar7": "returnValue",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] extractSubstring_00102bb0(void)\n\n{\n  long lVar1;\n  char *inputString;\n  size_t inputStringLen;\n  undefined *resultString;\n  ulong lengthToExtract;\n  undefined *sourcePtr;\n  long stackBase;\n  undefined *resultPtr;\n  byte isBackward;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  isBackward = 0;\n  inputStringLen = strlen(inputString);\n  lengthToExtract = (ulong)*(byte *)(*(long *)(stackBase + 8) + 0x1e);\n  resultString = sourcePtr;\n  if (lengthToExtract < inputStringLen) {\n    resultString = (undefined *)xmalloc(lengthToExtract + 1);\n    lVar1 = *(long *)(stackBase + 8);\n    resultPtr = resultString;\n    for (lengthToExtract = (ulong)*(byte *)(lVar1 + 0x1e); lengthToExtract != 0; lengthToExtract = lengthToExtract - 1) {\n      *resultPtr = *sourcePtr;\n      sourcePtr = sourcePtr + (ulong)isBackward * -2 + 1;\n      resultPtr = resultPtr + (ulong)isBackward * -2 + 1;\n    }\n    resultString[*(byte *)(lVar1 + 0x1e)] = 0;\n  }\n  returnValue._8_8_ = returnAddress;\n  returnValue._0_8_ = resultString;\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bb0",
            "calling": [
                "FUN_00105830"
            ],
            "imported": false,
            "current_name": "extract_substring_00102bb0"
        },
        "utimensat": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "FUN_00107c80"
            ],
            "imported": false,
            "current_name": "utimensat"
        },
        "getc": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102560",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "getc"
        },
        "dup": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "FUN_00102d2f",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "dup"
        },
        "FUN_00102f08": {
            "renaming": {
                "FUN_00102f08": "print_and_swap_00102f08",
                "unaff_RBX": "arrayPointer",
                "unaff_R12": "valuePointer"
            },
            "code": "\nundefined8 printAndSwap_00102f08(void)\n\n{\n  undefined8 *arrayPointer;\n  undefined8 *valuePointer;\n  \n  printf(\"a - %s\\n\",*arrayPointer);\n  arrayPointer[0x1e] = *valuePointer;\n  *valuePointer = arrayPointer;\n  return 1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f08",
            "calling": [
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "print_and_swap_00102f08"
        },
        "FUN_00105570": {
            "renaming": {
                "FUN_00105570": "process_inputs_00105570",
                "param_1": "context",
                "param_2": "inputs",
                "param_3": "flag",
                "ppcVar1": "current_input",
                "uVar2": "result",
                "bVar3": "temp",
                "iVar4": "count",
                "sVar5": "length",
                "piVar6": "errno_loc",
                "pcVar7": "input_path",
                "pcVar8": "temp_path",
                "uVar9": "dependency_path",
                "pcVar10": "current_path",
                "__s": "basename_result",
                "lVar11": "temp_pointer",
                "lVar12": "next_pointer",
                "uVar13": "return_value",
                "uVar14": "max_length",
                "ppcVar15": "input_list",
                "ppcVar16": "input_entry",
                "uVar17": "flag_value",
                "ppcVar18": "previous_entry",
                "bVar19": "is_dependency",
                "bVar20": "loop_flag",
                "local_15a": "is_error",
                "auStack_158": "temporary_array",
                "lStack_100": "modified_time",
                "sStack_c8": "file_stat"
            },
            "code": "\n\n\nundefined8 process_inputs_00105570(long context,char **inputs,char flag)\n\n{\n  char **current_input;\n  undefined result;\n  byte temp;\n  int count;\n  size_t length;\n  int *errno_loc;\n  char *input_path;\n  char *temp_path;\n  undefined8 dependency_path;\n  char *current_path;\n  char *basename_result;\n  long temp_pointer;\n  long next_pointer;\n  undefined8 return_value;\n  ulong max_length;\n  char **input_list;\n  char **input_entry;\n  uint flag_value;\n  char **previous_entry;\n  bool is_dependency;\n  byte loop_flag;\n  byte is_error;\n  undefined temporary_array [88];\n  long modified_time;\n  stat file_stat;\n  \n  loop_flag = 0;\n  current_input = (char **)(context + 0xf0);\n  is_error = 0;\n  if (inputs == (char **)0x0) {\n    return_value = FUN_00102943();\n    return return_value;\n  }\n  do {\n    current_path = *inputs;\njoined_r0x001055aa:\n    if (current_path == (char *)0x0) {\n      if (is_error != 0) {\n        return_value = FUN_001058b0(context);\n        return return_value;\n      }\n      DAT_0010d618 = 0;\n      return 0;\n    }\n    input_list = *(char ***)(context + 0xf0);\n    input_entry = current_input;\n    if (flag != '\\0') {\nLAB_0010564c:\n      flag_value = DAT_0010d640;\n      if (DAT_0010d640 != 0) goto LAB_001028f5;\n      next_pointer = *(long *)(context + 0xf0);\n      if (*(long *)(context + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n      do {\n        temp_pointer = next_pointer;\n        next_pointer = *(long *)(temp_pointer + 0xf0);\n      } while (next_pointer != 0);\n      input_entry = (char **)(temp_pointer + 0xf0);\n      current_path = *inputs;\n      do {\n        if (DAT_0010d620 != 0) {\n          return_value = FUN_00105830(current_path,context);\n          count = filename_cmp(return_value,\"__.LIBDEP\");\n          if (count == 0) {\n            temp = FUN_00105ae0(input_entry,DAT_0010d620,DAT_0010d60c != 0,DAT_0010d5f8);\n            is_error = temp | is_error;\n            goto LAB_0010577e;\n          }\n          current_path = *inputs;\n        }\n        result = DAT_0010d5f8;\n        is_dependency = DAT_0010d60c != 0;\n        next_pointer = bfd_openr(current_path,DAT_0010d5f0);\n        if (next_pointer != 0) {\n          inputs = inputs + 1;\n          temp = FUN_00105af0(input_entry,next_pointer,(uint)is_dependency,result);\n          is_error = is_error | temp;\n          current_path = *inputs;\n          goto joined_r0x001055aa;\n        }\n        FUN_00107c10(current_path,0);\n        flag_value = (uint)is_dependency;\nLAB_001028f5:\n        return_value = DAT_0010d638;\n        if (flag_value == 3) {\n          next_pointer = *(long *)(context + 0xf0);\n          if (*(long *)(context + 0xf0) != 0) goto LAB_00105670;\n        }\n        else {\n          for (; (undefined8 *)*input_entry != (undefined8 *)0x0;\n              input_entry = (char **)(*input_entry + 0xf0)) {\n            count = filename_cmp(*(undefined8 *)*input_entry,return_value);\n            if (count == 0) {\n              if (flag_value == 2) {\n                input_entry = (char **)(*input_entry + 0xf0);\n              }\n              break;\n            }\n          }\n        }\nLAB_0010571f:\n        current_path = *inputs;\n      } while( true );\n    }\n    previous_entry = current_input;\n    if (input_list == (char **)0x0) {\n      flag_value = DAT_0010d640;\n      if (DAT_0010d640 == 0) goto LAB_0010571f;\n      goto LAB_001028f5;\n    }\nLAB_001055d8:\n    if (DAT_0010d5f9 == '\\0') {\n      current_path = (char *)lbasename(*input_list);\n      temp_path = current_path;\n      if (DAT_0010d5fa != '\\0') {\n        length = strlen(current_path);\n        max_length = (ulong)*(byte *)(*(long *)(context + 8) + 0x1e);\n        if (max_length < length) {\n          temp_path = (char *)xmalloc(max_length + 1);\n          next_pointer = *(long *)(context + 8);\n          input_path = temp_path;\n          for (max_length = (ulong)*(byte *)(next_pointer + 0x1e); max_length != 0; max_length = max_length - 1) {\n            *input_path = *current_path;\n            current_path = current_path + (ulong)loop_flag * -2 + 1;\n            input_path = input_path + (ulong)loop_flag * -2 + 1;\n          }\n          temp_path[*(byte *)(next_pointer + 0x1e)] = '\\0';\n        }\n        input_path = *inputs;\n        current_path = temp_path;\n        if (DAT_0010d5f9 == '\\0') goto LAB_00105611;\n        goto LAB_00102980;\n      }\n      input_path = *inputs;\n      if (DAT_0010d5f9 != '\\0') goto LAB_00102980;\nLAB_00105611:\n      basename_result = (char *)lbasename(input_path);\n      if (DAT_0010d5fa != '\\0') {\n        length = strlen(basename_result);\n        max_length = (ulong)*(byte *)(*(long *)(context + 8) + 0x1e);\n        input_path = basename_result;\n        current_path = temp_path;\n        if (max_length < length) {\n          input_path = (char *)xmalloc(max_length + 1);\n          next_pointer = *(long *)(context + 8);\n          temp_path = input_path;\n          for (max_length = (ulong)*(byte *)(next_pointer + 0x1e); max_length != 0; max_length = max_length - 1) {\n            *temp_path = *basename_result;\n            basename_result = basename_result + (ulong)loop_flag * -2 + 1;\n            temp_path = temp_path + (ulong)loop_flag * -2 + 1;\n          }\n          input_path[*(byte *)(next_pointer + 0x1e)] = '\\0';\n        }\n        goto LAB_00102980;\n      }\n      count = filename_cmp(basename_result,temp_path);\n      if (count == 0) goto LAB_00102993;\nLAB_00105639:\n      previous_entry = input_list + 0x1e;\n      input_list = (char **)input_list[0x1e];\n      if (input_list == (char **)0x0) goto LAB_0010564c;\n      goto LAB_001055d8;\n    }\n    input_path = *inputs;\n    current_path = *input_list;\nLAB_00102980:\n    count = filename_cmp(input_path,current_path);\n    if (count != 0) goto LAB_00105639;\nLAB_00102993:\n    if (input_list[0x1c] == (char *)0x0) goto LAB_00105639;\n    if (_DAT_0010d644 != 0) {\n      count = stat(*inputs,&file_stat);\n      if (count != 0) {\n        errno_loc = __errno_location();\n        if (*errno_loc != 2) {\n          FUN_00107c10(*inputs);\nLAB_00102b7e:\n          current_path = *input_list;\n          return_value = dcgettext(0,\"internal stat error on %s\",5);\n          FUN_00107690(return_value,current_path);\n          free(inputs);\n          return 0;\n        }\n        goto LAB_0010577e;\n      }\n      input_entry = (char **)input_list[0x1d];\n      if ((char **)input_list[0x1d] == (char **)0x0) {\n        input_entry = input_list;\n      }\n      count = (**(code **)(input_entry[1] + 0x1e8))(input_list,temporary_array);\n      if (count != 0) goto LAB_00102b7e;\n      if (file_stat.st_mtim.tv_sec <= modified_time) goto LAB_0010577e;\n    }\n    return_value = FUN_00105870(current_input,2,*input_list);\n    if (DAT_0010d620 == 0) {\nLAB_00102ae2:\n      current_path = *inputs;\n      is_dependency = DAT_0010d60c != 0;\n      next_pointer = bfd_openr(current_path,DAT_0010d5f0);\n      if (next_pointer == 0) {\n        FUN_00107c10(current_path,0);\n        goto LAB_00102b3e;\n      }\n      temp = FUN_00103172(return_value,next_pointer,is_dependency);\n    }\n    else {\n      dependency_path = FUN_00105830(*inputs,context);\n      count = filename_cmp(dependency_path,\"__.LIBDEP\");\n      if (count != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n      temp = FUN_00103172(return_value,DAT_0010d620,DAT_0010d60c != 0);\n    }\n    if (temp != 0) {\n      *previous_entry = *(char **)(*previous_entry + 0xf0);\n      is_error = temp;\n    }\nLAB_0010577e:\n    inputs = inputs + 1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00102943"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105570",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "process_inputs_00105570"
        }
    },
    "used_tokens": 71926,
    "layers": [
        [
            "FUN_00102cd9",
            "FUN_001079c0",
            "FUN_00105a68",
            "FUN_001032a8",
            "FUN_0010285f",
            "FUN_00102f96",
            "FUN_0010342d",
            "FUN_0010394a",
            "FUN_00107920",
            "FUN_00105bb0",
            "FUN_00107640",
            "FUN_00102e6f",
            "FUN_0010315d",
            "FUN_00107890",
            "FUN_001033d6",
            "FUN_00103172",
            "FUN_00105870",
            "FUN_001030ed",
            "FUN_00105bc0",
            "FUN_00107650",
            "FUN_00102f1e",
            "FUN_00102fd7",
            "FUN_00103ba8",
            "FUN_00103ddc",
            "FUN_001078c0",
            "FUN_001075e0",
            "FUN_00105480",
            "FUN_001031a5",
            "FUN_00103df9",
            "FUN_00103a78",
            "FUN_001058b0",
            "FUN_00102bf5",
            "FUN_00102020",
            "FUN_00102943",
            "FUN_00107c80",
            "FUN_00105a20",
            "FUN_00102f55",
            "FUN_001057a0",
            "FUN_00102d8c",
            "FUN_00105300",
            "FUN_00105db0",
            "FUN_00103bd1",
            "FUN_00107c10",
            "FUN_00102710",
            "FUN_00103e95",
            "FUN_00107cc0",
            "FUN_00105ae0",
            "FUN_00107690",
            "FUN_0010266f",
            "FUN_00105830",
            "FUN_00107730",
            "FUN_00107c20",
            "FUN_001031cf",
            "FUN_0010312d",
            "FUN_00105c00",
            "FUN_001052a0",
            "FUN_0010336b",
            "FUN_00103c60",
            "FUN_00102e57",
            "FUN_00105af0",
            "FUN_0010300e",
            "FUN_00102ba1",
            "FUN_00107740",
            "FUN_00102d2f",
            "FUN_001028ed",
            "FUN_001033b0",
            "FUN_001025a0",
            "FUN_0010284b",
            "FUN_00102c25",
            "FUN_00102bb0",
            "FUN_00102f08",
            "FUN_00105570"
        ]
    ],
    "locked_functions": []
}