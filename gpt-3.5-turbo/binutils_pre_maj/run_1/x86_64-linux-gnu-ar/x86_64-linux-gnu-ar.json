{
    "functions": {
        "bfd_fdopenr": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenr(void)\n\n{\n  bfd_fdopenr();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_fdopenr"
        },
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "FUN_00102cd9": {
            "renaming": {
                "FUN_00102cd9": "find_matching_pointer_00102cd9",
                "in_EAX": "inputValue",
                "iVar1": "comparisonResult",
                "unaff_RBX": "currentPointer",
                "param_7": "targetValue"
            },
            "code": "\nlong * findMatchingPointer_00102cd9(void)\n\n{\n  int inputValue;\n  int comparisonResult;\n  long *currentPointer;\n  undefined8 targetValue;\n  \n  targetValue = DAT_0010d638;\n  if (inputValue == 3) {\n    for (; *currentPointer != 0; currentPointer = (long *)(*currentPointer + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*currentPointer != (undefined8 *)0x0; currentPointer = (long *)(*currentPointer + 0xf0)) {\n      comparisonResult = filename_cmp(*(undefined8 *)*currentPointer,targetValue);\n      if (comparisonResult == 0) {\n        if (inputValue != 2) {\n          return currentPointer;\n        }\n        return (long *)(*currentPointer + 0xf0);\n      }\n    }\n  }\n  return currentPointer;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102cd9",
            "calling": [
                "FUN_00105870"
            ],
            "imported": false,
            "current_name": "find_matching_pointer_00102cd9"
        },
        "bfd_close": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102490",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_00102710",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "bfd_close"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_0010d400 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_0010d2c8);\n  FUNC_00105cf0();\n  DAT_0010d400 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00105cf0",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105d60",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "lbasename": {
            "renaming": {},
            "code": "\nvoid lbasename(void)\n\n{\n  lbasename();\n  return;\n}\n\n",
            "called": [
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "FUN_00102e6f",
                "FUN_00105db0",
                "FUN_00105830",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "lbasename"
        },
        "bfd_bread": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102540",
            "calling": [
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "bfd_bread"
        },
        "FUN_001079c0": {
            "renaming": {
                "FUN_001079c0": "print_file_info_001079c0",
                "param_1": "outputFile",
                "param_2": "fileInfo",
                "param_3": "printTime",
                "param_4": "printAddress",
                "iVar1": "returnValue",
                "ppcVar2": "fileInfoPtr",
                "pcVar3": "timeString",
                "uVar4": "filePermissions",
                "local_100": "currentTime",
                "uStack_f3": "fileType",
                "cStack_f2": "readPermission",
                "cStack_f1": "writePermission",
                "cStack_f0": "executePermission",
                "cStack_ef": "readPermissionOther",
                "cStack_ee": "writePermissionOther",
                "cStack_ed": "executePermissionOther",
                "cStack_ec": "readPermissionGroup",
                "cStack_eb": "writePermissionGroup",
                "cStack_ea": "executePermissionGroup",
                "local_e8": "timeFormatted",
                "local_b8": "localBuffer",
                "uStack_a0": "fileSize",
                "uStack_9c": "majorDeviceID",
                "uStack_98": "minorDeviceID",
                "uStack_88": "inodeNumber",
                "local_60": "fileModifiedTime"
            },
            "code": "\nvoid printFileInfo_001079c0(FILE *outputFile,char **fileInfo,char printTime,char printAddress)\n\n{\n  int returnValue;\n  char **fileInfoPtr;\n  char *timeString;\n  uint filePermissions;\n  time_t currentTime;\n  undefined fileType;\n  char readPermission;\n  char writePermission;\n  char executePermission;\n  char readPermissionOther;\n  char writePermissionOther;\n  char executePermissionOther;\n  char readPermissionGroup;\n  char writePermissionGroup;\n  char executePermissionGroup;\n  undefined uStack_e9;\n  char timeFormatted [48];\n  undefined localBuffer [24];\n  uint fileSize;\n  uint majorDeviceID;\n  uint minorDeviceID;\n  undefined8 inodeNumber;\n  time_t fileModifiedTime;\n  \n  if (printTime != '\\0') {\n    fileInfoPtr = (char **)fileInfo[0x1d];\n    if ((char **)fileInfo[0x1d] == (char **)0x0) {\n      fileInfoPtr = fileInfo;\n    }\n    returnValue = (**(code **)(fileInfoPtr[1] + 0x1e8))(fileInfo,localBuffer);\n    if (returnValue == 0) {\n      currentTime = fileModifiedTime;\n      timeString = ctime(&currentTime);\n      if (timeString == (char *)0x0) {\n        timeString = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(timeFormatted,timeString);\n      }\n      else {\n        sprintf(timeFormatted,\"%.12s %.4s\",timeString + 4);\n      }\n      filePermissions = fileSize & 0xf000;\n      if (filePermissions == 0x4000) {\n        fileType = 100;\n      }\n      else if (filePermissions == 0xa000) {\n        fileType = 0x6c;\n      }\n      else if (filePermissions == 0x6000) {\n        fileType = 0x62;\n      }\n      else if (filePermissions == 0x2000) {\n        fileType = 99;\n      }\n      else if (filePermissions == 0xc000) {\n        fileType = 0x73;\n      }\n      else {\n        fileType = 0x70;\n        if (filePermissions != 0x1000) {\n          fileType = 0x2d;\n        }\n      }\n      readPermission = (-((fileSize & 0x100) == 0) & 0xbbU) + 0x72;\n      writePermission = (-((fileSize & 0x80) == 0) & 0xb6U) + 0x77;\n      executePermission = (-((fileSize & 0x40) == 0) & 0xb5U) + 0x78;\n      readPermissionOther = (-((fileSize & 0x20) == 0) & 0xbbU) + 0x72;\n      writePermissionOther = (-((fileSize & 0x10) == 0) & 0xb6U) + 0x77;\n      executePermissionOther = (-((fileSize & 8) == 0) & 0xb5U) + 0x78;\n      readPermissionGroup = (-((fileSize & 4) == 0) & 0xbbU) + 0x72;\n      writePermissionGroup = (-((fileSize & 2) == 0) & 0xb6U) + 0x77;\n      executePermissionGroup = (-((fileSize & 1) == 0) & 0xb5U) + 0x78;\n      if ((fileSize & 0x800) != 0) {\n        if (executePermission == 'x') {\n          executePermission = 's';\n        }\n        else {\n          executePermission = 'S';\n        }\n      }\n      if ((fileSize & 0x400) != 0) {\n        if (executePermissionOther == 'x') {\n          executePermissionOther = 's';\n        }\n        else {\n          executePermissionOther = 'S';\n        }\n      }\n      if ((fileSize & 0x200) != 0) {\n        if (executePermissionGroup == 'x') {\n          executePermissionGroup = 't';\n        }\n        else {\n          executePermissionGroup = 'T';\n        }\n      }\n      uStack_e9 = 0;\n      fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&readPermission,(ulong)majorDeviceID,(ulong)minorDeviceID,inodeNumber,\n              timeFormatted,(ulong)fileSize);\n    }\n  }\n  fputs(*fileInfo,outputFile);\n  if (printAddress != '\\0') {\n    if ((*(byte *)((long)fileInfo + 0x49) & 0x10) == 0) {\n      if (fileInfo[0xb] != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (fileInfo[0xc] != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "sprintf",
                "FUN_00102d8c",
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001079c0",
            "calling": [
                "FUN_00107890",
                "FUN_00103ddc"
            ],
            "imported": false,
            "current_name": "print_file_info_001079c0"
        },
        "FUN_00105a68": {
            "renaming": {
                "FUN_00105a68": "write_to_file_00105a68",
                "pcVar1": "sourceDirectory",
                "pFVar2": "filePointer",
                "sVar3": "sourceLength"
            },
            "code": "\nvoid writeToFile_00105a68(void)\n\n{\n  char *sourceDirectory;\n  FILE *filePointer;\n  size_t sourceLength;\n  \n  sourceDirectory = DAT_0010d5e8;\n  if (DAT_0010d5e8 != (char *)0x0) {\n    sourceLength = strlen(DAT_0010d5e8);\n    if (sourceLength != 0) {\n      if (sourceDirectory[sourceLength - 1] == '/') {\n        DAT_0010d618 = (char *)concat(sourceDirectory,DAT_0010d618,0);\n      }\n      else {\n        DAT_0010d618 = (char *)concat(sourceDirectory,&DAT_00108260,DAT_0010d618,0);\n      }\n    }\n  }\n  if (DAT_0010d60c != 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  filePointer = fopen(DAT_0010d618,\"w\");\n  if (filePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "concat",
                "printf",
                "xexit",
                "FUN_00102e57",
                "perror",
                "fopen",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a68",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "write_to_file_00105a68"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "FUN_001032a8": {
            "renaming": {
                "FUN_001032a8": "extract_files_from_archive_001032a8",
                "param_1": "archive",
                "param_2": "callback",
                "param_3": "entryNames",
                "param_4": "returnValue",
                "lVar1": "currentEntry",
                "uVar2": "currentEntryName",
                "bVar3": "entryFound",
                "plVar4": "currentNode",
                "iVar5": "comparisonResult",
                "__format": "formatString",
                "plVar6": "nextNode",
                "lVar7": "currentNodeAddress",
                "plVar8": "previousNode"
            },
            "code": "\n\n\nundefined8 extractFilesFromArchive_001032a8(long *archive,code *callback,undefined8 *entryNames,undefined8 returnValue)\n\n{\n  long currentEntry;\n  undefined8 currentEntryName;\n  bool entryFound;\n  long *currentNode;\n  int comparisonResult;\n  char *formatString;\n  long *nextNode;\n  long currentNodeAddress;\n  long *previousNode;\n  \n  currentNodeAddress = archive[0x1e];\n  if (entryNames == (undefined8 *)0x0) {\n    while (currentNodeAddress != 0) {\n      currentEntry = *(long *)(currentNodeAddress + 0xf0);\n      (*callback)(currentNodeAddress,0);\n      currentNodeAddress = currentEntry;\n    }\n  }\n  else {\n    do {\n      entryFound = false;\n      currentNode = (long *)archive[0x1e];\n      previousNode = archive;\n      while (nextNode = currentNode, nextNode != (long *)0x0) {\n        if (*nextNode != 0) {\n          comparisonResult = filename_cmp(*entryNames);\n          if (comparisonResult == 0) {\n            entryFound = true;\n            (*callback)(nextNode,previousNode);\n          }\n        }\n        previousNode = nextNode;\n        currentNode = (long *)nextNode[0x1e];\n      }\n      if (!entryFound) {\n        currentEntryName = *entryNames;\n        formatString = (char *)dcgettext(0,\"No entry %s in archive.\\n\",5);\n        fprintf(_stderr,formatString,currentEntryName);\n      }\n      entryNames = (undefined8 *)entryNames[1];\n    } while (entryNames != (undefined8 *)0x0);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "filename_cmp",
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001032a8",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "extract_files_from_archive_001032a8"
        },
        "FUN_0010285f": {
            "renaming": {
                "FUN_0010285f": "print_archive_entry_error_0010285f",
                "__format": "errorMessage",
                "lVar2": "extractedString",
                "plVar3": "tempPointer",
                "uVar4": "entryName",
                "plVar5": "currentPointer",
                "unaff_RBP": "functionPointer",
                "unaff_R12": "archivePointer",
                "unaff_R13D": "remainingEntries",
                "unaff_R14": "entryNameList",
                "iStack000000000000000c": "entryCount"
            },
            "code": "\n\n\nvoid printArchiveEntryError_0010285f(void)\n\n{\n  int iVar1;\n  char *errorMessage;\n  long extractedString;\n  long *tempPointer;\n  undefined8 entryName;\n  long *currentPointer;\n  code *functionPointer;\n  long archivePointer;\n  int remainingEntries;\n  undefined8 *entryNameList;\n  int entryCount;\n  \ncode_r0x0010285f:\n  entryName = *entryNameList;\n  errorMessage = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n  fprintf(_stderr,errorMessage,entryName);\nLAB_0010553e:\n  entryNameList = entryNameList + 1;\n  remainingEntries = remainingEntries + -1;\n  if (remainingEntries == 0) {\n    return;\n  }\n  currentPointer = *(long **)(archivePointer + 0xf0);\n  entryCount = 0;\n  do {\n    if (currentPointer == (long *)0x0) goto code_r0x0010285f;\n    if (*(int *)((long)currentPointer + 0xac) == 0) {\n      extractedString = *currentPointer;\n      if (extractedString == 0) {\n        tempPointer = (long *)currentPointer[0x1d];\n        if ((long *)currentPointer[0x1d] == (long *)0x0) {\n          tempPointer = currentPointer;\n        }\n        (**(code **)(tempPointer[1] + 0x1e8))(currentPointer,&stack0x00000010);\n      }\n      else if (((*(byte *)(archivePointer + 0x49) & 0x10) == 0) || (extractedString = extract_sub_string_00105830(), extractedString != 0))\n      {\n        entryName = extract_sub_string_00105830(*entryNameList);\n        iVar1 = filename_cmp(entryName,extractedString);\n        if ((iVar1 == 0) &&\n           ((DAT_0010d634 == '\\0' ||\n            (entryCount = entryCount + 1,\n            entryCount == _DAT_0010d630)))) break;\n      }\n    }\n    currentPointer = (long *)currentPointer[0x1e];\n  } while( true );\n  (*functionPointer)();\n  *(undefined4 *)((long)currentPointer + 0xac) = 1;\n  goto LAB_0010553e;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010285f",
            "calling": [
                "FUN_00105480"
            ],
            "imported": false,
            "current_name": "print_archive_entry_error_0010285f"
        },
        "bfd_set_archive_head": {
            "renaming": {},
            "code": "\nvoid bfd_set_archive_head(void)\n\n{\n  bfd_set_archive_head();\n  return;\n}\n\n",
            "called": [
                "bfd_set_archive_head"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "bfd_set_archive_head"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "FUN_00102bb0",
                "FUN_00105db0",
                "FUN_001057a0",
                "FUN_001028ed",
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "vfprintf": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024b0",
            "calling": [
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "vfprintf"
        },
        "FUN_00102f96": {
            "renaming": {
                "FUN_00102f96": "print_error_message_00102f96",
                "unaff_RBX": "errorFlag",
                "unaff_retaddr": "returnAddress",
                "uVar1": "errorMessage",
                "dcgettext": "getLocalizedMessage",
                "_stdout": "standardOutput",
                "_stderr": "standardError",
                "fprintf": "printFormatted",
                "fflush": "flushBuffer"
            },
            "code": "\n\n\nvoid printErrorMessage_00102f96(void)\n\n{\n  undefined8 errorMessage;\n  long errorFlag;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(standardOutput);\n  if (errorFlag != 0) {\n    fprintf(standardError,\"%s: %s: %s\\n\",DAT_0010d660);\n    return;\n  }\n  fprintf(standardError,\"%s: %s\\n\",DAT_0010d660,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "fflush",
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f96",
            "calling": [
                "FUN_00107c20"
            ],
            "imported": false,
            "current_name": "print_error_message_00102f96"
        },
        "FUN_0010342d": {
            "renaming": {
                "FUN_0010342d": "display_usage_message_0010342d",
                "param_1": "outputRedirected",
                "uVar1": "message",
                "pcVar2": "localizedMessage",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid displayUsageMessage_0010342d(uint outputRedirected)\n\n{\n  undefined8 message;\n  char *localizedMessage;\n  FILE *outputStream;\n  \n  localizedMessage = (char *)dcgettext(0,\n                             \"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV] [--plugin <name>] [member-name] [count] archive-file file...\\n\"\n                             ,5);\n  outputStream = _stderr;\n  if (outputRedirected != 0) {\n    outputStream = _stdout;\n  }\n  fprintf(outputStream,localizedMessage,DAT_0010d660);\n  message = DAT_0010d660;\n  localizedMessage = (char *)dcgettext(0,\"       %s -M [<mri-script]\\n\",5);\n  fprintf(outputStream,localizedMessage,message);\n  localizedMessage = (char *)dcgettext(0,\" commands:\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  d            - delete file(s) from the archive\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  m[ab]        - move file(s) in the archive\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  p            - print file(s) found in the archive\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  q[f]         - quick append file(s) to the archive\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\n                             \"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\\n\"\n                             ,5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  s            - act as ranlib\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  t[O][v]      - display contents of the archive\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  x[o]         - extract file(s) from the archive\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\" command specific modifiers:\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [a]          - put file(s) after [member-name]\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [b]          - put file(s) before [member-name] (same as [i])\\n\",5\n                            );\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [D]          - use zero for timestamps and uids/gids (default)\\n\",\n                             5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [U]          - use actual timestamps and uids/gids\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [N]          - use instance [count] of name\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [f]          - truncate inserted file names\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [P]          - use full path names when matching\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [o]          - preserve original dates\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [O]          - display offsets of files in the archive\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\n                             \"  [u]          - only replace files that are newer than current archive contents\\n\"\n                             ,5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\" generic modifiers:\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [c]          - do not warn if the library had to be created\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [s]          - create an archive index (cf. ranlib)\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [l <text> ]  - specify the dependencies of this library\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [S]          - do not build a symbol table\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [T]          - deprecated, use --thin instead\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [v]          - be verbose\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  [V]          - display the version number\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  @<file>      - read options from <file>\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  --target=BFDNAME - specify the target object format as BFDNAME\\n\",\n                             5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\n                             \"  --output=DIRNAME - specify the output directory for extraction operations\\n\"\n                             ,5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\n                             \"  --record-libdeps=<text> - specify the dependencies of this library\\n\"\n                             ,5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  --thin       - make a thin archive\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\" optional:\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  localizedMessage = (char *)dcgettext(0,\"  --plugin <p> - load the specified plugin\\n\",5);\n  fprintf(outputStream,localizedMessage);\n  print_emulation_options_0010336b(outputStream);\n  print_supported_targets_0010266f(DAT_0010d660,outputStream);\n  if (outputRedirected != 0) {\n    localizedMessage = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,localizedMessage,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(outputRedirected ^ 1);\n}\n\n",
            "called": [
                "FUN_0010266f",
                "FUN_0010336b",
                "dcgettext",
                "xexit",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010342d",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "display_usage_message_0010342d"
        },
        "FUN_0010394a": {
            "renaming": {
                "FUN_0010394a": "print_archive_usage_0010394a",
                "param_1": "flag_verbose",
                "uVar1": "symbol_map_timestamp",
                "__stream": "stream",
                "pcVar2": "message",
                "dcgettext": "getTranslatedMessage",
                "_stderr": "error_stream",
                "_stdout": "output_stream",
                "print_supported_targets_0010266f": "printSupportedTargets",
                "xexit": "exitProgram"
            },
            "code": "\n\n\nvoid printArchiveUsage_0010394a(uint flag_verbose)\n\n{\n  undefined8 symbol_map_timestamp;\n  char *message;\n  FILE *stream;\n  \n  symbol_map_timestamp = DAT_0010d660;\n  stream = error_stream;\n  if (flag_verbose != 0) {\n    stream = output_stream;\n  }\n  message = (char *)dcgettext(0,\"Usage: %s [options] archive\\n\",5);\n  fprintf(stream,message,symbol_map_timestamp);\n  message = (char *)dcgettext(0,\" Generate an index to speed access to archives\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\n                             \" The options are:\\n  @<file>                      Read options from <file>\\n\"\n                             ,5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\"  --plugin <name>              Load the specified plugin\\n\",5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\n                             \"  -D                           Use zero for symbol map timestamp (default)\\n  -U                           Use an actual symbol map timestamp\\n\"\n                             ,5);\n  fprintf(stream,message);\n  message = (char *)dcgettext(0,\n                             \"  -t                           Update the archive\\'s symbol map timestamp\\n  -h --help                    Print this help message\\n  -v --version                 Print version information\\n\"\n                             ,5);\n  fprintf(stream,message);\n  printSupportedTargets(DAT_0010d660,stream);\n  if (flag_verbose != 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(stream,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(flag_verbose ^ 1);\n}\n\n",
            "called": [
                "FUN_0010266f",
                "dcgettext",
                "xexit",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010394a",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_archive_usage_0010394a"
        },
        "FUN_00107920": {
            "renaming": {
                "FUN_00107920": "print_error_message_00107920",
                "param_1": "errorCode",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "param_8": "param8",
                "param_9": "errorMessage",
                "param_10": "param10",
                "param_11": "param11",
                "param_12": "param12",
                "param_13": "param13",
                "param_14": "param14",
                "in_AL": "flag",
                "local_d8": "bufferSize",
                "local_d4": "localVariable1",
                "local_d0": "localPointer1",
                "local_c8": "localPointer2",
                "local_b8": "buffer1",
                "local_b0": "param10Copy",
                "local_a8": "param11Copy",
                "local_a0": "param12Copy",
                "local_98": "param13Copy",
                "local_90": "param14Copy",
                "local_88": "localVar1",
                "local_78": "localVar2",
                "local_68": "localVar3",
                "local_58": "localVar4",
                "local_48": "localVar5",
                "local_38": "localVar6",
                "local_28": "localVar7",
                "local_18": "localVar8"
            },
            "code": "\nvoid printErrorMessage_00107920(undefined4 errorCode,undefined4 param2,undefined4 param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6,undefined4 param7,undefined4 param8,\n                 undefined8 errorMessage,undefined8 param10,undefined8 param11,undefined8 param12,\n                 undefined8 param13,undefined8 param14)\n\n{\n  char flag;\n  undefined4 bufferSize;\n  undefined4 localVariable1;\n  undefined *localPointer1;\n  undefined *localPointer2;\n  undefined buffer1 [8];\n  undefined8 param10Copy;\n  undefined8 param11Copy;\n  undefined8 param12Copy;\n  undefined8 param13Copy;\n  undefined8 param14Copy;\n  undefined4 localVar1;\n  undefined4 localVar2;\n  undefined4 localVar3;\n  undefined4 localVar4;\n  undefined4 localVar5;\n  undefined4 localVar6;\n  undefined4 localVar7;\n  undefined4 localVar8;\n  \n  if (flag != '\\0') {\n    localVar1 = errorCode;\n    localVar2 = param2;\n    localVar3 = param3;\n    localVar4 = param4;\n    localVar5 = param5;\n    localVar6 = param6;\n    localVar7 = param7;\n    localVar8 = param8;\n  }\n  localPointer1 = &stack0x00000008;\n  bufferSize = 8;\n  localPointer2 = buffer1;\n  localVariable1 = 0x30;\n  param10Copy = param10;\n  param11Copy = param11;\n  param12Copy = param12;\n  param13Copy = param13;\n  param14Copy = param14;\n  print_error_message_001078c0(errorMessage,&bufferSize);\n  return;\n}\n\n",
            "called": [
                "FUN_001078c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107920",
            "calling": [
                "FUN_001025a0",
                "FUN_00105300",
                "FUN_00102f1e",
                "FUN_00102e6f",
                "FUN_00105db0",
                "FUN_001052a0",
                "FUN_00102fd7"
            ],
            "imported": false,
            "current_name": "print_error_message_00107920"
        },
        "ctime": {
            "renaming": {},
            "code": "\n\n\nchar * ctime(time_t *__timer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = ctime(__timer);\n  return pcVar1;\n}\n\n",
            "called": [
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "ctime"
        },
        "bfd_set_default_target": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_default_target"
        },
        "bfd_get_error": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "FUN_00105300",
                "FUN_00107c20",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_get_error"
        },
        "bfd_fdopenw": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102570",
            "calling": [
                "FUN_00103c60",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "bfd_fdopenw"
        },
        "write": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "write"
        },
        "FUN_00105bb0": {
            "renaming": {
                "FUN_00105bb0": "initialize_value_00105bb0"
            },
            "code": "\nundefined8 initializeValue_00105bb0(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bb0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_value_00105bb0"
        },
        "FUN_00107640": {
            "renaming": {
                "FUN_00107640": "initialize_00107640"
            },
            "code": "\nundefined8 initialize_00107640(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107640",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "initialize_00107640"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102590",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "FUN_00102e6f": {
            "renaming": {
                "FUN_00102e6f": "extract_file_path_00102e6f",
                "in_RAX": "filePath",
                "pcVar1": "basePath",
                "uVar2": "basename",
                "uVar3": "errorMessage",
                "pFVar4": "filePointer",
                "sVar5": "pathLength",
                "pcVar6": "currentChar"
            },
            "code": "\nvoid extractFilePath_00102e6f(void)\n\n{\n  char *basePath;\n  char *filePath;\n  undefined8 basename;\n  undefined8 errorMessage;\n  FILE *filePointer;\n  size_t pathLength;\n  char *currentChar;\n  \n  basePath = DAT_0010d5e8;\n  do {\n    filePath = filePath + 1;\n    while (*filePath != '/') {\n      if (*filePath == '\\0') {\n        if ((DAT_0010d5e8 != (char *)0x0) && (pathLength = strlen(DAT_0010d5e8), pathLength != 0)) {\n          if (basePath[pathLength - 1] == '/') {\n            DAT_0010d618 = (char *)concat(basePath,DAT_0010d618,0);\n          }\n          else {\n            DAT_0010d618 = (char *)concat(basePath,&DAT_00108260,DAT_0010d618,0);\n          }\n        }\n        if (DAT_0010d60c != 0) {\n          printf(\"x - %s\\n\",DAT_0010d618);\n        }\n        filePointer = fopen(DAT_0010d618,\"w\");\n        if (filePointer == (FILE *)0x0) {\n          perror(DAT_0010d618);\n                    \n          xexit(1);\n        }\n        return;\n      }\n      currentChar = filePath;\n      if ((*filePath == '.') && (currentChar = filePath + 1, filePath[1] == '.')) {\n        currentChar = filePath + 2;\n        if ((filePath[2] == '/') || (filePath[2] == '\\0')) {\n          basename = lbasename();\n          basePath = DAT_0010d618;\n          errorMessage = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\"\n                            ,5);\n          print_error_message_00107920(errorMessage,basePath,basename);\n          DAT_0010d618 = (char *)basename;\n          write_to_file_00105a68();\n          return;\n        }\n      }\n      for (; (filePath = currentChar, *currentChar != '\\0' && (*currentChar != '/')); currentChar = currentChar + 1) {\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00105a68",
                "FUN_00102e6f",
                "lbasename",
                "dcgettext",
                "FUN_00107920"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e6f",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "extract_file_path_00102e6f"
        },
        "FUN_0010315d": {
            "renaming": {
                "FUN_0010315d": "check_and_exit_if_zero_0010315d",
                "xexit": "exitFunction"
            },
            "code": "\n\n\nvoid checkAndExitIfZero_0010315d(void)\n\n{\n  if (_DAT_0010d608 == 0) {\n                    \n    xexit(9);\n  }\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010315d",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_and_exit_if_zero_0010315d"
        },
        "textdomain": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "textdomain"
        },
        "concat": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_00105a68",
                "FUN_00102e57"
            ],
            "imported": false,
            "current_name": "concat"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "FUN_00107890": {
            "renaming": {
                "FUN_00107890": "print_file_info_00107890",
                "param_1": "file",
                "_stdout": "output"
            },
            "code": "\n\n\nvoid printFileInfo_00107890(undefined8 file)\n\n{\n  print_file_info_001079c0(output,file,DAT_0010d60c != 0,_DAT_0010d5fc != 0);\n  return;\n}\n\n",
            "called": [
                "FUN_001079c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107890",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_file_info_00107890"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102500",
            "calling": [
                "FUN_001033b0",
                "FUN_001075e0"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "bfd_check_format": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102520",
            "calling": [
                "FUN_00103c60",
                "FUN_00105af0",
                "FUN_00102710"
            ],
            "imported": false,
            "current_name": "bfd_check_format"
        },
        "FUN_001033d6": {
            "renaming": {
                "FUN_001033d6": "create_buffer_001033d6",
                "param_1": "inputParam1",
                "param_2": "inputParam2",
                "param_3": "inputParam3",
                "param_4": "inputParam4",
                "pvVar1": "buffer",
                "pvVar2": "dynamicMemory",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16]\ncreateBuffer_001033d6(undefined8 inputParam1,undefined8 inputParam2,undefined8 inputParam3,undefined8 inputParam4)\n\n{\n  void *buffer;\n  void *dynamicMemory;\n  undefined returnValue [16];\n  \n  buffer = malloc(0x40);\n  if (buffer != (void *)0x0) goto LAB_001033f7;\n  do {\n    buffer = (void *)print_error_message_and_exit_001033b0(\"out of dynamic memory in yy_create_buffer()\");\nLAB_001033f7:\n    *(undefined4 *)((long)buffer + 0x18) = 0x4000;\n    dynamicMemory = malloc(0x4002);\n    *(void **)((long)buffer + 8) = dynamicMemory;\n  } while (dynamicMemory == (void *)0x0);\n  *(undefined4 *)((long)buffer + 0x20) = 1;\n  initialize_file_001031cf(buffer,inputParam1);\n  returnValue._8_8_ = inputParam4;\n  returnValue._0_8_ = buffer;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_001033b0",
                "FUN_001031cf",
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033d6",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "create_buffer_001033d6"
        },
        "fileno": {
            "renaming": {},
            "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "FUN_00105db0",
                "FUN_001031cf"
            ],
            "imported": false,
            "current_name": "fileno"
        },
        "FUN_00103172": {
            "renaming": {
                "FUN_00103172": "copy_and_print_string_00103172",
                "param_1": "source_ptr",
                "param_2": "destination_ptr",
                "param_3": "should_print",
                "param_4": "value_to_set",
                "uVar1": "source_value",
                "auVar2": "new_data"
            },
            "code": "\nundefined  [16]\ncopy_and_print_string_00103172(undefined8 *source_ptr,undefined8 *destination_ptr,char should_print,undefined8 value_to_set)\n\n{\n  undefined8 source_value;\n  undefined new_data [16];\n  \n  if (should_print != '\\0') {\n    printf(\"r - %s\\n\",*destination_ptr);\n  }\n  source_value = *source_ptr;\n  destination_ptr[0x1e] = source_value;\n  new_data._1_7_ = (undefined7)((ulong)source_value >> 8);\n  new_data[0] = 1;\n  *source_ptr = destination_ptr;\n  new_data._8_8_ = value_to_set;\n  return new_data;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103172",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "copy_and_print_string_00103172"
        },
        "FUN_00105870": {
            "renaming": {
                "FUN_00105870": "find_matching_entry_00105870",
                "param_1": "entries",
                "param_2": "count",
                "param_3": "targetFilename",
                "uVar2": "defaultFilename",
                "iVar3": "mode",
                "iVar1": "cmpResult"
            },
            "code": "\nlong * findMatchingEntry_00105870(long *entries,int count,undefined8 targetFilename)\n\n{\n  int cmpResult;\n  undefined8 defaultFilename;\n  int mode;\n  \n  defaultFilename = DAT_0010d638;\n  mode = DAT_0010d640;\n  if (DAT_0010d640 == 0) {\n    defaultFilename = targetFilename;\n    mode = count;\n  }\n  if (mode == 3) {\n    for (; *entries != 0; entries = (long *)(*entries + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*entries != (undefined8 *)0x0; entries = (long *)(*entries + 0xf0)) {\n      cmpResult = filename_cmp(*(undefined8 *)*entries,defaultFilename);\n      if (cmpResult == 0) {\n        if (mode != 2) {\n          return entries;\n        }\n        return (long *)(*entries + 0xf0);\n      }\n    }\n  }\n  return entries;\n}\n\n",
            "called": [
                "FUN_00102cd9"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105870",
            "calling": [
                "FUN_00105db0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "find_matching_entry_00105870"
        },
        "FUN_001030ed": {
            "renaming": {
                "FUN_001030ed": "extract_data_from_binary_001030ed",
                "puVar1": "ptrData"
            },
            "code": "\nvoid extractDataFromBinary_001030ed(void)\n\n{\n  undefined8 *ptrData;\n  \n  ptrData = *(undefined8 **)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n  DAT_0010d598 = *(undefined4 *)((long)ptrData + 0x1c);\n  DAT_0010d5b0 = (undefined *)ptrData[2];\n  DAT_0010d5c8 = DAT_0010d5b0;\n  DAT_0010d590 = *ptrData;\n  DAT_0010d588 = *DAT_0010d5b0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001030ed",
            "calling": [
                "FUN_00103e95",
                "FUN_001031cf"
            ],
            "imported": false,
            "current_name": "extract_data_from_binary_001030ed"
        },
        "FUN_00105bc0": {
            "renaming": {
                "FUN_00105bc0": "copy_and_remove_file_00105bc0",
                "param_1": "sourceFilePath",
                "param_2": "destFilePath",
                "param_3": "filePermissions",
                "param_4": "returnValue",
                "uVar1": "result",
                "piVar2": "errnoAddress",
                "pcVar3": "errorString",
                "uVar4": "errorFormat",
                "uVar5": "errorNumber",
                "auVar6": "returnValues"
            },
            "code": "\nundefined  [16] copyAndRemoveFile_00105bc0(char *sourceFilePath,char *destFilePath,undefined4 filePermissions,undefined8 returnValue)\n\n{\n  uint result;\n  int *errnoAddress;\n  char *errorString;\n  undefined8 errorFormat;\n  ulong errorNumber;\n  undefined returnValues [16];\n  \n  if (destFilePath == sourceFilePath) {\n    errorNumber = 0;\n  }\n  else {\n    result = reverse_and_write_to_file_00105c00(filePermissions);\n    errorNumber = (ulong)result;\n    if (result != 0) {\n      errnoAddress = __errno_location();\n      errorString = strerror(*errnoAddress);\n      errorFormat = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      print_error_message_00107920(errorFormat,destFilePath,errorString);\n    }\n    unlink(sourceFilePath);\n  }\n  returnValues._8_8_ = returnValue;\n  returnValues._0_8_ = errorNumber;\n  return returnValues;\n}\n\n",
            "called": [
                "FUN_00105c00",
                "FUN_00102f1e"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bc0",
            "calling": [
                "FUN_00103e95",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "copy_and_remove_file_00105bc0"
        },
        "FUN_00107650": {
            "renaming": {
                "FUN_00107650": "check_file_and_generate_listing_00107650",
                "param_1": "file",
                "lVar2": "fileInfo",
                "uVar1": "result"
            },
            "code": "\nundefined8 checkFileAndGenerateListing_00107650(undefined8 file)\n\n{\n  undefined8 result;\n  long fileInfo;\n  \n  fileInfo = get_file_information_001052a0();\n  if (fileInfo < 1) {\n    result = 1;\n  }\n  else {\n    DAT_0010d648 = 1;\n    fileInfo = convert_and_open_library_00105300(file,0);\n    if (fileInfo == 0) {\n                    \n      xexit(1);\n    }\n    generate_archive_listing_001058b0(fileInfo);\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_00105300",
                "xexit",
                "FUN_001052a0",
                "FUN_0010284b",
                "FUN_001058b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107650",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "check_file_and_generate_listing_00107650"
        },
        "setlocale": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "setlocale"
        },
        "FUN_00102f1e": {
            "renaming": {
                "FUN_00102f1e": "copy_file_and_print_error_00102f1e",
                "piVar1": "error_number",
                "uVar2": "error_message",
                "unaff_RBP": "file_size",
                "unaff_R12": "file_path",
                "auVar3": "return_value"
            },
            "code": "\nundefined  [16] copy_file_and_print_error_00102f1e(void)\n\n{\n  int *error_number;\n  undefined8 error_message;\n  ulong file_size;\n  char *file_path;\n  undefined return_value [16];\n  undefined8 unaff_retaddr;\n  \n  error_number = __errno_location();\n  strerror(*error_number);\n  error_message = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  print_error_message_00107920(error_message);\n  unlink(file_path);\n  return_value._0_8_ = file_size & 0xffffffff;\n  return_value._8_8_ = unaff_retaddr;\n  return return_value;\n}\n\n",
            "called": [
                "dcgettext",
                "__errno_location",
                "strerror",
                "FUN_00107920",
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f1e",
            "calling": [
                "FUN_00105bc0"
            ],
            "imported": false,
            "current_name": "copy_file_and_print_error_00102f1e"
        },
        "bfd_set_error": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_error"
        },
        "FUN_00102fd7": {
            "renaming": {
                "FUN_00102fd7": "print_time_set_error_message_00102fd7",
                "piVar1": "ptr_errno",
                "uVar2": "var_error_message"
            },
            "code": "\nvoid print_time_set_error_message_00102fd7(void)\n\n{\n  int *ptr_errno;\n  undefined8 var_error_message;\n  \n  ptr_errno = __errno_location();\n  strerror(*ptr_errno);\n  var_error_message = dcgettext(0,\"%s: cannot set time: %s\",5);\n  print_error_message_00107920(var_error_message);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "__errno_location",
                "strerror",
                "FUN_00107920"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd7",
            "calling": [
                "FUN_00107c80"
            ],
            "imported": false,
            "current_name": "print_time_set_error_message_00102fd7"
        },
        "FUN_00103ba8": {
            "renaming": {
                "FUN_00103ba8": "check_ar_status_00103ba8",
                "printf": "printARStatus",
                "fflush": "flushOutput"
            },
            "code": "\n\n\nvoid checkARStatus_00103ba8(void)\n\n{\n  if (_DAT_0010d608 != 0) {\n    printf(\"AR >\");\n    fflush(_stdout);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "printf",
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ba8",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_ar_status_00103ba8"
        },
        "bindtextdomain": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bindtextdomain"
        },
        "filename_cmp": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "FUN_00105db0",
                "FUN_001032a8",
                "FUN_00103e95",
                "FUN_00105480",
                "FUN_001028ed",
                "FUN_00102cd9"
            ],
            "imported": false,
            "current_name": "filename_cmp"
        },
        "bfd_make_readable": {
            "renaming": {},
            "code": "\nvoid bfd_make_readable(void)\n\n{\n  bfd_make_readable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_readable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_make_readable"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "FUN_00105300",
                "FUN_00102e6f",
                "FUN_00105db0",
                "FUN_001032a8",
                "FUN_00103e95",
                "FUN_00102f96",
                "FUN_001031a5",
                "FUN_001058b0",
                "FUN_0010285f",
                "FUN_001075e0",
                "FUN_00102c25",
                "FUN_00103a78",
                "FUN_0010266f",
                "FUN_001025a0",
                "FUN_00103c60",
                "FUN_00102f1e",
                "FUN_0010336b",
                "FUN_0010342d",
                "FUN_001052a0",
                "FUN_0010394a",
                "FUN_00102d8c",
                "FUN_00103bd1",
                "FUN_001028ed",
                "FUN_00102fd7"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_format": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "bfd_set_format"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "FUN_0010266f",
                "FUN_00102d8c",
                "FUN_00103bd1"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "bfd_openw": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "FUN_00105300",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_openw"
        },
        "FUN_00103ddc": {
            "renaming": {
                "FUN_00103ddc": "print_file_info_00103ddc",
                "param_1": "file_name"
            },
            "code": "\nvoid print_file_info_00103ddc(undefined8 file_name)\n\n{\n  print_file_info_00103ddc_001079c0(DAT_0010d578,file_name,DAT_0010d60c != 0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_001079c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ddc",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "print_file_info_00103ddc"
        },
        "FUN_001078c0": {
            "renaming": {
                "FUN_001078c0": "print_error_message_001078c0",
                "param_1": "message",
                "param_2": "args",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printErrorMessage_001078c0(char *message,__gnuc_va_list args)\n\n{\n  fflush(standardOutput);\n  fprintf(standardError,\"%s: \",DAT_0010d660);\n  vfprintf(standardError,message,args);\n  putc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "fflush",
                "vfprintf",
                "fprintf",
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001078c0",
            "calling": [
                "FUN_00107690",
                "FUN_00107920"
            ],
            "imported": false,
            "current_name": "print_error_message_001078c0"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "bfd_openr": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00103e95",
                "FUN_00102710",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "bfd_openr"
        },
        "FUN_001075e0": {
            "renaming": {
                "FUN_001075e0": "print_version_info_001075e0",
                "param_1": "version",
                "pcVar1": "message"
            },
            "code": "\nvoid printVersionInfo_001075e0(undefined8 version)\n\n{\n  char *message;\n  \n  printf(\"GNU %s %s\\n\",version,\"(GNU Binutils for Debian) 2.40\");\n  message = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(message);\n  message = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(message);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "printf",
                "dcgettext",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001075e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_version_info_001075e0"
        },
        "FUN_00105480": {
            "renaming": {
                "FUN_00105480": "extract_entries_from_archive_00105480",
                "param_1": "archive",
                "param_2": "callback",
                "param_3": "entry_list",
                "param_4": "entry_count",
                "__format": "format_string",
                "lVar2": "next_entry",
                "plVar3": "current_entry",
                "uVar4": "extracted_string",
                "plVar5": "entry_ptr",
                "local_cc": "entry_counter",
                "local_c8": "buffer"
            },
            "code": "\n\n\nvoid extract_entries_from_archive_00105480(long archive,code *callback,undefined8 *entry_list,int entry_count)\n\n{\n  int iVar1;\n  char *format_string;\n  long next_entry;\n  long *current_entry;\n  undefined8 extracted_string;\n  long *entry_ptr;\n  int entry_counter;\n  undefined buffer [152];\n  \n  next_entry = *(long *)(archive + 0xf0);\n  if (entry_count == 0) {\n    for (; next_entry != 0; next_entry = *(long *)(next_entry + 0xf0)) {\n      (*callback)(next_entry);\n    }\n  }\n  else {\n    for (; next_entry != 0; next_entry = *(long *)(next_entry + 0xf0)) {\n      *(undefined4 *)(next_entry + 0xac) = 0;\n    }\n    do {\n      entry_ptr = *(long **)(archive + 0xf0);\n      entry_counter = 0;\n      for (; entry_ptr != (long *)0x0; entry_ptr = (long *)entry_ptr[0x1e]) {\n        if (*(int *)((long)entry_ptr + 0xac) == 0) {\n          next_entry = *entry_ptr;\n          if (next_entry == 0) {\n            current_entry = (long *)entry_ptr[0x1d];\n            if ((long *)entry_ptr[0x1d] == (long *)0x0) {\n              current_entry = entry_ptr;\n            }\n            (**(code **)(current_entry[1] + 0x1e8))(entry_ptr,buffer);\n          }\n          else if (((*(byte *)(archive + 0x49) & 0x10) == 0) ||\n                  (next_entry = extract_sub_string_00105830(next_entry,archive), next_entry != 0)) {\n            extracted_string = extract_sub_string_00105830(*entry_list,archive);\n            iVar1 = filename_cmp(extracted_string,next_entry);\n            if ((iVar1 == 0) &&\n               ((DAT_0010d634 == '\\0' || (entry_counter = entry_counter + 1, entry_counter == _DAT_0010d630)))) {\n              (*callback)();\n              *(undefined4 *)((long)entry_ptr + 0xac) = 1;\n              goto LAB_0010553e;\n            }\n          }\n        }\n      }\n      extracted_string = *entry_list;\n      format_string = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n      fprintf(_stderr,format_string,extracted_string);\nLAB_0010553e:\n      entry_list = entry_list + 1;\n      entry_count = entry_count + -1;\n    } while (entry_count != 0);\n  }\n  return;\n}\n\n",
            "called": [
                "filename_cmp",
                "FUN_00105830",
                "FUN_0010285f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105480",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_entries_from_archive_00105480"
        },
        "FUN_00105cf0": {
            "renaming": {
                "FUN_00105cf0": "FUNC_00105cf0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d03) */\n/* WARNING: Removing unreachable block (ram,0x00105d0f) */\n\nvoid FUNC_00105cf0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105cf0",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105cf0"
        },
        "FUN_001031a5": {
            "renaming": {
                "FUN_001031a5": "print_archive_script_syntax_error_001031a5",
                "uVar1": "lineNumber",
                "__format": "errorFormat"
            },
            "code": "\nvoid printArchiveScriptSyntaxError_001031a5(void)\n\n{\n  uint lineNumber;\n  char *errorFormat;\n  \n  lineNumber = DAT_0010d554 + 1;\n  errorFormat = (char *)dcgettext(0,\"Syntax error in archive script, line %d\\n\",5);\n  printf(errorFormat,(ulong)lineNumber);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031a5",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "print_archive_script_syntax_error_001031a5"
        },
        "bfd_make_writable": {
            "renaming": {},
            "code": "\nvoid bfd_make_writable(void)\n\n{\n  bfd_make_writable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_writable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_make_writable"
        },
        "strtol": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "strtol"
        },
        "bfd_create": {
            "renaming": {},
            "code": "\nvoid bfd_create(void)\n\n{\n  bfd_create();\n  return;\n}\n\n",
            "called": [
                "bfd_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_create"
        },
        "bfd_target_list": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "bfd_target_list"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "FUN_00102ba1",
                "FUN_0010266f",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_00103bd1",
                "FUN_00102c25",
                "FUN_00103a78",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "free"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102480",
            "calling": [
                "FUN_00105a68",
                "FUN_00105300",
                "FUN_00107650",
                "FUN_00105db0",
                "FUN_00107c10",
                "FUN_0010342d",
                "FUN_00107690",
                "FUN_0010394a",
                "FUN_0010315d",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "close": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "FUN_00105c00",
                "FUN_001058b0",
                "FUN_00102f55"
            ],
            "imported": false,
            "current_name": "close"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102470",
            "calling": [
                "FUN_00105a68",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "malloc": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "FUN_00105db0",
                "FUN_001033d6",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "malloc"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_001052a0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "FUN_00103df9": {
            "renaming": {
                "FUN_00103df9": "ensure_buffer_stack_00103df9",
                "in_RCX": "returnValue",
                "lVar1": "loopCounter",
                "lVar2": "newSize",
                "puVar3": "ptrToEnd",
                "bVar4": "tempByte"
            },
            "code": "\nundefined8 ensureBufferStack_00103df9(void)\n\n{\n  size_t __size;\n  undefined8 returnValue;\n  long loopCounter;\n  long newSize;\n  undefined4 *ptrToEnd;\n  byte tempByte;\n  \n  tempByte = 0;\n  if (DAT_0010d5a8 == (void *)0x0) {\n    DAT_0010d5a8 = calloc(8,1);\n    if (DAT_0010d5a8 != (void *)0x0) {\n      DAT_0010d580 = 1;\n      DAT_0010d5a0 = 0;\n      return returnValue;\n    }\n  }\n  else {\n    if (DAT_0010d5a0 < DAT_0010d580 - 1U) {\n      return returnValue;\n    }\n    newSize = DAT_0010d580 + 8;\n    __size = newSize * 8;\n    DAT_0010d5a8 = realloc(DAT_0010d5a8,__size);\n    if (DAT_0010d5a8 != (void *)0x0) {\n      ptrToEnd = (undefined4 *)((long)DAT_0010d5a8 + (__size - 0x40));\n      DAT_0010d580 = newSize;\n      for (loopCounter = 0x10; loopCounter != 0; loopCounter = loopCounter + -1) {\n        *ptrToEnd = 0;\n        ptrToEnd = ptrToEnd + (ulong)tempByte * -2 + 1;\n      }\n      return returnValue;\n    }\n  }\n  print_error_message_and_exit_001033b0(\"out of dynamic memory in yyensure_buffer_stack()\");\n  DAT_0010d5a0 = 0;\n  DAT_0010d580 = 1;\n  return returnValue;\n}\n\n",
            "called": [
                "realloc",
                "FUN_001033b0",
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103df9",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "ensure_buffer_stack_00103df9"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "FUN_00103c60",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "extract_and_print_archive_00103a78",
                "param_1": "config",
                "iVar1": "result",
                "__ptr": "buffer",
                "puVar2": "handle",
                "uVar3": "bytes_read",
                "uVar4": "error_message",
                "sVar5": "bytes_written",
                "piVar6": "errno_ptr",
                "unaff_RBP": "remaining_bytes",
                "pcVar7": "error_string",
                "unaff_R13": "total_bytes_read",
                "unaff_R14": "archive_size",
                "auStack_b8": "temp_buffer",
                "local_88": "desired_size"
            },
            "code": "\n\n\nvoid extract_and_print_archive_00103a78(undefined8 *config)\n\n{\n  int result;\n  void *buffer;\n  undefined8 *handle;\n  ulong bytes_read;\n  undefined8 error_message;\n  size_t bytes_written;\n  int *errno_ptr;\n  size_t remaining_bytes;\n  char *error_string;\n  ulong total_bytes_read;\n  ulong archive_size;\n  undefined temp_buffer [48];\n  ulong desired_size;\n  \n  buffer = (void *)xmalloc(0x2000);\n  handle = (undefined8 *)config[0x1d];\n  if ((undefined8 *)config[0x1d] == (undefined8 *)0x0) {\n    handle = config;\n  }\n  result = (**(code **)(handle[1] + 0x1e8))(config,temp_buffer);\n  if (result == 0) {\n    if (DAT_0010d60c != 0) {\n      printf(\"\\n<%s>\\n\\n\",*config);\n    }\n    total_bytes_read = 0;\n    bfd_seek(config,0,0);\n    goto LAB_00103afd;\n  }\n  config = (undefined8 *)*config;\n  error_string = \"internal stat error on %s\";\n  do {\n    error_message = dcgettext(0,error_string,5);\n    handle_error_00107690(error_message,config);\n    desired_size = archive_size;\n    do {\n      bytes_written = fwrite(buffer,1,remaining_bytes,_stdout);\n      if (bytes_written != remaining_bytes) {\n        errno_ptr = __errno_location();\n        error_string = strerror(*errno_ptr);\n        handle_error_00107690(\"stdout: %s\",error_string);\nLAB_00103b91:\n        free(buffer);\n        return;\n      }\n      total_bytes_read = total_bytes_read + bytes_written;\nLAB_00103afd:\n      if (desired_size <= total_bytes_read) goto LAB_00103b91;\n      remaining_bytes = desired_size - total_bytes_read;\n      if (0x2000 < remaining_bytes) {\n        remaining_bytes = 0x2000;\n      }\n      bytes_read = bfd_bread(buffer,remaining_bytes,config);\n    } while (remaining_bytes == bytes_read);\n    error_string = \"%s is not a valid archive\";\n    config = *(undefined8 **)config[0x1d];\n    archive_size = desired_size;\n  } while( true );\n}\n\n",
            "called": [
                "free",
                "printf",
                "xmalloc",
                "dcgettext",
                "bfd_bread",
                "FUN_00107690",
                "bfd_seek",
                "__errno_location",
                "strerror",
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_and_print_archive_00103a78"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "FUN_00105300",
                "FUN_001078c0",
                "FUN_00105db0",
                "FUN_001032a8",
                "FUN_00103e95",
                "FUN_00102f96",
                "FUN_0010285f",
                "FUN_0010266f",
                "FUN_00103c60",
                "FUN_0010336b",
                "FUN_0010342d",
                "FUN_001033b0",
                "FUN_0010394a",
                "FUN_00102d8c",
                "FUN_00103bd1"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "strrchr": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "strrchr"
        },
        "FUN_001058b0": {
            "renaming": {
                "FUN_001058b0": "generate_archive_listing_001058b0",
                "param_1": "archivePaths",
                "cVar1": "flag",
                "uVar2": "status",
                "iVar3": "fileDescriptor",
                "uVar4": "tempFile",
                "__format": "timeFormat",
                "__ptr": "filePath",
                "__stream": "tempFileStream",
                "ppcVar5": "fileStreamPtr",
                "uStack0000000000000020": "filePermissions",
                "in_stack_00000028": "fileSize",
                "in_stack_00000038": "timestamp",
                "local_3c": "errorCodes",
                "uStack_33": "fileType",
                "cStack_32": "ownerPermissions",
                "cStack_31": "groupPermissions"
            },
            "code": "\n\n\nvoid generateArchiveListing_001058b0(undefined8 *archivePaths)\n\n{\n  char flag;\n  uint status;\n  int fileDescriptor;\n  undefined8 tempFile;\n  char *timeFormat;\n  void *filePath;\n  FILE *tempFileStream;\n  char **fileStreamPtr;\n  uint filePermissions;\n  uint fileSize;\n  undefined8 timestamp;\n  int errorCodes [2];\n  undefined fileType;\n  char ownerPermissions;\n  char groupPermissions;\n  \n  tempFile = archivePaths[0x1e];\n  errorCodes[0] = -1;\n  filePath = (void *)xstrdup(*archivePaths);\n  tempFileStream = (FILE *)create_temp_file_from_path_001057a0(filePath,errorCodes);\n  fileDescriptor = errorCodes[0];\n  if (tempFileStream != (FILE *)0x0) {\n    DAT_0010d618 = tempFileStream;\n    fileStreamPtr = (char **)bfd_fdopenw(tempFileStream,*(undefined8 *)archivePaths[1],errorCodes[0]);\n    if (fileStreamPtr != (char **)0x0) {\n      DAT_0010d5e0 = fileStreamPtr;\n      bfd_set_format(fileStreamPtr,2);\n      status = (~DAT_0010d648 >> 0x1f) << 3 | *(byte *)((long)fileStreamPtr + 0x49) & 0xfffffff7;\n      *(char *)((long)fileStreamPtr + 0x49) = (char)status;\n      if (DAT_0010d5fa != '\\0') {\n        *(uint *)((long)fileStreamPtr + 0x44) = *(uint *)((long)fileStreamPtr + 0x44) | 0x400;\n      }\n      if (_DAT_0010d2d0 != 0) {\n        *(uint *)((long)fileStreamPtr + 0x44) = *(uint *)((long)fileStreamPtr + 0x44) | 0x2000;\n      }\n      if (DAT_0010d5f9 != '\\0') goto LAB_00102d37;\n      while( true ) {\n        if ((DAT_0010d5f8 != '\\0') || ((*(byte *)((long)archivePaths + 0x49) & 0x10) != 0)) {\n          *(byte *)((long)fileStreamPtr + 0x49) = (byte)status | 0x10;\n        }\n        flag = bfd_set_archive_head(fileStreamPtr,tempFile);\n        if (flag != '\\0') break;\n        status = handle_error_and_exit_00107c10(filePath);\nLAB_00102d37:\n        *(uint *)((long)fileStreamPtr + 0x44) = *(uint *)((long)fileStreamPtr + 0x44) | 0x100000;\n      }\n      fileDescriptor = dup(fileDescriptor);\n      flag = bfd_close(fileStreamPtr);\n      if (flag == '\\0') {\n        handle_error_and_exit_00107c10(filePath);\n        timeFormat = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(&stack0xffffffffffffffd8,timeFormat);\n        status = filePermissions & 0xf000;\n        if (status == 0x4000) {\n          fileType = 100;\n        }\n        else if (status == 0xa000) {\n          fileType = 0x6c;\n        }\n        else if (status == 0x6000) {\n          fileType = 0x62;\n        }\n        else if (status == 0x2000) {\n          fileType = 99;\n        }\n        else if (status == 0xc000) {\n          fileType = 0x73;\n        }\n        else {\n          fileType = 0x70;\n          if (status != 0x1000) {\n            fileType = 0x2d;\n          }\n        }\n        ownerPermissions = (-((_filePermissions & 0x100) == 0) & 0xbbU) + 0x72;\n        groupPermissions = (-((_filePermissions & 0x80) == 0) & 0xb6U) + 0x77;\n        fprintf(tempFileStream,\"%s %ld/%ld %6lu %s \",&ownerPermissions,_filePermissions >> 0x20,\n                (ulong)fileSize,timestamp,&stack0xffffffffffffffd8,\n                _filePermissions & 0xffffffff);\n        fputs(*fileStreamPtr,tempFileStream);\n        if ((char)archivePaths != '\\0') {\n          if ((*(byte *)((long)fileStreamPtr + 0x49) & 0x10) == 0) {\n            if (fileStreamPtr[0xb] != (char *)0x0) {\n              fprintf(tempFileStream,\" 0x%lx\");\n            }\n          }\n          else if (fileStreamPtr[0xc] != (char *)0x0) {\n            fprintf(tempFileStream,\" 0x%lx\");\n          }\n        }\n        fputc(10,tempFileStream);\n        return;\n      }\n      DAT_0010d5e0 = (char **)0x0;\n      DAT_0010d618 = (FILE *)0x0;\n      bfd_close(archivePaths);\n      fileDescriptor = copy_and_remove_file_00105bc0(tempFileStream,filePath,fileDescriptor);\n      if (fileDescriptor == 0) {\n        free(filePath);\n        free(tempFileStream);\n        return;\n      }\n      goto LAB_00102d7a;\n    }\n    close(fileDescriptor);\n    handle_error_and_exit_00107c10(filePath);\n  }\n  tempFile = dcgettext(0,\"could not create temporary file whilst writing archive\",5);\n  handle_error_and_exit_00107c10(tempFile);\nLAB_00102d7a:\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "close",
                "bfd_set_format",
                "FUN_001057a0",
                "FUN_00107c10",
                "xstrdup",
                "dcgettext",
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001058b0",
            "calling": [
                "FUN_00107650",
                "FUN_00105db0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "generate_archive_listing_001058b0"
        },
        "fputs": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "FUN_00102d8c"
            ],
            "imported": false,
            "current_name": "fputs"
        },
        "perror": {
            "renaming": {},
            "code": "\n\n\nvoid perror(char *__s)\n\n{\n  perror(__s);\n  return;\n}\n\n",
            "called": [
                "perror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024a0",
            "calling": [
                "FUN_00105a68",
                "FUN_00105300"
            ],
            "imported": false,
            "current_name": "perror"
        },
        "FUN_00102bf5": {
            "renaming": {
                "FUN_00102bf5": "cleanup_before_exit_00102bf5"
            },
            "code": "\nvoid cleanupBeforeExit_00102bf5(void)\n\n{\n  if (DAT_0010d5e0 != 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 != (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close",
                "fclose",
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bf5",
            "calling": [
                "FUN_00107730"
            ],
            "imported": false,
            "current_name": "cleanup_before_exit_00102bf5"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_indirect_function_00102020"
            },
            "code": "\nvoid executeIndirectFunction_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_function_00102020"
        },
        "open": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102460",
            "calling": [
                "FUN_00105c00",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "open"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "FUN_001078c0",
                "FUN_00102f96",
                "FUN_00103ba8",
                "FUN_00103bd1"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "FUN_00102943": {
            "renaming": {
                "FUN_00102943": "clear_data_00102943"
            },
            "code": "\nvoid clearData_00102943(void)\n\n{\n  DAT_0010d618 = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102943",
            "calling": [
                "FUN_00105570",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "clear_data_00102943"
        },
        "bfd_openr_next_archived_file": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102530",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "bfd_openr_next_archived_file"
        },
        "realloc": {
            "renaming": {},
            "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "FUN_00103df9",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "realloc"
        },
        "FUN_00107c80": {
            "renaming": {
                "FUN_00107c80": "set_file_time_00107c80",
                "param_1": "filePath",
                "param_2": "fileInfo",
                "iVar1": "result",
                "piVar2": "errnoLocation",
                "pcVar3": "errorString",
                "uVar4": "translatedError",
                "local_38": "accessTime",
                "uStack_34": "modificationTime",
                "uStack_30": "changeTime",
                "uStack_2c": "timeSpec",
                "local_28": "creationTime"
            },
            "code": "\nvoid setFileTime_00107c80(char *filePath,long fileInfo)\n\n{\n  int result;\n  int *errnoLocation;\n  char *errorString;\n  undefined8 translatedError;\n  undefined4 accessTime;\n  undefined4 modificationTime;\n  undefined4 changeTime;\n  undefined4 timeSpec;\n  undefined4 creationTime;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  \n  creationTime = *(undefined4 *)(fileInfo + 0x58);\n  uStack_24 = *(undefined4 *)(fileInfo + 0x5c);\n  uStack_20 = *(undefined4 *)(fileInfo + 0x60);\n  uStack_1c = *(undefined4 *)(fileInfo + 100);\n  accessTime = *(undefined4 *)(fileInfo + 0x48);\n  modificationTime = *(undefined4 *)(fileInfo + 0x4c);\n  changeTime = *(undefined4 *)(fileInfo + 0x50);\n  timeSpec = *(undefined4 *)(fileInfo + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&accessTime,0);\n  if (result != 0) {\n    errnoLocation = __errno_location();\n    errorString = strerror(*errnoLocation);\n    translatedError = dcgettext(0,\"%s: cannot set time: %s\",5);\n    print_error_message_00107920(translatedError,filePath,errorString);\n  }\n  return;\n}\n\n",
            "called": [
                "utimensat",
                "FUN_00102fd7"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c80",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "set_file_time_00107c80"
        },
        "isatty": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "FUN_00105db0",
                "FUN_001031cf"
            ],
            "imported": false,
            "current_name": "isatty"
        },
        "FUN_00105a20": {
            "renaming": {
                "FUN_00105a20": "extract_and_write_file_00105a20",
                "param_1": "inputPath",
                "pcVar1": "basePath",
                "pcVar2": "currentPath",
                "uVar3": "extractedFilename",
                "uVar4": "errorMessage",
                "pFVar5": "filePointer",
                "sVar6": "length"
            },
            "code": "\nvoid extractAndWriteFile_00105a20(char *inputPath)\n\n{\n  char *basePath;\n  char *currentPath;\n  undefined8 extractedFilename;\n  undefined8 errorMessage;\n  FILE *filePointer;\n  size_t length;\n  \n  basePath = DAT_0010d5e8;\n  DAT_0010d618 = inputPath;\n  if (*inputPath == '/') {\nLAB_00102e9a:\n    extractedFilename = lbasename();\n    basePath = DAT_0010d618;\n    errorMessage = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\",5);\n    print_error_message_00107920(errorMessage,basePath,extractedFilename);\n    DAT_0010d618 = (char *)extractedFilename;\n    FUN_00105a68();\n    return;\n  }\n  do {\n    if (*inputPath == '\\0') {\n      if ((DAT_0010d5e8 != (char *)0x0) && (length = strlen(DAT_0010d5e8), length != 0)) {\n        if (basePath[length - 1] == '/') {\n          DAT_0010d618 = (char *)concat(basePath,DAT_0010d618,0);\n        }\n        else {\n          DAT_0010d618 = (char *)concat(basePath,&DAT_00108260,DAT_0010d618,0);\n        }\n      }\n      if (DAT_0010d60c != 0) {\n        printf(\"x - %s\\n\",DAT_0010d618);\n      }\n      filePointer = fopen(DAT_0010d618,\"w\");\n      if (filePointer == (FILE *)0x0) {\n        perror(DAT_0010d618);\n                    \n        xexit(1);\n      }\n      return;\n    }\n    currentPath = inputPath;\n    if ((*inputPath == '.') && (currentPath = inputPath + 1, inputPath[1] == '.')) {\n      currentPath = inputPath + 2;\n      if ((inputPath[2] == '/') || (inputPath[2] == '\\0')) goto LAB_00102e9a;\n    }\n    for (; (*currentPath != '\\0' && (*currentPath != '/')); currentPath = currentPath + 1) {\n    }\n    for (; inputPath = currentPath, *currentPath == '/'; currentPath = currentPath + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a20",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "extract_and_write_file_00105a20"
        },
        "sprintf": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024f0",
            "calling": [
                "FUN_001079c0",
                "FUN_00102d8c"
            ],
            "imported": false,
            "current_name": "sprintf"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00105d20();\n  return;\n}\n\n",
            "called": [
                "FUN_00105d20"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105da0",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "FUN_00102bb0",
                "FUN_00105a68",
                "FUN_00105db0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "FUN_00102f55": {
            "renaming": {
                "FUN_00102f55": "close_and_return_error_00102f55",
                "unaff_R12D": "fileDescriptor",
                "piVar2": "errnoLocation",
                "iVar1": "errorValue"
            },
            "code": "\nundefined8 closeAndReturnError_00102f55(void)\n\n{\n  int errorValue;\n  int *errnoLocation;\n  int fileDescriptor;\n  \n  errnoLocation = __errno_location();\n  errorValue = *errnoLocation;\n  close(fileDescriptor);\n  *errnoLocation = errorValue;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f55",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "close_and_return_error_00102f55"
        },
        "FUN_001057a0": {
            "renaming": {
                "FUN_001057a0": "create_temp_file_from_path_001057a0",
                "param_1": "path",
                "param_2": "file_descriptor",
                "param_3": "unused_param_1",
                "param_4": "unused_param_2",
                "iVar1": "result",
                "pcVar2": "last_separator",
                "lVar3": "path_length",
                "lVar4": "index",
                "lVar5": "last_separator_index",
                "pcVar6": "temp_file_path",
                "bVar7": "is_last_separator",
                "auVar8": "return_value"
            },
            "code": "\nundefined  [16] create_temp_file_from_path_001057a0(char *path,int *file_descriptor,undefined8 unused_param_1,undefined8 unused_param_2)\n\n{\n  int result;\n  char *last_separator;\n  long path_length;\n  long index;\n  long last_separator_index;\n  char *temp_file_path;\n  byte is_last_separator;\n  undefined return_value [16];\n  \n  is_last_separator = 0;\n  last_separator = strrchr(path,0x2f);\n  if (last_separator == (char *)0x0) {\n    last_separator = (char *)xmalloc(9);\n    path_length = 0;\n  }\n  else {\n    last_separator_index = (long)last_separator - (long)path;\n    last_separator = (char *)xmalloc(last_separator_index + 0xb);\n    path_length = last_separator_index + 1;\n    temp_file_path = last_separator;\n    for (index = last_separator_index; index != 0; index = index + -1) {\n      *temp_file_path = *path;\n      path = path + (ulong)is_last_separator * -2 + 1;\n      temp_file_path = temp_file_path + (ulong)is_last_separator * -2 + 1;\n    }\n    last_separator[last_separator_index] = '/';\n  }\n  *(undefined8 *)(last_separator + path_length) = 0x5858585858587473;\n  *(undefined *)((long)(last_separator + path_length) + 8) = 0;\n  result = mkstemp(last_separator);\n  if (result == -1) {\n    temp_file_path = (char *)0x0;\n    free(last_separator);\n  }\n  else {\n    *file_descriptor = result;\n    temp_file_path = last_separator;\n  }\n  return_value._8_8_ = unused_param_2;\n  return_value._0_8_ = temp_file_path;\n  return return_value;\n}\n\n",
            "called": [
                "FUN_00102ba1",
                "xmalloc",
                "strrchr",
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001057a0",
            "calling": [
                "FUN_00103c60",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "create_temp_file_from_path_001057a0"
        },
        "bfd_cache_close": {
            "renaming": {},
            "code": "\nvoid bfd_cache_close(void)\n\n{\n  bfd_cache_close();\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "FUN_00102bf5",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_cache_close"
        },
        "FUN_00102d8c": {
            "renaming": {
                "FUN_00102d8c": "format_and_print_file_info_00102d8c",
                "param_19": "file_permissions",
                "param_20": "file_link_count",
                "param_22": "file_size",
                "__format": "corrupt_time_message",
                "uVar1": "first_nibble_permissions",
                "unaff_RBX": "file_path",
                "unaff_RBP": "output_file",
                "unaff_R12B": "show_address",
                "uStack0000000000000015": "type_indicator",
                "uStack000000000000001f": "padding",
                "uStack000000000000006c": "device_id"
            },
            "code": "\nvoid formatAndPrintFileInfo_00102d8c(void)\n\n{\n  char *corrupt_time_message;\n  uint first_nibble_permissions;\n  char **file_path;\n  FILE *output_file;\n  char show_address;\n  undefined type_indicator;\n  char cStack0000000000000016;\n  char cStack0000000000000017;\n  char param_9;\n  char cStack0000000000000019;\n  char cStack000000000000001a;\n  char cStack000000000000001b;\n  char cStack000000000000001c;\n  char cStack000000000000001d;\n  char cStack000000000000001e;\n  undefined padding;\n  uint file_permissions;\n  uint device_id;\n  uint file_link_count;\n  undefined8 file_size;\n  \n  corrupt_time_message = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,corrupt_time_message);\n  first_nibble_permissions = file_permissions & 0xf000;\n  if (first_nibble_permissions == 0x4000) {\n    type_indicator = 100;\n  }\n  else if (first_nibble_permissions == 0xa000) {\n    type_indicator = 0x6c;\n  }\n  else if (first_nibble_permissions == 0x6000) {\n    type_indicator = 0x62;\n  }\n  else if (first_nibble_permissions == 0x2000) {\n    type_indicator = 99;\n  }\n  else if (first_nibble_permissions == 0xc000) {\n    type_indicator = 0x73;\n  }\n  else {\n    type_indicator = 0x70;\n    if (first_nibble_permissions != 0x1000) {\n      type_indicator = 0x2d;\n    }\n  }\n  cStack0000000000000016 = (-((file_permissions & 0x100) == 0) & 0xbbU) + 0x72;\n  cStack0000000000000017 = (-((file_permissions & 0x80) == 0) & 0xb6U) + 0x77;\n  param_9 = (-((file_permissions & 0x40) == 0) & 0xb5U) + 0x78;\n  cStack0000000000000019 = (-((file_permissions & 0x20) == 0) & 0xbbU) + 0x72;\n  cStack000000000000001a = (-((file_permissions & 0x10) == 0) & 0xb6U) + 0x77;\n  cStack000000000000001b = (-((file_permissions & 8) == 0) & 0xb5U) + 0x78;\n  cStack000000000000001c = (-((file_permissions & 4) == 0) & 0xbbU) + 0x72;\n  cStack000000000000001d = (-((file_permissions & 2) == 0) & 0xb6U) + 0x77;\n  cStack000000000000001e = (-((file_permissions & 1) == 0) & 0xb5U) + 0x78;\n  if ((file_permissions & 0x800) != 0) {\n    if (param_9 == 'x') {\n      param_9 = 's';\n    }\n    else {\n      param_9 = 'S';\n    }\n  }\n  if ((file_permissions & 0x400) != 0) {\n    if (cStack000000000000001b == 'x') {\n      cStack000000000000001b = 's';\n    }\n    else {\n      cStack000000000000001b = 'S';\n    }\n  }\n  if ((file_permissions & 0x200) != 0) {\n    if (cStack000000000000001e == 'x') {\n      cStack000000000000001e = 't';\n    }\n    else {\n      cStack000000000000001e = 'T';\n    }\n  }\n  padding = 0;\n  fprintf(output_file,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)device_id,\n          (ulong)file_link_count,file_size,&stack0x00000020,(ulong)file_permissions);\n  fputs(*file_path,output_file);\n  if (show_address != '\\0') {\n    if ((*(byte *)((long)file_path + 0x49) & 0x10) == 0) {\n      if (file_path[0xb] != (char *)0x0) {\n        fprintf(output_file,\" 0x%lx\");\n      }\n    }\n    else if (file_path[0xc] != (char *)0x0) {\n      fprintf(output_file,\" 0x%lx\");\n    }\n  }\n  fputc(10,output_file);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fputc",
                "fprintf",
                "sprintf",
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d8c",
            "calling": [
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "format_and_print_file_info_00102d8c"
        },
        "bfd_plugin_set_plugin": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_plugin"
        },
        "__errno_location": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "FUN_00105c00",
                "FUN_001025a0",
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00102f1e",
                "FUN_00103e95",
                "FUN_001031cf",
                "FUN_001028ed",
                "FUN_00102f55",
                "FUN_00102c25",
                "FUN_00103a78",
                "FUN_00102fd7"
            ],
            "imported": false,
            "current_name": "__errno_location"
        },
        "FUN_00105300": {
            "renaming": {
                "FUN_00105300": "convert_and_open_library_00105300",
                "param_1": "libraryName",
                "param_2": "result",
                "plVar1": "fileList",
                "pcVar2": "errorString",
                "bVar3": "isThinLibrary",
                "cVar4": "checkFormat",
                "iVar5": "status",
                "uVar6": "errorMessage",
                "uVar7": "library",
                "piVar8": "errorCode",
                "lVar9": "archivedFile",
                "puVar10": "convertedLibrary",
                "local_b0": "matchingFormats",
                "local_a8": "fileStats"
            },
            "code": "\n\n\nundefined8 * convertAndOpenLibrary_00105300(char *libraryName,undefined8 *result)\n\n{\n  long *fileList;\n  char *errorString;\n  byte isThinLibrary;\n  char checkFormat;\n  int status;\n  undefined8 errorMessage;\n  undefined8 library;\n  int *errorCode;\n  long archivedFile;\n  undefined8 *convertedLibrary;\n  undefined8 matchingFormats;\n  stat fileStats;\n  \n  bfd_set_error(0);\n  if (DAT_0010d5f0 == (char *)0x0) {\n    DAT_0010d5f0 = \"plugin\";\n  }\n  status = stat(libraryName,&fileStats);\n  errorString = DAT_0010d618;\n  if (status == 0) goto LAB_001053be;\n  errorCode = __errno_location();\n  if (*errorCode == 2) {\n    if (DAT_0010d604 == '\\0') {\n      fprintf(_stderr,\"%s: \",DAT_0010d660);\n      perror(libraryName);\n      check_and_exit_if_zero_0010315d();\n      return (undefined8 *)0x0;\n    }\n    if ((DAT_0010d5f0 == (char *)0x0) && (result != (undefined8 *)0x0)) {\n      convertedLibrary = (undefined8 *)read_and_convert_library_00102710();\n      return convertedLibrary;\n    }\n    result = (undefined8 *)bfd_openw(libraryName,DAT_0010d5f0);\n    if (((result != (undefined8 *)0x0) && (checkFormat = bfd_set_format(result,2), checkFormat != '\\0')) &&\n       (checkFormat = bfd_close(result), checkFormat != '\\0')) {\n      errorString = libraryName;\n      if (_DAT_0010d610 == 0) goto LAB_00102826;\n      goto LAB_001053be;\n    }\n  }\n  handle_error_and_exit_00107c10(libraryName);\n  do {\n    isThinLibrary = *(byte *)((long)result + 0x49) >> 4 & 1;\n    if (DAT_0010d5f8 == '\\0') {\n      if (isThinLibrary != 0) {\n        library = *result;\n        errorMessage = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        handle_error_00107690(errorMessage,library);\n        goto LAB_00102812;\n      }\n    }\n    else if (isThinLibrary == 0) {\n      library = *result;\n      errorMessage = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      handle_error_00107690(errorMessage,library);\nLAB_001027cb:\n      print_error_message_00107c20(libraryName);\n      status = bfd_get_error();\n      if (status == 0xd) {\nLAB_00102812:\n        print_matching_formats_00103bd1(matchingFormats);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      fileList = result + 0x1e;\n      for (archivedFile = bfd_openr_next_archived_file(result,0); archivedFile != 0;\n          archivedFile = bfd_openr_next_archived_file(result,archivedFile)) {\n        *fileList = archivedFile;\n        fileList = (long *)(archivedFile + 0xf0);\n      }\n      *fileList = 0;\n      status = bfd_get_error();\n      if (status == 9) {\n        return result;\n      }\n      do {\n        handle_error_and_exit_00107c10(libraryName);\nLAB_00102826:\n        library = dcgettext(0,\"creating %s\",5);\n        print_error_message_00107920(library,libraryName);\n        errorString = libraryName;\nLAB_001053be:\n        DAT_0010d618 = errorString;\n        result = (undefined8 *)bfd_openr(libraryName,DAT_0010d5f0);\n      } while (result == (undefined8 *)0x0);\n      checkFormat = bfd_check_format_matches(result,2,&matchingFormats);\n      if (checkFormat == '\\0') goto LAB_001027cb;\n    } while (((DAT_0010d64c != 2) && (DAT_0010d64c != 7)) ||\n            (archivedFile = bfd_openr_next_archived_file(result,0), archivedFile == 0));\n  } while( true );\n}\n\n",
            "called": [
                "bfd_openw",
                "bfd_set_format",
                "FUN_00107c10",
                "dcgettext",
                "bfd_openr",
                "xexit",
                "bfd_openr_next_archived_file",
                "FUN_00107690",
                "bfd_set_error",
                "stat",
                "FUN_00102710",
                "bfd_close",
                "bfd_check_format_matches",
                "FUN_00107c20",
                "bfd_get_error",
                "fprintf",
                "perror",
                "__errno_location",
                "FUN_00103bd1",
                "FUN_0010315d",
                "FUN_00107920"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105300",
            "calling": [
                "FUN_00107650",
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "convert_and_open_library_00105300"
        },
        "FUN_00105db0": {
            "renaming": {
                "FUN_00105db0": "parse_command_line_00105db0",
                "param_1": "argc",
                "param_2": "argv",
                "pbVar1": "bytePtr",
                "puVar2": "uintPtr",
                "bVar3": "byteVar",
                "plVar4": "longPtr",
                "puVar5": "undefined8Ptr",
                "uVar6": "uintVar1",
                "uVar7": "uintVar2",
                "bVar8": "boolVar1",
                "bVar9": "boolVar2",
                "ppcVar10": "charPtrPtr",
                "piVar11": "intPtr",
                "puVar12": "undefinedPtr",
                "bVar13": "byteVar2",
                "cVar14": "charVar",
                "iVar15": "index",
                "uVar16": "tempVar1",
                "uVar17": "tempVar2",
                "pFVar18": "filePtr",
                "sVar19": "sizeVar1",
                "sVar20": "sizeVar2",
                "__ptr": "bytePtr2",
                "plVar21": "longPtr2",
                "pFVar22": "filePtr2",
                "pcVar23": "charVarPtr",
                "lVar24": "loopIndex3",
                "uVar25": "ulongVar1",
                "puVar26": "undefined8Ptr2",
                "uVar27": "tempVar3",
                "pFVar28": "filePtr3",
                "lVar34": "loopIndex1",
                "lVar35": "loopIndex4",
                "uVar37": "tempVar4",
                "unaff_RBP": "tempVar5",
                "pbVar38": "bytePtr3",
                "pcVar39": "charVarPtr2",
                "unaff_R12": "filePtr4",
                "pcVar43": "charVarPtr3",
                "uVar40": "ulongVar2",
                "uVar41": "ulongVar3",
                "uVar42": "ulongVar4",
                "uVar44": "tempVar7",
                "iVar45": "index2",
                "bVar47": "boolVar3",
                "bVar48": "byteVar3",
                "local_130": "tempVar8",
                "local_128": "filePtr5",
                "local_118": "bytePtr4",
                "local_110": "charPtrPtr2",
                "local_108": "sizeVar3",
                "local_100": "longVar2",
                "local_c8": "undefinedVar"
            },
            "code": "\n\n\nvoid parseCommandLine_00105db0(uint argc,FILE *argv)\n\n{\n  byte *bytePtr;\n  uint *uintPtr;\n  byte byteVar;\n  long *longPtr;\n  undefined8 *undefined8Ptr;\n  undefined4 uintVar1;\n  undefined4 uintVar2;\n  bool boolVar1;\n  bool boolVar2;\n  char **charPtrPtr;\n  int *intPtr;\n  undefined *undefinedPtr;\n  byte byteVar2;\n  char charVar;\n  int index;\n  uint tempVar1;\n  undefined4 tempVar2;\n  FILE *filePtr;\n  size_t sizeVar1;\n  size_t sizeVar2;\n  byte *bytePtr2;\n  long *longPtr2;\n  FILE *filePtr2;\n  char *charVarPtr;\n  long loopIndex3;\n  ulong ulongVar1;\n  undefined8 *undefined8Ptr2;\n  undefined8 tempVar3;\n  FILE *filePtr3;\n  long **pplVar29;\n  undefined8 uVar30;\n  char **ppcVar31;\n  uint extraout_EDX;\n  char **ppcVar32;\n  byte *pbyteVar3;\n  long loopIndex1;\n  long loopIndex4;\n  undefined **ppuVar36;\n  uint tempVar4;\n  char *tempVar5;\n  byte *bytePtr3;\n  char *charVarPtr2;\n  ulong ulongVar2;\n  ulong ulongVar3;\n  ulong ulongVar4;\n  FILE *filePtr4;\n  char *charVarPtr3;\n  uint tempVar7;\n  int index2;\n  char *pcVar46;\n  bool boolVar3;\n  byte byteVar3;\n  undefined8 tempVar8;\n  FILE *filePtr5;\n  byte *bytePtr4;\n  char **charPtrPtr2;\n  size_t sizeVar3;\n  long longVar2;\n  undefined undefinedVar [2];\n  undefined uStack_c6;\n  undefined5 uStack_c5;\n  uint local_b0;\n  \n  byteVar3 = 0;\n  pcVar46 = (char *)(ulong)argc;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_0010d660 = *(long **)argv;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010d660);\n  bfd_plugin_set_program_name(DAT_0010d660);\n  charVarPtr3 = (char *)argv;\n  filePtr = argv;\n  if ((int)argc < 2) goto LAB_001062c6;\n  charPtrPtr2 = (char **)0x7d0;\n  filePtr4 = (FILE *)0x1;\n  filePtr5 = (FILE *)0x0;\n  filePtr2 = argv;\n  do {\n    tempVar1 = (uint)filePtr4;\n    tempVar5 = (char *)(long)(int)tempVar1;\n    tempVar8 = (FILE *)((long)tempVar5 * 8);\n    charVarPtr3 = (char *)filePtr2;\n    if (**(char **)(&filePtr2->_flags + (long)tempVar5 * 2) == '@') {\n      tempVar7 = (int)charPtrPtr2 - 1;\n      charPtrPtr2 = (char **)(ulong)tempVar7;\n      if (tempVar7 == 0) {\n        longPtr2 = *(long **)filePtr2;\n        pcVar46 = \"%s: error: too many @-files encountered\\n\";\nLAB_00106ffe:\n        fprintf(_stderr,pcVar46,longPtr2);\nLAB_0010700f:\n                    \n        xexit(1);\n      }\n      charVarPtr2 = *(char **)(&filePtr2->_flags + (long)tempVar5 * 2) + 1;\n      index = stat(charVarPtr2,(stat *)undefinedVar);\n      if (-1 < index) {\n        if ((local_b0 & 0xf000) == 0x4000) {\n          longPtr2 = *(long **)filePtr2;\n          pcVar46 = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00106ffe;\n        }\n        filePtr = fopen(charVarPtr2,\"r\");\n        if (filePtr != (FILE *)0x0) {\n          index = fseek(filePtr,0,2);\n          if (((index != -1) && (sizeVar1 = ftell(filePtr), sizeVar1 != 0xffffffffffffffff)) &&\n             (index = fseek(filePtr,0,0), index != -1)) {\n            bytePtr4 = (byte *)xmalloc(sizeVar1 + 1);\n            sizeVar2 = fread(bytePtr4,1,sizeVar1,filePtr);\n            if ((sizeVar1 == sizeVar2) || (index = ferror(filePtr), index == 0)) {\n              bytePtr4[sizeVar2] = 0;\n              byteVar2 = *bytePtr4;\n              pbyteVar3 = bytePtr4;\n              while( true ) {\n                if (byteVar2 == 0) goto LAB_00106814;\n                if (((&_sch_istable)[(ulong)byteVar2 * 2] & 0x40) == 0) break;\n                byteVar2 = pbyteVar3[1];\n                pbyteVar3 = pbyteVar3 + 1;\n              }\n              sizeVar1 = strlen((char *)bytePtr4);\n              bytePtr2 = (byte *)xmalloc(sizeVar1 + 1);\n              filePtr3 = (FILE *)0x0;\n              index = 0;\n              boolVar2 = false;\n              boolVar3 = false;\n              boolVar1 = false;\n              longVar2 = 0;\n              pbyteVar3 = bytePtr4;\n              do {\n                while (((&_sch_istable)[(ulong)*pbyteVar3 * 2] & 0x40) != 0) {\n                  pbyteVar3 = pbyteVar3 + 1;\n                }\n                if ((index == 0) || (index + -1 <= (int)longVar2)) {\n                  if (filePtr3 == (FILE *)0x0) {\n                    index = 8;\n                    filePtr3 = (FILE *)xmalloc(0x40);\n                    ppcVar31 = (char **)((long)&filePtr3->_flags + longVar2 * 8);\n                    *ppcVar31 = (char *)0x0;\n                  }\n                  else {\n                    index = index * 2;\n                    filePtr3 = (FILE *)xrealloc(filePtr3,(long)index << 3);\n                    ppcVar31 = (char **)((long)&filePtr3->_flags + longVar2 * 8);\n                    *ppcVar31 = (char *)0x0;\n                  }\n                }\n                else {\n                  ppcVar31 = (char **)((long)&filePtr3->_flags + longVar2 * 8);\n                }\n                byteVar2 = *pbyteVar3;\n                bytePtr3 = bytePtr2;\n                while (byteVar2 != 0) {\n                  while( true ) {\n                    if ((((&_sch_istable)[(ulong)byteVar2 * 2] & 0x40) != 0) &&\n                       (!(bool)(boolVar2 | boolVar1 | boolVar3))) {\n                      boolVar1 = false;\n                      boolVar2 = false;\n                      boolVar3 = false;\n                      goto LAB_0010606f;\n                    }\n                    if (!boolVar1) break;\n                    pbyteVar3 = pbyteVar3 + 1;\n                    *bytePtr3 = byteVar2;\n                    bytePtr3 = bytePtr3 + 1;\n                    boolVar1 = false;\n                    byteVar2 = *pbyteVar3;\n                    if (byteVar2 == 0) goto LAB_0010606f;\n                  }\n                  if (byteVar2 == 0x5c) {\n                    boolVar1 = true;\n                  }\n                  else if (boolVar3) {\n                    if (byteVar2 == 0x27) {\n                      boolVar3 = false;\n                    }\n                    else {\nLAB_001061f1:\n                      *bytePtr3 = byteVar2;\n                      bytePtr3 = bytePtr3 + 1;\n                    }\n                  }\n                  else if (boolVar2) {\n                    if (byteVar2 != 0x22) goto LAB_001061f1;\n                    boolVar2 = false;\n                  }\n                  else if (byteVar2 == 0x27) {\n                    boolVar3 = true;\n                  }\n                  else {\n                    if (byteVar2 != 0x22) goto LAB_001061f1;\n                    boolVar2 = true;\n                  }\n                  bytePtr = pbyteVar3 + 1;\n                  pbyteVar3 = pbyteVar3 + 1;\n                  byteVar2 = *bytePtr;\n                }\nLAB_0010606f:\n                *bytePtr3 = 0;\n                longPtr2 = (long *)xstrdup(bytePtr2);\n                *ppcVar31 = (char *)longPtr2;\n                *(undefined8 *)(filePtr3->_shortbuf + longVar2 * 8 + -0x7b) = 0;\n                byteVar2 = *pbyteVar3;\n                byteVar = (&_sch_istable)[(ulong)byteVar2 * 2];\n                while ((byteVar & 0x40) != 0) {\n                  byteVar2 = pbyteVar3[1];\n                  pbyteVar3 = pbyteVar3 + 1;\n                  byteVar = (&_sch_istable)[(ulong)byteVar2 * 2];\n                }\n                longVar2 = longVar2 + 1;\n                if (byteVar2 == 0) {\n                  free(bytePtr2);\n                  if (filePtr2 == argv) goto LAB_00106834;\n                  goto LAB_0010610a;\n                }\n              } while( true );\n            }\n            free(bytePtr4);\n          }\n          fclose(filePtr);\n        }\n      }\n    }\n    if ((int)pcVar46 <= (int)(tempVar1 + 1)) {\nLAB_001062c6:\n      do {\n        if (_DAT_0010d65c < 0) goto LAB_001073cc;\nLAB_001062d3:\n        tempVar1 = (uint)filePtr4;\n        index = bfd_init();\n        charVarPtr2 = \"fatal error: libbfd ABI mismatch\";\n        if (index != 0x118) goto LAB_00106803;\n        charVarPtr2 = \"x86_64-pc-linux-gnu\";\n        tempVar1 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n        undefinedPtr = PTR_DAT_0010d2e0;\n        filePtr4 = (FILE *)(ulong)tempVar1;\n        if ((char)tempVar1 != '\\0') {\n          if (__xexit_cleanup == (code *)0x0) {\n            __xexit_cleanup = execute_reverse_functions_00107cc0;\n          }\n          if (*(int *)(PTR_DAT_0010d2e0 + 8) < 0x20) {\nLAB_0010632b:\n            undefinedPtr = PTR_DAT_0010d2e0;\n            index = *(int *)(PTR_DAT_0010d2e0 + 8);\n            *(int *)(PTR_DAT_0010d2e0 + 8) = index + 1;\n            *(code **)(undefinedPtr + (long)index * 8 + 0x10) = cleanup_function_00107730;\n          }\n          else {\n            undefined8Ptr2 = (undefined8 *)malloc(0x110);\n            if (undefined8Ptr2 != (undefined8 *)0x0) {\n              *undefined8Ptr2 = undefinedPtr;\n              *(undefined4 *)(undefined8Ptr2 + 1) = 0;\n              PTR_DAT_0010d2e0 = (undefined *)undefined8Ptr2;\n              goto LAB_0010632b;\n            }\n          }\n          loopIndex3 = 1;\n          do {\n            loopIndex4 = loopIndex3;\n            index = (int)pcVar46;\n            if (index <= (int)loopIndex4) break;\n            charVar = initialize_00107640(*(undefined8 *)((int *)charVarPtr3 + loopIndex4 * 2));\n            loopIndex3 = loopIndex4 + 1;\n          } while (charVar != '\\0');\n          pcVar46 = (char *)((long)charVarPtr3 + loopIndex4 * 8 + -8);\n          tempVar7 = index - ((int)loopIndex4 + -1);\n          filePtr = (FILE *)(ulong)tempVar7;\n          if (_DAT_0010d65c != 0) {\n            charVarPtr3 = \"DhHUvVt\";\n            tempVar4 = 0;\n            while (index = getopt_long(filePtr,pcVar46,\"DhHUvVt\",&PTR_DAT_0010d300), index != -1)\n            {\n              if (index < 0x77) {\n                if (0x43 < index) {\n                  switch(index) {\n                  case 0x44:\n                    _DAT_0010d2d0 = 1;\n                    break;\n                  case 0x48:\n                  case 0x68:\n                    _DAT_0010d658 = 1;\n                    break;\n                  case 0x55:\n                    _DAT_0010d2d0 = 0;\n                    break;\n                  case 0x56:\n                  case 0x76:\n                    _DAT_0010d654 = 1;\n                    break;\n                  case 0x74:\n                    tempVar4 = tempVar1;\n                  }\n                }\n              }\n              else if (index == 0xc9) {\n                bfd_plugin_set_plugin(_optarg);\n              }\n            }\n            if ((int)tempVar7 < 2) {\nLAB_00107125:\n              charVarPtr2 = (char *)0x0;\n              print_archive_usage_0010394a();\n            }\n            else {\n              if (_DAT_0010d658 != 0) {\nLAB_0010711b:\n                print_archive_usage_0010394a();\n                goto LAB_00107125;\n              }\n              if (_DAT_0010d654 != 0) {\n                print_version_info_001075e0(\"ranlib\");\n                goto LAB_0010711b;\n              }\n              if (_DAT_0010d2d0 < 0) {\n                _DAT_0010d2d0 = 1;\n              }\n              filePtr4 = (FILE *)0x0;\n              charVarPtr3 = (char *)(long)_optind;\n              while( true ) {\n                if ((int)tempVar7 <= (int)charVarPtr3) goto LAB_00106f8b;\n                charVarPtr2 = *(char **)((int *)pcVar46 + (long)charVarPtr3 * 2);\n                if ((char)tempVar4 != '\\0') break;\n                tempVar1 = check_file_and_generate_listing_00107650();\n                charVarPtr3 = (char *)((long)(int *)charVarPtr3 + 1);\n                filePtr4 = (FILE *)(ulong)((uint)filePtr4 | tempVar1);\n              }\n            }\n            while (loopIndex3 = get_file_information_001052a0(charVarPtr2), loopIndex3 < 1) {\n              tempVar1 = 1;\nLAB_001071c4:\n              intPtr = (int *)charVarPtr3;\n              charVarPtr3 = (char *)((long)intPtr + 1);\n              filePtr4 = (FILE *)(ulong)((uint)filePtr4 | tempVar1);\n              if ((int)tempVar7 <= (int)charVarPtr3) {\nLAB_00106f8b:\n                    \n                xexit(filePtr4);\n              }\n              charVarPtr2 = *(char **)((char *)((long)pcVar46 + 0x83) + (long)intPtr * 8 + -0x7b);\n            }\n            index = open(charVarPtr2,2,0);\n            if (index < 0) {\n              bfd_set_error(1);\n              handle_error_and_exit_00107c10(charVarPtr2);\nLAB_0010737f:\n              handle_error_and_exit_00107c10(charVarPtr2);\nLAB_00107387:\n              print_error_message_00107c20(charVarPtr2);\n              index = bfd_get_error();\n              if (index == 0xd) {\n                print_matching_formats_00103bd1(CONCAT53(uStack_c5,\n                                      CONCAT12(uStack_c6,CONCAT11(undefinedVar[1],undefinedVar[0]))));\n              }\n              goto LAB_0010700f;\n            }\n            tempVar5 = (char *)bfd_fdopenr(charVarPtr2,0);\n            if ((FILE *)tempVar5 == (FILE *)0x0) goto LAB_0010737f;\n            charVar = bfd_check_format_matches(tempVar5,2,undefinedVar);\n            if (charVar == '\\0') goto LAB_00107387;\n            if ((*(byte *)((long)((long)tempVar5 + 0x48) + 1) & 8) != 0) {\n              if (_DAT_0010d2d0 != 0) {\n                uintPtr = (uint *)((long)((long)tempVar5 + 0x40) + 4);\n                *uintPtr = *uintPtr | 0x2000;\n              }\n              (**(code **)(*(char **)((long)tempVar5 + 8) + 0x1f0))(tempVar5);\n              charVar = bfd_close(tempVar5);\n              if (charVar != '\\0') {\n                tempVar1 = 0;\n                goto LAB_001071c4;\n              }\n              goto LAB_0010737f;\n            }\n            tempVar3 = dcgettext(0,\"%s: no archive map to update\",5);\n            handle_error_00107690(tempVar3,charVarPtr2);\nLAB_001073cc:\n            charVarPtr2 = (char *)lbasename(DAT_0010d660);\n            sizeVar1 = strlen(charVarPtr2);\n            if ((sizeVar1 < 6) ||\n               (index = filename_cmp(charVarPtr2 + (sizeVar1 - 6),\"ranlib\"), index != 0)) {\n              _DAT_0010d65c = 0;\n            }\n            else {\n              _DAT_0010d65c = 1;\n            }\n            goto LAB_001062d3;\n          }\n          ppuVar36 = &PTR_DAT_0010d300;\n          tempVar5 = \"hdmpqrtxl:coOVsSuvabiMNfPTDU\";\n          charVarPtr3 = (char *)&DAT_001096a0;\n          filePtr2 = (FILE *)tempVar5;\n          filePtr3 = filePtr;\n          if ((int)tempVar7 < 2) goto switchD_00107462_caseD_1;\n          tempVar8 = (FILE *)CONCAT71(tempVar8._1_7_,(char)tempVar1);\nLAB_001063a3:\n          filePtr2 = (FILE *)tempVar5;\n          if (**(char **)((long)pcVar46 + 8) != '-') {\n            undefinedVar[0] = 0x2d;\n            uStack_c6 = 0;\n            sizeVar1 = strlen(*(char **)((long)pcVar46 + 8));\n            index = (int)sizeVar1 + (int)filePtr;\n            filePtr4 = (FILE *)xmalloc((long)index * 8);\n            tempVar2 = *(undefined4 *)((long)pcVar46 + 4);\n            filePtr4->_flags = *(int *)pcVar46;\n            *(undefined4 *)&filePtr4->field_0x4 = tempVar2;\n            ppcVar31 = *(char ***)((long)pcVar46 + 8);\n            filePtr5 = (FILE *)((long)pcVar46 + 0x10);\n            charPtrPtr2 = ppcVar31;\n            if (*(char *)ppcVar31 == '\\0') {\n              ppcVar32 = &filePtr4->_IO_read_ptr;\n            }\n            else {\n              bytePtr4 = undefinedVar;\n              undefinedVar[1] = *(char *)ppcVar31;\n              charVarPtr2 = (char *)xstrdup();\n              ppcVar32 = &filePtr4->_IO_read_end;\n              filePtr4->_IO_read_ptr = charVarPtr2;\n              if (*(char *)((long)ppcVar31 + 1) != '\\0') {\n                undefinedVar[1] = *(char *)((long)ppcVar31 + 1);\n                charVarPtr2 = (char *)xstrdup(bytePtr4);\n                ppcVar32 = &filePtr4->_IO_read_base;\n                filePtr4->_IO_read_end = charVarPtr2;\n                if (*(char *)((long)ppcVar31 + 2) != '\\0') {\n                  undefinedVar[1] = *(char *)((long)ppcVar31 + 2);\n                  charVarPtr2 = (char *)xstrdup(bytePtr4);\n                  ppcVar32 = &filePtr4->_IO_write_base;\n                  filePtr4->_IO_read_base = charVarPtr2;\n                  if (*(char *)((long)ppcVar31 + 3) != '\\0') {\n                    ppcVar32 = &filePtr4->_IO_write_ptr;\n                    undefinedVar[1] = *(char *)((long)ppcVar31 + 3);\n                    charVarPtr2 = (char *)xstrdup(bytePtr4);\n                    filePtr4->_IO_write_base = charVarPtr2;\n                    charVar = *(char *)((long)ppcVar31 + 4);\n                    charPtrPtr2 = ppcVar32;\n                    if (charVar != '\\0') {\n                      charVarPtr2 = (char *)((long)ppcVar31 + 4);\n                      ppcVar31 = ppcVar32;\n                      do {\n                        ppcVar32 = ppcVar31 + 1;\n                        undefinedVar[1] = charVar;\n                        charVarPtr = (char *)xstrdup(bytePtr4);\n                        charVarPtr2 = charVarPtr2 + 1;\n                        *ppcVar31 = charVarPtr;\n                        charVar = *charVarPtr2;\n                        ppcVar31 = ppcVar32;\n                        charPtrPtr2 = ppcVar32;\n                      } while (charVar != '\\0');\n                    }\n                  }\n                }\n              }\n            }\n            loopIndex3 = (long)(int)filePtr;\n            intPtr = (int *)pcVar46 + loopIndex3 * 2;\n            if (filePtr5 < intPtr) {\n              ulongVar1 = loopIndex3 * 8 - 0x11;\n              if ((ulongVar1 < 0x18) || (ppcVar32 == (char **)((long)pcVar46 + 0x18))) {\n                *ppcVar32 = *(char **)((long)pcVar46 + 0x10);\n                if (((char **)((long)pcVar46 + 0x18) < intPtr) &&\n                   ((((ppcVar32[1] = *(char **)((long)pcVar46 + 0x18),\n                      (char **)((long)pcVar46 + 0x20) < intPtr &&\n                      (ppcVar32[2] = *(char **)((long)pcVar46 + 0x20),\n                      (char **)((long)pcVar46 + 0x28) < intPtr)) &&\n                     (ppcVar32[3] = *(char **)((long)pcVar46 + 0x28),\n                     (char **)((long)pcVar46 + 0x30) < intPtr)) &&\n                    (ppcVar32[4] = *(char **)((long)pcVar46 + 0x30),\n                    (char **)((long)pcVar46 + 0x38) < intPtr)))) {\n                  ppcVar32[5] = *(char **)((long)pcVar46 + 0x38);\n                  charPtrPtr = ppcVar32 + 6;\n                  for (ppcVar31 = (char **)((long)pcVar46 + 0x40); ppcVar31 < intPtr;\n                      ppcVar31 = ppcVar31 + (ulong)byteVar3 * -2 + 1) {\n                    *charPtrPtr = *ppcVar31;\n                    charPtrPtr = charPtrPtr + (ulong)byteVar3 * -2 + 1;\n                  }\n                }\n              }\n              else {\n                tempVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x10) + 4);\n                uintVar1 = *(undefined4 *)((long)pcVar46 + 0x18);\n                uintVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x18) + 4);\n                ulongVar2 = (ulongVar1 >> 3) + 1;\n                *(undefined4 *)ppcVar32 = *(undefined4 *)((long)pcVar46 + 0x10);\n                *(undefined4 *)((long)ppcVar32 + 4) = tempVar2;\n                *(undefined4 *)(ppcVar32 + 1) = uintVar1;\n                *(undefined4 *)((long)ppcVar32 + 0xc) = uintVar2;\n                tempVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x20) + 4);\n                uintVar1 = *(undefined4 *)((long)pcVar46 + 0x28);\n                uintVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x28) + 4);\n                ulongVar1 = ulongVar2 >> 1;\n                *(undefined4 *)(ppcVar32 + 2) = *(undefined4 *)((long)pcVar46 + 0x20);\n                *(undefined4 *)((long)ppcVar32 + 0x14) = tempVar2;\n                *(undefined4 *)(ppcVar32 + 3) = uintVar1;\n                *(undefined4 *)((long)ppcVar32 + 0x1c) = uintVar2;\n                if (ulongVar1 != 2) {\n                  tempVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x30) + 4);\n                  uintVar1 = *(undefined4 *)((long)pcVar46 + 0x38);\n                  uintVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x38) + 4);\n                  *(undefined4 *)(ppcVar32 + 4) = *(undefined4 *)((long)pcVar46 + 0x30);\n                  *(undefined4 *)((long)ppcVar32 + 0x24) = tempVar2;\n                  *(undefined4 *)(ppcVar32 + 5) = uintVar1;\n                  *(undefined4 *)((long)ppcVar32 + 0x2c) = uintVar2;\n                  if (ulongVar1 != 3) {\n                    ulongVar3 = 3;\n                    do {\n                      ulongVar4 = ulongVar3 + 1;\n                      charVarPtr2 = (char *)((long)pcVar46 + 0x83) + ulongVar3 * 0x10 + -0x73;\n                      tempVar2 = *(undefined4 *)(charVarPtr2 + 4);\n                      uintVar1 = *(undefined4 *)(charVarPtr2 + 8);\n                      uintVar2 = *(undefined4 *)(charVarPtr2 + 0xc);\n                      ppcVar31 = ppcVar32 + ulongVar3 * 2;\n                      *(undefined4 *)ppcVar31 = *(undefined4 *)charVarPtr2;\n                      *(undefined4 *)((long)ppcVar31 + 4) = tempVar2;\n                      *(undefined4 *)(ppcVar31 + 1) = uintVar1;\n                      *(undefined4 *)((long)ppcVar31 + 0xc) = uintVar2;\n                      ulongVar3 = ulongVar4;\n                    } while (ulongVar4 != ulongVar1);\n                  }\n                }\n                if ((ulongVar2 & 1) != 0) {\n                  ppcVar32[ulongVar2 & 0xfffffffffffffffe] =\n                       *(char **)((long)filePtr5 + (ulongVar2 & 0xfffffffffffffffe) * 8);\n                }\n              }\n              ppcVar32 = ppcVar32 + loopIndex3 + -2;\n            }\n            filePtr = (FILE *)(ulong)(index - 1);\n            *ppcVar32 = (char *)0x0;\n            pcVar46 = (char *)filePtr4;\n          }\nLAB_001065a2:\n          while( true ) {\n            tempVar1 = (uint)filePtr4;\n            tempVar7 = getopt_long((ulong)filePtr & 0xffffffff,pcVar46,filePtr2,ppuVar36,0);\n            tempVar5 = (char *)filePtr2;\n            if (tempVar7 == 0xffffffff) break;\n            if (((tempVar7 - 100 < 0x15) && ((0x117201UL >> ((ulong)(tempVar7 - 100) & 0x3f) & 1) != 0))\n               && (DAT_0010d64c != 0)) goto LAB_001067f7;\n            filePtr3 = (FILE *)pcVar46;\n            if (tempVar7 < 0xcc) {\n                    /* WARNING: Could not recover jumptable at 0x001065eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              (*(code *)((long)(int *)charVarPtr3 + (long)((int *)charVarPtr3)[tempVar7]))();\n              return;\n            }\nswitchD_00107462_caseD_1:\n            display_usage_message_0010342d(0);\n            pcVar46 = (char *)filePtr3;\nswitchD_00107462_caseD_68:\n            _DAT_0010d658 = 1;\n          }\nLAB_00106680:\n          tempVar7 = DAT_0010d64c;\n          filePtr2 = (FILE *)tempVar5;\n          if (DAT_0010d64c == 0) {\n            if (((DAT_0010d648 == 1) || (_DAT_0010d650 != 0)) ||\n               (((int)filePtr <= _optind || (_optind < 1)))) {\n              tempVar7 = 0;\n              goto LAB_001066aa;\n            }\n            pcVar46 = (char *)((long)pcVar46 + (long)_optind * 8 + -8);\n            tempVar1 = (int)filePtr - (_optind + -1);\n            filePtr = (FILE *)(ulong)tempVar1;\n            _optind = 0;\n            if (1 < (int)tempVar1) goto LAB_001063a3;\n            goto LAB_001065a2;\n          }\nLAB_001066aa:\n          filePtr4 = (FILE *)((ulong)tempVar8 & 0xff);\n          tempVar1 = (uint)filePtr4;\n          ppuVar36 = (undefined **)((int *)pcVar46 + (long)_optind * 2);\n          if (_DAT_0010d658 == 0) {\n            if (_DAT_0010d654 != 0) {\n              print_version_info_001075e0(&DAT_0010807c);\n              goto LAB_00107591;\n            }\n            if (_DAT_0010d650 == 0) {\n              filePtr3 = (FILE *)pcVar46;\n              if (*ppuVar36 == (undefined *)0x0) goto switchD_00107462_caseD_1;\n              if (DAT_0010d64c == 7) {\n                if (DAT_0010d648 == 0) {\n                  if (tempVar7 == 3) goto LAB_00106abc;\n                  if (tempVar7 != 0) goto LAB_00106700;\nLAB_00106eff:\n                  charVarPtr2 = \"no operation specified\";\n                  goto LAB_00106803;\n                }\n                DAT_0010d64c = 2;\n                if (_DAT_0010d644 != 0) goto LAB_0010704f;\n              }\n              else if ((tempVar7 == 3) || (tempVar7 == 0)) {\n                if (DAT_0010d648 == 1) {\n                  tempVar2 = check_file_and_generate_listing_00107650();\n                    \n                  xexit(tempVar2);\n                }\nLAB_00106abc:\n                if (tempVar7 == 0) goto LAB_00106eff;\n                if (_DAT_0010d644 != 0) {\nLAB_00106ad1:\n                  charVarPtr2 = \"`u\\' is only meaningful with the `r\\' option.\";\n                  goto LAB_00106803;\n                }\n              }\n              else {\nLAB_00106700:\n                if (_DAT_0010d644 != 0) goto LAB_00107548;\n              }\nLAB_0010670d:\n              if (_DAT_0010d2d0 < 0) {\n                _DAT_0010d2d0 = 1;\n              }\nLAB_00106720:\n              tempVar5 = (char *)0x0;\n              if (DAT_0010d640 != 0) {\n                DAT_0010d638 = (long)*ppuVar36;\n                tempVar5 = (char *)0x1;\n                charVarPtr2 = \"missing position arg.\";\n                if (DAT_0010d638 == 0) goto LAB_00106803;\n              }\n              if (DAT_0010d634 != '\\0') {\n                charVarPtr2 = \"`N\\' is only meaningful with the `x\\' and `d\\' options.\";\n                if ((DAT_0010d64c & 0xfffffffb) == 1) {\n                  index = (int)tempVar5;\n                  if (*(char **)((long)ppuVar36 + (long)index * 2 * 4) == (char *)0x0) {\n                    tempVar3 = dcgettext(0,\"`N\\' missing value.\",5);\n                    handle_error_00107690(tempVar3);\n                    tempVar7 = extraout_EDX;\nLAB_00107548:\n                    if (tempVar7 == 2) {\nLAB_0010704f:\n                      charVarPtr2 = \"`u\\' is not meaningful with the `D\\' option.\";\n                      if (_DAT_0010d2d0 < 1) goto code_r0x00107068;\n                      goto LAB_00106803;\n                    }\n                    goto LAB_00106ad1;\n                  }\n                  tempVar5 = (char *)(ulong)(index + 1);\n                  loopIndex3 = strtol(*(char **)((long)ppuVar36 + (long)index * 2 * 4),(char **)0x0,10)\n                  ;\n                  charVarPtr2 = \"Value for `N\\' must be positive.\";\n                  _DAT_0010d630 = (int)loopIndex3;\n                  if (0 < _DAT_0010d630) goto LAB_0010673c;\n                }\n                goto LAB_00106803;\n              }\nLAB_0010673c:\n              loopIndex3 = (long)(int)tempVar5;\n              filePtr2 = (FILE *)tempVar5;\n              if (*(long *)(int *)((long)ppuVar36 + loopIndex3 * 2 * 4) == 0)\n              goto switchD_00107462_caseD_1;\n              filePtr2 = (FILE *)((long)ppuVar36 + (loopIndex3 + 1) * 2 * 4);\n              if (*(FILE **)filePtr2 == (FILE *)0x0) {\n                charVarPtr3 = (char *)0x0;\n                filePtr2 = (FILE *)0x0;\n              }\n              else if (*(long *)((long)ppuVar36 + (loopIndex3 + 2) * 2 * 4) == 0) {\n                charVarPtr3 = (char *)0x1;\n              }\n              else if (*(long *)((long)ppuVar36 + (loopIndex3 + 3) * 2 * 4) == 0) {\n                charVarPtr3 = (char *)0x2;\n              }\n              else if (*(long *)((long)ppuVar36 + (loopIndex3 + 4) * 2 * 4) == 0) {\n                charVarPtr3 = (char *)0x3;\n              }\n              else if (*(long *)((long)ppuVar36 + (loopIndex3 + 5) * 2 * 4) == 0) {\n                charVarPtr3 = (char *)0x4;\n              }\n              else {\n                filePtr = (FILE *)0x5;\n                do {\n                  charVarPtr3 = (char *)filePtr;\n                  filePtr = (FILE *)((long)(int *)charVarPtr3 + 1);\n                } while (*(long *)((int *)((long)ppuVar36 + loopIndex3 * 2 * 4) + (long)filePtr * 2) !=\n                         0);\n              }\n              undefined8Ptr2 = (undefined8 *)convert_and_open_library_00105300();\n              filePtr = filePtr2;\n              if (DAT_0010d64c == 5) {\n                charVarPtr2 = \"`x\\' cannot be used on thin archives.\";\n                if ((*(byte *)((long)undefined8Ptr2 + 0x49) & 0x10) == 0) {\n                  tempVar5 = (char *)filePtr2;\n                  if (DAT_0010d628 != (char *)0x0) goto LAB_00106d5c;\nswitchD_00106ed8_caseD_5:\n                  extract_entries_from_archive_00105480(undefined8Ptr2,extract_and_write_archive_00107740,tempVar5,(ulong)charVarPtr3 & 0xffffffff);\n                  goto LAB_0010696c;\n                }\n                goto LAB_00106803;\n              }\n              if (DAT_0010d628 != (char *)0x0) {\nLAB_00106d5c:\n                sizeVar1 = strlen(DAT_0010d628);\n                pcVar46 = \"__.LIBDEP\";\n                tempVar5 = (char *)(sizeVar1 + 1);\n                DAT_0010d620 = bfd_create(\"__.LIBDEP\",undefined8Ptr2);\n                if (DAT_0010d620 == 0) {\n                  charVarPtr2 = \"Cannot create libdeps record.\";\n                }\n                else {\n                  loopIndex3 = bfd_find_target(\"binary\",DAT_0010d620);\n                  charVarPtr2 = \"Cannot set libdeps record type to binary.\";\n                  if (loopIndex3 != 0) {\n                    charVar = bfd_set_format(DAT_0010d620,1,5);\n                    charVarPtr2 = \"Cannot set libdeps object format.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    charVar = bfd_make_writable(DAT_0010d620,\"Cannot set libdeps object format.\",5);\n                    charVarPtr2 = \"Cannot make libdeps object writable.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    filePtr3 = (FILE *)bfd_bwrite(DAT_0010d628,tempVar5,DAT_0010d620);\n                    charVarPtr2 = \"Cannot write libdeps record.\";\n                    if (filePtr3 != (FILE *)tempVar5) goto LAB_00106803;\n                    charVar = bfd_make_readable(DAT_0010d620,\"Cannot write libdeps record.\",5);\n                    charVarPtr2 = \"Cannot make libdeps object readable.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    loopIndex3 = bfd_find_target(\"plugin\",DAT_0010d620,5);\n                    charVarPtr2 = \"Cannot reset libdeps record type.\";\n                    if (loopIndex3 == 0) goto LAB_00106803;\n                    index = (int)charVarPtr3;\n                    tempVar8 = (FILE *)((long)(index + 2) * 8);\n                    tempVar5 = (char *)xmalloc(tempVar8,\"Cannot reset libdeps record type.\");\n                    if (index == 0) {\n                      loopIndex3 = 0;\n                    }\n                    else {\n                      tempVar2 = *(undefined4 *)&filePtr2->field_0x4;\n                      *(int *)tempVar5 = filePtr2->_flags;\n                      *(undefined4 *)((long)tempVar5 + 4) = tempVar2;\n                      loopIndex3 = 8;\n                      ppcVar31 = (char **)((long)tempVar5 + 8);\n                      for (charVarPtr3 = tempVar8[-1]._unused2 + 4; charVarPtr3 != (char *)0x0;\n                          charVarPtr3 = charVarPtr3 + -1) {\n                        *(undefined *)ppcVar31 = *(undefined *)&filePtr2->_flags;\n                        filePtr2 = (FILE *)((long)filePtr2 + (ulong)byteVar3 * -2 + 1);\n                        ppcVar31 = (char **)((long)ppcVar31 + (ulong)byteVar3 * -2 + 1);\n                      }\n                    }\n                    *(char **)((long)(char **)tempVar5 + loopIndex3) = \"__.LIBDEP\";\n                    charVarPtr3 = (char *)(ulong)(index + 1);\n                    *(undefined8 *)\n                     (((FILE *)((long)tempVar5 + -0xd8))->_unused2 + 0xc + (long)tempVar8) = 0;\n                    switch(DAT_0010d64c) {\n                    case 1:\n                      goto switchD_00106ed8_caseD_1;\n                    case 2:\n                    case 7:\n                      break;\n                    case 3:\n                      goto switchD_00106ed8_caseD_3;\n                    case 4:\n                      goto switchD_00106ed8_caseD_4;\n                    case 5:\n                      goto switchD_00106ed8_caseD_5;\n                    case 6:\n                      filePtr2 = (FILE *)tempVar5;\n                      if (_DAT_0010d610 == 0) goto LAB_00106afb;\n                      break;\n                    default:\n                      goto switchD_001067e8_caseD_5;\n                    }\n                    goto switchD_00106ed8_caseD_2;\n                  }\n                }\n                goto LAB_00106803;\n              }\n              switch(DAT_0010d64c) {\n              case 1:\n                tempVar5 = (char *)filePtr2;\n                if (filePtr2 == (FILE *)0x0) break;\nswitchD_00106ed8_caseD_1:\n                filePtr = (FILE *)0x0;\n                goto LAB_00106b89;\n              case 2:\n              case 7:\nswitchD_001067e8_caseD_2:\n                tempVar5 = (char *)filePtr2;\n                if ((filePtr2 != (FILE *)0x0) || (0 < DAT_0010d648)) {\nswitchD_00106ed8_caseD_2:\n                  process_files_00105570(undefined8Ptr2,tempVar5,DAT_0010d64c == 7);\n                  goto LAB_0010696c;\n                }\n                break;\n              case 3:\n                tempVar5 = (char *)filePtr2;\nswitchD_00106ed8_caseD_3:\n                extract_entries_from_archive_00105480(undefined8Ptr2,print_file_info_00107890,tempVar5,(ulong)charVarPtr3 & 0xffffffff);\n                goto LAB_0010696c;\n              case 4:\n                tempVar5 = (char *)filePtr2;\nswitchD_00106ed8_caseD_4:\n                extract_entries_from_archive_00105480(undefined8Ptr2,extract_and_print_archive_00103a78,tempVar5,(ulong)charVarPtr3 & 0xffffffff);\n                goto LAB_0010696c;\n              default:\nswitchD_001067e8_caseD_5:\n                charVarPtr2 = \"internal error -- this option not implemented\";\n                goto LAB_00106803;\n              case 6:\n                if (_DAT_0010d610 != 0) goto switchD_001067e8_caseD_2;\n                if (filePtr2 == (FILE *)0x0) break;\nLAB_00106afb:\n                filePtr = (FILE *)(undefined8Ptr2 + 0x1e);\n                do {\n                  filePtr4 = filePtr;\n                  if (*(FILE **)filePtr2 == (FILE *)0x0) {\nLAB_00106b9f:\n                    generate_archive_listing_001058b0(undefined8Ptr2);\n                    goto LAB_0010696c;\n                  }\n                  while( true ) {\n                    longPtr2 = *(long **)filePtr4;\n                    pcVar46 = *(char **)filePtr2;\n                    if (longPtr2 == (long *)0x0) {\n                      tempVar3 = *undefined8Ptr2;\n                      uVar30 = dcgettext(0,\"no entry %s in archive %s!\",5);\n                      handle_error_00107690(uVar30,pcVar46,tempVar3);\n                      charVarPtr3 = (char *)0x0;\n                      goto LAB_00107293;\n                    }\n                    loopIndex3 = *longPtr2;\n                    tempVar3 = extract_sub_string_00105830(pcVar46,undefined8Ptr2);\n                    index = filename_cmp(tempVar3,loopIndex3);\n                    if (index == 0) break;\n                    filePtr4 = (FILE *)(*(long **)filePtr4 + 0x1e);\n                  }\n                  *(long **)filePtr4 = (long *)longPtr2[0x1e];\n                  pplVar29 = (long **)find_matching_entry_00105870(filePtr,3,0);\n                  boolVar3 = DAT_0010d60c != 0;\n                  longPtr = *pplVar29;\n                  *pplVar29 = longPtr2;\n                  longPtr2[0x1e] = (long)longPtr;\n                  if (boolVar3) {\n                    printf(\"m - %s\\n\",*(FILE **)filePtr2);\n                  }\n                  filePtr2 = (FILE *)&filePtr2->_IO_read_ptr;\n                } while( true );\n              }\n              goto LAB_00106d4e;\n            }\n            if (-1 < _DAT_0010d2d0) goto LAB_0010755f;\n          }\n          else {\nLAB_00107591:\n            display_usage_message_0010342d(1);\n          }\n          _DAT_0010d2d0 = 1;\nLAB_0010755f:\n          index = fileno(_stdin);\n          _DAT_0010d608 = isatty(index);\n          process_script_00103e95();\nLAB_0010696c:\n                    \n          xexit(0);\n        }\n        tempVar2 = bfd_get_error();\n        filePtr2 = (FILE *)bfd_errmsg(tempVar2);\n        tempVar3 = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n        index = handle_error_00107690(tempVar3,\"x86_64-pc-linux-gnu\",filePtr2);\nLAB_0010751b:\n        if (DAT_0010d64c == 0) {\nLAB_00107447:\n          ppuVar36 = (undefined **)charVarPtr2;\n          filePtr3 = (FILE *)pcVar46;\n          switch(index) {\n          case 0:\n            goto switchD_00107462_caseD_0;\n          default:\n            goto switchD_00107462_caseD_1;\n          case 0x44:\n            _DAT_0010d2d0 = 1;\n            goto LAB_001065a2;\n          case 0x4d:\n            _DAT_0010d650 = 1;\n            goto LAB_001065a2;\n          case 0x4e:\n            DAT_0010d634 = '\\x01';\n            goto LAB_001065a2;\n          case 0x4f:\n            _DAT_0010d5fc = 1;\n            goto LAB_001065a2;\n          case 0x50:\n            DAT_0010d5f9 = 1;\n            goto LAB_001065a2;\n          case 0x53:\n            DAT_0010d648 = -1;\n            goto LAB_001065a2;\n          case 0x54:\n            DAT_0010d5f8 = 1;\n            goto LAB_001065a2;\n          case 0x55:\n            _DAT_0010d2d0 = 0;\n            goto LAB_001065a2;\n          case 0x56:\n            _DAT_0010d654 = 1;\n            goto LAB_001065a2;\n          case 0x61:\n            DAT_0010d640 = 2;\n            goto LAB_001065a2;\n          case 0x62:\n          case 0x69:\n            DAT_0010d640 = 1;\n            goto LAB_001065a2;\n          case 99:\n            _DAT_0010d610 = 1;\n            goto LAB_001065a2;\n          case 100:\n            DAT_0010d64c = 1;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x66:\n            DAT_0010d5fa = 1;\n            goto LAB_001065a2;\n          case 0x68:\n            goto switchD_00107462_caseD_68;\n          case 0x6c:\n            if (DAT_0010d628 == (char *)0x0) {\n              DAT_0010d628 = _optarg;\n              goto LAB_001065a2;\n            }\nLAB_00107293:\n            tempVar1 = (uint)filePtr4;\n            charVarPtr2 = \"libdeps specified more than once\";\n            tempVar5 = (char *)filePtr2;\n            break;\n          case 0x6d:\n            DAT_0010d64c = 6;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x6f:\n            _DAT_0010d600 = 1;\n            goto LAB_001065a2;\n          case 0x70:\n            DAT_0010d64c = 4;\n            goto LAB_001065a2;\n          case 0x71:\n            DAT_0010d64c = 7;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x72:\n            DAT_0010d64c = 2;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x73:\n            DAT_0010d648 = 1;\n            goto LAB_001065a2;\n          case 0x74:\n            DAT_0010d64c = 3;\n            goto LAB_001065a2;\n          case 0x75:\n            _DAT_0010d644 = 1;\n            goto LAB_001065a2;\n          case 0x76:\n            DAT_0010d60c = 1;\n            goto LAB_001065a2;\n          case 0x78:\n            DAT_0010d64c = 5;\n            goto LAB_001065a2;\n          case 0xc9:\n            bfd_plugin_set_plugin(_optarg);\n            goto LAB_001065a2;\n          case 0xca:\n            DAT_0010d5f0 = _optarg;\n            goto LAB_001065a2;\n          case 0xcb:\n            DAT_0010d5e8 = _optarg;\n            goto LAB_001065a2;\n          }\n          goto LAB_00106803;\n        }\nLAB_001067f7:\n        charVarPtr2 = \"two different operation options specified\";\n        tempVar5 = (char *)filePtr2;\nLAB_00106803:\n        tempVar3 = dcgettext(0,charVarPtr2,5);\n        handle_error_00107690(tempVar3);\nLAB_00106814:\n        index = (int)pcVar46;\n        filePtr3 = (FILE *)xmalloc(8);\n        *(long **)filePtr3 = (long *)0x0;\n        if ((FILE *)charVarPtr3 == argv) {\nLAB_00106834:\n          if (*(long **)charVarPtr3 == (long *)0x0) {\n            index = 0;\n          }\n          else {\n            loopIndex3 = 1;\n            do {\n              index = (int)loopIndex3;\n              loopIndex4 = loopIndex3 * 2;\n              loopIndex3 = loopIndex3 + 1;\n            } while (*(long *)((int *)charVarPtr3 + loopIndex4) != 0);\n          }\n          filePtr2 = (FILE *)xmalloc((long)(index + 1) << 3);\n          longPtr2 = *(long **)charVarPtr3;\n          loopIndex3 = 0;\n          while (longPtr2 != (long *)0x0) {\n            tempVar3 = xstrdup();\n            *(undefined8 *)((long)&filePtr2->_flags + loopIndex3) = tempVar3;\n            longPtr2 = *(long **)((char *)((long)charVarPtr3 + 0x83) + loopIndex3 + -0x7b);\n            loopIndex3 = loopIndex3 + 8;\n          }\n          *(undefined8 *)((long)&filePtr2->_flags + loopIndex3) = 0;\nLAB_0010610a:\n          index = (int)pcVar46;\n          charVarPtr3 = (char *)filePtr2;\n          if (*(long **)filePtr3 == (long *)0x0) goto LAB_00106a80;\n          loopIndex3 = 0;\n          do {\n            loopIndex1 = loopIndex3 + 1;\n            loopIndex4 = loopIndex3 * 8;\n            loopIndex3 = loopIndex1;\n          } while (*(long *)(filePtr3->_shortbuf + loopIndex4 + -0x7b) != 0);\n          sizeVar3 = loopIndex1 * 8;\n        }\n        else {\nLAB_00106a80:\n          loopIndex1 = 0;\n          sizeVar3 = 0;\n        }\n        loopIndex3 = (long)tempVar5 * 2;\n        tempVar5 = (char *)((long)(char **)tempVar5 + loopIndex1);\n        free(*(void **)((int *)charVarPtr3 + loopIndex3));\n        filePtr2 = (FILE *)xrealloc(charVarPtr3,(loopIndex1 + 1 + (long)index) * 8);\n        tempVar7 = index + -1 + (int)loopIndex1;\n        pcVar46 = (char *)(ulong)tempVar7;\n        memmove(&filePtr2->_flags + (long)tempVar5 * 2,\n                (void *)((long)&filePtr2->_IO_read_ptr + (long)tempVar8),\n                (long)(int)(index - tempVar1) << 3);\n        memcpy((void *)((long)&tempVar8->_flags + (long)&filePtr2->_flags),filePtr3,sizeVar3);\n        free(filePtr3);\n        free(bytePtr4);\n        fclose(filePtr);\n        tempVar1 = (int)filePtr5 + 1;\n        filePtr4 = tempVar8;\n        charVarPtr3 = (char *)filePtr2;\n        tempVar8 = filePtr3;\n        if ((int)tempVar1 < (int)tempVar7) goto LAB_001061ce;\n      } while( true );\n    }\n    tempVar1 = tempVar1 + 1;\n    filePtr5 = filePtr4;\nLAB_001061ce:\n    filePtr4 = (FILE *)(ulong)tempVar1;\n  } while( true );\nswitchD_00107462_caseD_0:\n  index = getopt_long((ulong)filePtr & 0xffffffff,pcVar46,filePtr2,\"x86_64-pc-linux-gnu\");\n  tempVar5 = (char *)filePtr2;\n  if (index == -1) goto LAB_00106680;\n  if ((0x14 < index - 100U) || ((0x117201UL >> ((byte)(index - 100U) & 0x3f) & 1) == 0))\n  goto LAB_00107447;\n  goto LAB_0010751b;\ncode_r0x00107068:\n  if (_DAT_0010d2d0 != 0) goto code_r0x0010706e;\n  goto LAB_00106720;\ncode_r0x0010706e:\n  tempVar3 = dcgettext(0,\"`u\\' modifier ignored since `D\\' is the default (see `U\\')\",5);\n  print_error_message_00107920(tempVar3);\n  goto LAB_0010670d;\nLAB_00106b89:\n  if (*(FILE **)tempVar5 == (FILE *)0x0) {\n    if ((char)filePtr != '\\0') goto LAB_00106b9f;\nLAB_00106d4e:\n    DAT_0010d618 = 0;\n    goto LAB_0010696c;\n  }\n  index2 = 0;\n  index = strcmp((char *)*(FILE **)tempVar5,\"__.SYMDEF\");\n  undefined8Ptr = undefined8Ptr2;\n  if (index == 0) {\n    *(byte *)((long)undefined8Ptr2 + 0x49) = *(byte *)((long)undefined8Ptr2 + 0x49) & 0xf7;\n    DAT_0010d648 = -1;\n  }\n  else {\n    while( true ) {\n      longPtr2 = undefined8Ptr + 0x1e;\n      if ((undefined8 *)*longPtr2 == (undefined8 *)0x0) break;\n      tempVar3 = *(undefined8 *)*longPtr2;\n      uVar30 = extract_sub_string_00105830(*(FILE **)tempVar5,undefined8Ptr2);\n      index = filename_cmp(uVar30,tempVar3);\n      if ((index == 0) &&\n         ((DAT_0010d634 == '\\0' || (index2 = index2 + 1, index2 == _DAT_0010d630)))) {\n        if (DAT_0010d60c != 0) {\n          printf(\"d - %s\\n\",*(FILE **)tempVar5);\n        }\n        *longPtr2 = *(long *)(*longPtr2 + 0xf0);\n        filePtr = filePtr4;\n        goto LAB_00106d38;\n      }\n      undefined8Ptr = (undefined8 *)*longPtr2;\n    }\n    if (DAT_0010d60c != 0) {\n      filePtr2 = *(FILE **)tempVar5;\n      pcVar46 = (char *)dcgettext(0,\"No member named `%s\\'\\n\",5);\n      printf(pcVar46,filePtr2);\n    }\n  }\nLAB_00106d38:\n  tempVar5 = (char *)((long)tempVar5 + 8);\n  goto LAB_00106b89;\n}\n\n",
            "called": [
                "bfd_bwrite",
                "strtol",
                "bfd_init",
                "isatty",
                "FUN_00107640",
                "FUN_001075e0",
                "bindtextdomain",
                "FUN_00103a78",
                "bfd_find_target",
                "memcpy",
                "fread",
                "FUN_00107730",
                "FUN_00105570",
                "FUN_00107c20",
                "bfd_plugin_set_plugin",
                "FUN_001052a0",
                "bfd_plugin_set_program_name",
                "open",
                "xrealloc",
                "bfd_create",
                "FUN_00107650",
                "FUN_00107740",
                "setlocale",
                "bfd_set_format",
                "xexit",
                "bfd_make_writable",
                "strcmp",
                "stat",
                "fseek",
                "bfd_fdopenr",
                "xmalloc",
                "lbasename",
                "bfd_set_error_program_name",
                "fprintf",
                "getopt_long",
                "xmalloc_set_program_name",
                "FUN_00105870",
                "FUN_00105300",
                "printf",
                "FUN_00105830",
                "dcgettext",
                "FUN_00107cc0",
                "bfd_set_error",
                "memmove",
                "fclose",
                "strlen",
                "bfd_close",
                "free",
                "bfd_set_default_target",
                "bfd_check_format_matches",
                "filename_cmp",
                "xstrdup",
                "ftell",
                "FUN_00105480",
                "FUN_0010394a",
                "FUN_00107920",
                "bfd_errmsg",
                "FUN_00107c10",
                "fileno",
                "FUN_00103e95",
                "FUN_00107690",
                "fopen",
                "ferror",
                "FUN_001058b0",
                "FUN_00107890",
                "FUN_0010342d",
                "bfd_get_error",
                "textdomain",
                "bfd_make_readable",
                "malloc",
                "FUN_00103bd1"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105db0",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "parse_command_line_00105db0"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "FUN_00103bd1": {
            "renaming": {
                "FUN_00103bd1": "print_matching_formats_00103bd1",
                "param_1": "formats",
                "__format": "formatString",
                "plVar2": "currentFormat",
                "uVar1": "globalVariable"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103bd1(long *formats)\n\n{\n  undefined8 globalVariable;\n  char *formatString;\n  long *currentFormat;\n  \n  fflush(_stdout);\n  globalVariable = DAT_0010d660;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,formatString,globalVariable);\n  for (currentFormat = formats; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(formats);\n  fputc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "free",
                "fflush",
                "dcgettext",
                "fputc",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bd1",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103bd1"
        },
        "strcmp": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "strcmp"
        },
        "FUN_00107c10": {
            "renaming": {
                "FUN_00107c10": "handle_error_and_exit_00107c10",
                "print_error_message_00107c20": "display_error_message",
                "xexit": "exit_program"
            },
            "code": "\nvoid handle_error_and_exit_00107c10(void)\n\n{\n  display_error_message();\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_00107c20",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c10",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_001058b0",
                "FUN_001028ed",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "handle_error_and_exit_00107c10"
        },
        "read": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "read"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107da8",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "FUN_00102710": {
            "renaming": {
                "FUN_00102710": "read_and_convert_library_00102710",
                "puVar8": "output_library",
                "unaff_RBP": "backup_library",
                "in_stack_00000008": "matching_format",
                "plVar1": "file_pointer",
                "lVar5": "archived_file",
                "cVar2": "format_check_result",
                "bVar3": "convert_to_thin",
                "iVar4": "error_code",
                "uVar6": "error_message",
                "uVar7": "library_name"
            },
            "code": "\n\n\nundefined8 * read_and_convert_library_00102710(void)\n\n{\n  long *file_pointer;\n  char format_check_result;\n  byte convert_to_thin;\n  int error_code;\n  long archived_file;\n  undefined8 error_message;\n  undefined8 library_name;\n  undefined8 *output_library;\n  undefined8 backup_library;\n  undefined8 matching_format;\n  \n  archived_file = bfd_openr();\n  if (archived_file != 0) {\n    format_check_result = bfd_check_format(archived_file,1);\n    if (format_check_result != '\\0') {\n      DAT_0010d5f0 = **(undefined8 **)(archived_file + 8);\n    }\n    bfd_close(archived_file);\n  }\n  output_library = (undefined8 *)bfd_openw();\n  if (((output_library != (undefined8 *)0x0) && (format_check_result = bfd_set_format(output_library,2), format_check_result != '\\0')) &&\n     (format_check_result = bfd_close(output_library), format_check_result != '\\0')) {\n    if (_DAT_0010d610 == 0) goto LAB_00102826;\n    goto LAB_001053b7;\n  }\n  handle_error_and_exit_00107c10();\n  do {\n    convert_to_thin = *(byte *)((long)output_library + 0x49) >> 4 & 1;\n    if (DAT_0010d5f8 == '\\0') {\n      if (convert_to_thin != 0) {\n        library_name = *output_library;\n        error_message = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        handle_error_00107690(error_message,library_name);\n        goto LAB_00102812;\n      }\n    }\n    else if (convert_to_thin == 0) {\n      library_name = *output_library;\n      error_message = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      handle_error_00107690(error_message,library_name);\nLAB_001027cb:\n      print_error_message_00107c20();\n      error_code = bfd_get_error();\n      if (error_code == 0xd) {\nLAB_00102812:\n        print_matching_formats_00103bd1(matching_format);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      file_pointer = output_library + 0x1e;\n      for (archived_file = bfd_openr_next_archived_file(output_library,0); archived_file != 0;\n          archived_file = bfd_openr_next_archived_file(output_library,archived_file)) {\n        *file_pointer = archived_file;\n        file_pointer = (long *)(archived_file + 0xf0);\n      }\n      *file_pointer = 0;\n      error_code = bfd_get_error();\n      if (error_code == 9) {\n        return output_library;\n      }\n      do {\n        handle_error_and_exit_00107c10();\nLAB_00102826:\n        library_name = dcgettext(0,\"creating %s\",5);\n        print_error_message_00107920(library_name);\nLAB_001053b7:\n        DAT_0010d618 = backup_library;\n        output_library = (undefined8 *)bfd_openr();\n      } while (output_library == (undefined8 *)0x0);\n      format_check_result = bfd_check_format_matches(output_library,2,&stack0x00000008);\n      if (format_check_result == '\\0') goto LAB_001027cb;\n    } while (((DAT_0010d64c != 2) && (DAT_0010d64c != 7)) ||\n            (archived_file = bfd_openr_next_archived_file(output_library,0), archived_file == 0));\n  } while( true );\n}\n\n",
            "called": [
                "bfd_check_format",
                "bfd_openr",
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102710",
            "calling": [
                "FUN_00105300"
            ],
            "imported": false,
            "current_name": "read_and_convert_library_00102710"
        },
        "FUN_00103e95": {
            "renaming": {
                "FUN_00103e95": "process_script_00103e95",
                "pplVar1": "doublePointer1",
                "cVar2": "charVariable",
                "ppFVar3": "doublePointer2",
                "pFVar4": "filePointer",
                "plVar5": "pointerVariable",
                "uVar6": "uVariable",
                "pbVar7": "bytePointer",
                "iVar8": "intVariable1",
                "pcVar10": "charPointer1",
                "uVar11": "uVariable2",
                "iVar9": "intVariable2",
                "plVar12": "pointerVariable2",
                "sVar13": "sizeVariable",
                "pvVar14": "voidPointer",
                "pcVar15": "charPointer2",
                "pcVar16": "charPointer3",
                "lVar17": "longVariable1",
                "lVar18": "longVariable2",
                "lVar21": "longVariable3",
                "uVar19": "ulongVariable1",
                "uVar20": "uintVariable",
                "lVar31": "longVariable5",
                "puVar22": "undefined8Pointer1",
                "puVar23": "undefined8Pointer2",
                "uVar24": "uintVariable2",
                "iVar25": "intVariable3",
                "uVar26": "ulongVariable2",
                "ppcVar27": "charDoublePointer1",
                "bVar28": "boolVariable",
                "ppcVar29": "charDoublePointer2",
                "bVar30": "byteVariable",
                "pbVar32": "bytePointer2",
                "pbVar33": "bytePointer3",
                "piVar34": "intPointer1",
                "pbVar35": "bytePointer4",
                "iVar37": "intVariable4",
                "ppcVar38": "charDoublePointer3",
                "bVar39": "byteVariable2",
                "auVar40": "undefinedArray",
                "auVar41": "undefinedArray2",
                "local_828": "charPointer4",
                "local_820": "charPointer5",
                "local_818": "longVariable6",
                "local_810": "charDoublePointer4",
                "local_800": "intVariable5",
                "local_740": "charArray",
                "local_678": "charPointerArray"
            },
            "code": "\n\n\nvoid processScript_00103e95(void)\n\n{\n  long **doublePointer1;\n  char charVariable;\n  FILE **doublePointer2;\n  FILE *filePointer;\n  long *pointerVariable;\n  undefined8 uVariable;\n  byte *bytePointer;\n  int intVariable1;\n  char *charPointer1;\n  undefined8 uVariable2;\n  int intVariable2;\n  long *pointerVariable2;\n  size_t sizeVariable;\n  void *voidPointer;\n  char *charPointer2;\n  char *charPointer3;\n  long longVariable1;\n  long longVariable2;\n  ulong ulongVariable1;\n  uint uintVariable;\n  long longVariable3;\n  undefined8 *undefined8Pointer1;\n  undefined8 *undefined8Pointer2;\n  uint uintVariable2;\n  int intVariable3;\n  ulong ulongVariable2;\n  char **charDoublePointer1;\n  bool boolVariable;\n  char **charDoublePointer2;\n  byte byteVariable;\n  long longVariable5;\n  byte *bytePointer2;\n  byte *bytePointer3;\n  int *intPointer1;\n  byte *bytePointer4;\n  uint uVar36;\n  int intVariable4;\n  char **charDoublePointer3;\n  byte byteVariable2;\n  undefined undefinedArray [16];\n  undefined undefinedArray2 [16];\n  char *charPointer4;\n  char *charPointer5;\n  long longVariable6;\n  char **charDoublePointer4;\n  int intVariable5;\n  uint local_7fc;\n  byte *local_7f8;\n  stat local_7d0;\n  char charArray [200];\n  char *charPointerArray [201];\n  \n  byteVariable2 = 0;\n  longVariable2 = 0;\n  DAT_0010d550 = -2;\n  charDoublePointer2 = charPointerArray;\n  intVariable5 = 0;\n  charPointer4 = charArray;\n  longVariable6 = 200;\n  charPointer5 = charPointer4;\n  charDoublePointer4 = charDoublePointer2;\nLAB_00103ee9:\n  *charPointer4 = (char)longVariable2;\n  if (charPointer5 + longVariable6 + -1 <= charPointer4) {\n    longVariable3 = (long)charPointer4 - (long)charPointer5;\n    longVariable1 = longVariable3 + 1;\n    if (longVariable6 < 10000) {\n      longVariable5 = longVariable6 * 2;\n      longVariable6 = 10000;\n      if (longVariable5 < 0x2711) {\n        longVariable6 = longVariable5;\n      }\n      charPointer1 = (char *)malloc(longVariable6 * 9 + 7);\n      if (charPointer1 != (char *)0x0) {\n        longVariable5 = longVariable1 * 8;\n        charPointer2 = charPointer5;\n        charPointer3 = charPointer1;\n        for (; longVariable1 != 0; longVariable1 = longVariable1 + -1) {\n          *charPointer3 = *charPointer2;\n          charPointer2 = charPointer2 + (ulong)byteVariable2 * -2 + 1;\n          charPointer3 = charPointer3 + (ulong)byteVariable2 * -2 + 1;\n        }\n        charDoublePointer3 = (char **)(charPointer1 + longVariable6);\n        charDoublePointer2 = charDoublePointer3;\n        for (; longVariable5 != 0; longVariable5 = longVariable5 + -1) {\n          *(undefined *)charDoublePointer2 = *(undefined *)charDoublePointer4;\n          charDoublePointer4 = (char **)((long)charDoublePointer4 + (ulong)byteVariable2 * -2 + 1);\n          charDoublePointer2 = (char **)((long)charDoublePointer2 + (ulong)byteVariable2 * -2 + 1);\n        }\n        if (charPointer5 != charArray) {\n          free(charPointer5);\n        }\n        charPointer4 = charPointer1 + longVariable3;\n        charDoublePointer2 = charDoublePointer3 + longVariable3;\n        charPointer5 = charPointer1;\n        charDoublePointer4 = charDoublePointer3;\n        if (charPointer1 + longVariable6 + -1 <= charPointer4) goto LAB_00105265;\n        goto LAB_00103fd8;\n      }\n    }\n    print_archive_script_syntax_error_001031a5();\nLAB_0010524c:\n    charPointer1 = charPointer5;\n    if (charPointer5 == charArray) {\n      return;\n    }\nLAB_00105265:\n    free(charPointer1);\n    return;\n  }\nLAB_00103fd8:\n  intVariable4 = (int)longVariable2;\n  if (intVariable4 == 3) goto LAB_0010524c;\n  charVariable = (&DAT_0010a200)[intVariable4];\n  if (charVariable != -0xe) {\n    if (DAT_0010d550 == -2) {\n      if (_DAT_0010d540 == 0) {\n        _DAT_0010d540 = 1;\n        if (DAT_0010d5d0 == 0) {\n          DAT_0010d5d0 = 1;\n        }\n        if (DAT_0010d590 == (FILE *)0x0) {\n          DAT_0010d590 = _stdin;\n        }\n        if (DAT_0010d538 == (FILE *)0x0) {\n          DAT_0010d538 = _stdout;\n        }\n        if ((DAT_0010d5a8 == 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) == 0)) {\n          ensure_buffer_stack_00103df9();\n          undefined8Pointer1 = (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          uVariable2 = create_buffer_001033d6(DAT_0010d590);\n          *undefined8Pointer1 = uVariable2;\n        }\n        extract_data_from_binary_001030ed();\n      }\nLAB_001040b1:\n      *DAT_0010d5b0 = DAT_0010d588;\n      bytePointer2 = DAT_0010d5b0;\n      bytePointer4 = DAT_0010d5b0;\n      uintVariable = DAT_0010d5d0;\nLAB_001040d4:\n      ulongVariable1 = (ulong)uintVariable;\n      ulongVariable2 = (ulong)local_7fc;\n      boolVariable = false;\n      do {\n        byteVariable = (&DAT_0010ab00)[*bytePointer4];\n        if (*(short *)(&DAT_0010a980 + (long)(int)ulongVariable1 * 2) != 0) {\n          boolVariable = true;\n          ulongVariable2 = ulongVariable1 & 0xffffffff;\n          local_7f8 = bytePointer4;\n        }\n        while( true ) {\n          intVariable1 = (int)ulongVariable1;\n          longVariable2 = (long)(int)((int)*(short *)(&DAT_0010a640 + (long)intVariable1 * 2) + (uint)byteVariable);\n          if (intVariable1 == *(short *)(&DAT_0010a440 + longVariable2 * 2)) break;\n          ulongVariable1 = (ulong)(uint)(int)*(short *)(&DAT_0010a800 + (long)intVariable1 * 2);\n          if (0xb0 < *(short *)(&DAT_0010a800 + (long)intVariable1 * 2)) {\n            byteVariable = (&DAT_0010a7c0)[(int)(uint)byteVariable];\n          }\n        }\n        bytePointer4 = bytePointer4 + 1;\n        ulongVariable1 = (ulong)*(short *)(&DAT_0010a240 + longVariable2 * 2);\n      } while (*(short *)(&DAT_0010a640 + ulongVariable1 * 2) != 0xc2);\n      local_7fc = (uint)ulongVariable2;\n      bytePointer3 = bytePointer2;\n      if (boolVariable) {\n        DAT_0010d5b8 = local_7f8;\n        DAT_0010d5c0 = local_7fc;\n      }\nLAB_0010419f:\n      intVariable1 = (int)*(short *)(&DAT_0010a980 + (long)(int)ulongVariable1 * 2);\n      if (intVariable1 == 0) {\n        intVariable1 = (int)*(short *)(&DAT_0010a980 + (long)(int)DAT_0010d5c0 * 2);\n        bytePointer4 = DAT_0010d5b8;\n      }\n      DAT_0010d530 = (int)bytePointer4 - (int)bytePointer3;\n      DAT_0010d588 = *bytePointer4;\n      DAT_0010d5b0 = bytePointer4;\n      DAT_0010d5c8 = bytePointer3;\n      *bytePointer4 = 0;\nLAB_001041f0:\n      bytePointer2 = DAT_0010d5c8;\n      longVariable2 = DAT_0010d5a0;\n      switch(intVariable1) {\n      case 0:\n        goto switchD_00104200_caseD_0;\n      case 1:\n      case 0x10:\n        DAT_0010d550 = 0x105;\n        break;\n      case 2:\n      case 0x11:\n        DAT_0010d550 = 0x107;\n        break;\n      case 3:\n      case 0x12:\n        DAT_0010d550 = 0x108;\n        break;\n      case 4:\n      case 0x13:\n        DAT_0010d550 = 0x109;\n        break;\n      case 5:\n      case 0x14:\n        DAT_0010d550 = 0x10a;\n        break;\n      case 6:\n      case 0x15:\n        DAT_0010d550 = 0x10b;\n        break;\n      case 7:\n      case 0x16:\n        DAT_0010d550 = 0x10c;\n        break;\n      case 8:\n      case 0x17:\n        DAT_0010d550 = 0x10d;\n        break;\n      case 9:\n      case 0x18:\n        DAT_0010d550 = 0x10e;\n        break;\n      case 10:\n      case 0x19:\n        DAT_0010d550 = 0x10f;\n        break;\n      case 0xb:\n      case 0x1a:\n        DAT_0010d550 = 0x106;\n        break;\n      case 0xc:\n      case 0x1b:\n        DAT_0010d550 = 0x113;\n        break;\n      case 0xd:\n      case 0x1c:\n        DAT_0010d550 = 0x111;\n        break;\n      case 0xe:\n      case 0x1d:\n        DAT_0010d550 = 0x103;\n        break;\n      case 0x1f:\n        DAT_0010d554 = DAT_0010d554 + 1;\n        goto LAB_001040b1;\n      case 0x20:\n        DAT_0010d550 = 0x28;\n        break;\n      case 0x21:\n        DAT_0010d550 = 0x29;\n        break;\n      case 0x22:\n        DAT_0010d550 = 0x2c;\n        break;\n      case 0x23:\n        DAT_0010d548 = (char *)xstrdup(DAT_0010d5c8);\n        DAT_0010d550 = 0x104;\n        break;\n      case 0x24:\n      case 0x25:\n      case 0x26:\n        goto LAB_001040b1;\n      case 0x27:\n        DAT_0010d554 = DAT_0010d554 + 1;\n        DAT_0010d550 = 0x102;\n        break;\n      case 0x28:\n        fwrite(DAT_0010d5c8,(long)DAT_0010d530,1,DAT_0010d538);\n        goto LAB_001040b1;\n      case 0x29:\n        goto switchD_00104200_caseD_29;\n      case 0x2a:\n        DAT_0010d550 = 0;\n        break;\n      default:\n        print_error_message_and_exit_001033b0(\"fatal flex scanner internal error--no action found\");\n      case 0xf:\n      case 0x1e:\n        DAT_0010d550 = 0x112;\n      }\n      longVariable2 = (long)intVariable4;\n    }\n    if (0 < DAT_0010d550) {\n      if (DAT_0010d550 != 0x100) {\n        intVariable4 = 2;\n        if (DAT_0010d550 < 0x114) {\n          intVariable4 = (int)(char)(&DAT_0010a0e0)[DAT_0010d550];\n        }\n        goto LAB_0010497d;\n      }\n      DAT_0010d550 = 0x101;\n      goto LAB_001051f0;\n    }\n    intVariable4 = 0;\n    DAT_0010d550 = 0;\nLAB_0010497d:\n    uintVariable = charVariable + intVariable4;\n    if ((0x22 < uintVariable) || (intVariable4 != (char)(&DAT_0010a0a0)[(int)uintVariable])) goto LAB_001049db;\n    charVariable = (&DAT_0010a060)[(int)uintVariable];\n    longVariable2 = (long)charVariable;\n    if (charVariable < '\\x01') {\n      intVariable4 = -(int)charVariable;\n      goto LAB_00104a0a;\n    }\n    DAT_0010d550 = -2;\n    intVariable5 = intVariable5 + -1 + (uint)(intVariable5 == 0);\n    charDoublePointer2 = charDoublePointer2 + 1;\n    *charDoublePointer2 = DAT_0010d548;\n    goto LAB_001049d1;\n  }\nLAB_001049db:\n  intVariable4 = (int)(char)(&DAT_0010a020)[(int)longVariable2];\n  if ((&DAT_0010a020)[(int)longVariable2] == '\\0') {\n    if (intVariable5 == 0) {\n      _DAT_0010d544 = _DAT_0010d544 + 1;\n      print_archive_script_syntax_error_001031a5();\nLAB_001051f0:\n      do {\n        if (((((char)(&DAT_0010a200)[longVariable2] != -0xe) &&\n             (uintVariable = (int)(char)(&DAT_0010a200)[longVariable2] + 1, uintVariable < 0x23)) &&\n            ((&DAT_0010a0a0)[(int)uintVariable] == '\\x01')) &&\n           (longVariable2 = (long)(char)(&DAT_0010a060)[(int)uintVariable],\n           '\\0' < (char)(&DAT_0010a060)[(int)uintVariable])) goto LAB_00105227;\n        if (charPointer5 == charPointer4) goto LAB_0010524c;\n        charPointer4 = charPointer4 + -1;\n        charDoublePointer2 = charDoublePointer2 + -1;\n        longVariable2 = (long)*charPointer4;\n      } while( true );\n    }\n    if (intVariable5 != 3) goto LAB_001051f0;\n    if (0 < DAT_0010d550) {\n      DAT_0010d550 = -2;\n      goto LAB_001051f0;\n    }\n    if (DAT_0010d550 != 0) goto LAB_001051f0;\n    goto LAB_0010524c;\n  }\nLAB_00104a0a:\n  uVariable2 = DAT_0010d660;\n  charDoublePointer1 = DAT_0010d558;\n  charVariable = (&DAT_00109fe0)[intVariable4];\n  charDoublePointer3 = (char **)charDoublePointer2[1 - charVariable];\n  switch(intVariable4) {\n  case 2:\n  case 6:\n    check_ar_status_00103ba8();\n    break;\n  case 0x13:\n    if (DAT_0010d558 == (char **)0x0) {\n      return;\n    }\n    bfd_cache_close();\n    unlink(*DAT_0010d558);\n    return;\n  case 0x15:\n    print_archive_script_syntax_error_001031a5();\n    break;\n  case 0x17:\n    undefined8Pointer1 = (undefined8 *)*charDoublePointer2;\n    if (DAT_0010d558 == (char **)0x0) {\n      charPointer1 = \"%s: no open archive\\n\";\nLAB_00104b62:\n      charPointer1 = (char *)dcgettext(0,charPointer1,5);\n      fprintf(_stderr,charPointer1,uVariable2);\n      check_and_exit_if_zero_0010315d();\n    }\n    else {\n      for (; undefined8Pointer1 != (undefined8 *)0x0; undefined8Pointer1 = (undefined8 *)undefined8Pointer1[1]) {\n        for (undefined8Pointer2 = (undefined8 *)DAT_0010d558[0x1f]; undefined8Pointer2 != (undefined8 *)0x0;\n            undefined8Pointer2 = (undefined8 *)undefined8Pointer2[0x1e]) {\n          intVariable1 = filename_cmp(*undefined8Pointer2);\n          if (intVariable1 == 0) {\n            extract_and_write_archive_00107740();\n            goto LAB_00104adf;\n          }\n        }\n        bfd_openr(*undefined8Pointer1,0);\n        uVariable = DAT_0010d660;\n        uVariable2 = *undefined8Pointer1;\n        charPointer1 = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,charPointer1,uVariable,uVariable2);\nLAB_00104adf:\n      }\n    }\n    break;\n  case 0x18:\n    undefined8Pointer1 = (undefined8 *)*charDoublePointer2;\n    if (DAT_0010d558 == (char **)0x0) {\nLAB_00104b4f:\n      charPointer1 = \"%s: no open output archive\\n\";\n      goto LAB_00104b62;\n    }\n    for (; undefined8Pointer1 != (undefined8 *)0x0; undefined8Pointer1 = (undefined8 *)undefined8Pointer1[1]) {\n      boolVariable = false;\n      charDoublePointer1 = DAT_0010d558 + 0x1f;\n      for (charPointer1 = DAT_0010d558[0x1f]; charPointer1 != (char *)0x0;\n          charPointer1 = *(char **)(charPointer1 + 0xf0)) {\n        intVariable1 = filename_cmp();\n        if (intVariable1 == 0) {\n          charPointer2 = (char *)bfd_openr(*undefined8Pointer1,0);\n          uVariable2 = DAT_0010d660;\n          if (charPointer2 == (char *)0x0) {\n            uVariable = *undefined8Pointer1;\n            charPointer2 = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n            fprintf(_stderr,charPointer2,uVariable2,uVariable);\n            check_and_exit_if_zero_0010315d();\n          }\n          else {\n            *charDoublePointer1 = charPointer2;\n            boolVariable = true;\n            *(undefined8 *)(charPointer2 + 0xf0) = *(undefined8 *)(charPointer1 + 0xf0);\n          }\n        }\n        else {\n          charDoublePointer1 = (char **)(charPointer1 + 0xf0);\n        }\n      }\n      if (!boolVariable) {\n        charPointer1 = (char *)bfd_openr(*undefined8Pointer1,0);\n        uVariable = DAT_0010d660;\n        uVariable2 = *undefined8Pointer1;\n        charPointer2 = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,charPointer2,uVariable,uVariable2);\n        uVariable2 = DAT_0010d660;\n        if (charPointer1 == (char *)0x0) {\n          uVariable = *undefined8Pointer1;\n          charPointer1 = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n          fprintf(_stderr,charPointer1,uVariable2,uVariable);\n          check_and_exit_if_zero_0010315d();\n        }\n        else {\n          *charDoublePointer1 = charPointer1;\n        }\n      }\n    }\n    break;\n  case 0x19:\n    if (DAT_0010d558 != (char **)0x0) {\n      DAT_0010d558[0x1f] = (char *)0x0;\n    }\n    break;\n  case 0x1a:\n    undefined8Pointer1 = (undefined8 *)*charDoublePointer2;\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    for (; undefined8Pointer1 != (undefined8 *)0x0; undefined8Pointer1 = (undefined8 *)undefined8Pointer1[1]) {\n      boolVariable = false;\n      charDoublePointer1 = DAT_0010d558 + 0x1f;\n      for (undefined8Pointer2 = (undefined8 *)DAT_0010d558[0x1f]; uVariable2 = DAT_0010d660,\n          undefined8Pointer2 != (undefined8 *)0x0; undefined8Pointer2 = (undefined8 *)undefined8Pointer2[0x1e]) {\n        intVariable1 = filename_cmp(*undefined8Pointer2,*undefined8Pointer1);\n        if (intVariable1 == 0) {\n          boolVariable = true;\n          *charDoublePointer1 = (char *)undefined8Pointer2[0x1e];\n        }\n        else {\n          charDoublePointer1 = (char **)(undefined8Pointer2 + 0x1e);\n        }\n      }\n      if (!boolVariable) {\n        uVariable = *undefined8Pointer1;\n        charPointer1 = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,charPointer1,uVariable2,uVariable);\n        check_and_exit_if_zero_0010315d();\n      }\n    }\n    break;\n  case 0x1b:\n    undefined8Pointer1 = (undefined8 *)*charDoublePointer2;\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    for (; undefined8Pointer1 != (undefined8 *)0x0; undefined8Pointer1 = (undefined8 *)undefined8Pointer1[1]) {\n      charPointer1 = (char *)bfd_openr(*undefined8Pointer1,\"plugin\");\n      uVariable2 = DAT_0010d660;\n      charDoublePointer1 = DAT_0010d558;\n      if (charPointer1 == (char *)0x0) {\n        uVariable = *undefined8Pointer1;\n        charPointer1 = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n        fprintf(_stderr,charPointer1,uVariable2,uVariable);\n        check_and_exit_if_zero_0010315d();\n      }\n      else {\n        *(char **)(charPointer1 + 0xf0) = DAT_0010d558[0x1f];\n        charDoublePointer1[0x1f] = charPointer1;\n      }\n    }\n    break;\n  case 0x1c:\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    charPointer1 = *DAT_0010d558;\n    DAT_0010d60c = 1;\n    DAT_0010d578 = _stdout;\n    charPointer2 = (char *)dcgettext(0,\"Current open archive is %s\\n\",5);\n    printf(charPointer2,charPointer1);\n    for (charPointer1 = DAT_0010d558[0x1f]; charPointer1 != (char *)0x0; charPointer1 = *(char **)(charPointer1 + 0xf0))\n    {\n      print_file_info_00103ddc(charPointer1,0);\n    }\n    break;\n  case 0x1d:\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    if (0 < _DAT_0010d2d0) {\n      *(uint *)((long)DAT_0010d558 + 0x44) = *(uint *)((long)DAT_0010d558 + 0x44) | 0x2000;\n    }\n    DAT_0010d568 = dup(DAT_0010d568);\n    bfd_close(charDoublePointer1);\n    charPointer1 = DAT_0010d570;\n    intVariable1 = stat(DAT_0010d570,&local_7d0);\n    if ((intVariable1 != 0) && (DAT_0010d558 = (char **)bfd_openw(charPointer1,0), DAT_0010d558 != (char **)0x0)\n       ) {\n      bfd_set_format(DAT_0010d558,2);\n      bfd_close(DAT_0010d558);\n    }\n    copy_and_remove_file_00105bc0(DAT_0010d560,DAT_0010d570,DAT_0010d568);\n    DAT_0010d558 = (char **)0x0;\n    free(DAT_0010d560);\n    free(DAT_0010d570);\n    break;\n  case 0x1e:\n    initialize_output_archive_00103c60(*charDoublePointer2,0);\n    break;\n  case 0x1f:\n    initialize_output_archive_00103c60(*charDoublePointer2,1);\n    break;\n  case 0x20:\n    charPointer1 = *charDoublePointer2;\n    if (DAT_0010d558 == (char **)0x0) {\n      charPointer1 = \"%s: no output archive specified yet\\n\";\n      goto LAB_00104b62;\n    }\n    longVariable2 = convert_and_open_library_00105300(charDoublePointer2[-1],0);\n    if (longVariable2 != 0) {\n      extract_files_from_archive_001032a8(longVariable2,assign_values_0010312d,charPointer1);\n    }\n    break;\n  case 0x21:\n    charPointer1 = *charDoublePointer2;\n    charPointer2 = charDoublePointer2[-1];\n    uVariable2 = convert_and_open_library_00105300(charDoublePointer2[-2],0);\n    if (charPointer1 == (char *)0x0) {\n      DAT_0010d578 = _stdout;\n    }\n    else {\n      DAT_0010d578 = fopen(charPointer1,\"w\");\n      if (DAT_0010d578 != (FILE *)0x0) {\n        extract_files_from_archive_001032a8(uVariable2,print_file_info_00103ddc,charPointer2);\n        bfd_close(uVariable2);\n        fclose(DAT_0010d578);\n        break;\n      }\n      DAT_0010d578 = _stdout;\n      charPointer3 = (char *)dcgettext(0,\"Can\\'t open file %s\\n\",5);\n      fprintf(_stderr,charPointer3,charPointer1);\n    }\n    extract_files_from_archive_001032a8(uVariable2,print_file_info_00103ddc,charPointer2);\n    bfd_close(uVariable2);\n    break;\n  case 0x22:\n    charDoublePointer3 = (char **)*charDoublePointer2;\n    break;\n  case 0x23:\n  case 0x25:\n  case 0x27:\n    charDoublePointer3 = (char **)0x0;\n    break;\n  case 0x24:\n    charDoublePointer3 = (char **)charDoublePointer2[-1];\n    break;\n  case 0x26:\n    charDoublePointer3 = (char **)malloc(0x10);\n    charPointer1 = charDoublePointer2[-2];\n    *charDoublePointer3 = *charDoublePointer2;\n    charDoublePointer3[1] = charPointer1;\n    break;\n  case 0x2a:\n    DAT_0010d60c = (uint)(DAT_0010d60c == 0);\n  }\n  longVariable2 = (long)charVariable;\n  charPointer4 = charPointer4 + -longVariable2;\n  charDoublePointer2[1 - longVariable2] = (char *)charDoublePointer3;\n  charDoublePointer2 = charDoublePointer2 + (1 - longVariable2);\n  uintVariable = (int)(char)(&DAT_00109f80)[(char)(&DAT_00109fa0)[intVariable4] + -0x18] + (int)*charPointer4;\n  if ((uintVariable < 0x23) && (*charPointer4 == (&DAT_0010a0a0)[(int)uintVariable])) {\n    longVariable2 = (long)(char)(&DAT_0010a060)[(int)uintVariable];\n  }\n  else {\n    longVariable2 = (long)(char)(&DAT_00109f60)[(char)(&DAT_00109fa0)[intVariable4] + -0x18];\n  }\n  goto LAB_001049d1;\nswitchD_00104200_caseD_29:\n  intVariable1 = ((int)bytePointer4 - (int)DAT_0010d5c8) + -1;\n  *bytePointer4 = DAT_0010d588;\n  doublePointer1 = (long **)(DAT_0010d5a8 + longVariable2 * 8);\n  doublePointer2 = (FILE **)*doublePointer1;\n  if (*(int *)(doublePointer2 + 7) == 0) {\n    DAT_0010d598 = *(uint *)((long)doublePointer2 + 0x1c);\n    *(undefined4 *)(doublePointer2 + 7) = 1;\n    *doublePointer2 = DAT_0010d590;\n  }\n  bytePointer = DAT_0010d5b0;\n  filePointer = doublePointer2[1];\n  undefinedArray._8_8_ = filePointer;\n  undefinedArray._0_8_ = doublePointer2;\n  if ((byte *)((long)&filePointer->_flags + (long)(int)DAT_0010d598) < DAT_0010d5b0) {\n    if ((byte *)((long)&filePointer->_flags + (long)(int)DAT_0010d598 + 1) < DAT_0010d5b0) {\n      undefinedArray = print_error_message_and_exit_001033b0();\n    }\n    if (*(int *)(undefinedArray._0_8_ + 0x34) != 0) {\n      uintVariable = (int)((long)bytePointer - (long)bytePointer2) - 1;\n      for (longVariable2 = 0; (int)longVariable2 < (int)uintVariable; longVariable2 = longVariable2 + 1) {\n        *(byte *)(undefinedArray._8_8_ + longVariable2) = bytePointer2[longVariable2];\n      }\n      pointerVariable2 = *doublePointer1;\n      if (*(int *)(pointerVariable2 + 7) == 2) {\n        DAT_0010d598 = 0;\n        *(undefined4 *)((long)pointerVariable2 + 0x1c) = 0;\nLAB_0010475e:\n        filePointer = DAT_0010d590;\n        if (uintVariable == 0) {\n          if ((DAT_0010d5a8 == 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) == 0)) {\n            ensure_buffer_stack_00103df9();\n            undefined8Pointer1 = (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n            uVariable2 = create_buffer_001033d6(filePointer);\n            *undefined8Pointer1 = uVariable2;\n          }\n          longVariable2 = DAT_0010d5a8;\n          if (DAT_0010d5a8 != 0) {\n            longVariable2 = *(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          }\n          intVariable2 = 1;\n          initialize_file_001031cf(longVariable2);\n          extract_data_from_binary_001030ed();\n        }\n        else {\n          intVariable2 = 2;\n          *(undefined4 *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x38) = 2;\n        }\n      }\n      else {\n        while( true ) {\n          pointerVariable = *doublePointer1;\n          uintVariable2 = ~uintVariable + *(int *)(pointerVariable2 + 3);\n          if (0 < (int)uintVariable2) break;\n          uintVariable2 = (int)DAT_0010d5b0 - (int)(void *)pointerVariable[1];\n          if (*(int *)(pointerVariable + 4) == 0) {\n            pointerVariable[1] = 0;\nLAB_00104626:\n            print_error_message_and_exit_001033b0();\n            break;\n          }\n          intVariable2 = *(int *)(pointerVariable + 3);\n          intVariable3 = intVariable2;\n          if (intVariable2 < 1) {\n            intVariable3 = intVariable2 / 8;\n          }\n          *(int *)(pointerVariable + 3) = intVariable3 + intVariable2;\n          voidPointer = realloc((void *)pointerVariable[1],(long)(intVariable3 + intVariable2 + 2));\n          pointerVariable[1] = (long)voidPointer;\n          if (voidPointer == (void *)0x0) goto LAB_00104626;\n          DAT_0010d5b0 = (byte *)((long)voidPointer + (long)(int)uintVariable2);\n          pointerVariable2 = *doublePointer1;\n        }\n        if (0x2000 < (int)uintVariable2) {\n          uintVariable2 = 0x2000;\n        }\n        ulongVariable2 = (ulong)uintVariable2;\n        if (*(int *)((long)pointerVariable + 0x24) == 0) {\n          intPointer1 = __errno_location();\n          ulongVariable2 = (ulong)(int)uintVariable2;\n          ulongVariable1 = (ulong)(int)uintVariable;\n          *intPointer1 = 0;\n          goto LAB_001046c7;\n        }\n        ulongVariable1 = 0;\n        intPointer1 = (int *)(long)(int)uintVariable;\n        do {\n          intVariable2 = getc(DAT_0010d590);\n          uVar36 = (uint)ulongVariable1;\n          if (intVariable2 == -1) {\n            intVariable2 = ferror(DAT_0010d590);\n            uintVariable2 = uVar36;\n            if (intVariable2 != 0) {\n              do {\n                charPointer1 = \"input in flex scanner failed\";\n                print_error_message_and_exit_001033b0();\n                do {\n                  *intPointer1 = 0;\n                  clearerr((FILE *)charPointer1);\nLAB_001046c7:\n                  sizeVariable = fread((void *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)\n                                         + ulongVariable1),1,ulongVariable2,DAT_0010d590);\n                  charPointer1 = (char *)DAT_0010d590;\n                  DAT_0010d598 = (uint)sizeVariable;\n                  uintVariable2 = DAT_0010d598;\n                  if ((DAT_0010d598 != 0) ||\n                     (intVariable2 = ferror(DAT_0010d590), uintVariable2 = DAT_0010d598, intVariable2 == 0))\n                  goto LAB_00104738;\n                } while (*intPointer1 == 4);\n              } while( true );\n            }\n            break;\n          }\n          if (intVariable2 == 10) {\n            *(undefined *)\n             ((long)(int *)(long)(int)uintVariable +\n             (long)(int)uVar36 + *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)) = 10;\n            uintVariable2 = uVar36 + 1;\n            break;\n          }\n          ulongVariable1 = (ulong)(uVar36 + 1);\n          *(char *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8) + (long)intPointer1) =\n               (char)intVariable2;\n          intPointer1 = (int *)((long)intPointer1 + 1);\n        } while (uintVariable2 != uVar36 + 1);\nLAB_00104738:\n        DAT_0010d598 = uintVariable2;\n        uintVariable2 = DAT_0010d598;\n        intVariable2 = 0;\n        *(uint *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x1c) = DAT_0010d598;\n        if (uintVariable2 == 0) goto LAB_0010475e;\n      }\n      pointerVariable2 = (long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n      longVariable2 = *pointerVariable2;\n      uintVariable = uintVariable + DAT_0010d598;\n      if (*(int *)(longVariable2 + 0x18) < (int)uintVariable) {\n        intVariable3 = ((int)DAT_0010d598 >> 1) + uintVariable;\n        voidPointer = realloc(*(void **)(longVariable2 + 8),(long)intVariable3);\n        *(void **)(longVariable2 + 8) = voidPointer;\n        undefinedArray2._8_8_ = pointerVariable2;\n        undefinedArray2._0_8_ = *pointerVariable2;\n        if (*(long *)(*pointerVariable2 + 8) == 0) {\n          undefinedArray2 = print_error_message_and_exit_001033b0();\n        }\n        pointerVariable2 = undefinedArray2._8_8_;\n        *(int *)(undefinedArray2._0_8_ + 0x18) = intVariable3 + -2;\n      }\n      DAT_0010d598 = uintVariable;\n      *(undefined *)(*(long *)(*pointerVariable2 + 8) + (long)(int)uintVariable) = 0;\n      *(undefined *)(*(long *)(*pointerVariable2 + 8) + 1 + (long)(int)uintVariable) = 0;\n      bytePointer2 = *(byte **)(*pointerVariable2 + 8);\n      DAT_0010d5c8 = bytePointer2;\n      if (intVariable2 == 1) goto LAB_001048a4;\n      if (intVariable2 == 2) goto LAB_001048ca;\n      bytePointer4 = bytePointer2 + intVariable1;\n      DAT_0010d5b0 = bytePointer4;\n      uintVariable = find_matching_value_0010300e();\n      goto LAB_001040d4;\n    }\n    if ((long)bytePointer - (long)bytePointer2 == 1) goto LAB_001048a4;\nLAB_001048ca:\n    bytePointer4 = (byte *)((long)(int)DAT_0010d598 +\n                      *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8));\n    DAT_0010d5b0 = bytePointer4;\n    ulongVariable1 = find_matching_value_0010300e();\n    bytePointer3 = DAT_0010d5c8;\n    goto LAB_0010419f;\n  }\n  bytePointer4 = bytePointer2 + intVariable1;\n  DAT_0010d5b0 = bytePointer4;\n  ulongVariable1 = find_matching_value_0010300e();\n  if (*(short *)(&DAT_0010a980 + (long)(int)(uint)ulongVariable1 * 2) != 0) {\n    DAT_0010d5b8 = bytePointer4;\n    DAT_0010d5c0 = (uint)ulongVariable1;\n  }\n  ulongVariable2 = ulongVariable1 & 0xffffffff;\n  while( true ) {\n    intVariable1 = (int)ulongVariable2;\n    if (intVariable1 == *(short *)(&DAT_0010a440 +\n                           (long)(*(short *)(&DAT_0010a640 + (long)intVariable1 * 2) + 1) * 2)) break;\n    ulongVariable2 = (ulong)(uint)(int)*(short *)(&DAT_0010a800 + (long)intVariable1 * 2);\n  }\n  uintVariable = (uint)*(short *)(&DAT_0010a240 +\n                           (long)(*(short *)(&DAT_0010a640 + (long)intVariable1 * 2) + 1) * 2);\n  bytePointer3 = bytePointer2;\n  if ((*(short *)(&DAT_0010a240 + (long)(*(short *)(&DAT_0010a640 + (long)intVariable1 * 2) + 1) * 2) == 0)\n     || (uintVariable == 0xb0)) goto LAB_0010419f;\n  bytePointer4 = bytePointer4 + 1;\n  goto LAB_001040d4;\nLAB_001048a4:\n  DAT_0010d5b0 = DAT_0010d5c8;\n  intVariable1 = (int)(DAT_0010d5d0 - 1) / 2 + 0x2a;\n  goto LAB_001041f0;\nswitchD_00104200_caseD_0:\n  *bytePointer4 = DAT_0010d588;\n  ulongVariable1 = (ulong)DAT_0010d5c0;\n  bytePointer4 = DAT_0010d5b8;\n  goto LAB_0010419f;\nLAB_00105227:\n  charDoublePointer2 = charDoublePointer2 + 1;\n  intVariable5 = 3;\n  *charDoublePointer2 = DAT_0010d548;\nLAB_001049d1:\n  charPointer4 = charPointer4 + 1;\n  goto LAB_00103ee9;\n}\n\n",
            "called": [
                "FUN_00105300",
                "dup",
                "realloc",
                "printf",
                "dcgettext",
                "FUN_001033d6",
                "fclose",
                "fwrite",
                "bfd_close",
                "free",
                "fread",
                "FUN_0010312d",
                "filename_cmp",
                "xstrdup",
                "FUN_001033b0",
                "FUN_00103ba8",
                "__errno_location",
                "FUN_0010315d",
                "FUN_0010300e",
                "FUN_00107740",
                "bfd_openw",
                "FUN_00103df9",
                "bfd_set_format",
                "FUN_001032a8",
                "bfd_openr",
                "FUN_00105bc0",
                "FUN_001031a5",
                "fopen",
                "ferror",
                "FUN_001031cf",
                "stat",
                "FUN_00103c60",
                "bfd_cache_close",
                "clearerr",
                "getc",
                "fprintf",
                "FUN_001030ed",
                "FUN_00103ddc",
                "malloc",
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103e95",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "process_script_00103e95"
        },
        "bfd_init": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_init"
        },
        "strerror": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102550",
            "calling": [
                "FUN_001025a0",
                "FUN_00103c60",
                "FUN_00102f1e",
                "FUN_00102c25",
                "FUN_00103a78",
                "FUN_00102fd7"
            ],
            "imported": false,
            "current_name": "strerror"
        },
        "FUN_00107cc0": {
            "renaming": {
                "FUN_00107cc0": "execute_reverse_functions_00107cc0",
                "lVar1": "index",
                "lVar2": "prevIndex",
                "lVar3": "loopIndex",
                "plVar4": "pointerList",
                "uVar5": "count"
            },
            "code": "\nvoid executeReverseFunctions_00107cc0(void)\n\n{\n  long index;\n  long prevIndex;\n  long loopIndex;\n  long *pointerList;\n  uint count;\n  \n  pointerList = (long *)PTR_DAT_0010d2e0;\n  if (PTR_DAT_0010d2e0 != (undefined *)0x0) {\n    do {\n      count = *(int *)(pointerList + 1) - 1;\n      if (-1 < (int)count) {\n        index = (long)(int)count;\n        count = count & 7;\n        (*(code *)pointerList[index + 2])();\n        prevIndex = index + -1;\n        if (-1 < (int)prevIndex) {\n          loopIndex = prevIndex;\n          if (count != 0) {\n            if (count != 1) {\n              if (count != 2) {\n                if (count != 3) {\n                  if (count != 4) {\n                    if (count != 5) {\n                      if (count != 6) {\n                        (*(code *)pointerList[index + 1])();\n                        prevIndex = index + -2;\n                      }\n                      (*(code *)pointerList[prevIndex + 2])();\n                      prevIndex = prevIndex + -1;\n                    }\n                    (*(code *)pointerList[prevIndex + 2])();\n                    prevIndex = prevIndex + -1;\n                  }\n                  (*(code *)pointerList[prevIndex + 2])();\n                  prevIndex = prevIndex + -1;\n                }\n                (*(code *)pointerList[prevIndex + 2])();\n                prevIndex = prevIndex + -1;\n              }\n              (*(code *)pointerList[prevIndex + 2])();\n              prevIndex = prevIndex + -1;\n            }\n            (*(code *)pointerList[prevIndex + 2])();\n            loopIndex = prevIndex + -1;\n            if ((int)(prevIndex + -1) < 0) goto LAB_00107d96;\n          }\n          do {\n            (*(code *)pointerList[loopIndex + 2])();\n            index = loopIndex + -1;\n            (*(code *)pointerList[loopIndex + 1])();\n            (*(code *)pointerList[loopIndex])();\n            (*(code *)pointerList[index])();\n            (*(code *)pointerList[loopIndex + -2])();\n            (*(code *)pointerList[loopIndex + -3])();\n            (*(code *)pointerList[loopIndex + -4])();\n            (*(code *)pointerList[loopIndex + -5])();\n            loopIndex = loopIndex + -8;\n          } while (-1 < (int)index + -7);\n        }\n      }\nLAB_00107d96:\n      pointerList = (long *)*pointerList;\n    } while (pointerList != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107cc0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "execute_reverse_functions_00107cc0"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "FUN_00105ae0": {
            "renaming": {
                "FUN_00105ae0": "extract_and_archive_files_00105ae0",
                "param_1": "archivePath",
                "param_2": "destinationPath",
                "param_3": "option1",
                "param_4": "option2"
            },
            "code": "\nvoid extractAndArchiveFiles_00105ae0(undefined8 archivePath,undefined8 destinationPath,undefined option1,undefined option2)\n\n{\n  extract_archived_files_00105af0(archivePath,destinationPath,option1,option2);\n  return;\n}\n\n",
            "called": [
                "FUN_00105af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105ae0",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "extract_and_archive_files_00105ae0"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(parse_command_line_00105db0,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "__libc_start_main",
                "FUN_00105db0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105cc0",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "FUN_00107690": {
            "renaming": {
                "FUN_00107690": "handle_error_00107690",
                "param_1": "errorCode",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "param_8": "param8",
                "param_9": "errorMessage",
                "param_10": "param10",
                "param_11": "param11",
                "param_12": "param12",
                "param_13": "param13",
                "param_14": "param14",
                "in_AL": "flag",
                "local_d8": "bufferSize",
                "local_d4": "localVar1",
                "local_d0": "localPtr1",
                "local_c8": "localPtr2",
                "local_b0": "paramArray1",
                "local_a8": "paramArray2",
                "local_a0": "paramArray3",
                "local_98": "paramArray4",
                "local_90": "paramArray5",
                "local_88": "errorCodeLocal",
                "local_78": "param2Local",
                "local_68": "param3Local",
                "local_58": "param4Local",
                "local_48": "param5Local",
                "local_38": "param6Local",
                "local_28": "param7Local",
                "local_18": "param8Local"
            },
            "code": "\nvoid handleError_00107690(undefined4 errorCode,undefined4 param2,undefined4 param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6,undefined4 param7,undefined4 param8,\n                 undefined8 errorMessage,undefined8 param10,undefined8 param11,undefined8 param12,\n                 undefined8 param13,undefined8 param14)\n\n{\n  char flag;\n  undefined4 bufferSize;\n  undefined4 localVar1;\n  undefined *localPtr1;\n  undefined *localPtr2;\n  undefined local_b8 [8];\n  undefined8 paramArray1;\n  undefined8 paramArray2;\n  undefined8 paramArray3;\n  undefined8 paramArray4;\n  undefined8 paramArray5;\n  undefined4 errorCodeLocal;\n  undefined4 param2Local;\n  undefined4 param3Local;\n  undefined4 param4Local;\n  undefined4 param5Local;\n  undefined4 param6Local;\n  undefined4 param7Local;\n  undefined4 param8Local;\n  \n  if (flag != '\\0') {\n    errorCodeLocal = errorCode;\n    param2Local = param2;\n    param3Local = param3;\n    param4Local = param4;\n    param5Local = param5;\n    param6Local = param6;\n    param7Local = param7;\n    param8Local = param8;\n  }\n  localPtr1 = &stack0x00000008;\n  bufferSize = 8;\n  localPtr2 = local_b8;\n  localVar1 = 0x30;\n  paramArray1 = param10;\n  paramArray2 = param11;\n  paramArray3 = param12;\n  paramArray4 = param13;\n  paramArray5 = param14;\n  print_error_message_001078c0(errorMessage,&bufferSize);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_001078c0",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107690",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_001028ed",
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "handle_error_00107690"
        },
        "bfd_seek": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102580",
            "calling": [
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "bfd_seek"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "FUN_0010266f": {
            "renaming": {
                "FUN_0010266f": "print_supported_targets_0010266f",
                "param_1": "target",
                "param_2": "outputFile",
                "lVar1": "currentTarget",
                "pcVar2": "prompt",
                "__ptr": "targetList",
                "plVar3": "currentTargetPtr"
            },
            "code": "\nvoid printSupportedTargets_0010266f(long target,FILE *outputFile)\n\n{\n  long currentTarget;\n  char *prompt;\n  long *targetList;\n  long *currentTargetPtr;\n  \n  if (target == 0) {\n    prompt = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,prompt);\n  }\n  else {\n    prompt = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,prompt,target);\n  }\n  targetList = (long *)bfd_target_list();\n  currentTargetPtr = targetList;\n  while( true ) {\n    currentTarget = *currentTargetPtr;\n    currentTargetPtr = currentTargetPtr + 1;\n    if (currentTarget == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "free",
                "bfd_target_list",
                "dcgettext",
                "fputc",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010266f",
            "calling": [
                "FUN_0010342d",
                "FUN_0010394a"
            ],
            "imported": false,
            "current_name": "print_supported_targets_0010266f"
        },
        "FUN_00105830": {
            "renaming": {
                "FUN_00105830": "extract_sub_string_00105830",
                "param_1": "inputString",
                "param_2": "structureAddress",
                "param_3": "unusedParam1",
                "param_4": "unusedParam2",
                "__s": "baseName",
                "uVar3": "stringLength",
                "pcVar4": "outputString",
                "bVar5": "tempFlag",
                "auVar6": "result"
            },
            "code": "\nundefined  [16] extractSubString_00105830(char *inputString,long structureAddress,undefined8 unusedParam1,undefined8 unusedParam2)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *baseName;\n  ulong stringLength;\n  char *outputString;\n  byte tempFlag;\n  undefined result [16];\n  \n  tempFlag = 0;\n  if (DAT_0010d5f9 == '\\0') {\n    baseName = (char *)lbasename();\n    inputString = baseName;\n    if ((DAT_0010d5fa != '\\0') && (structureAddress != 0)) {\n      sVar2 = strlen(baseName);\n      stringLength = (ulong)*(byte *)(*(long *)(structureAddress + 8) + 0x1e);\n      if (stringLength < sVar2) {\n        inputString = (char *)xmalloc(stringLength + 1);\n        lVar1 = *(long *)(structureAddress + 8);\n        outputString = inputString;\n        for (stringLength = (ulong)*(byte *)(lVar1 + 0x1e); stringLength != 0; stringLength = stringLength - 1) {\n          *outputString = *baseName;\n          baseName = baseName + (ulong)tempFlag * -2 + 1;\n          outputString = outputString + (ulong)tempFlag * -2 + 1;\n        }\n        inputString[*(byte *)(lVar1 + 0x1e)] = '\\0';\n      }\n    }\n  }\n  result._8_8_ = unusedParam2;\n  result._0_8_ = inputString;\n  return result;\n}\n\n",
            "called": [
                "FUN_00102bb0",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105830",
            "calling": [
                "FUN_00105db0",
                "FUN_00105480",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "extract_sub_string_00105830"
        },
        "bfd_find_target": {
            "renaming": {},
            "code": "\nvoid bfd_find_target(void)\n\n{\n  bfd_find_target();\n  return;\n}\n\n",
            "called": [
                "bfd_find_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_find_target"
        },
        "bfd_check_format_matches": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024c0",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_check_format_matches"
        },
        "FUN_00107730": {
            "renaming": {
                "FUN_00107730": "cleanup_function_00107730"
            },
            "code": "\nvoid cleanupFunction_00107730(void)\n\n{\n  if (DAT_0010d618 == 0) {\n    return;\n  }\n  if (DAT_0010d5e0 != 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 != (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
            "called": [
                "FUN_00102bf5"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107730",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "cleanup_function_00107730"
        },
        "mkstemp": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "mkstemp"
        },
        "FUN_00107c20": {
            "renaming": {
                "FUN_00107c20": "print_error_message_00107c20",
                "param_1": "errorString",
                "iVar1": "error",
                "uVar2": "errorMessage",
                "in_R10": "placeholder",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printErrorMessage_00107c20(long errorString)\n\n{\n  int error;\n  undefined8 errorMessage;\n  undefined8 placeholder;\n  \n  error = bfd_get_error();\n  if (error == 0) {\n    errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorMessage = bfd_errmsg(error);\n  }\n  fflush(standardOutput);\n  if (errorString != 0) {\n    fprintf(standardError,\"%s: %s: %s\\n\",DAT_0010d660,errorString,errorMessage,placeholder);\n    return;\n  }\n  fprintf(standardError,\"%s: %s\\n\",DAT_0010d660,errorMessage,placeholder);\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg",
                "FUN_00102f96",
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c20",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0",
                "FUN_00107c10"
            ],
            "imported": false,
            "current_name": "print_error_message_00107c20"
        },
        "lseek": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "lseek"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "FUN_001031cf": {
            "renaming": {
                "FUN_001031cf": "initialize_file_001031cf",
                "param_1": "filePointer",
                "param_2": "inputFile",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "iVar1": "errnoValue",
                "uVar2": "isTerminal",
                "iVar3": "fileDescriptor",
                "piVar4": "errnoLocation",
                "lVar5": "dataLocation"
            },
            "code": "\n\n\nundefined8\ninitializeFile_001031cf(FILE **filePointer,FILE *inputFile,undefined8 param3,undefined8 param4,undefined8 param5)\n\n{\n  int errnoValue;\n  uint isTerminal;\n  int fileDescriptor;\n  int *errnoLocation;\n  long dataLocation;\n  \n  errnoLocation = __errno_location();\n  dataLocation = DAT_0010d5a8;\n  errnoValue = *errnoLocation;\n  if (filePointer == (FILE **)0x0) {\n    _DAT_00000034 = 1;\n    _DAT_00000000 = inputFile;\n    if (DAT_0010d5a8 != 0) {\nLAB_00103263:\n      if (filePointer == *(FILE ***)(dataLocation + DAT_0010d5a0 * 8)) goto LAB_0010327b;\n    }\n  }\n  else {\n    *(undefined4 *)((long)filePointer + 0x1c) = 0;\n    *(undefined *)&filePointer[1]->_flags = 0;\n    *(undefined *)((long)&filePointer[1]->_flags + 1) = 0;\n    *(undefined4 *)(filePointer + 5) = 1;\n    filePointer[2] = filePointer[1];\n    *(undefined4 *)(filePointer + 7) = 0;\n    if (dataLocation != 0) {\n      if (filePointer == *(FILE ***)(dataLocation + DAT_0010d5a0 * 8)) {\n        extract_data_from_binary_001030ed();\n      }\n      *filePointer = inputFile;\n      *(undefined4 *)((long)filePointer + 0x34) = 1;\n      goto LAB_00103263;\n    }\n    *filePointer = inputFile;\n    *(undefined4 *)((long)filePointer + 0x34) = 1;\n  }\n  *(undefined8 *)((long)filePointer + 0x2c) = 1;\nLAB_0010327b:\n  isTerminal = 0;\n  if (inputFile != (FILE *)0x0) {\n    fileDescriptor = fileno(inputFile);\n    fileDescriptor = isatty(fileDescriptor);\n    isTerminal = (uint)(0 < fileDescriptor);\n  }\n  *(uint *)((long)filePointer + 0x24) = isTerminal;\n  *errnoLocation = errnoValue;\n  return param5;\n}\n\n",
            "called": [
                "isatty",
                "fileno",
                "FUN_001030ed",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031cf",
            "calling": [
                "FUN_001033d6",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "initialize_file_001031cf"
        },
        "FUN_0010312d": {
            "renaming": {
                "FUN_0010312d": "assign_values_0010312d",
                "param_1": "destination",
                "param_2": "source",
                "lVar1": "temp"
            },
            "code": "\nvoid assignValues_0010312d(long destination,long source)\n\n{\n  long temp;\n  \n  if (source != 0) {\n    *(undefined8 *)(source + 0xf0) = *(undefined8 *)(destination + 0xf0);\n  }\n  temp = DAT_0010d558;\n  *(undefined8 *)(destination + 0xf0) = *(undefined8 *)(DAT_0010d558 + 0xf8);\n  *(long *)(temp + 0xf8) = destination;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010312d",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "assign_values_0010312d"
        },
        "FUN_00105c00": {
            "renaming": {
                "FUN_00105c00": "reverse_and_write_to_file_00105c00",
                "param_1": "input_file_descriptor",
                "param_2": "output_file_path",
                "_Var3": "file_offset",
                "uVar4": "bytes_read",
                "sVar5": "bytes_written",
                "piVar6": "err_num_ptr",
                "iVar1": "err_num",
                "iVar2": "read_result",
                "__fd": "output_file_descriptor",
                "auStack_2038": "buffer"
            },
            "code": "\nulong reverse_and_write_to_file_00105c00(int input_file_descriptor,char *output_file_path)\n\n{\n  int err_num;\n  int output_file_descriptor;\n  int read_result;\n  __off_t file_offset;\n  ulong bytes_read;\n  size_t bytes_written;\n  int *err_num_ptr;\n  undefined buffer [8200];\n  \n  if ((-1 < input_file_descriptor) && (file_offset = lseek(input_file_descriptor,0,0), file_offset == 0)) {\n    output_file_descriptor = open(output_file_path,0x201);\n    if (output_file_descriptor < 0) {\n      bytes_read = close_and_return_error_00102f55();\n      return bytes_read;\n    }\n    do {\n      bytes_read = read(input_file_descriptor,buffer,0x2000);\n      read_result = (int)bytes_read;\n      if (read_result < 1) {\n        err_num_ptr = __errno_location();\n        err_num = *err_num_ptr;\n        close(input_file_descriptor);\n        close(output_file_descriptor);\n        if (read_result != 0) {\n          *err_num_ptr = err_num;\n          return 0xffffffff;\n        }\n        return bytes_read & 0xffffffff;\n      }\n      bytes_written = write(output_file_descriptor,buffer,(long)read_result);\n    } while (bytes_written == (long)read_result);\n    err_num_ptr = __errno_location();\n    read_result = *err_num_ptr;\n    close(input_file_descriptor);\n    close(output_file_descriptor);\n    *err_num_ptr = read_result;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "read",
                "lseek",
                "close",
                "__errno_location",
                "write",
                "FUN_00102f55",
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105c00",
            "calling": [
                "FUN_00105bc0"
            ],
            "imported": false,
            "current_name": "reverse_and_write_to_file_00105c00"
        },
        "calloc": {
            "renaming": {},
            "code": "\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(__nmemb,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "FUN_00103df9"
            ],
            "imported": false,
            "current_name": "calloc"
        },
        "FUN_00105d20": {
            "renaming": {
                "FUN_00105d20": "FUNC_00105d20"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d44) */\n/* WARNING: Removing unreachable block (ram,0x00105d50) */\n\nvoid FUNC_00105d20(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105d20",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105d20"
        },
        "FUN_001052a0": {
            "renaming": {
                "FUN_001052a0": "get_file_information_001052a0",
                "param_1": "filename",
                "iVar1": "status",
                "piVar2": "errnum_ptr",
                "uVar3": "error_message",
                "pcVar4": "error_reason",
                "sStack_a8": "file_stats"
            },
            "code": "\nlong get_file_information_001052a0(char *filename)\n\n{\n  int status;\n  int *errnum_ptr;\n  undefined8 error_message;\n  char *error_reason;\n  stat file_stats;\n  \n  if (filename != (char *)0x0) {\n    status = stat(filename,&file_stats);\n    if (status < 0) {\n      errnum_ptr = __errno_location();\n      if (*errnum_ptr == 2) {\n        error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n        print_error_message_00107920(error_message,filename);\n      }\n      else {\n        error_reason = strerror(*errnum_ptr);\n        error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        print_error_message_00107920(error_message,filename,error_reason);\n      }\n    }\n    else if ((file_stats.st_mode & 0xf000) == 0x4000) {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      print_error_message_00107920(error_message,filename);\n    }\n    else if ((file_stats.st_mode & 0xf000) == 0x8000) {\n      if (-1 < file_stats.st_size) {\n        return file_stats.st_size;\n      }\n      error_message = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      print_error_message_00107920(error_message,filename);\n    }\n    else {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      print_error_message_00107920(error_message,filename);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "FUN_001025a0",
                "dcgettext",
                "stat",
                "FUN_00107920"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a0",
            "calling": [
                "FUN_00107650",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "get_file_information_001052a0"
        },
        "FUN_0010336b": {
            "renaming": {
                "FUN_0010336b": "print_emulation_options_0010336b",
                "param_1": "outputFile",
                "pcVar1": "optionsString"
            },
            "code": "\nvoid printEmulationOptions_0010336b(FILE *outputFile)\n\n{\n  char *optionsString;\n  \n  optionsString = (char *)dcgettext(0,\" emulation options: \\n\",5);\n  fprintf(outputFile,optionsString);\n  optionsString = (char *)dcgettext(0,\"  No emulation specific options\\n\",5);\n  fprintf(outputFile,optionsString);\n  return;\n}\n\n",
            "called": [
                "dcgettext",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010336b",
            "calling": [
                "FUN_0010342d"
            ],
            "imported": false,
            "current_name": "print_emulation_options_0010336b"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "FUN_00105a68",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_001031a5",
                "FUN_00103ba8",
                "FUN_00102f08",
                "FUN_001075e0",
                "FUN_00103a78",
                "FUN_00103172"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "FUN_00103c60": {
            "renaming": {
                "FUN_00103c60": "initialize_output_archive_00103c60",
                "param_1": "inputArchivePath",
                "param_2": "isPlugin",
                "cVar1": "checkFormatResult",
                "piVar2": "errnoLocation",
                "pcVar3": "errorMessage",
                "lVar4": "inputArchive",
                "lVar5": "archivedFile",
                "uVar6": "outputArchivePath",
                "plVar7": "archivedFilePointer"
            },
            "code": "\n\n\nvoid initializeOutputArchive_00103c60(char *inputArchivePath,int isPlugin)\n\n{\n  char checkFormatResult;\n  int *errnoLocation;\n  char *errorMessage;\n  long inputArchive;\n  long archivedFile;\n  undefined8 outputArchivePath;\n  long *archivedFilePointer;\n  \n  DAT_0010d570 = xstrdup();\n  DAT_0010d560 = (char *)create_temp_file_from_path_001057a0(DAT_0010d570,&DAT_0010d568);\n  if (DAT_0010d560 == (char *)0x0) {\n    errnoLocation = __errno_location();\n    inputArchivePath = strerror(*errnoLocation);\n    outputArchivePath = DAT_0010d660;\n    errorMessage = (char *)dcgettext(0,\"%s: Can\\'t open temporary file (%s)\\n\",5);\n  }\n  else {\n    DAT_0010d558 = bfd_fdopenw(DAT_0010d560,0,DAT_0010d568);\n    if (DAT_0010d558 == 0) {\n      errorMessage = \"%s: Can\\'t open output archive %s\\n\";\n      inputArchivePath = DAT_0010d560;\n    }\n    else {\n      if (isPlugin != 0) {\nLAB_00103d02:\n        bfd_set_format(DAT_0010d558,2);\n        *(byte *)(DAT_0010d558 + 0x49) = *(byte *)(DAT_0010d558 + 0x49) & 0xe7 | 8;\n        return;\n      }\n      inputArchive = bfd_openr(inputArchivePath,\"plugin\");\n      if (inputArchive == 0) {\n        errorMessage = \"%s: Can\\'t open input archive %s\\n\";\n      }\n      else {\n        checkFormatResult = bfd_check_format(inputArchive,2);\n        if (checkFormatResult != '\\0') {\n          archivedFilePointer = (long *)(DAT_0010d558 + 0xf8);\n          for (archivedFile = bfd_openr_next_archived_file(inputArchive,0); archivedFile != 0;\n              archivedFile = bfd_openr_next_archived_file(inputArchive,archivedFile)) {\n            *archivedFilePointer = archivedFile;\n            archivedFilePointer = (long *)(archivedFile + 0xf0);\n          }\n          goto LAB_00103d02;\n        }\n        errorMessage = \"%s: file %s is not an archive\\n\";\n      }\n    }\n    outputArchivePath = DAT_0010d660;\n    errorMessage = (char *)dcgettext(0,errorMessage,5);\n  }\n  fprintf(_stderr,errorMessage,outputArchivePath,inputArchivePath);\n  check_and_exit_if_zero_0010315d();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format",
                "bfd_set_format",
                "xstrdup",
                "FUN_001057a0",
                "dcgettext",
                "bfd_openr",
                "bfd_openr_next_archived_file",
                "fprintf",
                "__errno_location",
                "FUN_0010315d",
                "strerror",
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c60",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "initialize_output_archive_00103c60"
        },
        "FUN_00102e57": {
            "renaming": {
                "FUN_00102e57": "write_to_file_and_print_00102e57",
                "pFVar1": "filePointer"
            },
            "code": "\nvoid writeToFileAndPrint_00102e57(void)\n\n{\n  FILE *filePointer;\n  \n  DAT_0010d618 = (char *)concat();\n  if (DAT_0010d60c != 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  filePointer = fopen(DAT_0010d618,\"w\");\n  if (filePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e57",
            "calling": [
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "write_to_file_and_print_00102e57"
        },
        "FUN_00105af0": {
            "renaming": {
                "FUN_00105af0": "extract_archived_files_00105af0",
                "param_1": "file_list",
                "param_2": "archive",
                "param_3": "print_enabled",
                "param_4": "check_format",
                "cVar1": "is_valid_format",
                "uVar2": "result",
                "lVar3": "current_file",
                "uVar4": "num_valid_files"
            },
            "code": "\nulong extract_archived_files_00105af0(long *file_list,long archive,char print_enabled,char check_format)\n\n{\n  char is_valid_format;\n  uint result;\n  long current_file;\n  ulong num_valid_files;\n  \n  if (check_format == '\\0') {\n    if (print_enabled != '\\0') {\n      num_valid_files = print_and_assign_00102f08();\n      return num_valid_files;\n    }\n  }\n  else {\n    is_valid_format = bfd_check_format(archive,2);\n    if (is_valid_format != '\\0') {\n      num_valid_files = 0;\n      for (current_file = bfd_openr_next_archived_file(archive,0); current_file != 0;\n          current_file = bfd_openr_next_archived_file(archive,current_file)) {\n        result = extract_archived_files_00105af0(file_list,current_file,print_enabled,1);\n        if ((char)result != '\\0') {\n          num_valid_files = (ulong)result;\n          file_list = (long *)(*file_list + 0xf0);\n        }\n      }\n      return num_valid_files;\n    }\n    if (print_enabled != '\\0') {\n      num_valid_files = print_and_assign_00102f08();\n      return num_valid_files;\n    }\n  }\n  *(long *)(archive + 0xf0) = *file_list;\n  *file_list = archive;\n  return 1;\n}\n\n",
            "called": [
                "bfd_check_format",
                "bfd_openr_next_archived_file",
                "FUN_00105af0",
                "FUN_00102f08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105af0",
            "calling": [
                "FUN_00105ae0",
                "FUN_00105af0",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "extract_archived_files_00105af0"
        },
        "FUN_0010300e": {
            "renaming": {
                "FUN_0010300e": "find_matching_value_0010300e",
                "bVar1": "hasMatch",
                "iVar2": "currentIndex",
                "lVar3": "computedIndex",
                "bVar4": "lookupResult",
                "pbVar5": "currentPointer",
                "in_R9": "matchingPointer",
                "in_R10D": "matchingIndex"
            },
            "code": "\nvoid findMatchingValue_0010300e(void)\n\n{\n  bool hasMatch;\n  int currentIndex;\n  long computedIndex;\n  byte lookupResult;\n  byte *currentPointer;\n  byte *matchingPointer;\n  int matchingIndex;\n  \n  hasMatch = false;\n  currentIndex = DAT_0010d5d0;\n  for (currentPointer = DAT_0010d5c8; currentPointer < DAT_0010d5b0; currentPointer = currentPointer + 1) {\n    lookupResult = 1;\n    if (*currentPointer != 0) {\n      lookupResult = (&DAT_0010ab00)[*currentPointer];\n    }\n    if (*(short *)(&DAT_0010a980 + (long)currentIndex * 2) != 0) {\n      hasMatch = true;\n      matchingPointer = currentPointer;\n      matchingIndex = currentIndex;\n    }\n    while( true ) {\n      computedIndex = (long)(int)((int)*(short *)(&DAT_0010a640 + (long)currentIndex * 2) + (uint)lookupResult);\n      if (*(short *)(&DAT_0010a440 + computedIndex * 2) == currentIndex) break;\n      currentIndex = (int)*(short *)(&DAT_0010a800 + (long)currentIndex * 2);\n      if (0xb0 < currentIndex) {\n        lookupResult = (&DAT_0010a7c0)[(int)(uint)lookupResult];\n      }\n    }\n    currentIndex = (int)*(short *)(&DAT_0010a240 + computedIndex * 2);\n  }\n  if (hasMatch) {\n    DAT_0010d5b8 = matchingPointer;\n    DAT_0010d5c0 = matchingIndex;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010300e",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "find_matching_value_0010300e"
        },
        "chmod": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "chmod"
        },
        "FUN_00102ba1": {
            "renaming": {
                "FUN_00102ba1": "free_and_return_00102ba1",
                "unaff_RBP": "buffer",
                "unaff_retaddr": "return_address",
                "auVar1": "result"
            },
            "code": "\nundefined  [16] free_and_return_00102ba1(void)\n\n{\n  undefined result [16];\n  void *buffer;\n  ulong return_address;\n  \n  free(buffer);\n  result._8_8_ = 0;\n  result._0_8_ = return_address;\n  return result << 0x40;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102ba1",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "free_and_return_00102ba1"
        },
        "FUN_00107740": {
            "renaming": {
                "FUN_00107740": "extract_and_write_archive_00107740",
                "param_1": "archive",
                "iVar1": "filenameComparisonResult",
                "iVar2": "errorHandlingResult",
                "piVar3": "errorNumber",
                "pcVar4": "errorMessage",
                "uVar5": "errorString",
                "pplVar6": "archiveData",
                "__ptr": "buffer",
                "__n": "bytesRead",
                "lVar7": "loopIndex",
                "plVar8": "currentFile",
                "puVar9": "localArray",
                "uVar10": "bytesWritten",
                "sVar11": "bytesToRead",
                "local_c8": "localArray",
                "_Stack_b0": "filePermissions",
                "uStack_98": "archiveSize",
                "uStack_80": "fileModificationTime",
                "uStack_70": "fileAccessTime"
            },
            "code": "\n\n\nlong * extractAndWriteArchive_00107740(long **archive)\n\n{\n  int filenameComparisonResult;\n  int errorHandlingResult;\n  int *errorNumber;\n  char *errorMessage;\n  undefined8 errorString;\n  long **archiveData;\n  void *buffer;\n  size_t bytesRead;\n  long loopIndex;\n  long *currentFile;\n  undefined4 *localArray;\n  ulong bytesWritten;\n  size_t bytesToRead;\n  undefined4 localArray [6];\n  __mode_t filePermissions;\n  ulong archiveSize;\n  undefined8 fileModificationTime;\n  undefined8 fileAccessTime;\n  \n  if (_DAT_0010d600 != 0) {\n    localArray = localArray;\n    for (loopIndex = 0x24; loopIndex != 0; loopIndex = loopIndex + -1) {\n      *localArray = 0;\n      localArray = localArray + 1;\n    }\n  }\n  archiveData = (long **)archive[0x1d];\n  if ((long **)archive[0x1d] == (long **)0x0) {\n    archiveData = archive;\n  }\n  errorHandlingResult = (*(code *)archiveData[1][0x3d])(archive,localArray);\n  if (errorHandlingResult != 0) {\n    currentFile = *archive;\n    errorString = dcgettext(0,\"internal stat error on %s\",5);\n    errorHandlingResult = handle_error_00107690(errorString,currentFile);\n    errorString = DAT_0010d638;\n    if (errorHandlingResult == 3) {\n      for (; *currentFile != 0; currentFile = (long *)(*currentFile + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*currentFile != (undefined8 *)0x0; currentFile = (long *)(*currentFile + 0xf0)) {\n        filenameComparisonResult = filename_cmp(*(undefined8 *)*currentFile,errorString);\n        if (filenameComparisonResult == 0) {\n          if (errorHandlingResult != 2) {\n            return currentFile;\n          }\n          return (long *)(*currentFile + 0xf0);\n        }\n      }\n    }\n    return currentFile;\n  }\n  bfd_seek(archive,0,0);\n  DAT_0010d5d8 = (FILE *)0x0;\n  if (archiveSize == 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 = (FILE *)extract_and_write_file_00105a20(*archive);\n  }\n  else {\n    bytesWritten = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      bytesToRead = archiveSize - bytesWritten;\n      if (0x2000 < bytesToRead) {\n        bytesToRead = 0x2000;\n      }\n      bytesRead = bfd_bread(buffer,bytesToRead,archive);\n      if (bytesToRead != bytesRead) {\nLAB_00102c78:\n        archive = (long **)*archive[0x1d];\n        errorString = dcgettext(0,\"%s is not a valid archive\",5);\n        handle_error_00107690(errorString,archive);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 == (FILE *)0x0) {\n        DAT_0010d5d8 = (FILE *)extract_and_write_file_00105a20(*archive);\n      }\n      bytesToRead = fwrite(buffer,1,bytesRead,DAT_0010d5d8);\n      if (bytesToRead != bytesRead) {\n        errorNumber = __errno_location();\n        errorMessage = strerror(*errorNumber);\n        handle_error_00107690(\"%s: %s\",DAT_0010d618,errorMessage);\n        goto LAB_00102c78;\n      }\n      bytesWritten = bytesWritten + bytesRead;\n    } while (bytesWritten < archiveSize);\n    free(buffer);\n  }\n  fclose(DAT_0010d5d8);\n  errorMessage = DAT_0010d618;\n  DAT_0010d5d8 = (FILE *)0x0;\n  chmod(DAT_0010d618,filePermissions);\n  if (_DAT_0010d600 != 0) {\n    fileModificationTime = fileAccessTime;\n    set_file_time_00107c80(errorMessage,localArray);\n  }\n  DAT_0010d618 = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "FUN_00102c25"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107740",
            "calling": [
                "FUN_00105db0",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "extract_and_write_archive_00107740"
        },
        "FUN_00102d2f": {
            "renaming": {
                "FUN_00102d2f": "print_file_info_00102d2f",
                "__format": "timeFormat",
                "unaff_RBX": "fileContents",
                "unaff_RBP": "outputFile",
                "unaff_R12": "flag1",
                "unaff_R13": "allocatedMemory",
                "unaff_R14D": "fileDescriptor",
                "uStack0000000000000068": "filePermissions",
                "uStack000000000000006c": "inodeNumber",
                "in_stack_00000070": "fileSize",
                "in_stack_00000080": "timestamp"
            },
            "code": "\nvoid printFileInfo_00102d2f(void)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  char *timeFormat;\n  uint uVar4;\n  char **fileContents;\n  FILE *outputFile;\n  long flag1;\n  void *allocatedMemory;\n  int fileDescriptor;\n  undefined uStack0000000000000015;\n  char cStack0000000000000016;\n  char cStack0000000000000017;\n  char in_stack_00000018;\n  char cStack0000000000000019;\n  char cStack000000000000001a;\n  char cStack000000000000001b;\n  char cStack000000000000001c;\n  char cStack000000000000001d;\n  char cStack000000000000001e;\n  undefined uStack000000000000001f;\n  uint filePermissions;\n  uint inodeNumber;\n  uint fileSize;\n  undefined8 timestamp;\n  \n  do {\n    bVar1 = handle_error_and_exit_00107c10();\n    *(uint *)((long)fileContents + 0x44) = *(uint *)((long)fileContents + 0x44) | 0x100000;\n    if ((DAT_0010d5f8 != '\\0') || ((*(byte *)(flag1 + 0x49) & 0x10) != 0)) {\n      *(byte *)((long)fileContents + 0x49) = bVar1 | 0x10;\n    }\n    cVar2 = bfd_set_archive_head();\n  } while (cVar2 == '\\0');\n  dup(fileDescriptor);\n  cVar2 = bfd_close();\n  if (cVar2 != '\\0') {\n    DAT_0010d5e0 = 0;\n    DAT_0010d618 = 0;\n    bfd_close();\n    iVar3 = copy_and_remove_file_00105bc0();\n    if (iVar3 == 0) {\n      free(allocatedMemory);\n      free(outputFile);\n      return;\n    }\n                    \n    xexit(1);\n  }\n  handle_error_and_exit_00107c10();\n  timeFormat = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,timeFormat);\n  uVar4 = filePermissions & 0xf000;\n  if (uVar4 == 0x4000) {\n    uStack0000000000000015 = 100;\n  }\n  else if (uVar4 == 0xa000) {\n    uStack0000000000000015 = 0x6c;\n  }\n  else if (uVar4 == 0x6000) {\n    uStack0000000000000015 = 0x62;\n  }\n  else if (uVar4 == 0x2000) {\n    uStack0000000000000015 = 99;\n  }\n  else if (uVar4 == 0xc000) {\n    uStack0000000000000015 = 0x73;\n  }\n  else {\n    uStack0000000000000015 = 0x70;\n    if (uVar4 != 0x1000) {\n      uStack0000000000000015 = 0x2d;\n    }\n  }\n  cStack0000000000000016 = (-((filePermissions & 0x100) == 0) & 0xbbU) + 0x72;\n  cStack0000000000000017 = (-((filePermissions & 0x80) == 0) & 0xb6U) + 0x77;\n  in_stack_00000018 = (-((filePermissions & 0x40) == 0) & 0xb5U) + 0x78;\n  cStack0000000000000019 = (-((filePermissions & 0x20) == 0) & 0xbbU) + 0x72;\n  cStack000000000000001a = (-((filePermissions & 0x10) == 0) & 0xb6U) + 0x77;\n  cStack000000000000001b = (-((filePermissions & 8) == 0) & 0xb5U) + 0x78;\n  cStack000000000000001c = (-((filePermissions & 4) == 0) & 0xbbU) + 0x72;\n  cStack000000000000001d = (-((filePermissions & 2) == 0) & 0xb6U) + 0x77;\n  cStack000000000000001e = (-((filePermissions & 1) == 0) & 0xb5U) + 0x78;\n  if ((filePermissions & 0x800) != 0) {\n    if (in_stack_00000018 == 'x') {\n      in_stack_00000018 = 's';\n    }\n    else {\n      in_stack_00000018 = 'S';\n    }\n  }\n  if ((filePermissions & 0x400) != 0) {\n    if (cStack000000000000001b == 'x') {\n      cStack000000000000001b = 's';\n    }\n    else {\n      cStack000000000000001b = 'S';\n    }\n  }\n  if ((filePermissions & 0x200) != 0) {\n    if (cStack000000000000001e == 'x') {\n      cStack000000000000001e = 't';\n    }\n    else {\n      cStack000000000000001e = 'T';\n    }\n  }\n  uStack000000000000001f = 0;\n  fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)inodeNumber,\n          (ulong)fileSize,timestamp,&stack0x00000020,(ulong)filePermissions)\n  ;\n  fputs(*fileContents,outputFile);\n  if ((char)flag1 != '\\0') {\n    if ((*(byte *)((long)fileContents + 0x49) & 0x10) == 0) {\n      if (fileContents[0xb] != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (fileContents[0xc] != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "free",
                "dup",
                "FUN_00107c10",
                "xexit",
                "FUN_00105bc0",
                "bfd_close",
                "bfd_set_archive_head",
                "FUN_00102d2f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d2f",
            "calling": [
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "print_file_info_00102d2f"
        },
        "FUN_001028ed": {
            "renaming": {
                "FUN_001028ed": "search_and_extract_files_001028ed",
                "param_1": "filename",
                "param_2": "fileSize",
                "uVar1": "undefinedVar1",
                "bVar2": "byteVar2",
                "iVar3": "integerVar3",
                "sVar4": "sizeVar4",
                "piVar5": "pointerVar5",
                "pcVar6": "charVar6",
                "pcVar7": "charVar7",
                "ppcVar8": "pointerPointerVar8",
                "uVar9": "undefinedVar9",
                "lVar10": "longVar10",
                "__s": "str1",
                "__s_00": "str2",
                "lVar11": "longVar11",
                "uVar12": "undefinedVar12",
                "uVar13": "ulongVar13",
                "unaff_RBX": "unaffectedRBX",
                "ppcVar14": "pointerPointerVar14",
                "unaff_RBP": "unaffectedRBP",
                "unaff_R12": "unaffectedR12",
                "unaff_R13D": "unaffectedR13D",
                "ppcVar15": "pointerPointerVar15",
                "unaff_R14": "unaffectedR14",
                "bVar16": "boolVar16",
                "bVar17": "byteVar17",
                "param_7": "filelist",
                "param_9": "result",
                "in_stack_00000078": "stackItem1",
                "in_stack_00000108": "stackItem2"
            },
            "code": "\n\n\nundefined8 searchAndExtractFiles_001028ed(undefined8 filename,long fileSize)\n\n{\n  undefined undefinedVar1;\n  byte byteVar2;\n  int integerVar3;\n  size_t sizeVar4;\n  int *pointerVar5;\n  char *charVar6;\n  char *charVar7;\n  char **pointerPointerVar8;\n  undefined8 undefinedVar9;\n  long longVar10;\n  char *str1;\n  char *str2;\n  long longVar11;\n  undefined8 undefinedVar12;\n  ulong ulongVar13;\n  char *unaffectedRBX;\n  char **pointerPointerVar14;\n  char **unaffectedRBP;\n  char **unaffectedR12;\n  uint unaffectedR13D;\n  char **pointerPointerVar15;\n  long unaffectedR14;\n  bool boolVar16;\n  byte byteVar17;\n  char **filelist;\n  undefined8 result;\n  long stackItem1;\n  long stackItem2;\n  \n  byteVar17 = 0;\ncode_r0x001028ed:\n  handle_error_and_exit_00107c10(unaffectedRBX,fileSize);\nLAB_001028f5:\n  undefinedVar12 = DAT_0010d638;\n  if (unaffectedR13D != 3) {\n    while( true ) {\n      if ((undefined8 *)*unaffectedR12 == (undefined8 *)0x0) goto LAB_0010571f;\n      integerVar3 = filename_cmp(*(undefined8 *)*unaffectedR12,undefinedVar12);\n      if (integerVar3 == 0) break;\n      unaffectedR12 = (char **)(*unaffectedR12 + 0xf0);\n    }\n    if (unaffectedR13D != 2) goto LAB_0010571f;\n    unaffectedR12 = (char **)(*unaffectedR12 + 0xf0);\n    goto LAB_0010571f;\n  }\n  longVar10 = *(long *)(unaffectedR14 + 0xf0);\n  if (*(long *)(unaffectedR14 + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n  do {\n    longVar11 = longVar10;\n    longVar10 = *(long *)(longVar11 + 0xf0);\n  } while (longVar10 != 0);\n  unaffectedR12 = (char **)(longVar11 + 0xf0);\n  unaffectedRBX = *unaffectedRBP;\n  if (DAT_0010d620 != 0) goto LAB_00105731;\nLAB_00105698:\n  undefinedVar1 = DAT_0010d5f8;\n  unaffectedR13D = (uint)(DAT_0010d60c != 0);\n  fileSize = bfd_openr(unaffectedRBX,DAT_0010d5f0);\n  if (fileSize != 0) {\n    unaffectedRBP = unaffectedRBP + 1;\n    byteVar2 = extract_archived_files_00105af0(unaffectedR12,fileSize,unaffectedR13D,undefinedVar1);\n    result._6_1_ = result._6_1_ | byteVar2;\n    charVar6 = *unaffectedRBP;\n    do {\n      if (charVar6 == (char *)0x0) {\n        if (result._6_1_ == 0) {\n          DAT_0010d618 = 0;\n          return 0;\n        }\n        undefinedVar12 = generate_archive_listing_001058b0();\n        return undefinedVar12;\n      }\n      pointerPointerVar14 = *(char ***)(unaffectedR14 + 0xf0);\n      unaffectedR12 = filelist;\n      if (result._7_1_ == '\\0') {\n        pointerPointerVar15 = filelist;\n        if (pointerPointerVar14 != (char **)0x0) {\n          do {\n            if (DAT_0010d5f9 == '\\0') {\n              str1 = (char *)lbasename(*pointerPointerVar14);\n              charVar7 = str1;\n              if (DAT_0010d5fa != '\\0') {\n                sizeVar4 = strlen(str1);\n                ulongVar13 = (ulong)*(byte *)(*(long *)(unaffectedR14 + 8) + 0x1e);\n                if (ulongVar13 < sizeVar4) {\n                  charVar7 = (char *)xmalloc(ulongVar13 + 1);\n                  longVar10 = *(long *)(unaffectedR14 + 8);\n                  charVar6 = charVar7;\n                  for (ulongVar13 = (ulong)*(byte *)(longVar10 + 0x1e); ulongVar13 != 0; ulongVar13 = ulongVar13 - 1) {\n                    *charVar6 = *str1;\n                    str1 = str1 + (ulong)byteVar17 * -2 + 1;\n                    charVar6 = charVar6 + (ulong)byteVar17 * -2 + 1;\n                  }\n                  charVar7[*(byte *)(longVar10 + 0x1e)] = '\\0';\n                }\n                charVar6 = *unaffectedRBP;\n                str1 = charVar7;\n                if (DAT_0010d5f9 == '\\0') goto LAB_00105611;\n                goto LAB_00102980;\n              }\n              charVar6 = *unaffectedRBP;\n              if (DAT_0010d5f9 != '\\0') goto LAB_00102980;\nLAB_00105611:\n              str2 = (char *)lbasename(charVar6);\n              if (DAT_0010d5fa != '\\0') {\n                sizeVar4 = strlen(str2);\n                ulongVar13 = (ulong)*(byte *)(*(long *)(unaffectedR14 + 8) + 0x1e);\n                charVar6 = str2;\n                str1 = charVar7;\n                if (ulongVar13 < sizeVar4) {\n                  charVar6 = (char *)xmalloc(ulongVar13 + 1);\n                  longVar10 = *(long *)(unaffectedR14 + 8);\n                  charVar7 = charVar6;\n                  for (ulongVar13 = (ulong)*(byte *)(longVar10 + 0x1e); ulongVar13 != 0; ulongVar13 = ulongVar13 - 1) {\n                    *charVar7 = *str2;\n                    str2 = str2 + (ulong)byteVar17 * -2 + 1;\n                    charVar7 = charVar7 + (ulong)byteVar17 * -2 + 1;\n                  }\n                  charVar6[*(byte *)(longVar10 + 0x1e)] = '\\0';\n                }\n                goto LAB_00102980;\n              }\n              integerVar3 = filename_cmp(str2,charVar7);\n            }\n            else {\n              charVar6 = *unaffectedRBP;\n              str1 = *pointerPointerVar14;\nLAB_00102980:\n              integerVar3 = filename_cmp(charVar6,str1);\n            }\n            if ((integerVar3 == 0) && (pointerPointerVar14[0x1c] != (char *)0x0)) {\n              if (_DAT_0010d644 != 0) {\n                integerVar3 = stat(*unaffectedRBP,(stat *)&stack0x000000b0);\n                if (integerVar3 != 0) {\n                  pointerVar5 = __errno_location();\n                  if (*pointerVar5 != 2) {\n                    handle_error_and_exit_00107c10(*unaffectedRBP);\nLAB_00102b7e:\n                    charVar6 = *pointerPointerVar14;\n                    undefinedVar12 = dcgettext(0,\"internal stat error on %s\",5);\n                    handle_error_00107690(undefinedVar12,charVar6);\n                    free(unaffectedRBP);\n                    return 0;\n                  }\n                  goto LAB_0010577e;\n                }\n                pointerPointerVar8 = (char **)pointerPointerVar14[0x1d];\n                if ((char **)pointerPointerVar14[0x1d] == (char **)0x0) {\n                  pointerPointerVar8 = pointerPointerVar14;\n                }\n                integerVar3 = (**(code **)(pointerPointerVar8[1] + 0x1e8))(pointerPointerVar14,&stack0x00000020);\n                if (integerVar3 != 0) goto LAB_00102b7e;\n                if (stackItem2 <= stackItem1) goto LAB_0010577e;\n              }\n              undefinedVar12 = find_matching_entry_00105870(filelist,2,*pointerPointerVar14);\n              if (DAT_0010d620 == 0) {\nLAB_00102ae2:\n                charVar6 = *unaffectedRBP;\n                boolVar16 = DAT_0010d60c != 0;\n                longVar10 = bfd_openr(charVar6,DAT_0010d5f0);\n                if (longVar10 == 0) {\n                  handle_error_and_exit_00107c10(charVar6,0);\n                  goto LAB_00102b3e;\n                }\n                byteVar2 = copy_and_print_string_00103172(undefinedVar12,longVar10,boolVar16);\n              }\n              else {\n                undefinedVar9 = extract_sub_string_00105830(*unaffectedRBP);\n                integerVar3 = filename_cmp(undefinedVar9,\"__.LIBDEP\");\n                if (integerVar3 != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n                byteVar2 = copy_and_print_string_00103172(undefinedVar12,DAT_0010d620,DAT_0010d60c != 0);\n              }\n              if (byteVar2 != 0) {\n                *pointerPointerVar15 = *(char **)(*pointerPointerVar15 + 0xf0);\n                result._6_1_ = byteVar2;\n              }\n              goto LAB_0010577e;\n            }\n            pointerPointerVar15 = pointerPointerVar14 + 0x1e;\n            pointerPointerVar14 = (char **)pointerPointerVar14[0x1e];\n          } while (pointerPointerVar14 != (char **)0x0);\n          goto LAB_0010564c;\n        }\n        unaffectedR13D = DAT_0010d640;\n        if (DAT_0010d640 != 0) goto LAB_001028f5;\n      }\n      else {\nLAB_0010564c:\n        unaffectedR13D = DAT_0010d640;\n        if (DAT_0010d640 != 0) goto LAB_001028f5;\n        longVar10 = *(long *)(unaffectedR14 + 0xf0);\n        if (*(long *)(unaffectedR14 + 0xf0) != 0) goto LAB_00105670;\n      }\nLAB_0010571f:\n      unaffectedRBX = *unaffectedRBP;\n      if (DAT_0010d620 == 0) goto LAB_00105698;\nLAB_00105731:\n      undefinedVar12 = extract_sub_string_00105830(unaffectedRBX);\n      integerVar3 = filename_cmp(undefinedVar12,\"__.LIBDEP\");\n      if (integerVar3 != 0) goto code_r0x0010574f;\n      byteVar2 = extract_and_archive_files_00105ae0(unaffectedR12,DAT_0010d620,DAT_0010d60c != 0,DAT_0010d5f8);\n      result._6_1_ = byteVar2 | result._6_1_;\nLAB_0010577e:\n      unaffectedRBP = unaffectedRBP + 1;\n      charVar6 = *unaffectedRBP;\n    } while( true );\n  }\n  goto code_r0x001028ed;\ncode_r0x0010574f:\n  unaffectedRBX = *unaffectedRBP;\n  goto LAB_00105698;\n}\n\n",
            "called": [
                "FUN_00105ae0",
                "FUN_00105870",
                "FUN_00107c10",
                "FUN_00105830",
                "bfd_openr",
                "dcgettext",
                "FUN_00105af0",
                "FUN_00107690",
                "FUN_00102943",
                "FUN_001058b0",
                "stat",
                "strlen",
                "FUN_00103172",
                "filename_cmp",
                "lbasename",
                "xmalloc",
                "__errno_location",
                "FUN_001028ed"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001028ed",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "search_and_extract_files_001028ed"
        },
        "clearerr": {
            "renaming": {},
            "code": "\n\n\nvoid clearerr(FILE *__stream)\n\n{\n  clearerr(__stream);\n  return;\n}\n\n",
            "called": [
                "clearerr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "clearerr"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "FUN_00102bf5",
                "FUN_00105db0",
                "FUN_00103e95",
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "bfd_errmsg": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024d0",
            "calling": [
                "FUN_00107c20",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_errmsg"
        },
        "FUN_001033b0": {
            "renaming": {
                "FUN_001033b0": "print_error_message_and_exit_001033b0",
                "param_1": "errorMessage",
                "_stderr": "errorStream"
            },
            "code": "\n\n\nvoid printErrorMessageAndExit_001033b0(undefined8 errorMessage)\n\n{\n  fprintf(errorStream,\"%s\\n\",errorMessage);\n                    \n  exit(2);\n}\n\n",
            "called": [
                "fprintf",
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033b0",
            "calling": [
                "FUN_00103df9",
                "FUN_001033d6",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "print_error_message_and_exit_001033b0"
        },
        "fwrite": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102510",
            "calling": [
                "FUN_00103e95",
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "fwrite"
        },
        "unlink": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "FUN_00102f1e",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "unlink"
        },
        "unlink_if_ordinary": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "FUN_00102bf5"
            ],
            "imported": false,
            "current_name": "unlink_if_ordinary"
        },
        "FUN_001025a0": {
            "renaming": {
                "FUN_001025a0": "FUNC_001025a0"
            },
            "code": "\nundefined8 FUNC_001025a0(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 = __errno_location();\n  if (*piVar1 == 2) {\n    uVar2 = dcgettext(0,\"\\'%s\\': No such file\",5);\n    print_error_message_00107920(uVar2);\n  }\n  else {\n    strerror(*piVar1);\n    uVar2 = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    print_error_message_00107920(uVar2);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "dcgettext",
                "__errno_location",
                "strerror",
                "FUN_00107920"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001025a0",
            "calling": [
                "FUN_001052a0"
            ],
            "imported": false,
            "current_name": "FUNC_001025a0"
        },
        "FUN_0010284b": {
            "renaming": {
                "FUN_0010284b": "get_return_value_0010284b",
                "undefined8": "int64"
            },
            "code": "\nint64 getReturnValue_0010284b(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010284b",
            "calling": [
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "get_return_value_0010284b"
        },
        "FUN_00102c25": {
            "renaming": {
                "FUN_00102c25": "extract_and_write_archive_00102c25",
                "param_7": "permissions",
                "param_11": "mode",
                "param_12": "archiveSize",
                "plVar8": "currentFile",
                "pplVar6": "errorHandler",
                "__ptr": "buffer",
                "__n": "bytesRead",
                "lVar7": "loopCounter",
                "iVar2": "errorCode",
                "uVar5": "translationString",
                "puVar9": "paramPtr",
                "uVar10": "bytesProcessed",
                "sVar11": "bytesToRead",
                "piVar3": "errnoLocation",
                "pcVar4": "errorString",
                "iVar1": "cmpResult"
            },
            "code": "\n\n\nlong * extractAndWriteArchive_00102c25(void)\n\n{\n  int cmpResult;\n  int errorCode;\n  int *errnoLocation;\n  char *errorString;\n  undefined8 translationString;\n  long **errorHandler;\n  void *buffer;\n  size_t bytesRead;\n  long loopCounter;\n  long **unaff_RBX;\n  long *currentFile;\n  undefined4 *paramPtr;\n  ulong bytesProcessed;\n  size_t bytesToRead;\n  undefined4 *permissions;\n  __mode_t mode;\n  ulong archiveSize;\n  \n  paramPtr = permissions;\n  for (loopCounter = 0x24; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *paramPtr = 0;\n    paramPtr = paramPtr + 1;\n  }\n  errorHandler = (long **)unaff_RBX[0x1d];\n  if ((long **)unaff_RBX[0x1d] == (long **)0x0) {\n    errorHandler = unaff_RBX;\n  }\n  errorCode = (*(code *)errorHandler[1][0x3d])();\n  if (errorCode != 0) {\n    currentFile = *unaff_RBX;\n    translationString = dcgettext(0,\"internal stat error on %s\",5);\n    errorCode = handle_error_00107690(translationString,currentFile);\n    translationString = DAT_0010d638;\n    if (errorCode == 3) {\n      for (; *currentFile != 0; currentFile = (long *)(*currentFile + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*currentFile != (undefined8 *)0x0; currentFile = (long *)(*currentFile + 0xf0)) {\n        cmpResult = filename_cmp(*(undefined8 *)*currentFile,translationString);\n        if (cmpResult == 0) {\n          if (errorCode != 2) {\n            return currentFile;\n          }\n          return (long *)(*currentFile + 0xf0);\n        }\n      }\n    }\n    return currentFile;\n  }\n  bfd_seek();\n  DAT_0010d5d8 = (FILE *)0x0;\n  if (archiveSize == 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 = (FILE *)extract_and_write_file_00105a20(*unaff_RBX);\n  }\n  else {\n    bytesProcessed = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      bytesToRead = archiveSize - bytesProcessed;\n      if (0x2000 < bytesToRead) {\n        bytesToRead = 0x2000;\n      }\n      bytesRead = bfd_bread(buffer,bytesToRead);\n      if (bytesToRead != bytesRead) {\nLAB_00102c78:\n        unaff_RBX = (long **)*unaff_RBX[0x1d];\n        translationString = dcgettext(0,\"%s is not a valid archive\",5);\n        handle_error_00107690(translationString,unaff_RBX);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 == (FILE *)0x0) {\n        DAT_0010d5d8 = (FILE *)extract_and_write_file_00105a20(*unaff_RBX);\n      }\n      bytesToRead = fwrite(buffer,1,bytesRead,DAT_0010d5d8);\n      if (bytesToRead != bytesRead) {\n        errnoLocation = __errno_location();\n        errorString = strerror(*errnoLocation);\n        handle_error_00107690(\"%s: %s\",DAT_0010d618,errorString);\n        goto LAB_00102c78;\n      }\n      bytesProcessed = bytesProcessed + bytesRead;\n    } while (bytesProcessed < archiveSize);\n    free(buffer);\n  }\n  fclose(DAT_0010d5d8);\n  errorString = DAT_0010d618;\n  DAT_0010d5d8 = (FILE *)0x0;\n  chmod(DAT_0010d618,mode);\n  if (_DAT_0010d600 != 0) {\n    set_file_time_00107c80(errorString,permissions);\n  }\n  DAT_0010d618 = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "dcgettext",
                "bfd_bread",
                "FUN_00107690",
                "fclose",
                "strerror",
                "fwrite",
                "FUN_00107c80",
                "free",
                "xmalloc",
                "bfd_seek",
                "__errno_location",
                "FUN_00105a20",
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c25",
            "calling": [
                "FUN_00107740"
            ],
            "imported": false,
            "current_name": "extract_and_write_archive_00102c25"
        },
        "bfd_plugin_set_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_program_name"
        },
        "bfd_bwrite": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_bwrite"
        },
        "FUN_00102bb0": {
            "renaming": {
                "FUN_00102bb0": "process_string_00102bb0",
                "in_RAX": "inputString",
                "sVar2": "inputLength",
                "puVar3": "processedString",
                "uVar4": "truncateLength",
                "unaff_RBX": "sourcePointer",
                "unaff_RBP": "framePointer",
                "puVar5": "destinationPointer",
                "bVar6": "byteVar",
                "auVar7": "returnValue",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] processString_00102bb0(void)\n\n{\n  long lVar1;\n  char *inputString;\n  size_t inputLength;\n  undefined *processedString;\n  ulong truncateLength;\n  undefined *sourcePointer;\n  long framePointer;\n  undefined *destinationPointer;\n  byte byteVar;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  byteVar = 0;\n  inputLength = strlen(inputString);\n  truncateLength = (ulong)*(byte *)(*(long *)(framePointer + 8) + 0x1e);\n  processedString = sourcePointer;\n  if (truncateLength < inputLength) {\n    processedString = (undefined *)xmalloc(truncateLength + 1);\n    lVar1 = *(long *)(framePointer + 8);\n    destinationPointer = processedString;\n    for (truncateLength = (ulong)*(byte *)(lVar1 + 0x1e); truncateLength != 0; truncateLength = truncateLength - 1) {\n      *destinationPointer = *sourcePointer;\n      sourcePointer = sourcePointer + (ulong)byteVar * -2 + 1;\n      destinationPointer = destinationPointer + (ulong)byteVar * -2 + 1;\n    }\n    processedString[*(byte *)(lVar1 + 0x1e)] = 0;\n  }\n  returnValue._8_8_ = returnAddress;\n  returnValue._0_8_ = processedString;\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bb0",
            "calling": [
                "FUN_00105830"
            ],
            "imported": false,
            "current_name": "process_string_00102bb0"
        },
        "utimensat": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "FUN_00107c80"
            ],
            "imported": false,
            "current_name": "utimensat"
        },
        "getc": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102560",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "getc"
        },
        "dup": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "FUN_00103e95",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "dup"
        },
        "FUN_00102f08": {
            "renaming": {
                "FUN_00102f08": "print_and_assign_00102f08",
                "unaff_RBX": "targetString",
                "unaff_R12": "sourceString"
            },
            "code": "\nundefined8 printAndAssign_00102f08(void)\n\n{\n  undefined8 *targetString;\n  undefined8 *sourceString;\n  \n  printf(\"a - %s\\n\",*targetString);\n  targetString[0x1e] = *sourceString;\n  *sourceString = targetString;\n  return 1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f08",
            "calling": [
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "print_and_assign_00102f08"
        },
        "FUN_00105570": {
            "renaming": {
                "FUN_00105570": "process_files_00105570",
                "param_1": "binary",
                "param_2": "file_paths",
                "param_3": "extract_and_print",
                "ppcVar1": "ptr_binary_info",
                "uVar2": "undefined_var",
                "bVar3": "byte_var",
                "iVar4": "index",
                "sVar5": "size",
                "piVar6": "ptr_errno",
                "pcVar7": "file_path",
                "pcVar8": "base_name",
                "uVar9": "extracted_string",
                "pcVar10": "current_file",
                "__s": "base_name_2",
                "lVar11": "prev_ptr_binary_info",
                "lVar12": "ptr_binary_info",
                "uVar13": "result",
                "uVar14": "ulong_var",
                "ppcVar15": "ptr_file_paths",
                "ppcVar16": "ptr_curr_binary_info",
                "uVar17": "uint_var",
                "ppcVar18": "ptr_prev_file_paths",
                "bVar19": "bool_var",
                "bVar20": "byte_var_2",
                "local_15a": "local_bool_var",
                "auStack_158": "stack_data_1",
                "lStack_100": "stack_data_2",
                "sStack_c8": "stack_stat_info"
            },
            "code": "\n\n\nundefined8 process_files_00105570(long binary,char **file_paths,char extract_and_print)\n\n{\n  char **ptr_binary_info;\n  undefined undefined_var;\n  byte byte_var;\n  int index;\n  size_t size;\n  int *ptr_errno;\n  char *file_path;\n  char *base_name;\n  undefined8 extracted_string;\n  char *current_file;\n  char *base_name_2;\n  long prev_ptr_binary_info;\n  long ptr_binary_info;\n  undefined8 result;\n  ulong ulong_var;\n  char **ptr_file_paths;\n  char **ptr_curr_binary_info;\n  uint uint_var;\n  char **ptr_prev_file_paths;\n  bool bool_var;\n  byte byte_var_2;\n  byte local_bool_var;\n  undefined stack_data_1 [88];\n  long stack_data_2;\n  stat stack_stat_info;\n  \n  byte_var_2 = 0;\n  ptr_binary_info = (char **)(binary + 0xf0);\n  local_bool_var = 0;\n  if (file_paths == (char **)0x0) {\n    result = clear_data_00102943();\n    return result;\n  }\n  do {\n    current_file = *file_paths;\njoined_r0x001055aa:\n    if (current_file == (char *)0x0) {\n      if (local_bool_var != 0) {\n        result = generate_archive_listing_001058b0(binary);\n        return result;\n      }\n      DAT_0010d618 = 0;\n      return 0;\n    }\n    ptr_file_paths = *(char ***)(binary + 0xf0);\n    ptr_curr_binary_info = ptr_binary_info;\n    if (extract_and_print != '\\0') {\nLAB_0010564c:\n      uint_var = DAT_0010d640;\n      if (DAT_0010d640 != 0) goto LAB_001028f5;\n      ptr_binary_info = *(long *)(binary + 0xf0);\n      if (*(long *)(binary + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n      do {\n        prev_ptr_binary_info = ptr_binary_info;\n        ptr_binary_info = *(long *)(prev_ptr_binary_info + 0xf0);\n      } while (ptr_binary_info != 0);\n      ptr_curr_binary_info = (char **)(prev_ptr_binary_info + 0xf0);\n      current_file = *file_paths;\n      do {\n        if (DAT_0010d620 != 0) {\n          result = extract_sub_string_00105830(current_file,binary);\n          index = filename_cmp(result,\"__.LIBDEP\");\n          if (index == 0) {\n            byte_var = extract_and_archive_files_00105ae0(ptr_curr_binary_info,DAT_0010d620,DAT_0010d60c != 0,DAT_0010d5f8);\n            local_bool_var = byte_var | local_bool_var;\n            goto LAB_0010577e;\n          }\n          current_file = *file_paths;\n        }\n        undefined_var = DAT_0010d5f8;\n        bool_var = DAT_0010d60c != 0;\n        ptr_binary_info = bfd_openr(current_file,DAT_0010d5f0);\n        if (ptr_binary_info != 0) {\n          file_paths = file_paths + 1;\n          byte_var = extract_archived_files_00105af0(ptr_curr_binary_info,ptr_binary_info,(uint)bool_var,undefined_var);\n          local_bool_var = local_bool_var | byte_var;\n          current_file = *file_paths;\n          goto joined_r0x001055aa;\n        }\n        handle_error_and_exit_00107c10(current_file,0);\n        uint_var = (uint)bool_var;\nLAB_001028f5:\n        result = DAT_0010d638;\n        if (uint_var == 3) {\n          ptr_binary_info = *(long *)(binary + 0xf0);\n          if (*(long *)(binary + 0xf0) != 0) goto LAB_00105670;\n        }\n        else {\n          for (; (undefined8 *)*ptr_curr_binary_info != (undefined8 *)0x0;\n              ptr_curr_binary_info = (char **)(*ptr_curr_binary_info + 0xf0)) {\n            index = filename_cmp(*(undefined8 *)*ptr_curr_binary_info,result);\n            if (index == 0) {\n              if (uint_var == 2) {\n                ptr_curr_binary_info = (char **)(*ptr_curr_binary_info + 0xf0);\n              }\n              break;\n            }\n          }\n        }\nLAB_0010571f:\n        current_file = *file_paths;\n      } while( true );\n    }\n    ptr_prev_file_paths = ptr_binary_info;\n    if (ptr_file_paths == (char **)0x0) {\n      uint_var = DAT_0010d640;\n      if (DAT_0010d640 == 0) goto LAB_0010571f;\n      goto LAB_001028f5;\n    }\nLAB_001055d8:\n    if (DAT_0010d5f9 == '\\0') {\n      current_file = (char *)lbasename(*ptr_file_paths);\n      base_name = current_file;\n      if (DAT_0010d5fa != '\\0') {\n        size = strlen(current_file);\n        ulong_var = (ulong)*(byte *)(*(long *)(binary + 8) + 0x1e);\n        if (ulong_var < size) {\n          base_name = (char *)xmalloc(ulong_var + 1);\n          ptr_binary_info = *(long *)(binary + 8);\n          file_path = base_name;\n          for (ulong_var = (ulong)*(byte *)(ptr_binary_info + 0x1e); ulong_var != 0; ulong_var = ulong_var - 1) {\n            *file_path = *current_file;\n            current_file = current_file + (ulong)byte_var_2 * -2 + 1;\n            file_path = file_path + (ulong)byte_var_2 * -2 + 1;\n          }\n          base_name[*(byte *)(ptr_binary_info + 0x1e)] = '\\0';\n        }\n        file_path = *file_paths;\n        current_file = base_name;\n        if (DAT_0010d5f9 == '\\0') goto LAB_00105611;\n        goto LAB_00102980;\n      }\n      file_path = *file_paths;\n      if (DAT_0010d5f9 != '\\0') goto LAB_00102980;\nLAB_00105611:\n      base_name_2 = (char *)lbasename(file_path);\n      if (DAT_0010d5fa != '\\0') {\n        size = strlen(base_name_2);\n        ulong_var = (ulong)*(byte *)(*(long *)(binary + 8) + 0x1e);\n        file_path = base_name_2;\n        current_file = base_name;\n        if (ulong_var < size) {\n          file_path = (char *)xmalloc(ulong_var + 1);\n          ptr_binary_info = *(long *)(binary + 8);\n          base_name = file_path;\n          for (ulong_var = (ulong)*(byte *)(ptr_binary_info + 0x1e); ulong_var != 0; ulong_var = ulong_var - 1) {\n            *base_name = *base_name_2;\n            base_name_2 = base_name_2 + (ulong)byte_var_2 * -2 + 1;\n            base_name = base_name + (ulong)byte_var_2 * -2 + 1;\n          }\n          file_path[*(byte *)(ptr_binary_info + 0x1e)] = '\\0';\n        }\n        goto LAB_00102980;\n      }\n      index = filename_cmp(base_name_2,base_name);\n      if (index == 0) goto LAB_00102993;\nLAB_00105639:\n      ptr_prev_file_paths = ptr_file_paths + 0x1e;\n      ptr_file_paths = (char **)ptr_file_paths[0x1e];\n      if (ptr_file_paths == (char **)0x0) goto LAB_0010564c;\n      goto LAB_001055d8;\n    }\n    file_path = *file_paths;\n    current_file = *ptr_file_paths;\nLAB_00102980:\n    index = filename_cmp(file_path,current_file);\n    if (index != 0) goto LAB_00105639;\nLAB_00102993:\n    if (ptr_file_paths[0x1c] == (char *)0x0) goto LAB_00105639;\n    if (_DAT_0010d644 != 0) {\n      index = stat(*file_paths,&stack_stat_info);\n      if (index != 0) {\n        ptr_errno = __errno_location();\n        if (*ptr_errno != 2) {\n          handle_error_and_exit_00107c10(*file_paths);\nLAB_00102b7e:\n          current_file = *ptr_file_paths;\n          result = dcgettext(0,\"internal stat error on %s\",5);\n          handle_error_00107690(result,current_file);\n          free(file_paths);\n          return 0;\n        }\n        goto LAB_0010577e;\n      }\n      ptr_curr_binary_info = (char **)ptr_file_paths[0x1d];\n      if ((char **)ptr_file_paths[0x1d] == (char **)0x0) {\n        ptr_curr_binary_info = ptr_file_paths;\n      }\n      index = (**(code **)(ptr_curr_binary_info[1] + 0x1e8))(ptr_file_paths,stack_data_1);\n      if (index != 0) goto LAB_00102b7e;\n      if (stack_stat_info.st_mtim.tv_sec <= stack_data_2) goto LAB_0010577e;\n    }\n    result = find_matching_entry_00105870(ptr_binary_info,2,*ptr_file_paths);\n    if (DAT_0010d620 == 0) {\nLAB_00102ae2:\n      current_file = *file_paths;\n      bool_var = DAT_0010d60c != 0;\n      ptr_binary_info = bfd_openr(current_file,DAT_0010d5f0);\n      if (ptr_binary_info == 0) {\n        handle_error_and_exit_00107c10(current_file,0);\n        goto LAB_00102b3e;\n      }\n      byte_var = copy_and_print_string_00103172(result,ptr_binary_info,bool_var);\n    }\n    else {\n      extracted_string = extract_sub_string_00105830(*file_paths,binary);\n      index = filename_cmp(extracted_string,\"__.LIBDEP\");\n      if (index != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n      byte_var = copy_and_print_string_00103172(result,DAT_0010d620,DAT_0010d60c != 0);\n    }\n    if (byte_var != 0) {\n      *ptr_prev_file_paths = *(char **)(*ptr_prev_file_paths + 0xf0);\n      local_bool_var = byte_var;\n    }\nLAB_0010577e:\n    file_paths = file_paths + 1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00102943"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105570",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "process_files_00105570"
        }
    },
    "used_tokens": 90042,
    "layers": [
        [
            "FUN_00102cd9",
            "FUN_001079c0",
            "FUN_00105a68",
            "FUN_001032a8",
            "FUN_00102f96",
            "FUN_00105bb0",
            "FUN_00107640",
            "FUN_0010315d",
            "FUN_00103172",
            "FUN_00105870",
            "FUN_001030ed",
            "FUN_00103ba8",
            "FUN_001078c0",
            "FUN_001075e0",
            "FUN_001031a5",
            "FUN_00102bf5",
            "FUN_00102020",
            "FUN_00102943",
            "FUN_00105a20",
            "FUN_00102f55",
            "FUN_001057a0",
            "FUN_00102d8c",
            "FUN_00103bd1",
            "FUN_00107cc0",
            "FUN_0010266f",
            "FUN_00105830",
            "FUN_00107730",
            "FUN_00107c20",
            "FUN_0010312d",
            "FUN_0010336b",
            "FUN_00102e57",
            "FUN_0010300e",
            "FUN_00102ba1",
            "FUN_001033b0",
            "FUN_0010284b",
            "FUN_00102bb0",
            "FUN_00102f08"
        ],
        [
            "FUN_0010285f",
            "FUN_0010342d",
            "FUN_0010394a",
            "FUN_00107920",
            "FUN_00107890",
            "FUN_00103ddc",
            "FUN_00105480",
            "FUN_00103df9",
            "FUN_00107c10",
            "FUN_00107690",
            "FUN_001031cf",
            "FUN_00105c00",
            "FUN_00103c60"
        ],
        [
            "FUN_00102e6f",
            "FUN_001033d6",
            "FUN_00105bc0",
            "FUN_00102f1e",
            "FUN_00102fd7",
            "FUN_00103a78",
            "FUN_00107c80",
            "FUN_00102710",
            "FUN_001052a0",
            "FUN_001025a0"
        ],
        [
            "FUN_001058b0",
            "FUN_00105300",
            "FUN_00107740",
            "FUN_00102d2f",
            "FUN_00102c25"
        ],
        [
            "FUN_00107650",
            "FUN_00103e95"
        ],
        [
            "FUN_00105af0"
        ],
        [
            "FUN_00105ae0"
        ],
        [
            "FUN_001028ed",
            "FUN_00105570"
        ],
        [
            "FUN_00105db0"
        ]
    ],
    "locked_functions": []
}