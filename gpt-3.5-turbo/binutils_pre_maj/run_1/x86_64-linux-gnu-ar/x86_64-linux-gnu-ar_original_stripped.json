{
    "functions": {
        "FUN_00102cd9": {
            "renaming": {
                "FUN_00102cd9": "find_matching_pointer_00102cd9",
                "in_EAX": "condition",
                "iVar1": "comparisonResult",
                "unaff_RBX": "currentPointer",
                "param_7": "searchName"
            },
            "code": "\nlong * findMatchingPointer_00102cd9(void)\n\n{\n  int condition;\n  int comparisonResult;\n  long *currentPointer;\n  undefined8 searchName;\n  \n  searchName = posname;\n  if (condition == 3) {\n    for (; *currentPointer != 0; currentPointer = (long *)(*currentPointer + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*currentPointer != (undefined8 *)0x0; currentPointer = (long *)(*currentPointer + 0xf0)) {\n      comparisonResult = filename_cmp(*(undefined8 *)*currentPointer,searchName);\n      if (comparisonResult == 0) {\n        if (condition != 2) {\n          return currentPointer;\n        }\n        return (long *)(*currentPointer + 0xf0);\n      }\n    }\n  }\n  return currentPointer;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102cd9",
            "calling": [
                "get_pos_bfd"
            ],
            "imported": false,
            "current_name": "find_matching_pointer_00102cd9"
        },
        "FUN_001021b0": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001021b0"
        },
        "FUN_001079c0": {
            "renaming": {
                "FUN_001079c0": "print_file_info_001079c0",
                "param_1": "fileStream",
                "param_2": "fileInfo",
                "param_3": "printTime",
                "param_4": "printAddress",
                "iVar1": "result",
                "ppcVar2": "filePtr",
                "pcVar3": "timeStr",
                "uVar4": "fileModeOctal",
                "local_100": "fileTime",
                "uStack_f3": "fileTypeChar",
                "cStack_f2": "userRead",
                "cStack_f1": "userWrite",
                "cStack_f0": "userExec",
                "cStack_ef": "groupRead",
                "cStack_ee": "groupWrite",
                "cStack_ed": "groupExec",
                "cStack_ec": "otherRead",
                "cStack_eb": "otherWrite",
                "cStack_ea": "otherExec",
                "uStack_e9": "unused",
                "local_e8": "timeFormat",
                "local_b8": "unknownData",
                "uStack_a0": "fileModeFlags",
                "uStack_9c": "fileSizeHigh",
                "uStack_98": "fileSizeLow",
                "uStack_88": "fileInode",
                "local_60": "currentTime"
            },
            "code": "\nvoid printFileInfo_001079c0(FILE *fileStream,char **fileInfo,char printTime,char printAddress)\n\n{\n  int result;\n  char **filePtr;\n  char *timeStr;\n  uint fileModeOctal;\n  time_t fileTime;\n  undefined fileTypeChar;\n  char userRead;\n  char userWrite;\n  char userExec;\n  char groupRead;\n  char groupWrite;\n  char groupExec;\n  char otherRead;\n  char otherWrite;\n  char otherExec;\n  undefined unused;\n  char timeFormat [48];\n  undefined unknownData [24];\n  uint fileModeFlags;\n  uint fileSizeHigh;\n  uint fileSizeLow;\n  undefined8 fileInode;\n  time_t currentTime;\n  \n  if (printTime != '\\0') {\n    filePtr = (char **)fileInfo[0x1d];\n    if ((char **)fileInfo[0x1d] == (char **)0x0) {\n      filePtr = fileInfo;\n    }\n    result = (**(code **)(filePtr[1] + 0x1e8))(fileInfo,unknownData);\n    if (result == 0) {\n      fileTime = currentTime;\n      timeStr = ctime(&fileTime);\n      if (timeStr == (char *)0x0) {\n        timeStr = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(timeFormat,timeStr);\n      }\n      else {\n        sprintf(timeFormat,\"%.12s %.4s\",timeStr + 4);\n      }\n      fileModeOctal = fileModeFlags & 0xf000;\n      if (fileModeOctal == 0x4000) {\n        fileTypeChar = 100;\n      }\n      else if (fileModeOctal == 0xa000) {\n        fileTypeChar = 0x6c;\n      }\n      else if (fileModeOctal == 0x6000) {\n        fileTypeChar = 0x62;\n      }\n      else if (fileModeOctal == 0x2000) {\n        fileTypeChar = 99;\n      }\n      else if (fileModeOctal == 0xc000) {\n        fileTypeChar = 0x73;\n      }\n      else {\n        fileTypeChar = 0x70;\n        if (fileModeOctal != 0x1000) {\n          fileTypeChar = 0x2d;\n        }\n      }\n      userRead = (-((fileModeFlags & 0x100) == 0) & 0xbbU) + 0x72;\n      userWrite = (-((fileModeFlags & 0x80) == 0) & 0xb6U) + 0x77;\n      userExec = (-((fileModeFlags & 0x40) == 0) & 0xb5U) + 0x78;\n      groupRead = (-((fileModeFlags & 0x20) == 0) & 0xbbU) + 0x72;\n      groupWrite = (-((fileModeFlags & 0x10) == 0) & 0xb6U) + 0x77;\n      groupExec = (-((fileModeFlags & 8) == 0) & 0xb5U) + 0x78;\n      otherRead = (-((fileModeFlags & 4) == 0) & 0xbbU) + 0x72;\n      otherWrite = (-((fileModeFlags & 2) == 0) & 0xb6U) + 0x77;\n      otherExec = (-((fileModeFlags & 1) == 0) & 0xb5U) + 0x78;\n      if ((fileModeFlags & 0x800) != 0) {\n        if (userExec == 'x') {\n          userExec = 's';\n        }\n        else {\n          userExec = 'S';\n        }\n      }\n      if ((fileModeFlags & 0x400) != 0) {\n        if (groupExec == 'x') {\n          groupExec = 's';\n        }\n        else {\n          groupExec = 'S';\n        }\n      }\n      if ((fileModeFlags & 0x200) != 0) {\n        if (otherExec == 'x') {\n          otherExec = 't';\n        }\n        else {\n          otherExec = 'T';\n        }\n      }\n      unused = 0;\n      fprintf(fileStream,\"%s %ld/%ld %6lu %s \",&userRead,(ulong)fileSizeHigh,(ulong)fileSizeLow,fileInode,\n              timeFormat,(ulong)fileModeFlags);\n    }\n  }\n  fputs(*fileInfo,fileStream);\n  if (printAddress != '\\0') {\n    if ((*(byte *)((long)fileInfo + 0x49) & 0x10) == 0) {\n      if (fileInfo[0xb] != (char *)0x0) {\n        fprintf(fileStream,\" 0x%lx\");\n      }\n    }\n    else if (fileInfo[0xc] != (char *)0x0) {\n      fprintf(fileStream,\" 0x%lx\");\n    }\n  }\n  fputc(10,fileStream);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr.cold",
                "ctime",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001079c0",
            "calling": [
                "ar_directory_doer",
                "print_descr"
            ],
            "imported": false,
            "current_name": "print_file_info_001079c0"
        },
        "FUN_00105a68": {
            "renaming": {
                "FUN_00105a68": "initialize_output_and_open_file_00105a68",
                "pcVar1": "outputDirectory",
                "pFVar2": "outputFilePointer",
                "sVar3": "outputDirLength"
            },
            "code": "\nvoid initializeOutputAndOpenFile_00105a68(void)\n\n{\n  char *outputDirectory;\n  FILE *outputFilePointer;\n  size_t outputDirLength;\n  \n  outputDirectory = output_dir;\n  if (output_dir != (char *)0x0) {\n    outputDirLength = strlen(output_dir);\n    if (outputDirLength != 0) {\n      if (outputDirectory[outputDirLength - 1] == '/') {\n        output_filename = (char *)concat(outputDirectory,output_filename,0);\n      }\n      else {\n        output_filename = (char *)concat(outputDirectory,&DAT_00108260,output_filename,0);\n      }\n    }\n  }\n  if (verbose != 0) {\n    printf(\"x - %s\\n\",output_filename);\n  }\n  outputFilePointer = fopen(output_filename,\"w\");\n  if (outputFilePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(output_filename);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "strlen",
                "open_output_file.isra.0.cold",
                "perror",
                "printf",
                "fopen",
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a68",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "initialize_output_and_open_file_00105a68"
        },
        "FUN_001022d0": {
            "renaming": {},
            "code": "\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(__nmemb,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "yyensure_buffer_stack"
            ],
            "imported": false,
            "current_name": "FUN_001022d0"
        },
        "FUN_001023f0": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001023f0"
        },
        "FUN_001032a8": {
            "renaming": {
                "FUN_001032a8": "process_archive_001032a8",
                "param_1": "archive_entries",
                "param_2": "callback_function",
                "param_3": "entry_names",
                "param_4": "return_value",
                "lVar1": "next_entry",
                "uVar2": "current_entry",
                "bVar3": "entry_found",
                "plVar4": "current_entry_ptr",
                "iVar5": "comparison_result",
                "__format": "error_format",
                "plVar6": "next_entry_ptr",
                "lVar7": "current_entry_address",
                "plVar8": "previous_entry_ptr"
            },
            "code": "\n\n\nundefined8 process_archive_001032a8(long *archive_entries,code *callback_function,undefined8 *entry_names,undefined8 return_value)\n\n{\n  long next_entry;\n  undefined8 current_entry;\n  bool entry_found;\n  long *current_entry_ptr;\n  int comparison_result;\n  char *error_format;\n  long *next_entry_ptr;\n  long current_entry_address;\n  long *previous_entry_ptr;\n  \n  current_entry_address = archive_entries[0x1e];\n  if (entry_names == (undefined8 *)0x0) {\n    while (current_entry_address != 0) {\n      next_entry = *(long *)(current_entry_address + 0xf0);\n      (*callback_function)(current_entry_address,0);\n      current_entry_address = next_entry;\n    }\n  }\n  else {\n    do {\n      entry_found = false;\n      current_entry_ptr = (long *)archive_entries[0x1e];\n      previous_entry_ptr = archive_entries;\n      while (next_entry_ptr = current_entry_ptr, next_entry_ptr != (long *)0x0) {\n        if (*next_entry_ptr != 0) {\n          comparison_result = filename_cmp(*entry_names);\n          if (comparison_result == 0) {\n            entry_found = true;\n            (*callback_function)(next_entry_ptr,previous_entry_ptr);\n          }\n        }\n        previous_entry_ptr = next_entry_ptr;\n        current_entry_ptr = (long *)next_entry_ptr[0x1e];\n      }\n      if (!entry_found) {\n        current_entry = *entry_names;\n        error_format = (char *)dcgettext(0,\"No entry %s in archive.\\n\",5);\n        fprintf(_stderr,error_format,current_entry);\n      }\n      entry_names = (undefined8 *)entry_names[1];\n    } while (entry_names != (undefined8 *)0x0);\n  }\n  return return_value;\n}\n\n",
            "called": [
                "filename_cmp",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001032a8",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "process_archive_001032a8"
        },
        "FUN_00102f96": {
            "renaming": {
                "FUN_00102f96": "print_error_message_00102f96",
                "unaff_RBX": "errorFlag",
                "unaff_retaddr": "returnAddress",
                "uVar1": "errorMessage"
            },
            "code": "\n\n\nvoid printErrorMessage_00102f96(void)\n\n{\n  undefined8 errorMessage;\n  long errorFlag;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (errorFlag != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",program_name);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",program_name,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f96",
            "calling": [
                "bfd_nonfatal"
            ],
            "imported": false,
            "current_name": "print_error_message_00102f96"
        },
        "FUN_0010342d": {
            "renaming": {
                "FUN_0010342d": "print_usage_message_0010342d",
                "param_1": "isQuietMode",
                "uVar1": "programName",
                "pcVar2": "localizedText",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid printUsageMessage_0010342d(uint isQuietMode)\n\n{\n  undefined8 programName;\n  char *localizedText;\n  FILE *outputStream;\n  \n  localizedText = (char *)dcgettext(0,\n                             \"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV] [--plugin <name>] [member-name] [count] archive-file file...\\n\"\n                             ,5);\n  outputStream = _stderr;\n  if (isQuietMode != 0) {\n    outputStream = _stdout;\n  }\n  fprintf(outputStream,localizedText,program_name);\n  programName = program_name;\n  localizedText = (char *)dcgettext(0,\"       %s -M [<mri-script]\\n\",5);\n  fprintf(outputStream,localizedText,programName);\n  localizedText = (char *)dcgettext(0,\" commands:\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  d            - delete file(s) from the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  m[ab]        - move file(s) in the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  p            - print file(s) found in the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  q[f]         - quick append file(s) to the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\n                             \"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\\n\"\n                             ,5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  s            - act as ranlib\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  t[O][v]      - display contents of the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  x[o]         - extract file(s) from the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\" command specific modifiers:\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [a]          - put file(s) after [member-name]\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [b]          - put file(s) before [member-name] (same as [i])\\n\",5\n                            );\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [D]          - use zero for timestamps and uids/gids (default)\\n\",\n                             5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [U]          - use actual timestamps and uids/gids\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [N]          - use instance [count] of name\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [f]          - truncate inserted file names\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [P]          - use full path names when matching\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [o]          - preserve original dates\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [O]          - display offsets of files in the archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\n                             \"  [u]          - only replace files that are newer than current archive contents\\n\"\n                             ,5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\" generic modifiers:\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [c]          - do not warn if the library had to be created\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [s]          - create an archive index (cf. ranlib)\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [l <text> ]  - specify the dependencies of this library\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [S]          - do not build a symbol table\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [T]          - deprecated, use --thin instead\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [v]          - be verbose\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  [V]          - display the version number\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  @<file>      - read options from <file>\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  --target=BFDNAME - specify the target object format as BFDNAME\\n\",\n                             5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\n                             \"  --output=DIRNAME - specify the output directory for extraction operations\\n\"\n                             ,5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\n                             \"  --record-libdeps=<text> - specify the dependencies of this library\\n\"\n                             ,5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  --thin       - make a thin archive\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\" optional:\\n\",5);\n  fprintf(outputStream,localizedText);\n  localizedText = (char *)dcgettext(0,\"  --plugin <p> - load the specified plugin\\n\",5);\n  fprintf(outputStream,localizedText);\n  ar_emul_default_usage(outputStream);\n  list_supported_targets(program_name,outputStream);\n  if (isQuietMode != 0) {\n    localizedText = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,localizedText,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(isQuietMode ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "fprintf",
                "list_supported_targets",
                "ar_emul_default_usage",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010342d",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_usage_message_0010342d"
        },
        "FUN_00102110": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102110"
        },
        "FUN_00107920": {
            "renaming": {
                "FUN_00107920": "report_data_00107920",
                "param_1": "source",
                "param_2": "destination",
                "param_3": "length",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "param_8": "param8",
                "param_9": "reportFunction",
                "param_10": "param10",
                "param_11": "param11",
                "param_12": "param12",
                "param_13": "param13",
                "param_14": "param14",
                "in_AL": "condition",
                "local_d8": "localSize",
                "local_d4": "localSize2",
                "local_d0": "localAddress",
                "local_c8": "localBuffer",
                "local_b8": "localData",
                "local_b0": "localParam10",
                "local_a8": "localParam11",
                "local_a0": "localParam12",
                "local_98": "localParam13",
                "local_90": "localParam14",
                "local_88": "localParam1",
                "local_78": "localParam2",
                "local_68": "localParam3",
                "local_58": "localParam4",
                "local_48": "localParam5",
                "local_38": "localParam6",
                "local_28": "localParam7",
                "local_18": "localParam8"
            },
            "code": "\nvoid reportData_00107920(undefined4 source,undefined4 destination,undefined4 length,undefined4 param4,\n                 undefined4 param5,undefined4 param6,undefined4 param7,undefined4 param8,\n                 undefined8 reportFunction,undefined8 param10,undefined8 param11,undefined8 param12,\n                 undefined8 param13,undefined8 param14)\n\n{\n  char condition;\n  undefined4 localSize;\n  undefined4 localSize2;\n  undefined *localAddress;\n  undefined *localBuffer;\n  undefined localData [8];\n  undefined8 localParam10;\n  undefined8 localParam11;\n  undefined8 localParam12;\n  undefined8 localParam13;\n  undefined8 localParam14;\n  undefined4 localParam1;\n  undefined4 localParam2;\n  undefined4 localParam3;\n  undefined4 localParam4;\n  undefined4 localParam5;\n  undefined4 localParam6;\n  undefined4 localParam7;\n  undefined4 localParam8;\n  \n  if (condition != '\\0') {\n    localParam1 = source;\n    localParam2 = destination;\n    localParam3 = length;\n    localParam4 = param4;\n    localParam5 = param5;\n    localParam6 = param6;\n    localParam7 = param7;\n    localParam8 = param8;\n  }\n  localAddress = &stack0x00000008;\n  localSize = 8;\n  localBuffer = localData;\n  localSize2 = 0x30;\n  localParam10 = param10;\n  localParam11 = param11;\n  localParam12 = param12;\n  localParam13 = param13;\n  localParam14 = param14;\n  report(reportFunction,&localSize);\n  return;\n}\n\n",
            "called": [
                "report"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107920",
            "calling": [
                "open_inarch",
                "set_times.cold",
                "get_file_size.cold",
                "smart_rename.constprop.0.cold",
                "get_file_size",
                "main",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "report_data_00107920"
        },
        "FUN_00102230": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "normalize.cold",
                "make_tempname",
                "print_contents",
                "replace_members.cold",
                "extract_file.cold",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102230"
        },
        "FUN_00102590": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102590",
            "calling": [
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "FUN_00102590"
        },
        "FUN_00102350": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102350"
        },
        "FUN_0010e190": {
            "renaming": {},
            "code": "\n\n\n\nint putc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* putc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e190",
            "calling": [
                "putc"
            ],
            "imported": false,
            "current_name": "FUN_0010e190"
        },
        "FUN_00102470": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102470",
            "calling": [
                "FUN_00105a68",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102470"
        },
        "FUN_0010e070": {
            "renaming": {},
            "code": "\n\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fread@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e070",
            "calling": [
                "fread"
            ],
            "imported": false,
            "current_name": "FUN_0010e070"
        },
        "FUN_00102e6f": {
            "renaming": {
                "FUN_00102e6f": "initialize_output_and_open_file_00102e6f",
                "pcVar1": "output_directory",
                "in_RAX": "input_string",
                "uVar2": "base_name",
                "uVar3": "error_message",
                "pFVar4": "file_pointer",
                "sVar5": "output_directory_length",
                "pcVar6": "current_character"
            },
            "code": "\nvoid initialize_output_and_open_file_00102e6f(void)\n\n{\n  char *output_directory;\n  char *input_string;\n  undefined8 base_name;\n  undefined8 error_message;\n  FILE *file_pointer;\n  size_t output_directory_length;\n  char *current_character;\n  \n  output_directory = output_dir;\n  do {\n    input_string = input_string + 1;\n    while (*input_string != '/') {\n      if (*input_string == '\\0') {\n        if ((output_dir != (char *)0x0) && (output_directory_length = strlen(output_dir), output_directory_length != 0)) {\n          if (output_directory[output_directory_length - 1] == '/') {\n            output_filename = (char *)concat(output_directory,output_filename,0);\n          }\n          else {\n            output_filename = (char *)concat(output_directory,&DAT_00108260,output_filename,0);\n          }\n        }\n        if (verbose != 0) {\n          printf(\"x - %s\\n\",output_filename);\n        }\n        file_pointer = fopen(output_filename,\"w\");\n        if (file_pointer == (FILE *)0x0) {\n          perror(output_filename);\n                    \n          xexit(1);\n        }\n        return;\n      }\n      current_character = input_string;\n      if ((*input_string == '.') && (current_character = input_string + 1, input_string[1] == '.')) {\n        current_character = input_string + 2;\n        if ((input_string[2] == '/') || (input_string[2] == '\\0')) {\n          base_name = lbasename();\n          output_directory = output_filename;\n          error_message = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\"\n                            ,5);\n          non_fatal(error_message,output_directory,base_name);\n          output_filename = (char *)base_name;\n          initialize_output_and_open_file_00102e6f_00105a68();\n          return;\n        }\n      }\n      for (; (input_string = current_character, *current_character != '\\0' && (*current_character != '/')); current_character = current_character + 1) {\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00105a68",
                "dcgettext",
                "non_fatal",
                "FUN_00102e6f",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e6f",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "initialize_output_and_open_file_00102e6f"
        },
        "FUN_001020a0": {
            "renaming": {},
            "code": "\nvoid bfd_make_readable(void)\n\n{\n  bfd_make_readable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_readable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020a0"
        },
        "FUN_001021c0": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "FUN_001021c0"
        },
        "FUN_001022e0": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022e0"
        },
        "FUN_001033d6": {
            "renaming": {
                "FUN_001033d6": "create_buffer_001033d6",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "pvVar1": "buffer",
                "pvVar2": "dynamicMemory",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16]\ncreateBuffer_001033d6(undefined8 param1,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  void *buffer;\n  void *dynamicMemory;\n  undefined returnValue [16];\n  \n  buffer = malloc(0x40);\n  if (buffer != (void *)0x0) goto LAB_001033f7;\n  do {\n    buffer = (void *)yy_fatal_error(\"out of dynamic memory in yy_create_buffer()\");\nLAB_001033f7:\n    *(undefined4 *)((long)buffer + 0x18) = 0x4000;\n    dynamicMemory = malloc(0x4002);\n    *(void **)((long)buffer + 8) = dynamicMemory;\n  } while (dynamicMemory == (void *)0x0);\n  *(undefined4 *)((long)buffer + 0x20) = 1;\n  yy_init_buffer(buffer,param1);\n  returnValue._8_8_ = param4;\n  returnValue._0_8_ = buffer;\n  return returnValue;\n}\n\n",
            "called": [
                "yy_init_buffer",
                "yy_fatal_error",
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033d6",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "create_buffer_001033d6"
        },
        "FUN_00102000": {
            "renaming": {
                "FUN_00102000": "initialize_tracing_00102000",
                "ctx": "context",
                "iVar1": "result"
            },
            "code": "\nint initializeTracing_00102000(EVP_PKEY_CTX *context)\n\n{\n  int result;\n  \n  result = __gmon_start__();\n  return result;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "initialize_tracing_00102000"
        },
        "FUN_00102120": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102120"
        },
        "FUN_00102480": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102480",
            "calling": [
                "open_inarch",
                "fatal",
                "bfd_fatal",
                "ranlib_only",
                "FUN_00105a68",
                "maybequit",
                "ranlib_usage",
                "write_archive.cold",
                "usage",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102480"
        },
        "FUN_00105870": {
            "renaming": {
                "FUN_00105870": "find_matching_ptr_00105870",
                "param_1": "ptrArray",
                "param_2": "ptrArraySize",
                "param_3": "targetName",
                "iVar1": "nameComparisonResult",
                "uVar2": "nameToMatch",
                "iVar3": "searchMode"
            },
            "code": "\nlong * findMatchingPtr_00105870(long *ptrArray,int ptrArraySize,undefined8 targetName)\n\n{\n  int nameComparisonResult;\n  undefined8 nameToMatch;\n  int searchMode;\n  \n  nameToMatch = posname;\n  searchMode = postype;\n  if (postype == 0) {\n    nameToMatch = targetName;\n    searchMode = ptrArraySize;\n  }\n  if (searchMode == 3) {\n    for (; *ptrArray != 0; ptrArray = (long *)(*ptrArray + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*ptrArray != (undefined8 *)0x0; ptrArray = (long *)(*ptrArray + 0xf0)) {\n      nameComparisonResult = filename_cmp(*(undefined8 *)*ptrArray,nameToMatch);\n      if (nameComparisonResult == 0) {\n        if (searchMode != 2) {\n          return ptrArray;\n        }\n        return (long *)(*ptrArray + 0xf0);\n      }\n    }\n  }\n  return ptrArray;\n}\n\n",
            "called": [
                "get_pos_bfd.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105870",
            "calling": [
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "find_matching_ptr_00105870"
        },
        "FUN_00102240": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102240"
        },
        "FUN_00102360": {
            "renaming": {},
            "code": "\n\n\nvoid clearerr(FILE *__stream)\n\n{\n  clearerr(__stream);\n  return;\n}\n\n",
            "called": [
                "clearerr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102360"
        },
        "FUN_00103ba8": {
            "renaming": {
                "FUN_00103ba8": "print_ar_prompt_00103ba8",
                "interactive": "is_interactive",
                "printf": "print_formatted",
                "fflush": "flush_standard_output"
            },
            "code": "\n\n\nvoid print_ar_prompt_00103ba8(void)\n\n{\n  if (is_interactive != 0) {\n    print_formatted(\"AR >\");\n    flush_standard_output(_stdout);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "fflush",
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ba8",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_ar_prompt_00103ba8"
        },
        "FUN_00103ddc": {
            "renaming": {
                "FUN_00103ddc": "print_arelt_description_00103ddc",
                "param_1": "param",
                "outfile": "output_file",
                "verbose": "is_verbose"
            },
            "code": "\nvoid print_arelt_description_00103ddc(undefined8 param)\n\n{\n  print_arelt_descr(output_file,param,is_verbose != 0,0);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ddc",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_arelt_description_00103ddc"
        },
        "FUN_001078c0": {
            "renaming": {
                "FUN_001078c0": "print_error_message_001078c0",
                "param_1": "format_string",
                "param_2": "va_arguments",
                "_stdout": "standard_output",
                "_stderr": "standard_error",
                "program_name": "name_of_program"
            },
            "code": "\n\n\nvoid print_error_message_001078c0(char *format_string,__gnuc_va_list va_arguments)\n\n{\n  fflush(standard_output);\n  fprintf(standard_error,\"%s: \",name_of_program);\n  vfprintf(standard_error,format_string,va_arguments);\n  putc(10,standard_error);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "putc",
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001078c0",
            "calling": [
                "fatal",
                "non_fatal"
            ],
            "imported": false,
            "current_name": "print_error_message_001078c0"
        },
        "FUN_001022f0": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "report"
            ],
            "imported": false,
            "current_name": "FUN_001022f0"
        },
        "FUN_001020b0": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001020b0"
        },
        "FUN_001021d0": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "write_archive.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001021d0"
        },
        "FUN_001031a5": {
            "renaming": {
                "FUN_001031a5": "print_error_message_001031a5",
                "uVar1": "lineNumber",
                "__format": "errorFormat"
            },
            "code": "\nvoid printErrorMessage_001031a5(void)\n\n{\n  uint lineNumber;\n  char *errorFormat;\n  \n  lineNumber = linenumber + 1;\n  errorFormat = (char *)dcgettext(0,\"Syntax error in archive script, line %d\\n\",5);\n  printf(errorFormat,(ulong)lineNumber);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031a5",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_error_message_001031a5"
        },
        "FUN_0010e098": {
            "renaming": {},
            "code": "\n\n\nvoid textdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* textdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e098",
            "calling": [
                "textdomain"
            ],
            "imported": false,
            "current_name": "FUN_0010e098"
        },
        "FUN_00102370": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102370"
        },
        "FUN_00102490": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102490",
            "calling": [
                "open_inarch",
                "open_inarch.cold",
                "write_archive.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102490"
        },
        "FUN_0010e090": {
            "renaming": {},
            "code": "\n\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* write@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e090",
            "calling": [
                "write"
            ],
            "imported": false,
            "current_name": "FUN_0010e090"
        },
        "FUN_00102130": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "open_inarch",
                "open_inarch.cold",
                "ar_open",
                "replace_members.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102130"
        },
        "FUN_00102250": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102250"
        },
        "FUN_00103df9": {
            "renaming": {
                "FUN_00103df9": "ensure_buffer_stack_00103df9",
                "in_RCX": "input_param",
                "__size": "buffer_size",
                "lVar1": "loop_counter",
                "lVar2": "new_stack_max",
                "puVar3": "buffer_ptr",
                "bVar4": "loop_increment",
                "yy_buffer_stack": "buffer_stack",
                "yy_buffer_stack_max": "buffer_stack_max",
                "yy_buffer_stack_top": "buffer_stack_top"
            },
            "code": "\nundefined8 ensure_buffer_stack_00103df9(void)\n\n{\n  size_t buffer_size;\n  undefined8 input_param;\n  long loop_counter;\n  long new_stack_max;\n  undefined4 *buffer_ptr;\n  byte loop_increment;\n  \n  loop_increment = 0;\n  if (buffer_stack == (void *)0x0) {\n    buffer_stack = calloc(8,1);\n    if (buffer_stack != (void *)0x0) {\n      buffer_stack_max = 1;\n      buffer_stack_top = 0;\n      return input_param;\n    }\n  }\n  else {\n    if (buffer_stack_top < buffer_stack_max - 1U) {\n      return input_param;\n    }\n    new_stack_max = buffer_stack_max + 8;\n    buffer_size = new_stack_max * 8;\n    buffer_stack = realloc(buffer_stack,buffer_size);\n    if (buffer_stack != (void *)0x0) {\n      buffer_ptr = (undefined4 *)((long)buffer_stack + (buffer_size - 0x40));\n      buffer_stack_max = new_stack_max;\n      for (loop_counter = 0x10; loop_counter != 0; loop_counter = loop_counter + -1) {\n        *buffer_ptr = 0;\n        buffer_ptr = buffer_ptr + (ulong)loop_increment * -2 + 1;\n      }\n      return input_param;\n    }\n  }\n  yy_fatal_error(\"out of dynamic memory in yyensure_buffer_stack_00103df9()\");\n  buffer_stack_top = 0;\n  buffer_stack_max = 1;\n  return input_param;\n}\n\n",
            "called": [
                "calloc",
                "yy_fatal_error",
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103df9",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "ensure_buffer_stack_00103df9"
        },
        "FUN_0010e308": {
            "renaming": {},
            "code": "\n\n\nvoid __cxa_finalize(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __cxa_finalize@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e308",
            "calling": [
                "__cxa_finalize"
            ],
            "imported": false,
            "current_name": "FUN_0010e308"
        },
        "FUN_001021e0": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_001021e0"
        },
        "FUN_001020c0": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "yy_init_buffer",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020c0"
        },
        "FUN_00105da0": {
            "renaming": {},
            "code": "\nvoid register_tm_clones(void)\n\n{\n  register_tm_clones();\n  return;\n}\n\n",
            "called": [
                "register_tm_clones"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105da0",
            "calling": [],
            "imported": false,
            "current_name": "FUN_00105da0"
        },
        "FUN_00102bf5": {
            "renaming": {
                "FUN_00102bf5": "cleanup_output_00102bf5",
                "output_bfd": "bfd_handle",
                "output_file": "file_handle",
                "output_filename": "filename"
            },
            "code": "\nvoid cleanup_output_00102bf5(void)\n\n{\n  if (bfd_handle != 0) {\n    bfd_cache_close();\n  }\n  if (file_handle != (FILE *)0x0) {\n    fclose(file_handle);\n  }\n  unlink_if_ordinary(filename);\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary",
                "fclose",
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bf5",
            "calling": [
                "remove_output"
            ],
            "imported": false,
            "current_name": "cleanup_output_00102bf5"
        },
        "FUN_00102260": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "simple_copy.constprop.0.cold",
                "write_archive",
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102260"
        },
        "FUN_00102380": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102380"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_indirect_function_00102020"
            },
            "code": "\nvoid executeIndirectFunction_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_function_00102020"
        },
        "FUN_00102140": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "extract_file.cold",
                "remove_output.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102140"
        },
        "FUN_00102943": {
            "renaming": {
                "FUN_00102943": "initialize_output_filename_00102943",
                "output_filename": "outputFilename"
            },
            "code": "\nvoid initializeOutputFilename_00102943(void)\n\n{\n  outputFilename = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102943",
            "calling": [
                "replace_members.cold",
                "replace_members"
            ],
            "imported": false,
            "current_name": "initialize_output_filename_00102943"
        },
        "FUN_00107c80": {
            "renaming": {
                "FUN_00107c80": "set_file_time_00107c80",
                "param_1": "filePath",
                "param_2": "fileData",
                "iVar1": "result",
                "piVar2": "errnoPtr",
                "pcVar3": "strError",
                "uVar4": "translatedError",
                "local_38": "accessTime",
                "uStack_34": "modificationTime",
                "uStack_30": "changeTime",
                "uStack_2c": "birthTime",
                "local_28": "originalAccessTime",
                "uStack_24": "originalModificationTime",
                "uStack_20": "originalChangeTime",
                "uStack_1c": "originalBirthTime"
            },
            "code": "\nvoid setFileTime_00107c80(char *filePath,long fileData)\n\n{\n  int result;\n  int *errnoPtr;\n  char *strError;\n  undefined8 translatedError;\n  undefined4 accessTime;\n  undefined4 modificationTime;\n  undefined4 changeTime;\n  undefined4 birthTime;\n  undefined4 originalAccessTime;\n  undefined4 originalModificationTime;\n  undefined4 originalChangeTime;\n  undefined4 originalBirthTime;\n  \n  originalAccessTime = *(undefined4 *)(fileData + 0x58);\n  originalModificationTime = *(undefined4 *)(fileData + 0x5c);\n  originalChangeTime = *(undefined4 *)(fileData + 0x60);\n  originalBirthTime = *(undefined4 *)(fileData + 100);\n  accessTime = *(undefined4 *)(fileData + 0x48);\n  modificationTime = *(undefined4 *)(fileData + 0x4c);\n  changeTime = *(undefined4 *)(fileData + 0x50);\n  birthTime = *(undefined4 *)(fileData + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&accessTime,0);\n  if (result != 0) {\n    errnoPtr = __errno_location();\n    strError = strerror(*errnoPtr);\n    translatedError = dcgettext(0,\"%s: cannot set time: %s\",5);\n    non_fatal(translatedError,filePath,strError);\n  }\n  return;\n}\n\n",
            "called": [
                "utimensat",
                "set_times.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c80",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "set_file_time_00107c80"
        },
        "FUN_001020d0": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001020d0"
        },
        "FUN_001021f0": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "print_arelt_descr.cold"
            ],
            "imported": false,
            "current_name": "FUN_001021f0"
        },
        "FUN_00102390": {
            "renaming": {},
            "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "yy_init_buffer",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102390"
        },
        "FUN_00102d8c": {
            "renaming": {
                "FUN_00102d8c": "print_file_info_00102d8c",
                "param_19": "filePermission",
                "param_20": "fileSize",
                "param_22": "timeStamp",
                "__format": "corruptTimeFormat",
                "uVar1": "fileType",
                "unaff_RBX": "fileContent",
                "unaff_RBP": "outputFile",
                "unaff_R12B": "printHex",
                "uStack0000000000000015": "fileSymbol",
                "cStack0000000000000016": "symbol1",
                "cStack0000000000000017": "symbol2",
                "param_9": "symbol3",
                "cStack0000000000000019": "symbol4",
                "cStack000000000000001a": "symbol5",
                "cStack000000000000001b": "symbol6",
                "cStack000000000000001c": "symbol7",
                "cStack000000000000001d": "symbol8",
                "cStack000000000000001e": "symbol9",
                "uStack000000000000001f": "printHexFlag",
                "uStack000000000000006c": "filePermissions",
                "stack0x00000016": "symbolStack1",
                "stack0x00000020": "symbolStack2"
            },
            "code": "\nvoid printFileInfo_00102d8c(void)\n\n{\n  char *corruptTimeFormat;\n  uint fileType;\n  char **fileContent;\n  FILE *outputFile;\n  char printHex;\n  undefined fileSymbol;\n  char symbol1;\n  char symbol2;\n  char symbol3;\n  char symbol4;\n  char symbol5;\n  char symbol6;\n  char symbol7;\n  char symbol8;\n  char symbol9;\n  undefined printHexFlag;\n  uint filePermission;\n  uint filePermissions;\n  uint fileSize;\n  undefined8 timeStamp;\n  \n  corruptTimeFormat = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&symbolStack2,corruptTimeFormat);\n  fileType = filePermission & 0xf000;\n  if (fileType == 0x4000) {\n    fileSymbol = 100;\n  }\n  else if (fileType == 0xa000) {\n    fileSymbol = 0x6c;\n  }\n  else if (fileType == 0x6000) {\n    fileSymbol = 0x62;\n  }\n  else if (fileType == 0x2000) {\n    fileSymbol = 99;\n  }\n  else if (fileType == 0xc000) {\n    fileSymbol = 0x73;\n  }\n  else {\n    fileSymbol = 0x70;\n    if (fileType != 0x1000) {\n      fileSymbol = 0x2d;\n    }\n  }\n  symbol1 = (-((filePermission & 0x100) == 0) & 0xbbU) + 0x72;\n  symbol2 = (-((filePermission & 0x80) == 0) & 0xb6U) + 0x77;\n  symbol3 = (-((filePermission & 0x40) == 0) & 0xb5U) + 0x78;\n  symbol4 = (-((filePermission & 0x20) == 0) & 0xbbU) + 0x72;\n  symbol5 = (-((filePermission & 0x10) == 0) & 0xb6U) + 0x77;\n  symbol6 = (-((filePermission & 8) == 0) & 0xb5U) + 0x78;\n  symbol7 = (-((filePermission & 4) == 0) & 0xbbU) + 0x72;\n  symbol8 = (-((filePermission & 2) == 0) & 0xb6U) + 0x77;\n  symbol9 = (-((filePermission & 1) == 0) & 0xb5U) + 0x78;\n  if ((filePermission & 0x800) != 0) {\n    if (symbol3 == 'x') {\n      symbol3 = 's';\n    }\n    else {\n      symbol3 = 'S';\n    }\n  }\n  if ((filePermission & 0x400) != 0) {\n    if (symbol6 == 'x') {\n      symbol6 = 's';\n    }\n    else {\n      symbol6 = 'S';\n    }\n  }\n  if ((filePermission & 0x200) != 0) {\n    if (symbol9 == 'x') {\n      symbol9 = 't';\n    }\n    else {\n      symbol9 = 'T';\n    }\n  }\n  printHexFlag = 0;\n  fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&symbolStack1,(ulong)filePermissions,\n          (ulong)fileSize,timeStamp,&symbolStack2,(ulong)filePermission);\n  fputs(*fileContent,outputFile);\n  if (printHex != '\\0') {\n    if ((*(byte *)((long)fileContent + 0x49) & 0x10) == 0) {\n      if (fileContent[0xb] != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (fileContent[0xc] != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fputs",
                "fputc",
                "dcgettext",
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d8c",
            "calling": [
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "print_file_info_00102d8c"
        },
        "FUN_00105300": {
            "renaming": {
                "FUN_00105300": "process_file_00105300",
                "param_1": "inputPath",
                "param_2": "outputPath",
                "plVar1": "archivedFileList",
                "pcVar2": "outputFilename",
                "bVar3": "isThinLibrary",
                "cVar4": "formatCheck",
                "iVar5": "errorCode",
                "uVar6": "errorString",
                "uVar7": "errorStringAlt",
                "piVar8": "errnoValue",
                "lVar9": "archivedFile",
                "puVar10": "inputArchive",
                "local_b0": "matchingFormats",
                "local_a8": "fileStat",
                "target": "defaultTarget",
                "program_name": "executableName",
                "_stderr": "errorOutput",
                "silent_create": "isSilentCreate",
                "operation_alters_arch": "isOperationAlteringArch",
                "make_thin_archive": "isMakingThinArchive",
                "dcgettext": "localizedMessage",
                "fatal": "handleFatalError",
                "list_matching_formats": "printMatchingFormats",
                "bfd_set_error": "setError",
                "fprintf": "printErrorMessage",
                "perror": "printError",
                "maybequit": "handleErrorQuit",
                "open_inarch_cold": "openInputArchive",
                "bfd_openw": "openOutputArchive",
                "bfd_set_format": "setOutputFormat",
                "bfd_close": "closeOutputArchive",
                "bfd_fatal": "handleBFDfatalError",
                "bfd_nonfatal": "handleNonFatalBFDerror",
                "bfd_get_error": "getBFDerror",
                "xexit": "exitProgram",
                "bfd_openr_next_archived_file": "getNextArchivedFile",
                "bfd_openr": "openArchive",
                "bfd_check_format_matches": "checkFormatMatches",
                "operation": "fileOperation"
            },
            "code": "\n\n\nundefined8 * processFile_00105300(char *inputPath,undefined8 *outputPath)\n\n{\n  long *archivedFileList;\n  char *outputFilename;\n  byte isThinLibrary;\n  char formatCheck;\n  int errorCode;\n  undefined8 errorString;\n  undefined8 errorStringAlt;\n  int *errnoValue;\n  long archivedFile;\n  undefined8 *inputArchive;\n  undefined8 matchingFormats;\n  stat fileStat;\n  \n  setError(0);\n  if (defaultTarget == (char *)0x0) {\n    defaultTarget = \"plugin\";\n  }\n  errorCode = stat(inputPath,&fileStat);\n  outputFilename = output_filename;\n  if (errorCode == 0) goto LAB_001053be;\n  errnoValue = __errno_location();\n  if (*errnoValue == 2) {\n    if (isOperationAlteringArch == '\\0') {\n      printErrorMessage(errorOutput,\"%s: \",executableName);\n      printError(inputPath);\n      handleErrorQuit();\n      return (undefined8 *)0x0;\n    }\n    if ((defaultTarget == (char *)0x0) && (outputPath != (undefined8 *)0x0)) {\n      inputArchive = (undefined8 *)openInputArchive();\n      return inputArchive;\n    }\n    outputPath = (undefined8 *)openOutputArchive(inputPath,defaultTarget);\n    if (((outputPath != (undefined8 *)0x0) && (formatCheck = setOutputFormat(outputPath,2), formatCheck != '\\0')) &&\n       (formatCheck = closeOutputArchive(outputPath), formatCheck != '\\0')) {\n      outputFilename = inputPath;\n      if (isSilentCreate == 0) goto LAB_00102826;\n      goto LAB_001053be;\n    }\n  }\n  handleBFDfatalError(inputPath);\n  do {\n    isThinLibrary = *(byte *)((long)outputPath + 0x49) >> 4 & 1;\n    if (isMakingThinArchive == '\\0') {\n      if (isThinLibrary != 0) {\n        errorStringAlt = *outputPath;\n        errorString = localizedMessage(0,\"Cannot convert existing thin library %s to normal format\",5);\n        handleFatalError(errorString,errorStringAlt);\n        goto LAB_00102812;\n      }\n    }\n    else if (isThinLibrary == 0) {\n      errorStringAlt = *outputPath;\n      errorString = localizedMessage(0,\"Cannot convert existing library %s to thin format\",5);\n      handleFatalError(errorString,errorStringAlt);\nLAB_001027cb:\n      handleNonFatalBFDerror(inputPath);\n      errorCode = getBFDerror();\n      if (errorCode == 0xd) {\nLAB_00102812:\n        printMatchingFormats(matchingFormats);\n      }\n                    \n      exitProgram(1);\n    }\n    do {\n      archivedFileList = outputPath + 0x1e;\n      for (archivedFile = getNextArchivedFile(outputPath,0); archivedFile != 0;\n          archivedFile = getNextArchivedFile(outputPath,archivedFile)) {\n        *archivedFileList = archivedFile;\n        archivedFileList = (long *)(archivedFile + 0xf0);\n      }\n      *archivedFileList = 0;\n      errorCode = getBFDerror();\n      if (errorCode == 9) {\n        return outputPath;\n      }\n      do {\n        handleBFDfatalError(inputPath);\nLAB_00102826:\n        errorStringAlt = localizedMessage(0,\"creating %s\",5);\n        non_handleFatalError(errorStringAlt,inputPath);\n        outputFilename = inputPath;\nLAB_001053be:\n        output_filename = outputFilename;\n        outputPath = (undefined8 *)openArchive(inputPath,defaultTarget);\n      } while (outputPath == (undefined8 *)0x0);\n      formatCheck = checkFormatMatches(outputPath,2,&matchingFormats);\n      if (formatCheck == '\\0') goto LAB_001027cb;\n    } while (((fileOperation != 2) && (fileOperation != 7)) ||\n            (archivedFile = getNextArchivedFile(outputPath,0), archivedFile == 0));\n  } while( true );\n}\n\n",
            "called": [
                "xexit",
                "bfd_openr_next_archived_file",
                "bfd_fatal",
                "fprintf",
                "maybequit",
                "bfd_check_format_matches",
                "bfd_nonfatal",
                "bfd_openr",
                "dcgettext",
                "non_fatal",
                "fatal",
                "stat",
                "open_inarch.cold",
                "list_matching_formats",
                "__errno_location",
                "bfd_openw",
                "bfd_get_error",
                "perror",
                "bfd_close",
                "bfd_set_error",
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105300",
            "calling": [
                "ranlib_only",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "process_file_00105300"
        },
        "FUN_00105db0": {
            "renaming": {
                "FUN_00105db0": "FUNC_00105db0"
            },
            "code": "\n\n\nvoid FUNC_00105db0(uint param_1,FILE *param_2)\n\n{\n  byte *pbVar1;\n  uint *puVar2;\n  byte bVar3;\n  long *plVar4;\n  undefined8 *puVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  bool bVar8;\n  bool bVar9;\n  char **ppcVar10;\n  int *piVar11;\n  undefined *puVar12;\n  byte bVar13;\n  char cVar14;\n  int iVar15;\n  uint uVar16;\n  undefined4 uVar17;\n  FILE *pFVar18;\n  size_t sVar19;\n  size_t sVar20;\n  byte *__ptr;\n  long *plVar21;\n  FILE *pFVar22;\n  char *pcVar23;\n  long lVar24;\n  ulong uVar25;\n  undefined8 *puVar26;\n  undefined8 uVar27;\n  FILE *pFVar28;\n  long **pplVar29;\n  undefined8 uVar30;\n  char **ppcVar31;\n  uint extraout_EDX;\n  char **ppcVar32;\n  byte *pbVar33;\n  long lVar34;\n  long lVar35;\n  undefined1 *puVar36;\n  uint uVar37;\n  char *unaff_RBP;\n  byte *pbVar38;\n  char *pcVar39;\n  ulong uVar40;\n  ulong uVar41;\n  ulong uVar42;\n  FILE *unaff_R12;\n  char *pcVar43;\n  uint uVar44;\n  int iVar45;\n  char *pcVar46;\n  bool bVar47;\n  byte bVar48;\n  undefined8 local_130;\n  FILE *local_128;\n  byte *local_118;\n  char **local_110;\n  size_t local_108;\n  long local_100;\n  undefined local_c8 [2];\n  undefined uStack_c6;\n  undefined5 uStack_c5;\n  uint local_b0;\n  \n  bVar48 = 0;\n  pcVar46 = (char *)(ulong)param_1;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  program_name = *(long **)param_2;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(program_name);\n  bfd_plugin_set_program_name(program_name);\n  pcVar43 = (char *)param_2;\n  pFVar18 = param_2;\n  if ((int)param_1 < 2) goto LAB_001062c6;\n  local_110 = (char **)0x7d0;\n  unaff_R12 = (FILE *)0x1;\n  local_128 = (FILE *)0x0;\n  pFVar22 = param_2;\n  do {\n    uVar16 = (uint)unaff_R12;\n    unaff_RBP = (char *)(long)(int)uVar16;\n    local_130 = (FILE *)((long)unaff_RBP * 8);\n    pcVar43 = (char *)pFVar22;\n    if (**(char **)(&pFVar22->_flags + (long)unaff_RBP * 2) == '@') {\n      uVar44 = (int)local_110 - 1;\n      local_110 = (char **)(ulong)uVar44;\n      if (uVar44 == 0) {\n        plVar21 = *(long **)pFVar22;\n        pcVar46 = \"%s: error: too many @-files encountered\\n\";\nLAB_00106ffe:\n        fprintf(_stderr,pcVar46,plVar21);\nLAB_0010700f:\n                    \n        xexit(1);\n      }\n      pcVar39 = *(char **)(&pFVar22->_flags + (long)unaff_RBP * 2) + 1;\n      iVar15 = stat(pcVar39,(stat *)local_c8);\n      if (-1 < iVar15) {\n        if ((local_b0 & 0xf000) == 0x4000) {\n          plVar21 = *(long **)pFVar22;\n          pcVar46 = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00106ffe;\n        }\n        pFVar18 = fopen(pcVar39,\"r\");\n        if (pFVar18 != (FILE *)0x0) {\n          iVar15 = fseek(pFVar18,0,2);\n          if (((iVar15 != -1) && (sVar19 = ftell(pFVar18), sVar19 != 0xffffffffffffffff)) &&\n             (iVar15 = fseek(pFVar18,0,0), iVar15 != -1)) {\n            local_118 = (byte *)xmalloc(sVar19 + 1);\n            sVar20 = fread(local_118,1,sVar19,pFVar18);\n            if ((sVar19 == sVar20) || (iVar15 = ferror(pFVar18), iVar15 == 0)) {\n              local_118[sVar20] = 0;\n              bVar13 = *local_118;\n              pbVar33 = local_118;\n              while( true ) {\n                if (bVar13 == 0) goto LAB_00106814;\n                if (((&_sch_istable)[(ulong)bVar13 * 2] & 0x40) == 0) break;\n                bVar13 = pbVar33[1];\n                pbVar33 = pbVar33 + 1;\n              }\n              sVar19 = strlen((char *)local_118);\n              __ptr = (byte *)xmalloc(sVar19 + 1);\n              pFVar28 = (FILE *)0x0;\n              iVar15 = 0;\n              bVar9 = false;\n              bVar47 = false;\n              bVar8 = false;\n              local_100 = 0;\n              pbVar33 = local_118;\n              do {\n                while (((&_sch_istable)[(ulong)*pbVar33 * 2] & 0x40) != 0) {\n                  pbVar33 = pbVar33 + 1;\n                }\n                if ((iVar15 == 0) || (iVar15 + -1 <= (int)local_100)) {\n                  if (pFVar28 == (FILE *)0x0) {\n                    iVar15 = 8;\n                    pFVar28 = (FILE *)xmalloc(0x40);\n                    ppcVar31 = (char **)((long)&pFVar28->_flags + local_100 * 8);\n                    *ppcVar31 = (char *)0x0;\n                  }\n                  else {\n                    iVar15 = iVar15 * 2;\n                    pFVar28 = (FILE *)xrealloc(pFVar28,(long)iVar15 << 3);\n                    ppcVar31 = (char **)((long)&pFVar28->_flags + local_100 * 8);\n                    *ppcVar31 = (char *)0x0;\n                  }\n                }\n                else {\n                  ppcVar31 = (char **)((long)&pFVar28->_flags + local_100 * 8);\n                }\n                bVar13 = *pbVar33;\n                pbVar38 = __ptr;\n                while (bVar13 != 0) {\n                  while( true ) {\n                    if ((((&_sch_istable)[(ulong)bVar13 * 2] & 0x40) != 0) &&\n                       (!(bool)(bVar9 | bVar8 | bVar47))) {\n                      bVar8 = false;\n                      bVar9 = false;\n                      bVar47 = false;\n                      goto LAB_0010606f;\n                    }\n                    if (!bVar8) break;\n                    pbVar33 = pbVar33 + 1;\n                    *pbVar38 = bVar13;\n                    pbVar38 = pbVar38 + 1;\n                    bVar8 = false;\n                    bVar13 = *pbVar33;\n                    if (bVar13 == 0) goto LAB_0010606f;\n                  }\n                  if (bVar13 == 0x5c) {\n                    bVar8 = true;\n                  }\n                  else if (bVar47) {\n                    if (bVar13 == 0x27) {\n                      bVar47 = false;\n                    }\n                    else {\nLAB_001061f1:\n                      *pbVar38 = bVar13;\n                      pbVar38 = pbVar38 + 1;\n                    }\n                  }\n                  else if (bVar9) {\n                    if (bVar13 != 0x22) goto LAB_001061f1;\n                    bVar9 = false;\n                  }\n                  else if (bVar13 == 0x27) {\n                    bVar47 = true;\n                  }\n                  else {\n                    if (bVar13 != 0x22) goto LAB_001061f1;\n                    bVar9 = true;\n                  }\n                  pbVar1 = pbVar33 + 1;\n                  pbVar33 = pbVar33 + 1;\n                  bVar13 = *pbVar1;\n                }\nLAB_0010606f:\n                *pbVar38 = 0;\n                plVar21 = (long *)xstrdup(__ptr);\n                *ppcVar31 = (char *)plVar21;\n                *(undefined8 *)(pFVar28->_shortbuf + local_100 * 8 + -0x7b) = 0;\n                bVar13 = *pbVar33;\n                bVar3 = (&_sch_istable)[(ulong)bVar13 * 2];\n                while ((bVar3 & 0x40) != 0) {\n                  bVar13 = pbVar33[1];\n                  pbVar33 = pbVar33 + 1;\n                  bVar3 = (&_sch_istable)[(ulong)bVar13 * 2];\n                }\n                local_100 = local_100 + 1;\n                if (bVar13 == 0) {\n                  free(__ptr);\n                  if (pFVar22 == param_2) goto LAB_00106834;\n                  goto LAB_0010610a;\n                }\n              } while( true );\n            }\n            free(local_118);\n          }\n          fclose(pFVar18);\n        }\n      }\n    }\n    if ((int)pcVar46 <= (int)(uVar16 + 1)) {\nLAB_001062c6:\n      do {\n        if (is_ranlib < 0) goto LAB_001073cc;\nLAB_001062d3:\n        uVar16 = (uint)unaff_R12;\n        iVar15 = bfd_init();\n        pcVar39 = \"fatal error: libbfd ABI mismatch\";\n        if (iVar15 != 0x118) goto LAB_00106803;\n        pcVar39 = \"x86_64-pc-linux-gnu\";\n        uVar16 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n        puVar12 = xatexit_head;\n        unaff_R12 = (FILE *)(ulong)uVar16;\n        if ((char)uVar16 != '\\0') {\n          if (__xexit_cleanup == (code *)0x0) {\n            __xexit_cleanup = xatexit_cleanup;\n          }\n          if (*(int *)(xatexit_head + 8) < 0x20) {\nLAB_0010632b:\n            puVar12 = xatexit_head;\n            iVar15 = *(int *)(xatexit_head + 8);\n            *(int *)(xatexit_head + 8) = iVar15 + 1;\n            *(code **)(puVar12 + (long)iVar15 * 8 + 0x10) = remove_output;\n          }\n          else {\n            puVar26 = (undefined8 *)malloc(0x110);\n            if (puVar26 != (undefined8 *)0x0) {\n              *puVar26 = puVar12;\n              *(undefined4 *)(puVar26 + 1) = 0;\n              xatexit_head = (undefined *)puVar26;\n              goto LAB_0010632b;\n            }\n          }\n          lVar24 = 1;\n          do {\n            lVar35 = lVar24;\n            iVar15 = (int)pcVar46;\n            if (iVar15 <= (int)lVar35) break;\n            cVar14 = ar_emul_default_parse_arg(*(undefined8 *)((int *)pcVar43 + lVar35 * 2));\n            lVar24 = lVar35 + 1;\n          } while (cVar14 != '\\0');\n          pcVar46 = (char *)((long)pcVar43 + lVar35 * 8 + -8);\n          uVar44 = iVar15 - ((int)lVar35 + -1);\n          pFVar18 = (FILE *)(ulong)uVar44;\n          if (is_ranlib != 0) {\n            pcVar43 = \"DhHUvVt\";\n            uVar37 = 0;\n            while (iVar15 = getopt_long(pFVar18,pcVar46,\"DhHUvVt\",long_options), iVar15 != -1) {\n              if (iVar15 < 0x77) {\n                if (0x43 < iVar15) {\n                  switch(iVar15) {\n                  case 0x44:\n                    deterministic = 1;\n                    break;\n                  case 0x48:\n                  case 0x68:\n                    show_help = 1;\n                    break;\n                  case 0x55:\n                    deterministic = 0;\n                    break;\n                  case 0x56:\n                  case 0x76:\n                    show_version = 1;\n                    break;\n                  case 0x74:\n                    uVar37 = uVar16;\n                  }\n                }\n              }\n              else if (iVar15 == 0xc9) {\n                bfd_plugin_set_plugin(_optarg);\n              }\n            }\n            if ((int)uVar44 < 2) {\nLAB_00107125:\n              pcVar39 = (char *)0x0;\n              ranlib_usage();\n            }\n            else {\n              if (show_help != 0) {\nLAB_0010711b:\n                ranlib_usage();\n                goto LAB_00107125;\n              }\n              if (show_version != 0) {\n                print_version(\"ranlib\");\n                goto LAB_0010711b;\n              }\n              if (deterministic < 0) {\n                deterministic = 1;\n              }\n              unaff_R12 = (FILE *)0x0;\n              pcVar43 = (char *)(long)_optind;\n              while( true ) {\n                if ((int)uVar44 <= (int)pcVar43) goto LAB_00106f8b;\n                pcVar39 = *(char **)((int *)pcVar46 + (long)pcVar43 * 2);\n                if ((char)uVar37 != '\\0') break;\n                uVar16 = ranlib_only();\n                pcVar43 = (char *)((long)(int *)pcVar43 + 1);\n                unaff_R12 = (FILE *)(ulong)((uint)unaff_R12 | uVar16);\n              }\n            }\n            while (lVar24 = get_file_size(pcVar39), lVar24 < 1) {\n              uVar16 = 1;\nLAB_001071c4:\n              piVar11 = (int *)pcVar43;\n              pcVar43 = (char *)((long)piVar11 + 1);\n              unaff_R12 = (FILE *)(ulong)((uint)unaff_R12 | uVar16);\n              if ((int)uVar44 <= (int)pcVar43) {\nLAB_00106f8b:\n                    \n                xexit(unaff_R12);\n              }\n              pcVar39 = *(char **)((char *)((long)pcVar46 + 0x83) + (long)piVar11 * 8 + -0x7b);\n            }\n            iVar15 = open(pcVar39,2,0);\n            if (iVar15 < 0) {\n              bfd_set_error(1);\n              bfd_fatal(pcVar39);\nLAB_0010737f:\n              bfd_fatal(pcVar39);\nLAB_00107387:\n              bfd_nonfatal(pcVar39);\n              iVar15 = bfd_get_error();\n              if (iVar15 == 0xd) {\n                list_matching_formats\n                          (CONCAT53(uStack_c5,CONCAT12(uStack_c6,CONCAT11(local_c8[1],local_c8[0])))\n                          );\n              }\n              goto LAB_0010700f;\n            }\n            unaff_RBP = (char *)bfd_fdopenr(pcVar39,0);\n            if ((FILE *)unaff_RBP == (FILE *)0x0) goto LAB_0010737f;\n            cVar14 = bfd_check_format_matches(unaff_RBP,2,local_c8);\n            if (cVar14 == '\\0') goto LAB_00107387;\n            if ((*(byte *)((long)((long)unaff_RBP + 0x48) + 1) & 8) != 0) {\n              if (deterministic != 0) {\n                puVar2 = (uint *)((long)((long)unaff_RBP + 0x40) + 4);\n                *puVar2 = *puVar2 | 0x2000;\n              }\n              (**(code **)(*(char **)((long)unaff_RBP + 8) + 0x1f0))(unaff_RBP);\n              cVar14 = bfd_close(unaff_RBP);\n              if (cVar14 != '\\0') {\n                uVar16 = 0;\n                goto LAB_001071c4;\n              }\n              goto LAB_0010737f;\n            }\n            uVar27 = dcgettext(0,\"%s: no archive map to update\",5);\n            fatal(uVar27,pcVar39);\nLAB_001073cc:\n            pcVar39 = (char *)lbasename(program_name);\n            sVar19 = strlen(pcVar39);\n            if ((sVar19 < 6) ||\n               (iVar15 = filename_cmp(pcVar39 + (sVar19 - 6),\"ranlib\"), iVar15 != 0)) {\n              is_ranlib = 0;\n            }\n            else {\n              is_ranlib = 1;\n            }\n            goto LAB_001062d3;\n          }\n          puVar36 = long_options;\n          unaff_RBP = \"hdmpqrtxl:coOVsSuvabiMNfPTDU\";\n          pcVar43 = (char *)&DAT_001096a0;\n          pFVar22 = (FILE *)unaff_RBP;\n          pFVar28 = pFVar18;\n          if ((int)uVar44 < 2) goto switchD_00107462_caseD_1;\n          local_130 = (FILE *)CONCAT71(local_130._1_7_,(char)uVar16);\nLAB_001063a3:\n          pFVar22 = (FILE *)unaff_RBP;\n          if (**(char **)((long)pcVar46 + 8) != '-') {\n            local_c8[0] = 0x2d;\n            uStack_c6 = 0;\n            sVar19 = strlen(*(char **)((long)pcVar46 + 8));\n            iVar15 = (int)sVar19 + (int)pFVar18;\n            unaff_R12 = (FILE *)xmalloc((long)iVar15 * 8);\n            uVar17 = *(undefined4 *)((long)pcVar46 + 4);\n            unaff_R12->_flags = *(int *)pcVar46;\n            *(undefined4 *)&unaff_R12->field_0x4 = uVar17;\n            ppcVar31 = *(char ***)((long)pcVar46 + 8);\n            local_128 = (FILE *)((long)pcVar46 + 0x10);\n            local_110 = ppcVar31;\n            if (*(char *)ppcVar31 == '\\0') {\n              ppcVar32 = &unaff_R12->_IO_read_ptr;\n            }\n            else {\n              local_118 = local_c8;\n              local_c8[1] = *(char *)ppcVar31;\n              pcVar39 = (char *)xstrdup();\n              ppcVar32 = &unaff_R12->_IO_read_end;\n              unaff_R12->_IO_read_ptr = pcVar39;\n              if (*(char *)((long)ppcVar31 + 1) != '\\0') {\n                local_c8[1] = *(char *)((long)ppcVar31 + 1);\n                pcVar39 = (char *)xstrdup(local_118);\n                ppcVar32 = &unaff_R12->_IO_read_base;\n                unaff_R12->_IO_read_end = pcVar39;\n                if (*(char *)((long)ppcVar31 + 2) != '\\0') {\n                  local_c8[1] = *(char *)((long)ppcVar31 + 2);\n                  pcVar39 = (char *)xstrdup(local_118);\n                  ppcVar32 = &unaff_R12->_IO_write_base;\n                  unaff_R12->_IO_read_base = pcVar39;\n                  if (*(char *)((long)ppcVar31 + 3) != '\\0') {\n                    ppcVar32 = &unaff_R12->_IO_write_ptr;\n                    local_c8[1] = *(char *)((long)ppcVar31 + 3);\n                    pcVar39 = (char *)xstrdup(local_118);\n                    unaff_R12->_IO_write_base = pcVar39;\n                    cVar14 = *(char *)((long)ppcVar31 + 4);\n                    local_110 = ppcVar32;\n                    if (cVar14 != '\\0') {\n                      pcVar39 = (char *)((long)ppcVar31 + 4);\n                      ppcVar31 = ppcVar32;\n                      do {\n                        ppcVar32 = ppcVar31 + 1;\n                        local_c8[1] = cVar14;\n                        pcVar23 = (char *)xstrdup(local_118);\n                        pcVar39 = pcVar39 + 1;\n                        *ppcVar31 = pcVar23;\n                        cVar14 = *pcVar39;\n                        ppcVar31 = ppcVar32;\n                        local_110 = ppcVar32;\n                      } while (cVar14 != '\\0');\n                    }\n                  }\n                }\n              }\n            }\n            lVar24 = (long)(int)pFVar18;\n            piVar11 = (int *)pcVar46 + lVar24 * 2;\n            if (local_128 < piVar11) {\n              uVar25 = lVar24 * 8 - 0x11;\n              if ((uVar25 < 0x18) || (ppcVar32 == (char **)((long)pcVar46 + 0x18))) {\n                *ppcVar32 = *(char **)((long)pcVar46 + 0x10);\n                if (((char **)((long)pcVar46 + 0x18) < piVar11) &&\n                   ((((ppcVar32[1] = *(char **)((long)pcVar46 + 0x18),\n                      (char **)((long)pcVar46 + 0x20) < piVar11 &&\n                      (ppcVar32[2] = *(char **)((long)pcVar46 + 0x20),\n                      (char **)((long)pcVar46 + 0x28) < piVar11)) &&\n                     (ppcVar32[3] = *(char **)((long)pcVar46 + 0x28),\n                     (char **)((long)pcVar46 + 0x30) < piVar11)) &&\n                    (ppcVar32[4] = *(char **)((long)pcVar46 + 0x30),\n                    (char **)((long)pcVar46 + 0x38) < piVar11)))) {\n                  ppcVar32[5] = *(char **)((long)pcVar46 + 0x38);\n                  ppcVar10 = ppcVar32 + 6;\n                  for (ppcVar31 = (char **)((long)pcVar46 + 0x40); ppcVar31 < piVar11;\n                      ppcVar31 = ppcVar31 + (ulong)bVar48 * -2 + 1) {\n                    *ppcVar10 = *ppcVar31;\n                    ppcVar10 = ppcVar10 + (ulong)bVar48 * -2 + 1;\n                  }\n                }\n              }\n              else {\n                uVar17 = *(undefined4 *)((long)((long)pcVar46 + 0x10) + 4);\n                uVar6 = *(undefined4 *)((long)pcVar46 + 0x18);\n                uVar7 = *(undefined4 *)((long)((long)pcVar46 + 0x18) + 4);\n                uVar40 = (uVar25 >> 3) + 1;\n                *(undefined4 *)ppcVar32 = *(undefined4 *)((long)pcVar46 + 0x10);\n                *(undefined4 *)((long)ppcVar32 + 4) = uVar17;\n                *(undefined4 *)(ppcVar32 + 1) = uVar6;\n                *(undefined4 *)((long)ppcVar32 + 0xc) = uVar7;\n                uVar17 = *(undefined4 *)((long)((long)pcVar46 + 0x20) + 4);\n                uVar6 = *(undefined4 *)((long)pcVar46 + 0x28);\n                uVar7 = *(undefined4 *)((long)((long)pcVar46 + 0x28) + 4);\n                uVar25 = uVar40 >> 1;\n                *(undefined4 *)(ppcVar32 + 2) = *(undefined4 *)((long)pcVar46 + 0x20);\n                *(undefined4 *)((long)ppcVar32 + 0x14) = uVar17;\n                *(undefined4 *)(ppcVar32 + 3) = uVar6;\n                *(undefined4 *)((long)ppcVar32 + 0x1c) = uVar7;\n                if (uVar25 != 2) {\n                  uVar17 = *(undefined4 *)((long)((long)pcVar46 + 0x30) + 4);\n                  uVar6 = *(undefined4 *)((long)pcVar46 + 0x38);\n                  uVar7 = *(undefined4 *)((long)((long)pcVar46 + 0x38) + 4);\n                  *(undefined4 *)(ppcVar32 + 4) = *(undefined4 *)((long)pcVar46 + 0x30);\n                  *(undefined4 *)((long)ppcVar32 + 0x24) = uVar17;\n                  *(undefined4 *)(ppcVar32 + 5) = uVar6;\n                  *(undefined4 *)((long)ppcVar32 + 0x2c) = uVar7;\n                  if (uVar25 != 3) {\n                    uVar41 = 3;\n                    do {\n                      uVar42 = uVar41 + 1;\n                      pcVar39 = (char *)((long)pcVar46 + 0x83) + uVar41 * 0x10 + -0x73;\n                      uVar17 = *(undefined4 *)(pcVar39 + 4);\n                      uVar6 = *(undefined4 *)(pcVar39 + 8);\n                      uVar7 = *(undefined4 *)(pcVar39 + 0xc);\n                      ppcVar31 = ppcVar32 + uVar41 * 2;\n                      *(undefined4 *)ppcVar31 = *(undefined4 *)pcVar39;\n                      *(undefined4 *)((long)ppcVar31 + 4) = uVar17;\n                      *(undefined4 *)(ppcVar31 + 1) = uVar6;\n                      *(undefined4 *)((long)ppcVar31 + 0xc) = uVar7;\n                      uVar41 = uVar42;\n                    } while (uVar42 != uVar25);\n                  }\n                }\n                if ((uVar40 & 1) != 0) {\n                  ppcVar32[uVar40 & 0xfffffffffffffffe] =\n                       *(char **)((long)local_128 + (uVar40 & 0xfffffffffffffffe) * 8);\n                }\n              }\n              ppcVar32 = ppcVar32 + lVar24 + -2;\n            }\n            pFVar18 = (FILE *)(ulong)(iVar15 - 1);\n            *ppcVar32 = (char *)0x0;\n            pcVar46 = (char *)unaff_R12;\n          }\nLAB_001065a2:\n          while( true ) {\n            uVar16 = (uint)unaff_R12;\n            uVar44 = getopt_long((ulong)pFVar18 & 0xffffffff,pcVar46,pFVar22,puVar36,0);\n            unaff_RBP = (char *)pFVar22;\n            if (uVar44 == 0xffffffff) break;\n            if (((uVar44 - 100 < 0x15) && ((0x117201UL >> ((ulong)(uVar44 - 100) & 0x3f) & 1) != 0))\n               && (operation != 0)) goto LAB_001067f7;\n            pFVar28 = (FILE *)pcVar46;\n            if (uVar44 < 0xcc) {\n                    /* WARNING: Could not recover jumptable at 0x001065eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              (*(code *)((long)(int *)pcVar43 + (long)((int *)pcVar43)[uVar44]))();\n              return;\n            }\nswitchD_00107462_caseD_1:\n            usage(0);\n            pcVar46 = (char *)pFVar28;\nswitchD_00107462_caseD_68:\n            show_help = 1;\n          }\nLAB_00106680:\n          uVar44 = operation;\n          pFVar22 = (FILE *)unaff_RBP;\n          if (operation == 0) {\n            if (((write_armap == 1) || (mri_mode != 0)) ||\n               (((int)pFVar18 <= _optind || (_optind < 1)))) {\n              uVar44 = 0;\n              goto LAB_001066aa;\n            }\n            pcVar46 = (char *)((long)pcVar46 + (long)_optind * 8 + -8);\n            uVar16 = (int)pFVar18 - (_optind + -1);\n            pFVar18 = (FILE *)(ulong)uVar16;\n            _optind = 0;\n            if (1 < (int)uVar16) goto LAB_001063a3;\n            goto LAB_001065a2;\n          }\nLAB_001066aa:\n          unaff_R12 = (FILE *)((ulong)local_130 & 0xff);\n          uVar16 = (uint)unaff_R12;\n          puVar36 = (undefined1 *)((int *)pcVar46 + (long)_optind * 2);\n          if (show_help == 0) {\n            if (show_version != 0) {\n              print_version(&DAT_0010807c);\n              goto LAB_00107591;\n            }\n            if (mri_mode == 0) {\n              pFVar28 = (FILE *)pcVar46;\n              if (*(long *)puVar36 == 0) goto switchD_00107462_caseD_1;\n              if (operation == 7) {\n                if (write_armap == 0) {\n                  if (uVar44 == 3) goto LAB_00106abc;\n                  if (uVar44 != 0) goto LAB_00106700;\nLAB_00106eff:\n                  pcVar39 = \"no operation specified\";\n                  goto LAB_00106803;\n                }\n                operation = 2;\n                if (newer_only != 0) goto LAB_0010704f;\n              }\n              else if ((uVar44 == 3) || (uVar44 == 0)) {\n                if (write_armap == 1) {\n                  uVar17 = ranlib_only();\n                    \n                  xexit(uVar17);\n                }\nLAB_00106abc:\n                if (uVar44 == 0) goto LAB_00106eff;\n                if (newer_only != 0) {\nLAB_00106ad1:\n                  pcVar39 = \"`u\\' is only meaningful with the `r\\' option.\";\n                  goto LAB_00106803;\n                }\n              }\n              else {\nLAB_00106700:\n                if (newer_only != 0) goto LAB_00107548;\n              }\nLAB_0010670d:\n              if (deterministic < 0) {\n                deterministic = 1;\n              }\nLAB_00106720:\n              unaff_RBP = (char *)0x0;\n              if (postype != 0) {\n                posname = *(long *)puVar36;\n                unaff_RBP = (char *)0x1;\n                pcVar39 = \"missing position arg.\";\n                if (posname == 0) goto LAB_00106803;\n              }\n              if (counted_name_mode != '\\0') {\n                pcVar39 = \"`N\\' is only meaningful with the `x\\' and `d\\' options.\";\n                if ((operation & 0xfffffffb) == 1) {\n                  iVar15 = (int)unaff_RBP;\n                  if (*(char **)((long)puVar36 + (long)iVar15 * 2 * 4) == (char *)0x0) {\n                    uVar27 = dcgettext(0,\"`N\\' missing value.\",5);\n                    fatal(uVar27);\n                    uVar44 = extraout_EDX;\nLAB_00107548:\n                    if (uVar44 == 2) {\nLAB_0010704f:\n                      pcVar39 = \"`u\\' is not meaningful with the `D\\' option.\";\n                      if (deterministic < 1) goto code_r0x00107068;\n                      goto LAB_00106803;\n                    }\n                    goto LAB_00106ad1;\n                  }\n                  unaff_RBP = (char *)(ulong)(iVar15 + 1);\n                  lVar24 = strtol(*(char **)((long)puVar36 + (long)iVar15 * 2 * 4),(char **)0x0,10);\n                  pcVar39 = \"Value for `N\\' must be positive.\";\n                  counted_name_counter = (int)lVar24;\n                  if (0 < counted_name_counter) goto LAB_0010673c;\n                }\n                goto LAB_00106803;\n              }\nLAB_0010673c:\n              lVar24 = (long)(int)unaff_RBP;\n              pFVar22 = (FILE *)unaff_RBP;\n              if (*(long *)(int *)((long)puVar36 + lVar24 * 2 * 4) == 0)\n              goto switchD_00107462_caseD_1;\n              pFVar22 = (FILE *)((long)puVar36 + (lVar24 + 1) * 2 * 4);\n              if (*(FILE **)pFVar22 == (FILE *)0x0) {\n                pcVar43 = (char *)0x0;\n                pFVar22 = (FILE *)0x0;\n              }\n              else if (*(long *)((long)puVar36 + (lVar24 + 2) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x1;\n              }\n              else if (*(long *)((long)puVar36 + (lVar24 + 3) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x2;\n              }\n              else if (*(long *)((long)puVar36 + (lVar24 + 4) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x3;\n              }\n              else if (*(long *)((long)puVar36 + (lVar24 + 5) * 2 * 4) == 0) {\n                pcVar43 = (char *)0x4;\n              }\n              else {\n                pFVar18 = (FILE *)0x5;\n                do {\n                  pcVar43 = (char *)pFVar18;\n                  pFVar18 = (FILE *)((long)(int *)pcVar43 + 1);\n                } while (*(long *)((int *)((long)puVar36 + lVar24 * 2 * 4) + (long)pFVar18 * 2) != 0\n                        );\n              }\n              puVar26 = (undefined8 *)open_inarch();\n              pFVar18 = pFVar22;\n              if (operation == 5) {\n                pcVar39 = \"`x\\' cannot be used on thin archives.\";\n                if ((*(byte *)((long)puVar26 + 0x49) & 0x10) == 0) {\n                  unaff_RBP = (char *)pFVar22;\n                  if (libdeps != (char *)0x0) goto LAB_00106d5c;\nswitchD_00106ed8_caseD_5:\n                  map_over_members(puVar26,extract_file,unaff_RBP,(ulong)pcVar43 & 0xffffffff);\n                  goto LAB_0010696c;\n                }\n                goto LAB_00106803;\n              }\n              if (libdeps != (char *)0x0) {\nLAB_00106d5c:\n                sVar19 = strlen(libdeps);\n                pcVar46 = \"__.LIBDEP\";\n                unaff_RBP = (char *)(sVar19 + 1);\n                libdeps_bfd = bfd_create(\"__.LIBDEP\",puVar26);\n                if (libdeps_bfd == 0) {\n                  pcVar39 = \"Cannot create libdeps record.\";\n                }\n                else {\n                  lVar24 = bfd_find_target(\"binary\",libdeps_bfd);\n                  pcVar39 = \"Cannot set libdeps record type to binary.\";\n                  if (lVar24 != 0) {\n                    cVar14 = bfd_set_format(libdeps_bfd,1,5);\n                    pcVar39 = \"Cannot set libdeps object format.\";\n                    if (cVar14 == '\\0') goto LAB_00106803;\n                    cVar14 = bfd_make_writable(libdeps_bfd,\"Cannot set libdeps object format.\",5);\n                    pcVar39 = \"Cannot make libdeps object writable.\";\n                    if (cVar14 == '\\0') goto LAB_00106803;\n                    pFVar28 = (FILE *)bfd_bwrite(libdeps,unaff_RBP,libdeps_bfd);\n                    pcVar39 = \"Cannot write libdeps record.\";\n                    if (pFVar28 != (FILE *)unaff_RBP) goto LAB_00106803;\n                    cVar14 = bfd_make_readable(libdeps_bfd,\"Cannot write libdeps record.\",5);\n                    pcVar39 = \"Cannot make libdeps object readable.\";\n                    if (cVar14 == '\\0') goto LAB_00106803;\n                    lVar24 = bfd_find_target(\"plugin\",libdeps_bfd,5);\n                    pcVar39 = \"Cannot reset libdeps record type.\";\n                    if (lVar24 == 0) goto LAB_00106803;\n                    iVar15 = (int)pcVar43;\n                    local_130 = (FILE *)((long)(iVar15 + 2) * 8);\n                    unaff_RBP = (char *)xmalloc(local_130,\"Cannot reset libdeps record type.\");\n                    if (iVar15 == 0) {\n                      lVar24 = 0;\n                    }\n                    else {\n                      uVar17 = *(undefined4 *)&pFVar22->field_0x4;\n                      *(int *)unaff_RBP = pFVar22->_flags;\n                      *(undefined4 *)((long)unaff_RBP + 4) = uVar17;\n                      lVar24 = 8;\n                      ppcVar31 = (char **)((long)unaff_RBP + 8);\n                      for (pcVar43 = local_130[-1]._unused2 + 4; pcVar43 != (char *)0x0;\n                          pcVar43 = pcVar43 + -1) {\n                        *(undefined *)ppcVar31 = *(undefined *)&pFVar22->_flags;\n                        pFVar22 = (FILE *)((long)pFVar22 + (ulong)bVar48 * -2 + 1);\n                        ppcVar31 = (char **)((long)ppcVar31 + (ulong)bVar48 * -2 + 1);\n                      }\n                    }\n                    *(char **)((long)(char **)unaff_RBP + lVar24) = \"__.LIBDEP\";\n                    pcVar43 = (char *)(ulong)(iVar15 + 1);\n                    *(undefined8 *)\n                     (((FILE *)((long)unaff_RBP + -0xd8))->_unused2 + 0xc + (long)local_130) = 0;\n                    switch(operation) {\n                    case 1:\n                      goto switchD_00106ed8_caseD_1;\n                    case 2:\n                    case 7:\n                      break;\n                    case 3:\n                      goto switchD_00106ed8_caseD_3;\n                    case 4:\n                      goto switchD_00106ed8_caseD_4;\n                    case 5:\n                      goto switchD_00106ed8_caseD_5;\n                    case 6:\n                      pFVar22 = (FILE *)unaff_RBP;\n                      if (silent_create == 0) goto LAB_00106afb;\n                      break;\n                    default:\n                      goto switchD_001067e8_caseD_5;\n                    }\n                    goto switchD_00106ed8_caseD_2;\n                  }\n                }\n                goto LAB_00106803;\n              }\n              switch(operation) {\n              case 1:\n                unaff_RBP = (char *)pFVar22;\n                if (pFVar22 == (FILE *)0x0) break;\nswitchD_00106ed8_caseD_1:\n                pFVar18 = (FILE *)0x0;\n                goto LAB_00106b89;\n              case 2:\n              case 7:\nswitchD_001067e8_caseD_2:\n                unaff_RBP = (char *)pFVar22;\n                if ((pFVar22 != (FILE *)0x0) || (0 < write_armap)) {\nswitchD_00106ed8_caseD_2:\n                  replace_members(puVar26,unaff_RBP,operation == 7);\n                  goto LAB_0010696c;\n                }\n                break;\n              case 3:\n                unaff_RBP = (char *)pFVar22;\nswitchD_00106ed8_caseD_3:\n                map_over_members(puVar26,print_descr,unaff_RBP,(ulong)pcVar43 & 0xffffffff);\n                goto LAB_0010696c;\n              case 4:\n                unaff_RBP = (char *)pFVar22;\nswitchD_00106ed8_caseD_4:\n                map_over_members(puVar26,print_contents,unaff_RBP,(ulong)pcVar43 & 0xffffffff);\n                goto LAB_0010696c;\n              default:\nswitchD_001067e8_caseD_5:\n                pcVar39 = \"internal error -- this option not implemented\";\n                goto LAB_00106803;\n              case 6:\n                if (silent_create != 0) goto switchD_001067e8_caseD_2;\n                if (pFVar22 == (FILE *)0x0) break;\nLAB_00106afb:\n                pFVar18 = (FILE *)(puVar26 + 0x1e);\n                do {\n                  unaff_R12 = pFVar18;\n                  if (*(FILE **)pFVar22 == (FILE *)0x0) {\nLAB_00106b9f:\n                    write_archive(puVar26);\n                    goto LAB_0010696c;\n                  }\n                  while( true ) {\n                    plVar21 = *(long **)unaff_R12;\n                    pcVar46 = *(char **)pFVar22;\n                    if (plVar21 == (long *)0x0) {\n                      uVar27 = *puVar26;\n                      uVar30 = dcgettext(0,\"no entry %s in archive %s!\",5);\n                      fatal(uVar30,pcVar46,uVar27);\n                      pcVar43 = (char *)0x0;\n                      goto LAB_00107293;\n                    }\n                    lVar24 = *plVar21;\n                    uVar27 = normalize(pcVar46,puVar26);\n                    iVar15 = filename_cmp(uVar27,lVar24);\n                    if (iVar15 == 0) break;\n                    unaff_R12 = (FILE *)(*(long **)unaff_R12 + 0x1e);\n                  }\n                  *(long **)unaff_R12 = (long *)plVar21[0x1e];\n                  pplVar29 = (long **)get_pos_bfd(pFVar18,3,0);\n                  bVar47 = verbose != 0;\n                  plVar4 = *pplVar29;\n                  *pplVar29 = plVar21;\n                  plVar21[0x1e] = (long)plVar4;\n                  if (bVar47) {\n                    printf(\"m - %s\\n\",*(FILE **)pFVar22);\n                  }\n                  pFVar22 = (FILE *)&pFVar22->_IO_read_ptr;\n                } while( true );\n              }\n              goto LAB_00106d4e;\n            }\n            if (-1 < deterministic) goto LAB_0010755f;\n          }\n          else {\nLAB_00107591:\n            usage(1);\n          }\n          deterministic = 1;\nLAB_0010755f:\n          iVar15 = fileno(_stdin);\n          interactive = isatty(iVar15);\n          yyparse_isra_0();\nLAB_0010696c:\n                    \n          xexit(0);\n        }\n        uVar17 = bfd_get_error();\n        pFVar22 = (FILE *)bfd_errmsg(uVar17);\n        uVar27 = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n        iVar15 = fatal(uVar27,\"x86_64-pc-linux-gnu\",pFVar22);\nLAB_0010751b:\n        if (operation == 0) {\nLAB_00107447:\n          puVar36 = pcVar39;\n          pFVar28 = (FILE *)pcVar46;\n          switch(iVar15) {\n          case 0:\n            goto switchD_00107462_caseD_0;\n          default:\n            goto switchD_00107462_caseD_1;\n          case 0x44:\n            deterministic = 1;\n            goto LAB_001065a2;\n          case 0x4d:\n            mri_mode = 1;\n            goto LAB_001065a2;\n          case 0x4e:\n            counted_name_mode = '\\x01';\n            goto LAB_001065a2;\n          case 0x4f:\n            display_offsets = 1;\n            goto LAB_001065a2;\n          case 0x50:\n            full_pathname = 1;\n            goto LAB_001065a2;\n          case 0x53:\n            write_armap = -1;\n            goto LAB_001065a2;\n          case 0x54:\n            make_thin_archive = 1;\n            goto LAB_001065a2;\n          case 0x55:\n            deterministic = 0;\n            goto LAB_001065a2;\n          case 0x56:\n            show_version = 1;\n            goto LAB_001065a2;\n          case 0x61:\n            postype = 2;\n            goto LAB_001065a2;\n          case 0x62:\n          case 0x69:\n            postype = 1;\n            goto LAB_001065a2;\n          case 99:\n            silent_create = 1;\n            goto LAB_001065a2;\n          case 100:\n            operation = 1;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x66:\n            ar_truncate = 1;\n            goto LAB_001065a2;\n          case 0x68:\n            goto switchD_00107462_caseD_68;\n          case 0x6c:\n            if (libdeps == (char *)0x0) {\n              libdeps = _optarg;\n              goto LAB_001065a2;\n            }\nLAB_00107293:\n            uVar16 = (uint)unaff_R12;\n            pcVar39 = \"libdeps specified more than once\";\n            unaff_RBP = (char *)pFVar22;\n            break;\n          case 0x6d:\n            operation = 6;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x6f:\n            preserve_dates = 1;\n            goto LAB_001065a2;\n          case 0x70:\n            operation = 4;\n            goto LAB_001065a2;\n          case 0x71:\n            operation = 7;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x72:\n            operation = 2;\n            operation_alters_arch = 1;\n            goto LAB_001065a2;\n          case 0x73:\n            write_armap = 1;\n            goto LAB_001065a2;\n          case 0x74:\n            operation = 3;\n            goto LAB_001065a2;\n          case 0x75:\n            newer_only = 1;\n            goto LAB_001065a2;\n          case 0x76:\n            verbose = 1;\n            goto LAB_001065a2;\n          case 0x78:\n            operation = 5;\n            goto LAB_001065a2;\n          case 0xc9:\n            bfd_plugin_set_plugin(_optarg);\n            goto LAB_001065a2;\n          case 0xca:\n            target = _optarg;\n            goto LAB_001065a2;\n          case 0xcb:\n            output_dir = _optarg;\n            goto LAB_001065a2;\n          }\n          goto LAB_00106803;\n        }\nLAB_001067f7:\n        pcVar39 = \"two different operation options specified\";\n        unaff_RBP = (char *)pFVar22;\nLAB_00106803:\n        uVar27 = dcgettext(0,pcVar39,5);\n        fatal(uVar27);\nLAB_00106814:\n        iVar15 = (int)pcVar46;\n        pFVar28 = (FILE *)xmalloc(8);\n        *(long **)pFVar28 = (long *)0x0;\n        if ((FILE *)pcVar43 == param_2) {\nLAB_00106834:\n          if (*(long **)pcVar43 == (long *)0x0) {\n            iVar15 = 0;\n          }\n          else {\n            lVar24 = 1;\n            do {\n              iVar15 = (int)lVar24;\n              lVar35 = lVar24 * 2;\n              lVar24 = lVar24 + 1;\n            } while (*(long *)((int *)pcVar43 + lVar35) != 0);\n          }\n          pFVar22 = (FILE *)xmalloc((long)(iVar15 + 1) << 3);\n          plVar21 = *(long **)pcVar43;\n          lVar24 = 0;\n          while (plVar21 != (long *)0x0) {\n            uVar27 = xstrdup();\n            *(undefined8 *)((long)&pFVar22->_flags + lVar24) = uVar27;\n            plVar21 = *(long **)((char *)((long)pcVar43 + 0x83) + lVar24 + -0x7b);\n            lVar24 = lVar24 + 8;\n          }\n          *(undefined8 *)((long)&pFVar22->_flags + lVar24) = 0;\nLAB_0010610a:\n          iVar15 = (int)pcVar46;\n          pcVar43 = (char *)pFVar22;\n          if (*(long **)pFVar28 == (long *)0x0) goto LAB_00106a80;\n          lVar24 = 0;\n          do {\n            lVar34 = lVar24 + 1;\n            lVar35 = lVar24 * 8;\n            lVar24 = lVar34;\n          } while (*(long *)(pFVar28->_shortbuf + lVar35 + -0x7b) != 0);\n          local_108 = lVar34 * 8;\n        }\n        else {\nLAB_00106a80:\n          lVar34 = 0;\n          local_108 = 0;\n        }\n        lVar24 = (long)unaff_RBP * 2;\n        unaff_RBP = (char *)((long)(char **)unaff_RBP + lVar34);\n        free(*(void **)((int *)pcVar43 + lVar24));\n        pFVar22 = (FILE *)xrealloc(pcVar43,(lVar34 + 1 + (long)iVar15) * 8);\n        uVar44 = iVar15 + -1 + (int)lVar34;\n        pcVar46 = (char *)(ulong)uVar44;\n        memmove(&pFVar22->_flags + (long)unaff_RBP * 2,\n                (void *)((long)&pFVar22->_IO_read_ptr + (long)local_130),\n                (long)(int)(iVar15 - uVar16) << 3);\n        memcpy((void *)((long)&local_130->_flags + (long)&pFVar22->_flags),pFVar28,local_108);\n        free(pFVar28);\n        free(local_118);\n        fclose(pFVar18);\n        uVar16 = (int)local_128 + 1;\n        unaff_R12 = local_130;\n        pcVar43 = (char *)pFVar22;\n        local_130 = pFVar28;\n        if ((int)uVar16 < (int)uVar44) goto LAB_001061ce;\n      } while( true );\n    }\n    uVar16 = uVar16 + 1;\n    local_128 = unaff_R12;\nLAB_001061ce:\n    unaff_R12 = (FILE *)(ulong)uVar16;\n  } while( true );\nswitchD_00107462_caseD_0:\n  iVar15 = getopt_long((ulong)pFVar18 & 0xffffffff,pcVar46,pFVar22,\"x86_64-pc-linux-gnu\");\n  unaff_RBP = (char *)pFVar22;\n  if (iVar15 == -1) goto LAB_00106680;\n  if ((0x14 < iVar15 - 100U) || ((0x117201UL >> ((byte)(iVar15 - 100U) & 0x3f) & 1) == 0))\n  goto LAB_00107447;\n  goto LAB_0010751b;\ncode_r0x00107068:\n  if (deterministic != 0) goto code_r0x0010706e;\n  goto LAB_00106720;\ncode_r0x0010706e:\n  uVar27 = dcgettext(0,\"`u\\' modifier ignored since `D\\' is the default (see `U\\')\",5);\n  non_fatal(uVar27);\n  goto LAB_0010670d;\nLAB_00106b89:\n  if (*(FILE **)unaff_RBP == (FILE *)0x0) {\n    if ((char)pFVar18 != '\\0') goto LAB_00106b9f;\nLAB_00106d4e:\n    output_filename = 0;\n    goto LAB_0010696c;\n  }\n  iVar45 = 0;\n  iVar15 = strcmp((char *)*(FILE **)unaff_RBP,\"__.SYMDEF\");\n  puVar5 = puVar26;\n  if (iVar15 == 0) {\n    *(byte *)((long)puVar26 + 0x49) = *(byte *)((long)puVar26 + 0x49) & 0xf7;\n    write_armap = -1;\n  }\n  else {\n    while( true ) {\n      plVar21 = puVar5 + 0x1e;\n      if ((undefined8 *)*plVar21 == (undefined8 *)0x0) break;\n      uVar27 = *(undefined8 *)*plVar21;\n      uVar30 = normalize(*(FILE **)unaff_RBP,puVar26);\n      iVar15 = filename_cmp(uVar30,uVar27);\n      if ((iVar15 == 0) &&\n         ((counted_name_mode == '\\0' || (iVar45 = iVar45 + 1, iVar45 == counted_name_counter)))) {\n        if (verbose != 0) {\n          printf(\"d - %s\\n\",*(FILE **)unaff_RBP);\n        }\n        *plVar21 = *(long *)(*plVar21 + 0xf0);\n        pFVar18 = unaff_R12;\n        goto LAB_00106d38;\n      }\n      puVar5 = (undefined8 *)*plVar21;\n    }\n    if (verbose != 0) {\n      pFVar22 = *(FILE **)unaff_RBP;\n      pcVar46 = (char *)dcgettext(0,\"No member named `%s\\'\\n\",5);\n      printf(pcVar46,pFVar22);\n    }\n  }\nLAB_00106d38:\n  unaff_RBP = (char *)((long)unaff_RBP + 8);\n  goto LAB_00106b89;\n}\n\n",
            "called": [
                "open_inarch",
                "bfd_fatal",
                "fprintf",
                "strtol",
                "fread",
                "fclose",
                "bfd_plugin_set_program_name",
                "bfd_errmsg",
                "bfd_plugin_set_plugin",
                "bfd_nonfatal",
                "dcgettext",
                "non_fatal",
                "strcmp",
                "fatal",
                "xmalloc",
                "memmove",
                "write_archive",
                "bindtextdomain",
                "normalize",
                "setlocale",
                "replace_members",
                "printf",
                "ranlib_usage",
                "bfd_close",
                "fopen",
                "bfd_set_format",
                "print_contents",
                "bfd_make_writable",
                "ar_emul_default_parse_arg",
                "bfd_check_format_matches",
                "memcpy",
                "bfd_find_target",
                "bfd_set_error_program_name",
                "bfd_get_error",
                "print_version",
                "open",
                "bfd_set_error",
                "free",
                "bfd_init",
                "xstrdup",
                "ranlib_only",
                "getopt_long",
                "ferror",
                "map_over_members",
                "get_file_size",
                "fileno",
                "bfd_create",
                "stat",
                "strlen",
                "filename_cmp",
                "bfd_set_default_target",
                "bfd_bwrite",
                "bfd_make_readable",
                "usage",
                "xexit",
                "bfd_fdopenr",
                "ftell",
                "textdomain",
                "fseek",
                "remove_output",
                "yyparse.isra.0",
                "xmalloc_set_program_name",
                "print_descr",
                "get_pos_bfd",
                "list_matching_formats",
                "extract_file",
                "xrealloc",
                "xatexit_cleanup",
                "isatty",
                "malloc",
                "lbasename"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105db0",
            "calling": [
                "_start"
            ],
            "imported": false,
            "current_name": "FUNC_00105db0"
        },
        "FUN_00102150": {
            "renaming": {},
            "code": "\n\n\nchar * ctime(time_t *__timer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = ctime(__timer);\n  return pcVar1;\n}\n\n",
            "called": [
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "FUN_00102150"
        },
        "FUN_00102270": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "ar_open",
                "write_archive",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102270"
        },
        "FUN_00103bd1": {
            "renaming": {
                "FUN_00103bd1": "print_matching_formats_00103bd1",
                "param_1": "formats",
                "__format": "formatString",
                "plVar2": "format"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103bd1(long *formats)\n\n{\n  undefined8 uVar1;\n  char *formatString;\n  long *format;\n  \n  fflush(_stdout);\n  uVar1 = program_name;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,formatString,uVar1);\n  for (format = formats; *format != 0; format = format + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(formats);\n  fputc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fflush",
                "fputc",
                "free",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bd1",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103bd1"
        },
        "FUN_00102030": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "list_matching_formats",
                "print_contents",
                "list_supported_targets",
                "extract_file.cold",
                "write_archive.cold",
                "main",
                "make_tempname.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102030"
        },
        "FUN_00102710": {
            "renaming": {
                "FUN_00102710": "extract_and_convert_lib_00102710",
                "in_stack_00000008": "output_filename",
                "unaff_RBP": "target",
                "silent_create": "is_silent_create",
                "make_thin_archive": "is_make_thin_archive",
                "target": "library_path",
                "bfd_openr": "open_read",
                "bfd_check_format": "check_format",
                "bfd_close": "close",
                "bfd_openw": "open_write",
                "bfd_set_format": "set_format",
                "bfd_fatal": "fatal_error",
                "bfd_nonfatal": "non_fatal_error",
                "bfd_get_error": "get_error",
                "bfd_openr_next_archived_file": "open_next_archived_file",
                "dcgettext": "get_text",
                "list_matching_formats": "list_formats",
                "xexit": "exit",
                "operation": "opertation_type",
                "stack0x00000008": "stack_param",
                "output_filename": "output_path"
            },
            "code": "\nundefined8 * extract_and_convert_lib_00102710(void)\n\n{\n  long *plVar1;\n  char cVar2;\n  byte bVar3;\n  int iVar4;\n  long lVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 *puVar8;\n  undefined8 target;\n  undefined8 output_filename;\n  \n  lVar5 = open_read();\n  if (lVar5 != 0) {\n    cVar2 = check_format(lVar5,1);\n    if (cVar2 != '\\0') {\n      library_path = **(undefined8 **)(lVar5 + 8);\n    }\n    close(lVar5);\n  }\n  puVar8 = (undefined8 *)open_write();\n  if (((puVar8 != (undefined8 *)0x0) && (cVar2 = set_format(puVar8,2), cVar2 != '\\0')) &&\n     (cVar2 = close(puVar8), cVar2 != '\\0')) {\n    if (is_silent_create == 0) goto LAB_00102826;\n    goto LAB_001053b7;\n  }\n  fatal_error();\n  do {\n    bVar3 = *(byte *)((long)puVar8 + 0x49) >> 4 & 1;\n    if (is_make_thin_archive == '\\0') {\n      if (bVar3 != 0) {\n        uVar7 = *puVar8;\n        uVar6 = get_text(0,\"Cannot convert existing thin library %s to normal format\",5);\n        fatal(uVar6,uVar7);\n        goto LAB_00102812;\n      }\n    }\n    else if (bVar3 == 0) {\n      uVar7 = *puVar8;\n      uVar6 = get_text(0,\"Cannot convert existing library %s to thin format\",5);\n      fatal(uVar6,uVar7);\nLAB_001027cb:\n      non_fatal_error();\n      iVar4 = get_error();\n      if (iVar4 == 0xd) {\nLAB_00102812:\n        list_formats(output_filename);\n      }\n                    \n      exit(1);\n    }\n    do {\n      plVar1 = puVar8 + 0x1e;\n      for (lVar5 = open_next_archived_file(puVar8,0); lVar5 != 0;\n          lVar5 = open_next_archived_file(puVar8,lVar5)) {\n        *plVar1 = lVar5;\n        plVar1 = (long *)(lVar5 + 0xf0);\n      }\n      *plVar1 = 0;\n      iVar4 = get_error();\n      if (iVar4 == 9) {\n        return puVar8;\n      }\n      do {\n        fatal_error();\nLAB_00102826:\n        uVar7 = get_text(0,\"creating %s\",5);\n        non_fatal(uVar7);\nLAB_001053b7:\n        output_path = target;\n        puVar8 = (undefined8 *)open_read();\n      } while (puVar8 == (undefined8 *)0x0);\n      cVar2 = check_format_matches(puVar8,2,&stack_param);\n      if (cVar2 == '\\0') goto LAB_001027cb;\n    } while (((opertation_type != 2) && (opertation_type != 7)) ||\n            (lVar5 = open_next_archived_file(puVar8,0), lVar5 == 0));\n  } while( true );\n}\n\n",
            "called": [
                "bfd_check_format",
                "bfd_close",
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102710",
            "calling": [
                "open_inarch"
            ],
            "imported": false,
            "current_name": "extract_and_convert_lib_00102710"
        },
        "FUN_0010e2b0": {
            "renaming": {},
            "code": "\n\n\n\nvoid exit(int __status)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* exit@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2b0",
            "calling": [
                "exit"
            ],
            "imported": false,
            "current_name": "FUN_0010e2b0"
        },
        "FUN_0010e208": {
            "renaming": {},
            "code": "\n\n\n\nint fflush(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fflush@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e208",
            "calling": [
                "fflush"
            ],
            "imported": false,
            "current_name": "FUN_0010e208"
        },
        "FUN_00103e95": {
            "renaming": {
                "FUN_00103e95": "parse_file_00103e95",
                "pplVar1": "pointerToPointer",
                "cVar2": "character",
                "ppFVar3": "pointerToPointerOfFile",
                "pFVar4": "pointerToFile",
                "plVar5": "pointerToLong",
                "uVar6": "unsignedVar",
                "pbVar7": "pointerToByte",
                "iVar8": "integer",
                "pcVar10": "pointerToCharacter",
                "uVar11": "unsignedVar",
                "iVar9": "integer",
                "plVar12": "pointerToLong",
                "sVar13": "size",
                "pvVar14": "pointerToVoid",
                "pcVar15": "pointerToCharacter",
                "pcVar16": "pointerToCharacter",
                "lVar17": "longVar",
                "lVar18": "longVar",
                "uVar19": "unsignedVar",
                "uVar20": "unsignedVar",
                "lVar21": "longVar",
                "puVar22": "pointerToUnsignedVar",
                "puVar23": "pointerToUnsignedVar",
                "uVar24": "unsignedVar",
                "iVar25": "integer",
                "uVar26": "unsignedVar",
                "ppcVar27": "pointerToPointerOfCharacter",
                "bVar28": "boolean",
                "ppcVar29": "pointerToPointerOfCharacter",
                "bVar30": "byteVar",
                "lVar31": "longVar",
                "pbVar32": "pointerToByte",
                "pbVar33": "pointerToByte",
                "piVar34": "pointerToInteger",
                "pbVar35": "pointerToByte",
                "uVar36": "unsignedVar",
                "iVar37": "integer",
                "ppcVar38": "pointerToPointerOfCharacter",
                "bVar39": "boolean",
                "auVar40": "arrayOfUnsignedVar[16]",
                "auVar41": "arrayOfUnsignedVar[16]",
                "local_828": "localPointerToCharacter",
                "local_820": "localPointerToCharacter",
                "local_818": "localLongVar",
                "local_810": "localPointerToPointerOfCharacter",
                "local_800": "localInteger",
                "local_7fc": "localUnsignedVar",
                "local_7f8": "localPointerToByte",
                "local_7d0": "localStat",
                "local_740": "localArray[200]",
                "local_678": "localArray[201]"
            },
            "code": "\n\n\nvoid parseFile_00103e95(void)\n\n{\n  long **pointerToPointer;\n  char character;\n  FILE **pointerToPointerOfFile;\n  FILE *pointerToFile;\n  long *pointerToLong;\n  undefined8 unsignedVar;\n  byte *pointerToByte;\n  int integer;\n  char *pointerToCharacter;\n  undefined8 unsignedVar;\n  int integer;\n  long *pointerToLong;\n  size_t size;\n  void *pointerToVoid;\n  char *pointerToCharacter;\n  char *pointerToCharacter;\n  long longVar;\n  long longVar;\n  ulong unsignedVar;\n  uint unsignedVar;\n  long longVar;\n  undefined8 *pointerToUnsignedVar;\n  undefined8 *pointerToUnsignedVar;\n  uint unsignedVar;\n  int integer;\n  ulong unsignedVar;\n  char **pointerToPointerOfCharacter;\n  bool boolean;\n  char **pointerToPointerOfCharacter;\n  byte byteVar;\n  long longVar;\n  byte *pointerToByte;\n  byte *pointerToByte;\n  int *pointerToInteger;\n  byte *pointerToByte;\n  uint unsignedVar;\n  int integer;\n  char **pointerToPointerOfCharacter;\n  byte boolean;\n  undefined arrayOfUnsignedVar[16] [16];\n  undefined arrayOfUnsignedVar[16] [16];\n  char *localPointerToCharacter;\n  char *localPointerToCharacter;\n  long localLongVar;\n  char **localPointerToPointerOfCharacter;\n  int localInteger;\n  uint localUnsignedVar;\n  byte *localPointerToByte;\n  stat localStat;\n  char localArray[200] [200];\n  char *localArray[201] [201];\n  \n  boolean = 0;\n  longVar = 0;\n  yychar = -2;\n  pointerToPointerOfCharacter = localArray[201];\n  localInteger = 0;\n  localPointerToCharacter = localArray[200];\n  localLongVar = 200;\n  localPointerToCharacter = localPointerToCharacter;\n  localPointerToPointerOfCharacter = pointerToPointerOfCharacter;\nLAB_00103ee9:\n  *localPointerToCharacter = (char)longVar;\n  if (localPointerToCharacter + localLongVar + -1 <= localPointerToCharacter) {\n    longVar = (long)localPointerToCharacter - (long)localPointerToCharacter;\n    longVar = longVar + 1;\n    if (localLongVar < 10000) {\n      longVar = localLongVar * 2;\n      localLongVar = 10000;\n      if (longVar < 0x2711) {\n        localLongVar = longVar;\n      }\n      pointerToCharacter = (char *)malloc(localLongVar * 9 + 7);\n      if (pointerToCharacter != (char *)0x0) {\n        longVar = longVar * 8;\n        pointerToCharacter = localPointerToCharacter;\n        pointerToCharacter = pointerToCharacter;\n        for (; longVar != 0; longVar = longVar + -1) {\n          *pointerToCharacter = *pointerToCharacter;\n          pointerToCharacter = pointerToCharacter + (ulong)boolean * -2 + 1;\n          pointerToCharacter = pointerToCharacter + (ulong)boolean * -2 + 1;\n        }\n        pointerToPointerOfCharacter = (char **)(pointerToCharacter + localLongVar);\n        pointerToPointerOfCharacter = pointerToPointerOfCharacter;\n        for (; longVar != 0; longVar = longVar + -1) {\n          *(undefined *)pointerToPointerOfCharacter = *(undefined *)localPointerToPointerOfCharacter;\n          localPointerToPointerOfCharacter = (char **)((long)localPointerToPointerOfCharacter + (ulong)boolean * -2 + 1);\n          pointerToPointerOfCharacter = (char **)((long)pointerToPointerOfCharacter + (ulong)boolean * -2 + 1);\n        }\n        if (localPointerToCharacter != localArray[200]) {\n          free(localPointerToCharacter);\n        }\n        localPointerToCharacter = pointerToCharacter + longVar;\n        pointerToPointerOfCharacter = pointerToPointerOfCharacter + longVar;\n        localPointerToCharacter = pointerToCharacter;\n        localPointerToPointerOfCharacter = pointerToPointerOfCharacter;\n        if (pointerToCharacter + localLongVar + -1 <= localPointerToCharacter) goto LAB_00105265;\n        goto LAB_00103fd8;\n      }\n    }\n    yyerror_constprop_0();\nLAB_0010524c:\n    pointerToCharacter = localPointerToCharacter;\n    if (localPointerToCharacter == localArray[200]) {\n      return;\n    }\nLAB_00105265:\n    free(pointerToCharacter);\n    return;\n  }\nLAB_00103fd8:\n  integer = (int)longVar;\n  if (integer == 3) goto LAB_0010524c;\n  character = (&yypact)[integer];\n  if (character != -0xe) {\n    if (yychar == -2) {\n      if (yy_init == 0) {\n        yy_init = 1;\n        if (yy_start == 0) {\n          yy_start = 1;\n        }\n        if (yyin == (FILE *)0x0) {\n          yyin = _stdin;\n        }\n        if (yyout == (FILE *)0x0) {\n          yyout = _stdout;\n        }\n        if ((yy_buffer_stack == 0) || (*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) == 0)) {\n          yyensure_buffer_stack();\n          pointerToUnsignedVar = (undefined8 *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n          unsignedVar = yy_create_buffer_constprop_0(yyin);\n          *pointerToUnsignedVar = unsignedVar;\n        }\n        yy_load_buffer_state();\n      }\nLAB_001040b1:\n      *yy_c_buf_p = yy_hold_char;\n      pointerToByte = yy_c_buf_p;\n      pointerToByte = yy_c_buf_p;\n      unsignedVar = yy_start;\nLAB_001040d4:\n      unsignedVar = (ulong)unsignedVar;\n      unsignedVar = (ulong)localUnsignedVar;\n      boolean = false;\n      do {\n        byteVar = yy_ec[*pointerToByte];\n        if (*(short *)(yy_accept + (long)(int)unsignedVar * 2) != 0) {\n          boolean = true;\n          unsignedVar = unsignedVar & 0xffffffff;\n          localPointerToByte = pointerToByte;\n        }\n        while( true ) {\n          integer = (int)unsignedVar;\n          longVar = (long)(int)((int)*(short *)(yy_base + (long)integer * 2) + (uint)byteVar);\n          if (integer == *(short *)(yy_chk + longVar * 2)) break;\n          unsignedVar = (ulong)(uint)(int)*(short *)(yy_def + (long)integer * 2);\n          if (0xb0 < *(short *)(yy_def + (long)integer * 2)) {\n            byteVar = yy_meta[(int)(uint)byteVar];\n          }\n        }\n        pointerToByte = pointerToByte + 1;\n        unsignedVar = (ulong)*(short *)(yy_nxt + longVar * 2);\n      } while (*(short *)(yy_base + unsignedVar * 2) != 0xc2);\n      localUnsignedVar = (uint)unsignedVar;\n      pointerToByte = pointerToByte;\n      if (boolean) {\n        yy_last_accepting_cpos = localPointerToByte;\n        yy_last_accepting_state = localUnsignedVar;\n      }\nLAB_0010419f:\n      integer = (int)*(short *)(yy_accept + (long)(int)unsignedVar * 2);\n      if (integer == 0) {\n        integer = (int)*(short *)(yy_accept + (long)(int)yy_last_accepting_state * 2);\n        pointerToByte = yy_last_accepting_cpos;\n      }\n      yyleng = (int)pointerToByte - (int)pointerToByte;\n      yy_hold_char = *pointerToByte;\n      yy_c_buf_p = pointerToByte;\n      yytext = pointerToByte;\n      *pointerToByte = 0;\nLAB_001041f0:\n      pointerToByte = yytext;\n      longVar = yy_buffer_stack_top;\n      switch(integer) {\n      case 0:\n        goto switchD_00104200_caseD_0;\n      case 1:\n      case 0x10:\n        yychar = 0x105;\n        break;\n      case 2:\n      case 0x11:\n        yychar = 0x107;\n        break;\n      case 3:\n      case 0x12:\n        yychar = 0x108;\n        break;\n      case 4:\n      case 0x13:\n        yychar = 0x109;\n        break;\n      case 5:\n      case 0x14:\n        yychar = 0x10a;\n        break;\n      case 6:\n      case 0x15:\n        yychar = 0x10b;\n        break;\n      case 7:\n      case 0x16:\n        yychar = 0x10c;\n        break;\n      case 8:\n      case 0x17:\n        yychar = 0x10d;\n        break;\n      case 9:\n      case 0x18:\n        yychar = 0x10e;\n        break;\n      case 10:\n      case 0x19:\n        yychar = 0x10f;\n        break;\n      case 0xb:\n      case 0x1a:\n        yychar = 0x106;\n        break;\n      case 0xc:\n      case 0x1b:\n        yychar = 0x113;\n        break;\n      case 0xd:\n      case 0x1c:\n        yychar = 0x111;\n        break;\n      case 0xe:\n      case 0x1d:\n        yychar = 0x103;\n        break;\n      case 0x1f:\n        linenumber = linenumber + 1;\n        goto LAB_001040b1;\n      case 0x20:\n        yychar = 0x28;\n        break;\n      case 0x21:\n        yychar = 0x29;\n        break;\n      case 0x22:\n        yychar = 0x2c;\n        break;\n      case 0x23:\n        yylval = (char *)xstrdup(yytext);\n        yychar = 0x104;\n        break;\n      case 0x24:\n      case 0x25:\n      case 0x26:\n        goto LAB_001040b1;\n      case 0x27:\n        linenumber = linenumber + 1;\n        yychar = 0x102;\n        break;\n      case 0x28:\n        fwrite(yytext,(long)yyleng,1,yyout);\n        goto LAB_001040b1;\n      case 0x29:\n        goto switchD_00104200_caseD_29;\n      case 0x2a:\n        yychar = 0;\n        break;\n      default:\n        yy_fatal_error(\"fatal flex scanner internal error--no action found\");\n      case 0xf:\n      case 0x1e:\n        yychar = 0x112;\n      }\n      longVar = (long)integer;\n    }\n    if (0 < yychar) {\n      if (yychar != 0x100) {\n        integer = 2;\n        if (yychar < 0x114) {\n          integer = (int)(char)yytranslate[yychar];\n        }\n        goto LAB_0010497d;\n      }\n      yychar = 0x101;\n      goto LAB_001051f0;\n    }\n    integer = 0;\n    yychar = 0;\nLAB_0010497d:\n    unsignedVar = character + integer;\n    if ((0x22 < unsignedVar) || (integer != (char)yycheck[(int)unsignedVar])) goto LAB_001049db;\n    character = yytable[(int)unsignedVar];\n    longVar = (long)character;\n    if (character < '\\x01') {\n      integer = -(int)character;\n      goto LAB_00104a0a;\n    }\n    yychar = -2;\n    localInteger = localInteger + -1 + (uint)(localInteger == 0);\n    pointerToPointerOfCharacter = pointerToPointerOfCharacter + 1;\n    *pointerToPointerOfCharacter = yylval;\n    goto LAB_001049d1;\n  }\nLAB_001049db:\n  integer = (int)(char)(&yydefact)[(int)longVar];\n  if ((&yydefact)[(int)longVar] == '\\0') {\n    if (localInteger == 0) {\n      yynerrs = yynerrs + 1;\n      yyerror_constprop_0();\nLAB_001051f0:\n      do {\n        if (((((char)(&yypact)[longVar] != -0xe) &&\n             (unsignedVar = (int)(char)(&yypact)[longVar] + 1, unsignedVar < 0x23)) &&\n            (yycheck[(int)unsignedVar] == '\\x01')) &&\n           (longVar = (long)(char)yytable[(int)unsignedVar], '\\0' < (char)yytable[(int)unsignedVar]))\n        goto LAB_00105227;\n        if (localPointerToCharacter == localPointerToCharacter) goto LAB_0010524c;\n        localPointerToCharacter = localPointerToCharacter + -1;\n        pointerToPointerOfCharacter = pointerToPointerOfCharacter + -1;\n        longVar = (long)*localPointerToCharacter;\n      } while( true );\n    }\n    if (localInteger != 3) goto LAB_001051f0;\n    if (0 < yychar) {\n      yychar = -2;\n      goto LAB_001051f0;\n    }\n    if (yychar != 0) goto LAB_001051f0;\n    goto LAB_0010524c;\n  }\nLAB_00104a0a:\n  unsignedVar = program_name;\n  pointerToPointerOfCharacter = obfd;\n  character = yyr2[integer];\n  pointerToPointerOfCharacter = (char **)pointerToPointerOfCharacter[1 - character];\n  switch(integer) {\n  case 2:\n  case 6:\n    prompt();\n    break;\n  case 0x13:\n    if (obfd == (char **)0x0) {\n      return;\n    }\n    bfd_cache_close();\n    unlink(*obfd);\n    return;\n  case 0x15:\n    yyerror_constprop_0();\n    break;\n  case 0x17:\n    pointerToUnsignedVar = (undefined8 *)*pointerToPointerOfCharacter;\n    if (obfd == (char **)0x0) {\n      pointerToCharacter = \"%s: no open archive\\n\";\nLAB_00104b62:\n      pointerToCharacter = (char *)dcgettext(0,pointerToCharacter,5);\n      fprintf(_stderr,pointerToCharacter,unsignedVar);\n      maybequit();\n    }\n    else {\n      for (; pointerToUnsignedVar != (undefined8 *)0x0; pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[1]) {\n        for (pointerToUnsignedVar = (undefined8 *)obfd[0x1f]; pointerToUnsignedVar != (undefined8 *)0x0;\n            pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[0x1e]) {\n          integer = filename_cmp(*pointerToUnsignedVar);\n          if (integer == 0) {\n            extract_file();\n            goto LAB_00104adf;\n          }\n        }\n        bfd_openr(*pointerToUnsignedVar,0);\n        unsignedVar = program_name;\n        unsignedVar = *pointerToUnsignedVar;\n        pointerToCharacter = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointerToCharacter,unsignedVar,unsignedVar);\nLAB_00104adf:\n      }\n    }\n    break;\n  case 0x18:\n    pointerToUnsignedVar = (undefined8 *)*pointerToPointerOfCharacter;\n    if (obfd == (char **)0x0) {\nLAB_00104b4f:\n      pointerToCharacter = \"%s: no open output archive\\n\";\n      goto LAB_00104b62;\n    }\n    for (; pointerToUnsignedVar != (undefined8 *)0x0; pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[1]) {\n      boolean = false;\n      pointerToPointerOfCharacter = obfd + 0x1f;\n      for (pointerToCharacter = obfd[0x1f]; pointerToCharacter != (char *)0x0; pointerToCharacter = *(char **)(pointerToCharacter + 0xf0)) {\n        integer = filename_cmp();\n        if (integer == 0) {\n          pointerToCharacter = (char *)bfd_openr(*pointerToUnsignedVar,0);\n          unsignedVar = program_name;\n          if (pointerToCharacter == (char *)0x0) {\n            unsignedVar = *pointerToUnsignedVar;\n            pointerToCharacter = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n            fprintf(_stderr,pointerToCharacter,unsignedVar,unsignedVar);\n            maybequit();\n          }\n          else {\n            *pointerToPointerOfCharacter = pointerToCharacter;\n            boolean = true;\n            *(undefined8 *)(pointerToCharacter + 0xf0) = *(undefined8 *)(pointerToCharacter + 0xf0);\n          }\n        }\n        else {\n          pointerToPointerOfCharacter = (char **)(pointerToCharacter + 0xf0);\n        }\n      }\n      if (!boolean) {\n        pointerToCharacter = (char *)bfd_openr(*pointerToUnsignedVar,0);\n        unsignedVar = program_name;\n        unsignedVar = *pointerToUnsignedVar;\n        pointerToCharacter = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointerToCharacter,unsignedVar,unsignedVar);\n        unsignedVar = program_name;\n        if (pointerToCharacter == (char *)0x0) {\n          unsignedVar = *pointerToUnsignedVar;\n          pointerToCharacter = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n          fprintf(_stderr,pointerToCharacter,unsignedVar,unsignedVar);\n          maybequit();\n        }\n        else {\n          *pointerToPointerOfCharacter = pointerToCharacter;\n        }\n      }\n    }\n    break;\n  case 0x19:\n    if (obfd != (char **)0x0) {\n      obfd[0x1f] = (char *)0x0;\n    }\n    break;\n  case 0x1a:\n    pointerToUnsignedVar = (undefined8 *)*pointerToPointerOfCharacter;\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    for (; pointerToUnsignedVar != (undefined8 *)0x0; pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[1]) {\n      boolean = false;\n      pointerToPointerOfCharacter = obfd + 0x1f;\n      for (pointerToUnsignedVar = (undefined8 *)obfd[0x1f]; unsignedVar = program_name, pointerToUnsignedVar != (undefined8 *)0x0;\n          pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[0x1e]) {\n        integer = filename_cmp(*pointerToUnsignedVar,*pointerToUnsignedVar);\n        if (integer == 0) {\n          boolean = true;\n          *pointerToPointerOfCharacter = (char *)pointerToUnsignedVar[0x1e];\n        }\n        else {\n          pointerToPointerOfCharacter = (char **)(pointerToUnsignedVar + 0x1e);\n        }\n      }\n      if (!boolean) {\n        unsignedVar = *pointerToUnsignedVar;\n        pointerToCharacter = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointerToCharacter,unsignedVar,unsignedVar);\n        maybequit();\n      }\n    }\n    break;\n  case 0x1b:\n    pointerToUnsignedVar = (undefined8 *)*pointerToPointerOfCharacter;\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    for (; pointerToUnsignedVar != (undefined8 *)0x0; pointerToUnsignedVar = (undefined8 *)pointerToUnsignedVar[1]) {\n      pointerToCharacter = (char *)bfd_openr(*pointerToUnsignedVar,\"plugin\");\n      unsignedVar = program_name;\n      pointerToPointerOfCharacter = obfd;\n      if (pointerToCharacter == (char *)0x0) {\n        unsignedVar = *pointerToUnsignedVar;\n        pointerToCharacter = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n        fprintf(_stderr,pointerToCharacter,unsignedVar,unsignedVar);\n        maybequit();\n      }\n      else {\n        *(char **)(pointerToCharacter + 0xf0) = obfd[0x1f];\n        pointerToPointerOfCharacter[0x1f] = pointerToCharacter;\n      }\n    }\n    break;\n  case 0x1c:\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    pointerToCharacter = *obfd;\n    verbose = 1;\n    outfile = _stdout;\n    pointerToCharacter = (char *)dcgettext(0,\"Current open archive is %s\\n\",5);\n    printf(pointerToCharacter,pointerToCharacter);\n    for (pointerToCharacter = obfd[0x1f]; pointerToCharacter != (char *)0x0; pointerToCharacter = *(char **)(pointerToCharacter + 0xf0)) {\n      ar_directory_doer(pointerToCharacter,0);\n    }\n    break;\n  case 0x1d:\n    if (obfd == (char **)0x0) goto LAB_00104b4f;\n    if (0 < deterministic) {\n      *(uint *)((long)obfd + 0x44) = *(uint *)((long)obfd + 0x44) | 0x2000;\n    }\n    temp_fd = dup(temp_fd);\n    bfd_close(pointerToPointerOfCharacter);\n    pointerToCharacter = real_name;\n    integer = stat(real_name,&localStat);\n    if ((integer != 0) && (obfd = (char **)bfd_openw(pointerToCharacter,0), obfd != (char **)0x0)) {\n      bfd_set_format(obfd,2);\n      bfd_close(obfd);\n    }\n    smart_rename_constprop_0(temp_name,real_name,temp_fd);\n    obfd = (char **)0x0;\n    free(temp_name);\n    free(real_name);\n    break;\n  case 0x1e:\n    ar_open(*pointerToPointerOfCharacter,0);\n    break;\n  case 0x1f:\n    ar_open(*pointerToPointerOfCharacter,1);\n    break;\n  case 0x20:\n    pointerToCharacter = *pointerToPointerOfCharacter;\n    if (obfd == (char **)0x0) {\n      pointerToCharacter = \"%s: no output archive specified yet\\n\";\n      goto LAB_00104b62;\n    }\n    longVar = open_inarch(pointerToPointerOfCharacter[-1],0);\n    if (longVar != 0) {\n      map_over_list(longVar,ar_addlib_doer,pointerToCharacter);\n    }\n    break;\n  case 0x21:\n    pointerToCharacter = *pointerToPointerOfCharacter;\n    pointerToCharacter = pointerToPointerOfCharacter[-1];\n    unsignedVar = open_inarch(pointerToPointerOfCharacter[-2],0);\n    if (pointerToCharacter == (char *)0x0) {\n      outfile = _stdout;\n    }\n    else {\n      outfile = fopen(pointerToCharacter,\"w\");\n      if (outfile != (FILE *)0x0) {\n        map_over_list(unsignedVar,ar_directory_doer,pointerToCharacter);\n        bfd_close(unsignedVar);\n        fclose(outfile);\n        break;\n      }\n      outfile = _stdout;\n      pointerToCharacter = (char *)dcgettext(0,\"Can\\'t open file %s\\n\",5);\n      fprintf(_stderr,pointerToCharacter,pointerToCharacter);\n    }\n    map_over_list(unsignedVar,ar_directory_doer,pointerToCharacter);\n    bfd_close(unsignedVar);\n    break;\n  case 0x22:\n    pointerToPointerOfCharacter = (char **)*pointerToPointerOfCharacter;\n    break;\n  case 0x23:\n  case 0x25:\n  case 0x27:\n    pointerToPointerOfCharacter = (char **)0x0;\n    break;\n  case 0x24:\n    pointerToPointerOfCharacter = (char **)pointerToPointerOfCharacter[-1];\n    break;\n  case 0x26:\n    pointerToPointerOfCharacter = (char **)malloc(0x10);\n    pointerToCharacter = pointerToPointerOfCharacter[-2];\n    *pointerToPointerOfCharacter = *pointerToPointerOfCharacter;\n    pointerToPointerOfCharacter[1] = pointerToCharacter;\n    break;\n  case 0x2a:\n    verbose = (uint)(verbose == 0);\n  }\n  longVar = (long)character;\n  localPointerToCharacter = localPointerToCharacter + -longVar;\n  pointerToPointerOfCharacter[1 - longVar] = (char *)pointerToPointerOfCharacter;\n  pointerToPointerOfCharacter = pointerToPointerOfCharacter + (1 - longVar);\n  unsignedVar = (int)(char)yypgoto[(char)yyr1[integer] + -0x18] + (int)*localPointerToCharacter;\n  if ((unsignedVar < 0x23) && (*localPointerToCharacter == yycheck[(int)unsignedVar])) {\n    longVar = (long)(char)yytable[(int)unsignedVar];\n  }\n  else {\n    longVar = (long)(char)yydefgoto[(char)yyr1[integer] + -0x18];\n  }\n  goto LAB_001049d1;\nswitchD_00104200_caseD_29:\n  integer = ((int)pointerToByte - (int)yytext) + -1;\n  *pointerToByte = yy_hold_char;\n  pointerToPointer = (long **)(yy_buffer_stack + longVar * 8);\n  pointerToPointerOfFile = (FILE **)*pointerToPointer;\n  if (*(int *)(pointerToPointerOfFile + 7) == 0) {\n    yy_n_chars = *(uint *)((long)pointerToPointerOfFile + 0x1c);\n    *(undefined4 *)(pointerToPointerOfFile + 7) = 1;\n    *pointerToPointerOfFile = yyin;\n  }\n  pointerToByte = yy_c_buf_p;\n  pointerToFile = pointerToPointerOfFile[1];\n  arrayOfUnsignedVar[16]._8_8_ = pointerToFile;\n  arrayOfUnsignedVar[16]._0_8_ = pointerToPointerOfFile;\n  if ((byte *)((long)&pointerToFile->_flags + (long)(int)yy_n_chars) < yy_c_buf_p) {\n    if ((byte *)((long)&pointerToFile->_flags + (long)(int)yy_n_chars + 1) < yy_c_buf_p) {\n      arrayOfUnsignedVar[16] = yy_fatal_error();\n    }\n    if (*(int *)(arrayOfUnsignedVar[16]._0_8_ + 0x34) != 0) {\n      unsignedVar = (int)((long)pointerToByte - (long)pointerToByte) - 1;\n      for (longVar = 0; (int)longVar < (int)unsignedVar; longVar = longVar + 1) {\n        *(byte *)(arrayOfUnsignedVar[16]._8_8_ + longVar) = pointerToByte[longVar];\n      }\n      pointerToLong = *pointerToPointer;\n      if (*(int *)(pointerToLong + 7) == 2) {\n        yy_n_chars = 0;\n        *(undefined4 *)((long)pointerToLong + 0x1c) = 0;\nLAB_0010475e:\n        pointerToFile = yyin;\n        if (unsignedVar == 0) {\n          if ((yy_buffer_stack == 0) || (*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) == 0))\n          {\n            yyensure_buffer_stack();\n            pointerToUnsignedVar = (undefined8 *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n            unsignedVar = yy_create_buffer_constprop_0(pointerToFile);\n            *pointerToUnsignedVar = unsignedVar;\n          }\n          longVar = yy_buffer_stack;\n          if (yy_buffer_stack != 0) {\n            longVar = *(long *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n          }\n          integer = 1;\n          yy_init_buffer(longVar);\n          yy_load_buffer_state();\n        }\n        else {\n          integer = 2;\n          *(undefined4 *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 0x38) = 2;\n        }\n      }\n      else {\n        while( true ) {\n          pointerToLong = *pointerToPointer;\n          unsignedVar = ~unsignedVar + *(int *)(pointerToLong + 3);\n          if (0 < (int)unsignedVar) break;\n          unsignedVar = (int)yy_c_buf_p - (int)(void *)pointerToLong[1];\n          if (*(int *)(pointerToLong + 4) == 0) {\n            pointerToLong[1] = 0;\nLAB_00104626:\n            yy_fatal_error();\n            break;\n          }\n          integer = *(int *)(pointerToLong + 3);\n          integer = integer;\n          if (integer < 1) {\n            integer = integer / 8;\n          }\n          *(int *)(pointerToLong + 3) = integer + integer;\n          pointerToVoid = realloc((void *)pointerToLong[1],(long)(integer + integer + 2));\n          pointerToLong[1] = (long)pointerToVoid;\n          if (pointerToVoid == (void *)0x0) goto LAB_00104626;\n          yy_c_buf_p = (byte *)((long)pointerToVoid + (long)(int)unsignedVar);\n          pointerToLong = *pointerToPointer;\n        }\n        if (0x2000 < (int)unsignedVar) {\n          unsignedVar = 0x2000;\n        }\n        unsignedVar = (ulong)unsignedVar;\n        if (*(int *)((long)pointerToLong + 0x24) == 0) {\n          pointerToInteger = __errno_location();\n          unsignedVar = (ulong)(int)unsignedVar;\n          unsignedVar = (ulong)(int)unsignedVar;\n          *pointerToInteger = 0;\n          goto LAB_001046c7;\n        }\n        unsignedVar = 0;\n        pointerToInteger = (int *)(long)(int)unsignedVar;\n        do {\n          integer = getc(yyin);\n          unsignedVar = (uint)unsignedVar;\n          if (integer == -1) {\n            integer = ferror(yyin);\n            unsignedVar = unsignedVar;\n            if (integer != 0) {\n              do {\n                pointerToCharacter = \"input in flex scanner failed\";\n                yy_fatal_error();\n                do {\n                  *pointerToInteger = 0;\n                  clearerr((FILE *)pointerToCharacter);\nLAB_001046c7:\n                  size = fread((void *)(*(long *)(*(long *)(yy_buffer_stack +\n                                                             yy_buffer_stack_top * 8) + 8) + unsignedVar)\n                                 ,1,unsignedVar,yyin);\n                  pointerToCharacter = (char *)yyin;\n                  yy_n_chars = (uint)size;\n                  unsignedVar = yy_n_chars;\n                  if ((yy_n_chars != 0) || (integer = ferror(yyin), unsignedVar = yy_n_chars, integer == 0))\n                  goto LAB_00104738;\n                } while (*pointerToInteger == 4);\n              } while( true );\n            }\n            break;\n          }\n          if (integer == 10) {\n            *(undefined *)\n             ((long)(int *)(long)(int)unsignedVar +\n             (long)(int)unsignedVar + *(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8)\n             ) = 10;\n            unsignedVar = unsignedVar + 1;\n            break;\n          }\n          unsignedVar = (ulong)(unsignedVar + 1);\n          *(char *)(*(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8) +\n                   (long)pointerToInteger) = (char)integer;\n          pointerToInteger = (int *)((long)pointerToInteger + 1);\n        } while (unsignedVar != unsignedVar + 1);\nLAB_00104738:\n        yy_n_chars = unsignedVar;\n        unsignedVar = yy_n_chars;\n        integer = 0;\n        *(uint *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 0x1c) = yy_n_chars;\n        if (unsignedVar == 0) goto LAB_0010475e;\n      }\n      pointerToLong = (long *)(yy_buffer_stack + yy_buffer_stack_top * 8);\n      longVar = *pointerToLong;\n      unsignedVar = unsignedVar + yy_n_chars;\n      if (*(int *)(longVar + 0x18) < (int)unsignedVar) {\n        integer = ((int)yy_n_chars >> 1) + unsignedVar;\n        pointerToVoid = realloc(*(void **)(longVar + 8),(long)integer);\n        *(void **)(longVar + 8) = pointerToVoid;\n        arrayOfUnsignedVar[16]._8_8_ = pointerToLong;\n        arrayOfUnsignedVar[16]._0_8_ = *pointerToLong;\n        if (*(long *)(*pointerToLong + 8) == 0) {\n          arrayOfUnsignedVar[16] = yy_fatal_error();\n        }\n        pointerToLong = arrayOfUnsignedVar[16]._8_8_;\n        *(int *)(arrayOfUnsignedVar[16]._0_8_ + 0x18) = integer + -2;\n      }\n      yy_n_chars = unsignedVar;\n      *(undefined *)(*(long *)(*pointerToLong + 8) + (long)(int)unsignedVar) = 0;\n      *(undefined *)(*(long *)(*pointerToLong + 8) + 1 + (long)(int)unsignedVar) = 0;\n      pointerToByte = *(byte **)(*pointerToLong + 8);\n      yytext = pointerToByte;\n      if (integer == 1) goto LAB_001048a4;\n      if (integer == 2) goto LAB_001048ca;\n      pointerToByte = pointerToByte + integer;\n      yy_c_buf_p = pointerToByte;\n      unsignedVar = yy_get_previous_state();\n      goto LAB_001040d4;\n    }\n    if ((long)pointerToByte - (long)pointerToByte == 1) goto LAB_001048a4;\nLAB_001048ca:\n    pointerToByte = (byte *)((long)(int)yy_n_chars +\n                      *(long *)(*(long *)(yy_buffer_stack + yy_buffer_stack_top * 8) + 8));\n    yy_c_buf_p = pointerToByte;\n    unsignedVar = yy_get_previous_state();\n    pointerToByte = yytext;\n    goto LAB_0010419f;\n  }\n  pointerToByte = pointerToByte + integer;\n  yy_c_buf_p = pointerToByte;\n  unsignedVar = yy_get_previous_state();\n  if (*(short *)(yy_accept + (long)(int)(uint)unsignedVar * 2) != 0) {\n    yy_last_accepting_cpos = pointerToByte;\n    yy_last_accepting_state = (uint)unsignedVar;\n  }\n  unsignedVar = unsignedVar & 0xffffffff;\n  while( true ) {\n    integer = (int)unsignedVar;\n    if (integer == *(short *)(yy_chk + (long)(*(short *)(yy_base + (long)integer * 2) + 1) * 2)) break;\n    unsignedVar = (ulong)(uint)(int)*(short *)(yy_def + (long)integer * 2);\n  }\n  unsignedVar = (uint)*(short *)(yy_nxt + (long)(*(short *)(yy_base + (long)integer * 2) + 1) * 2);\n  pointerToByte = pointerToByte;\n  if ((*(short *)(yy_nxt + (long)(*(short *)(yy_base + (long)integer * 2) + 1) * 2) == 0) ||\n     (unsignedVar == 0xb0)) goto LAB_0010419f;\n  pointerToByte = pointerToByte + 1;\n  goto LAB_001040d4;\nLAB_001048a4:\n  yy_c_buf_p = yytext;\n  integer = (int)(yy_start - 1) / 2 + 0x2a;\n  goto LAB_001041f0;\nswitchD_00104200_caseD_0:\n  *pointerToByte = yy_hold_char;\n  unsignedVar = (ulong)yy_last_accepting_state;\n  pointerToByte = yy_last_accepting_cpos;\n  goto LAB_0010419f;\nLAB_00105227:\n  pointerToPointerOfCharacter = pointerToPointerOfCharacter + 1;\n  localInteger = 3;\n  *pointerToPointerOfCharacter = yylval;\nLAB_001049d1:\n  localPointerToCharacter = localPointerToCharacter + 1;\n  goto LAB_00103ee9;\n}\n\n",
            "called": [
                "open_inarch",
                "prompt",
                "smart_rename.constprop.0",
                "fprintf",
                "ferror",
                "fread",
                "fclose",
                "clearerr",
                "maybequit",
                "dcgettext",
                "map_over_list",
                "yy_load_buffer_state",
                "ar_directory_doer",
                "fwrite",
                "stat",
                "ar_open",
                "filename_cmp",
                "__errno_location",
                "yyerror.constprop.0",
                "bfd_openw",
                "dup",
                "ar_addlib_doer",
                "yy_fatal_error",
                "printf",
                "fopen",
                "bfd_close",
                "unlink",
                "bfd_set_format",
                "yy_init_buffer",
                "bfd_cache_close",
                "yy_get_previous_state",
                "bfd_openr",
                "realloc",
                "yyensure_buffer_stack",
                "yy_create_buffer.constprop.0",
                "getc",
                "extract_file",
                "free",
                "malloc",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103e95",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "parse_file_00103e95"
        },
        "FUN_001020e0": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001020e0"
        },
        "FUN_0010e200": {
            "renaming": {},
            "code": "\n\n\n\nvoid * malloc(size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* malloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e200",
            "calling": [
                "malloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e200"
        },
        "FUN_00102280": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "list_matching_formats",
                "list_supported_targets",
                "print_arelt_descr.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102280"
        },
        "FUN_00107730": {
            "renaming": {
                "FUN_00107730": "close_output_file_00107730",
                "output_filename": "filename",
                "output_file": "file",
                "unlink_if_ordinary": "removeFile"
            },
            "code": "\nvoid closeOutputFile_00107730(void)\n\n{\n  if (filename == 0) {\n    return;\n  }\n  if (output_bfd != 0) {\n    bfd_cache_close();\n  }\n  if (file != (FILE *)0x0) {\n    fclose(file);\n  }\n  removeFile(filename);\n  return;\n}\n\n",
            "called": [
                "remove_output.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107730",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "close_output_file_00107730"
        },
        "FUN_00102040": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "set_times"
            ],
            "imported": false,
            "current_name": "FUN_00102040"
        },
        "FUN_00102160": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102160"
        },
        "FUN_0010e2a8": {
            "renaming": {},
            "code": "\n\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* sprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2a8",
            "calling": [
                "sprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e2a8"
        },
        "FUN_001020f0": {
            "renaming": {},
            "code": "\nvoid bfd_set_archive_head(void)\n\n{\n  bfd_set_archive_head();\n  return;\n}\n\n",
            "called": [
                "bfd_set_archive_head"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "write_archive.cold"
            ],
            "imported": false,
            "current_name": "FUN_001020f0"
        },
        "FUN_001031cf": {
            "renaming": {
                "FUN_001031cf": "setup_file_001031cf",
                "param_1": "file_stack",
                "param_2": "input_file",
                "iVar1": "errno_value",
                "uVar2": "is_terminal",
                "iVar3": "fileno_result",
                "piVar4": "errno_location",
                "lVar5": "buffer_stack"
            },
            "code": "\n\n\nundefined8\nsetup_file_001031cf(FILE **file_stack,FILE *input_file,undefined8 param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  int errno_value;\n  uint is_terminal;\n  int fileno_result;\n  int *errno_location;\n  long buffer_stack;\n  \n  errno_location = __errno_location();\n  buffer_stack = yy_buffer_stack;\n  errno_value = *errno_location;\n  if (file_stack == (FILE **)0x0) {\n    _DAT_00000034 = 1;\n    _DAT_00000000 = input_file;\n    if (yy_buffer_stack != 0) {\nLAB_00103263:\n      if (file_stack == *(FILE ***)(buffer_stack + yy_buffer_stack_top * 8)) goto LAB_0010327b;\n    }\n  }\n  else {\n    *(undefined4 *)((long)file_stack + 0x1c) = 0;\n    *(undefined *)&file_stack[1]->_flags = 0;\n    *(undefined *)((long)&file_stack[1]->_flags + 1) = 0;\n    *(undefined4 *)(file_stack + 5) = 1;\n    file_stack[2] = file_stack[1];\n    *(undefined4 *)(file_stack + 7) = 0;\n    if (buffer_stack != 0) {\n      if (file_stack == *(FILE ***)(buffer_stack + yy_buffer_stack_top * 8)) {\n        yy_load_buffer_state();\n      }\n      *file_stack = input_file;\n      *(undefined4 *)((long)file_stack + 0x34) = 1;\n      goto LAB_00103263;\n    }\n    *file_stack = input_file;\n    *(undefined4 *)((long)file_stack + 0x34) = 1;\n  }\n  *(undefined8 *)((long)file_stack + 0x2c) = 1;\nLAB_0010327b:\n  is_terminal = 0;\n  if (input_file != (FILE *)0x0) {\n    fileno_result = fileno(input_file);\n    fileno_result = isatty(fileno_result);\n    is_terminal = (uint)(0 < fileno_result);\n  }\n  *(uint *)((long)file_stack + 0x24) = is_terminal;\n  *errno_location = errno_value;\n  return param_5;\n}\n\n",
            "called": [
                "yy_load_buffer_state",
                "__errno_location",
                "isatty",
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031cf",
            "calling": [
                "yy_create_buffer.constprop.0",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "setup_file_001031cf"
        },
        "FUN_0010312d": {
            "renaming": {
                "FUN_0010312d": "copy_data_0010312d",
                "param_1": "sourcePtr",
                "param_2": "destinationPtr",
                "lVar1": "tempPtr"
            },
            "code": "\nvoid copyData_0010312d(long sourcePtr,long destinationPtr)\n\n{\n  long tempPtr;\n  \n  if (destinationPtr != 0) {\n    *(undefined8 *)(destinationPtr + 0xf0) = *(undefined8 *)(sourcePtr + 0xf0);\n  }\n  tempPtr = obfd;\n  *(undefined8 *)(sourcePtr + 0xf0) = *(undefined8 *)(obfd + 0xf8);\n  *(long *)(tempPtr + 0xf8) = sourcePtr;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010312d",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "copy_data_0010312d"
        },
        "FUN_00105c00": {
            "renaming": {
                "FUN_00105c00": "copy_and_verify_file_00105c00",
                "param_1": "file_descriptor",
                "param_2": "destination_path",
                "iVar1": "original_errno",
                "__fd": "destination_file_descriptor",
                "_Var3": "file_offset",
                "uVar4": "bytes_copied",
                "sVar5": "bytes_written",
                "piVar6": "errno_location",
                "auStack_2038": "buffer"
            },
            "code": "\nulong copy_and_verify_file_00105c00(int file_descriptor,char *destination_path)\n\n{\n  int original_errno;\n  int destination_file_descriptor;\n  int iVar2;\n  __off_t file_offset;\n  ulong bytes_copied;\n  size_t bytes_written;\n  int *errno_location;\n  undefined buffer [8200];\n  \n  if ((-1 < file_descriptor) && (file_offset = lseek(file_descriptor,0,0), file_offset == 0)) {\n    destination_file_descriptor = open(destination_path,0x201);\n    if (destination_file_descriptor < 0) {\n      bytes_copied = simple_copy_constprop_0_cold();\n      return bytes_copied;\n    }\n    do {\n      bytes_copied = read(file_descriptor,buffer,0x2000);\n      iVar2 = (int)bytes_copied;\n      if (iVar2 < 1) {\n        errno_location = __errno_location();\n        original_errno = *errno_location;\n        close(file_descriptor);\n        close(destination_file_descriptor);\n        if (iVar2 != 0) {\n          *errno_location = original_errno;\n          return 0xffffffff;\n        }\n        return bytes_copied & 0xffffffff;\n      }\n      bytes_written = write(destination_file_descriptor,buffer,(long)iVar2);\n    } while (bytes_written == (long)iVar2);\n    errno_location = __errno_location();\n    iVar2 = *errno_location;\n    close(file_descriptor);\n    close(destination_file_descriptor);\n    *errno_location = iVar2;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "simple_copy.constprop.0.cold",
                "__errno_location",
                "write",
                "open",
                "read",
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105c00",
            "calling": [
                "smart_rename.constprop.0"
            ],
            "imported": false,
            "current_name": "copy_and_verify_file_00105c00"
        },
        "FUN_00105d20": {
            "renaming": {
                "FUN_00105d20": "FUNC_00105d20"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d44) */\n/* WARNING: Removing unreachable block (ram,0x00105d50) */\n\nvoid FUNC_00105d20(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105d20",
            "calling": [
                "frame_dummy"
            ],
            "imported": false,
            "current_name": "FUNC_00105d20"
        },
        "FUN_001052a0": {
            "renaming": {
                "FUN_001052a0": "check_file_001052a0",
                "param_1": "file_path",
                "iVar1": "status",
                "piVar2": "errno_ptr",
                "uVar3": "error_message",
                "pcVar4": "error_reason",
                "sStack_a8": "file_stats"
            },
            "code": "\nlong check_file_001052a0(char *file_path)\n\n{\n  int status;\n  int *errno_ptr;\n  undefined8 error_message;\n  char *error_reason;\n  stat file_stats;\n  \n  if (file_path != (char *)0x0) {\n    status = stat(file_path,&file_stats);\n    if (status < 0) {\n      errno_ptr = __errno_location();\n      if (*errno_ptr == 2) {\n        error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n        non_fatal(error_message,file_path);\n      }\n      else {\n        error_reason = strerror(*errno_ptr);\n        error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        non_fatal(error_message,file_path,error_reason);\n      }\n    }\n    else if ((file_stats.st_mode & 0xf000) == 0x4000) {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      non_fatal(error_message,file_path);\n    }\n    else if ((file_stats.st_mode & 0xf000) == 0x8000) {\n      if (-1 < file_stats.st_size) {\n        return file_stats.st_size;\n      }\n      error_message = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      non_fatal(error_message,file_path);\n    }\n    else {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      non_fatal(error_message,file_path);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "stat",
                "get_file_size.cold",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a0",
            "calling": [
                "ranlib_only",
                "main"
            ],
            "imported": false,
            "current_name": "check_file_001052a0"
        },
        "FUN_0010336b": {
            "renaming": {
                "FUN_0010336b": "print_emulation_options_0010336b",
                "param_1": "outputFile",
                "pcVar1": "emulationOption"
            },
            "code": "\nvoid printEmulationOptions_0010336b(FILE *outputFile)\n\n{\n  char *emulationOption;\n  \n  emulationOption = (char *)dcgettext(0,\" emulation options: \\n\",5);\n  fprintf(outputFile,emulationOption);\n  emulationOption = (char *)dcgettext(0,\"  No emulation specific options\\n\",5);\n  fprintf(outputFile,emulationOption);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010336b",
            "calling": [
                "usage"
            ],
            "imported": false,
            "current_name": "print_emulation_options_0010336b"
        },
        "FUN_00103c60": {
            "renaming": {
                "FUN_00103c60": "extract_archived_files_00103c60",
                "param_1": "input_archive_path",
                "param_2": "flag",
                "cVar1": "format_check_result",
                "piVar2": "errno_location_ptr",
                "pcVar3": "error_message",
                "lVar4": "input_archive_handle",
                "lVar5": "archived_file_handle",
                "uVar6": "program_name",
                "plVar7": "archived_files_ptr"
            },
            "code": "\n\n\nvoid extractArchivedFiles_00103c60(char *input_archive_path,int flag)\n\n{\n  char format_check_result;\n  int *errno_location_ptr;\n  char *error_message;\n  long input_archive_handle;\n  long archived_file_handle;\n  undefined8 program_name;\n  long *archived_files_ptr;\n  \n  real_name = xstrdup();\n  temp_name = (char *)make_tempname(real_name,&temp_fd);\n  if (temp_name == (char *)0x0) {\n    errno_location_ptr = __errno_location();\n    input_archive_path = strerror(*errno_location_ptr);\n    program_name = program_name;\n    error_message = (char *)dcgettext(0,\"%s: Can\\'t open temporary file (%s)\\n\",5);\n  }\n  else {\n    obfd = bfd_fdopenw(temp_name,0,temp_fd);\n    if (obfd == 0) {\n      error_message = \"%s: Can\\'t open output archive %s\\n\";\n      input_archive_path = temp_name;\n    }\n    else {\n      if (flag != 0) {\nLAB_00103d02:\n        bfd_set_format(obfd,2);\n        *(byte *)(obfd + 0x49) = *(byte *)(obfd + 0x49) & 0xe7 | 8;\n        return;\n      }\n      input_archive_handle = bfd_openr(input_archive_path,\"plugin\");\n      if (input_archive_handle == 0) {\n        error_message = \"%s: Can\\'t open input archive %s\\n\";\n      }\n      else {\n        format_check_result = bfd_check_format(input_archive_handle,2);\n        if (format_check_result != '\\0') {\n          archived_files_ptr = (long *)(obfd + 0xf8);\n          for (archived_file_handle = bfd_openr_next_archived_file(input_archive_handle,0); archived_file_handle != 0;\n              archived_file_handle = bfd_openr_next_archived_file(input_archive_handle,archived_file_handle)) {\n            *archived_files_ptr = archived_file_handle;\n            archived_files_ptr = (long *)(archived_file_handle + 0xf0);\n          }\n          goto LAB_00103d02;\n        }\n        error_message = \"%s: file %s is not an archive\\n\";\n      }\n    }\n    program_name = program_name;\n    error_message = (char *)dcgettext(0,error_message,5);\n  }\n  fprintf(_stderr,error_message,program_name,input_archive_path);\n  maybequit();\n  return;\n}\n\n",
            "called": [
                "make_tempname",
                "bfd_openr_next_archived_file",
                "__errno_location",
                "strerror",
                "fprintf",
                "bfd_check_format",
                "maybequit",
                "bfd_fdopenw",
                "bfd_openr",
                "dcgettext",
                "bfd_set_format",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c60",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "extract_archived_files_00103c60"
        },
        "FUN_0010e218": {
            "renaming": {},
            "code": "\n\n\n\nint mkstemp(char *__template)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* mkstemp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e218",
            "calling": [
                "mkstemp"
            ],
            "imported": false,
            "current_name": "FUN_0010e218"
        },
        "FUN_00102170": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "open_inarch",
                "print_contents",
                "bfd_nonfatal.cold",
                "replace_members.cold",
                "list_supported_targets",
                "extract_file.cold",
                "ar_emul_default_usage",
                "get_file_size",
                "main",
                "FUN_00102e6f",
                "yyparse.isra.0",
                "map_over_list",
                "ar_open",
                "list_matching_formats",
                "write_archive",
                "set_times.cold",
                "yyerror.constprop.0",
                "get_file_size.cold",
                "map_over_members.cold",
                "print_arelt_descr.cold",
                "smart_rename.constprop.0.cold",
                "print_version",
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "FUN_00102170"
        },
        "FUN_00102290": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "FUN_00102290"
        },
        "FUN_0010300e": {
            "renaming": {
                "FUN_0010300e": "find_accepting_state_0010300e",
                "yy_start": "start_state",
                "yytext": "current_char",
                "yy_c_buf_p": "buffer_pointer",
                "yy_ec": "char_class",
                "yy_accept": "accept_state_array",
                "yy_base": "base_state_array",
                "yy_chk": "check_state_array",
                "yy_def": "default_state_array",
                "yy_meta": "meta_state_array",
                "yy_nxt": "next_state_array",
                "bVar1": "found_accepting_state",
                "iVar2": "current_state",
                "lVar3": "next_state_offset",
                "bVar4": "char_class_value",
                "pbVar5": "current_char_pointer",
                "in_R9": "last_accepting_cpos",
                "in_R10D": "last_accepting_state"
            },
            "code": "\nvoid find_accepting_state_0010300e(void)\n\n{\n  bool found_accepting_state;\n  int current_state;\n  long next_state_offset;\n  byte char_class_value;\n  byte *current_char_pointer;\n  byte *last_accepting_cpos;\n  int last_accepting_state;\n  \n  found_accepting_state = false;\n  current_state = start_state;\n  for (current_char_pointer = current_char; current_char_pointer < buffer_pointer; current_char_pointer = current_char_pointer + 1) {\n    char_class_value = 1;\n    if (*current_char_pointer != 0) {\n      char_class_value = char_class[*current_char_pointer];\n    }\n    if (*(short *)(accept_state_array + (long)current_state * 2) != 0) {\n      found_accepting_state = true;\n      last_accepting_cpos = current_char_pointer;\n      last_accepting_state = current_state;\n    }\n    while( true ) {\n      next_state_offset = (long)(int)((int)*(short *)(base_state_array + (long)current_state * 2) + (uint)char_class_value);\n      if (*(short *)(check_state_array + next_state_offset * 2) == current_state) break;\n      current_state = (int)*(short *)(default_state_array + (long)current_state * 2);\n      if (0xb0 < current_state) {\n        char_class_value = meta_state_array[(int)(uint)char_class_value];\n      }\n    }\n    current_state = (int)*(short *)(next_state_array + next_state_offset * 2);\n  }\n  if (found_accepting_state) {\n    yy_last_accepting_cpos = last_accepting_cpos;\n    yy_last_accepting_state = last_accepting_state;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010300e",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "find_accepting_state_0010300e"
        },
        "FUN_00107740": {
            "renaming": {
                "FUN_00107740": "extract_and_write_archive_file_00107740",
                "param_1": "archive",
                "iVar1": "cmpResult",
                "iVar2": "statError",
                "piVar3": "errNum",
                "pcVar4": "errString",
                "uVar5": "translatableString",
                "pplVar6": "archivePointer",
                "__ptr": "buffer",
                "__n": "bytesRead",
                "lVar7": "loopCounter",
                "plVar8": "file",
                "puVar9": "localInfoArray",
                "uVar10": "totalBytesRead",
                "sVar11": "writeSize",
                "local_c8": "fileInfo",
                "_Stack_b0": "filePermissions",
                "uStack_98": "fileSize",
                "uStack_80": "time1",
                "uStack_70": "time2",
                "output_file": "outputFile",
                "open_output_file_isra_0": "openOutputFile",
                "output_filename": "outputFileName",
                "dcgettext": "getTranslatedString",
                "posname": "positionName",
                "filename_cmp": "compareFileName",
                "bfd_seek": "setFilePosition",
                "preserve_dates": "preserveDates",
                "fatal": "terminateProgram",
                "errno_location": "getErrnoLocation",
                "strerror": "getErrorString",
                "fwrite": "writeToFile",
                "fclose": "closeFile",
                "chmod": "changeFilePermissions",
                "set_times": "setFileTimes",
                "free": "releaseMemory"
            },
            "code": "\nlong * extractAndWriteArchiveFile_00107740(long **archive)\n\n{\n  int cmpResult;\n  int statError;\n  int *errNum;\n  char *errString;\n  undefined8 translatableString;\n  long **archivePointer;\n  void *buffer;\n  size_t bytesRead;\n  long loopCounter;\n  long *file;\n  undefined4 *localInfoArray;\n  ulong totalBytesRead;\n  size_t writeSize;\n  undefined4 fileInfo [6];\n  __mode_t filePermissions;\n  ulong fileSize;\n  undefined8 time1;\n  undefined8 time2;\n  \n  if (preserveDates != 0) {\n    localInfoArray = fileInfo;\n    for (loopCounter = 0x24; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *localInfoArray = 0;\n      localInfoArray = localInfoArray + 1;\n    }\n  }\n  archivePointer = (long **)archive[0x1d];\n  if ((long **)archive[0x1d] == (long **)0x0) {\n    archivePointer = archive;\n  }\n  statError = (*(code *)archivePointer[1][0x3d])(archive,fileInfo);\n  if (statError != 0) {\n    file = *archive;\n    translatableString = getTranslatedString(0,\"internal stat error on %s\",5);\n    statError = terminateProgram(translatableString,file);\n    translatableString = positionName;\n    if (statError == 3) {\n      for (; *file != 0; file = (long *)(*file + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*file != (undefined8 *)0x0; file = (long *)(*file + 0xf0)) {\n        cmpResult = compareFileName(*(undefined8 *)*file,translatableString);\n        if (cmpResult == 0) {\n          if (statError != 2) {\n            return file;\n          }\n          return (long *)(*file + 0xf0);\n        }\n      }\n    }\n    return file;\n  }\n  setFilePosition(archive,0,0);\n  outputFile = (FILE *)0x0;\n  if (fileSize == 0) {\nLAB_00102ca2:\n    outputFile = (FILE *)openOutputFile(*archive);\n  }\n  else {\n    totalBytesRead = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      writeSize = fileSize - totalBytesRead;\n      if (0x2000 < writeSize) {\n        writeSize = 0x2000;\n      }\n      bytesRead = bfd_bread(buffer,writeSize,archive);\n      if (writeSize != bytesRead) {\nLAB_00102c78:\n        archive = (long **)*archive[0x1d];\n        translatableString = getTranslatedString(0,\"%s is not a valid archive\",5);\n        terminateProgram(translatableString,archive);\n        goto LAB_00102ca2;\n      }\n      if (outputFile == (FILE *)0x0) {\n        outputFile = (FILE *)openOutputFile(*archive);\n      }\n      writeSize = writeToFile(buffer,1,bytesRead,outputFile);\n      if (writeSize != bytesRead) {\n        errNum = __getErrnoLocation();\n        errString = getErrorString(*errNum);\n        terminateProgram(\"%s: %s\",outputFileName,errString);\n        goto LAB_00102c78;\n      }\n      totalBytesRead = totalBytesRead + bytesRead;\n    } while (totalBytesRead < fileSize);\n    releaseMemory(buffer);\n  }\n  closeFile(outputFile);\n  errString = outputFileName;\n  outputFile = (FILE *)0x0;\n  changeFilePermissions(outputFileName,filePermissions);\n  if (preserveDates != 0) {\n    time1 = time2;\n    setFileTimes(errString,fileInfo);\n  }\n  outputFileName = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "extract_file.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107740",
            "calling": [
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "extract_and_write_archive_file_00107740"
        },
        "FUN_00102050": {
            "renaming": {},
            "code": "\nvoid bfd_cache_close(void)\n\n{\n  bfd_cache_close();\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "remove_output.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102050"
        },
        "FUN_0010e2b8": {
            "renaming": {},
            "code": "\n\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fwrite@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2b8",
            "calling": [
                "fwrite"
            ],
            "imported": false,
            "current_name": "FUN_0010e2b8"
        },
        "FUN_001028ed": {
            "renaming": {
                "FUN_001028ed": "FUNC_001028ed"
            },
            "code": "\nundefined8 FUNC_001028ed(undefined8 param_1,long param_2)\n\n{\n  undefined uVar1;\n  byte bVar2;\n  int iVar3;\n  size_t sVar4;\n  int *piVar5;\n  char *pcVar6;\n  char *pcVar7;\n  char **ppcVar8;\n  undefined8 uVar9;\n  long lVar10;\n  char *__s;\n  char *__s_00;\n  long lVar11;\n  undefined8 uVar12;\n  ulong uVar13;\n  char *unaff_RBX;\n  char **ppcVar14;\n  char **unaff_RBP;\n  char **unaff_R12;\n  uint unaff_R13D;\n  char **ppcVar15;\n  long unaff_R14;\n  bool bVar16;\n  byte bVar17;\n  char **param_7;\n  undefined8 param_9;\n  long in_stack_00000078;\n  long in_stack_00000108;\n  \n  bVar17 = 0;\ncode_r0x001028ed:\n  bfd_fatal(unaff_RBX,param_2);\nLAB_001028f5:\n  uVar12 = posname;\n  if (unaff_R13D != 3) {\n    while( true ) {\n      if ((undefined8 *)*unaff_R12 == (undefined8 *)0x0) goto LAB_0010571f;\n      iVar3 = filename_cmp(*(undefined8 *)*unaff_R12,uVar12);\n      if (iVar3 == 0) break;\n      unaff_R12 = (char **)(*unaff_R12 + 0xf0);\n    }\n    if (unaff_R13D != 2) goto LAB_0010571f;\n    unaff_R12 = (char **)(*unaff_R12 + 0xf0);\n    goto LAB_0010571f;\n  }\n  lVar10 = *(long *)(unaff_R14 + 0xf0);\n  if (*(long *)(unaff_R14 + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n  do {\n    lVar11 = lVar10;\n    lVar10 = *(long *)(lVar11 + 0xf0);\n  } while (lVar10 != 0);\n  unaff_R12 = (char **)(lVar11 + 0xf0);\n  unaff_RBX = *unaff_RBP;\n  if (libdeps_bfd != 0) goto LAB_00105731;\nLAB_00105698:\n  uVar1 = make_thin_archive;\n  unaff_R13D = (uint)(verbose != 0);\n  param_2 = bfd_openr(unaff_RBX,target);\n  if (param_2 != 0) {\n    unaff_RBP = unaff_RBP + 1;\n    bVar2 = do_ar_emul_append_constprop_0(unaff_R12,param_2,unaff_R13D,uVar1);\n    param_9._6_1_ = param_9._6_1_ | bVar2;\n    pcVar6 = *unaff_RBP;\n    do {\n      if (pcVar6 == (char *)0x0) {\n        if (param_9._6_1_ == 0) {\n          output_filename = 0;\n          return 0;\n        }\n        uVar12 = write_archive();\n        return uVar12;\n      }\n      ppcVar14 = *(char ***)(unaff_R14 + 0xf0);\n      unaff_R12 = param_7;\n      if (param_9._7_1_ == '\\0') {\n        ppcVar15 = param_7;\n        if (ppcVar14 != (char **)0x0) {\n          do {\n            if (full_pathname == '\\0') {\n              __s = (char *)lbasename(*ppcVar14);\n              pcVar7 = __s;\n              if (ar_truncate != '\\0') {\n                sVar4 = strlen(__s);\n                uVar13 = (ulong)*(byte *)(*(long *)(unaff_R14 + 8) + 0x1e);\n                if (uVar13 < sVar4) {\n                  pcVar7 = (char *)xmalloc(uVar13 + 1);\n                  lVar10 = *(long *)(unaff_R14 + 8);\n                  pcVar6 = pcVar7;\n                  for (uVar13 = (ulong)*(byte *)(lVar10 + 0x1e); uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *pcVar6 = *__s;\n                    __s = __s + (ulong)bVar17 * -2 + 1;\n                    pcVar6 = pcVar6 + (ulong)bVar17 * -2 + 1;\n                  }\n                  pcVar7[*(byte *)(lVar10 + 0x1e)] = '\\0';\n                }\n                pcVar6 = *unaff_RBP;\n                __s = pcVar7;\n                if (full_pathname == '\\0') goto LAB_00105611;\n                goto LAB_00102980;\n              }\n              pcVar6 = *unaff_RBP;\n              if (full_pathname != '\\0') goto LAB_00102980;\nLAB_00105611:\n              __s_00 = (char *)lbasename(pcVar6);\n              if (ar_truncate != '\\0') {\n                sVar4 = strlen(__s_00);\n                uVar13 = (ulong)*(byte *)(*(long *)(unaff_R14 + 8) + 0x1e);\n                pcVar6 = __s_00;\n                __s = pcVar7;\n                if (uVar13 < sVar4) {\n                  pcVar6 = (char *)xmalloc(uVar13 + 1);\n                  lVar10 = *(long *)(unaff_R14 + 8);\n                  pcVar7 = pcVar6;\n                  for (uVar13 = (ulong)*(byte *)(lVar10 + 0x1e); uVar13 != 0; uVar13 = uVar13 - 1) {\n                    *pcVar7 = *__s_00;\n                    __s_00 = __s_00 + (ulong)bVar17 * -2 + 1;\n                    pcVar7 = pcVar7 + (ulong)bVar17 * -2 + 1;\n                  }\n                  pcVar6[*(byte *)(lVar10 + 0x1e)] = '\\0';\n                }\n                goto LAB_00102980;\n              }\n              iVar3 = filename_cmp(__s_00,pcVar7);\n            }\n            else {\n              pcVar6 = *unaff_RBP;\n              __s = *ppcVar14;\nLAB_00102980:\n              iVar3 = filename_cmp(pcVar6,__s);\n            }\n            if ((iVar3 == 0) && (ppcVar14[0x1c] != (char *)0x0)) {\n              if (newer_only != 0) {\n                iVar3 = stat(*unaff_RBP,(stat *)&stack0x000000b0);\n                if (iVar3 != 0) {\n                  piVar5 = __errno_location();\n                  if (*piVar5 != 2) {\n                    bfd_fatal(*unaff_RBP);\nLAB_00102b7e:\n                    pcVar6 = *ppcVar14;\n                    uVar12 = dcgettext(0,\"internal stat error on %s\",5);\n                    fatal(uVar12,pcVar6);\n                    free(unaff_RBP);\n                    return 0;\n                  }\n                  goto LAB_0010577e;\n                }\n                ppcVar8 = (char **)ppcVar14[0x1d];\n                if ((char **)ppcVar14[0x1d] == (char **)0x0) {\n                  ppcVar8 = ppcVar14;\n                }\n                iVar3 = (**(code **)(ppcVar8[1] + 0x1e8))(ppcVar14,&stack0x00000020);\n                if (iVar3 != 0) goto LAB_00102b7e;\n                if (in_stack_00000108 <= in_stack_00000078) goto LAB_0010577e;\n              }\n              uVar12 = get_pos_bfd(param_7,2,*ppcVar14);\n              if (libdeps_bfd == 0) {\nLAB_00102ae2:\n                pcVar6 = *unaff_RBP;\n                bVar16 = verbose != 0;\n                lVar10 = bfd_openr(pcVar6,target);\n                if (lVar10 == 0) {\n                  bfd_fatal(pcVar6,0);\n                  goto LAB_00102b3e;\n                }\n                bVar2 = ar_emul_default_replace(uVar12,lVar10,bVar16);\n              }\n              else {\n                uVar9 = normalize(*unaff_RBP);\n                iVar3 = filename_cmp(uVar9,\"__.LIBDEP\");\n                if (iVar3 != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n                bVar2 = ar_emul_default_replace(uVar12,libdeps_bfd,verbose != 0);\n              }\n              if (bVar2 != 0) {\n                *ppcVar15 = *(char **)(*ppcVar15 + 0xf0);\n                param_9._6_1_ = bVar2;\n              }\n              goto LAB_0010577e;\n            }\n            ppcVar15 = ppcVar14 + 0x1e;\n            ppcVar14 = (char **)ppcVar14[0x1e];\n          } while (ppcVar14 != (char **)0x0);\n          goto LAB_0010564c;\n        }\n        unaff_R13D = postype;\n        if (postype != 0) goto LAB_001028f5;\n      }\n      else {\nLAB_0010564c:\n        unaff_R13D = postype;\n        if (postype != 0) goto LAB_001028f5;\n        lVar10 = *(long *)(unaff_R14 + 0xf0);\n        if (*(long *)(unaff_R14 + 0xf0) != 0) goto LAB_00105670;\n      }\nLAB_0010571f:\n      unaff_RBX = *unaff_RBP;\n      if (libdeps_bfd == 0) goto LAB_00105698;\nLAB_00105731:\n      uVar12 = normalize(unaff_RBX);\n      iVar3 = filename_cmp(uVar12,\"__.LIBDEP\");\n      if (iVar3 != 0) goto code_r0x0010574f;\n      bVar2 = ar_emul_default_append(unaff_R12,libdeps_bfd,verbose != 0,make_thin_archive);\n      param_9._6_1_ = bVar2 | param_9._6_1_;\nLAB_0010577e:\n      unaff_RBP = unaff_RBP + 1;\n      pcVar6 = *unaff_RBP;\n    } while( true );\n  }\n  goto code_r0x001028ed;\ncode_r0x0010574f:\n  unaff_RBX = *unaff_RBP;\n  goto LAB_00105698;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0",
                "bfd_fatal",
                "replace_members.cold",
                "bfd_openr",
                "dcgettext",
                "ar_emul_default_replace",
                "ar_emul_default_append",
                "xmalloc",
                "fatal",
                "stat",
                "strlen",
                "filename_cmp",
                "get_pos_bfd",
                "__errno_location",
                "write_archive",
                "normalize",
                "FUN_00102943",
                "lbasename"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x001028ed",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "FUNC_001028ed"
        },
        "FUN_0010e1b0": {
            "renaming": {},
            "code": "\n\n\n\nlong ftell(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ftell@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1b0",
            "calling": [
                "ftell"
            ],
            "imported": false,
            "current_name": "FUN_0010e1b0"
        },
        "FUN_0010e228": {
            "renaming": {},
            "code": "\n\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* realloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e228",
            "calling": [
                "realloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e228"
        },
        "FUN_0010e108": {
            "renaming": {},
            "code": "\n\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputs@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e108",
            "calling": [
                "fputs"
            ],
            "imported": false,
            "current_name": "FUN_0010e108"
        },
        "FUN_00102060": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "yy_init_buffer",
                "open_inarch",
                "simple_copy.constprop.0.cold",
                "ar_open",
                "print_contents",
                "set_times.cold",
                "get_file_size.cold",
                "replace_members.cold",
                "simple_copy.constprop.0",
                "smart_rename.constprop.0.cold",
                "extract_file.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102060"
        },
        "FUN_00102180": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "normalize.cold",
                "FUN_00105a68",
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102180"
        },
        "FUN_001025a0": {
            "renaming": {
                "FUN_001025a0": "handle_file_error_001025a0",
                "piVar1": "error_ptr",
                "uVar2": "error_message"
            },
            "code": "\nundefined8 handle_file_error_001025a0(void)\n\n{\n  int *error_ptr;\n  undefined8 error_message;\n  \n  error_ptr = __errno_location();\n  if (*error_ptr == 2) {\n    error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n    non_fatal(error_message);\n  }\n  else {\n    strerror(*error_ptr);\n    error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    non_fatal(error_message);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001025a0",
            "calling": [
                "get_file_size"
            ],
            "imported": false,
            "current_name": "handle_file_error_001025a0"
        },
        "FUN_0010284b": {
            "renaming": {
                "FUN_0010284b": "get_return_value_0010284b",
                "undefined8": "uint64_t"
            },
            "code": "\nuint64_t getReturnValue_0010284b(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010284b",
            "calling": [
                "ranlib_only"
            ],
            "imported": false,
            "current_name": "get_return_value_0010284b"
        },
        "FUN_0010e220": {
            "renaming": {},
            "code": "\n\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e220",
            "calling": [
                "fseek"
            ],
            "imported": false,
            "current_name": "FUN_0010e220"
        },
        "FUN_0010e100": {
            "renaming": {},
            "code": "\n\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* lseek@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e100",
            "calling": [
                "lseek"
            ],
            "imported": false,
            "current_name": "FUN_0010e100"
        },
        "FUN_00105cc0": {
            "renaming": {
                "FUN_00105cc0": "start_main_loop_00105cc0",
                "auStack_8": "stackFrame"
            },
            "code": "\nvoid processEntry startMainLoop_00105cc0(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined stackFrame [8];\n  \n  __libc_start_main(main,param_2,&stack0x00000008,0,0,param_1,stackFrame);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "__libc_start_main",
                "main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105cc0",
            "calling": [],
            "imported": false,
            "current_name": "start_main_loop_00105cc0"
        },
        "FUN_00102f08": {
            "renaming": {
                "FUN_00102f08": "print_and_update_00102f08",
                "unaff_RBX": "dataPointer",
                "unaff_R12": "valuePointer"
            },
            "code": "\nundefined8 printAndUpdate_00102f08(void)\n\n{\n  undefined8 *dataPointer;\n  undefined8 *valuePointer;\n  \n  printf(\"a - %s\\n\",*dataPointer);\n  dataPointer[0x1e] = *valuePointer;\n  *valuePointer = dataPointer;\n  return 1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f08",
            "calling": [
                "do_ar_emul_append.constprop.0"
            ],
            "imported": false,
            "current_name": "print_and_update_00102f08"
        },
        "FUN_00105570": {
            "renaming": {
                "FUN_00105570": "process_files_00105570",
                "param_1": "archiveData",
                "param_2": "filePaths",
                "param_3": "isOutput",
                "ppcVar1": "currentFile",
                "uVar2": "undefinedVar",
                "bVar3": "byteVar",
                "iVar4": "indexVar",
                "sVar5": "sizeVar",
                "piVar6": "errnoPtr",
                "pcVar7": "currentPath",
                "pcVar8": "truncatedPath",
                "uVar9": "normalizedPath",
                "__s": "basenameStr",
                "lVar11": "currentPtr",
                "lVar12": "nextPtr",
                "uVar13": "returnValue",
                "uVar14": "byteValue",
                "ppcVar15": "firstFilePtr",
                "ppcVar16": "previousFilePtr",
                "uVar17": "positionType",
                "ppcVar18": "previousFilePtr",
                "bVar19": "boolVar",
                "bVar20": "byteVar",
                "local_15a": "localFlag",
                "auStack_158": "auxiliaryStack",
                "lStack_100": "lStack",
                "sStack_c8": "statStruct"
            },
            "code": "\nundefined8 processFiles_00105570(long archiveData,char **filePaths,char isOutput)\n\n{\n  char **currentFile;\n  undefined undefinedVar;\n  byte byteVar;\n  int indexVar;\n  size_t sizeVar;\n  int *errnoPtr;\n  char *currentPath;\n  char *truncatedPath;\n  undefined8 normalizedPath;\n  char *pcVar10;\n  char *basenameStr;\n  long currentPtr;\n  long nextPtr;\n  undefined8 returnValue;\n  ulong byteValue;\n  char **firstFilePtr;\n  char **previousFilePtr;\n  uint positionType;\n  char **previousFilePtr;\n  bool boolVar;\n  byte byteVar;\n  byte localFlag;\n  undefined auxiliaryStack [88];\n  long lStack;\n  stat statStruct;\n  \n  byteVar = 0;\n  currentFile = (char **)(archiveData + 0xf0);\n  localFlag = 0;\n  if (filePaths == (char **)0x0) {\n    returnValue = initialize_output_filename_00102943();\n    return returnValue;\n  }\n  do {\n    pcVar10 = *filePaths;\njoined_r0x001055aa:\n    if (pcVar10 == (char *)0x0) {\n      if (localFlag != 0) {\n        returnValue = write_archive(archiveData);\n        return returnValue;\n      }\n      output_filename = 0;\n      return 0;\n    }\n    firstFilePtr = *(char ***)(archiveData + 0xf0);\n    previousFilePtr = currentFile;\n    if (isOutput != '\\0') {\nLAB_0010564c:\n      positionType = postype;\n      if (postype != 0) goto LAB_001028f5;\n      nextPtr = *(long *)(archiveData + 0xf0);\n      if (*(long *)(archiveData + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n      do {\n        currentPtr = nextPtr;\n        nextPtr = *(long *)(currentPtr + 0xf0);\n      } while (nextPtr != 0);\n      previousFilePtr = (char **)(currentPtr + 0xf0);\n      pcVar10 = *filePaths;\n      do {\n        if (libdeps_bfd != 0) {\n          returnValue = normalize(pcVar10,archiveData);\n          indexVar = filename_cmp(returnValue,\"__.LIBDEP\");\n          if (indexVar == 0) {\n            byteVar = ar_emul_default_append(previousFilePtr,libdeps_bfd,verbose != 0,make_thin_archive);\n            localFlag = byteVar | localFlag;\n            goto LAB_0010577e;\n          }\n          pcVar10 = *filePaths;\n        }\n        undefinedVar = make_thin_archive;\n        boolVar = verbose != 0;\n        nextPtr = bfd_openr(pcVar10,target);\n        if (nextPtr != 0) {\n          filePaths = filePaths + 1;\n          byteVar = do_ar_emul_append_constprop_0(previousFilePtr,nextPtr,(uint)boolVar,undefinedVar);\n          localFlag = localFlag | byteVar;\n          pcVar10 = *filePaths;\n          goto joined_r0x001055aa;\n        }\n        bfd_fatal(pcVar10,0);\n        positionType = (uint)boolVar;\nLAB_001028f5:\n        returnValue = posname;\n        if (positionType == 3) {\n          nextPtr = *(long *)(archiveData + 0xf0);\n          if (*(long *)(archiveData + 0xf0) != 0) goto LAB_00105670;\n        }\n        else {\n          for (; (undefined8 *)*previousFilePtr != (undefined8 *)0x0;\n              previousFilePtr = (char **)(*previousFilePtr + 0xf0)) {\n            indexVar = filename_cmp(*(undefined8 *)*previousFilePtr,returnValue);\n            if (indexVar == 0) {\n              if (positionType == 2) {\n                previousFilePtr = (char **)(*previousFilePtr + 0xf0);\n              }\n              break;\n            }\n          }\n        }\nLAB_0010571f:\n        pcVar10 = *filePaths;\n      } while( true );\n    }\n    previousFilePtr = currentFile;\n    if (firstFilePtr == (char **)0x0) {\n      positionType = postype;\n      if (postype == 0) goto LAB_0010571f;\n      goto LAB_001028f5;\n    }\nLAB_001055d8:\n    if (full_pathname == '\\0') {\n      pcVar10 = (char *)lbasename(*firstFilePtr);\n      truncatedPath = pcVar10;\n      if (ar_truncate != '\\0') {\n        sizeVar = strlen(pcVar10);\n        byteValue = (ulong)*(byte *)(*(long *)(archiveData + 8) + 0x1e);\n        if (byteValue < sizeVar) {\n          truncatedPath = (char *)xmalloc(byteValue + 1);\n          nextPtr = *(long *)(archiveData + 8);\n          currentPath = truncatedPath;\n          for (byteValue = (ulong)*(byte *)(nextPtr + 0x1e); byteValue != 0; byteValue = byteValue - 1) {\n            *currentPath = *pcVar10;\n            pcVar10 = pcVar10 + (ulong)byteVar * -2 + 1;\n            currentPath = currentPath + (ulong)byteVar * -2 + 1;\n          }\n          truncatedPath[*(byte *)(nextPtr + 0x1e)] = '\\0';\n        }\n        currentPath = *filePaths;\n        pcVar10 = truncatedPath;\n        if (full_pathname == '\\0') goto LAB_00105611;\n        goto LAB_00102980;\n      }\n      currentPath = *filePaths;\n      if (full_pathname != '\\0') goto LAB_00102980;\nLAB_00105611:\n      basenameStr = (char *)lbasename(currentPath);\n      if (ar_truncate != '\\0') {\n        sizeVar = strlen(basenameStr);\n        byteValue = (ulong)*(byte *)(*(long *)(archiveData + 8) + 0x1e);\n        currentPath = basenameStr;\n        pcVar10 = truncatedPath;\n        if (byteValue < sizeVar) {\n          currentPath = (char *)xmalloc(byteValue + 1);\n          nextPtr = *(long *)(archiveData + 8);\n          truncatedPath = currentPath;\n          for (byteValue = (ulong)*(byte *)(nextPtr + 0x1e); byteValue != 0; byteValue = byteValue - 1) {\n            *truncatedPath = *basenameStr;\n            basenameStr = basenameStr + (ulong)byteVar * -2 + 1;\n            truncatedPath = truncatedPath + (ulong)byteVar * -2 + 1;\n          }\n          currentPath[*(byte *)(nextPtr + 0x1e)] = '\\0';\n        }\n        goto LAB_00102980;\n      }\n      indexVar = filename_cmp(basenameStr,truncatedPath);\n      if (indexVar == 0) goto LAB_00102993;\nLAB_00105639:\n      previousFilePtr = firstFilePtr + 0x1e;\n      firstFilePtr = (char **)firstFilePtr[0x1e];\n      if (firstFilePtr == (char **)0x0) goto LAB_0010564c;\n      goto LAB_001055d8;\n    }\n    currentPath = *filePaths;\n    pcVar10 = *firstFilePtr;\nLAB_00102980:\n    indexVar = filename_cmp(currentPath,pcVar10);\n    if (indexVar != 0) goto LAB_00105639;\nLAB_00102993:\n    if (firstFilePtr[0x1c] == (char *)0x0) goto LAB_00105639;\n    if (newer_only != 0) {\n      indexVar = stat(*filePaths,&statStruct);\n      if (indexVar != 0) {\n        errnoPtr = __errno_location();\n        if (*errnoPtr != 2) {\n          bfd_fatal(*filePaths);\nLAB_00102b7e:\n          pcVar10 = *firstFilePtr;\n          returnValue = dcgettext(0,\"internal stat error on %s\",5);\n          fatal(returnValue,pcVar10);\n          free(filePaths);\n          return 0;\n        }\n        goto LAB_0010577e;\n      }\n      previousFilePtr = (char **)firstFilePtr[0x1d];\n      if ((char **)firstFilePtr[0x1d] == (char **)0x0) {\n        previousFilePtr = firstFilePtr;\n      }\n      indexVar = (**(code **)(previousFilePtr[1] + 0x1e8))(firstFilePtr,auxiliaryStack);\n      if (indexVar != 0) goto LAB_00102b7e;\n      if (statStruct.st_mtim.tv_sec <= lStack) goto LAB_0010577e;\n    }\n    returnValue = get_pos_bfd(currentFile,2,*firstFilePtr);\n    if (libdeps_bfd == 0) {\nLAB_00102ae2:\n      pcVar10 = *filePaths;\n      boolVar = verbose != 0;\n      nextPtr = bfd_openr(pcVar10,target);\n      if (nextPtr == 0) {\n        bfd_fatal(pcVar10,0);\n        goto LAB_00102b3e;\n      }\n      byteVar = ar_emul_default_replace(returnValue,nextPtr,boolVar);\n    }\n    else {\n      normalizedPath = normalize(*filePaths,archiveData);\n      indexVar = filename_cmp(normalizedPath,\"__.LIBDEP\");\n      if (indexVar != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n      byteVar = ar_emul_default_replace(returnValue,libdeps_bfd,verbose != 0);\n    }\n    if (byteVar != 0) {\n      *previousFilePtr = *(char **)(*previousFilePtr + 0xf0);\n      localFlag = byteVar;\n    }\nLAB_0010577e:\n    filePaths = filePaths + 1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00102943"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105570",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_files_00105570"
        },
        "FUN_0010e1a8": {
            "renaming": {},
            "code": "\n\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1a8",
            "calling": [
                "fprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e1a8"
        },
        "FUN_0010e2e8": {
            "renaming": {},
            "code": "\n\n\n\nint getc(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2e8",
            "calling": [
                "getc"
            ],
            "imported": false,
            "current_name": "FUN_0010e2e8"
        },
        "FUN_0010e1c0": {
            "renaming": {},
            "code": "\n\n\n\nint stat(char *__file,stat *__buf)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* stat@GLIBC_2.33 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1c0",
            "calling": [
                "stat"
            ],
            "imported": false,
            "current_name": "FUN_0010e1c0"
        },
        "FUN_00102500": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102500",
            "calling": [
                "print_version",
                "yy_fatal_error"
            ],
            "imported": false,
            "current_name": "FUN_00102500"
        },
        "FUN_0010e2e0": {
            "renaming": {},
            "code": "\n\n\n\nchar * strerror(int __errnum)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strerror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e2e0",
            "calling": [
                "strerror"
            ],
            "imported": false,
            "current_name": "FUN_0010e2e0"
        },
        "FUN_0010e238": {
            "renaming": {},
            "code": "\n\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* setlocale@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e238",
            "calling": [
                "setlocale"
            ],
            "imported": false,
            "current_name": "FUN_0010e238"
        },
        "FUN_00102190": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102190"
        },
        "FUN_00102070": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "smart_rename.constprop.0.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102070"
        },
        "FUN_0010285f": {
            "renaming": {
                "FUN_0010285f": "print_archive_entry_not_found_0010285f",
                "__format": "formatString",
                "lVar2": "normalizedEntry",
                "plVar3": "matchingEntry",
                "uVar4": "currentEntry",
                "plVar5": "entry",
                "unaff_RBP": "callbackFunction",
                "unaff_R12": "archiveBaseAddress",
                "unaff_R13D": "remainingEntries",
                "unaff_R14": "entries",
                "iStack000000000000000c": "matchingEntriesCounter",
                "code_r0x0010285f": "startLoop",
                "LAB_0010553e": "endLoop"
            },
            "code": "\n\n\nvoid printArchiveEntryNotFound_0010285f(void)\n\n{\n  int iVar1;\n  char *formatString;\n  long normalizedEntry;\n  long *matchingEntry;\n  undefined8 currentEntry;\n  long *entry;\n  code *callbackFunction;\n  long archiveBaseAddress;\n  int remainingEntries;\n  undefined8 *entries;\n  int matchingEntriesCounter;\n  \nstartLoop:\n  currentEntry = *entries;\n  formatString = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n  fprintf(_stderr,formatString,currentEntry);\nendLoop:\n  entries = entries + 1;\n  remainingEntries = remainingEntries + -1;\n  if (remainingEntries == 0) {\n    return;\n  }\n  entry = *(long **)(archiveBaseAddress + 0xf0);\n  matchingEntriesCounter = 0;\n  do {\n    if (entry == (long *)0x0) goto startLoop;\n    if (*(int *)((long)entry + 0xac) == 0) {\n      normalizedEntry = *entry;\n      if (normalizedEntry == 0) {\n        matchingEntry = (long *)entry[0x1d];\n        if ((long *)entry[0x1d] == (long *)0x0) {\n          matchingEntry = entry;\n        }\n        (**(code **)(matchingEntry[1] + 0x1e8))(entry,&stack0x00000010);\n      }\n      else if (((*(byte *)(archiveBaseAddress + 0x49) & 0x10) == 0) || (normalizedEntry = normalize(), normalizedEntry != 0)) {\n        currentEntry = normalize(*entries);\n        iVar1 = filename_cmp(currentEntry,normalizedEntry);\n        if ((iVar1 == 0) &&\n           ((counted_name_mode == '\\0' ||\n            (matchingEntriesCounter = matchingEntriesCounter + 1,\n            matchingEntriesCounter == counted_name_counter)))) break;\n      }\n    }\n    entry = (long *)entry[0x1e];\n  } while( true );\n  (*callbackFunction)();\n  *(undefined4 *)((long)entry + 0xac) = 1;\n  goto endLoop;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010285f",
            "calling": [
                "map_over_members"
            ],
            "imported": false,
            "current_name": "print_archive_entry_not_found_0010285f"
        },
        "FUN_0010394a": {
            "renaming": {
                "FUN_0010394a": "print_usage_0010394a",
                "param_1": "isError",
                "uVar1": "programName",
                "pcVar2": "translatedString",
                "__stream": "outputFile"
            },
            "code": "\n\n\nvoid printUsage_0010394a(uint isError)\n\n{\n  undefined8 programName;\n  char *translatedString;\n  FILE *outputFile;\n  \n  programName = program_name;\n  outputFile = _stderr;\n  if (isError != 0) {\n    outputFile = _stdout;\n  }\n  translatedString = (char *)dcgettext(0,\"Usage: %s [options] archive\\n\",5);\n  fprintf(outputFile,translatedString,programName);\n  translatedString = (char *)dcgettext(0,\" Generate an index to speed access to archives\\n\",5);\n  fprintf(outputFile,translatedString);\n  translatedString = (char *)dcgettext(0,\n                             \" The options are:\\n  @<file>                      Read options from <file>\\n\"\n                             ,5);\n  fprintf(outputFile,translatedString);\n  translatedString = (char *)dcgettext(0,\"  --plugin <name>              Load the specified plugin\\n\",5);\n  fprintf(outputFile,translatedString);\n  translatedString = (char *)dcgettext(0,\n                             \"  -D                           Use zero for symbol map timestamp (default)\\n  -U                           Use an actual symbol map timestamp\\n\"\n                             ,5);\n  fprintf(outputFile,translatedString);\n  translatedString = (char *)dcgettext(0,\n                             \"  -t                           Update the archive\\'s symbol map timestamp\\n  -h --help                    Print this help message\\n  -v --version                 Print version information\\n\"\n                             ,5);\n  fprintf(outputFile,translatedString);\n  list_supported_targets(program_name,outputFile);\n  if (isError != 0) {\n    translatedString = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputFile,translatedString,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(isError ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "fprintf",
                "list_supported_targets",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010394a",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_usage_0010394a"
        },
        "FUN_00105bb0": {
            "renaming": {
                "FUN_00105bb0": "initialize_00105bb0"
            },
            "code": "\nundefined8 initialize_00105bb0(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bb0",
            "calling": [],
            "imported": false,
            "current_name": "initialize_00105bb0"
        },
        "FUN_00107640": {
            "renaming": {
                "FUN_00107640": "initialize_00107640"
            },
            "code": "\nundefined8 initialize_00107640(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107640",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "initialize_00107640"
        },
        "FUN_0010e1d8": {
            "renaming": {},
            "code": "\n\n\n\nvoid clearerr(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* clearerr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1d8",
            "calling": [
                "clearerr"
            ],
            "imported": false,
            "current_name": "FUN_0010e1d8"
        },
        "FUN_00102510": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102510",
            "calling": [
                "print_contents",
                "extract_file.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102510"
        },
        "FUN_0010315d": {
            "renaming": {
                "FUN_0010315d": "exit_if_not_interactive_0010315d",
                "interactive": "isInteractive"
            },
            "code": "\nvoid exitIfNotInteractive_0010315d(void)\n\n{\n  if (isInteractive == 0) {\n                    \n    xexit(9);\n  }\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010315d",
            "calling": [
                "open_inarch",
                "ar_open",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "exit_if_not_interactive_0010315d"
        },
        "FUN_0010e1d0": {
            "renaming": {},
            "code": "\n\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strtol@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1d0",
            "calling": [
                "strtol"
            ],
            "imported": false,
            "current_name": "FUN_0010e1d0"
        },
        "FUN_0010e248": {
            "renaming": {},
            "code": "\n\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* chmod@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e248",
            "calling": [
                "chmod"
            ],
            "imported": false,
            "current_name": "FUN_0010e248"
        },
        "FUN_0010e008": {
            "renaming": {},
            "code": "\n\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* utimensat@GLIBC_2.6 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e008",
            "calling": [
                "utimensat"
            ],
            "imported": false,
            "current_name": "FUN_0010e008"
        },
        "FUN_00102080": {
            "renaming": {},
            "code": "\nvoid bfd_make_writable(void)\n\n{\n  bfd_make_writable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_writable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102080"
        },
        "FUN_00107890": {
            "renaming": {
                "FUN_00107890": "print_arelt_description_00107890",
                "param_1": "output_stream",
                "_stdout": "output_stream",
                "verbose": "is_verbose",
                "display_offsets": "show_offsets"
            },
            "code": "\n\n\nvoid print_arelt_description_00107890(undefined8 output_stream)\n\n{\n  print_arelt_descr(output_stream,output_stream,is_verbose != 0,show_offsets != 0);\n  return;\n}\n\n",
            "called": [
                "print_arelt_descr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107890",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_arelt_description_00107890"
        },
        "FUN_001024a0": {
            "renaming": {},
            "code": "\n\n\nvoid perror(char *__s)\n\n{\n  perror(__s);\n  return;\n}\n\n",
            "called": [
                "perror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024a0",
            "calling": [
                "open_inarch",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "FUN_001024a0"
        },
        "FUN_0010e000": {
            "renaming": {},
            "code": "\n\n\n\nvoid free(void *__ptr)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* free@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e000",
            "calling": [
                "free"
            ],
            "imported": false,
            "current_name": "FUN_0010e000"
        },
        "FUN_00103172": {
            "renaming": {
                "FUN_00103172": "copy_and_print_string_00103172",
                "param_1": "source_string",
                "param_2": "destination_array",
                "param_3": "should_print",
                "param_4": "extra_data",
                "uVar1": "source_string_value",
                "auVar2": "new_array"
            },
            "code": "\nundefined  [16]\ncopy_and_print_string_00103172(undefined8 *source_string,undefined8 *destination_array,char should_print,undefined8 extra_data)\n\n{\n  undefined8 source_string_value;\n  undefined new_array [16];\n  \n  if (should_print != '\\0') {\n    printf(\"r - %s\\n\",*destination_array);\n  }\n  source_string_value = *source_string;\n  destination_array[0x1e] = source_string_value;\n  new_array._1_7_ = (undefined7)((ulong)source_string_value >> 8);\n  new_array[0] = 1;\n  *source_string = destination_array;\n  new_array._8_8_ = extra_data;\n  return new_array;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103172",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "copy_and_print_string_00103172"
        },
        "FUN_0010e0a8": {
            "renaming": {},
            "code": "\n\n\n\nint fclose(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fclose@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0a8",
            "calling": [
                "fclose"
            ],
            "imported": false,
            "current_name": "FUN_0010e0a8"
        },
        "FUN_001030ed": {
            "renaming": {
                "FUN_001030ed": "initialize_buffer_001030ed",
                "yy_buffer_stack": "bufferStack",
                "yy_buffer_stack_top": "bufferStackTop",
                "puVar1": "bufferPointer",
                "yy_n_chars": "totalChars",
                "yy_c_buf_p": "currentBufferPointer",
                "yytext": "textBuffer",
                "yyin": "input",
                "yy_hold_char": "heldCharacter"
            },
            "code": "\nvoid initializeBuffer_001030ed(void)\n\n{\n  undefined8 *bufferPointer;\n  \n  bufferPointer = *(undefined8 **)(bufferStack + bufferStackTop * 8);\n  totalChars = *(undefined4 *)((long)bufferPointer + 0x1c);\n  currentBufferPointer = (undefined *)bufferPointer[2];\n  textBuffer = currentBufferPointer;\n  input = *bufferPointer;\n  heldCharacter = *currentBufferPointer;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001030ed",
            "calling": [
                "yy_init_buffer",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "initialize_buffer_001030ed"
        },
        "FUN_00105bc0": {
            "renaming": {
                "FUN_00105bc0": "copy_and_unlink_file_00105bc0",
                "param_1": "sourceFile",
                "param_2": "destinationFile",
                "param_3": "filePermissions",
                "param_4": "fileSize",
                "uVar1": "copyResult",
                "piVar2": "errnoLocation",
                "pcVar3": "errorStr",
                "uVar4": "errorFormatStr",
                "uVar5": "copyError",
                "auVar6": "result"
            },
            "code": "\nundefined  [16] copyAndUnlinkFile_00105bc0(char *sourceFile,char *destinationFile,undefined4 filePermissions,undefined8 fileSize)\n\n{\n  uint copyResult;\n  int *errnoLocation;\n  char *errorStr;\n  undefined8 errorFormatStr;\n  ulong copyError;\n  undefined result [16];\n  \n  if (destinationFile == sourceFile) {\n    copyError = 0;\n  }\n  else {\n    copyResult = simple_copy_constprop_0(filePermissions);\n    copyError = (ulong)copyResult;\n    if (copyResult != 0) {\n      errnoLocation = __errno_location();\n      errorStr = strerror(*errnoLocation);\n      errorFormatStr = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      non_fatal(errorFormatStr,destinationFile,errorStr);\n    }\n    unlink(sourceFile);\n  }\n  result._8_8_ = fileSize;\n  result._0_8_ = copyError;\n  return result;\n}\n\n",
            "called": [
                "simple_copy.constprop.0",
                "smart_rename.constprop.0.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bc0",
            "calling": [
                "write_archive.cold",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "copy_and_unlink_file_00105bc0"
        },
        "FUN_00107650": {
            "renaming": {
                "FUN_00107650": "check_and_write_archive_00107650",
                "param_1": "file",
                "uVar1": "returnValue",
                "lVar2": "fileSize",
                "get_file_size": "getFileSize",
                "write_armap": "shouldWriteArmap",
                "open_inarch": "openArchive",
                "xexit": "exitFunction",
                "write_archive": "writeArchive"
            },
            "code": "\nundefined8 checkAndWriteArchive_00107650(undefined8 file)\n\n{\n  undefined8 returnValue;\n  long fileSize;\n  \n  fileSize = getFileSize();\n  if (fileSize < 1) {\n    returnValue = 1;\n  }\n  else {\n    shouldWriteArmap = 1;\n    fileSize = openArchive(file,0);\n    if (fileSize == 0) {\n                    \n      exitFunction(1);\n    }\n    writeArchive(fileSize);\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "xexit",
                "open_inarch",
                "write_archive",
                "ranlib_only.cold",
                "get_file_size"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107650",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "check_and_write_archive_00107650"
        },
        "FUN_00102f1e": {
            "renaming": {
                "FUN_00102f1e": "copy_and_unlink_file_00102f1e",
                "unaff_RBP": "fileSize",
                "unaff_R12": "filePath",
                "unaff_retaddr": "returnAddress",
                "piVar1": "errorLocation",
                "uVar2": "errorMessage",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16] copyAndUnlinkFile_00102f1e(void)\n\n{\n  int *errorLocation;\n  undefined8 errorMessage;\n  ulong fileSize;\n  char *filePath;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  errorLocation = __errno_location();\n  strerror(*errorLocation);\n  errorMessage = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  non_fatal(errorMessage);\n  unlink(filePath);\n  returnValue._0_8_ = fileSize & 0xffffffff;\n  returnValue._8_8_ = returnAddress;\n  return returnValue;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "unlink",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f1e",
            "calling": [
                "smart_rename.constprop.0"
            ],
            "imported": false,
            "current_name": "copy_and_unlink_file_00102f1e"
        },
        "FUN_0010e1e8": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memcpy@GLIBC_2.14 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1e8",
            "calling": [
                "memcpy"
            ],
            "imported": false,
            "current_name": "FUN_0010e1e8"
        },
        "FUN_00102fd7": {
            "renaming": {
                "FUN_00102fd7": "set_time_error_00102fd7",
                "piVar1": "errorLocation",
                "uVar2": "localizedMessage"
            },
            "code": "\nvoid setTimeError_00102fd7(void)\n\n{\n  int *errorLocation;\n  undefined8 localizedMessage;\n  \n  errorLocation = __errno_location();\n  strerror(*errorLocation);\n  localizedMessage = dcgettext(0,\"%s: cannot set time: %s\",5);\n  non_fatal(localizedMessage);\n  return;\n}\n\n",
            "called": [
                "__errno_location",
                "strerror",
                "dcgettext",
                "non_fatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd7",
            "calling": [
                "set_times"
            ],
            "imported": false,
            "current_name": "set_time_error_00102fd7"
        },
        "FUN_0010e0c8": {
            "renaming": {},
            "code": "\n\n\nvoid dcgettext(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dcgettext@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0c8",
            "calling": [
                "dcgettext"
            ],
            "imported": false,
            "current_name": "FUN_0010e0c8"
        },
        "FUN_00102400": {
            "renaming": {},
            "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "yyensure_buffer_stack",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102400"
        },
        "FUN_00102520": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102520",
            "calling": [
                "open_inarch.cold",
                "do_ar_emul_append.constprop.0",
                "ar_open"
            ],
            "imported": false,
            "current_name": "FUN_00102520"
        },
        "FUN_001024b0": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024b0",
            "calling": [
                "report"
            ],
            "imported": false,
            "current_name": "FUN_001024b0"
        },
        "FUN_00107da8": {
            "renaming": {
                "FUN_00107da8": "FUNC_00107da8"
            },
            "code": "\nvoid FUNC_00107da8(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107da8",
            "calling": [],
            "imported": false,
            "current_name": "FUNC_00107da8"
        },
        "FUN_0010e0c0": {
            "renaming": {},
            "code": "\n\n\nvoid bindtextdomain(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* bindtextdomain@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0c0",
            "calling": [
                "bindtextdomain"
            ],
            "imported": false,
            "current_name": "FUN_0010e0c0"
        },
        "FUN_0010e018": {
            "renaming": {},
            "code": "\n\n\nvoid __libc_start_main(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __libc_start_main@GLIBC_2.34 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e018",
            "calling": [
                "_start"
            ],
            "imported": false,
            "current_name": "FUN_0010e018"
        },
        "FUN_00105d60": {
            "renaming": {
                "FUN_00105d60": "initialize_resources_00105d60",
                "completed_0": "isInitialized",
                "__cxa_finalize": "finalizeDynamicObjects",
                "__dso_handle": "dynamicObjectHandle",
                "deregister_tm_clones": "deregisterMemoryClones"
            },
            "code": "\nvoid initializeResources_00105d60(void)\n\n{\n  if (isInitialized != '\\0') {\n    return;\n  }\n  finalizeDynamicObjects(dynamicObjectHandle);\n  deregisterMemoryClones();\n  isInitialized = 1;\n  return;\n}\n\n",
            "called": [
                "deregister_tm_clones",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105d60",
            "calling": [],
            "imported": false,
            "current_name": "initialize_resources_00105d60"
        },
        "FUN_001075e0": {
            "renaming": {
                "FUN_001075e0": "print_version_info_001075e0",
                "param_1": "versionString",
                "pcVar1": "localizedString"
            },
            "code": "\nvoid printVersionInfo_001075e0(undefined8 versionString)\n\n{\n  char *localizedString;\n  \n  printf(\"GNU %s %s\\n\",versionString,\"(GNU Binutils for Debian) 2.40\");\n  localizedString = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(localizedString);\n  localizedString = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(localizedString);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "exit",
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001075e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "print_version_info_001075e0"
        },
        "FUN_00105480": {
            "renaming": {
                "FUN_00105480": "process_entries_00105480",
                "param_1": "archive",
                "param_2": "entryProcessor",
                "param_3": "entryNames",
                "param_4": "numEntries",
                "__format": "format",
                "lVar2": "currentEntry",
                "plVar3": "nextEntry",
                "uVar4": "normalizedEntryName",
                "plVar5": "entryPtr",
                "local_cc": "counter",
                "local_c8": "buffer",
                "plVar5[0x1e]": "entryPtr.next",
                "plVar5[0x1d]": "entryPtr.relativePath",
                "counted_name_mode": "isCountedNameMode",
                "counted_name_counter": "countedNameCounter"
            },
            "code": "\n\n\nvoid processEntries_00105480(long archive,code *entryProcessor,undefined8 *entryNames,int numEntries)\n\n{\n  int iVar1;\n  char *format;\n  long currentEntry;\n  long *nextEntry;\n  undefined8 normalizedEntryName;\n  long *entryPtr;\n  int counter;\n  undefined buffer [152];\n  \n  currentEntry = *(long *)(archive + 0xf0);\n  if (numEntries == 0) {\n    for (; currentEntry != 0; currentEntry = *(long *)(currentEntry + 0xf0)) {\n      (*entryProcessor)(currentEntry);\n    }\n  }\n  else {\n    for (; currentEntry != 0; currentEntry = *(long *)(currentEntry + 0xf0)) {\n      *(undefined4 *)(currentEntry + 0xac) = 0;\n    }\n    do {\n      entryPtr = *(long **)(archive + 0xf0);\n      counter = 0;\n      for (; entryPtr != (long *)0x0; entryPtr = (long *)entryPtr.next) {\n        if (*(int *)((long)entryPtr + 0xac) == 0) {\n          currentEntry = *entryPtr;\n          if (currentEntry == 0) {\n            nextEntry = (long *)entryPtr.relativePath;\n            if ((long *)entryPtr.relativePath == (long *)0x0) {\n              nextEntry = entryPtr;\n            }\n            (**(code **)(nextEntry[1] + 0x1e8))(entryPtr,buffer);\n          }\n          else if (((*(byte *)(archive + 0x49) & 0x10) == 0) ||\n                  (currentEntry = normalize(currentEntry,archive), currentEntry != 0)) {\n            normalizedEntryName = normalize(*entryNames,archive);\n            iVar1 = filename_cmp(normalizedEntryName,currentEntry);\n            if ((iVar1 == 0) &&\n               ((isCountedNameMode == '\\0' ||\n                (counter = counter + 1, counter == countedNameCounter)))) {\n              (*entryProcessor)();\n              *(undefined4 *)((long)entryPtr + 0xac) = 1;\n              goto LAB_0010553e;\n            }\n          }\n        }\n      }\n      normalizedEntryName = *entryNames;\n      format = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n      fprintf(_stderr,format,normalizedEntryName);\nLAB_0010553e:\n      entryNames = entryNames + 1;\n      numEntries = numEntries + -1;\n    } while (numEntries != 0);\n  }\n  return;\n}\n\n",
            "called": [
                "filename_cmp",
                "normalize",
                "map_over_members.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105480",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_entries_00105480"
        },
        "FUN_00105cf0": {
            "renaming": {
                "FUN_00105cf0": "FUNC_00105cf0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d03) */\n/* WARNING: Removing unreachable block (ram,0x00105d0f) */\n\nvoid FUNC_00105cf0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105cf0",
            "calling": [
                "__do_global_dtors_aux"
            ],
            "imported": false,
            "current_name": "FUNC_00105cf0"
        },
        "FUN_00102090": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102090"
        },
        "FUN_0010e258": {
            "renaming": {},
            "code": "\n\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* memmove@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e258",
            "calling": [
                "memmove"
            ],
            "imported": false,
            "current_name": "FUN_0010e258"
        },
        "FUN_00102530": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102530",
            "calling": [
                "open_inarch",
                "do_ar_emul_append.constprop.0",
                "ar_open"
            ],
            "imported": false,
            "current_name": "FUN_00102530"
        },
        "FUN_0010e0b8": {
            "renaming": {},
            "code": "\n\n\n\nchar * ctime(time_t *__timer)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ctime@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0b8",
            "calling": [
                "ctime"
            ],
            "imported": false,
            "current_name": "FUN_0010e0b8"
        },
        "FUN_0010e0d8": {
            "renaming": {},
            "code": "\n\n\nvoid getopt_long(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* getopt_long@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0d8",
            "calling": [
                "getopt_long"
            ],
            "imported": false,
            "current_name": "FUN_0010e0d8"
        },
        "FUN_00102410": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102410"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "process_archive_00103a78",
                "param_1": "parameters",
                "iVar1": "returnValue",
                "__ptr": "buffer",
                "puVar2": "ptrToParameters",
                "uVar3": "bytesRead",
                "uVar4": "errorString",
                "sVar5": "bytesWritten",
                "piVar6": "errorNumber",
                "unaff_RBP": "remainingBytes",
                "pcVar7": "errorMessage",
                "unaff_R13": "totalBytesRead",
                "unaff_R14": "totalBytes",
                "auStack_b8": "stackBuffer",
                "local_88": "endOfFile"
            },
            "code": "\n\n\nvoid process_archive_00103a78(undefined8 *parameters)\n\n{\n  int returnValue;\n  void *buffer;\n  undefined8 *ptrToParameters;\n  ulong bytesRead;\n  undefined8 errorString;\n  size_t bytesWritten;\n  int *errorNumber;\n  size_t remainingBytes;\n  char *errorMessage;\n  ulong totalBytesRead;\n  ulong totalBytes;\n  undefined stackBuffer [48];\n  ulong endOfFile;\n  \n  buffer = (void *)xmalloc(0x2000);\n  ptrToParameters = (undefined8 *)parameters[0x1d];\n  if ((undefined8 *)parameters[0x1d] == (undefined8 *)0x0) {\n    ptrToParameters = parameters;\n  }\n  returnValue = (**(code **)(ptrToParameters[1] + 0x1e8))(parameters,stackBuffer);\n  if (returnValue == 0) {\n    if (verbose != 0) {\n      printf(\"\\n<%s>\\n\\n\",*parameters);\n    }\n    totalBytesRead = 0;\n    bfd_seek(parameters,0,0);\n    goto LAB_00103afd;\n  }\n  parameters = (undefined8 *)*parameters;\n  errorMessage = \"internal stat error on %s\";\n  do {\n    errorString = dcgettext(0,errorMessage,5);\n    fatal(errorString,parameters);\n    endOfFile = totalBytes;\n    do {\n      bytesWritten = fwrite(buffer,1,remainingBytes,_stdout);\n      if (bytesWritten != remainingBytes) {\n        errorNumber = __errno_location();\n        errorMessage = strerror(*errorNumber);\n        fatal(\"stdout: %s\",errorMessage);\nLAB_00103b91:\n        free(buffer);\n        return;\n      }\n      totalBytesRead = totalBytesRead + bytesWritten;\nLAB_00103afd:\n      if (endOfFile <= totalBytesRead) goto LAB_00103b91;\n      remainingBytes = endOfFile - totalBytesRead;\n      if (0x2000 < remainingBytes) {\n        remainingBytes = 0x2000;\n      }\n      bytesRead = bfd_bread(buffer,remainingBytes,parameters);\n    } while (remainingBytes == bytesRead);\n    errorMessage = \"%s is not a valid archive\";\n    parameters = *(undefined8 **)parameters[0x1d];\n    totalBytes = endOfFile;\n  } while( true );\n}\n\n",
            "called": [
                "fwrite",
                "xmalloc",
                "fatal",
                "bfd_seek",
                "__errno_location",
                "strerror",
                "printf",
                "free",
                "dcgettext",
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "process_archive_00103a78"
        },
        "FUN_0010e1f0": {
            "renaming": {},
            "code": "\n\n\n\nint fileno(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fileno@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e1f0",
            "calling": [
                "fileno"
            ],
            "imported": false,
            "current_name": "FUN_0010e1f0"
        },
        "FUN_001023a0": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001023a0"
        },
        "FUN_0010e0d0": {
            "renaming": {},
            "code": "\n\n\n\nsize_t strlen(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strlen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0d0",
            "calling": [
                "strlen"
            ],
            "imported": false,
            "current_name": "FUN_0010e0d0"
        },
        "FUN_001024c0": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024c0",
            "calling": [
                "open_inarch",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024c0"
        },
        "FUN_0010e028": {
            "renaming": {},
            "code": "\n\n\n\nint unlink(char *__name)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* unlink@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e028",
            "calling": [
                "unlink"
            ],
            "imported": false,
            "current_name": "FUN_0010e028"
        },
        "FUN_0010e268": {
            "renaming": {},
            "code": "\n\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fopen@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e268",
            "calling": [
                "fopen"
            ],
            "imported": false,
            "current_name": "FUN_0010e268"
        },
        "FUN_0010e148": {
            "renaming": {},
            "code": "\n\n\n\nint close(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* close@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e148",
            "calling": [
                "close"
            ],
            "imported": false,
            "current_name": "FUN_0010e148"
        },
        "FUN_0010e020": {
            "renaming": {},
            "code": "\n\n\n\nint * __errno_location(void)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* __errno_location@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e020",
            "calling": [
                "__errno_location"
            ],
            "imported": false,
            "current_name": "FUN_0010e020"
        },
        "FUN_001058b0": {
            "renaming": {
                "FUN_001058b0": "write_archive_file_001058b0",
                "param_1": "input_params",
                "__format": "format_string",
                "__ptr": "file_path",
                "__stream": "temp_file",
                "ppcVar5": "output_bfd_ptr",
                "uVar2": "modified_flags",
                "uStack0000000000000020": "file_mode",
                "in_stack_00000028": "file_size",
                "in_stack_00000038": "timestamp",
                "local_3c": "error_code",
                "uStack_33": "file_type",
                "cStack_32": "char1",
                "cStack_31": "char2",
                "output_filename": "output_file_path",
                "ar_truncate": "truncate_flag",
                "deterministic": "deterministic_flag",
                "full_pathname": "full_path_flag",
                "make_thin_archive": "thin_archive_flag"
            },
            "code": "\nvoid write_archive_file_001058b0(undefined8 *input_params)\n\n{\n  char cVar1;\n  uint modified_flags;\n  int iVar3;\n  undefined8 uVar4;\n  char *format_string;\n  void *file_path;\n  FILE *temp_file;\n  char **output_bfd_ptr;\n  uint file_mode;\n  uint file_size;\n  undefined8 timestamp;\n  int error_code [2];\n  undefined file_type;\n  char char1;\n  char char2;\n  \n  uVar4 = input_params[0x1e];\n  error_code[0] = -1;\n  file_path = (void *)xstrdup(*input_params);\n  temp_file = (FILE *)make_tempname(file_path,error_code);\n  iVar3 = error_code[0];\n  if (temp_file != (FILE *)0x0) {\n    output_file_path = temp_file;\n    output_bfd_ptr = (char **)bfd_fdopenw(temp_file,*(undefined8 *)input_params[1],error_code[0]);\n    if (output_bfd_ptr != (char **)0x0) {\n      output_bfd = output_bfd_ptr;\n      bfd_set_format(output_bfd_ptr,2);\n      modified_flags = (~write_armap >> 0x1f) << 3 | *(byte *)((long)output_bfd_ptr + 0x49) & 0xfffffff7;\n      *(char *)((long)output_bfd_ptr + 0x49) = (char)modified_flags;\n      if (truncate_flag != '\\0') {\n        *(uint *)((long)output_bfd_ptr + 0x44) = *(uint *)((long)output_bfd_ptr + 0x44) | 0x400;\n      }\n      if (deterministic_flag != 0) {\n        *(uint *)((long)output_bfd_ptr + 0x44) = *(uint *)((long)output_bfd_ptr + 0x44) | 0x2000;\n      }\n      if (full_path_flag != '\\0') goto LAB_00102d37;\n      while( true ) {\n        if ((thin_archive_flag != '\\0') || ((*(byte *)((long)input_params + 0x49) & 0x10) != 0)) {\n          *(byte *)((long)output_bfd_ptr + 0x49) = (byte)modified_flags | 0x10;\n        }\n        cVar1 = bfd_set_archive_head(output_bfd_ptr,uVar4);\n        if (cVar1 != '\\0') break;\n        modified_flags = bfd_fatal(file_path);\nLAB_00102d37:\n        *(uint *)((long)output_bfd_ptr + 0x44) = *(uint *)((long)output_bfd_ptr + 0x44) | 0x100000;\n      }\n      iVar3 = dup(iVar3);\n      cVar1 = bfd_close(output_bfd_ptr);\n      if (cVar1 == '\\0') {\n        bfd_fatal(file_path);\n        format_string = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(&stack0xffffffffffffffd8,format_string);\n        modified_flags = file_mode & 0xf000;\n        if (modified_flags == 0x4000) {\n          file_type = 100;\n        }\n        else if (modified_flags == 0xa000) {\n          file_type = 0x6c;\n        }\n        else if (modified_flags == 0x6000) {\n          file_type = 0x62;\n        }\n        else if (modified_flags == 0x2000) {\n          file_type = 99;\n        }\n        else if (modified_flags == 0xc000) {\n          file_type = 0x73;\n        }\n        else {\n          file_type = 0x70;\n          if (modified_flags != 0x1000) {\n            file_type = 0x2d;\n          }\n        }\n        char1 = (-((_file_mode & 0x100) == 0) & 0xbbU) + 0x72;\n        char2 = (-((_file_mode & 0x80) == 0) & 0xb6U) + 0x77;\n        fprintf(temp_file,\"%s %ld/%ld %6lu %s \",&char1,_file_mode >> 0x20,\n                (ulong)file_size,timestamp,&stack0xffffffffffffffd8,\n                _file_mode & 0xffffffff);\n        fputs(*output_bfd_ptr,temp_file);\n        if ((char)input_params != '\\0') {\n          if ((*(byte *)((long)output_bfd_ptr + 0x49) & 0x10) == 0) {\n            if (output_bfd_ptr[0xb] != (char *)0x0) {\n              fprintf(temp_file,\" 0x%lx\");\n            }\n          }\n          else if (output_bfd_ptr[0xc] != (char *)0x0) {\n            fprintf(temp_file,\" 0x%lx\");\n          }\n        }\n        fputc(10,temp_file);\n        return;\n      }\n      output_bfd = (char **)0x0;\n      output_file_path = (FILE *)0x0;\n      bfd_close(input_params);\n      iVar3 = smart_rename_constprop_0(temp_file,file_path,iVar3);\n      if (iVar3 == 0) {\n        free(file_path);\n        free(temp_file);\n        return;\n      }\n      goto LAB_00102d7a;\n    }\n    close(iVar3);\n    bfd_fatal(file_path);\n  }\n  uVar4 = dcgettext(0,\"could not create temporary file whilst writing archive\",5);\n  bfd_fatal(uVar4);\nLAB_00102d7a:\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "make_tempname",
                "close",
                "bfd_fatal",
                "bfd_fdopenw",
                "dcgettext",
                "bfd_set_format",
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001058b0",
            "calling": [
                "ranlib_only",
                "replace_members.cold",
                "main"
            ],
            "imported": false,
            "current_name": "write_archive_file_001058b0"
        },
        "FUN_00102420": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "open_inarch",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102420"
        },
        "FUN_0010e260": {
            "renaming": {},
            "code": "\n\n\n\nint open(char *__file,int __oflag,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* open@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e260",
            "calling": [
                "open"
            ],
            "imported": false,
            "current_name": "FUN_0010e260"
        },
        "FUN_00102540": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102540",
            "calling": [
                "print_contents",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102540"
        },
        "FUN_00102300": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenr(void)\n\n{\n  bfd_fdopenr();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102300"
        },
        "FUN_001024d0": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024d0",
            "calling": [
                "bfd_nonfatal",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024d0"
        },
        "FUN_0010e0e0": {
            "renaming": {},
            "code": "\n\n\n\nint printf(char *__format,...)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* printf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0e0",
            "calling": [
                "printf"
            ],
            "imported": false,
            "current_name": "FUN_0010e0e0"
        },
        "FUN_001023b0": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "yy_create_buffer.constprop.0",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001023b0"
        },
        "FUN_00105a20": {
            "renaming": {
                "FUN_00105a20": "extract_archive_member_00105a20",
                "param_1": "inputPath",
                "pcVar1": "outputDir",
                "pcVar2": "currentChar",
                "uVar3": "baseName",
                "uVar4": "errorMsg",
                "pFVar5": "filePtr",
                "sVar6": "outputDirLength"
            },
            "code": "\nvoid extractArchiveMember_00105a20(char *inputPath)\n\n{\n  char *outputDir;\n  char *currentChar;\n  undefined8 baseName;\n  undefined8 errorMsg;\n  FILE *filePtr;\n  size_t outputDirLength;\n  \n  outputDir = output_dir;\n  output_filename = inputPath;\n  if (*inputPath == '/') {\nLAB_00102e9a:\n    baseName = lbasename();\n    outputDir = output_filename;\n    errorMsg = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\",5);\n    non_fatal(errorMsg,outputDir,baseName);\n    output_filename = (char *)baseName;\n    FUN_00105a68();\n    return;\n  }\n  do {\n    if (*inputPath == '\\0') {\n      if ((output_dir != (char *)0x0) && (outputDirLength = strlen(output_dir), outputDirLength != 0)) {\n        if (outputDir[outputDirLength - 1] == '/') {\n          output_filename = (char *)concat(outputDir,output_filename,0);\n        }\n        else {\n          output_filename = (char *)concat(outputDir,&DAT_00108260,output_filename,0);\n        }\n      }\n      if (verbose != 0) {\n        printf(\"x - %s\\n\",output_filename);\n      }\n      filePtr = fopen(output_filename,\"w\");\n      if (filePtr == (FILE *)0x0) {\n        perror(output_filename);\n                    \n        xexit(1);\n      }\n      return;\n    }\n    currentChar = inputPath;\n    if ((*inputPath == '.') && (currentChar = inputPath + 1, inputPath[1] == '.')) {\n      currentChar = inputPath + 2;\n      if ((inputPath[2] == '/') || (inputPath[2] == '\\0')) goto LAB_00102e9a;\n    }\n    for (; (*currentChar != '\\0' && (*currentChar != '/')); currentChar = currentChar + 1) {\n    }\n    for (; inputPath = currentChar, *currentChar == '/'; currentChar = currentChar + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a20",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "extract_archive_member_00105a20"
        },
        "FUN_0010e158": {
            "renaming": {},
            "code": "\n\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* fputc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e158",
            "calling": [
                "fputc"
            ],
            "imported": false,
            "current_name": "FUN_0010e158"
        },
        "FUN_00102f55": {
            "renaming": {
                "FUN_00102f55": "close_and_reset_error_00102f55",
                "piVar2": "error_ptr",
                "iVar1": "saved_error",
                "unaff_R12D": "file_descriptor"
            },
            "code": "\nundefined8 close_and_reset_error_00102f55(void)\n\n{\n  int saved_error;\n  int *error_ptr;\n  int file_descriptor;\n  \n  error_ptr = __errno_location();\n  saved_error = *error_ptr;\n  close(file_descriptor);\n  *error_ptr = saved_error;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f55",
            "calling": [
                "simple_copy.constprop.0"
            ],
            "imported": false,
            "current_name": "close_and_reset_error_00102f55"
        },
        "FUN_001057a0": {
            "renaming": {
                "FUN_001057a0": "extract_file_name_001057a0",
                "param_1": "file_path",
                "param_2": "file_descriptor",
                "param_3": "unused_param1",
                "param_4": "unused_param2",
                "iVar1": "temp_file_descriptor",
                "pcVar2": "last_occurrence",
                "lVar3": "file_name_length",
                "lVar4": "index",
                "lVar5": "last_occurrence_index",
                "pcVar6": "new_file_path",
                "bVar7": "flag",
                "auVar8": "result",
                "xmalloc": "allocate_memory",
                "strrchr": "find_last_occurrence_of_character",
                "mkstemp": "create_temporary_file",
                "free": "deallocate_memory"
            },
            "code": "\nundefined  [16] extract_file_name_001057a0(char *file_path,int *file_descriptor,undefined8 unused_param1,undefined8 unused_param2)\n\n{\n  int temp_file_descriptor;\n  char *last_occurrence;\n  long file_name_length;\n  long index;\n  long last_occurrence_index;\n  char *new_file_path;\n  byte flag;\n  undefined result [16];\n  \n  flag = 0;\n  last_occurrence = find_last_occurrence_of_character(file_path,0x2f);\n  if (last_occurrence == (char *)0x0) {\n    last_occurrence = (char *)allocate_memory(9);\n    file_name_length = 0;\n  }\n  else {\n    last_occurrence_index = (long)last_occurrence - (long)file_path;\n    last_occurrence = (char *)allocate_memory(last_occurrence_index + 0xb);\n    file_name_length = last_occurrence_index + 1;\n    new_file_path = last_occurrence;\n    for (index = last_occurrence_index; index != 0; index = index + -1) {\n      *new_file_path = *file_path;\n      file_path = file_path + (ulong)flag * -2 + 1;\n      new_file_path = new_file_path + (ulong)flag * -2 + 1;\n    }\n    last_occurrence[last_occurrence_index] = '/';\n  }\n  *(undefined8 *)(last_occurrence + file_name_length) = 0x5858585858587473;\n  *(undefined *)((long)(last_occurrence + file_name_length) + 8) = 0;\n  temp_file_descriptor = create_temporary_file(last_occurrence);\n  if (temp_file_descriptor == -1) {\n    new_file_path = (char *)0x0;\n    deallocate_memory(last_occurrence);\n  }\n  else {\n    *file_descriptor = temp_file_descriptor;\n    new_file_path = last_occurrence;\n  }\n  result._8_8_ = unused_param2;\n  result._0_8_ = new_file_path;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "strrchr",
                "mkstemp",
                "make_tempname.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001057a0",
            "calling": [
                "ar_open",
                "write_archive"
            ],
            "imported": false,
            "current_name": "extract_file_name_001057a0"
        },
        "FUN_00102550": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102550",
            "calling": [
                "ar_open",
                "print_contents",
                "set_times.cold",
                "get_file_size.cold",
                "smart_rename.constprop.0.cold",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102550"
        },
        "FUN_00102310": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "report",
                "open_inarch",
                "bfd_nonfatal.cold",
                "list_supported_targets",
                "ar_emul_default_usage",
                "main",
                "yyparse.isra.0",
                "map_over_list",
                "ar_open",
                "list_matching_formats",
                "map_over_members.cold",
                "print_arelt_descr.cold",
                "yy_fatal_error",
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "FUN_00102310"
        },
        "FUN_00102430": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102430"
        },
        "FUN_0010e0f8": {
            "renaming": {},
            "code": "\n\n\n\nint dup(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* dup@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0f8",
            "calling": [
                "dup"
            ],
            "imported": false,
            "current_name": "FUN_0010e0f8"
        },
        "FUN_00107c10": {
            "renaming": {
                "FUN_00107c10": "exit_with_error_00107c10",
                "bfd_nonfatal": "handleNonFatal",
                "xexit": "exitCode"
            },
            "code": "\nvoid exitWithError_00107c10(void)\n\n{\n  handleNonFatal();\n                    \n  exitCode(1);\n}\n\n",
            "called": [
                "xexit",
                "bfd_nonfatal"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c10",
            "calling": [
                "open_inarch",
                "write_archive",
                "replace_members.cold",
                "write_archive.cold",
                "main"
            ],
            "imported": false,
            "current_name": "exit_with_error_00107c10"
        },
        "FUN_001023c0": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "report",
                "list_matching_formats",
                "prompt",
                "bfd_nonfatal.cold"
            ],
            "imported": false,
            "current_name": "FUN_001023c0"
        },
        "FUN_0010e0f0": {
            "renaming": {},
            "code": "\n\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strrchr@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e0f0",
            "calling": [
                "strrchr"
            ],
            "imported": false,
            "current_name": "FUN_0010e0f0"
        },
        "FUN_001024e0": {
            "renaming": {},
            "code": "\nvoid bfd_find_target(void)\n\n{\n  bfd_find_target();\n  return;\n}\n\n",
            "called": [
                "bfd_find_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024e0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001024e0"
        },
        "FUN_001022a0": {
            "renaming": {},
            "code": "\nvoid bfd_create(void)\n\n{\n  bfd_create();\n  return;\n}\n\n",
            "called": [
                "bfd_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022a0"
        },
        "FUN_00107cc0": {
            "renaming": {
                "FUN_00107cc0": "execute_at_exit_functions_00107cc0",
                "plVar4": "currentFunction",
                "lVar1": "index",
                "lVar2": "prevIndex",
                "lVar3": "tempIndex",
                "uVar5": "flag",
                "xatexit_head": "head"
            },
            "code": "\nvoid executeAtExitFunctions_00107cc0(void)\n\n{\n  long index;\n  long prevIndex;\n  long tempIndex;\n  long *currentFunction;\n  uint flag;\n  \n  currentFunction = (long *)head;\n  if (head != (undefined *)0x0) {\n    do {\n      flag = *(int *)(currentFunction + 1) - 1;\n      if (-1 < (int)flag) {\n        index = (long)(int)flag;\n        flag = flag & 7;\n        (*(code *)currentFunction[index + 2])();\n        prevIndex = index + -1;\n        if (-1 < (int)prevIndex) {\n          tempIndex = prevIndex;\n          if (flag != 0) {\n            if (flag != 1) {\n              if (flag != 2) {\n                if (flag != 3) {\n                  if (flag != 4) {\n                    if (flag != 5) {\n                      if (flag != 6) {\n                        (*(code *)currentFunction[index + 1])();\n                        prevIndex = index + -2;\n                      }\n                      (*(code *)currentFunction[prevIndex + 2])();\n                      prevIndex = prevIndex + -1;\n                    }\n                    (*(code *)currentFunction[prevIndex + 2])();\n                    prevIndex = prevIndex + -1;\n                  }\n                  (*(code *)currentFunction[prevIndex + 2])();\n                  prevIndex = prevIndex + -1;\n                }\n                (*(code *)currentFunction[prevIndex + 2])();\n                prevIndex = prevIndex + -1;\n              }\n              (*(code *)currentFunction[prevIndex + 2])();\n              prevIndex = prevIndex + -1;\n            }\n            (*(code *)currentFunction[prevIndex + 2])();\n            tempIndex = prevIndex + -1;\n            if ((int)(prevIndex + -1) < 0) goto LAB_00107d96;\n          }\n          do {\n            (*(code *)currentFunction[tempIndex + 2])();\n            index = tempIndex + -1;\n            (*(code *)currentFunction[tempIndex + 1])();\n            (*(code *)currentFunction[tempIndex])();\n            (*(code *)currentFunction[index])();\n            (*(code *)currentFunction[tempIndex + -2])();\n            (*(code *)currentFunction[tempIndex + -3])();\n            (*(code *)currentFunction[tempIndex + -4])();\n            (*(code *)currentFunction[tempIndex + -5])();\n            tempIndex = tempIndex + -8;\n          } while (-1 < (int)index + -7);\n        }\n      }\nLAB_00107d96:\n      currentFunction = (long *)*currentFunction;\n    } while (currentFunction != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107cc0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "execute_at_exit_functions_00107cc0"
        },
        "FUN_0010e288": {
            "renaming": {},
            "code": "\n\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* vfprintf@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e288",
            "calling": [
                "vfprintf"
            ],
            "imported": false,
            "current_name": "FUN_0010e288"
        },
        "FUN_00105ae0": {
            "renaming": {
                "FUN_00105ae0": "append_constant_property_00105ae0",
                "param_1": "dest",
                "param_2": "source",
                "param_3": "undefined1",
                "param_4": "undefined2"
            },
            "code": "\nvoid appendConstantProperty_00105ae0(undefined8 dest,undefined8 source,undefined undefined1,undefined undefined2)\n\n{\n  do_ar_emul_append_constprop_0(dest,source,undefined1,undefined2);\n  return;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105ae0",
            "calling": [
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "append_constant_property_00105ae0"
        },
        "FUN_00107690": {
            "renaming": {
                "FUN_00107690": "report_and_exit_00107690",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "param_5": "input5",
                "param_6": "input6",
                "param_7": "input7",
                "param_8": "input8",
                "param_9": "data1",
                "param_10": "data2",
                "param_11": "data3",
                "param_12": "data4",
                "param_13": "data5",
                "param_14": "data6",
                "local_d8": "length",
                "local_d4": "offset",
                "local_d0": "buffer",
                "local_c8": "localBuffer",
                "local_b8": "bufferArray",
                "local_b0": "param2",
                "local_a8": "param3",
                "local_a0": "param4",
                "local_98": "param5",
                "local_90": "param6",
                "local_88": "input1Copy",
                "local_78": "input2Copy",
                "local_68": "input3Copy",
                "local_58": "input4Copy",
                "local_48": "input5Copy",
                "local_38": "input6Copy",
                "local_28": "input7Copy",
                "local_18": "input8Copy",
                "in_AL": "flag"
            },
            "code": "\nvoid reportAndExit_00107690(undefined4 input1,undefined4 input2,undefined4 input3,undefined4 input4,\n                 undefined4 input5,undefined4 input6,undefined4 input7,undefined4 input8,\n                 undefined8 data1,undefined8 data2,undefined8 data3,undefined8 data4,\n                 undefined8 data5,undefined8 data6)\n\n{\n  char flag;\n  undefined4 length;\n  undefined4 offset;\n  undefined *buffer;\n  undefined *localBuffer;\n  undefined bufferArray [8];\n  undefined8 param2;\n  undefined8 param3;\n  undefined8 param4;\n  undefined8 param5;\n  undefined8 param6;\n  undefined4 input1Copy;\n  undefined4 input2Copy;\n  undefined4 input3Copy;\n  undefined4 input4Copy;\n  undefined4 input5Copy;\n  undefined4 input6Copy;\n  undefined4 input7Copy;\n  undefined4 input8Copy;\n  \n  if (flag != '\\0') {\n    input1Copy = input1;\n    input2Copy = input2;\n    input3Copy = input3;\n    input4Copy = input4;\n    input5Copy = input5;\n    input6Copy = input6;\n    input7Copy = input7;\n    input8Copy = input8;\n  }\n  buffer = &stack0x00000008;\n  length = 8;\n  localBuffer = bufferArray;\n  offset = 0x30;\n  param2 = data2;\n  param3 = data3;\n  param4 = data4;\n  param5 = data5;\n  param6 = data6;\n  report(data1,&length);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "report"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107690",
            "calling": [
                "open_inarch",
                "print_contents",
                "replace_members.cold",
                "extract_file.cold",
                "main"
            ],
            "imported": false,
            "current_name": "report_and_exit_00107690"
        },
        "FUN_0010266f": {
            "renaming": {
                "FUN_0010266f": "print_supported_targets_0010266f",
                "param_1": "target",
                "param_2": "outputFile",
                "lVar1": "currentTarget",
                "pcVar2": "targetString",
                "__ptr": "targetList",
                "plVar3": "targetListPtr"
            },
            "code": "\nvoid printSupportedTargets_0010266f(long target,FILE *outputFile)\n\n{\n  long currentTarget;\n  char *targetString;\n  long *targetList;\n  long *targetListPtr;\n  \n  if (target == 0) {\n    targetString = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,targetString);\n  }\n  else {\n    targetString = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,targetString,target);\n  }\n  targetList = (long *)bfd_target_list();\n  targetListPtr = targetList;\n  while( true ) {\n    currentTarget = *targetListPtr;\n    targetListPtr = targetListPtr + 1;\n    if (currentTarget == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fputc",
                "free",
                "dcgettext",
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010266f",
            "calling": [
                "ranlib_usage",
                "usage"
            ],
            "imported": false,
            "current_name": "print_supported_targets_0010266f"
        },
        "FUN_00102440": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102440"
        },
        "FUN_0010e280": {
            "renaming": {},
            "code": "\n\n\n\nvoid perror(char *__s)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* perror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e280",
            "calling": [
                "perror"
            ],
            "imported": false,
            "current_name": "FUN_0010e280"
        },
        "FUN_00102560": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102560",
            "calling": [
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102560"
        },
        "FUN_00105830": {
            "renaming": {
                "FUN_00105830": "extract_basename_00105830",
                "param_1": "input_path",
                "param_2": "file_info",
                "param_3": "unused_param_1",
                "param_4": "unused_param_2",
                "__s": "base_name",
                "uVar3": "basename_length",
                "pcVar4": "dest_ptr",
                "bVar5": "loop_var",
                "auVar6": "result_struct",
                "full_pathname": "is_full_path"
            },
            "code": "\nundefined  [16] extract_basename_00105830(char *input_path,long file_info,undefined8 unused_param_1,undefined8 unused_param_2)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *base_name;\n  ulong basename_length;\n  char *dest_ptr;\n  byte loop_var;\n  undefined result_struct [16];\n  \n  loop_var = 0;\n  if (is_full_path == '\\0') {\n    base_name = (char *)lbasename();\n    input_path = base_name;\n    if ((ar_truncate != '\\0') && (file_info != 0)) {\n      sVar2 = strlen(base_name);\n      basename_length = (ulong)*(byte *)(*(long *)(file_info + 8) + 0x1e);\n      if (basename_length < sVar2) {\n        input_path = (char *)xmalloc(basename_length + 1);\n        lVar1 = *(long *)(file_info + 8);\n        dest_ptr = input_path;\n        for (basename_length = (ulong)*(byte *)(lVar1 + 0x1e); basename_length != 0; basename_length = basename_length - 1) {\n          *dest_ptr = *base_name;\n          base_name = base_name + (ulong)loop_var * -2 + 1;\n          dest_ptr = dest_ptr + (ulong)loop_var * -2 + 1;\n        }\n        input_path[*(byte *)(lVar1 + 0x1e)] = '\\0';\n      }\n    }\n  }\n  result_struct._8_8_ = unused_param_2;\n  result_struct._0_8_ = input_path;\n  return result_struct;\n}\n\n",
            "called": [
                "normalize.cold",
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105830",
            "calling": [
                "replace_members.cold",
                "map_over_members",
                "main"
            ],
            "imported": false,
            "current_name": "extract_basename_00105830"
        },
        "FUN_0010e160": {
            "renaming": {},
            "code": "\n\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* read@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e160",
            "calling": [
                "read"
            ],
            "imported": false,
            "current_name": "FUN_0010e160"
        },
        "FUN_00102200": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_00105a68",
                "open_output_file.isra.0.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102200"
        },
        "FUN_00102320": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102320"
        },
        "FUN_00107c20": {
            "renaming": {
                "FUN_00107c20": "print_error_message_00107c20",
                "param_1": "errorMessage",
                "iVar1": "error",
                "uVar2": "message",
                "in_R10": "extraInfo"
            },
            "code": "\n\n\nvoid printErrorMessage_00107c20(long errorMessage)\n\n{\n  int error;\n  undefined8 message;\n  undefined8 extraInfo;\n  \n  error = bfd_get_error();\n  if (error == 0) {\n    message = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    message = bfd_errmsg(error);\n  }\n  fflush(_stdout);\n  if (errorMessage != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",program_name,errorMessage,message,extraInfo);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",program_name,message,extraInfo);\n  return;\n}\n\n",
            "called": [
                "bfd_nonfatal.cold",
                "bfd_get_error",
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c20",
            "calling": [
                "open_inarch",
                "bfd_fatal",
                "main"
            ],
            "imported": false,
            "current_name": "print_error_message_00107c20"
        },
        "FUN_001022b0": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_001022b0"
        },
        "FUN_001023d0": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "remove_output.cold"
            ],
            "imported": false,
            "current_name": "FUN_001023d0"
        },
        "FUN_001024f0": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024f0",
            "calling": [
                "print_arelt_descr.cold",
                "print_arelt_descr"
            ],
            "imported": false,
            "current_name": "FUN_001024f0"
        },
        "FUN_00102e57": {
            "renaming": {
                "FUN_00102e57": "create_output_file_00102e57",
                "pFVar1": "file_ptr",
                "output_filename": "concatenated_filename"
            },
            "code": "\nvoid create_output_file_00102e57(void)\n\n{\n  FILE *file_ptr;\n  \n  concatenated_filename = (char *)concat();\n  if (verbose != 0) {\n    printf(\"x - %s\\n\",concatenated_filename);\n  }\n  file_ptr = fopen(concatenated_filename,\"w\");\n  if (file_ptr != (FILE *)0x0) {\n    return;\n  }\n  perror(concatenated_filename);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e57",
            "calling": [
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "create_output_file_00102e57"
        },
        "FUN_0010e058": {
            "renaming": {},
            "code": "\n\n\n\nint ferror(FILE *__stream)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* ferror@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e058",
            "calling": [
                "ferror"
            ],
            "imported": false,
            "current_name": "FUN_0010e058"
        },
        "FUN_00105af0": {
            "renaming": {
                "FUN_00105af0": "process_archives_00105af0",
                "param_1": "archive_list",
                "param_2": "current_file",
                "param_3": "should_emulate",
                "param_4": "should_check_format",
                "cVar1": "format_check_result",
                "uVar2": "emulation_result",
                "lVar3": "next_file",
                "uVar4": "result"
            },
            "code": "\nulong process_archives_00105af0(long *archive_list,long current_file,char should_emulate,char should_check_format)\n\n{\n  char format_check_result;\n  uint emulation_result;\n  long next_file;\n  ulong result;\n  \n  if (should_check_format == '\\0') {\n    if (should_emulate != '\\0') {\n      result = do_ar_emul_append_constprop_0_cold();\n      return result;\n    }\n  }\n  else {\n    format_check_result = bfd_check_format(current_file,2);\n    if (format_check_result != '\\0') {\n      result = 0;\n      for (next_file = bfd_openr_next_archived_file(current_file,0); next_file != 0;\n          next_file = bfd_openr_next_archived_file(current_file,next_file)) {\n        emulation_result = process_archives_00105af0(archive_list,next_file,should_emulate,1);\n        if ((char)emulation_result != '\\0') {\n          result = (ulong)emulation_result;\n          archive_list = (long *)(*archive_list + 0xf0);\n        }\n      }\n      return result;\n    }\n    if (should_emulate != '\\0') {\n      result = do_ar_emul_append_constprop_0_cold();\n      return result;\n    }\n  }\n  *(long *)(current_file + 0xf0) = *archive_list;\n  *archive_list = current_file;\n  return 1;\n}\n\n",
            "called": [
                "do_ar_emul_append.constprop.0.cold",
                "bfd_openr_next_archived_file",
                "do_ar_emul_append.constprop.0",
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105af0",
            "calling": [
                "ar_emul_default_append",
                "do_ar_emul_append.constprop.0",
                "replace_members.cold"
            ],
            "imported": false,
            "current_name": "process_archives_00105af0"
        },
        "FUN_00102330": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "open_inarch",
                "replace_members.cold",
                "get_file_size",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102330"
        },
        "FUN_00102450": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102450"
        },
        "FUN_00102ba1": {
            "renaming": {
                "FUN_00102ba1": "free_and_return_00102ba1",
                "unaff_RBP": "ptr_memory",
                "unaff_retaddr": "return_address",
                "auVar1": "result"
            },
            "code": "\nundefined  [16] free_and_return_00102ba1(void)\n\n{\n  undefined result [16];\n  void *ptr_memory;\n  ulong return_address;\n  \n  free(ptr_memory);\n  result._8_8_ = 0;\n  result._0_8_ = return_address;\n  return result << 0x40;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102ba1",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "free_and_return_00102ba1"
        },
        "FUN_00102210": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "list_supported_targets"
            ],
            "imported": false,
            "current_name": "FUN_00102210"
        },
        "FUN_00102570": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102570",
            "calling": [
                "ar_open",
                "write_archive"
            ],
            "imported": false,
            "current_name": "FUN_00102570"
        },
        "FUN_00102d2f": {
            "renaming": {
                "FUN_00102d2f": "print_file_stats_00102d2f",
                "unaff_RBX": "fileData",
                "unaff_RBP": "outputFile",
                "unaff_R12": "flags",
                "unaff_R13": "data",
                "unaff_R14D": "tmp",
                "uStack0000000000000015": "fileType",
                "cStack0000000000000016": "hasExecutePermission",
                "cStack0000000000000017": "hasWritePermission",
                "in_stack_00000018": "hasReadPermission",
                "cStack0000000000000019": "isArchive",
                "cStack000000000000001a": "isDirectory",
                "cStack000000000000001b": "isSetUID",
                "cStack000000000000001c": "isSetGID",
                "cStack000000000000001d": "isSticky",
                "cStack000000000000001e": "isOtherWritable",
                "uStack000000000000001f": "unused",
                "uStack0000000000000068": "fileMode",
                "uStack000000000000006c": "nlinks",
                "in_stack_00000070": "uid",
                "in_stack_00000080": "size",
                "output_bfd": "outputBfd",
                "output_filename": "outputFilename",
                "smart_rename_constprop_0": "renameFile",
                "xexit": "exitProgram",
                "free": "freeMemory",
                "sprintf": "formatString",
                "fprintf": "printFormatted",
                "fputs": "printString",
                "fputc": "printCharacter",
                "char": "character",
                "int": "integer",
                "FILE": "file"
            },
            "code": "\nvoid printFileStats_00102d2f(void)\n\n{\n  byte bVar1;\n  character cVar2;\n  integer iVar3;\n  character *__format;\n  uinteger uVar4;\n  character **fileData;\n  file *outputFile;\n  long flags;\n  void *data;\n  integer tmp;\n  undefined fileType;\n  character hasExecutePermission;\n  character hasWritePermission;\n  character hasReadPermission;\n  character isArchive;\n  character isDirectory;\n  character isSetUID;\n  character isSetGID;\n  character isSticky;\n  character isOtherWritable;\n  undefined unused;\n  uinteger fileMode;\n  uinteger nlinks;\n  uinteger uid;\n  undefined8 size;\n  \n  do {\n    bVar1 = bfd_fatal();\n    *(uinteger *)((long)fileData + 0x44) = *(uinteger *)((long)fileData + 0x44) | 0x100000;\n    if ((make_thin_archive != '\\0') || ((*(byte *)(flags + 0x49) & 0x10) != 0)) {\n      *(byte *)((long)fileData + 0x49) = bVar1 | 0x10;\n    }\n    cVar2 = bfd_set_archive_head();\n  } while (cVar2 == '\\0');\n  dup(tmp);\n  cVar2 = bfd_close();\n  if (cVar2 != '\\0') {\n    outputBfd = 0;\n    outputFilename = 0;\n    bfd_close();\n    iVar3 = renameFile();\n    if (iVar3 == 0) {\n      freeMemory(data);\n      freeMemory(outputFile);\n      return;\n    }\n                    \n    exitProgram(1);\n  }\n  bfd_fatal();\n  __format = (character *)dcgettext(0,\"<time data corrupt>\",5);\n  formatString(&stack0x00000020,__format);\n  uVar4 = fileMode & 0xf000;\n  if (uVar4 == 0x4000) {\n    fileType = 100;\n  }\n  else if (uVar4 == 0xa000) {\n    fileType = 0x6c;\n  }\n  else if (uVar4 == 0x6000) {\n    fileType = 0x62;\n  }\n  else if (uVar4 == 0x2000) {\n    fileType = 99;\n  }\n  else if (uVar4 == 0xc000) {\n    fileType = 0x73;\n  }\n  else {\n    fileType = 0x70;\n    if (uVar4 != 0x1000) {\n      fileType = 0x2d;\n    }\n  }\n  hasExecutePermission = (-((fileMode & 0x100) == 0) & 0xbbU) + 0x72;\n  hasWritePermission = (-((fileMode & 0x80) == 0) & 0xb6U) + 0x77;\n  hasReadPermission = (-((fileMode & 0x40) == 0) & 0xb5U) + 0x78;\n  isArchive = (-((fileMode & 0x20) == 0) & 0xbbU) + 0x72;\n  isDirectory = (-((fileMode & 0x10) == 0) & 0xb6U) + 0x77;\n  isSetUID = (-((fileMode & 8) == 0) & 0xb5U) + 0x78;\n  isSetGID = (-((fileMode & 4) == 0) & 0xbbU) + 0x72;\n  isSticky = (-((fileMode & 2) == 0) & 0xb6U) + 0x77;\n  isOtherWritable = (-((fileMode & 1) == 0) & 0xb5U) + 0x78;\n  if ((fileMode & 0x800) != 0) {\n    if (hasReadPermission == 'x') {\n      hasReadPermission = 's';\n    }\n    else {\n      hasReadPermission = 'S';\n    }\n  }\n  if ((fileMode & 0x400) != 0) {\n    if (isSetUID == 'x') {\n      isSetUID = 's';\n    }\n    else {\n      isSetUID = 'S';\n    }\n  }\n  if ((fileMode & 0x200) != 0) {\n    if (isOtherWritable == 'x') {\n      isOtherWritable = 't';\n    }\n    else {\n      isOtherWritable = 'T';\n    }\n  }\n  unused = 0;\n  printFormatted(outputFile,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)nlinks,\n          (ulong)uid,size,&stack0x00000020,(ulong)fileMode)\n  ;\n  printString(*fileData,outputFile);\n  if ((character)flags != '\\0') {\n    if ((*(byte *)((long)fileData + 0x49) & 0x10) == 0) {\n      if (fileData[0xb] != (character *)0x0) {\n        printFormatted(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (fileData[0xc] != (character *)0x0) {\n      printFormatted(outputFile,\" 0x%lx\");\n    }\n  }\n  printCharacter(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "xexit",
                "bfd_fatal",
                "dup",
                "smart_rename.constprop.0",
                "bfd_close",
                "bfd_set_archive_head",
                "free",
                "write_archive.cold"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d2f",
            "calling": [
                "write_archive.cold"
            ],
            "imported": false,
            "current_name": "print_file_stats_00102d2f"
        },
        "FUN_001021a0": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "do_ar_emul_append.constprop.0.cold",
                "ar_emul_default_replace",
                "print_contents",
                "prompt",
                "FUN_00105a68",
                "yyerror.constprop.0",
                "print_version",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_001021a0"
        },
        "FUN_001033b0": {
            "renaming": {
                "FUN_001033b0": "print_and_exit_001033b0",
                "param_1": "message",
                "_stderr": "errorStream"
            },
            "code": "\n\n\nvoid printAndExit_001033b0(undefined8 message)\n\n{\n  fprintf(errorStream,\"%s\\n\",message);\n                    \n  exit(2);\n}\n\n",
            "called": [
                "exit",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033b0",
            "calling": [
                "yy_create_buffer.constprop.0",
                "yyensure_buffer_stack",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "print_and_exit_001033b0"
        },
        "FUN_001022c0": {
            "renaming": {},
            "code": "\nvoid lbasename(void)\n\n{\n  lbasename();\n  return;\n}\n\n",
            "called": [
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "replace_members.cold",
                "normalize",
                "main",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "FUN_001022c0"
        },
        "FUN_001023e0": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "make_tempname"
            ],
            "imported": false,
            "current_name": "FUN_001023e0"
        },
        "FUN_00102c25": {
            "renaming": {
                "FUN_00102c25": "extract_and_save_file_00102c25",
                "puVar9": "paramArray",
                "iVar1": "filenameComparisonResult",
                "iVar2": "statReturnValue",
                "param_7": "paramArray",
                "__ptr": "buffer",
                "__n": "bytesRead",
                "lVar7": "loopCounter",
                "unaff_RBX": "fileInfoArray",
                "plVar8": "fileInfoPointer",
                "uVar5": "errorMessage",
                "pplVar6": "pointerArray",
                "output_file": "outputFile",
                "param_12": "fileSize",
                "uVar10": "bytesReadTotal",
                "sVar11": "bytesToRead"
            },
            "code": "\nlong * extract_and_save_file_00102c25(void)\n\n{\n  int filenameComparisonResult;\n  int statReturnValue;\n  int *piVar3;\n  char *pcVar4;\n  undefined8 errorMessage;\n  long **pointerArray;\n  void *buffer;\n  size_t bytesRead;\n  long loopCounter;\n  long **fileInfoArray;\n  long *fileInfoPointer;\n  undefined4 *paramArray;\n  ulong bytesReadTotal;\n  size_t bytesToRead;\n  undefined4 *paramArray;\n  __mode_t param_11;\n  ulong fileSize;\n  \n  paramArray = paramArray;\n  for (loopCounter = 0x24; loopCounter != 0; loopCounter = loopCounter + -1) {\n    *paramArray = 0;\n    paramArray = paramArray + 1;\n  }\n  pointerArray = (long **)fileInfoArray[0x1d];\n  if ((long **)fileInfoArray[0x1d] == (long **)0x0) {\n    pointerArray = fileInfoArray;\n  }\n  statReturnValue = (*(code *)pointerArray[1][0x3d])();\n  if (statReturnValue != 0) {\n    fileInfoPointer = *fileInfoArray;\n    errorMessage = dcgettext(0,\"internal stat error on %s\",5);\n    statReturnValue = fatal(errorMessage,fileInfoPointer);\n    errorMessage = posname;\n    if (statReturnValue == 3) {\n      for (; *fileInfoPointer != 0; fileInfoPointer = (long *)(*fileInfoPointer + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*fileInfoPointer != (undefined8 *)0x0; fileInfoPointer = (long *)(*fileInfoPointer + 0xf0)) {\n        filenameComparisonResult = filename_cmp(*(undefined8 *)*fileInfoPointer,errorMessage);\n        if (filenameComparisonResult == 0) {\n          if (statReturnValue != 2) {\n            return fileInfoPointer;\n          }\n          return (long *)(*fileInfoPointer + 0xf0);\n        }\n      }\n    }\n    return fileInfoPointer;\n  }\n  bfd_seek();\n  outputFile = (FILE *)0x0;\n  if (fileSize == 0) {\nLAB_00102ca2:\n    outputFile = (FILE *)open_outputFile_isra_0(*fileInfoArray);\n  }\n  else {\n    bytesReadTotal = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      bytesToRead = fileSize - bytesReadTotal;\n      if (0x2000 < bytesToRead) {\n        bytesToRead = 0x2000;\n      }\n      bytesRead = bfd_bread(buffer,bytesToRead);\n      if (bytesToRead != bytesRead) {\nLAB_00102c78:\n        fileInfoArray = (long **)*fileInfoArray[0x1d];\n        errorMessage = dcgettext(0,\"%s is not a valid archive\",5);\n        fatal(errorMessage,fileInfoArray);\n        goto LAB_00102ca2;\n      }\n      if (outputFile == (FILE *)0x0) {\n        outputFile = (FILE *)open_outputFile_isra_0(*fileInfoArray);\n      }\n      bytesToRead = fwrite(buffer,1,bytesRead,outputFile);\n      if (bytesToRead != bytesRead) {\n        piVar3 = __errno_location();\n        pcVar4 = strerror(*piVar3);\n        fatal(\"%s: %s\",outputFilename,pcVar4);\n        goto LAB_00102c78;\n      }\n      bytesReadTotal = bytesReadTotal + bytesRead;\n    } while (bytesReadTotal < fileSize);\n    free(buffer);\n  }\n  fclose(outputFile);\n  pcVar4 = outputFilename;\n  outputFile = (FILE *)0x0;\n  chmod(outputFilename,param_11);\n  if (preserve_dates != 0) {\n    set_times(pcVar4,paramArray);\n  }\n  outputFilename = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "open_output_file.isra.0",
                "strerror",
                "fclose",
                "set_times",
                "dcgettext",
                "bfd_bread",
                "chmod",
                "fwrite",
                "fatal",
                "xmalloc",
                "bfd_seek",
                "__errno_location",
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c25",
            "calling": [
                "extract_file"
            ],
            "imported": false,
            "current_name": "extract_and_save_file_00102c25"
        },
        "FUN_0010e188": {
            "renaming": {},
            "code": "\n\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* strcmp@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e188",
            "calling": [
                "strcmp"
            ],
            "imported": false,
            "current_name": "FUN_0010e188"
        },
        "FUN_00102220": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "open_inarch",
                "bfd_nonfatal",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102220"
        },
        "FUN_00102bb0": {
            "renaming": {
                "FUN_00102bb0": "reverse_string_00102bb0",
                "in_RAX": "inputString",
                "sVar2": "stringLength",
                "puVar3": "reversedString",
                "uVar4": "maxLength",
                "unaff_RBX": "currentChar",
                "unaff_RBP": "basePointer",
                "puVar5": "reversedPointer",
                "bVar6": "reverseFlag",
                "auVar7": "result"
            },
            "code": "\nundefined  [16] reverseString_00102bb0(void)\n\n{\n  long lVar1;\n  char *inputString;\n  size_t stringLength;\n  undefined *reversedString;\n  ulong maxLength;\n  undefined *currentChar;\n  long basePointer;\n  undefined *reversedPointer;\n  byte reverseFlag;\n  undefined result [16];\n  undefined8 unaff_retaddr;\n  \n  reverseFlag = 0;\n  stringLength = strlen(inputString);\n  maxLength = (ulong)*(byte *)(*(long *)(basePointer + 8) + 0x1e);\n  reversedString = currentChar;\n  if (maxLength < stringLength) {\n    reversedString = (undefined *)xmalloc(maxLength + 1);\n    lVar1 = *(long *)(basePointer + 8);\n    reversedPointer = reversedString;\n    for (maxLength = (ulong)*(byte *)(lVar1 + 0x1e); maxLength != 0; maxLength = maxLength - 1) {\n      *reversedPointer = *currentChar;\n      currentChar = currentChar + (ulong)reverseFlag * -2 + 1;\n      reversedPointer = reversedPointer + (ulong)reverseFlag * -2 + 1;\n    }\n    reversedString[*(byte *)(lVar1 + 0x1e)] = 0;\n  }\n  result._8_8_ = unaff_retaddr;\n  result._0_8_ = reversedString;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bb0",
            "calling": [
                "normalize"
            ],
            "imported": false,
            "current_name": "reverse_string_00102bb0"
        },
        "FUN_0010e060": {
            "renaming": {},
            "code": "\n\n\n\nint isatty(int __fd)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* isatty@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e060",
            "calling": [
                "isatty"
            ],
            "imported": false,
            "current_name": "FUN_0010e060"
        },
        "FUN_00102340": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "open_inarch",
                "ar_open",
                "write_archive",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102340"
        },
        "FUN_00102100": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "map_over_list",
                "replace_members.cold",
                "map_over_members",
                "get_pos_bfd.cold",
                "main",
                "yyparse.isra.0"
            ],
            "imported": false,
            "current_name": "FUN_00102100"
        },
        "FUN_00102460": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102460",
            "calling": [
                "simple_copy.constprop.0",
                "main"
            ],
            "imported": false,
            "current_name": "FUN_00102460"
        },
        "FUN_00102580": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102580",
            "calling": [
                "print_contents",
                "extract_file.cold"
            ],
            "imported": false,
            "current_name": "FUN_00102580"
        },
        "FUN_0010e180": {
            "renaming": {},
            "code": "\n\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n                    /* WARNING: Bad instruction - Truncating control flow here */\n                    /* calloc@GLIBC_2.2.5 */\n  halt_baddata();\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010e180",
            "calling": [
                "calloc"
            ],
            "imported": false,
            "current_name": "FUN_0010e180"
        }
    },
    "used_tokens": 67514,
    "layers": [
        [
            "FUN_00102cd9",
            "FUN_001079c0",
            "FUN_00105a68",
            "FUN_001032a8",
            "FUN_00102f96",
            "FUN_0010342d",
            "FUN_00107920",
            "FUN_001033d6",
            "FUN_00102000",
            "FUN_00105870",
            "FUN_00103ba8",
            "FUN_00103ddc",
            "FUN_001078c0",
            "FUN_001031a5",
            "FUN_00103df9",
            "FUN_00102bf5",
            "FUN_00102020",
            "FUN_00102943",
            "FUN_00107c80",
            "FUN_00102d8c",
            "FUN_00105300",
            "FUN_00105db0",
            "FUN_00103bd1",
            "FUN_00102710",
            "FUN_00103e95",
            "FUN_00107730",
            "FUN_001031cf",
            "FUN_0010312d",
            "FUN_00105c00",
            "FUN_001052a0",
            "FUN_0010336b",
            "FUN_00103c60",
            "FUN_0010300e",
            "FUN_00107740",
            "FUN_001028ed",
            "FUN_001025a0",
            "FUN_0010284b",
            "FUN_00105cc0",
            "FUN_00102f08",
            "FUN_0010285f",
            "FUN_0010394a",
            "FUN_00105bb0",
            "FUN_00107640",
            "FUN_0010315d",
            "FUN_00107890",
            "FUN_00103172",
            "FUN_001030ed",
            "FUN_00105bc0",
            "FUN_00107650",
            "FUN_00102f1e",
            "FUN_00102fd7",
            "FUN_00105d60",
            "FUN_001075e0",
            "FUN_00105480",
            "FUN_00103a78",
            "FUN_001058b0",
            "FUN_00105a20",
            "FUN_00102f55",
            "FUN_001057a0",
            "FUN_00107c10",
            "FUN_00107cc0",
            "FUN_00105ae0",
            "FUN_00107690",
            "FUN_0010266f",
            "FUN_00105830",
            "FUN_00107c20",
            "FUN_00102e57",
            "FUN_00102ba1",
            "FUN_00102d2f",
            "FUN_001033b0",
            "FUN_00102c25",
            "FUN_00102bb0"
        ],
        [
            "FUN_00102e6f",
            "FUN_00105570"
        ],
        [
            "FUN_00105af0"
        ]
    ],
    "locked_functions": []
}