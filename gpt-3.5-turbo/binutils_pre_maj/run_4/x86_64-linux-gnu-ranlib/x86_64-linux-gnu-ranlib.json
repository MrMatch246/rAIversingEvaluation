{
    "functions": {
        "bfd_fdopenr": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenr(void)\n\n{\n  bfd_fdopenr();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102300",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_fdopenr"
        },
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022f0",
            "calling": [
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "FUN_00102cd9": {
            "renaming": {
                "FUN_00102cd9": "find_matching_address_00102cd9",
                "in_EAX": "eaxValue",
                "iVar1": "comparisonResult",
                "unaff_RBX": "currentAddress",
                "param_7": "comparisonString"
            },
            "code": "\nlong * findMatchingAddress_00102cd9(void)\n\n{\n  int eaxValue;\n  int comparisonResult;\n  long *currentAddress;\n  undefined8 comparisonString;\n  \n  comparisonString = DAT_0010d638;\n  if (eaxValue == 3) {\n    for (; *currentAddress != 0; currentAddress = (long *)(*currentAddress + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*currentAddress != (undefined8 *)0x0; currentAddress = (long *)(*currentAddress + 0xf0)) {\n      comparisonResult = filename_cmp(*(undefined8 *)*currentAddress,comparisonString);\n      if (comparisonResult == 0) {\n        if (eaxValue != 2) {\n          return currentAddress;\n        }\n        return (long *)(*currentAddress + 0xf0);\n      }\n    }\n  }\n  return currentAddress;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102cd9",
            "calling": [
                "FUN_00105870"
            ],
            "imported": false,
            "current_name": "find_matching_address_00102cd9"
        },
        "bfd_close": {
            "renaming": {},
            "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
            "called": [
                "bfd_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102490",
            "calling": [
                "FUN_00105300",
                "FUN_00102710",
                "FUN_00103e95",
                "FUN_00105db0",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "bfd_close"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_0010d400 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_0010d2c8);\n  FUNC_00105cf0();\n  DAT_0010d400 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00105cf0",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105d60",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "lbasename": {
            "renaming": {},
            "code": "\nvoid lbasename(void)\n\n{\n  lbasename();\n  return;\n}\n\n",
            "called": [
                "lbasename"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022c0",
            "calling": [
                "FUN_00105830",
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "lbasename"
        },
        "bfd_bread": {
            "renaming": {},
            "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
            "called": [
                "bfd_bread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102540",
            "calling": [
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "bfd_bread"
        },
        "FUN_001079c0": {
            "renaming": {
                "FUN_001079c0": "print_file_info_001079c0",
                "param_1": "file",
                "param_2": "args",
                "param_3": "show_permissions",
                "param_4": "show_address",
                "iVar1": "result",
                "ppcVar2": "file_info",
                "pcVar3": "time_str",
                "uVar4": "file_type",
                "local_100": "current_time",
                "uStack_f3": "file_permission",
                "cStack_f2": "user_permission",
                "cStack_f1": "group_permission",
                "cStack_f0": "other_permission",
                "cStack_ef": "setuid",
                "cStack_ee": "setgid",
                "cStack_ed": "sticky_bit",
                "cStack_ec": "read_permission",
                "cStack_eb": "write_permission",
                "cStack_ea": "execute_permission",
                "local_e8": "time_buffer",
                "local_b8": "file_info_buffer",
                "uStack_a0": "permission_flags",
                "uStack_9c": "inode",
                "uStack_98": "device",
                "uStack_88": "hard_links",
                "local_60": "modification_time"
            },
            "code": "\nvoid printFileInfo_001079c0(FILE *file,char **args,char show_permissions,char show_address)\n\n{\n  int result;\n  char **file_info;\n  char *time_str;\n  uint file_type;\n  time_t current_time;\n  undefined file_permission;\n  char user_permission;\n  char group_permission;\n  char other_permission;\n  char setuid;\n  char setgid;\n  char sticky_bit;\n  char read_permission;\n  char write_permission;\n  char execute_permission;\n  undefined uStack_e9;\n  char time_buffer [48];\n  undefined file_info_buffer [24];\n  uint permission_flags;\n  uint inode;\n  uint device;\n  undefined8 hard_links;\n  time_t modification_time;\n  \n  if (show_permissions != '\\0') {\n    file_info = (char **)args[0x1d];\n    if ((char **)args[0x1d] == (char **)0x0) {\n      file_info = args;\n    }\n    result = (**(code **)(file_info[1] + 0x1e8))(args,file_info_buffer);\n    if (result == 0) {\n      current_time = modification_time;\n      time_str = ctime(&current_time);\n      if (time_str == (char *)0x0) {\n        time_str = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(time_buffer,time_str);\n      }\n      else {\n        sprintf(time_buffer,\"%.12s %.4s\",time_str + 4);\n      }\n      file_type = permission_flags & 0xf000;\n      if (file_type == 0x4000) {\n        file_permission = 100;\n      }\n      else if (file_type == 0xa000) {\n        file_permission = 0x6c;\n      }\n      else if (file_type == 0x6000) {\n        file_permission = 0x62;\n      }\n      else if (file_type == 0x2000) {\n        file_permission = 99;\n      }\n      else if (file_type == 0xc000) {\n        file_permission = 0x73;\n      }\n      else {\n        file_permission = 0x70;\n        if (file_type != 0x1000) {\n          file_permission = 0x2d;\n        }\n      }\n      user_permission = (-((permission_flags & 0x100) == 0) & 0xbbU) + 0x72;\n      group_permission = (-((permission_flags & 0x80) == 0) & 0xb6U) + 0x77;\n      other_permission = (-((permission_flags & 0x40) == 0) & 0xb5U) + 0x78;\n      setuid = (-((permission_flags & 0x20) == 0) & 0xbbU) + 0x72;\n      setgid = (-((permission_flags & 0x10) == 0) & 0xb6U) + 0x77;\n      sticky_bit = (-((permission_flags & 8) == 0) & 0xb5U) + 0x78;\n      read_permission = (-((permission_flags & 4) == 0) & 0xbbU) + 0x72;\n      write_permission = (-((permission_flags & 2) == 0) & 0xb6U) + 0x77;\n      execute_permission = (-((permission_flags & 1) == 0) & 0xb5U) + 0x78;\n      if ((permission_flags & 0x800) != 0) {\n        if (other_permission == 'x') {\n          other_permission = 's';\n        }\n        else {\n          other_permission = 'S';\n        }\n      }\n      if ((permission_flags & 0x400) != 0) {\n        if (sticky_bit == 'x') {\n          sticky_bit = 's';\n        }\n        else {\n          sticky_bit = 'S';\n        }\n      }\n      if ((permission_flags & 0x200) != 0) {\n        if (execute_permission == 'x') {\n          execute_permission = 't';\n        }\n        else {\n          execute_permission = 'T';\n        }\n      }\n      uStack_e9 = 0;\n      fprintf(file,\"%s %ld/%ld %6lu %s \",&user_permission,(ulong)inode,(ulong)device,hard_links,\n              time_buffer,(ulong)permission_flags);\n    }\n  }\n  fputs(*args,file);\n  if (show_address != '\\0') {\n    if ((*(byte *)((long)args + 0x49) & 0x10) == 0) {\n      if (args[0xb] != (char *)0x0) {\n        fprintf(file,\" 0x%lx\");\n      }\n    }\n    else if (args[0xc] != (char *)0x0) {\n      fprintf(file,\" 0x%lx\");\n    }\n  }\n  fputc(10,file);\n  return;\n}\n\n",
            "called": [
                "sprintf",
                "FUN_00102d8c",
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001079c0",
            "calling": [
                "FUN_00103ddc",
                "FUN_00107890"
            ],
            "imported": false,
            "current_name": "print_file_info_001079c0"
        },
        "FUN_00105a68": {
            "renaming": {
                "FUN_00105a68": "process_file_path_00105a68",
                "pcVar1": "fileDirectory",
                "pFVar2": "filePointer",
                "sVar3": "fileLength"
            },
            "code": "\nvoid processFilePath_00105a68(void)\n\n{\n  char *fileDirectory;\n  FILE *filePointer;\n  size_t fileLength;\n  \n  fileDirectory = DAT_0010d5e8;\n  if (DAT_0010d5e8 != (char *)0x0) {\n    fileLength = strlen(DAT_0010d5e8);\n    if (fileLength != 0) {\n      if (fileDirectory[fileLength - 1] == '/') {\n        DAT_0010d618 = (char *)concat(fileDirectory,DAT_0010d618,0);\n      }\n      else {\n        DAT_0010d618 = (char *)concat(fileDirectory,&DAT_00108260,DAT_0010d618,0);\n      }\n    }\n  }\n  if (DAT_0010d60c != 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  filePointer = fopen(DAT_0010d618,\"w\");\n  if (filePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "strlen",
                "perror",
                "FUN_00102e57",
                "xexit",
                "concat",
                "printf",
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a68",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "process_file_path_00105a68"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023f0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "FUN_001032a8": {
            "renaming": {
                "FUN_001032a8": "extract_and_print_entries_001032a8",
                "param_1": "archive",
                "param_2": "entryProcessor",
                "param_3": "entryNames",
                "param_4": "returnValue",
                "lVar1": "nextEntry",
                "uVar2": "currentEntry",
                "bVar3": "foundEntry",
                "plVar4": "currentNode",
                "iVar5": "comparisonResult",
                "__format": "errorMessage",
                "plVar6": "nextNode",
                "lVar7": "currentArchiveEntry",
                "plVar8": "previousNode"
            },
            "code": "\n\n\nundefined8 extractAndPrintEntries_001032a8(long *archive,code *entryProcessor,undefined8 *entryNames,undefined8 returnValue)\n\n{\n  long nextEntry;\n  undefined8 currentEntry;\n  bool foundEntry;\n  long *currentNode;\n  int comparisonResult;\n  char *errorMessage;\n  long *nextNode;\n  long currentArchiveEntry;\n  long *previousNode;\n  \n  currentArchiveEntry = archive[0x1e];\n  if (entryNames == (undefined8 *)0x0) {\n    while (currentArchiveEntry != 0) {\n      nextEntry = *(long *)(currentArchiveEntry + 0xf0);\n      (*entryProcessor)(currentArchiveEntry,0);\n      currentArchiveEntry = nextEntry;\n    }\n  }\n  else {\n    do {\n      foundEntry = false;\n      currentNode = (long *)archive[0x1e];\n      previousNode = archive;\n      while (nextNode = currentNode, nextNode != (long *)0x0) {\n        if (*nextNode != 0) {\n          comparisonResult = filename_cmp(*entryNames);\n          if (comparisonResult == 0) {\n            foundEntry = true;\n            (*entryProcessor)(nextNode,previousNode);\n          }\n        }\n        previousNode = nextNode;\n        currentNode = (long *)nextNode[0x1e];\n      }\n      if (!foundEntry) {\n        currentEntry = *entryNames;\n        errorMessage = (char *)dcgettext(0,\"No entry %s in archive.\\n\",5);\n        fprintf(_stderr,errorMessage,currentEntry);\n      }\n      entryNames = (undefined8 *)entryNames[1];\n    } while (entryNames != (undefined8 *)0x0);\n  }\n  return returnValue;\n}\n\n",
            "called": [
                "filename_cmp",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001032a8",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "extract_and_print_entries_001032a8"
        },
        "FUN_0010285f": {
            "renaming": {
                "FUN_0010285f": "print_archive_entry_not_found_error_0010285f",
                "__format": "errorMessage",
                "lVar2": "fileName",
                "plVar3": "archiveEntry",
                "uVar4": "entryName",
                "plVar5": "currentEntry",
                "unaff_RBP": "functionPointer",
                "unaff_R12": "archiveHeader",
                "unaff_R13D": "entryCount",
                "unaff_R14": "entryNames",
                "iStack000000000000000c": "count"
            },
            "code": "\n\n\nvoid printArchiveEntryNotFoundError_0010285f(void)\n\n{\n  int iVar1;\n  char *errorMessage;\n  long fileName;\n  long *archiveEntry;\n  undefined8 entryName;\n  long *currentEntry;\n  code *functionPointer;\n  long archiveHeader;\n  int entryCount;\n  undefined8 *entryNames;\n  int count;\n  \ncode_r0x0010285f:\n  entryName = *entryNames;\n  errorMessage = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n  fprintf(_stderr,errorMessage,entryName);\nLAB_0010553e:\n  entryNames = entryNames + 1;\n  entryCount = entryCount + -1;\n  if (entryCount == 0) {\n    return;\n  }\n  currentEntry = *(long **)(archiveHeader + 0xf0);\n  count = 0;\n  do {\n    if (currentEntry == (long *)0x0) goto code_r0x0010285f;\n    if (*(int *)((long)currentEntry + 0xac) == 0) {\n      fileName = *currentEntry;\n      if (fileName == 0) {\n        archiveEntry = (long *)currentEntry[0x1d];\n        if ((long *)currentEntry[0x1d] == (long *)0x0) {\n          archiveEntry = currentEntry;\n        }\n        (**(code **)(archiveEntry[1] + 0x1e8))(currentEntry,&stack0x00000010);\n      }\n      else if (((*(byte *)(archiveHeader + 0x49) & 0x10) == 0) || (fileName = extract_file_name_00105830(), fileName != 0))\n      {\n        entryName = extract_file_name_00105830(*entryNames);\n        iVar1 = filename_cmp(entryName,fileName);\n        if ((iVar1 == 0) &&\n           ((DAT_0010d634 == '\\0' ||\n            (count = count + 1,\n            count == _DAT_0010d630)))) break;\n      }\n    }\n    currentEntry = (long *)currentEntry[0x1e];\n  } while( true );\n  (*functionPointer)();\n  *(undefined4 *)((long)currentEntry + 0xac) = 1;\n  goto LAB_0010553e;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010285f",
            "calling": [
                "FUN_00105480"
            ],
            "imported": false,
            "current_name": "print_archive_entry_not_found_error_0010285f"
        },
        "bfd_set_archive_head": {
            "renaming": {},
            "code": "\nvoid bfd_set_archive_head(void)\n\n{\n  bfd_set_archive_head();\n  return;\n}\n\n",
            "called": [
                "bfd_set_archive_head"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "bfd_set_archive_head"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "FUN_00102c25",
                "FUN_001057a0",
                "FUN_001028ed",
                "FUN_00102bb0",
                "FUN_00105db0",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "vfprintf": {
            "renaming": {},
            "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 = vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
            "called": [
                "vfprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024b0",
            "calling": [
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "vfprintf"
        },
        "FUN_00102f96": {
            "renaming": {
                "FUN_00102f96": "print_error_info_00102f96",
                "uVar1": "errorMessage",
                "unaff_RBX": "errorCode",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\n\n\nvoid printErrorInfo_00102f96(void)\n\n{\n  undefined8 errorMessage;\n  long errorCode;\n  undefined8 returnAddress;\n  \n  errorMessage = dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (errorCode != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010d660);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010d660,errorMessage,returnAddress);\n  return;\n}\n\n",
            "called": [
                "fflush",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f96",
            "calling": [
                "FUN_00107c20"
            ],
            "imported": false,
            "current_name": "print_error_info_00102f96"
        },
        "FUN_0010342d": {
            "renaming": {
                "FUN_0010342d": "print_usage_0010342d",
                "param_1": "isVerbose",
                "uVar1": "versionNumber",
                "pcVar2": "message",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid printUsage_0010342d(uint isVerbose)\n\n{\n  undefined8 versionNumber;\n  char *message;\n  FILE *outputStream;\n  \n  message = (char *)dcgettext(0,\n                             \"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV] [--plugin <name>] [member-name] [count] archive-file file...\\n\"\n                             ,5);\n  outputStream = _stderr;\n  if (isVerbose != 0) {\n    outputStream = _stdout;\n  }\n  fprintf(outputStream,message,DAT_0010d660);\n  versionNumber = DAT_0010d660;\n  message = (char *)dcgettext(0,\"       %s -M [<mri-script]\\n\",5);\n  fprintf(outputStream,message,versionNumber);\n  message = (char *)dcgettext(0,\" commands:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  d            - delete file(s) from the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  m[ab]        - move file(s) in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  p            - print file(s) found in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  q[f]         - quick append file(s) to the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  s            - act as ranlib\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  t[O][v]      - display contents of the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  x[o]         - extract file(s) from the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" command specific modifiers:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [a]          - put file(s) after [member-name]\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [b]          - put file(s) before [member-name] (same as [i])\\n\",5\n                            );\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [D]          - use zero for timestamps and uids/gids (default)\\n\",\n                             5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [U]          - use actual timestamps and uids/gids\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [N]          - use instance [count] of name\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [f]          - truncate inserted file names\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [P]          - use full path names when matching\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [o]          - preserve original dates\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [O]          - display offsets of files in the archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  [u]          - only replace files that are newer than current archive contents\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" generic modifiers:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [c]          - do not warn if the library had to be created\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [s]          - create an archive index (cf. ranlib)\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [l <text> ]  - specify the dependencies of this library\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [S]          - do not build a symbol table\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [T]          - deprecated, use --thin instead\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [v]          - be verbose\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  [V]          - display the version number\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  @<file>      - read options from <file>\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --target=BFDNAME - specify the target object format as BFDNAME\\n\",\n                             5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  --output=DIRNAME - specify the output directory for extraction operations\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  --record-libdeps=<text> - specify the dependencies of this library\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --thin       - make a thin archive\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\" optional:\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --plugin <p> - load the specified plugin\\n\",5);\n  fprintf(outputStream,message);\n  print_emulation_options_0010336b(outputStream);\n  print_supported_targets_0010266f(DAT_0010d660,outputStream);\n  if (isVerbose != 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(isVerbose ^ 1);\n}\n\n",
            "called": [
                "FUN_0010336b",
                "xexit",
                "fprintf",
                "dcgettext",
                "FUN_0010266f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010342d",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_usage_0010342d"
        },
        "FUN_0010394a": {
            "renaming": {
                "FUN_0010394a": "print_archive_index_0010394a",
                "param_1": "isUsageOption",
                "uVar1": "symbolMapTimestamp",
                "pcVar2": "message",
                "__stream": "outputStream"
            },
            "code": "\n\n\nvoid printArchiveIndex_0010394a(uint isUsageOption)\n\n{\n  undefined8 symbolMapTimestamp;\n  char *message;\n  FILE *outputStream;\n  \n  symbolMapTimestamp = DAT_0010d660;\n  outputStream = _stderr;\n  if (isUsageOption != 0) {\n    outputStream = _stdout;\n  }\n  message = (char *)dcgettext(0,\"Usage: %s [options] archive\\n\",5);\n  fprintf(outputStream,message,symbolMapTimestamp);\n  message = (char *)dcgettext(0,\" Generate an index to speed access to archives\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \" The options are:\\n  @<file>                      Read options from <file>\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\"  --plugin <name>              Load the specified plugin\\n\",5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  -D                           Use zero for symbol map timestamp (default)\\n  -U                           Use an actual symbol map timestamp\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  message = (char *)dcgettext(0,\n                             \"  -t                           Update the archive\\'s symbol map timestamp\\n  -h --help                    Print this help message\\n  -v --version                 Print version information\\n\"\n                             ,5);\n  fprintf(outputStream,message);\n  print_supported_targets_0010266f(DAT_0010d660,outputStream);\n  if (isUsageOption != 0) {\n    message = (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(outputStream,message,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  xexit(isUsageOption ^ 1);\n}\n\n",
            "called": [
                "xexit",
                "fprintf",
                "dcgettext",
                "FUN_0010266f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010394a",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_archive_index_0010394a"
        },
        "FUN_00107920": {
            "renaming": {
                "FUN_00107920": "print_error_message_00107920",
                "param_1": "errorCode",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "param_8": "param8",
                "param_9": "errorMessage",
                "param_10": "param10",
                "param_11": "param11",
                "param_12": "param12",
                "param_13": "param13",
                "param_14": "param14",
                "in_AL": "flag",
                "local_d8": "size",
                "local_d4": "value",
                "local_d0": "ptrSize",
                "local_c8": "ptrValue",
                "local_b8": "buffer",
                "local_b0": "param10Copy",
                "local_a8": "param11Copy",
                "local_a0": "param12Copy",
                "local_98": "param13Copy",
                "local_90": "param14Copy",
                "local_88": "errorCodeCopy",
                "local_78": "param2Copy",
                "local_68": "param3Copy",
                "local_58": "param4Copy",
                "local_48": "param5Copy",
                "local_38": "param6Copy",
                "local_28": "param7Copy",
                "local_18": "param8Copy"
            },
            "code": "\nvoid printErrorMessage_00107920(undefined4 errorCode,undefined4 param2,undefined4 param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6,undefined4 param7,undefined4 param8,\n                 undefined8 errorMessage,undefined8 param10,undefined8 param11,undefined8 param12,\n                 undefined8 param13,undefined8 param14)\n\n{\n  char flag;\n  undefined4 size;\n  undefined4 value;\n  undefined *ptrSize;\n  undefined *ptrValue;\n  undefined buffer [8];\n  undefined8 param10Copy;\n  undefined8 param11Copy;\n  undefined8 param12Copy;\n  undefined8 param13Copy;\n  undefined8 param14Copy;\n  undefined4 errorCodeCopy;\n  undefined4 param2Copy;\n  undefined4 param3Copy;\n  undefined4 param4Copy;\n  undefined4 param5Copy;\n  undefined4 param6Copy;\n  undefined4 param7Copy;\n  undefined4 param8Copy;\n  \n  if (flag != '\\0') {\n    errorCodeCopy = errorCode;\n    param2Copy = param2;\n    param3Copy = param3;\n    param4Copy = param4;\n    param5Copy = param5;\n    param6Copy = param6;\n    param7Copy = param7;\n    param8Copy = param8;\n  }\n  ptrSize = &stack0x00000008;\n  size = 8;\n  ptrValue = buffer;\n  value = 0x30;\n  param10Copy = param10;\n  param11Copy = param11;\n  param12Copy = param12;\n  param13Copy = param13;\n  param14Copy = param14;\n  print_error_message_001078c0(errorMessage,&size);\n  return;\n}\n\n",
            "called": [
                "FUN_001078c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107920",
            "calling": [
                "FUN_00105300",
                "FUN_00102f1e",
                "FUN_001052a0",
                "FUN_001025a0",
                "FUN_00102fd7",
                "FUN_00105db0",
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "print_error_message_00107920"
        },
        "ctime": {
            "renaming": {},
            "code": "\n\n\nchar * ctime(time_t *__timer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = ctime(__timer);\n  return pcVar1;\n}\n\n",
            "called": [
                "ctime"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "ctime"
        },
        "bfd_set_default_target": {
            "renaming": {},
            "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
            "called": [
                "bfd_set_default_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_default_target"
        },
        "bfd_get_error": {
            "renaming": {},
            "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
            "called": [
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "FUN_00105300",
                "FUN_00107c20",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_get_error"
        },
        "bfd_fdopenw": {
            "renaming": {},
            "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
            "called": [
                "bfd_fdopenw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102570",
            "calling": [
                "FUN_00103c60",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "bfd_fdopenw"
        },
        "write": {
            "renaming": {},
            "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
            "called": [
                "write"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "write"
        },
        "FUN_00105bb0": {
            "renaming": {
                "FUN_00105bb0": "check_return_value_00105bb0"
            },
            "code": "\nundefined8 check_return_value_00105bb0(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bb0",
            "calling": [],
            "imported": false,
            "current_name": "check_return_value_00105bb0"
        },
        "FUN_00107640": {
            "renaming": {
                "FUN_00107640": "get_initial_value_00107640"
            },
            "code": "\nundefined8 get_initial_value_00107640(void)\n\n{\n  return 0;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107640",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "get_initial_value_00107640"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102590",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "FUN_00102e6f": {
            "renaming": {
                "FUN_00102e6f": "process_file_path_00102e6f",
                "pcVar1": "current_path",
                "in_RAX": "file_name",
                "uVar2": "base_name",
                "uVar3": "error_message",
                "pFVar4": "file_pointer",
                "sVar5": "file_name_length",
                "pcVar6": "ptr"
            },
            "code": "\nvoid process_file_path_00102e6f(void)\n\n{\n  char *current_path;\n  char *file_name;\n  undefined8 base_name;\n  undefined8 error_message;\n  FILE *file_pointer;\n  size_t file_name_length;\n  char *ptr;\n  \n  current_path = DAT_0010d5e8;\n  do {\n    file_name = file_name + 1;\n    while (*file_name != '/') {\n      if (*file_name == '\\0') {\n        if ((DAT_0010d5e8 != (char *)0x0) && (file_name_length = strlen(DAT_0010d5e8), file_name_length != 0)) {\n          if (current_path[file_name_length - 1] == '/') {\n            DAT_0010d618 = (char *)concat(current_path,DAT_0010d618,0);\n          }\n          else {\n            DAT_0010d618 = (char *)concat(current_path,&DAT_00108260,DAT_0010d618,0);\n          }\n        }\n        if (DAT_0010d60c != 0) {\n          printf(\"x - %s\\n\",DAT_0010d618);\n        }\n        file_pointer = fopen(DAT_0010d618,\"w\");\n        if (file_pointer == (FILE *)0x0) {\n          perror(DAT_0010d618);\n                    \n          xexit(1);\n        }\n        return;\n      }\n      ptr = file_name;\n      if ((*file_name == '.') && (ptr = file_name + 1, file_name[1] == '.')) {\n        ptr = file_name + 2;\n        if ((file_name[2] == '/') || (file_name[2] == '\\0')) {\n          base_name = lbasename();\n          current_path = DAT_0010d618;\n          error_message = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\"\n                            ,5);\n          print_error_message_00107920(error_message,current_path,base_name);\n          DAT_0010d618 = (char *)base_name;\n          process_file_path_00102e6f_00105a68();\n          return;\n        }\n      }\n      for (; (file_name = ptr, *ptr != '\\0' && (*ptr != '/')); ptr = ptr + 1) {\n      }\n    }\n  } while( true );\n}\n\n",
            "called": [
                "lbasename",
                "FUN_00107920",
                "dcgettext",
                "FUN_00105a68",
                "FUN_00102e6f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e6f",
            "calling": [
                "FUN_00102e6f"
            ],
            "imported": false,
            "current_name": "process_file_path_00102e6f"
        },
        "FUN_0010315d": {
            "renaming": {
                "FUN_0010315d": "check_and_exit_if_zero_0010315d"
            },
            "code": "\n\n\nvoid checkAndExitIfZero_0010315d(void)\n\n{\n  if (_DAT_0010d608 == 0) {\n                    \n    xexit(9);\n  }\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010315d",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_and_exit_if_zero_0010315d"
        },
        "textdomain": {
            "renaming": {},
            "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
            "called": [
                "textdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "textdomain"
        },
        "concat": {
            "renaming": {},
            "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_00102e57",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "concat"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "FUN_00103e95",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "FUN_00107890": {
            "renaming": {
                "FUN_00107890": "FUNC_00107890"
            },
            "code": "\n\n\nvoid FUNC_00107890(undefined8 param_1)\n\n{\n  print_file_info_001079c0(_stdout,param_1,DAT_0010d60c != 0,_DAT_0010d5fc != 0);\n  return;\n}\n\n",
            "called": [
                "FUN_001079c0"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00107890",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "FUNC_00107890"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102500",
            "calling": [
                "FUN_001033b0",
                "FUN_001075e0"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "bfd_check_format": {
            "renaming": {},
            "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102520",
            "calling": [
                "FUN_00103c60",
                "FUN_00102710",
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "bfd_check_format"
        },
        "FUN_001033d6": {
            "renaming": {
                "FUN_001033d6": "create_buffer_001033d6",
                "param_1": "buffer_size",
                "param_4": "flag",
                "pvVar1": "buffer",
                "pvVar2": "allocated_buffer",
                "auVar3": "returnValue"
            },
            "code": "\nundefined  [16]\ncreate_buffer_001033d6(undefined8 buffer_size,undefined8 param_2,undefined8 param_3,undefined8 flag)\n\n{\n  void *buffer;\n  void *allocated_buffer;\n  undefined returnValue [16];\n  \n  buffer = malloc(0x40);\n  if (buffer != (void *)0x0) goto LAB_001033f7;\n  do {\n    buffer = (void *)report_error_and_exit_001033b0(\"out of dynamic memory in yy_create_buffer_001033d6()\");\nLAB_001033f7:\n    *(undefined4 *)((long)buffer + 0x18) = 0x4000;\n    allocated_buffer = malloc(0x4002);\n    *(void **)((long)buffer + 8) = allocated_buffer;\n  } while (allocated_buffer == (void *)0x0);\n  *(undefined4 *)((long)buffer + 0x20) = 1;\n  initialize_file_001031cf(buffer,buffer_size);\n  returnValue._8_8_ = flag;\n  returnValue._0_8_ = buffer;\n  return returnValue;\n}\n\n",
            "called": [
                "FUN_001033b0",
                "FUN_001031cf",
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033d6",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "create_buffer_001033d6"
        },
        "fileno": {
            "renaming": {},
            "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fileno(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fileno"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102390",
            "calling": [
                "FUN_001031cf",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "fileno"
        },
        "FUN_00103172": {
            "renaming": {
                "FUN_00103172": "copy_and_print_string_00103172",
                "param_1": "source_string",
                "param_2": "destination_array",
                "param_3": "should_print",
                "param_4": "additional_data",
                "uVar1": "current_string",
                "auVar2": "output_array"
            },
            "code": "\nundefined  [16]\ncopy_and_print_string_00103172(undefined8 *source_string,undefined8 *destination_array,char should_print,undefined8 additional_data)\n\n{\n  undefined8 current_string;\n  undefined output_array [16];\n  \n  if (should_print != '\\0') {\n    printf(\"r - %s\\n\",*destination_array);\n  }\n  current_string = *source_string;\n  destination_array[0x1e] = current_string;\n  output_array._1_7_ = (undefined7)((ulong)current_string >> 8);\n  output_array[0] = 1;\n  *source_string = destination_array;\n  output_array._8_8_ = additional_data;\n  return output_array;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103172",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "copy_and_print_string_00103172"
        },
        "FUN_00105870": {
            "renaming": {
                "FUN_00105870": "find_last_match_00105870",
                "param_1": "file_list",
                "param_2": "comparison_type",
                "param_3": "target_filename",
                "iVar1": "comparison_result",
                "iVar3": "loop_condition",
                "uVar2": "default_target"
            },
            "code": "\nlong * find_last_match_00105870(long *file_list,int comparison_type,undefined8 target_filename)\n\n{\n  int comparison_result;\n  undefined8 default_target;\n  int loop_condition;\n  \n  default_target = DAT_0010d638;\n  loop_condition = DAT_0010d640;\n  if (DAT_0010d640 == 0) {\n    default_target = target_filename;\n    loop_condition = comparison_type;\n  }\n  if (loop_condition == 3) {\n    for (; *file_list != 0; file_list = (long *)(*file_list + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*file_list != (undefined8 *)0x0; file_list = (long *)(*file_list + 0xf0)) {\n      comparison_result = filename_cmp(*(undefined8 *)*file_list,default_target);\n      if (comparison_result == 0) {\n        if (loop_condition != 2) {\n          return file_list;\n        }\n        return (long *)(*file_list + 0xf0);\n      }\n    }\n  }\n  return file_list;\n}\n\n",
            "called": [
                "FUN_00102cd9"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105870",
            "calling": [
                "FUN_001028ed",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "find_last_match_00105870"
        },
        "FUN_001030ed": {
            "renaming": {
                "FUN_001030ed": "initialize_data_001030ed",
                "puVar1": "dataPointer"
            },
            "code": "\nvoid initializeData_001030ed(void)\n\n{\n  undefined8 *dataPointer;\n  \n  dataPointer = *(undefined8 **)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n  DAT_0010d598 = *(undefined4 *)((long)dataPointer + 0x1c);\n  DAT_0010d5b0 = (undefined *)dataPointer[2];\n  DAT_0010d5c8 = DAT_0010d5b0;\n  DAT_0010d590 = *dataPointer;\n  DAT_0010d588 = *DAT_0010d5b0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001030ed",
            "calling": [
                "FUN_00103e95",
                "FUN_001031cf"
            ],
            "imported": false,
            "current_name": "initialize_data_001030ed"
        },
        "FUN_00105bc0": {
            "renaming": {
                "FUN_00105bc0": "copy_and_replace_file_00105bc0",
                "param_1": "sourceFilePath",
                "param_2": "destinationFilePath",
                "param_3": "filePermissions",
                "param_4": "timestamp",
                "uVar1": "copyResult",
                "piVar2": "errnoLocation",
                "pcVar3": "errorString",
                "uVar4": "error",
                "uVar5": "copySize",
                "auVar6": "result"
            },
            "code": "\nundefined  [16] copyAndReplaceFile_00105bc0(char *sourceFilePath,char *destinationFilePath,undefined4 filePermissions,undefined8 timestamp)\n\n{\n  uint copyResult;\n  int *errnoLocation;\n  char *errorString;\n  undefined8 error;\n  ulong copySize;\n  undefined result [16];\n  \n  if (destinationFilePath == sourceFilePath) {\n    copySize = 0;\n  }\n  else {\n    copyResult = copy_data_to_file_00105c00(filePermissions);\n    copySize = (ulong)copyResult;\n    if (copyResult != 0) {\n      errnoLocation = __errno_location();\n      errorString = strerror(*errnoLocation);\n      error = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n      print_error_message_00107920(error,destinationFilePath,errorString);\n    }\n    unlink(sourceFilePath);\n  }\n  result._8_8_ = timestamp;\n  result._0_8_ = copySize;\n  return result;\n}\n\n",
            "called": [
                "FUN_00102f1e",
                "FUN_00105c00"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105bc0",
            "calling": [
                "FUN_00103e95",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "copy_and_replace_file_00105bc0"
        },
        "FUN_00107650": {
            "renaming": {
                "FUN_00107650": "check_and_print_file_info_00107650",
                "param_1": "file",
                "uVar1": "result",
                "lVar2": "fileStatus"
            },
            "code": "\nundefined8 checkAndPrintFileInfo_00107650(undefined8 file)\n\n{\n  undefined8 result;\n  long fileStatus;\n  \n  fileStatus = check_file_001052a0();\n  if (fileStatus < 1) {\n    result = 1;\n  }\n  else {\n    DAT_0010d648 = 1;\n    fileStatus = parse_binary_file_00105300(file,0);\n    if (fileStatus == 0) {\n                    \n      xexit(1);\n    }\n    extract_and_print_archive_file_info_001058b0(fileStatus);\n    result = 0;\n  }\n  return result;\n}\n\n",
            "called": [
                "FUN_00105300",
                "FUN_001052a0",
                "xexit",
                "FUN_0010284b",
                "FUN_001058b0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107650",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "check_and_print_file_info_00107650"
        },
        "setlocale": {
            "renaming": {},
            "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
            "called": [
                "setlocale"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102410",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "setlocale"
        },
        "FUN_00102f1e": {
            "renaming": {
                "FUN_00102f1e": "copy_file_and_print_error_00102f1e",
                "piVar1": "errno_location",
                "uVar2": "error_message",
                "unaff_RBP": "file_size",
                "unaff_R12": "file_path",
                "auVar3": "result",
                "unaff_retaddr": "return_address"
            },
            "code": "\nundefined  [16] copy_file_and_print_error_00102f1e(void)\n\n{\n  int *errno_location;\n  undefined8 error_message;\n  ulong file_size;\n  char *file_path;\n  undefined result [16];\n  undefined8 return_address;\n  \n  errno_location = __errno_location();\n  strerror(*errno_location);\n  error_message = dcgettext(0,\"unable to copy file \\'%s\\'; reason: %s\",5);\n  print_error_message_00107920(error_message);\n  unlink(file_path);\n  result._0_8_ = file_size & 0xffffffff;\n  result._8_8_ = return_address;\n  return result;\n}\n\n",
            "called": [
                "strerror",
                "FUN_00107920",
                "dcgettext",
                "unlink",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f1e",
            "calling": [
                "FUN_00105bc0"
            ],
            "imported": false,
            "current_name": "copy_file_and_print_error_00102f1e"
        },
        "bfd_set_error": {
            "renaming": {},
            "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102240",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_error"
        },
        "FUN_00102fd7": {
            "renaming": {
                "FUN_00102fd7": "print_error_message_00102fd7",
                "piVar1": "error_number_ptr",
                "uVar2": "error_message",
                "__errno_location": "__get_error_number_location",
                "strerror": "get_error_string",
                "dcgettext": "get_localized_string",
                "print_error_message_00107920": "print_error_message"
            },
            "code": "\nvoid print_error_message_00102fd7(void)\n\n{\n  int *error_number_ptr;\n  undefined8 error_message;\n  \n  error_number_ptr = __errno_location();\n  strerror(*error_number_ptr);\n  error_message = dcgettext(0,\"%s: cannot set time: %s\",5);\n  print_error_message_00102fd7(error_message);\n  return;\n}\n\n",
            "called": [
                "strerror",
                "FUN_00107920",
                "dcgettext",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102fd7",
            "calling": [
                "FUN_00107c80"
            ],
            "imported": false,
            "current_name": "print_error_message_00102fd7"
        },
        "FUN_00103ba8": {
            "renaming": {
                "FUN_00103ba8": "check_and_print_ar_00103ba8"
            },
            "code": "\n\n\nvoid checkAndPrintAR_00103ba8(void)\n\n{\n  if (_DAT_0010d608 != 0) {\n    printf(\"AR >\");\n    fflush(_stdout);\n    return;\n  }\n  return;\n}\n\n",
            "called": [
                "fflush",
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ba8",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "check_and_print_ar_00103ba8"
        },
        "bindtextdomain": {
            "renaming": {},
            "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
            "called": [
                "bindtextdomain"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bindtextdomain"
        },
        "filename_cmp": {
            "renaming": {},
            "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
            "called": [
                "filename_cmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "FUN_00105480",
                "FUN_00103e95",
                "FUN_001028ed",
                "FUN_00102cd9",
                "FUN_00105db0",
                "FUN_001032a8"
            ],
            "imported": false,
            "current_name": "filename_cmp"
        },
        "bfd_make_readable": {
            "renaming": {},
            "code": "\nvoid bfd_make_readable(void)\n\n{\n  bfd_make_readable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_readable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_make_readable"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "FUN_00103bd1",
                "FUN_00102c25",
                "FUN_00103c60",
                "FUN_001052a0",
                "FUN_00103e95",
                "FUN_0010285f",
                "FUN_00102fd7",
                "FUN_00102d8c",
                "FUN_001031a5",
                "FUN_00102e6f",
                "FUN_00105300",
                "FUN_00102f1e",
                "FUN_0010336b",
                "FUN_001028ed",
                "FUN_001025a0",
                "FUN_00102f96",
                "FUN_0010394a",
                "FUN_001075e0",
                "FUN_0010342d",
                "FUN_00105db0",
                "FUN_00103a78",
                "FUN_001032a8",
                "FUN_0010266f",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_format": {
            "renaming": {},
            "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
            "called": [
                "bfd_set_format"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102340",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00103e95",
                "FUN_00105db0",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "bfd_set_format"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102440",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102280",
            "calling": [
                "FUN_00103bd1",
                "FUN_00102d8c",
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "bfd_openw": {
            "renaming": {},
            "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
            "called": [
                "bfd_openw"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102420",
            "calling": [
                "FUN_00105300",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "bfd_openw"
        },
        "FUN_00103ddc": {
            "renaming": {
                "FUN_00103ddc": "print_file_info_00103ddc",
                "param_1": "fileInfo",
                "print_file_info_001079c0": "printFileInfoHelper"
            },
            "code": "\nvoid printFileInfo_00103ddc(undefined8 fileInfo)\n\n{\n  printFileInfo_00103ddcHelper(DAT_0010d578,fileInfo,DAT_0010d60c != 0,0);\n  return;\n}\n\n",
            "called": [
                "FUN_001079c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103ddc",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "print_file_info_00103ddc"
        },
        "FUN_001078c0": {
            "renaming": {
                "FUN_001078c0": "print_error_message_001078c0",
                "param_1": "message",
                "param_2": "arguments",
                "_stdout": "standardOutput",
                "_stderr": "standardError"
            },
            "code": "\n\n\nvoid printErrorMessage_001078c0(char *message,__gnuc_va_list arguments)\n\n{\n  fflush(standardOutput);\n  fprintf(standardError,\"%s: \",DAT_0010d660);\n  vfprintf(standardError,message,arguments);\n  putc(10,standardError);\n  return;\n}\n\n",
            "called": [
                "putc",
                "fflush",
                "vfprintf",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001078c0",
            "calling": [
                "FUN_00107690",
                "FUN_00107920"
            ],
            "imported": false,
            "current_name": "print_error_message_001078c0"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "bfd_openr": {
            "renaming": {},
            "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
            "called": [
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00102710",
                "FUN_00103e95",
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "bfd_openr"
        },
        "FUN_001075e0": {
            "renaming": {
                "FUN_001075e0": "print_version_info_001075e0",
                "param_1": "programVersion",
                "pcVar1": "copyrightMessage"
            },
            "code": "\nvoid printVersionInfo_001075e0(undefined8 programVersion)\n\n{\n  char *copyrightMessage;\n  \n  printf(\"GNU %s %s\\n\",programVersion,\"(GNU Binutils for Debian) 2.40\");\n  copyrightMessage = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(copyrightMessage);\n  copyrightMessage = (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(copyrightMessage);\n                    \n  exit(0);\n}\n\n",
            "called": [
                "exit",
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001075e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_version_info_001075e0"
        },
        "FUN_00105480": {
            "renaming": {
                "FUN_00105480": "reverse_entries_in_archive_00105480",
                "param_1": "archivePtr",
                "param_2": "entryCallback",
                "param_3": "entryNames",
                "param_4": "numEntries",
                "iVar1": "cmpResult",
                "__format": "errorMsgFormat",
                "lVar2": "entryPtr",
                "plVar3": "filePtr",
                "uVar4": "extractedName",
                "plVar5": "currentEntryPtr",
                "local_cc": "count",
                "local_c8": "localBuffer"
            },
            "code": "\n\n\nvoid reverseEntriesInArchive_00105480(long archivePtr,code *entryCallback,undefined8 *entryNames,int numEntries)\n\n{\n  int cmpResult;\n  char *errorMsgFormat;\n  long entryPtr;\n  long *filePtr;\n  undefined8 extractedName;\n  long *currentEntryPtr;\n  int count;\n  undefined localBuffer [152];\n  \n  entryPtr = *(long *)(archivePtr + 0xf0);\n  if (numEntries == 0) {\n    for (; entryPtr != 0; entryPtr = *(long *)(entryPtr + 0xf0)) {\n      (*entryCallback)(entryPtr);\n    }\n  }\n  else {\n    for (; entryPtr != 0; entryPtr = *(long *)(entryPtr + 0xf0)) {\n      *(undefined4 *)(entryPtr + 0xac) = 0;\n    }\n    do {\n      currentEntryPtr = *(long **)(archivePtr + 0xf0);\n      count = 0;\n      for (; currentEntryPtr != (long *)0x0; currentEntryPtr = (long *)currentEntryPtr[0x1e]) {\n        if (*(int *)((long)currentEntryPtr + 0xac) == 0) {\n          entryPtr = *currentEntryPtr;\n          if (entryPtr == 0) {\n            filePtr = (long *)currentEntryPtr[0x1d];\n            if ((long *)currentEntryPtr[0x1d] == (long *)0x0) {\n              filePtr = currentEntryPtr;\n            }\n            (**(code **)(filePtr[1] + 0x1e8))(currentEntryPtr,localBuffer);\n          }\n          else if (((*(byte *)(archivePtr + 0x49) & 0x10) == 0) ||\n                  (entryPtr = extract_file_name_00105830(entryPtr,archivePtr), entryPtr != 0)) {\n            extractedName = extract_file_name_00105830(*entryNames,archivePtr);\n            cmpResult = filename_cmp(extractedName,entryPtr);\n            if ((cmpResult == 0) &&\n               ((DAT_0010d634 == '\\0' || (count = count + 1, count == _DAT_0010d630)))) {\n              (*entryCallback)();\n              *(undefined4 *)((long)currentEntryPtr + 0xac) = 1;\n              goto LAB_0010553e;\n            }\n          }\n        }\n      }\n      extractedName = *entryNames;\n      errorMsgFormat = (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n      fprintf(_stderr,errorMsgFormat,extractedName);\nLAB_0010553e:\n      entryNames = entryNames + 1;\n      numEntries = numEntries + -1;\n    } while (numEntries != 0);\n  }\n  return;\n}\n\n",
            "called": [
                "filename_cmp",
                "FUN_00105830",
                "FUN_0010285f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105480",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "reverse_entries_in_archive_00105480"
        },
        "FUN_00105cf0": {
            "renaming": {
                "FUN_00105cf0": "FUNC_00105cf0"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d03) */\n/* WARNING: Removing unreachable block (ram,0x00105d0f) */\n\nvoid FUNC_00105cf0(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105cf0",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105cf0"
        },
        "FUN_001031a5": {
            "renaming": {
                "FUN_001031a5": "print_syntax_error_001031a5",
                "uVar1": "updatedVar",
                "__format": "errorFormat"
            },
            "code": "\nvoid printSyntaxError_001031a5(void)\n\n{\n  uint updatedVar;\n  char *errorFormat;\n  \n  updatedVar = DAT_0010d554 + 1;\n  errorFormat = (char *)dcgettext(0,\"Syntax error in archive script, line %d\\n\",5);\n  printf(errorFormat,(ulong)updatedVar);\n  return;\n}\n\n",
            "called": [
                "printf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031a5",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "print_syntax_error_001031a5"
        },
        "bfd_make_writable": {
            "renaming": {},
            "code": "\nvoid bfd_make_writable(void)\n\n{\n  bfd_make_writable();\n  return;\n}\n\n",
            "called": [
                "bfd_make_writable"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_make_writable"
        },
        "strtol": {
            "renaming": {},
            "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 = strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
            "called": [
                "strtol"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102350",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "strtol"
        },
        "bfd_create": {
            "renaming": {},
            "code": "\nvoid bfd_create(void)\n\n{\n  bfd_create();\n  return;\n}\n\n",
            "called": [
                "bfd_create"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_create"
        },
        "bfd_target_list": {
            "renaming": {},
            "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
            "called": [
                "bfd_target_list"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "bfd_target_list"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "FUN_00103bd1",
                "FUN_00102c25",
                "FUN_00102ba1",
                "FUN_00103e95",
                "FUN_00105db0",
                "FUN_00103a78",
                "FUN_00102d2f",
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "free"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102480",
            "calling": [
                "FUN_00105300",
                "FUN_00107690",
                "FUN_00107c10",
                "FUN_0010394a",
                "FUN_0010342d",
                "FUN_00105db0",
                "FUN_00107650",
                "FUN_0010315d",
                "FUN_00102d2f",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "close": {
            "renaming": {},
            "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = close(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102260",
            "calling": [
                "FUN_00105c00",
                "FUN_00102f55",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "close"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102470",
            "calling": [
                "FUN_00103e95",
                "FUN_00105db0",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "malloc": {
            "renaming": {},
            "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = malloc(__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "malloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023b0",
            "calling": [
                "FUN_001033d6",
                "FUN_00103e95",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "malloc"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102330",
            "calling": [
                "FUN_00105300",
                "FUN_001052a0",
                "FUN_00103e95",
                "FUN_001028ed",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "FUN_00103df9": {
            "renaming": {
                "FUN_00103df9": "ensure_buffer_stack_00103df9",
                "in_RCX": "returnValue",
                "__size": "bufferSize",
                "lVar1": "loopCounter",
                "lVar2": "newSize",
                "puVar3": "bufferPointer",
                "bVar4": "loopIncrement"
            },
            "code": "\nundefined8 ensureBufferStack_00103df9(void)\n\n{\n  size_t bufferSize;\n  undefined8 returnValue;\n  long loopCounter;\n  long newSize;\n  undefined4 *bufferPointer;\n  byte loopIncrement;\n  \n  loopIncrement = 0;\n  if (DAT_0010d5a8 == (void *)0x0) {\n    DAT_0010d5a8 = calloc(8,1);\n    if (DAT_0010d5a8 != (void *)0x0) {\n      DAT_0010d580 = 1;\n      DAT_0010d5a0 = 0;\n      return returnValue;\n    }\n  }\n  else {\n    if (DAT_0010d5a0 < DAT_0010d580 - 1U) {\n      return returnValue;\n    }\n    newSize = DAT_0010d580 + 8;\n    bufferSize = newSize * 8;\n    DAT_0010d5a8 = realloc(DAT_0010d5a8,bufferSize);\n    if (DAT_0010d5a8 != (void *)0x0) {\n      bufferPointer = (undefined4 *)((long)DAT_0010d5a8 + (bufferSize - 0x40));\n      DAT_0010d580 = newSize;\n      for (loopCounter = 0x10; loopCounter != 0; loopCounter = loopCounter + -1) {\n        *bufferPointer = 0;\n        bufferPointer = bufferPointer + (ulong)loopIncrement * -2 + 1;\n      }\n      return returnValue;\n    }\n  }\n  report_error_and_exit_001033b0(\"out of dynamic memory in yyensure_buffer_stack()\");\n  DAT_0010d5a0 = 0;\n  DAT_0010d580 = 1;\n  return returnValue;\n}\n\n",
            "called": [
                "realloc",
                "FUN_001033b0",
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103df9",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "ensure_buffer_stack_00103df9"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102270",
            "calling": [
                "FUN_00103c60",
                "FUN_00103e95",
                "FUN_00105db0",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "FUN_00103a78": {
            "renaming": {
                "FUN_00103a78": "extract_and_print_archive_00103a78",
                "param_1": "archive_info",
                "iVar1": "status",
                "__ptr": "buffer",
                "puVar2": "archive_ptr",
                "uVar3": "bytes_read",
                "uVar4": "error_message",
                "sVar5": "bytes_written",
                "piVar6": "errno_location",
                "unaff_RBP": "remaining_bytes",
                "pcVar7": "error_string",
                "unaff_R13": "total_bytes_read",
                "unaff_R14": "archive_size",
                "auStack_b8": "stack_buffer",
                "local_88": "expected_size"
            },
            "code": "\n\n\nvoid extract_and_print_archive_00103a78(undefined8 *archive_info)\n\n{\n  int status;\n  void *buffer;\n  undefined8 *archive_ptr;\n  ulong bytes_read;\n  undefined8 error_message;\n  size_t bytes_written;\n  int *errno_location;\n  size_t remaining_bytes;\n  char *error_string;\n  ulong total_bytes_read;\n  ulong archive_size;\n  undefined stack_buffer [48];\n  ulong expected_size;\n  \n  buffer = (void *)xmalloc(0x2000);\n  archive_ptr = (undefined8 *)archive_info[0x1d];\n  if ((undefined8 *)archive_info[0x1d] == (undefined8 *)0x0) {\n    archive_ptr = archive_info;\n  }\n  status = (**(code **)(archive_ptr[1] + 0x1e8))(archive_info,stack_buffer);\n  if (status == 0) {\n    if (DAT_0010d60c != 0) {\n      printf(\"\\n<%s>\\n\\n\",*archive_info);\n    }\n    total_bytes_read = 0;\n    bfd_seek(archive_info,0,0);\n    goto LAB_00103afd;\n  }\n  archive_info = (undefined8 *)*archive_info;\n  error_string = \"internal stat error on %s\";\n  do {\n    error_message = dcgettext(0,error_string,5);\n    print_error_and_exit_00107690(error_message,archive_info);\n    expected_size = archive_size;\n    do {\n      bytes_written = fwrite(buffer,1,remaining_bytes,_stdout);\n      if (bytes_written != remaining_bytes) {\n        errno_location = __errno_location();\n        error_string = strerror(*errno_location);\n        print_error_and_exit_00107690(\"stdout: %s\",error_string);\nLAB_00103b91:\n        free(buffer);\n        return;\n      }\n      total_bytes_read = total_bytes_read + bytes_written;\nLAB_00103afd:\n      if (expected_size <= total_bytes_read) goto LAB_00103b91;\n      remaining_bytes = expected_size - total_bytes_read;\n      if (0x2000 < remaining_bytes) {\n        remaining_bytes = 0x2000;\n      }\n      bytes_read = bfd_bread(buffer,remaining_bytes,archive_info);\n    } while (remaining_bytes == bytes_read);\n    error_string = \"%s is not a valid archive\";\n    archive_info = *(undefined8 **)archive_info[0x1d];\n    archive_size = expected_size;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00107690",
                "bfd_seek",
                "xmalloc",
                "free",
                "strerror",
                "bfd_bread",
                "printf",
                "fwrite",
                "dcgettext",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103a78",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_and_print_archive_00103a78"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102310",
            "calling": [
                "FUN_00103bd1",
                "FUN_00103c60",
                "FUN_00103e95",
                "FUN_0010285f",
                "FUN_001078c0",
                "FUN_00102d8c",
                "FUN_00105300",
                "FUN_0010336b",
                "FUN_001033b0",
                "FUN_00102f96",
                "FUN_0010394a",
                "FUN_0010342d",
                "FUN_00105db0",
                "FUN_001032a8",
                "FUN_0010266f"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "strrchr": {
            "renaming": {},
            "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strrchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "strrchr"
        },
        "FUN_001058b0": {
            "renaming": {
                "FUN_001058b0": "extract_and_print_archive_file_info_001058b0",
                "cVar1": "charVar1",
                "uVar2": "uintVar2",
                "iVar3": "intVar3",
                "uVar4": "uintVar4",
                "uStack0000000000000020": "stackVar1",
                "in_stack_00000028": "stackVar2",
                "in_stack_00000038": "stackVar3",
                "uStack_33": "stackChar1",
                "cStack_32": "stackChar2",
                "cStack_31": "stackChar3"
            },
            "code": "\n\n\nvoid extractAndPrintArchiveFileInfo_001058b0(undefined8 *param_1)\n\n{\n  char charVar1;\n  uint uintVar2;\n  int intVar3;\n  undefined8 uintVar4;\n  char *__format;\n  void *__ptr;\n  FILE *__stream;\n  char **ppcVar5;\n  uint stackVar1;\n  uint stackVar2;\n  undefined8 stackVar3;\n  int local_3c [2];\n  undefined stackChar1;\n  char stackChar2;\n  char stackChar3;\n  \n  uintVar4 = param_1[0x1e];\n  local_3c[0] = -1;\n  __ptr = (void *)xstrdup(*param_1);\n  __stream = (FILE *)extract_file_name_001057a0(__ptr,local_3c);\n  intVar3 = local_3c[0];\n  if (__stream != (FILE *)0x0) {\n    DAT_0010d618 = __stream;\n    ppcVar5 = (char **)bfd_fdopenw(__stream,*(undefined8 *)param_1[1],local_3c[0]);\n    if (ppcVar5 != (char **)0x0) {\n      DAT_0010d5e0 = ppcVar5;\n      bfd_set_format(ppcVar5,2);\n      uintVar2 = (~DAT_0010d648 >> 0x1f) << 3 | *(byte *)((long)ppcVar5 + 0x49) & 0xfffffff7;\n      *(char *)((long)ppcVar5 + 0x49) = (char)uintVar2;\n      if (DAT_0010d5fa != '\\0') {\n        *(uint *)((long)ppcVar5 + 0x44) = *(uint *)((long)ppcVar5 + 0x44) | 0x400;\n      }\n      if (_DAT_0010d2d0 != 0) {\n        *(uint *)((long)ppcVar5 + 0x44) = *(uint *)((long)ppcVar5 + 0x44) | 0x2000;\n      }\n      if (DAT_0010d5f9 != '\\0') goto LAB_00102d37;\n      while( true ) {\n        if ((DAT_0010d5f8 != '\\0') || ((*(byte *)((long)param_1 + 0x49) & 0x10) != 0)) {\n          *(byte *)((long)ppcVar5 + 0x49) = (byte)uintVar2 | 0x10;\n        }\n        charVar1 = bfd_set_archive_head(ppcVar5,uintVar4);\n        if (charVar1 != '\\0') break;\n        uintVar2 = handle_error_and_exit_00107c10(__ptr);\nLAB_00102d37:\n        *(uint *)((long)ppcVar5 + 0x44) = *(uint *)((long)ppcVar5 + 0x44) | 0x100000;\n      }\n      intVar3 = dup(intVar3);\n      charVar1 = bfd_close(ppcVar5);\n      if (charVar1 == '\\0') {\n        handle_error_and_exit_00107c10(__ptr);\n        __format = (char *)dcgettext(0,\"<time data corrupt>\",5);\n        sprintf(&stack0xffffffffffffffd8,__format);\n        uintVar2 = stackVar1 & 0xf000;\n        if (uintVar2 == 0x4000) {\n          stackChar1 = 100;\n        }\n        else if (uintVar2 == 0xa000) {\n          stackChar1 = 0x6c;\n        }\n        else if (uintVar2 == 0x6000) {\n          stackChar1 = 0x62;\n        }\n        else if (uintVar2 == 0x2000) {\n          stackChar1 = 99;\n        }\n        else if (uintVar2 == 0xc000) {\n          stackChar1 = 0x73;\n        }\n        else {\n          stackChar1 = 0x70;\n          if (uintVar2 != 0x1000) {\n            stackChar1 = 0x2d;\n          }\n        }\n        stackChar2 = (-((_stackVar1 & 0x100) == 0) & 0xbbU) + 0x72;\n        stackChar3 = (-((_stackVar1 & 0x80) == 0) & 0xb6U) + 0x77;\n        fprintf(__stream,\"%s %ld/%ld %6lu %s \",&stackChar2,_stackVar1 >> 0x20,\n                (ulong)stackVar2,stackVar3,&stack0xffffffffffffffd8,\n                _stackVar1 & 0xffffffff);\n        fputs(*ppcVar5,__stream);\n        if ((char)param_1 != '\\0') {\n          if ((*(byte *)((long)ppcVar5 + 0x49) & 0x10) == 0) {\n            if (ppcVar5[0xb] != (char *)0x0) {\n              fprintf(__stream,\" 0x%lx\");\n            }\n          }\n          else if (ppcVar5[0xc] != (char *)0x0) {\n            fprintf(__stream,\" 0x%lx\");\n          }\n        }\n        fputc(10,__stream);\n        return;\n      }\n      DAT_0010d5e0 = (char **)0x0;\n      DAT_0010d618 = (FILE *)0x0;\n      bfd_close(param_1);\n      intVar3 = copy_and_replace_file_00105bc0(__stream,__ptr,intVar3);\n      if (intVar3 == 0) {\n        free(__ptr);\n        free(__stream);\n        return;\n      }\n      goto LAB_00102d7a;\n    }\n    close(intVar3);\n    handle_error_and_exit_00107c10(__ptr);\n  }\n  uintVar4 = dcgettext(0,\"could not create temporary file whilst writing archive\",5);\n  handle_error_and_exit_00107c10(uintVar4);\nLAB_00102d7a:\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "close",
                "FUN_001057a0",
                "xstrdup",
                "FUN_00107c10",
                "bfd_fdopenw",
                "bfd_set_format",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001058b0",
            "calling": [
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "extract_and_print_archive_file_info_001058b0"
        },
        "fputs": {
            "renaming": {},
            "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputs(__s,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputs"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "FUN_00102d8c"
            ],
            "imported": false,
            "current_name": "fputs"
        },
        "perror": {
            "renaming": {},
            "code": "\n\n\nvoid perror(char *__s)\n\n{\n  perror(__s);\n  return;\n}\n\n",
            "called": [
                "perror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024a0",
            "calling": [
                "FUN_00105300",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "perror"
        },
        "FUN_00102bf5": {
            "renaming": {
                "FUN_00102bf5": "close_and_remove_files_00102bf5"
            },
            "code": "\nvoid closeAndRemoveFiles_00102bf5(void)\n\n{\n  if (DAT_0010d5e0 != 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 != (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close",
                "unlink_if_ordinary",
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bf5",
            "calling": [
                "FUN_00107730"
            ],
            "imported": false,
            "current_name": "close_and_remove_files_00102bf5"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_indirect_call_00102020"
            },
            "code": "\nvoid execute_indirect_call_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_call_00102020"
        },
        "open": {
            "renaming": {},
            "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 = open(__file,__oflag);\n  return iVar1;\n}\n\n",
            "called": [
                "open"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102460",
            "calling": [
                "FUN_00105c00",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "open"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023c0",
            "calling": [
                "FUN_00103bd1",
                "FUN_00103ba8",
                "FUN_00102f96",
                "FUN_001078c0"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "FUN_00102943": {
            "renaming": {
                "FUN_00102943": "initialize_data_00102943"
            },
            "code": "\nvoid initializeData_00102943(void)\n\n{\n  DAT_0010d618 = 0;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102943",
            "calling": [
                "FUN_001028ed",
                "FUN_00105570"
            ],
            "imported": false,
            "current_name": "initialize_data_00102943"
        },
        "bfd_openr_next_archived_file": {
            "renaming": {},
            "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102530",
            "calling": [
                "FUN_00105300",
                "FUN_00103c60",
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "bfd_openr_next_archived_file"
        },
        "realloc": {
            "renaming": {},
            "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "realloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [
                "FUN_00103e95",
                "FUN_00103df9"
            ],
            "imported": false,
            "current_name": "realloc"
        },
        "FUN_00107c80": {
            "renaming": {
                "FUN_00107c80": "set_file_time_00107c80",
                "param_1": "filePath",
                "param_2": "fileInfo",
                "iVar1": "result",
                "piVar2": "errorNumberPtr",
                "pcVar3": "errorMessage",
                "uVar4": "translatedErrorMessage",
                "local_38": "fileTime1",
                "uStack_34": "fileTime2",
                "uStack_30": "fileTime3",
                "uStack_2c": "fileTime4",
                "local_28": "openMode",
                "uStack_24": "filePermission1",
                "uStack_20": "filePermission2",
                "uStack_1c": "filePermission3"
            },
            "code": "\nvoid setFileTime_00107c80(char *filePath,long fileInfo)\n\n{\n  int result;\n  int *errorNumberPtr;\n  char *errorMessage;\n  undefined8 translatedErrorMessage;\n  undefined4 fileTime1;\n  undefined4 fileTime2;\n  undefined4 fileTime3;\n  undefined4 fileTime4;\n  undefined4 openMode;\n  undefined4 filePermission1;\n  undefined4 filePermission2;\n  undefined4 filePermission3;\n  \n  openMode = *(undefined4 *)(fileInfo + 0x58);\n  filePermission1 = *(undefined4 *)(fileInfo + 0x5c);\n  filePermission2 = *(undefined4 *)(fileInfo + 0x60);\n  filePermission3 = *(undefined4 *)(fileInfo + 100);\n  fileTime1 = *(undefined4 *)(fileInfo + 0x48);\n  fileTime2 = *(undefined4 *)(fileInfo + 0x4c);\n  fileTime3 = *(undefined4 *)(fileInfo + 0x50);\n  fileTime4 = *(undefined4 *)(fileInfo + 0x54);\n  result = utimensat(-100,filePath,(timespec *)&fileTime1,0);\n  if (result != 0) {\n    errorNumberPtr = __errno_location();\n    errorMessage = strerror(*errorNumberPtr);\n    translatedErrorMessage = dcgettext(0,\"%s: cannot set time: %s\",5);\n    print_error_message_00107920(translatedErrorMessage,filePath,errorMessage);\n  }\n  return;\n}\n\n",
            "called": [
                "FUN_00102fd7",
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c80",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "set_file_time_00107c80"
        },
        "isatty": {
            "renaming": {},
            "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = isatty(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "FUN_001031cf",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "isatty"
        },
        "FUN_00105a20": {
            "renaming": {
                "FUN_00105a20": "process_output_file_00105a20",
                "param_1": "output_path",
                "pcVar1": "base_path",
                "pcVar2": "curr_char",
                "uVar3": "basename_result",
                "uVar4": "error_message",
                "pFVar5": "file_handler",
                "sVar6": "path_length"
            },
            "code": "\nvoid process_output_file_00105a20(char *output_path)\n\n{\n  char *base_path;\n  char *curr_char;\n  undefined8 basename_result;\n  undefined8 error_message;\n  FILE *file_handler;\n  size_t path_length;\n  \n  base_path = DAT_0010d5e8;\n  DAT_0010d618 = output_path;\n  if (*output_path == '/') {\nLAB_00102e9a:\n    basename_result = lbasename();\n    base_path = DAT_0010d618;\n    error_message = dcgettext(0,\"illegal output pathname for archive member: %s, using \\'%s\\' instead\",5);\n    print_error_message_00107920(error_message,base_path,basename_result);\n    DAT_0010d618 = (char *)basename_result;\n    FUN_00105a68();\n    return;\n  }\n  do {\n    if (*output_path == '\\0') {\n      if ((DAT_0010d5e8 != (char *)0x0) && (path_length = strlen(DAT_0010d5e8), path_length != 0)) {\n        if (base_path[path_length - 1] == '/') {\n          DAT_0010d618 = (char *)concat(base_path,DAT_0010d618,0);\n        }\n        else {\n          DAT_0010d618 = (char *)concat(base_path,&DAT_00108260,DAT_0010d618,0);\n        }\n      }\n      if (DAT_0010d60c != 0) {\n        printf(\"x - %s\\n\",DAT_0010d618);\n      }\n      file_handler = fopen(DAT_0010d618,\"w\");\n      if (file_handler == (FILE *)0x0) {\n        perror(DAT_0010d618);\n                    \n        xexit(1);\n      }\n      return;\n    }\n    curr_char = output_path;\n    if ((*output_path == '.') && (curr_char = output_path + 1, output_path[1] == '.')) {\n      curr_char = output_path + 2;\n      if ((output_path[2] == '/') || (output_path[2] == '\\0')) goto LAB_00102e9a;\n    }\n    for (; (*curr_char != '\\0' && (*curr_char != '/')); curr_char = curr_char + 1) {\n    }\n    for (; output_path = curr_char, *curr_char == '/'; curr_char = curr_char + 1) {\n    }\n  } while( true );\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105a20",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "process_output_file_00105a20"
        },
        "sprintf": {
            "renaming": {},
            "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = sprintf(__s,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "sprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024f0",
            "calling": [
                "FUN_00102d8c",
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "sprintf"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00105d20();\n  return;\n}\n\n",
            "called": [
                "FUN_00105d20"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105da0",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "FUN_001028ed",
                "FUN_00102bb0",
                "FUN_00105db0",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "FUN_00102f55": {
            "renaming": {
                "FUN_00102f55": "close_file_and_set_error_00102f55",
                "piVar2": "errorPointer",
                "iVar1": "errorValue",
                "unaff_R12D": "fileDescriptor"
            },
            "code": "\nundefined8 closeFileAndSetError_00102f55(void)\n\n{\n  int errorValue;\n  int *errorPointer;\n  int fileDescriptor;\n  \n  errorPointer = __errno_location();\n  errorValue = *errorPointer;\n  close(fileDescriptor);\n  *errorPointer = errorValue;\n  return 0xffffffff;\n}\n\n",
            "called": [
                "close",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f55",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "close_file_and_set_error_00102f55"
        },
        "FUN_001057a0": {
            "renaming": {
                "FUN_001057a0": "extract_file_name_001057a0",
                "param_1": "filepath",
                "param_2": "file_descriptor",
                "param_3": "unused_arg1",
                "param_4": "unused_arg2",
                "iVar1": "temp_file_descriptor",
                "pcVar2": "last_occurrence_of_slash",
                "lVar3": "file_name_length",
                "lVar4": "file_name_index",
                "lVar5": "last_occurrence_index",
                "pcVar6": "extracted_file_name",
                "bVar7": "is_last_character_slash",
                "auVar8": "result"
            },
            "code": "\nundefined  [16] extract_file_name_001057a0(char *filepath,int *file_descriptor,undefined8 unused_arg1,undefined8 unused_arg2)\n\n{\n  int temp_file_descriptor;\n  char *last_occurrence_of_slash;\n  long file_name_length;\n  long file_name_index;\n  long last_occurrence_index;\n  char *extracted_file_name;\n  byte is_last_character_slash;\n  undefined result [16];\n  \n  is_last_character_slash = 0;\n  last_occurrence_of_slash = strrchr(filepath,0x2f);\n  if (last_occurrence_of_slash == (char *)0x0) {\n    last_occurrence_of_slash = (char *)xmalloc(9);\n    file_name_length = 0;\n  }\n  else {\n    last_occurrence_index = (long)last_occurrence_of_slash - (long)filepath;\n    last_occurrence_of_slash = (char *)xmalloc(last_occurrence_index + 0xb);\n    file_name_length = last_occurrence_index + 1;\n    extracted_file_name = last_occurrence_of_slash;\n    for (file_name_index = last_occurrence_index; file_name_index != 0; file_name_index = file_name_index + -1) {\n      *extracted_file_name = *filepath;\n      filepath = filepath + (ulong)is_last_character_slash * -2 + 1;\n      extracted_file_name = extracted_file_name + (ulong)is_last_character_slash * -2 + 1;\n    }\n    last_occurrence_of_slash[last_occurrence_index] = '/';\n  }\n  *(undefined8 *)(last_occurrence_of_slash + file_name_length) = 0x5858585858587473;\n  *(undefined *)((long)(last_occurrence_of_slash + file_name_length) + 8) = 0;\n  temp_file_descriptor = mkstemp(last_occurrence_of_slash);\n  if (temp_file_descriptor == -1) {\n    extracted_file_name = (char *)0x0;\n    free(last_occurrence_of_slash);\n  }\n  else {\n    *file_descriptor = temp_file_descriptor;\n    extracted_file_name = last_occurrence_of_slash;\n  }\n  result._8_8_ = unused_arg2;\n  result._0_8_ = extracted_file_name;\n  return result;\n}\n\n",
            "called": [
                "xmalloc",
                "FUN_00102ba1",
                "strrchr",
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001057a0",
            "calling": [
                "FUN_00103c60",
                "FUN_001058b0"
            ],
            "imported": false,
            "current_name": "extract_file_name_001057a0"
        },
        "bfd_cache_close": {
            "renaming": {},
            "code": "\nvoid bfd_cache_close(void)\n\n{\n  bfd_cache_close();\n  return;\n}\n\n",
            "called": [
                "bfd_cache_close"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "FUN_00103e95",
                "FUN_00102bf5"
            ],
            "imported": false,
            "current_name": "bfd_cache_close"
        },
        "FUN_00102d8c": {
            "renaming": {
                "FUN_00102d8c": "print_file_info_00102d8c",
                "unaff_RBX": "fileContent",
                "unaff_RBP": "filePtr",
                "unaff_R12B": "isHexFormat",
                "uStack0000000000000015": "fileTypeChar",
                "cStack0000000000000016": "firstPermissionChar",
                "cStack0000000000000017": "secondPermissionChar",
                "param_9": "thirdPermissionChar",
                "cStack0000000000000019": "fourthPermissionChar",
                "cStack000000000000001a": "fifthPermissionChar",
                "cStack000000000000001b": "sixthPermissionChar",
                "cStack000000000000001c": "seventhPermissionChar",
                "cStack000000000000001d": "eighthPermissionChar",
                "cStack000000000000001e": "ninethPermissionChar",
                "uStack000000000000001f": "isXPermissionAvailable",
                "param_19": "permissions",
                "uStack000000000000006c": "fileSize",
                "param_20": "timestamp",
                "param_22": "filePtrDecoded",
                "__format": "errorMsg"
            },
            "code": "\nvoid printFileInfo_00102d8c(void)\n\n{\n  char *errorMsg;\n  uint uVar1;\n  char **fileContent;\n  FILE *filePtr;\n  char isHexFormat;\n  undefined fileTypeChar;\n  char firstPermissionChar;\n  char secondPermissionChar;\n  char thirdPermissionChar;\n  char fourthPermissionChar;\n  char fifthPermissionChar;\n  char sixthPermissionChar;\n  char seventhPermissionChar;\n  char eighthPermissionChar;\n  char ninethPermissionChar;\n  undefined isXPermissionAvailable;\n  uint permissions;\n  uint fileSize;\n  uint timestamp;\n  undefined8 filePtrDecoded;\n  \n  errorMsg = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,errorMsg);\n  uVar1 = permissions & 0xf000;\n  if (uVar1 == 0x4000) {\n    fileTypeChar = 100;\n  }\n  else if (uVar1 == 0xa000) {\n    fileTypeChar = 0x6c;\n  }\n  else if (uVar1 == 0x6000) {\n    fileTypeChar = 0x62;\n  }\n  else if (uVar1 == 0x2000) {\n    fileTypeChar = 99;\n  }\n  else if (uVar1 == 0xc000) {\n    fileTypeChar = 0x73;\n  }\n  else {\n    fileTypeChar = 0x70;\n    if (uVar1 != 0x1000) {\n      fileTypeChar = 0x2d;\n    }\n  }\n  firstPermissionChar = (-((permissions & 0x100) == 0) & 0xbbU) + 0x72;\n  secondPermissionChar = (-((permissions & 0x80) == 0) & 0xb6U) + 0x77;\n  thirdPermissionChar = (-((permissions & 0x40) == 0) & 0xb5U) + 0x78;\n  fourthPermissionChar = (-((permissions & 0x20) == 0) & 0xbbU) + 0x72;\n  fifthPermissionChar = (-((permissions & 0x10) == 0) & 0xb6U) + 0x77;\n  sixthPermissionChar = (-((permissions & 8) == 0) & 0xb5U) + 0x78;\n  seventhPermissionChar = (-((permissions & 4) == 0) & 0xbbU) + 0x72;\n  eighthPermissionChar = (-((permissions & 2) == 0) & 0xb6U) + 0x77;\n  ninethPermissionChar = (-((permissions & 1) == 0) & 0xb5U) + 0x78;\n  if ((permissions & 0x800) != 0) {\n    if (thirdPermissionChar == 'x') {\n      thirdPermissionChar = 's';\n    }\n    else {\n      thirdPermissionChar = 'S';\n    }\n  }\n  if ((permissions & 0x400) != 0) {\n    if (sixthPermissionChar == 'x') {\n      sixthPermissionChar = 's';\n    }\n    else {\n      sixthPermissionChar = 'S';\n    }\n  }\n  if ((permissions & 0x200) != 0) {\n    if (ninethPermissionChar == 'x') {\n      ninethPermissionChar = 't';\n    }\n    else {\n      ninethPermissionChar = 'T';\n    }\n  }\n  isXPermissionAvailable = 0;\n  fprintf(filePtr,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)fileSize,\n          (ulong)timestamp,filePtrDecoded,&stack0x00000020,(ulong)permissions);\n  fputs(*fileContent,filePtr);\n  if (isHexFormat != '\\0') {\n    if ((*(byte *)((long)fileContent + 0x49) & 0x10) == 0) {\n      if (fileContent[0xb] != (char *)0x0) {\n        fprintf(filePtr,\" 0x%lx\");\n      }\n    }\n    else if (fileContent[0xc] != (char *)0x0) {\n      fprintf(filePtr,\" 0x%lx\");\n    }\n  }\n  fputc(10,filePtr);\n  return;\n}\n\n",
            "called": [
                "fputc",
                "fputs",
                "sprintf",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d8c",
            "calling": [
                "FUN_001079c0"
            ],
            "imported": false,
            "current_name": "print_file_info_00102d8c"
        },
        "bfd_plugin_set_plugin": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_plugin"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_plugin"
        },
        "__errno_location": {
            "renaming": {},
            "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 = __errno_location();\n  return piVar1;\n}\n\n",
            "called": [
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "FUN_00102c25",
                "FUN_00105300",
                "FUN_00102f1e",
                "FUN_00103c60",
                "FUN_00103e95",
                "FUN_001028ed",
                "FUN_00105c00",
                "FUN_001031cf",
                "FUN_001025a0",
                "FUN_00102f55",
                "FUN_00102fd7",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "__errno_location"
        },
        "FUN_00105300": {
            "renaming": {
                "FUN_00105300": "parse_binary_file_00105300",
                "param_1": "filename",
                "param_2": "fileData",
                "plVar1": "archivedFile",
                "pcVar2": "pluginName",
                "bVar3": "isThinLibrary",
                "cVar4": "status",
                "iVar5": "result",
                "uVar6": "errorString",
                "uVar7": "errorMessage",
                "piVar8": "errnoPtr",
                "lVar9": "filePtr",
                "puVar10": "archivedFiles",
                "local_b0": "formatBuffer",
                "local_a8": "fileStats"
            },
            "code": "\n\n\nundefined8 * parseBinaryFile_00105300(char *filename,undefined8 *fileData)\n\n{\n  long *archivedFile;\n  char *pluginName;\n  byte isThinLibrary;\n  char status;\n  int result;\n  undefined8 errorString;\n  undefined8 errorMessage;\n  int *errnoPtr;\n  long filePtr;\n  undefined8 *archivedFiles;\n  undefined8 formatBuffer;\n  stat fileStats;\n  \n  bfd_set_error(0);\n  if (DAT_0010d5f0 == (char *)0x0) {\n    DAT_0010d5f0 = \"plugin\";\n  }\n  result = stat(filename,&fileStats);\n  pluginName = DAT_0010d618;\n  if (result == 0) goto LAB_001053be;\n  errnoPtr = __errno_location();\n  if (*errnoPtr == 2) {\n    if (DAT_0010d604 == '\\0') {\n      fprintf(_stderr,\"%s: \",DAT_0010d660);\n      perror(filename);\n      check_and_exit_if_zero_0010315d();\n      return (undefined8 *)0x0;\n    }\n    if ((DAT_0010d5f0 == (char *)0x0) && (fileData != (undefined8 *)0x0)) {\n      archivedFiles = (undefined8 *)extract_archived_files_00102710();\n      return archivedFiles;\n    }\n    fileData = (undefined8 *)bfd_openw(filename,DAT_0010d5f0);\n    if (((fileData != (undefined8 *)0x0) && (status = bfd_set_format(fileData,2), status != '\\0')) &&\n       (status = bfd_close(fileData), status != '\\0')) {\n      pluginName = filename;\n      if (_DAT_0010d610 == 0) goto LAB_00102826;\n      goto LAB_001053be;\n    }\n  }\n  handle_error_and_exit_00107c10(filename);\n  do {\n    isThinLibrary = *(byte *)((long)fileData + 0x49) >> 4 & 1;\n    if (DAT_0010d5f8 == '\\0') {\n      if (isThinLibrary != 0) {\n        errorMessage = *fileData;\n        errorString = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        print_error_and_exit_00107690(errorString,errorMessage);\n        goto LAB_00102812;\n      }\n    }\n    else if (isThinLibrary == 0) {\n      errorMessage = *fileData;\n      errorString = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      print_error_and_exit_00107690(errorString,errorMessage);\nLAB_001027cb:\n      print_error_message_00107c20(filename);\n      result = bfd_get_error();\n      if (result == 0xd) {\nLAB_00102812:\n        print_matching_formats_00103bd1(formatBuffer);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      archivedFile = fileData + 0x1e;\n      for (filePtr = bfd_openr_next_archived_file(fileData,0); filePtr != 0;\n          filePtr = bfd_openr_next_archived_file(fileData,filePtr)) {\n        *archivedFile = filePtr;\n        archivedFile = (long *)(filePtr + 0xf0);\n      }\n      *archivedFile = 0;\n      result = bfd_get_error();\n      if (result == 9) {\n        return fileData;\n      }\n      do {\n        handle_error_and_exit_00107c10(filename);\nLAB_00102826:\n        errorMessage = dcgettext(0,\"creating %s\",5);\n        print_error_message_00107920(errorMessage,filename);\n        pluginName = filename;\nLAB_001053be:\n        DAT_0010d618 = pluginName;\n        fileData = (undefined8 *)bfd_openr(filename,DAT_0010d5f0);\n      } while (fileData == (undefined8 *)0x0);\n      status = bfd_check_format_matches(fileData,2,&formatBuffer);\n      if (status == '\\0') goto LAB_001027cb;\n    } while (((DAT_0010d64c != 2) && (DAT_0010d64c != 7)) ||\n            (filePtr = bfd_openr_next_archived_file(fileData,0), filePtr == 0));\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00103bd1",
                "bfd_set_error",
                "FUN_00102710",
                "FUN_00107c10",
                "bfd_close",
                "stat",
                "perror",
                "bfd_openw",
                "FUN_00107690",
                "bfd_openr_next_archived_file",
                "bfd_check_format_matches",
                "bfd_set_format",
                "FUN_00107c20",
                "bfd_openr",
                "xexit",
                "FUN_00107920",
                "fprintf",
                "dcgettext",
                "FUN_0010315d",
                "bfd_get_error",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105300",
            "calling": [
                "FUN_00103e95",
                "FUN_00105db0",
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "parse_binary_file_00105300"
        },
        "FUN_00105db0": {
            "renaming": {
                "FUN_00105db0": "process_archive_00105db0",
                "param_1": "argc",
                "param_2": "argv",
                "pbVar1": "pointerByte1",
                "puVar2": "pointerUInt",
                "bVar3": "byteVar",
                "plVar4": "pointerLong",
                "puVar5": "pointerUInt64",
                "uVar6": "unsignedVar1",
                "uVar7": "unsignedVar2",
                "bVar8": "boolVar1",
                "bVar9": "boolVar2",
                "ppcVar10": "pointerPointerChar",
                "piVar11": "pointerInt",
                "puVar12": "pointerVoid",
                "bVar13": "byteVar2",
                "cVar14": "charVar",
                "iVar15": "intVar",
                "uVar16": "unsignedVar3",
                "uVar17": "unsignedVar4",
                "pFVar18": "pointerFile",
                "sVar19": "sizeVar",
                "sVar20": "sizeVar2",
                "__ptr": "bytePtr",
                "plVar21": "pointerLong2",
                "pFVar22": "pointerFile2",
                "pcVar23": "pointerChar",
                "lVar24": "longVar",
                "uVar25": "unsignedVar5",
                "puVar26": "pointerUInt64_2",
                "uVar27": "unsignedVar6",
                "pFVar28": "pointerFile3",
                "local_110": "localData4",
                "extraout_EDX": "extraOutputEDX",
                "pplVar29": "pointerPointerLong",
                "uVar30": "unsignedVar7",
                "ppcVar31": "pointerPointerChar2",
                "ppcVar32": "pointerPointerChar3",
                "pbVar33": "pointerByte2",
                "lVar34": "longVar2",
                "lVar35": "longVar3",
                "ppuVar36": "pointerPointerVoid",
                "uVar37": "unsignedVar8",
                "unaff_RBP": "unaffectedRegister_1",
                "pbVar38": "pointerByte3",
                "pcVar39": "pointerChar2",
                "uVar40": "unsignedVar9",
                "uVar41": "unsignedVar10",
                "uVar42": "unsignedVar11",
                "unaff_R12": "unaffectedRegister_2",
                "pcVar43": "pointerChar3",
                "local_130": "localData1",
                "local_128": "localData2",
                "local_118": "localData3",
                "local_108": "localData5",
                "local_100": "localData6",
                "local_c8": "localData7",
                "uStack_c6": "unsignedStackVar1",
                "uStack_c5": "unsignedStackVar2",
                "local_b0": "localData8"
            },
            "code": "\n\n\nvoid processArchive_00105db0(uint argc,FILE *argv)\n\n{\n  byte *pointerByte1;\n  uint *pointerUInt;\n  byte byteVar;\n  long *pointerLong;\n  undefined8 *pointerUInt64;\n  undefined4 unsignedVar1;\n  undefined4 unsignedVar2;\n  bool boolVar1;\n  bool boolVar2;\n  char **pointerPointerChar;\n  int *pointerInt;\n  undefined *pointerVoid;\n  byte byteVar2;\n  char charVar;\n  int intVar;\n  uint unsignedVar3;\n  undefined4 unsignedVar4;\n  FILE *pointerFile;\n  size_t sizeVar;\n  size_t sizeVar2;\n  byte *bytePtr;\n  long *pointerLong2;\n  FILE *pointerFile2;\n  char *pointerChar;\n  long longVar;\n  ulong unsignedVar5;\n  undefined8 *pointerUInt64_2;\n  undefined8 unsignedVar6;\n  FILE *pointerFile3;\n  long **pointerPointerLong;\n  undefined8 unsignedVar7;\n  char **pointerPointerChar2;\n  uint extraOutputEDX;\n  char **pointerPointerChar3;\n  byte *pointerByte2;\n  long longVar2;\n  long longVar3;\n  undefined **pointerPointerVoid;\n  uint unsignedVar8;\n  char *unaffectedRegister_1;\n  byte *pointerByte3;\n  char *pointerChar2;\n  ulong unsignedVar9;\n  ulong unsignedVar10;\n  ulong unsignedVar11;\n  FILE *unaffectedRegister_2;\n  char *pointerChar3;\n  uint uVar44;\n  int iVar45;\n  char *pcVar46;\n  bool bVar47;\n  byte bVar48;\n  undefined8 localData1;\n  FILE *localData2;\n  byte *localData3;\n  char **localData4;\n  size_t localData5;\n  long localData6;\n  undefined localData7 [2];\n  undefined unsignedStackVar1;\n  undefined5 unsignedStackVar2;\n  uint localData8;\n  \n  bVar48 = 0;\n  pcVar46 = (char *)(ulong)argc;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_0010d660 = *(long **)argv;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010d660);\n  bfd_plugin_set_program_name(DAT_0010d660);\n  pointerChar3 = (char *)argv;\n  pointerFile = argv;\n  if ((int)argc < 2) goto LAB_001062c6;\n  localData4 = (char **)0x7d0;\n  unaffectedRegister_2 = (FILE *)0x1;\n  localData2 = (FILE *)0x0;\n  pointerFile2 = argv;\n  do {\n    unsignedVar3 = (uint)unaffectedRegister_2;\n    unaffectedRegister_1 = (char *)(long)(int)unsignedVar3;\n    localData1 = (FILE *)((long)unaffectedRegister_1 * 8);\n    pointerChar3 = (char *)pointerFile2;\n    if (**(char **)(&pointerFile2->_flags + (long)unaffectedRegister_1 * 2) == '@') {\n      uVar44 = (int)localData4 - 1;\n      localData4 = (char **)(ulong)uVar44;\n      if (uVar44 == 0) {\n        pointerLong2 = *(long **)pointerFile2;\n        pcVar46 = \"%s: error: too many @-files encountered\\n\";\nLAB_00106ffe:\n        fprintf(_stderr,pcVar46,pointerLong2);\nLAB_0010700f:\n                    \n        xexit(1);\n      }\n      pointerChar2 = *(char **)(&pointerFile2->_flags + (long)unaffectedRegister_1 * 2) + 1;\n      intVar = stat(pointerChar2,(stat *)localData7);\n      if (-1 < intVar) {\n        if ((localData8 & 0xf000) == 0x4000) {\n          pointerLong2 = *(long **)pointerFile2;\n          pcVar46 = \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00106ffe;\n        }\n        pointerFile = fopen(pointerChar2,\"r\");\n        if (pointerFile != (FILE *)0x0) {\n          intVar = fseek(pointerFile,0,2);\n          if (((intVar != -1) && (sizeVar = ftell(pointerFile), sizeVar != 0xffffffffffffffff)) &&\n             (intVar = fseek(pointerFile,0,0), intVar != -1)) {\n            localData3 = (byte *)xmalloc(sizeVar + 1);\n            sizeVar2 = fread(localData3,1,sizeVar,pointerFile);\n            if ((sizeVar == sizeVar2) || (intVar = ferror(pointerFile), intVar == 0)) {\n              localData3[sizeVar2] = 0;\n              byteVar2 = *localData3;\n              pointerByte2 = localData3;\n              while( true ) {\n                if (byteVar2 == 0) goto LAB_00106814;\n                if (((&_sch_istable)[(ulong)byteVar2 * 2] & 0x40) == 0) break;\n                byteVar2 = pointerByte2[1];\n                pointerByte2 = pointerByte2 + 1;\n              }\n              sizeVar = strlen((char *)localData3);\n              bytePtr = (byte *)xmalloc(sizeVar + 1);\n              pointerFile3 = (FILE *)0x0;\n              intVar = 0;\n              boolVar2 = false;\n              bVar47 = false;\n              boolVar1 = false;\n              localData6 = 0;\n              pointerByte2 = localData3;\n              do {\n                while (((&_sch_istable)[(ulong)*pointerByte2 * 2] & 0x40) != 0) {\n                  pointerByte2 = pointerByte2 + 1;\n                }\n                if ((intVar == 0) || (intVar + -1 <= (int)localData6)) {\n                  if (pointerFile3 == (FILE *)0x0) {\n                    intVar = 8;\n                    pointerFile3 = (FILE *)xmalloc(0x40);\n                    pointerPointerChar2 = (char **)((long)&pointerFile3->_flags + localData6 * 8);\n                    *pointerPointerChar2 = (char *)0x0;\n                  }\n                  else {\n                    intVar = intVar * 2;\n                    pointerFile3 = (FILE *)xrealloc(pointerFile3,(long)intVar << 3);\n                    pointerPointerChar2 = (char **)((long)&pointerFile3->_flags + localData6 * 8);\n                    *pointerPointerChar2 = (char *)0x0;\n                  }\n                }\n                else {\n                  pointerPointerChar2 = (char **)((long)&pointerFile3->_flags + localData6 * 8);\n                }\n                byteVar2 = *pointerByte2;\n                pointerByte3 = bytePtr;\n                while (byteVar2 != 0) {\n                  while( true ) {\n                    if ((((&_sch_istable)[(ulong)byteVar2 * 2] & 0x40) != 0) &&\n                       (!(bool)(boolVar2 | boolVar1 | bVar47))) {\n                      boolVar1 = false;\n                      boolVar2 = false;\n                      bVar47 = false;\n                      goto LAB_0010606f;\n                    }\n                    if (!boolVar1) break;\n                    pointerByte2 = pointerByte2 + 1;\n                    *pointerByte3 = byteVar2;\n                    pointerByte3 = pointerByte3 + 1;\n                    boolVar1 = false;\n                    byteVar2 = *pointerByte2;\n                    if (byteVar2 == 0) goto LAB_0010606f;\n                  }\n                  if (byteVar2 == 0x5c) {\n                    boolVar1 = true;\n                  }\n                  else if (bVar47) {\n                    if (byteVar2 == 0x27) {\n                      bVar47 = false;\n                    }\n                    else {\nLAB_001061f1:\n                      *pointerByte3 = byteVar2;\n                      pointerByte3 = pointerByte3 + 1;\n                    }\n                  }\n                  else if (boolVar2) {\n                    if (byteVar2 != 0x22) goto LAB_001061f1;\n                    boolVar2 = false;\n                  }\n                  else if (byteVar2 == 0x27) {\n                    bVar47 = true;\n                  }\n                  else {\n                    if (byteVar2 != 0x22) goto LAB_001061f1;\n                    boolVar2 = true;\n                  }\n                  pointerByte1 = pointerByte2 + 1;\n                  pointerByte2 = pointerByte2 + 1;\n                  byteVar2 = *pointerByte1;\n                }\nLAB_0010606f:\n                *pointerByte3 = 0;\n                pointerLong2 = (long *)xstrdup(bytePtr);\n                *pointerPointerChar2 = (char *)pointerLong2;\n                *(undefined8 *)(pointerFile3->_shortbuf + localData6 * 8 + -0x7b) = 0;\n                byteVar2 = *pointerByte2;\n                byteVar = (&_sch_istable)[(ulong)byteVar2 * 2];\n                while ((byteVar & 0x40) != 0) {\n                  byteVar2 = pointerByte2[1];\n                  pointerByte2 = pointerByte2 + 1;\n                  byteVar = (&_sch_istable)[(ulong)byteVar2 * 2];\n                }\n                localData6 = localData6 + 1;\n                if (byteVar2 == 0) {\n                  free(bytePtr);\n                  if (pointerFile2 == argv) goto LAB_00106834;\n                  goto LAB_0010610a;\n                }\n              } while( true );\n            }\n            free(localData3);\n          }\n          fclose(pointerFile);\n        }\n      }\n    }\n    if ((int)pcVar46 <= (int)(unsignedVar3 + 1)) {\nLAB_001062c6:\n      do {\n        if (_DAT_0010d2d4 < 0) goto LAB_001073cc;\nLAB_001062d3:\n        unsignedVar3 = (uint)unaffectedRegister_2;\n        intVar = bfd_init();\n        pointerChar2 = \"fatal error: libbfd ABI mismatch\";\n        if (intVar != 0x118) goto LAB_00106803;\n        pointerChar2 = \"x86_64-pc-linux-gnu\";\n        unsignedVar3 = bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n        pointerVoid = PTR_DAT_0010d2e0;\n        unaffectedRegister_2 = (FILE *)(ulong)unsignedVar3;\n        if ((char)unsignedVar3 != '\\0') {\n          if (__xexit_cleanup == (code *)0x0) {\n            __xexit_cleanup = execute_functions_00107cc0;\n          }\n          if (*(int *)(PTR_DAT_0010d2e0 + 8) < 0x20) {\nLAB_0010632b:\n            pointerVoid = PTR_DAT_0010d2e0;\n            intVar = *(int *)(PTR_DAT_0010d2e0 + 8);\n            *(int *)(PTR_DAT_0010d2e0 + 8) = intVar + 1;\n            *(code **)(pointerVoid + (long)intVar * 8 + 0x10) = cleanup_and_close_00107730;\n          }\n          else {\n            pointerUInt64_2 = (undefined8 *)malloc(0x110);\n            if (pointerUInt64_2 != (undefined8 *)0x0) {\n              *pointerUInt64_2 = pointerVoid;\n              *(undefined4 *)(pointerUInt64_2 + 1) = 0;\n              PTR_DAT_0010d2e0 = (undefined *)pointerUInt64_2;\n              goto LAB_0010632b;\n            }\n          }\n          longVar = 1;\n          do {\n            longVar3 = longVar;\n            intVar = (int)pcVar46;\n            if (intVar <= (int)longVar3) break;\n            charVar = get_initial_value_00107640(*(undefined8 *)((int *)pointerChar3 + longVar3 * 2));\n            longVar = longVar3 + 1;\n          } while (charVar != '\\0');\n          pcVar46 = (char *)((long)pointerChar3 + longVar3 * 8 + -8);\n          uVar44 = intVar - ((int)longVar3 + -1);\n          pointerFile = (FILE *)(ulong)uVar44;\n          if (_DAT_0010d2d4 != 0) {\n            pointerChar3 = \"DhHUvVt\";\n            unsignedVar8 = 0;\n            while (intVar = getopt_long(pointerFile,pcVar46,\"DhHUvVt\",&PTR_DAT_0010d300), intVar != -1)\n            {\n              if (intVar < 0x77) {\n                if (0x43 < intVar) {\n                  switch(intVar) {\n                  case 0x44:\n                    _DAT_0010d2d0 = 1;\n                    break;\n                  case 0x48:\n                  case 0x68:\n                    _DAT_0010d658 = 1;\n                    break;\n                  case 0x55:\n                    _DAT_0010d2d0 = 0;\n                    break;\n                  case 0x56:\n                  case 0x76:\n                    _DAT_0010d654 = 1;\n                    break;\n                  case 0x74:\n                    unsignedVar8 = unsignedVar3;\n                  }\n                }\n              }\n              else if (intVar == 0xc9) {\n                bfd_plugin_set_plugin(_optarg);\n              }\n            }\n            if ((int)uVar44 < 2) {\nLAB_00107125:\n              pointerChar2 = (char *)0x0;\n              print_archive_index_0010394a();\n            }\n            else {\n              if (_DAT_0010d658 != 0) {\nLAB_0010711b:\n                print_archive_index_0010394a();\n                goto LAB_00107125;\n              }\n              if (_DAT_0010d654 != 0) {\n                print_version_info_001075e0(\"ranlib\");\n                goto LAB_0010711b;\n              }\n              if (_DAT_0010d2d0 < 0) {\n                _DAT_0010d2d0 = 1;\n              }\n              unaffectedRegister_2 = (FILE *)0x0;\n              pointerChar3 = (char *)(long)_optind;\n              while( true ) {\n                if ((int)uVar44 <= (int)pointerChar3) goto LAB_00106f8b;\n                pointerChar2 = *(char **)((int *)pcVar46 + (long)pointerChar3 * 2);\n                if ((char)unsignedVar8 != '\\0') break;\n                unsignedVar3 = check_and_print_file_info_00107650();\n                pointerChar3 = (char *)((long)(int *)pointerChar3 + 1);\n                unaffectedRegister_2 = (FILE *)(ulong)((uint)unaffectedRegister_2 | unsignedVar3);\n              }\n            }\n            while (longVar = check_file_001052a0(pointerChar2), longVar < 1) {\n              unsignedVar3 = 1;\nLAB_001071c4:\n              pointerInt = (int *)pointerChar3;\n              pointerChar3 = (char *)((long)pointerInt + 1);\n              unaffectedRegister_2 = (FILE *)(ulong)((uint)unaffectedRegister_2 | unsignedVar3);\n              if ((int)uVar44 <= (int)pointerChar3) {\nLAB_00106f8b:\n                    \n                xexit(unaffectedRegister_2);\n              }\n              pointerChar2 = *(char **)((char *)((long)pcVar46 + 0x83) + (long)pointerInt * 8 + -0x7b);\n            }\n            intVar = open(pointerChar2,2,0);\n            if (intVar < 0) {\n              bfd_set_error(1);\n              handle_error_and_exit_00107c10(pointerChar2);\nLAB_0010737f:\n              handle_error_and_exit_00107c10(pointerChar2);\nLAB_00107387:\n              print_error_message_00107c20(pointerChar2);\n              intVar = bfd_get_error();\n              if (intVar == 0xd) {\n                print_matching_formats_00103bd1(CONCAT53(unsignedStackVar2,\n                                      CONCAT12(unsignedStackVar1,CONCAT11(localData7[1],localData7[0]))));\n              }\n              goto LAB_0010700f;\n            }\n            unaffectedRegister_1 = (char *)bfd_fdopenr(pointerChar2,0);\n            if ((FILE *)unaffectedRegister_1 == (FILE *)0x0) goto LAB_0010737f;\n            charVar = bfd_check_format_matches(unaffectedRegister_1,2,localData7);\n            if (charVar == '\\0') goto LAB_00107387;\n            if ((*(byte *)((long)((long)unaffectedRegister_1 + 0x48) + 1) & 8) != 0) {\n              if (_DAT_0010d2d0 != 0) {\n                pointerUInt = (uint *)((long)((long)unaffectedRegister_1 + 0x40) + 4);\n                *pointerUInt = *pointerUInt | 0x2000;\n              }\n              (**(code **)(*(char **)((long)unaffectedRegister_1 + 8) + 0x1f0))(unaffectedRegister_1);\n              charVar = bfd_close(unaffectedRegister_1);\n              if (charVar != '\\0') {\n                unsignedVar3 = 0;\n                goto LAB_001071c4;\n              }\n              goto LAB_0010737f;\n            }\n            unsignedVar6 = dcgettext(0,\"%s: no archive map to update\",5);\n            print_error_and_exit_00107690(unsignedVar6,pointerChar2);\nLAB_001073cc:\n            pointerChar2 = (char *)lbasename(DAT_0010d660);\n            sizeVar = strlen(pointerChar2);\n            if ((sizeVar < 6) ||\n               (intVar = filename_cmp(pointerChar2 + (sizeVar - 6),\"ranlib\"), intVar != 0)) {\n              _DAT_0010d2d4 = 0;\n            }\n            else {\n              _DAT_0010d2d4 = 1;\n            }\n            goto LAB_001062d3;\n          }\n          pointerPointerVoid = &PTR_DAT_0010d300;\n          unaffectedRegister_1 = \"hdmpqrtxl:coOVsSuvabiMNfPTDU\";\n          pointerChar3 = (char *)&DAT_001096a0;\n          pointerFile2 = (FILE *)unaffectedRegister_1;\n          pointerFile3 = pointerFile;\n          if ((int)uVar44 < 2) goto switchD_00107462_caseD_1;\n          localData1 = (FILE *)CONCAT71(localData1._1_7_,(char)unsignedVar3);\nLAB_001063a3:\n          pointerFile2 = (FILE *)unaffectedRegister_1;\n          if (**(char **)((long)pcVar46 + 8) != '-') {\n            localData7[0] = 0x2d;\n            unsignedStackVar1 = 0;\n            sizeVar = strlen(*(char **)((long)pcVar46 + 8));\n            intVar = (int)sizeVar + (int)pointerFile;\n            unaffectedRegister_2 = (FILE *)xmalloc((long)intVar * 8);\n            unsignedVar4 = *(undefined4 *)((long)pcVar46 + 4);\n            unaffectedRegister_2->_flags = *(int *)pcVar46;\n            *(undefined4 *)&unaffectedRegister_2->field_0x4 = unsignedVar4;\n            pointerPointerChar2 = *(char ***)((long)pcVar46 + 8);\n            localData2 = (FILE *)((long)pcVar46 + 0x10);\n            localData4 = pointerPointerChar2;\n            if (*(char *)pointerPointerChar2 == '\\0') {\n              pointerPointerChar3 = &unaffectedRegister_2->_IO_read_ptr;\n            }\n            else {\n              localData3 = localData7;\n              localData7[1] = *(char *)pointerPointerChar2;\n              pointerChar2 = (char *)xstrdup();\n              pointerPointerChar3 = &unaffectedRegister_2->_IO_read_end;\n              unaffectedRegister_2->_IO_read_ptr = pointerChar2;\n              if (*(char *)((long)pointerPointerChar2 + 1) != '\\0') {\n                localData7[1] = *(char *)((long)pointerPointerChar2 + 1);\n                pointerChar2 = (char *)xstrdup(localData3);\n                pointerPointerChar3 = &unaffectedRegister_2->_IO_read_base;\n                unaffectedRegister_2->_IO_read_end = pointerChar2;\n                if (*(char *)((long)pointerPointerChar2 + 2) != '\\0') {\n                  localData7[1] = *(char *)((long)pointerPointerChar2 + 2);\n                  pointerChar2 = (char *)xstrdup(localData3);\n                  pointerPointerChar3 = &unaffectedRegister_2->_IO_write_base;\n                  unaffectedRegister_2->_IO_read_base = pointerChar2;\n                  if (*(char *)((long)pointerPointerChar2 + 3) != '\\0') {\n                    pointerPointerChar3 = &unaffectedRegister_2->_IO_write_ptr;\n                    localData7[1] = *(char *)((long)pointerPointerChar2 + 3);\n                    pointerChar2 = (char *)xstrdup(localData3);\n                    unaffectedRegister_2->_IO_write_base = pointerChar2;\n                    charVar = *(char *)((long)pointerPointerChar2 + 4);\n                    localData4 = pointerPointerChar3;\n                    if (charVar != '\\0') {\n                      pointerChar2 = (char *)((long)pointerPointerChar2 + 4);\n                      pointerPointerChar2 = pointerPointerChar3;\n                      do {\n                        pointerPointerChar3 = pointerPointerChar2 + 1;\n                        localData7[1] = charVar;\n                        pointerChar = (char *)xstrdup(localData3);\n                        pointerChar2 = pointerChar2 + 1;\n                        *pointerPointerChar2 = pointerChar;\n                        charVar = *pointerChar2;\n                        pointerPointerChar2 = pointerPointerChar3;\n                        localData4 = pointerPointerChar3;\n                      } while (charVar != '\\0');\n                    }\n                  }\n                }\n              }\n            }\n            longVar = (long)(int)pointerFile;\n            pointerInt = (int *)pcVar46 + longVar * 2;\n            if (localData2 < pointerInt) {\n              unsignedVar5 = longVar * 8 - 0x11;\n              if ((unsignedVar5 < 0x18) || (pointerPointerChar3 == (char **)((long)pcVar46 + 0x18))) {\n                *pointerPointerChar3 = *(char **)((long)pcVar46 + 0x10);\n                if (((char **)((long)pcVar46 + 0x18) < pointerInt) &&\n                   ((((pointerPointerChar3[1] = *(char **)((long)pcVar46 + 0x18),\n                      (char **)((long)pcVar46 + 0x20) < pointerInt &&\n                      (pointerPointerChar3[2] = *(char **)((long)pcVar46 + 0x20),\n                      (char **)((long)pcVar46 + 0x28) < pointerInt)) &&\n                     (pointerPointerChar3[3] = *(char **)((long)pcVar46 + 0x28),\n                     (char **)((long)pcVar46 + 0x30) < pointerInt)) &&\n                    (pointerPointerChar3[4] = *(char **)((long)pcVar46 + 0x30),\n                    (char **)((long)pcVar46 + 0x38) < pointerInt)))) {\n                  pointerPointerChar3[5] = *(char **)((long)pcVar46 + 0x38);\n                  pointerPointerChar = pointerPointerChar3 + 6;\n                  for (pointerPointerChar2 = (char **)((long)pcVar46 + 0x40); pointerPointerChar2 < pointerInt;\n                      pointerPointerChar2 = pointerPointerChar2 + (ulong)bVar48 * -2 + 1) {\n                    *pointerPointerChar = *pointerPointerChar2;\n                    pointerPointerChar = pointerPointerChar + (ulong)bVar48 * -2 + 1;\n                  }\n                }\n              }\n              else {\n                unsignedVar4 = *(undefined4 *)((long)((long)pcVar46 + 0x10) + 4);\n                unsignedVar1 = *(undefined4 *)((long)pcVar46 + 0x18);\n                unsignedVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x18) + 4);\n                unsignedVar9 = (unsignedVar5 >> 3) + 1;\n                *(undefined4 *)pointerPointerChar3 = *(undefined4 *)((long)pcVar46 + 0x10);\n                *(undefined4 *)((long)pointerPointerChar3 + 4) = unsignedVar4;\n                *(undefined4 *)(pointerPointerChar3 + 1) = unsignedVar1;\n                *(undefined4 *)((long)pointerPointerChar3 + 0xc) = unsignedVar2;\n                unsignedVar4 = *(undefined4 *)((long)((long)pcVar46 + 0x20) + 4);\n                unsignedVar1 = *(undefined4 *)((long)pcVar46 + 0x28);\n                unsignedVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x28) + 4);\n                unsignedVar5 = unsignedVar9 >> 1;\n                *(undefined4 *)(pointerPointerChar3 + 2) = *(undefined4 *)((long)pcVar46 + 0x20);\n                *(undefined4 *)((long)pointerPointerChar3 + 0x14) = unsignedVar4;\n                *(undefined4 *)(pointerPointerChar3 + 3) = unsignedVar1;\n                *(undefined4 *)((long)pointerPointerChar3 + 0x1c) = unsignedVar2;\n                if (unsignedVar5 != 2) {\n                  unsignedVar4 = *(undefined4 *)((long)((long)pcVar46 + 0x30) + 4);\n                  unsignedVar1 = *(undefined4 *)((long)pcVar46 + 0x38);\n                  unsignedVar2 = *(undefined4 *)((long)((long)pcVar46 + 0x38) + 4);\n                  *(undefined4 *)(pointerPointerChar3 + 4) = *(undefined4 *)((long)pcVar46 + 0x30);\n                  *(undefined4 *)((long)pointerPointerChar3 + 0x24) = unsignedVar4;\n                  *(undefined4 *)(pointerPointerChar3 + 5) = unsignedVar1;\n                  *(undefined4 *)((long)pointerPointerChar3 + 0x2c) = unsignedVar2;\n                  if (unsignedVar5 != 3) {\n                    unsignedVar10 = 3;\n                    do {\n                      unsignedVar11 = unsignedVar10 + 1;\n                      pointerChar2 = (char *)((long)pcVar46 + 0x83) + unsignedVar10 * 0x10 + -0x73;\n                      unsignedVar4 = *(undefined4 *)(pointerChar2 + 4);\n                      unsignedVar1 = *(undefined4 *)(pointerChar2 + 8);\n                      unsignedVar2 = *(undefined4 *)(pointerChar2 + 0xc);\n                      pointerPointerChar2 = pointerPointerChar3 + unsignedVar10 * 2;\n                      *(undefined4 *)pointerPointerChar2 = *(undefined4 *)pointerChar2;\n                      *(undefined4 *)((long)pointerPointerChar2 + 4) = unsignedVar4;\n                      *(undefined4 *)(pointerPointerChar2 + 1) = unsignedVar1;\n                      *(undefined4 *)((long)pointerPointerChar2 + 0xc) = unsignedVar2;\n                      unsignedVar10 = unsignedVar11;\n                    } while (unsignedVar11 != unsignedVar5);\n                  }\n                }\n                if ((unsignedVar9 & 1) != 0) {\n                  pointerPointerChar3[unsignedVar9 & 0xfffffffffffffffe] =\n                       *(char **)((long)localData2 + (unsignedVar9 & 0xfffffffffffffffe) * 8);\n                }\n              }\n              pointerPointerChar3 = pointerPointerChar3 + longVar + -2;\n            }\n            pointerFile = (FILE *)(ulong)(intVar - 1);\n            *pointerPointerChar3 = (char *)0x0;\n            pcVar46 = (char *)unaffectedRegister_2;\n          }\nLAB_001065a2:\n          while( true ) {\n            unsignedVar3 = (uint)unaffectedRegister_2;\n            uVar44 = getopt_long((ulong)pointerFile & 0xffffffff,pcVar46,pointerFile2,pointerPointerVoid,0);\n            unaffectedRegister_1 = (char *)pointerFile2;\n            if (uVar44 == 0xffffffff) break;\n            if (((uVar44 - 100 < 0x15) && ((0x117201UL >> ((ulong)(uVar44 - 100) & 0x3f) & 1) != 0))\n               && (DAT_0010d64c != 0)) goto LAB_001067f7;\n            pointerFile3 = (FILE *)pcVar46;\n            if (uVar44 < 0xcc) {\n                    /* WARNING: Could not recover jumptable at 0x001065eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              (*(code *)((long)(int *)pointerChar3 + (long)((int *)pointerChar3)[uVar44]))();\n              return;\n            }\nswitchD_00107462_caseD_1:\n            print_usage_0010342d(0);\n            pcVar46 = (char *)pointerFile3;\nswitchD_00107462_caseD_68:\n            _DAT_0010d658 = 1;\n          }\nLAB_00106680:\n          uVar44 = DAT_0010d64c;\n          pointerFile2 = (FILE *)unaffectedRegister_1;\n          if (DAT_0010d64c == 0) {\n            if (((DAT_0010d648 == 1) || (_DAT_0010d650 != 0)) ||\n               (((int)pointerFile <= _optind || (_optind < 1)))) {\n              uVar44 = 0;\n              goto LAB_001066aa;\n            }\n            pcVar46 = (char *)((long)pcVar46 + (long)_optind * 8 + -8);\n            unsignedVar3 = (int)pointerFile - (_optind + -1);\n            pointerFile = (FILE *)(ulong)unsignedVar3;\n            _optind = 0;\n            if (1 < (int)unsignedVar3) goto LAB_001063a3;\n            goto LAB_001065a2;\n          }\nLAB_001066aa:\n          unaffectedRegister_2 = (FILE *)((ulong)localData1 & 0xff);\n          unsignedVar3 = (uint)unaffectedRegister_2;\n          pointerPointerVoid = (undefined **)((int *)pcVar46 + (long)_optind * 2);\n          if (_DAT_0010d658 == 0) {\n            if (_DAT_0010d654 != 0) {\n              print_version_info_001075e0(&DAT_0010807c);\n              goto LAB_00107591;\n            }\n            if (_DAT_0010d650 == 0) {\n              pointerFile3 = (FILE *)pcVar46;\n              if (*pointerPointerVoid == (undefined *)0x0) goto switchD_00107462_caseD_1;\n              if (DAT_0010d64c == 7) {\n                if (DAT_0010d648 == 0) {\n                  if (uVar44 == 3) goto LAB_00106abc;\n                  if (uVar44 != 0) goto LAB_00106700;\nLAB_00106eff:\n                  pointerChar2 = \"no operation specified\";\n                  goto LAB_00106803;\n                }\n                DAT_0010d64c = 2;\n                if (_DAT_0010d644 != 0) goto LAB_0010704f;\n              }\n              else if ((uVar44 == 3) || (uVar44 == 0)) {\n                if (DAT_0010d648 == 1) {\n                  unsignedVar4 = check_and_print_file_info_00107650();\n                    \n                  xexit(unsignedVar4);\n                }\nLAB_00106abc:\n                if (uVar44 == 0) goto LAB_00106eff;\n                if (_DAT_0010d644 != 0) {\nLAB_00106ad1:\n                  pointerChar2 = \"`u\\' is only meaningful with the `r\\' option.\";\n                  goto LAB_00106803;\n                }\n              }\n              else {\nLAB_00106700:\n                if (_DAT_0010d644 != 0) goto LAB_00107548;\n              }\nLAB_0010670d:\n              if (_DAT_0010d2d0 < 0) {\n                _DAT_0010d2d0 = 1;\n              }\nLAB_00106720:\n              unaffectedRegister_1 = (char *)0x0;\n              if (DAT_0010d640 != 0) {\n                DAT_0010d638 = (long)*pointerPointerVoid;\n                unaffectedRegister_1 = (char *)0x1;\n                pointerChar2 = \"missing position arg.\";\n                if (DAT_0010d638 == 0) goto LAB_00106803;\n              }\n              if (DAT_0010d634 != '\\0') {\n                pointerChar2 = \"`N\\' is only meaningful with the `x\\' and `d\\' options.\";\n                if ((DAT_0010d64c & 0xfffffffb) == 1) {\n                  intVar = (int)unaffectedRegister_1;\n                  if (*(char **)((long)pointerPointerVoid + (long)intVar * 2 * 4) == (char *)0x0) {\n                    unsignedVar6 = dcgettext(0,\"`N\\' missing value.\",5);\n                    print_error_and_exit_00107690(unsignedVar6);\n                    uVar44 = extraOutputEDX;\nLAB_00107548:\n                    if (uVar44 == 2) {\nLAB_0010704f:\n                      pointerChar2 = \"`u\\' is not meaningful with the `D\\' option.\";\n                      if (_DAT_0010d2d0 < 1) goto code_r0x00107068;\n                      goto LAB_00106803;\n                    }\n                    goto LAB_00106ad1;\n                  }\n                  unaffectedRegister_1 = (char *)(ulong)(intVar + 1);\n                  longVar = strtol(*(char **)((long)pointerPointerVoid + (long)intVar * 2 * 4),(char **)0x0,10)\n                  ;\n                  pointerChar2 = \"Value for `N\\' must be positive.\";\n                  _DAT_0010d630 = (int)longVar;\n                  if (0 < _DAT_0010d630) goto LAB_0010673c;\n                }\n                goto LAB_00106803;\n              }\nLAB_0010673c:\n              longVar = (long)(int)unaffectedRegister_1;\n              pointerFile2 = (FILE *)unaffectedRegister_1;\n              if (*(long *)(int *)((long)pointerPointerVoid + longVar * 2 * 4) == 0)\n              goto switchD_00107462_caseD_1;\n              pointerFile2 = (FILE *)((long)pointerPointerVoid + (longVar + 1) * 2 * 4);\n              if (*(FILE **)pointerFile2 == (FILE *)0x0) {\n                pointerChar3 = (char *)0x0;\n                pointerFile2 = (FILE *)0x0;\n              }\n              else if (*(long *)((long)pointerPointerVoid + (longVar + 2) * 2 * 4) == 0) {\n                pointerChar3 = (char *)0x1;\n              }\n              else if (*(long *)((long)pointerPointerVoid + (longVar + 3) * 2 * 4) == 0) {\n                pointerChar3 = (char *)0x2;\n              }\n              else if (*(long *)((long)pointerPointerVoid + (longVar + 4) * 2 * 4) == 0) {\n                pointerChar3 = (char *)0x3;\n              }\n              else if (*(long *)((long)pointerPointerVoid + (longVar + 5) * 2 * 4) == 0) {\n                pointerChar3 = (char *)0x4;\n              }\n              else {\n                pointerFile = (FILE *)0x5;\n                do {\n                  pointerChar3 = (char *)pointerFile;\n                  pointerFile = (FILE *)((long)(int *)pointerChar3 + 1);\n                } while (*(long *)((int *)((long)pointerPointerVoid + longVar * 2 * 4) + (long)pointerFile * 2) !=\n                         0);\n              }\n              pointerUInt64_2 = (undefined8 *)parse_binary_file_00105300();\n              pointerFile = pointerFile2;\n              if (DAT_0010d64c == 5) {\n                pointerChar2 = \"`x\\' cannot be used on thin archives.\";\n                if ((*(byte *)((long)pointerUInt64_2 + 0x49) & 0x10) == 0) {\n                  unaffectedRegister_1 = (char *)pointerFile2;\n                  if (DAT_0010d628 != (char *)0x0) goto LAB_00106d5c;\nswitchD_00106ed8_caseD_5:\n                  reverse_entries_in_archive_00105480(pointerUInt64_2,extract_file_from_binary_00107740,unaffectedRegister_1,(ulong)pointerChar3 & 0xffffffff);\n                  goto LAB_0010696c;\n                }\n                goto LAB_00106803;\n              }\n              if (DAT_0010d628 != (char *)0x0) {\nLAB_00106d5c:\n                sizeVar = strlen(DAT_0010d628);\n                pcVar46 = \"__.LIBDEP\";\n                unaffectedRegister_1 = (char *)(sizeVar + 1);\n                DAT_0010d620 = bfd_create(\"__.LIBDEP\",pointerUInt64_2);\n                if (DAT_0010d620 == 0) {\n                  pointerChar2 = \"Cannot create libdeps record.\";\n                }\n                else {\n                  longVar = bfd_find_target(\"binary\",DAT_0010d620);\n                  pointerChar2 = \"Cannot set libdeps record type to binary.\";\n                  if (longVar != 0) {\n                    charVar = bfd_set_format(DAT_0010d620,1,5);\n                    pointerChar2 = \"Cannot set libdeps object format.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    charVar = bfd_make_writable(DAT_0010d620,\"Cannot set libdeps object format.\",5);\n                    pointerChar2 = \"Cannot make libdeps object writable.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    pointerFile3 = (FILE *)bfd_bwrite(DAT_0010d628,unaffectedRegister_1,DAT_0010d620);\n                    pointerChar2 = \"Cannot write libdeps record.\";\n                    if (pointerFile3 != (FILE *)unaffectedRegister_1) goto LAB_00106803;\n                    charVar = bfd_make_readable(DAT_0010d620,\"Cannot write libdeps record.\",5);\n                    pointerChar2 = \"Cannot make libdeps object readable.\";\n                    if (charVar == '\\0') goto LAB_00106803;\n                    longVar = bfd_find_target(\"plugin\",DAT_0010d620,5);\n                    pointerChar2 = \"Cannot reset libdeps record type.\";\n                    if (longVar == 0) goto LAB_00106803;\n                    intVar = (int)pointerChar3;\n                    localData1 = (FILE *)((long)(intVar + 2) * 8);\n                    unaffectedRegister_1 = (char *)xmalloc(localData1,\"Cannot reset libdeps record type.\");\n                    if (intVar == 0) {\n                      longVar = 0;\n                    }\n                    else {\n                      unsignedVar4 = *(undefined4 *)&pointerFile2->field_0x4;\n                      *(int *)unaffectedRegister_1 = pointerFile2->_flags;\n                      *(undefined4 *)((long)unaffectedRegister_1 + 4) = unsignedVar4;\n                      longVar = 8;\n                      pointerPointerChar2 = (char **)((long)unaffectedRegister_1 + 8);\n                      for (pointerChar3 = localData1[-1]._unused2 + 4; pointerChar3 != (char *)0x0;\n                          pointerChar3 = pointerChar3 + -1) {\n                        *(undefined *)pointerPointerChar2 = *(undefined *)&pointerFile2->_flags;\n                        pointerFile2 = (FILE *)((long)pointerFile2 + (ulong)bVar48 * -2 + 1);\n                        pointerPointerChar2 = (char **)((long)pointerPointerChar2 + (ulong)bVar48 * -2 + 1);\n                      }\n                    }\n                    *(char **)((long)(char **)unaffectedRegister_1 + longVar) = \"__.LIBDEP\";\n                    pointerChar3 = (char *)(ulong)(intVar + 1);\n                    *(undefined8 *)\n                     (((FILE *)((long)unaffectedRegister_1 + -0xd8))->_unused2 + 0xc + (long)localData1) = 0;\n                    switch(DAT_0010d64c) {\n                    case 1:\n                      goto switchD_00106ed8_caseD_1;\n                    case 2:\n                    case 7:\n                      break;\n                    case 3:\n                      goto switchD_00106ed8_caseD_3;\n                    case 4:\n                      goto switchD_00106ed8_caseD_4;\n                    case 5:\n                      goto switchD_00106ed8_caseD_5;\n                    case 6:\n                      pointerFile2 = (FILE *)unaffectedRegister_1;\n                      if (_DAT_0010d610 == 0) goto LAB_00106afb;\n                      break;\n                    default:\n                      goto switchD_001067e8_caseD_5;\n                    }\n                    goto switchD_00106ed8_caseD_2;\n                  }\n                }\n                goto LAB_00106803;\n              }\n              switch(DAT_0010d64c) {\n              case 1:\n                unaffectedRegister_1 = (char *)pointerFile2;\n                if (pointerFile2 == (FILE *)0x0) break;\nswitchD_00106ed8_caseD_1:\n                pointerFile = (FILE *)0x0;\n                goto LAB_00106b89;\n              case 2:\n              case 7:\nswitchD_001067e8_caseD_2:\n                unaffectedRegister_1 = (char *)pointerFile2;\n                if ((pointerFile2 != (FILE *)0x0) || (0 < DAT_0010d648)) {\nswitchD_00106ed8_caseD_2:\n                  process_binary_00105570(pointerUInt64_2,unaffectedRegister_1,DAT_0010d64c == 7);\n                  goto LAB_0010696c;\n                }\n                break;\n              case 3:\n                unaffectedRegister_1 = (char *)pointerFile2;\nswitchD_00106ed8_caseD_3:\n                reverse_entries_in_archive_00105480(pointerUInt64_2,FUNC_00107890,unaffectedRegister_1,(ulong)pointerChar3 & 0xffffffff);\n                goto LAB_0010696c;\n              case 4:\n                unaffectedRegister_1 = (char *)pointerFile2;\nswitchD_00106ed8_caseD_4:\n                reverse_entries_in_archive_00105480(pointerUInt64_2,extract_and_print_archive_00103a78,unaffectedRegister_1,(ulong)pointerChar3 & 0xffffffff);\n                goto LAB_0010696c;\n              default:\nswitchD_001067e8_caseD_5:\n                pointerChar2 = \"internal error -- this option not implemented\";\n                goto LAB_00106803;\n              case 6:\n                if (_DAT_0010d610 != 0) goto switchD_001067e8_caseD_2;\n                if (pointerFile2 == (FILE *)0x0) break;\nLAB_00106afb:\n                pointerFile = (FILE *)(pointerUInt64_2 + 0x1e);\n                do {\n                  unaffectedRegister_2 = pointerFile;\n                  if (*(FILE **)pointerFile2 == (FILE *)0x0) {\nLAB_00106b9f:\n                    extract_and_print_archive_file_info_001058b0(pointerUInt64_2);\n                    goto LAB_0010696c;\n                  }\n                  while( true ) {\n                    pointerLong2 = *(long **)unaffectedRegister_2;\n                    pcVar46 = *(char **)pointerFile2;\n                    if (pointerLong2 == (long *)0x0) {\n                      unsignedVar6 = *pointerUInt64_2;\n                      unsignedVar7 = dcgettext(0,\"no entry %s in archive %s!\",5);\n                      print_error_and_exit_00107690(unsignedVar7,pcVar46,unsignedVar6);\n                      pointerChar3 = (char *)0x0;\n                      goto LAB_00107293;\n                    }\n                    longVar = *pointerLong2;\n                    unsignedVar6 = extract_file_name_00105830(pcVar46,pointerUInt64_2);\n                    intVar = filename_cmp(unsignedVar6,longVar);\n                    if (intVar == 0) break;\n                    unaffectedRegister_2 = (FILE *)(*(long **)unaffectedRegister_2 + 0x1e);\n                  }\n                  *(long **)unaffectedRegister_2 = (long *)pointerLong2[0x1e];\n                  pointerPointerLong = (long **)find_last_match_00105870(pointerFile,3,0);\n                  bVar47 = DAT_0010d60c != 0;\n                  pointerLong = *pointerPointerLong;\n                  *pointerPointerLong = pointerLong2;\n                  pointerLong2[0x1e] = (long)pointerLong;\n                  if (bVar47) {\n                    printf(\"m - %s\\n\",*(FILE **)pointerFile2);\n                  }\n                  pointerFile2 = (FILE *)&pointerFile2->_IO_read_ptr;\n                } while( true );\n              }\n              goto LAB_00106d4e;\n            }\n            if (-1 < _DAT_0010d2d0) goto LAB_0010755f;\n          }\n          else {\nLAB_00107591:\n            print_usage_0010342d(1);\n          }\n          _DAT_0010d2d0 = 1;\nLAB_0010755f:\n          intVar = fileno(_stdin);\n          _DAT_0010d608 = isatty(intVar);\n          extract_and_print_entries_00103e95();\nLAB_0010696c:\n                    \n          xexit(0);\n        }\n        unsignedVar4 = bfd_get_error();\n        pointerFile2 = (FILE *)bfd_errmsg(unsignedVar4);\n        unsignedVar6 = dcgettext(0,\"can\\'t set BFD default target to `%s\\': %s\",5);\n        intVar = print_error_and_exit_00107690(unsignedVar6,\"x86_64-pc-linux-gnu\",pointerFile2);\nLAB_0010751b:\n        if (DAT_0010d64c == 0) {\nLAB_00107447:\n          pointerPointerVoid = (undefined **)pointerChar2;\n          pointerFile3 = (FILE *)pcVar46;\n          switch(intVar) {\n          case 0:\n            goto switchD_00107462_caseD_0;\n          default:\n            goto switchD_00107462_caseD_1;\n          case 0x44:\n            _DAT_0010d2d0 = 1;\n            goto LAB_001065a2;\n          case 0x4d:\n            _DAT_0010d650 = 1;\n            goto LAB_001065a2;\n          case 0x4e:\n            DAT_0010d634 = '\\x01';\n            goto LAB_001065a2;\n          case 0x4f:\n            _DAT_0010d5fc = 1;\n            goto LAB_001065a2;\n          case 0x50:\n            DAT_0010d5f9 = 1;\n            goto LAB_001065a2;\n          case 0x53:\n            DAT_0010d648 = -1;\n            goto LAB_001065a2;\n          case 0x54:\n            DAT_0010d5f8 = 1;\n            goto LAB_001065a2;\n          case 0x55:\n            _DAT_0010d2d0 = 0;\n            goto LAB_001065a2;\n          case 0x56:\n            _DAT_0010d654 = 1;\n            goto LAB_001065a2;\n          case 0x61:\n            DAT_0010d640 = 2;\n            goto LAB_001065a2;\n          case 0x62:\n          case 0x69:\n            DAT_0010d640 = 1;\n            goto LAB_001065a2;\n          case 99:\n            _DAT_0010d610 = 1;\n            goto LAB_001065a2;\n          case 100:\n            DAT_0010d64c = 1;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x66:\n            DAT_0010d5fa = 1;\n            goto LAB_001065a2;\n          case 0x68:\n            goto switchD_00107462_caseD_68;\n          case 0x6c:\n            if (DAT_0010d628 == (char *)0x0) {\n              DAT_0010d628 = _optarg;\n              goto LAB_001065a2;\n            }\nLAB_00107293:\n            unsignedVar3 = (uint)unaffectedRegister_2;\n            pointerChar2 = \"libdeps specified more than once\";\n            unaffectedRegister_1 = (char *)pointerFile2;\n            break;\n          case 0x6d:\n            DAT_0010d64c = 6;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x6f:\n            _DAT_0010d600 = 1;\n            goto LAB_001065a2;\n          case 0x70:\n            DAT_0010d64c = 4;\n            goto LAB_001065a2;\n          case 0x71:\n            DAT_0010d64c = 7;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x72:\n            DAT_0010d64c = 2;\n            DAT_0010d604 = 1;\n            goto LAB_001065a2;\n          case 0x73:\n            DAT_0010d648 = 1;\n            goto LAB_001065a2;\n          case 0x74:\n            DAT_0010d64c = 3;\n            goto LAB_001065a2;\n          case 0x75:\n            _DAT_0010d644 = 1;\n            goto LAB_001065a2;\n          case 0x76:\n            DAT_0010d60c = 1;\n            goto LAB_001065a2;\n          case 0x78:\n            DAT_0010d64c = 5;\n            goto LAB_001065a2;\n          case 0xc9:\n            bfd_plugin_set_plugin(_optarg);\n            goto LAB_001065a2;\n          case 0xca:\n            DAT_0010d5f0 = _optarg;\n            goto LAB_001065a2;\n          case 0xcb:\n            DAT_0010d5e8 = _optarg;\n            goto LAB_001065a2;\n          }\n          goto LAB_00106803;\n        }\nLAB_001067f7:\n        pointerChar2 = \"two different operation options specified\";\n        unaffectedRegister_1 = (char *)pointerFile2;\nLAB_00106803:\n        unsignedVar6 = dcgettext(0,pointerChar2,5);\n        print_error_and_exit_00107690(unsignedVar6);\nLAB_00106814:\n        intVar = (int)pcVar46;\n        pointerFile3 = (FILE *)xmalloc(8);\n        *(long **)pointerFile3 = (long *)0x0;\n        if ((FILE *)pointerChar3 == argv) {\nLAB_00106834:\n          if (*(long **)pointerChar3 == (long *)0x0) {\n            intVar = 0;\n          }\n          else {\n            longVar = 1;\n            do {\n              intVar = (int)longVar;\n              longVar3 = longVar * 2;\n              longVar = longVar + 1;\n            } while (*(long *)((int *)pointerChar3 + longVar3) != 0);\n          }\n          pointerFile2 = (FILE *)xmalloc((long)(intVar + 1) << 3);\n          pointerLong2 = *(long **)pointerChar3;\n          longVar = 0;\n          while (pointerLong2 != (long *)0x0) {\n            unsignedVar6 = xstrdup();\n            *(undefined8 *)((long)&pointerFile2->_flags + longVar) = unsignedVar6;\n            pointerLong2 = *(long **)((char *)((long)pointerChar3 + 0x83) + longVar + -0x7b);\n            longVar = longVar + 8;\n          }\n          *(undefined8 *)((long)&pointerFile2->_flags + longVar) = 0;\nLAB_0010610a:\n          intVar = (int)pcVar46;\n          pointerChar3 = (char *)pointerFile2;\n          if (*(long **)pointerFile3 == (long *)0x0) goto LAB_00106a80;\n          longVar = 0;\n          do {\n            longVar2 = longVar + 1;\n            longVar3 = longVar * 8;\n            longVar = longVar2;\n          } while (*(long *)(pointerFile3->_shortbuf + longVar3 + -0x7b) != 0);\n          localData5 = longVar2 * 8;\n        }\n        else {\nLAB_00106a80:\n          longVar2 = 0;\n          localData5 = 0;\n        }\n        longVar = (long)unaffectedRegister_1 * 2;\n        unaffectedRegister_1 = (char *)((long)(char **)unaffectedRegister_1 + longVar2);\n        free(*(void **)((int *)pointerChar3 + longVar));\n        pointerFile2 = (FILE *)xrealloc(pointerChar3,(longVar2 + 1 + (long)intVar) * 8);\n        uVar44 = intVar + -1 + (int)longVar2;\n        pcVar46 = (char *)(ulong)uVar44;\n        memmove(&pointerFile2->_flags + (long)unaffectedRegister_1 * 2,\n                (void *)((long)&pointerFile2->_IO_read_ptr + (long)localData1),\n                (long)(int)(intVar - unsignedVar3) << 3);\n        memcpy((void *)((long)&localData1->_flags + (long)&pointerFile2->_flags),pointerFile3,localData5);\n        free(pointerFile3);\n        free(localData3);\n        fclose(pointerFile);\n        unsignedVar3 = (int)localData2 + 1;\n        unaffectedRegister_2 = localData1;\n        pointerChar3 = (char *)pointerFile2;\n        localData1 = pointerFile3;\n        if ((int)unsignedVar3 < (int)uVar44) goto LAB_001061ce;\n      } while( true );\n    }\n    unsignedVar3 = unsignedVar3 + 1;\n    localData2 = unaffectedRegister_2;\nLAB_001061ce:\n    unaffectedRegister_2 = (FILE *)(ulong)unsignedVar3;\n  } while( true );\nswitchD_00107462_caseD_0:\n  intVar = getopt_long((ulong)pointerFile & 0xffffffff,pcVar46,pointerFile2,\"x86_64-pc-linux-gnu\");\n  unaffectedRegister_1 = (char *)pointerFile2;\n  if (intVar == -1) goto LAB_00106680;\n  if ((0x14 < intVar - 100U) || ((0x117201UL >> ((byte)(intVar - 100U) & 0x3f) & 1) == 0))\n  goto LAB_00107447;\n  goto LAB_0010751b;\ncode_r0x00107068:\n  if (_DAT_0010d2d0 != 0) goto code_r0x0010706e;\n  goto LAB_00106720;\ncode_r0x0010706e:\n  unsignedVar6 = dcgettext(0,\"`u\\' modifier ignored since `D\\' is the default (see `U\\')\",5);\n  print_error_message_00107920(unsignedVar6);\n  goto LAB_0010670d;\nLAB_00106b89:\n  if (*(FILE **)unaffectedRegister_1 == (FILE *)0x0) {\n    if ((char)pointerFile != '\\0') goto LAB_00106b9f;\nLAB_00106d4e:\n    DAT_0010d618 = 0;\n    goto LAB_0010696c;\n  }\n  iVar45 = 0;\n  intVar = strcmp((char *)*(FILE **)unaffectedRegister_1,\"__.SYMDEF\");\n  pointerUInt64 = pointerUInt64_2;\n  if (intVar == 0) {\n    *(byte *)((long)pointerUInt64_2 + 0x49) = *(byte *)((long)pointerUInt64_2 + 0x49) & 0xf7;\n    DAT_0010d648 = -1;\n  }\n  else {\n    while( true ) {\n      pointerLong2 = pointerUInt64 + 0x1e;\n      if ((undefined8 *)*pointerLong2 == (undefined8 *)0x0) break;\n      unsignedVar6 = *(undefined8 *)*pointerLong2;\n      unsignedVar7 = extract_file_name_00105830(*(FILE **)unaffectedRegister_1,pointerUInt64_2);\n      intVar = filename_cmp(unsignedVar7,unsignedVar6);\n      if ((intVar == 0) &&\n         ((DAT_0010d634 == '\\0' || (iVar45 = iVar45 + 1, iVar45 == _DAT_0010d630)))) {\n        if (DAT_0010d60c != 0) {\n          printf(\"d - %s\\n\",*(FILE **)unaffectedRegister_1);\n        }\n        *pointerLong2 = *(long *)(*pointerLong2 + 0xf0);\n        pointerFile = unaffectedRegister_2;\n        goto LAB_00106d38;\n      }\n      pointerUInt64 = (undefined8 *)*pointerLong2;\n    }\n    if (DAT_0010d60c != 0) {\n      pointerFile2 = *(FILE **)unaffectedRegister_1;\n      pcVar46 = (char *)dcgettext(0,\"No member named `%s\\'\\n\",5);\n      printf(pcVar46,pointerFile2);\n    }\n  }\nLAB_00106d38:\n  unaffectedRegister_1 = (char *)((long)unaffectedRegister_1 + 8);\n  goto LAB_00106b89;\n}\n\n",
            "called": [
                "xmalloc",
                "strlen",
                "fseek",
                "ftell",
                "fread",
                "memcpy",
                "FUN_00107cc0",
                "bfd_make_writable",
                "bfd_check_format_matches",
                "free",
                "setlocale",
                "FUN_00105830",
                "memmove",
                "FUN_00107c20",
                "bfd_make_readable",
                "FUN_00107640",
                "xexit",
                "FUN_0010394a",
                "FUN_00107890",
                "textdomain",
                "printf",
                "FUN_00103a78",
                "bfd_find_target",
                "isatty",
                "FUN_001052a0",
                "open",
                "bindtextdomain",
                "FUN_00103e95",
                "bfd_close",
                "stat",
                "strcmp",
                "bfd_create",
                "malloc",
                "bfd_plugin_set_program_name",
                "getopt_long",
                "bfd_set_format",
                "strtol",
                "xrealloc",
                "lbasename",
                "FUN_00107920",
                "FUN_0010342d",
                "fprintf",
                "bfd_set_error_program_name",
                "dcgettext",
                "bfd_get_error",
                "FUN_00103bd1",
                "filename_cmp",
                "bfd_fdopenr",
                "FUN_00105870",
                "bfd_set_error",
                "FUN_00107740",
                "bfd_set_default_target",
                "bfd_errmsg",
                "xmalloc_set_program_name",
                "FUN_00105570",
                "FUN_00105300",
                "bfd_init",
                "ferror",
                "fileno",
                "fopen",
                "FUN_001058b0",
                "FUN_00105480",
                "bfd_bwrite",
                "FUN_00107c10",
                "FUN_00107730",
                "FUN_00107650",
                "bfd_plugin_set_plugin",
                "FUN_00107690",
                "xstrdup",
                "FUN_001075e0",
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105db0",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "process_archive_00105db0"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102250",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "FUN_00103bd1": {
            "renaming": {
                "FUN_00103bd1": "print_matching_formats_00103bd1",
                "param_1": "formatsList",
                "__format": "formatString",
                "plVar2": "currentFormat",
                "uVar1": "dataValue"
            },
            "code": "\n\n\nvoid printMatchingFormats_00103bd1(long *formatsList)\n\n{\n  undefined8 dataValue;\n  char *formatString;\n  long *currentFormat;\n  \n  fflush(_stdout);\n  dataValue = DAT_0010d660;\n  formatString = (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,formatString,dataValue);\n  for (currentFormat = formatsList; *currentFormat != 0; currentFormat = currentFormat + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(formatsList);\n  fputc(10,_stderr);\n  return;\n}\n\n",
            "called": [
                "fputc",
                "free",
                "fflush",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103bd1",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_matching_formats_00103bd1"
        },
        "strcmp": {
            "renaming": {},
            "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 = strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
            "called": [
                "strcmp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "strcmp"
        },
        "FUN_00107c10": {
            "renaming": {
                "FUN_00107c10": "handle_error_and_exit_00107c10",
                "print_error_message_00107c20": "print_error_message",
                "xexit": "exit_code"
            },
            "code": "\nvoid handle_error_and_exit_00107c10(void)\n\n{\n  print_error_message();\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "FUN_00107c20",
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c10",
            "calling": [
                "FUN_00105300",
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_001058b0",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "handle_error_and_exit_00107c10"
        },
        "read": {
            "renaming": {},
            "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 = read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
            "called": [
                "read"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102290",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "read"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107da8",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "FUN_00102710": {
            "renaming": {
                "FUN_00102710": "extract_archived_files_00102710",
                "plVar1": "archive_pointer",
                "cVar2": "check_result",
                "bVar3": "bit_flag",
                "iVar4": "error_code",
                "lVar5": "file_pointer",
                "uVar6": "error_message",
                "uVar7": "library_name",
                "puVar8": "output_file_pointer",
                "unaff_RBP": "unaffected_register_BP",
                "in_stack_00000008": "input_stack_argument"
            },
            "code": "\n\n\nundefined8 * extract_archived_files_00102710(void)\n\n{\n  long *archive_pointer;\n  char check_result;\n  byte bit_flag;\n  int error_code;\n  long file_pointer;\n  undefined8 error_message;\n  undefined8 library_name;\n  undefined8 *output_file_pointer;\n  undefined8 unaffected_register_BP;\n  undefined8 input_stack_argument;\n  \n  file_pointer = bfd_openr();\n  if (file_pointer != 0) {\n    check_result = bfd_check_format(file_pointer,1);\n    if (check_result != '\\0') {\n      DAT_0010d5f0 = **(undefined8 **)(file_pointer + 8);\n    }\n    bfd_close(file_pointer);\n  }\n  output_file_pointer = (undefined8 *)bfd_openw();\n  if (((output_file_pointer != (undefined8 *)0x0) && (check_result = bfd_set_format(output_file_pointer,2), check_result != '\\0')) &&\n     (check_result = bfd_close(output_file_pointer), check_result != '\\0')) {\n    if (_DAT_0010d610 == 0) goto LAB_00102826;\n    goto LAB_001053b7;\n  }\n  handle_error_and_exit_00107c10();\n  do {\n    bit_flag = *(byte *)((long)output_file_pointer + 0x49) >> 4 & 1;\n    if (DAT_0010d5f8 == '\\0') {\n      if (bit_flag != 0) {\n        library_name = *output_file_pointer;\n        error_message = dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        print_error_and_exit_00107690(error_message,library_name);\n        goto LAB_00102812;\n      }\n    }\n    else if (bit_flag == 0) {\n      library_name = *output_file_pointer;\n      error_message = dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      print_error_and_exit_00107690(error_message,library_name);\nLAB_001027cb:\n      print_error_message_00107c20();\n      error_code = bfd_get_error();\n      if (error_code == 0xd) {\nLAB_00102812:\n        print_matching_formats_00103bd1(input_stack_argument);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      archive_pointer = output_file_pointer + 0x1e;\n      for (file_pointer = bfd_openr_next_archived_file(output_file_pointer,0); file_pointer != 0;\n          file_pointer = bfd_openr_next_archived_file(output_file_pointer,file_pointer)) {\n        *archive_pointer = file_pointer;\n        archive_pointer = (long *)(file_pointer + 0xf0);\n      }\n      *archive_pointer = 0;\n      error_code = bfd_get_error();\n      if (error_code == 9) {\n        return output_file_pointer;\n      }\n      do {\n        handle_error_and_exit_00107c10();\nLAB_00102826:\n        library_name = dcgettext(0,\"creating %s\",5);\n        print_error_message_00107920(library_name);\nLAB_001053b7:\n        DAT_0010d618 = unaffected_register_BP;\n        output_file_pointer = (undefined8 *)bfd_openr();\n      } while (output_file_pointer == (undefined8 *)0x0);\n      check_result = bfd_check_format_matches(output_file_pointer,2,&stack0x00000008);\n      if (check_result == '\\0') goto LAB_001027cb;\n    } while (((DAT_0010d64c != 2) && (DAT_0010d64c != 7)) ||\n            (file_pointer = bfd_openr_next_archived_file(output_file_pointer,0), file_pointer == 0));\n  } while( true );\n}\n\n",
            "called": [
                "bfd_check_format",
                "bfd_close",
                "bfd_openr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102710",
            "calling": [
                "FUN_00105300"
            ],
            "imported": false,
            "current_name": "extract_archived_files_00102710"
        },
        "FUN_00103e95": {
            "renaming": {
                "FUN_00103e95": "extract_and_print_entries_00103e95",
                "pplVar1": "double_pointer",
                "cVar2": "character",
                "ppFVar3": "double_pointer_to_file",
                "pFVar4": "file_pointer",
                "plVar5": "pointer_to_long",
                "uVar6": "unsigned_long",
                "pbVar7": "pointer_to_byte",
                "iVar8": "integer",
                "pcVar10": "pointer_to_character",
                "uVar11": "unsigned_long",
                "iVar9": "integer",
                "plVar12": "pointer_to_long",
                "sVar13": "size",
                "pvVar14": "pointer_to_void",
                "pcVar15": "pointer_to_character",
                "pcVar16": "pointer_to_character",
                "lVar17": "long",
                "lVar18": "long",
                "uVar19": "unsigned_long",
                "uVar20": "unsigned_integer",
                "lVar21": "long",
                "puVar22": "pointer_to_unsigned_long",
                "puVar23": "pointer_to_unsigned_long",
                "uVar24": "unsigned_integer",
                "iVar25": "integer",
                "uVar26": "unsigned_long",
                "ppcVar27": "double_pointer_to_character",
                "bVar28": "boolean",
                "ppcVar29": "double_pointer_to_character",
                "bVar30": "byte",
                "lVar31": "long",
                "pbVar32": "pointer_to_byte",
                "pbVar33": "pointer_to_byte",
                "piVar34": "pointer_to_integer",
                "pbVar35": "pointer_to_byte",
                "iVar37": "integer",
                "ppcVar38": "double_pointer_to_character",
                "bVar39": "byte",
                "local_828": "local_pointer_to_character",
                "local_820": "local_pointer_to_character",
                "local_818": "local_long",
                "local_810": "local_double_pointer_to_character",
                "local_800": "local_integer",
                "local_7fc": "local_unsigned_integer",
                "local_7f8": "local_pointer_to_byte",
                "local_7d0": "local_stat",
                "local_740": "local_character_array",
                "local_678": "local_character_double_pointer"
            },
            "code": "\n\n\nvoid extract_and_print_entries_00103e95(void)\n\n{\n  long **double_pointer;\n  char character;\n  FILE **double_pointer_to_file;\n  FILE *file_pointer;\n  long *pointer_to_long;\n  undefined8 unsigned_long;\n  byte *pointer_to_byte;\n  int integer;\n  char *pointer_to_character;\n  undefined8 unsigned_long;\n  int integer;\n  long *pointer_to_long;\n  size_t size;\n  void *pointer_to_void;\n  char *pointer_to_character;\n  char *pointer_to_character;\n  long long;\n  long long;\n  ulong unsigned_long;\n  uint unsigned_integer;\n  long long;\n  undefined8 *pointer_to_unsigned_long;\n  undefined8 *pointer_to_unsigned_long;\n  uint unsigned_integer;\n  int integer;\n  ulong unsigned_long;\n  char **double_pointer_to_character;\n  bool boolean;\n  char **double_pointer_to_character;\n  byte byte;\n  long long;\n  byte *pointer_to_byte;\n  byte *pointer_to_byte;\n  int *pointer_to_integer;\n  byte *pointer_to_byte;\n  uint uVar36;\n  int integer;\n  char **double_pointer_to_character;\n  byte byte;\n  undefined auVar40 [16];\n  undefined auVar41 [16];\n  char *local_pointer_to_character;\n  char *local_pointer_to_character;\n  long local_long;\n  char **local_double_pointer_to_character;\n  int local_integer;\n  uint local_unsigned_integer;\n  byte *local_pointer_to_byte;\n  stat local_stat;\n  char local_character_array [200];\n  char *local_character_double_pointer [201];\n  \n  byte = 0;\n  long = 0;\n  DAT_0010d550 = -2;\n  double_pointer_to_character = local_character_double_pointer;\n  local_integer = 0;\n  local_pointer_to_character = local_character_array;\n  local_long = 200;\n  local_pointer_to_character = local_pointer_to_character;\n  local_double_pointer_to_character = double_pointer_to_character;\nLAB_00103ee9:\n  *local_pointer_to_character = (char)long;\n  if (local_pointer_to_character + local_long + -1 <= local_pointer_to_character) {\n    long = (long)local_pointer_to_character - (long)local_pointer_to_character;\n    long = long + 1;\n    if (local_long < 10000) {\n      long = local_long * 2;\n      local_long = 10000;\n      if (long < 0x2711) {\n        local_long = long;\n      }\n      pointer_to_character = (char *)malloc(local_long * 9 + 7);\n      if (pointer_to_character != (char *)0x0) {\n        long = long * 8;\n        pointer_to_character = local_pointer_to_character;\n        pointer_to_character = pointer_to_character;\n        for (; long != 0; long = long + -1) {\n          *pointer_to_character = *pointer_to_character;\n          pointer_to_character = pointer_to_character + (ulong)byte * -2 + 1;\n          pointer_to_character = pointer_to_character + (ulong)byte * -2 + 1;\n        }\n        double_pointer_to_character = (char **)(pointer_to_character + local_long);\n        double_pointer_to_character = double_pointer_to_character;\n        for (; long != 0; long = long + -1) {\n          *(undefined *)double_pointer_to_character = *(undefined *)local_double_pointer_to_character;\n          local_double_pointer_to_character = (char **)((long)local_double_pointer_to_character + (ulong)byte * -2 + 1);\n          double_pointer_to_character = (char **)((long)double_pointer_to_character + (ulong)byte * -2 + 1);\n        }\n        if (local_pointer_to_character != local_character_array) {\n          free(local_pointer_to_character);\n        }\n        local_pointer_to_character = pointer_to_character + long;\n        double_pointer_to_character = double_pointer_to_character + long;\n        local_pointer_to_character = pointer_to_character;\n        local_double_pointer_to_character = double_pointer_to_character;\n        if (pointer_to_character + local_long + -1 <= local_pointer_to_character) goto LAB_00105265;\n        goto LAB_00103fd8;\n      }\n    }\n    print_syntax_error_001031a5();\nLAB_0010524c:\n    pointer_to_character = local_pointer_to_character;\n    if (local_pointer_to_character == local_character_array) {\n      return;\n    }\nLAB_00105265:\n    free(pointer_to_character);\n    return;\n  }\nLAB_00103fd8:\n  integer = (int)long;\n  if (integer == 3) goto LAB_0010524c;\n  character = (&DAT_0010a200)[integer];\n  if (character != -0xe) {\n    if (DAT_0010d550 == -2) {\n      if (_DAT_0010d540 == 0) {\n        _DAT_0010d540 = 1;\n        if (DAT_0010d5d0 == 0) {\n          DAT_0010d5d0 = 1;\n        }\n        if (DAT_0010d590 == (FILE *)0x0) {\n          DAT_0010d590 = _stdin;\n        }\n        if (DAT_0010d538 == (FILE *)0x0) {\n          DAT_0010d538 = _stdout;\n        }\n        if ((DAT_0010d5a8 == 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) == 0)) {\n          ensure_buffer_stack_00103df9();\n          pointer_to_unsigned_long = (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          unsigned_long = create_buffer_001033d6(DAT_0010d590);\n          *pointer_to_unsigned_long = unsigned_long;\n        }\n        initialize_data_001030ed();\n      }\nLAB_001040b1:\n      *DAT_0010d5b0 = DAT_0010d588;\n      pointer_to_byte = DAT_0010d5b0;\n      pointer_to_byte = DAT_0010d5b0;\n      unsigned_integer = DAT_0010d5d0;\nLAB_001040d4:\n      unsigned_long = (ulong)unsigned_integer;\n      unsigned_long = (ulong)local_unsigned_integer;\n      boolean = false;\n      do {\n        byte = (&DAT_0010ab00)[*pointer_to_byte];\n        if (*(short *)(&DAT_0010a980 + (long)(int)unsigned_long * 2) != 0) {\n          boolean = true;\n          unsigned_long = unsigned_long & 0xffffffff;\n          local_pointer_to_byte = pointer_to_byte;\n        }\n        while( true ) {\n          integer = (int)unsigned_long;\n          long = (long)(int)((int)*(short *)(&DAT_0010a640 + (long)integer * 2) + (uint)byte);\n          if (integer == *(short *)(&DAT_0010a440 + long * 2)) break;\n          unsigned_long = (ulong)(uint)(int)*(short *)(&DAT_0010a800 + (long)integer * 2);\n          if (0xb0 < *(short *)(&DAT_0010a800 + (long)integer * 2)) {\n            byte = (&DAT_0010a7c0)[(int)(uint)byte];\n          }\n        }\n        pointer_to_byte = pointer_to_byte + 1;\n        unsigned_long = (ulong)*(short *)(&DAT_0010a240 + long * 2);\n      } while (*(short *)(&DAT_0010a640 + unsigned_long * 2) != 0xc2);\n      local_unsigned_integer = (uint)unsigned_long;\n      pointer_to_byte = pointer_to_byte;\n      if (boolean) {\n        DAT_0010d5b8 = local_pointer_to_byte;\n        DAT_0010d5c0 = local_unsigned_integer;\n      }\nLAB_0010419f:\n      integer = (int)*(short *)(&DAT_0010a980 + (long)(int)unsigned_long * 2);\n      if (integer == 0) {\n        integer = (int)*(short *)(&DAT_0010a980 + (long)(int)DAT_0010d5c0 * 2);\n        pointer_to_byte = DAT_0010d5b8;\n      }\n      DAT_0010d530 = (int)pointer_to_byte - (int)pointer_to_byte;\n      DAT_0010d588 = *pointer_to_byte;\n      DAT_0010d5b0 = pointer_to_byte;\n      DAT_0010d5c8 = pointer_to_byte;\n      *pointer_to_byte = 0;\nLAB_001041f0:\n      pointer_to_byte = DAT_0010d5c8;\n      long = DAT_0010d5a0;\n      switch(integer) {\n      case 0:\n        goto switchD_00104200_caseD_0;\n      case 1:\n      case 0x10:\n        DAT_0010d550 = 0x105;\n        break;\n      case 2:\n      case 0x11:\n        DAT_0010d550 = 0x107;\n        break;\n      case 3:\n      case 0x12:\n        DAT_0010d550 = 0x108;\n        break;\n      case 4:\n      case 0x13:\n        DAT_0010d550 = 0x109;\n        break;\n      case 5:\n      case 0x14:\n        DAT_0010d550 = 0x10a;\n        break;\n      case 6:\n      case 0x15:\n        DAT_0010d550 = 0x10b;\n        break;\n      case 7:\n      case 0x16:\n        DAT_0010d550 = 0x10c;\n        break;\n      case 8:\n      case 0x17:\n        DAT_0010d550 = 0x10d;\n        break;\n      case 9:\n      case 0x18:\n        DAT_0010d550 = 0x10e;\n        break;\n      case 10:\n      case 0x19:\n        DAT_0010d550 = 0x10f;\n        break;\n      case 0xb:\n      case 0x1a:\n        DAT_0010d550 = 0x106;\n        break;\n      case 0xc:\n      case 0x1b:\n        DAT_0010d550 = 0x113;\n        break;\n      case 0xd:\n      case 0x1c:\n        DAT_0010d550 = 0x111;\n        break;\n      case 0xe:\n      case 0x1d:\n        DAT_0010d550 = 0x103;\n        break;\n      case 0x1f:\n        DAT_0010d554 = DAT_0010d554 + 1;\n        goto LAB_001040b1;\n      case 0x20:\n        DAT_0010d550 = 0x28;\n        break;\n      case 0x21:\n        DAT_0010d550 = 0x29;\n        break;\n      case 0x22:\n        DAT_0010d550 = 0x2c;\n        break;\n      case 0x23:\n        DAT_0010d548 = (char *)xstrdup(DAT_0010d5c8);\n        DAT_0010d550 = 0x104;\n        break;\n      case 0x24:\n      case 0x25:\n      case 0x26:\n        goto LAB_001040b1;\n      case 0x27:\n        DAT_0010d554 = DAT_0010d554 + 1;\n        DAT_0010d550 = 0x102;\n        break;\n      case 0x28:\n        fwrite(DAT_0010d5c8,(long)DAT_0010d530,1,DAT_0010d538);\n        goto LAB_001040b1;\n      case 0x29:\n        goto switchD_00104200_caseD_29;\n      case 0x2a:\n        DAT_0010d550 = 0;\n        break;\n      default:\n        report_error_and_exit_001033b0(\"fatal flex scanner internal error--no action found\");\n      case 0xf:\n      case 0x1e:\n        DAT_0010d550 = 0x112;\n      }\n      long = (long)integer;\n    }\n    if (0 < DAT_0010d550) {\n      if (DAT_0010d550 != 0x100) {\n        integer = 2;\n        if (DAT_0010d550 < 0x114) {\n          integer = (int)(char)(&DAT_0010a0e0)[DAT_0010d550];\n        }\n        goto LAB_0010497d;\n      }\n      DAT_0010d550 = 0x101;\n      goto LAB_001051f0;\n    }\n    integer = 0;\n    DAT_0010d550 = 0;\nLAB_0010497d:\n    unsigned_integer = character + integer;\n    if ((0x22 < unsigned_integer) || (integer != (char)(&DAT_0010a0a0)[(int)unsigned_integer])) goto LAB_001049db;\n    character = (&DAT_0010a060)[(int)unsigned_integer];\n    long = (long)character;\n    if (character < '\\x01') {\n      integer = -(int)character;\n      goto LAB_00104a0a;\n    }\n    DAT_0010d550 = -2;\n    local_integer = local_integer + -1 + (uint)(local_integer == 0);\n    double_pointer_to_character = double_pointer_to_character + 1;\n    *double_pointer_to_character = DAT_0010d548;\n    goto LAB_001049d1;\n  }\nLAB_001049db:\n  integer = (int)(char)(&DAT_0010a020)[(int)long];\n  if ((&DAT_0010a020)[(int)long] == '\\0') {\n    if (local_integer == 0) {\n      _DAT_0010d544 = _DAT_0010d544 + 1;\n      print_syntax_error_001031a5();\nLAB_001051f0:\n      do {\n        if (((((char)(&DAT_0010a200)[long] != -0xe) &&\n             (unsigned_integer = (int)(char)(&DAT_0010a200)[long] + 1, unsigned_integer < 0x23)) &&\n            ((&DAT_0010a0a0)[(int)unsigned_integer] == '\\x01')) &&\n           (long = (long)(char)(&DAT_0010a060)[(int)unsigned_integer],\n           '\\0' < (char)(&DAT_0010a060)[(int)unsigned_integer])) goto LAB_00105227;\n        if (local_pointer_to_character == local_pointer_to_character) goto LAB_0010524c;\n        local_pointer_to_character = local_pointer_to_character + -1;\n        double_pointer_to_character = double_pointer_to_character + -1;\n        long = (long)*local_pointer_to_character;\n      } while( true );\n    }\n    if (local_integer != 3) goto LAB_001051f0;\n    if (0 < DAT_0010d550) {\n      DAT_0010d550 = -2;\n      goto LAB_001051f0;\n    }\n    if (DAT_0010d550 != 0) goto LAB_001051f0;\n    goto LAB_0010524c;\n  }\nLAB_00104a0a:\n  unsigned_long = DAT_0010d660;\n  double_pointer_to_character = DAT_0010d558;\n  character = (&DAT_00109fe0)[integer];\n  double_pointer_to_character = (char **)double_pointer_to_character[1 - character];\n  switch(integer) {\n  case 2:\n  case 6:\n    check_and_print_ar_00103ba8();\n    break;\n  case 0x13:\n    if (DAT_0010d558 == (char **)0x0) {\n      return;\n    }\n    bfd_cache_close();\n    unlink(*DAT_0010d558);\n    return;\n  case 0x15:\n    print_syntax_error_001031a5();\n    break;\n  case 0x17:\n    pointer_to_unsigned_long = (undefined8 *)*double_pointer_to_character;\n    if (DAT_0010d558 == (char **)0x0) {\n      pointer_to_character = \"%s: no open archive\\n\";\nLAB_00104b62:\n      pointer_to_character = (char *)dcgettext(0,pointer_to_character,5);\n      fprintf(_stderr,pointer_to_character,unsigned_long);\n      check_and_exit_if_zero_0010315d();\n    }\n    else {\n      for (; pointer_to_unsigned_long != (undefined8 *)0x0; pointer_to_unsigned_long = (undefined8 *)pointer_to_unsigned_long[1]) {\n        for (pointer_to_unsigned_long = (undefined8 *)DAT_0010d558[0x1f]; pointer_to_unsigned_long != (undefined8 *)0x0;\n            pointer_to_unsigned_long = (undefined8 *)pointer_to_unsigned_long[0x1e]) {\n          integer = filename_cmp(*pointer_to_unsigned_long);\n          if (integer == 0) {\n            extract_file_from_binary_00107740();\n            goto LAB_00104adf;\n          }\n        }\n        bfd_openr(*pointer_to_unsigned_long,0);\n        unsigned_long = DAT_0010d660;\n        unsigned_long = *pointer_to_unsigned_long;\n        pointer_to_character = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointer_to_character,unsigned_long,unsigned_long);\nLAB_00104adf:\n      }\n    }\n    break;\n  case 0x18:\n    pointer_to_unsigned_long = (undefined8 *)*double_pointer_to_character;\n    if (DAT_0010d558 == (char **)0x0) {\nLAB_00104b4f:\n      pointer_to_character = \"%s: no open output archive\\n\";\n      goto LAB_00104b62;\n    }\n    for (; pointer_to_unsigned_long != (undefined8 *)0x0; pointer_to_unsigned_long = (undefined8 *)pointer_to_unsigned_long[1]) {\n      boolean = false;\n      double_pointer_to_character = DAT_0010d558 + 0x1f;\n      for (pointer_to_character = DAT_0010d558[0x1f]; pointer_to_character != (char *)0x0;\n          pointer_to_character = *(char **)(pointer_to_character + 0xf0)) {\n        integer = filename_cmp();\n        if (integer == 0) {\n          pointer_to_character = (char *)bfd_openr(*pointer_to_unsigned_long,0);\n          unsigned_long = DAT_0010d660;\n          if (pointer_to_character == (char *)0x0) {\n            unsigned_long = *pointer_to_unsigned_long;\n            pointer_to_character = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n            fprintf(_stderr,pointer_to_character,unsigned_long,unsigned_long);\n            check_and_exit_if_zero_0010315d();\n          }\n          else {\n            *double_pointer_to_character = pointer_to_character;\n            boolean = true;\n            *(undefined8 *)(pointer_to_character + 0xf0) = *(undefined8 *)(pointer_to_character + 0xf0);\n          }\n        }\n        else {\n          double_pointer_to_character = (char **)(pointer_to_character + 0xf0);\n        }\n      }\n      if (!boolean) {\n        pointer_to_character = (char *)bfd_openr(*pointer_to_unsigned_long,0);\n        unsigned_long = DAT_0010d660;\n        unsigned_long = *pointer_to_unsigned_long;\n        pointer_to_character = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointer_to_character,unsigned_long,unsigned_long);\n        unsigned_long = DAT_0010d660;\n        if (pointer_to_character == (char *)0x0) {\n          unsigned_long = *pointer_to_unsigned_long;\n          pointer_to_character = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n          fprintf(_stderr,pointer_to_character,unsigned_long,unsigned_long);\n          check_and_exit_if_zero_0010315d();\n        }\n        else {\n          *double_pointer_to_character = pointer_to_character;\n        }\n      }\n    }\n    break;\n  case 0x19:\n    if (DAT_0010d558 != (char **)0x0) {\n      DAT_0010d558[0x1f] = (char *)0x0;\n    }\n    break;\n  case 0x1a:\n    pointer_to_unsigned_long = (undefined8 *)*double_pointer_to_character;\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    for (; pointer_to_unsigned_long != (undefined8 *)0x0; pointer_to_unsigned_long = (undefined8 *)pointer_to_unsigned_long[1]) {\n      boolean = false;\n      double_pointer_to_character = DAT_0010d558 + 0x1f;\n      for (pointer_to_unsigned_long = (undefined8 *)DAT_0010d558[0x1f]; unsigned_long = DAT_0010d660,\n          pointer_to_unsigned_long != (undefined8 *)0x0; pointer_to_unsigned_long = (undefined8 *)pointer_to_unsigned_long[0x1e]) {\n        integer = filename_cmp(*pointer_to_unsigned_long,*pointer_to_unsigned_long);\n        if (integer == 0) {\n          boolean = true;\n          *double_pointer_to_character = (char *)pointer_to_unsigned_long[0x1e];\n        }\n        else {\n          double_pointer_to_character = (char **)(pointer_to_unsigned_long + 0x1e);\n        }\n      }\n      if (!boolean) {\n        unsigned_long = *pointer_to_unsigned_long;\n        pointer_to_character = (char *)dcgettext(0,\"%s: can\\'t find module file %s\\n\",5);\n        fprintf(_stderr,pointer_to_character,unsigned_long,unsigned_long);\n        check_and_exit_if_zero_0010315d();\n      }\n    }\n    break;\n  case 0x1b:\n    pointer_to_unsigned_long = (undefined8 *)*double_pointer_to_character;\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    for (; pointer_to_unsigned_long != (undefined8 *)0x0; pointer_to_unsigned_long = (undefined8 *)pointer_to_unsigned_long[1]) {\n      pointer_to_character = (char *)bfd_openr(*pointer_to_unsigned_long,\"plugin\");\n      unsigned_long = DAT_0010d660;\n      double_pointer_to_character = DAT_0010d558;\n      if (pointer_to_character == (char *)0x0) {\n        unsigned_long = *pointer_to_unsigned_long;\n        pointer_to_character = (char *)dcgettext(0,\"%s: can\\'t open file %s\\n\",5);\n        fprintf(_stderr,pointer_to_character,unsigned_long,unsigned_long);\n        check_and_exit_if_zero_0010315d();\n      }\n      else {\n        *(char **)(pointer_to_character + 0xf0) = DAT_0010d558[0x1f];\n        double_pointer_to_character[0x1f] = pointer_to_character;\n      }\n    }\n    break;\n  case 0x1c:\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    pointer_to_character = *DAT_0010d558;\n    DAT_0010d60c = 1;\n    DAT_0010d578 = _stdout;\n    pointer_to_character = (char *)dcgettext(0,\"Current open archive is %s\\n\",5);\n    printf(pointer_to_character,pointer_to_character);\n    for (pointer_to_character = DAT_0010d558[0x1f]; pointer_to_character != (char *)0x0; pointer_to_character = *(char **)(pointer_to_character + 0xf0))\n    {\n      print_file_info_00103ddc(pointer_to_character,0);\n    }\n    break;\n  case 0x1d:\n    if (DAT_0010d558 == (char **)0x0) goto LAB_00104b4f;\n    if (0 < _DAT_0010d2d0) {\n      *(uint *)((long)DAT_0010d558 + 0x44) = *(uint *)((long)DAT_0010d558 + 0x44) | 0x2000;\n    }\n    DAT_0010d568 = dup(DAT_0010d568);\n    bfd_close(double_pointer_to_character);\n    pointer_to_character = DAT_0010d570;\n    integer = stat(DAT_0010d570,&local_stat);\n    if ((integer != 0) && (DAT_0010d558 = (char **)bfd_openw(pointer_to_character,0), DAT_0010d558 != (char **)0x0)\n       ) {\n      bfd_set_format(DAT_0010d558,2);\n      bfd_close(DAT_0010d558);\n    }\n    copy_and_replace_file_00105bc0(DAT_0010d560,DAT_0010d570,DAT_0010d568);\n    DAT_0010d558 = (char **)0x0;\n    free(DAT_0010d560);\n    free(DAT_0010d570);\n    break;\n  case 0x1e:\n    create_bfd_archive_00103c60(*double_pointer_to_character,0);\n    break;\n  case 0x1f:\n    create_bfd_archive_00103c60(*double_pointer_to_character,1);\n    break;\n  case 0x20:\n    pointer_to_character = *double_pointer_to_character;\n    if (DAT_0010d558 == (char **)0x0) {\n      pointer_to_character = \"%s: no output archive specified yet\\n\";\n      goto LAB_00104b62;\n    }\n    long = parse_binary_file_00105300(double_pointer_to_character[-1],0);\n    if (long != 0) {\n      extract_and_print_entries_00103e95_001032a8(long,copy_data_0010312d,pointer_to_character);\n    }\n    break;\n  case 0x21:\n    pointer_to_character = *double_pointer_to_character;\n    pointer_to_character = double_pointer_to_character[-1];\n    unsigned_long = parse_binary_file_00105300(double_pointer_to_character[-2],0);\n    if (pointer_to_character == (char *)0x0) {\n      DAT_0010d578 = _stdout;\n    }\n    else {\n      DAT_0010d578 = fopen(pointer_to_character,\"w\");\n      if (DAT_0010d578 != (FILE *)0x0) {\n        extract_and_print_entries_00103e95_001032a8(unsigned_long,print_file_info_00103ddc,pointer_to_character);\n        bfd_close(unsigned_long);\n        fclose(DAT_0010d578);\n        break;\n      }\n      DAT_0010d578 = _stdout;\n      pointer_to_character = (char *)dcgettext(0,\"Can\\'t open file %s\\n\",5);\n      fprintf(_stderr,pointer_to_character,pointer_to_character);\n    }\n    extract_and_print_entries_00103e95_001032a8(unsigned_long,print_file_info_00103ddc,pointer_to_character);\n    bfd_close(unsigned_long);\n    break;\n  case 0x22:\n    double_pointer_to_character = (char **)*double_pointer_to_character;\n    break;\n  case 0x23:\n  case 0x25:\n  case 0x27:\n    double_pointer_to_character = (char **)0x0;\n    break;\n  case 0x24:\n    double_pointer_to_character = (char **)double_pointer_to_character[-1];\n    break;\n  case 0x26:\n    double_pointer_to_character = (char **)malloc(0x10);\n    pointer_to_character = double_pointer_to_character[-2];\n    *double_pointer_to_character = *double_pointer_to_character;\n    double_pointer_to_character[1] = pointer_to_character;\n    break;\n  case 0x2a:\n    DAT_0010d60c = (uint)(DAT_0010d60c == 0);\n  }\n  long = (long)character;\n  local_pointer_to_character = local_pointer_to_character + -long;\n  double_pointer_to_character[1 - long] = (char *)double_pointer_to_character;\n  double_pointer_to_character = double_pointer_to_character + (1 - long);\n  unsigned_integer = (int)(char)(&DAT_00109f80)[(char)(&DAT_00109fa0)[integer] + -0x18] + (int)*local_pointer_to_character;\n  if ((unsigned_integer < 0x23) && (*local_pointer_to_character == (&DAT_0010a0a0)[(int)unsigned_integer])) {\n    long = (long)(char)(&DAT_0010a060)[(int)unsigned_integer];\n  }\n  else {\n    long = (long)(char)(&DAT_00109f60)[(char)(&DAT_00109fa0)[integer] + -0x18];\n  }\n  goto LAB_001049d1;\nswitchD_00104200_caseD_29:\n  integer = ((int)pointer_to_byte - (int)DAT_0010d5c8) + -1;\n  *pointer_to_byte = DAT_0010d588;\n  double_pointer = (long **)(DAT_0010d5a8 + long * 8);\n  double_pointer_to_file = (FILE **)*double_pointer;\n  if (*(int *)(double_pointer_to_file + 7) == 0) {\n    DAT_0010d598 = *(uint *)((long)double_pointer_to_file + 0x1c);\n    *(undefined4 *)(double_pointer_to_file + 7) = 1;\n    *double_pointer_to_file = DAT_0010d590;\n  }\n  pointer_to_byte = DAT_0010d5b0;\n  file_pointer = double_pointer_to_file[1];\n  auVar40._8_8_ = file_pointer;\n  auVar40._0_8_ = double_pointer_to_file;\n  if ((byte *)((long)&file_pointer->_flags + (long)(int)DAT_0010d598) < DAT_0010d5b0) {\n    if ((byte *)((long)&file_pointer->_flags + (long)(int)DAT_0010d598 + 1) < DAT_0010d5b0) {\n      auVar40 = report_error_and_exit_001033b0();\n    }\n    if (*(int *)(auVar40._0_8_ + 0x34) != 0) {\n      unsigned_integer = (int)((long)pointer_to_byte - (long)pointer_to_byte) - 1;\n      for (long = 0; (int)long < (int)unsigned_integer; long = long + 1) {\n        *(byte *)(auVar40._8_8_ + long) = pointer_to_byte[long];\n      }\n      pointer_to_long = *double_pointer;\n      if (*(int *)(pointer_to_long + 7) == 2) {\n        DAT_0010d598 = 0;\n        *(undefined4 *)((long)pointer_to_long + 0x1c) = 0;\nLAB_0010475e:\n        file_pointer = DAT_0010d590;\n        if (unsigned_integer == 0) {\n          if ((DAT_0010d5a8 == 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) == 0)) {\n            ensure_buffer_stack_00103df9();\n            pointer_to_unsigned_long = (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n            unsigned_long = create_buffer_001033d6(file_pointer);\n            *pointer_to_unsigned_long = unsigned_long;\n          }\n          long = DAT_0010d5a8;\n          if (DAT_0010d5a8 != 0) {\n            long = *(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          }\n          integer = 1;\n          initialize_file_001031cf(long);\n          initialize_data_001030ed();\n        }\n        else {\n          integer = 2;\n          *(undefined4 *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x38) = 2;\n        }\n      }\n      else {\n        while( true ) {\n          pointer_to_long = *double_pointer;\n          unsigned_integer = ~unsigned_integer + *(int *)(pointer_to_long + 3);\n          if (0 < (int)unsigned_integer) break;\n          unsigned_integer = (int)DAT_0010d5b0 - (int)(void *)pointer_to_long[1];\n          if (*(int *)(pointer_to_long + 4) == 0) {\n            pointer_to_long[1] = 0;\nLAB_00104626:\n            report_error_and_exit_001033b0();\n            break;\n          }\n          integer = *(int *)(pointer_to_long + 3);\n          integer = integer;\n          if (integer < 1) {\n            integer = integer / 8;\n          }\n          *(int *)(pointer_to_long + 3) = integer + integer;\n          pointer_to_void = realloc((void *)pointer_to_long[1],(long)(integer + integer + 2));\n          pointer_to_long[1] = (long)pointer_to_void;\n          if (pointer_to_void == (void *)0x0) goto LAB_00104626;\n          DAT_0010d5b0 = (byte *)((long)pointer_to_void + (long)(int)unsigned_integer);\n          pointer_to_long = *double_pointer;\n        }\n        if (0x2000 < (int)unsigned_integer) {\n          unsigned_integer = 0x2000;\n        }\n        unsigned_long = (ulong)unsigned_integer;\n        if (*(int *)((long)pointer_to_long + 0x24) == 0) {\n          pointer_to_integer = __errno_location();\n          unsigned_long = (ulong)(int)unsigned_integer;\n          unsigned_long = (ulong)(int)unsigned_integer;\n          *pointer_to_integer = 0;\n          goto LAB_001046c7;\n        }\n        unsigned_long = 0;\n        pointer_to_integer = (int *)(long)(int)unsigned_integer;\n        do {\n          integer = getc(DAT_0010d590);\n          uVar36 = (uint)unsigned_long;\n          if (integer == -1) {\n            integer = ferror(DAT_0010d590);\n            unsigned_integer = uVar36;\n            if (integer != 0) {\n              do {\n                pointer_to_character = \"input in flex scanner failed\";\n                report_error_and_exit_001033b0();\n                do {\n                  *pointer_to_integer = 0;\n                  clearerr((FILE *)pointer_to_character);\nLAB_001046c7:\n                  size = fread((void *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)\n                                         + unsigned_long),1,unsigned_long,DAT_0010d590);\n                  pointer_to_character = (char *)DAT_0010d590;\n                  DAT_0010d598 = (uint)size;\n                  unsigned_integer = DAT_0010d598;\n                  if ((DAT_0010d598 != 0) ||\n                     (integer = ferror(DAT_0010d590), unsigned_integer = DAT_0010d598, integer == 0))\n                  goto LAB_00104738;\n                } while (*pointer_to_integer == 4);\n              } while( true );\n            }\n            break;\n          }\n          if (integer == 10) {\n            *(undefined *)\n             ((long)(int *)(long)(int)unsigned_integer +\n             (long)(int)uVar36 + *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)) = 10;\n            unsigned_integer = uVar36 + 1;\n            break;\n          }\n          unsigned_long = (ulong)(uVar36 + 1);\n          *(char *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8) + (long)pointer_to_integer) =\n               (char)integer;\n          pointer_to_integer = (int *)((long)pointer_to_integer + 1);\n        } while (unsigned_integer != uVar36 + 1);\nLAB_00104738:\n        DAT_0010d598 = unsigned_integer;\n        unsigned_integer = DAT_0010d598;\n        integer = 0;\n        *(uint *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x1c) = DAT_0010d598;\n        if (unsigned_integer == 0) goto LAB_0010475e;\n      }\n      pointer_to_long = (long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n      long = *pointer_to_long;\n      unsigned_integer = unsigned_integer + DAT_0010d598;\n      if (*(int *)(long + 0x18) < (int)unsigned_integer) {\n        integer = ((int)DAT_0010d598 >> 1) + unsigned_integer;\n        pointer_to_void = realloc(*(void **)(long + 8),(long)integer);\n        *(void **)(long + 8) = pointer_to_void;\n        auVar41._8_8_ = pointer_to_long;\n        auVar41._0_8_ = *pointer_to_long;\n        if (*(long *)(*pointer_to_long + 8) == 0) {\n          auVar41 = report_error_and_exit_001033b0();\n        }\n        pointer_to_long = auVar41._8_8_;\n        *(int *)(auVar41._0_8_ + 0x18) = integer + -2;\n      }\n      DAT_0010d598 = unsigned_integer;\n      *(undefined *)(*(long *)(*pointer_to_long + 8) + (long)(int)unsigned_integer) = 0;\n      *(undefined *)(*(long *)(*pointer_to_long + 8) + 1 + (long)(int)unsigned_integer) = 0;\n      pointer_to_byte = *(byte **)(*pointer_to_long + 8);\n      DAT_0010d5c8 = pointer_to_byte;\n      if (integer == 1) goto LAB_001048a4;\n      if (integer == 2) goto LAB_001048ca;\n      pointer_to_byte = pointer_to_byte + integer;\n      DAT_0010d5b0 = pointer_to_byte;\n      unsigned_integer = find_modified_bytes_0010300e();\n      goto LAB_001040d4;\n    }\n    if ((long)pointer_to_byte - (long)pointer_to_byte == 1) goto LAB_001048a4;\nLAB_001048ca:\n    pointer_to_byte = (byte *)((long)(int)DAT_0010d598 +\n                      *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8));\n    DAT_0010d5b0 = pointer_to_byte;\n    unsigned_long = find_modified_bytes_0010300e();\n    pointer_to_byte = DAT_0010d5c8;\n    goto LAB_0010419f;\n  }\n  pointer_to_byte = pointer_to_byte + integer;\n  DAT_0010d5b0 = pointer_to_byte;\n  unsigned_long = find_modified_bytes_0010300e();\n  if (*(short *)(&DAT_0010a980 + (long)(int)(uint)unsigned_long * 2) != 0) {\n    DAT_0010d5b8 = pointer_to_byte;\n    DAT_0010d5c0 = (uint)unsigned_long;\n  }\n  unsigned_long = unsigned_long & 0xffffffff;\n  while( true ) {\n    integer = (int)unsigned_long;\n    if (integer == *(short *)(&DAT_0010a440 +\n                           (long)(*(short *)(&DAT_0010a640 + (long)integer * 2) + 1) * 2)) break;\n    unsigned_long = (ulong)(uint)(int)*(short *)(&DAT_0010a800 + (long)integer * 2);\n  }\n  unsigned_integer = (uint)*(short *)(&DAT_0010a240 +\n                           (long)(*(short *)(&DAT_0010a640 + (long)integer * 2) + 1) * 2);\n  pointer_to_byte = pointer_to_byte;\n  if ((*(short *)(&DAT_0010a240 + (long)(*(short *)(&DAT_0010a640 + (long)integer * 2) + 1) * 2) == 0)\n     || (unsigned_integer == 0xb0)) goto LAB_0010419f;\n  pointer_to_byte = pointer_to_byte + 1;\n  goto LAB_001040d4;\nLAB_001048a4:\n  DAT_0010d5b0 = DAT_0010d5c8;\n  integer = (int)(DAT_0010d5d0 - 1) / 2 + 0x2a;\n  goto LAB_001041f0;\nswitchD_00104200_caseD_0:\n  *pointer_to_byte = DAT_0010d588;\n  unsigned_long = (ulong)DAT_0010d5c0;\n  pointer_to_byte = DAT_0010d5b8;\n  goto LAB_0010419f;\nLAB_00105227:\n  double_pointer_to_character = double_pointer_to_character + 1;\n  local_integer = 3;\n  *double_pointer_to_character = DAT_0010d548;\nLAB_001049d1:\n  local_pointer_to_character = local_pointer_to_character + 1;\n  goto LAB_00103ee9;\n}\n\n",
            "called": [
                "FUN_00103c60",
                "filename_cmp",
                "FUN_001033d6",
                "bfd_openw",
                "FUN_001031cf",
                "FUN_00107740",
                "fread",
                "FUN_00105300",
                "FUN_001030ed",
                "FUN_00105bc0",
                "free",
                "ferror",
                "dup",
                "fwrite",
                "printf",
                "FUN_0010315d",
                "fopen",
                "bfd_close",
                "stat",
                "clearerr",
                "FUN_00103df9",
                "malloc",
                "FUN_0010312d",
                "FUN_001031a5",
                "FUN_0010300e",
                "realloc",
                "FUN_00103ba8",
                "bfd_cache_close",
                "xstrdup",
                "FUN_001033b0",
                "bfd_openr",
                "bfd_set_format",
                "FUN_00103ddc",
                "fprintf",
                "fclose",
                "dcgettext",
                "FUN_001032a8",
                "unlink",
                "__errno_location",
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103e95",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_and_print_entries_00103e95"
        },
        "bfd_init": {
            "renaming": {},
            "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
            "called": [
                "bfd_init"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022b0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_init"
        },
        "strerror": {
            "renaming": {},
            "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strerror(__errnum);\n  return pcVar1;\n}\n\n",
            "called": [
                "strerror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102550",
            "calling": [
                "FUN_00102c25",
                "FUN_00102f1e",
                "FUN_00103c60",
                "FUN_001025a0",
                "FUN_00102fd7",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "strerror"
        },
        "FUN_00107cc0": {
            "renaming": {
                "FUN_00107cc0": "execute_functions_00107cc0",
                "plVar4": "functionList",
                "lVar1": "index",
                "lVar2": "prevIndex",
                "lVar3": "tempIndex",
                "uVar5": "loopCounter"
            },
            "code": "\nvoid executeFunctions_00107cc0(void)\n\n{\n  long index;\n  long prevIndex;\n  long tempIndex;\n  long *functionList;\n  uint loopCounter;\n  \n  functionList = (long *)PTR_DAT_0010d2e0;\n  if (PTR_DAT_0010d2e0 != (undefined *)0x0) {\n    do {\n      loopCounter = *(int *)(functionList + 1) - 1;\n      if (-1 < (int)loopCounter) {\n        index = (long)(int)loopCounter;\n        loopCounter = loopCounter & 7;\n        (*(code *)functionList[index + 2])();\n        prevIndex = index + -1;\n        if (-1 < (int)prevIndex) {\n          tempIndex = prevIndex;\n          if (loopCounter != 0) {\n            if (loopCounter != 1) {\n              if (loopCounter != 2) {\n                if (loopCounter != 3) {\n                  if (loopCounter != 4) {\n                    if (loopCounter != 5) {\n                      if (loopCounter != 6) {\n                        (*(code *)functionList[index + 1])();\n                        prevIndex = index + -2;\n                      }\n                      (*(code *)functionList[prevIndex + 2])();\n                      prevIndex = prevIndex + -1;\n                    }\n                    (*(code *)functionList[prevIndex + 2])();\n                    prevIndex = prevIndex + -1;\n                  }\n                  (*(code *)functionList[prevIndex + 2])();\n                  prevIndex = prevIndex + -1;\n                }\n                (*(code *)functionList[prevIndex + 2])();\n                prevIndex = prevIndex + -1;\n              }\n              (*(code *)functionList[prevIndex + 2])();\n              prevIndex = prevIndex + -1;\n            }\n            (*(code *)functionList[prevIndex + 2])();\n            tempIndex = prevIndex + -1;\n            if ((int)(prevIndex + -1) < 0) goto LAB_00107d96;\n          }\n          do {\n            (*(code *)functionList[tempIndex + 2])();\n            index = tempIndex + -1;\n            (*(code *)functionList[tempIndex + 1])();\n            (*(code *)functionList[tempIndex])();\n            (*(code *)functionList[index])();\n            (*(code *)functionList[tempIndex + -2])();\n            (*(code *)functionList[tempIndex + -3])();\n            (*(code *)functionList[tempIndex + -4])();\n            (*(code *)functionList[tempIndex + -5])();\n            tempIndex = tempIndex + -8;\n          } while (-1 < (int)index + -7);\n        }\n      }\nLAB_00107d96:\n      functionList = (long *)*functionList;\n    } while (functionList != (long *)0x0);\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107cc0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "execute_functions_00107cc0"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "FUN_00103e95",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "FUN_00105ae0": {
            "renaming": {
                "FUN_00105ae0": "process_files_in_archive_00105ae0",
                "param_1": "archive_ptr",
                "param_2": "file_ptr",
                "param_3": "undefined_1",
                "param_4": "undefined_2"
            },
            "code": "\nvoid process_files_in_archive_00105ae0(undefined8 archive_ptr,undefined8 file_ptr,undefined undefined_1,undefined undefined_2)\n\n{\n  process_files_in_archive_00105ae0_00105af0(archive_ptr,file_ptr,undefined_1,undefined_2);\n  return;\n}\n\n",
            "called": [
                "FUN_00105af0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105ae0",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "process_files_in_archive_00105ae0"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(process_archive_00105db0,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "__libc_start_main",
                "FUN_00105db0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105cc0",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "FUN_00107690": {
            "renaming": {
                "FUN_00107690": "print_error_and_exit_00107690",
                "param_1": "error_code",
                "in_AL": "input_condition",
                "local_d8": "local_variable1",
                "local_d4": "local_variable2",
                "local_d0": "local_pointer1",
                "local_c8": "local_pointer2",
                "local_b8": "local_array1",
                "local_b0": "local_param10",
                "local_a8": "local_param11",
                "local_a0": "local_param12",
                "local_98": "local_param13",
                "local_90": "local_param14",
                "local_88": "local_1",
                "local_78": "local_2",
                "local_68": "local_3",
                "local_58": "local_4",
                "local_48": "local_5",
                "local_38": "local_6",
                "local_28": "local_7",
                "local_18": "local_8",
                "print_error_message_001078c0": "print_error_message",
                "xexit": "exit_program"
            },
            "code": "\nvoid print_error_and_exit_00107690(undefined4 error_code,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 error_code0,undefined8 error_code1,undefined8 error_code2,\n                 undefined8 error_code3,undefined8 error_code4)\n\n{\n  char input_condition;\n  undefined4 local_variable1;\n  undefined4 local_variable2;\n  undefined *local_pointer1;\n  undefined *local_pointer2;\n  undefined local_array1 [8];\n  undefined8 local_param10;\n  undefined8 local_param11;\n  undefined8 local_param12;\n  undefined8 local_param13;\n  undefined8 local_param14;\n  undefined4 local_1;\n  undefined4 local_2;\n  undefined4 local_3;\n  undefined4 local_4;\n  undefined4 local_5;\n  undefined4 local_6;\n  undefined4 local_7;\n  undefined4 local_8;\n  \n  if (input_condition != '\\0') {\n    local_1 = error_code;\n    local_2 = param_2;\n    local_3 = param_3;\n    local_4 = param_4;\n    local_5 = param_5;\n    local_6 = param_6;\n    local_7 = param_7;\n    local_8 = param_8;\n  }\n  local_pointer1 = &stack0x00000008;\n  local_variable1 = 8;\n  local_pointer2 = local_array1;\n  local_variable2 = 0x30;\n  local_param10 = error_code0;\n  local_param11 = error_code1;\n  local_param12 = error_code2;\n  local_param13 = error_code3;\n  local_param14 = error_code4;\n  print_error_message(param_9,&local_variable1);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "xexit",
                "FUN_001078c0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107690",
            "calling": [
                "FUN_00105300",
                "FUN_00102c25",
                "FUN_001028ed",
                "FUN_00105db0",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "print_error_and_exit_00107690"
        },
        "bfd_seek": {
            "renaming": {},
            "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
            "called": [
                "bfd_seek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102580",
            "calling": [
                "FUN_00102c25",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "bfd_seek"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102450",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "FUN_0010266f": {
            "renaming": {
                "FUN_0010266f": "print_supported_targets_0010266f",
                "param_1": "target",
                "param_2": "outputFile",
                "lVar1": "currentTarget",
                "pcVar2": "message",
                "__ptr": "targetList",
                "plVar3": "currentPtr"
            },
            "code": "\nvoid printSupportedTargets_0010266f(long target,FILE *outputFile)\n\n{\n  long currentTarget;\n  char *message;\n  long *targetList;\n  long *currentPtr;\n  \n  if (target == 0) {\n    message = (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(outputFile,message);\n  }\n  else {\n    message = (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(outputFile,message,target);\n  }\n  targetList = (long *)bfd_target_list();\n  currentPtr = targetList;\n  while( true ) {\n    currentTarget = *currentPtr;\n    currentPtr = currentPtr + 1;\n    if (currentTarget == 0) break;\n    fprintf(outputFile,\" %s\");\n  }\n  fputc(10,outputFile);\n  free(targetList);\n  return;\n}\n\n",
            "called": [
                "fputc",
                "free",
                "bfd_target_list",
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010266f",
            "calling": [
                "FUN_0010394a",
                "FUN_0010342d"
            ],
            "imported": false,
            "current_name": "print_supported_targets_0010266f"
        },
        "FUN_00105830": {
            "renaming": {
                "FUN_00105830": "extract_file_name_00105830",
                "param_1": "input_string",
                "param_2": "struct_ptr",
                "__s": "base_name",
                "uVar3": "max_length",
                "pcVar4": "output_string",
                "bVar5": "flag",
                "auVar6": "result"
            },
            "code": "\nundefined  [16] extractFileName_00105830(char *input_string,long struct_ptr,undefined8 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *base_name;\n  ulong max_length;\n  char *output_string;\n  byte flag;\n  undefined result [16];\n  \n  flag = 0;\n  if (DAT_0010d5f9 == '\\0') {\n    base_name = (char *)lbasename();\n    input_string = base_name;\n    if ((DAT_0010d5fa != '\\0') && (struct_ptr != 0)) {\n      sVar2 = strlen(base_name);\n      max_length = (ulong)*(byte *)(*(long *)(struct_ptr + 8) + 0x1e);\n      if (max_length < sVar2) {\n        input_string = (char *)xmalloc(max_length + 1);\n        lVar1 = *(long *)(struct_ptr + 8);\n        output_string = input_string;\n        for (max_length = (ulong)*(byte *)(lVar1 + 0x1e); max_length != 0; max_length = max_length - 1) {\n          *output_string = *base_name;\n          base_name = base_name + (ulong)flag * -2 + 1;\n          output_string = output_string + (ulong)flag * -2 + 1;\n        }\n        input_string[*(byte *)(lVar1 + 0x1e)] = '\\0';\n      }\n    }\n  }\n  result._8_8_ = param_4;\n  result._0_8_ = input_string;\n  return result;\n}\n\n",
            "called": [
                "lbasename",
                "FUN_00102bb0"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105830",
            "calling": [
                "FUN_00105480",
                "FUN_001028ed",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_file_name_00105830"
        },
        "bfd_find_target": {
            "renaming": {},
            "code": "\nvoid bfd_find_target(void)\n\n{\n  bfd_find_target();\n  return;\n}\n\n",
            "called": [
                "bfd_find_target"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024e0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_find_target"
        },
        "bfd_check_format_matches": {
            "renaming": {},
            "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
            "called": [
                "bfd_check_format_matches"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024c0",
            "calling": [
                "FUN_00105300",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_check_format_matches"
        },
        "FUN_00107730": {
            "renaming": {
                "FUN_00107730": "cleanup_and_close_00107730"
            },
            "code": "\nvoid cleanupAndClose_00107730(void)\n\n{\n  if (DAT_0010d618 == 0) {\n    return;\n  }\n  if (DAT_0010d5e0 != 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 != (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
            "called": [
                "FUN_00102bf5"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107730",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "cleanup_and_close_00107730"
        },
        "mkstemp": {
            "renaming": {},
            "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 = mkstemp(__template);\n  return iVar1;\n}\n\n",
            "called": [
                "mkstemp"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023e0",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "mkstemp"
        },
        "FUN_00107c20": {
            "renaming": {
                "FUN_00107c20": "print_error_message_00107c20",
                "param_1": "errorType",
                "iVar1": "error",
                "uVar2": "errorString",
                "in_R10": "additionalInfo"
            },
            "code": "\n\n\nvoid printErrorMessage_00107c20(long errorType)\n\n{\n  int error;\n  undefined8 errorString;\n  undefined8 additionalInfo;\n  \n  error = bfd_get_error();\n  if (error == 0) {\n    errorString = dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    errorString = bfd_errmsg(error);\n  }\n  fflush(_stdout);\n  if (errorType != 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010d660,errorType,errorString,additionalInfo);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010d660,errorString,additionalInfo);\n  return;\n}\n\n",
            "called": [
                "FUN_00102f96",
                "bfd_errmsg",
                "bfd_get_error"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107c20",
            "calling": [
                "FUN_00105300",
                "FUN_00107c10",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "print_error_message_00107c20"
        },
        "lseek": {
            "renaming": {},
            "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 = lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
            "called": [
                "lseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "FUN_00105c00"
            ],
            "imported": false,
            "current_name": "lseek"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102320",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "FUN_001031cf": {
            "renaming": {
                "FUN_001031cf": "initialize_file_001031cf",
                "param_1": "file_ptr",
                "param_2": "input_file",
                "iVar1": "errno_value",
                "uVar2": "is_tty",
                "iVar3": "file_number",
                "piVar4": "errno_ptr"
            },
            "code": "\n\n\nundefined8\ninitialize_file_001031cf(FILE **file_ptr,FILE *input_file,undefined8 param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  int errno_value;\n  uint is_tty;\n  int file_number;\n  int *errno_ptr;\n  long lVar5;\n  \n  errno_ptr = __errno_location();\n  lVar5 = DAT_0010d5a8;\n  errno_value = *errno_ptr;\n  if (file_ptr == (FILE **)0x0) {\n    _DAT_00000034 = 1;\n    _DAT_00000000 = input_file;\n    if (DAT_0010d5a8 != 0) {\nLAB_00103263:\n      if (file_ptr == *(FILE ***)(lVar5 + DAT_0010d5a0 * 8)) goto LAB_0010327b;\n    }\n  }\n  else {\n    *(undefined4 *)((long)file_ptr + 0x1c) = 0;\n    *(undefined *)&file_ptr[1]->_flags = 0;\n    *(undefined *)((long)&file_ptr[1]->_flags + 1) = 0;\n    *(undefined4 *)(file_ptr + 5) = 1;\n    file_ptr[2] = file_ptr[1];\n    *(undefined4 *)(file_ptr + 7) = 0;\n    if (lVar5 != 0) {\n      if (file_ptr == *(FILE ***)(lVar5 + DAT_0010d5a0 * 8)) {\n        initialize_data_001030ed();\n      }\n      *file_ptr = input_file;\n      *(undefined4 *)((long)file_ptr + 0x34) = 1;\n      goto LAB_00103263;\n    }\n    *file_ptr = input_file;\n    *(undefined4 *)((long)file_ptr + 0x34) = 1;\n  }\n  *(undefined8 *)((long)file_ptr + 0x2c) = 1;\nLAB_0010327b:\n  is_tty = 0;\n  if (input_file != (FILE *)0x0) {\n    file_number = fileno(input_file);\n    file_number = isatty(file_number);\n    is_tty = (uint)(0 < file_number);\n  }\n  *(uint *)((long)file_ptr + 0x24) = is_tty;\n  *errno_ptr = errno_value;\n  return param_5;\n}\n\n",
            "called": [
                "FUN_001030ed",
                "fileno",
                "__errno_location",
                "isatty"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001031cf",
            "calling": [
                "FUN_001033d6",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "initialize_file_001031cf"
        },
        "FUN_0010312d": {
            "renaming": {
                "FUN_0010312d": "copy_data_0010312d",
                "param_1": "source",
                "param_2": "destination",
                "lVar1": "temp"
            },
            "code": "\nvoid copyData_0010312d(long source,long destination)\n\n{\n  long temp;\n  \n  if (destination != 0) {\n    *(undefined8 *)(destination + 0xf0) = *(undefined8 *)(source + 0xf0);\n  }\n  temp = DAT_0010d558;\n  *(undefined8 *)(source + 0xf0) = *(undefined8 *)(DAT_0010d558 + 0xf8);\n  *(long *)(temp + 0xf8) = source;\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010312d",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "copy_data_0010312d"
        },
        "FUN_00105c00": {
            "renaming": {
                "FUN_00105c00": "copy_data_to_file_00105c00",
                "param_1": "sourceFileDescriptor",
                "param_2": "destinationFilePath",
                "_Var3": "currentOffset",
                "uVar4": "bytesRead",
                "sVar5": "bytesWritten",
                "piVar6": "errnoPtr",
                "auStack_2038": "buffer",
                "iVar1": "error",
                "__fd": "destinationFileDescriptor",
                "iVar2": "result",
                "__errno_location": "getErrno",
                "close_file_and_set_error_00102f55": "closeFileAndSetError"
            },
            "code": "\nulong copyDataToFile_00105c00(int sourceFileDescriptor,char *destinationFilePath)\n\n{\n  int error;\n  int destinationFileDescriptor;\n  int result;\n  __off_t currentOffset;\n  ulong bytesRead;\n  size_t bytesWritten;\n  int *errnoPtr;\n  undefined buffer [8200];\n  \n  if ((-1 < sourceFileDescriptor) && (currentOffset = lseek(sourceFileDescriptor,0,0), currentOffset == 0)) {\n    destinationFileDescriptor = open(destinationFilePath,0x201);\n    if (destinationFileDescriptor < 0) {\n      bytesRead = closeFileAndSetError();\n      return bytesRead;\n    }\n    do {\n      bytesRead = read(sourceFileDescriptor,buffer,0x2000);\n      result = (int)bytesRead;\n      if (result < 1) {\n        errnoPtr = __errno_location();\n        error = *errnoPtr;\n        close(sourceFileDescriptor);\n        close(destinationFileDescriptor);\n        if (result != 0) {\n          *errnoPtr = error;\n          return 0xffffffff;\n        }\n        return bytesRead & 0xffffffff;\n      }\n      bytesWritten = write(destinationFileDescriptor,buffer,(long)result);\n    } while (bytesWritten == (long)result);\n    errnoPtr = __errno_location();\n    result = *errnoPtr;\n    close(sourceFileDescriptor);\n    close(destinationFileDescriptor);\n    *errnoPtr = result;\n  }\n  return 0xffffffff;\n}\n\n",
            "called": [
                "open",
                "read",
                "close",
                "lseek",
                "write",
                "FUN_00102f55",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105c00",
            "calling": [
                "FUN_00105bc0"
            ],
            "imported": false,
            "current_name": "copy_data_to_file_00105c00"
        },
        "calloc": {
            "renaming": {},
            "code": "\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = calloc(__nmemb,__size);\n  return pvVar1;\n}\n\n",
            "called": [
                "calloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001022d0",
            "calling": [
                "FUN_00103df9"
            ],
            "imported": false,
            "current_name": "calloc"
        },
        "FUN_00105d20": {
            "renaming": {
                "FUN_00105d20": "FUNC_00105d20"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d44) */\n/* WARNING: Removing unreachable block (ram,0x00105d50) */\n\nvoid FUNC_00105d20(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00105d20",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00105d20"
        },
        "FUN_001052a0": {
            "renaming": {
                "FUN_001052a0": "check_file_001052a0",
                "param_1": "filename",
                "iVar1": "status",
                "piVar2": "errno_ptr",
                "uVar3": "error_message",
                "pcVar4": "reason",
                "sStack_a8": "file_status"
            },
            "code": "\nlong check_file_001052a0(char *filename)\n\n{\n  int status;\n  int *errno_ptr;\n  undefined8 error_message;\n  char *reason;\n  stat file_status;\n  \n  if (filename != (char *)0x0) {\n    status = stat(filename,&file_status);\n    if (status < 0) {\n      errno_ptr = __errno_location();\n      if (*errno_ptr == 2) {\n        error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n        print_error_message_00107920(error_message,filename);\n      }\n      else {\n        reason = strerror(*errno_ptr);\n        error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n        print_error_message_00107920(error_message,filename,reason);\n      }\n    }\n    else if ((file_status.st_mode & 0xf000) == 0x4000) {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is a directory\",5);\n      print_error_message_00107920(error_message,filename);\n    }\n    else if ((file_status.st_mode & 0xf000) == 0x8000) {\n      if (-1 < file_status.st_size) {\n        return file_status.st_size;\n      }\n      error_message = dcgettext(0,\"Warning: \\'%s\\' has negative size, probably it is too large\",5);\n      print_error_message_00107920(error_message,filename);\n    }\n    else {\n      error_message = dcgettext(0,\"Warning: \\'%s\\' is not an ordinary file\",5);\n      print_error_message_00107920(error_message,filename);\n    }\n  }\n  return -1;\n}\n\n",
            "called": [
                "stat",
                "FUN_001025a0",
                "FUN_00107920",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001052a0",
            "calling": [
                "FUN_00105db0",
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "check_file_001052a0"
        },
        "FUN_0010336b": {
            "renaming": {
                "FUN_0010336b": "print_emulation_options_0010336b",
                "param_1": "outputFile",
                "pcVar1": "emulationOptionString"
            },
            "code": "\nvoid printEmulationOptions_0010336b(FILE *outputFile)\n\n{\n  char *emulationOptionString;\n  \n  emulationOptionString = (char *)dcgettext(0,\" emulation options: \\n\",5);\n  fprintf(outputFile,emulationOptionString);\n  emulationOptionString = (char *)dcgettext(0,\"  No emulation specific options\\n\",5);\n  fprintf(outputFile,emulationOptionString);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010336b",
            "calling": [
                "FUN_0010342d"
            ],
            "imported": false,
            "current_name": "print_emulation_options_0010336b"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "FUN_00103172",
                "FUN_00103ba8",
                "FUN_00103e95",
                "FUN_00102f08",
                "FUN_001075e0",
                "FUN_00105db0",
                "FUN_00103a78",
                "FUN_001031a5",
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "FUN_00103c60": {
            "renaming": {
                "FUN_00103c60": "create_bfd_archive_00103c60",
                "param_1": "input_file",
                "param_2": "is_reverse",
                "cVar1": "format_check_result",
                "piVar2": "error_flag",
                "pcVar3": "error_message",
                "lVar4": "input_archive",
                "lVar5": "archived_file",
                "uVar6": "program_name",
                "plVar7": "archived_file_ptr"
            },
            "code": "\n\n\nvoid create_bfd_archive_00103c60(char *input_file,int is_reverse)\n\n{\n  char format_check_result;\n  int *error_flag;\n  char *error_message;\n  long input_archive;\n  long archived_file;\n  undefined8 program_name;\n  long *archived_file_ptr;\n  \n  DAT_0010d570 = xstrdup();\n  DAT_0010d560 = (char *)extract_file_name_001057a0(DAT_0010d570,&DAT_0010d568);\n  if (DAT_0010d560 == (char *)0x0) {\n    error_flag = __errno_location();\n    input_file = strerror(*error_flag);\n    program_name = DAT_0010d660;\n    error_message = (char *)dcgettext(0,\"%s: Can\\'t open temporary file (%s)\\n\",5);\n  }\n  else {\n    DAT_0010d558 = bfd_fdopenw(DAT_0010d560,0,DAT_0010d568);\n    if (DAT_0010d558 == 0) {\n      error_message = \"%s: Can\\'t open output archive %s\\n\";\n      input_file = DAT_0010d560;\n    }\n    else {\n      if (is_reverse != 0) {\nLAB_00103d02:\n        bfd_set_format(DAT_0010d558,2);\n        *(byte *)(DAT_0010d558 + 0x49) = *(byte *)(DAT_0010d558 + 0x49) & 0xe7 | 8;\n        return;\n      }\n      input_archive = bfd_openr(input_file,\"plugin\");\n      if (input_archive == 0) {\n        error_message = \"%s: Can\\'t open input archive %s\\n\";\n      }\n      else {\n        format_check_result = bfd_check_format(input_archive,2);\n        if (format_check_result != '\\0') {\n          archived_file_ptr = (long *)(DAT_0010d558 + 0xf8);\n          for (archived_file = bfd_openr_next_archived_file(input_archive,0); archived_file != 0;\n              archived_file = bfd_openr_next_archived_file(input_archive,archived_file)) {\n            *archived_file_ptr = archived_file;\n            archived_file_ptr = (long *)(archived_file + 0xf0);\n          }\n          goto LAB_00103d02;\n        }\n        error_message = \"%s: file %s is not an archive\\n\";\n      }\n    }\n    program_name = DAT_0010d660;\n    error_message = (char *)dcgettext(0,error_message,5);\n  }\n  fprintf(_stderr,error_message,program_name,input_file);\n  check_and_exit_if_zero_0010315d();\n  return;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file",
                "bfd_check_format",
                "xstrdup",
                "FUN_001057a0",
                "bfd_set_format",
                "strerror",
                "bfd_fdopenw",
                "bfd_openr",
                "fprintf",
                "FUN_0010315d",
                "dcgettext",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00103c60",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "create_bfd_archive_00103c60"
        },
        "FUN_00102e57": {
            "renaming": {
                "FUN_00102e57": "write_to_file_00102e57",
                "pFVar1": "filePointer"
            },
            "code": "\nvoid writeToFile_00102e57(void)\n\n{\n  FILE *filePointer;\n  \n  DAT_0010d618 = (char *)concat();\n  if (DAT_0010d60c != 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  filePointer = fopen(DAT_0010d618,\"w\");\n  if (filePointer != (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
            "called": [
                "concat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e57",
            "calling": [
                "FUN_00105a68"
            ],
            "imported": false,
            "current_name": "write_to_file_00102e57"
        },
        "FUN_00105af0": {
            "renaming": {
                "FUN_00105af0": "process_files_in_archive_00105af0",
                "param_1": "file_list",
                "param_2": "archive",
                "param_3": "flag1",
                "param_4": "flag2",
                "cVar1": "is_valid_format",
                "uVar2": "result",
                "lVar3": "current_file",
                "uVar4": "return_value"
            },
            "code": "\nulong process_files_in_archive_00105af0(long *file_list,long archive,char flag1,char flag2)\n\n{\n  char is_valid_format;\n  uint result;\n  long current_file;\n  ulong return_value;\n  \n  if (flag2 == '\\0') {\n    if (flag1 != '\\0') {\n      return_value = print_and_assign_00102f08();\n      return return_value;\n    }\n  }\n  else {\n    is_valid_format = bfd_check_format(archive,2);\n    if (is_valid_format != '\\0') {\n      return_value = 0;\n      for (current_file = bfd_openr_next_archived_file(archive,0); current_file != 0;\n          current_file = bfd_openr_next_archived_file(archive,current_file)) {\n        result = process_files_in_archive_00105af0(file_list,current_file,flag1,1);\n        if ((char)result != '\\0') {\n          return_value = (ulong)result;\n          file_list = (long *)(*file_list + 0xf0);\n        }\n      }\n      return return_value;\n    }\n    if (flag1 != '\\0') {\n      return_value = print_and_assign_00102f08();\n      return return_value;\n    }\n  }\n  *(long *)(archive + 0xf0) = *file_list;\n  *file_list = archive;\n  return 1;\n}\n\n",
            "called": [
                "bfd_openr_next_archived_file",
                "bfd_check_format",
                "FUN_00105af0",
                "FUN_00102f08"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105af0",
            "calling": [
                "FUN_00105af0",
                "FUN_001028ed",
                "FUN_00105ae0"
            ],
            "imported": false,
            "current_name": "process_files_in_archive_00105af0"
        },
        "FUN_0010300e": {
            "renaming": {
                "FUN_0010300e": "find_modified_bytes_0010300e",
                "bVar1": "isModifiedByte",
                "iVar2": "index",
                "lVar3": "calculatedIndex",
                "bVar4": "modifiedValue",
                "pbVar5": "currentByte",
                "in_R9": "firstModifiedByte",
                "in_R10D": "firstModifiedIndex"
            },
            "code": "\nvoid findModifiedBytes_0010300e(void)\n\n{\n  bool isModifiedByte;\n  int index;\n  long calculatedIndex;\n  byte modifiedValue;\n  byte *currentByte;\n  byte *firstModifiedByte;\n  int firstModifiedIndex;\n  \n  isModifiedByte = false;\n  index = DAT_0010d5d0;\n  for (currentByte = DAT_0010d5c8; currentByte < DAT_0010d5b0; currentByte = currentByte + 1) {\n    modifiedValue = 1;\n    if (*currentByte != 0) {\n      modifiedValue = (&DAT_0010ab00)[*currentByte];\n    }\n    if (*(short *)(&DAT_0010a980 + (long)index * 2) != 0) {\n      isModifiedByte = true;\n      firstModifiedByte = currentByte;\n      firstModifiedIndex = index;\n    }\n    while( true ) {\n      calculatedIndex = (long)(int)((int)*(short *)(&DAT_0010a640 + (long)index * 2) + (uint)modifiedValue);\n      if (*(short *)(&DAT_0010a440 + calculatedIndex * 2) == index) break;\n      index = (int)*(short *)(&DAT_0010a800 + (long)index * 2);\n      if (0xb0 < index) {\n        modifiedValue = (&DAT_0010a7c0)[(int)(uint)modifiedValue];\n      }\n    }\n    index = (int)*(short *)(&DAT_0010a240 + calculatedIndex * 2);\n  }\n  if (isModifiedByte) {\n    DAT_0010d5b8 = firstModifiedByte;\n    DAT_0010d5c0 = firstModifiedIndex;\n  }\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010300e",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "find_modified_bytes_0010300e"
        },
        "chmod": {
            "renaming": {},
            "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 = chmod(__file,__mode);\n  return iVar1;\n}\n\n",
            "called": [
                "chmod"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102430",
            "calling": [
                "FUN_00102c25"
            ],
            "imported": false,
            "current_name": "chmod"
        },
        "FUN_00102ba1": {
            "renaming": {
                "FUN_00102ba1": "deallocate_and_return_address_00102ba1",
                "unaff_RBP": "memory_block",
                "unaff_retaddr": "return_address",
                "auVar1": "updated_register"
            },
            "code": "\nundefined  [16] deallocate_and_return_address_00102ba1(void)\n\n{\n  undefined updated_register [16];\n  void *memory_block;\n  ulong return_address;\n  \n  free(memory_block);\n  updated_register._8_8_ = 0;\n  updated_register._0_8_ = return_address;\n  return updated_register << 0x40;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102ba1",
            "calling": [
                "FUN_001057a0"
            ],
            "imported": false,
            "current_name": "deallocate_and_return_address_00102ba1"
        },
        "FUN_00107740": {
            "renaming": {
                "FUN_00107740": "extract_file_from_binary_00107740",
                "param_1": "binaryData",
                "iVar1": "comparisonResult",
                "iVar2": "errorCode",
                "piVar3": "errorNumber",
                "pcVar4": "errorMessage",
                "uVar5": "translatedMessage",
                "pplVar6": "filePointer",
                "__ptr": "bufferPointer",
                "__n": "bufferSize",
                "lVar7": "loopCounter",
                "plVar8": "fileDataPointer",
                "puVar9": "localVariables",
                "uVar10": "bytesRead",
                "sVar11": "bytesToRead",
                "local_c8": "localArray",
                "_Stack_b0": "filePermissions",
                "uStack_98": "fileSize",
                "uStack_80": "stackVar1",
                "uStack_70": "stackVar2"
            },
            "code": "\n\n\nlong * extractFileFromBinary_00107740(long **binaryData)\n\n{\n  int comparisonResult;\n  int errorCode;\n  int *errorNumber;\n  char *errorMessage;\n  undefined8 translatedMessage;\n  long **filePointer;\n  void *bufferPointer;\n  size_t bufferSize;\n  long loopCounter;\n  long *fileDataPointer;\n  undefined4 *localVariables;\n  ulong bytesRead;\n  size_t bytesToRead;\n  undefined4 localArray [6];\n  __mode_t filePermissions;\n  ulong fileSize;\n  undefined8 stackVar1;\n  undefined8 stackVar2;\n  \n  if (_DAT_0010d600 != 0) {\n    localVariables = localArray;\n    for (loopCounter = 0x24; loopCounter != 0; loopCounter = loopCounter + -1) {\n      *localVariables = 0;\n      localVariables = localVariables + 1;\n    }\n  }\n  filePointer = (long **)binaryData[0x1d];\n  if ((long **)binaryData[0x1d] == (long **)0x0) {\n    filePointer = binaryData;\n  }\n  errorCode = (*(code *)filePointer[1][0x3d])(binaryData,localArray);\n  if (errorCode != 0) {\n    fileDataPointer = *binaryData;\n    translatedMessage = dcgettext(0,\"internal stat error on %s\",5);\n    errorCode = print_error_and_exit_00107690(translatedMessage,fileDataPointer);\n    translatedMessage = DAT_0010d638;\n    if (errorCode == 3) {\n      for (; *fileDataPointer != 0; fileDataPointer = (long *)(*fileDataPointer + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*fileDataPointer != (undefined8 *)0x0; fileDataPointer = (long *)(*fileDataPointer + 0xf0)) {\n        comparisonResult = filename_cmp(*(undefined8 *)*fileDataPointer,translatedMessage);\n        if (comparisonResult == 0) {\n          if (errorCode != 2) {\n            return fileDataPointer;\n          }\n          return (long *)(*fileDataPointer + 0xf0);\n        }\n      }\n    }\n    return fileDataPointer;\n  }\n  bfd_seek(binaryData,0,0);\n  DAT_0010d5d8 = (FILE *)0x0;\n  if (fileSize == 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 = (FILE *)process_output_file_00105a20(*binaryData);\n  }\n  else {\n    bytesRead = 0;\n    bufferPointer = (void *)xmalloc(0x2000);\n    do {\n      bytesToRead = fileSize - bytesRead;\n      if (0x2000 < bytesToRead) {\n        bytesToRead = 0x2000;\n      }\n      bufferSize = bfd_bread(bufferPointer,bytesToRead,binaryData);\n      if (bytesToRead != bufferSize) {\nLAB_00102c78:\n        binaryData = (long **)*binaryData[0x1d];\n        translatedMessage = dcgettext(0,\"%s is not a valid archive\",5);\n        print_error_and_exit_00107690(translatedMessage,binaryData);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 == (FILE *)0x0) {\n        DAT_0010d5d8 = (FILE *)process_output_file_00105a20(*binaryData);\n      }\n      bytesToRead = fwrite(bufferPointer,1,bufferSize,DAT_0010d5d8);\n      if (bytesToRead != bufferSize) {\n        errorNumber = __errno_location();\n        errorMessage = strerror(*errorNumber);\n        print_error_and_exit_00107690(\"%s: %s\",DAT_0010d618,errorMessage);\n        goto LAB_00102c78;\n      }\n      bytesRead = bytesRead + bufferSize;\n    } while (bytesRead < fileSize);\n    free(bufferPointer);\n  }\n  fclose(DAT_0010d5d8);\n  errorMessage = DAT_0010d618;\n  DAT_0010d5d8 = (FILE *)0x0;\n  chmod(DAT_0010d618,filePermissions);\n  if (_DAT_0010d600 != 0) {\n    stackVar1 = stackVar2;\n    set_file_time_00107c80(errorMessage,localArray);\n  }\n  DAT_0010d618 = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "FUN_00102c25"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00107740",
            "calling": [
                "FUN_00103e95",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "extract_file_from_binary_00107740"
        },
        "FUN_00102d2f": {
            "renaming": {
                "FUN_00102d2f": "print_file_attributes_00102d2f",
                "bVar1": "errorFlag",
                "cVar2": "bfdResult",
                "iVar3": "copyResult",
                "__format": "timeDataMessage",
                "uVar4": "filePermissions",
                "unaff_RBX": "strings",
                "unaff_RBP": "outputFile",
                "unaff_R12": "isExecutable",
                "unaff_R13": "stringPtr",
                "unaff_R14D": "fileDescriptor",
                "uStack0000000000000015": "displayChar1",
                "cStack0000000000000016": "displayChar2",
                "cStack0000000000000017": "displayChar3",
                "in_stack_00000018": "displayChar4",
                "cStack0000000000000019": "displayChar5",
                "cStack000000000000001a": "displayChar6",
                "cStack000000000000001b": "displayChar7",
                "cStack000000000000001c": "displayChar8",
                "cStack000000000000001d": "displayChar9",
                "cStack000000000000001e": "displayChar10",
                "uStack000000000000001f": "displayChar11",
                "uStack0000000000000068": "fileType",
                "uStack000000000000006c": "fileUid",
                "in_stack_00000070": "fileGid",
                "in_stack_00000080": "fileSize"
            },
            "code": "\nvoid printFileAttributes_00102d2f(void)\n\n{\n  byte errorFlag;\n  char bfdResult;\n  int copyResult;\n  char *timeDataMessage;\n  uint filePermissions;\n  char **strings;\n  FILE *outputFile;\n  long isExecutable;\n  void *stringPtr;\n  int fileDescriptor;\n  undefined displayChar1;\n  char displayChar2;\n  char displayChar3;\n  char displayChar4;\n  char displayChar5;\n  char displayChar6;\n  char displayChar7;\n  char displayChar8;\n  char displayChar9;\n  char displayChar10;\n  undefined displayChar11;\n  uint fileType;\n  uint fileUid;\n  uint fileGid;\n  undefined8 fileSize;\n  \n  do {\n    errorFlag = handle_error_and_exit_00107c10();\n    *(uint *)((long)strings + 0x44) = *(uint *)((long)strings + 0x44) | 0x100000;\n    if ((DAT_0010d5f8 != '\\0') || ((*(byte *)(isExecutable + 0x49) & 0x10) != 0)) {\n      *(byte *)((long)strings + 0x49) = errorFlag | 0x10;\n    }\n    bfdResult = bfd_set_archive_head();\n  } while (bfdResult == '\\0');\n  dup(fileDescriptor);\n  bfdResult = bfd_close();\n  if (bfdResult != '\\0') {\n    DAT_0010d5e0 = 0;\n    DAT_0010d618 = 0;\n    bfd_close();\n    copyResult = copy_and_replace_file_00105bc0();\n    if (copyResult == 0) {\n      free(stringPtr);\n      free(outputFile);\n      return;\n    }\n                    \n    xexit(1);\n  }\n  handle_error_and_exit_00107c10();\n  timeDataMessage = (char *)dcgettext(0,\"<time data corrupt>\",5);\n  sprintf(&stack0x00000020,timeDataMessage);\n  filePermissions = fileType & 0xf000;\n  if (filePermissions == 0x4000) {\n    displayChar1 = 100;\n  }\n  else if (filePermissions == 0xa000) {\n    displayChar1 = 0x6c;\n  }\n  else if (filePermissions == 0x6000) {\n    displayChar1 = 0x62;\n  }\n  else if (filePermissions == 0x2000) {\n    displayChar1 = 99;\n  }\n  else if (filePermissions == 0xc000) {\n    displayChar1 = 0x73;\n  }\n  else {\n    displayChar1 = 0x70;\n    if (filePermissions != 0x1000) {\n      displayChar1 = 0x2d;\n    }\n  }\n  displayChar2 = (-((fileType & 0x100) == 0) & 0xbbU) + 0x72;\n  displayChar3 = (-((fileType & 0x80) == 0) & 0xb6U) + 0x77;\n  displayChar4 = (-((fileType & 0x40) == 0) & 0xb5U) + 0x78;\n  displayChar5 = (-((fileType & 0x20) == 0) & 0xbbU) + 0x72;\n  displayChar6 = (-((fileType & 0x10) == 0) & 0xb6U) + 0x77;\n  displayChar7 = (-((fileType & 8) == 0) & 0xb5U) + 0x78;\n  displayChar8 = (-((fileType & 4) == 0) & 0xbbU) + 0x72;\n  displayChar9 = (-((fileType & 2) == 0) & 0xb6U) + 0x77;\n  displayChar10 = (-((fileType & 1) == 0) & 0xb5U) + 0x78;\n  if ((fileType & 0x800) != 0) {\n    if (displayChar4 == 'x') {\n      displayChar4 = 's';\n    }\n    else {\n      displayChar4 = 'S';\n    }\n  }\n  if ((fileType & 0x400) != 0) {\n    if (displayChar7 == 'x') {\n      displayChar7 = 's';\n    }\n    else {\n      displayChar7 = 'S';\n    }\n  }\n  if ((fileType & 0x200) != 0) {\n    if (displayChar10 == 'x') {\n      displayChar10 = 't';\n    }\n    else {\n      displayChar10 = 'T';\n    }\n  }\n  displayChar11 = 0;\n  fprintf(outputFile,\"%s %ld/%ld %6lu %s \",&stack0x00000016,(ulong)fileUid,\n          (ulong)fileGid,fileSize,&stack0x00000020,(ulong)fileType)\n  ;\n  fputs(*strings,outputFile);\n  if ((char)isExecutable != '\\0') {\n    if ((*(byte *)((long)strings + 0x49) & 0x10) == 0) {\n      if (strings[0xb] != (char *)0x0) {\n        fprintf(outputFile,\" 0x%lx\");\n      }\n    }\n    else if (strings[0xc] != (char *)0x0) {\n      fprintf(outputFile,\" 0x%lx\");\n    }\n  }\n  fputc(10,outputFile);\n  return;\n}\n\n",
            "called": [
                "FUN_00105bc0",
                "free",
                "bfd_set_archive_head",
                "bfd_close",
                "FUN_00107c10",
                "dup",
                "xexit",
                "FUN_00102d2f"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102d2f",
            "calling": [
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "print_file_attributes_00102d2f"
        },
        "FUN_001028ed": {
            "renaming": {
                "FUN_001028ed": "process_files_001028ed",
                "param_1": "arg1",
                "param_2": "arg2",
                "uVar1": "undefinedVar1",
                "bVar2": "byteVar2",
                "iVar3": "intVar3",
                "sVar4": "sizeVar4",
                "piVar5": "intPtr5",
                "pcVar6": "charPtr6",
                "pcVar7": "charPtr7",
                "ppcVar8": "charPtrPtr8",
                "uVar9": "undefinedVar9",
                "lVar10": "longVar10",
                "__s": "charArr_s",
                "__s_00": "charArr_s00",
                "lVar11": "longVar11",
                "uVar12": "undefinedVar12",
                "uVar13": "ulongVar13",
                "unaff_RBX": "unaffectedRBX",
                "ppcVar14": "charPtrPtr14",
                "unaff_RBP": "unaffectedRBP",
                "unaff_R12": "unaffectedR12",
                "unaff_R13D": "unaffectedR13D",
                "ppcVar15": "charPtrPtr15",
                "unaff_R14": "unaffectedR14",
                "bVar16": "boolVar16",
                "bVar17": "byteVar17",
                "param_7": "param7",
                "param_9": "param9",
                "in_stack_00000078": "inStack_00000078",
                "in_stack_00000108": "inStack_00000108"
            },
            "code": "\n\n\nundefined8 processFiles_001028ed(undefined8 arg1,long arg2)\n\n{\n  undefined undefinedVar1;\n  byte byteVar2;\n  int intVar3;\n  size_t sizeVar4;\n  int *intPtr5;\n  char *charPtr6;\n  char *charPtr7;\n  char **charPtrPtr8;\n  undefined8 undefinedVar9;\n  long longVar10;\n  char *charArr_s;\n  char *charArr_s00;\n  long longVar11;\n  undefined8 undefinedVar12;\n  ulong ulongVar13;\n  char *unaffectedRBX;\n  char **charPtrPtr14;\n  char **unaffectedRBP;\n  char **unaffectedR12;\n  uint unaffectedR13D;\n  char **charPtrPtr15;\n  long unaffectedR14;\n  bool boolVar16;\n  byte byteVar17;\n  char **param7;\n  undefined8 param9;\n  long inStack_00000078;\n  long inStack_00000108;\n  \n  byteVar17 = 0;\ncode_r0x001028ed:\n  handle_error_and_exit_00107c10(unaffectedRBX,arg2);\nLAB_001028f5:\n  undefinedVar12 = DAT_0010d638;\n  if (unaffectedR13D != 3) {\n    while( true ) {\n      if ((undefined8 *)*unaffectedR12 == (undefined8 *)0x0) goto LAB_0010571f;\n      intVar3 = filename_cmp(*(undefined8 *)*unaffectedR12,undefinedVar12);\n      if (intVar3 == 0) break;\n      unaffectedR12 = (char **)(*unaffectedR12 + 0xf0);\n    }\n    if (unaffectedR13D != 2) goto LAB_0010571f;\n    unaffectedR12 = (char **)(*unaffectedR12 + 0xf0);\n    goto LAB_0010571f;\n  }\n  longVar10 = *(long *)(unaffectedR14 + 0xf0);\n  if (*(long *)(unaffectedR14 + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n  do {\n    longVar11 = longVar10;\n    longVar10 = *(long *)(longVar11 + 0xf0);\n  } while (longVar10 != 0);\n  unaffectedR12 = (char **)(longVar11 + 0xf0);\n  unaffectedRBX = *unaffectedRBP;\n  if (DAT_0010d620 != 0) goto LAB_00105731;\nLAB_00105698:\n  undefinedVar1 = DAT_0010d5f8;\n  unaffectedR13D = (uint)(DAT_0010d60c != 0);\n  arg2 = bfd_openr(unaffectedRBX,DAT_0010d5f0);\n  if (arg2 != 0) {\n    unaffectedRBP = unaffectedRBP + 1;\n    byteVar2 = process_files_in_archive_00105af0(unaffectedR12,arg2,unaffectedR13D,undefinedVar1);\n    param9._6_1_ = param9._6_1_ | byteVar2;\n    charPtr6 = *unaffectedRBP;\n    do {\n      if (charPtr6 == (char *)0x0) {\n        if (param9._6_1_ == 0) {\n          DAT_0010d618 = 0;\n          return 0;\n        }\n        undefinedVar12 = extract_and_print_archive_file_info_001058b0();\n        return undefinedVar12;\n      }\n      charPtrPtr14 = *(char ***)(unaffectedR14 + 0xf0);\n      unaffectedR12 = param7;\n      if (param9._7_1_ == '\\0') {\n        charPtrPtr15 = param7;\n        if (charPtrPtr14 != (char **)0x0) {\n          do {\n            if (DAT_0010d5f9 == '\\0') {\n              charArr_s = (char *)lbasename(*charPtrPtr14);\n              charPtr7 = charArr_s;\n              if (DAT_0010d5fa != '\\0') {\n                sizeVar4 = strlen(charArr_s);\n                ulongVar13 = (ulong)*(byte *)(*(long *)(unaffectedR14 + 8) + 0x1e);\n                if (ulongVar13 < sizeVar4) {\n                  charPtr7 = (char *)xmalloc(ulongVar13 + 1);\n                  longVar10 = *(long *)(unaffectedR14 + 8);\n                  charPtr6 = charPtr7;\n                  for (ulongVar13 = (ulong)*(byte *)(longVar10 + 0x1e); ulongVar13 != 0; ulongVar13 = ulongVar13 - 1) {\n                    *charPtr6 = *charArr_s;\n                    charArr_s = charArr_s + (ulong)byteVar17 * -2 + 1;\n                    charPtr6 = charPtr6 + (ulong)byteVar17 * -2 + 1;\n                  }\n                  charPtr7[*(byte *)(longVar10 + 0x1e)] = '\\0';\n                }\n                charPtr6 = *unaffectedRBP;\n                charArr_s = charPtr7;\n                if (DAT_0010d5f9 == '\\0') goto LAB_00105611;\n                goto LAB_00102980;\n              }\n              charPtr6 = *unaffectedRBP;\n              if (DAT_0010d5f9 != '\\0') goto LAB_00102980;\nLAB_00105611:\n              charArr_s00 = (char *)lbasename(charPtr6);\n              if (DAT_0010d5fa != '\\0') {\n                sizeVar4 = strlen(charArr_s00);\n                ulongVar13 = (ulong)*(byte *)(*(long *)(unaffectedR14 + 8) + 0x1e);\n                charPtr6 = charArr_s00;\n                charArr_s = charPtr7;\n                if (ulongVar13 < sizeVar4) {\n                  charPtr6 = (char *)xmalloc(ulongVar13 + 1);\n                  longVar10 = *(long *)(unaffectedR14 + 8);\n                  charPtr7 = charPtr6;\n                  for (ulongVar13 = (ulong)*(byte *)(longVar10 + 0x1e); ulongVar13 != 0; ulongVar13 = ulongVar13 - 1) {\n                    *charPtr7 = *charArr_s00;\n                    charArr_s00 = charArr_s00 + (ulong)byteVar17 * -2 + 1;\n                    charPtr7 = charPtr7 + (ulong)byteVar17 * -2 + 1;\n                  }\n                  charPtr6[*(byte *)(longVar10 + 0x1e)] = '\\0';\n                }\n                goto LAB_00102980;\n              }\n              intVar3 = filename_cmp(charArr_s00,charPtr7);\n            }\n            else {\n              charPtr6 = *unaffectedRBP;\n              charArr_s = *charPtrPtr14;\nLAB_00102980:\n              intVar3 = filename_cmp(charPtr6,charArr_s);\n            }\n            if ((intVar3 == 0) && (charPtrPtr14[0x1c] != (char *)0x0)) {\n              if (_DAT_0010d644 != 0) {\n                intVar3 = stat(*unaffectedRBP,(stat *)&stack0x000000b0);\n                if (intVar3 != 0) {\n                  intPtr5 = __errno_location();\n                  if (*intPtr5 != 2) {\n                    handle_error_and_exit_00107c10(*unaffectedRBP);\nLAB_00102b7e:\n                    charPtr6 = *charPtrPtr14;\n                    undefinedVar12 = dcgettext(0,\"internal stat error on %s\",5);\n                    print_error_and_exit_00107690(undefinedVar12,charPtr6);\n                    free(unaffectedRBP);\n                    return 0;\n                  }\n                  goto LAB_0010577e;\n                }\n                charPtrPtr8 = (char **)charPtrPtr14[0x1d];\n                if ((char **)charPtrPtr14[0x1d] == (char **)0x0) {\n                  charPtrPtr8 = charPtrPtr14;\n                }\n                intVar3 = (**(code **)(charPtrPtr8[1] + 0x1e8))(charPtrPtr14,&stack0x00000020);\n                if (intVar3 != 0) goto LAB_00102b7e;\n                if (inStack_00000108 <= inStack_00000078) goto LAB_0010577e;\n              }\n              undefinedVar12 = find_last_match_00105870(param7,2,*charPtrPtr14);\n              if (DAT_0010d620 == 0) {\nLAB_00102ae2:\n                charPtr6 = *unaffectedRBP;\n                boolVar16 = DAT_0010d60c != 0;\n                longVar10 = bfd_openr(charPtr6,DAT_0010d5f0);\n                if (longVar10 == 0) {\n                  handle_error_and_exit_00107c10(charPtr6,0);\n                  goto LAB_00102b3e;\n                }\n                byteVar2 = copy_and_print_string_00103172(undefinedVar12,longVar10,boolVar16);\n              }\n              else {\n                undefinedVar9 = extract_file_name_00105830(*unaffectedRBP);\n                intVar3 = filename_cmp(undefinedVar9,\"__.LIBDEP\");\n                if (intVar3 != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n                byteVar2 = copy_and_print_string_00103172(undefinedVar12,DAT_0010d620,DAT_0010d60c != 0);\n              }\n              if (byteVar2 != 0) {\n                *charPtrPtr15 = *(char **)(*charPtrPtr15 + 0xf0);\n                param9._6_1_ = byteVar2;\n              }\n              goto LAB_0010577e;\n            }\n            charPtrPtr15 = charPtrPtr14 + 0x1e;\n            charPtrPtr14 = (char **)charPtrPtr14[0x1e];\n          } while (charPtrPtr14 != (char **)0x0);\n          goto LAB_0010564c;\n        }\n        unaffectedR13D = DAT_0010d640;\n        if (DAT_0010d640 != 0) goto LAB_001028f5;\n      }\n      else {\nLAB_0010564c:\n        unaffectedR13D = DAT_0010d640;\n        if (DAT_0010d640 != 0) goto LAB_001028f5;\n        longVar10 = *(long *)(unaffectedR14 + 0xf0);\n        if (*(long *)(unaffectedR14 + 0xf0) != 0) goto LAB_00105670;\n      }\nLAB_0010571f:\n      unaffectedRBX = *unaffectedRBP;\n      if (DAT_0010d620 == 0) goto LAB_00105698;\nLAB_00105731:\n      undefinedVar12 = extract_file_name_00105830(unaffectedRBX);\n      intVar3 = filename_cmp(undefinedVar12,\"__.LIBDEP\");\n      if (intVar3 != 0) goto code_r0x0010574f;\n      byteVar2 = process_files_in_archive_00105ae0(unaffectedR12,DAT_0010d620,DAT_0010d60c != 0,DAT_0010d5f8);\n      param9._6_1_ = byteVar2 | param9._6_1_;\nLAB_0010577e:\n      unaffectedRBP = unaffectedRBP + 1;\n      charPtr6 = *unaffectedRBP;\n    } while( true );\n  }\n  goto code_r0x001028ed;\ncode_r0x0010574f:\n  unaffectedRBX = *unaffectedRBP;\n  goto LAB_00105698;\n}\n\n",
            "called": [
                "xmalloc",
                "filename_cmp",
                "FUN_00103172",
                "FUN_00105870",
                "strlen",
                "FUN_00107c10",
                "stat",
                "FUN_00107690",
                "FUN_00102943",
                "FUN_00105af0",
                "FUN_00105830",
                "bfd_openr",
                "FUN_001028ed",
                "lbasename",
                "dcgettext",
                "FUN_001058b0",
                "FUN_00105ae0",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001028ed",
            "calling": [
                "FUN_001028ed"
            ],
            "imported": false,
            "current_name": "process_files_001028ed"
        },
        "clearerr": {
            "renaming": {},
            "code": "\n\n\nvoid clearerr(FILE *__stream)\n\n{\n  clearerr(__stream);\n  return;\n}\n\n",
            "called": [
                "clearerr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102360",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "clearerr"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "FUN_00102c25",
                "FUN_00103e95",
                "FUN_00102bf5",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "bfd_errmsg": {
            "renaming": {},
            "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
            "called": [
                "bfd_errmsg"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024d0",
            "calling": [
                "FUN_00107c20",
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_errmsg"
        },
        "FUN_001033b0": {
            "renaming": {
                "FUN_001033b0": "report_error_and_exit_001033b0",
                "param_1": "errorMessage",
                "_stderr": "errorOutput",
                "exit": "terminateExecution"
            },
            "code": "\n\n\nvoid reportErrorAndExit_001033b0(undefined8 errorMessage)\n\n{\n  fprintf(errorOutput,\"%s\\n\",errorMessage);\n                    \n  exit(2);\n}\n\n",
            "called": [
                "exit",
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001033b0",
            "calling": [
                "FUN_001033d6",
                "FUN_00103e95",
                "FUN_00103df9"
            ],
            "imported": false,
            "current_name": "report_error_and_exit_001033b0"
        },
        "fwrite": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102510",
            "calling": [
                "FUN_00102c25",
                "FUN_00103e95",
                "FUN_00103a78"
            ],
            "imported": false,
            "current_name": "fwrite"
        },
        "unlink": {
            "renaming": {},
            "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 = unlink(__name);\n  return iVar1;\n}\n\n",
            "called": [
                "unlink"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "FUN_00102f1e",
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "unlink"
        },
        "unlink_if_ordinary": {
            "renaming": {},
            "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
            "called": [
                "unlink_if_ordinary"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023d0",
            "calling": [
                "FUN_00102bf5"
            ],
            "imported": false,
            "current_name": "unlink_if_ordinary"
        },
        "FUN_001025a0": {
            "renaming": {
                "FUN_001025a0": "print_file_error_001025a0",
                "piVar1": "error_location",
                "uVar2": "error_message",
                "__errno_location": "get_errno_location",
                "dcgettext": "get_translated_message",
                "print_error_message_00107920": "print_error_message",
                "strerror": "get_error_message"
            },
            "code": "\nundefined8 print_file_error_001025a0(void)\n\n{\n  int *error_location;\n  undefined8 error_message;\n  \n  error_location = __errno_location();\n  if (*error_location == 2) {\n    error_message = dcgettext(0,\"\\'%s\\': No such file\",5);\n    print_error_message(error_message);\n  }\n  else {\n    strerror(*error_location);\n    error_message = dcgettext(0,\"Warning: could not locate \\'%s\\'.  reason: %s\",5);\n    print_error_message(error_message);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
            "called": [
                "strerror",
                "FUN_00107920",
                "dcgettext",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001025a0",
            "calling": [
                "FUN_001052a0"
            ],
            "imported": false,
            "current_name": "print_file_error_001025a0"
        },
        "FUN_0010284b": {
            "renaming": {
                "FUN_0010284b": "get_one_0010284b"
            },
            "code": "\nundefined8 get_one_0010284b(void)\n\n{\n  return 1;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010284b",
            "calling": [
                "FUN_00107650"
            ],
            "imported": false,
            "current_name": "get_one_0010284b"
        },
        "FUN_00102c25": {
            "renaming": {
                "FUN_00102c25": "extract_and_process_archive_00102c25",
                "param_7": "param_array",
                "unaff_RBX": "struct_array",
                "iVar1": "filename_comparison_result",
                "iVar2": "stat_error",
                "__ptr": "buffer",
                "__n": "bytes_read",
                "lVar7": "loop_counter",
                "plVar8": "current_pointer",
                "puVar9": "param_7_ptr",
                "uVar5": "error_msg",
                "pplVar6": "func_array",
                "uVar10": "bytes_remaining",
                "sVar11": "bytes_to_read",
                "param_11": "file_permissions",
                "param_12": "archive_size",
                "piVar3": "error_code",
                "pcVar4": "error_string"
            },
            "code": "\n\n\nlong * extract_and_process_archive_00102c25(void)\n\n{\n  int filename_comparison_result;\n  int stat_error;\n  int *error_code;\n  char *error_string;\n  undefined8 error_msg;\n  long **func_array;\n  void *buffer;\n  size_t bytes_read;\n  long loop_counter;\n  long **struct_array;\n  long *current_pointer;\n  undefined4 *param_7_ptr;\n  ulong bytes_remaining;\n  size_t bytes_to_read;\n  undefined4 *param_array;\n  __mode_t file_permissions;\n  ulong archive_size;\n  \n  param_7_ptr = param_array;\n  for (loop_counter = 0x24; loop_counter != 0; loop_counter = loop_counter + -1) {\n    *param_7_ptr = 0;\n    param_7_ptr = param_7_ptr + 1;\n  }\n  func_array = (long **)struct_array[0x1d];\n  if ((long **)struct_array[0x1d] == (long **)0x0) {\n    func_array = struct_array;\n  }\n  stat_error = (*(code *)func_array[1][0x3d])();\n  if (stat_error != 0) {\n    current_pointer = *struct_array;\n    error_msg = dcgettext(0,\"internal stat error on %s\",5);\n    stat_error = print_error_and_exit_00107690(error_msg,current_pointer);\n    error_msg = DAT_0010d638;\n    if (stat_error == 3) {\n      for (; *current_pointer != 0; current_pointer = (long *)(*current_pointer + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*current_pointer != (undefined8 *)0x0; current_pointer = (long *)(*current_pointer + 0xf0)) {\n        filename_comparison_result = filename_cmp(*(undefined8 *)*current_pointer,error_msg);\n        if (filename_comparison_result == 0) {\n          if (stat_error != 2) {\n            return current_pointer;\n          }\n          return (long *)(*current_pointer + 0xf0);\n        }\n      }\n    }\n    return current_pointer;\n  }\n  bfd_seek();\n  DAT_0010d5d8 = (FILE *)0x0;\n  if (archive_size == 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 = (FILE *)process_output_file_00105a20(*struct_array);\n  }\n  else {\n    bytes_remaining = 0;\n    buffer = (void *)xmalloc(0x2000);\n    do {\n      bytes_to_read = archive_size - bytes_remaining;\n      if (0x2000 < bytes_to_read) {\n        bytes_to_read = 0x2000;\n      }\n      bytes_read = bfd_bread(buffer,bytes_to_read);\n      if (bytes_to_read != bytes_read) {\nLAB_00102c78:\n        struct_array = (long **)*struct_array[0x1d];\n        error_msg = dcgettext(0,\"%s is not a valid archive\",5);\n        print_error_and_exit_00107690(error_msg,struct_array);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 == (FILE *)0x0) {\n        DAT_0010d5d8 = (FILE *)process_output_file_00105a20(*struct_array);\n      }\n      bytes_to_read = fwrite(buffer,1,bytes_read,DAT_0010d5d8);\n      if (bytes_to_read != bytes_read) {\n        error_code = __errno_location();\n        error_string = strerror(*error_code);\n        print_error_and_exit_00107690(\"%s: %s\",DAT_0010d618,error_string);\n        goto LAB_00102c78;\n      }\n      bytes_remaining = bytes_remaining + bytes_read;\n    } while (bytes_remaining < archive_size);\n    free(buffer);\n  }\n  fclose(DAT_0010d5d8);\n  error_string = DAT_0010d618;\n  DAT_0010d5d8 = (FILE *)0x0;\n  chmod(DAT_0010d618,file_permissions);\n  if (_DAT_0010d600 != 0) {\n    set_file_time_00107c80(error_string,param_array);\n  }\n  DAT_0010d618 = (char *)0x0;\n  return (long *)0x0;\n}\n\n",
            "called": [
                "bfd_seek",
                "xmalloc",
                "strerror",
                "FUN_00105a20",
                "bfd_bread",
                "chmod",
                "FUN_00107690",
                "free",
                "FUN_00107c80",
                "fclose",
                "fwrite",
                "dcgettext",
                "__errno_location"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102c25",
            "calling": [
                "FUN_00107740"
            ],
            "imported": false,
            "current_name": "extract_and_process_archive_00102c25"
        },
        "bfd_plugin_set_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_plugin_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001023a0",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_plugin_set_program_name"
        },
        "bfd_bwrite": {
            "renaming": {},
            "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
            "called": [
                "bfd_bwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102370",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "bfd_bwrite"
        },
        "FUN_00102bb0": {
            "renaming": {
                "FUN_00102bb0": "reverse_string_00102bb0",
                "in_RAX": "inputString",
                "sVar2": "stringLength",
                "puVar3": "reversedString",
                "uVar4": "maxSize",
                "unaff_RBX": "sourceString",
                "unaff_RBP": "basePointer",
                "puVar5": "reversedStringPtr",
                "bVar6": "flag",
                "auVar7": "returnValue",
                "unaff_retaddr": "returnAddress"
            },
            "code": "\nundefined  [16] reverseString_00102bb0(void)\n\n{\n  long lVar1;\n  char *inputString;\n  size_t stringLength;\n  undefined *reversedString;\n  ulong maxSize;\n  undefined *sourceString;\n  long basePointer;\n  undefined *reversedStringPtr;\n  byte flag;\n  undefined returnValue [16];\n  undefined8 returnAddress;\n  \n  flag = 0;\n  stringLength = strlen(inputString);\n  maxSize = (ulong)*(byte *)(*(long *)(basePointer + 8) + 0x1e);\n  reversedString = sourceString;\n  if (maxSize < stringLength) {\n    reversedString = (undefined *)xmalloc(maxSize + 1);\n    lVar1 = *(long *)(basePointer + 8);\n    reversedStringPtr = reversedString;\n    for (maxSize = (ulong)*(byte *)(lVar1 + 0x1e); maxSize != 0; maxSize = maxSize - 1) {\n      *reversedStringPtr = *sourceString;\n      sourceString = sourceString + (ulong)flag * -2 + 1;\n      reversedStringPtr = reversedStringPtr + (ulong)flag * -2 + 1;\n    }\n    reversedString[*(byte *)(lVar1 + 0x1e)] = 0;\n  }\n  returnValue._8_8_ = returnAddress;\n  returnValue._0_8_ = reversedString;\n  return returnValue;\n}\n\n",
            "called": [
                "xmalloc",
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102bb0",
            "calling": [
                "FUN_00105830"
            ],
            "imported": false,
            "current_name": "reverse_string_00102bb0"
        },
        "utimensat": {
            "renaming": {},
            "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 = utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
            "called": [
                "utimensat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "FUN_00107c80"
            ],
            "imported": false,
            "current_name": "utimensat"
        },
        "getc": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102560",
            "calling": [
                "FUN_00103e95"
            ],
            "imported": false,
            "current_name": "getc"
        },
        "dup": {
            "renaming": {},
            "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 = dup(__fd);\n  return iVar1;\n}\n\n",
            "called": [
                "dup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "FUN_00103e95",
                "FUN_00102d2f"
            ],
            "imported": false,
            "current_name": "dup"
        },
        "FUN_00102f08": {
            "renaming": {
                "FUN_00102f08": "print_and_assign_00102f08",
                "unaff_RBX": "ptr1",
                "unaff_R12": "ptr2"
            },
            "code": "\nundefined8 printAndAssign_00102f08(void)\n\n{\n  undefined8 *ptr1;\n  undefined8 *ptr2;\n  \n  printf(\"a - %s\\n\",*ptr1);\n  ptr1[0x1e] = *ptr2;\n  *ptr2 = ptr1;\n  return 1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f08",
            "calling": [
                "FUN_00105af0"
            ],
            "imported": false,
            "current_name": "print_and_assign_00102f08"
        },
        "FUN_00105570": {
            "renaming": {
                "FUN_00105570": "process_binary_00105570",
                "param_1": "binaryData",
                "param_2": "filePaths",
                "param_3": "isArchive",
                "ppcVar1": "archiveFilePath",
                "uVar2": "undefinedVar",
                "bVar3": "byteVar",
                "iVar4": "indexVar",
                "sVar5": "lengthVar",
                "piVar6": "errnoLocation",
                "pcVar7": "currentFilePath",
                "pcVar8": "baseName",
                "uVar9": "extractedFileName",
                "pcVar10": "file",
                "__s": "baseName2",
                "lVar11": "ptr1",
                "lVar12": "ptr2",
                "uVar13": "returnValue",
                "uVar14": "ulongVar",
                "ppcVar15": "filePathsPtr",
                "ppcVar16": "archiveFilePathPtr",
                "uVar17": "uintVar",
                "bVar19": "boolVar",
                "bVar20": "byteVar2",
                "local_15a": "localByteVar",
                "auStack_158": "stackArray",
                "lStack_100": "lStack",
                "sStack_c8": "statStruct"
            },
            "code": "\n\n\nundefined8 processBinary_00105570(long binaryData,char **filePaths,char isArchive)\n\n{\n  char **archiveFilePath;\n  undefined undefinedVar;\n  byte byteVar;\n  int indexVar;\n  size_t lengthVar;\n  int *errnoLocation;\n  char *currentFilePath;\n  char *baseName;\n  undefined8 extractedFileName;\n  char *file;\n  char *baseName2;\n  long ptr1;\n  long ptr2;\n  undefined8 returnValue;\n  ulong ulongVar;\n  char **filePathsPtr;\n  char **archiveFilePathPtr;\n  uint uintVar;\n  char **archiveFilePath8;\n  bool boolVar;\n  byte byteVar2;\n  byte localByteVar;\n  undefined stackArray [88];\n  long lStack;\n  stat statStruct;\n  \n  byteVar2 = 0;\n  archiveFilePath = (char **)(binaryData + 0xf0);\n  localByteVar = 0;\n  if (filePaths == (char **)0x0) {\n    returnValue = initialize_data_00102943();\n    return returnValue;\n  }\n  do {\n    file = *filePaths;\njoined_r0x001055aa:\n    if (file == (char *)0x0) {\n      if (localByteVar != 0) {\n        returnValue = extract_and_print_archive_file_info_001058b0(binaryData);\n        return returnValue;\n      }\n      DAT_0010d618 = 0;\n      return 0;\n    }\n    filePathsPtr = *(char ***)(binaryData + 0xf0);\n    archiveFilePathPtr = archiveFilePath;\n    if (isArchive != '\\0') {\nLAB_0010564c:\n      uintVar = DAT_0010d640;\n      if (DAT_0010d640 != 0) goto LAB_001028f5;\n      ptr2 = *(long *)(binaryData + 0xf0);\n      if (*(long *)(binaryData + 0xf0) == 0) goto LAB_0010571f;\nLAB_00105670:\n      do {\n        ptr1 = ptr2;\n        ptr2 = *(long *)(ptr1 + 0xf0);\n      } while (ptr2 != 0);\n      archiveFilePathPtr = (char **)(ptr1 + 0xf0);\n      file = *filePaths;\n      do {\n        if (DAT_0010d620 != 0) {\n          returnValue = extract_file_name_00105830(file,binaryData);\n          indexVar = filename_cmp(returnValue,\"__.LIBDEP\");\n          if (indexVar == 0) {\n            byteVar = process_files_in_archive_00105ae0(archiveFilePathPtr,DAT_0010d620,DAT_0010d60c != 0,DAT_0010d5f8);\n            localByteVar = byteVar | localByteVar;\n            goto LAB_0010577e;\n          }\n          file = *filePaths;\n        }\n        undefinedVar = DAT_0010d5f8;\n        boolVar = DAT_0010d60c != 0;\n        ptr2 = bfd_openr(file,DAT_0010d5f0);\n        if (ptr2 != 0) {\n          filePaths = filePaths + 1;\n          byteVar = process_files_in_archive_00105af0(archiveFilePathPtr,ptr2,(uint)boolVar,undefinedVar);\n          localByteVar = localByteVar | byteVar;\n          file = *filePaths;\n          goto joined_r0x001055aa;\n        }\n        handle_error_and_exit_00107c10(file,0);\n        uintVar = (uint)boolVar;\nLAB_001028f5:\n        returnValue = DAT_0010d638;\n        if (uintVar == 3) {\n          ptr2 = *(long *)(binaryData + 0xf0);\n          if (*(long *)(binaryData + 0xf0) != 0) goto LAB_00105670;\n        }\n        else {\n          for (; (undefined8 *)*archiveFilePathPtr != (undefined8 *)0x0;\n              archiveFilePathPtr = (char **)(*archiveFilePathPtr + 0xf0)) {\n            indexVar = filename_cmp(*(undefined8 *)*archiveFilePathPtr,returnValue);\n            if (indexVar == 0) {\n              if (uintVar == 2) {\n                archiveFilePathPtr = (char **)(*archiveFilePathPtr + 0xf0);\n              }\n              break;\n            }\n          }\n        }\nLAB_0010571f:\n        file = *filePaths;\n      } while( true );\n    }\n    archiveFilePath8 = archiveFilePath;\n    if (filePathsPtr == (char **)0x0) {\n      uintVar = DAT_0010d640;\n      if (DAT_0010d640 == 0) goto LAB_0010571f;\n      goto LAB_001028f5;\n    }\nLAB_001055d8:\n    if (DAT_0010d5f9 == '\\0') {\n      file = (char *)lbasename(*filePathsPtr);\n      baseName = file;\n      if (DAT_0010d5fa != '\\0') {\n        lengthVar = strlen(file);\n        ulongVar = (ulong)*(byte *)(*(long *)(binaryData + 8) + 0x1e);\n        if (ulongVar < lengthVar) {\n          baseName = (char *)xmalloc(ulongVar + 1);\n          ptr2 = *(long *)(binaryData + 8);\n          currentFilePath = baseName;\n          for (ulongVar = (ulong)*(byte *)(ptr2 + 0x1e); ulongVar != 0; ulongVar = ulongVar - 1) {\n            *currentFilePath = *file;\n            file = file + (ulong)byteVar2 * -2 + 1;\n            currentFilePath = currentFilePath + (ulong)byteVar2 * -2 + 1;\n          }\n          baseName[*(byte *)(ptr2 + 0x1e)] = '\\0';\n        }\n        currentFilePath = *filePaths;\n        file = baseName;\n        if (DAT_0010d5f9 == '\\0') goto LAB_00105611;\n        goto LAB_00102980;\n      }\n      currentFilePath = *filePaths;\n      if (DAT_0010d5f9 != '\\0') goto LAB_00102980;\nLAB_00105611:\n      baseName2 = (char *)lbasename(currentFilePath);\n      if (DAT_0010d5fa != '\\0') {\n        lengthVar = strlen(baseName2);\n        ulongVar = (ulong)*(byte *)(*(long *)(binaryData + 8) + 0x1e);\n        currentFilePath = baseName2;\n        file = baseName;\n        if (ulongVar < lengthVar) {\n          currentFilePath = (char *)xmalloc(ulongVar + 1);\n          ptr2 = *(long *)(binaryData + 8);\n          baseName = currentFilePath;\n          for (ulongVar = (ulong)*(byte *)(ptr2 + 0x1e); ulongVar != 0; ulongVar = ulongVar - 1) {\n            *baseName = *baseName2;\n            baseName2 = baseName2 + (ulong)byteVar2 * -2 + 1;\n            baseName = baseName + (ulong)byteVar2 * -2 + 1;\n          }\n          currentFilePath[*(byte *)(ptr2 + 0x1e)] = '\\0';\n        }\n        goto LAB_00102980;\n      }\n      indexVar = filename_cmp(baseName2,baseName);\n      if (indexVar == 0) goto LAB_00102993;\nLAB_00105639:\n      archiveFilePath8 = filePathsPtr + 0x1e;\n      filePathsPtr = (char **)filePathsPtr[0x1e];\n      if (filePathsPtr == (char **)0x0) goto LAB_0010564c;\n      goto LAB_001055d8;\n    }\n    currentFilePath = *filePaths;\n    file = *filePathsPtr;\nLAB_00102980:\n    indexVar = filename_cmp(currentFilePath,file);\n    if (indexVar != 0) goto LAB_00105639;\nLAB_00102993:\n    if (filePathsPtr[0x1c] == (char *)0x0) goto LAB_00105639;\n    if (_DAT_0010d644 != 0) {\n      indexVar = stat(*filePaths,&statStruct);\n      if (indexVar != 0) {\n        errnoLocation = __errno_location();\n        if (*errnoLocation != 2) {\n          handle_error_and_exit_00107c10(*filePaths);\nLAB_00102b7e:\n          file = *filePathsPtr;\n          returnValue = dcgettext(0,\"internal stat error on %s\",5);\n          print_error_and_exit_00107690(returnValue,file);\n          free(filePaths);\n          return 0;\n        }\n        goto LAB_0010577e;\n      }\n      archiveFilePathPtr = (char **)filePathsPtr[0x1d];\n      if ((char **)filePathsPtr[0x1d] == (char **)0x0) {\n        archiveFilePathPtr = filePathsPtr;\n      }\n      indexVar = (**(code **)(archiveFilePathPtr[1] + 0x1e8))(filePathsPtr,stackArray);\n      if (indexVar != 0) goto LAB_00102b7e;\n      if (statStruct.st_mtim.tv_sec <= lStack) goto LAB_0010577e;\n    }\n    returnValue = find_last_match_00105870(archiveFilePath,2,*filePathsPtr);\n    if (DAT_0010d620 == 0) {\nLAB_00102ae2:\n      file = *filePaths;\n      boolVar = DAT_0010d60c != 0;\n      ptr2 = bfd_openr(file,DAT_0010d5f0);\n      if (ptr2 == 0) {\n        handle_error_and_exit_00107c10(file,0);\n        goto LAB_00102b3e;\n      }\n      byteVar = copy_and_print_string_00103172(returnValue,ptr2,boolVar);\n    }\n    else {\n      extractedFileName = extract_file_name_00105830(*filePaths,binaryData);\n      indexVar = filename_cmp(extractedFileName,\"__.LIBDEP\");\n      if (indexVar != 0) goto LAB_00102ae2;\nLAB_00102b3e:\n      byteVar = copy_and_print_string_00103172(returnValue,DAT_0010d620,DAT_0010d60c != 0);\n    }\n    if (byteVar != 0) {\n      *archiveFilePath8 = *(char **)(*archiveFilePath8 + 0xf0);\n      localByteVar = byteVar;\n    }\nLAB_0010577e:\n    filePaths = filePaths + 1;\n  } while( true );\n}\n\n",
            "called": [
                "FUN_00102943"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00105570",
            "calling": [
                "FUN_00105db0"
            ],
            "imported": false,
            "current_name": "process_binary_00105570"
        }
    },
    "used_tokens": 101201,
    "layers": [
        [
            "FUN_00102cd9",
            "FUN_001079c0",
            "FUN_00105a68",
            "FUN_001032a8",
            "FUN_00102f96",
            "FUN_00105bb0",
            "FUN_00107640",
            "FUN_0010315d",
            "FUN_00103172",
            "FUN_00105870",
            "FUN_001030ed",
            "FUN_00103ba8",
            "FUN_001078c0",
            "FUN_001075e0",
            "FUN_001031a5",
            "FUN_00102bf5",
            "FUN_00102020",
            "FUN_00102943",
            "FUN_00105a20",
            "FUN_00102f55",
            "FUN_001057a0",
            "FUN_00102d8c",
            "FUN_00103bd1",
            "FUN_00107cc0",
            "FUN_0010266f",
            "FUN_00105830",
            "FUN_00107730",
            "FUN_00107c20",
            "FUN_0010312d",
            "FUN_0010336b",
            "FUN_00102e57",
            "FUN_0010300e",
            "FUN_00102ba1",
            "FUN_001033b0",
            "FUN_0010284b",
            "FUN_00102bb0",
            "FUN_00102f08"
        ],
        [
            "FUN_0010285f",
            "FUN_0010342d",
            "FUN_0010394a",
            "FUN_00107920",
            "FUN_00107890",
            "FUN_00103ddc",
            "FUN_00105480",
            "FUN_00103df9",
            "FUN_00107c10",
            "FUN_00107690",
            "FUN_001031cf",
            "FUN_00105c00",
            "FUN_00103c60"
        ],
        [
            "FUN_00102e6f",
            "FUN_001033d6",
            "FUN_00105bc0",
            "FUN_00102f1e",
            "FUN_00102fd7",
            "FUN_00103a78",
            "FUN_00107c80",
            "FUN_00102710",
            "FUN_001052a0",
            "FUN_001025a0"
        ],
        [
            "FUN_001058b0",
            "FUN_00105300",
            "FUN_00107740",
            "FUN_00102d2f",
            "FUN_00102c25"
        ],
        [
            "FUN_00107650",
            "FUN_00103e95"
        ],
        [
            "FUN_00105af0"
        ],
        [
            "FUN_00105ae0"
        ],
        [
            "FUN_001028ed",
            "FUN_00105570"
        ],
        [
            "FUN_00105db0"
        ]
    ],
    "locked_functions": []
}