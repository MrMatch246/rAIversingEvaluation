{
    "functions": {
        "putc": {
            "renaming": {},
            "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = putc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102130",
            "calling": [
                "FUN_001024f0",
                "FUN_00102e20",
                "FUN_00102380"
            ],
            "imported": false,
            "current_name": "putc"
        },
        "fflush": {
            "renaming": {},
            "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fflush(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fflush"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102180",
            "calling": [
                "FUN_001024f0",
                "FUN_00102e20"
            ],
            "imported": false,
            "current_name": "fflush"
        },
        "_FINI_0": {
            "renaming": {},
            "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_00105120 != '\\0') {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_00105100);\n  FUNC_00102430();\n  DAT_00105120 = 1;\n  return;\n}\n\n",
            "called": [
                "FUN_00102430",
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024a0",
            "calling": [],
            "imported": false,
            "current_name": "_FINI_0"
        },
        "ftell": {
            "renaming": {},
            "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 = ftell(__stream);\n  return lVar1;\n}\n\n",
            "called": [
                "ftell"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102150",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "ftell"
        },
        "dcgettext": {
            "renaming": {},
            "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
            "called": [
                "dcgettext"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102090",
            "calling": [
                "FUN_0010225e",
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "dcgettext"
        },
        "bfd_set_error_program_name": {
            "renaming": {},
            "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
            "called": [
                "bfd_set_error_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021b0",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "bfd_set_error_program_name"
        },
        "fputc": {
            "renaming": {},
            "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fputc(__c,__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fputc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102120",
            "calling": [
                "FUN_0010225e"
            ],
            "imported": false,
            "current_name": "fputc"
        },
        "strchr": {
            "renaming": {},
            "code": "\n\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 = strchr(__s,__c);\n  return pcVar1;\n}\n\n",
            "called": [
                "strchr"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020c0",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "strchr"
        },
        "FUN_0010225e": {
            "renaming": {
                "FUN_0010225e": "display_usage_and_exit_0010225e",
                "param_1": "outputFile",
                "param_2": "exitCode",
                "__format": "formatString",
                "puVar1": "demanglersPointer"
            },
            "code": "\n\n\nvoid displayUsageAndExit_0010225e(FILE *outputFile,int exitCode)\n\n{\n  char *formatString;\n  undefined8 *demanglersPointer;\n  \n  fprintf(outputFile,\"Usage: %s [options] [mangled names]\\n\",DAT_0010d148);\n  fprintf(outputFile,\"Options are:\\n  [-_|--strip-underscore]     Ignore first leading underscore%s\\n\",\n          \"\");\n  fprintf(outputFile,\"  [-n|--no-strip-underscore]  Do not ignore a leading underscore%s\\n\",\n          \" (default)\");\n  fwrite(\"  [-p|--no-params]            Do not display function arguments\\n  [-i|--no-verbose]           Do not show implementation details (if any)\\n  [-R|--recurse-limit]        Enable a limit on recursion whilst demangling.  [Default]\\n  ]-r|--no-recurse-limit]     Disable a limit on recursion whilst demangling\\n  [-t|--types]                Also attempt to demangle type encodings\\n  [-s|--format \"\n         ,1,0x184,outputFile);\n  fprintf(outputFile,\"{%s\",_libiberty_demanglers);\n  demanglersPointer = (undefined8 *)&libiberty_demanglers;\n  while (*(int *)(demanglersPointer + 4) != 0) {\n    fprintf(outputFile,\",%s\",demanglersPointer[3]);\n    demanglersPointer = demanglersPointer + 3;\n  }\n  fputc(0x7d,outputFile);\n  fwrite(&DAT_001035e8,1,2,outputFile);\n  fwrite(\"  [@<file>]                   Read extra options from <file>\\n  [-h|--help]                 Display this information\\n  [-v|--version]              Show the version information\\nDemangled names are displayed to stdout.\\nIf a name cannot be demangled it is just echoed to stdout.\\nIf no names are provided on the command line, stdin is read.\\n\"\n         ,1,0x150,outputFile);\n  if (exitCode == 0) {\n    formatString = (char *)dcgettext(0,\"Report bugs to %s.\\n\",5);\n    fprintf(outputFile,formatString,\"<https://sourceware.org/bugzilla/>\");\n  }\n                    \n  exit(exitCode);\n}\n\n",
            "called": [
                "fprintf",
                "fputc",
                "fwrite",
                "bfd_set_error_program_name",
                "exit",
                "dcgettext",
                "exit",
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x0010225e",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "display_usage_and_exit_0010225e"
        },
        "_DT_INIT": {
            "renaming": {},
            "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
            "called": [
                "__gmon_start__"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102000",
            "calling": [],
            "imported": false,
            "current_name": "_DT_INIT"
        },
        "fseek": {
            "renaming": {},
            "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 = fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
            "called": [
                "fseek"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102190",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "fseek"
        },
        "cplus_demangle": {
            "renaming": {},
            "code": "\nvoid cplus_demangle(void)\n\n{\n  cplus_demangle();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021a0",
            "calling": [
                "FUN_00102380"
            ],
            "imported": false,
            "current_name": "cplus_demangle"
        },
        "FUN_001024f0": {
            "renaming": {
                "FUN_001024f0": "demangle_symbols_001024f0",
                "param_1": "argc",
                "param_2": "argv",
                "pbVar1": "current_char",
                "bVar2": "istable_result",
                "bVar3": "in_single_quotes",
                "bVar4": "in_double_quotes",
                "bVar5": "escaped_char",
                "bVar6": "current_byte",
                "iVar7": "index",
                "uVar8": "counter",
                "iVar9": "opt",
                "__stream": "file_stream",
                "__n": "file_size",
                "__s": "file_contents",
                "sVar10": "bytes_read",
                "__ptr": "buffer",
                "lVar11": "string_length",
                "plVar12": "args",
                "lVar13": "arg_length",
                "uVar14": "result",
                "pcVar15": "error_message",
                "pbVar16": "current_byte_ptr",
                "lVar17": "current_arg",
                "ppuVar18": "option_table",
                "lVar19": "arg_index",
                "pbVar20": "buffer_ptr",
                "unaff_R13": "iteration_counter",
                "local_110": "max_iterations",
                "local_10c": "max_files",
                "local_108": "total_arg_length",
                "local_100": "string_index",
                "local_c8": "file_stats"
            },
            "code": "\n\n\nundefined8 demangle_symbols_001024f0(int argc,long *argv)\n\n{\n  byte *current_char;\n  byte istable_result;\n  bool in_single_quotes;\n  bool in_double_quotes;\n  bool escaped_char;\n  byte current_byte;\n  int index;\n  uint counter;\n  int opt;\n  FILE *file_stream;\n  size_t file_size;\n  byte *file_contents;\n  size_t bytes_read;\n  byte *buffer;\n  long string_length;\n  long *args;\n  long *file_contentsrc;\n  long *parg_length;\n  undefined8 result;\n  char *error_message;\n  byte *current_byte_ptr;\n  long current_arg;\n  undefined **option_table;\n  long arg_index;\n  byte *buffer_ptr;\n  ulong iteration_counter;\n  int max_iterations;\n  int max_files;\n  size_t total_arg_length;\n  long string_index;\n  stat file_stats;\n  \n  DAT_0010d148 = *argv;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010d148);\n  args = argv;\n  if (1 < argc) {\n    max_files = 2000;\n    iteration_counter = 1;\n    max_iterations = 0;\n    do {\n      opt = (int)iteration_counter;\n      current_arg = (long)opt;\n      if (*(char *)args[current_arg] == '@') {\n        max_files = max_files + -1;\n        if (max_files == 0) goto LAB_00102bdd;\n        error_message = (char *)args[current_arg] + 1;\n        index = stat(error_message,&file_stats);\n        if (index < 0) goto LAB_00102900;\n        if ((file_stats.st_mode & 0xf000) == 0x4000) {\n          current_arg = *args;\n          error_message = \"%s: error: @-file refers to a directory\\n\";\n          do {\n            fprintf(_stderr,error_message,current_arg);\n            xexit(1);\nLAB_00102bdd:\n            current_arg = *args;\n            error_message = \"%s: error: too many @-files encountered\\n\";\n          } while( true );\n        }\n        file_stream = fopen(error_message,\"r\");\n        if (file_stream == (FILE *)0x0) goto LAB_00102900;\n        index = fseek(file_stream,0,2);\n        if (((index == -1) || (file_size = ftell(file_stream), file_size == 0xffffffffffffffff)) ||\n           (index = fseek(file_stream,0,0), index == -1)) {\nLAB_001029a0:\n          fclose(file_stream);\n          if (opt + 1 < argc) goto LAB_0010290d;\n          break;\n        }\n        file_contents = (byte *)xmalloc(file_size + 1);\n        bytes_read = fread(file_contents,1,file_size,file_stream);\n        if ((file_size != bytes_read) && (index = ferror(file_stream), index != 0)) {\n          free(file_contents);\n          goto LAB_001029a0;\n        }\n        file_contents[bytes_read] = 0;\n        current_byte = *file_contents;\n        current_byte_ptr = file_contents;\n        if (current_byte != 0) {\nLAB_00102680:\n          if (((&_sch_istable)[(ulong)current_byte * 2] & 0x40) != 0) goto LAB_00102670;\n          strlen((char *)file_contents);\n          buffer = (byte *)xmalloc();\n          file_contentsrc = (long *)0x0;\n          index = 0;\n          in_single_quotes = false;\n          escaped_char = false;\n          in_double_quotes = false;\n          string_index = 0;\n          current_byte_ptr = file_contents;\n          do {\n            while (((&_sch_istable)[(ulong)*current_byte_ptr * 2] & 0x40) != 0) {\n              current_byte_ptr = current_byte_ptr + 1;\n            }\n            if ((index == 0) || (index + -1 <= (int)string_index)) {\n              if (file_contentsrc == (long *)0x0) {\n                index = 8;\n                file_contentsrc = (long *)xmalloc(0x40);\n              }\n              else {\n                index = index * 2;\n                file_contentsrc = (long *)xrealloc(file_contentsrc,(long)index << 3);\n              }\n              parg_length = file_contentsrc + string_index;\n              *parg_length = 0;\n            }\n            else {\n              parg_length = file_contentsrc + string_index;\n            }\n            current_byte = *current_byte_ptr;\n            buffer_ptr = buffer;\n            while (current_byte != 0) {\n              while( true ) {\n                if ((((&_sch_istable)[(ulong)current_byte * 2] & 0x40) != 0) &&\n                   (!(bool)(escaped_char | in_double_quotes | in_single_quotes))) {\n                  in_double_quotes = false;\n                  in_single_quotes = false;\n                  escaped_char = false;\n                  goto LAB_0010276f;\n                }\n                if (!in_double_quotes) break;\n                current_byte_ptr = current_byte_ptr + 1;\n                *buffer_ptr = current_byte;\n                buffer_ptr = buffer_ptr + 1;\n                in_double_quotes = false;\n                current_byte = *current_byte_ptr;\n                if (current_byte == 0) goto LAB_0010276f;\n              }\n              if (current_byte == 0x5c) {\n                in_double_quotes = true;\n              }\n              else if (escaped_char) {\n                if (current_byte == 0x27) {\n                  escaped_char = false;\n                }\n                else {\nLAB_001028e1:\n                  *buffer_ptr = current_byte;\n                  buffer_ptr = buffer_ptr + 1;\n                }\n              }\n              else if (in_single_quotes) {\n                if (current_byte != 0x22) goto LAB_001028e1;\n                in_single_quotes = false;\n              }\n              else if (current_byte == 0x27) {\n                escaped_char = true;\n              }\n              else {\n                if (current_byte != 0x22) goto LAB_001028e1;\n                in_single_quotes = true;\n              }\n              current_char = current_byte_ptr + 1;\n              current_byte_ptr = current_byte_ptr + 1;\n              current_byte = *current_char;\n            }\nLAB_0010276f:\n            *buffer_ptr = 0;\n            string_length = xstrdup(buffer);\n            *parg_length = string_length;\n            file_contentsrc[string_index + 1] = 0;\n            current_byte = *current_byte_ptr;\n            istable_result = (&_sch_istable)[(ulong)current_byte * 2];\n            while ((istable_result & 0x40) != 0) {\n              current_byte = current_byte_ptr[1];\n              current_byte_ptr = current_byte_ptr + 1;\n              istable_result = (&_sch_istable)[(ulong)current_byte * 2];\n            }\n            string_index = string_index + 1;\n          } while (current_byte != 0);\n          free(buffer);\n          parg_length = args;\n          if (argv == args) goto LAB_00102adb;\n          goto LAB_00102807;\n        }\nLAB_00102abe:\n        file_contentsrc = (long *)xmalloc(8);\n        *file_contentsrc = 0;\n        if (argv == args) {\nLAB_00102adb:\n          if (*args == 0) {\n            index = 0;\n          }\n          else {\n            string_length = 1;\n            do {\n              index = (int)string_length;\n              parg_length = args + string_length;\n              string_length = string_length + 1;\n            } while (*parg_length != 0);\n          }\n          arg_index = 0;\n          parg_length = (long *)xmalloc((long)(index + 1) << 3);\n          string_length = *args;\n          while (string_length != 0) {\n            result = xstrdup();\n            *(undefined8 *)((long)parg_length + arg_index) = result;\n            arg_index = arg_index + 8;\n            string_length = *(long *)((long)args + arg_index);\n          }\n          *(undefined8 *)((long)parg_length + arg_index) = 0;\nLAB_00102807:\n          args = parg_length;\n          if (*file_contentsrc == 0) goto LAB_00102ba3;\n          string_length = 0;\n          do {\n            string_length = string_length + 1;\n          } while (file_contentsrc[string_length] != 0);\n          total_arg_length = string_length * 8;\n        }\n        else {\nLAB_00102ba3:\n          string_length = 0;\n          total_arg_length = 0;\n        }\n        free((void *)args[current_arg]);\n        args = (long *)xrealloc(args,(string_length + 1 + (long)argc) * 8);\n        index = argc + -1 + (int)string_length;\n        memmove(args + current_arg + string_length,args + current_arg + 1,(long)(argc - opt) << 3);\n        memcpy(args + current_arg,file_contentsrc,total_arg_length);\n        free(file_contentsrc);\n        free(file_contents);\n        fclose(file_stream);\n        counter = max_iterations + 1;\n        iteration_counter = current_arg * 8;\n        argc = index;\n        if (index <= (int)counter) break;\n      }\n      else {\nLAB_00102900:\n        if (argc <= opt + 1) break;\nLAB_0010290d:\n        counter = opt + 1;\n        max_iterations = opt;\n      }\n      iteration_counter = (ulong)counter;\n    } while( true );\n  }\n  option_table = &PTR_s_strip_underscore_00104be0;\n  while (opt = getopt_long(argc,args,\"_hinprRs:tv\",&PTR_s_strip_underscore_00104be0,0),\n        opt != -1) {\n    switch(opt) {\n    case 0x3f:\nswitchD_001029f9_caseD_3f:\n      FUN_0010225e(_stderr,1);\n    case 0x5f:\nswitchD_001029f9_caseD_5f:\n      _DAT_0010d140 = 1;\n      break;\n    default:\n      do {\n        opt = getopt_long(argc,args,\"_hinprRs:tv\",&PTR_s_strip_underscore_00104be0,0);\n        if (opt == -1) goto LAB_00102a6c;\n        switch(opt) {\n        case 0x3f:\n          goto switchD_001029f9_caseD_3f;\n        case 0x52:\n          goto switchD_001029f9_caseD_52;\n        case 0x5f:\n          goto switchD_001029f9_caseD_5f;\n        case 0x68:\n          goto switchD_001029f9_caseD_68;\n        case 0x69:\n          goto switchD_001029f9_caseD_69;\n        case 0x6e:\n          goto switchD_001029f9_caseD_6e;\n        case 0x70:\n          goto switchD_001029f9_caseD_70;\n        case 0x72:\n          goto switchD_001029f9_caseD_72;\n        case 0x73:\n          goto switchD_001029f9_caseD_73;\n        case 0x74:\n          goto switchD_001029f9_caseD_74;\n        case 0x76:\n          goto switchD_001029f9_caseD_76;\n        }\n      } while( true );\n    case 0x52:\nswitchD_001029f9_caseD_52:\n      DAT_00105108 = DAT_00105108 & 0xfffbffff;\n      break;\n    case 0x68:\nswitchD_001029f9_caseD_68:\n      FUN_0010225e(_stdout,0);\n    case 0x74:\nswitchD_001029f9_caseD_74:\n      DAT_00105108 = DAT_00105108 | 0x10;\n      break;\n    case 0x69:\nswitchD_001029f9_caseD_69:\n      DAT_00105108 = DAT_00105108 & 0xfffffff7;\n      break;\n    case 0x6e:\nswitchD_001029f9_caseD_6e:\n      _DAT_0010d140 = 0;\n      break;\n    case 0x70:\nswitchD_001029f9_caseD_70:\n      DAT_00105108 = DAT_00105108 & 0xfffffffe;\n      break;\n    case 0x72:\nswitchD_001029f9_caseD_72:\n      DAT_00105108 = DAT_00105108 | 0x40000;\n      break;\n    case 0x73:\nswitchD_001029f9_caseD_73:\n      opt = cplus_demangle_name_to_style(_optarg);\n      if (opt == 0) {\n        fprintf(_stderr,\"%s: unknown demangling style `%s\\'\\n\",DAT_0010d148,_optarg);\n        return 1;\n      }\n      cplus_demangle_set_style(opt);\n      break;\n    case 0x76:\nswitchD_001029f9_caseD_76:\n      printf(\"GNU %s %s\\n\",\"c++filt\",\"(GNU Binutils for Debian) 2.40\");\n      error_message = (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n      printf(error_message);\n      error_message = (char *)dcgettext(0,\n                                  \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                                  ,5);\n      printf(error_message);\n                    \n      exit(0);\n    }\n  }\nLAB_00102a6c:\n  if (_optind < argc) {\n    do {\n      FUN_00102380(args[_optind]);\n      putc(10,_stdout);\n      _optind = _optind + 1;\n    } while (_optind < argc);\n  }\n  else {\n    if (_current_demangling_style == 0x8000) {\nLAB_00102c76:\n      option_table = (undefined **)&stdout;\n      do {\n        iteration_counter = 0;\n        counter = getc(_stdin);\n        while( true ) {\n          args = (long *)(iteration_counter & 0xffffffff);\n          if (counter == 0xffffffff) goto LAB_00102d0d;\n          if ((((&_sch_istable)[(ulong)(counter & 0xff) * 2] & 0x8c) == 0) &&\n             (error_message = strchr(\"_$.\",counter), error_message == (char *)0x0)) {\n            if ((int)args != 0) goto LAB_00102d6f;\n            goto LAB_00102d47;\n          }\n          if (iteration_counter == 0x7ffe) break;\n          (&DAT_00105140)[iteration_counter] = (char)counter;\n          iteration_counter = iteration_counter + 1;\n          counter = getc(_stdin);\n        }\n        args = (long *)0x7ffe;\nLAB_00102d6f:\n        *(undefined *)(args + 0x20a28) = 0;\n        FUN_00102380(&DAT_00105140);\nLAB_00102d47:\n        putc(counter,_stdout);\n        if (counter == 10) {\n          fflush(_stdout);\n        }\n      } while( true );\n    }\n    if (_current_demangling_style < 0x8001) {\n      if (((_current_demangling_style == 0x100) || (_current_demangling_style == 0x4000)) ||\n         (_current_demangling_style == 4)) goto LAB_00102c76;\n    }\n    else if ((_current_demangling_style - 0x10000U & 0xfffeffff) == 0) goto LAB_00102c76;\n    FUN_00102e20(\"Internal error: no symbol alphabet for current style\");\nLAB_00102d0d:\n    if ((int)iteration_counter != 0) {\n      *(undefined *)(args + 0x20a28) = 0;\n      FUN_00102380();\n    }\n    fflush((FILE *)*option_table);\n  }\n  return 0;\nLAB_00102670:\n  current_byte = current_byte_ptr[1];\n  current_byte_ptr = current_byte_ptr + 1;\n  if (current_byte == 0) goto LAB_00102abe;\n  goto LAB_00102680;\n}\n\n",
            "called": [
                "FUN_0010225e",
                "fopen",
                "stat",
                "ftell",
                "xmalloc",
                "bfd_set_error_program_name",
                "free",
                "memcpy",
                "dcgettext",
                "putc",
                "cplus_demangle_name_to_style",
                "fclose",
                "strchr",
                "xstrdup",
                "xmalloc_set_program_name",
                "cplus_demangle_set_style",
                "exit",
                "memmove",
                "getopt_long",
                "fseek",
                "printf",
                "fprintf",
                "fflush",
                "ferror",
                "xrealloc",
                "FUN_00102380",
                "strlen",
                "xexit",
                "fread",
                "FUN_00102e20",
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024f0",
            "calling": [
                "entry"
            ],
            "imported": false,
            "current_name": "demangle_symbols_001024f0"
        },
        "printf": {
            "renaming": {},
            "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = printf(__format);\n  return iVar1;\n}\n\n",
            "called": [
                "printf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020d0",
            "calling": [
                "FUN_001024f0",
                "FUN_00102380"
            ],
            "imported": false,
            "current_name": "printf"
        },
        "_INIT_0": {
            "renaming": {},
            "code": "\nvoid _INIT_0(void)\n\n{\n  FUNC_00102460();\n  return;\n}\n\n",
            "called": [
                "FUN_00102460"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001024e0",
            "calling": [],
            "imported": false,
            "current_name": "_INIT_0"
        },
        "strlen": {
            "renaming": {},
            "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = strlen(__s);\n  return sVar1;\n}\n\n",
            "called": [
                "strlen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020a0",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "strlen"
        },
        "cplus_demangle_set_style": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_set_style(void)\n\n{\n  cplus_demangle_set_style();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_set_style"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102070",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "cplus_demangle_set_style"
        },
        "xmalloc": {
            "renaming": {},
            "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
            "called": [
                "xmalloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020f0",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "xmalloc"
        },
        "FUN_00102230": {
            "renaming": {
                "FUN_00102230": "print_demangled_string_00102230",
                "param_1": "offset",
                "in_AL": "character",
                "__ptr": "demangledString",
                "unaff_RBX": "stringPointer"
            },
            "code": "\n\n\nvoid printDemangledString_00102230(ulong offset)\n\n{\n  byte character;\n  void *demangledString;\n  char *stringPointer;\n  \n  if (stringPointer[character] == '_') {\n    offset = (ulong)((int)offset + 1);\n  }\n  demangledString = (void *)cplus_demangle(stringPointer + offset,DAT_00105108);\n  if (demangledString != (void *)0x0) {\n    if (*stringPointer == '.') {\n      putc(0x2e,_stdout);\n    }\n    printf(\"%s\",demangledString);\n    free(demangledString);\n    return;\n  }\n  printf(\"%s\");\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102230",
            "calling": [
                "FUN_00102380"
            ],
            "imported": false,
            "current_name": "print_demangled_string_00102230"
        },
        "FUN_00102430": {
            "renaming": {
                "FUN_00102430": "FUNC_00102430"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00102443) */\n/* WARNING: Removing unreachable block (ram,0x0010244f) */\n\nvoid FUNC_00102430(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_deregisterTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00102430",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "FUNC_00102430"
        },
        "free": {
            "renaming": {},
            "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
            "called": [
                "free"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102040",
            "calling": [
                "FUN_001024f0",
                "FUN_00102380"
            ],
            "imported": false,
            "current_name": "free"
        },
        "xrealloc": {
            "renaming": {},
            "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
            "called": [
                "xrealloc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020e0",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "xrealloc"
        },
        "xexit": {
            "renaming": {},
            "code": "\nvoid xexit(void)\n\n{\n  xexit();\n  return;\n}\n\n",
            "called": [
                "xexit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021e0",
            "calling": [
                "FUN_001024f0",
                "FUN_00102e20"
            ],
            "imported": false,
            "current_name": "xexit"
        },
        "xmalloc_set_program_name": {
            "renaming": {},
            "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
            "called": [
                "xmalloc_set_program_name"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102100",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "xmalloc_set_program_name"
        },
        "__cxa_finalize": {
            "renaming": {},
            "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
            "called": [
                "__cxa_finalize"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102220",
            "calling": [
                "_FINI_0"
            ],
            "imported": false,
            "current_name": "__cxa_finalize"
        },
        "fopen": {
            "renaming": {},
            "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
            "called": [
                "fopen"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021d0",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "fopen"
        },
        "stat": {
            "renaming": {},
            "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 = stat(__file,__buf);\n  return iVar1;\n}\n\n",
            "called": [
                "stat"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102160",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "stat"
        },
        "_DT_FINI": {
            "renaming": {},
            "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102f00",
            "calling": [],
            "imported": false,
            "current_name": "_DT_FINI"
        },
        "getopt_long": {
            "renaming": {},
            "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
            "called": [
                "getopt_long"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001020b0",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "getopt_long"
        },
        "fclose": {
            "renaming": {},
            "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = fclose(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "fclose"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102080",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "fclose"
        },
        "xstrdup": {
            "renaming": {},
            "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
            "called": [
                "xstrdup"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102110",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "xstrdup"
        },
        "fwrite": {
            "renaming": {},
            "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
            "called": [
                "fwrite"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102200",
            "calling": [
                "FUN_0010225e",
                "FUN_00102e20"
            ],
            "imported": false,
            "current_name": "fwrite"
        },
        "cplus_demangle_name_to_style": {
            "renaming": {},
            "code": "\nvoid cplus_demangle_name_to_style(void)\n\n{\n  cplus_demangle_name_to_style();\n  return;\n}\n\n",
            "called": [
                "cplus_demangle_name_to_style"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102030",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "cplus_demangle_name_to_style"
        },
        "fprintf": {
            "renaming": {},
            "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 = fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
            "called": [
                "fprintf"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102140",
            "calling": [
                "FUN_0010225e",
                "FUN_001024f0",
                "FUN_00102e20"
            ],
            "imported": false,
            "current_name": "fprintf"
        },
        "fread": {
            "renaming": {},
            "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 = fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
            "called": [
                "fread"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102060",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "fread"
        },
        "ferror": {
            "renaming": {},
            "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = ferror(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "ferror"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102050",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "ferror"
        },
        "exit": {
            "renaming": {},
            "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
            "called": [
                "exit"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021f0",
            "calling": [
                "FUN_0010225e",
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "exit"
        },
        "entry": {
            "renaming": {},
            "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_001024f0,param_2,&stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "called": [
                "FUN_001024f0",
                "__libc_start_main"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102400",
            "calling": [],
            "imported": false,
            "current_name": "entry"
        },
        "memcpy": {
            "renaming": {},
            "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memcpy"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102170",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "memcpy"
        },
        "memmove": {
            "renaming": {},
            "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 = memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
            "called": [
                "memmove"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x001021c0",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "memmove"
        },
        "FUN_00102e20": {
            "renaming": {
                "FUN_00102e20": "handle_internal_error_00102e20",
                "_stdout": "standardOutput",
                "_stderr": "standardError",
                "xexit": "exitCode"
            },
            "code": "\n\n\nvoid handleInternalError_00102e20(void)\n\n{\n  fflush(standardOutput);\n  fprintf(standardError,\"%s: \",DAT_0010d148);\n  fwrite(\"Internal error: no symbol alphabet for current style\",1,0x34,standardError);\n  putc(10,standardError);\n  xexit(1);\n  return;\n}\n\n",
            "called": [
                "fprintf",
                "fwrite",
                "fflush",
                "xexit",
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102e20",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "handle_internal_error_00102e20"
        },
        "getc": {
            "renaming": {},
            "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 = getc(__stream);\n  return iVar1;\n}\n\n",
            "called": [
                "getc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102210",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "getc"
        },
        "FUN_00102380": {
            "renaming": {
                "FUN_00102380": "parse_and_print_symbol_00102380",
                "param_1": "symbol",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "isSpecialSymbol",
                "__ptr": "demangledSymbol",
                "uVar2": "offset",
                "putc": "printCharacter",
                "_stdout": "stdout",
                "printf": "printFormatted",
                "free": "freeMemory"
            },
            "code": "\n\n\nvoid parseAndPrintSymbol_00102380(char *symbol,undefined8 param2,undefined8 param3,undefined8 param4)\n\n{\n  uint isSpecialSymbol;\n  void *demangledSymbol;\n  ulong offset;\n  \n  isSpecialSymbol = (uint)(*symbol == '.' || *symbol == '$');\n  offset = (ulong)isSpecialSymbol;\n  if ((_DAT_0010d140 != 0) && (symbol[isSpecialSymbol] == '_')) {\n    offset = (ulong)(isSpecialSymbol + 1);\n  }\n  demangledSymbol = (void *)cplus_demangle(symbol + offset,DAT_00105108);\n  if (demangledSymbol != (void *)0x0) {\n    if (*symbol == '.') {\n      putc(0x2e,stdout);\n    }\n    printf(\"%s\",demangledSymbol);\n    freeMemory(demangledSymbol);\n    return;\n  }\n  printf(\"%s\",symbol,param4);\n  return;\n}\n\n",
            "called": [
                "printf",
                "FUN_00102230",
                "free",
                "cplus_demangle",
                "putc"
            ],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102380",
            "calling": [
                "FUN_001024f0"
            ],
            "imported": false,
            "current_name": "parse_and_print_symbol_00102380"
        },
        "FUN_00102020": {
            "renaming": {
                "FUN_00102020": "execute_indirect_jump_00102020",
                "undefined": "jumpAddress"
            },
            "code": "\nvoid executeIndirectJump_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(jumpAddress *)0x0)();\n  return;\n}\n\n",
            "called": [],
            "skipped": false,
            "tags": [],
            "improved": true,
            "entrypoint": "0x00102020",
            "calling": [],
            "imported": false,
            "current_name": "execute_indirect_jump_00102020"
        },
        "FUN_00102460": {
            "renaming": {
                "FUN_00102460": "FUNC_00102460"
            },
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00102484) */\n/* WARNING: Removing unreachable block (ram,0x00102490) */\n\nvoid FUNC_00102460(void)\n\n{\n  return;\n}\n\n",
            "called": [
                "_ITM_registerTMCloneTable"
            ],
            "skipped": true,
            "tags": [],
            "improved": false,
            "entrypoint": "0x00102460",
            "calling": [
                "_INIT_0"
            ],
            "imported": false,
            "current_name": "FUNC_00102460"
        }
    },
    "used_tokens": 6659,
    "layers": [
        [
            "FUN_0010225e",
            "FUN_001024f0",
            "FUN_00102230",
            "FUN_00102e20",
            "FUN_00102380",
            "FUN_00102020"
        ]
    ],
    "locked_functions": []
}