{
  "functions": {
    "FUN_00000410": {
      "entrypoint": "0x00000410",
      "current_name": "FUN_00000410",
      "code": "\nvoid FUN_00000410(void)\n\n{\n  uart_stdio_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000459c"
      ],
      "called": [
        "FUN_00000df4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000428": {
      "entrypoint": "0x00000428",
      "current_name": "FUN_00000428",
      "code": "\ndword FUN_00000428(undefined4 *param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  dword local_c;\n  \n  uVar1 \u003d irq_disable();\n  local_c \u003d Elf32_Rel_ARRAY_1fff0200[0].r_offset;\n  if ((param_2 + Elf32_Rel_ARRAY_1fff0200[0].r_offset \u003c 0x20030001) \u0026\u0026\n     (0x1fff0def \u003c param_2 + Elf32_Rel_ARRAY_1fff0200[0].r_offset)) {\n    Elf32_Rel_ARRAY_1fff0200[0].r_offset \u003d param_2 + Elf32_Rel_ARRAY_1fff0200[0].r_offset;\n  }\n  else {\n    *param_1 \u003d 0xc;\n    local_c \u003d 0xffffffff;\n  }\n  irq_restore(uVar1);\n  return local_c;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004bd0"
      ],
      "called": [
        "FUN_00000d0c",
        "FUN_00000cd0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000490": {
      "entrypoint": "0x00000490",
      "current_name": "FUN_00000490",
      "code": "\nundefined4 FUN_00000490(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d uart_stdio_read(param_3,param_4);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004dc8"
      ],
      "called": [
        "FUN_00000e14"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000004f2": {
      "entrypoint": "0x000004f2",
      "current_name": "FUN_000004f2",
      "code": "\nundefined4 FUN_000004f2(undefined4 *param_1)\n\n{\n  *param_1 \u003d 0x13;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004e26",
        "FUN_00004dee"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000514": {
      "entrypoint": "0x00000514",
      "current_name": "FUN_00000514",
      "code": "\nundefined4 FUN_00000514(undefined4 *param_1)\n\n{\n  *param_1 \u003d 0x13;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000056b8"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000534": {
      "entrypoint": "0x00000534",
      "current_name": "FUN_00000534",
      "code": "\nundefined4 FUN_00000534(undefined4 *param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  \n  *param_1 \u003d 0;\n  if (((param_2 \u003d\u003d 0) || (param_2 \u003d\u003d 1)) || (param_2 \u003d\u003d 2)) {\n    uVar1 \u003d 1;\n  }\n  else {\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005700"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000566": {
      "entrypoint": "0x00000566",
      "current_name": "FUN_00000566",
      "code": "\nint FUN_00000566(int param_1)\n\n{\n  byte bVar1;\n  byte bVar2;\n  byte bVar3;\n  byte bVar4;\n  int iVar5;\n  \n  bVar2 \u003d (byte)param_1;\n  bVar3 \u003d (byte)((uint)param_1 \u003e\u003e 8);\n  bVar4 \u003d (byte)((uint)param_1 \u003e\u003e 0x10);\n  bVar1 \u003d (byte)((uint)param_1 \u003e\u003e 0x18);\n  iVar5 \u003d LZCOUNT((uint)(byte)((((((((bVar2 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 1 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 2 \u0026 1) \u003c\u003c 1\n                                  | bVar2 \u003e\u003e 3 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 4 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 5 \u0026 1) \u003c\u003c\n                                1 | bVar2 \u003e\u003e 6 \u0026 1) \u003c\u003c 1 | bVar2 \u003e\u003e 7) \u003c\u003c 0x18 |\n                  (uint)(byte)((((((((bVar3 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 1 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 2 \u0026 1) \u003c\u003c 1\n                                  | bVar3 \u003e\u003e 3 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 4 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 5 \u0026 1) \u003c\u003c\n                                1 | bVar3 \u003e\u003e 6 \u0026 1) \u003c\u003c 1 | bVar3 \u003e\u003e 7) \u003c\u003c 0x10 |\n                  (uint)(byte)((((((((bVar4 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 1 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 2 \u0026 1) \u003c\u003c 1\n                                  | bVar4 \u003e\u003e 3 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 4 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 5 \u0026 1) \u003c\u003c\n                                1 | bVar4 \u003e\u003e 6 \u0026 1) \u003c\u003c 1 | bVar4 \u003e\u003e 7) \u003c\u003c 8 |\n                  (uint)(byte)((((((((bVar1 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 1 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 2 \u0026 1) \u003c\u003c 1\n                                  | bVar1 \u003e\u003e 3 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 4 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 5 \u0026 1) \u003c\u003c\n                                1 | bVar1 \u003e\u003e 6 \u0026 1) \u003c\u003c 1 | bVar1 \u003e\u003e 7));\n  if (param_1 \u003d\u003d 0) {\n    iVar5 \u003d -1;\n  }\n  return iVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000610"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000058e": {
      "entrypoint": "0x0000058e",
      "current_name": "FUN_0000058e",
      "code": "\nvoid FUN_0000058e(int *param_1,undefined4 *param_2)\n\n{\n  if (*param_1 \u003d\u003d 0) {\n    *param_2 \u003d param_2;\n  }\n  else {\n    *param_2 \u003d *(undefined4 *)*param_1;\n    *(undefined4 **)*param_1 \u003d param_2;\n  }\n  *param_1 \u003d (int)param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000698"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000005ca": {
      "entrypoint": "0x000005ca",
      "current_name": "FUN_000005ca",
      "code": "\nundefined4 * FUN_000005ca(int *param_1)\n\n{\n  undefined4 *puVar1;\n  \n  if (*param_1 \u003d\u003d 0) {\n    puVar1 \u003d (undefined4 *)0x0;\n  }\n  else {\n    puVar1 \u003d *(undefined4 **)*param_1;\n    if (puVar1 \u003d\u003d (undefined4 *)*param_1) {\n      *param_1 \u003d 0;\n    }\n    else {\n      *(undefined4 *)*param_1 \u003d *puVar1;\n    }\n  }\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000698"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000610": {
      "entrypoint": "0x00000610",
      "current_name": "FUN_00000610",
      "code": "\nundefined4 FUN_00000610(void)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  \n  iVar1 \u003d DAT_1fff03dc;\n  DAT_1fff0354 \u003d 0;\n  iVar2 \u003d bitarithm_lsb(DAT_1fff0424);\n  iVar2 \u003d **(int **)(\u0026DAT_1fff03e4 + iVar2 * 4);\n  if (iVar1 \u003d\u003d iVar2 + -8) {\n    uVar3 \u003d 0;\n  }\n  else {\n    if ((iVar1 !\u003d 0) \u0026\u0026 (*(char *)(iVar1 + 4) \u003d\u003d \u0027\\t\u0027)) {\n      *(undefined *)(iVar1 + 4) \u003d 10;\n    }\n    *(undefined *)(iVar2 + -4) \u003d 9;\n    DAT_1fff03e0 \u003d *(undefined2 *)(iVar2 + -2);\n    uVar3 \u003d 1;\n    DAT_1fff03dc \u003d iVar2 + -8;\n  }\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00000566"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000698": {
      "entrypoint": "0x00000698",
      "current_name": "FUN_00000698",
      "code": "\nvoid FUN_00000698(int param_1,uint param_2)\n\n{\n  if (param_2 \u003c 9) {\n    if ((8 \u003c *(byte *)(param_1 + 4)) \u0026\u0026\n       (clist_lpop(\u0026DAT_1fff03e4 + (uint)*(byte *)(param_1 + 5) * 4),\n       *(int *)(\u0026DAT_1fff03e4 + (uint)*(byte *)(param_1 + 5) * 4) \u003d\u003d 0)) {\n      DAT_1fff0424 \u003d DAT_1fff0424 \u0026 ~(1 \u003c\u003c *(sbyte *)(param_1 + 5));\n    }\n  }\n  else if (*(byte *)(param_1 + 4) \u003c 9) {\n    clist_rpush(\u0026DAT_1fff03e4 + (uint)*(byte *)(param_1 + 5) * 4,param_1 + 8);\n    DAT_1fff0424 \u003d DAT_1fff0424 | 1 \u003c\u003c *(sbyte *)(param_1 + 5);\n  }\n  *(char *)(param_1 + 4) \u003d (char)param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000010d4",
        "FUN_00002434",
        "FUN_000024bc",
        "FUN_00000794"
      ],
      "called": [
        "FUN_0000058e",
        "FUN_000005ca"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000738": {
      "entrypoint": "0x00000738",
      "current_name": "FUN_00000738",
      "code": "\nvoid FUN_00000738(ushort param_1)\n\n{\n  int iVar1;\n  \n  if ((*(byte *)(DAT_1fff03dc + 4) \u003c 9) || (param_1 \u003c *(byte *)(DAT_1fff03dc + 5))) {\n    iVar1 \u003d irq_is_in();\n    if (iVar1 \u003d\u003d 0) {\n      thread_yield_higher();\n    }\n    else {\n      DAT_1fff0354 \u003d 1;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000010d4",
        "FUN_000024bc"
      ],
      "called": [
        "FUN_00000d2a",
        "FUN_0000093c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000794": {
      "entrypoint": "0x00000794",
      "current_name": "FUN_00000794",
      "code": "\nint * FUN_00000794(void)\n\n{\n  int extraout_r1;\n  int iVar1;\n  undefined4 *puVar2;\n  uint uVar3;\n  int iStack_1c;\n  int iStack_18;\n  int *piStack_14;\n  \n  irq_disable();\n  *(undefined4 *)(\u0026DAT_1fff0358 + DAT_1fff03e0 * 4) \u003d 0;\n  DAT_1fff0350 \u003d DAT_1fff0350 + -1;\n  sched_set_status(DAT_1fff03dc,0);\n  puVar2 \u003d \u0026DAT_1fff03dc;\n  iVar1 \u003d 0;\n  DAT_1fff03dc \u003d 0;\n  cpu_switch_context_exit();\n  uVar3 \u003d (int)puVar2 + iVar1 \u0026 0xfffffffc;\n  piStack_14 \u003d (int *)(uVar3 - 4);\n  *piStack_14 \u003d 0x77777777;\n  if (((uint)piStack_14 \u0026 7) !\u003d 0) {\n    piStack_14 \u003d (int *)(uVar3 - 8);\n    *piStack_14 \u003d 0x88888888;\n  }\n  piStack_14[-1] \u003d 0x1000000;\n  piStack_14[-2] \u003d iVar1 \u003c\u003c 0xd;\n  piStack_14[-3] \u003d 0x795;\n  piStack_14 \u003d piStack_14 + -4;\n  *piStack_14 \u003d 0;\n  for (iStack_18 \u003d 3; 0 \u003c iStack_18; iStack_18 \u003d iStack_18 + -1) {\n    piStack_14 \u003d piStack_14 + -1;\n    *piStack_14 \u003d iStack_18;\n  }\n  piStack_14 \u003d piStack_14 + -1;\n  *piStack_14 \u003d extraout_r1;\n  for (iStack_1c \u003d 0xb; 3 \u003c iStack_1c; iStack_1c \u003d iStack_1c + -1) {\n    piStack_14 \u003d piStack_14 + -1;\n    *piStack_14 \u003d iStack_1c;\n  }\n  piStack_14[-1] \u003d -3;\n  return piStack_14 + -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00000698",
        "FUN_00000cd0",
        "FUN_00000930"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000007dc": {
      "entrypoint": "0x000007dc",
      "current_name": "FUN_000007dc",
      "code": "\nint * FUN_000007dc(undefined4 param_1,int param_2,int param_3,int param_4)\n\n{\n  uint uVar1;\n  int local_14;\n  int local_10;\n  int *local_c;\n  \n  uVar1 \u003d param_4 + param_3 \u0026 0xfffffffc;\n  local_c \u003d (int *)(uVar1 - 4);\n  *local_c \u003d 0x77777777;\n  if (((uint)local_c \u0026 7) !\u003d 0) {\n    local_c \u003d (int *)(uVar1 - 8);\n    *local_c \u003d 0x88888888;\n  }\n  local_c[-1] \u003d 0x1000000;\n  local_c[-2] \u003d param_1;\n  local_c[-3] \u003d 0x795;\n  local_c \u003d local_c + -4;\n  *local_c \u003d 0;\n  for (local_10 \u003d 3; 0 \u003c local_10; local_10 \u003d local_10 + -1) {\n    local_c \u003d local_c + -1;\n    *local_c \u003d local_10;\n  }\n  local_c \u003d local_c + -1;\n  *local_c \u003d param_2;\n  for (local_14 \u003d 0xb; 3 \u003c local_14; local_14 \u003d local_14 + -1) {\n    local_c \u003d local_c + -1;\n    *local_c \u003d local_14;\n  }\n  local_c[-1] \u003d -3;\n  return local_c + -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000010d4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000008b8": {
      "entrypoint": "0x000008b8",
      "current_name": "FUN_000008b8",
      "code": "\nint FUN_000008b8(void)\n\n{\n  Elf32_Rel *local_c;\n  \n  for (local_c \u003d (Elf32_Rel *)\u0026DAT_1fff0000;\n      (local_c-\u003er_offset \u003d\u003d 0xe7fee7fe \u0026\u0026 (local_c \u003c Elf32_Rel_ARRAY_1fff0200));\n      local_c \u003d (Elf32_Rel *)\u0026local_c-\u003er_info) {\n  }\n  return ((int)Elf32_Rel_ARRAY_1fff0200 - (int)local_c \u003e\u003e 2) \u003c\u003c 2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000211c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000900": {
      "entrypoint": "0x00000900",
      "current_name": "FUN_00000900",
      "code": "\nundefined4 FUN_00000900(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d getMainStackPointer();\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000211c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000091c": {
      "entrypoint": "0x0000091c",
      "current_name": "FUN_0000091c",
      "code": "\nundefined4 FUN_0000091c(void)\n\n{\n  return 0x1fff0000;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000211c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000930": {
      "entrypoint": "0x00000930",
      "current_name": "FUN_00000930",
      "code": "\nvoid FUN_00000930(void)\n\n{\n  irq_enable();\n  software_interrupt(1);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f8c",
        "FUN_00000794"
      ],
      "called": [
        "FUN_00000cf0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000093c": {
      "entrypoint": "0x0000093c",
      "current_name": "FUN_0000093c",
      "code": "\n\n\nvoid FUN_0000093c(void)\n\n{\n  _DAT_e000ed04 \u003d _DAT_e000ed04 | 0x10000000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002798",
        "FUN_00001cf0",
        "FUN_00002434",
        "FUN_00000738",
        "FUN_00001348"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000990": {
      "entrypoint": "0x00000990",
      "current_name": "FUN_00000990",
      "code": "\nvoid FUN_00000990(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000099c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000099c": {
      "entrypoint": "0x0000099c",
      "current_name": "FUN_0000099c",
      "code": "\nvoid FUN_0000099c(void)\n\n{\n  undefined4 uStack_18;\n  undefined4 *local_14;\n  dword *local_10;\n  Elf32_Rel *local_c;\n  \n  local_14 \u003d \u0026uStack_18;\n  local_10 \u003d (dword *)\u0026DAT_00007c60;\n  pre_startup();\n  local_c \u003d (Elf32_Rel *)\u0026DAT_1fff0000;\n  while (local_c \u003c \u0026uStack_18) {\n    local_c-\u003er_offset \u003d 0xe7fee7fe;\n    local_c \u003d (Elf32_Rel *)((int)local_c + 4);\n  }\n  local_c \u003d Elf32_Rel_ARRAY_1fff0200;\n  while (local_c \u003c (Elf32_Rel *)\u0026DAT_1fff0350) {\n    local_c-\u003er_offset \u003d *local_10;\n    local_10 \u003d local_10 + 1;\n    local_c \u003d (Elf32_Rel *)\u0026local_c-\u003er_info;\n  }\n  local_c \u003d (Elf32_Rel *)\u0026DAT_1fff0350;\n  while (local_c \u003c (undefined4 *)0x1fff0df0) {\n    local_c-\u003er_offset \u003d 0;\n    local_c \u003d (Elf32_Rel *)((int)local_c + 4);\n  }\n  post_startup();\n  board_init();\n  __libc_init_array();\n  kernel_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00000f8c",
        "FUN_00000e64",
        "FUN_00000990",
        "FUN_00000db0",
        "FUN_0000459c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000a30": {
      "entrypoint": "0x00000a30",
      "current_name": "FUN_00000a30",
      "code": "\nundefined * FUN_00000a30(void)\n\n{\n  int in_r3;\n  \n  core_panic(4,\"NMI HANDLER\");\n  return \u0026stack0xe000ffe0 + -*(int *)(in_r3 + 0x4c);\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00000f04"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000cc0": {
      "entrypoint": "0x00000cc0",
      "current_name": "FUN_00000cc0",
      "code": "\nundefined4 FUN_00000cc0(void)\n\n{\n  bool bVar1;\n  undefined4 uVar2;\n  \n  core_panic(10,\"DUMMY HANDLER\");\n  uVar2 \u003d 0;\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 \u003d isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000dc0"
      ],
      "called": [
        "FUN_00000f04"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000cd0": {
      "entrypoint": "0x00000cd0",
      "current_name": "FUN_00000cd0",
      "code": "\nundefined4 FUN_00000cd0(void)\n\n{\n  bool bVar1;\n  undefined4 uVar2;\n  \n  uVar2 \u003d 0;\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 \u003d isIRQinterruptsEnabled();\n  }\n  disableIRQinterrupts();\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f8c",
        "FUN_00001c84",
        "FUN_00000f04",
        "FUN_00000e58",
        "FUN_000010d4",
        "FUN_00000428",
        "FUN_00002434",
        "FUN_000024bc",
        "FUN_00000794"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000cf0": {
      "entrypoint": "0x00000cf0",
      "current_name": "FUN_00000cf0",
      "code": "\nundefined4 FUN_00000cf0(void)\n\n{\n  bool bVar1;\n  undefined4 uVar2;\n  \n  enableIRQinterrupts();\n  uVar2 \u003d 0;\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 \u003d isIRQinterruptsEnabled();\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000930"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000d0c": {
      "entrypoint": "0x00000d0c",
      "current_name": "FUN_00000d0c",
      "code": "\nvoid FUN_00000d0c(uint param_1)\n\n{\n  bool bVar1;\n  \n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    enableIRQinterrupts((param_1 \u0026 1) \u003d\u003d 1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001c84",
        "FUN_000010d4",
        "FUN_00000428",
        "FUN_00002434",
        "FUN_000024bc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000d2a": {
      "entrypoint": "0x00000d2a",
      "current_name": "FUN_00000d2a",
      "code": "\nuint FUN_00000d2a(void)\n\n{\n  bool bVar1;\n  uint uVar2;\n  \n  uVar2 \u003d 0;\n  bVar1 \u003d (bool)isCurrentModePrivileged();\n  if (bVar1) {\n    uVar2 \u003d getCurrentExceptionNumber();\n    uVar2 \u003d uVar2 \u0026 0x1f;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000738"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000d44": {
      "entrypoint": "0x00000d44",
      "current_name": "FUN_00000d44",
      "code": "\nint FUN_00000d44(uint param_1,int param_2)\n\n{\n  return param_2 * 4 + (param_1 \u0026 0xf0000000 | (param_1 \u0026 0xfffff) \u003c\u003c 5) + 0x2000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000d76"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000d76": {
      "entrypoint": "0x00000d76",
      "current_name": "FUN_00000d76",
      "code": "\nvoid FUN_00000d76(undefined4 param_1,undefined param_2)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 \u003d (undefined4 *)FUN_00000d44(param_1,param_2);\n  *puVar1 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000d9c"
      ],
      "called": [
        "FUN_00000d44"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000d9c": {
      "entrypoint": "0x00000d9c",
      "current_name": "FUN_00000d9c",
      "code": "\nvoid FUN_00000d9c(void)\n\n{\n  bit_clear32(0x40048040,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000db0"
      ],
      "called": [
        "FUN_00000d76"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000db0": {
      "entrypoint": "0x00000db0",
      "current_name": "FUN_00000db0",
      "code": "\nvoid FUN_00000db0(void)\n\n{\n  wdog_disable();\n  cpu_errata_fixes();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000099c"
      ],
      "called": [
        "FUN_00000dcc",
        "FUN_00000d9c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000dc0": {
      "entrypoint": "0x00000dc0",
      "current_name": "FUN_00000dc0",
      "code": "\nvoid FUN_00000dc0(void)\n\n{\n  dummy_handler_default();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00000cc0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000dcc": {
      "entrypoint": "0x00000dcc",
      "current_name": "FUN_00000dcc",
      "code": "\n\n\nvoid FUN_00000dcc(void)\n\n{\n  _DAT_4005200e \u003d 0xd928;\n  _DAT_40052000 \u003d 0xd2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000db0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000df4": {
      "entrypoint": "0x00000df4",
      "current_name": "FUN_00000df4",
      "code": "\nvoid FUN_00000df4(void)\n\n{\n  uart_init(0,0x1c200,0x12b5,0x1fff0204);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000410"
      ],
      "called": [
        "FUN_000013b8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000e14": {
      "entrypoint": "0x00000e14",
      "current_name": "FUN_00000e14",
      "code": "\nundefined4 FUN_00000e14(undefined4 param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d isrpipe_read(0x1fff0204,param_1,param_2);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000490"
      ],
      "called": [
        "FUN_000012e2"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000e38": {
      "entrypoint": "0x00000e38",
      "current_name": "FUN_00000e38",
      "code": "\nundefined4 FUN_00000e38(undefined4 param_1,undefined4 param_2)\n\n{\n  uart_write(0,param_1,param_2);\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004dee"
      ],
      "called": [
        "FUN_000015d0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000e58": {
      "entrypoint": "0x00000e58",
      "current_name": "FUN_00000e58",
      "code": "\nvoid FUN_00000e58(void)\n\n{\n  irq_disable();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f04"
      ],
      "called": [
        "FUN_00000cd0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000e64": {
      "entrypoint": "0x00000e64",
      "current_name": "FUN_00000e64",
      "code": "\n\n\nvoid FUN_00000e64(void)\n\n{\n  _DAT_40048038 \u003d _DAT_40048038 | 0x200;\n  _DAT_40049048 \u003d _DAT_40049048 \u0026 0xfefff8ff;\n  cpu_init();\n  gpio_init(0x2056,0x80);\n  gpio_init(0x511a,0x80);\n  gpio_init(0x2055,0x80);\n  gpio_set(0x2056);\n  gpio_set(0x511a);\n  gpio_set(0x2055);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000099c"
      ],
      "called": [
        "FUN_00001eea",
        "FUN_00001ff6",
        "FUN_00001274"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000ed8": {
      "entrypoint": "0x00000ed8",
      "current_name": "FUN_00000ed8",
      "code": "\nvoid FUN_00000ed8(void)\n\n{\n  undefined4 in_lr;\n  \n  iprintf(\u0026DAT_00006f58,in_lr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f04"
      ],
      "called": [
        "FUN_00004c84"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000ef8": {
      "entrypoint": "0x00000ef8",
      "current_name": "FUN_00000ef8",
      "code": "\nvoid FUN_00000ef8(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f04"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000f04": {
      "entrypoint": "0x00000f04",
      "current_name": "FUN_00000f04",
      "code": "\nvoid FUN_00000f04(char param_1,undefined4 param_2)\n\n{\n  undefined4 uStack_18;\n  code *UNRECOVERED_JUMPTABLE;\n  undefined4 local_10;\n  char local_9;\n  \n  local_10 \u003d param_2;\n  local_9 \u003d param_1;\n  if (DAT_1fff0468 \u003d\u003d 0) {\n    DAT_1fff0468 \u003d 1;\n    if (param_1 \u003d\u003d \u0027\\x03\u0027) {\n      cpu_print_last_instruction();\n    }\n    iprintf(\"*** RIOT kernel panic:\\n%s\\n\\n\",local_10);\n    ps();\n    iprintf(\u0026DAT_00006f78);\n    iprintf(\"*** halted.\\n\\n\");\n  }\n  irq_disable();\n  panic_arch();\n  UNRECOVERED_JUMPTABLE \u003d (code *)0xf4d;\n  pm_off();\n  uStack_18 \u003d (int)\u0026uStack_18 + 1;\n  auto_init();\n  iprintf(\"main(): This is RIOT! (Version: 2018.04-vm-HEAD)\\n\");\n  main();\n                    /* WARNING: Could not recover jumptable at 0x00000f7a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000cc0",
        "FUN_000013b8",
        "FUN_00000fec",
        "FUN_00000a30",
        "FUN_00003ec4",
        "FUN_00001034"
      ],
      "called": [
        "FUN_00000ed8",
        "FUN_00004c84",
        "FUN_00000ef8",
        "FUN_00000e58",
        "FUN_0000211c",
        "FUN_000023a4",
        "FUN_00002400",
        "FUN_00000cd0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000f8c": {
      "entrypoint": "0x00000f8c",
      "current_name": "FUN_00000f8c",
      "code": "\nvoid FUN_00000f8c(void)\n\n{\n  uint uVar1;\n  undefined4 *puVar2;\n  uint uVar3;\n  int iStack_24;\n  int *piStack_20;\n  undefined4 uStack_1c;\n  undefined4 local_18;\n  undefined4 local_14;\n  dword local_10;\n  \n  irq_disable();\n  local_10 \u003d Elf32_Rel_ARRAY_1fff0200[3].r_info;\n  local_14 \u003d 0;\n  local_18 \u003d 0xf81;\n  thread_create(\u0026DAT_1fff0a6c,0x100,0xf,0xc);\n  local_10 \u003d Elf32_Rel_ARRAY_1fff0200[3].r_offset;\n  local_14 \u003d 0;\n  local_18 \u003d 0xf5d;\n  uVar3 \u003d 0xc;\n  thread_create(\u0026DAT_1fff046c,0x600,7);\n  uStack_1c \u003d 0xfd3;\n  uVar1 \u003d cpu_switch_context_exit();\n  uVar1 \u003d uVar1 \u003e\u003e 0x1e;\n  puVar2 \u003d (undefined4 *)(uVar3 * 0x100);\n  iStack_24 \u003d (uVar3 \u003e\u003e 0x1d) \u003c\u003c 0x11;\n  piStack_20 \u003d \u0026iStack_24;\n  if ((uVar1 \u0026 uVar1 - 1) !\u003d 0) {\n    core_panic(3,\"FAILED ASSERTION.\");\n  }\n  *puVar2 \u003d 0;\n  puVar2[1] \u003d 0;\n  puVar2[2] \u003d uVar1 - 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000099c"
      ],
      "called": [
        "FUN_000010d4",
        "FUN_00000cd0",
        "FUN_00000930"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00000fec": {
      "entrypoint": "0x00000fec",
      "current_name": "FUN_00000fec",
      "code": "\nvoid FUN_00000fec(undefined4 *param_1,uint param_2)\n\n{\n  if ((param_2 \u0026 param_2 - 1) !\u003d 0) {\n    core_panic(3,\"FAILED ASSERTION.\");\n  }\n  *param_1 \u003d 0;\n  param_1[1] \u003d 0;\n  param_1[2] \u003d param_2 - 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000010d4"
      ],
      "called": [
        "FUN_00000f04"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001034": {
      "entrypoint": "0x00001034",
      "current_name": "FUN_00001034",
      "code": "\nvoid FUN_00001034(int **param_1,int param_2)\n\n{\n  int **local_1c;\n  \n  if (8 \u003c *(byte *)(param_2 + 4)) {\n    core_panic(3,\"FAILED ASSERTION.\");\n  }\n  for (local_1c \u003d param_1;\n      (*local_1c !\u003d (int *)0x0 \u0026\u0026 (*(byte *)((int)*local_1c + -3) \u003c\u003d *(byte *)(param_2 + 5)));\n      local_1c \u003d (int **)*local_1c) {\n  }\n  *(int **)(param_2 + 8) \u003d *local_1c;\n  *local_1c \u003d (int *)(int **)(param_2 + 8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002434"
      ],
      "called": [
        "FUN_00000f04"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000010a0": {
      "entrypoint": "0x000010a0",
      "current_name": "FUN_000010a0",
      "code": "\nint FUN_000010a0(int *param_1)\n\n{\n  int *local_c;\n  \n  for (local_c \u003d param_1; (int *)*local_c \u003d\u003d local_c; local_c \u003d local_c + 1) {\n  }\n  return (int)local_c - (int)param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000211c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000010d4": {
      "entrypoint": "0x000010d4",
      "current_name": "FUN_000010d4",
      "code": "\nint FUN_000010d4(uint param_1,int param_2,byte param_3,uint param_4,undefined4 param_5,\n                undefined4 param_6,undefined4 param_7)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  int iVar3;\n  uint uVar4;\n  undefined4 *puVar5;\n  int local_30;\n  uint local_2c;\n  uint local_10;\n  short local_c;\n  short local_a;\n  \n  if (param_3 \u003c 0x10) {\n    local_30 \u003d param_2;\n    local_2c \u003d param_1;\n    if ((param_1 \u0026 3) !\u003d 0) {\n      local_30 \u003d 4 - (param_1 \u0026 3);\n      local_2c \u003d local_30 + param_1;\n      local_30 \u003d param_2 - local_30;\n    }\n    uVar4 \u003d local_30 - 0x30U \u0026 0xfffffffc;\n    puVar5 \u003d (undefined4 *)(uVar4 + local_2c);\n    if ((param_4 \u0026 8) \u003d\u003d 0) {\n      *(uint *)local_2c \u003d local_2c;\n    }\n    else {\n      for (local_10 \u003d local_2c; local_10 \u003c uVar4 + local_2c; local_10 \u003d local_10 + 4) {\n        *(uint *)local_10 \u003d local_10;\n      }\n    }\n    uVar1 \u003d irq_disable();\n    local_a \u003d 0;\n    for (local_c \u003d 1; local_c \u003c 0x21; local_c \u003d local_c + 1) {\n      if (*(int *)(\u0026DAT_1fff0358 + local_c * 4) \u003d\u003d 0) {\n        local_a \u003d local_c;\n        break;\n      }\n    }\n    if (local_a \u003d\u003d 0) {\n      irq_restore(uVar1);\n      iVar3 \u003d -0x8b;\n    }\n    else {\n      *(undefined4 **)(\u0026DAT_1fff0358 + local_a * 4) \u003d puVar5;\n      *(short *)((int)puVar5 + 6) \u003d local_a;\n      uVar2 \u003d thread_stack_init(param_5,param_6,local_2c,uVar4);\n      *puVar5 \u003d uVar2;\n      puVar5[9] \u003d local_2c;\n      puVar5[0xb] \u003d param_2;\n      puVar5[10] \u003d param_7;\n      *(byte *)((int)puVar5 + 5) \u003d param_3;\n      *(undefined *)(puVar5 + 1) \u003d 0;\n      puVar5[2] \u003d 0;\n      puVar5[3] \u003d 0;\n      puVar5[4] \u003d 0;\n      cib_init(puVar5 + 5,0);\n      puVar5[8] \u003d 0;\n      DAT_1fff0350 \u003d DAT_1fff0350 + 1;\n      if ((param_4 \u0026 1) \u003d\u003d 0) {\n        sched_set_status(puVar5,10);\n        if ((param_4 \u0026 4) \u003d\u003d 0) {\n          irq_restore(uVar1);\n          sched_switch(param_3);\n          return (int)local_a;\n        }\n      }\n      else {\n        sched_set_status(puVar5,1);\n      }\n      irq_restore(uVar1);\n      iVar3 \u003d (int)local_a;\n    }\n  }\n  else {\n    iVar3 \u003d -0x16;\n  }\n  return iVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f8c"
      ],
      "called": [
        "FUN_000007dc",
        "FUN_00000698",
        "FUN_00000fec",
        "FUN_00000d0c",
        "FUN_00000738",
        "FUN_00000cd0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001274": {
      "entrypoint": "0x00001274",
      "current_name": "FUN_00001274",
      "code": "\nvoid FUN_00001274(void)\n\n{\n  cortexm_init();\n  DAT_4007e000 \u003d DAT_4007e000 | 0x28;\n  kinetis_mcg_init();\n  periph_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000e64"
      ],
      "called": [
        "FUN_00001c84",
        "FUN_0000258c",
        "FUN_00002396"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000129c": {
      "entrypoint": "0x0000129c",
      "current_name": "FUN_0000129c",
      "code": "\nvoid FUN_0000129c(undefined4 param_1)\n\n{\n  _mutex_lock(param_1,1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000012e2"
      ],
      "called": [
        "FUN_00002434"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000012b4": {
      "entrypoint": "0x000012b4",
      "current_name": "FUN_000012b4",
      "code": "\nundefined4 FUN_000012b4(int param_1,undefined param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d tsrb_add_one(param_1 + 4,param_2);\n  mutex_unlock(param_1);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_000024bc",
        "FUN_00002364"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000012e2": {
      "entrypoint": "0x000012e2",
      "current_name": "FUN_000012e2",
      "code": "\nint FUN_000012e2(int param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  \n  while( true ) {\n    iVar1 \u003d tsrb_get(param_1 + 4,param_2,param_3);\n    if (iVar1 !\u003d 0) break;\n    mutex_lock(param_1);\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000e14"
      ],
      "called": [
        "FUN_0000231c",
        "FUN_0000129c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001318": {
      "entrypoint": "0x00001318",
      "current_name": "FUN_00001318",
      "code": "\nvoid FUN_00001318(byte param_1)\n\n{\n  *(int *)(((uint)(int)(char)param_1 \u003e\u003e 5) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (param_1 \u0026 0x1f);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000014c4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001348": {
      "entrypoint": "0x00001348",
      "current_name": "FUN_00001348",
      "code": "\nvoid FUN_00001348(void)\n\n{\n  if (DAT_1fff0354 !\u003d 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001628"
      ],
      "called": [
        "FUN_0000093c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001360": {
      "entrypoint": "0x00001360",
      "current_name": "FUN_00001360",
      "code": "\nint FUN_00001360(uint param_1,int param_2)\n\n{\n  return param_2 * 4 + (param_1 \u0026 0xf0000000 | (param_1 \u0026 0xfffff) \u003c\u003c 5) + 0x2000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001392"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001392": {
      "entrypoint": "0x00001392",
      "current_name": "FUN_00001392",
      "code": "\nvoid FUN_00001392(undefined4 param_1,undefined param_2)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 \u003d (undefined4 *)FUN_00001360(param_1,param_2);\n  *puVar1 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000013b8"
      ],
      "called": [
        "FUN_00001360"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000013b8": {
      "entrypoint": "0x000013b8",
      "current_name": "FUN_000013b8",
      "code": "\nundefined4 FUN_000013b8(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 !\u003d 0) {\n    core_panic(3,\"FAILED ASSERTION.\");\n  }\n  *(undefined4 *)(\u0026DAT_1fff0b6c + param_1 * 8) \u003d param_3;\n  *(undefined4 *)(\u0026DAT_1fff0b70 + param_1 * 8) \u003d param_4;\n  uart_init_pins(param_1);\n  FUN_00001392(*(undefined4 *)(\u0026DAT_00006ffc + param_1 * 0x20),\n               *(undefined *)(param_1 * 0x20 + 0x7000));\n  if ((\u0026DAT_00007002)[param_1 * 0x20] \u003d\u003d \u0027\\0\u0027) {\n    uart_init_uart(param_1,param_2);\n    uVar1 \u003d 0;\n  }\n  else {\n    uVar1 \u003d 0xffffffff;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000df4"
      ],
      "called": [
        "FUN_00001392",
        "FUN_00000f04",
        "FUN_000014c4",
        "FUN_00001448"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001448": {
      "entrypoint": "0x00001448",
      "current_name": "FUN_00001448",
      "code": "\nvoid FUN_00001448(int param_1)\n\n{\n  if (*(short *)(\u0026DAT_00006fec + param_1 * 0x20) !\u003d -1) {\n    gpio_init_port(*(undefined2 *)(\u0026DAT_00006fec + param_1 * 0x20),\n                   *(undefined4 *)(\u0026DAT_00006ff0 + param_1 * 0x20));\n  }\n  if (*(short *)(\u0026DAT_00006fee + param_1 * 0x20) !\u003d -1) {\n    gpio_init_port(*(undefined2 *)(\u0026DAT_00006fee + param_1 * 0x20),\n                   *(undefined4 *)(\u0026DAT_00006ff4 + param_1 * 0x20));\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000013b8"
      ],
      "called": [
        "FUN_00001f80"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000014c4": {
      "entrypoint": "0x000014c4",
      "current_name": "FUN_000014c4",
      "code": "\nvoid FUN_000014c4(int param_1,uint param_2)\n\n{\n  byte *pbVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  pbVar1 \u003d *(byte **)(\u0026DAT_00006fe4 + param_1 * 0x20);\n  uVar2 \u003d *(uint *)(\u0026DAT_00006fe8 + param_1 * 0x20);\n  pbVar1[3] \u003d pbVar1[3] \u0026 0xf3;\n  pbVar1[2] \u003d (\u0026DAT_00007001)[param_1 * 0x20];\n  uVar3 \u003d uVar2 / (param_2 \u003c\u003c 4);\n  *pbVar1 \u003d (byte)(uVar3 \u003e\u003e 8) \u0026 0x1f;\n  pbVar1[1] \u003d (byte)uVar3;\n  pbVar1[10] \u003d (byte)((uVar2 \u003c\u003c 2) / param_2 + 1 \u003e\u003e 1) \u0026 0x1f;\n  pbVar1[0x10] \u003d pbVar1[0x10] | 0x88;\n  if ((pbVar1[0x10] \u0026 0x70) \u003d\u003d 0) {\n    pbVar1[0x13] \u003d 0;\n  }\n  else {\n    pbVar1[0x13] \u003d (char)(2 \u003c\u003c (pbVar1[0x10] \u003e\u003e 4 \u0026 7)) - 1;\n  }\n  pbVar1[0x15] \u003d 1;\n  pbVar1[0x11] \u003d 0xc0;\n  pbVar1[3] \u003d pbVar1[3] | 0x2c;\n  FUN_00001318((int)(char)(\u0026DAT_00006ff8)[param_1 * 0x20]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000013b8"
      ],
      "called": [
        "FUN_00001318"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000015d0": {
      "entrypoint": "0x000015d0",
      "current_name": "FUN_000015d0",
      "code": "\nvoid FUN_000015d0(int param_1,int param_2,uint param_3)\n\n{\n  int iVar1;\n  uint local_c;\n  \n  iVar1 \u003d *(int *)(\u0026DAT_00006fe4 + param_1 * 0x20);\n  for (local_c \u003d 0; local_c \u003c param_3; local_c \u003d local_c + 1) {\n    do {\n    } while (-1 \u003c *(char *)(iVar1 + 4));\n    *(undefined *)(iVar1 + 7) \u003d *(undefined *)(local_c + param_2);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000e38"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001628": {
      "entrypoint": "0x00001628",
      "current_name": "FUN_00001628",
      "code": "\nvoid FUN_00001628(int param_1)\n\n{\n  if (((*(byte *)(*(int *)(\u0026DAT_00006fe4 + param_1 * 0x20) + 4) \u0026 0x20) !\u003d 0) \u0026\u0026\n     (*(int *)(\u0026DAT_1fff0b6c + param_1 * 8) !\u003d 0)) {\n    (**(code **)(\u0026DAT_1fff0b6c + param_1 * 8))\n              (*(undefined4 *)(\u0026DAT_1fff0b70 + param_1 * 8),\n               *(undefined *)(*(int *)(\u0026DAT_00006fe4 + param_1 * 0x20) + 7));\n  }\n  FUN_00001348();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001688"
      ],
      "called": [
        "FUN_00001348"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001688": {
      "entrypoint": "0x00001688",
      "current_name": "FUN_00001688",
      "code": "\nvoid FUN_00001688(void)\n\n{\n  irq_handler_uart(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00001628"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001696": {
      "entrypoint": "0x00001696",
      "current_name": "FUN_00001696",
      "code": "\nint FUN_00001696(uint param_1,int param_2)\n\n{\n  return param_2 * 4 + (param_1 \u0026 0xf0000000 | (param_1 \u0026 0xfffff) \u003c\u003c 5) + 0x2000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000016c8",
        "FUN_00001710",
        "FUN_000016ec"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000016c8": {
      "entrypoint": "0x000016c8",
      "current_name": "FUN_000016c8",
      "code": "\nvoid FUN_000016c8(undefined4 param_1,undefined param_2)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 \u003d (undefined4 *)FUN_00001696(param_1,param_2);\n  *puVar1 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000017dc"
      ],
      "called": [
        "FUN_00001696"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000016ec": {
      "entrypoint": "0x000016ec",
      "current_name": "FUN_000016ec",
      "code": "\nvoid FUN_000016ec(undefined4 param_1,undefined param_2)\n\n{\n  undefined *puVar1;\n  \n  puVar1 \u003d (undefined *)FUN_00001696(param_1,param_2);\n  *puVar1 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000182c",
        "FUN_00001778",
        "FUN_00001a60",
        "FUN_00001a3c",
        "FUN_00001a18"
      ],
      "called": [
        "FUN_00001696"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001710": {
      "entrypoint": "0x00001710",
      "current_name": "FUN_00001710",
      "code": "\nvoid FUN_00001710(undefined4 param_1,undefined param_2)\n\n{\n  undefined *puVar1;\n  \n  puVar1 \u003d (undefined *)FUN_00001696(param_1,param_2);\n  *puVar1 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000182c",
        "FUN_00001778",
        "FUN_000019c0",
        "FUN_000018bc",
        "FUN_00001a60",
        "FUN_00001960",
        "FUN_00001734",
        "FUN_00001bb8"
      ],
      "called": [
        "FUN_00001696"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001734": {
      "entrypoint": "0x00001734",
      "current_name": "FUN_00001734",
      "code": "\nvoid FUN_00001734(void)\n\n{\n  bit_clear8(\u0026DAT_40064005,6);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000019c0",
        "FUN_00001a3c",
        "FUN_00001a18"
      ],
      "called": [
        "FUN_00001710"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001748": {
      "entrypoint": "0x00001748",
      "current_name": "FUN_00001748",
      "code": "\nvoid FUN_00001748(byte param_1)\n\n{\n  DAT_40064003 \u003d param_1 | DAT_40064003 \u0026 0x1f;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000019c0",
        "FUN_000018bc",
        "FUN_00001960",
        "FUN_0000191c",
        "FUN_00001bb8"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001778": {
      "entrypoint": "0x00001778",
      "current_name": "FUN_00001778",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0000179c) */\n/* WARNING: Removing unreachable block (ram,0x000017b2) */\n/* WARNING: Removing unreachable block (ram,0x000017c0) */\n\nvoid FUN_00001778(void)\n\n{\n  DAT_40064001 \u003d DAT_40064001 \u0026 0xcf | 0x20;\n  bit_clear8(\u0026DAT_40064001,2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000019c0",
        "FUN_0000191c"
      ],
      "called": [
        "FUN_00001710",
        "FUN_000016ec"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000017dc": {
      "entrypoint": "0x000017dc",
      "current_name": "FUN_000017dc",
      "code": "\n\n\nvoid FUN_000017dc(void)\n\n{\n  FUN_000016c8(\u0026DAT_4004803c,0x1d);\n  if ((_DAT_4003d010 \u0026 0x100) \u003d\u003d 0) {\n    _DAT_4003d010 \u003d 0x104;\n  }\n  _DAT_40047000 \u003d _DAT_40047000 \u0026 0xfff3ffff | 0x80000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001c84"
      ],
      "called": [
        "FUN_000016c8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000182c": {
      "entrypoint": "0x0000182c",
      "current_name": "FUN_0000182c",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0000187c) */\n/* WARNING: Removing unreachable block (ram,0x0000186a) */\n/* WARNING: Removing unreachable block (ram,0x00001898) */\n\nvoid FUN_0000182c(void)\n\n{\n  DAT_40064008 \u003d DAT_40064008 \u0026 0xd0;\n  bit_set8(\u0026DAT_40064001,0);\n  bit_clear8(\u0026DAT_40064000,1);\n  bit_clear8(\u0026DAT_40064000,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001c84"
      ],
      "called": [
        "FUN_00001710",
        "FUN_000016ec"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000018bc": {
      "entrypoint": "0x000018bc",
      "current_name": "FUN_000018bc",
      "code": "\nvoid FUN_000018bc(void)\n\n{\n  kinetis_mcg_set_fll_factor(0xa0);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b | 4;\n  bit_clear8(\u0026DAT_40064001,1);\n  do {\n  } while ((DAT_40064006 \u0026 0x10) \u003d\u003d 0);\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 0);\n  DAT_1fff0b74 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001b10"
      ],
      "called": [
        "FUN_00001748",
        "FUN_00001710"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000191c": {
      "entrypoint": "0x0000191c",
      "current_name": "FUN_0000191c",
      "code": "\nvoid FUN_0000191c(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(0x40);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 0);\n  DAT_1fff0b74 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001b10"
      ],
      "called": [
        "FUN_00001748",
        "FUN_00001778"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001960": {
      "entrypoint": "0x00001960",
      "current_name": "FUN_00001960",
      "code": "\nvoid FUN_00001960(void)\n\n{\n  kinetis_mcg_set_fll_factor(0xa0);\n  bit_clear8(\u0026DAT_40064001,1);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b | 0x44;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 4);\n  do {\n  } while ((DAT_40064006 \u0026 0x10) \u003d\u003d 0);\n  DAT_1fff0b74 \u003d 2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001b10"
      ],
      "called": [
        "FUN_00001710",
        "FUN_00001748"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000019c0": {
      "entrypoint": "0x000019c0",
      "current_name": "FUN_000019c0",
      "code": "\nvoid FUN_000019c0(void)\n\n{\n  kinetis_mcg_enable_osc();\n  kinetis_mcg_set_fll_factor(0x40);\n  bit_clear8(\u0026DAT_40064001,1);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b | 0x80;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 8);\n  kinetis_mcg_disable_pll();\n  DAT_1fff0b74 \u003d 3;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001b10"
      ],
      "called": [
        "FUN_00001710",
        "FUN_00001748",
        "FUN_00001778",
        "FUN_00001734"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001a18": {
      "entrypoint": "0x00001a18",
      "current_name": "FUN_00001a18",
      "code": "\nvoid FUN_00001a18(void)\n\n{\n  bit_set8(\u0026DAT_40064001,1);\n  kinetis_mcg_disable_pll();\n  DAT_1fff0b74 \u003d 4;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001b10"
      ],
      "called": [
        "FUN_000016ec",
        "FUN_00001734"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001a3c": {
      "entrypoint": "0x00001a3c",
      "current_name": "FUN_00001a3c",
      "code": "\nvoid FUN_00001a3c(void)\n\n{\n  bit_set8(\u0026DAT_40064001,1);\n  kinetis_mcg_disable_pll();\n  DAT_1fff0b74 \u003d 5;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001b10"
      ],
      "called": [
        "FUN_000016ec",
        "FUN_00001734"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001a60": {
      "entrypoint": "0x00001a60",
      "current_name": "FUN_00001a60",
      "code": "\nvoid FUN_00001a60(void)\n\n{\n  bit_clear8(\u0026DAT_40064001,1);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3f | 0x80;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 8);\n  bit_set8(\u0026DAT_40064005,6);\n  do {\n  } while ((DAT_40064006 \u0026 0x20) \u003d\u003d 0);\n  do {\n  } while ((DAT_40064006 \u0026 0x40) \u003d\u003d 0);\n  DAT_1fff0b74 \u003d 6;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001b10"
      ],
      "called": [
        "FUN_00001710",
        "FUN_000016ec"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001ad4": {
      "entrypoint": "0x00001ad4",
      "current_name": "FUN_00001ad4",
      "code": "\nvoid FUN_00001ad4(void)\n\n{\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3f;\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 0xc);\n  DAT_1fff0b74 \u003d 7;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001b10"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001b10": {
      "entrypoint": "0x00001b10",
      "current_name": "FUN_00001b10",
      "code": "\nundefined4 FUN_00001b10(byte param_1)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 \u003c 8) {\n    do {\n      switch((\u0026DAT_00007004)[(uint)param_1 + (uint)DAT_1fff0b74 * 8]) {\n      case 0:\n        kinetis_mcg_set_fei();\n        break;\n      case 1:\n        kinetis_mcg_set_fee();\n        break;\n      case 2:\n        kinetis_mcg_set_fbi();\n        break;\n      case 3:\n        kinetis_mcg_set_fbe();\n        break;\n      case 4:\n        kinetis_mcg_set_blpi();\n        break;\n      case 5:\n        kinetis_mcg_set_blpe();\n        break;\n      case 6:\n        kinetis_mcg_set_pbe();\n        break;\n      case 7:\n        kinetis_mcg_set_pee();\n        break;\n      default:\n        return 0xffffffff;\n      }\n    } while (param_1 !\u003d DAT_1fff0b74);\n    uVar1 \u003d 0;\n  }\n  else {\n    uVar1 \u003d 0xffffffff;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001c84"
      ],
      "called": [
        "FUN_00001ad4",
        "FUN_000019c0",
        "FUN_000018bc",
        "FUN_00001a60",
        "FUN_00001960",
        "FUN_00001a3c",
        "FUN_0000191c",
        "FUN_00001a18"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001bb8": {
      "entrypoint": "0x00001bb8",
      "current_name": "FUN_00001bb8",
      "code": "\nvoid FUN_00001bb8(void)\n\n{\n  if ((DAT_40064001 \u0026 2) !\u003d 0) {\n    bit_clear8(\u0026DAT_40064001,1);\n  }\n  if ((DAT_40064005 \u0026 0x40) !\u003d 0) {\n    if ((DAT_40064000 \u0026 0xc0) \u003d\u003d 0) {\n      DAT_40064000 \u003d DAT_40064000 \u0026 0x3f | 0x80;\n      do {\n      } while ((DAT_40064006 \u0026 0xc) !\u003d 8);\n    }\n    bit_clear8(\u0026DAT_40064005,6);\n    do {\n    } while ((DAT_40064006 \u0026 0x20) !\u003d 0);\n  }\n  kinetis_mcg_set_fll_factor(0);\n  DAT_40064000 \u003d DAT_40064000 \u0026 0x3b | 4;\n  do {\n  } while ((DAT_40064006 \u0026 0x10) \u003d\u003d 0);\n  do {\n  } while ((DAT_40064006 \u0026 0xc) !\u003d 0);\n  DAT_1fff0b74 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001c84"
      ],
      "called": [
        "FUN_00001710",
        "FUN_00001748"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001c84": {
      "entrypoint": "0x00001c84",
      "current_name": "FUN_00001c84",
      "code": "\n\n\nvoid FUN_00001c84(void)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d irq_disable();\n  kinetis_mcg_set_safe_mode();\n  _DAT_40048044 \u003d 0x220000;\n  DAT_4006400c \u003d 0;\n  DAT_40064000 \u003d DAT_40064000 \u0026 199 | 0x38;\n  DAT_40064004 \u003d 0x13;\n  DAT_40064005 \u003d 0;\n  kinetis_mcg_init_mcgirclk();\n  kinetis_mcg_init_erclk32k();\n  kinetis_mcg_set_mode(7);\n  irq_restore(uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001274"
      ],
      "called": [
        "FUN_0000182c",
        "FUN_00000d0c",
        "FUN_00000cd0",
        "FUN_00001b10",
        "FUN_00001bb8",
        "FUN_000017dc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001cf0": {
      "entrypoint": "0x00001cf0",
      "current_name": "FUN_00001cf0",
      "code": "\nvoid FUN_00001cf0(void)\n\n{\n  if (DAT_1fff0354 !\u003d 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002028"
      ],
      "called": [
        "FUN_0000093c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001d08": {
      "entrypoint": "0x00001d08",
      "current_name": "FUN_00001d08",
      "code": "\nint FUN_00001d08(uint param_1,int param_2)\n\n{\n  return param_2 * 4 + (param_1 \u0026 0xf0000000 | (param_1 \u0026 0xfffff) \u003c\u003c 5) + 0x2000000;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001d3a"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001d3a": {
      "entrypoint": "0x00001d3a",
      "current_name": "FUN_00001d3a",
      "code": "\nvoid FUN_00001d3a(undefined4 param_1,undefined param_2)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 \u003d (undefined4 *)bitband_addr(param_1,param_2);\n  *puVar1 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001ddc"
      ],
      "called": [
        "FUN_00001d08"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001d5e": {
      "entrypoint": "0x00001d5e",
      "current_name": "FUN_00001d5e",
      "code": "\nuint FUN_00001d5e(ushort param_1)\n\n{\n  return param_1 \u0026 0x7000 | 0x40048000;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001eea",
        "FUN_00001f80"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001d80": {
      "entrypoint": "0x00001d80",
      "current_name": "FUN_00001d80",
      "code": "\nuint FUN_00001d80(ushort param_1)\n\n{\n  return param_1 \u0026 0x1c0 | 0x400ff000;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001eea",
        "FUN_00001ff6"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001da2": {
      "entrypoint": "0x00001da2",
      "current_name": "FUN_00001da2",
      "code": "\nushort FUN_00001da2(ushort param_1)\n\n{\n  return param_1 \u003e\u003e 6 \u0026 7;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001f80",
        "FUN_00001ddc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001dc0": {
      "entrypoint": "0x00001dc0",
      "current_name": "FUN_00001dc0",
      "code": "\nushort FUN_00001dc0(ushort param_1)\n\n{\n  return param_1 \u0026 0x3f;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001eea",
        "FUN_00001f80",
        "FUN_00001ff6"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001ddc": {
      "entrypoint": "0x00001ddc",
      "current_name": "FUN_00001ddc",
      "code": "\nvoid FUN_00001ddc(undefined2 param_1)\n\n{\n  char cVar1;\n  \n  cVar1 \u003d port_num(param_1);\n  bit_set32(\u0026DAT_40048038,cVar1 + \u0027\\t\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001f80"
      ],
      "called": [
        "FUN_00001d3a",
        "FUN_00001da2"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001e0c": {
      "entrypoint": "0x00001e0c",
      "current_name": "FUN_00001e0c",
      "code": "\nuint FUN_00001e0c(int param_1,uint param_2)\n\n{\n  return *(uint *)(\u0026DAT_1fff0bd8 + (((int)param_2 \u003e\u003e 3) + param_1 * 4) * 4) \u003e\u003e ((param_2 \u0026 7) \u003c\u003c 2)\n         \u0026 0xf;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002028",
        "FUN_00001ec4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001e44": {
      "entrypoint": "0x00001e44",
      "current_name": "FUN_00001e44",
      "code": "\nvoid FUN_00001e44(int param_1,uint param_2,int param_3)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d (int)param_2 \u003e\u003e 3;\n  *(uint *)(\u0026DAT_1fff0bd8 + (iVar1 + param_1 * 4) * 4) \u003d\n       *(uint *)(\u0026DAT_1fff0bd8 + (iVar1 + param_1 * 4) * 4) \u0026 ~(0xf \u003c\u003c ((param_2 \u0026 7) \u003c\u003c 2));\n  *(uint *)(\u0026DAT_1fff0bd8 + (iVar1 + param_1 * 4) * 4) \u003d\n       *(uint *)(\u0026DAT_1fff0bd8 + (iVar1 + param_1 * 4) * 4) | param_3 \u003c\u003c ((param_2 \u0026 7) \u003c\u003c 2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001ec4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001ec4": {
      "entrypoint": "0x00001ec4",
      "current_name": "FUN_00001ec4",
      "code": "\nvoid FUN_00001ec4(undefined4 param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d get_ctx(param_1,param_2);\n  write_map(param_1,param_2,uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001f80"
      ],
      "called": [
        "FUN_00001e0c",
        "FUN_00001e44"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001eea": {
      "entrypoint": "0x00001eea",
      "current_name": "FUN_00001eea",
      "code": "\nundefined4 FUN_00001eea(undefined2 param_1,byte param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  \n  gpio_init_port(param_1,0);\n  if ((char)param_2 \u003c \u0027\\0\u0027) {\n    uVar1 \u003d pin_num(param_1);\n    iVar2 \u003d gpio(param_1);\n    *(uint *)(iVar2 + 0x14) \u003d *(uint *)(iVar2 + 0x14) | 1 \u003c\u003c (uVar1 \u0026 0xff);\n  }\n  else {\n    uVar1 \u003d pin_num(param_1);\n    iVar2 \u003d gpio(param_1);\n    *(uint *)(iVar2 + 0x14) \u003d *(uint *)(iVar2 + 0x14) \u0026 ~(1 \u003c\u003c (uVar1 \u0026 0xff));\n  }\n  iVar2 \u003d port(param_1);\n  iVar3 \u003d pin_num(param_1);\n  *(uint *)(iVar2 + iVar3 * 4) \u003d param_2 \u0026 0x23 | 0x100;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000e64"
      ],
      "called": [
        "FUN_00001d5e",
        "FUN_00001f80",
        "FUN_00001d80",
        "FUN_00001dc0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001f80": {
      "entrypoint": "0x00001f80",
      "current_name": "FUN_00001f80",
      "code": "\nvoid FUN_00001f80(undefined2 param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  uint uVar5;\n  \n  clk_en(param_1);\n  iVar1 \u003d port(param_1);\n  iVar2 \u003d pin_num(param_1);\n  uVar5 \u003d *(uint *)(iVar1 + iVar2 * 4);\n  iVar1 \u003d port(param_1);\n  iVar2 \u003d pin_num(param_1);\n  *(undefined4 *)(iVar1 + iVar2 * 4) \u003d param_2;\n  if ((uVar5 \u0026 0xf0000) !\u003d 0) {\n    uVar3 \u003d port_num(param_1);\n    uVar4 \u003d pin_num(param_1);\n    ctx_clear(uVar3,uVar4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001eea",
        "FUN_00001448"
      ],
      "called": [
        "FUN_00001d5e",
        "FUN_00001ddc",
        "FUN_00001da2",
        "FUN_00001ec4",
        "FUN_00001dc0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00001ff6": {
      "entrypoint": "0x00001ff6",
      "current_name": "FUN_00001ff6",
      "code": "\nvoid FUN_00001ff6(undefined2 param_1)\n\n{\n  uint uVar1;\n  int iVar2;\n  \n  uVar1 \u003d pin_num(param_1);\n  iVar2 \u003d gpio(param_1);\n  *(int *)(iVar2 + 4) \u003d 1 \u003c\u003c (uVar1 \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000e64"
      ],
      "called": [
        "FUN_00001d80",
        "FUN_00001dc0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002028": {
      "entrypoint": "0x00002028",
      "current_name": "FUN_00002028",
      "code": "\nvoid FUN_00002028(int param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint local_c;\n  \n  uVar2 \u003d *(uint *)(param_1 + 0xa0);\n  for (local_c \u003d 0; (int)local_c \u003c 0x20; local_c \u003d local_c + 1) {\n    if (((uVar2 \u0026 1 \u003c\u003c (local_c \u0026 0xff)) !\u003d 0) \u0026\u0026\n       ((*(uint *)(param_1 + local_c * 4) \u0026 0xf0000) !\u003d 0)) {\n      *(int *)(param_1 + 0xa0) \u003d 1 \u003c\u003c (local_c \u0026 0xff);\n      iVar1 \u003d get_ctx(param_2,local_c);\n      (**(code **)(\u0026DAT_1fff0b78 + iVar1 * 0xc))(*(undefined4 *)(\u0026DAT_1fff0b7c + iVar1 * 0xc));\n    }\n  }\n  FUN_00001cf0();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000020f4",
        "FUN_000020b8",
        "FUN_00002108",
        "FUN_000020cc",
        "FUN_000020e0"
      ],
      "called": [
        "FUN_00001e0c",
        "FUN_00001cf0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000020b8": {
      "entrypoint": "0x000020b8",
      "current_name": "FUN_000020b8",
      "code": "\nvoid FUN_000020b8(void)\n\n{\n  irq_handler(0x40049000,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00002028"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000020cc": {
      "entrypoint": "0x000020cc",
      "current_name": "FUN_000020cc",
      "code": "\nvoid FUN_000020cc(void)\n\n{\n  irq_handler(0x4004a000,1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00002028"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000020e0": {
      "entrypoint": "0x000020e0",
      "current_name": "FUN_000020e0",
      "code": "\nvoid FUN_000020e0(void)\n\n{\n  irq_handler(0x4004b000,2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00002028"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000020f4": {
      "entrypoint": "0x000020f4",
      "current_name": "FUN_000020f4",
      "code": "\nvoid FUN_000020f4(void)\n\n{\n  irq_handler(0x4004c000,3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00002028"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002108": {
      "entrypoint": "0x00002108",
      "current_name": "FUN_00002108",
      "code": "\nvoid FUN_00002108(void)\n\n{\n  irq_handler(0x4004d000,4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00002028"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000211c": {
      "entrypoint": "0x0000211c",
      "current_name": "FUN_0000211c",
      "code": "\nvoid FUN_0000211c(void)\n\n{\n  int iVar1;\n  undefined2 local_40;\n  int local_3c;\n  int local_38;\n  dword local_34;\n  uint local_30;\n  undefined4 *local_2c;\n  undefined4 local_28;\n  undefined4 local_24;\n  int local_20;\n  short local_1a;\n  int local_18;\n  int local_14;\n  \n  local_40 \u003d 0x515f;\n  local_14 \u003d 0;\n  local_18 \u003d 0;\n  iprintf(\"\\tpid | %-21s| %-9sQ | pri | stack  ( used) | base addr  | current     \\n\",\u0026DAT_000070b8,\n          \"state\");\n  local_20 \u003d thread_isr_stack_usage();\n  local_24 \u003d thread_isr_stack_start();\n  local_28 \u003d thread_isr_stack_pointer();\n  iprintf(\"\\t  - | isr_stack            | -        - |   - | %6i (%5i) | %10p | %10p\\n\",0x200,\n          local_20,local_24,local_28);\n  local_14 \u003d local_14 + 0x200;\n  if (0 \u003c local_20) {\n    local_18 \u003d local_20 + local_18;\n  }\n  for (local_1a \u003d 1; local_1a \u003c 0x21; local_1a \u003d local_1a + 1) {\n    local_2c \u003d *(undefined4 **)(\u0026DAT_1fff0358 + local_1a * 4);\n    if (local_2c !\u003d (undefined4 *)0x0) {\n      local_30 \u003d (uint)*(byte *)(local_2c + 1);\n      local_34 \u003d (\u0026Elf32_Rel_ARRAY_1fff0200[4].r_offset)[local_30];\n      local_38 \u003d (int)\u0026local_40 + (uint)(8 \u003c local_30);\n      local_3c \u003d local_2c[0xb];\n      local_14 \u003d local_3c + local_14;\n      iVar1 \u003d thread_measure_stack_free(local_2c[9]);\n      local_3c \u003d local_3c - iVar1;\n      local_18 \u003d local_3c + local_18;\n      iprintf(\"\\t%3hi | %-20s | %-8s %.1s | %3i | %6i (%5i) | %10p | %10p \\n\",\n              (int)*(short *)((int)local_2c + 6),local_2c[10],local_34,local_38,\n              *(undefined *)((int)local_2c + 5),local_2c[0xb],local_3c,local_2c[9],*local_2c);\n    }\n  }\n  iprintf(\"\\t%5s %-21s|%13s%6s %6i (%5i)\\n\",\u0026DAT_00007190,\u0026DAT_00007194,\u0026DAT_00007190,\u0026DAT_00007190,\n          local_14,local_18);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f04",
        "FUN_00002eb4"
      ],
      "called": [
        "FUN_00004c84",
        "FUN_0000091c",
        "FUN_000008b8",
        "FUN_00000900",
        "FUN_000010a0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002270": {
      "entrypoint": "0x00002270",
      "current_name": "FUN_00002270",
      "code": "\nundefined FUN_00002270(int param_1)\n\n{\n  undefined uVar1;\n  int iVar2;\n  bool bVar3;\n  \n  iVar2 \u003d *(int *)(param_1 + 0xc);\n  bVar3 \u003d *(int *)(param_1 + 8) \u003d\u003d iVar2;\n  if (bVar3) {\n    iVar2 \u003d 1;\n  }\n  uVar1 \u003d (undefined)iVar2;\n  if (!bVar3) {\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000231c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002294": {
      "entrypoint": "0x00002294",
      "current_name": "FUN_00002294",
      "code": "\nundefined FUN_00002294(int param_1)\n\n{\n  undefined uVar1;\n  int iVar2;\n  bool bVar3;\n  \n  iVar2 \u003d *(int *)(param_1 + 4);\n  bVar3 \u003d *(int *)(param_1 + 0xc) - *(int *)(param_1 + 8) \u003d\u003d iVar2;\n  if (bVar3) {\n    iVar2 \u003d 1;\n  }\n  uVar1 \u003d (undefined)iVar2;\n  if (!bVar3) {\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002364"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000022be": {
      "entrypoint": "0x000022be",
      "current_name": "FUN_000022be",
      "code": "\nvoid FUN_000022be(int *param_1,undefined param_2)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d param_1[3];\n  param_1[3] \u003d uVar1 + 1;\n  *(undefined *)((uVar1 \u0026 param_1[1] - 1U) + *param_1) \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002364"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000022f0": {
      "entrypoint": "0x000022f0",
      "current_name": "FUN_000022f0",
      "code": "\nundefined FUN_000022f0(int *param_1)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d param_1[2];\n  param_1[2] \u003d uVar1 + 1;\n  return *(undefined *)((uVar1 \u0026 param_1[1] - 1U) + *param_1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000231c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000231c": {
      "entrypoint": "0x0000231c",
      "current_name": "FUN_0000231c",
      "code": "\nint FUN_0000231c(undefined4 param_1,undefined *param_2,int param_3)\n\n{\n  undefined uVar1;\n  int iVar2;\n  undefined *local_20;\n  int local_14;\n  \n  local_20 \u003d param_2;\n  local_14 \u003d param_3;\n  while ((local_14 !\u003d 0 \u0026\u0026 (iVar2 \u003d tsrb_empty(param_1), iVar2 \u003d\u003d 0))) {\n    uVar1 \u003d _pop(param_1);\n    *local_20 \u003d uVar1;\n    local_14 \u003d local_14 + -1;\n    local_20 \u003d local_20 + 1;\n  }\n  return param_3 - local_14;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000012e2"
      ],
      "called": [
        "FUN_000022f0",
        "FUN_00002270"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002364": {
      "entrypoint": "0x00002364",
      "current_name": "FUN_00002364",
      "code": "\nundefined4 FUN_00002364(undefined4 param_1,undefined param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  iVar1 \u003d tsrb_full(param_1);\n  if (iVar1 \u003d\u003d 0) {\n    _push(param_1,param_2);\n    uVar2 \u003d 0;\n  }\n  else {\n    uVar2 \u003d 0xffffffff;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000012b4"
      ],
      "called": [
        "FUN_000022be",
        "FUN_00002294"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002396": {
      "entrypoint": "0x00002396",
      "current_name": "FUN_00002396",
      "code": "\nvoid FUN_00002396(void)\n\n{\n  rtc_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001274"
      ],
      "called": [
        "FUN_000025f4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000023a4": {
      "entrypoint": "0x000023a4",
      "current_name": "FUN_000023a4",
      "code": "\nundefined4 FUN_000023a4(void)\n\n{\n  undefined4 uVar1;\n  undefined auStack_88 [128];\n  \n  startForkserver(0);\n  puts(\"Welcome to RIOT!\");\n  uVar1 \u003d shell_run(0,auStack_88,0x80);\n  software_interrupt(0x3f);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f04"
      ],
      "called": [
        "FUN_000023d0",
        "FUN_00002e6c",
        "FUN_00004db8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000023c8": {
      "entrypoint": "0x000023c8",
      "current_name": "FUN_000023c8",
      "code": "\nvoid FUN_000023c8(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000023d0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000023d0": {
      "entrypoint": "0x000023d0",
      "current_name": "FUN_000023d0",
      "code": "\nundefined4 FUN_000023d0(undefined4 param_1)\n\n{\n  undefined4 uVar1;\n  \n  if (DAT_1fff0d98 \u003d\u003d 0) {\n    uVar1 \u003d aflCall(1,param_1,0);\n  }\n  else {\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000023a4"
      ],
      "called": [
        "FUN_000023c8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002400": {
      "entrypoint": "0x00002400",
      "current_name": "FUN_00002400",
      "code": "\nvoid FUN_00002400(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000f04"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000240c": {
      "entrypoint": "0x0000240c",
      "current_name": "FUN_0000240c",
      "code": "\nundefined4 * FUN_0000240c(undefined4 *param_1)\n\n{\n  undefined4 *puVar1;\n  \n  puVar1 \u003d (undefined4 *)*param_1;\n  if (puVar1 !\u003d (undefined4 *)0x0) {\n    *param_1 \u003d *puVar1;\n  }\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000024bc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002434": {
      "entrypoint": "0x00002434",
      "current_name": "FUN_00002434",
      "code": "\nundefined4 FUN_00002434(int *param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  uVar2 \u003d irq_disable();\n  iVar1 \u003d DAT_1fff03dc;\n  if (*param_1 \u003d\u003d 0) {\n    *param_1 \u003d -1;\n    irq_restore(uVar2);\n    uVar2 \u003d 1;\n  }\n  else if (param_2 \u003d\u003d 0) {\n    irq_restore(uVar2);\n    uVar2 \u003d 0;\n  }\n  else {\n    sched_set_status(DAT_1fff03dc,2);\n    if (*param_1 \u003d\u003d -1) {\n      *param_1 \u003d iVar1 + 8;\n      *(undefined4 *)*param_1 \u003d 0;\n    }\n    else {\n      thread_add_to_list(param_1,iVar1);\n    }\n    irq_restore(uVar2);\n    thread_yield_higher();\n    uVar2 \u003d 1;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000129c"
      ],
      "called": [
        "FUN_0000093c",
        "FUN_00000698",
        "FUN_00000d0c",
        "FUN_00000cd0",
        "FUN_00001034"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000024bc": {
      "entrypoint": "0x000024bc",
      "current_name": "FUN_000024bc",
      "code": "\nvoid FUN_000024bc(int *param_1)\n\n{\n  undefined uVar1;\n  undefined4 uVar2;\n  int iVar3;\n  \n  uVar2 \u003d irq_disable();\n  if (*param_1 \u003d\u003d 0) {\n    irq_restore(uVar2);\n  }\n  else if (*param_1 \u003d\u003d -1) {\n    *param_1 \u003d 0;\n    irq_restore(uVar2);\n  }\n  else {\n    iVar3 \u003d list_remove_head(param_1);\n    sched_set_status(iVar3 + -8,10);\n    if (*param_1 \u003d\u003d 0) {\n      *param_1 \u003d -1;\n    }\n    uVar1 \u003d *(undefined *)(iVar3 + -3);\n    irq_restore(uVar2);\n    sched_switch(uVar1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000012b4"
      ],
      "called": [
        "FUN_00000698",
        "FUN_00000d0c",
        "FUN_00000738",
        "FUN_00000cd0",
        "FUN_0000240c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002538": {
      "entrypoint": "0x00002538",
      "current_name": "FUN_00002538",
      "code": "\nvoid FUN_00002538(byte param_1,uint param_2)\n\n{\n  if ((char)param_1 \u003c \u0027\\0\u0027) {\n    (\u0026DAT_e000ed14)[param_1 \u0026 0xf] \u003d (char)((param_2 \u0026 0xff) \u003c\u003c 4);\n  }\n  else {\n    *(char *)((char)param_1 + -0x1fff1c00) \u003d (char)((param_2 \u0026 0xff) \u003c\u003c 4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000258c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000258c": {
      "entrypoint": "0x0000258c",
      "current_name": "FUN_0000258c",
      "code": "\n\n\nvoid FUN_0000258c(void)\n\n{\n  uint local_c;\n  \n  _DAT_e000ed08 \u003d 0;\n  FUN_00002538(0xfffffffe,1);\n  FUN_00002538(0xfffffffb,1);\n  for (local_c \u003d 0; local_c \u003c 0x66; local_c \u003d local_c + 1) {\n    FUN_00002538((int)(char)local_c,1);\n  }\n  _DAT_e000ed10 \u003d _DAT_e000ed10 | 0x10;\n  _DAT_e000ed14 \u003d _DAT_e000ed14 | 0x200;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00001274"
      ],
      "called": [
        "FUN_00002538"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000025f4": {
      "entrypoint": "0x000025f4",
      "current_name": "FUN_000025f4",
      "code": "\nvoid FUN_000025f4(void)\n\n{\n  rtt_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002396"
      ],
      "called": [
        "FUN_000027b0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002600": {
      "entrypoint": "0x00002600",
      "current_name": "FUN_00002600",
      "code": "\nundefined4 FUN_00002600(undefined4 param_1)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d mktime(param_1);\n  rtt_set_counter(uVar1);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003478"
      ],
      "called": [
        "FUN_0000285c",
        "FUN_000047e4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002624": {
      "entrypoint": "0x00002624",
      "current_name": "FUN_00002624",
      "code": "\nundefined4 FUN_00002624(undefined4 param_1)\n\n{\n  undefined4 local_10;\n  undefined4 uStack_c;\n  \n  local_10 \u003d rtt_get_counter();\n  uStack_c \u003d 0;\n  gmtime_r(\u0026local_10,param_1);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003444"
      ],
      "called": [
        "FUN_0000443c",
        "FUN_0000281c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002654": {
      "entrypoint": "0x00002654",
      "current_name": "FUN_00002654",
      "code": "\nundefined4 FUN_00002654(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d mktime(param_1);\n  DAT_1fff0d9c \u003d param_2;\n  rtt_set_alarm(uVar1,0x26f1,param_3);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000033f4"
      ],
      "called": [
        "FUN_000047e4",
        "FUN_00002894"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002690": {
      "entrypoint": "0x00002690",
      "current_name": "FUN_00002690",
      "code": "\nundefined4 FUN_00002690(undefined4 param_1)\n\n{\n  undefined4 local_10;\n  undefined4 uStack_c;\n  \n  local_10 \u003d rtt_get_alarm();\n  uStack_c \u003d 0;\n  gmtime_r(\u0026local_10,param_1);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000033c0"
      ],
      "called": [
        "FUN_000028f0",
        "FUN_0000443c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000026c0": {
      "entrypoint": "0x000026c0",
      "current_name": "FUN_000026c0",
      "code": "\nvoid FUN_000026c0(void)\n\n{\n  rtt_clear_alarm();\n  DAT_1fff0d9c \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003524"
      ],
      "called": [
        "FUN_00002910"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000026d8": {
      "entrypoint": "0x000026d8",
      "current_name": "FUN_000026d8",
      "code": "\nvoid FUN_000026d8(void)\n\n{\n  rtt_poweron();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003524"
      ],
      "called": [
        "FUN_0000294c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000026e4": {
      "entrypoint": "0x000026e4",
      "current_name": "FUN_000026e4",
      "code": "\nvoid FUN_000026e4(void)\n\n{\n  rtt_poweroff();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003524"
      ],
      "called": [
        "FUN_00002970"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000026f0": {
      "entrypoint": "0x000026f0",
      "current_name": "FUN_000026f0",
      "code": "\nvoid FUN_000026f0(undefined4 param_1)\n\n{\n  if (DAT_1fff0d9c !\u003d (code *)0x0) {\n    (*DAT_1fff0d9c)(param_1);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002714": {
      "entrypoint": "0x00002714",
      "current_name": "FUN_00002714",
      "code": "\nvoid FUN_00002714(byte param_1)\n\n{\n  *(int *)(((uint)(int)(char)param_1 \u003e\u003e 5) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (param_1 \u0026 0x1f);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002894"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002744": {
      "entrypoint": "0x00002744",
      "current_name": "FUN_00002744",
      "code": "\nvoid FUN_00002744(byte param_1,uint param_2)\n\n{\n  if ((char)param_1 \u003c \u0027\\0\u0027) {\n    (\u0026DAT_e000ed14)[param_1 \u0026 0xf] \u003d (char)((param_2 \u0026 0xff) \u003c\u003c 4);\n  }\n  else {\n    *(char *)((char)param_1 + -0x1fff1c00) \u003d (char)((param_2 \u0026 0xff) \u003c\u003c 4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002894"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002798": {
      "entrypoint": "0x00002798",
      "current_name": "FUN_00002798",
      "code": "\nvoid FUN_00002798(void)\n\n{\n  if (DAT_1fff0354 !\u003d 0) {\n    thread_yield_higher();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002994"
      ],
      "called": [
        "FUN_0000093c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000027b0": {
      "entrypoint": "0x000027b0",
      "current_name": "FUN_000027b0",
      "code": "\n\n\nvoid FUN_000027b0(void)\n\n{\n  _DAT_4004803c \u003d _DAT_4004803c | 0x20000000;\n  if ((_DAT_4003d014 \u0026 1) !\u003d 0) {\n    _DAT_4003d000 \u003d 0;\n  }\n  _DAT_4003d010 \u003d 0x104;\n  _DAT_4003d008 \u003d 0xffffff42;\n  _DAT_4003d01c \u003d 0;\n  rtt_poweron();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000025f4"
      ],
      "called": [
        "FUN_0000294c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000281c": {
      "entrypoint": "0x0000281c",
      "current_name": "FUN_0000281c",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00002840) */\n/* WARNING: Removing unreachable block (ram,0x0000284c) */\n\n\nundefined4 FUN_0000281c(void)\n\n{\n  return _DAT_4003d000;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002624"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000285c": {
      "entrypoint": "0x0000285c",
      "current_name": "FUN_0000285c",
      "code": "\n\n\nvoid FUN_0000285c(undefined4 param_1)\n\n{\n  _DAT_4003d000 \u003d param_1;\n  _DAT_4003d014 \u003d _DAT_4003d014 \u0026 0xffffffef | 0x10;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002600"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002894": {
      "entrypoint": "0x00002894",
      "current_name": "FUN_00002894",
      "code": "\n\n\nvoid FUN_00002894(int param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  _DAT_4003d008 \u003d param_1 + -1;\n  _DAT_4003d01c \u003d _DAT_4003d01c \u0026 0xfffffffb | 4;\n  DAT_1fff0da0 \u003d param_2;\n  DAT_1fff0da4 \u003d param_3;\n  NVIC_SetPriority(0x2e,10);\n  NVIC_EnableIRQ(0x2e);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002654"
      ],
      "called": [
        "FUN_00002714",
        "FUN_00002744"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000028f0": {
      "entrypoint": "0x000028f0",
      "current_name": "FUN_000028f0",
      "code": "\n\n\nint FUN_000028f0(void)\n\n{\n  return _DAT_4003d008 + 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002690"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002910": {
      "entrypoint": "0x00002910",
      "current_name": "FUN_00002910",
      "code": "\n\n\nvoid FUN_00002910(void)\n\n{\n  _DAT_4003d01c \u003d _DAT_4003d01c \u0026 0xfffffffb;\n  _DAT_4003d008 \u003d 0;\n  DAT_1fff0da0 \u003d 0;\n  DAT_1fff0da4 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000026c0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000294c": {
      "entrypoint": "0x0000294c",
      "current_name": "FUN_0000294c",
      "code": "\n\n\nvoid FUN_0000294c(void)\n\n{\n  _DAT_4003d014 \u003d _DAT_4003d014 | 0x10;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000027b0",
        "FUN_000026d8"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002970": {
      "entrypoint": "0x00002970",
      "current_name": "FUN_00002970",
      "code": "\n\n\nvoid FUN_00002970(void)\n\n{\n  _DAT_4003d014 \u003d _DAT_4003d014 \u0026 0xffffffef;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000026e4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002994": {
      "entrypoint": "0x00002994",
      "current_name": "FUN_00002994",
      "code": "\n\n\nvoid FUN_00002994(void)\n\n{\n  if (((_DAT_4003d014 \u0026 4) !\u003d 0) \u0026\u0026 (DAT_1fff0da0 !\u003d (code *)0x0)) {\n    _DAT_4003d01c \u003d _DAT_4003d01c \u0026 0xfffffffb;\n    (*DAT_1fff0da0)(DAT_1fff0da4);\n  }\n  if (((_DAT_4003d014 \u0026 2) !\u003d 0) \u0026\u0026 (DAT_1fff0da8 !\u003d (code *)0x0)) {\n    (*DAT_1fff0da8)(DAT_1fff0dac);\n  }\n  cortexm_isr_end();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00002798"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002a00": {
      "entrypoint": "0x00002a00",
      "current_name": "FUN_00002a00",
      "code": "\nvoid FUN_00002a00(undefined4 param_1)\n\n{\n  putchar(param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002e48",
        "FUN_00002d94"
      ],
      "called": [
        "FUN_00004cb4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002a18": {
      "entrypoint": "0x00002a18",
      "current_name": "FUN_00002a18",
      "code": "\nint FUN_00002a18(int *param_1,undefined4 param_2)\n\n{\n  int iVar1;\n  int *local_18;\n  undefined **local_14;\n  uint local_10;\n  int *local_c;\n  \n  local_18 \u003d param_1;\n  local_14 \u003d \u0026PTR_s_reboot_00007300;\n  local_10 \u003d 0;\n  do {\n    if (1 \u003c local_10) {\n      return 0;\n    }\n    local_c \u003d (\u0026local_18)[local_10];\n    if (local_c !\u003d (int *)0x0) {\n      for (; *local_c !\u003d 0; local_c \u003d local_c + 3) {\n        iVar1 \u003d strcmp(*local_c,param_2);\n        if (iVar1 \u003d\u003d 0) {\n          return local_c[2];\n        }\n      }\n    }\n    local_10 \u003d local_10 + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002b10"
      ],
      "called": [
        "FUN_00004e52"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002a88": {
      "entrypoint": "0x00002a88",
      "current_name": "FUN_00002a88",
      "code": "\nvoid FUN_00002a88(int *param_1)\n\n{\n  int *local_18;\n  undefined **local_14;\n  uint local_10;\n  int *local_c;\n  \n  iprintf(\"%-20s %s\\n\",\"Command\",\"Description\");\n  puts(\"---------------------------------------\");\n  local_18 \u003d param_1;\n  local_14 \u003d \u0026PTR_s_reboot_00007300;\n  for (local_10 \u003d 0; local_10 \u003c 2; local_10 \u003d local_10 + 1) {\n    local_c \u003d (\u0026local_18)[local_10];\n    if (local_c !\u003d (int *)0x0) {\n      for (; *local_c !\u003d 0; local_c \u003d local_c + 3) {\n        iprintf(\"%-20s %s\\n\",*local_c,local_c[1]);\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002b10"
      ],
      "called": [
        "FUN_00004c84",
        "FUN_00004db8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002b10": {
      "entrypoint": "0x00002b10",
      "current_name": "FUN_00002b10",
      "code": "\nvoid FUN_00002b10(undefined4 param_1,byte *param_2)\n\n{\n  int iVar1;\n  byte *pbVar2;\n  byte *local_48 [3];\n  code *local_3c;\n  char **local_38;\n  uint local_34;\n  byte local_2d;\n  char *local_2c;\n  char *local_28;\n  char **local_24;\n  uint local_20;\n  int local_1c;\n  uint local_18;\n  byte *local_14;\n  \n  local_18 \u003d 0;\n  local_1c \u003d 0;\n  local_14 \u003d param_2;\n  while( true ) {\n    local_48[0] \u003d param_2;\n    local_48[1] \u003d (byte *)param_1;\n    if (0x20 \u003c *local_14) {\n      if ((*local_14 \u003d\u003d 0x22) || (*local_14 \u003d\u003d 0x27)) {\n        local_2d \u003d *local_14;\n        do {\n          pbVar2 \u003d local_14 + 1;\n          if (*pbVar2 \u003d\u003d 0) {\n            local_14 \u003d pbVar2;\n            puts(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n            return;\n          }\n          if (*pbVar2 \u003d\u003d 0x5c) {\n            local_1c \u003d local_1c + 1;\n            local_14 \u003d local_14 + 2;\n            pbVar2 \u003d local_14;\n            if (*local_14 \u003d\u003d 0) {\n              puts(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n              return;\n            }\n          }\n          local_14 \u003d pbVar2;\n        } while (local_2d !\u003d *local_14);\n        if (0x20 \u003c local_14[1]) {\n          puts(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n          return;\n        }\n      }\n      else {\n        do {\n          if (*local_14 \u003d\u003d 0x5c) {\n            local_1c \u003d local_1c + 1;\n            local_14 \u003d local_14 + 1;\n            if (*local_14 \u003d\u003d 0) {\n              puts(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n              return;\n            }\n          }\n          local_14 \u003d local_14 + 1;\n          if (*local_14 \u003d\u003d 0x22) {\n            puts(Elf32_Rel_ARRAY_1fff0200[9].r_info);\n            return;\n          }\n        } while (0x20 \u003c *local_14);\n      }\n      local_18 \u003d local_18 + 1;\n    }\n    if (*local_14 \u003d\u003d 0) break;\n    *local_14 \u003d 0;\n    local_14 \u003d local_14 + 1;\n  }\n  if (local_18 !\u003d 0) {\n    local_34 \u003d local_18;\n    local_38 \u003d (char **)((int)local_48 - ((local_18 + 1) * 4 + 7 \u0026 0xfffffff8));\n    local_38[local_18] \u003d (char *)0x0;\n    local_14 \u003d param_2;\n    for (local_20 \u003d 0; local_24 \u003d local_38, local_20 \u003c local_18; local_20 \u003d local_20 + 1) {\n      for (; *local_14 \u003d\u003d 0; local_14 \u003d local_14 + 1) {\n      }\n      if ((*local_14 \u003d\u003d 0x22) || (*local_14 \u003d\u003d 0x27)) {\n        local_14 \u003d local_14 + 1;\n      }\n      local_38[local_20] \u003d (char *)local_14;\n      for (; *local_14 !\u003d 0; local_14 \u003d local_14 + 1) {\n      }\n    }\n    for (; (local_1c !\u003d 0 \u0026\u0026 (*local_24 !\u003d (char *)0x0)); local_24 \u003d local_24 + 1) {\n      for (local_28 \u003d *local_24; *local_28 !\u003d \u0027\\0\u0027; local_28 \u003d local_28 + 1) {\n        if (*local_28 \u003d\u003d \u0027\\\\\u0027) {\n          for (local_2c \u003d local_28; *local_2c !\u003d \u0027\\0\u0027; local_2c \u003d local_2c + 1) {\n            *local_2c \u003d local_2c[1];\n          }\n          local_1c \u003d local_1c + -1;\n          if (local_1c \u003d\u003d 0) break;\n        }\n      }\n    }\n    local_3c \u003d (code *)find_handler(param_1,*local_38);\n    if (local_3c \u003d\u003d (code *)0x0) {\n      iVar1 \u003d strcmp(\u0026DAT_00007214,*local_38);\n      if (iVar1 \u003d\u003d 0) {\n        print_help(local_48[1]);\n      }\n      else {\n        iprintf(\"shell: command not found: %s\\n\",*local_38);\n      }\n    }\n    else {\n      (*local_3c)(local_18,local_38);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002e6c"
      ],
      "called": [
        "FUN_00004c84",
        "FUN_00002a18",
        "FUN_00004db8",
        "FUN_00004e52",
        "FUN_00002a88"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002d94": {
      "entrypoint": "0x00002d94",
      "current_name": "FUN_00002d94",
      "code": "\nuint FUN_00002d94(undefined *param_1,int param_2)\n\n{\n  int iVar1;\n  byte bVar2;\n  bool bVar3;\n  undefined *local_c;\n  \n  local_c \u003d param_1;\n  while( true ) {\n    if (param_2 + -1 \u003c\u003d (int)local_c - (int)param_1) {\n      return 0xffffffff;\n    }\n    iVar1 \u003d getchar();\n    if (iVar1 \u003c 0) break;\n    if ((iVar1 \u003d\u003d 0xd) || (iVar1 \u003d\u003d 10)) {\n      *local_c \u003d 0;\n      _putchar(0xd);\n      _putchar(10);\n      bVar3 \u003d local_c \u003d\u003d param_1;\n      if (bVar3) {\n        param_1 \u003d (undefined *)0x1;\n      }\n      bVar2 \u003d (byte)param_1;\n      if (!bVar3) {\n        bVar2 \u003d 0;\n      }\n      return (uint)bVar2;\n    }\n    if ((iVar1 \u003d\u003d 8) || (iVar1 \u003d\u003d 0x7f)) {\n      if (local_c !\u003d param_1) {\n        local_c \u003d local_c + -1;\n        *local_c \u003d 0;\n        _putchar(8);\n        _putchar(0x20);\n        _putchar(8);\n      }\n    }\n    else {\n      *local_c \u003d (char)iVar1;\n      _putchar(iVar1);\n      local_c \u003d local_c + 1;\n    }\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002e6c"
      ],
      "called": [
        "FUN_00002a00",
        "FUN_00004418"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002e48": {
      "entrypoint": "0x00002e48",
      "current_name": "FUN_00002e48",
      "code": "\nvoid FUN_00002e48(void)\n\n{\n  _putchar(0x3e);\n  _putchar(0x20);\n  fflush(*(undefined4 *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 8));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002e6c"
      ],
      "called": [
        "FUN_000041d0",
        "FUN_00002a00"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002e6c": {
      "entrypoint": "0x00002e6c",
      "current_name": "FUN_00002e6c",
      "code": "\nvoid FUN_00002e6c(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  \n  print_prompt();\n  do {\n    iVar1 \u003d readline(param_2,param_3);\n    if (iVar1 \u003d\u003d 0) {\n      handle_input_line(param_1,param_2);\n    }\n    print_prompt();\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000023a4"
      ],
      "called": [
        "FUN_00002b10",
        "FUN_00002e48",
        "FUN_00002d94"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002e9c": {
      "entrypoint": "0x00002e9c",
      "current_name": "FUN_00002e9c",
      "code": "\nundefined4 FUN_00002e9c(void)\n\n{\n  pm_reboot();\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00003688"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002eb4": {
      "entrypoint": "0x00002eb4",
      "current_name": "FUN_00002eb4",
      "code": "\nundefined4 FUN_00002eb4(void)\n\n{\n  ps();\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_0000211c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002ecc": {
      "entrypoint": "0x00002ecc",
      "current_name": "FUN_00002ecc",
      "code": "\nvoid FUN_00002ecc(undefined4 param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  undefined4 uVar2;\n  undefined auStack_1c [8];\n  uint local_14;\n  \n  local_14 \u003d saul_reg_read(param_2,auStack_1c);\n  if ((int)local_14 \u003c 1) {\n    iprintf(\"error: failed to read from device #%i\\n\",param_1);\n  }\n  else {\n    uVar2 \u003d *(undefined4 *)(param_2 + 8);\n    uVar1 \u003d saul_class_to_str(*(undefined *)(*(int *)(param_2 + 0xc) + 8));\n    iprintf(\"Reading from #%i (%s|%s)\\n\",param_1,uVar2,uVar1);\n    phydat_dump(auStack_1c,local_14 \u0026 0xff);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002fe0",
        "FUN_00002f30"
      ],
      "called": [
        "FUN_00004c84",
        "FUN_000039e8",
        "FUN_00003d64",
        "FUN_00003694"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002f30": {
      "entrypoint": "0x00002f30",
      "current_name": "FUN_00002f30",
      "code": "\nvoid FUN_00002f30(void)\n\n{\n  int local_10;\n  undefined4 *local_c;\n  \n  local_10 \u003d 0;\n  for (local_c \u003d DAT_1fff0db0; local_c !\u003d (undefined4 *)0x0; local_c \u003d (undefined4 *)*local_c) {\n    probe(local_10,local_c);\n    puts(\u0026DAT_00007380);\n    local_10 \u003d local_10 + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002fe0"
      ],
      "called": [
        "FUN_00002ecc",
        "FUN_00004db8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002f74": {
      "entrypoint": "0x00002f74",
      "current_name": "FUN_00002f74",
      "code": "\nvoid FUN_00002f74(void)\n\n{\n  undefined4 uVar1;\n  int local_18;\n  undefined4 *local_14;\n  \n  local_14 \u003d DAT_1fff0db0;\n  local_18 \u003d 0;\n  if (DAT_1fff0db0 \u003d\u003d (undefined4 *)0x0) {\n    puts(\"No devices found\");\n  }\n  else {\n    puts(\"ID\\tClass\\t\\tName\");\n  }\n  for (; local_14 !\u003d (undefined4 *)0x0; local_14 \u003d (undefined4 *)*local_14) {\n    uVar1 \u003d saul_class_to_str(*(undefined *)(local_14[3] + 8));\n    iprintf(\"#%i\\t%s\\t%s\\n\",local_18,uVar1,local_14[2]);\n    local_18 \u003d local_18 + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000316c"
      ],
      "called": [
        "FUN_00004c84",
        "FUN_000039e8",
        "FUN_00004db8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00002fe0": {
      "entrypoint": "0x00002fe0",
      "current_name": "FUN_00002fe0",
      "code": "\nvoid FUN_00002fe0(int param_1,undefined4 *param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (param_1 \u003c 3) {\n    iprintf(\"usage: %s %s \u003cdevice id\u003e|all\\n\",*param_2,param_2[1]);\n  }\n  else {\n    iVar1 \u003d strcmp(param_2[2],\u0026DAT_000073d4);\n    if (iVar1 \u003d\u003d 0) {\n      probe_all();\n    }\n    else {\n      uVar2 \u003d atoi(param_2[2]);\n      iVar1 \u003d saul_reg_find_nth(uVar2);\n      if (iVar1 \u003d\u003d 0) {\n        puts(\"error: undefined device id given\");\n      }\n      else {\n        probe(uVar2,iVar1);\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000316c"
      ],
      "called": [
        "FUN_00004c84",
        "FUN_00002ecc",
        "FUN_00003d24",
        "FUN_00002f30",
        "FUN_00004db8",
        "FUN_00004e52",
        "FUN_00004042"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000305c": {
      "entrypoint": "0x0000305c",
      "current_name": "FUN_0000305c",
      "code": "\nvoid FUN_0000305c(int param_1,undefined4 *param_2)\n\n{\n  undefined2 uVar1;\n  undefined2 auStack_20 [4];\n  uint local_18;\n  int local_14;\n  undefined4 local_10;\n  int local_c;\n  \n  if (param_1 \u003c 4) {\n    iprintf(\"usage: %s %s \u003cdevice id\u003e \u003cvalue 0\u003e [\u003cvalue 1\u003e [\u003cvalue 2]]\\n\",*param_2,param_2[1]);\n  }\n  else {\n    local_10 \u003d atoi(param_2[2]);\n    local_14 \u003d saul_reg_find_nth(local_10);\n    if (local_14 \u003d\u003d 0) {\n      puts(\"error: undefined device given\");\n    }\n    else {\n      memset(auStack_20,0,8);\n      if (5 \u003c param_1) {\n        param_1 \u003d 6;\n      }\n      local_18 \u003d param_1 - 3;\n      for (local_c \u003d 0; local_c \u003c (int)local_18; local_c \u003d local_c + 1) {\n        uVar1 \u003d atoi(param_2[local_c + 3]);\n        auStack_20[local_c] \u003d uVar1;\n      }\n      iprintf(\"Writing to device #%i - %s\\n\",local_10,*(undefined4 *)(local_14 + 8));\n      phydat_dump(auStack_20,local_18 \u0026 0xff);\n      local_18 \u003d saul_reg_write(local_14,auStack_20);\n      if ((int)local_18 \u003c 1) {\n        if (local_18 \u003d\u003d -0x86) {\n          iprintf(\"error: device #%i is not writable\\n\",local_10);\n        }\n        else {\n          iprintf(\"error: failure to write to device #%i\\n\",local_10);\n        }\n      }\n      else {\n        iprintf(\"data successfully written to device #%i\\n\",local_10);\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000316c"
      ],
      "called": [
        "FUN_00004c84",
        "FUN_00003d94",
        "FUN_00004622",
        "FUN_00003d24",
        "FUN_00004db8",
        "FUN_00003694",
        "FUN_00004042"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000316c": {
      "entrypoint": "0x0000316c",
      "current_name": "FUN_0000316c",
      "code": "\nundefined4 FUN_0000316c(int param_1,undefined4 *param_2)\n\n{\n  int iVar1;\n  \n  if (param_1 \u003c 2) {\n    list();\n  }\n  else {\n    iVar1 \u003d strcmp(param_2[1],\u0026DAT_000074ec);\n    if (iVar1 \u003d\u003d 0) {\n      read(param_1,param_2);\n    }\n    else {\n      iVar1 \u003d strcmp(param_2[1],\"write\");\n      if (iVar1 \u003d\u003d 0) {\n        write(param_1,param_2);\n      }\n      else {\n        iprintf(\"usage: %s read|write\\n\",*param_2);\n      }\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00002f74",
        "FUN_00004c84",
        "FUN_00002fe0",
        "FUN_00004e52",
        "FUN_0000305c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000031e0": {
      "entrypoint": "0x000031e0",
      "current_name": "FUN_000031e0",
      "code": "\nvoid FUN_000031e0(void)\n\n{\n  puts(\"The alarm rang\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00004db8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000031fc": {
      "entrypoint": "0x000031fc",
      "current_name": "FUN_000031fc",
      "code": "\nint FUN_000031fc(int param_1,int param_2,int param_3)\n\n{\n  byte bVar1;\n  int iVar2;\n  \n  iVar2 \u003d param_2;\n  if (param_2 \u003c 3) {\n    iVar2 \u003d 1;\n  }\n  bVar1 \u003d (byte)iVar2;\n  if (2 \u003c param_2) {\n    bVar1 \u003d 0;\n  }\n  param_1 \u003d param_1 - (uint)bVar1;\n  iVar2 \u003d param_1;\n  if (param_1 \u003c 0) {\n    iVar2 \u003d param_1 + 3;\n  }\n  return ((((iVar2 \u003e\u003e 2) + param_1) - param_1 / 100) + param_1 / 400 +\n          *(int *)((int)Elf32_Rel_ARRAY_1fff0200 + (param_2 + -1) * 4 + 0x50) + param_3) % 7;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000328c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000328c": {
      "entrypoint": "0x0000328c",
      "current_name": "FUN_0000328c",
      "code": "\nundefined4 FUN_0000328c(undefined4 *param_1,int *param_2)\n\n{\n  int iVar1;\n  int local_10;\n  short local_a;\n  \n  local_a \u003d strtol(*param_1,\u0026local_10,10);\n  param_2[5] \u003d local_a + -0x76c;\n  local_a \u003d strtol(local_10 + 1,\u0026local_10,10);\n  param_2[4] \u003d local_a + -1;\n  local_a \u003d strtol(local_10 + 1,\u0026local_10,10);\n  param_2[3] \u003d (int)local_a;\n  local_a \u003d strtol(param_1[1],\u0026local_10,10);\n  param_2[2] \u003d (int)local_a;\n  local_a \u003d strtol(local_10 + 1,\u0026local_10,10);\n  param_2[1] \u003d (int)local_a;\n  local_a \u003d strtol(local_10 + 1,\u0026local_10,10);\n  *param_2 \u003d (int)local_a;\n  iVar1 \u003d dow(param_2[5] + 0x76c,param_2[4] + 1,param_2[3]);\n  param_2[6] \u003d iVar1;\n  param_2[8] \u003d -1;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000033f4",
        "FUN_00003478"
      ],
      "called": [
        "FUN_000031fc",
        "FUN_00004f84"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003378": {
      "entrypoint": "0x00003378",
      "current_name": "FUN_00003378",
      "code": "\nundefined4 FUN_00003378(undefined4 *param_1)\n\n{\n  iprintf(\"%04i-%02i-%02i %02i:%02i:%02i\\n\",param_1[5] + 0x76c,param_1[4] + 1,param_1[3],param_1[2],\n          param_1[1],*param_1);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003444",
        "FUN_000033c0"
      ],
      "called": [
        "FUN_00004c84"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000033c0": {
      "entrypoint": "0x000033c0",
      "current_name": "FUN_000033c0",
      "code": "\nbool FUN_000033c0(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 \u003d rtc_get_alarm(auStack_2c);\n  if (iVar1 !\u003d 0) {\n    puts(\"rtc: error getting alarm\");\n  }\n  else {\n    _print_time(auStack_2c);\n  }\n  return iVar1 !\u003d 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003524"
      ],
      "called": [
        "FUN_00002690",
        "FUN_00004db8",
        "FUN_00003378"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000033f4": {
      "entrypoint": "0x000033f4",
      "current_name": "FUN_000033f4",
      "code": "\nundefined4 FUN_000033f4(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 \u003d _parse_time(param_1,auStack_2c);\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d rtc_set_alarm(auStack_2c,0x31e1,0);\n    if (iVar1 \u003d\u003d -1) {\n      puts(\"rtc: error setting alarm\");\n      uVar2 \u003d 1;\n    }\n    else {\n      uVar2 \u003d 0;\n    }\n  }\n  else {\n    uVar2 \u003d 1;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003524"
      ],
      "called": [
        "FUN_00004db8",
        "FUN_0000328c",
        "FUN_00002654"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003444": {
      "entrypoint": "0x00003444",
      "current_name": "FUN_00003444",
      "code": "\nbool FUN_00003444(void)\n\n{\n  int iVar1;\n  undefined auStack_2c [36];\n  \n  iVar1 \u003d rtc_get_time(auStack_2c);\n  if (iVar1 !\u003d 0) {\n    puts(\"rtc: error getting time\");\n  }\n  else {\n    _print_time(auStack_2c);\n  }\n  return iVar1 !\u003d 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003524"
      ],
      "called": [
        "FUN_00002624",
        "FUN_00004db8",
        "FUN_00003378"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003478": {
      "entrypoint": "0x00003478",
      "current_name": "FUN_00003478",
      "code": "\nundefined4 FUN_00003478(undefined4 param_1)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_2c [36];\n  \n  iVar1 \u003d _parse_time(param_1,auStack_2c);\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d rtc_set_time(auStack_2c);\n    if (iVar1 \u003d\u003d -1) {\n      puts(\"rtc: error setting time\");\n      uVar2 \u003d 1;\n    }\n    else {\n      uVar2 \u003d 0;\n    }\n  }\n  else {\n    uVar2 \u003d 1;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003524"
      ],
      "called": [
        "FUN_00002600",
        "FUN_00004db8",
        "FUN_0000328c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000034c0": {
      "entrypoint": "0x000034c0",
      "current_name": "FUN_000034c0",
      "code": "\nundefined4 FUN_000034c0(void)\n\n{\n  puts(\"usage: rtc \u003ccommand\u003e [arguments]\");\n  puts(\"commands:\");\n  puts(\"\\tpoweron\\t\\tpower the interface on\");\n  puts(\"\\tpoweroff\\tpower the interface off\");\n  puts(\"\\tclearalarm\\tdeactivate the current alarm\");\n  puts(\"\\tgetalarm\\tprint the currently alarm time\");\n  puts(\"\\tsetalarm YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset an alarm for the specified time\");\n  puts(\"\\tgettime\\t\\tprint the current time\");\n  puts(\"\\tsettime YYYY-MM-DD HH:MM:SS\\n\\t\\t\\tset the current time\");\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003524"
      ],
      "called": [
        "FUN_00004db8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003524": {
      "entrypoint": "0x00003524",
      "current_name": "FUN_00003524",
      "code": "\nundefined4 FUN_00003524(int param_1,int param_2)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (param_1 \u003c 2) {\n    _rtc_usage();\n    uVar2 \u003d 1;\n  }\n  else {\n    iVar1 \u003d strncmp(*(undefined4 *)(param_2 + 4),\"poweron\",7);\n    if (iVar1 \u003d\u003d 0) {\n      rtc_poweron();\n    }\n    else {\n      iVar1 \u003d strncmp(*(undefined4 *)(param_2 + 4),\"poweroff\",8);\n      if (iVar1 \u003d\u003d 0) {\n        rtc_poweroff();\n      }\n      else {\n        iVar1 \u003d strncmp(*(undefined4 *)(param_2 + 4),\"clearalarm\",8);\n        if (iVar1 \u003d\u003d 0) {\n          rtc_clear_alarm();\n        }\n        else {\n          iVar1 \u003d strncmp(*(undefined4 *)(param_2 + 4),\"getalarm\",8);\n          if (iVar1 \u003d\u003d 0) {\n            _rtc_getalarm();\n          }\n          else {\n            iVar1 \u003d strncmp(*(undefined4 *)(param_2 + 4),\"setalarm\",8);\n            if ((iVar1 \u003d\u003d 0) \u0026\u0026 (param_1 \u003d\u003d 4)) {\n              _rtc_setalarm(param_2 + 8);\n            }\n            else {\n              iVar1 \u003d strncmp(*(undefined4 *)(param_2 + 4),\"gettime\",7);\n              if (iVar1 \u003d\u003d 0) {\n                _rtc_gettime();\n              }\n              else {\n                iVar1 \u003d strncmp(*(undefined4 *)(param_2 + 4),\"settime\",7);\n                if ((iVar1 !\u003d 0) || (param_1 !\u003d 4)) {\n                  iprintf(\"unknown command or missing parameters: %s\\n\\n\",\n                          *(undefined4 *)(param_2 + 4));\n                  _rtc_usage();\n                  return 1;\n                }\n                _rtc_settime(param_2 + 8);\n              }\n            }\n          }\n        }\n      }\n    }\n    uVar2 \u003d 0;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00004c84",
        "FUN_000033f4",
        "FUN_000026c0",
        "FUN_00004e66",
        "FUN_00003444",
        "FUN_000033c0",
        "FUN_000026d8",
        "FUN_000026e4",
        "FUN_00003478",
        "FUN_000034c0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003658": {
      "entrypoint": "0x00003658",
      "current_name": "FUN_00003658",
      "code": "\nvoid FUN_00003658(void)\n\n{\n  DataSynchronizationBarrier(0xf);\n  DataSynchronizationBarrier(0xf);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003688"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003688": {
      "entrypoint": "0x00003688",
      "current_name": "FUN_00003688",
      "code": "\nvoid FUN_00003688(void)\n\n{\n  NVIC_SystemReset();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002e9c"
      ],
      "called": [
        "FUN_00003658"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003694": {
      "entrypoint": "0x00003694",
      "current_name": "FUN_00003694",
      "code": "\nvoid FUN_00003694(int param_1,byte param_2)\n\n{\n  undefined4 uVar1;\n  char cVar2;\n  uint uVar3;\n  bool bVar4;\n  undefined auStack_18 [8];\n  int local_10;\n  char local_a;\n  byte local_9;\n  \n  if ((param_1 \u003d\u003d 0) || (3 \u003c param_2)) {\n    puts(\"Unable to display data object\");\n  }\n  else {\n    iprintf(\"Data:\");\n    for (local_9 \u003d 0; local_9 \u003c param_2; local_9 \u003d local_9 + 1) {\n      if (*(byte *)(param_1 + 6) \u003c 0x14) {\n        uVar3 \u003d 1 \u003c\u003c (uint)*(byte *)(param_1 + 6) \u0026 0x8018f;\n        bVar4 \u003d uVar3 !\u003d 0;\n        if (bVar4) {\n          uVar3 \u003d 1;\n        }\n        cVar2 \u003d (char)uVar3;\n        if (!bVar4) {\n          cVar2 \u003d \u0027\\0\u0027;\n        }\n        if (cVar2 \u003d\u003d \u0027\\0\u0027) goto LAB_000036ee;\n        local_a \u003d \u0027\\0\u0027;\n      }\n      else {\nLAB_000036ee:\n        local_a \u003d phydat_prefix_from_scale((int)*(char *)(param_1 + 7));\n      }\n      iprintf(\u0026DAT_000077bc);\n      if (param_2 \u003c 2) {\n        iprintf(\"     \");\n      }\n      else {\n        iprintf(\"[%u] \",local_9);\n      }\n      if (local_a \u003d\u003d \u0027\\0\u0027) {\n        if (*(char *)(param_1 + 7) \u003d\u003d \u0027\\0\u0027) {\n          iprintf(\u0026DAT_000077d8,(int)*(short *)(param_1 + (uint)local_9 * 2));\n        }\n        else if ((*(char *)(param_1 + 7) + 4 \u003c 0 \u003d\u003d SCARRY4((int)*(char *)(param_1 + 7),4)) \u0026\u0026\n                (*(char *)(param_1 + 7) \u003c \u0027\\0\u0027)) {\n          local_10 \u003d fmt_s16_dfp(auStack_18,(int)*(short *)(param_1 + (uint)local_9 * 2),\n                                 (int)*(char *)(param_1 + 7));\n          auStack_18[local_10] \u003d 0;\n          iprintf(\u0026DAT_000077dc,auStack_18);\n        }\n        else {\n          iprintf(\"%iE%i\",(int)*(short *)(param_1 + (uint)local_9 * 2),(int)*(char *)(param_1 + 7));\n        }\n      }\n      else {\n        iprintf(\"%6d %c\",(int)*(short *)(param_1 + (uint)local_9 * 2),local_a);\n      }\n      uVar1 \u003d phydat_unit_to_str(*(undefined *)(param_1 + 6));\n      iprintf(\u0026DAT_000077e8,uVar1);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002ecc",
        "FUN_0000305c"
      ],
      "called": [
        "FUN_00003918",
        "FUN_00004c84",
        "FUN_00004db8",
        "FUN_00003e9e",
        "FUN_00003810"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003810": {
      "entrypoint": "0x00003810",
      "current_name": "FUN_00003810",
      "code": "\nundefined * FUN_00003810(undefined param_1)\n\n{\n  undefined *puVar1;\n  \n  switch(param_1) {\n  case 2:\n    puVar1 \u003d \u0026DAT_000077ec;\n    break;\n  case 3:\n    puVar1 \u003d \u0026DAT_000077f0;\n    break;\n  case 4:\n    puVar1 \u003d \u0026DAT_000077f4;\n    break;\n  case 5:\n    puVar1 \u003d \u0026DAT_000077f8;\n    break;\n  case 6:\n    puVar1 \u003d \u0026DAT_000077fc;\n    break;\n  case 7:\n    puVar1 \u003d (undefined *)0x7800;\n    break;\n  case 8:\n    puVar1 \u003d \u0026DAT_00007804;\n    break;\n  case 9:\n    puVar1 \u003d \u0026DAT_00007808;\n    break;\n  case 10:\n    puVar1 \u003d \u0026DAT_0000780c;\n    break;\n  case 0xb:\n    puVar1 \u003d \u0026DAT_00007810;\n    break;\n  case 0xc:\n    puVar1 \u003d \u0026DAT_00007814;\n    break;\n  case 0xd:\n    puVar1 \u003d \u0026DAT_00007818;\n    break;\n  case 0xe:\n    puVar1 \u003d \u0026DAT_0000781c;\n    break;\n  case 0xf:\n    puVar1 \u003d \u0026DAT_00007820;\n    break;\n  case 0x10:\n    puVar1 \u003d \u0026DAT_00007824;\n    break;\n  case 0x11:\n    puVar1 \u003d \u0026DAT_0000782c;\n    break;\n  default:\n    puVar1 \u003d \u0026DAT_00007834;\n    break;\n  case 0x13:\n    puVar1 \u003d \u0026DAT_00007830;\n    break;\n  case 0x15:\n    puVar1 \u003d \u0026DAT_00007828;\n  }\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003694"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003918": {
      "entrypoint": "0x00003918",
      "current_name": "FUN_00003918",
      "code": "\nundefined4 FUN_00003918(undefined param_1)\n\n{\n  undefined4 uVar1;\n  \n  switch(param_1) {\n  case 2:\n    uVar1 \u003d 0x68;\n    break;\n  case 3:\n    uVar1 \u003d 0x6b;\n    break;\n  case 6:\n    uVar1 \u003d 0x4d;\n    break;\n  case 9:\n    uVar1 \u003d 0x47;\n    break;\n  case 0xc:\n    uVar1 \u003d 0x54;\n    break;\n  case 0xf:\n    uVar1 \u003d 0x50;\n    break;\n  case 0xf1:\n    uVar1 \u003d 0x66;\n    break;\n  default:\n    uVar1 \u003d 0;\n    break;\n  case 0xf4:\n    uVar1 \u003d 0x70;\n    break;\n  case 0xf7:\n    uVar1 \u003d 0x6e;\n    break;\n  case 0xfa:\n    uVar1 \u003d 0x75;\n    break;\n  case 0xfd:\n    uVar1 \u003d 0x6d;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003694"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000039e8": {
      "entrypoint": "0x000039e8",
      "current_name": "FUN_000039e8",
      "code": "\nchar * FUN_000039e8(char param_1)\n\n{\n  char *pcVar1;\n  \n  switch(param_1) {\n  case \u0027\\0\u0027:\n    pcVar1 \u003d \"CLASS_UNDEF\";\n    break;\n  case \u0027@\u0027:\n    pcVar1 \u003d \"ACT_ANY\";\n    break;\n  case \u0027B\u0027:\n    pcVar1 \u003d \"ACT_LED_RGB\";\n    break;\n  case \u0027C\u0027:\n    pcVar1 \u003d \"ACT_SERVO\";\n    break;\n  case \u0027D\u0027:\n    pcVar1 \u003d \"ACT_MOTOR\";\n    break;\n  case \u0027E\u0027:\n    pcVar1 \u003d \"ACT_SWITCH\";\n    break;\n  case \u0027F\u0027:\n    pcVar1 \u003d \"ACT_DIMMER\";\n    break;\n  case -0x80:\n    pcVar1 \u003d \"SENSE_ANY\";\n    break;\n  case -0x7f:\n    pcVar1 \u003d \"SENSE_BTN\";\n    break;\n  case -0x7e:\n    pcVar1 \u003d \"SENSE_TEMP\";\n    break;\n  case -0x7d:\n    pcVar1 \u003d \"SENSE_HUM\";\n    break;\n  case -0x7c:\n    pcVar1 \u003d \"SENSE_LIGHT\";\n    break;\n  case -0x7b:\n    pcVar1 \u003d \"SENSE_ACCEL\";\n    break;\n  case -0x7a:\n    pcVar1 \u003d \"SENSE_MAG\";\n    break;\n  case -0x79:\n    pcVar1 \u003d \"SENSE_GYRO\";\n    break;\n  case -0x78:\n    pcVar1 \u003d \"SENSE_COLOR\";\n    break;\n  case -0x77:\n    pcVar1 \u003d \"SENSE_PRESS\";\n    break;\n  case -0x76:\n    pcVar1 \u003d \"SENSE_ANALOG\";\n    break;\n  case -0x75:\n    pcVar1 \u003d \"SENSE_UV\";\n    break;\n  case -0x74:\n    pcVar1 \u003d \"SENSE_OBJTEMP\";\n    break;\n  case -0x73:\n    pcVar1 \u003d \"SENSE_PULSE_COUNT\";\n    break;\n  case -0x72:\n    pcVar1 \u003d \"SENSE_DISTANCE\";\n    break;\n  case -0x71:\n    pcVar1 \u003d \"SENSE_CO2\";\n    break;\n  default:\n    if (param_1 \u003d\u003d -1) {\n      return \"CLASS_ANY\";\n    }\n  case \u0027\\x01\u0027:\n  case \u0027\\x02\u0027:\n  case \u0027\\x03\u0027:\n  case \u0027\\x04\u0027:\n  case \u0027\\x05\u0027:\n  case \u0027\\x06\u0027:\n  case \u0027\\a\u0027:\n  case \u0027\\b\u0027:\n  case \u0027\\t\u0027:\n  case \u0027\\n\u0027:\n  case \u0027\\v\u0027:\n  case \u0027\\f\u0027:\n  case \u0027\\r\u0027:\n  case \u0027\\x0e\u0027:\n  case \u0027\\x0f\u0027:\n  case \u0027\\x10\u0027:\n  case \u0027\\x11\u0027:\n  case \u0027\\x12\u0027:\n  case \u0027\\x13\u0027:\n  case \u0027\\x14\u0027:\n  case \u0027\\x15\u0027:\n  case \u0027\\x16\u0027:\n  case \u0027\\x17\u0027:\n  case \u0027\\x18\u0027:\n  case \u0027\\x19\u0027:\n  case \u0027\\x1a\u0027:\n  case \u0027\\x1b\u0027:\n  case \u0027\\x1c\u0027:\n  case \u0027\\x1d\u0027:\n  case \u0027\\x1e\u0027:\n  case \u0027\\x1f\u0027:\n  case \u0027 \u0027:\n  case \u0027!\u0027:\n  case \u0027\\\"\u0027:\n  case \u0027#\u0027:\n  case \u0027$\u0027:\n  case \u0027%\u0027:\n  case \u0027\u0026\u0027:\n  case \u0027\\\u0027\u0027:\n  case \u0027(\u0027:\n  case \u0027)\u0027:\n  case \u0027*\u0027:\n  case \u0027+\u0027:\n  case \u0027,\u0027:\n  case \u0027-\u0027:\n  case \u0027.\u0027:\n  case \u0027/\u0027:\n  case \u00270\u0027:\n  case \u00271\u0027:\n  case \u00272\u0027:\n  case \u00273\u0027:\n  case \u00274\u0027:\n  case \u00275\u0027:\n  case \u00276\u0027:\n  case \u00277\u0027:\n  case \u00278\u0027:\n  case \u00279\u0027:\n  case \u0027:\u0027:\n  case \u0027;\u0027:\n  case \u0027\u003c\u0027:\n  case \u0027\u003d\u0027:\n  case \u0027\u003e\u0027:\n  case \u0027?\u0027:\n  case \u0027A\u0027:\n  case \u0027G\u0027:\n  case \u0027H\u0027:\n  case \u0027I\u0027:\n  case \u0027J\u0027:\n  case \u0027K\u0027:\n  case \u0027L\u0027:\n  case \u0027M\u0027:\n  case \u0027N\u0027:\n  case \u0027O\u0027:\n  case \u0027P\u0027:\n  case \u0027Q\u0027:\n  case \u0027R\u0027:\n  case \u0027S\u0027:\n  case \u0027T\u0027:\n  case \u0027U\u0027:\n  case \u0027V\u0027:\n  case \u0027W\u0027:\n  case \u0027X\u0027:\n  case \u0027Y\u0027:\n  case \u0027Z\u0027:\n  case \u0027[\u0027:\n  case \u0027\\\\\u0027:\n  case \u0027]\u0027:\n  case \u0027^\u0027:\n  case \u0027_\u0027:\n  case \u0027`\u0027:\n  case \u0027a\u0027:\n  case \u0027b\u0027:\n  case \u0027c\u0027:\n  case \u0027d\u0027:\n  case \u0027e\u0027:\n  case \u0027f\u0027:\n  case \u0027g\u0027:\n  case \u0027h\u0027:\n  case \u0027i\u0027:\n  case \u0027j\u0027:\n  case \u0027k\u0027:\n  case \u0027l\u0027:\n  case \u0027m\u0027:\n  case \u0027n\u0027:\n  case \u0027o\u0027:\n  case \u0027p\u0027:\n  case \u0027q\u0027:\n  case \u0027r\u0027:\n  case \u0027s\u0027:\n  case \u0027t\u0027:\n  case \u0027u\u0027:\n  case \u0027v\u0027:\n  case \u0027w\u0027:\n  case \u0027x\u0027:\n  case \u0027y\u0027:\n  case \u0027z\u0027:\n  case \u0027{\u0027:\n  case \u0027|\u0027:\n  case \u0027}\u0027:\n  case \u0027~\u0027:\n  case \u0027\\x7f\u0027:\n    pcVar1 \u003d \"CLASS_UNKNOWN\";\n  }\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002f74",
        "FUN_00002ecc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003d24": {
      "entrypoint": "0x00003d24",
      "current_name": "FUN_00003d24",
      "code": "\nundefined4 * FUN_00003d24(int param_1)\n\n{\n  int local_10;\n  undefined4 *local_c;\n  \n  local_10 \u003d 0;\n  for (local_c \u003d DAT_1fff0db0; (local_10 \u003c param_1 \u0026\u0026 (local_c !\u003d (undefined4 *)0x0));\n      local_c \u003d (undefined4 *)*local_c) {\n    local_10 \u003d local_10 + 1;\n  }\n  return local_c;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002fe0",
        "FUN_0000305c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003d64": {
      "entrypoint": "0x00003d64",
      "current_name": "FUN_00003d64",
      "code": "\nundefined4 FUN_00003d64(int param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 \u003d\u003d 0) {\n    uVar1 \u003d 0xffffffed;\n  }\n  else {\n    uVar1 \u003d (***(code ***)(param_1 + 0xc))(*(undefined4 *)(param_1 + 4),param_2);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002ecc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003d94": {
      "entrypoint": "0x00003d94",
      "current_name": "FUN_00003d94",
      "code": "\nundefined4 FUN_00003d94(int param_1,undefined4 param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_1 \u003d\u003d 0) {\n    uVar1 \u003d 0xffffffed;\n  }\n  else {\n    uVar1 \u003d (**(code **)(*(int *)(param_1 + 0xc) + 4))(*(undefined4 *)(param_1 + 4),param_2);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000305c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003dc4": {
      "entrypoint": "0x00003dc4",
      "current_name": "FUN_00003dc4",
      "code": "\nint FUN_00003dc4(int param_1,uint param_2)\n\n{\n  uint local_20;\n  char *local_14;\n  uint local_10;\n  int local_c;\n  \n  local_c \u003d 1;\n  if (param_2 \u003c 1000000000) {\n    for (local_10 \u003d 10; local_10 \u003c\u003d param_2; local_10 \u003d local_10 * 10) {\n      local_c \u003d local_c + 1;\n    }\n  }\n  else {\n    local_c \u003d 10;\n  }\n  if (param_1 !\u003d 0) {\n    local_14 \u003d (char *)(local_c + param_1);\n    local_20 \u003d param_2;\n    do {\n      local_14 \u003d local_14 + -1;\n      *local_14 \u003d (char)(local_20 % 10) + \u00270\u0027;\n      local_20 \u003d local_20 / 10;\n    } while (local_20 !\u003d 0);\n  }\n  return local_c;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003e58"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003e58": {
      "entrypoint": "0x00003e58",
      "current_name": "FUN_00003e58",
      "code": "\nint FUN_00003e58(undefined *param_1,int param_2)\n\n{\n  int iVar1;\n  int local_18;\n  undefined *local_14;\n  \n  local_18 \u003d param_2;\n  local_14 \u003d param_1;\n  if (-(param_2 \u003e\u003e 0x1f) !\u003d 0) {\n    if (param_1 !\u003d (undefined *)0x0) {\n      local_14 \u003d param_1 + 1;\n      *param_1 \u003d 0x2d;\n    }\n    local_18 \u003d -param_2;\n  }\n  iVar1 \u003d fmt_u32_dec(local_14,local_18);\n  return -(param_2 \u003e\u003e 0x1f) + iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003ec4"
      ],
      "called": [
        "FUN_00003dc4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003e9e": {
      "entrypoint": "0x00003e9e",
      "current_name": "FUN_00003e9e",
      "code": "\nundefined4 FUN_00003e9e(undefined4 param_1,short param_2,undefined4 param_3)\n\n{\n  undefined4 uVar1;\n  \n  uVar1 \u003d fmt_s32_dfp(param_1,(int)param_2,param_3);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003694"
      ],
      "called": [
        "FUN_00003ec4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003ec4": {
      "entrypoint": "0x00003ec4",
      "current_name": "FUN_00003ec4",
      "code": "\nint FUN_00003ec4(undefined *param_1,uint param_2,int param_3)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  int local_10;\n  int local_c;\n  \n  if (param_3 + 7 \u003c 0 !\u003d SCARRY4(param_3,7)) {\n    core_panic(3,\"FAILED ASSERTION.\");\n  }\n  local_c \u003d 0;\n  if (param_3 \u003d\u003d 0) {\n    local_c \u003d fmt_s32_dec(param_1,param_2);\n  }\n  else if (param_3 \u003c 1) {\n    uVar3 \u003d param_2 / *(uint *)(\u0026DAT_00007978 + param_3 * -4);\n    local_10 \u003d param_2 - *(uint *)(\u0026DAT_00007978 + param_3 * -4) * uVar3;\n    if (local_10 \u003c 0) {\n      local_10 \u003d -local_10;\n    }\n    if ((uVar3 \u003d\u003d 0) \u0026\u0026 ((int)param_2 \u003c 0)) {\n      if (param_1 !\u003d (undefined *)0x0) {\n        *param_1 \u003d 0x2d;\n      }\n      local_c \u003d 1;\n    }\n    if (param_1 \u003d\u003d (undefined *)0x0) {\n      iVar1 \u003d fmt_s32_dec(0,uVar3);\n      local_c \u003d iVar1 + 1 + local_c;\n    }\n    else {\n      iVar1 \u003d fmt_s32_dec(param_1 + local_c,uVar3);\n      iVar1 \u003d local_c + iVar1;\n      local_c \u003d iVar1 + 1;\n      param_1[iVar1] \u003d 0x2e;\n      uVar2 \u003d fmt_s32_dec(param_1 + local_c,local_10);\n      fmt_lpad(param_1 + local_c,uVar2,-param_3,0x30);\n    }\n    local_c \u003d -param_3 + local_c;\n  }\n  else {\n    local_c \u003d fmt_s32_dec(param_1,param_2);\n    if (param_1 !\u003d (undefined *)0x0) {\n      memset(param_1 + local_c,0x30,param_3);\n    }\n    local_c \u003d param_3 + local_c;\n  }\n  return local_c;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003e9e"
      ],
      "called": [
        "FUN_00000f04",
        "FUN_00004622",
        "FUN_00003ff4",
        "FUN_00003e58"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00003ff4": {
      "entrypoint": "0x00003ff4",
      "current_name": "FUN_00003ff4",
      "code": "\nuint FUN_00003ff4(int param_1,uint param_2,uint param_3,undefined param_4)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d param_2;\n  if ((param_2 \u003c param_3) \u0026\u0026 (uVar1 \u003d param_3, param_1 !\u003d 0)) {\n    memmove((param_3 - param_2) + param_1,param_1,param_2);\n    memset(param_1,param_4,param_3 - param_2);\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003ec4"
      ],
      "called": [
        "FUN_00004622",
        "FUN_000045ee"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004042": {
      "entrypoint": "0x00004042",
      "current_name": "FUN_00004042",
      "code": "\nvoid FUN_00004042(undefined4 param_1)\n\n{\n  strtol(param_1,0,10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002fe0",
        "FUN_0000305c"
      ],
      "called": [
        "FUN_00004f84"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000404c": {
      "entrypoint": "0x0000404c",
      "current_name": "FUN_0000404c",
      "code": "\nundefined4 FUN_0000404c(uint *param_1,int *param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  ushort uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar3 \u003d (uint)uVar4;\n  if ((int)(uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar1 \u003d param_2[4];\n    if (iVar1 !\u003d 0) {\n      iVar5 \u003d uVar3 \u003c\u003c 0x1e;\n      bVar9 \u003d iVar5 \u003d\u003d 0;\n      iVar7 \u003d *param_2;\n      if (bVar9) {\n        iVar5 \u003d param_2[5];\n      }\n      *param_2 \u003d iVar1;\n      if (!bVar9) {\n        iVar5 \u003d 0;\n      }\n      param_2[2] \u003d iVar5;\n      for (iVar7 \u003d iVar7 - iVar1; 0 \u003c iVar7; iVar7 \u003d iVar7 - iVar5) {\n        iVar5 \u003d (*(code *)param_2[10])(param_1,param_2[8],iVar1,iVar7);\n        if (iVar5 \u003c 1) {\n          *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n          return 0xffffffff;\n        }\n        iVar1 \u003d iVar1 + iVar5;\n      }\n    }\n  }\n  else {\n    if ((param_2[1] \u003c 1) \u0026\u0026 (param_2[0x10] \u003c 1)) {\n      return 0;\n    }\n    pcVar6 \u003d (code *)param_2[0xb];\n    if (pcVar6 \u003d\u003d (code *)0x0) {\n      return 0;\n    }\n    uVar8 \u003d *param_1;\n    *param_1 \u003d 0;\n    if ((uVar4 \u0026 0x1000) \u003d\u003d 0) {\n      iVar1 \u003d (*pcVar6)(param_1,param_2[8],uVar3 \u0026 0x1000,1);\n      if ((iVar1 \u003d\u003d -1) \u0026\u0026 (uVar3 \u003d *param_1, uVar3 !\u003d 0)) {\n        if ((uVar3 \u003d\u003d 0x1d) || (uVar3 \u003d\u003d 0x16)) {\n          *param_1 \u003d uVar8;\n          return 0;\n        }\n        uVar4 \u003d *(ushort *)(param_2 + 3);\n        goto LAB_00004104;\n      }\n    }\n    else {\n      iVar1 \u003d param_2[0x15];\n    }\n    if (((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1d) \u003c 0) \u0026\u0026\n       (iVar1 \u003d iVar1 - param_2[1], param_2[0xd] !\u003d 0)) {\n      iVar1 \u003d iVar1 - param_2[0x10];\n    }\n    iVar1 \u003d (*(code *)param_2[0xb])(param_1,param_2[8],iVar1,0);\n    uVar4 \u003d *(ushort *)(param_2 + 3);\n    if ((iVar1 \u003d\u003d -1) \u0026\u0026\n       ((0x1d \u003c *param_1 || (-1 \u003c (int)((0x20400001U \u003e\u003e (*param_1 \u0026 0xff)) \u003c\u003c 0x1f))))) {\nLAB_00004104:\n      *(ushort *)(param_2 + 3) \u003d uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    param_2[1] \u003d 0;\n    *param_2 \u003d param_2[4];\n    if (((int)((uint)uVar4 \u003c\u003c 0x13) \u003c 0) \u0026\u0026 ((iVar1 !\u003d -1 || (*param_1 \u003d\u003d 0)))) {\n      param_2[0x15] \u003d iVar1;\n    }\n    piVar2 \u003d (int *)param_2[0xd];\n    *param_1 \u003d uVar8;\n    if (piVar2 !\u003d (int *)0x0) {\n      if (piVar2 !\u003d param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[0xd] \u003d 0;\n      return 0;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004158",
        "FUN_00006768"
      ],
      "called": [
        "FUN_00004b34"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004158": {
      "entrypoint": "0x00004158",
      "current_name": "FUN_00004158",
      "code": "\nundefined4 FUN_00004158(int param_1,undefined4 *param_2)\n\n{\n  undefined4 uVar1;\n  \n  if (param_2[4] !\u003d 0) {\n    if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n      __sinit();\n    }\n    if (param_2 \u003d\u003d \u0026DAT_000079b8) {\n      param_2 \u003d *(undefined4 **)(param_1 + 4);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026DAT_000079d8) {\n      param_2 \u003d *(undefined4 **)(param_1 + 8);\n    }\n    else if (param_2 \u003d\u003d (undefined4 *)\u0026DAT_00007998) {\n      param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n    }\n    if (*(short *)(param_2 + 3) !\u003d 0) {\n      if ((-1 \u003c (int)(param_2[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)*(short *)(param_2 + 3) \u003c\u003c 0x16)) {\n        __retarget_lock_acquire_recursive(param_2[0x16]);\n      }\n      uVar1 \u003d __sflush_r(param_1,param_2);\n      if ((int)(param_2[0x19] \u003c\u003c 0x1f) \u003c 0) {\n        return uVar1;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16) \u003c 0) {\n        return uVar1;\n      }\n      __retarget_lock_release_recursive(param_2[0x16]);\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000041d0",
        "FUN_00005404",
        "FUN_00006768"
      ],
      "called": [
        "FUN_000045e8",
        "FUN_000045ec",
        "FUN_0000404c",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000041d0": {
      "entrypoint": "0x000041d0",
      "current_name": "FUN_000041d0",
      "code": "\nuint FUN_000041d0(int param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  uint uVar1;\n  int iVar2;\n  dword *pdVar3;\n  int iVar4;\n  uint uVar5;\n  int iVar6;\n  undefined4 *puVar7;\n  \n  if (param_1 \u003d\u003d 0) {\n    puVar7 \u003d \u0026DAT_000079f8;\n    pdVar3 \u003d \u0026Elf32_Rel_ARRAY_1fff0200[0x19].r_info;\n    uVar5 \u003d 0;\n    do {\n      iVar6 \u003d pdVar3[1];\n      iVar4 \u003d pdVar3[2];\n      while (iVar6 \u003d iVar6 + -1, -1 \u003c iVar6) {\n        if ((1 \u003c *(ushort *)(iVar4 + 0xc)) \u0026\u0026 (iVar2 \u003d *(short *)(iVar4 + 0xe) + 1, iVar2 !\u003d 0)) {\n          uVar1 \u003d _fflush_r(0x1fff0284,iVar4,param_3,iVar2,puVar7);\n          uVar5 \u003d uVar5 | uVar1;\n        }\n        iVar4 \u003d iVar4 + 0x68;\n      }\n      pdVar3 \u003d (dword *)*pdVar3;\n    } while (pdVar3 !\u003d (dword *)0x0);\n    return uVar5;\n  }\n  uVar5 \u003d _fflush_r(Elf32_Rel_ARRAY_1fff0200[16].r_offset,param_1);\n  return uVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002e48"
      ],
      "called": [
        "FUN_00004158"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000041f4": {
      "entrypoint": "0x000041f4",
      "current_name": "FUN_000041f4",
      "code": "\nvoid FUN_000041f4(undefined4 *param_1,undefined2 param_2,undefined2 param_3)\n\n{\n  *param_1 \u003d 0;\n  param_1[1] \u003d 0;\n  param_1[4] \u003d 0;\n  param_1[5] \u003d 0;\n  param_1[2] \u003d 0;\n  *(undefined2 *)(param_1 + 3) \u003d param_2;\n  param_1[0x19] \u003d 0;\n  *(undefined2 *)((int)param_1 + 0xe) \u003d param_3;\n  param_1[6] \u003d 0;\n  memset(param_1 + 0x17,0,8);\n  param_1[9] \u003d 0x4dc9;\n  param_1[10] \u003d 0x4def;\n  param_1[0xb] \u003d 0x4e27;\n  param_1[8] \u003d param_1;\n  param_1[0xc] \u003d \u0026LAB_00004e4a_1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000042a4"
      ],
      "called": [
        "FUN_00004622"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004248": {
      "entrypoint": "0x00004248",
      "current_name": "FUN_00004248",
      "code": "\nundefined4 * FUN_00004248(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  int iVar2;\n  \n  iVar2 \u003d (param_2 + -1) * 0x68;\n  puVar1 \u003d (undefined4 *)_malloc_r(param_1,iVar2 + 0x74);\n  if (puVar1 !\u003d (undefined4 *)0x0) {\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d param_2;\n    puVar1[2] \u003d puVar1 + 3;\n    memset(puVar1 + 3,0,iVar2 + 0x68);\n  }\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004314"
      ],
      "called": [
        "FUN_00004622",
        "FUN_00004bd0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004274": {
      "entrypoint": "0x00004274",
      "current_name": "FUN_00004274",
      "code": "\nvoid FUN_00004274(void)\n\n{\n  __retarget_lock_acquire_recursive(\u0026DAT_1fff0dec);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004314"
      ],
      "called": [
        "FUN_000045e8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004280": {
      "entrypoint": "0x00004280",
      "current_name": "FUN_00004280",
      "code": "\nvoid FUN_00004280(void)\n\n{\n  __retarget_lock_release_recursive(\u0026DAT_1fff0dec);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004314"
      ],
      "called": [
        "FUN_000045ec"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000428c": {
      "entrypoint": "0x0000428c",
      "current_name": "FUN_0000428c",
      "code": "\nvoid FUN_0000428c(void)\n\n{\n  __retarget_lock_acquire_recursive(0x1fff0de7);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000042a4"
      ],
      "called": [
        "FUN_000045e8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000042a4": {
      "entrypoint": "0x000042a4",
      "current_name": "FUN_000042a4",
      "code": "\nvoid FUN_000042a4(int param_1)\n\n{\n  undefined4 uVar1;\n  \n  __sinit_lock_acquire();\n  if (*(int *)(param_1 + 0x18) \u003d\u003d 0) {\n    *(undefined4 *)(param_1 + 0x48) \u003d 0;\n    *(undefined4 *)(param_1 + 0x4c) \u003d 0;\n    *(undefined4 *)(param_1 + 0x50) \u003d 0;\n    uVar1 \u003d 0x1fff0284;\n    *(undefined **)(param_1 + 0x28) \u003d \u0026DAT_0000423d;\n    if (param_1 \u003d\u003d 0x1fff0284) {\n      uVar1 \u003d 1;\n    }\n    if (param_1 \u003d\u003d 0x1fff0284) {\n      *(undefined4 *)(param_1 + 0x18) \u003d uVar1;\n    }\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 4) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 8) \u003d uVar1;\n    uVar1 \u003d __sfp(param_1);\n    *(undefined4 *)(param_1 + 0xc) \u003d uVar1;\n    std(*(undefined4 *)(param_1 + 4),4,0);\n    std(*(undefined4 *)(param_1 + 8),9,1);\n    std(*(undefined4 *)(param_1 + 0xc),0x12,2);\n    *(undefined4 *)(param_1 + 0x18) \u003d 1;\n  }\n  __retarget_lock_release_recursive(0x1fff0de7);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004c84",
        "FUN_00004158",
        "FUN_00005404",
        "FUN_000057f8",
        "FUN_00006768",
        "FUN_00004314",
        "FUN_00004db8",
        "FUN_00005e10",
        "FUN_000054a8",
        "FUN_00004418",
        "FUN_00004cb4"
      ],
      "called": [
        "FUN_000041f4",
        "FUN_0000428c",
        "FUN_00004314",
        "FUN_000045ec"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004314": {
      "entrypoint": "0x00004314",
      "current_name": "FUN_00004314",
      "code": "\nundefined4 * FUN_00004314(undefined4 *param_1)\n\n{\n  dword dVar1;\n  int iVar2;\n  undefined4 *puVar3;\n  dword *pdVar4;\n  \n  __sfp_lock_acquire();\n  if (Elf32_Rel_ARRAY_1fff0200[19].r_info \u003d\u003d 0) {\n    __sinit(0x1fff0284);\n  }\n  pdVar4 \u003d \u0026Elf32_Rel_ARRAY_1fff0200[0x19].r_info;\n  do {\n    iVar2 \u003d pdVar4[1];\n    puVar3 \u003d (undefined4 *)pdVar4[2];\n    while (iVar2 \u003d iVar2 + -1, -1 \u003c iVar2) {\n      if (*(short *)(puVar3 + 3) \u003d\u003d 0) {\n        puVar3[3] \u003d 0xffff0001;\n        puVar3[0x19] \u003d 0;\n        __retarget_lock_init_recursive(puVar3 + 0x16);\n        __sfp_lock_release();\n        puVar3[1] \u003d 0;\n        puVar3[2] \u003d 0;\n        puVar3[4] \u003d 0;\n        puVar3[5] \u003d 0;\n        *puVar3 \u003d 0;\n        puVar3[6] \u003d 0;\n        memset(puVar3 + 0x17,0,8);\n        puVar3[0xd] \u003d 0;\n        puVar3[0xe] \u003d 0;\n        puVar3[0x12] \u003d 0;\n        puVar3[0x13] \u003d 0;\n        return puVar3;\n      }\n      puVar3 \u003d puVar3 + 0x1a;\n    }\n    if (*pdVar4 \u003d\u003d 0) {\n      dVar1 \u003d __sfmoreglue(param_1,4);\n      *pdVar4 \u003d dVar1;\n      if (dVar1 \u003d\u003d 0) {\n        __sfp_lock_release();\n        *param_1 \u003d 0xc;\n        return (undefined4 *)0x0;\n      }\n    }\n    pdVar4 \u003d (dword *)*pdVar4;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000042a4"
      ],
      "called": [
        "FUN_00004274",
        "FUN_00004622",
        "FUN_00004280",
        "FUN_00004248",
        "FUN_000042a4",
        "FUN_000045e4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000043a0": {
      "entrypoint": "0x000043a0",
      "current_name": "FUN_000043a0",
      "code": "\nuint FUN_000043a0(int param_1,code *param_2)\n\n{\n  uint uVar1;\n  int *piVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  \n  piVar2 \u003d (int *)(param_1 + 0x48);\n  uVar4 \u003d 0;\n  do {\n    iVar5 \u003d piVar2[1];\n    iVar3 \u003d piVar2[2];\n    while (iVar5 \u003d iVar5 + -1, -1 \u003c iVar5) {\n      if ((1 \u003c *(ushort *)(iVar3 + 0xc)) \u0026\u0026 (*(short *)(iVar3 + 0xe) !\u003d -1)) {\n        uVar1 \u003d (*param_2)(iVar3);\n        uVar4 \u003d uVar4 | uVar1;\n      }\n      iVar3 \u003d iVar3 + 0x68;\n    }\n    piVar2 \u003d (int *)*piVar2;\n  } while (piVar2 !\u003d (int *)0x0);\n  return uVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00006768"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004418": {
      "entrypoint": "0x00004418",
      "current_name": "FUN_00004418",
      "code": "\nuint FUN_00004418(void)\n\n{\n  dword dVar1;\n  uint uVar2;\n  byte **ppbVar3;\n  byte *pbVar4;\n  \n  dVar1 \u003d Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset !\u003d 0) \u0026\u0026\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) \u003d\u003d 0)) {\n    __sinit(Elf32_Rel_ARRAY_1fff0200[16].r_offset);\n  }\n  ppbVar3 \u003d *(byte ***)(dVar1 + 4);\n  if ((dVar1 !\u003d 0) \u0026\u0026 (*(int *)(dVar1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (ppbVar3 \u003d\u003d (byte **)\u0026DAT_000079b8) {\n    ppbVar3 \u003d *(byte ***)(dVar1 + 4);\n  }\n  else if (ppbVar3 \u003d\u003d (byte **)\u0026DAT_000079d8) {\n    ppbVar3 \u003d *(byte ***)(dVar1 + 8);\n  }\n  else if (ppbVar3 \u003d\u003d (byte **)\u0026DAT_00007998) {\n    ppbVar3 \u003d *(byte ***)(dVar1 + 0xc);\n  }\n  if ((-1 \u003c (int)ppbVar3[0x19] \u003c\u003c 0x1f) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(ppbVar3 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_acquire_recursive(ppbVar3[0x16]);\n  }\n  pbVar4 \u003d ppbVar3[1];\n  ppbVar3[1] \u003d pbVar4 + -1;\n  if ((int)(pbVar4 + -1) \u003c 0) {\n    uVar2 \u003d __srget_r(dVar1,ppbVar3);\n  }\n  else {\n    pbVar4 \u003d *ppbVar3;\n    *ppbVar3 \u003d pbVar4 + 1;\n    uVar2 \u003d (uint)*pbVar4;\n  }\n  if ((-1 \u003c (int)ppbVar3[0x19] \u003c\u003c 0x1f) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(ppbVar3 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_release_recursive(ppbVar3[0x16]);\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002d94"
      ],
      "called": [
        "FUN_000045e8",
        "FUN_00005e10",
        "FUN_000045ec",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000443c": {
      "entrypoint": "0x0000443c",
      "current_name": "FUN_0000443c",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x000044a8) */\n\nuint * FUN_0000443c(undefined4 *param_1,uint *param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  uVar6 \u003d *param_1;\n  uVar7 \u003d param_1[1];\n  iVar1 \u003d __aeabi_ldivmod(uVar6,uVar7,0x15180,0);\n  uVar3 \u003d 0x15180;\n  __aeabi_ldivmod(uVar6,uVar7,0x15180,0);\n  bVar9 \u003d (int)uVar3 \u003c 0;\n  if (bVar9) {\n    uVar3 \u003d uVar3 + 0x15180;\n  }\n  if (bVar9) {\n    uVar2 \u003d iVar1 + 0xafa6b;\n  }\n  else {\n    uVar2 \u003d iVar1 + 0xafa6c;\n  }\n  param_2[2] \u003d uVar3 / 0xe10;\n  param_2[1] \u003d (uVar3 % 0xe10) / 0x3c;\n  *param_2 \u003d (uVar3 % 0xe10) % 0x3c;\n  param_2[6] \u003d (uVar2 + 3) % 7;\n  uVar3 \u003d uVar2;\n  if ((int)uVar2 \u003c 0) {\n    uVar3 \u003d uVar2 - 0x23ab0;\n  }\n  uVar2 \u003d (uVar3 / 0x23ab1) * -0x23ab1 + uVar2;\n  uVar4 \u003d ((uVar2 / 0x8eac + uVar2) - uVar2 / 0x5b4) - uVar2 / 0x23ab0;\n  uVar5 \u003d uVar4 / 0x16d;\n  uVar2 \u003d (uVar5 / 100 - uVar4 / 0x5b4) + uVar2 + uVar5 * -0x16d;\n  uVar8 \u003d uVar2 * 5 + 2;\n  uVar4 \u003d uVar8 / 0x99;\n  if (uVar8 \u003c 0x5fa) {\n    iVar1 \u003d 2;\n  }\n  else {\n    iVar1 \u003d -10;\n  }\n  uVar8 \u003d uVar4 + iVar1;\n  iVar1 \u003d (uVar3 / 0x23ab1) * 400 + uVar5;\n  if (uVar8 \u003c 2) {\n    iVar1 \u003d iVar1 + 1;\n  }\n  if (uVar2 \u003c 0x132) {\n    if (((uVar5 \u0026 3) \u003d\u003d 0) \u0026\u0026 (uVar5 !\u003d (uVar5 / 100) * 100)) {\n      uVar3 \u003d 1;\n    }\n    else {\n      uVar3 \u003d (uint)(uVar5 % 400 \u003d\u003d 0);\n    }\n    uVar3 \u003d uVar2 + 0x3b + uVar3;\n  }\n  else {\n    uVar3 \u003d uVar2 - 0x132;\n  }\n  param_2[7] \u003d uVar3;\n  param_2[3] \u003d (uVar2 + 1) - (uVar4 * 0x99 + 2) / 5;\n  param_2[4] \u003d uVar8;\n  param_2[5] \u003d iVar1 - 0x76c;\n  param_2[8] \u003d 0;\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002690",
        "FUN_00002624"
      ],
      "called": [
        "FUN_00006974"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000459c": {
      "entrypoint": "0x0000459c",
      "current_name": "FUN_0000459c",
      "code": "\nvoid FUN_0000459c(void)\n\n{\n  code **ppcVar1;\n  int iVar2;\n  \n  ppcVar1 \u003d (code **)\u0026DAT_00007c58;\n  for (iVar2 \u003d 0; iVar2 !\u003d 0; iVar2 \u003d iVar2 + 1) {\n    (**ppcVar1)();\n    ppcVar1 \u003d ppcVar1 + 1;\n  }\n  _init();\n  ppcVar1 \u003d (code **)\u0026DAT_00007c58;\n  for (iVar2 \u003d 0; iVar2 !\u003d 0; iVar2 \u003d iVar2 + 1) {\n    (**ppcVar1)();\n    ppcVar1 \u003d ppcVar1 + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000099c"
      ],
      "called": [
        "FUN_00000410"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000045e4": {
      "entrypoint": "0x000045e4",
      "current_name": "FUN_000045e4",
      "code": "\nvoid FUN_000045e4(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004314"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000045e8": {
      "entrypoint": "0x000045e8",
      "current_name": "FUN_000045e8",
      "code": "\nvoid FUN_000045e8(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000428c",
        "FUN_00004158",
        "FUN_00005fec",
        "FUN_00004274",
        "FUN_00005790",
        "FUN_000057f8",
        "FUN_00004db8",
        "FUN_00004418",
        "FUN_00004cb4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000045ec": {
      "entrypoint": "0x000045ec",
      "current_name": "FUN_000045ec",
      "code": "\nvoid FUN_000045ec(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005ff8",
        "FUN_00004158",
        "FUN_0000579c",
        "FUN_000057f8",
        "FUN_00004db8",
        "FUN_00004280",
        "FUN_000042a4",
        "FUN_00004418",
        "FUN_00004cb4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000045ee": {
      "entrypoint": "0x000045ee",
      "current_name": "FUN_000045ee",
      "code": "\nvoid FUN_000045ee(undefined *param_1,undefined *param_2,int param_3)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  \n  puVar2 \u003d param_2 + param_3;\n  if ((param_2 \u003c param_1) \u0026\u0026 (param_1 \u003c puVar2)) {\n    puVar1 \u003d param_1 + param_3;\n    while (puVar1 !\u003d param_1) {\n      puVar2 \u003d puVar2 + -1;\n      puVar1 \u003d puVar1 + -1;\n      *puVar1 \u003d *puVar2;\n    }\n  }\n  else {\n    param_1 \u003d param_1 + -1;\n    for (; param_2 !\u003d puVar2; param_2 \u003d param_2 + 1) {\n      param_1 \u003d param_1 + 1;\n      *param_1 \u003d *param_2;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00003ff4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004622": {
      "entrypoint": "0x00004622",
      "current_name": "FUN_00004622",
      "code": "\nvoid FUN_00004622(undefined *param_1,undefined param_2,int param_3)\n\n{\n  undefined *puVar1;\n  \n  puVar1 \u003d param_1 + param_3;\n  for (; param_1 !\u003d puVar1; param_1 \u003d param_1 + 1) {\n    *param_1 \u003d param_2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000041f4",
        "FUN_00003ff4",
        "FUN_00004314",
        "FUN_00003ec4",
        "FUN_00004248",
        "FUN_0000305c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004634": {
      "entrypoint": "0x00004634",
      "current_name": "FUN_00004634",
      "code": "\nvoid FUN_00004634(uint *param_1,uint param_2,undefined4 param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  int iVar4;\n  bool bVar5;\n  uint *local_20;\n  uint local_1c;\n  undefined4 uStack_18;\n  \n  local_20 \u003d param_1;\n  local_1c \u003d param_2;\n  uStack_18 \u003d param_3;\n  if (0x3b \u003c *param_1) {\n    div(\u0026local_20,*param_1,0x3c);\n    uVar2 \u003d param_1[1] + (int)local_20;\n    param_1[1] \u003d uVar2;\n    if ((int)local_1c \u003c 0) {\n      uVar2 \u003d uVar2 - 1;\n      *param_1 \u003d local_1c + 0x3c;\n    }\n    else {\n      *param_1 \u003d local_1c;\n    }\n    if ((int)local_1c \u003c 0) {\n      param_1[1] \u003d uVar2;\n    }\n  }\n  if (0x3b \u003c param_1[1]) {\n    div(\u0026local_20,param_1[1],0x3c);\n    bVar5 \u003d (int)local_1c \u003c 0;\n    uVar3 \u003d param_1[2] + (int)local_20;\n    param_1[2] \u003d uVar3;\n    uVar2 \u003d local_1c;\n    if (bVar5) {\n      uVar2 \u003d local_1c + 0x3c;\n      uVar3 \u003d uVar3 - 1;\n    }\n    if (!bVar5) {\n      param_1[1] \u003d uVar2;\n    }\n    if (bVar5) {\n      param_1[1] \u003d uVar2;\n    }\n    if (bVar5) {\n      param_1[2] \u003d uVar3;\n    }\n  }\n  if (0x17 \u003c param_1[2]) {\n    div(\u0026local_20,param_1[2],0x18);\n    bVar5 \u003d (int)local_1c \u003c 0;\n    uVar3 \u003d param_1[3] + (int)local_20;\n    param_1[3] \u003d uVar3;\n    uVar2 \u003d local_1c;\n    if (bVar5) {\n      uVar2 \u003d local_1c + 0x18;\n      uVar3 \u003d uVar3 - 1;\n    }\n    if (!bVar5) {\n      param_1[2] \u003d uVar2;\n    }\n    if (bVar5) {\n      param_1[2] \u003d uVar2;\n    }\n    if (bVar5) {\n      param_1[3] \u003d uVar3;\n    }\n  }\n  if (0xb \u003c param_1[4]) {\n    div(\u0026local_20,param_1[4],0xc);\n    bVar5 \u003d (int)local_1c \u003c 0;\n    uVar2 \u003d param_1[5] + (int)local_20;\n    param_1[5] \u003d uVar2;\n    if (bVar5) {\n      local_1c \u003d local_1c + 0xc;\n      uVar2 \u003d uVar2 - 1;\n    }\n    if (!bVar5) {\n      param_1[4] \u003d local_1c;\n    }\n    if (bVar5) {\n      param_1[4] \u003d local_1c;\n    }\n    if (bVar5) {\n      param_1[5] \u003d uVar2;\n    }\n  }\n  uVar2 \u003d param_1[5];\n  if ((uVar2 \u0026 3) \u003d\u003d 0) {\n    if (uVar2 \u003d\u003d (uVar2 / 100) * 100) {\n      if ((uVar2 + 0x76c) % 400 \u003d\u003d 0) {\n        iVar4 \u003d 0x1d;\n      }\n      else {\n        iVar4 \u003d 0x1c;\n      }\n    }\n    else {\n      iVar4 \u003d 0x1d;\n    }\n  }\n  else {\n    iVar4 \u003d 0x1c;\n  }\n  if ((int)param_1[3] \u003c 1) {\n    while ((int)param_1[3] \u003c 1) {\n      uVar2 \u003d param_1[4];\n      param_1[4] \u003d uVar2 - 1;\n      if (uVar2 - 1 \u003d\u003d 0xffffffff) {\n        uVar3 \u003d param_1[5];\n        uVar2 \u003d uVar3 - 1;\n        param_1[4] \u003d 0xb;\n        param_1[5] \u003d uVar2;\n        if ((uVar2 \u0026 3) \u003d\u003d 0) {\n          if (uVar2 \u003d\u003d (uVar2 / 100) * 100) {\n            if ((uVar3 + 0x76b) % 400 \u003d\u003d 0) {\n              iVar4 \u003d 0x1d;\n            }\n            else {\n              iVar4 \u003d 0x1c;\n            }\n          }\n          else {\n            iVar4 \u003d 0x1d;\n          }\n        }\n        else {\n          iVar4 \u003d 0x1c;\n        }\n      }\n      iVar1 \u003d iVar4;\n      if (param_1[4] !\u003d 1) {\n        iVar1 \u003d (\u0026DAT_000079fc)[param_1[4]];\n      }\n      param_1[3] \u003d iVar1 + param_1[3];\n    }\n  }\n  else {\n    while( true ) {\n      uVar2 \u003d param_1[4];\n      iVar1 \u003d iVar4;\n      if (uVar2 !\u003d 1) {\n        iVar1 \u003d (\u0026DAT_000079fc)[uVar2];\n      }\n      if ((int)param_1[3] \u003c\u003d iVar1) break;\n      param_1[3] \u003d param_1[3] - iVar1;\n      param_1[4] \u003d uVar2 + 1;\n      if (uVar2 + 1 \u003d\u003d 0xc) {\n        uVar3 \u003d param_1[5];\n        uVar2 \u003d uVar3 + 1;\n        param_1[4] \u003d 0;\n        param_1[5] \u003d uVar2;\n        if ((uVar2 \u0026 3) \u003d\u003d 0) {\n          if (uVar2 % 100 \u003d\u003d 0) {\n            if ((uVar3 + 0x76d) % 400 \u003d\u003d 0) {\n              iVar4 \u003d 0x1d;\n            }\n            else {\n              iVar4 \u003d 0x1c;\n            }\n          }\n          else {\n            iVar4 \u003d 0x1d;\n          }\n        }\n        else {\n          iVar4 \u003d 0x1c;\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000047e4"
      ],
      "called": [
        "FUN_00005584"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000047e4": {
      "entrypoint": "0x000047e4",
      "current_name": "FUN_000047e4",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00004ab2) */\n\nundefined8 FUN_000047e4(int *param_1)\n\n{\n  longlong lVar1;\n  longlong lVar2;\n  int *piVar3;\n  uint uVar4;\n  int iVar5;\n  int iVar6;\n  int iVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  int iVar11;\n  uint uVar12;\n  uint uVar13;\n  uint uVar14;\n  uint uVar15;\n  bool bVar16;\n  \n  piVar3 \u003d (int *)__gettzinfo();\n  validate_structure(param_1);\n  uVar12 \u003d param_1[5];\n  iVar11 \u003d param_1[3] + -1 + *(int *)(\u0026DAT_00007a2c + param_1[4] * 4);\n  if (((1 \u003c param_1[4]) \u0026\u0026 ((uVar12 \u0026 3) \u003d\u003d 0)) \u0026\u0026\n     ((uVar12 !\u003d (uVar12 / 100) * 100 || (uVar12 + 0x76c \u003d\u003d ((uVar12 + 0x76c) / 400) * 400)))) {\n    iVar11 \u003d iVar11 + 1;\n  }\n  param_1[7] \u003d iVar11;\n  if (20000 \u003c (int)\u0026DAT_00002710 + uVar12) {\n    iVar7 \u003d -1;\n    iVar5 \u003d -1;\n    goto LAB_00004aba;\n  }\n  if ((int)uVar12 \u003c 0x47) {\n    if (uVar12 !\u003d 0x46) {\n      for (uVar9 \u003d 0x45; (int)uVar12 \u003c (int)uVar9; uVar9 \u003d uVar9 - 1) {\n        if ((uVar9 \u0026 3) \u003d\u003d 0) {\n          if (uVar9 \u003d\u003d (uVar9 / 100) * 100) {\n            if ((uVar9 + 0x76c) % 400 \u003d\u003d 0) {\n              iVar7 \u003d 0x16e;\n            }\n            else {\n              iVar7 \u003d 0x16d;\n            }\n          }\n          else {\n            iVar7 \u003d 0x16e;\n          }\n        }\n        else {\n          iVar7 \u003d 0x16d;\n        }\n        iVar11 \u003d iVar11 - iVar7;\n      }\n      if ((uVar9 \u0026 3) \u003d\u003d 0) {\n        if (uVar12 \u003d\u003d (uVar12 / 100) * 100) {\n          iVar7 \u003d 0x16d;\n          if ((uVar12 + 0x76c) % 400 \u003d\u003d 0) {\n            iVar7 \u003d 0x16e;\n          }\n        }\n        else {\n          iVar7 \u003d 0x16e;\n        }\n      }\n      else {\n        iVar7 \u003d 0x16d;\n      }\n      iVar11 \u003d iVar11 - iVar7;\n    }\n  }\n  else {\n    uVar9 \u003d 0x46;\n    do {\n      if ((uVar9 \u0026 3) \u003d\u003d 0) {\n        if (uVar9 % 100 \u003d\u003d 0) {\n          if ((uVar9 + 0x76c) % 400 \u003d\u003d 0) {\n            iVar7 \u003d 0x16e;\n          }\n          else {\n            iVar7 \u003d 0x16d;\n          }\n        }\n        else {\n          iVar7 \u003d 0x16e;\n        }\n      }\n      else {\n        iVar7 \u003d 0x16d;\n      }\n      uVar9 \u003d uVar9 + 1;\n      iVar11 \u003d iVar11 + iVar7;\n    } while (uVar12 !\u003d uVar9);\n  }\n  lVar1 \u003d (longlong)iVar11 * 0x15180 + (longlong)(param_1[2] * 0xe10 + param_1[1] * 0x3c + *param_1)\n  ;\n  uVar15 \u003d (uint)lVar1;\n  iVar7 \u003d (int)((ulonglong)lVar1 \u003e\u003e 0x20);\n  __tz_lock();\n  _tzset_unlocked();\n  uVar9 \u003d DAT_1fff0dd8;\n  if (DAT_1fff0dd8 \u003d\u003d 0) {\nLAB_00004934:\n    uVar12 \u003d piVar3[10];\n    iVar7 \u003d (uint)lVar1 + uVar12;\n    iVar5 \u003d (int)((ulonglong)lVar1 \u003e\u003e 0x20) +\n            ((int)uVar12 \u003e\u003e 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n  }\n  else {\n    uVar14 \u003d param_1[8];\n    uVar13 \u003d uVar14;\n    if (0 \u003c (int)uVar14) {\n      uVar13 \u003d 1;\n    }\n    if ((piVar3[1] \u003d\u003d param_1[5] + 0x76c) || (iVar5 \u003d __tzcalc_limits(), iVar5 !\u003d 0)) {\n      uVar10 \u003d piVar3[0x14];\n      uVar4 \u003d piVar3[0x12];\n      uVar8 \u003d piVar3[10];\n      uVar9 \u003d uVar4 - uVar8;\n      iVar5 \u003d (piVar3[0x13] - ((int)uVar8 \u003e\u003e 0x1f)) - (uint)(uVar4 \u003c uVar8);\n      if (((int)((iVar7 - iVar5) - (uint)(uVar15 \u003c uVar9)) \u003c 0 \u003d\u003d\n           (SBORROW4(iVar7,iVar5) !\u003d SBORROW4(iVar7 - iVar5,(uint)(uVar15 \u003c uVar9)))) \u0026\u0026\n         (iVar6 \u003d (piVar3[0x13] - ((int)uVar10 \u003e\u003e 0x1f)) - (uint)(uVar4 \u003c uVar10),\n         bVar16 \u003d uVar15 \u003c uVar4 - uVar10,\n         (int)((iVar7 - iVar6) - (uint)bVar16) \u003c 0 !\u003d\n         (SBORROW4(iVar7,iVar6) !\u003d SBORROW4(iVar7 - iVar6,(uint)bVar16)))) goto LAB_00004a88;\n      uVar4 \u003d piVar3[8] - uVar10;\n      iVar6 \u003d (piVar3[9] - ((int)uVar10 \u003e\u003e 0x1f)) - (uint)((uint)piVar3[8] \u003c uVar10);\n      if (*piVar3 !\u003d 0) {\n        if ((int)((iVar7 - iVar6) - (uint)(uVar15 \u003c uVar4)) \u003c 0 \u003d\u003d\n            (SBORROW4(iVar7,iVar6) !\u003d SBORROW4(iVar7 - iVar6,(uint)(uVar15 \u003c uVar4))))\n        goto LAB_0000491e;\nLAB_0000492a:\n        uVar9 \u003d 0;\n        if ((int)uVar14 \u003c 0) goto LAB_00004934;\nLAB_00004a14:\n        uVar15 \u003d uVar13 ^ uVar9;\n        uVar13 \u003d uVar9;\n        if (uVar15 \u003d\u003d 1) {\n          if (uVar9 \u003d\u003d 0) {\n            iVar7 \u003d uVar10 - uVar8;\n          }\n          else {\n            iVar7 \u003d uVar8 - uVar10;\n          }\n          iVar5 \u003d param_1[3];\n          *param_1 \u003d *param_1 + iVar7;\n          lVar2 \u003d lVar1 + iVar7;\n          validate_structure(param_1);\n          iVar5 \u003d param_1[3] - iVar5;\n          lVar1 \u003d lVar1 + iVar7;\n          if (iVar5 !\u003d 0) {\n            if (iVar5 \u003c 2) {\n              if (iVar5 \u003d\u003d -2 || iVar5 + 2 \u003c 0 !\u003d SCARRY4(iVar5,2)) {\n                iVar5 \u003d 1;\n              }\n            }\n            else {\n              iVar5 \u003d -1;\n            }\n            iVar7 \u003d iVar5 + param_1[7];\n            iVar11 \u003d iVar11 + iVar5;\n            if (iVar7 \u003c 0) {\n              uVar9 \u003d uVar12 - 1;\n              if ((uVar9 \u0026 3) \u003d\u003d 0) {\n                if (uVar9 \u003d\u003d (uVar9 / 100) * 100) {\n                  iVar7 \u003d 0x16d;\n                  if ((uVar12 + 0x76b) % 400 !\u003d 0) {\n                    iVar7 \u003d 0x16c;\n                  }\n                }\n                else {\n                  iVar7 \u003d 0x16d;\n                }\n              }\n              else {\n                iVar7 \u003d 0x16c;\n              }\n            }\n            else {\n              if ((uVar12 \u0026 3) \u003d\u003d 0) {\n                if (uVar12 \u003d\u003d (uVar12 / 100) * 100) {\n                  iVar5 \u003d 0x16d;\n                  if ((uVar12 + 0x76c) % 400 \u003d\u003d 0) {\n                    iVar5 \u003d 0x16e;\n                  }\n                }\n                else {\n                  iVar5 \u003d 0x16e;\n                }\n              }\n              else {\n                iVar5 \u003d 0x16d;\n              }\n              if (iVar5 \u003c\u003d iVar7) {\n                iVar7 \u003d iVar7 - iVar5;\n              }\n            }\n            param_1[7] \u003d iVar7;\n            lVar1 \u003d lVar2;\n          }\n        }\n        goto LAB_00004a88;\n      }\n      if ((int)((iVar7 - iVar6) - (uint)(uVar15 \u003c uVar4)) \u003c 0 !\u003d\n          (SBORROW4(iVar7,iVar6) !\u003d SBORROW4(iVar7 - iVar6,(uint)(uVar15 \u003c uVar4)))) {\nLAB_0000491e:\n        if ((int)((iVar7 - iVar5) - (uint)(uVar15 \u003c uVar9)) \u003c 0 \u003d\u003d\n            (SBORROW4(iVar7,iVar5) !\u003d SBORROW4(iVar7 - iVar5,(uint)(uVar15 \u003c uVar9))))\n        goto LAB_0000492a;\n      }\n      if (-1 \u003c (int)uVar14) {\n        uVar9 \u003d 1;\n        goto LAB_00004a14;\n      }\n    }\n    else {\nLAB_00004a88:\n      uVar9 \u003d uVar13;\n      if (uVar13 !\u003d 1) goto LAB_00004934;\n    }\n    uVar12 \u003d piVar3[0x14];\n    iVar7 \u003d (uint)lVar1 + uVar12;\n    iVar5 \u003d (int)((ulonglong)lVar1 \u003e\u003e 0x20) +\n            ((int)uVar12 \u003e\u003e 0x1f) + (uint)CARRY4((uint)lVar1,uVar12);\n    uVar9 \u003d 1;\n  }\n  __tz_unlock();\n  param_1[8] \u003d uVar9;\n  param_1[6] \u003d (iVar11 + 4U) % 7;\nLAB_00004aba:\n  return CONCAT44(iVar5,iVar7);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002600",
        "FUN_00002654"
      ],
      "called": [
        "FUN_00005100",
        "FUN_000050f4",
        "FUN_000056b0",
        "FUN_000050e8",
        "FUN_00004f98",
        "FUN_00004634"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004b34": {
      "entrypoint": "0x00004b34",
      "current_name": "FUN_00004b34",
      "code": "\nvoid FUN_00004b34(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  int *piVar1;\n  int **extraout_r1;\n  int **ppiVar2;\n  int **ppiVar3;\n  int **ppiVar4;\n  int **ppiVar5;\n  bool bVar6;\n  \n  if (param_2 \u003d\u003d 0) {\n    return;\n  }\n  ppiVar5 \u003d (int **)(param_2 + -4);\n  if (*(int *)(param_2 + -4) \u003c 0) {\n    ppiVar5 \u003d (int **)((int)ppiVar5 + *(int *)(param_2 + -4));\n  }\n  __malloc_lock();\n  ppiVar3 \u003d (int **)\u0026DAT_1fff0db4;\n  if (DAT_1fff0db4 \u003d\u003d (int **)0x0) {\n    ppiVar5[1] \u003d (int *)0x0;\n    ppiVar2 \u003d extraout_r1;\n    DAT_1fff0db4 \u003d ppiVar5;\n  }\n  else {\n    ppiVar4 \u003d DAT_1fff0db4;\n    if (ppiVar5 \u003c DAT_1fff0db4) {\n      ppiVar2 \u003d (int **)*ppiVar5;\n      ppiVar3 \u003d (int **)((int)ppiVar5 + (int)ppiVar2);\n      bVar6 \u003d DAT_1fff0db4 \u003d\u003d ppiVar3;\n      if (bVar6) {\n        ppiVar3 \u003d (int **)*DAT_1fff0db4;\n        DAT_1fff0db4 \u003d (int **)DAT_1fff0db4[1];\n      }\n      ppiVar5[1] \u003d (int *)DAT_1fff0db4;\n      DAT_1fff0db4 \u003d ppiVar5;\n      if (bVar6) {\n        ppiVar3 \u003d (int **)((int)ppiVar3 + (int)ppiVar2);\n        *ppiVar5 \u003d (int *)ppiVar3;\n      }\n    }\n    else {\n      do {\n        ppiVar3 \u003d ppiVar4;\n        ppiVar4 \u003d (int **)ppiVar3[1];\n        if (ppiVar4 \u003d\u003d (int **)0x0) break;\n      } while (ppiVar4 \u003c\u003d ppiVar5);\n      ppiVar2 \u003d (int **)*ppiVar3;\n      if ((int **)((int)ppiVar3 + (int)ppiVar2) \u003d\u003d ppiVar5) {\n        ppiVar2 \u003d (int **)((int)ppiVar2 + (int)*ppiVar5);\n        *ppiVar3 \u003d (int *)ppiVar2;\n        if (ppiVar4 \u003d\u003d (int **)((int)ppiVar3 + (int)ppiVar2)) {\n          piVar1 \u003d *ppiVar4;\n          ppiVar3[1] \u003d ppiVar4[1];\n          ppiVar2 \u003d (int **)((int)ppiVar2 + (int)piVar1);\n          *ppiVar3 \u003d (int *)ppiVar2;\n        }\n      }\n      else if (ppiVar5 \u003c (int **)((int)ppiVar3 + (int)ppiVar2)) {\n        *param_1 \u003d 0xc;\n      }\n      else {\n        ppiVar2 \u003d (int **)((int)ppiVar5 + (int)*ppiVar5);\n        bVar6 \u003d ppiVar4 \u003d\u003d ppiVar2;\n        if (bVar6) {\n          ppiVar2 \u003d (int **)*ppiVar4;\n          ppiVar4 \u003d (int **)ppiVar4[1];\n        }\n        ppiVar5[1] \u003d (int *)ppiVar4;\n        if (bVar6) {\n          ppiVar2 \u003d (int **)((int)ppiVar2 + (int)*ppiVar5);\n          *ppiVar5 \u003d (int *)ppiVar2;\n        }\n        ppiVar3[1] \u003d (int *)ppiVar5;\n      }\n    }\n  }\n  __malloc_unlock(param_1,ppiVar2,ppiVar3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00006192",
        "FUN_00006768",
        "FUN_00005780",
        "FUN_000054a8",
        "FUN_000060cc",
        "FUN_0000404c"
      ],
      "called": [
        "FUN_0000579c",
        "FUN_00005790"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004bd0": {
      "entrypoint": "0x00004bd0",
      "current_name": "FUN_00004bd0",
      "code": "\nuint FUN_00004bd0(undefined4 *param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  uint *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint *puVar4;\n  uint uVar5;\n  \n  uVar5 \u003d (param_2 + 3 \u0026 0xfffffffc) + 8;\n  if (uVar5 \u003c 0xc) {\n    uVar5 \u003d 0xc;\n  }\n  if (((int)uVar5 \u003c 0) || (uVar5 \u003c param_2)) {\n    *param_1 \u003d 0xc;\n  }\n  else {\n    __malloc_lock();\n    puVar1 \u003d DAT_1fff0db4;\n    for (puVar4 \u003d DAT_1fff0db4; puVar4 !\u003d (uint *)0x0; puVar4 \u003d (uint *)puVar4[1]) {\n      uVar3 \u003d *puVar4 - uVar5;\n      if (-1 \u003c (int)uVar3) {\n        if (0xb \u003c uVar3) {\n          *puVar4 \u003d uVar3;\n          puVar4 \u003d (uint *)((int)puVar4 + uVar3);\n          goto LAB_00004c34;\n        }\n        if (puVar1 \u003d\u003d puVar4) {\n          DAT_1fff0db4 \u003d (uint *)puVar4[1];\n        }\n        if (puVar1 !\u003d puVar4) {\n          puVar1[1] \u003d (uint)(uint *)puVar4[1];\n        }\n        goto LAB_00004c42;\n      }\n      puVar1 \u003d puVar4;\n    }\n    if (DAT_1fff0db8 \u003d\u003d 0) {\n      DAT_1fff0db8 \u003d _sbrk_r(param_1,0,puVar1,0,param_4);\n    }\n    puVar1 \u003d (uint *)_sbrk_r(param_1,uVar5);\n    if ((puVar1 !\u003d (uint *)0xffffffff) \u0026\u0026\n       ((puVar4 \u003d (uint *)((int)puVar1 + 3U \u0026 0xfffffffc), puVar1 \u003d\u003d puVar4 ||\n        (iVar2 \u003d _sbrk_r(param_1,(int)puVar4 - (int)puVar1), iVar2 !\u003d -1)))) {\nLAB_00004c34:\n      *puVar4 \u003d uVar5;\nLAB_00004c42:\n      __malloc_unlock(param_1);\n      uVar5 \u003d (int)puVar4 + 0xbU \u0026 0xfffffff8;\n      iVar2 \u003d uVar5 - (int)(puVar4 + 1);\n      if (iVar2 \u003d\u003d 0) {\n        return uVar5;\n      }\n      *(uint *)((int)puVar4 + iVar2) \u003d (int)(puVar4 + 1) - uVar5;\n      return uVar5;\n    }\n    *param_1 \u003d 0xc;\n    __malloc_unlock(param_1);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100",
        "FUN_00005700",
        "FUN_000068f0",
        "FUN_000060cc",
        "FUN_00004248"
      ],
      "called": [
        "FUN_0000579c",
        "FUN_00000428",
        "FUN_00005790"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004c84": {
      "entrypoint": "0x00004c84",
      "current_name": "FUN_00004c84",
      "code": "\nvoid FUN_00004c84(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  dword dVar1;\n  undefined4 uVar2;\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  dVar1 \u003d Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  uVar2 \u003d param_1;\n  uStack_c \u003d param_2;\n  uStack_8 \u003d param_3;\n  uStack_4 \u003d param_4;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset !\u003d 0) \u0026\u0026\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) \u003d\u003d 0)) {\n    __sinit(Elf32_Rel_ARRAY_1fff0200[16].r_offset);\n  }\n  _vfprintf_r(dVar1,*(undefined4 *)(dVar1 + 8),param_1,\u0026uStack_c,uVar2,\u0026uStack_c);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00000ed8",
        "FUN_00002b10",
        "FUN_0000211c",
        "FUN_00003378",
        "FUN_00003694",
        "FUN_0000305c",
        "FUN_00002f74",
        "FUN_00002ecc",
        "FUN_00000f04",
        "FUN_0000316c",
        "FUN_00002fe0",
        "FUN_00003524",
        "FUN_00002a88"
      ],
      "called": [
        "FUN_000057f8",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004cb4": {
      "entrypoint": "0x00004cb4",
      "current_name": "FUN_00004cb4",
      "code": "\nuint FUN_00004cb4(uint param_1)\n\n{\n  dword dVar1;\n  undefined4 *puVar2;\n  uint uVar3;\n  undefined *puVar4;\n  undefined4 unaff_r4;\n  undefined4 unaff_r5;\n  \n  dVar1 \u003d Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset !\u003d 0) \u0026\u0026\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) \u003d\u003d 0)) {\n    __sinit(Elf32_Rel_ARRAY_1fff0200[16].r_offset);\n  }\n  puVar2 \u003d *(undefined4 **)(dVar1 + 8);\n  if ((dVar1 !\u003d 0) \u0026\u0026 (*(int *)(dVar1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (puVar2 \u003d\u003d \u0026DAT_000079b8) {\n    puVar2 \u003d *(undefined4 **)(dVar1 + 4);\n  }\n  else if (puVar2 \u003d\u003d (undefined4 *)\u0026DAT_000079d8) {\n    puVar2 \u003d *(undefined4 **)(dVar1 + 8);\n  }\n  else if (puVar2 \u003d\u003d (undefined4 *)\u0026DAT_00007998) {\n    puVar2 \u003d *(undefined4 **)(dVar1 + 0xc);\n  }\n  if ((-1 \u003c (int)(puVar2[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(puVar2 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_acquire_recursive(puVar2[0x16]);\n  }\n  uVar3 \u003d puVar2[2] - 1;\n  puVar2[2] \u003d uVar3;\n  if (((int)uVar3 \u003c 0) \u0026\u0026 (((int)uVar3 \u003c (int)puVar2[6] || (uVar3 \u003d param_1 \u0026 0xff, uVar3 \u003d\u003d 10))))\n  {\n    param_1 \u003d __swbuf_r(dVar1,param_1,puVar2,uVar3,unaff_r4,unaff_r5);\n  }\n  else {\n    puVar4 \u003d (undefined *)*puVar2;\n    *puVar2 \u003d puVar4 + 1;\n    *puVar4 \u003d (char)param_1;\n    param_1 \u003d param_1 \u0026 0xff;\n  }\n  if ((-1 \u003c (int)(puVar2[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(puVar2 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_release_recursive(puVar2[0x16]);\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002a00"
      ],
      "called": [
        "FUN_000045e8",
        "FUN_00005404",
        "FUN_000045ec",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004db8": {
      "entrypoint": "0x00004db8",
      "current_name": "FUN_00004db8",
      "code": "\nundefined4 FUN_00004db8(int param_1)\n\n{\n  char cVar1;\n  dword dVar2;\n  int iVar3;\n  char *pcVar4;\n  char **ppcVar5;\n  undefined4 uVar6;\n  char *pcVar7;\n  \n  dVar2 \u003d Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset !\u003d 0) \u0026\u0026\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  ppcVar5 \u003d *(char ***)(dVar2 + 8);\n  if (*(int *)(dVar2 + 0x18) \u003d\u003d 0) {\n    __sinit(dVar2);\n  }\n  if (ppcVar5 \u003d\u003d (char **)\u0026DAT_000079b8) {\n    ppcVar5 \u003d *(char ***)(dVar2 + 4);\n  }\n  else if (ppcVar5 \u003d\u003d (char **)\u0026DAT_000079d8) {\n    ppcVar5 \u003d *(char ***)(dVar2 + 8);\n  }\n  else if (ppcVar5 \u003d\u003d (char **)\u0026DAT_00007998) {\n    ppcVar5 \u003d *(char ***)(dVar2 + 0xc);\n  }\n  if ((-1 \u003c (int)ppcVar5[0x19] \u003c\u003c 0x1f) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(ppcVar5 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_acquire_recursive(ppcVar5[0x16]);\n  }\n  if ((((int)((uint)*(ushort *)(ppcVar5 + 3) \u003c\u003c 0x1c) \u003c 0) \u0026\u0026 (ppcVar5[4] !\u003d (char *)0x0)) ||\n     (iVar3 \u003d __swsetup_r(dVar2,ppcVar5), iVar3 \u003d\u003d 0)) {\n    pcVar7 \u003d (char *)(param_1 + -1);\n    do {\n      while( true ) {\n        pcVar7 \u003d pcVar7 + 1;\n        cVar1 \u003d *pcVar7;\n        pcVar4 \u003d ppcVar5[2] + -1;\n        ppcVar5[2] \u003d pcVar4;\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          if (-1 \u003c (int)pcVar4) {\n            pcVar7 \u003d *ppcVar5;\n            uVar6 \u003d 10;\n            *ppcVar5 \u003d pcVar7 + 1;\n            *pcVar7 \u003d \u0027\\n\u0027;\n            goto LAB_00004d64;\n          }\n          iVar3 \u003d __swbuf_r(dVar2,10,ppcVar5);\n          if (iVar3 !\u003d -1) {\n            uVar6 \u003d 10;\n            goto LAB_00004d64;\n          }\n          goto LAB_00004d60;\n        }\n        if (((int)pcVar4 \u003c 0) \u0026\u0026 (((int)pcVar4 \u003c (int)ppcVar5[6] || (cVar1 \u003d\u003d \u0027\\n\u0027)))) break;\n        pcVar4 \u003d *ppcVar5;\n        *ppcVar5 \u003d pcVar4 + 1;\n        *pcVar4 \u003d cVar1;\n      }\n      iVar3 \u003d __swbuf_r(dVar2,cVar1,ppcVar5);\n    } while (iVar3 !\u003d -1);\n  }\nLAB_00004d60:\n  uVar6 \u003d 0xffffffff;\nLAB_00004d64:\n  if ((-1 \u003c (int)ppcVar5[0x19] \u003c\u003c 0x1f) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(ppcVar5 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_release_recursive(ppcVar5[0x16]);\n  }\n  return uVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002b10",
        "FUN_000023a4",
        "FUN_00003694",
        "FUN_00003478",
        "FUN_000034c0",
        "FUN_0000305c",
        "FUN_00002f74",
        "FUN_000033f4",
        "FUN_00002fe0",
        "FUN_00003444",
        "FUN_000033c0",
        "FUN_00002f30",
        "FUN_000031e0",
        "FUN_00002a88"
      ],
      "called": [
        "FUN_000045e8",
        "FUN_00005404",
        "FUN_000045ec",
        "FUN_000054a8",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004dc8": {
      "entrypoint": "0x00004dc8",
      "current_name": "FUN_00004dc8",
      "code": "\nvoid FUN_00004dc8(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  iVar1 \u003d _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 \u003d -1 \u003c iVar1;\n  if (bVar3) {\n    uVar2 \u003d *(int *)(param_2 + 0x54) + iVar1;\n  }\n  else {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xffffefff;\n  }\n  if (bVar3) {\n    *(uint *)(param_2 + 0x54) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(short *)(param_2 + 0xc) \u003d (short)uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00000490"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004dee": {
      "entrypoint": "0x00004dee",
      "current_name": "FUN_00004dee",
      "code": "\nundefined4 FUN_00004dee(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uVar1;\n  \n  if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x17) \u003c 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n  }\n  *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  uVar1 \u003d uart_stdio_write(param_3,param_4);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_000004f2",
        "FUN_00000e38"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004e26": {
      "entrypoint": "0x00004e26",
      "current_name": "FUN_00004e26",
      "code": "\nvoid FUN_00004e26(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  bool bVar3;\n  \n  iVar1 \u003d _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  bVar3 \u003d iVar1 \u003d\u003d -1;\n  if (bVar3) {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  }\n  else {\n    *(int *)(param_2 + 0x54) \u003d iVar1;\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  if (!bVar3) {\n    *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_000004f2"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004e52": {
      "entrypoint": "0x00004e52",
      "current_name": "FUN_00004e52",
      "code": "\nint FUN_00004e52(byte *param_1,byte *param_2)\n\n{\n  byte bVar1;\n  uint uVar2;\n  bool bVar3;\n  \n  do {\n    uVar2 \u003d (uint)*param_1;\n    bVar1 \u003d *param_2;\n    bVar3 \u003d uVar2 \u003d\u003d 1;\n    if (uVar2 !\u003d 0) {\n      bVar3 \u003d uVar2 \u003d\u003d bVar1;\n    }\n    param_1 \u003d param_1 + 1;\n    param_2 \u003d param_2 + 1;\n  } while (bVar3);\n  return uVar2 - bVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00002b10",
        "FUN_0000316c",
        "FUN_00005100",
        "FUN_00002fe0",
        "FUN_00002a18",
        "FUN_00004e52"
      ],
      "called": [
        "FUN_00004e52"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004e66": {
      "entrypoint": "0x00004e66",
      "current_name": "FUN_00004e66",
      "code": "\nint FUN_00004e66(byte *param_1,int param_2,int param_3)\n\n{\n  byte *pbVar1;\n  int iVar2;\n  byte *pbVar3;\n  uint uVar4;\n  \n  if (param_3 \u003d\u003d 0) {\n    iVar2 \u003d 0;\n  }\n  else {\n    pbVar3 \u003d (byte *)(param_2 + -1);\n    pbVar1 \u003d param_1;\n    do {\n      uVar4 \u003d (uint)*pbVar1;\n      pbVar3 \u003d pbVar3 + 1;\n      if ((uVar4 !\u003d *pbVar3) || (pbVar1 + 1 \u003d\u003d param_1 + param_3)) break;\n      pbVar1 \u003d pbVar1 + 1;\n    } while (uVar4 !\u003d 0);\n    iVar2 \u003d uVar4 - *pbVar3;\n  }\n  return iVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000562c",
        "FUN_00003524"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004f84": {
      "entrypoint": "0x00004f84",
      "current_name": "FUN_00004f84",
      "code": "\nuint FUN_00004f84(byte *param_1,byte **param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  byte *pbVar8;\n  byte *pbVar9;\n  \n  pbVar9 \u003d param_1;\n  do {\n    pbVar8 \u003d pbVar9;\n    pbVar9 \u003d pbVar8 + 1;\n    uVar2 \u003d (uint)*pbVar8;\n    uVar3 \u003d (byte)(\u0026DAT_00007a99)[uVar2] \u0026 8;\n  } while (((\u0026DAT_00007a99)[uVar2] \u0026 8) !\u003d 0);\n  if (uVar2 \u003d\u003d 0x2d) {\n    uVar2 \u003d (uint)*pbVar9;\n    uVar3 \u003d 1;\n    pbVar9 \u003d pbVar8 + 2;\n  }\n  else if (uVar2 \u003d\u003d 0x2b) {\n    uVar2 \u003d (uint)*pbVar9;\n    pbVar9 \u003d pbVar8 + 2;\n  }\n  if (param_3 \u003d\u003d 0) {\n    if (uVar2 !\u003d 0x30) {\n      param_3 \u003d 10;\n      goto LAB_00004ed6;\n    }\n  }\n  else if ((param_3 !\u003d 0x10) || (uVar2 !\u003d 0x30)) goto LAB_00004ed6;\n  if ((*pbVar9 \u0026 0xdf) \u003d\u003d 0x58) {\n    uVar2 \u003d (uint)pbVar9[1];\n    param_3 \u003d 0x10;\n    pbVar9 \u003d pbVar9 + 2;\n  }\n  else {\n    uVar2 \u003d 0x30;\n    if (param_3 \u003d\u003d 0) {\n      param_3 \u003d 8;\n    }\n  }\nLAB_00004ed6:\n  uVar6 \u003d uVar3 + 0x7fffffff;\n  iVar5 \u003d 0;\n  uVar7 \u003d uVar6 / param_3;\n  uVar1 \u003d 0;\n  do {\n    uVar4 \u003d uVar2 - 0x30;\n    if (9 \u003c uVar4) {\n      if (uVar2 - 0x41 \u003c 0x1a) {\n        uVar4 \u003d uVar2 - 0x37;\n      }\n      else {\n        if (0x19 \u003c uVar2 - 0x61) break;\n        uVar4 \u003d uVar2 - 0x57;\n      }\n    }\n    if ((int)param_3 \u003c\u003d (int)uVar4) break;\n    if (iVar5 !\u003d -1) {\n      if ((uVar7 \u003c uVar1) || ((uVar7 \u003d\u003d uVar1 \u0026\u0026 ((int)(uVar6 - param_3 * uVar7) \u003c (int)uVar4)))) {\n        iVar5 \u003d -1;\n      }\n      else {\n        uVar1 \u003d uVar1 * param_3 + uVar4;\n        iVar5 \u003d 1;\n      }\n    }\n    uVar2 \u003d (uint)*pbVar9;\n    pbVar9 \u003d pbVar9 + 1;\n  } while( true );\n  if (iVar5 \u003d\u003d -1) {\n    *(undefined4 *)Elf32_Rel_ARRAY_1fff0200[16].r_offset \u003d 0x22;\n    uVar1 \u003d uVar6;\n    if (param_2 \u003d\u003d (byte **)0x0) {\n      return uVar6;\n    }\n  }\n  else {\n    if (uVar3 !\u003d 0) {\n      uVar1 \u003d -uVar1;\n    }\n    if (param_2 \u003d\u003d (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar5 \u003d\u003d 0) goto LAB_00004f64;\n  }\n  param_1 \u003d pbVar9 + -1;\nLAB_00004f64:\n  *param_2 \u003d param_1;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000328c",
        "FUN_00004042"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00004f98": {
      "entrypoint": "0x00004f98",
      "current_name": "FUN_00004f98",
      "code": "\nundefined4 FUN_00004f98(uint param_1)\n\n{\n  uint *puVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  int iVar4;\n  uint *puVar5;\n  int iVar6;\n  uint uVar7;\n  int iVar8;\n  int iVar9;\n  uint uVar10;\n  \n  puVar1 \u003d (uint *)__gettzinfo();\n  if ((int)param_1 \u003c 0x7b2) {\n    uVar2 \u003d 0;\n  }\n  else {\n    iVar6 \u003d (param_1 - 0x7b2) * 0x16d + ((int)(param_1 - 0x7b1) \u003e\u003e 2) +\n            (param_1 - 0x76d) / 0xffffff9c + (param_1 - 0x641) / 400;\n    puVar1[1] \u003d param_1;\n    uVar10 \u003d (uint)(param_1 % 400 \u003d\u003d 0);\n    puVar5 \u003d puVar1;\n    do {\n      uVar3 \u003d puVar5[5];\n      if (*(char *)(puVar5 + 2) \u003d\u003d \u0027J\u0027) {\n        if ((((param_1 \u0026 3) \u003d\u003d 0) \u0026\u0026 (param_1 % 100 !\u003d 0)) || (param_1 % 400 \u003d\u003d 0)) {\n          if ((int)uVar3 \u003c 0x3c) {\n            iVar4 \u003d 0;\n          }\n          else {\n            iVar4 \u003d 1;\n          }\n        }\n        else {\n          iVar4 \u003d 0;\n        }\n        iVar4 \u003d iVar4 + iVar6 + uVar3 + -1;\n      }\n      else if (*(char *)(puVar5 + 2) \u003d\u003d \u0027D\u0027) {\n        iVar4 \u003d iVar6 + uVar3;\n      }\n      else {\n        uVar7 \u003d uVar10;\n        if (((param_1 \u0026 3) \u003d\u003d 0) \u0026\u0026 (param_1 % 100 !\u003d 0)) {\n          uVar7 \u003d 1;\n        }\n        iVar8 \u003d 0;\n        iVar4 \u003d iVar6;\n        while( true ) {\n          iVar8 \u003d iVar8 + 1;\n          if ((int)puVar5[3] \u003c\u003d iVar8) break;\n          iVar4 \u003d iVar4 + *(int *)(\u0026UNK_00007b98 + iVar8 * 4 + uVar7 * 0x30);\n        }\n        iVar9 \u003d uVar3 - (iVar4 + 4U) % 7;\n        if (iVar9 \u003c 0) {\n          iVar9 \u003d iVar9 + 7;\n        }\n        for (iVar9 \u003d (puVar5[4] - 1) * 7 + iVar9;\n            *(int *)(\u0026UNK_00007b98 + iVar8 * 4 + uVar7 * 0x30) \u003c\u003d iVar9; iVar9 \u003d iVar9 + -7) {\n        }\n        iVar4 \u003d iVar4 + iVar9;\n      }\n      uVar3 \u003d puVar5[10] + iVar4 * 0x15180 + puVar5[6];\n      puVar5[8] \u003d uVar3;\n      puVar5[9] \u003d (int)uVar3 \u003e\u003e 0x1f;\n      puVar5 \u003d puVar5 + 10;\n    } while (puVar1 + 0x14 !\u003d puVar5);\n    uVar3 \u003d puVar1[9];\n    uVar10 \u003d puVar1[0x13];\n    *puVar1 \u003d (uint)((int)((uVar3 - uVar10) - (uint)(puVar1[8] \u003c puVar1[0x12])) \u003c 0 !\u003d\n                    (SBORROW4(uVar3,uVar10) !\u003d\n                    SBORROW4(uVar3 - uVar10,(uint)(puVar1[8] \u003c puVar1[0x12]))));\n    uVar2 \u003d 1;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100",
        "FUN_000047e4"
      ],
      "called": [
        "FUN_000056b0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000050e8": {
      "entrypoint": "0x000050e8",
      "current_name": "FUN_000050e8",
      "code": "\nundefined * FUN_000050e8(void)\n\n{\n  return \u0026DAT_1fff0deb;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000047e4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000050f4": {
      "entrypoint": "0x000050f4",
      "current_name": "FUN_000050f4",
      "code": "\nundefined * FUN_000050f4(void)\n\n{\n  return \u0026DAT_1fff0deb;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000047e4"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005100": {
      "entrypoint": "0x00005100",
      "current_name": "FUN_00005100",
      "code": "\nvoid FUN_00005100(void)\n\n{\n  dword dVar1;\n  int iVar2;\n  char *pcVar3;\n  int iVar4;\n  int iVar5;\n  undefined uVar6;\n  char *pcVar7;\n  bool bVar8;\n  ushort *puVar9;\n  int *piVar10;\n  ushort *puVar11;\n  int *piVar12;\n  ushort local_3c;\n  ushort local_3a;\n  ushort local_38;\n  ushort local_36;\n  ushort local_34;\n  ushort local_32;\n  int local_30;\n  char *local_2c [2];\n  \n  dVar1 \u003d Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  iVar2 \u003d __gettzinfo();\n  pcVar3 \u003d (char *)_getenv_r(dVar1,\u0026DAT_00007a5c);\n  if (pcVar3 \u003d\u003d (char *)0x0) {\n    Elf32_Rel_ARRAY_1fff0200[28].r_info \u003d (dword)\u0026DAT_00007a5f;\n    Elf32_Rel_ARRAY_1fff0200[29].r_offset \u003d (dword)\u0026DAT_00007a5f;\n    DAT_1fff0dd8 \u003d pcVar3;\n    DAT_1fff0ddc \u003d pcVar3;\n    free(DAT_1fff0dd4);\n    DAT_1fff0dd4 \u003d 0;\n  }\n  else if ((DAT_1fff0dd4 \u003d\u003d 0) || (iVar4 \u003d strcmp(), iVar4 !\u003d 0)) {\n    free(DAT_1fff0dd4);\n    iVar4 \u003d strlen(pcVar3);\n    DAT_1fff0dd4 \u003d _malloc_r(dVar1,iVar4 + 1);\n    if (DAT_1fff0dd4 !\u003d 0) {\n      strcpy(DAT_1fff0dd4,pcVar3);\n    }\n    if (*pcVar3 \u003d\u003d \u0027:\u0027) {\n      pcVar3 \u003d pcVar3 + 1;\n    }\n    iVar4 \u003d siscanf(pcVar3,\"%10[^0-9,+-]%n\",\u0026DAT_1fff0dc7,\u0026local_30);\n    if (0 \u003c iVar4) {\n      pcVar7 \u003d pcVar3 + local_30;\n      if (pcVar3[local_30] \u003d\u003d \u0027-\u0027) {\n        pcVar7 \u003d pcVar7 + 1;\n        iVar4 \u003d -1;\n      }\n      else {\n        if (pcVar3[local_30] \u003d\u003d \u0027+\u0027) {\n          pcVar7 \u003d pcVar7 + 1;\n        }\n        iVar4 \u003d 1;\n      }\n      local_3a \u003d 0;\n      local_38 \u003d 0;\n      puVar9 \u003d \u0026local_3a;\n      piVar10 \u003d \u0026local_30;\n      puVar11 \u003d \u0026local_38;\n      piVar12 \u003d \u0026local_30;\n      iVar5 \u003d siscanf(pcVar7,\"%hu%n:%hu%n:%hu%n\",\u0026local_3c,\u0026local_30,\u0026local_3a,\u0026local_30,\u0026local_38,\n                      \u0026local_30);\n      if (0 \u003c iVar5) {\n        *(uint *)(iVar2 + 0x28) \u003d\n             ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar4;\n        Elf32_Rel_ARRAY_1fff0200[28].r_info \u003d (dword)\u0026DAT_1fff0dc7;\n        pcVar7 \u003d pcVar7 + local_30;\n        iVar4 \u003d siscanf(pcVar7,\"%10[^0-9,+-]%n\",\u0026DAT_1fff0dbc,\u0026local_30,puVar9,piVar10,puVar11,\n                        piVar12);\n        if (iVar4 \u003c 1) {\n          Elf32_Rel_ARRAY_1fff0200[29].r_offset \u003d Elf32_Rel_ARRAY_1fff0200[28].r_info;\n          DAT_1fff0ddc \u003d *(char **)(iVar2 + 0x28);\n          DAT_1fff0dd8 \u003d (char *)0x0;\n        }\n        else {\n          Elf32_Rel_ARRAY_1fff0200[29].r_offset \u003d (dword)\u0026DAT_1fff0dbc;\n          pcVar3 \u003d pcVar7 + local_30;\n          if (pcVar7[local_30] \u003d\u003d \u0027-\u0027) {\n            pcVar3 \u003d pcVar3 + 1;\n            iVar4 \u003d -1;\n          }\n          else {\n            if (pcVar7[local_30] \u003d\u003d \u0027+\u0027) {\n              pcVar3 \u003d pcVar3 + 1;\n            }\n            iVar4 \u003d 1;\n          }\n          local_3c \u003d 0;\n          local_3a \u003d 0;\n          local_38 \u003d 0;\n          local_30 \u003d 0;\n          iVar5 \u003d siscanf(pcVar3,\"%hu%n:%hu%n:%hu%n\",\u0026local_3c,\u0026local_30,\u0026local_3a,\u0026local_30,\n                          \u0026local_38,\u0026local_30);\n          if (iVar5 \u003c 1) {\n            iVar4 \u003d *(int *)(iVar2 + 0x28) + -0xe10;\n          }\n          else {\n            iVar4 \u003d ((uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38) * iVar4;\n          }\n          *(int *)(iVar2 + 0x50) \u003d iVar4;\n          pcVar3 \u003d pcVar3 + local_30;\n          bVar8 \u003d false;\n          iVar4 \u003d iVar2;\n          while( true ) {\n            if (*pcVar3 \u003d\u003d \u0027,\u0027) {\n              pcVar3 \u003d pcVar3 + 1;\n            }\n            if (*pcVar3 \u003d\u003d \u0027M\u0027) {\n              iVar5 \u003d siscanf(pcVar3,\"M%hu%n.%hu%n.%hu%n\",\u0026local_36,\u0026local_30,\u0026local_34,\u0026local_30,\n                              \u0026local_32,\u0026local_30);\n              if (iVar5 !\u003d 3) {\n                return;\n              }\n              if (0xb \u003c local_36 - 1) {\n                return;\n              }\n              if (4 \u003c local_34 - 1) {\n                return;\n              }\n              if (6 \u003c local_32) {\n                return;\n              }\n              *(uint *)(iVar4 + 0xc) \u003d (uint)local_36;\n              *(uint *)(iVar4 + 0x10) \u003d (uint)local_34;\n              *(undefined *)(iVar4 + 8) \u003d 0x4d;\n              *(uint *)(iVar4 + 0x14) \u003d (uint)local_32;\n              pcVar7 \u003d pcVar3 + local_30;\n            }\n            else {\n              if (*pcVar3 \u003d\u003d \u0027J\u0027) {\n                pcVar3 \u003d pcVar3 + 1;\n                uVar6 \u003d 0x4a;\n              }\n              else {\n                uVar6 \u003d 0x44;\n              }\n              local_32 \u003d strtoul(pcVar3,local_2c,10);\n              pcVar7 \u003d local_2c[0];\n              if (local_2c[0] \u003d\u003d pcVar3) {\n                if (bVar8) {\n                  *(undefined *)(iVar2 + 0x30) \u003d 0x4d;\n                  *(undefined4 *)(iVar2 + 0x34) \u003d 0xb;\n                  *(undefined4 *)(iVar2 + 0x38) \u003d 1;\n                  *(undefined4 *)(iVar2 + 0x3c) \u003d 0;\n                }\n                else {\n                  *(undefined *)(iVar2 + 8) \u003d 0x4d;\n                  *(undefined4 *)(iVar2 + 0xc) \u003d 3;\n                  *(undefined4 *)(iVar2 + 0x10) \u003d 2;\n                  *(undefined4 *)(iVar2 + 0x14) \u003d 0;\n                }\n              }\n              else {\n                *(undefined *)(iVar4 + 8) \u003d uVar6;\n                *(uint *)(iVar4 + 0x14) \u003d (uint)local_32;\n              }\n            }\n            local_3c \u003d 2;\n            local_3a \u003d 0;\n            local_38 \u003d 0;\n            local_30 \u003d 0;\n            if (*pcVar7 \u003d\u003d \u0027/\u0027) {\n              siscanf(pcVar7,\u0026DAT_00007a85,\u0026local_3c,\u0026local_30,\u0026local_3a,\u0026local_30,\u0026local_38,\n                      \u0026local_30);\n            }\n            *(uint *)(iVar4 + 0x18) \u003d\n                 (uint)local_3c * 0xe10 + (uint)local_3a * 0x3c + (uint)local_38;\n            iVar4 \u003d iVar4 + 0x28;\n            pcVar3 \u003d pcVar7 + local_30;\n            if (bVar8) break;\n            bVar8 \u003d true;\n          }\n          __tzcalc_limits(*(undefined4 *)(iVar2 + 4));\n          DAT_1fff0ddc \u003d *(char **)(iVar2 + 0x28);\n          DAT_1fff0dd8 \u003d (char *)(*(int *)(iVar2 + 0x50) - (int)DAT_1fff0ddc);\n          if (DAT_1fff0dd8 !\u003d (char *)0x0) {\n            DAT_1fff0dd8 \u003d (char *)0x1;\n          }\n        }\n      }\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000047e4"
      ],
      "called": [
        "FUN_000056a0",
        "FUN_00005ecc",
        "FUN_00005ebc",
        "FUN_00005e68",
        "FUN_000056b0",
        "FUN_00005780",
        "FUN_00004bd0",
        "FUN_00005fd8",
        "FUN_00004e52",
        "FUN_00004f98"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005404": {
      "entrypoint": "0x00005404",
      "current_name": "FUN_00005404",
      "code": "\nuint FUN_00005404(int param_1,uint param_2,int *param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined *puVar3;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_3 \u003d\u003d \u0026DAT_000079b8) {\n    param_3 \u003d *(int **)(param_1 + 4);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026DAT_000079d8) {\n    param_3 \u003d *(int **)(param_1 + 8);\n  }\n  else if (param_3 \u003d\u003d (int *)\u0026DAT_00007998) {\n    param_3 \u003d *(int **)(param_1 + 0xc);\n  }\n  param_3[2] \u003d param_3[6];\n  uVar2 \u003d (uint)*(ushort *)(param_3 + 3);\n  iVar1 \u003d uVar2 \u003c\u003c 0x1c;\n  if (((iVar1 \u003c 0) \u0026\u0026 (uVar2 \u003d param_3[4], uVar2 !\u003d 0)) ||\n     (iVar1 \u003d __swsetup_r(param_1,param_3,iVar1,uVar2,param_4), iVar1 \u003d\u003d 0)) {\n    iVar1 \u003d *param_3 - param_3[4];\n    param_2 \u003d param_2 \u0026 0xff;\n    if ((iVar1 \u003c param_3[5]) || (iVar1 \u003d _fflush_r(param_1,param_3), iVar1 \u003d\u003d 0)) {\n      param_3[2] \u003d param_3[2] + -1;\n      puVar3 \u003d (undefined *)*param_3;\n      *param_3 \u003d (int)(puVar3 + 1);\n      *puVar3 \u003d (char)param_2;\n      if (param_3[5] !\u003d iVar1 + 1) {\n        if (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x1f)) {\n          return param_2;\n        }\n        if (param_2 !\u003d 10) {\n          return param_2;\n        }\n      }\n      iVar1 \u003d _fflush_r(param_1,param_3);\n      if (iVar1 \u003d\u003d 0) {\n        return param_2;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004db8",
        "FUN_00004cb4",
        "FUN_000057a8"
      ],
      "called": [
        "FUN_00004158",
        "FUN_000054a8",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000054a8": {
      "entrypoint": "0x000054a8",
      "current_name": "FUN_000054a8",
      "code": "\nuint FUN_000054a8(undefined4 *param_1,undefined4 *param_2)\n\n{\n  ushort uVar1;\n  dword dVar2;\n  ushort uVar3;\n  uint uVar4;\n  uint uVar5;\n  \n  dVar2 \u003d Elf32_Rel_ARRAY_1fff0200[16].r_offset;\n  if ((Elf32_Rel_ARRAY_1fff0200[16].r_offset !\u003d 0) \u0026\u0026\n     (*(int *)(Elf32_Rel_ARRAY_1fff0200[16].r_offset + 0x18) \u003d\u003d 0)) {\n    __sinit(Elf32_Rel_ARRAY_1fff0200[16].r_offset);\n  }\n  if (param_2 \u003d\u003d \u0026DAT_000079b8) {\n    param_2 \u003d *(undefined4 **)(dVar2 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026DAT_000079d8) {\n    param_2 \u003d *(undefined4 **)(dVar2 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026DAT_00007998) {\n    param_2 \u003d *(undefined4 **)(dVar2 + 0xc);\n  }\n  uVar4 \u003d (uint)*(ushort *)(param_2 + 3);\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  if (-1 \u003c (int)(uVar4 \u003c\u003c 0x1c)) {\n    if (-1 \u003c (int)(uVar4 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      goto LAB_000054d8;\n    }\n    if ((int)(uVar4 \u003c\u003c 0x1d) \u003c 0) {\n      if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n        if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n          _free_r(param_1);\n        }\n        param_2[0xd] \u003d 0;\n      }\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xffdb;\n      param_2[1] \u003d 0;\n      *param_2 \u003d param_2[4];\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 8;\n  }\n  if ((param_2[4] \u003d\u003d 0) \u0026\u0026 ((*(ushort *)(param_2 + 3) \u0026 0x280) !\u003d 0x200)) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar1 \u003d *(ushort *)(param_2 + 3);\n  uVar4 \u003d (uint)uVar1;\n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  uVar5 \u003d uVar4 \u0026 1;\n  if ((uVar1 \u0026 1) \u003d\u003d 0) {\n    if (-1 \u003c (int)(uVar4 \u003c\u003c 0x1e)) {\n      uVar5 \u003d param_2[5];\n    }\n    param_2[2] \u003d uVar5;\n  }\n  else {\n    param_2[2] \u003d 0;\n    param_2[6] \u003d -param_2[5];\n  }\n  if (param_2[4] !\u003d 0) {\n    return 0;\n  }\n  if ((uVar1 \u0026 0x80) \u003d\u003d 0) {\n    return uVar4 \u0026 0x80;\n  }\nLAB_000054d8:\n  *(ushort *)(param_2 + 3) \u003d uVar3 | 0x40;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005404",
        "FUN_000057f8",
        "FUN_00004db8"
      ],
      "called": [
        "FUN_00005700",
        "FUN_00004b34",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005584": {
      "entrypoint": "0x00005584",
      "current_name": "FUN_00005584",
      "code": "\nvoid FUN_00005584(uint *param_1,uint param_2,uint param_3)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  uVar2 \u003d param_2 / param_3;\n  uVar1 \u003d param_2 - param_3 * uVar2;\n  if ((int)param_2 \u003c 0) {\n    if (0 \u003c (int)uVar1) {\n      uVar2 \u003d uVar2 - 1;\n      uVar1 \u003d uVar1 + param_3;\n    }\n  }\n  else if ((int)uVar1 \u003c 0) {\n    uVar2 \u003d uVar2 + 1;\n    uVar1 \u003d uVar1 - param_3;\n  }\n  *param_1 \u003d uVar2;\n  param_1[1] \u003d uVar1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004634"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000562c": {
      "entrypoint": "0x0000562c",
      "current_name": "FUN_0000562c",
      "code": "\nint FUN_0000562c(undefined4 param_1,char *param_2,int *param_3)\n\n{\n  char cVar1;\n  int *piVar2;\n  int iVar3;\n  char *pcVar4;\n  int *piVar5;\n  int iVar6;\n  \n  __env_lock();\n  pcVar4 \u003d param_2;\n  if (Elf32_Rel_ARRAY_1fff0200[41].r_offset !\u003d 0) {\n    do {\n      cVar1 \u003d *pcVar4;\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        iVar6 \u003d (int)pcVar4 - (int)param_2;\n        piVar2 \u003d (int *)Elf32_Rel_ARRAY_1fff0200[41].r_offset;\n        while( true ) {\n          piVar5 \u003d piVar2;\n          if (*piVar5 \u003d\u003d 0) break;\n          iVar3 \u003d strncmp(*piVar5,param_2,iVar6);\n          piVar2 \u003d piVar5 + 1;\n          if ((iVar3 \u003d\u003d 0) \u0026\u0026 (iVar3 \u003d *piVar5, *(char *)(iVar3 + iVar6) \u003d\u003d \u0027\u003d\u0027)) {\n            *param_3 \u003d (int)((int)piVar5 - Elf32_Rel_ARRAY_1fff0200[41].r_offset) \u003e\u003e 2;\n            __env_unlock(param_1);\n            return iVar3 + iVar6 + 1;\n          }\n        }\n        break;\n      }\n      pcVar4 \u003d pcVar4 + 1;\n    } while (cVar1 !\u003d \u0027\u003d\u0027);\n  }\n  __env_unlock(param_1);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000056a0"
      ],
      "called": [
        "FUN_00005ff8",
        "FUN_00005fec",
        "FUN_00004e66"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000056a0": {
      "entrypoint": "0x000056a0",
      "current_name": "FUN_000056a0",
      "code": "\nvoid FUN_000056a0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  \n  uStack_c \u003d param_2;\n  uStack_8 \u003d param_3;\n  _findenv_r(param_1,param_2,\u0026uStack_c,param_4,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100"
      ],
      "called": [
        "FUN_0000562c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000056b0": {
      "entrypoint": "0x000056b0",
      "current_name": "FUN_000056b0",
      "code": "\nundefined4 FUN_000056b0(void)\n\n{\n  return 0x1fff02f0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100",
        "FUN_000047e4",
        "FUN_00004f98"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000056b8": {
      "entrypoint": "0x000056b8",
      "current_name": "FUN_000056b8",
      "code": "\nundefined4 FUN_000056b8(undefined4 param_1,int param_2,undefined4 *param_3,uint *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  undefined auStack_68 [4];\n  uint local_64;\n  \n  if ((*(short *)(param_2 + 0xe) \u003c 0) ||\n     (iVar1 \u003d _fstat_r(param_1,(int)*(short *)(param_2 + 0xe),auStack_68), iVar1 \u003c 0)) {\n    *param_4 \u003d 0;\n    if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x18) \u003c 0) {\n      uVar2 \u003d 0x40;\n      goto LAB_000056f8;\n    }\n  }\n  else {\n    *param_4 \u003d (uint)((local_64 \u0026 0xf000) \u003d\u003d 0x2000);\n  }\n  uVar2 \u003d 0x400;\nLAB_000056f8:\n  *param_3 \u003d uVar2;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005700"
      ],
      "called": [
        "FUN_00000514"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005700": {
      "entrypoint": "0x00005700",
      "current_name": "FUN_00005700",
      "code": "\nvoid FUN_00005700(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int local_18;\n  int *local_14;\n  \n  if (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1e)) {\n    local_18 \u003d param_1;\n    local_14 \u003d param_2;\n    uVar1 \u003d __swhatbuf_r(param_1,param_2,\u0026local_18,\u0026local_14);\n    iVar2 \u003d _malloc_r(param_1,local_18);\n    if (iVar2 !\u003d 0) {\n      *(undefined **)(param_1 + 0x28) \u003d \u0026DAT_0000423d;\n      *param_2 \u003d iVar2;\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x80;\n      param_2[5] \u003d local_18;\n      param_2[4] \u003d iVar2;\n      if ((local_14 !\u003d (int *)0x0) \u0026\u0026\n         (iVar2 \u003d _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 !\u003d 0)) {\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 1;\n      }\n      *(ushort *)(param_2 + 3) \u003d uVar1 | *(ushort *)(param_2 + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(param_2 + 3) \u003c\u003c 0x16 \u003c 0) {\n      return;\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfffc | 2;\n  }\n  *param_2 \u003d (int)param_2 + 0x47;\n  param_2[4] \u003d (int)param_2 + 0x47;\n  param_2[5] \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00006768",
        "FUN_000054a8"
      ],
      "called": [
        "FUN_00004bd0",
        "FUN_00000534",
        "FUN_000056b8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005780": {
      "entrypoint": "0x00005780",
      "current_name": "FUN_00005780",
      "code": "\nvoid FUN_00005780(undefined4 param_1)\n\n{\n  _free_r(Elf32_Rel_ARRAY_1fff0200[16].r_offset,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100"
      ],
      "called": [
        "FUN_00004b34"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005790": {
      "entrypoint": "0x00005790",
      "current_name": "FUN_00005790",
      "code": "\nvoid FUN_00005790(void)\n\n{\n  __retarget_lock_acquire_recursive(\u0026DAT_1fff0de8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004bd0",
        "FUN_00004b34"
      ],
      "called": [
        "FUN_000045e8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000579c": {
      "entrypoint": "0x0000579c",
      "current_name": "FUN_0000579c",
      "code": "\nvoid FUN_0000579c(void)\n\n{\n  __retarget_lock_release_recursive(\u0026DAT_1fff0de8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004bd0",
        "FUN_00004b34"
      ],
      "called": [
        "FUN_000045ec"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000057a8": {
      "entrypoint": "0x000057a8",
      "current_name": "FUN_000057a8",
      "code": "\nint FUN_000057a8(undefined4 param_1,int param_2,undefined4 *param_3)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  \n  iVar1 \u003d param_3[2] + -1;\n  param_3[2] \u003d iVar1;\n  if ((iVar1 \u003c 0) \u0026\u0026 ((iVar1 \u003c (int)param_3[6] || (param_2 \u003d\u003d 10)))) {\n    iVar1 \u003d __swbuf_r();\n    return iVar1;\n  }\n  puVar2 \u003d (undefined *)*param_3;\n  *param_3 \u003d puVar2 + 1;\n  *puVar2 \u003d (char)param_2;\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000057d2"
      ],
      "called": [
        "FUN_00005404"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000057d2": {
      "entrypoint": "0x000057d2",
      "current_name": "FUN_000057d2",
      "code": "\nint FUN_000057d2(undefined4 param_1,undefined4 param_2,undefined *param_3,int param_4)\n\n{\n  int iVar1;\n  undefined *puVar2;\n  int iVar3;\n  \n  puVar2 \u003d param_3 + param_4;\n  iVar3 \u003d param_4;\n  do {\n    if (param_3 \u003d\u003d puVar2) {\n      return 0;\n    }\n    iVar1 \u003d __sfputc_r(param_1,*param_3,param_2,param_4,iVar3);\n    param_4 \u003d iVar1 + 1;\n    param_3 \u003d param_3 + 1;\n  } while (param_4 !\u003d 0);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000057f8"
      ],
      "called": [
        "FUN_000057a8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000057f8": {
      "entrypoint": "0x000057f8",
      "current_name": "FUN_000057f8",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x000059f0) */\n\nint FUN_000057f8(int param_1,undefined4 *param_2,byte *param_3,int *param_4)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  bool bVar4;\n  byte *pbVar5;\n  int unaff_r7;\n  byte *pbVar6;\n  int *local_8c;\n  uint local_88;\n  int local_84;\n  undefined4 uStack_80;\n  int local_7c;\n  int local_74;\n  byte local_70;\n  undefined local_6f;\n  undefined local_6e;\n  undefined local_45;\n  undefined4 local_30;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d \u0026DAT_000079b8) {\n    param_2 \u003d *(undefined4 **)(param_1 + 4);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026DAT_000079d8) {\n    param_2 \u003d *(undefined4 **)(param_1 + 8);\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026DAT_00007998) {\n    param_2 \u003d *(undefined4 **)(param_1 + 0xc);\n  }\n  if ((-1 \u003c (int)(param_2[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16))) {\n    __retarget_lock_acquire_recursive(param_2[0x16]);\n  }\n  if (((-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x1c)) || (param_2[4] \u003d\u003d 0)) \u0026\u0026\n     (iVar1 \u003d __swsetup_r(param_1,param_2), iVar1 !\u003d 0)) {\n    if ((-1 \u003c (int)(param_2[0x19] \u003c\u003c 0x1f)) \u0026\u0026 (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16)))\n    {\n      __retarget_lock_release_recursive(param_2[0x16]);\n    }\n    return -1;\n  }\n  local_74 \u003d 0;\n  local_6f \u003d 0x20;\n  local_6e \u003d 0x30;\n  pbVar6 \u003d param_3;\n  local_8c \u003d param_4;\nLAB_0000588e:\n  pbVar5 \u003d pbVar6;\n  if (*pbVar5 !\u003d 0) goto code_r0x00005896;\n  goto LAB_0000589a;\ncode_r0x00005896:\n  pbVar6 \u003d pbVar5 + 1;\n  if (*pbVar5 \u003d\u003d 0x25) {\nLAB_0000589a:\n    iVar1 \u003d (int)pbVar5 - (int)param_3;\n    if (iVar1 !\u003d 0) {\n      iVar2 \u003d __sfputs_r(param_1,param_2,param_3,iVar1);\n      if (iVar2 \u003d\u003d -1) {\nLAB_00005a06:\n        if ((-1 \u003c (int)(param_2[0x19] \u003c\u003c 0x1f)) \u0026\u0026\n           (-1 \u003c (int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x16))) {\n          __retarget_lock_release_recursive(param_2[0x16]);\n        }\n        if ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x19) \u003c 0) {\n          return -1;\n        }\n        return local_74;\n      }\n      local_74 \u003d local_74 + iVar1;\n    }\n    if (*pbVar5 \u003d\u003d 0) goto LAB_00005a06;\n    local_84 \u003d -1;\n    uStack_80 \u003d 0;\n    local_88 \u003d 0;\n    local_7c \u003d 0;\n    local_45 \u003d 0;\n    local_30 \u003d 0;\n    pbVar6 \u003d pbVar5 + 1;\n    while( true ) {\n      pbVar5 \u003d pbVar6 + 1;\n      iVar1 \u003d memchr(\"#-0+ \",*pbVar6,5);\n      if (iVar1 \u003d\u003d 0) break;\n      local_88 \u003d 1 \u003c\u003c (iVar1 - 0x7bfcU \u0026 0xff) | local_88;\n      pbVar6 \u003d pbVar5;\n    }\n    if ((int)(local_88 \u003c\u003c 0x1b) \u003c 0) {\n      local_45 \u003d 0x20;\n    }\n    if ((int)(local_88 \u003c\u003c 0x1c) \u003c 0) {\n      local_45 \u003d 0x2b;\n    }\n    if (*pbVar6 \u003d\u003d 0x2a) {\n      piVar3 \u003d local_8c + 1;\n      local_7c \u003d *local_8c;\n      local_8c \u003d piVar3;\n      if (local_7c \u003c 0) {\n        local_7c \u003d -local_7c;\n        local_88 \u003d local_88 | 2;\n      }\n    }\n    else {\n      bVar4 \u003d false;\n      iVar1 \u003d local_7c;\n      pbVar5 \u003d pbVar6;\n      while( true ) {\n        if (9 \u003c *pbVar5 - 0x30) break;\n        iVar1 \u003d iVar1 * 10 + (*pbVar5 - 0x30);\n        bVar4 \u003d true;\n        pbVar5 \u003d pbVar5 + 1;\n      }\n      if (bVar4) {\n        local_7c \u003d iVar1;\n      }\n    }\n    if (*pbVar5 \u003d\u003d 0x2e) {\n      if (pbVar5[1] \u003d\u003d 0x2a) {\n        local_84 \u003d *local_8c;\n        if (local_84 \u003c 0) {\n          local_84 \u003d -1;\n        }\n        pbVar5 \u003d pbVar5 + 2;\n        local_8c \u003d local_8c + 1;\n      }\n      else {\n        bVar4 \u003d false;\n        local_84 \u003d 0;\n        iVar1 \u003d 0;\n        while( true ) {\n          pbVar5 \u003d pbVar5 + 1;\n          if (9 \u003c *pbVar5 - 0x30) break;\n          iVar1 \u003d iVar1 * 10 + (*pbVar5 - 0x30);\n          bVar4 \u003d true;\n        }\n        if (bVar4) {\n          local_84 \u003d iVar1;\n        }\n      }\n    }\n    iVar1 \u003d memchr(\u0026DAT_00007c02,*pbVar5,3);\n    if (iVar1 !\u003d 0) {\n      local_88 \u003d local_88 | 0x40 \u003c\u003c (iVar1 - 0x7c02U \u0026 0xff);\n      pbVar5 \u003d pbVar5 + 1;\n    }\n    param_3 \u003d pbVar5 + 1;\n    local_70 \u003d *pbVar5;\n    iVar1 \u003d memchr(\"efgEFG\",local_70,6);\n    if (iVar1 \u003d\u003d 0) {\n      unaff_r7 \u003d _printf_i(param_1,\u0026local_88,param_2,0x57d3,\u0026local_8c);\n      if (unaff_r7 \u003d\u003d -1) goto LAB_00005a06;\n    }\n    else {\n      local_8c \u003d (int *)(((int)local_8c + 7U \u0026 0xfffffff8) + 8);\n    }\n    local_74 \u003d local_74 + unaff_r7;\n    pbVar6 \u003d param_3;\n  }\n  goto LAB_0000588e;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004c84"
      ],
      "called": [
        "FUN_000057d2",
        "FUN_000045e8",
        "FUN_000045ec",
        "FUN_000054a8",
        "FUN_00006010",
        "FUN_000042a4",
        "FUN_00005b34"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005a58": {
      "entrypoint": "0x00005a58",
      "current_name": "FUN_00005a58",
      "code": "\nundefined4\nFUN_00005a58(undefined4 param_1,uint *param_2,uint *param_3,undefined4 param_4,code *param_5)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  bool bVar6;\n  \n  uVar4 \u003d param_2[4];\n  if ((int)param_2[4] \u003c (int)param_2[2]) {\n    uVar4 \u003d param_2[2];\n  }\n  *param_3 \u003d uVar4;\n  if (*(char *)((int)param_2 + 0x43) !\u003d \u0027\\0\u0027) {\n    *param_3 \u003d uVar4 + 1;\n  }\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *param_3 \u003d *param_3 + 2;\n  }\n  if ((*param_2 \u0026 6) \u003d\u003d 0) {\n    for (iVar1 \u003d 0; iVar1 \u003c (int)(param_2[3] - *param_3); iVar1 \u003d iVar1 + 1) {\n      iVar3 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x19,1);\n      if (iVar3 \u003d\u003d -1) goto LAB_00005afc;\n    }\n  }\n  uVar4 \u003d (uint)*(byte *)((int)param_2 + 0x43);\n  if (uVar4 !\u003d 0) {\n    uVar4 \u003d 1;\n  }\n  if ((int)(*param_2 \u003c\u003c 0x1a) \u003c 0) {\n    *(undefined *)((int)param_2 + uVar4 + 0x43) \u003d 0x30;\n    *(undefined *)((int)param_2 + uVar4 + 0x44) \u003d *(undefined *)((int)param_2 + 0x45);\n    uVar4 \u003d uVar4 + 2;\n  }\n  iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x43,uVar4);\n  if (iVar1 \u003d\u003d -1) {\nLAB_00005afc:\n    uVar2 \u003d 0xffffffff;\n  }\n  else {\n    uVar4 \u003d param_2[3];\n    bVar6 \u003d (*param_2 \u0026 6) \u003d\u003d 4;\n    if (bVar6) {\n      uVar4 \u003d uVar4 - *param_3;\n    }\n    if (bVar6) {\n      uVar4 \u003d uVar4 \u0026 ~((int)uVar4 \u003e\u003e 0x1f);\n    }\n    else {\n      uVar4 \u003d 0;\n    }\n    if ((int)param_2[4] \u003c (int)param_2[2]) {\n      uVar4 \u003d uVar4 + (param_2[2] - param_2[4]);\n    }\n    for (uVar5 \u003d 0; uVar4 !\u003d uVar5; uVar5 \u003d uVar5 + 1) {\n      iVar1 \u003d (*param_5)(param_1,param_4,(int)param_2 + 0x1a,1);\n      if (iVar1 \u003d\u003d -1) goto LAB_00005afc;\n    }\n    uVar2 \u003d 0;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005b34"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005b34": {
      "entrypoint": "0x00005b34",
      "current_name": "FUN_00005b34",
      "code": "\ncode * FUN_00005b34(undefined4 param_1,uint *param_2,undefined4 param_3,code *param_4,uint **param_5\n                   )\n\n{\n  bool bVar1;\n  byte bVar2;\n  int iVar3;\n  code *pcVar4;\n  char *pcVar5;\n  int iVar6;\n  char *pcVar7;\n  uint uVar8;\n  uint *puVar9;\n  uint uVar10;\n  uint **ppuVar11;\n  char **ppcVar12;\n  uint uVar13;\n  char *pcVar14;\n  code *local_24;\n  \n  bVar2 \u003d *(byte *)(param_2 + 6);\n  pcVar7 \u003d (char *)((int)param_2 + 0x43);\n  local_24 \u003d param_4;\n  if (0x78 \u003c bVar2) {\nswitchD_00005b70_caseD_65:\n    *(byte *)((int)param_2 + 0x42) \u003d bVar2;\nLAB_00005bdc:\n    pcVar7 \u003d (char *)((int)param_2 + 0x42);\n    uVar8 \u003d 1;\nLAB_00005d28:\n    param_2[4] \u003d uVar8;\n    *(undefined *)((int)param_2 + 0x43) \u003d 0;\n    goto LAB_00005c84;\n  }\n  if (bVar2 \u003c 99) {\n    if (bVar2 \u003d\u003d 0) goto LAB_00005d06;\n    if (bVar2 \u003d\u003d 0x58) {\n      pcVar5 \u003d \"0123456789ABCDEF\";\n      *(undefined *)((int)param_2 + 0x45) \u003d 0x58;\n      goto LAB_00005ca8;\n    }\n    goto switchD_00005b70_caseD_65;\n  }\n  switch(bVar2) {\n  case 99:\n    uVar8 \u003d **param_5;\n    *param_5 \u003d *param_5 + 1;\n    *(char *)((int)param_2 + 0x42) \u003d (char)uVar8;\n    goto LAB_00005bdc;\n  case 100:\n  case 0x69:\n    uVar10 \u003d *param_2;\n    puVar9 \u003d *param_5;\n    if ((int)(uVar10 \u003c\u003c 0x18) \u003c 0) {\n      uVar8 \u003d *puVar9;\n      *param_5 \u003d puVar9 + 1;\n    }\n    else {\n      uVar8 \u003d *puVar9;\n      *param_5 \u003d puVar9 + 1;\n      if ((uVar10 \u0026 0x40) !\u003d 0) {\n        uVar8 \u003d (uint)(short)uVar8;\n      }\n    }\n    if ((int)uVar8 \u003c 0) {\n      uVar8 \u003d -uVar8;\n      *(undefined *)((int)param_2 + 0x43) \u003d 0x2d;\n    }\n    pcVar5 \u003d \"0123456789ABCDEF\";\n    uVar10 \u003d 10;\n    goto LAB_00005c36;\n  default:\n    goto switchD_00005b70_caseD_65;\n  case 0x6e:\n    ppuVar11 \u003d (uint **)*param_5;\n    uVar10 \u003d *param_2;\n    uVar8 \u003d param_2[5];\n    *param_5 \u003d (uint *)(ppuVar11 + 1);\n    puVar9 \u003d *ppuVar11;\n    if (((int)(uVar10 \u003c\u003c 0x18) \u003c 0) || (-1 \u003c (int)(uVar10 \u003c\u003c 0x19))) {\n      *puVar9 \u003d uVar8;\n    }\n    else {\n      *(short *)puVar9 \u003d (short)uVar8;\n    }\nLAB_00005d06:\n    param_2[4] \u003d 0;\n    goto LAB_00005c84;\n  case 0x6f:\n  case 0x75:\n    puVar9 \u003d *param_5;\n    uVar8 \u003d *param_2;\n    *param_5 \u003d puVar9 + 1;\n    if (((int)(uVar8 \u003c\u003c 0x18) \u003c 0) || (-1 \u003c (int)(uVar8 \u003c\u003c 0x19))) {\n      uVar8 \u003d *puVar9;\n    }\n    else {\n      uVar8 \u003d (uint)*(ushort *)puVar9;\n    }\n    pcVar5 \u003d \"0123456789ABCDEF\";\n    if (bVar2 \u003d\u003d 0x6f) {\n      uVar10 \u003d 8;\n    }\n    else {\n      uVar10 \u003d 10;\n    }\n    break;\n  case 0x70:\n    *param_2 \u003d *param_2 | 0x20;\n  case 0x78:\n    pcVar5 \u003d \"0123456789abcdef\";\n    *(undefined *)((int)param_2 + 0x45) \u003d 0x78;\nLAB_00005ca8:\n    uVar10 \u003d *param_2;\n    uVar8 \u003d **param_5;\n    *param_5 \u003d *param_5 + 1;\n    if ((-1 \u003c (int)(uVar10 \u003c\u003c 0x18)) \u0026\u0026 ((int)(uVar10 \u003c\u003c 0x19) \u003c 0)) {\n      uVar8 \u003d uVar8 \u0026 0xffff;\n    }\n    if ((int)(uVar10 \u003c\u003c 0x1f) \u003c 0) {\n      *param_2 \u003d uVar10 | 0x20;\n    }\n    if (uVar8 \u003d\u003d 0) {\n      *param_2 \u003d *param_2 \u0026 0xffffffdf;\n    }\n    uVar10 \u003d 0x10;\n    break;\n  case 0x73:\n    ppcVar12 \u003d (char **)*param_5;\n    *param_5 \u003d (uint *)(ppcVar12 + 1);\n    pcVar7 \u003d *ppcVar12;\n    iVar3 \u003d memchr(pcVar7,0,param_2[1],ppcVar12,param_1,param_2,param_3);\n    if (iVar3 !\u003d 0) {\n      param_2[1] \u003d iVar3 - (int)pcVar7;\n    }\n    uVar8 \u003d param_2[1];\n    goto LAB_00005d28;\n  }\n  *(undefined *)((int)param_2 + 0x43) \u003d 0;\nLAB_00005c36:\n  uVar13 \u003d param_2[1];\n  param_2[2] \u003d uVar13;\n  if (-1 \u003c (int)uVar13) {\n    *param_2 \u003d *param_2 \u0026 0xfffffffb;\n  }\n  pcVar14 \u003d pcVar7;\n  if ((uVar8 !\u003d 0) || (uVar13 !\u003d 0)) {\n    do {\n      pcVar14 \u003d pcVar14 + -1;\n      *pcVar14 \u003d pcVar5[uVar8 - uVar10 * (uVar8 / uVar10)];\n      bVar1 \u003d uVar10 \u003c\u003d uVar8;\n      uVar8 \u003d uVar8 / uVar10;\n    } while (bVar1);\n  }\n  if (((uVar10 \u003d\u003d 8) \u0026\u0026 ((int)(*param_2 \u003c\u003c 0x1f) \u003c 0)) \u0026\u0026 ((int)param_2[1] \u003c\u003d (int)param_2[4])) {\n    pcVar14[-1] \u003d \u00270\u0027;\n    pcVar14 \u003d pcVar14 + -1;\n  }\n  param_2[4] \u003d (int)pcVar7 - (int)pcVar14;\n  pcVar7 \u003d pcVar14;\nLAB_00005c84:\n  iVar3 \u003d _printf_common(param_1,param_2,\u0026local_24,param_3,param_4);\n  if ((iVar3 \u003d\u003d -1) || (iVar3 \u003d (*param_4)(param_1,param_3,pcVar7,param_2[4]), iVar3 \u003d\u003d -1)) {\nLAB_00005c98:\n    pcVar4 \u003d (code *)0xffffffff;\n  }\n  else {\n    if ((int)(*param_2 \u003c\u003c 0x1e) \u003c 0) {\n      for (iVar3 \u003d 0; iVar3 \u003c (int)(param_2[3] - (int)local_24); iVar3 \u003d iVar3 + 1) {\n        iVar6 \u003d (*param_4)(param_1,param_3,(int)param_2 + 0x19,1);\n        if (iVar6 \u003d\u003d -1) goto LAB_00005c98;\n      }\n    }\n    pcVar4 \u003d (code *)param_2[3];\n    if ((int)(code *)param_2[3] \u003c (int)local_24) {\n      pcVar4 \u003d local_24;\n    }\n  }\n  return pcVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000057f8"
      ],
      "called": [
        "FUN_00005a58",
        "FUN_00006010"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005e10": {
      "entrypoint": "0x00005e10",
      "current_name": "FUN_00005e10",
      "code": "\nuint FUN_00005e10(int param_1,byte **param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  byte *pbVar3;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x18) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d (byte **)\u0026DAT_000079b8) {\n    param_2 \u003d *(byte ***)(param_1 + 4);\n  }\n  else if (param_2 \u003d\u003d (byte **)\u0026DAT_000079d8) {\n    param_2 \u003d *(byte ***)(param_1 + 8);\n  }\n  else if (param_2 \u003d\u003d (byte **)\u0026DAT_00007998) {\n    param_2 \u003d *(byte ***)(param_1 + 0xc);\n  }\n  iVar1 \u003d __srefill_r(param_1,param_2);\n  if (iVar1 \u003d\u003d 0) {\n    param_2[1] \u003d param_2[1] + -1;\n    pbVar3 \u003d *param_2;\n    *param_2 \u003d pbVar3 + 1;\n    uVar2 \u003d (uint)*pbVar3;\n  }\n  else {\n    uVar2 \u003d 0xffffffff;\n  }\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00004418"
      ],
      "called": [
        "FUN_00006768",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005e68": {
      "entrypoint": "0x00005e68",
      "current_name": "FUN_00005e68",
      "code": "\nvoid FUN_00005e68(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 local_80;\n  undefined4 local_7c;\n  undefined2 local_74;\n  undefined2 local_72;\n  undefined4 local_70;\n  undefined4 local_6c;\n  undefined *local_5c;\n  undefined4 local_4c;\n  undefined4 local_38;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  local_74 \u003d 0x204;\n  local_80 \u003d param_1;\n  local_70 \u003d param_1;\n  uStack_8 \u003d param_3;\n  uStack_4 \u003d param_4;\n  local_7c \u003d strlen();\n  local_5c \u003d \u0026LAB_00004dea_1;\n  local_4c \u003d 0;\n  local_38 \u003d 0;\n  local_72 \u003d 0xffff;\n  local_6c \u003d local_7c;\n  __ssvfiscanf_r(Elf32_Rel_ARRAY_1fff0200[16].r_offset,\u0026local_80,param_2,\u0026uStack_8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100"
      ],
      "called": [
        "FUN_000061cc",
        "FUN_00005ecc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005ebc": {
      "entrypoint": "0x00005ebc",
      "current_name": "FUN_00005ebc",
      "code": "\nvoid FUN_00005ebc(char *param_1,char *param_2)\n\n{\n  char cVar1;\n  \n  do {\n    cVar1 \u003d *param_2;\n    *param_1 \u003d cVar1;\n    param_2 \u003d param_2 + 1;\n    param_1 \u003d param_1 + 1;\n  } while (cVar1 !\u003d \u0027\\0\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005ecc": {
      "entrypoint": "0x00005ecc",
      "current_name": "FUN_00005ecc",
      "code": "\nchar * FUN_00005ecc(char *param_1)\n\n{\n  char cVar1;\n  char *pcVar2;\n  char *pcVar3;\n  \n  pcVar3 \u003d param_1;\n  do {\n    pcVar2 \u003d pcVar3 + 1;\n    cVar1 \u003d *pcVar3;\n    pcVar3 \u003d pcVar2;\n  } while (cVar1 !\u003d \u0027\\0\u0027);\n  return pcVar2 + (-1 - (int)param_1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100",
        "FUN_00005e68"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005edc": {
      "entrypoint": "0x00005edc",
      "current_name": "FUN_00005edc",
      "code": "\nuint FUN_00005edc(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  byte bVar3;\n  int iVar4;\n  uint uVar5;\n  uint uVar6;\n  byte *pbVar7;\n  byte *pbVar8;\n  \n  pbVar8 \u003d param_2;\n  do {\n    pbVar7 \u003d pbVar8;\n    pbVar8 \u003d pbVar7 + 1;\n    uVar2 \u003d (uint)*pbVar7;\n    bVar3 \u003d (\u0026DAT_00007a99)[uVar2] \u0026 8;\n  } while (((\u0026DAT_00007a99)[uVar2] \u0026 8) !\u003d 0);\n  if (uVar2 \u003d\u003d 0x2d) {\n    uVar2 \u003d (uint)*pbVar8;\n    bVar3 \u003d 1;\n    pbVar8 \u003d pbVar7 + 2;\n  }\n  else if (uVar2 \u003d\u003d 0x2b) {\n    uVar2 \u003d (uint)*pbVar8;\n    pbVar8 \u003d pbVar7 + 2;\n  }\n  if (param_4 \u003d\u003d 0) {\n    if (uVar2 !\u003d 0x30) {\n      param_4 \u003d 10;\n      goto LAB_00005f26;\n    }\n  }\n  else if ((param_4 !\u003d 0x10) || (uVar2 !\u003d 0x30)) goto LAB_00005f26;\n  if ((*pbVar8 \u0026 0xdf) \u003d\u003d 0x58) {\n    uVar2 \u003d (uint)pbVar8[1];\n    param_4 \u003d 0x10;\n    pbVar8 \u003d pbVar8 + 2;\n  }\n  else {\n    uVar2 \u003d 0x30;\n    if (param_4 \u003d\u003d 0) {\n      param_4 \u003d 8;\n    }\n  }\nLAB_00005f26:\n  iVar4 \u003d 0;\n  uVar6 \u003d 0xffffffff / param_4;\n  uVar1 \u003d 0;\n  do {\n    uVar5 \u003d uVar2 - 0x30;\n    if (9 \u003c uVar5) {\n      if (uVar2 - 0x41 \u003c 0x1a) {\n        uVar5 \u003d uVar2 - 0x37;\n      }\n      else {\n        if (0x19 \u003c uVar2 - 0x61) break;\n        uVar5 \u003d uVar2 - 0x57;\n      }\n    }\n    if ((int)param_4 \u003c\u003d (int)uVar5) break;\n    if (((iVar4 \u003c 0) || (uVar6 \u003c uVar1)) ||\n       ((uVar6 \u003d\u003d uVar1 \u0026\u0026 ((int)~(param_4 * uVar6) \u003c (int)uVar5)))) {\n      iVar4 \u003d -1;\n    }\n    else {\n      uVar1 \u003d uVar1 * param_4 + uVar5;\n      iVar4 \u003d 1;\n    }\n    uVar2 \u003d (uint)*pbVar8;\n    pbVar8 \u003d pbVar8 + 1;\n  } while( true );\n  if (iVar4 \u003c 0) {\n    *param_1 \u003d 0x22;\n    uVar1 \u003d 0xffffffff;\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return 0xffffffff;\n    }\n  }\n  else {\n    if (bVar3 !\u003d 0) {\n      uVar1 \u003d -uVar1;\n    }\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar1;\n    }\n    if (iVar4 \u003d\u003d 0) goto LAB_00005fb8;\n  }\n  param_2 \u003d pbVar8 + -1;\nLAB_00005fb8:\n  *param_3 \u003d param_2;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005fd8"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005fd8": {
      "entrypoint": "0x00005fd8",
      "current_name": "FUN_00005fd8",
      "code": "\nvoid FUN_00005fd8(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  _strtoul_l_isra_0(Elf32_Rel_ARRAY_1fff0200[16].r_offset,param_1,param_2,param_3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005100"
      ],
      "called": [
        "FUN_00005edc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005fec": {
      "entrypoint": "0x00005fec",
      "current_name": "FUN_00005fec",
      "code": "\nvoid FUN_00005fec(void)\n\n{\n  __retarget_lock_acquire_recursive(0x1fff0de6);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000562c"
      ],
      "called": [
        "FUN_000045e8"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00005ff8": {
      "entrypoint": "0x00005ff8",
      "current_name": "FUN_00005ff8",
      "code": "\nvoid FUN_00005ff8(void)\n\n{\n  __retarget_lock_release_recursive(0x1fff0de6);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000562c"
      ],
      "called": [
        "FUN_000045ec"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00006010": {
      "entrypoint": "0x00006010",
      "current_name": "FUN_00006010",
      "code": "\nbyte * FUN_00006010(uint *param_1,uint param_2,uint param_3)\n\n{\n  byte bVar1;\n  char cVar2;\n  char cVar3;\n  char cVar4;\n  char cVar5;\n  byte *pbVar6;\n  uint *puVar7;\n  byte *pbVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  bool bVar14;\n  bool bVar15;\n  bool bVar16;\n  \n  param_2 \u003d param_2 \u0026 0xff;\n  if ((int)param_3 \u003c 0x10) {\njoined_r0x00006070:\n    do {\n      if (param_3 \u003d\u003d 0) {\n        return (byte *)0x0;\n      }\n      puVar7 \u003d (uint *)((int)param_1 + 1);\n      bVar1 \u003d *(byte *)param_1;\n      param_3 \u003d param_3 - 1;\n      param_1 \u003d puVar7;\n    } while (bVar1 !\u003d param_2);\n  }\n  else {\n    uVar9 \u003d (uint)param_1 \u0026 7;\n    while( true ) {\n      if (uVar9 \u003d\u003d 0) {\n        uVar9 \u003d param_2 | param_2 \u003c\u003c 8;\n        uVar9 \u003d uVar9 | uVar9 \u003c\u003c 0x10;\n        uVar10 \u003d param_3 \u0026 0xfffffff8;\n        do {\n          puVar7 \u003d param_1 + 2;\n          uVar10 \u003d uVar10 - 8;\n          uVar11 \u003d *param_1 ^ uVar9;\n          uVar12 \u003d param_1[1] ^ uVar9;\n          cVar2 \u003d -((char)uVar11 \u003d\u003d \u0027\\0\u0027);\n          cVar3 \u003d -((char)(uVar11 \u003e\u003e 8) \u003d\u003d \u0027\\0\u0027);\n          cVar4 \u003d -((char)(uVar11 \u003e\u003e 0x10) \u003d\u003d \u0027\\0\u0027);\n          cVar5 \u003d -((char)(uVar11 \u003e\u003e 0x18) \u003d\u003d \u0027\\0\u0027);\n          uVar11 \u003d CONCAT13(cVar5,CONCAT12(cVar4,CONCAT11(cVar3,cVar2)));\n          bVar13 \u003d (char)uVar12 !\u003d \u0027\\0\u0027;\n          bVar14 \u003d (char)(uVar12 \u003e\u003e 8) !\u003d \u0027\\0\u0027;\n          bVar15 \u003d (char)(uVar12 \u003e\u003e 0x10) !\u003d \u0027\\0\u0027;\n          bVar16 \u003d (char)(uVar12 \u003e\u003e 0x18) !\u003d \u0027\\0\u0027;\n          uVar12 \u003d CONCAT13(bVar16 * cVar5 - !bVar16,\n                            CONCAT12(bVar15 * cVar4 - !bVar15,\n                                     CONCAT11(bVar14 * cVar3 - !bVar14,bVar13 * cVar2 - !bVar13)));\n          if (uVar12 !\u003d 0) {\n            if (uVar11 \u003d\u003d 0) {\n              pbVar8 \u003d (byte *)((int)param_1 + 5);\n              uVar11 \u003d uVar12;\n            }\n            else {\n              pbVar8 \u003d (byte *)((int)param_1 + 1);\n            }\n            if ((uVar11 \u0026 1) \u003d\u003d 0) {\n              bVar13 \u003d (uVar11 \u0026 0x100) \u003d\u003d 0;\n              pbVar6 \u003d pbVar8 + 1;\n              if (bVar13) {\n                bVar13 \u003d (uVar11 \u0026 0x18000) \u003d\u003d 0;\n                pbVar6 \u003d pbVar8 + 2;\n              }\n              pbVar8 \u003d pbVar6;\n              if (bVar13) {\n                pbVar8 \u003d pbVar8 + 1;\n              }\n            }\n            return pbVar8 + -1;\n          }\n          param_1 \u003d puVar7;\n        } while (uVar10 !\u003d 0);\n        param_3 \u003d param_3 \u0026 7;\n        goto joined_r0x00006070;\n      }\n      puVar7 \u003d (uint *)((int)param_1 + 1);\n      param_3 \u003d param_3 - 1;\n      if (*(byte *)param_1 \u003d\u003d param_2) break;\n      uVar9 \u003d (uint)puVar7 \u0026 7;\n      param_1 \u003d puVar7;\n      if (param_3 \u003d\u003d 0) {\n        return (byte *)0x0;\n      }\n    }\n  }\n  return (byte *)((int)puVar7 + -1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000061cc",
        "FUN_000057f8",
        "FUN_00005b34",
        "FUN_0000656c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000060b0": {
      "entrypoint": "0x000060b0",
      "current_name": "FUN_000060b0",
      "code": "\nvoid FUN_000060b0(int param_1,undefined *param_2,int param_3)\n\n{\n  undefined *puVar1;\n  undefined *puVar2;\n  undefined *puVar3;\n  \n  puVar2 \u003d param_2 + param_3;\n  puVar3 \u003d (undefined *)(param_1 + -1);\n  if (param_2 !\u003d puVar2) {\n    do {\n      puVar1 \u003d param_2 + 1;\n      puVar3 \u003d puVar3 + 1;\n      *puVar3 \u003d *param_2;\n      param_2 \u003d puVar1;\n    } while (puVar1 !\u003d puVar2);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000068f0",
        "FUN_000060cc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000060cc": {
      "entrypoint": "0x000060cc",
      "current_name": "FUN_000060cc",
      "code": "\nint FUN_000060cc(undefined4 param_1,int param_2,uint param_3,undefined4 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  \n  if (param_2 !\u003d 0) {\n    if (param_3 \u003d\u003d 0) {\n      _free_r();\n      iVar1 \u003d 0;\n    }\n    else {\n      uVar2 \u003d _malloc_usable_size_r();\n      iVar1 \u003d param_2;\n      if ((uVar2 \u003c param_3) \u0026\u0026 (iVar1 \u003d _malloc_r(param_1,param_3), iVar1 !\u003d 0)) {\n        memcpy(iVar1,param_2,param_3);\n        _free_r(param_1,param_2);\n      }\n    }\n    return iVar1;\n  }\n  iVar1 \u003d _malloc_r(param_1,param_3,param_3,param_4);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000068f0"
      ],
      "called": [
        "FUN_00004bd0",
        "FUN_00004b34",
        "FUN_000060b0",
        "FUN_00006964"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00006192": {
      "entrypoint": "0x00006192",
      "current_name": "FUN_00006192",
      "code": "\nundefined4 FUN_00006192(undefined4 param_1,undefined4 *param_2)\n\n{\n  if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n    if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n      _free_r();\n    }\n    param_2[1] \u003d param_2[0x10];\n    param_2[0xd] \u003d 0;\n    if (param_2[0x10] !\u003d 0) {\n      *param_2 \u003d param_2[0xf];\n      return 0;\n    }\n  }\n  *param_2 \u003d param_2[4];\n  param_2[1] \u003d 0;\n  *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x20;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000061cc"
      ],
      "called": [
        "FUN_00004b34"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000061cc": {
      "entrypoint": "0x000061cc",
      "current_name": "FUN_000061cc",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00006482) */\n\nint FUN_000061cc(undefined4 param_1,byte **param_2,byte *param_3,int **param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  byte *pbVar3;\n  uint uVar4;\n  int **local_2b0;\n  undefined auStack_2ac [256];\n  uint local_1ac;\n  undefined4 local_1a8;\n  uint local_1a4;\n  int local_1a0;\n  int local_19c;\n  undefined *local_198;\n  int local_194;\n  undefined *local_30;\n  code *local_2c;\n  \n  local_1a0 \u003d 0;\n  local_19c \u003d 0;\n  local_30 \u003d \u0026LAB_00006118_1;\n  local_2c \u003d __ssrefill_r + 1;\n  local_2b0 \u003d param_4;\n  local_198 \u003d auStack_2ac;\nLAB_000061f6:\n  while( true ) {\n    while( true ) {\n      uVar4 \u003d (uint)*param_3;\n      if (uVar4 \u003d\u003d 0) {\n        return local_1a0;\n      }\n      uVar2 \u003d (byte)(\u0026DAT_00007a99)[uVar4] \u0026 8;\n      pbVar3 \u003d param_3 + 1;\n      if (((\u0026DAT_00007a99)[uVar4] \u0026 8) \u003d\u003d 0) break;\n      while (((param_3 \u003d pbVar3, 0 \u003c (int)param_2[1] ||\n              (iVar1 \u003d (*local_2c)(param_1,param_2), iVar1 \u003d\u003d 0)) \u0026\u0026\n             ((int)((uint)(byte)(\u0026DAT_00007a99)[**param_2] \u003c\u003c 0x1c) \u003c 0))) {\n        local_19c \u003d local_19c + 1;\n        param_2[1] \u003d param_2[1] + -1;\n        *param_2 \u003d *param_2 + 1;\n      }\n    }\n    if (uVar4 \u003d\u003d 0x25) break;\nLAB_00006352:\n    if (((int)param_2[1] \u003c 1) \u0026\u0026 (iVar1 \u003d (*local_2c)(param_1,param_2), iVar1 !\u003d 0))\n    goto LAB_00006380;\n    if (**param_2 !\u003d uVar4) {\n      return local_1a0;\n    }\n    *param_2 \u003d *param_2 + 1;\n    local_19c \u003d local_19c + 1;\n    param_2[1] \u003d param_2[1] + -1;\n    param_3 \u003d pbVar3;\n  }\n  local_1a4 \u003d uVar2;\n  local_1ac \u003d uVar2;\n  if (param_3[1] \u003d\u003d 0x2a) {\n    pbVar3 \u003d param_3 + 2;\n    local_1ac \u003d 0x10;\n  }\n  while( true ) {\n    uVar2 \u003d (uint)*pbVar3;\n    if (9 \u003c uVar2 - 0x30) break;\n    pbVar3 \u003d pbVar3 + 1;\n    local_1a4 \u003d (local_1a4 * 10 + uVar2) - 0x30;\n  }\n  iVar1 \u003d memchr(\u0026DAT_00007c02,uVar2,3);\n  if (iVar1 !\u003d 0) {\n    local_1ac \u003d 1 \u003c\u003c (iVar1 - 0x7c02U \u0026 0xff) | local_1ac;\n    pbVar3 \u003d pbVar3 + 1;\n  }\n  param_3 \u003d pbVar3 + 1;\n  uVar2 \u003d (uint)*pbVar3;\n  if (uVar2 \u003c 0x79) {\n    if (0x57 \u003c uVar2) {\n      switch(uVar2) {\n      default:\n        goto switchD_000062c0_caseD_59;\n      case 0x5b:\n        param_3 \u003d (byte *)__sccl(auStack_2ac,param_3);\n        local_1ac \u003d local_1ac | 0x40;\n        local_194 \u003d 1;\n        break;\n      case 99:\n        local_1ac \u003d local_1ac | 0x40;\n        local_194 \u003d 0;\n        break;\n      case 100:\n      case 0x75:\n        local_1a8 \u003d 10;\nLAB_000063a0:\n        if (uVar2 \u003c 0x6f) {\n          local_194 \u003d 3;\n        }\n        else {\n          local_194 \u003d 4;\n        }\n        break;\n      case 0x65:\n      case 0x66:\n      case 0x67:\nswitchD_000062c0_caseD_65:\n        local_194 \u003d 5;\n        break;\n      case 0x69:\n        local_1a8 \u003d 0;\n        local_194 \u003d 3;\n        break;\n      case 0x6e:\n        if (-1 \u003c (int)(local_1ac \u003c\u003c 0x1b)) {\n          if ((int)(local_1ac \u003c\u003c 0x1f) \u003c 0) {\n            *(short *)*local_2b0 \u003d (short)local_19c;\n            local_2b0 \u003d local_2b0 + 1;\n          }\n          else {\n            **local_2b0 \u003d local_19c;\n            local_2b0 \u003d local_2b0 + 1;\n          }\n        }\n        goto LAB_000061f6;\n      case 0x6f:\n        local_1a8 \u003d 8;\n        local_194 \u003d 4;\n        break;\n      case 0x70:\n        local_1ac \u003d local_1ac | 0x20;\n      case 0x58:\n      case 0x78:\n        local_1ac \u003d local_1ac | 0x200;\n        local_1a8 \u003d 0x10;\n        goto LAB_000063a0;\n      case 0x73:\n        local_194 \u003d 2;\n      }\nLAB_000063ac:\n      if (((int)param_2[1] \u003c 1) \u0026\u0026 (iVar1 \u003d (*local_2c)(param_1,param_2), iVar1 !\u003d 0))\n      goto LAB_00006380;\n      if (-1 \u003c (int)(local_1ac \u003c\u003c 0x19)) {\n        while ((int)((uint)(byte)(\u0026DAT_00007a99)[**param_2] \u003c\u003c 0x1c) \u003c 0) {\n          local_19c \u003d local_19c + 1;\n          pbVar3 \u003d param_2[1];\n          param_2[1] \u003d pbVar3 + -1;\n          if ((int)(pbVar3 + -1) \u003c 1) {\n            iVar1 \u003d (*local_2c)(param_1,param_2);\n            if (iVar1 !\u003d 0) goto LAB_00006380;\n          }\n          else {\n            *param_2 \u003d *param_2 + 1;\n          }\n        }\n      }\n      if (local_194 \u003c 3) {\n        iVar1 \u003d _scanf_chars(param_1,\u0026local_1ac,param_2,\u0026local_2b0);\n      }\n      else {\n        if (4 \u003c local_194) goto LAB_000061f6;\n        iVar1 \u003d _scanf_i(param_1,\u0026local_1ac,param_2,\u0026local_2b0);\n      }\n      if (iVar1 \u003d\u003d 1) {\n        return local_1a0;\n      }\n      if (iVar1 \u003d\u003d 2) {\nLAB_00006380:\n        if (local_1a0 \u003d\u003d 0) {\nLAB_00006388:\n          local_1a0 \u003d -1;\n        }\n        else if ((*(ushort *)(param_2 + 3) \u0026 0x40) !\u003d 0) {\n          local_1a0 \u003d -1;\n        }\n        return local_1a0;\n      }\n      goto LAB_000061f6;\n    }\n    pbVar3 \u003d param_3;\n    if (uVar2 \u003d\u003d 0x25) goto LAB_00006352;\n    if (uVar2 \u003c 0x26) {\n      if (uVar2 !\u003d 0) goto switchD_000062c0_caseD_59;\n      goto LAB_00006388;\n    }\n    if (uVar2 - 0x45 \u003c 3) goto switchD_000062c0_caseD_65;\n  }\nswitchD_000062c0_caseD_59:\n  local_194 \u003d 3;\n  local_1a8 \u003d 10;\n  goto LAB_000063ac;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005e68"
      ],
      "called": [
        "FUN_00006192",
        "FUN_0000687c",
        "FUN_00006010",
        "FUN_000064bc",
        "FUN_0000656c"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000064bc": {
      "entrypoint": "0x000064bc",
      "current_name": "FUN_000064bc",
      "code": "\nundefined4 FUN_000064bc(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  byte **ppbVar3;\n  byte *pbVar4;\n  byte *unaff_r6;\n  byte *pbVar5;\n  int iVar6;\n  \n  if (param_2[2] \u003d\u003d 0) {\n    if (param_2[6] \u003d\u003d 0) {\n      uVar2 \u003d 1;\n    }\n    else {\n      uVar2 \u003d 0xffffffff;\n    }\n    param_2[2] \u003d uVar2;\n  }\n  if (-1 \u003c (int)(*param_2 \u003c\u003c 0x1b)) {\n    ppbVar3 \u003d (byte **)*param_4;\n    *param_4 \u003d ppbVar3 + 1;\n    unaff_r6 \u003d *ppbVar3;\n  }\n  iVar6 \u003d 0;\n  do {\n    uVar2 \u003d param_2[6];\n    if (uVar2 !\u003d 0) {\n      if (uVar2 \u003d\u003d 1) {\n        if (*(char *)(param_2[5] + (uint)**param_3) \u003d\u003d \u0027\\0\u0027) {\n          if (iVar6 \u003d\u003d 0) {\n            return 1;\n          }\nLAB_0000654a:\n          if (((*param_2 \u0026 0x10) \u003d\u003d 0) \u0026\u0026 (param_2[3] \u003d param_2[3] + 1, param_2[6] !\u003d 0)) {\n            *unaff_r6 \u003d 0;\n          }\n          param_2[4] \u003d iVar6 + param_2[4];\n          return 0;\n        }\n      }\n      else if ((uVar2 !\u003d 2) || ((int)((uint)(byte)(\u0026DAT_00007a99)[**param_3] \u003c\u003c 0x1c) \u003c 0))\n      goto LAB_0000654a;\n    }\n    pbVar5 \u003d unaff_r6;\n    if (-1 \u003c (int)(*param_2 \u003c\u003c 0x1b)) {\n      pbVar5 \u003d unaff_r6 + 1;\n      *unaff_r6 \u003d **param_3;\n    }\n    pbVar4 \u003d param_3[1];\n    *param_3 \u003d *param_3 + 1;\n    uVar2 \u003d param_2[2] - 1;\n    param_3[1] \u003d pbVar4 + -1;\n    iVar6 \u003d iVar6 + 1;\n    param_2[2] \u003d uVar2;\n    unaff_r6 \u003d pbVar5;\n    if ((uVar2 \u003d\u003d 0) ||\n       (((int)(pbVar4 + -1) \u003c 1 \u0026\u0026\n        (iVar1 \u003d (*(code *)param_2[0x60])(param_1,param_3,uVar2,(code *)param_2[0x60],param_4),\n        iVar1 !\u003d 0)))) goto LAB_0000654a;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000061cc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000656c": {
      "entrypoint": "0x0000656c",
      "current_name": "FUN_0000656c",
      "code": "\nundefined4 FUN_0000656c(undefined4 param_1,uint *param_2,byte **param_3,undefined4 *param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  code *pcVar3;\n  uint uVar4;\n  byte *pbVar5;\n  uint uVar6;\n  undefined4 *puVar7;\n  uint *puVar8;\n  uint *puVar9;\n  uint *puVar10;\n  int unaff_r9;\n  int iVar11;\n  undefined *local_34 [4];\n  \n  local_34[0] \u003d \u0026DAT_00007c2f;\n  local_34[1] \u003d \u0026DAT_00007c32;\n  local_34[2] \u003d \u0026DAT_00007c35;\n  pcVar3 \u003d (code *)\u0026UNK_00004f81;\n  if (param_2[6] !\u003d 3) {\n    pcVar3 \u003d (code *)\u0026UNK_00005fd5;\n  }\n  uVar6 \u003d param_2[2];\n  uVar4 \u003d uVar6 - 1;\n  if (0x15c \u003c uVar4) {\n    unaff_r9 \u003d uVar6 - 0x15d;\n    uVar6 \u003d 0x15d;\n  }\n  if (0x15c \u003c uVar4) {\n    param_2[2] \u003d uVar6;\n  }\n  puVar10 \u003d param_2 + 7;\n  if (uVar4 \u003c 0x15d) {\n    unaff_r9 \u003d 0;\n  }\n  *param_2 \u003d *param_2 | 0xd00;\n  iVar11 \u003d 0;\n  puVar9 \u003d puVar10;\n  do {\n    iVar1 \u003d memchr(local_34[iVar11],**param_3,2);\n    if (iVar1 !\u003d 0) {\n      if (iVar11 \u003d\u003d 1) {\n        if (param_2[1] \u003d\u003d 0) {\n          param_2[1] \u003d 8;\n          *param_2 \u003d *param_2 | 0x200;\n        }\n        uVar4 \u003d *param_2 \u0026 0xfffffaff;\nLAB_000065f4:\n        *param_2 \u003d uVar4;\n      }\n      else if (iVar11 \u003d\u003d 2) {\n        if ((*param_2 \u0026 0x600) !\u003d 0x200) goto LAB_00006624;\n        param_2[1] \u003d 0x10;\n        uVar4 \u003d *param_2 | 0x100;\n        goto LAB_000065f4;\n      }\n      uVar4 \u003d param_2[2];\n      param_2[2] \u003d uVar4 - 1;\n      if (uVar4 !\u003d 0) {\n        pbVar5 \u003d *param_3;\n        *param_3 \u003d pbVar5 + 1;\n        puVar8 \u003d (uint *)((int)puVar9 + 1);\n        *(byte *)puVar9 \u003d *pbVar5;\n        pbVar5 \u003d param_3[1];\n        param_3[1] \u003d pbVar5 + -1;\n        puVar9 \u003d puVar8;\n        if (((int)(pbVar5 + -1) \u003c 1) \u0026\u0026\n           (iVar1 \u003d (*(code *)param_2[0x60])(param_1,param_3), iVar1 !\u003d 0)) {\n          iVar11 \u003d 0;\n          goto LAB_000066ca;\n        }\n      }\n    }\nLAB_00006624:\n    iVar11 \u003d iVar11 + 1;\n  } while (iVar11 !\u003d 3);\n  if (param_2[1] \u003d\u003d 0) {\n    param_2[1] \u003d 10;\n  }\n  __sccl(param_2[5],\"01234567]\" + (8 - param_2[1]));\n  iVar11 \u003d 0;\n  while( true ) {\n    puVar8 \u003d puVar9;\n    if (param_2[2] \u003d\u003d 0) break;\n    pbVar5 \u003d *param_3;\n    uVar4 \u003d (uint)*pbVar5;\n    if (*(char *)(param_2[5] + uVar4) \u003d\u003d \u0027\\0\u0027) break;\n    if ((uVar4 \u003d\u003d 0x30) \u0026\u0026 ((int)(*param_2 \u003c\u003c 0x14) \u003c 0)) {\n      iVar11 \u003d iVar11 + 1;\n      if (unaff_r9 !\u003d 0) {\n        unaff_r9 \u003d unaff_r9 + -1;\n        param_2[2] \u003d param_2[2] + 1;\n      }\n    }\n    else {\n      *param_2 \u003d *param_2 \u0026 0xfffff6ff;\n      puVar8 \u003d (uint *)((int)puVar9 + 1);\n      *(byte *)puVar9 \u003d *pbVar5;\n    }\n    pbVar5 \u003d param_3[1];\n    param_3[1] \u003d pbVar5 + -1;\n    if ((int)(pbVar5 + -1) \u003c 1) {\n      iVar1 \u003d (*(code *)param_2[0x60])(param_1,param_3);\n      if (iVar1 !\u003d 0) break;\n    }\n    else {\n      *param_3 \u003d *param_3 + 1;\n    }\n    param_2[2] \u003d param_2[2] - 1;\n    puVar9 \u003d puVar8;\n  }\nLAB_000066ca:\n  if ((int)(*param_2 \u003c\u003c 0x17) \u003c 0) {\n    if (puVar10 \u003c puVar8) {\n      (*(code *)param_2[0x5f])(param_1,*(byte *)((int)puVar8 + -1),param_3);\n      puVar8 \u003d (uint *)((int)puVar8 + -1);\n    }\n    if (puVar8 \u003d\u003d puVar10) {\n      return 1;\n    }\n  }\n  if ((*param_2 \u0026 0x10) \u003d\u003d 0) {\n    *(byte *)puVar8 \u003d 0;\n    uVar2 \u003d (*pcVar3)(param_1,puVar10,0,param_2[1]);\n    puVar7 \u003d (undefined4 *)*param_4;\n    uVar4 \u003d *param_2;\n    *param_4 \u003d puVar7 + 1;\n    puVar7 \u003d (undefined4 *)*puVar7;\n    if ((uVar4 \u0026 0x20) \u003d\u003d 0) {\n      if ((int)(uVar4 \u003c\u003c 0x1f) \u003c 0) {\n        *(short *)puVar7 \u003d (short)uVar2;\n      }\n      else {\n        *puVar7 \u003d uVar2;\n      }\n    }\n    else {\n      *puVar7 \u003d uVar2;\n    }\n    param_2[3] \u003d param_2[3] + 1;\n  }\n  param_2[4] \u003d (uint)((int)puVar8 + param_2[4] + (iVar11 - (int)puVar10));\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000061cc"
      ],
      "called": [
        "FUN_0000687c",
        "FUN_00006010"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00006768": {
      "entrypoint": "0x00006768",
      "current_name": "FUN_00006768",
      "code": "\nundefined4\nFUN_00006768(undefined4 *param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined2 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  ushort uVar4;\n  uint uVar5;\n  \n  if ((param_1 !\u003d (undefined4 *)0x0) \u0026\u0026 (param_1[6] \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (param_2 \u003d\u003d \u0026DAT_000079b8) {\n    param_2 \u003d (undefined4 *)param_1[1];\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026DAT_000079d8) {\n    param_2 \u003d (undefined4 *)param_1[2];\n  }\n  else if (param_2 \u003d\u003d (undefined4 *)\u0026DAT_00007998) {\n    param_2 \u003d (undefined4 *)param_1[3];\n  }\n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  param_2[1] \u003d 0;\n  uVar5 \u003d (uint)*(ushort *)(param_2 + 3);\n  if ((int)(uVar5 \u003c\u003c 0x1a) \u003c 0) {\n    return 0xffffffff;\n  }\n  if ((int)(uVar5 \u003c\u003c 0x1d) \u003c 0) {\n    if ((undefined4 *)param_2[0xd] !\u003d (undefined4 *)0x0) {\n      if ((undefined4 *)param_2[0xd] !\u003d param_2 + 0x11) {\n        _free_r(param_1);\n      }\n      param_2[1] \u003d param_2[0x10];\n      param_2[0xd] \u003d 0;\n      if (param_2[0x10] !\u003d 0) {\n        *param_2 \u003d param_2[0xf];\n        return 0;\n      }\n    }\n  }\n  else {\n    if (-1 \u003c (int)(uVar5 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      uVar4 \u003d uVar4 | 0x40;\n      goto LAB_000067b8;\n    }\n    if ((int)(uVar5 \u003c\u003c 0x1c) \u003c 0) {\n      iVar2 \u003d _fflush_r(param_1,param_2,uVar5 \u003c\u003c 0x1c,uVar5,param_4);\n      if (iVar2 !\u003d 0) {\n        return 0xffffffff;\n      }\n      param_2[2] \u003d 0;\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfff7;\n      param_2[6] \u003d 0;\n    }\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 4;\n  }\n  if (param_2[4] \u003d\u003d 0) {\n    __smakebuf_r(param_1,param_2);\n  }\n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar1 \u003d *(undefined2 *)(param_2 + 3);\n  if ((uVar4 \u0026 3) !\u003d 0) {\n    *(undefined2 *)(param_2 + 3) \u003d 1;\n    _fwalk(0x1fff0284,\u0026LAB_00006754_1);\n    *(undefined2 *)(param_2 + 3) \u003d uVar1;\n    if ((uVar4 \u0026 9) \u003d\u003d 9) {\n      __sflush_r(param_1,param_2);\n    }\n  }\n  uVar3 \u003d param_2[4];\n  *param_2 \u003d uVar3;\n  iVar2 \u003d (*(code *)param_2[9])(param_1,param_2[8],uVar3,param_2[5]);\n  param_2[1] \u003d iVar2;\n  if (0 \u003c iVar2) {\n    return 0;\n  }\n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  if (iVar2 !\u003d 0) {\n    uVar3 \u003d 0;\n  }\n  else {\n    uVar4 \u003d uVar4 | 0x20;\n  }\n  if (iVar2 !\u003d 0) {\n    param_2[1] \u003d uVar3;\n    uVar4 \u003d uVar4 | 0x40;\n  }\nLAB_000067b8:\n  *(ushort *)(param_2 + 3) \u003d uVar4;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00005e10"
      ],
      "called": [
        "FUN_00004158",
        "FUN_000043a0",
        "FUN_00005700",
        "FUN_00004b34",
        "FUN_0000404c",
        "FUN_000042a4"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0000687c": {
      "entrypoint": "0x0000687c",
      "current_name": "FUN_0000687c",
      "code": "\nbyte * FUN_0000687c(int param_1,byte *param_2)\n\n{\n  byte *pbVar1;\n  uint uVar2;\n  int iVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  bool bVar7;\n  \n  uVar4 \u003d (uint)*param_2;\n  bVar7 \u003d uVar4 \u003d\u003d 0x5e;\n  if (bVar7) {\n    uVar4 \u003d (uint)param_2[1];\n    param_2 \u003d param_2 + 2;\n  }\n  else {\n    param_2 \u003d param_2 + 1;\n  }\n  iVar3 \u003d param_1 + -1;\n  do {\n    iVar3 \u003d iVar3 + 1;\n    *(bool *)iVar3 \u003d bVar7;\n  } while (iVar3 !\u003d param_1 + 0xff);\n  if (uVar4 \u003d\u003d 0) {\n    pbVar1 \u003d param_2 + -1;\n  }\n  else {\nLAB_000068aa:\n    do {\n      uVar5 \u003d uVar4;\n      *(bool *)(param_1 + uVar5) \u003d !bVar7;\n      param_2 \u003d param_2 + 1;\n      while( true ) {\n        uVar4 \u003d (uint)param_2[-1];\n        if (uVar4 !\u003d 0x2d) break;\n        uVar6 \u003d (uint)*param_2;\n        if ((uVar6 \u003d\u003d 0x5d) || (uVar2 \u003d uVar5, (int)uVar6 \u003c (int)uVar5)) goto LAB_000068aa;\n        do {\n          uVar2 \u003d uVar2 + 1;\n          *(bool *)(param_1 + uVar2) \u003d !bVar7;\n        } while ((int)uVar2 \u003c (int)uVar6);\n        iVar3 \u003d ~uVar5 + uVar6;\n        if ((int)uVar6 \u003c\u003d (int)uVar5) {\n          iVar3 \u003d 0;\n        }\n        uVar5 \u003d uVar5 + 1 + iVar3;\n        param_2 \u003d param_2 + 2;\n      }\n      pbVar1 \u003d param_2;\n    } while ((uVar4 !\u003d 0x5d) \u0026\u0026 (pbVar1 \u003d param_2 + -1, uVar4 !\u003d 0));\n  }\n  return pbVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000061cc",
        "FUN_0000656c"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_000068f0": {
      "entrypoint": "0x000068f0",
      "current_name": "FUN_000068f0",
      "code": "\nundefined4 FUN_000068f0(undefined4 param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  \n  if ((int *)param_2[0xd] \u003d\u003d param_2 + 0x11) {\n    iVar1 \u003d _malloc_r(param_1,0x400);\n    if (iVar1 !\u003d 0) {\n      param_2[0xe] \u003d 0x400;\n      param_2[0xd] \u003d iVar1;\n      *(undefined *)(iVar1 + 0x3ff) \u003d *(undefined *)((int)param_2 + 0x46);\n      *(undefined *)(iVar1 + 0x3fe) \u003d *(undefined *)((int)param_2 + 0x45);\n      *(undefined *)(iVar1 + 0x3fd) \u003d *(undefined *)(param_2 + 0x11);\n      *param_2 \u003d iVar1 + 0x3fd;\n      return 0;\n    }\n  }\n  else {\n    iVar2 \u003d param_2[0xe];\n    iVar1 \u003d _realloc_r(param_1,(int *)param_2[0xd],iVar2 \u003c\u003c 1);\n    if (iVar1 !\u003d 0) {\n      memcpy(iVar1 + iVar2,iVar1,iVar2);\n      param_2[0xd] \u003d iVar1;\n      param_2[0xe] \u003d iVar2 \u003c\u003c 1;\n      *param_2 \u003d iVar1 + iVar2;\n      return 0;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00004bd0",
        "FUN_000060b0",
        "FUN_000060cc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00006964": {
      "entrypoint": "0x00006964",
      "current_name": "FUN_00006964",
      "code": "\nint FUN_00006964(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d *(int *)(param_2 + -4) + -4;\n  if (*(int *)(param_2 + -4) \u003c 0) {\n    iVar1 \u003d iVar1 + *(int *)(param_2 + iVar1);\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_000060cc"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00006974": {
      "entrypoint": "0x00006974",
      "current_name": "FUN_00006974",
      "code": "\nundefined8 FUN_00006974(int param_1,int param_2,int param_3,int param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined local_8 [8];\n  \n  if ((param_4 \u003d\u003d 0) \u0026\u0026 (param_3 \u003d\u003d 0)) {\n    if (param_2 \u003c 0) {\n      param_1 \u003d 0;\n      param_2 \u003d -0x80000000;\n    }\n    else if (param_2 !\u003d 0 || param_1 !\u003d 0) {\n      param_2 \u003d 0x7fffffff;\n      param_1 \u003d -1;\n    }\n    return CONCAT44(param_2,param_1);\n  }\n  if (param_2 \u003c 0) {\n    iVar1 \u003d -param_2 - (uint)(param_1 !\u003d 0);\n    if (param_4 \u003c 0) {\n      uVar2 \u003d __udivmoddi4(-param_1,iVar1,-param_3,-param_4 - (uint)(param_3 !\u003d 0),local_8);\n      return uVar2;\n    }\n    uVar2 \u003d __udivmoddi4(-param_1,iVar1,param_3,param_4,local_8);\n    return CONCAT44(-(int)((ulonglong)uVar2 \u003e\u003e 0x20) - (uint)((int)uVar2 !\u003d 0),-(int)uVar2);\n  }\n  if (param_4 \u003c 0) {\n    uVar2 \u003d __udivmoddi4(param_1,param_2,-param_3,-param_4 - (uint)(param_3 !\u003d 0),local_8);\n    return CONCAT44(-(int)((ulonglong)uVar2 \u003e\u003e 0x20) - (uint)((int)uVar2 !\u003d 0),-(int)uVar2);\n  }\n  uVar2 \u003d __udivmoddi4();\n  return uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0000443c"
      ],
      "called": [
        "FUN_00006a14"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00006a14": {
      "entrypoint": "0x00006a14",
      "current_name": "FUN_00006a14",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00006ca0) */\n\nulonglong FUN_00006a14(uint param_1,uint param_2,uint param_3,uint param_4,uint *param_5)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  uint uVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  bool bVar10;\n  ulonglong uVar11;\n  \n  if (param_4 \u003d\u003d 0) {\n    if (param_2 \u003c param_3) {\n      iVar2 \u003d LZCOUNT(param_3);\n      uVar5 \u003d param_3;\n      if (iVar2 !\u003d 0) {\n        uVar5 \u003d param_3 \u003c\u003c iVar2;\n        param_2 \u003d param_1 \u003e\u003e (0x20U - iVar2 \u0026 0xff) | param_2 \u003c\u003c iVar2;\n        param_1 \u003d param_1 \u003c\u003c iVar2;\n      }\n      uVar6 \u003d uVar5 \u003e\u003e 0x10;\n      uVar8 \u003d param_2 / uVar6;\n      uVar3 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar6 * uVar8) * 0x10000;\n      uVar1 \u003d uVar8 * (uVar5 \u0026 0xffff);\n      uVar4 \u003d uVar8;\n      if (uVar3 \u003c\u003d uVar1 \u0026\u0026 uVar1 - uVar3 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar5,uVar3);\n        uVar3 \u003d uVar5 + uVar3;\n        uVar4 \u003d uVar8 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar3 \u003c\u003d uVar1 \u0026\u0026 uVar1 - uVar3 !\u003d 0)) {\n          uVar4 \u003d uVar8 - 2;\n          uVar3 \u003d uVar3 + uVar5;\n        }\n      }\n      uVar8 \u003d (uVar3 - uVar1) / uVar6;\n      uVar6 \u003d param_1 \u0026 0xffff | ((uVar3 - uVar1) - uVar6 * uVar8) * 0x10000;\n      uVar3 \u003d uVar8 * (uVar5 \u0026 0xffff);\n      uVar1 \u003d uVar8;\n      if (uVar6 \u003c\u003d uVar3 \u0026\u0026 uVar3 - uVar6 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar5,uVar6);\n        uVar6 \u003d uVar5 + uVar6;\n        uVar1 \u003d uVar8 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar3 \u0026\u0026 uVar3 - uVar6 !\u003d 0)) {\n          uVar1 \u003d uVar8 - 2;\n          uVar6 \u003d uVar6 + uVar5;\n        }\n      }\n      uVar6 \u003d uVar6 - uVar3;\n      uVar1 \u003d uVar1 | uVar4 \u003c\u003c 0x10;\n      uVar5 \u003d 0;\n    }\n    else {\n      if (param_3 \u003d\u003d 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE \u003d (code *)software_udf(0xff,0x6abc);\n        uVar11 \u003d (*UNRECOVERED_JUMPTABLE)();\n        return uVar11;\n      }\n      iVar2 \u003d LZCOUNT(param_3);\n      if (iVar2 \u003d\u003d 0) {\n        param_2 \u003d param_2 - param_3;\n        uVar9 \u003d param_3 \u003e\u003e 0x10;\n        uVar7 \u003d param_3 \u0026 0xffff;\n        uVar5 \u003d 1;\n        uVar4 \u003d param_3;\n      }\n      else {\n        uVar4 \u003d param_3 \u003c\u003c iVar2;\n        uVar9 \u003d uVar4 \u003e\u003e 0x10;\n        uVar1 \u003d param_2 \u003e\u003e (0x20U - iVar2 \u0026 0xff);\n        uVar5 \u003d param_1 \u003e\u003e (0x20U - iVar2 \u0026 0xff) | param_2 \u003c\u003c iVar2;\n        uVar3 \u003d uVar1 / uVar9;\n        uVar7 \u003d uVar4 \u0026 0xffff;\n        uVar8 \u003d uVar5 \u003e\u003e 0x10 | (uVar1 - uVar9 * uVar3) * 0x10000;\n        uVar6 \u003d uVar3 * uVar7;\n        param_1 \u003d param_1 \u003c\u003c iVar2;\n        uVar1 \u003d uVar3;\n        if (uVar8 \u003c\u003d uVar6 \u0026\u0026 uVar6 - uVar8 !\u003d 0) {\n          bVar10 \u003d CARRY4(uVar4,uVar8);\n          uVar8 \u003d uVar4 + uVar8;\n          uVar1 \u003d uVar3 - 1;\n          if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar8 \u003c\u003d uVar6 \u0026\u0026 uVar6 - uVar8 !\u003d 0)) {\n            uVar1 \u003d uVar3 - 2;\n            uVar8 \u003d uVar8 + uVar4;\n          }\n        }\n        uVar3 \u003d (uVar8 - uVar6) / uVar9;\n        param_2 \u003d uVar5 \u0026 0xffff | ((uVar8 - uVar6) - uVar9 * uVar3) * 0x10000;\n        uVar6 \u003d uVar3 * uVar7;\n        uVar5 \u003d uVar3;\n        if (param_2 \u003c\u003d uVar6 \u0026\u0026 uVar6 - param_2 !\u003d 0) {\n          bVar10 \u003d CARRY4(uVar4,param_2);\n          param_2 \u003d uVar4 + param_2;\n          uVar5 \u003d uVar3 - 1;\n          if ((bVar10 \u003d\u003d false) \u0026\u0026 (param_2 \u003c\u003d uVar6 \u0026\u0026 uVar6 - param_2 !\u003d 0)) {\n            uVar5 \u003d uVar3 - 2;\n            param_2 \u003d param_2 + uVar4;\n          }\n        }\n        param_2 \u003d param_2 - uVar6;\n        uVar5 \u003d uVar5 | uVar1 \u003c\u003c 0x10;\n      }\n      uVar8 \u003d param_2 / uVar9;\n      uVar6 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar9 * uVar8) * 0x10000;\n      uVar1 \u003d uVar7 * uVar8;\n      uVar3 \u003d uVar8;\n      if (uVar6 \u003c\u003d uVar1 \u0026\u0026 uVar1 - uVar6 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar4,uVar6);\n        uVar6 \u003d uVar4 + uVar6;\n        uVar3 \u003d uVar8 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar1 \u0026\u0026 uVar1 - uVar6 !\u003d 0)) {\n          uVar3 \u003d uVar8 - 2;\n          uVar6 \u003d uVar6 + uVar4;\n        }\n      }\n      uVar8 \u003d (uVar6 - uVar1) / uVar9;\n      uVar6 \u003d param_1 \u0026 0xffff | ((uVar6 - uVar1) - uVar9 * uVar8) * 0x10000;\n      uVar7 \u003d uVar7 * uVar8;\n      uVar1 \u003d uVar8;\n      if (uVar6 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar6 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar4,uVar6);\n        uVar6 \u003d uVar4 + uVar6;\n        uVar1 \u003d uVar8 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar6 !\u003d 0)) {\n          uVar1 \u003d uVar8 - 2;\n          uVar6 \u003d uVar6 + uVar4;\n        }\n      }\n      uVar6 \u003d uVar6 - uVar7;\n      uVar1 \u003d uVar1 | uVar3 \u003c\u003c 0x10;\n    }\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d uVar6 \u003e\u003e LZCOUNT(param_3);\n      param_5[1] \u003d 0;\n    }\n  }\n  else if (param_2 \u003c param_4) {\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d param_1;\n      param_5[1] \u003d param_2;\n      return 0;\n    }\n    uVar1 \u003d 0;\n    uVar5 \u003d 0;\n  }\n  else {\n    iVar2 \u003d LZCOUNT(param_4);\n    if (iVar2 !\u003d 0) {\n      uVar7 \u003d 0x20 - iVar2;\n      uVar3 \u003d param_3 \u003e\u003e (uVar7 \u0026 0xff) | param_4 \u003c\u003c iVar2;\n      uVar9 \u003d uVar3 \u003e\u003e 0x10;\n      uVar1 \u003d param_2 \u003e\u003e (uVar7 \u0026 0xff);\n      uVar5 \u003d param_1 \u003e\u003e (uVar7 \u0026 0xff) | param_2 \u003c\u003c iVar2;\n      uVar6 \u003d uVar1 / uVar9;\n      uVar4 \u003d uVar5 \u003e\u003e 0x10 | (uVar1 - uVar9 * uVar6) * 0x10000;\n      uVar8 \u003d uVar6 * (uVar3 \u0026 0xffff);\n      param_1 \u003d param_1 \u003c\u003c iVar2;\n      uVar1 \u003d uVar6;\n      if (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar3,uVar4);\n        uVar4 \u003d uVar3 + uVar4;\n        uVar1 \u003d uVar6 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0)) {\n          uVar1 \u003d uVar6 - 2;\n          uVar4 \u003d uVar4 + uVar3;\n        }\n      }\n      uVar6 \u003d (uVar4 - uVar8) / uVar9;\n      uVar4 \u003d uVar5 \u0026 0xffff | ((uVar4 - uVar8) - uVar9 * uVar6) * 0x10000;\n      uVar8 \u003d uVar6 * (uVar3 \u0026 0xffff);\n      uVar5 \u003d uVar6;\n      if (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0) {\n        bVar10 \u003d CARRY4(uVar3,uVar4);\n        uVar4 \u003d uVar3 + uVar4;\n        uVar5 \u003d uVar6 - 1;\n        if ((bVar10 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0)) {\n          uVar5 \u003d uVar6 - 2;\n          uVar4 \u003d uVar4 + uVar3;\n        }\n      }\n      uVar5 \u003d uVar5 | uVar1 \u003c\u003c 0x10;\n      uVar11 \u003d (ulonglong)uVar5 * (ulonglong)(param_3 \u003c\u003c iVar2);\n      if (CONCAT44(uVar4 - uVar8,param_1) \u003c uVar11) {\n        uVar11 \u003d uVar11 - CONCAT44(uVar3,param_3 \u003c\u003c iVar2);\n        uVar5 \u003d uVar5 - 1;\n      }\n      if (param_5 !\u003d (uint *)0x0) {\n        uVar1 \u003d ((uVar4 - uVar8) - (int)(uVar11 \u003e\u003e 0x20)) - (uint)(param_1 \u003c (uint)uVar11);\n        *param_5 \u003d uVar1 \u003c\u003c (uVar7 \u0026 0xff) | param_1 - (uint)uVar11 \u003e\u003e iVar2;\n        param_5[1] \u003d uVar1 \u003e\u003e iVar2;\n      }\n      return (ulonglong)uVar5;\n    }\n    if ((param_4 \u003c param_2) || (param_3 \u003c\u003d param_1)) {\n      bVar10 \u003d param_1 \u003c param_3;\n      param_1 \u003d param_1 - param_3;\n      param_2 \u003d (param_2 - param_4) - (uint)bVar10;\n      uVar1 \u003d 1;\n    }\n    else {\n      uVar1 \u003d 0;\n    }\n    uVar5 \u003d 0;\n    if (param_5 !\u003d (uint *)0x0) {\n      *param_5 \u003d param_1;\n      param_5[1] \u003d param_2;\n    }\n  }\n  return CONCAT44(uVar5,uVar1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00006974"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}