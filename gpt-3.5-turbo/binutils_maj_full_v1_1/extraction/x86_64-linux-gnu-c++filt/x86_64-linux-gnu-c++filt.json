{
  "functions": {
    "_DT_INIT": {
      "entrypoint": "0x00102000",
      "current_name": "_DT_INIT",
      "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__gmon_start__"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102020": {
      "entrypoint": "0x00102020",
      "current_name": "FUN_00102020",
      "code": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle_name_to_style": {
      "entrypoint": "0x00102030",
      "current_name": "cplus_demangle_name_to_style",
      "code": "\nvoid cplus_demangle_name_to_style(void)\n\n{\n  cplus_demangle_name_to_style();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "cplus_demangle_name_to_style"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x00102040",
      "current_name": "free",
      "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0",
        "FUN_00102380"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ferror": {
      "entrypoint": "0x00102050",
      "current_name": "ferror",
      "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d ferror(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "ferror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fread": {
      "entrypoint": "0x00102060",
      "current_name": "fread",
      "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "fread"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle_set_style": {
      "entrypoint": "0x00102070",
      "current_name": "cplus_demangle_set_style",
      "code": "\nvoid cplus_demangle_set_style(void)\n\n{\n  cplus_demangle_set_style();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "cplus_demangle_set_style"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x00102080",
      "current_name": "fclose",
      "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fclose(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "fclose"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dcgettext": {
      "entrypoint": "0x00102090",
      "current_name": "dcgettext",
      "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0",
        "FUN_0010225e"
      ],
      "called": [
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x001020a0",
      "current_name": "strlen",
      "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d strlen(__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getopt_long": {
      "entrypoint": "0x001020b0",
      "current_name": "getopt_long",
      "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "getopt_long"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strchr": {
      "entrypoint": "0x001020c0",
      "current_name": "strchr",
      "code": "\n\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strchr(__s,__c);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "strchr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printf": {
      "entrypoint": "0x001020d0",
      "current_name": "printf",
      "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d printf(__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0",
        "FUN_00102380"
      ],
      "called": [
        "printf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xrealloc": {
      "entrypoint": "0x001020e0",
      "current_name": "xrealloc",
      "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "xrealloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc": {
      "entrypoint": "0x001020f0",
      "current_name": "xmalloc",
      "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc_set_program_name": {
      "entrypoint": "0x00102100",
      "current_name": "xmalloc_set_program_name",
      "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "xmalloc_set_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xstrdup": {
      "entrypoint": "0x00102110",
      "current_name": "xstrdup",
      "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "xstrdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fputc": {
      "entrypoint": "0x00102120",
      "current_name": "fputc",
      "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fputc(__c,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010225e"
      ],
      "called": [
        "fputc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "putc": {
      "entrypoint": "0x00102130",
      "current_name": "putc",
      "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d putc(__c,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0",
        "FUN_00102380",
        "FUN_00102e20"
      ],
      "called": [
        "putc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fprintf": {
      "entrypoint": "0x00102140",
      "current_name": "fprintf",
      "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0",
        "FUN_0010225e",
        "FUN_00102e20"
      ],
      "called": [
        "fprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ftell": {
      "entrypoint": "0x00102150",
      "current_name": "ftell",
      "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d ftell(__stream);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "ftell"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stat": {
      "entrypoint": "0x00102160",
      "current_name": "stat",
      "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d stat(__file,__buf);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "stat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x00102170",
      "current_name": "memcpy",
      "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "memcpy"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fflush": {
      "entrypoint": "0x00102180",
      "current_name": "fflush",
      "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fflush(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0",
        "FUN_00102e20"
      ],
      "called": [
        "fflush"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fseek": {
      "entrypoint": "0x00102190",
      "current_name": "fseek",
      "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "fseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle": {
      "entrypoint": "0x001021a0",
      "current_name": "cplus_demangle",
      "code": "\nvoid cplus_demangle(void)\n\n{\n  cplus_demangle();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102380"
      ],
      "called": [
        "cplus_demangle"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_error_program_name": {
      "entrypoint": "0x001021b0",
      "current_name": "bfd_set_error_program_name",
      "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "bfd_set_error_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x001021c0",
      "current_name": "memmove",
      "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "memmove"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fopen": {
      "entrypoint": "0x001021d0",
      "current_name": "fopen",
      "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 \u003d fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "fopen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xexit": {
      "entrypoint": "0x001021e0",
      "current_name": "xexit",
      "code": "\nvoid xexit(void)\n\n{\n  xexit();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0",
        "FUN_00102e20"
      ],
      "called": [
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "exit": {
      "entrypoint": "0x001021f0",
      "current_name": "exit",
      "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0",
        "FUN_0010225e"
      ],
      "called": [
        "exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fwrite": {
      "entrypoint": "0x00102200",
      "current_name": "fwrite",
      "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010225e",
        "FUN_00102e20"
      ],
      "called": [
        "fwrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getc": {
      "entrypoint": "0x00102210",
      "current_name": "getc",
      "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d getc(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "getc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_finalize": {
      "entrypoint": "0x00102220",
      "current_name": "__cxa_finalize",
      "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "__cxa_finalize"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102230": {
      "entrypoint": "0x00102230",
      "current_name": "FUN_00102230",
      "code": "\n\n\nvoid FUN_00102230(ulong param_1)\n\n{\n  byte in_AL;\n  void *__ptr;\n  char *unaff_RBX;\n  \n  if (unaff_RBX[in_AL] \u003d\u003d \u0027_\u0027) {\n    param_1 \u003d (ulong)((int)param_1 + 1);\n  }\n  __ptr \u003d (void *)cplus_demangle(unaff_RBX + param_1,DAT_00105108);\n  if (__ptr !\u003d (void *)0x0) {\n    if (*unaff_RBX \u003d\u003d \u0027.\u0027) {\n      putc(0x2e,_stdout);\n    }\n    printf(\"%s\",__ptr);\n    free(__ptr);\n    return;\n  }\n  printf(\"%s\");\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102380"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010225e": {
      "entrypoint": "0x0010225e",
      "current_name": "FUN_0010225e",
      "code": "\n\n\nvoid FUN_0010225e(FILE *param_1,int param_2)\n\n{\n  char *__format;\n  undefined8 *puVar1;\n  \n  fprintf(param_1,\"Usage: %s [options] [mangled names]\\n\",DAT_0010d148);\n  fprintf(param_1,\"Options are:\\n  [-_|--strip-underscore]     Ignore first leading underscore%s\\n\",\n          \"\");\n  fprintf(param_1,\"  [-n|--no-strip-underscore]  Do not ignore a leading underscore%s\\n\",\n          \" (default)\");\n  fwrite(\"  [-p|--no-params]            Do not display function arguments\\n  [-i|--no-verbose]           Do not show implementation details (if any)\\n  [-R|--recurse-limit]        Enable a limit on recursion whilst demangling.  [Default]\\n  ]-r|--no-recurse-limit]     Disable a limit on recursion whilst demangling\\n  [-t|--types]                Also attempt to demangle type encodings\\n  [-s|--format \"\n         ,1,0x184,param_1);\n  fprintf(param_1,\"{%s\",_libiberty_demanglers);\n  puVar1 \u003d (undefined8 *)\u0026libiberty_demanglers;\n  while (*(int *)(puVar1 + 4) !\u003d 0) {\n    fprintf(param_1,\",%s\",puVar1[3]);\n    puVar1 \u003d puVar1 + 3;\n  }\n  fputc(0x7d,param_1);\n  fwrite(\u0026DAT_001035e8,1,2,param_1);\n  fwrite(\"  [@\u003cfile\u003e]                   Read extra options from \u003cfile\u003e\\n  [-h|--help]                 Display this information\\n  [-v|--version]              Show the version information\\nDemangled names are displayed to stdout.\\nIf a name cannot be demangled it is just echoed to stdout.\\nIf no names are provided on the command line, stdin is read.\\n\"\n         ,1,0x150,param_1);\n  if (param_2 \u003d\u003d 0) {\n    __format \u003d (char *)dcgettext(0,\"Report bugs to %s.\\n\",5);\n    fprintf(param_1,__format,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n                    \n  exit(param_2);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "exit",
        "memmove",
        "fputc",
        "dcgettext",
        "fprintf",
        "fwrite",
        "bfd_set_error_program_name",
        "exit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102380": {
      "entrypoint": "0x00102380",
      "current_name": "FUN_00102380",
      "code": "\n\n\nvoid FUN_00102380(char *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  uint uVar1;\n  void *__ptr;\n  ulong uVar2;\n  \n  uVar1 \u003d (uint)(*param_1 \u003d\u003d \u0027.\u0027 || *param_1 \u003d\u003d \u0027$\u0027);\n  uVar2 \u003d (ulong)uVar1;\n  if ((_DAT_0010d140 !\u003d 0) \u0026\u0026 (param_1[uVar1] \u003d\u003d \u0027_\u0027)) {\n    uVar2 \u003d (ulong)(uVar1 + 1);\n  }\n  __ptr \u003d (void *)cplus_demangle(param_1 + uVar2,DAT_00105108);\n  if (__ptr !\u003d (void *)0x0) {\n    if (*param_1 \u003d\u003d \u0027.\u0027) {\n      putc(0x2e,_stdout);\n    }\n    printf(\"%s\",__ptr);\n    free(__ptr);\n    return;\n  }\n  printf(\"%s\",param_1,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "printf",
        "putc",
        "FUN_00102230",
        "free",
        "cplus_demangle"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "entry": {
      "entrypoint": "0x00102400",
      "current_name": "entry",
      "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_001024f0,param_2,\u0026stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_001024f0",
        "__libc_start_main"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102430": {
      "entrypoint": "0x00102430",
      "current_name": "FUN_00102430",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00102443) */\n/* WARNING: Removing unreachable block (ram,0x0010244f) */\n\nvoid FUN_00102430(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "_ITM_deregisterTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102460": {
      "entrypoint": "0x00102460",
      "current_name": "FUN_00102460",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00102484) */\n/* WARNING: Removing unreachable block (ram,0x00102490) */\n\nvoid FUN_00102460(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_INIT_0"
      ],
      "called": [
        "_ITM_registerTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_FINI_0": {
      "entrypoint": "0x001024a0",
      "current_name": "_FINI_0",
      "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_00105120 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_00105100);\n  FUN_00102430();\n  DAT_00105120 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00102430",
        "__cxa_finalize"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_INIT_0": {
      "entrypoint": "0x001024e0",
      "current_name": "_INIT_0",
      "code": "\nvoid _INIT_0(void)\n\n{\n  FUN_00102460();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00102460"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001024f0": {
      "entrypoint": "0x001024f0",
      "current_name": "FUN_001024f0",
      "code": "\n\n\nundefined8 FUN_001024f0(int param_1,long *param_2)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  bool bVar3;\n  bool bVar4;\n  bool bVar5;\n  byte bVar6;\n  int iVar7;\n  uint uVar8;\n  int iVar9;\n  FILE *__stream;\n  size_t __n;\n  byte *__s;\n  size_t sVar10;\n  byte *__ptr;\n  long lVar11;\n  long *plVar12;\n  long *__src;\n  long *plVar13;\n  undefined8 uVar14;\n  char *pcVar15;\n  byte *pbVar16;\n  long lVar17;\n  undefined **ppuVar18;\n  long lVar19;\n  byte *pbVar20;\n  ulong unaff_R13;\n  int local_110;\n  int local_10c;\n  size_t local_108;\n  long local_100;\n  stat local_c8;\n  \n  DAT_0010d148 \u003d *param_2;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010d148);\n  plVar12 \u003d param_2;\n  if (1 \u003c param_1) {\n    local_10c \u003d 2000;\n    unaff_R13 \u003d 1;\n    local_110 \u003d 0;\n    do {\n      iVar9 \u003d (int)unaff_R13;\n      lVar17 \u003d (long)iVar9;\n      if (*(char *)plVar12[lVar17] \u003d\u003d \u0027@\u0027) {\n        local_10c \u003d local_10c + -1;\n        if (local_10c \u003d\u003d 0) goto LAB_00102bdd;\n        pcVar15 \u003d (char *)plVar12[lVar17] + 1;\n        iVar7 \u003d stat(pcVar15,\u0026local_c8);\n        if (iVar7 \u003c 0) goto LAB_00102900;\n        if ((local_c8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n          lVar17 \u003d *plVar12;\n          pcVar15 \u003d \"%s: error: @-file refers to a directory\\n\";\n          do {\n            fprintf(_stderr,pcVar15,lVar17);\n            xexit(1);\nLAB_00102bdd:\n            lVar17 \u003d *plVar12;\n            pcVar15 \u003d \"%s: error: too many @-files encountered\\n\";\n          } while( true );\n        }\n        __stream \u003d fopen(pcVar15,\"r\");\n        if (__stream \u003d\u003d (FILE *)0x0) goto LAB_00102900;\n        iVar7 \u003d fseek(__stream,0,2);\n        if (((iVar7 \u003d\u003d -1) || (__n \u003d ftell(__stream), __n \u003d\u003d 0xffffffffffffffff)) ||\n           (iVar7 \u003d fseek(__stream,0,0), iVar7 \u003d\u003d -1)) {\nLAB_001029a0:\n          fclose(__stream);\n          if (iVar9 + 1 \u003c param_1) goto LAB_0010290d;\n          break;\n        }\n        __s \u003d (byte *)xmalloc(__n + 1);\n        sVar10 \u003d fread(__s,1,__n,__stream);\n        if ((__n !\u003d sVar10) \u0026\u0026 (iVar7 \u003d ferror(__stream), iVar7 !\u003d 0)) {\n          free(__s);\n          goto LAB_001029a0;\n        }\n        __s[sVar10] \u003d 0;\n        bVar6 \u003d *__s;\n        pbVar16 \u003d __s;\n        if (bVar6 !\u003d 0) {\nLAB_00102680:\n          if (((\u0026_sch_istable)[(ulong)bVar6 * 2] \u0026 0x40) !\u003d 0) goto LAB_00102670;\n          strlen((char *)__s);\n          __ptr \u003d (byte *)xmalloc();\n          __src \u003d (long *)0x0;\n          iVar7 \u003d 0;\n          bVar3 \u003d false;\n          bVar5 \u003d false;\n          bVar4 \u003d false;\n          local_100 \u003d 0;\n          pbVar16 \u003d __s;\n          do {\n            while (((\u0026_sch_istable)[(ulong)*pbVar16 * 2] \u0026 0x40) !\u003d 0) {\n              pbVar16 \u003d pbVar16 + 1;\n            }\n            if ((iVar7 \u003d\u003d 0) || (iVar7 + -1 \u003c\u003d (int)local_100)) {\n              if (__src \u003d\u003d (long *)0x0) {\n                iVar7 \u003d 8;\n                __src \u003d (long *)xmalloc(0x40);\n              }\n              else {\n                iVar7 \u003d iVar7 * 2;\n                __src \u003d (long *)xrealloc(__src,(long)iVar7 \u003c\u003c 3);\n              }\n              plVar13 \u003d __src + local_100;\n              *plVar13 \u003d 0;\n            }\n            else {\n              plVar13 \u003d __src + local_100;\n            }\n            bVar6 \u003d *pbVar16;\n            pbVar20 \u003d __ptr;\n            while (bVar6 !\u003d 0) {\n              while( true ) {\n                if ((((\u0026_sch_istable)[(ulong)bVar6 * 2] \u0026 0x40) !\u003d 0) \u0026\u0026\n                   (!(bool)(bVar5 | bVar4 | bVar3))) {\n                  bVar4 \u003d false;\n                  bVar3 \u003d false;\n                  bVar5 \u003d false;\n                  goto LAB_0010276f;\n                }\n                if (!bVar4) break;\n                pbVar16 \u003d pbVar16 + 1;\n                *pbVar20 \u003d bVar6;\n                pbVar20 \u003d pbVar20 + 1;\n                bVar4 \u003d false;\n                bVar6 \u003d *pbVar16;\n                if (bVar6 \u003d\u003d 0) goto LAB_0010276f;\n              }\n              if (bVar6 \u003d\u003d 0x5c) {\n                bVar4 \u003d true;\n              }\n              else if (bVar5) {\n                if (bVar6 \u003d\u003d 0x27) {\n                  bVar5 \u003d false;\n                }\n                else {\nLAB_001028e1:\n                  *pbVar20 \u003d bVar6;\n                  pbVar20 \u003d pbVar20 + 1;\n                }\n              }\n              else if (bVar3) {\n                if (bVar6 !\u003d 0x22) goto LAB_001028e1;\n                bVar3 \u003d false;\n              }\n              else if (bVar6 \u003d\u003d 0x27) {\n                bVar5 \u003d true;\n              }\n              else {\n                if (bVar6 !\u003d 0x22) goto LAB_001028e1;\n                bVar3 \u003d true;\n              }\n              pbVar1 \u003d pbVar16 + 1;\n              pbVar16 \u003d pbVar16 + 1;\n              bVar6 \u003d *pbVar1;\n            }\nLAB_0010276f:\n            *pbVar20 \u003d 0;\n            lVar11 \u003d xstrdup(__ptr);\n            *plVar13 \u003d lVar11;\n            __src[local_100 + 1] \u003d 0;\n            bVar6 \u003d *pbVar16;\n            bVar2 \u003d (\u0026_sch_istable)[(ulong)bVar6 * 2];\n            while ((bVar2 \u0026 0x40) !\u003d 0) {\n              bVar6 \u003d pbVar16[1];\n              pbVar16 \u003d pbVar16 + 1;\n              bVar2 \u003d (\u0026_sch_istable)[(ulong)bVar6 * 2];\n            }\n            local_100 \u003d local_100 + 1;\n          } while (bVar6 !\u003d 0);\n          free(__ptr);\n          plVar13 \u003d plVar12;\n          if (param_2 \u003d\u003d plVar12) goto LAB_00102adb;\n          goto LAB_00102807;\n        }\nLAB_00102abe:\n        __src \u003d (long *)xmalloc(8);\n        *__src \u003d 0;\n        if (param_2 \u003d\u003d plVar12) {\nLAB_00102adb:\n          if (*plVar12 \u003d\u003d 0) {\n            iVar7 \u003d 0;\n          }\n          else {\n            lVar11 \u003d 1;\n            do {\n              iVar7 \u003d (int)lVar11;\n              plVar13 \u003d plVar12 + lVar11;\n              lVar11 \u003d lVar11 + 1;\n            } while (*plVar13 !\u003d 0);\n          }\n          lVar19 \u003d 0;\n          plVar13 \u003d (long *)xmalloc((long)(iVar7 + 1) \u003c\u003c 3);\n          lVar11 \u003d *plVar12;\n          while (lVar11 !\u003d 0) {\n            uVar14 \u003d xstrdup();\n            *(undefined8 *)((long)plVar13 + lVar19) \u003d uVar14;\n            lVar19 \u003d lVar19 + 8;\n            lVar11 \u003d *(long *)((long)plVar12 + lVar19);\n          }\n          *(undefined8 *)((long)plVar13 + lVar19) \u003d 0;\nLAB_00102807:\n          plVar12 \u003d plVar13;\n          if (*__src \u003d\u003d 0) goto LAB_00102ba3;\n          lVar11 \u003d 0;\n          do {\n            lVar11 \u003d lVar11 + 1;\n          } while (__src[lVar11] !\u003d 0);\n          local_108 \u003d lVar11 * 8;\n        }\n        else {\nLAB_00102ba3:\n          lVar11 \u003d 0;\n          local_108 \u003d 0;\n        }\n        free((void *)plVar12[lVar17]);\n        plVar12 \u003d (long *)xrealloc(plVar12,(lVar11 + 1 + (long)param_1) * 8);\n        iVar7 \u003d param_1 + -1 + (int)lVar11;\n        memmove(plVar12 + lVar17 + lVar11,plVar12 + lVar17 + 1,(long)(param_1 - iVar9) \u003c\u003c 3);\n        memcpy(plVar12 + lVar17,__src,local_108);\n        free(__src);\n        free(__s);\n        fclose(__stream);\n        uVar8 \u003d local_110 + 1;\n        unaff_R13 \u003d lVar17 * 8;\n        param_1 \u003d iVar7;\n        if (iVar7 \u003c\u003d (int)uVar8) break;\n      }\n      else {\nLAB_00102900:\n        if (param_1 \u003c\u003d iVar9 + 1) break;\nLAB_0010290d:\n        uVar8 \u003d iVar9 + 1;\n        local_110 \u003d iVar9;\n      }\n      unaff_R13 \u003d (ulong)uVar8;\n    } while( true );\n  }\n  ppuVar18 \u003d \u0026PTR_s_strip_underscore_00104be0;\n  while (iVar9 \u003d getopt_long(param_1,plVar12,\"_hinprRs:tv\",\u0026PTR_s_strip_underscore_00104be0,0),\n        iVar9 !\u003d -1) {\n    switch(iVar9) {\n    case 0x3f:\nswitchD_001029f9_caseD_3f:\n      FUN_0010225e(_stderr,1);\n    case 0x5f:\nswitchD_001029f9_caseD_5f:\n      _DAT_0010d140 \u003d 1;\n      break;\n    default:\n      do {\n        iVar9 \u003d getopt_long(param_1,plVar12,\"_hinprRs:tv\",\u0026PTR_s_strip_underscore_00104be0,0);\n        if (iVar9 \u003d\u003d -1) goto LAB_00102a6c;\n        switch(iVar9) {\n        case 0x3f:\n          goto switchD_001029f9_caseD_3f;\n        case 0x52:\n          goto switchD_001029f9_caseD_52;\n        case 0x5f:\n          goto switchD_001029f9_caseD_5f;\n        case 0x68:\n          goto switchD_001029f9_caseD_68;\n        case 0x69:\n          goto switchD_001029f9_caseD_69;\n        case 0x6e:\n          goto switchD_001029f9_caseD_6e;\n        case 0x70:\n          goto switchD_001029f9_caseD_70;\n        case 0x72:\n          goto switchD_001029f9_caseD_72;\n        case 0x73:\n          goto switchD_001029f9_caseD_73;\n        case 0x74:\n          goto switchD_001029f9_caseD_74;\n        case 0x76:\n          goto switchD_001029f9_caseD_76;\n        }\n      } while( true );\n    case 0x52:\nswitchD_001029f9_caseD_52:\n      DAT_00105108 \u003d DAT_00105108 \u0026 0xfffbffff;\n      break;\n    case 0x68:\nswitchD_001029f9_caseD_68:\n      FUN_0010225e(_stdout,0);\n    case 0x74:\nswitchD_001029f9_caseD_74:\n      DAT_00105108 \u003d DAT_00105108 | 0x10;\n      break;\n    case 0x69:\nswitchD_001029f9_caseD_69:\n      DAT_00105108 \u003d DAT_00105108 \u0026 0xfffffff7;\n      break;\n    case 0x6e:\nswitchD_001029f9_caseD_6e:\n      _DAT_0010d140 \u003d 0;\n      break;\n    case 0x70:\nswitchD_001029f9_caseD_70:\n      DAT_00105108 \u003d DAT_00105108 \u0026 0xfffffffe;\n      break;\n    case 0x72:\nswitchD_001029f9_caseD_72:\n      DAT_00105108 \u003d DAT_00105108 | 0x40000;\n      break;\n    case 0x73:\nswitchD_001029f9_caseD_73:\n      iVar9 \u003d cplus_demangle_name_to_style(_optarg);\n      if (iVar9 \u003d\u003d 0) {\n        fprintf(_stderr,\"%s: unknown demangling style `%s\\\u0027\\n\",DAT_0010d148,_optarg);\n        return 1;\n      }\n      cplus_demangle_set_style(iVar9);\n      break;\n    case 0x76:\nswitchD_001029f9_caseD_76:\n      printf(\"GNU %s %s\\n\",\"c++filt\",\"(GNU Binutils for Debian) 2.40\");\n      pcVar15 \u003d (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n      printf(pcVar15);\n      pcVar15 \u003d (char *)dcgettext(0,\n                                  \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                                  ,5);\n      printf(pcVar15);\n                    \n      exit(0);\n    }\n  }\nLAB_00102a6c:\n  if (_optind \u003c param_1) {\n    do {\n      FUN_00102380(plVar12[_optind]);\n      putc(10,_stdout);\n      _optind \u003d _optind + 1;\n    } while (_optind \u003c param_1);\n  }\n  else {\n    if (_current_demangling_style \u003d\u003d 0x8000) {\nLAB_00102c76:\n      ppuVar18 \u003d (undefined **)\u0026stdout;\n      do {\n        unaff_R13 \u003d 0;\n        uVar8 \u003d getc(_stdin);\n        while( true ) {\n          plVar12 \u003d (long *)(unaff_R13 \u0026 0xffffffff);\n          if (uVar8 \u003d\u003d 0xffffffff) goto LAB_00102d0d;\n          if ((((\u0026_sch_istable)[(ulong)(uVar8 \u0026 0xff) * 2] \u0026 0x8c) \u003d\u003d 0) \u0026\u0026\n             (pcVar15 \u003d strchr(\"_$.\",uVar8), pcVar15 \u003d\u003d (char *)0x0)) {\n            if ((int)plVar12 !\u003d 0) goto LAB_00102d6f;\n            goto LAB_00102d47;\n          }\n          if (unaff_R13 \u003d\u003d 0x7ffe) break;\n          (\u0026DAT_00105140)[unaff_R13] \u003d (char)uVar8;\n          unaff_R13 \u003d unaff_R13 + 1;\n          uVar8 \u003d getc(_stdin);\n        }\n        plVar12 \u003d (long *)0x7ffe;\nLAB_00102d6f:\n        *(undefined *)(plVar12 + 0x20a28) \u003d 0;\n        FUN_00102380(\u0026DAT_00105140);\nLAB_00102d47:\n        putc(uVar8,_stdout);\n        if (uVar8 \u003d\u003d 10) {\n          fflush(_stdout);\n        }\n      } while( true );\n    }\n    if (_current_demangling_style \u003c 0x8001) {\n      if (((_current_demangling_style \u003d\u003d 0x100) || (_current_demangling_style \u003d\u003d 0x4000)) ||\n         (_current_demangling_style \u003d\u003d 4)) goto LAB_00102c76;\n    }\n    else if ((_current_demangling_style - 0x10000U \u0026 0xfffeffff) \u003d\u003d 0) goto LAB_00102c76;\n    FUN_00102e20(\"Internal error: no symbol alphabet for current style\");\nLAB_00102d0d:\n    if ((int)unaff_R13 !\u003d 0) {\n      *(undefined *)(plVar12 + 0x20a28) \u003d 0;\n      FUN_00102380();\n    }\n    fflush((FILE *)*ppuVar18);\n  }\n  return 0;\nLAB_00102670:\n  bVar6 \u003d pbVar16[1];\n  pbVar16 \u003d pbVar16 + 1;\n  if (bVar6 \u003d\u003d 0) goto LAB_00102abe;\n  goto LAB_00102680;\n}\n\n",
      "renaming": {},
      "calling": [
        "entry"
      ],
      "called": [
        "cplus_demangle_name_to_style",
        "printf",
        "strchr",
        "cplus_demangle_set_style",
        "xexit",
        "getopt_long",
        "bfd_set_error_program_name",
        "xmalloc_set_program_name",
        "xmalloc",
        "fprintf",
        "fread",
        "FUN_00102e20",
        "ferror",
        "xstrdup",
        "fopen",
        "fseek",
        "putc",
        "getc",
        "memcpy",
        "fclose",
        "free",
        "stat",
        "fflush",
        "ftell",
        "exit",
        "memmove",
        "FUN_0010225e",
        "xrealloc",
        "FUN_00102380",
        "strlen",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102e20": {
      "entrypoint": "0x00102e20",
      "current_name": "FUN_00102e20",
      "code": "\n\n\nvoid FUN_00102e20(void)\n\n{\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",DAT_0010d148);\n  fwrite(\"Internal error: no symbol alphabet for current style\",1,0x34,_stderr);\n  putc(10,_stderr);\n  xexit(1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024f0"
      ],
      "called": [
        "xexit",
        "putc",
        "fprintf",
        "fwrite",
        "fflush"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_DT_FINI": {
      "entrypoint": "0x00102f00",
      "current_name": "_DT_FINI",
      "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}