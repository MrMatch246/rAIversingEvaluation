{
  "functions": {
    "_DT_INIT": {
      "entrypoint": "0x00102000",
      "current_name": "_DT_INIT",
      "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__gmon_start__"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102020": {
      "entrypoint": "0x00102020",
      "current_name": "FUN_00102020",
      "code": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x00102030",
      "current_name": "free",
      "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130",
        "FUN_0010278c",
        "FUN_0010281b",
        "FUN_00102a90"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "putchar": {
      "entrypoint": "0x00102040",
      "current_name": "putchar",
      "code": "\n\n\nint putchar(int __c)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d putchar(__c);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102fe0",
        "FUN_00102a40"
      ],
      "called": [
        "putchar"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__errno_location": {
      "entrypoint": "0x00102050",
      "current_name": "__errno_location",
      "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 \u003d __errno_location();\n  return piVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102360"
      ],
      "called": [
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_core_file_failing_command": {
      "entrypoint": "0x00102060",
      "current_name": "bfd_core_file_failing_command",
      "code": "\nvoid bfd_core_file_failing_command(void)\n\n{\n  bfd_core_file_failing_command();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024d2"
      ],
      "called": [
        "bfd_core_file_failing_command"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "puts": {
      "entrypoint": "0x00102070",
      "current_name": "puts",
      "code": "\n\n\nint puts(char *__s)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d puts(__s);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90",
        "FUN_001024d2"
      ],
      "called": [
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ferror": {
      "entrypoint": "0x00102080",
      "current_name": "ferror",
      "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d ferror(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "ferror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_default_target": {
      "entrypoint": "0x00102090",
      "current_name": "bfd_set_default_target",
      "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "bfd_set_default_target"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fread": {
      "entrypoint": "0x001020a0",
      "current_name": "fread",
      "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "fread"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "textdomain": {
      "entrypoint": "0x001020b0",
      "current_name": "textdomain",
      "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "textdomain"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openr": {
      "entrypoint": "0x001020c0",
      "current_name": "bfd_openr",
      "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102980"
      ],
      "called": [
        "bfd_openr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x001020d0",
      "current_name": "fclose",
      "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fclose(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "fclose"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bindtextdomain": {
      "entrypoint": "0x001020e0",
      "current_name": "bindtextdomain",
      "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "bindtextdomain"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dcgettext": {
      "entrypoint": "0x001020f0",
      "current_name": "dcgettext",
      "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102360",
        "FUN_0010274b",
        "FUN_00103130",
        "FUN_0010278c",
        "FUN_0010281b",
        "FUN_00102980"
      ],
      "called": [
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x00102100",
      "current_name": "strlen",
      "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d strlen(__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130",
        "FUN_00103c50",
        "FUN_00102e50"
      ],
      "called": [
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getopt_long": {
      "entrypoint": "0x00102110",
      "current_name": "getopt_long",
      "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "getopt_long"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printf": {
      "entrypoint": "0x00102120",
      "current_name": "printf",
      "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d printf(__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102fe0",
        "FUN_00102e90",
        "FUN_0010259c",
        "FUN_00103130",
        "FUN_00102710",
        "FUN_00102a90",
        "FUN_001024d2"
      ],
      "called": [
        "printf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xrealloc": {
      "entrypoint": "0x00102130",
      "current_name": "xrealloc",
      "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "xrealloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fputs": {
      "entrypoint": "0x00102140",
      "current_name": "fputs",
      "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fputs(__s,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90"
      ],
      "called": [
        "fputs"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_target_list": {
      "entrypoint": "0x00102150",
      "current_name": "bfd_target_list",
      "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010281b"
      ],
      "called": [
        "bfd_target_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_error": {
      "entrypoint": "0x00102160",
      "current_name": "bfd_get_error",
      "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103d20",
        "FUN_001023b6",
        "FUN_00103130",
        "FUN_001024d2"
      ],
      "called": [
        "bfd_get_error"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc": {
      "entrypoint": "0x00102170",
      "current_name": "xmalloc",
      "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130",
        "FUN_00102a90"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_error": {
      "entrypoint": "0x00102180",
      "current_name": "bfd_set_error",
      "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023b6"
      ],
      "called": [
        "bfd_set_error"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc_set_program_name": {
      "entrypoint": "0x00102190",
      "current_name": "xmalloc_set_program_name",
      "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "xmalloc_set_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xstrdup": {
      "entrypoint": "0x001021a0",
      "current_name": "xstrdup",
      "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "xstrdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fputc": {
      "entrypoint": "0x001021b0",
      "current_name": "fputc",
      "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fputc(__c,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010281b",
        "FUN_0010278c"
      ],
      "called": [
        "fputc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_init": {
      "entrypoint": "0x001021c0",
      "current_name": "bfd_init",
      "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "bfd_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "putc": {
      "entrypoint": "0x001021d0",
      "current_name": "putc",
      "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d putc(__c,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130",
        "FUN_00102ee0",
        "FUN_00102a90"
      ],
      "called": [
        "putc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fprintf": {
      "entrypoint": "0x001021e0",
      "current_name": "fprintf",
      "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010274b",
        "FUN_00103130",
        "FUN_0010278c",
        "FUN_0010281b",
        "FUN_00102ee0"
      ],
      "called": [
        "fprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ftell": {
      "entrypoint": "0x001021f0",
      "current_name": "ftell",
      "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d ftell(__stream);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "ftell"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stat": {
      "entrypoint": "0x00102200",
      "current_name": "stat",
      "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d stat(__file,__buf);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130",
        "FUN_00102980"
      ],
      "called": [
        "stat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtol": {
      "entrypoint": "0x00102210",
      "current_name": "strtol",
      "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "strtol"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x00102220",
      "current_name": "memcpy",
      "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "memcpy"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fflush": {
      "entrypoint": "0x00102230",
      "current_name": "fflush",
      "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fflush(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010274b",
        "FUN_0010278c",
        "FUN_00102ee0"
      ],
      "called": [
        "fflush"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fseek": {
      "entrypoint": "0x00102240",
      "current_name": "fseek",
      "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "fseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setlocale": {
      "entrypoint": "0x00102250",
      "current_name": "setlocale",
      "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "setlocale"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_error_program_name": {
      "entrypoint": "0x00102260",
      "current_name": "bfd_set_error_program_name",
      "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "bfd_set_error_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x00102270",
      "current_name": "memmove",
      "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "memmove"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fopen": {
      "entrypoint": "0x00102280",
      "current_name": "fopen",
      "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 \u003d fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "fopen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xexit": {
      "entrypoint": "0x00102290",
      "current_name": "xexit",
      "code": "\nvoid xexit(void)\n\n{\n  xexit();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130",
        "FUN_00102db0",
        "FUN_00102a90"
      ],
      "called": [
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_close": {
      "entrypoint": "0x001022a0",
      "current_name": "bfd_close",
      "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023b6"
      ],
      "called": [
        "bfd_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "vfprintf": {
      "entrypoint": "0x001022b0",
      "current_name": "vfprintf",
      "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102ee0"
      ],
      "called": [
        "vfprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_check_format_matches": {
      "entrypoint": "0x001022c0",
      "current_name": "bfd_check_format_matches",
      "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a40",
        "FUN_001024d2"
      ],
      "called": [
        "bfd_check_format_matches"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_errmsg": {
      "entrypoint": "0x001022d0",
      "current_name": "bfd_errmsg",
      "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103d20",
        "FUN_00103130"
      ],
      "called": [
        "bfd_errmsg"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sprintf": {
      "entrypoint": "0x001022e0",
      "current_name": "sprintf",
      "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d sprintf(__s,__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102e90",
        "FUN_00102710",
        "FUN_00102e50"
      ],
      "called": [
        "sprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "exit": {
      "entrypoint": "0x001022f0",
      "current_name": "exit",
      "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130",
        "FUN_0010281b"
      ],
      "called": [
        "exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fwrite": {
      "entrypoint": "0x00102300",
      "current_name": "fwrite",
      "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130",
        "FUN_001024d2"
      ],
      "called": [
        "fwrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_check_format": {
      "entrypoint": "0x00102310",
      "current_name": "bfd_check_format",
      "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102980",
        "FUN_00102a40"
      ],
      "called": [
        "bfd_check_format"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openr_next_archived_file": {
      "entrypoint": "0x00102320",
      "current_name": "bfd_openr_next_archived_file",
      "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023b6"
      ],
      "called": [
        "bfd_openr_next_archived_file"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_map_over_sections": {
      "entrypoint": "0x00102330",
      "current_name": "bfd_map_over_sections",
      "code": "\nvoid bfd_map_over_sections(void)\n\n{\n  bfd_map_over_sections();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90"
      ],
      "called": [
        "bfd_map_over_sections"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strerror": {
      "entrypoint": "0x00102340",
      "current_name": "strerror",
      "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strerror(__errnum);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102360"
      ],
      "called": [
        "strerror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_finalize": {
      "entrypoint": "0x00102350",
      "current_name": "__cxa_finalize",
      "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "__cxa_finalize"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102360": {
      "entrypoint": "0x00102360",
      "current_name": "FUN_00102360",
      "code": "\nvoid FUN_00102360(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 \u003d __errno_location();\n  if (*piVar1 \u003d\u003d 2) {\n    uVar2 \u003d dcgettext(0,\"\\\u0027%s\\\u0027: No such file\",5);\n    FUN_00102f40(uVar2);\n  }\n  else {\n    strerror(*piVar1);\n    uVar2 \u003d dcgettext(0,\"Warning: could not locate \\\u0027%s\\\u0027.  reason: %s\",5);\n    FUN_00102f40(uVar2);\n  }\n  DAT_00107314 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102980"
      ],
      "called": [
        "dcgettext",
        "FUN_00102f40",
        "strerror",
        "__errno_location"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001023b6": {
      "entrypoint": "0x001023b6",
      "current_name": "FUN_001023b6",
      "code": "\nvoid FUN_001023b6(void)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 *unaff_RBX;\n  long lVar4;\n  \n  lVar3 \u003d 0;\n  do {\n    lVar4 \u003d lVar3;\n    bfd_set_error(0);\n    lVar3 \u003d bfd_openr_next_archived_file();\n    if (lVar3 \u003d\u003d 0) {\n      iVar2 \u003d bfd_get_error();\n      if (iVar2 !\u003d 9) {\n        FUN_00103d20(*unaff_RBX);\n        DAT_00107314 \u003d 2;\n      }\n      if (lVar4 !\u003d 0) {\n        bfd_close(lVar4);\n      }\n      break;\n    }\n    FUN_00102a40();\n  } while ((lVar4 \u003d\u003d 0) || (bfd_close(), lVar4 !\u003d lVar3));\n  cVar1 \u003d bfd_close();\n  if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n    FUN_00103d20();\n    DAT_00107314 \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102980"
      ],
      "called": [
        "FUN_00103d20",
        "bfd_set_error",
        "bfd_get_error",
        "bfd_close",
        "bfd_openr_next_archived_file",
        "FUN_00102a40"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001024d2": {
      "entrypoint": "0x001024d2",
      "current_name": "FUN_001024d2",
      "code": "\n\n\nvoid FUN_001024d2(void)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 *unaff_RBX;\n  undefined8 param_7;\n  \n  iVar2 \u003d bfd_get_error();\n  if (iVar2 \u003d\u003d 0xd) {\n    FUN_00103d20(*unaff_RBX);\n    FUN_0010278c(param_7);\n    DAT_00107314 \u003d 3;\n  }\n  else {\n    cVar1 \u003d bfd_check_format_matches();\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      FUN_00103d20(*unaff_RBX);\n      iVar2 \u003d bfd_get_error();\n      if (iVar2 \u003d\u003d 0xd) {\n        FUN_0010278c(param_7);\n      }\n      DAT_00107314 \u003d 3;\n    }\n    else {\n      FUN_00102a90();\n      fwrite(\" (core file\",1,0xb,_stdout);\n      lVar3 \u003d bfd_core_file_failing_command();\n      if (lVar3 !\u003d 0) {\n        printf(\" invoked as %s\",lVar3);\n      }\n      puts(\")\\n\");\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a40"
      ],
      "called": [
        "puts",
        "FUN_00103d20",
        "printf",
        "bfd_get_error",
        "FUN_0010278c",
        "bfd_core_file_failing_command",
        "fwrite",
        "FUN_00102a90",
        "bfd_check_format_matches"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010259c": {
      "entrypoint": "0x0010259c",
      "current_name": "FUN_0010259c",
      "code": "\nvoid FUN_0010259c(void)\n\n{\n  undefined8 *in_RAX;\n  \n  printf(\" (ex %s)\",*in_RAX);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90"
      ],
      "called": [
        "printf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001026ea": {
      "entrypoint": "0x001026ea",
      "current_name": "FUN_001026ea",
      "code": "\nundefined8 FUN_001026ea(void)\n\n{\n  undefined8 in_RAX;\n  undefined8 unaff_retaddr;\n  \n  DAT_001072d8 \u003d in_RAX;\n  return unaff_retaddr;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103c50"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001026f6": {
      "entrypoint": "0x001026f6",
      "current_name": "FUN_001026f6",
      "code": "\nvoid FUN_001026f6(void)\n\n{\n  int in_EAX;\n  char *__format;\n  \n  __format \u003d \"0x%lx\";\n  if (in_EAX \u003d\u003d 1) {\n    __format \u003d \"0%lo\";\n  }\n  sprintf(\u0026stack0x00000000,__format);\n  strlen(\u0026stack0x00000000);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102e50"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102710": {
      "entrypoint": "0x00102710",
      "current_name": "FUN_00102710",
      "code": "\nvoid FUN_00102710(void)\n\n{\n  int in_EAX;\n  uint unaff_EBX;\n  char *__format;\n  \n  __format \u003d \"0x%lx\";\n  if (in_EAX \u003d\u003d 1) {\n    __format \u003d \"0%lo\";\n  }\n  sprintf(\u0026stack0x00000000,__format);\n  printf(\"%*s\",(ulong)unaff_EBX);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102e90"
      ],
      "called": [
        "printf",
        "sprintf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010274a": {
      "entrypoint": "0x0010274a",
      "current_name": "FUN_0010274a",
      "code": "\nvoid FUN_0010274a(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103cc0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010274b": {
      "entrypoint": "0x0010274b",
      "current_name": "FUN_0010274b",
      "code": "\n\n\nvoid FUN_0010274b(void)\n\n{\n  undefined8 uVar1;\n  long unaff_RBX;\n  undefined8 unaff_retaddr;\n  \n  uVar1 \u003d dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (unaff_RBX !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_00107350);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_00107350,uVar1,unaff_retaddr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103d20"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "fflush"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010278c": {
      "entrypoint": "0x0010278c",
      "current_name": "FUN_0010278c",
      "code": "\n\n\nvoid FUN_0010278c(long *param_1)\n\n{\n  undefined8 uVar1;\n  char *__format;\n  long *plVar2;\n  \n  fflush(_stdout);\n  uVar1 \u003d DAT_00107350;\n  __format \u003d (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,__format,uVar1);\n  for (plVar2 \u003d param_1; *plVar2 !\u003d 0; plVar2 \u003d plVar2 + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(param_1);\n  fputc(10,_stderr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001024d2"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "fflush",
        "free",
        "fputc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010281b": {
      "entrypoint": "0x0010281b",
      "current_name": "FUN_0010281b",
      "code": "\nvoid FUN_0010281b(FILE *param_1,int param_2)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long *__ptr;\n  long *plVar3;\n  \n  lVar1 \u003d DAT_00107350;\n  pcVar2 \u003d (char *)dcgettext(0,\"Usage: %s [option(s)] [file(s)]\\n\",5);\n  fprintf(param_1,pcVar2,lVar1);\n  pcVar2 \u003d (char *)dcgettext(0,\" Displays the sizes of sections inside binary files\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\" If no input file(s) are specified, a.out is assumed\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \" The options are:\\n  -A|-B|-G  --format\u003d{sysv|berkeley|gnu}  Select output style (default is %s)\\n  -o|-d|-x  --radix\u003d{8|10|16}         Display numbers in octal, decimal or hex\\n  -t        --totals                  Display the total sizes (Berkeley only)\\n  -f                                  Ignored.\\n            --common                  Display total size for *COM* syms\\n            --target\u003d\u003cbfdname\u003e        Set the binary file format\\n            @\u003cfile\u003e                   Read options from \u003cfile\u003e\\n  -h|-H|-?  --help                    Display this information\\n  -v|-V     --version                 Display the program\\\u0027s version\\n\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2,\"berkeley\");\n  lVar1 \u003d DAT_00107350;\n  if (DAT_00107350 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(param_1,pcVar2);\n  }\n  else {\n    pcVar2 \u003d (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(param_1,pcVar2,lVar1);\n  }\n  __ptr \u003d (long *)bfd_target_list();\n  plVar3 \u003d __ptr;\n  while( true ) {\n    lVar1 \u003d *plVar3;\n    plVar3 \u003d plVar3 + 1;\n    if (lVar1 \u003d\u003d 0) break;\n    fprintf(param_1,\" %s\");\n  }\n  fputc(10,param_1);\n  free(__ptr);\n  if (param_2 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(param_1,pcVar2,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n                    \n  exit(param_2);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "free",
        "exit",
        "fputc",
        "bfd_target_list"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102980": {
      "entrypoint": "0x00102980",
      "current_name": "FUN_00102980",
      "code": "\nvoid FUN_00102980(char *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  long lVar6;\n  stat sStack_b8;\n  \n  if (param_1 !\u003d (char *)0x0) {\n    iVar2 \u003d stat(param_1,\u0026sStack_b8);\n    if (iVar2 \u003c 0) {\n      piVar3 \u003d __errno_location();\n      if (*piVar3 \u003d\u003d 2) {\n        uVar4 \u003d dcgettext(0,\"\\\u0027%s\\\u0027: No such file\",5);\n        FUN_00102f40(uVar4,param_1);\n      }\n      else {\n        pcVar5 \u003d strerror(*piVar3);\n        uVar4 \u003d dcgettext(0,\"Warning: could not locate \\\u0027%s\\\u0027.  reason: %s\",5);\n        FUN_00102f40(uVar4,param_1,pcVar5);\n      }\n    }\n    else if ((sStack_b8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n      uVar4 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 is a directory\",5);\n      FUN_00102f40(uVar4,param_1);\n    }\n    else if ((sStack_b8.st_mode \u0026 0xf000) \u003d\u003d 0x8000) {\n      if (sStack_b8.st_size \u003c 0) {\n        uVar4 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 has negative size, probably it is too large\",5);\n        FUN_00102f40(uVar4,param_1);\n      }\n      else if (sStack_b8.st_size !\u003d 0) {\n        lVar6 \u003d bfd_openr(param_1,DAT_00107340);\n        if (lVar6 !\u003d 0) {\n          cVar1 \u003d bfd_check_format(lVar6,2);\n          if (cVar1 !\u003d \u0027\\0\u0027) {\n            FUN_001023b6();\n            return;\n          }\n          FUN_00102a40(lVar6);\n          cVar1 \u003d bfd_close(lVar6);\n          if (cVar1 !\u003d \u0027\\0\u0027) {\n            return;\n          }\n        }\n        FUN_00103d20(param_1);\n        DAT_00107314 \u003d 1;\n        return;\n      }\n    }\n    else {\n      uVar4 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 is not an ordinary file\",5);\n      FUN_00102f40(uVar4,param_1);\n    }\n  }\n  DAT_00107314 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "bfd_openr",
        "FUN_00102360",
        "dcgettext",
        "FUN_001023b6",
        "FUN_00102f40",
        "stat",
        "bfd_check_format",
        "FUN_00102a40"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102a40": {
      "entrypoint": "0x00102a40",
      "current_name": "FUN_00102a40",
      "code": "\n\n\nvoid FUN_00102a40(undefined8 *param_1)\n\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 local_20 [2];\n  \n  cVar1 \u003d bfd_check_format(param_1,2);\n  if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n    cVar1 \u003d bfd_check_format_matches(param_1,1,local_20);\n    if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n      iVar2 \u003d bfd_get_error();\n      if (iVar2 \u003d\u003d 0xd) {\n        FUN_00103d20(*param_1);\n        FUN_0010278c(local_20[0]);\n        DAT_00107314 \u003d 3;\n      }\n      else {\n        cVar1 \u003d bfd_check_format_matches(param_1,3,local_20);\n        if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n          FUN_00103d20(*param_1);\n          iVar2 \u003d bfd_get_error();\n          if (iVar2 \u003d\u003d 0xd) {\n            FUN_0010278c(local_20[0]);\n          }\n          DAT_00107314 \u003d 3;\n        }\n        else {\n          FUN_00102a90(param_1);\n          fwrite(\" (core file\",1,0xb,_stdout);\n          lVar3 \u003d bfd_core_file_failing_command(param_1);\n          if (lVar3 !\u003d 0) {\n            printf(\" invoked as %s\",lVar3);\n          }\n          puts(\")\\n\");\n        }\n      }\n    }\n    else {\n      FUN_00102a90(param_1);\n      putchar(10);\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023b6",
        "FUN_00102980"
      ],
      "called": [
        "bfd_check_format",
        "putchar",
        "FUN_00102a90",
        "FUN_001024d2",
        "bfd_check_format_matches"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102a90": {
      "entrypoint": "0x00102a90",
      "current_name": "FUN_00102a90",
      "code": "\n\n\nvoid FUN_00102a90(char **param_1)\n\n{\n  long lVar1;\n  undefined8 extraout_RDX;\n  long lVar2;\n  long extraout_RDX_00;\n  undefined8 extraout_RDX_01;\n  undefined8 uVar3;\n  void *__ptr;\n  int iVar4;\n  char cVar5;\n  void *pvVar6;\n  char *pcVar7;\n  int iVar8;\n  long lVar9;\n  bool bVar10;\n  bool bVar11;\n  undefined *puVar12;\n  \n  if ((_DAT_00107310 \u003d\u003d 0) || (DAT_001072f0 \u003d 0, (*(uint *)((long)param_1 + 0x44) \u0026 0x52) !\u003d 0x10))\n  goto LAB_00102aa8;\n  lVar9 \u003d (**(code **)(param_1[1] + 0x1f8))();\n  if (lVar9 \u003c 0) {\n    FUN_00103d20(*param_1);\n    xexit(1);\nLAB_001026b4:\n    __ptr \u003d (void *)xmalloc();\n  }\n  else {\n    __ptr \u003d (void *)0x0;\n    if (lVar9 !\u003d 0) goto LAB_001026b4;\n  }\n  pvVar6 \u003d __ptr;\n  lVar9 \u003d (**(code **)(param_1[1] + 0x200))(param_1);\n  cVar5 \u003d (char)pvVar6;\n  if (lVar9 \u003c 0) {\n    FUN_00103d20(*param_1);\n    xexit(1);\n    lVar2 \u003d extraout_RDX_00;\n  }\n  else {\n    cVar5 \u003d \u0027\\0\u0027;\n    lVar2 \u003d DAT_001072f0;\n    while (bVar10 \u003d lVar9 !\u003d 0, lVar9 \u003d lVar9 + -1, bVar10) {\n      lVar1 \u003d *(long *)((long)__ptr + lVar9 * 8);\n      if (((*(byte *)(*(long *)(lVar1 + 0x20) + 0x25) \u0026 0x10) !\u003d 0) \u0026\u0026\n         ((*(byte *)(lVar1 + 0x19) \u0026 1) \u003d\u003d 0)) {\n        lVar2 \u003d lVar2 + *(long *)(lVar1 + 0x10);\n        cVar5 \u003d \u0027\\x01\u0027;\n      }\n    }\n  }\n  if (cVar5 !\u003d \u0027\\0\u0027) {\n    DAT_001072f0 \u003d lVar2;\n  }\n  free(__ptr);\nLAB_00102aa8:\n  if (DAT_00107348 \u003d\u003d 1) {\n    DAT_001072e0 \u003d 0;\n    DAT_001072d8 \u003d 0;\n    DAT_001072d0 \u003d 0;\n    bfd_map_over_sections(param_1,FUN_00103c50,0);\n    if (_DAT_00107310 !\u003d 0) {\n      if ((int)DAT_001072d0 \u003c 5) {\n        DAT_001072d0 \u003d 5;\n      }\n      DAT_001072e0 \u003d DAT_001072e0 + DAT_001072f0;\n    }\n    DAT_001072cc \u003d FUN_00102e50(DAT_001072d8);\n    if (DAT_001072cc \u003c 4) {\n      DAT_001072cc \u003d 4;\n    }\n    DAT_001072c8 \u003d FUN_00102e50();\n    if (DAT_001072c8 \u003c 4) {\n      DAT_001072c8 \u003d 4;\n    }\n    DAT_001072e0 \u003d 0;\n    printf(\"%s  \",*param_1);\n    uVar3 \u003d extraout_RDX_01;\n    if ((undefined8 *)param_1[0x1d] !\u003d (undefined8 *)0x0) {\n      printf(\" (ex %s)\",*(undefined8 *)param_1[0x1d]);\n      uVar3 \u003d extraout_RDX;\n    }\n    puVar12 \u003d \u0026DAT_001040fc;\n    printf(\":\\n%-*s   %*s   %*s\\n\",(ulong)DAT_001072d0,\"section\",(ulong)DAT_001072c8,\u0026DAT_00104067,\n           (ulong)DAT_001072cc,\u0026DAT_001040fc,uVar3);\n    bfd_map_over_sections(param_1,FUN_00103cc0,0);\n    if (_DAT_00107310 !\u003d 0) {\n      DAT_001072e0 \u003d DAT_001072e0 + DAT_001072f0;\n      FUN_00102fe0(\"*COM*\",DAT_001072f0,0,puVar12);\n    }\n    printf(\"%-*s   \",(ulong)DAT_001072d0,\"Total\");\n    FUN_00102e90(DAT_001072c8,DAT_001072e0);\n    puts(\"\\n\");\n    return;\n  }\n  iVar8 \u003d (-(uint)(DAT_00107348 \u003d\u003d 0) \u0026 0xfffffffd) + 10;\n  bVar10 \u003d DAT_00107348 \u003d\u003d 0;\n  DAT_00107308 \u003d 0;\n  DAT_00107300 \u003d 0;\n  DAT_001072f8 \u003d 0;\n  bfd_map_over_sections(param_1,FUN_00102d70,0);\n  DAT_00107308 \u003d DAT_00107308 + DAT_001072f0;\n  iVar4 \u003d DAT_001072e8 + 1;\n  bVar11 \u003d DAT_001072e8 \u003d\u003d 0;\n  DAT_001072e8 \u003d iVar4;\n  if (bVar11) {\n    if (DAT_00107348 \u003d\u003d 0) {\n      pcVar7 \u003d \"   text\\t   data\\t    bss\\t    dec\\t    hex\\tfilename\";\n      if (DAT_0010733c \u003d\u003d 1) {\n        pcVar7 \u003d \"   text\\t   data\\t    bss\\t    oct\\t    hex\\tfilename\";\n      }\n      puts(pcVar7);\n    }\n    else {\n      puts(\"      text       data        bss      total filename\");\n    }\n  }\n  lVar9 \u003d DAT_001072f8 + DAT_00107300 + DAT_00107308;\n  if (_DAT_00107334 !\u003d 0) {\n    DAT_00107328 \u003d DAT_00107328 + DAT_001072f8;\n    DAT_00107320 \u003d DAT_00107320 + DAT_00107300;\n    DAT_00107318 \u003d DAT_00107318 + DAT_00107308;\n  }\n  iVar4 \u003d (int)(char)((-bVar10 \u0026 0xe9U) + 0x20);\n  FUN_00102e90(iVar8);\n  putc(iVar4,_stdout);\n  FUN_00102e90(iVar8,DAT_00107300);\n  putc(iVar4,_stdout);\n  FUN_00102e90(iVar8,DAT_00107308);\n  putc(iVar4,_stdout);\n  if (DAT_00107348 \u003d\u003d 0) {\n    pcVar7 \u003d \"%7lu\\t%7lx\";\n    if (DAT_0010733c \u003d\u003d 1) {\n      pcVar7 \u003d \"%7lo\\t%7lx\";\n    }\n    printf(pcVar7,lVar9,lVar9);\n  }\n  else {\n    FUN_00102e90(iVar8,lVar9);\n  }\n  putc(iVar4,_stdout);\n  fputs(*param_1,_stdout);\n  if ((undefined8 *)param_1[0x1d] \u003d\u003d (undefined8 *)0x0) {\n    return;\n  }\n  printf(\" (ex %s)\",*(undefined8 *)param_1[0x1d]);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a40",
        "FUN_001024d2"
      ],
      "called": [
        "FUN_00102fe0",
        "xexit",
        "FUN_0010259c",
        "fputs",
        "free",
        "putc",
        "FUN_00103cc0",
        "puts",
        "FUN_00103d20",
        "printf",
        "bfd_map_over_sections",
        "FUN_00102e90",
        "xmalloc",
        "FUN_00103c50",
        "FUN_00102d70",
        "FUN_00102e50"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102d70": {
      "entrypoint": "0x00102d70",
      "current_name": "FUN_00102d70",
      "code": "\nvoid FUN_00102d70(undefined8 param_1,long param_2)\n\n{\n  uint uVar1;\n  long lVar2;\n  \n  uVar1 \u003d *(uint *)(param_2 + 0x24);\n  if ((uVar1 \u0026 1) !\u003d 0) {\n    lVar2 \u003d *(long *)(param_2 + 0x40);\n    if (((uVar1 \u0026 0x10) !\u003d 0) || ((DAT_00107348 \u003d\u003d 0 \u0026\u0026 ((uVar1 \u0026 8) !\u003d 0)))) {\n      DAT_001072f8 \u003d DAT_001072f8 + lVar2;\n      return;\n    }\n    if ((uVar1 \u0026 0x100) !\u003d 0) {\n      DAT_00107300 \u003d DAT_00107300 + lVar2;\n      return;\n    }\n    DAT_00107308 \u003d DAT_00107308 + lVar2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102db0": {
      "entrypoint": "0x00102db0",
      "current_name": "FUN_00102db0",
      "code": "\nvoid FUN_00102db0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  char *__format;\n  undefined8 uVar1;\n  char acStack_110 [48];\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_88 \u003d param_1;\n    local_78 \u003d param_2;\n    local_68 \u003d param_3;\n    local_58 \u003d param_4;\n    local_48 \u003d param_5;\n    local_38 \u003d param_6;\n    local_28 \u003d param_7;\n    local_18 \u003d param_8;\n  }\n  local_d0 \u003d \u0026stack0x00000008;\n  local_d8 \u003d 8;\n  local_c8 \u003d local_b8;\n  local_d4 \u003d 0x30;\n  local_b0 \u003d param_10;\n  local_a8 \u003d param_11;\n  local_a0 \u003d param_12;\n  local_98 \u003d param_13;\n  local_90 \u003d param_14;\n  FUN_00102ee0(param_9,\u0026local_d8);\n  uVar1 \u003d 1;\n  xexit(1);\n  if (DAT_0010733c \u003d\u003d 0) {\n    __format \u003d \"%lu\";\n  }\n  else {\n    __format \u003d \"0x%lx\";\n    if (DAT_0010733c \u003d\u003d 1) {\n      __format \u003d \"0%lo\";\n    }\n  }\n  sprintf(acStack_110,__format,uVar1);\n  strlen(acStack_110);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103130"
      ],
      "called": [
        "xexit",
        "FUN_00102ee0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102e50": {
      "entrypoint": "0x00102e50",
      "current_name": "FUN_00102e50",
      "code": "\nvoid FUN_00102e50(undefined8 param_1)\n\n{\n  char *__format;\n  char acStack_38 [48];\n  \n  if (DAT_0010733c \u003d\u003d 0) {\n    __format \u003d \"%lu\";\n  }\n  else {\n    __format \u003d \"0x%lx\";\n    if (DAT_0010733c \u003d\u003d 1) {\n      __format \u003d \"0%lo\";\n    }\n  }\n  sprintf(acStack_38,__format,param_1);\n  strlen(acStack_38);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90"
      ],
      "called": [
        "sprintf",
        "FUN_001026f6",
        "strlen"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102e90": {
      "entrypoint": "0x00102e90",
      "current_name": "FUN_00102e90",
      "code": "\nvoid FUN_00102e90(ulong param_1,undefined8 param_2)\n\n{\n  char *__format;\n  char acStack_48 [56];\n  \n  if (DAT_0010733c \u003d\u003d 0) {\n    sprintf(acStack_48,\"%lu\",param_2);\n    printf(\"%*s\",param_1 \u0026 0xffffffff,acStack_48);\n  }\n  else {\n    __format \u003d \"0x%lx\";\n    if (DAT_0010733c \u003d\u003d 1) {\n      __format \u003d \"0%lo\";\n    }\n    sprintf(acStack_48,__format,param_2);\n    printf(\"%*s\",param_1 \u0026 0xffffffff,acStack_48);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102fe0",
        "FUN_00103130",
        "FUN_00102a90"
      ],
      "called": [
        "printf",
        "sprintf",
        "FUN_00102710"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102ee0": {
      "entrypoint": "0x00102ee0",
      "current_name": "FUN_00102ee0",
      "code": "\n\n\nvoid FUN_00102ee0(char *param_1,__gnuc_va_list param_2)\n\n{\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",DAT_00107350);\n  vfprintf(_stderr,param_1,param_2);\n  putc(10,_stderr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102f40",
        "FUN_00102db0"
      ],
      "called": [
        "fprintf",
        "fflush",
        "vfprintf",
        "putc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102f40": {
      "entrypoint": "0x00102f40",
      "current_name": "FUN_00102f40",
      "code": "\nvoid FUN_00102f40(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_88 \u003d param_1;\n    local_78 \u003d param_2;\n    local_68 \u003d param_3;\n    local_58 \u003d param_4;\n    local_48 \u003d param_5;\n    local_38 \u003d param_6;\n    local_28 \u003d param_7;\n    local_18 \u003d param_8;\n  }\n  local_d0 \u003d \u0026stack0x00000008;\n  local_d8 \u003d 8;\n  local_c8 \u003d local_b8;\n  local_d4 \u003d 0x30;\n  local_b0 \u003d param_10;\n  local_a8 \u003d param_11;\n  local_a0 \u003d param_12;\n  local_98 \u003d param_13;\n  local_90 \u003d param_14;\n  FUN_00102ee0(param_9,\u0026local_d8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102360",
        "FUN_00103130",
        "FUN_00102980"
      ],
      "called": [
        "FUN_00102ee0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102fe0": {
      "entrypoint": "0x00102fe0",
      "current_name": "FUN_00102fe0",
      "code": "\nvoid FUN_00102fe0(undefined8 param_1,undefined8 param_2,undefined8 param_3)\n\n{\n  printf(\"%-*s   \",(ulong)DAT_001072d0,param_1);\n  FUN_00102e90(DAT_001072c8,param_2);\n  printf(\"   \");\n  FUN_00102e90(DAT_001072cc,param_3);\n  putchar(10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90",
        "FUN_00103cc0"
      ],
      "called": [
        "printf",
        "FUN_00102e90",
        "putchar"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "entry": {
      "entrypoint": "0x00103040",
      "current_name": "entry",
      "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_00103130,param_2,\u0026stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00103130",
        "__libc_start_main"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103070": {
      "entrypoint": "0x00103070",
      "current_name": "FUN_00103070",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00103083) */\n/* WARNING: Removing unreachable block (ram,0x0010308f) */\n\nvoid FUN_00103070(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "_ITM_deregisterTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001030a0": {
      "entrypoint": "0x001030a0",
      "current_name": "FUN_001030a0",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x001030c4) */\n/* WARNING: Removing unreachable block (ram,0x001030d0) */\n\nvoid FUN_001030a0(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_INIT_0"
      ],
      "called": [
        "_ITM_registerTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_FINI_0": {
      "entrypoint": "0x001030e0",
      "current_name": "_FINI_0",
      "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_001072c0 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_001071a8);\n  FUN_00103070();\n  DAT_001072c0 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__cxa_finalize",
        "FUN_00103070"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_INIT_0": {
      "entrypoint": "0x00103120",
      "current_name": "_INIT_0",
      "code": "\nvoid _INIT_0(void)\n\n{\n  FUN_001030a0();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_001030a0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103130": {
      "entrypoint": "0x00103130",
      "current_name": "FUN_00103130",
      "code": "\n\n\nundefined4 FUN_00103130(int param_1,long *param_2)\n\n{\n  byte *pbVar1;\n  byte bVar2;\n  bool bVar3;\n  bool bVar4;\n  char *pcVar5;\n  byte bVar6;\n  char cVar7;\n  int iVar8;\n  undefined4 uVar9;\n  FILE *__stream;\n  byte *__s;\n  char *pcVar10;\n  size_t sVar11;\n  byte *__ptr;\n  long *__src;\n  long lVar12;\n  long *plVar13;\n  long *plVar14;\n  ulong uVar15;\n  undefined8 uVar16;\n  char *pcVar17;\n  byte *pbVar18;\n  undefined **unaff_RBP;\n  long lVar19;\n  byte *pbVar20;\n  int iVar21;\n  int iVar22;\n  bool bVar23;\n  int local_110;\n  int local_10c;\n  size_t local_108;\n  stat local_c8;\n  \n  setlocale(5,\"\");\n  pcVar17 \u003d \"binutils\";\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_00107350 \u003d *param_2;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_00107350);\n  plVar13 \u003d param_2;\n  if (1 \u003c param_1) {\n    local_10c \u003d 2000;\n    local_110 \u003d 0;\n    iVar8 \u003d 1;\n    do {\n      while( true ) {\n        iVar22 \u003d iVar8;\n        unaff_RBP \u003d (undefined **)(long)iVar22;\n        if (*(char *)plVar13[(long)unaff_RBP] \u003d\u003d \u0027@\u0027) break;\nLAB_001035a0:\n        if (param_1 \u003c\u003d iVar22 + 1) goto LAB_00103612;\nLAB_001035aa:\n        iVar8 \u003d iVar22 + 1;\n        local_110 \u003d iVar22;\n      }\n      local_10c \u003d local_10c + -1;\n      if (local_10c \u003d\u003d 0) goto LAB_001039c5;\n      pcVar17 \u003d (char *)plVar13[(long)unaff_RBP] + 1;\n      iVar8 \u003d stat(pcVar17,\u0026local_c8);\n      if (iVar8 \u003c 0) goto LAB_001035a0;\n      if ((local_c8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n        lVar19 \u003d *plVar13;\n        pcVar17 \u003d \"%s: error: @-file refers to a directory\\n\";\n        do {\n          fprintf(_stderr,pcVar17,lVar19);\n          xexit(1);\nLAB_001039c5:\n          lVar19 \u003d *plVar13;\n          pcVar17 \u003d \"%s: error: too many @-files encountered\\n\";\n        } while( true );\n      }\n      __stream \u003d fopen(pcVar17,\"r\");\n      if (__stream \u003d\u003d (FILE *)0x0) goto LAB_001035a0;\n      iVar8 \u003d fseek(__stream,0,2);\n      if (((iVar8 \u003d\u003d -1) ||\n          (pcVar17 \u003d (char *)ftell(__stream), pcVar17 \u003d\u003d (char *)0xffffffffffffffff)) ||\n         (iVar8 \u003d fseek(__stream,0,0), iVar8 \u003d\u003d -1)) {\nLAB_00103600:\n        fclose(__stream);\n        if (iVar22 + 1 \u003c param_1) goto LAB_001035aa;\n        break;\n      }\n      __s \u003d (byte *)xmalloc(pcVar17 + 1);\n      pcVar10 \u003d (char *)fread(__s,1,(size_t)pcVar17,__stream);\n      if ((pcVar17 !\u003d pcVar10) \u0026\u0026 (iVar8 \u003d ferror(__stream), iVar8 !\u003d 0)) {\n        free(__s);\n        goto LAB_00103600;\n      }\n      __s[(long)pcVar10] \u003d 0;\n      bVar6 \u003d *__s;\n      pbVar18 \u003d __s;\n      if (bVar6 !\u003d 0) {\nLAB_00103300:\n        if (((\u0026_sch_istable)[(ulong)bVar6 * 2] \u0026 0x40) !\u003d 0) goto LAB_001032f0;\n        sVar11 \u003d strlen((char *)__s);\n        __ptr \u003d (byte *)xmalloc(sVar11 + 1);\n        iVar8 \u003d 0;\n        bVar23 \u003d false;\n        bVar4 \u003d false;\n        lVar19 \u003d 0;\n        __src \u003d (long *)0x0;\n        bVar3 \u003d false;\n        pbVar18 \u003d __s;\n        do {\n          while (((\u0026_sch_istable)[(ulong)*pbVar18 * 2] \u0026 0x40) !\u003d 0) {\n            pbVar18 \u003d pbVar18 + 1;\n          }\n          if ((iVar8 \u003d\u003d 0) || (plVar14 \u003d __src + lVar19, iVar8 + -1 \u003c\u003d (int)lVar19)) {\n            if (__src \u003d\u003d (long *)0x0) {\n              iVar8 \u003d 8;\n              __src \u003d (long *)xmalloc(0x40);\n              plVar14 \u003d __src + lVar19;\n              *plVar14 \u003d 0;\n            }\n            else {\n              iVar8 \u003d iVar8 * 2;\n              __src \u003d (long *)xrealloc(__src,(long)iVar8 \u003c\u003c 3);\n              plVar14 \u003d __src + lVar19;\n              *plVar14 \u003d 0;\n            }\n          }\n          bVar6 \u003d *pbVar18;\n          pbVar20 \u003d __ptr;\n          while (bVar6 !\u003d 0) {\n            while( true ) {\n              if ((((\u0026_sch_istable)[(ulong)bVar6 * 2] \u0026 0x40) !\u003d 0) \u0026\u0026\n                 (!(bool)(bVar4 | bVar3 | bVar23))) {\n                bVar3 \u003d false;\n                bVar23 \u003d false;\n                bVar4 \u003d false;\n                goto LAB_00103410;\n              }\n              if (!bVar3) break;\n              pbVar18 \u003d pbVar18 + 1;\n              *pbVar20 \u003d bVar6;\n              pbVar20 \u003d pbVar20 + 1;\n              bVar3 \u003d false;\n              bVar6 \u003d *pbVar18;\n              if (bVar6 \u003d\u003d 0) goto LAB_00103410;\n            }\n            if (bVar6 \u003d\u003d 0x5c) {\n              bVar3 \u003d true;\n            }\n            else if (bVar4) {\n              if (bVar6 \u003d\u003d 0x27) {\n                bVar4 \u003d false;\n              }\n              else {\nLAB_00103585:\n                *pbVar20 \u003d bVar6;\n                pbVar20 \u003d pbVar20 + 1;\n              }\n            }\n            else if (bVar23) {\n              if (bVar6 !\u003d 0x22) goto LAB_00103585;\n              bVar23 \u003d false;\n            }\n            else if (bVar6 \u003d\u003d 0x27) {\n              bVar4 \u003d true;\n            }\n            else {\n              if (bVar6 !\u003d 0x22) goto LAB_00103585;\n              bVar23 \u003d true;\n            }\n            pbVar1 \u003d pbVar18 + 1;\n            pbVar18 \u003d pbVar18 + 1;\n            bVar6 \u003d *pbVar1;\n          }\nLAB_00103410:\n          *pbVar20 \u003d 0;\n          lVar12 \u003d xstrdup(__ptr);\n          *plVar14 \u003d lVar12;\n          __src[lVar19 + 1] \u003d 0;\n          bVar6 \u003d *pbVar18;\n          bVar2 \u003d (\u0026_sch_istable)[(ulong)bVar6 * 2];\n          while ((bVar2 \u0026 0x40) !\u003d 0) {\n            bVar6 \u003d pbVar18[1];\n            pbVar18 \u003d pbVar18 + 1;\n            bVar2 \u003d (\u0026_sch_istable)[(ulong)bVar6 * 2];\n          }\n          lVar19 \u003d lVar19 + 1;\n        } while (bVar6 !\u003d 0);\n        free(__ptr);\n        plVar14 \u003d plVar13;\n        if (param_2 \u003d\u003d plVar13) goto LAB_0010372c;\n        goto LAB_001034ad;\n      }\nLAB_0010370f:\n      __src \u003d (long *)xmalloc();\n      *__src \u003d 0;\n      if (param_2 \u003d\u003d plVar13) {\nLAB_0010372c:\n        if (*plVar13 \u003d\u003d 0) {\n          iVar8 \u003d 0;\n        }\n        else {\n          lVar19 \u003d 1;\n          do {\n            iVar8 \u003d (int)lVar19;\n            plVar14 \u003d plVar13 + lVar19;\n            lVar19 \u003d lVar19 + 1;\n          } while (*plVar14 !\u003d 0);\n        }\n        lVar12 \u003d 0;\n        plVar14 \u003d (long *)xmalloc((long)(iVar8 + 1) \u003c\u003c 3);\n        lVar19 \u003d *plVar13;\n        while (lVar19 !\u003d 0) {\n          uVar16 \u003d xstrdup();\n          *(undefined8 *)((long)plVar14 + lVar12) \u003d uVar16;\n          lVar12 \u003d lVar12 + 8;\n          lVar19 \u003d *(long *)((long)plVar13 + lVar12);\n        }\n        *(undefined8 *)((long)plVar14 + lVar12) \u003d 0;\nLAB_001034ad:\n        plVar13 \u003d plVar14;\n        if (*__src \u003d\u003d 0) goto LAB_001038cc;\n        pcVar17 \u003d (char *)0x0;\n        do {\n          pcVar17 \u003d pcVar17 + 1;\n        } while (__src[(long)pcVar17] !\u003d 0);\n        local_108 \u003d (long)pcVar17 * 8;\n      }\n      else {\nLAB_001038cc:\n        pcVar17 \u003d (char *)0x0;\n        local_108 \u003d 0;\n      }\n      free((void *)plVar13[(long)unaff_RBP]);\n      plVar13 \u003d (long *)xrealloc(plVar13,(long)(pcVar17 + (long)param_1 + 1) * 8);\n      iVar21 \u003d param_1 + -1 + (int)pcVar17;\n      memmove(plVar13 + (long)(undefined **)((long)unaff_RBP + (long)pcVar17),\n              plVar13 + (long)((long)unaff_RBP + 1),(long)(param_1 - iVar22) \u003c\u003c 3);\n      memcpy(plVar13 + (long)unaff_RBP,__src,local_108);\n      free(__src);\n      free(__s);\n      fclose(__stream);\n      unaff_RBP \u003d (undefined **)((long)unaff_RBP + (long)pcVar17);\n      iVar8 \u003d local_110 + 1;\n      param_1 \u003d iVar21;\n    } while (local_110 + 1 \u003c iVar21);\n  }\nLAB_00103612:\n  iVar8 \u003d bfd_init();\n  if (iVar8 !\u003d 0x118) goto LAB_001039f8;\n  pcVar10 \u003d \"x86_64-pc-linux-gnu\";\n  unaff_RBP \u003d \u0026PTR_s_common_001071c0;\n  pcVar17 \u003d \"ABGHhVvdfotx\";\n  cVar7 \u003d bfd_set_default_target(\"x86_64-pc-linux-gnu\");\n  if (cVar7 \u003d\u003d \u0027\\0\u0027) {\n    uVar9 \u003d bfd_get_error();\n    pcVar17 \u003d (char *)bfd_errmsg(uVar9);\n    uVar16 \u003d dcgettext(0,\"can\\\u0027t set BFD default target to `%s\\\u0027: %s\",5);\n    uVar15 \u003d FUN_00102db0(uVar16,\"x86_64-pc-linux-gnu\",pcVar17);\n    goto LAB_00103b74;\n  }\n  do {\n    while (iVar8 \u003d getopt_long(param_1,plVar13,pcVar17,unaff_RBP,0), iVar8 !\u003d -1) {\n      pcVar5 \u003d pcVar10;\n      if (iVar8 \u003c 0x79) {\n        if (iVar8 \u003c 0x3f) {\nswitchD_001037fd_caseD_40:\n          iVar8 \u003d getopt_long(param_1,plVar13,pcVar17,unaff_RBP,0);\n          if (iVar8 \u003d\u003d -1) break;\n          if (0x78 \u003c iVar8) goto LAB_00103937;\n          if (0x3e \u003c iVar8) {\n            switch(iVar8) {\n            case 0x3f:\n            case 0x48:\n            case 0x68:\n              goto switchD_001037fd_caseD_3f;\n            case 0x41:\n              goto switchD_001037fd_caseD_41;\n            case 0x42:\n              goto switchD_001037fd_caseD_42;\n            case 0x47:\n              goto switchD_001037fd_caseD_47;\n            case 0x56:\n            case 0x76:\n              goto switchD_001037fd_caseD_56;\n            case 100:\n              goto switchD_001037fd_caseD_64;\n            case 0x6f:\n              goto switchD_001037fd_caseD_6f;\n            case 0x74:\n              goto switchD_001037fd_caseD_74;\n            case 0x78:\n              goto switchD_001037fd_caseD_78;\n            }\n          }\n          do {\n            do {\n              while( true ) {\n                iVar8 \u003d getopt_long(param_1,plVar13,pcVar17,unaff_RBP,0);\n                if (iVar8 \u003d\u003d -1) goto LAB_00103664;\n                if (0x78 \u003c iVar8) break;\n                if (0x3e \u003c iVar8) {\n                  switch(iVar8) {\n                  case 0x3f:\n                  case 0x48:\n                  case 0x68:\n                    goto switchD_001037fd_caseD_3f;\n                  case 0x41:\n                    goto switchD_001037fd_caseD_41;\n                  case 0x42:\n                    goto switchD_001037fd_caseD_42;\n                  case 0x47:\n                    goto switchD_001037fd_caseD_47;\n                  case 0x56:\n                  case 0x76:\n                    goto switchD_001037fd_caseD_56;\n                  case 100:\n                    goto switchD_001037fd_caseD_64;\n                  case 0x6f:\n                    goto switchD_001037fd_caseD_6f;\n                  case 0x74:\n                    goto switchD_001037fd_caseD_74;\n                  case 0x78:\n                    goto switchD_001037fd_caseD_78;\n                  }\n                }\n              }\nLAB_00103937:\n              if (iVar8 \u003d\u003d 0xca) goto LAB_001039d1;\n            } while (0xca \u003c iVar8);\n            if (iVar8 \u003d\u003d 200) goto LAB_00103869;\n          } while (iVar8 !\u003d 0xc9);\n          goto LAB_00103a15;\n        }\n        switch(iVar8) {\n        case 0x3f:\n        case 0x48:\n        case 0x68:\n          goto switchD_001037fd_caseD_3f;\n        default:\n          goto switchD_001037fd_caseD_40;\n        case 0x41:\n          goto switchD_001037fd_caseD_41;\n        case 0x42:\nswitchD_001037fd_caseD_42:\n          DAT_00107348 \u003d 0;\n          break;\n        case 0x47:\nswitchD_001037fd_caseD_47:\n          DAT_00107348 \u003d 2;\n          break;\n        case 0x56:\n        case 0x76:\nswitchD_001037fd_caseD_56:\n          _DAT_00107338 \u003d 1;\n          break;\n        case 100:\n          goto switchD_001037fd_caseD_64;\n        case 0x6f:\n          goto switchD_001037fd_caseD_6f;\n        case 0x74:\nswitchD_001037fd_caseD_74:\n          _DAT_00107334 \u003d 1;\n          break;\n        case 0x78:\n          goto switchD_001037fd_caseD_78;\n        }\n      }\n      else if (iVar8 \u003d\u003d 0xca) {\nLAB_001039d1:\n        DAT_00107340 \u003d _optarg;\n      }\n      else {\n        if (0xca \u003c iVar8) goto switchD_001037fd_caseD_40;\n        if (iVar8 !\u003d 200) {\n          if (iVar8 !\u003d 0xc9) goto switchD_001037fd_caseD_40;\n          goto LAB_00103a15;\n        }\nLAB_00103869:\n        pcVar10 \u003d _optarg;\n        if (0x31 \u003c (byte)(*_optarg + 0xbeU)) goto LAB_00103bc8;\n        uVar15 \u003d 1L \u003c\u003c (*_optarg + 0xbeU \u0026 0x3f);\n        if ((uVar15 \u0026 0x2000000020) !\u003d 0) goto switchD_001037fd_caseD_47;\n        if ((uVar15 \u0026 0x2000000020000) \u003d\u003d 0) {\nLAB_00103b74:\n          if ((uVar15 \u0026 0x100000001) \u003d\u003d 0) goto LAB_00103bc8;\n          goto switchD_001037fd_caseD_42;\n        }\nswitchD_001037fd_caseD_41:\n        DAT_00107348 \u003d 1;\n      }\n    }\nLAB_00103664:\n    if (_DAT_00107338 !\u003d 0) {\n      printf(\"GNU %s %s\\n\",\u0026DAT_00104067,\"(GNU Binutils for Debian) 2.40\");\n      pcVar17 \u003d (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n      printf(pcVar17);\n      pcVar17 \u003d (char *)dcgettext(0,\n                                  \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                                  ,5);\n      printf(pcVar17);\n                    \n      exit(0);\n    }\n    if (_DAT_00107330 \u003d\u003d 0) {\n      iVar8 \u003d _optind - param_1;\n      if (_optind \u003d\u003d param_1) {\n        FUN_00102980(\"a.out\");\n      }\n      else {\n        while (lVar19 \u003d (long)_optind, SBORROW4(_optind,param_1) !\u003d iVar8 \u003c 0) {\n          _optind \u003d _optind + 1;\n          FUN_00102980(plVar13[lVar19]);\n          iVar8 \u003d _optind - param_1;\n        }\n      }\n      if ((_DAT_00107334 !\u003d 0) \u0026\u0026 ((DAT_00107348 \u0026 0xfffffffd) \u003d\u003d 0)) {\n        lVar19 \u003d DAT_00107320 + DAT_00107328 + DAT_00107318;\n        iVar8 \u003d (-(uint)(DAT_00107348 \u003d\u003d 0) \u0026 0xfffffffd) + 10;\n        bVar23 \u003d DAT_00107348 \u003d\u003d 0;\n        FUN_00102e90(iVar8);\n        iVar22 \u003d (int)(char)((-bVar23 \u0026 0xe9U) + 0x20);\n        putc(iVar22,_stdout);\n        FUN_00102e90(iVar8,DAT_00107320);\n        putc(iVar22,_stdout);\n        FUN_00102e90(iVar8,DAT_00107318);\n        putc(iVar22,_stdout);\n        if (DAT_00107348 \u003d\u003d 0) {\n          pcVar17 \u003d \"%7lu\\t%7lx\";\n          if (DAT_0010733c \u003d\u003d 1) {\n            pcVar17 \u003d \"%7lo\\t%7lx\";\n          }\n          printf(pcVar17,lVar19,lVar19);\n        }\n        else {\n          FUN_00102e90(iVar8,lVar19);\n        }\n        putc(iVar22,_stdout);\n        fwrite(\"(TOTALS)\\n\",1,9,_stdout);\n      }\n      return DAT_00107314;\n    }\n    FUN_0010281b(_stdout,0);\nLAB_001039f8:\n    uVar16 \u003d dcgettext(0,\"fatal error: libbfd ABI mismatch\",5);\n    FUN_00102db0(uVar16);\nLAB_00103a15:\n    lVar19 \u003d strtol(_optarg,(char **)0x0,10);\n    pcVar10 \u003d _optarg;\n    iVar8 \u003d (int)lVar19;\n    pcVar5 \u003d \u0026optarg;\n    if (iVar8 \u003d\u003d 10) {\nswitchD_001037fd_caseD_64:\n      pcVar10 \u003d pcVar5;\n      DAT_0010733c \u003d 0;\n    }\n    else if (iVar8 \u003d\u003d 0x10) {\nswitchD_001037fd_caseD_78:\n      pcVar10 \u003d pcVar5;\n      DAT_0010733c \u003d 2;\n    }\n    else {\n      if (iVar8 !\u003d 8) {\n        uVar16 \u003d dcgettext(0,\"Invalid radix: %s\\n\",5);\n        pcVar17 \u003d \u0026optarg;\n        do {\n          FUN_00102f40(uVar16,pcVar10);\n          pcVar10 \u003d pcVar17;\nswitchD_001037fd_caseD_3f:\n          FUN_0010281b(_stderr,1);\nLAB_00103bc8:\n          uVar16 \u003d dcgettext(0,\"invalid argument to --format: %s\",5);\n          pcVar17 \u003d pcVar10;\n        } while( true );\n      }\nswitchD_001037fd_caseD_6f:\n      pcVar10 \u003d pcVar5;\n      DAT_0010733c \u003d 1;\n    }\n  } while( true );\nLAB_001032f0:\n  bVar6 \u003d pbVar18[1];\n  pbVar18 \u003d pbVar18 + 1;\n  if (bVar6 \u003d\u003d 0) goto LAB_0010370f;\n  goto LAB_00103300;\n}\n\n",
      "renaming": {},
      "calling": [
        "entry"
      ],
      "called": [
        "bfd_errmsg",
        "xexit",
        "fprintf",
        "bfd_get_error",
        "xstrdup",
        "fseek",
        "free",
        "FUN_0010281b",
        "memcpy",
        "fwrite",
        "FUN_00102e90",
        "stat",
        "bindtextdomain",
        "FUN_00102db0",
        "setlocale",
        "fclose",
        "xrealloc",
        "fopen",
        "fread",
        "ftell",
        "FUN_00102f40",
        "getopt_long",
        "bfd_set_default_target",
        "exit",
        "putc",
        "xmalloc_set_program_name",
        "printf",
        "xmalloc",
        "dcgettext",
        "bfd_set_error_program_name",
        "FUN_00102980",
        "textdomain",
        "ferror",
        "memmove",
        "strtol",
        "bfd_init",
        "strlen"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103c50": {
      "entrypoint": "0x00103c50",
      "current_name": "FUN_00103c50",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nundefined8 FUN_00103c50(undefined8 param_1,char **param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  char *pcVar1;\n  undefined8 in_RAX;\n  size_t sVar2;\n  \n  if (*(uint *)((long)param_2 + 0x24) !\u003d 0) {\n    if (((param_2 !\u003d (char **)0x108370) \u0026\u0026 ((*(uint *)((long)param_2 + 0x24) \u0026 0x1000) \u003d\u003d 0)) \u0026\u0026\n       (param_2 !\u003d (char **)0x108258)) {\n      pcVar1 \u003d param_2[8];\n      sVar2 \u003d strlen(*param_2);\n      if (DAT_001072d0 \u003c (int)sVar2) {\n        DAT_001072d0 \u003d (int)sVar2;\n      }\n      DAT_001072e0 \u003d DAT_001072e0 + (long)pcVar1;\n      if (DAT_001072d8 \u003c param_2[6]) {\n        DAT_001072d8 \u003d param_2[6];\n      }\n    }\n    return param_4;\n  }\n  return in_RAX;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90"
      ],
      "called": [
        "FUN_001026ea",
        "strlen"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103cc0": {
      "entrypoint": "0x00103cc0",
      "current_name": "FUN_00103cc0",
      "code": "\nvoid FUN_00103cc0(undefined8 param_1,undefined8 *param_2)\n\n{\n  if ((((*(uint *)((long)param_2 + 0x24) !\u003d 0) \u0026\u0026 (param_2 !\u003d (undefined8 *)0x108370)) \u0026\u0026\n      ((*(uint *)((long)param_2 + 0x24) \u0026 0x1000) \u003d\u003d 0)) \u0026\u0026 (param_2 !\u003d (undefined8 *)0x108258)) {\n    DAT_001072e0 \u003d DAT_001072e0 + param_2[8];\n    FUN_00102fe0(*param_2,param_2[8],param_2[6]);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102a90"
      ],
      "called": [
        "FUN_00102fe0",
        "FUN_0010274a"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103d20": {
      "entrypoint": "0x00103d20",
      "current_name": "FUN_00103d20",
      "code": "\n\n\nvoid FUN_00103d20(long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 in_R10;\n  \n  iVar1 \u003d bfd_get_error();\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    uVar2 \u003d bfd_errmsg(iVar1);\n  }\n  fflush(_stdout);\n  if (param_1 !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_00107350,param_1,uVar2,in_R10);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_00107350,uVar2,in_R10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023b6",
        "FUN_00102a90",
        "FUN_001024d2"
      ],
      "called": [
        "bfd_errmsg",
        "FUN_0010274b",
        "bfd_get_error"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_DT_FINI": {
      "entrypoint": "0x00103d80",
      "current_name": "_DT_FINI",
      "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}