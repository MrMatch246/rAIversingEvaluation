{
  "functions": {
    "_DT_INIT": {
      "entrypoint": "0x00102000",
      "current_name": "_DT_INIT",
      "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__gmon_start__"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102020": {
      "entrypoint": "0x00102020",
      "current_name": "FUN_00102020",
      "code": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle_name_to_style": {
      "entrypoint": "0x00102030",
      "current_name": "cplus_demangle_name_to_style",
      "code": "\nvoid cplus_demangle_name_to_style(void)\n\n{\n  cplus_demangle_name_to_style();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "cplus_demangle_name_to_style"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x00102040",
      "current_name": "free",
      "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023e1",
        "FUN_001027b0"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_scan_vma": {
      "entrypoint": "0x00102050",
      "current_name": "bfd_scan_vma",
      "code": "\nvoid bfd_scan_vma(void)\n\n{\n  bfd_scan_vma();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_scan_vma"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "putchar": {
      "entrypoint": "0x00102060",
      "current_name": "putchar",
      "code": "\n\n\nint putchar(int __c)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d putchar(__c);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "putchar"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__errno_location": {
      "entrypoint": "0x00102070",
      "current_name": "__errno_location",
      "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 \u003d __errno_location();\n  return piVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "puts": {
      "entrypoint": "0x00102080",
      "current_name": "puts",
      "code": "\n\n\nint puts(char *__s)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d puts(__s);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "puts"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ferror": {
      "entrypoint": "0x00102090",
      "current_name": "ferror",
      "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d ferror(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "ferror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_default_target": {
      "entrypoint": "0x001020a0",
      "current_name": "bfd_set_default_target",
      "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_set_default_target"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fread": {
      "entrypoint": "0x001020b0",
      "current_name": "fread",
      "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "fread"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "cplus_demangle_set_style": {
      "entrypoint": "0x001020c0",
      "current_name": "cplus_demangle_set_style",
      "code": "\nvoid cplus_demangle_set_style(void)\n\n{\n  cplus_demangle_set_style();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "cplus_demangle_set_style"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "textdomain": {
      "entrypoint": "0x001020d0",
      "current_name": "textdomain",
      "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "textdomain"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openr": {
      "entrypoint": "0x001020e0",
      "current_name": "bfd_openr",
      "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_openr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x001020f0",
      "current_name": "fclose",
      "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fclose(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "fclose"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bindtextdomain": {
      "entrypoint": "0x00102100",
      "current_name": "bindtextdomain",
      "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bindtextdomain"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dcgettext": {
      "entrypoint": "0x00102110",
      "current_name": "dcgettext",
      "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023e1",
        "FUN_001023a0",
        "FUN_001027b0"
      ],
      "called": [
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x00102120",
      "current_name": "strlen",
      "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d strlen(__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getopt_long": {
      "entrypoint": "0x00102130",
      "current_name": "getopt_long",
      "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "getopt_long"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strchr": {
      "entrypoint": "0x00102140",
      "current_name": "strchr",
      "code": "\n\n\nchar * strchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strchr(__s,__c);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "strchr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printf": {
      "entrypoint": "0x00102150",
      "current_name": "printf",
      "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d printf(__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "printf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xrealloc": {
      "entrypoint": "0x00102160",
      "current_name": "xrealloc",
      "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "xrealloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strrchr": {
      "entrypoint": "0x00102170",
      "current_name": "strrchr",
      "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "strrchr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_target_list": {
      "entrypoint": "0x00102180",
      "current_name": "bfd_target_list",
      "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023e1"
      ],
      "called": [
        "bfd_target_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_error": {
      "entrypoint": "0x00102190",
      "current_name": "bfd_get_error",
      "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0",
        "FUN_00103c70"
      ],
      "called": [
        "bfd_get_error"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc": {
      "entrypoint": "0x001021a0",
      "current_name": "xmalloc",
      "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc_set_program_name": {
      "entrypoint": "0x001021b0",
      "current_name": "xmalloc_set_program_name",
      "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "xmalloc_set_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xstrdup": {
      "entrypoint": "0x001021c0",
      "current_name": "xstrdup",
      "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "xstrdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fputc": {
      "entrypoint": "0x001021d0",
      "current_name": "fputc",
      "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fputc(__c,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023e1",
        "FUN_001027b0"
      ],
      "called": [
        "fputc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_section_by_name": {
      "entrypoint": "0x001021e0",
      "current_name": "bfd_get_section_by_name",
      "code": "\nvoid bfd_get_section_by_name(void)\n\n{\n  bfd_get_section_by_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_get_section_by_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fgets": {
      "entrypoint": "0x001021f0",
      "current_name": "fgets",
      "code": "\n\n\nchar * fgets(char *__s,int __n,FILE *__stream)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d fgets(__s,__n,__stream);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "fgets"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_init": {
      "entrypoint": "0x00102200",
      "current_name": "bfd_init",
      "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcmp": {
      "entrypoint": "0x00102210",
      "current_name": "strcmp",
      "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "putc": {
      "entrypoint": "0x00102220",
      "current_name": "putc",
      "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d putc(__c,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001025c0"
      ],
      "called": [
        "putc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fprintf": {
      "entrypoint": "0x00102230",
      "current_name": "fprintf",
      "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001025c0",
        "FUN_001023e1",
        "FUN_001023a0",
        "FUN_001027b0"
      ],
      "called": [
        "fprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ftell": {
      "entrypoint": "0x00102240",
      "current_name": "ftell",
      "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d ftell(__stream);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "ftell"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stat": {
      "entrypoint": "0x00102250",
      "current_name": "stat",
      "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d stat(__file,__buf);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "stat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x00102260",
      "current_name": "memcpy",
      "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "memcpy"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fflush": {
      "entrypoint": "0x00102270",
      "current_name": "fflush",
      "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fflush(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001025c0",
        "FUN_001023a0",
        "FUN_001027b0"
      ],
      "called": [
        "fflush"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fseek": {
      "entrypoint": "0x00102280",
      "current_name": "fseek",
      "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "fseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setlocale": {
      "entrypoint": "0x00102290",
      "current_name": "setlocale",
      "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "setlocale"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_error_program_name": {
      "entrypoint": "0x001022a0",
      "current_name": "bfd_set_error_program_name",
      "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_set_error_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x001022b0",
      "current_name": "memmove",
      "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "memmove"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_demangle": {
      "entrypoint": "0x001022c0",
      "current_name": "bfd_demangle",
      "code": "\nvoid bfd_demangle(void)\n\n{\n  bfd_demangle();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_demangle"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fopen": {
      "entrypoint": "0x001022d0",
      "current_name": "fopen",
      "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 \u003d fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "fopen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xexit": {
      "entrypoint": "0x001022e0",
      "current_name": "xexit",
      "code": "\nvoid xexit(void)\n\n{\n  xexit();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bd0",
        "FUN_001027b0"
      ],
      "called": [
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_close": {
      "entrypoint": "0x001022f0",
      "current_name": "bfd_close",
      "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "vfprintf": {
      "entrypoint": "0x00102300",
      "current_name": "vfprintf",
      "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001025c0"
      ],
      "called": [
        "vfprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_check_format_matches": {
      "entrypoint": "0x00102310",
      "current_name": "bfd_check_format_matches",
      "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_check_format_matches"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtoul": {
      "entrypoint": "0x00102320",
      "current_name": "strtoul",
      "code": "\n\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 \u003d strtoul(__nptr,__endptr,__base);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "strtoul"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_errmsg": {
      "entrypoint": "0x00102330",
      "current_name": "bfd_errmsg",
      "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0",
        "FUN_00103c70"
      ],
      "called": [
        "bfd_errmsg"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "exit": {
      "entrypoint": "0x00102340",
      "current_name": "exit",
      "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001023e1",
        "FUN_001027b0"
      ],
      "called": [
        "exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_check_format": {
      "entrypoint": "0x00102350",
      "current_name": "bfd_check_format",
      "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_check_format"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_fprintf_vma": {
      "entrypoint": "0x00102360",
      "current_name": "bfd_fprintf_vma",
      "code": "\nvoid bfd_fprintf_vma(void)\n\n{\n  bfd_fprintf_vma();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_fprintf_vma"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_map_over_sections": {
      "entrypoint": "0x00102370",
      "current_name": "bfd_map_over_sections",
      "code": "\nvoid bfd_map_over_sections(void)\n\n{\n  bfd_map_over_sections();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_map_over_sections"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strerror": {
      "entrypoint": "0x00102380",
      "current_name": "strerror",
      "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strerror(__errnum);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "strerror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_finalize": {
      "entrypoint": "0x00102390",
      "current_name": "__cxa_finalize",
      "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "__cxa_finalize"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001023a0": {
      "entrypoint": "0x001023a0",
      "current_name": "FUN_001023a0",
      "code": "\n\n\nvoid FUN_001023a0(void)\n\n{\n  undefined8 uVar1;\n  long unaff_RBX;\n  undefined8 unaff_retaddr;\n  \n  uVar1 \u003d dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (unaff_RBX !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_00106438);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_00106438,uVar1,unaff_retaddr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103c70"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "fflush"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001023e1": {
      "entrypoint": "0x001023e1",
      "current_name": "FUN_001023e1",
      "code": "\nvoid FUN_001023e1(FILE *param_1,int param_2)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long *__ptr;\n  long *plVar3;\n  \n  lVar1 \u003d DAT_00106438;\n  pcVar2 \u003d (char *)dcgettext(0,\"Usage: %s [option(s)] [addr(s)]\\n\",5);\n  fprintf(param_1,pcVar2,lVar1);\n  pcVar2 \u003d (char *)dcgettext(0,\" Convert addresses into line number/file name pairs.\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \" If no addresses are specified on the command line, they will be read from stdin\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \" The options are:\\n  @\u003cfile\u003e                Read options from \u003cfile\u003e\\n  -a --addresses         Show addresses\\n  -b --target\u003d\u003cbfdname\u003e  Set the binary file format\\n  -e --exe\u003d\u003cexecutable\u003e  Set the input file name (default is a.out)\\n  -i --inlines           Unwind inlined functions\\n  -j --section\u003d\u003cname\u003e    Read section-relative offsets instead of addresses\\n  -p --pretty-print      Make the output easier to read for humans\\n  -s --basenames         Strip directory names\\n  -f --functions         Show function names\\n  -C --demangle[\u003dstyle]  Demangle function names\\n  -R --recurse-limit     Enable a limit on recursion whilst demangling.  [Default]\\n  -r --no-recurse-limit  Disable a limit on recursion whilst demangling\\n  -h --help              Display this information\\n  -v --version           Display the program\\\u0027s version\\n\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  lVar1 \u003d DAT_00106438;\n  if (DAT_00106438 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(param_1,pcVar2);\n  }\n  else {\n    pcVar2 \u003d (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(param_1,pcVar2,lVar1);\n  }\n  __ptr \u003d (long *)bfd_target_list();\n  plVar3 \u003d __ptr;\n  while( true ) {\n    lVar1 \u003d *plVar3;\n    plVar3 \u003d plVar3 + 1;\n    if (lVar1 \u003d\u003d 0) break;\n    fprintf(param_1,\" %s\");\n  }\n  fputc(10,param_1);\n  free(__ptr);\n  if (param_2 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(param_1,pcVar2,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n                    \n  exit(param_2);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "free",
        "fprintf",
        "exit",
        "fputc",
        "dcgettext",
        "bfd_target_list"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102540": {
      "entrypoint": "0x00102540",
      "current_name": "FUN_00102540",
      "code": "\nvoid FUN_00102540(long param_1,long param_2)\n\n{\n  ulong uVar1;\n  \n  if ((DAT_00106408 \u003d\u003d \u0027\\0\u0027) \u0026\u0026 ((*(byte *)(param_2 + 0x24) \u0026 1) !\u003d 0)) {\n    uVar1 \u003d *(ulong *)(param_2 + 0x30);\n    if ((uVar1 \u003c\u003d DAT_00106410) \u0026\u0026 (DAT_00106410 \u003c *(long *)(param_2 + 0x40) + uVar1)) {\n      DAT_00106408 \u003d (**(code **)(*(long *)(param_1 + 8) + 0x240))\n                               (param_1,DAT_00106418,param_2,DAT_00106410 - uVar1,\u0026DAT_001063f8,\n                                \u0026DAT_00106400,\u0026DAT_001063f4,\u0026DAT_001063f0);\n      return;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001025c0": {
      "entrypoint": "0x001025c0",
      "current_name": "FUN_001025c0",
      "code": "\n\n\nvoid FUN_001025c0(char *param_1,__gnuc_va_list param_2)\n\n{\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",DAT_00106438);\n  vfprintf(_stderr,param_1,param_2);\n  putc(10,_stderr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102620",
        "FUN_00103bd0"
      ],
      "called": [
        "putc",
        "vfprintf",
        "fprintf",
        "fflush"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102620": {
      "entrypoint": "0x00102620",
      "current_name": "FUN_00102620",
      "code": "\nvoid FUN_00102620(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_88 \u003d param_1;\n    local_78 \u003d param_2;\n    local_68 \u003d param_3;\n    local_58 \u003d param_4;\n    local_48 \u003d param_5;\n    local_38 \u003d param_6;\n    local_28 \u003d param_7;\n    local_18 \u003d param_8;\n  }\n  local_d0 \u003d \u0026stack0x00000008;\n  local_d8 \u003d 8;\n  local_c8 \u003d local_b8;\n  local_d4 \u003d 0x30;\n  local_b0 \u003d param_10;\n  local_a8 \u003d param_11;\n  local_a0 \u003d param_12;\n  local_98 \u003d param_13;\n  local_90 \u003d param_14;\n  FUN_001025c0(param_9,\u0026local_d8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "FUN_001025c0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "entry": {
      "entrypoint": "0x001026c0",
      "current_name": "entry",
      "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_001027b0,param_2,\u0026stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__libc_start_main",
        "FUN_001027b0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001026f0": {
      "entrypoint": "0x001026f0",
      "current_name": "FUN_001026f0",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00102703) */\n/* WARNING: Removing unreachable block (ram,0x0010270f) */\n\nvoid FUN_001026f0(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "_ITM_deregisterTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102720": {
      "entrypoint": "0x00102720",
      "current_name": "FUN_00102720",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00102744) */\n/* WARNING: Removing unreachable block (ram,0x00102750) */\n\nvoid FUN_00102720(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_INIT_0"
      ],
      "called": [
        "_ITM_registerTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_FINI_0": {
      "entrypoint": "0x00102760",
      "current_name": "_FINI_0",
      "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_001063e0 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_001061c8);\n  FUN_001026f0();\n  DAT_001063e0 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_001026f0",
        "__cxa_finalize"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_INIT_0": {
      "entrypoint": "0x001027a0",
      "current_name": "_INIT_0",
      "code": "\nvoid _INIT_0(void)\n\n{\n  FUN_00102720();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00102720"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001027b0": {
      "entrypoint": "0x001027b0",
      "current_name": "FUN_001027b0",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\n\nundefined8 FUN_001027b0(uint param_1,FILE *param_2)\n\n{\n  byte *pbVar1;\n  uint *puVar2;\n  byte bVar3;\n  ushort uVar4;\n  long lVar5;\n  bool bVar6;\n  bool bVar7;\n  bool bVar8;\n  void *pvVar9;\n  byte bVar10;\n  char cVar11;\n  int iVar12;\n  uint uVar13;\n  int iVar14;\n  undefined4 uVar15;\n  FILE *__stream;\n  byte *__s;\n  undefined **ppuVar16;\n  size_t sVar17;\n  byte *__ptr;\n  undefined *puVar18;\n  FILE *pFVar19;\n  long lVar20;\n  stat *psVar21;\n  undefined8 uVar22;\n  int *piVar23;\n  undefined **ppuVar24;\n  stat *__s_00;\n  ulong uVar25;\n  long *plVar26;\n  FILE *pFVar27;\n  char *pcVar28;\n  byte *pbVar29;\n  char *unaff_RBP;\n  long lVar30;\n  byte *pbVar31;\n  char *pcVar32;\n  undefined **ppuVar33;\n  int iVar34;\n  undefined **unaff_R12;\n  stat *psVar35;\n  int iVar36;\n  uint uVar37;\n  undefined **local_148;\n  undefined **local_140;\n  size_t local_120;\n  long local_118;\n  long *local_d0;\n  stat local_c8;\n  \n  pFVar27 \u003d (FILE *)(ulong)param_1;\n  setlocale(5,\"\");\n  pcVar28 \u003d \"binutils\";\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_00106438 \u003d *(long **)param_2;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_00106438);\n  pFVar19 \u003d param_2;\n  __stream \u003d param_2;\n  if (1 \u003c (int)param_1) {\n    iVar14 \u003d 2000;\n    unaff_R12 \u003d (undefined **)0x1;\n    local_140 \u003d (undefined **)0x0;\n    do {\n      iVar34 \u003d (int)unaff_R12;\n      unaff_RBP \u003d (char *)(long)iVar34;\n      local_148 \u003d (undefined **)((long)unaff_RBP * 8);\n      iVar36 \u003d (int)pFVar27;\n      if (**(char **)(\u0026pFVar19-\u003e_flags + (long)unaff_RBP * 2) \u003d\u003d \u0027@\u0027) {\n        iVar14 \u003d iVar14 + -1;\n        if (iVar14 \u003d\u003d 0) {\n          plVar26 \u003d *(long **)pFVar19;\n          pcVar28 \u003d \"%s: error: too many @-files encountered\\n\";\n          goto LAB_00103239;\n        }\n        pcVar28 \u003d *(char **)(\u0026pFVar19-\u003e_flags + (long)unaff_RBP * 2) + 1;\n        iVar12 \u003d stat(pcVar28,\u0026local_c8);\n        if (iVar12 \u003c 0) goto LAB_00102c30;\n        if ((local_c8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n          do {\n            plVar26 \u003d *(long **)pFVar19;\n            pcVar28 \u003d \"%s: error: @-file refers to a directory\\n\";\nLAB_00103239:\n            fprintf(_stderr,pcVar28,plVar26);\n            xexit(1);\n          } while( true );\n        }\n        __stream \u003d fopen(pcVar28,\"r\");\n        if (__stream \u003d\u003d (FILE *)0x0) goto LAB_00102c30;\n        iVar12 \u003d fseek(__stream,0,2);\n        if (((iVar12 \u003d\u003d -1) ||\n            (pcVar28 \u003d (char *)ftell(__stream),\n            (undefined **)pcVar28 \u003d\u003d (undefined **)0xffffffffffffffff)) ||\n           (iVar12 \u003d fseek(__stream,0,0), iVar12 \u003d\u003d -1)) {\nLAB_00102c90:\n          fclose(__stream);\n          if (iVar34 + 1 \u003c iVar36) goto LAB_00102c3a;\n          break;\n        }\n        __s \u003d (byte *)xmalloc((long)pcVar28 + 1);\n        ppuVar16 \u003d (undefined **)fread(__s,1,(size_t)pcVar28,__stream);\n        if (((undefined **)pcVar28 !\u003d ppuVar16) \u0026\u0026 (iVar12 \u003d ferror(__stream), iVar12 !\u003d 0)) {\n          free(__s);\n          goto LAB_00102c90;\n        }\n        __s[(long)ppuVar16] \u003d 0;\n        bVar10 \u003d *__s;\n        pbVar29 \u003d __s;\n        if (bVar10 !\u003d 0) {\nLAB_00102980:\n          if (((\u0026_sch_istable)[(ulong)bVar10 * 2] \u0026 0x40) !\u003d 0) goto LAB_00102970;\n          sVar17 \u003d strlen((char *)__s);\n          __ptr \u003d (byte *)xmalloc(sVar17 + 1);\n          ppuVar16 \u003d (undefined **)0x0;\n          iVar12 \u003d 0;\n          bVar6 \u003d false;\n          bVar7 \u003d false;\n          bVar8 \u003d false;\n          local_118 \u003d 0;\n          pbVar29 \u003d __s;\n          do {\n            while (((\u0026_sch_istable)[(ulong)*pbVar29 * 2] \u0026 0x40) !\u003d 0) {\n              pbVar29 \u003d pbVar29 + 1;\n            }\n            if ((iVar12 \u003d\u003d 0) || (ppuVar24 \u003d ppuVar16 + local_118, iVar12 + -1 \u003c\u003d (int)local_118)) {\n              if (ppuVar16 \u003d\u003d (undefined **)0x0) {\n                ppuVar16 \u003d (undefined **)xmalloc(0x40);\n                iVar12 \u003d 8;\n                ppuVar24 \u003d ppuVar16 + local_118;\n                *ppuVar24 \u003d (undefined *)0x0;\n              }\n              else {\n                iVar12 \u003d iVar12 * 2;\n                ppuVar16 \u003d (undefined **)xrealloc(ppuVar16,(long)iVar12 \u003c\u003c 3);\n                ppuVar24 \u003d ppuVar16 + local_118;\n                *ppuVar24 \u003d (undefined *)0x0;\n              }\n            }\n            bVar10 \u003d *pbVar29;\n            pbVar31 \u003d __ptr;\n            while (bVar10 !\u003d 0) {\n              while( true ) {\n                if ((((\u0026_sch_istable)[(ulong)bVar10 * 2] \u0026 0x40) !\u003d 0) \u0026\u0026\n                   (!(bool)(bVar8 | bVar7 | bVar6))) {\n                  bVar8 \u003d false;\n                  bVar6 \u003d false;\n                  bVar7 \u003d false;\n                  goto LAB_00102a9e;\n                }\n                if (!bVar8) break;\n                pbVar29 \u003d pbVar29 + 1;\n                *pbVar31 \u003d bVar10;\n                pbVar31 \u003d pbVar31 + 1;\n                bVar8 \u003d false;\n                bVar10 \u003d *pbVar29;\n                if (bVar10 \u003d\u003d 0) goto LAB_00102a9e;\n              }\n              if (bVar10 \u003d\u003d 0x5c) {\n                bVar8 \u003d true;\n              }\n              else if (bVar7) {\n                if (bVar10 \u003d\u003d 0x27) {\n                  bVar7 \u003d false;\n                }\n                else {\nLAB_00102c0d:\n                  *pbVar31 \u003d bVar10;\n                  pbVar31 \u003d pbVar31 + 1;\n                }\n              }\n              else if (bVar6) {\n                if (bVar10 !\u003d 0x22) goto LAB_00102c0d;\n                bVar6 \u003d false;\n              }\n              else if (bVar10 \u003d\u003d 0x27) {\n                bVar7 \u003d true;\n              }\n              else {\n                if (bVar10 !\u003d 0x22) goto LAB_00102c0d;\n                bVar6 \u003d true;\n              }\n              pbVar1 \u003d pbVar29 + 1;\n              pbVar29 \u003d pbVar29 + 1;\n              bVar10 \u003d *pbVar1;\n            }\nLAB_00102a9e:\n            *pbVar31 \u003d 0;\n            puVar18 \u003d (undefined *)xstrdup(__ptr);\n            *ppuVar24 \u003d puVar18;\n            ppuVar16[local_118 + 1] \u003d (undefined *)0x0;\n            bVar10 \u003d *pbVar29;\n            bVar3 \u003d (\u0026_sch_istable)[(ulong)bVar10 * 2];\n            while ((bVar3 \u0026 0x40) !\u003d 0) {\n              bVar10 \u003d pbVar29[1];\n              pbVar29 \u003d pbVar29 + 1;\n              bVar3 \u003d (\u0026_sch_istable)[(ulong)bVar10 * 2];\n            }\n            local_118 \u003d local_118 + 1;\n          } while (bVar10 !\u003d 0);\n          free(__ptr);\n          pFVar27 \u003d pFVar19;\n          if (param_2 \u003d\u003d pFVar19) goto LAB_001030d9;\n          goto LAB_00102b38;\n        }\nLAB_001030bb:\n        ppuVar16 \u003d (undefined **)xmalloc(8);\n        *ppuVar16 \u003d (undefined *)0x0;\n        if (param_2 \u003d\u003d pFVar19) {\nLAB_001030d9:\n          if (*(long **)pFVar19 \u003d\u003d (long *)0x0) {\n            iVar12 \u003d 0;\n          }\n          else {\n            lVar20 \u003d 1;\n            do {\n              iVar12 \u003d (int)lVar20;\n              lVar30 \u003d lVar20 * 2;\n              lVar20 \u003d lVar20 + 1;\n            } while (*(long *)(\u0026pFVar19-\u003e_flags + lVar30) !\u003d 0);\n          }\n          pFVar27 \u003d (FILE *)xmalloc((long)(iVar12 + 1) \u003c\u003c 3);\n          plVar26 \u003d *(long **)pFVar19;\n          lVar20 \u003d 0;\n          while (plVar26 !\u003d (long *)0x0) {\n            uVar22 \u003d xstrdup();\n            *(undefined8 *)((long)\u0026pFVar27-\u003e_flags + lVar20) \u003d uVar22;\n            plVar26 \u003d *(long **)(pFVar19-\u003e_shortbuf + lVar20 + -0x7b);\n            lVar20 \u003d lVar20 + 8;\n          }\n          *(undefined8 *)((long)\u0026pFVar27-\u003e_flags + lVar20) \u003d 0;\nLAB_00102b38:\n          pFVar19 \u003d pFVar27;\n          if (*ppuVar16 \u003d\u003d (undefined *)0x0) goto LAB_0010318e;\n          pcVar28 \u003d (char *)0x0;\n          do {\n            pcVar28 \u003d (char *)((long)pcVar28 + 1);\n          } while (ppuVar16[(long)pcVar28] !\u003d (undefined *)0x0);\n          local_120 \u003d (long)pcVar28 * 8;\n        }\n        else {\nLAB_0010318e:\n          pcVar28 \u003d (char *)0x0;\n          local_120 \u003d 0;\n        }\n        free(*(void **)(\u0026pFVar19-\u003e_flags + (long)unaff_RBP * 2));\n        pFVar19 \u003d (FILE *)xrealloc(pFVar19,((long)pcVar28 + (long)iVar36 + 1) * 8);\n        uVar37 \u003d iVar36 + -1 + (int)pcVar28;\n        pFVar27 \u003d (FILE *)(ulong)uVar37;\n        memmove(\u0026pFVar19-\u003e_flags + (long)(FILE **)((long)unaff_RBP + (long)pcVar28) * 2,\n                \u0026pFVar19-\u003e_IO_read_ptr + (long)unaff_RBP,(long)(iVar36 - iVar34) \u003c\u003c 3);\n        memcpy(\u0026pFVar19-\u003e_flags + (long)unaff_RBP * 2,ppuVar16,local_120);\n        free(ppuVar16);\n        free(__s);\n        fclose(__stream);\n        uVar13 \u003d (int)local_140 + 1;\n        unaff_RBP \u003d (char *)(FILE **)((long)unaff_RBP + (long)pcVar28);\n        unaff_R12 \u003d local_148;\n        local_148 \u003d ppuVar16;\n        if ((int)uVar37 \u003c\u003d (int)uVar13) break;\n      }\n      else {\nLAB_00102c30:\n        if (iVar36 \u003c\u003d iVar34 + 1) break;\nLAB_00102c3a:\n        uVar13 \u003d iVar34 + 1;\n        local_140 \u003d unaff_R12;\n      }\n      unaff_R12 \u003d (undefined **)(ulong)uVar13;\n    } while( true );\n  }\n  iVar14 \u003d bfd_init();\n  if (iVar14 !\u003d 0x118) {\n    uVar22 \u003d dcgettext(0,\"fatal error: libbfd ABI mismatch\",5);\n    FUN_00103bd0(uVar22);\n    goto switchD_00102d16_caseD_43;\n  }\n  pcVar28 \u003d \"x86_64-pc-linux-gnu\";\n  cVar11 \u003d bfd_set_default_target();\n  if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n    uVar15 \u003d bfd_get_error();\n    unaff_RBP \u003d (char *)bfd_errmsg(uVar15);\n    uVar22 \u003d dcgettext(0,\"can\\\u0027t set BFD default target to `%s\\\u0027: %s\",5);\n    FUN_00103bd0(uVar22,\"x86_64-pc-linux-gnu\",unaff_RBP);\n    goto switchD_00102d16_caseD_61;\n  }\n  unaff_R12 \u003d \u0026PTR_s_addresses_001061e0;\n  local_140 \u003d (undefined **)0x0;\n  unaff_RBP \u003d \"ab:Ce:rRsfHhij:pVv\";\n  local_148 \u003d (undefined **)0x0;\n  pcVar28 \u003d (char *)(undefined **)0x0;\nswitchD_00102d16_caseD_0:\n  do {\n    uVar15 \u003d getopt_long(pFVar27,pFVar19,unaff_RBP,unaff_R12,0);\n    switch(uVar15) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n    case 6:\n    case 7:\n    case 8:\n    case 9:\n    case 10:\n    case 0xb:\n    case 0xc:\n    case 0xd:\n    case 0xe:\n    case 0xf:\n    case 0x10:\n    case 0x11:\n    case 0x12:\n    case 0x13:\n    case 0x14:\n    case 0x15:\n    case 0x16:\n    case 0x17:\n    case 0x18:\n    case 0x19:\n    case 0x1a:\n    case 0x1b:\n    case 0x1c:\n    case 0x1d:\n    case 0x1e:\n    case 0x1f:\n    case 0x20:\n    case 0x21:\n    case 0x22:\n    case 0x23:\n    case 0x24:\n    case 0x25:\n    case 0x26:\n    case 0x27:\n    case 0x28:\n    case 0x29:\n    case 0x2a:\n    case 0x2b:\n    case 0x2c:\n    case 0x2d:\n    case 0x2e:\n    case 0x2f:\n    case 0x30:\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x41:\n    case 0x42:\n    case 0x44:\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x49:\n    case 0x4a:\n    case 0x4b:\n    case 0x4c:\n    case 0x4d:\n    case 0x4e:\n    case 0x4f:\n    case 0x50:\n    case 0x51:\n    case 0x53:\n    case 0x54:\n    case 0x55:\n    case 0x57:\n    case 0x58:\n    case 0x59:\n    case 0x5a:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x5e:\n    case 0x5f:\n    case 0x60:\n    case 99:\n    case 100:\n    case 0x67:\n    case 0x6b:\n    case 0x6c:\n    case 0x6d:\n    case 0x6e:\n    case 0x6f:\n    case 0x71:\n    case 0x74:\n    case 0x75:\n      FUN_001023e1(_stderr,1);\n    case 0x6a:\n      local_148 \u003d _optarg;\n      break;\n    case 0x43:\nswitchD_00102d16_caseD_43:\n      __stream \u003d (FILE *)\u0026optarg;\n      DAT_00106434 \u003d \u0027\\x01\u0027;\n      if (_optarg !\u003d (undefined **)0x0) {\n        iVar14 \u003d cplus_demangle_name_to_style();\n        if (iVar14 \u003d\u003d 0) goto LAB_0010339f;\n        cplus_demangle_set_style();\n      }\n      break;\n    case 0x48:\n    case 0x68:\n      FUN_001023e1(_stdout,0);\nLAB_0010339f:\n      pcVar28 \u003d *(char **)__stream;\n      pcVar32 \u003d \"unknown demangling style `%s\\\u0027\";\nLAB_001033ae:\n      uVar22 \u003d dcgettext(0,pcVar32,5);\n      FUN_00103bd0(uVar22,pcVar28);\nswitchD_00102d16_caseD_72:\n      DAT_001061d0 \u003d DAT_001061d0 | 0x40000;\n      break;\n    case 0x52:\n      DAT_001061d0 \u003d DAT_001061d0 \u0026 0xfffbffff;\n      break;\n    case 0x56:\n    case 0x76:\n      printf(\"GNU %s %s\\n\",\"addr2line\",\"(GNU Binutils for Debian) 2.40\");\n      pcVar28 \u003d (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n      printf(pcVar28);\n      pcVar28 \u003d (char *)dcgettext(0,\n                                  \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                                  ,5);\n      printf(pcVar28);\n                    \n      exit(0);\n    case 0x61:\nswitchD_00102d16_caseD_61:\n      DAT_00106435 \u003d \u0027\\x01\u0027;\n      break;\n    case 0x62:\n      local_140 \u003d _optarg;\n      break;\n    case 0x65:\n      pcVar28 \u003d (char *)_optarg;\n      break;\n    case 0x66:\n      DAT_00106432 \u003d \u0027\\x01\u0027;\n      break;\n    case 0x69:\n      DAT_00106430 \u003d \u0027\\x01\u0027;\n      break;\n    case 0x70:\n      DAT_00106431 \u003d \u0027\\x01\u0027;\n      break;\n    case 0x72:\n      goto switchD_00102d16_caseD_72;\n    case 0x73:\n      goto switchD_00102d16_caseD_73;\n    default:\n      DAT_00106428 \u003d (char **)(\u0026pFVar19-\u003e_flags + (long)_optind * 2);\n      DAT_00106420 \u003d (int)pFVar27 - _optind;\n      if ((undefined **)pcVar28 \u003d\u003d (undefined **)0x0) {\n        pcVar28 \u003d \"a.out\";\n      }\n      iVar14 \u003d stat(pcVar28,\u0026local_c8);\n      if (iVar14 \u003c 0) {\n        piVar23 \u003d __errno_location();\n        pcVar32 \u003d \"\\\u0027%s\\\u0027: No such file\";\n        if (*piVar23 !\u003d 2) {\n          pcVar32 \u003d strerror(*piVar23);\n          uVar22 \u003d dcgettext(0,\"Warning: could not locate \\\u0027%s\\\u0027.  reason: %s\",5);\n          FUN_00102620(uVar22,pcVar28,pcVar32);\n          return 1;\n        }\nLAB_001039cd:\n        uVar22 \u003d dcgettext(0,pcVar32,5);\n        FUN_00102620(uVar22,pcVar28);\n        return 1;\n      }\n      if ((local_c8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n        pcVar32 \u003d \"Warning: \\\u0027%s\\\u0027 is a directory\";\n        goto LAB_001039cd;\n      }\n      pcVar32 \u003d \"Warning: \\\u0027%s\\\u0027 is not an ordinary file\";\n      if ((local_c8.st_mode \u0026 0xf000) !\u003d 0x8000) goto LAB_001039cd;\n      pcVar32 \u003d \"Warning: \\\u0027%s\\\u0027 has negative size, probably it is too large\";\n      if (local_c8.st_size \u003c 0) goto LAB_001039cd;\n      if (local_c8.st_size \u003d\u003d 0) {\n        return 1;\n      }\n      pFVar19 \u003d (FILE *)bfd_openr(pcVar28,local_140);\n      if (pFVar19 \u003d\u003d (FILE *)0x0) {\n        FUN_00103c70(pcVar28);\n        xexit(1);\n        goto LAB_00103a85;\n      }\n      puVar2 \u003d (uint *)((long)\u0026pFVar19-\u003e_IO_buf_end + 4);\n      *puVar2 \u003d *puVar2 | 0x8000;\n      cVar11 \u003d bfd_check_format(pFVar19,2);\n      if (cVar11 !\u003d \u0027\\0\u0027) {\n        pcVar32 \u003d \"%s: cannot get addresses from archive\";\n        goto LAB_001033ae;\n      }\n      cVar11 \u003d bfd_check_format_matches(pFVar19,1,\u0026local_d0);\n      if (cVar11 \u003d\u003d \u0027\\0\u0027) {\n        FUN_00103c70(*(long **)pFVar19);\n        iVar14 \u003d bfd_get_error();\n        if (iVar14 \u003d\u003d 0xd) {\n          pFVar19 \u003d (FILE *)0x1040e1;\n          fflush(_stdout);\n          plVar26 \u003d DAT_00106438;\n          pcVar28 \u003d (char *)dcgettext(0,\"%s: Matching formats:\",5);\n          fprintf(_stderr,pcVar28,plVar26);\n          for (plVar26 \u003d local_d0; *plVar26 !\u003d 0; plVar26 \u003d plVar26 + 1) {\n            fprintf(_stderr,\" %s\");\n          }\n          free(local_d0);\n          fputc(10,_stderr);\n        }\n        goto LAB_00103801;\n      }\n      ppuVar16 \u003d local_148;\n      if ((local_148 !\u003d (undefined **)0x0) \u0026\u0026\n         (ppuVar16 \u003d (undefined **)bfd_get_section_by_name(pFVar19), ppuVar16 \u003d\u003d (undefined **)0x0))\n      {\n        uVar22 \u003d dcgettext(0,\"%s: cannot find section %s\",5);\n        FUN_00103bd0(uVar22,pcVar28,local_148);\n        goto LAB_0010399c;\n      }\n      local_148 \u003d ppuVar16;\n      if ((*(byte *)((long)\u0026pFVar19-\u003e_IO_buf_end + 4) \u0026 0x10) \u003d\u003d 0) goto LAB_00102ecd;\n      lVar20 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 0x1f8))(pFVar19);\n      if (lVar20 \u003d\u003d 0) {\n        lVar20 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 0x350))(pFVar19);\n        if (-1 \u003c lVar20) {\n          DAT_00106418 \u003d (void *)xmalloc(lVar20);\n          DAT_001063e8 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 0x358))(pFVar19);\n          if (-1 \u003c DAT_001063e8) goto LAB_00102ebf;\n        }\n      }\n      else if (-1 \u003c lVar20) {\n        DAT_00106418 \u003d (void *)xmalloc(lVar20);\n        DAT_001063e8 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 0x200))(pFVar19);\n        if (-1 \u003c DAT_001063e8) {\n          if (DAT_001063e8 \u003d\u003d 0) goto LAB_0010380b;\n          goto LAB_00102ebf;\n        }\n      }\n      FUN_00103c70(*(long **)pFVar19);\nLAB_00103801:\n      xexit(1);\nLAB_0010380b:\n      lVar20 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 0x350))(pFVar19);\n      if (0 \u003c lVar20) {\n        free(DAT_00106418);\n        DAT_00106418 \u003d (void *)xmalloc(lVar20);\n        DAT_001063e8 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 0x358))(pFVar19);\n      }\nLAB_00102ebf:\n      if (DAT_001063e8 \u003c 1) {\n        free(DAT_00106418);\n        DAT_00106418 \u003d (void *)0x0;\n      }\nLAB_00102ecd:\n      unaff_R12 \u003d (undefined **)(ulong)DAT_00106420;\n      __stream \u003d (FILE *)\u0026DAT_0010400a;\n      if (DAT_00106420 \u003d\u003d 0) goto LAB_00103065;\nLAB_00102ee7:\n      if ((int)DAT_00106420 \u003c 1) {\nLAB_0010308a:\n        free(DAT_00106418);\n        DAT_00106418 \u003d (void *)0x0;\n        bfd_close(pFVar19);\n        return 0;\n      }\n      DAT_00106420 \u003d DAT_00106420 - 1;\n      psVar21 \u003d (stat *)*DAT_00106428;\n      DAT_00106428 \u003d DAT_00106428 + 1;\n      do {\n        bVar10 \u003d *(byte *)\u0026psVar21-\u003est_dev;\n        uVar25 \u003d (ulong)bVar10;\n        uVar4 \u003d *(ushort *)(\u0026_sch_istable + uVar25 * 2);\n        __s_00 \u003d psVar21;\n        while ((uVar4 \u0026 0x40) !\u003d 0) {\n          bVar10 \u003d *(byte *)((long)\u0026__s_00-\u003est_dev + 1);\n          uVar25 \u003d (ulong)bVar10;\n          __s_00 \u003d (stat *)((long)\u0026__s_00-\u003est_dev + 1);\n          uVar4 \u003d *(ushort *)(\u0026_sch_istable + uVar25 * 2);\n        }\n        if ((((uVar4 \u0026 4) \u003d\u003d 0) \u0026\u0026 (bVar10 !\u003d 0)) \u0026\u0026\n           ((psVar35 \u003d __s_00, 5 \u003c (byte)((\u0026_sch_toupper)[uVar25] + 0xbf) ||\n            (pcVar28 \u003d strchr((char *)__s_00,0x2b), pcVar28 !\u003d (char *)0x0)))) {\n          while( true ) {\n            bVar10 \u003d *(byte *)\u0026psVar35-\u003est_dev;\n            psVar21 \u003d psVar35;\n            if (((bVar10 \u003d\u003d 0) || ((*(ushort *)(\u0026_sch_istable + (ulong)bVar10 * 2) \u0026 0x40) !\u003d 0)) ||\n               (bVar10 \u003d\u003d 0x2b)) break;\n            psVar35 \u003d (stat *)((long)\u0026psVar35-\u003est_dev + 1);\n          }\n          while (((\u0026_sch_istable)[(ulong)*(byte *)\u0026psVar21-\u003est_dev * 2] \u0026 0x40) !\u003d 0) {\n            psVar21 \u003d (stat *)((long)\u0026psVar21-\u003est_dev + 1);\n          }\n          uVar25 \u003d 0;\n          if (*(byte *)\u0026psVar21-\u003est_dev \u003d\u003d 0x2b) {\n            uVar25 \u003d strtoul((char *)((long)\u0026psVar21-\u003est_dev + 1),(char **)0x0,0);\n          }\n          pvVar9 \u003d DAT_00106418;\n          lVar20 \u003d DAT_001063e8;\n          *(undefined *)\u0026psVar35-\u003est_dev \u003d 0;\n          for (lVar30 \u003d 0; lVar30 \u003c lVar20; lVar30 \u003d lVar30 + 1) {\n            lVar5 \u003d *(long *)((long)pvVar9 + lVar30 * 8);\n            iVar14 \u003d strcmp(*(char **)(lVar5 + 8),(char *)__s_00);\n            if (iVar14 \u003d\u003d 0) {\n              unaff_R12 \u003d (undefined **)((ulong)unaff_R12 \u0026 0xffffffff);\n              DAT_00106410 \u003d (undefined *)\n                             (uVar25 + *(long *)(lVar5 + 0x10) +\n                             *(long *)(*(long *)(lVar5 + 0x20) + 0x30));\n              goto LAB_00102f4b;\n            }\n          }\n          unaff_R12 \u003d (undefined **)((ulong)unaff_R12 \u0026 0xffffffff);\n          for (lVar20 \u003d 0; lVar20 \u003c DAT_001063e8; lVar20 \u003d lVar20 + 1) {\n            pcVar28 \u003d (char *)bfd_demangle(pFVar19,*(undefined8 *)\n                                                    (*(long *)((long)DAT_00106418 + lVar20 * 8) + 8)\n                                           ,DAT_001061d0);\n            if ((pcVar28 !\u003d (char *)0x0) \u0026\u0026 (iVar14 \u003d strcmp(pcVar28,(char *)__s_00), iVar14 \u003d\u003d 0))\n            {\n              free(pcVar28);\n              lVar20 \u003d *(long *)((long)DAT_00106418 + lVar20 * 8);\n              DAT_00106410 \u003d (undefined *)\n                             (*(long *)(lVar20 + 0x10) + uVar25 +\n                             *(long *)(*(long *)(lVar20 + 0x20) + 0x30));\n              goto LAB_00102f4b;\n            }\n            free(pcVar28);\n          }\n          DAT_00106410 \u003d (undefined *)0x0;\n        }\n        else {\n          DAT_00106410 \u003d (undefined *)bfd_scan_vma(psVar21,0,0x10);\n        }\nLAB_00102f4b:\n        if (*(int *)(pFVar19-\u003e_IO_read_ptr + 8) \u003d\u003d 5) {\n          lVar20 \u003d *(long *)(pFVar19-\u003e_IO_read_ptr + 0x380);\n          uVar25 \u003d 1L \u003c\u003c (*(char *)(*(long *)(lVar20 + 0x340) + 10) - 1U \u0026 0x3f);\n          DAT_00106410 \u003d (undefined *)((ulong)DAT_00106410 \u0026 uVar25 * 2 - 1);\n          if ((*(byte *)(lVar20 + 0x3f1) \u0026 1) !\u003d 0) {\n            DAT_00106410 \u003d (undefined *)(((ulong)DAT_00106410 ^ uVar25) - uVar25);\n          }\n        }\n        if (DAT_00106435 !\u003d \u0027\\0\u0027) {\n          printf(\"0x\");\n          bfd_fprintf_vma(pFVar19,_stdout,DAT_00106410);\n          if (DAT_00106431 \u003d\u003d \u0027\\0\u0027) {\n            putchar(10);\n          }\n          else {\n            printf(\": \");\n          }\n        }\n        unaff_RBP \u003d \u0026stdout;\n        DAT_00106408 \u003d \u0027\\0\u0027;\n        if (local_148 \u003d\u003d (undefined **)0x0) {\n          bfd_map_over_sections(pFVar19,FUN_00102540,0);\nLAB_00102fcf:\n          if (DAT_00106408 !\u003d \u0027\\0\u0027) {\n            do {\n              if (DAT_00106432 !\u003d \u0027\\0\u0027) {\n                ppuVar16 \u003d DAT_00106400;\n                if (DAT_00106400 \u003d\u003d (undefined **)0x0) {\nLAB_00103a4a:\n                  ppuVar24 \u003d (undefined **)\u0026DAT_0010400a;\n                }\n                else {\n                  if (*(char *)DAT_00106400 \u003d\u003d \u0027\\0\u0027) {\n                    ppuVar16 \u003d (undefined **)0x0;\n                    goto LAB_00103a4a;\n                  }\n                  pcVar28 \u003d (char *)DAT_00106400;\n                  pFVar27 \u003d pFVar19;\n                  if (DAT_00106434 \u003d\u003d \u0027\\0\u0027) {\nLAB_001031f4:\n                    ppuVar16 \u003d (undefined **)0x0;\n                    ppuVar24 \u003d (undefined **)pcVar28;\n                    pFVar19 \u003d pFVar27;\n                  }\n                  else {\nLAB_0010399c:\n                    ppuVar16 \u003d (undefined **)bfd_demangle(pFVar27,pcVar28,DAT_001061d0);\n                    ppuVar24 \u003d ppuVar16;\n                    pFVar19 \u003d pFVar27;\n                    if (ppuVar16 \u003d\u003d (undefined **)0x0) goto LAB_001031f4;\n                  }\n                }\n                printf(\"%s\",ppuVar24);\n                if (DAT_00106431 \u003d\u003d \u0027\\0\u0027) {\n                  putchar(10);\n                }\n                else {\n                  pcVar28 \u003d (char *)dcgettext(0,\u0026DAT_001040f1,5);\n                  printf(pcVar28);\n                }\n                free(ppuVar16);\n              }\n              pFVar27 \u003d DAT_001063f8;\n              if (DAT_00106433 \u003d\u003d \u0027\\0\u0027) {\n                if (DAT_001063f8 \u003d\u003d (FILE *)0x0) {\n                  pFVar27 \u003d __stream;\n                }\n              }\n              else if (DAT_001063f8 \u003d\u003d (FILE *)0x0) {\n                pFVar27 \u003d (FILE *)\u0026DAT_0010400a;\n              }\n              else {\n                pcVar28 \u003d strrchr((char *)DAT_001063f8,0x2f);\n                if (pcVar28 !\u003d (char *)0x0) {\n                  pFVar27 \u003d (FILE *)(pcVar28 + 1);\n                  DAT_001063f8 \u003d pFVar27;\n                }\n              }\n              printf(\"%s:\",pFVar27);\n              pFVar27 \u003d pFVar19;\n              if (DAT_001063f4 \u003d\u003d 0) {\nLAB_00103a85:\n                puts(\"?\");\n                pFVar19 \u003d pFVar27;\n              }\n              else if (DAT_001063f0 \u003d\u003d 0) {\n                printf(\"%u\\n\");\n              }\n              else {\n                printf(\"%u (discriminator %u)\\n\");\n              }\n              if (DAT_00106430 \u003d\u003d \u0027\\0\u0027) {\nLAB_0010304c:\n                DAT_00106408 \u003d \u0027\\0\u0027;\n                goto LAB_00103053;\n              }\n              DAT_00106408 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 600))\n                                       (pFVar19,\u0026DAT_001063f8,\u0026DAT_00106400,\u0026DAT_001063f4);\n              ppuVar16 \u003d DAT_00106400;\n              if (DAT_00106408 \u003d\u003d \u0027\\0\u0027) goto LAB_00103053;\n              while (DAT_00106400 \u003d ppuVar16, DAT_00106431 \u003d\u003d \u0027\\0\u0027) {\n                if (DAT_00106432 !\u003d \u0027\\0\u0027) {\n                  ppuVar24 \u003d ppuVar16;\n                  if (ppuVar16 \u003d\u003d (undefined **)0x0) {\nLAB_00103b7b:\n                    ppuVar33 \u003d (undefined **)\u0026DAT_0010400a;\n                  }\n                  else {\n                    if (*(char *)ppuVar16 \u003d\u003d \u0027\\0\u0027) {\n                      ppuVar24 \u003d (undefined **)0x0;\n                      goto LAB_00103b7b;\n                    }\n                    if ((DAT_00106434 \u003d\u003d \u0027\\0\u0027) ||\n                       (ppuVar24 \u003d (undefined **)bfd_demangle(pFVar19,ppuVar16,DAT_001061d0),\n                       ppuVar33 \u003d ppuVar24, ppuVar24 \u003d\u003d (undefined **)0x0)) {\n                      ppuVar24 \u003d (undefined **)0x0;\n                      ppuVar33 \u003d ppuVar16;\n                    }\n                  }\n                  printf(\"%s\",ppuVar33);\n                  if (DAT_00106431 \u003d\u003d \u0027\\0\u0027) {\n                    putchar(10);\n                  }\n                  else {\n                    pcVar28 \u003d (char *)dcgettext(0,\u0026DAT_001040f1,5);\n                    printf(pcVar28);\n                  }\n                  free(ppuVar24);\n                }\n                pFVar27 \u003d DAT_001063f8;\n                if (DAT_00106433 \u003d\u003d \u0027\\0\u0027) {\n                  if (DAT_001063f8 \u003d\u003d (FILE *)0x0) {\n                    pFVar27 \u003d (FILE *)\u0026DAT_0010400a;\n                  }\n                }\n                else if (DAT_001063f8 \u003d\u003d (FILE *)0x0) {\n                  pFVar27 \u003d (FILE *)\u0026DAT_0010400a;\n                }\n                else {\n                  pcVar28 \u003d strrchr((char *)DAT_001063f8,0x2f);\n                  if (pcVar28 !\u003d (char *)0x0) {\n                    pFVar27 \u003d (FILE *)(pcVar28 + 1);\n                    DAT_001063f8 \u003d pFVar27;\n                  }\n                }\n                printf(\"%s:\",pFVar27);\n                if (DAT_001063f4 \u003d\u003d 0) {\n                  puts(\"?\");\n                }\n                else if (DAT_001063f0 \u003d\u003d 0) {\n                  printf(\"%u\\n\");\n                }\n                else {\n                  printf(\"%u (discriminator %u)\\n\");\n                }\n                if (DAT_00106430 \u003d\u003d \u0027\\0\u0027) goto LAB_0010304c;\n                DAT_00106408 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 600))\n                                         (pFVar19,\u0026DAT_001063f8,\u0026DAT_00106400,\u0026DAT_001063f4);\n                ppuVar16 \u003d DAT_00106400;\n                if (DAT_00106408 \u003d\u003d \u0027\\0\u0027) {\n                  DAT_00106408 \u003d \u0027\\0\u0027;\n                  goto LAB_00103053;\n                }\n              }\n              pcVar28 \u003d (char *)dcgettext(0,\" (inlined by) \",5);\n              printf(pcVar28);\n            } while( true );\n          }\n        }\n        else if (((*(byte *)((long)local_148 + 0x24) \u0026 1) !\u003d 0) \u0026\u0026 (DAT_00106410 \u003c local_148[8])) {\n          DAT_00106408 \u003d (**(code **)(pFVar19-\u003e_IO_read_ptr + 0x240))\n                                   (pFVar19,DAT_00106418,local_148,DAT_00106410,\u0026DAT_001063f8,\n                                    \u0026DAT_00106400,\u0026DAT_001063f4,\u0026DAT_001063f0);\n          goto LAB_00102fcf;\n        }\n        if (DAT_00106432 !\u003d \u0027\\0\u0027) {\n          if (DAT_00106431 \u003d\u003d \u0027\\0\u0027) {\n            puts(\"??\");\n          }\n          else {\n            printf(\"?? \");\n          }\n        }\n        puts(\"??:0\");\nLAB_00103053:\n        fflush(*(FILE **)unaff_RBP);\n        if ((int)unaff_R12 !\u003d 0) goto LAB_00102ee7;\nLAB_00103065:\n        pcVar28 \u003d fgets((char *)\u0026local_c8,100,_stdin);\n        psVar21 \u003d \u0026local_c8;\n        if (pcVar28 \u003d\u003d (char *)0x0) goto LAB_0010308a;\n      } while( true );\n    }\n  } while( true );\nLAB_00102970:\n  bVar10 \u003d pbVar29[1];\n  pbVar29 \u003d pbVar29 + 1;\n  if (bVar10 \u003d\u003d 0) goto LAB_001030bb;\n  goto LAB_00102980;\nswitchD_00102d16_caseD_73:\n  DAT_00106433 \u003d \u0027\\x01\u0027;\n  goto switchD_00102d16_caseD_0;\n}\n\n",
      "renaming": {},
      "calling": [
        "entry"
      ],
      "called": [
        "FUN_00102540",
        "bfd_map_over_sections",
        "bfd_close",
        "bfd_get_error",
        "bfd_fprintf_vma",
        "bfd_demangle",
        "fflush",
        "bfd_get_section_by_name",
        "fgets",
        "xstrdup",
        "strcmp",
        "bfd_check_format_matches",
        "putchar",
        "strtoul",
        "fclose",
        "strlen",
        "setlocale",
        "bfd_errmsg",
        "printf",
        "free",
        "xrealloc",
        "fprintf",
        "cplus_demangle_set_style",
        "__errno_location",
        "bfd_scan_vma",
        "fputc",
        "bfd_openr",
        "bfd_check_format",
        "bindtextdomain",
        "ftell",
        "memcpy",
        "xmalloc_set_program_name",
        "bfd_set_error_program_name",
        "bfd_init",
        "cplus_demangle_name_to_style",
        "textdomain",
        "getopt_long",
        "puts",
        "memmove",
        "dcgettext",
        "FUN_00103c70",
        "strrchr",
        "FUN_001023e1",
        "xexit",
        "ferror",
        "FUN_00103bd0",
        "xmalloc",
        "strchr",
        "fseek",
        "FUN_00102620",
        "fopen",
        "stat",
        "bfd_set_default_target",
        "exit",
        "strerror",
        "fread"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103bd0": {
      "entrypoint": "0x00103bd0",
      "current_name": "FUN_00103bd0",
      "code": "\n\n\nvoid FUN_00103bd0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  int iVar1;\n  undefined8 uVar2;\n  long lVar3;\n  undefined8 in_R10;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_88 \u003d param_1;\n    local_78 \u003d param_2;\n    local_68 \u003d param_3;\n    local_58 \u003d param_4;\n    local_48 \u003d param_5;\n    local_38 \u003d param_6;\n    local_28 \u003d param_7;\n    local_18 \u003d param_8;\n  }\n  local_d0 \u003d \u0026stack0x00000008;\n  local_d8 \u003d 8;\n  local_c8 \u003d local_b8;\n  local_d4 \u003d 0x30;\n  local_b0 \u003d param_10;\n  local_a8 \u003d param_11;\n  local_a0 \u003d param_12;\n  local_98 \u003d param_13;\n  local_90 \u003d param_14;\n  FUN_001025c0(param_9,\u0026local_d8);\n  lVar3 \u003d 1;\n  xexit();\n  iVar1 \u003d bfd_get_error();\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    uVar2 \u003d bfd_errmsg(iVar1);\n  }\n  fflush(_stdout);\n  if (lVar3 !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_00106438,lVar3,uVar2,in_R10);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_00106438,uVar2,in_R10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "FUN_001025c0",
        "xexit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103c70": {
      "entrypoint": "0x00103c70",
      "current_name": "FUN_00103c70",
      "code": "\n\n\nvoid FUN_00103c70(long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 in_R10;\n  \n  iVar1 \u003d bfd_get_error();\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    uVar2 \u003d bfd_errmsg(iVar1);\n  }\n  fflush(_stdout);\n  if (param_1 !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_00106438,param_1,uVar2,in_R10);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_00106438,uVar2,in_R10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027b0"
      ],
      "called": [
        "bfd_get_error",
        "FUN_001023a0",
        "bfd_errmsg"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_DT_FINI": {
      "entrypoint": "0x00103cd0",
      "current_name": "_DT_FINI",
      "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}