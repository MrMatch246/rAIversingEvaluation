{
  "functions": {
    "_DT_INIT": {
      "entrypoint": "0x00102000",
      "current_name": "_DT_INIT",
      "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__gmon_start__"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102020": {
      "entrypoint": "0x00102020",
      "current_name": "FUN_00102020",
      "code": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x00102030",
      "current_name": "free",
      "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001032de",
        "FUN_001025ab",
        "FUN_001029a5",
        "FUN_00102f65",
        "FUN_00103bf0",
        "FUN_00103006"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcasecmp": {
      "entrypoint": "0x00102040",
      "current_name": "strcasecmp",
      "code": "\n\n\nint strcasecmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d strcasecmp(__s1,__s2);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010234b",
        "FUN_00104c60",
        "FUN_00104d30",
        "FUN_001022c0",
        "FUN_00104ce0",
        "FUN_00104da0"
      ],
      "called": [
        "strcasecmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "abort": {
      "entrypoint": "0x00102050",
      "current_name": "abort",
      "code": "\n\n\nvoid abort(void)\n\n{\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102c98",
        "FUN_0010354e",
        "FUN_00104de0",
        "caseD_0",
        "FUN_0010347f"
      ],
      "called": [
        "abort"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__errno_location": {
      "entrypoint": "0x00102060",
      "current_name": "__errno_location",
      "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 \u003d __errno_location();\n  return piVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0",
        "FUN_001024ec"
      ],
      "called": [
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strncmp": {
      "entrypoint": "0x00102070",
      "current_name": "strncmp",
      "code": "\n\n\nint strncmp(char *__s1,char *__s2,size_t __n)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d strncmp(__s1,__s2,__n);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001027fd"
      ],
      "called": [
        "strncmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ferror": {
      "entrypoint": "0x00102080",
      "current_name": "ferror",
      "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d ferror(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "ferror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fread": {
      "entrypoint": "0x00102090",
      "current_name": "fread",
      "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_00104de0",
        "FUN_001025ab",
        "FUN_001029a5",
        "FUN_00103bf0",
        "FUN_001028be"
      ],
      "called": [
        "fread"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "textdomain": {
      "entrypoint": "0x001020a0",
      "current_name": "textdomain",
      "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "textdomain"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x001020b0",
      "current_name": "fclose",
      "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fclose(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001029a5",
        "FUN_00103bf0"
      ],
      "called": [
        "fclose"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bindtextdomain": {
      "entrypoint": "0x001020c0",
      "current_name": "bindtextdomain",
      "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "bindtextdomain"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dcgettext": {
      "entrypoint": "0x001020d0",
      "current_name": "dcgettext",
      "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102323",
        "FUN_00102c98",
        "error",
        "FUN_00102434",
        "FUN_00104de0",
        "FUN_001032de",
        "FUN_001029a5",
        "FUN_00104da0",
        "caseD_0",
        "FUN_0010358d",
        "FUN_0010234b",
        "FUN_0010354e",
        "warn",
        "FUN_001025ab",
        "FUN_00103bf0",
        "FUN_001024ec",
        "FUN_00102cc4",
        "FUN_00102558",
        "FUN_001028be",
        "FUN_001022c0",
        "FUN_0010347f"
      ],
      "called": [
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x001020e0",
      "current_name": "strlen",
      "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d strlen(__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_00103186",
        "FUN_001027fd",
        "FUN_00103bf0",
        "FUN_00103006",
        "FUN_00103160"
      ],
      "called": [
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mmap": {
      "entrypoint": "0x001020f0",
      "current_name": "mmap",
      "code": "\n\n\nvoid * mmap(void *__addr,size_t __len,int __prot,int __flags,int __fd,__off_t __offset)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d mmap(__addr,__len,__prot,__flags,__fd,__offset);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "mmap"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getopt_long": {
      "entrypoint": "0x00102100",
      "current_name": "getopt_long",
      "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "getopt_long"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printf": {
      "entrypoint": "0x00102110",
      "current_name": "printf",
      "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d printf(__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "printf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "rewind": {
      "entrypoint": "0x00102120",
      "current_name": "rewind",
      "code": "\n\n\nvoid rewind(FILE *__stream)\n\n{\n  rewind(__stream);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "rewind"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "snprintf": {
      "entrypoint": "0x00102130",
      "current_name": "snprintf",
      "code": "\n\n\nint snprintf(char *__s,size_t __maxlen,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d snprintf(__s,__maxlen,__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d"
      ],
      "called": [
        "snprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sbrk": {
      "entrypoint": "0x00102140",
      "current_name": "sbrk",
      "code": "\n\n\nvoid * sbrk(intptr_t __delta)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d sbrk(__delta);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102fc7"
      ],
      "called": [
        "sbrk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcmp": {
      "entrypoint": "0x00102150",
      "current_name": "strcmp",
      "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001029a5",
        "FUN_00103bf0"
      ],
      "called": [
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fprintf": {
      "entrypoint": "0x00102160",
      "current_name": "fprintf",
      "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102fc7",
        "error",
        "warn",
        "FUN_001032de",
        "FUN_00103bf0"
      ],
      "called": [
        "fprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ftell": {
      "entrypoint": "0x00102170",
      "current_name": "ftell",
      "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d ftell(__stream);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0",
        "FUN_00103bf0"
      ],
      "called": [
        "ftell"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stat": {
      "entrypoint": "0x00102180",
      "current_name": "stat",
      "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d stat(__file,__buf);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "stat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x00102190",
      "current_name": "memcpy",
      "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "memcpy"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fileno": {
      "entrypoint": "0x001021a0",
      "current_name": "fileno",
      "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fileno(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001029a5",
        "FUN_00103bf0"
      ],
      "called": [
        "fileno"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "malloc": {
      "entrypoint": "0x001021b0",
      "current_name": "malloc",
      "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d malloc(__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_00103449",
        "FUN_001025ab",
        "FUN_00102cc4",
        "FUN_00105370"
      ],
      "called": [
        "malloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fflush": {
      "entrypoint": "0x001021c0",
      "current_name": "fflush",
      "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fflush(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "error",
        "warn"
      ],
      "called": [
        "fflush"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fseek": {
      "entrypoint": "0x001021d0",
      "current_name": "fseek",
      "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_00104de0",
        "FUN_001025ab",
        "FUN_001029a5",
        "FUN_00103bf0",
        "FUN_001028be"
      ],
      "called": [
        "fseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "realloc": {
      "entrypoint": "0x001021e0",
      "current_name": "realloc",
      "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103449"
      ],
      "called": [
        "realloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "munmap": {
      "entrypoint": "0x001021f0",
      "current_name": "munmap",
      "code": "\n\n\nint munmap(void *__addr,size_t __len)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d munmap(__addr,__len);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "munmap"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setlocale": {
      "entrypoint": "0x00102200",
      "current_name": "setlocale",
      "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "setlocale"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x00102210",
      "current_name": "memmove",
      "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "memmove"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fopen": {
      "entrypoint": "0x00102220",
      "current_name": "fopen",
      "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 \u003d fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001029a5",
        "FUN_00103bf0"
      ],
      "called": [
        "fopen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "vfprintf": {
      "entrypoint": "0x00102230",
      "current_name": "vfprintf",
      "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "error",
        "warn"
      ],
      "called": [
        "vfprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtoul": {
      "entrypoint": "0x00102240",
      "current_name": "strtoul",
      "code": "\n\n\nulong strtoul(char *__nptr,char **__endptr,int __base)\n\n{\n  ulong uVar1;\n  \n  uVar1 \u003d strtoul(__nptr,__endptr,__base);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001025ab",
        "FUN_001029a5",
        "FUN_00103bf0",
        "FUN_001028be"
      ],
      "called": [
        "strtoul"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "exit": {
      "entrypoint": "0x00102250",
      "current_name": "exit",
      "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102fbc",
        "FUN_001032de",
        "FUN_00103bf0"
      ],
      "called": [
        "exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fwrite": {
      "entrypoint": "0x00102260",
      "current_name": "fwrite",
      "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0"
      ],
      "called": [
        "fwrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strdup": {
      "entrypoint": "0x00102270",
      "current_name": "strdup",
      "code": "\n\n\nchar * strdup(char *__s)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strdup(__s);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001025ab"
      ],
      "called": [
        "strdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strerror": {
      "entrypoint": "0x00102280",
      "current_name": "strerror",
      "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strerror(__errnum);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0",
        "FUN_001024ec"
      ],
      "called": [
        "strerror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fstat": {
      "entrypoint": "0x00102290",
      "current_name": "fstat",
      "code": "\n\n\nint fstat(int __fd,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fstat(__fd,__buf);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001029a5",
        "FUN_00103bf0"
      ],
      "called": [
        "fstat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getc": {
      "entrypoint": "0x001022a0",
      "current_name": "getc",
      "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d getc(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001025ab"
      ],
      "called": [
        "getc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_finalize": {
      "entrypoint": "0x001022b0",
      "current_name": "__cxa_finalize",
      "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "__cxa_finalize"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001022c0": {
      "entrypoint": "0x001022c0",
      "current_name": "FUN_001022c0",
      "code": "\nundefined  [16] FUN_001022c0(void)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  char *unaff_RBX;\n  int unaff_EBP;\n  undefined auVar4 [16];\n  undefined8 unaff_retaddr;\n  \n  iVar1 \u003d strcasecmp(unaff_RBX,\"lam_u48\");\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d 4;\n  }\n  else {\n    iVar1 \u003d strcasecmp(unaff_RBX,\"lam_u57\");\n    uVar2 \u003d 8;\n    if (iVar1 !\u003d 0) {\n      uVar3 \u003d dcgettext(0,\"Unknown x86 feature: %s\\n\",5);\n      error(uVar3);\n      uVar3 \u003d 0xffffffff;\n      goto LAB_00104ca5;\n    }\n  }\n  if (unaff_EBP \u003d\u003d 0) {\n    DAT_00109440 \u003d uVar2 | DAT_00109440;\n    DAT_00109444 \u003d ~uVar2 \u0026 DAT_00109444;\n  }\n  else {\n    DAT_00109444 \u003d uVar2 | DAT_00109444;\n    DAT_00109440 \u003d DAT_00109440 \u0026 ~uVar2;\n  }\n  uVar3 \u003d 0;\nLAB_00104ca5:\n  auVar4._8_8_ \u003d unaff_retaddr;\n  auVar4._0_8_ \u003d uVar3;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104c60"
      ],
      "called": [
        "dcgettext",
        "error",
        "strcasecmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102323": {
      "entrypoint": "0x00102323",
      "current_name": "FUN_00102323",
      "code": "\nundefined  [16] FUN_00102323(void)\n\n{\n  undefined8 uVar1;\n  undefined auVar2 [16];\n  undefined8 unaff_retaddr;\n  \n  uVar1 \u003d dcgettext(0,\"Unknown OSABI: %s\\n\",5);\n  error(uVar1);\n  auVar2._8_8_ \u003d unaff_retaddr;\n  auVar2._0_8_ \u003d 0xffffffff;\n  return auVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104ce0"
      ],
      "called": [
        "dcgettext",
        "error"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010234b": {
      "entrypoint": "0x0010234b",
      "current_name": "FUN_0010234b",
      "code": "\nint FUN_0010234b(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  char *unaff_RBX;\n  \n  iVar1 \u003d strcasecmp(unaff_RBX,\"x86_64\");\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d 0x3e;\n  }\n  else {\n    iVar1 \u003d strcasecmp(unaff_RBX,\"x86-64\");\n    if (iVar1 \u003d\u003d 0) {\n      iVar1 \u003d 0x3e;\n    }\n    else {\n      iVar1 \u003d strcasecmp(unaff_RBX,\"none\");\n      if (iVar1 !\u003d 0) {\n        uVar2 \u003d dcgettext(0,\"Unknown machine type: %s\\n\",5);\n        error(uVar2);\n        iVar1 \u003d -1;\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104d30"
      ],
      "called": [
        "dcgettext",
        "error",
        "strcasecmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001023ce": {
      "entrypoint": "0x001023ce",
      "current_name": "FUN_001023ce",
      "code": "\nundefined8 FUN_001023ce(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104da0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102434": {
      "entrypoint": "0x00102434",
      "current_name": "FUN_00102434",
      "code": "\nundefined8 FUN_00102434(void)\n\n{\n  undefined8 uVar1;\n  size_t sVar2;\n  FILE *unaff_RBX;\n  char *pcVar3;\n  \n  uVar1 \u003d dcgettext(0,\"%s: Failed to seek to ELF header\\n\",5);\n  error(uVar1);\n  if (DAT_001093e6 \u003d\u003d \u0027\\x01\u0027) {\n    if (DAT_0010941a \u003d\u003d DAT_0010916c) {\n      return 0;\n    }\n    if (DAT_00109170 \u003d\u003d 0xffffffff) {\n      if (DAT_0010941a \u003d\u003d 6) {\n        DAT_00109170 \u003d 1;\n      }\n      else if (DAT_0010941a \u003c 7) {\n        DAT_00109170 \u003d (DAT_0010941a !\u003d 3) + 1 + (uint)(DAT_0010941a !\u003d 3);\n      }\n      else {\n        DAT_00109170 \u003d 3 - ((ushort)(DAT_0010941a - 0xb4) \u003c 2);\n      }\n    }\n    if ((DAT_001093e4 \u003d\u003d DAT_00109170) || (DAT_00109170 \u003d\u003d 3)) {\n      if ((DAT_001093e4 \u003d\u003d DAT_00109168) || (DAT_00109168 \u003d\u003d 3)) {\n        if ((DAT_0010941a \u003d\u003d DAT_00109174) || (DAT_00109174 \u003d\u003d 0xffffffff)) {\n          if ((DAT_00109164 \u003d\u003d 0xffffffff) || (DAT_00109418 \u003d\u003d DAT_00109164)) {\n            if ((DAT_0010915c \u003d\u003d 0xffffffff) || (DAT_001093e7 \u003d\u003d DAT_0010915c)) {\n              if ((DAT_001093e8 \u003d\u003d DAT_00109154) || (DAT_00109154 \u003d\u003d 0xffffffff)) {\n                if (DAT_001093e4 \u003d\u003d 1) {\n                  if (DAT_0010916c !\u003d 0xffffffff) {\n                    (*DAT_001093b8)(\u0026DAT_00109392,(long)(int)DAT_0010916c,2);\n                  }\n                  if (DAT_00109160 !\u003d -1) {\n                    (*DAT_001093b8)(\u0026DAT_00109390,(long)DAT_00109160,2);\n                  }\n                  if (DAT_00109158 !\u003d -1) {\n                    DAT_00109387 \u003d (undefined)DAT_00109158;\n                  }\n                  if (DAT_00109150 !\u003d -1) {\n                    DAT_00109388 \u003d (undefined)DAT_00109150;\n                  }\n                  sVar2 \u003d fwrite(\u0026DAT_00109380,0x34,1,unaff_RBX);\n                  if (sVar2 \u003d\u003d 1) {\n                    return 0;\n                  }\n                  uVar1 \u003d FUN_001024ec();\n                  return uVar1;\n                }\n                if (DAT_001093e4 !\u003d 2) {\n                    \n                  abort();\n                }\n                if (DAT_0010916c !\u003d 0xffffffff) {\n                  (*DAT_001093b8)(\u0026DAT_00109352,(long)(int)DAT_0010916c,2);\n                }\n                if (DAT_00109160 !\u003d -1) {\n                  (*DAT_001093b8)(\u0026DAT_00109350,(long)DAT_00109160,2);\n                }\n                if (DAT_00109158 !\u003d -1) {\n                  DAT_00109347 \u003d (undefined)DAT_00109158;\n                }\n                if (DAT_00109150 !\u003d -1) {\n                  DAT_00109348 \u003d (undefined)DAT_00109150;\n                }\n                sVar2 \u003d fwrite(\u0026DAT_00109340,0x40,1,unaff_RBX);\n                if (sVar2 \u003d\u003d 1) {\n                  return 0;\n                }\n                uVar1 \u003d FUN_001024ec();\n                return uVar1;\n              }\n              pcVar3 \u003d \"%s: Unmatched EI_ABIVERSION: %d is not %d\\n\";\n            }\n            else {\n              pcVar3 \u003d \"%s: Unmatched EI_OSABI: %d is not %d\\n\";\n            }\n          }\n          else {\n            pcVar3 \u003d \"%s: Unmatched e_type: %d is not %d\\n\";\n          }\n        }\n        else {\n          pcVar3 \u003d \"%s: Unmatched e_machine: %d is not %d\\n\";\n        }\n        uVar1 \u003d dcgettext(0,pcVar3,5);\n        error(uVar1);\n        return 1;\n      }\n      pcVar3 \u003d \"%s: Unmatched output EI_CLASS: %d is not %d\\n\";\n    }\n    else {\n      pcVar3 \u003d \"%s: Unmatched input EI_CLASS: %d is not %d\\n\";\n    }\n    uVar1 \u003d dcgettext(0,pcVar3,5);\n    error(uVar1);\n  }\n  else {\n    uVar1 \u003d dcgettext(0,\"%s: Unsupported EI_VERSION: %d is not %d\\n\",5);\n    error(uVar1);\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0"
      ],
      "called": [
        "dcgettext",
        "error"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001024ec": {
      "entrypoint": "0x001024ec",
      "current_name": "FUN_001024ec",
      "code": "\nundefined8 FUN_001024ec(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 \u003d __errno_location();\n  strerror(*piVar1);\n  uVar2 \u003d dcgettext(0,\"%s: Failed to update ELF header: %s\\n\",5);\n  error(uVar2);\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0"
      ],
      "called": [
        "dcgettext",
        "error",
        "strerror",
        "__errno_location"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102558": {
      "entrypoint": "0x00102558",
      "current_name": "FUN_00102558",
      "code": "\nundefined8 FUN_00102558(void)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 \u003d dcgettext(0,\"%s: Failed to read ELF header\\n\",5);\n  error(uVar1);\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0"
      ],
      "called": [
        "dcgettext",
        "error"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001025ab": {
      "entrypoint": "0x001025ab",
      "current_name": "FUN_001025ab",
      "code": "\nundefined4 FUN_001025ab(char **param_1,char *param_2,FILE *param_3,long param_4,undefined4 param_5)\n\n{\n  char **__ptr;\n  undefined uVar1;\n  char cVar2;\n  int iVar3;\n  char *pcVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  char *pcVar7;\n  \n  pcVar4 \u003d strdup(param_2);\n  param_1[2] \u003d (char *)0x0;\n  *(undefined4 *)((long)param_1 + 0x54) \u003d 0;\n  *param_1 \u003d pcVar4;\n  param_1[1] \u003d (char *)param_3;\n  param_1[5] \u003d (char *)0x0;\n  param_1[6] \u003d (char *)0x0;\n  *(undefined4 *)(param_1 + 10) \u003d param_5;\n  param_1[9] \u003d (char *)0x8;\n  *(undefined (*) [16])(param_1 + 3) \u003d ZEXT816(0);\n  *(undefined (*) [16])(param_1 + 7) \u003d ZEXT816(0);\n  iVar3 \u003d fseek(param_3,8,0);\n  pcVar4 \u003d \"%s: failed to seek to first archive header\\n\";\n  if (iVar3 !\u003d 0) goto LAB_00102658;\n  __ptr \u003d param_1 + 0xb;\n  sVar5 \u003d fread(__ptr,1,0x3c,param_3);\n  if (sVar5 !\u003d 0x3c) {\n    if (sVar5 \u003d\u003d 0) {\n      return 0;\n    }\n    pcVar4 \u003d \"%s: failed to read archive header\\n\";\n    goto LAB_00102658;\n  }\n  cVar2 \u003d FUN_001027fd(__ptr,\"/               \");\n  if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n    cVar2 \u003d FUN_001027fd(__ptr,\"/SYM64/         \");\n    if (cVar2 !\u003d \u0027\\0\u0027) {\n      *(undefined4 *)((long)param_1 + 0x54) \u003d 1;\n      iVar3 \u003d FUN_001028be(param_1,8);\n      goto joined_r0x001026dd;\n    }\n  }\n  else {\n    iVar3 \u003d FUN_001028be(param_1,4);\njoined_r0x001026dd:\n    if (iVar3 \u003d\u003d 0) {\n      return 1;\n    }\n  }\n  cVar2 \u003d FUN_001027fd(__ptr);\n  if (cVar2 \u003d\u003d \u0027\\0\u0027) {\n    return 0;\n  }\n  uVar1 \u003d *(undefined *)((long)param_1 + 0x92);\n  *(undefined *)((long)param_1 + 0x92) \u003d 0;\n  pcVar4 \u003d (char *)strtoul((char *)(param_1 + 0x11),(char **)0x0,10);\n  pcVar7 \u003d \"%s: long name table is too small, (size \u003d %ld)\\n\";\n  param_1[7] \u003d pcVar4;\n  *(undefined *)((long)param_1 + 0x92) \u003d uVar1;\n  if ((char *)0x7 \u003c pcVar4) {\n    if (((long)pcVar4 \u003c\u003d param_4) \u0026\u0026 (-1 \u003c (long)pcVar4)) {\n      param_1[9] \u003d pcVar4 + 0x3c + (long)param_1[9];\n      pcVar7 \u003d (char *)malloc((size_t)(pcVar4 + 1));\n      param_1[6] \u003d pcVar7;\n      if (pcVar7 \u003d\u003d (char *)0x0) {\n        uVar6 \u003d dcgettext(0,\"Out of memory reading long symbol names in archive\\n\",5);\n        error(uVar6);\n        return 1;\n      }\n      sVar5 \u003d fread(pcVar7,(size_t)pcVar4,1,param_3);\n      if (sVar5 \u003d\u003d 1) {\n        if ((*(byte *)(param_1 + 7) \u0026 1) !\u003d 0) {\n          getc(param_3);\n        }\n        param_1[6][(long)param_1[7]] \u003d \u0027\\0\u0027;\n        return 0;\n      }\n      free(param_1[6]);\n      pcVar4 \u003d \"%s: failed to read long symbol name string table\\n\";\n      param_1[6] \u003d (char *)0x0;\nLAB_00102658:\n      uVar6 \u003d dcgettext(0,pcVar4,5);\n      error(uVar6,param_2);\n      return 1;\n    }\n    pcVar7 \u003d \"%s: long name table is too big, (size \u003d %#lx)\\n\";\n  }\n  uVar6 \u003d dcgettext(0,pcVar7,5);\n  error(uVar6,param_2,pcVar4);\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001029a5"
      ],
      "called": [
        "dcgettext",
        "error",
        "free",
        "fread",
        "malloc",
        "fseek",
        "FUN_001027fd",
        "strtoul",
        "FUN_001028be",
        "getc",
        "strdup"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001027fd": {
      "entrypoint": "0x001027fd",
      "current_name": "FUN_001027fd",
      "code": "\nundefined  [16] FUN_001027fd(char *param_1,char *param_2)\n\n{\n  int iVar1;\n  undefined8 in_RAX;\n  size_t __n;\n  undefined4 extraout_var;\n  undefined auVar2 [16];\n  \n  __n \u003d strlen(param_2);\n  iVar1 \u003d strncmp(param_1,param_2,__n);\n  auVar2._1_7_ \u003d (undefined7)(CONCAT44(extraout_var,iVar1) \u003e\u003e 8);\n  auVar2[0] \u003d iVar1 \u003d\u003d 0;\n  auVar2._8_8_ \u003d in_RAX;\n  return auVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001025ab"
      ],
      "called": [
        "strncmp",
        "strlen"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "caseD_3": {
      "entrypoint": "0x00102825",
      "current_name": "caseD_3",
      "code": "\nvoid switchD_00103aac::caseD_3(long param_1,undefined8 param_2)\n\n{\n  FUN_00103ab3(param_1,param_2,\n               (ulong)*(byte *)(param_1 + 1) \u003c\u003c 8 | (ulong)*(byte *)(param_1 + 2) \u003c\u003c 0x10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103a90"
      ],
      "called": [
        "FUN_00103ab3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "caseD_0": {
      "entrypoint": "0x0010289a",
      "current_name": "caseD_0",
      "code": "\nvoid switchD_00103aac::caseD_0(void)\n\n{\n  undefined8 uVar1;\n  undefined4 unaff_EBX;\n  \n  uVar1 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n  error(uVar1,unaff_EBX);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103a90"
      ],
      "called": [
        "dcgettext",
        "error",
        "abort"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001028be": {
      "entrypoint": "0x001028be",
      "current_name": "FUN_001028be",
      "code": "\nundefined8 FUN_001028be(undefined8 *param_1)\n\n{\n  undefined uVar1;\n  int iVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  char *pcVar7;\n  \n  uVar1 \u003d *(undefined *)((long)param_1 + 0x92);\n  *(undefined *)((long)param_1 + 0x92) \u003d 0;\n  uVar3 \u003d strtoul((char *)(param_1 + 0x11),(char **)0x0,10);\n  *(undefined *)((long)param_1 + 0x92) \u003d uVar1;\n  if ((long)uVar3 \u003c 0) {\n    uVar6 \u003d *param_1;\n    uVar4 \u003d dcgettext(0,\"%s: invalid archive header size: %ld\\n\",5);\n    error(uVar4,uVar6,uVar3);\n  }\n  else {\n    uVar3 \u003d uVar3 + 1 \u0026 0xfffffffffffffffe;\n    param_1[9] \u003d uVar3 + 0x3c + param_1[9];\n    iVar2 \u003d fseek((FILE *)param_1[1],uVar3,1);\n    if (iVar2 \u003d\u003d 0) {\n      sVar5 \u003d fread(param_1 + 0xb,1,0x3c,(FILE *)param_1[1]);\n      if ((sVar5 \u003d\u003d 0x3c) || (sVar5 \u003d\u003d 0)) {\n        return 1;\n      }\n      uVar6 \u003d *param_1;\n      pcVar7 \u003d \"%s: failed to read archive header following archive index\\n\";\n    }\n    else {\n      uVar6 \u003d *param_1;\n      pcVar7 \u003d \"%s: failed to skip archive symbol table\\n\";\n    }\n    uVar4 \u003d dcgettext(0,pcVar7,5);\n    error(uVar4,uVar6);\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001025ab"
      ],
      "called": [
        "dcgettext",
        "error",
        "fread",
        "fseek",
        "strtoul"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001029a5": {
      "entrypoint": "0x001029a5",
      "current_name": "FUN_001029a5",
      "code": "\nundefined4 * FUN_001029a5(undefined8 *param_1,char **param_2)\n\n{\n  undefined uVar1;\n  undefined4 uVar2;\n  undefined4 uVar3;\n  undefined4 uVar4;\n  undefined4 uVar5;\n  int iVar6;\n  ulong uVar7;\n  ulong uVar8;\n  ulong uVar9;\n  undefined8 uVar10;\n  FILE *__stream;\n  size_t sVar11;\n  undefined4 *puVar12;\n  long lVar13;\n  char *pcVar14;\n  char *pcVar15;\n  char *pcVar16;\n  char *local_c0;\n  stat local_b8;\n  \n  if (*(char *)(param_1 + 0xb) !\u003d \u0027/\u0027) {\n    lVar13 \u003d 0;\n    do {\n      if (*(char *)((long)param_1 + lVar13 + 0x58) \u003d\u003d \u0027/\u0027) {\n        *(undefined *)((long)param_1 + lVar13 + 0x58) \u003d 0;\n        puVar12 \u003d (undefined4 *)FUN_00103160(param_1 + 0xb);\n        return puVar12;\n      }\n      lVar13 \u003d lVar13 + 1;\n    } while (lVar13 !\u003d 0x10);\n    puVar12 \u003d (undefined4 *)FUN_00105370(0x11);\n    uVar2 \u003d *(undefined4 *)(param_1 + 0xb);\n    uVar3 \u003d *(undefined4 *)((long)param_1 + 0x5c);\n    uVar4 \u003d *(undefined4 *)(param_1 + 0xc);\n    uVar5 \u003d *(undefined4 *)((long)param_1 + 100);\n    *(undefined *)(puVar12 + 4) \u003d 0;\n    *puVar12 \u003d uVar2;\n    puVar12[1] \u003d uVar3;\n    puVar12[2] \u003d uVar4;\n    puVar12[3] \u003d uVar5;\n    return puVar12;\n  }\n  if ((param_1[6] \u003d\u003d 0) || (param_1[7] \u003d\u003d 0)) {\n    pcVar15 \u003d \"Archive member uses long names, but no longname table found\\n\";\nLAB_00102acd:\n    uVar10 \u003d dcgettext(0,pcVar15,5);\n    error(uVar10);\n    return (undefined4 *)0x0;\n  }\n  uVar1 \u003d *(undefined *)((long)param_1 + 0x92);\n  param_1[8] \u003d 0;\n  *(undefined *)((long)param_1 + 0x92) \u003d 0;\n  uVar7 \u003d strtoul((char *)((long)param_1 + 0x59),\u0026local_c0,10);\n  if (((*(int *)(param_1 + 10) !\u003d 0) \u0026\u0026 (local_c0 !\u003d (char *)0x0)) \u0026\u0026 (*local_c0 \u003d\u003d \u0027:\u0027)) {\n    uVar8 \u003d strtoul(local_c0 + 1,(char **)0x0,10);\n    param_1[8] \u003d uVar8;\n  }\n  uVar8 \u003d param_1[7];\n  *(undefined *)((long)param_1 + 0x92) \u003d uVar1;\n  if (uVar8 \u003c uVar7) {\n    uVar10 \u003d dcgettext(0,\"Found long name index (%ld) beyond end of long name table\\n\",5);\n    error(uVar10,uVar7);\n    return (undefined4 *)0x0;\n  }\n  lVar13 \u003d param_1[6];\n  for (uVar9 \u003d uVar7;\n      ((uVar8 !\u003d uVar9 \u0026\u0026 (*(char *)(lVar13 + uVar9) !\u003d \u0027\\0\u0027)) \u0026\u0026\n      (*(char *)(lVar13 + uVar9) !\u003d \u0027\\n\u0027)); uVar9 \u003d uVar9 + 1) {\n  }\n  if ((uVar9 !\u003d 0) \u0026\u0026 (*(char *)(lVar13 + -1 + uVar9) \u003d\u003d \u0027/\u0027)) {\n    uVar9 \u003d uVar9 - 1;\n  }\n  if (uVar9 \u003c uVar8) {\n    uVar8 \u003d uVar9;\n  }\n  *(undefined *)(lVar13 + uVar8) \u003d 0;\n  if ((*(int *)(param_1 + 10) \u003d\u003d 0) || (param_1[8] \u003d\u003d 0)) goto LAB_00102c2d;\n  if (uVar8 \u003c\u003d uVar7) {\n    pcVar15 \u003d \"Invalid Thin archive member name\\n\";\n    goto LAB_00102acd;\n  }\n  pcVar15 \u003d (char *)FUN_00102cc4(*param_1,param_1[6] + uVar7,uVar8 - uVar7);\n  if (pcVar15 !\u003d (char *)0x0) {\n    if ((*param_2 \u003d\u003d (char *)0x0) || (iVar6 \u003d strcmp(*param_2,pcVar15), iVar6 !\u003d 0)) {\n      if ((FILE *)param_2[1] !\u003d (FILE *)0x0) {\n        fclose((FILE *)param_2[1]);\n        param_2[1] \u003d (char *)0x0;\n      }\n      FUN_00102f65(param_2);\n      __stream \u003d fopen(pcVar15,\"rb\");\n      if (__stream !\u003d (FILE *)0x0) {\n        iVar6 \u003d fileno(__stream);\n        iVar6 \u003d fstat(iVar6,\u0026local_b8);\n        if ((-1 \u003c iVar6) \u0026\u0026\n           (iVar6 \u003d FUN_001025ab(param_2,pcVar15,__stream,local_b8.st_size,0), iVar6 \u003d\u003d 0))\n        goto LAB_00102b84;\n      }\n    }\n    else {\nLAB_00102b84:\n      iVar6 \u003d fseek((FILE *)param_2[1],param_1[8],0);\n      if (iVar6 \u003d\u003d 0) {\n        sVar11 \u003d fread(param_2 + 0xb,1,0x3c,(FILE *)param_2[1]);\n        if (sVar11 \u003d\u003d 0x3c) {\n          if (*(short *)((long)param_2 + 0x92) \u003d\u003d 0xa60) {\n            puVar12 \u003d (undefined4 *)FUN_001029a5(param_2,0);\n            if (puVar12 !\u003d (undefined4 *)0x0) {\n              free(pcVar15);\n              return puVar12;\n            }\n            goto LAB_00102c25;\n          }\n          pcVar14 \u003d *param_2;\n          pcVar16 \u003d \"%s: did not find a valid archive header\\n\";\n        }\n        else {\n          pcVar14 \u003d *param_2;\n          pcVar16 \u003d \"%s: failed to read archive header\\n\";\n        }\n      }\n      else {\n        pcVar14 \u003d *param_2;\n        pcVar16 \u003d \"%s: failed to seek to next file name\\n\";\n      }\n      uVar10 \u003d dcgettext(0,pcVar16,5);\n      error(uVar10,pcVar14);\n    }\n  }\nLAB_00102c25:\n  free(pcVar15);\nLAB_00102c2d:\n  puVar12 \u003d (undefined4 *)FUN_00103160(param_1[6] + uVar7);\n  return puVar12;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001029a5"
      ],
      "called": [
        "fopen",
        "free",
        "error",
        "fseek",
        "FUN_001029a5",
        "FUN_00102f65",
        "strtoul",
        "strcmp",
        "dcgettext",
        "fileno",
        "fread",
        "fclose",
        "FUN_001025ab",
        "FUN_00102cc4",
        "FUN_00105370",
        "FUN_00103160",
        "fstat"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102c98": {
      "entrypoint": "0x00102c98",
      "current_name": "FUN_00102c98",
      "code": "\nvoid FUN_00102c98(void)\n\n{\n  undefined8 uVar1;\n  undefined4 unaff_EBX;\n  \n  uVar1 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n  error(uVar1,unaff_EBX);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103ad0"
      ],
      "called": [
        "dcgettext",
        "error",
        "abort"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102cbc": {
      "entrypoint": "0x00102cbc",
      "current_name": "FUN_00102cbc",
      "code": "\nchar * FUN_00102cbc(undefined8 param_1,char *param_2)\n\n{\n  ulong __size;\n  long lVar1;\n  char cVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  ulong extraout_RDX;\n  char *unaff_RBX;\n  ulong uVar7;\n  byte bVar8;\n  \n  bVar8 \u003d 0;\n  FUN_00102fc7();\n  pcVar3 \u003d unaff_RBX;\n  pcVar4 \u003d unaff_RBX;\n  while (cVar2 \u003d *pcVar3, cVar2 !\u003d \u0027\\0\u0027) {\n    pcVar3 \u003d pcVar3 + 1;\n    if (cVar2 \u003d\u003d \u0027/\u0027) {\n      pcVar4 \u003d pcVar3;\n    }\n  }\n  if ((*param_2 \u003d\u003d \u0027/\u0027) || (unaff_RBX \u003d\u003d pcVar4)) {\n    if (extraout_RDX + 1 \u003d\u003d 0) {\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(extraout_RDX + 1);\n    uVar6 \u003d extraout_RDX;\n    pcVar3 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar6 !\u003d 0; uVar6 \u003d uVar6 - 1) {\n        *pcVar3 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      pcVar4[extraout_RDX] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  else {\n    uVar7 \u003d (long)pcVar4 - (long)unaff_RBX;\n    lVar1 \u003d uVar7 + extraout_RDX;\n    uVar6 \u003d extraout_RDX;\n    if (extraout_RDX \u003c\u003d uVar7) {\n      uVar6 \u003d uVar7;\n    }\n    __size \u003d lVar1 + 1;\n    if (__size \u003c uVar6) {\n      uVar5 \u003d dcgettext(0,\"Abnormal length of thin archive member name: %lx\\n\",5);\n      error(uVar5,extraout_RDX);\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(__size);\n    pcVar3 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar6 \u003d extraout_RDX, uVar7 !\u003d 0; uVar7 \u003d uVar7 - 1) {\n        *pcVar3 \u003d *unaff_RBX;\n        unaff_RBX \u003d unaff_RBX + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      for (; uVar6 !\u003d 0; uVar6 \u003d uVar6 - 1) {\n        *pcVar3 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      pcVar4[lVar1] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  uVar5 \u003d dcgettext(0,\"Out of memory\\n\",5);\n  error(uVar5);\n  return (char *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105370"
      ],
      "called": [
        "FUN_00102fc7"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102cc4": {
      "entrypoint": "0x00102cc4",
      "current_name": "FUN_00102cc4",
      "code": "\nchar * FUN_00102cc4(char *param_1,char *param_2,ulong param_3)\n\n{\n  ulong __size;\n  long lVar1;\n  char cVar2;\n  char *pcVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  ulong uVar6;\n  ulong uVar7;\n  byte bVar8;\n  \n  bVar8 \u003d 0;\n  pcVar3 \u003d param_1;\n  pcVar4 \u003d param_1;\n  while (cVar2 \u003d *pcVar3, cVar2 !\u003d \u0027\\0\u0027) {\n    pcVar3 \u003d pcVar3 + 1;\n    if (cVar2 \u003d\u003d \u0027/\u0027) {\n      pcVar4 \u003d pcVar3;\n    }\n  }\n  if ((*param_2 \u003d\u003d \u0027/\u0027) || (param_1 \u003d\u003d pcVar4)) {\n    if (param_3 + 1 \u003d\u003d 0) {\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(param_3 + 1);\n    uVar6 \u003d param_3;\n    pcVar3 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar6 !\u003d 0; uVar6 \u003d uVar6 - 1) {\n        *pcVar3 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      pcVar4[param_3] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  else {\n    uVar7 \u003d (long)pcVar4 - (long)param_1;\n    lVar1 \u003d uVar7 + param_3;\n    uVar6 \u003d param_3;\n    if (param_3 \u003c\u003d uVar7) {\n      uVar6 \u003d uVar7;\n    }\n    __size \u003d lVar1 + 1;\n    if (__size \u003c uVar6) {\n      uVar5 \u003d dcgettext(0,\"Abnormal length of thin archive member name: %lx\\n\",5);\n      error(uVar5,param_3);\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(__size);\n    pcVar3 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar7 !\u003d 0; uVar7 \u003d uVar7 - 1) {\n        *pcVar3 \u003d *param_1;\n        param_1 \u003d param_1 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      for (; param_3 !\u003d 0; param_3 \u003d param_3 - 1) {\n        *pcVar3 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar8 * -2 + 1;\n        pcVar3 \u003d pcVar3 + (ulong)bVar8 * -2 + 1;\n      }\n      pcVar4[lVar1] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  uVar5 \u003d dcgettext(0,\"Out of memory\\n\",5);\n  error(uVar5);\n  return (char *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001029a5"
      ],
      "called": [
        "dcgettext",
        "error",
        "malloc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "warn": {
      "entrypoint": "0x00102da5",
      "current_name": "warn",
      "code": "\n\n\nvoid warn(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n         undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,char *param_9,\n         undefined8 param_10,undefined8 param_11,undefined8 param_12,undefined8 param_13,\n         undefined8 param_14)\n\n{\n  char in_AL;\n  char *__format;\n  undefined4 local_e0;\n  undefined4 local_dc;\n  undefined *local_d8;\n  undefined *local_d0;\n  undefined local_c8 [8];\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_98 \u003d param_1;\n    local_88 \u003d param_2;\n    local_78 \u003d param_3;\n    local_68 \u003d param_4;\n    local_58 \u003d param_5;\n    local_48 \u003d param_6;\n    local_38 \u003d param_7;\n    local_28 \u003d param_8;\n  }\n  local_c0 \u003d param_10;\n  local_b8 \u003d param_11;\n  local_b0 \u003d param_12;\n  local_a8 \u003d param_13;\n  local_a0 \u003d param_14;\n  fflush(_stdout);\n  local_d8 \u003d \u0026stack0x00000008;\n  local_d0 \u003d local_c8;\n  local_e0 \u003d 8;\n  local_dc \u003d 0x30;\n  __format \u003d (char *)dcgettext(0,\"%s: Warning: \",5);\n  fprintf(_stderr,__format,\"elfedit\");\n  vfprintf(_stderr,param_9,\u0026local_e0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "dcgettext",
        "fflush",
        "fprintf",
        "vfprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "error": {
      "entrypoint": "0x00102e85",
      "current_name": "error",
      "code": "\n\n\nvoid error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n          undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,char *param_9,\n          undefined8 param_10,undefined8 param_11,undefined8 param_12,undefined8 param_13,\n          undefined8 param_14)\n\n{\n  char in_AL;\n  char *__format;\n  undefined4 local_e0;\n  undefined4 local_dc;\n  undefined *local_d8;\n  undefined *local_d0;\n  undefined local_c8 [8];\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_98 \u003d param_1;\n    local_88 \u003d param_2;\n    local_78 \u003d param_3;\n    local_68 \u003d param_4;\n    local_58 \u003d param_5;\n    local_48 \u003d param_6;\n    local_38 \u003d param_7;\n    local_28 \u003d param_8;\n  }\n  local_c0 \u003d param_10;\n  local_b8 \u003d param_11;\n  local_b0 \u003d param_12;\n  local_a8 \u003d param_13;\n  local_a0 \u003d param_14;\n  fflush(_stdout);\n  local_d8 \u003d \u0026stack0x00000008;\n  local_d0 \u003d local_c8;\n  local_e0 \u003d 8;\n  local_dc \u003d 0x30;\n  __format \u003d (char *)dcgettext(0,\"%s: Error: \",5);\n  fprintf(_stderr,__format,\"elfedit\");\n  vfprintf(_stderr,param_9,\u0026local_e0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102323",
        "FUN_00102c98",
        "FUN_00102434",
        "FUN_00104de0",
        "FUN_001029a5",
        "FUN_00104da0",
        "caseD_0",
        "FUN_0010358d",
        "FUN_0010234b",
        "FUN_0010354e",
        "FUN_001025ab",
        "FUN_00103bf0",
        "FUN_001024ec",
        "FUN_00102cc4",
        "FUN_00102558",
        "FUN_001028be",
        "FUN_001022c0",
        "FUN_0010347f"
      ],
      "called": [
        "dcgettext",
        "fprintf",
        "fflush",
        "vfprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102f65": {
      "entrypoint": "0x00102f65",
      "current_name": "FUN_00102f65",
      "code": "\nvoid FUN_00102f65(void **param_1)\n\n{\n  free(*param_1);\n  free(param_1[3]);\n  free(param_1[4]);\n  free(param_1[6]);\n  *param_1 \u003d (void *)0x0;\n  param_1[6] \u003d (void *)0x0;\n  *(undefined (*) [16])(param_1 + 3) \u003d ZEXT816(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_001029a5"
      ],
      "called": [
        "free"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102fa0": {
      "entrypoint": "0x00102fa0",
      "current_name": "FUN_00102fa0",
      "code": "\nvoid FUN_00102fa0(byte **param_1)\n\n{\n  while (((\u0026DAT_00107040)[(ulong)**param_1 * 2] \u0026 0x40) !\u003d 0) {\n    *param_1 \u003d *param_1 + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102fbc": {
      "entrypoint": "0x00102fbc",
      "current_name": "FUN_00102fbc",
      "code": "\nvoid FUN_00102fbc(void)\n\n{\n                    \n  exit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102fc7",
        "FUN_00103bf0"
      ],
      "called": [
        "exit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102fc7": {
      "entrypoint": "0x00102fc7",
      "current_name": "FUN_00102fc7",
      "code": "\n\n\nchar * FUN_00102fc7(undefined8 param_1)\n\n{\n  char cVar1;\n  void *pvVar2;\n  size_t sVar3;\n  ulong uVar4;\n  char *pcVar5;\n  char **ppcVar6;\n  undefined8 extraout_RDX;\n  long lVar7;\n  char *__s;\n  FILE *__ptr;\n  char *pcVar8;\n  byte bVar9;\n  undefined8 extraout_XMM0_Qa;\n  uint uStack_f8;\n  char **ppcVar10;\n  char **ppcVar11;\n  char *apcStack_e0 [4];\n  undefined8 uStack_c0;\n  long lStack_b8;\n  undefined8 uStack_b0;\n  undefined8 uStack_28;\n  \n  bVar9 \u003d 0;\n  pvVar2 \u003d sbrk(0);\n  lStack_b8 \u003d (long)pvVar2 + -0x10a0e0;\n  apcStack_e0[3] \u003d \"\";\n  __s \u003d \"\\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\\n\";\n  __ptr \u003d _stderr;\n  uStack_c0 \u003d param_1;\n  fprintf(_stderr,\"\\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\\n\");\n  cVar1 \u003d FUN_00102fbc();\n  if (cVar1 !\u003d \u0027\\0\u0027) {\n    uStack_b0 \u003d extraout_XMM0_Qa;\n  }\n  lVar7 \u003d 0;\n  uStack_f8 \u003d 0x10;\n  pcVar8 \u003d __s;\n  ppcVar10 \u003d (char **)register0x00000020;\n  apcStack_e0[2] \u003d (char *)extraout_RDX;\n  uStack_28 \u003d param_1;\n  do {\n    sVar3 \u003d strlen(pcVar8);\n    lVar7 \u003d lVar7 + sVar3;\n    if (uStack_f8 \u003c 0x30) {\n      uVar4 \u003d (ulong)uStack_f8;\n      uStack_f8 \u003d uStack_f8 + 8;\n      ppcVar6 \u003d (char **)((long)apcStack_e0 + uVar4);\n      ppcVar11 \u003d ppcVar10;\n    }\n    else {\n      ppcVar11 \u003d ppcVar10 + 1;\n      ppcVar6 \u003d ppcVar10;\n    }\n    pcVar8 \u003d *ppcVar6;\n    ppcVar10 \u003d ppcVar11;\n  } while (pcVar8 !\u003d (char *)0x0);\n  pcVar5 \u003d (char *)FUN_00105370(lVar7 + 1);\n  uStack_f8 \u003d 0x10;\n  pcVar8 \u003d pcVar5;\n  ppcVar10 \u003d (char **)register0x00000020;\n  do {\n    sVar3 \u003d strlen(__s);\n    for (; sVar3 !\u003d 0; sVar3 \u003d sVar3 - 1) {\n      *pcVar8 \u003d *__s;\n      __s \u003d __s + (ulong)bVar9 * -2 + 1;\n      pcVar8 \u003d pcVar8 + (ulong)bVar9 * -2 + 1;\n    }\n    if (uStack_f8 \u003c 0x30) {\n      uVar4 \u003d (ulong)uStack_f8;\n      uStack_f8 \u003d uStack_f8 + 8;\n      ppcVar6 \u003d (char **)((long)apcStack_e0 + uVar4);\n      ppcVar11 \u003d ppcVar10;\n    }\n    else {\n      ppcVar11 \u003d ppcVar10 + 1;\n      ppcVar6 \u003d ppcVar10;\n    }\n    __s \u003d *ppcVar6;\n    ppcVar10 \u003d ppcVar11;\n  } while (__s !\u003d (char *)0x0);\n  *pcVar8 \u003d \u0027\\0\u0027;\n  free(__ptr);\n  return pcVar5;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103449",
        "FUN_00102cbc"
      ],
      "called": [
        "sbrk",
        "FUN_00102fbc",
        "fprintf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103006": {
      "entrypoint": "0x00103006",
      "current_name": "FUN_00103006",
      "code": "\nchar * FUN_00103006(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                   undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                   void *param_9,char *param_10,undefined8 param_11,undefined8 param_12,\n                   undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  size_t sVar1;\n  ulong uVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  long lVar5;\n  char *pcVar6;\n  byte bVar7;\n  uint local_f0;\n  char **local_e8;\n  char *local_d8 [4];\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined4 local_a8;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  \n  bVar7 \u003d 0;\n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_a8 \u003d param_1;\n    local_98 \u003d param_2;\n    local_88 \u003d param_3;\n    local_78 \u003d param_4;\n    local_68 \u003d param_5;\n    local_58 \u003d param_6;\n    local_48 \u003d param_7;\n    local_38 \u003d param_8;\n  }\n  local_e8 \u003d (char **)\u0026stack0x00000008;\n  lVar5 \u003d 0;\n  local_f0 \u003d 0x10;\n  pcVar6 \u003d param_10;\n  local_d8[2] \u003d (char *)param_11;\n  local_d8[3] \u003d (char *)param_12;\n  local_b8 \u003d param_13;\n  local_b0 \u003d param_14;\n  do {\n    sVar1 \u003d strlen(pcVar6);\n    lVar5 \u003d lVar5 + sVar1;\n    if (local_f0 \u003c 0x30) {\n      uVar2 \u003d (ulong)local_f0;\n      local_f0 \u003d local_f0 + 8;\n      ppcVar4 \u003d (char **)((long)local_d8 + uVar2);\n    }\n    else {\n      ppcVar4 \u003d local_e8;\n      local_e8 \u003d local_e8 + 1;\n    }\n    pcVar6 \u003d *ppcVar4;\n  } while (pcVar6 !\u003d (char *)0x0);\n  pcVar3 \u003d (char *)FUN_00105370(lVar5 + 1);\n  local_f0 \u003d 0x10;\n  local_e8 \u003d (char **)\u0026stack0x00000008;\n  pcVar6 \u003d pcVar3;\n  do {\n    sVar1 \u003d strlen(param_10);\n    for (; sVar1 !\u003d 0; sVar1 \u003d sVar1 - 1) {\n      *pcVar6 \u003d *param_10;\n      param_10 \u003d param_10 + (ulong)bVar7 * -2 + 1;\n      pcVar6 \u003d pcVar6 + (ulong)bVar7 * -2 + 1;\n    }\n    if (local_f0 \u003c 0x30) {\n      uVar2 \u003d (ulong)local_f0;\n      local_f0 \u003d local_f0 + 8;\n      ppcVar4 \u003d (char **)((long)local_d8 + uVar2);\n    }\n    else {\n      ppcVar4 \u003d local_e8;\n      local_e8 \u003d local_e8 + 1;\n    }\n    param_10 \u003d *ppcVar4;\n  } while (param_10 !\u003d (char *)0x0);\n  *pcVar6 \u003d \u0027\\0\u0027;\n  free(param_9);\n  return pcVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001032de"
      ],
      "called": [
        "free",
        "strlen",
        "FUN_00105370"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103160": {
      "entrypoint": "0x00103160",
      "current_name": "FUN_00103160",
      "code": "\nvoid FUN_00103160(char *param_1)\n\n{\n  size_t sVar1;\n  char *pcVar2;\n  long lVar3;\n  byte bVar4;\n  \n  bVar4 \u003d 0;\n  sVar1 \u003d strlen(param_1);\n  lVar3 \u003d sVar1 + 1;\n  pcVar2 \u003d (char *)FUN_00105370(lVar3);\n  for (; lVar3 !\u003d 0; lVar3 \u003d lVar3 + -1) {\n    *pcVar2 \u003d *param_1;\n    param_1 \u003d param_1 + (ulong)bVar4 * -2 + 1;\n    pcVar2 \u003d pcVar2 + (ulong)bVar4 * -2 + 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001029a5",
        "FUN_00103bf0"
      ],
      "called": [
        "strlen",
        "FUN_00105370"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103186": {
      "entrypoint": "0x00103186",
      "current_name": "FUN_00103186",
      "code": "\nchar * FUN_00103186(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                   undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                   undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                   undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  size_t sVar1;\n  ulong uVar2;\n  char *pcVar3;\n  char **ppcVar4;\n  long lVar5;\n  char *pcVar6;\n  char *pcVar7;\n  byte bVar8;\n  uint local_e0;\n  char **local_d8;\n  char *local_c8 [4];\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined4 local_98;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  \n  bVar8 \u003d 0;\n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_98 \u003d param_1;\n    local_88 \u003d param_2;\n    local_78 \u003d param_3;\n    local_68 \u003d param_4;\n    local_58 \u003d param_5;\n    local_48 \u003d param_6;\n    local_38 \u003d param_7;\n    local_28 \u003d param_8;\n  }\n  local_d8 \u003d (char **)\u0026stack0x00000008;\n  lVar5 \u003d 0;\n  local_e0 \u003d 8;\n  pcVar6 \u003d \"none\";\n  local_c8[1] \u003d (char *)param_10;\n  local_c8[2] \u003d (char *)param_11;\n  local_c8[3] \u003d (char *)param_12;\n  local_a8 \u003d param_13;\n  local_a0 \u003d param_14;\n  do {\n    sVar1 \u003d strlen(pcVar6);\n    lVar5 \u003d lVar5 + sVar1;\n    if (local_e0 \u003c 0x30) {\n      uVar2 \u003d (ulong)local_e0;\n      local_e0 \u003d local_e0 + 8;\n      ppcVar4 \u003d (char **)((long)local_c8 + uVar2);\n    }\n    else {\n      ppcVar4 \u003d local_d8;\n      local_d8 \u003d local_d8 + 1;\n    }\n    pcVar6 \u003d *ppcVar4;\n  } while (pcVar6 !\u003d (char *)0x0);\n  pcVar6 \u003d \"none\";\n  pcVar3 \u003d (char *)FUN_00105370(lVar5 + 1);\n  local_e0 \u003d 8;\n  local_d8 \u003d (char **)\u0026stack0x00000008;\n  pcVar7 \u003d pcVar3;\n  do {\n    sVar1 \u003d strlen(pcVar6);\n    for (; sVar1 !\u003d 0; sVar1 \u003d sVar1 - 1) {\n      *pcVar7 \u003d *pcVar6;\n      pcVar6 \u003d pcVar6 + (ulong)bVar8 * -2 + 1;\n      pcVar7 \u003d pcVar7 + (ulong)bVar8 * -2 + 1;\n    }\n    if (local_e0 \u003c 0x30) {\n      uVar2 \u003d (ulong)local_e0;\n      local_e0 \u003d local_e0 + 8;\n      ppcVar4 \u003d (char **)((long)local_c8 + uVar2);\n    }\n    else {\n      ppcVar4 \u003d local_d8;\n      local_d8 \u003d local_d8 + 1;\n    }\n    pcVar6 \u003d *ppcVar4;\n  } while (pcVar6 !\u003d (char *)0x0);\n  *pcVar7 \u003d \u0027\\0\u0027;\n  return pcVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001032de"
      ],
      "called": [
        "strlen",
        "FUN_00105370"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001032de": {
      "entrypoint": "0x001032de",
      "current_name": "FUN_001032de",
      "code": "\nvoid FUN_001032de(FILE *param_1,int param_2)\n\n{\n  undefined8 *puVar1;\n  void *__ptr;\n  char *pcVar2;\n  undefined4 *puVar3;\n  \n  puVar3 \u003d \u0026DAT_00108ca0;\n  __ptr \u003d (void *)FUN_00103186(\u0026DAT_00106137,0);\n  do {\n    puVar1 \u003d (undefined8 *)(puVar3 + 6);\n    puVar3 \u003d puVar3 + 4;\n    __ptr \u003d (void *)FUN_00103006(__ptr,__ptr,\u0026DAT_001061ef,*puVar1,0);\n  } while (puVar3 !\u003d (undefined4 *)\u0026DAT_00108d90);\n  pcVar2 \u003d (char *)dcgettext(0,\"Usage: %s \u003coption(s)\u003e elffile(s)\\n\",5);\n  fprintf(param_1,pcVar2,\"elfedit\");\n  pcVar2 \u003d (char *)dcgettext(0,\" Update the ELF header of ELF files\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\" The options are:\\n\",5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  --input-mach [none|i386|iamcu|l1om|k1om|x86_64]\\n                              Set input machine type\\n  --output-mach [none|i386|iamcu|l1om|k1om|x86_64]\\n                              Set output machine type\\n  --input-type [none|rel|exec|dyn]\\n                              Set input file type\\n  --output-type [none|rel|exec|dyn]\\n                              Set output file type\\n  --input-osabi [%s]\\n                              Set input OSABI\\n  --output-osabi [%s]\\n                              Set output OSABI\\n  --input-abiversion [0-255]  Set input ABIVERSION\\n  --output-abiversion [0-255] Set output ABIVERSION\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2,__ptr,__ptr);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  --enable-x86-feature [ibt|shstk|lam_u48|lam_u57]\\n                              Enable x86 feature\\n  --disable-x86-feature [ibt|shstk|lam_u48|lam_u57]\\n                              Disable x86 feature\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -h --help                   Display this information\\n  -v --version                Display the version number of %s\\n\"\n                             ,5);\n  fprintf(param_1,pcVar2,\"elfedit\");\n  if (param_2 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(param_1,pcVar2,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n  free(__ptr);\n                    \n  exit(param_2);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "dcgettext",
        "FUN_00103186",
        "free",
        "fprintf",
        "exit",
        "FUN_00103006"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103449": {
      "entrypoint": "0x00103449",
      "current_name": "FUN_00103449",
      "code": "\nvoid FUN_00103449(void *param_1,size_t param_2)\n\n{\n  size_t __size;\n  void *pvVar1;\n  \n  __size \u003d 1;\n  if (param_2 !\u003d 0) {\n    __size \u003d param_2;\n  }\n  if (param_1 \u003d\u003d (void *)0x0) {\n    pvVar1 \u003d malloc(__size);\n  }\n  else {\n    pvVar1 \u003d realloc(param_1,__size);\n  }\n  if (pvVar1 \u003d\u003d (void *)0x0) {\n    FUN_00102fc7(__size);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "FUN_00102fc7",
        "malloc",
        "realloc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010347f": {
      "entrypoint": "0x0010347f",
      "current_name": "FUN_0010347f",
      "code": "\nulong FUN_0010347f(ulong *param_1,undefined4 param_2)\n\n{\n  uint uVar1;\n  ulong uVar2;\n  undefined8 uVar3;\n  \n  switch(param_2) {\n  case 1:\n    return (ulong)*(byte *)param_1;\n  case 2:\n    return (ulong)CONCAT11((char)*(undefined2 *)param_1,(char)((ushort)*(undefined2 *)param_1 \u003e\u003e 8))\n    ;\n  case 3:\n    return (ulong)*(byte *)((long)param_1 + 1) \u003c\u003c 8 | (ulong)*(byte *)param_1 \u003c\u003c 0x10 |\n           (ulong)*(byte *)((long)param_1 + 2);\n  case 4:\n    uVar1 \u003d *(uint *)param_1;\n    return (ulong)(uVar1 \u003e\u003e 0x18 | (uVar1 \u0026 0xff0000) \u003e\u003e 8 | (uVar1 \u0026 0xff00) \u003c\u003c 8 | uVar1 \u003c\u003c 0x18);\n  case 5:\n    uVar1 \u003d *(uint *)((long)param_1 + 1);\n    return (ulong)CONCAT14(*(byte *)param_1,\n                           uVar1 \u003e\u003e 0x18 | (uVar1 \u0026 0xff0000) \u003e\u003e 8 | (uVar1 \u0026 0xff00) \u003c\u003c 8 |\n                           uVar1 \u003c\u003c 0x18);\n  case 6:\n    uVar1 \u003d *(uint *)((long)param_1 + 2);\n    return (ulong)*(byte *)((long)param_1 + 1) \u003c\u003c 0x20 | (ulong)*(byte *)param_1 \u003c\u003c 0x28 |\n           (ulong)(uVar1 \u003e\u003e 0x18 | (uVar1 \u0026 0xff0000) \u003e\u003e 8 | (uVar1 \u0026 0xff00) \u003c\u003c 8 | uVar1 \u003c\u003c 0x18);\n  case 7:\n    uVar1 \u003d *(uint *)((long)param_1 + 3);\n    return (ulong)*(byte *)((long)param_1 + 2) \u003c\u003c 0x20 | (ulong)*(byte *)((long)param_1 + 1) \u003c\u003c 0x28\n           | (ulong)*(byte *)param_1 \u003c\u003c 0x30 |\n           (ulong)(uVar1 \u003e\u003e 0x18 | (uVar1 \u0026 0xff0000) \u003e\u003e 8 | (uVar1 \u0026 0xff00) \u003c\u003c 8 | uVar1 \u003c\u003c 0x18);\n  case 8:\n    uVar2 \u003d *param_1;\n    return uVar2 \u003e\u003e 0x38 | (uVar2 \u0026 0xff000000000000) \u003e\u003e 0x28 | (uVar2 \u0026 0xff0000000000) \u003e\u003e 0x18 |\n           (uVar2 \u0026 0xff00000000) \u003e\u003e 8 | (uVar2 \u0026 0xff000000) \u003c\u003c 8 | (uVar2 \u0026 0xff0000) \u003c\u003c 0x18 |\n           (uVar2 \u0026 0xff00) \u003c\u003c 0x28 | uVar2 \u003c\u003c 0x38;\n  default:\n    uVar3 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n    error(uVar3,param_2);\n                    \n    abort();\n  }\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0"
      ],
      "called": [
        "dcgettext",
        "error",
        "abort"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010354e": {
      "entrypoint": "0x0010354e",
      "current_name": "FUN_0010354e",
      "code": "\nvoid FUN_0010354e(long param_1,ulong param_2,uint param_3)\n\n{\n  undefined8 uVar1;\n  int iVar2;\n  ulong uVar3;\n  \n  uVar3 \u003d (ulong)param_3;\n  if (8 \u003c param_3) {\n    uVar1 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n    error(uVar1,param_3);\n                    \n    abort();\n  }\n  while (iVar2 \u003d (int)uVar3, uVar3 \u003d (ulong)(iVar2 - 1), iVar2 !\u003d 0) {\n    *(char *)(param_1 + uVar3) \u003d (char)param_2;\n    param_2 \u003d param_2 \u003e\u003e 8;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0"
      ],
      "called": [
        "dcgettext",
        "error",
        "abort"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010358d": {
      "entrypoint": "0x0010358d",
      "current_name": "FUN_0010358d",
      "code": "\nuint FUN_0010358d(undefined8 param_1,FILE *param_2,char param_3)\n\n{\n  long lVar1;\n  char *pcVar2;\n  int iVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  size_t sVar6;\n  undefined8 uVar7;\n  ulong uVar8;\n  size_t sVar9;\n  char *__s;\n  size_t sVar10;\n  size_t sVar11;\n  char *__s_00;\n  char *pcVar12;\n  FILE *__stream;\n  char *pcVar13;\n  uint uVar14;\n  stat local_208;\n  undefined local_178 [24];\n  undefined local_160 [16];\n  undefined8 local_148;\n  undefined local_d8 [16];\n  undefined local_c0 [16];\n  undefined8 local_a8;\n  long local_98;\n  long local_90;\n  int local_88;\n  undefined local_80 [48];\n  char local_50 [10];\n  short local_46;\n  \n  local_148 \u003d 0;\n  local_d8 \u003d ZEXT816(0);\n  local_c0 \u003d ZEXT816(0);\n  local_178._0_16_ \u003d ZEXT816(0);\n  local_160 \u003d ZEXT816(0);\n  local_a8 \u003d 0;\n  iVar3 \u003d fileno(param_2);\n  iVar3 \u003d fstat(iVar3,\u0026local_208);\n  if ((iVar3 \u003c 0) ||\n     (iVar3 \u003d FUN_001025ab(local_d8,param_1,param_2,local_208.st_size,param_3), iVar3 !\u003d 0)) {\nLAB_001036cc:\n    uVar14 \u003d 1;\nLAB_00103a46:\n    if ((FILE *)local_178._8_8_ !\u003d (FILE *)0x0) {\n      fclose((FILE *)local_178._8_8_);\n    }\n    FUN_00102f65(local_178);\n    FUN_00102f65(local_d8);\n  }\n  else {\n    uVar14 \u003d 0;\n    while (iVar3 \u003d fseek(param_2,local_90,0), iVar3 \u003d\u003d 0) {\n      sVar6 \u003d fread(local_80,1,0x3c,param_2);\n      if (sVar6 !\u003d 0x3c) {\n        if (sVar6 \u003d\u003d 0) goto LAB_00103a46;\n        pcVar13 \u003d \"%s: failed to read archive header\\n\";\nLAB_001036b8:\n        uVar5 \u003d dcgettext(0,pcVar13,5);\n        error(uVar5,param_1);\n        goto LAB_001036cc;\n      }\n      if (local_46 !\u003d 0xa60) {\n        uVar5 \u003d local_d8._0_8_;\n        uVar7 \u003d dcgettext(0,\"%s: did not find a valid archive header\\n\",5);\n        error(uVar7,uVar5);\n        goto LAB_001036cc;\n      }\n      local_90 \u003d local_90 + 0x3c;\n      uVar8 \u003d strtoul(local_50,(char **)0x0,10);\n      DAT_00109438 \u003d (uVar8 + 1) - (ulong)((uVar8 \u0026 1) \u003d\u003d 0);\n      pcVar13 \u003d (char *)FUN_001029a5(local_d8,local_178);\n      if (pcVar13 \u003d\u003d (char *)0x0) {\n        pcVar13 \u003d \"%s: bad archive file name\\n\";\n        goto LAB_001036b8;\n      }\n      sVar9 \u003d strlen(pcVar13);\n      __s \u003d (char *)dcgettext(0,\"\u003ccorrupt\u003e\",5);\n      pcVar12 \u003d (char *)local_d8._0_8_;\n      sVar10 \u003d strlen((char *)local_d8._0_8_);\n      sVar11 \u003d strlen(pcVar13);\n      sVar6 \u003d sVar10 + sVar11 + 3;\n      if (local_88 \u003d\u003d 0) {\n        __s_00 \u003d (char *)malloc(sVar6);\n        if (__s_00 \u003d\u003d (char *)0x0) goto LAB_001037d3;\n        snprintf(__s_00,sVar6,\"%s(%s)\",pcVar12,pcVar13);\n      }\n      else if (local_98 \u003d\u003d 0) {\n        __s_00 \u003d (char *)malloc(sVar6);\n        if (__s_00 \u003d\u003d (char *)0x0) {\nLAB_001037d3:\n          uVar5 \u003d dcgettext(0,\"Out of memory\\n\",5);\n          error(uVar5);\n          uVar5 \u003d dcgettext(0,\"%s: bad archive file name\\n\",5);\n          error(uVar5,param_1);\n          free(pcVar13);\n          goto LAB_001036cc;\n        }\n        snprintf(__s_00,sVar6,\"%s[%s]\",pcVar12,pcVar13);\n      }\n      else {\n        pcVar2 \u003d (char *)local_178._0_8_;\n        lVar1 \u003d sVar10 + sVar11 + 5;\n        if ((char *)local_178._0_8_ \u003d\u003d (char *)0x0) {\n          sVar6 \u003d strlen(__s);\n          sVar6 \u003d lVar1 + sVar6;\n          __s_00 \u003d (char *)malloc(sVar6);\n          pcVar2 \u003d __s;\n        }\n        else {\n          sVar6 \u003d strlen((char *)local_178._0_8_);\n          sVar6 \u003d lVar1 + sVar6;\n          __s_00 \u003d (char *)malloc(sVar6);\n        }\n        if (__s_00 \u003d\u003d (char *)0x0) goto LAB_001037d3;\n        snprintf(__s_00,sVar6,\"%s[%s(%s)]\",pcVar12,pcVar2,pcVar13);\n      }\n      if (param_3 \u003d\u003d \u0027\\0\u0027) {\n        free(pcVar13);\n        local_90 \u003d local_90 + DAT_00109438;\n        uVar4 \u003d FUN_00104de0(__s_00,param_2);\n        uVar14 \u003d uVar14 | uVar4;\n      }\n      else {\n        if (local_98 \u003d\u003d 0) {\n          pcVar12 \u003d (char *)FUN_00102cc4(param_1,pcVar13,sVar9);\n          free(pcVar13);\n          if (pcVar12 !\u003d (char *)0x0) {\n            __stream \u003d fopen(pcVar12,\"r+b\");\n            if (__stream !\u003d (FILE *)0x0) {\n              uVar4 \u003d FUN_00104de0(__s_00,__stream);\n              uVar14 \u003d uVar14 | uVar4;\n              fclose(__stream);\n              free(pcVar12);\n              goto LAB_00103a39;\n            }\n            uVar5 \u003d dcgettext(0,\"Input file \\\u0027%s\\\u0027 is not readable\\n\",5);\n            error(uVar5,pcVar12);\n            free(pcVar12);\n          }\n          free(__s_00);\n          goto LAB_001036cc;\n        }\n        free(pcVar13);\n        iVar3 \u003d fseek((FILE *)local_178._8_8_,local_98 + 0x3c,0);\n        if (iVar3 !\u003d 0) {\n          uVar5 \u003d local_178._0_8_;\n          uVar7 \u003d dcgettext(0,\"%s: failed to seek to archive member\\n\",5);\n          error(uVar7,uVar5);\n          free(__s_00);\n          goto LAB_001036cc;\n        }\n        uVar4 \u003d FUN_00104de0(__s_00,local_178._8_8_);\n        uVar14 \u003d uVar14 | uVar4;\n      }\nLAB_00103a39:\n      free(__s_00);\n    }\n    uVar5 \u003d dcgettext(0,\"%s: failed to seek to next archive header\\n\",5);\n    uVar14 \u003d 1;\n    error(uVar5,param_1);\n  }\n  return uVar14;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "fopen",
        "error",
        "free",
        "malloc",
        "FUN_00104de0",
        "fseek",
        "FUN_001029a5",
        "FUN_00102f65",
        "strtoul",
        "dcgettext",
        "fileno",
        "strlen",
        "fread",
        "fclose",
        "snprintf",
        "FUN_001025ab",
        "FUN_00102cc4",
        "fstat"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103a90": {
      "entrypoint": "0x00103a90",
      "current_name": "FUN_00103a90",
      "code": "\nulong FUN_00103a90(ulong *param_1,ulong param_2)\n\n{\n  ulong uVar1;\n  undefined8 uVar2;\n  \n  switch(param_2 \u0026 0xffffffff) {\n  default:\n    uVar2 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n    error(uVar2,param_2 \u0026 0xffffffff);\n                    \n    abort();\n  case 1:\n    return (ulong)*(byte *)param_1;\n  case 2:\n    return (ulong)*(ushort *)param_1;\n  case 3:\n    uVar1 \u003d FUN_00103ab3(param_1,param_2,\n                         (ulong)*(byte *)((long)param_1 + 1) \u003c\u003c 8 |\n                         (ulong)*(byte *)((long)param_1 + 2) \u003c\u003c 0x10);\n    return uVar1;\n  case 4:\n    return (ulong)*(uint *)param_1;\n  case 5:\n    uVar1 \u003d FUN_00103ab3(param_1,param_2,(ulong)*(byte *)((long)param_1 + 4) \u003c\u003c 0x20);\n    return uVar1;\n  case 6:\n    uVar1 \u003d FUN_00103ab3(param_1,param_2,\n                         (ulong)*(byte *)((long)param_1 + 4) \u003c\u003c 0x20 |\n                         (ulong)*(byte *)((long)param_1 + 5) \u003c\u003c 0x28);\n    return uVar1;\n  case 7:\n    uVar1 \u003d FUN_00103ab3(param_1,param_2,\n                         (ulong)*(byte *)((long)param_1 + 4) \u003c\u003c 0x20 |\n                         (ulong)*(byte *)((long)param_1 + 5) \u003c\u003c 0x28 | (ulong)*(uint *)param_1);\n    return uVar1;\n  case 8:\n    return *param_1;\n  }\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0"
      ],
      "called": [
        "FUN_00103ab3",
        "caseD_0",
        "caseD_3"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103ab3": {
      "entrypoint": "0x00103ab3",
      "current_name": "FUN_00103ab3",
      "code": "\nvoid FUN_00103ab3(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103a90",
        "caseD_3"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103ad0": {
      "entrypoint": "0x00103ad0",
      "current_name": "FUN_00103ad0",
      "code": "\nvoid FUN_00103ad0(long param_1,ulong param_2,uint param_3)\n\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  \n  if (param_3 \u003c 9) {\n    for (uVar2 \u003d 0; param_3 !\u003d uVar2; uVar2 \u003d uVar2 + 1) {\n      *(char *)(param_1 + uVar2) \u003d (char)param_2;\n      param_2 \u003d param_2 \u003e\u003e 8;\n    }\n    return;\n  }\n  uVar1 \u003d dcgettext(0,\"Unhandled data length: %d\\n\",5);\n  error(uVar1,param_3);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00104de0"
      ],
      "called": [
        "FUN_00102c98"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "entry": {
      "entrypoint": "0x00103b00",
      "current_name": "entry",
      "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_00103bf0,param_2,\u0026stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__libc_start_main",
        "FUN_00103bf0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103b30": {
      "entrypoint": "0x00103b30",
      "current_name": "FUN_00103b30",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00103b43) */\n/* WARNING: Removing unreachable block (ram,0x00103b4f) */\n\nvoid FUN_00103b30(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "_ITM_deregisterTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103b60": {
      "entrypoint": "0x00103b60",
      "current_name": "FUN_00103b60",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00103b84) */\n/* WARNING: Removing unreachable block (ram,0x00103b90) */\n\nvoid FUN_00103b60(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_INIT_0"
      ],
      "called": [
        "_ITM_registerTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_FINI_0": {
      "entrypoint": "0x00103ba0",
      "current_name": "_FINI_0",
      "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_00109320 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_00109148);\n  FUN_00103b30();\n  DAT_00109320 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00103b30",
        "__cxa_finalize"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_INIT_0": {
      "entrypoint": "0x00103be0",
      "current_name": "_INIT_0",
      "code": "\nvoid _INIT_0(void)\n\n{\n  FUN_00103b60();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00103b60"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103bf0": {
      "entrypoint": "0x00103bf0",
      "current_name": "FUN_00103bf0",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\n\nuint FUN_00103bf0(int param_1,long *param_2)\n\n{\n  char cVar1;\n  byte bVar2;\n  ulong uVar3;\n  bool bVar4;\n  bool bVar5;\n  bool bVar6;\n  bool bVar7;\n  int iVar8;\n  uint uVar9;\n  int iVar10;\n  void *__addr;\n  void *__ptr;\n  long *plVar11;\n  ulong uVar12;\n  ulong uVar13;\n  ulong uVar14;\n  ulong uVar15;\n  FILE *pFVar16;\n  size_t sVar17;\n  byte *__s;\n  size_t sVar18;\n  int *piVar19;\n  long lVar20;\n  long *plVar21;\n  byte *pbVar22;\n  long lVar23;\n  long *plVar24;\n  undefined8 uVar25;\n  ulong uVar26;\n  byte *pbVar27;\n  uint uVar28;\n  long lVar29;\n  uint uVar30;\n  int iVar31;\n  undefined **ppuVar32;\n  uint uVar33;\n  char *pcVar34;\n  ulong uVar35;\n  char *pcVar36;\n  undefined8 *puVar37;\n  ulong uVar38;\n  undefined8 *local_138;\n  ulong local_120;\n  char *local_d8;\n  byte *local_d0;\n  stat local_c8;\n  \n  iVar8 \u003d 0;\n  iVar31 \u003d 2000;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  plVar21 \u003d param_2;\nLAB_00103c54:\n  lVar29 \u003d (long)(iVar8 + 1);\n  do {\n    iVar8 \u003d (int)lVar29;\n    if (param_1 \u003c\u003d iVar8) {\n      ppuVar32 \u003d \u0026PTR_s_input_mach_00109180;\n      break;\n    }\n    if (*(char *)plVar21[lVar29] \u003d\u003d \u0027@\u0027) {\n      iVar31 \u003d iVar31 + -1;\n      if (iVar31 \u003d\u003d 0) {\n        lVar29 \u003d *plVar21;\n        pcVar36 \u003d \"%s: error: too many @-files encountered\\n\";\n        goto LAB_00104739;\n      }\n      pcVar36 \u003d (char *)plVar21[lVar29] + 1;\n      iVar10 \u003d stat(pcVar36,\u0026local_c8);\n      if (-1 \u003c iVar10) {\n        if ((local_c8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n          do {\n            lVar29 \u003d *plVar21;\n            pcVar36 \u003d \"%s: error: @-file refers to a directory\\n\";\nLAB_00104739:\n            fprintf(_stderr,pcVar36,lVar29);\n            FUN_00102fbc();\n          } while( true );\n        }\n        pFVar16 \u003d fopen(pcVar36,\"r\");\n        if (pFVar16 !\u003d (FILE *)0x0) goto code_r0x00104650;\n      }\n    }\n    lVar29 \u003d lVar29 + 1;\n  } while( true );\nLAB_00103c87:\n  iVar8 \u003d getopt_long(param_1,plVar21,\u0026DAT_0010604c,ppuVar32,0);\n  if (iVar8 \u003d\u003d -1) {\n    if ((_optind \u003d\u003d param_1) ||\n       (((DAT_00109444 | DAT_00109440) \u003d\u003d 0 \u0026\u0026\n        (ppuVar32 \u003d (undefined **)0x0,\n        (DAT_0010916c \u0026 DAT_00109160 \u0026 DAT_00109158 \u0026 DAT_00109150) \u003d\u003d 0xffffffff))))\n    goto switchD_00103cba_caseD_69;\n    uVar30 \u003d 0;\n    goto LAB_00103d1c;\n  }\n  switch(iVar8) {\n  case 0x68:\n    FUN_001032de(_stdout,0);\n  default:\nswitchD_00103cba_caseD_69:\n    FUN_001032de(_stderr,1);\n    goto switchD_00103cba_caseD_9a;\n  case 0x76:\n    printf(\"GNU %s %s\\n\",\"elfedit\",\"(GNU Binutils for Debian) 2.40\");\n    pcVar36 \u003d (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n    printf(pcVar36);\n    pcVar36 \u003d (char *)dcgettext(0,\n                                \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                                ,5);\n    printf(pcVar36);\n                    \n    exit(0);\n  case 0x96:\n    DAT_00109174 \u003d FUN_00104d30(_optarg);\n    if (DAT_00109174 \u003c 0) {\n      return 1;\n    }\n    if (DAT_00109174 \u003d\u003d 6) {\n      DAT_00109170 \u003d 1;\n    }\n    else if (DAT_00109174 \u003c 7) {\n      DAT_00109170 \u003d (DAT_00109174 !\u003d 3) + 1 + (uint)(DAT_00109174 !\u003d 3);\n    }\n    else {\n      DAT_00109170 \u003d 3 - (uint)(DAT_00109174 - 0xb4U \u003c 2);\n    }\n    goto LAB_00103c87;\n  case 0x97:\n    DAT_0010916c \u003d FUN_00104d30(_optarg);\n    if ((int)DAT_0010916c \u003c 0) {\n      return 1;\n    }\n    if ((int)DAT_0010916c \u003c 0xb6) {\n      DAT_00109168 \u003d 2;\n      if (((int)DAT_0010916c \u003c 0xb4) \u0026\u0026 (DAT_00109168 \u003d 1, DAT_0010916c !\u003d 3)) {\n        DAT_00109168 \u003d (DAT_0010916c !\u003d 6) + 1 + (uint)(DAT_0010916c !\u003d 6);\n      }\n    }\n    else {\n      DAT_00109168 \u003d 3;\n    }\n    goto LAB_00103c87;\n  case 0x98:\n    DAT_00109164 \u003d FUN_00104da0(_optarg);\n    uVar30 \u003d DAT_00109164;\n    break;\n  case 0x99:\n    DAT_00109160 \u003d FUN_00104da0(_optarg);\n    uVar30 \u003d DAT_00109160;\n    break;\n  case 0x9a:\n    goto switchD_00103cba_caseD_9a;\n  case 0x9b:\n    DAT_00109158 \u003d FUN_00104ce0(_optarg);\n    uVar30 \u003d DAT_00109158;\n    break;\n  case 0x9c:\n    uVar15 \u003d strtoul(_optarg,\u0026local_d8,0);\n    uVar30 \u003d (uint)uVar15;\n    cVar1 \u003d *local_d8;\n    DAT_00109154 \u003d uVar30;\n    pcVar36 \u003d _optarg;\n    goto joined_r0x00104334;\n  case 0x9d:\n    uVar15 \u003d strtoul(_optarg,\u0026local_d8,0);\n    uVar30 \u003d (uint)uVar15;\n    cVar1 \u003d *local_d8;\n    DAT_00109150 \u003d uVar30;\n    pcVar36 \u003d _optarg;\njoined_r0x00104334:\n    _optarg \u003d pcVar36;\n    if ((cVar1 !\u003d \u0027\\0\u0027) || (0xff \u003c uVar30)) {\n      uVar25 \u003d dcgettext(0,\"Invalid ABIVERSION: %s\\n\",5);\n      error(uVar25,pcVar36);\n      return 1;\n    }\n    goto LAB_00103c87;\n  case 0x9e:\n    uVar25 \u003d 1;\n    goto LAB_00103e9d;\n  case 0x9f:\n    uVar25 \u003d 0;\nLAB_00103e9d:\n    uVar30 \u003d FUN_00104c60(_optarg,uVar25);\n  }\njoined_r0x00103eae:\n  if ((int)uVar30 \u003c 0) {\n    return 1;\n  }\n  goto LAB_00103c87;\nLAB_00103d1c:\n  lVar29 \u003d (long)_optind;\n  if (param_1 \u003c\u003d _optind) {\n    return uVar30;\n  }\n  _optind \u003d _optind + 1;\n  pcVar36 \u003d (char *)plVar21[lVar29];\n  iVar8 \u003d stat(pcVar36,\u0026local_c8);\n  if (iVar8 \u003c 0) {\n    piVar19 \u003d __errno_location();\n    pcVar34 \u003d \"\\\u0027%s\\\u0027: No such file\\n\";\n    if (*piVar19 \u003d\u003d 2) goto LAB_00104497;\n    pcVar34 \u003d strerror(*piVar19);\n    uVar25 \u003d dcgettext(0,\"Could not locate \\\u0027%s\\\u0027.  System error message: %s\\n\",5);\n    error(uVar25,pcVar36,pcVar34);\nLAB_001044ab:\n    uVar9 \u003d 1;\n  }\n  else {\n    if ((local_c8.st_mode \u0026 0xf000) !\u003d 0x8000) {\n      pcVar34 \u003d \"\\\u0027%s\\\u0027 is not an ordinary file\\n\";\nLAB_00104497:\n      uVar25 \u003d dcgettext(0,pcVar34,5);\n      error(uVar25,pcVar36);\n      goto LAB_001044ab;\n    }\n    pFVar16 \u003d fopen(pcVar36,\"r+b\");\n    if (pFVar16 \u003d\u003d (FILE *)0x0) {\n      pcVar34 \u003d \"Input file \\\u0027%s\\\u0027 is not readable\\n\";\n      goto LAB_00104497;\n    }\n    sVar17 \u003d fread(\u0026local_d0,8,1,pFVar16);\n    if (sVar17 !\u003d 1) {\n      uVar25 \u003d dcgettext(0,\"%s: Failed to read file\\\u0027s magic number\\n\",5);\n      error(uVar25,pcVar36);\n      fclose(pFVar16);\n      goto LAB_001044ab;\n    }\n    if (local_d0 \u003d\u003d (byte *)0xa3e686372613c21) {\n      uVar9 \u003d FUN_0010358d(pcVar36,pFVar16,0);\n    }\n    else if (local_d0 \u003d\u003d (byte *)0xa3e6e6968743c21) {\n      uVar9 \u003d FUN_0010358d(pcVar36,pFVar16,1);\n    }\n    else {\n      rewind(pFVar16);\n      DAT_00109438 \u003d 0;\n      uVar9 \u003d FUN_00104de0(pcVar36,pFVar16);\n      if (((uVar9 \u003d\u003d 0) \u0026\u0026 ((ushort)(DAT_00109418 - 2U) \u003c 2)) \u0026\u0026\n         ((DAT_00109444 | DAT_00109440) !\u003d 0)) {\n        if ((DAT_0010941a \u003d\u003d 3) ||\n           (pcVar34 \u003d \"%s: Not an i386 nor x86-64 ELF file\\n\", DAT_0010941a \u003d\u003d 0x3e)) {\n          iVar8 \u003d fileno(pFVar16);\n          iVar8 \u003d fstat(iVar8,\u0026local_c8);\n          if (iVar8 \u003c 0) {\n            uVar25 \u003d dcgettext(0,\"%s: stat () failed\\n\",5);\n            error(uVar25,pcVar36);\n            uVar9 \u003d 1;\n          }\n          else {\n            iVar8 \u003d fileno(pFVar16);\n            __addr \u003d mmap((void *)0x0,local_c8.st_size,3,1,iVar8,0);\n            if (__addr \u003d\u003d (void *)0xffffffffffffffff) {\n              pcVar34 \u003d \"%s: mmap () failed\\n\";\n              goto LAB_0010438d;\n            }\n            __ptr \u003d (void *)FUN_00105370((ulong)DAT_00109424 \u003c\u003c 6);\n            lVar29 \u003d DAT_001093f8;\n            if (DAT_001093e4 \u003d\u003d \u0027\\x01\u0027) {\n              for (uVar15 \u003d 0; (uint)uVar15 \u003c DAT_00109424; uVar15 \u003d (ulong)((uint)uVar15 + 1)) {\n                lVar20 \u003d uVar15 * 0x20 + lVar29 + (long)__addr;\n                puVar37 \u003d (undefined8 *)((long)__ptr + uVar15 * 0x40);\n                uVar25 \u003d (*DAT_001093c0)(lVar20,4);\n                *puVar37 \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 4,4);\n                puVar37[2] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 8,4);\n                puVar37[3] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0xc,4);\n                puVar37[4] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x10,4);\n                puVar37[5] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x14,4);\n                puVar37[6] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x18,4);\n                puVar37[1] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x1c,4);\n                puVar37[7] \u003d uVar25;\n              }\n            }\n            else {\n              for (uVar28 \u003d 0; uVar28 \u003c DAT_00109424; uVar28 \u003d uVar28 + 1) {\n                lVar20 \u003d (ulong)uVar28 * 0x38 + lVar29 + (long)__addr;\n                puVar37 \u003d (undefined8 *)((ulong)uVar28 * 0x40 + (long)__ptr);\n                uVar25 \u003d (*DAT_001093c0)(lVar20,4);\n                *puVar37 \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 8,8);\n                puVar37[2] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x10,8);\n                puVar37[3] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x18,8);\n                puVar37[4] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x20,8);\n                puVar37[5] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x28,8);\n                puVar37[6] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 4,4);\n                puVar37[1] \u003d uVar25;\n                uVar25 \u003d (*DAT_001093c0)(lVar20 + 0x30,8);\n                puVar37[7] \u003d uVar25;\n              }\n            }\n            for (uVar15 \u003d 0; (uint)uVar15 \u003c DAT_00109424; uVar15 \u003d (ulong)((uint)uVar15 + 1)) {\n              plVar11 \u003d (long *)(uVar15 * 0x40 + (long)__ptr);\n              if (*plVar11 \u003d\u003d 4) {\n                lVar29 \u003d plVar11[5];\n                uVar3 \u003d plVar11[7];\n                uVar35 \u003d (long)__addr + plVar11[2];\n                for (local_120 \u003d uVar35; local_120 \u003c uVar35 + lVar29;\n                    local_120 \u003d local_120 + ((uVar3 - 1) + uVar14 + uVar13 \u0026 uVar26)) {\n                  if ((uVar35 - local_120) + lVar29 \u003c 0xc) {\nLAB_001044cb:\n                    uVar25 \u003d dcgettext(0,\"%s: Invalid PT_NOTE segment\\n\",5);\n                    error(uVar25,pcVar36);\n                    uVar9 \u003d 1;\n                    goto LAB_001042bf;\n                  }\n                  lVar20 \u003d (*DAT_001093c0)(local_120 + 8,4);\n                  uVar12 \u003d (*DAT_001093c0)(local_120,4);\n                  if ((uVar35 - (long)(char *)(local_120 + 0xc)) + lVar29 \u003c uVar12)\n                  goto LAB_001044cb;\n                  uVar13 \u003d (*DAT_001093c0)(local_120 + 4,4);\n                  uVar26 \u003d -uVar3;\n                  uVar14 \u003d uVar3 + 0xb + uVar12 \u0026 uVar26;\n                  uVar38 \u003d local_120 + uVar14;\n                  if ((uVar13 !\u003d 0) \u0026\u0026\n                     ((uVar35 + lVar29 \u003c\u003d uVar38 || ((uVar35 - uVar38) + lVar29 \u003c uVar13))))\n                  goto LAB_001044cb;\n                  if ((uVar12 \u003d\u003d 4) \u0026\u0026\n                     ((iVar8 \u003d strcmp((char *)(local_120 + 0xc),\"GNU\"), iVar8 \u003d\u003d 0 \u0026\u0026 (lVar20 \u003d\u003d 5))\n                     )) {\n                    if ((uVar13 \u003c 8) || (uVar13 % uVar3 !\u003d 0)) goto LAB_001044cb;\n                    uVar12 \u003d uVar38 + uVar13;\n                    do {\n                      iVar8 \u003d (*DAT_001093c0)(uVar38,4);\n                      uVar28 \u003d (*DAT_001093c0)(uVar38 + 4,4);\n                      lVar20 \u003d uVar38 + 8;\n                      if (uVar12 \u003c lVar20 + (ulong)uVar28) goto LAB_001044cb;\n                      if (iVar8 \u003d\u003d -0x3ffffffe) {\n                        if (uVar28 !\u003d 4) goto LAB_001044cb;\n                        uVar28 \u003d (*DAT_001093c0)(lVar20,4);\n                        if (DAT_00109444 \u003d\u003d 0) {\n                          uVar33 \u003d uVar28;\n                          if (DAT_00109440 \u003d\u003d 0) goto LAB_001042bf;\nLAB_001042ac:\n                          uVar33 \u003d uVar33 \u0026 ~DAT_00109440;\n                        }\n                        else {\n                          uVar33 \u003d DAT_00109444 | uVar28;\n                          if (DAT_00109440 !\u003d 0) goto LAB_001042ac;\n                        }\n                        if (uVar28 !\u003d uVar33) {\n                          (*DAT_001093b8)(lVar20,uVar33,4);\n                        }\n                        goto LAB_001042bf;\n                      }\n                      uVar38 \u003d lVar20 + ((ulong)uVar28 + (uVar3 - 1) \u0026 uVar26);\n                    } while (7 \u003c (long)(uVar12 - uVar38));\n                  }\n                }\n              }\n            }\nLAB_001042bf:\n            free(__ptr);\n            munmap(__addr,local_c8.st_size);\n          }\n        }\n        else {\nLAB_0010438d:\n          uVar25 \u003d dcgettext(0,pcVar34,5);\n          error(uVar25,pcVar36);\n        }\n      }\n    }\n    fclose(pFVar16);\n  }\n  uVar30 \u003d uVar30 | uVar9;\n  goto LAB_00103d1c;\nswitchD_00103cba_caseD_9a:\n  DAT_0010915c \u003d FUN_00104ce0(_optarg);\n  uVar30 \u003d DAT_0010915c;\n  goto joined_r0x00103eae;\ncode_r0x00104650:\n  iVar10 \u003d fseek(pFVar16,0,2);\n  if (((iVar10 !\u003d -1) \u0026\u0026 (sVar17 \u003d ftell(pFVar16), sVar17 !\u003d 0xffffffffffffffff)) \u0026\u0026\n     (iVar10 \u003d fseek(pFVar16,0,0), iVar10 !\u003d -1)) {\n    __s \u003d (byte *)FUN_00105370(sVar17 + 1);\n    sVar18 \u003d fread(__s,1,sVar17,pFVar16);\n    if ((sVar17 \u003d\u003d sVar18) || (iVar10 \u003d ferror(pFVar16), iVar10 \u003d\u003d 0)) {\n      __s[sVar18] \u003d 0;\n      pbVar27 \u003d __s;\nLAB_001046fc:\n      if (*pbVar27 \u003d\u003d 0) {\n        local_138 \u003d (undefined8 *)FUN_00105370(8);\n        *local_138 \u003d 0;\n      }\n      else {\n        if (((\u0026DAT_00107040)[(ulong)*pbVar27 * 2] \u0026 0x40) !\u003d 0) goto code_r0x00104718;\n        local_d0 \u003d __s;\n        strlen((char *)__s);\n        pbVar27 \u003d (byte *)FUN_00105370();\n        local_138 \u003d (undefined8 *)0x0;\n        iVar10 \u003d 0;\n        bVar6 \u003d false;\n        bVar5 \u003d false;\n        bVar7 \u003d false;\n        lVar20 \u003d 0;\n        do {\n          FUN_00102fa0(\u0026local_d0);\n          pbVar22 \u003d pbVar27;\n          if ((iVar10 \u003d\u003d 0) || (iVar10 + -1 \u003c\u003d (int)lVar20)) {\n            if (local_138 \u003d\u003d (undefined8 *)0x0) {\n              iVar10 \u003d 8;\n              local_138 \u003d (undefined8 *)FUN_00105370(0x40);\n            }\n            else {\n              iVar10 \u003d iVar10 * 2;\n              local_138 \u003d (undefined8 *)FUN_00103449(local_138,(long)iVar10 \u003c\u003c 3);\n            }\n            local_138[lVar20] \u003d 0;\n          }\n          for (; bVar2 \u003d *local_d0, bVar2 !\u003d 0; local_d0 \u003d local_d0 + 1) {\n            if ((((\u0026DAT_00107040)[(ulong)bVar2 * 2] \u0026 0x40) !\u003d 0) \u0026\u0026\n               (bVar4 \u003d (bool)(bVar5 | bVar7 | bVar6), !bVar4)) {\n              bVar6 \u003d false;\n              bVar7 \u003d false;\n              bVar5 \u003d bVar4;\n              break;\n            }\n            if (bVar6) {\n              *pbVar22 \u003d bVar2;\n              bVar6 \u003d false;\n              pbVar22 \u003d pbVar22 + 1;\n            }\n            else if (bVar2 \u003d\u003d 0x5c) {\n              bVar6 \u003d true;\n            }\n            else if (bVar5) {\n              if (bVar2 \u003d\u003d 0x27) {\n                bVar5 \u003d false;\n              }\n              else {\nLAB_00104c08:\n                *pbVar22 \u003d bVar2;\n                pbVar22 \u003d pbVar22 + 1;\n              }\n            }\n            else if (bVar7) {\n              if (bVar2 !\u003d 0x22) goto LAB_00104c08;\n              bVar7 \u003d false;\n            }\n            else if (bVar2 \u003d\u003d 0x27) {\n              bVar5 \u003d true;\n            }\n            else {\n              if (bVar2 !\u003d 0x22) goto LAB_00104c08;\n              bVar7 \u003d true;\n            }\n          }\n          *pbVar22 \u003d 0;\n          uVar25 \u003d FUN_00103160();\n          local_138[lVar20] \u003d uVar25;\n          local_138[lVar20 + 1] \u003d 0;\n          FUN_00102fa0(\u0026local_d0);\n          lVar20 \u003d lVar20 + 1;\n        } while (*local_d0 !\u003d 0);\n        free(pbVar27);\n      }\n      if (plVar21 \u003d\u003d param_2) {\n        lVar20 \u003d 1;\n        do {\n          lVar23 \u003d lVar20;\n          lVar20 \u003d lVar23 + 1;\n        } while (plVar21[lVar23 + -1] !\u003d 0);\n        plVar24 \u003d (long *)FUN_00105370((long)(int)lVar23 \u003c\u003c 3);\n        plVar11 \u003d plVar24;\n        while (lVar20 \u003d *plVar21, plVar21 \u003d plVar21 + 1, lVar20 !\u003d 0) {\n          lVar20 \u003d FUN_00103160();\n          *plVar11 \u003d lVar20;\n          plVar11 \u003d plVar11 + 1;\n        }\n        *plVar11 \u003d 0;\n        lVar20 \u003d 0;\n      }\n      else {\n        lVar20 \u003d 0;\n        plVar24 \u003d plVar21;\n      }\n      for (; local_138[lVar20] !\u003d 0; lVar20 \u003d lVar20 + 1) {\n      }\n      free((void *)plVar24[lVar29]);\n      plVar21 \u003d (long *)FUN_00103449(plVar24,(lVar20 + 1 + (long)param_1) * 8);\n      memmove(plVar21 + lVar29 + lVar20,plVar21 + lVar29 + 1,(long)(param_1 - iVar8) \u003c\u003c 3);\n      param_1 \u003d param_1 + -1 + (int)lVar20;\n      memcpy(plVar21 + lVar29,local_138,lVar20 * 8);\n      free(local_138);\n      free(__s);\n      iVar8 \u003d iVar8 + -1;\n    }\n    else {\n      free(__s);\n    }\n  }\n  fclose(pFVar16);\n  goto LAB_00103c54;\ncode_r0x00104718:\n  pbVar27 \u003d pbVar27 + 1;\n  goto LAB_001046fc;\n}\n\n",
      "renaming": {},
      "calling": [
        "entry"
      ],
      "called": [
        "bindtextdomain",
        "fopen",
        "free",
        "setlocale",
        "FUN_00103449",
        "FUN_00104d30",
        "FUN_001032de",
        "exit",
        "mmap",
        "strtoul",
        "FUN_00104da0",
        "strcmp",
        "memcpy",
        "FUN_0010358d",
        "FUN_00102fbc",
        "strlen",
        "fclose",
        "memmove",
        "FUN_00103160",
        "getopt_long",
        "munmap",
        "__errno_location",
        "error",
        "fprintf",
        "FUN_00104de0",
        "fseek",
        "textdomain",
        "dcgettext",
        "FUN_00102fa0",
        "fileno",
        "ferror",
        "strerror",
        "fread",
        "FUN_00104c60",
        "FUN_00105370",
        "ftell",
        "fstat",
        "printf",
        "rewind",
        "FUN_00104ce0",
        "stat"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104c60": {
      "entrypoint": "0x00104c60",
      "current_name": "FUN_00104c60",
      "code": "\nundefined  [16] FUN_00104c60(char *param_1,int param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined8 uVar3;\n  undefined auVar4 [16];\n  \n  iVar1 \u003d strcasecmp(param_1,\"ibt\");\n  uVar2 \u003d 1;\n  if (iVar1 !\u003d 0) {\n    iVar1 \u003d strcasecmp(param_1,\"shstk\");\n    uVar2 \u003d 2;\n    if (iVar1 !\u003d 0) {\n      iVar1 \u003d strcasecmp(param_1,\"lam_u48\");\n      if (iVar1 \u003d\u003d 0) {\n        uVar2 \u003d 4;\n      }\n      else {\n        iVar1 \u003d strcasecmp(param_1,\"lam_u57\");\n        uVar2 \u003d 8;\n        if (iVar1 !\u003d 0) {\n          uVar3 \u003d dcgettext(0,\"Unknown x86 feature: %s\\n\",5);\n          error(uVar3,param_1);\n          uVar3 \u003d 0xffffffff;\n          goto LAB_00104ca5;\n        }\n      }\n    }\n  }\n  if (param_2 \u003d\u003d 0) {\n    DAT_00109440 \u003d uVar2 | DAT_00109440;\n    DAT_00109444 \u003d ~uVar2 \u0026 DAT_00109444;\n  }\n  else {\n    DAT_00109444 \u003d uVar2 | DAT_00109444;\n    DAT_00109440 \u003d DAT_00109440 \u0026 ~uVar2;\n  }\n  uVar3 \u003d 0;\nLAB_00104ca5:\n  auVar4._8_8_ \u003d param_4;\n  auVar4._0_8_ \u003d uVar3;\n  return auVar4;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "FUN_001022c0",
        "strcasecmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104ce0": {
      "entrypoint": "0x00104ce0",
      "current_name": "FUN_00104ce0",
      "code": "\nundefined  [16] FUN_00104ce0(char *param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  ulong uVar3;\n  uint uVar4;\n  undefined4 *puVar5;\n  undefined auVar6 [16];\n  \n  puVar5 \u003d \u0026DAT_00108ca0;\n  uVar3 \u003d 0;\n  do {\n    iVar1 \u003d strcasecmp(param_1,*(char **)(puVar5 + 2));\n    if (iVar1 \u003d\u003d 0) {\n      uVar3 \u003d (ulong)(uint)(\u0026DAT_00108ca0)[uVar3 * 4];\n      goto LAB_00104d20;\n    }\n    uVar4 \u003d (int)uVar3 + 1;\n    uVar3 \u003d (ulong)uVar4;\n    puVar5 \u003d puVar5 + 4;\n  } while (uVar4 !\u003d 0x10);\n  uVar2 \u003d dcgettext(0,\"Unknown OSABI: %s\\n\",5);\n  error(uVar2,param_1);\n  uVar3 \u003d 0xffffffff;\nLAB_00104d20:\n  auVar6._8_8_ \u003d param_4;\n  auVar6._0_8_ \u003d uVar3;\n  return auVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "FUN_00102323",
        "strcasecmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104d30": {
      "entrypoint": "0x00104d30",
      "current_name": "FUN_00104d30",
      "code": "\nint FUN_00104d30(char *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  iVar1 \u003d strcasecmp(param_1,\"i386\");\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d 3;\n  }\n  else {\n    iVar1 \u003d strcasecmp(param_1,\"iamcu\");\n    if (iVar1 \u003d\u003d 0) {\n      return 6;\n    }\n    iVar2 \u003d strcasecmp(param_1,\"l1om\");\n    iVar1 \u003d 0xb4;\n    if (iVar2 !\u003d 0) {\n      iVar1 \u003d strcasecmp(param_1,\"k1om\");\n      if (iVar1 \u003d\u003d 0) {\n        return 0xb5;\n      }\n      iVar1 \u003d strcasecmp(param_1,\"x86_64\");\n      if (iVar1 \u003d\u003d 0) {\n        iVar1 \u003d 0x3e;\n      }\n      else {\n        iVar1 \u003d strcasecmp(param_1,\"x86-64\");\n        if (iVar1 \u003d\u003d 0) {\n          iVar1 \u003d 0x3e;\n        }\n        else {\n          iVar1 \u003d strcasecmp(param_1,\"none\");\n          if (iVar1 !\u003d 0) {\n            uVar3 \u003d dcgettext(0,\"Unknown machine type: %s\\n\",5);\n            error(uVar3,param_1);\n            iVar1 \u003d -1;\n          }\n        }\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "FUN_0010234b",
        "strcasecmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104da0": {
      "entrypoint": "0x00104da0",
      "current_name": "FUN_00104da0",
      "code": "\nint FUN_00104da0(char *param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  iVar1 \u003d strcasecmp(param_1,\"rel\");\n  if (iVar1 \u003d\u003d 0) {\n    iVar1 \u003d 1;\n  }\n  else {\n    iVar2 \u003d strcasecmp(param_1,\"exec\");\n    iVar1 \u003d 2;\n    if (iVar2 !\u003d 0) {\n      iVar1 \u003d strcasecmp(param_1,\"dyn\");\n      if (iVar1 \u003d\u003d 0) {\n        iVar1 \u003d 3;\n      }\n      else {\n        iVar1 \u003d strcasecmp(param_1,\"none\");\n        if (iVar1 !\u003d 0) {\n          uVar3 \u003d dcgettext(0,\"Unknown type: %s\\n\",5);\n          error(uVar3,param_1);\n          iVar1 \u003d -1;\n        }\n      }\n    }\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bf0"
      ],
      "called": [
        "dcgettext",
        "error",
        "FUN_001023ce",
        "strcasecmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00104de0": {
      "entrypoint": "0x00104de0",
      "current_name": "FUN_00104de0",
      "code": "\n\n\nundefined8 FUN_00104de0(undefined8 param_1,FILE *param_2)\n\n{\n  int iVar1;\n  long __off;\n  size_t sVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  uint uVar5;\n  uint uVar6;\n  \n  __off \u003d ftell(param_2);\n  sVar2 \u003d fread(\u0026DAT_001093e0,0x10,1,param_2);\n  if ((sVar2 \u003d\u003d 1) \u0026\u0026 (_DAT_001093e0 \u003d\u003d 0x464c457f)) {\n    DAT_001093b8 \u003d FUN_0010354e;\n    if (DAT_001093e5 !\u003d \u0027\\x02\u0027) {\n      DAT_001093b8 \u003d FUN_00103ad0;\n    }\n    DAT_001093c0 \u003d FUN_0010347f;\n    if (DAT_001093e5 !\u003d \u0027\\x02\u0027) {\n      DAT_001093c0 \u003d FUN_00103a90;\n    }\n    if ((char)_DAT_001093e4 \u003d\u003d \u0027\\x01\u0027) {\n      sVar2 \u003d fread(\u0026DAT_00109390,0x24,1,param_2);\n      if (sVar2 !\u003d 1) goto code_r0x00102558;\n      DAT_00109418 \u003d (*DAT_001093c0)(\u0026DAT_00109390,2);\n      DAT_0010941a \u003d (*DAT_001093c0)(\u0026DAT_00109392,2);\n      _DAT_00109408 \u003d (*DAT_001093c0)(\u0026DAT_00109394,4);\n      _DAT_001093f0 \u003d (*DAT_001093c0)(\u0026DAT_00109398,4);\n      DAT_001093f8 \u003d (*DAT_001093c0)(\u0026DAT_0010939c,4);\n      _DAT_00109400 \u003d (*DAT_001093c0)(\u0026DAT_001093a0,4);\n      _DAT_00109410 \u003d (*DAT_001093c0)(\u0026DAT_001093a4,4);\n      _DAT_0010941c \u003d (*DAT_001093c0)(\u0026DAT_001093a8,2);\n      _DAT_00109420 \u003d (*DAT_001093c0)(\u0026DAT_001093aa,2);\n      DAT_00109424 \u003d (*DAT_001093c0)(\u0026DAT_001093ac,2);\n      _DAT_00109428 \u003d (*DAT_001093c0)(\u0026DAT_001093ae,2);\n      _DAT_0010942c \u003d (*DAT_001093c0)(\u0026DAT_001093b0,2);\n      _DAT_00109430 \u003d (*DAT_001093c0)(\u0026DAT_001093b2,2);\n      _DAT_00109380 \u003d _DAT_001093e0;\n      uRam0000000000109384 \u003d _DAT_001093e4;\n      _DAT_00109388 \u003d _DAT_001093e8;\n      uRam000000000010938c \u003d uRam00000000001093ec;\n    }\n    else {\n      if ((char)_DAT_001093e4 !\u003d \u0027\\x02\u0027) {\n        uVar3 \u003d FUN_00102558();\n        return uVar3;\n      }\n      sVar2 \u003d fread(\u0026DAT_00109350,0x30,1,param_2);\n      if (sVar2 !\u003d 1) goto code_r0x00102558;\n      DAT_00109418 \u003d (*DAT_001093c0)(\u0026DAT_00109350,2);\n      DAT_0010941a \u003d (*DAT_001093c0)(\u0026DAT_00109352,2);\n      _DAT_00109408 \u003d (*DAT_001093c0)(\u0026DAT_00109354,4);\n      _DAT_001093f0 \u003d (*DAT_001093c0)(\u0026DAT_00109358,8);\n      DAT_001093f8 \u003d (*DAT_001093c0)(\u0026DAT_00109360,8);\n      _DAT_00109400 \u003d (*DAT_001093c0)(\u0026DAT_00109368,8);\n      _DAT_00109410 \u003d (*DAT_001093c0)(\u0026DAT_00109370,4);\n      _DAT_0010941c \u003d (*DAT_001093c0)(\u0026DAT_00109374,2);\n      _DAT_00109420 \u003d (*DAT_001093c0)(\u0026DAT_00109376,2);\n      DAT_00109424 \u003d (*DAT_001093c0)(\u0026DAT_00109378,2);\n      _DAT_00109428 \u003d (*DAT_001093c0)(\u0026DAT_0010937a,2);\n      _DAT_0010942c \u003d (*DAT_001093c0)(\u0026DAT_0010937c,2);\n      _DAT_00109430 \u003d (*DAT_001093c0)(\u0026DAT_0010937e,2);\n      _DAT_00109340 \u003d _DAT_001093e0;\n      uRam0000000000109344 \u003d _DAT_001093e4;\n      _DAT_00109348 \u003d _DAT_001093e8;\n      uRam000000000010934c \u003d uRam00000000001093ec;\n    }\n    iVar1 \u003d fseek(param_2,__off,0);\n    if (iVar1 !\u003d 0) {\n      uVar3 \u003d dcgettext(0,\"%s: Failed to seek to ELF header\\n\",5);\n      error(uVar3,param_1);\n    }\n    uVar5 \u003d _DAT_001093e4 \u003e\u003e 0x10 \u0026 0xff;\n    if ((char)uVar5 \u003d\u003d \u0027\\x01\u0027) {\n      uVar5 \u003d (uint)DAT_0010941a;\n      if (uVar5 \u003d\u003d DAT_0010916c) {\n        return 0;\n      }\n      uVar6 \u003d _DAT_001093e4 \u0026 0xff;\n      if (DAT_00109170 \u003d\u003d 0xffffffff) {\n        if (DAT_0010941a \u003d\u003d 6) {\n          DAT_00109170 \u003d 1;\n        }\n        else if (DAT_0010941a \u003c 7) {\n          DAT_00109170 \u003d (DAT_0010941a !\u003d 3) + 1 + (uint)(DAT_0010941a !\u003d 3);\n        }\n        else {\n          DAT_00109170 \u003d 3 - ((ushort)(DAT_0010941a - 0xb4) \u003c 2);\n        }\n      }\n      if ((uVar6 \u003d\u003d DAT_00109170) || (DAT_00109170 \u003d\u003d 3)) {\n        if ((uVar6 \u003d\u003d DAT_00109168) || (DAT_00109168 \u003d\u003d 3)) {\n          if ((uVar5 \u003d\u003d DAT_00109174) || (DAT_00109174 \u003d\u003d 0xffffffff)) {\n            uVar5 \u003d (uint)DAT_00109418;\n            if ((DAT_00109164 \u003d\u003d 0xffffffff) || (uVar5 \u003d\u003d DAT_00109164)) {\n              uVar5 \u003d _DAT_001093e4 \u003e\u003e 0x18;\n              if ((DAT_0010915c \u003d\u003d 0xffffffff) || (uVar5 \u003d\u003d DAT_0010915c)) {\n                uVar5 \u003d _DAT_001093e8 \u0026 0xff;\n                if ((uVar5 \u003d\u003d DAT_00109154) || (DAT_00109154 \u003d\u003d 0xffffffff)) {\n                  if ((char)uVar6 \u003d\u003d \u0027\\x01\u0027) {\n                    if (DAT_0010916c !\u003d 0xffffffff) {\n                      (*DAT_001093b8)(\u0026DAT_00109392,(long)(int)DAT_0010916c,2);\n                    }\n                    if (DAT_00109160 !\u003d -1) {\n                      (*DAT_001093b8)(\u0026DAT_00109390,(long)DAT_00109160,2);\n                    }\n                    if (DAT_00109158 !\u003d -1) {\n                      uRam0000000000109384 \u003d\n                           CONCAT13((char)DAT_00109158,(undefined3)uRam0000000000109384);\n                    }\n                    if (DAT_00109150 !\u003d -1) {\n                      _DAT_00109388 \u003d CONCAT31(DAT_00109388_1,(char)DAT_00109150);\n                    }\n                    sVar2 \u003d fwrite(\u0026DAT_00109380,0x34,1,param_2);\n                    if (sVar2 \u003d\u003d 1) {\n                      return 0;\n                    }\n                    uVar3 \u003d FUN_001024ec();\n                    return uVar3;\n                  }\n                  if ((char)uVar6 !\u003d \u0027\\x02\u0027) {\n                    \n                    abort();\n                  }\n                  if (DAT_0010916c !\u003d 0xffffffff) {\n                    (*DAT_001093b8)(\u0026DAT_00109352,(long)(int)DAT_0010916c,2);\n                  }\n                  if (DAT_00109160 !\u003d -1) {\n                    (*DAT_001093b8)(\u0026DAT_00109350,(long)DAT_00109160,2);\n                  }\n                  if (DAT_00109158 !\u003d -1) {\n                    uRam0000000000109344 \u003d\n                         CONCAT13((char)DAT_00109158,(undefined3)uRam0000000000109344);\n                  }\n                  if (DAT_00109150 !\u003d -1) {\n                    _DAT_00109348 \u003d CONCAT31(DAT_00109348_1,(char)DAT_00109150);\n                  }\n                  sVar2 \u003d fwrite(\u0026DAT_00109340,0x40,1,param_2);\n                  if (sVar2 \u003d\u003d 1) {\n                    return 0;\n                  }\n                  uVar3 \u003d FUN_001024ec();\n                  return uVar3;\n                }\n                pcVar4 \u003d \"%s: Unmatched EI_ABIVERSION: %d is not %d\\n\";\n                uVar6 \u003d DAT_00109154;\n              }\n              else {\n                pcVar4 \u003d \"%s: Unmatched EI_OSABI: %d is not %d\\n\";\n                uVar6 \u003d DAT_0010915c;\n              }\n            }\n            else {\n              pcVar4 \u003d \"%s: Unmatched e_type: %d is not %d\\n\";\n              uVar6 \u003d DAT_00109164;\n            }\n          }\n          else {\n            pcVar4 \u003d \"%s: Unmatched e_machine: %d is not %d\\n\";\n            uVar6 \u003d DAT_00109174;\n          }\n          uVar3 \u003d dcgettext(0,pcVar4,5);\n          error(uVar3,param_1,uVar5,uVar6);\n          return 1;\n        }\n        pcVar4 \u003d \"%s: Unmatched output EI_CLASS: %d is not %d\\n\";\n        uVar5 \u003d DAT_00109168;\n      }\n      else {\n        pcVar4 \u003d \"%s: Unmatched input EI_CLASS: %d is not %d\\n\";\n        uVar5 \u003d DAT_00109170;\n      }\n      uVar3 \u003d dcgettext(0,pcVar4,5);\n      error(uVar3,param_1,uVar6,uVar5);\n    }\n    else {\n      uVar3 \u003d dcgettext(0,\"%s: Unsupported EI_VERSION: %d is not %d\\n\",5);\n      error(uVar3,param_1,uVar5,1);\n    }\n  }\n  else {\ncode_r0x00102558:\n    uVar3 \u003d dcgettext(0,\"%s: Failed to read ELF header\\n\",5);\n    error(uVar3,param_1);\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010358d",
        "FUN_00103bf0"
      ],
      "called": [
        "error",
        "FUN_00102434",
        "FUN_00103a90",
        "fseek",
        "fwrite",
        "dcgettext",
        "fread",
        "FUN_0010354e",
        "FUN_001024ec",
        "ftell",
        "FUN_00102558",
        "abort",
        "FUN_00103ad0",
        "FUN_0010347f"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105370": {
      "entrypoint": "0x00105370",
      "current_name": "FUN_00105370",
      "code": "\nchar * FUN_00105370(char *param_1,char *param_2)\n\n{\n  ulong __size;\n  long lVar1;\n  char cVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  char *pcVar5;\n  char *pcVar6;\n  ulong uVar7;\n  ulong extraout_RDX;\n  ulong uVar8;\n  byte bVar9;\n  \n  bVar9 \u003d 0;\n  pcVar5 \u003d (char *)0x1;\n  if (param_1 !\u003d (char *)0x0) {\n    pcVar5 \u003d param_1;\n  }\n  pcVar6 \u003d (char *)malloc((size_t)pcVar5);\n  if (pcVar6 !\u003d (char *)0x0) {\n    return pcVar6;\n  }\n  FUN_00102fc7();\n  pcVar6 \u003d pcVar5;\n  pcVar4 \u003d pcVar5;\n  while (cVar2 \u003d *pcVar6, cVar2 !\u003d \u0027\\0\u0027) {\n    pcVar6 \u003d pcVar6 + 1;\n    if (cVar2 \u003d\u003d \u0027/\u0027) {\n      pcVar4 \u003d pcVar6;\n    }\n  }\n  if ((*param_2 \u003d\u003d \u0027/\u0027) || (pcVar5 \u003d\u003d pcVar4)) {\n    if (extraout_RDX + 1 \u003d\u003d 0) {\n      return (char *)0x0;\n    }\n    pcVar6 \u003d (char *)malloc(extraout_RDX + 1);\n    uVar7 \u003d extraout_RDX;\n    pcVar5 \u003d pcVar6;\n    if (pcVar6 !\u003d (char *)0x0) {\n      for (; uVar7 !\u003d 0; uVar7 \u003d uVar7 - 1) {\n        *pcVar5 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar9 * -2 + 1;\n        pcVar5 \u003d pcVar5 + (ulong)bVar9 * -2 + 1;\n      }\n      pcVar6[extraout_RDX] \u003d \u0027\\0\u0027;\n      return pcVar6;\n    }\n  }\n  else {\n    uVar8 \u003d (long)pcVar4 - (long)pcVar5;\n    lVar1 \u003d uVar8 + extraout_RDX;\n    uVar7 \u003d extraout_RDX;\n    if (extraout_RDX \u003c\u003d uVar8) {\n      uVar7 \u003d uVar8;\n    }\n    __size \u003d lVar1 + 1;\n    if (__size \u003c uVar7) {\n      uVar3 \u003d dcgettext(0,\"Abnormal length of thin archive member name: %lx\\n\",5);\n      error(uVar3,extraout_RDX);\n      return (char *)0x0;\n    }\n    pcVar4 \u003d (char *)malloc(__size);\n    pcVar6 \u003d pcVar4;\n    if (pcVar4 !\u003d (char *)0x0) {\n      for (; uVar7 \u003d extraout_RDX, uVar8 !\u003d 0; uVar8 \u003d uVar8 - 1) {\n        *pcVar6 \u003d *pcVar5;\n        pcVar5 \u003d pcVar5 + (ulong)bVar9 * -2 + 1;\n        pcVar6 \u003d pcVar6 + (ulong)bVar9 * -2 + 1;\n      }\n      for (; uVar7 !\u003d 0; uVar7 \u003d uVar7 - 1) {\n        *pcVar6 \u003d *param_2;\n        param_2 \u003d param_2 + (ulong)bVar9 * -2 + 1;\n        pcVar6 \u003d pcVar6 + (ulong)bVar9 * -2 + 1;\n      }\n      pcVar4[lVar1] \u003d \u0027\\0\u0027;\n      return pcVar4;\n    }\n  }\n  uVar3 \u003d dcgettext(0,\"Out of memory\\n\",5);\n  error(uVar3);\n  return (char *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103186",
        "FUN_001029a5",
        "FUN_00103bf0",
        "FUN_00103006",
        "FUN_00103160"
      ],
      "called": [
        "malloc",
        "FUN_00102cbc"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_DT_FINI": {
      "entrypoint": "0x00105394",
      "current_name": "_DT_FINI",
      "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}