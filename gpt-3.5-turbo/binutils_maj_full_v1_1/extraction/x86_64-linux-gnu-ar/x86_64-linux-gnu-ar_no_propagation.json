{
  "functions": {
    "_DT_INIT": {
      "entrypoint": "0x00102000",
      "current_name": "_DT_INIT",
      "code": "\nvoid _DT_INIT(void)\n\n{\n  __gmon_start__();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__gmon_start__"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102020": {
      "entrypoint": "0x00102020",
      "current_name": "FUN_00102020",
      "code": "\nvoid FUN_00102020(void)\n\n{\n                    /* WARNING: Treating indirect jump as call */\n  (*(code *)(undefined *)0x0)();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x00102030",
      "current_name": "free",
      "code": "\n\n\nvoid free(void *__ptr)\n\n{\n  free(__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bd1",
        "FUN_00102ba1",
        "FUN_00103e95",
        "FUN_0010266f",
        "FUN_00105db0",
        "FUN_00102d2f",
        "FUN_00103a78",
        "FUN_00102c25"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "utimensat": {
      "entrypoint": "0x00102040",
      "current_name": "utimensat",
      "code": "\n\n\nint utimensat(int __fd,char *__path,timespec *__times,int __flags)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d utimensat(__fd,__path,__times,__flags);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107c80"
      ],
      "called": [
        "utimensat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_cache_close": {
      "entrypoint": "0x00102050",
      "current_name": "bfd_cache_close",
      "code": "\nvoid bfd_cache_close(void)\n\n{\n  bfd_cache_close();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102bf5",
        "FUN_00103e95"
      ],
      "called": [
        "bfd_cache_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__errno_location": {
      "entrypoint": "0x00102060",
      "current_name": "__errno_location",
      "code": "\n\n\nint * __errno_location(void)\n\n{\n  int *piVar1;\n  \n  piVar1 \u003d __errno_location();\n  return piVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_001031cf",
        "FUN_00105c00",
        "FUN_00103e95",
        "FUN_00102f55",
        "FUN_00103c60",
        "FUN_00102fd7",
        "FUN_00105300",
        "FUN_001025a0",
        "FUN_00102f1e",
        "FUN_00103a78",
        "FUN_00102c25"
      ],
      "called": [
        "__errno_location"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "unlink": {
      "entrypoint": "0x00102070",
      "current_name": "unlink",
      "code": "\n\n\nint unlink(char *__name)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d unlink(__name);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00102f1e"
      ],
      "called": [
        "unlink"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_make_writable": {
      "entrypoint": "0x00102080",
      "current_name": "bfd_make_writable",
      "code": "\nvoid bfd_make_writable(void)\n\n{\n  bfd_make_writable();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_make_writable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_plugin_set_plugin": {
      "entrypoint": "0x00102090",
      "current_name": "bfd_plugin_set_plugin",
      "code": "\nvoid bfd_plugin_set_plugin(void)\n\n{\n  bfd_plugin_set_plugin();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_plugin_set_plugin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_make_readable": {
      "entrypoint": "0x001020a0",
      "current_name": "bfd_make_readable",
      "code": "\nvoid bfd_make_readable(void)\n\n{\n  bfd_make_readable();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_make_readable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ferror": {
      "entrypoint": "0x001020b0",
      "current_name": "ferror",
      "code": "\n\n\nint ferror(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d ferror(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00105db0"
      ],
      "called": [
        "ferror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "isatty": {
      "entrypoint": "0x001020c0",
      "current_name": "isatty",
      "code": "\n\n\nint isatty(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d isatty(__fd);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001031cf",
        "FUN_00105db0"
      ],
      "called": [
        "isatty"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_default_target": {
      "entrypoint": "0x001020d0",
      "current_name": "bfd_set_default_target",
      "code": "\nvoid bfd_set_default_target(void)\n\n{\n  bfd_set_default_target();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_set_default_target"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fread": {
      "entrypoint": "0x001020e0",
      "current_name": "fread",
      "code": "\n\n\nsize_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fread(__ptr,__size,__n,__stream);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00105db0"
      ],
      "called": [
        "fread"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_archive_head": {
      "entrypoint": "0x001020f0",
      "current_name": "bfd_set_archive_head",
      "code": "\nvoid bfd_set_archive_head(void)\n\n{\n  bfd_set_archive_head();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102d2f"
      ],
      "called": [
        "bfd_set_archive_head"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "filename_cmp": {
      "entrypoint": "0x00102100",
      "current_name": "filename_cmp",
      "code": "\nvoid filename_cmp(void)\n\n{\n  filename_cmp();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_001032a8",
        "FUN_00102cd9",
        "FUN_00103e95",
        "FUN_00105480",
        "FUN_00105db0"
      ],
      "called": [
        "filename_cmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write": {
      "entrypoint": "0x00102110",
      "current_name": "write",
      "code": "\n\n\nssize_t write(int __fd,void *__buf,size_t __n)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 \u003d write(__fd,__buf,__n);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105c00"
      ],
      "called": [
        "write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "textdomain": {
      "entrypoint": "0x00102120",
      "current_name": "textdomain",
      "code": "\nvoid textdomain(void)\n\n{\n  textdomain();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "textdomain"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openr": {
      "entrypoint": "0x00102130",
      "current_name": "bfd_openr",
      "code": "\nvoid bfd_openr(void)\n\n{\n  bfd_openr();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00102710",
        "FUN_00103e95",
        "FUN_00103c60",
        "FUN_00105300"
      ],
      "called": [
        "bfd_openr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x00102140",
      "current_name": "fclose",
      "code": "\n\n\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fclose(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102bf5",
        "FUN_00103e95",
        "FUN_00105db0",
        "FUN_00102c25"
      ],
      "called": [
        "fclose"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ctime": {
      "entrypoint": "0x00102150",
      "current_name": "ctime",
      "code": "\n\n\nchar * ctime(time_t *__timer)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d ctime(__timer);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001079c0"
      ],
      "called": [
        "ctime"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bindtextdomain": {
      "entrypoint": "0x00102160",
      "current_name": "bindtextdomain",
      "code": "\nvoid bindtextdomain(void)\n\n{\n  bindtextdomain();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bindtextdomain"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dcgettext": {
      "entrypoint": "0x00102170",
      "current_name": "dcgettext",
      "code": "\nvoid dcgettext(void)\n\n{\n  dcgettext();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010342d",
        "FUN_001031a5",
        "FUN_00103c60",
        "FUN_0010266f",
        "FUN_00102d8c",
        "FUN_001052a0",
        "FUN_00102fd7",
        "FUN_0010394a",
        "FUN_00105db0",
        "FUN_001025a0",
        "FUN_00102f96",
        "FUN_001058b0",
        "FUN_00102c25",
        "FUN_00103bd1",
        "FUN_0010285f",
        "FUN_001028ed",
        "FUN_001032a8",
        "FUN_00102e6f",
        "FUN_0010336b",
        "FUN_00103e95",
        "FUN_001075e0",
        "FUN_00105300",
        "FUN_00102f1e",
        "FUN_00103a78"
      ],
      "called": [
        "dcgettext"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x00102180",
      "current_name": "strlen",
      "code": "\n\n\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d strlen(__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00105a68",
        "FUN_00105db0",
        "FUN_00102bb0"
      ],
      "called": [
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getopt_long": {
      "entrypoint": "0x00102190",
      "current_name": "getopt_long",
      "code": "\nvoid getopt_long(void)\n\n{\n  getopt_long();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "getopt_long"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printf": {
      "entrypoint": "0x001021a0",
      "current_name": "printf",
      "code": "\n\n\nint printf(char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d printf(__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_001075e0",
        "FUN_001031a5",
        "FUN_00102f08",
        "FUN_00105a68",
        "FUN_00105db0",
        "FUN_00103172",
        "FUN_00103a78",
        "FUN_00103ba8"
      ],
      "called": [
        "printf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xrealloc": {
      "entrypoint": "0x001021b0",
      "current_name": "xrealloc",
      "code": "\nvoid xrealloc(void)\n\n{\n  xrealloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "xrealloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strrchr": {
      "entrypoint": "0x001021c0",
      "current_name": "strrchr",
      "code": "\n\n\nchar * strrchr(char *__s,int __c)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strrchr(__s,__c);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001057a0"
      ],
      "called": [
        "strrchr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "dup": {
      "entrypoint": "0x001021d0",
      "current_name": "dup",
      "code": "\n\n\nint dup(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d dup(__fd);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00102d2f"
      ],
      "called": [
        "dup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "lseek": {
      "entrypoint": "0x001021e0",
      "current_name": "lseek",
      "code": "\n\n\n__off_t lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  __off_t _Var1;\n  \n  _Var1 \u003d lseek(__fd,__offset,__whence);\n  return _Var1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105c00"
      ],
      "called": [
        "lseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fputs": {
      "entrypoint": "0x001021f0",
      "current_name": "fputs",
      "code": "\n\n\nint fputs(char *__s,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fputs(__s,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102d8c"
      ],
      "called": [
        "fputs"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "concat": {
      "entrypoint": "0x00102200",
      "current_name": "concat",
      "code": "\nvoid concat(void)\n\n{\n  concat();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102e57",
        "FUN_00105a68"
      ],
      "called": [
        "concat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_target_list": {
      "entrypoint": "0x00102210",
      "current_name": "bfd_target_list",
      "code": "\nvoid bfd_target_list(void)\n\n{\n  bfd_target_list();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010266f"
      ],
      "called": [
        "bfd_target_list"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_get_error": {
      "entrypoint": "0x00102220",
      "current_name": "bfd_get_error",
      "code": "\nvoid bfd_get_error(void)\n\n{\n  bfd_get_error();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105300",
        "FUN_00105db0",
        "FUN_00107c20"
      ],
      "called": [
        "bfd_get_error"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc": {
      "entrypoint": "0x00102230",
      "current_name": "xmalloc",
      "code": "\nvoid xmalloc(void)\n\n{\n  xmalloc();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001057a0",
        "FUN_001028ed",
        "FUN_00105db0",
        "FUN_00103a78",
        "FUN_00102bb0",
        "FUN_00102c25"
      ],
      "called": [
        "xmalloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_error": {
      "entrypoint": "0x00102240",
      "current_name": "bfd_set_error",
      "code": "\nvoid bfd_set_error(void)\n\n{\n  bfd_set_error();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105300",
        "FUN_00105db0"
      ],
      "called": [
        "bfd_set_error"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xmalloc_set_program_name": {
      "entrypoint": "0x00102250",
      "current_name": "xmalloc_set_program_name",
      "code": "\nvoid xmalloc_set_program_name(void)\n\n{\n  xmalloc_set_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "xmalloc_set_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "close": {
      "entrypoint": "0x00102260",
      "current_name": "close",
      "code": "\n\n\nint close(int __fd)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d close(__fd);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105c00",
        "FUN_00102f55",
        "FUN_001058b0"
      ],
      "called": [
        "close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xstrdup": {
      "entrypoint": "0x00102270",
      "current_name": "xstrdup",
      "code": "\nvoid xstrdup(void)\n\n{\n  xstrdup();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00103c60",
        "FUN_00105db0",
        "FUN_001058b0"
      ],
      "called": [
        "xstrdup"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fputc": {
      "entrypoint": "0x00102280",
      "current_name": "fputc",
      "code": "\n\n\nint fputc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fputc(__c,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bd1",
        "FUN_0010266f",
        "FUN_00102d8c"
      ],
      "called": [
        "fputc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read": {
      "entrypoint": "0x00102290",
      "current_name": "read",
      "code": "\n\n\nssize_t read(int __fd,void *__buf,size_t __nbytes)\n\n{\n  ssize_t sVar1;\n  \n  sVar1 \u003d read(__fd,__buf,__nbytes);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105c00"
      ],
      "called": [
        "read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_create": {
      "entrypoint": "0x001022a0",
      "current_name": "bfd_create",
      "code": "\nvoid bfd_create(void)\n\n{\n  bfd_create();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_create"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_init": {
      "entrypoint": "0x001022b0",
      "current_name": "bfd_init",
      "code": "\nvoid bfd_init(void)\n\n{\n  bfd_init();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "lbasename": {
      "entrypoint": "0x001022c0",
      "current_name": "lbasename",
      "code": "\nvoid lbasename(void)\n\n{\n  lbasename();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00102e6f",
        "FUN_00105830",
        "FUN_00105db0"
      ],
      "called": [
        "lbasename"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "calloc": {
      "entrypoint": "0x001022d0",
      "current_name": "calloc",
      "code": "\n\n\nvoid * calloc(size_t __nmemb,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d calloc(__nmemb,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103df9"
      ],
      "called": [
        "calloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcmp": {
      "entrypoint": "0x001022e0",
      "current_name": "strcmp",
      "code": "\n\n\nint strcmp(char *__s1,char *__s2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d strcmp(__s1,__s2);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "putc": {
      "entrypoint": "0x001022f0",
      "current_name": "putc",
      "code": "\n\n\nint putc(int __c,FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d putc(__c,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001078c0"
      ],
      "called": [
        "putc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_fdopenr": {
      "entrypoint": "0x00102300",
      "current_name": "bfd_fdopenr",
      "code": "\nvoid bfd_fdopenr(void)\n\n{\n  bfd_fdopenr();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_fdopenr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fprintf": {
      "entrypoint": "0x00102310",
      "current_name": "fprintf",
      "code": "\n\n\nint fprintf(FILE *__stream,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fprintf(__stream,__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001078c0",
        "FUN_0010342d",
        "FUN_00103c60",
        "FUN_0010266f",
        "FUN_00102d8c",
        "FUN_0010394a",
        "FUN_00105db0",
        "FUN_00102f96",
        "FUN_00103bd1",
        "FUN_0010285f",
        "FUN_001032a8",
        "FUN_0010336b",
        "FUN_00103e95",
        "FUN_00105300",
        "FUN_001033b0"
      ],
      "called": [
        "fprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "ftell": {
      "entrypoint": "0x00102320",
      "current_name": "ftell",
      "code": "\n\n\nlong ftell(FILE *__stream)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d ftell(__stream);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "ftell"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "stat": {
      "entrypoint": "0x00102330",
      "current_name": "stat",
      "code": "\n\n\nint stat(char *__file,stat *__buf)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d stat(__file,__buf);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00103e95",
        "FUN_001052a0",
        "FUN_00105300",
        "FUN_00105db0"
      ],
      "called": [
        "stat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_format": {
      "entrypoint": "0x00102340",
      "current_name": "bfd_set_format",
      "code": "\nvoid bfd_set_format(void)\n\n{\n  bfd_set_format();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00103c60",
        "FUN_00105300",
        "FUN_00105db0",
        "FUN_001058b0"
      ],
      "called": [
        "bfd_set_format"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtol": {
      "entrypoint": "0x00102350",
      "current_name": "strtol",
      "code": "\n\n\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d strtol(__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "strtol"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "clearerr": {
      "entrypoint": "0x00102360",
      "current_name": "clearerr",
      "code": "\n\n\nvoid clearerr(FILE *__stream)\n\n{\n  clearerr(__stream);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "clearerr"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_bwrite": {
      "entrypoint": "0x00102370",
      "current_name": "bfd_bwrite",
      "code": "\nvoid bfd_bwrite(void)\n\n{\n  bfd_bwrite();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_bwrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x00102380",
      "current_name": "memcpy",
      "code": "\n\n\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memcpy(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "memcpy"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fileno": {
      "entrypoint": "0x00102390",
      "current_name": "fileno",
      "code": "\n\n\nint fileno(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fileno(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001031cf",
        "FUN_00105db0"
      ],
      "called": [
        "fileno"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_plugin_set_program_name": {
      "entrypoint": "0x001023a0",
      "current_name": "bfd_plugin_set_program_name",
      "code": "\nvoid bfd_plugin_set_program_name(void)\n\n{\n  bfd_plugin_set_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_plugin_set_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "malloc": {
      "entrypoint": "0x001023b0",
      "current_name": "malloc",
      "code": "\n\n\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d malloc(__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_001033d6",
        "FUN_00105db0"
      ],
      "called": [
        "malloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fflush": {
      "entrypoint": "0x001023c0",
      "current_name": "fflush",
      "code": "\n\n\nint fflush(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fflush(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103bd1",
        "FUN_001078c0",
        "FUN_00102f96",
        "FUN_00103ba8"
      ],
      "called": [
        "fflush"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "unlink_if_ordinary": {
      "entrypoint": "0x001023d0",
      "current_name": "unlink_if_ordinary",
      "code": "\nvoid unlink_if_ordinary(void)\n\n{\n  unlink_if_ordinary();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102bf5"
      ],
      "called": [
        "unlink_if_ordinary"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "mkstemp": {
      "entrypoint": "0x001023e0",
      "current_name": "mkstemp",
      "code": "\n\n\nint mkstemp(char *__template)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d mkstemp(__template);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001057a0"
      ],
      "called": [
        "mkstemp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fseek": {
      "entrypoint": "0x001023f0",
      "current_name": "fseek",
      "code": "\n\n\nint fseek(FILE *__stream,long __off,int __whence)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d fseek(__stream,__off,__whence);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "fseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "realloc": {
      "entrypoint": "0x00102400",
      "current_name": "realloc",
      "code": "\n\n\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d realloc(__ptr,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00103df9"
      ],
      "called": [
        "realloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setlocale": {
      "entrypoint": "0x00102410",
      "current_name": "setlocale",
      "code": "\n\n\nchar * setlocale(int __category,char *__locale)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d setlocale(__category,__locale);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "setlocale"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openw": {
      "entrypoint": "0x00102420",
      "current_name": "bfd_openw",
      "code": "\nvoid bfd_openw(void)\n\n{\n  bfd_openw();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00105300"
      ],
      "called": [
        "bfd_openw"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "chmod": {
      "entrypoint": "0x00102430",
      "current_name": "chmod",
      "code": "\n\n\nint chmod(char *__file,__mode_t __mode)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d chmod(__file,__mode);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102c25"
      ],
      "called": [
        "chmod"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_set_error_program_name": {
      "entrypoint": "0x00102440",
      "current_name": "bfd_set_error_program_name",
      "code": "\nvoid bfd_set_error_program_name(void)\n\n{\n  bfd_set_error_program_name();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_set_error_program_name"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x00102450",
      "current_name": "memmove",
      "code": "\n\n\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d memmove(__dest,__src,__n);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "memmove"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "open": {
      "entrypoint": "0x00102460",
      "current_name": "open",
      "code": "\n\n\nint open(char *__file,int __oflag,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d open(__file,__oflag);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105c00",
        "FUN_00105db0"
      ],
      "called": [
        "open"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fopen": {
      "entrypoint": "0x00102470",
      "current_name": "fopen",
      "code": "\n\n\nFILE * fopen(char *__filename,char *__modes)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 \u003d fopen(__filename,__modes);\n  return pFVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00105a68",
        "FUN_00105db0"
      ],
      "called": [
        "fopen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "xexit": {
      "entrypoint": "0x00102480",
      "current_name": "xexit",
      "code": "\nvoid xexit(void)\n\n{\n                    \n  xexit();\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107690",
        "FUN_0010342d",
        "FUN_00107650",
        "FUN_00107c10",
        "FUN_00105a68",
        "FUN_00105300",
        "FUN_0010394a",
        "FUN_00105db0",
        "FUN_0010315d",
        "FUN_00102d2f"
      ],
      "called": [
        "xexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_close": {
      "entrypoint": "0x00102490",
      "current_name": "bfd_close",
      "code": "\nvoid bfd_close(void)\n\n{\n  bfd_close();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102710",
        "FUN_00103e95",
        "FUN_00105300",
        "FUN_00105db0",
        "FUN_00102d2f"
      ],
      "called": [
        "bfd_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "perror": {
      "entrypoint": "0x001024a0",
      "current_name": "perror",
      "code": "\n\n\nvoid perror(char *__s)\n\n{\n  perror(__s);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105a68",
        "FUN_00105300"
      ],
      "called": [
        "perror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "vfprintf": {
      "entrypoint": "0x001024b0",
      "current_name": "vfprintf",
      "code": "\n\n\nint vfprintf(FILE *__s,char *__format,__gnuc_va_list __arg)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d vfprintf(__s,__format,__arg);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001078c0"
      ],
      "called": [
        "vfprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_check_format_matches": {
      "entrypoint": "0x001024c0",
      "current_name": "bfd_check_format_matches",
      "code": "\nvoid bfd_check_format_matches(void)\n\n{\n  bfd_check_format_matches();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105300",
        "FUN_00105db0"
      ],
      "called": [
        "bfd_check_format_matches"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_errmsg": {
      "entrypoint": "0x001024d0",
      "current_name": "bfd_errmsg",
      "code": "\nvoid bfd_errmsg(void)\n\n{\n  bfd_errmsg();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0",
        "FUN_00107c20"
      ],
      "called": [
        "bfd_errmsg"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_find_target": {
      "entrypoint": "0x001024e0",
      "current_name": "bfd_find_target",
      "code": "\nvoid bfd_find_target(void)\n\n{\n  bfd_find_target();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "bfd_find_target"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "sprintf": {
      "entrypoint": "0x001024f0",
      "current_name": "sprintf",
      "code": "\n\n\nint sprintf(char *__s,char *__format,...)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d sprintf(__s,__format);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001079c0",
        "FUN_00102d8c"
      ],
      "called": [
        "sprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "exit": {
      "entrypoint": "0x00102500",
      "current_name": "exit",
      "code": "\n\n\nvoid exit(int __status)\n\n{\n                    \n  exit(__status);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001075e0",
        "FUN_001033b0"
      ],
      "called": [
        "exit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fwrite": {
      "entrypoint": "0x00102510",
      "current_name": "fwrite",
      "code": "\n\n\nsize_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)\n\n{\n  size_t sVar1;\n  \n  sVar1 \u003d fwrite(__ptr,__size,__n,__s);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00103a78",
        "FUN_00102c25"
      ],
      "called": [
        "fwrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_check_format": {
      "entrypoint": "0x00102520",
      "current_name": "bfd_check_format",
      "code": "\nvoid bfd_check_format(void)\n\n{\n  bfd_check_format();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102710",
        "FUN_00105af0",
        "FUN_00103c60"
      ],
      "called": [
        "bfd_check_format"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_openr_next_archived_file": {
      "entrypoint": "0x00102530",
      "current_name": "bfd_openr_next_archived_file",
      "code": "\nvoid bfd_openr_next_archived_file(void)\n\n{\n  bfd_openr_next_archived_file();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105af0",
        "FUN_00103c60",
        "FUN_00105300"
      ],
      "called": [
        "bfd_openr_next_archived_file"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_bread": {
      "entrypoint": "0x00102540",
      "current_name": "bfd_bread",
      "code": "\nvoid bfd_bread(void)\n\n{\n  bfd_bread();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103a78",
        "FUN_00102c25"
      ],
      "called": [
        "bfd_bread"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strerror": {
      "entrypoint": "0x00102550",
      "current_name": "strerror",
      "code": "\n\n\nchar * strerror(int __errnum)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d strerror(__errnum);\n  return pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103c60",
        "FUN_00102fd7",
        "FUN_001025a0",
        "FUN_00102f1e",
        "FUN_00103a78",
        "FUN_00102c25"
      ],
      "called": [
        "strerror"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "getc": {
      "entrypoint": "0x00102560",
      "current_name": "getc",
      "code": "\n\n\nint getc(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d getc(__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "getc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_fdopenw": {
      "entrypoint": "0x00102570",
      "current_name": "bfd_fdopenw",
      "code": "\nvoid bfd_fdopenw(void)\n\n{\n  bfd_fdopenw();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103c60",
        "FUN_001058b0"
      ],
      "called": [
        "bfd_fdopenw"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "bfd_seek": {
      "entrypoint": "0x00102580",
      "current_name": "bfd_seek",
      "code": "\nvoid bfd_seek(void)\n\n{\n  bfd_seek();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103a78",
        "FUN_00102c25"
      ],
      "called": [
        "bfd_seek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_finalize": {
      "entrypoint": "0x00102590",
      "current_name": "__cxa_finalize",
      "code": "\nvoid __cxa_finalize(void)\n\n{\n  __cxa_finalize();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "__cxa_finalize"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001025a0": {
      "entrypoint": "0x001025a0",
      "current_name": "FUN_001025a0",
      "code": "\nundefined8 FUN_001025a0(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 \u003d __errno_location();\n  if (*piVar1 \u003d\u003d 2) {\n    uVar2 \u003d dcgettext(0,\"\\\u0027%s\\\u0027: No such file\",5);\n    FUN_00107920(uVar2);\n  }\n  else {\n    strerror(*piVar1);\n    uVar2 \u003d dcgettext(0,\"Warning: could not locate \\\u0027%s\\\u0027.  reason: %s\",5);\n    FUN_00107920(uVar2);\n  }\n  return 0xffffffffffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001052a0"
      ],
      "called": [
        "FUN_00107920",
        "dcgettext",
        "strerror",
        "__errno_location"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010266f": {
      "entrypoint": "0x0010266f",
      "current_name": "FUN_0010266f",
      "code": "\nvoid FUN_0010266f(long param_1,FILE *param_2)\n\n{\n  long lVar1;\n  char *pcVar2;\n  long *__ptr;\n  long *plVar3;\n  \n  if (param_1 \u003d\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Supported targets:\",5);\n    fprintf(param_2,pcVar2);\n  }\n  else {\n    pcVar2 \u003d (char *)dcgettext(0,\"%s: supported targets:\",5);\n    fprintf(param_2,pcVar2,param_1);\n  }\n  __ptr \u003d (long *)bfd_target_list();\n  plVar3 \u003d __ptr;\n  while( true ) {\n    lVar1 \u003d *plVar3;\n    plVar3 \u003d plVar3 + 1;\n    if (lVar1 \u003d\u003d 0) break;\n    fprintf(param_2,\" %s\");\n  }\n  fputc(10,param_2);\n  free(__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010342d",
        "FUN_0010394a"
      ],
      "called": [
        "free",
        "fputc",
        "fprintf",
        "dcgettext",
        "bfd_target_list"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102710": {
      "entrypoint": "0x00102710",
      "current_name": "FUN_00102710",
      "code": "\n\n\nundefined8 * FUN_00102710(void)\n\n{\n  long *plVar1;\n  char cVar2;\n  byte bVar3;\n  int iVar4;\n  long lVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 *puVar8;\n  undefined8 unaff_RBP;\n  undefined8 in_stack_00000008;\n  \n  lVar5 \u003d bfd_openr();\n  if (lVar5 !\u003d 0) {\n    cVar2 \u003d bfd_check_format(lVar5,1);\n    if (cVar2 !\u003d \u0027\\0\u0027) {\n      DAT_0010d5f0 \u003d **(undefined8 **)(lVar5 + 8);\n    }\n    bfd_close(lVar5);\n  }\n  puVar8 \u003d (undefined8 *)bfd_openw();\n  if (((puVar8 !\u003d (undefined8 *)0x0) \u0026\u0026 (cVar2 \u003d bfd_set_format(puVar8,2), cVar2 !\u003d \u0027\\0\u0027)) \u0026\u0026\n     (cVar2 \u003d bfd_close(puVar8), cVar2 !\u003d \u0027\\0\u0027)) {\n    if (_DAT_0010d610 \u003d\u003d 0) goto LAB_00102826;\n    goto LAB_001053b7;\n  }\n  FUN_00107c10();\n  do {\n    bVar3 \u003d *(byte *)((long)puVar8 + 0x49) \u003e\u003e 4 \u0026 1;\n    if (DAT_0010d5f8 \u003d\u003d \u0027\\0\u0027) {\n      if (bVar3 !\u003d 0) {\n        uVar7 \u003d *puVar8;\n        uVar6 \u003d dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        FUN_00107690(uVar6,uVar7);\n        goto LAB_00102812;\n      }\n    }\n    else if (bVar3 \u003d\u003d 0) {\n      uVar7 \u003d *puVar8;\n      uVar6 \u003d dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      FUN_00107690(uVar6,uVar7);\nLAB_001027cb:\n      FUN_00107c20();\n      iVar4 \u003d bfd_get_error();\n      if (iVar4 \u003d\u003d 0xd) {\nLAB_00102812:\n        FUN_00103bd1(in_stack_00000008);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      plVar1 \u003d puVar8 + 0x1e;\n      for (lVar5 \u003d bfd_openr_next_archived_file(puVar8,0); lVar5 !\u003d 0;\n          lVar5 \u003d bfd_openr_next_archived_file(puVar8,lVar5)) {\n        *plVar1 \u003d lVar5;\n        plVar1 \u003d (long *)(lVar5 + 0xf0);\n      }\n      *plVar1 \u003d 0;\n      iVar4 \u003d bfd_get_error();\n      if (iVar4 \u003d\u003d 9) {\n        return puVar8;\n      }\n      do {\n        FUN_00107c10();\nLAB_00102826:\n        uVar7 \u003d dcgettext(0,\"creating %s\",5);\n        FUN_00107920(uVar7);\nLAB_001053b7:\n        DAT_0010d618 \u003d unaff_RBP;\n        puVar8 \u003d (undefined8 *)bfd_openr();\n      } while (puVar8 \u003d\u003d (undefined8 *)0x0);\n      cVar2 \u003d bfd_check_format_matches(puVar8,2,\u0026stack0x00000008);\n      if (cVar2 \u003d\u003d \u0027\\0\u0027) goto LAB_001027cb;\n    } while (((DAT_0010d64c !\u003d 2) \u0026\u0026 (DAT_0010d64c !\u003d 7)) ||\n            (lVar5 \u003d bfd_openr_next_archived_file(puVar8,0), lVar5 \u003d\u003d 0));\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105300"
      ],
      "called": [
        "bfd_check_format",
        "bfd_close",
        "bfd_openr"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010284b": {
      "entrypoint": "0x0010284b",
      "current_name": "FUN_0010284b",
      "code": "\nundefined8 FUN_0010284b(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107650"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010285f": {
      "entrypoint": "0x0010285f",
      "current_name": "FUN_0010285f",
      "code": "\n\n\nvoid FUN_0010285f(void)\n\n{\n  int iVar1;\n  char *__format;\n  long lVar2;\n  long *plVar3;\n  undefined8 uVar4;\n  long *plVar5;\n  code *unaff_RBP;\n  long unaff_R12;\n  int unaff_R13D;\n  undefined8 *unaff_R14;\n  int iStack000000000000000c;\n  \ncode_r0x0010285f:\n  uVar4 \u003d *unaff_R14;\n  __format \u003d (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n  fprintf(_stderr,__format,uVar4);\nLAB_0010553e:\n  unaff_R14 \u003d unaff_R14 + 1;\n  unaff_R13D \u003d unaff_R13D + -1;\n  if (unaff_R13D \u003d\u003d 0) {\n    return;\n  }\n  plVar5 \u003d *(long **)(unaff_R12 + 0xf0);\n  iStack000000000000000c \u003d 0;\n  do {\n    if (plVar5 \u003d\u003d (long *)0x0) goto code_r0x0010285f;\n    if (*(int *)((long)plVar5 + 0xac) \u003d\u003d 0) {\n      lVar2 \u003d *plVar5;\n      if (lVar2 \u003d\u003d 0) {\n        plVar3 \u003d (long *)plVar5[0x1d];\n        if ((long *)plVar5[0x1d] \u003d\u003d (long *)0x0) {\n          plVar3 \u003d plVar5;\n        }\n        (**(code **)(plVar3[1] + 0x1e8))(plVar5,\u0026stack0x00000010);\n      }\n      else if (((*(byte *)(unaff_R12 + 0x49) \u0026 0x10) \u003d\u003d 0) || (lVar2 \u003d FUN_00105830(), lVar2 !\u003d 0))\n      {\n        uVar4 \u003d FUN_00105830(*unaff_R14);\n        iVar1 \u003d filename_cmp(uVar4,lVar2);\n        if ((iVar1 \u003d\u003d 0) \u0026\u0026\n           ((DAT_0010d634 \u003d\u003d \u0027\\0\u0027 ||\n            (iStack000000000000000c \u003d iStack000000000000000c + 1,\n            iStack000000000000000c \u003d\u003d _DAT_0010d630)))) break;\n      }\n    }\n    plVar5 \u003d (long *)plVar5[0x1e];\n  } while( true );\n  (*unaff_RBP)();\n  *(undefined4 *)((long)plVar5 + 0xac) \u003d 1;\n  goto LAB_0010553e;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105480"
      ],
      "called": [
        "fprintf",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001028ed": {
      "entrypoint": "0x001028ed",
      "current_name": "FUN_001028ed",
      "code": "\n\n\nundefined8 FUN_001028ed(undefined8 param_1,long param_2)\n\n{\n  undefined uVar1;\n  byte bVar2;\n  int iVar3;\n  size_t sVar4;\n  int *piVar5;\n  char *pcVar6;\n  char *pcVar7;\n  char **ppcVar8;\n  undefined8 uVar9;\n  long lVar10;\n  char *__s;\n  char *__s_00;\n  long lVar11;\n  undefined8 uVar12;\n  ulong uVar13;\n  char *unaff_RBX;\n  char **ppcVar14;\n  char **unaff_RBP;\n  char **unaff_R12;\n  uint unaff_R13D;\n  char **ppcVar15;\n  long unaff_R14;\n  bool bVar16;\n  byte bVar17;\n  char **param_7;\n  undefined8 param_9;\n  long in_stack_00000078;\n  long in_stack_00000108;\n  \n  bVar17 \u003d 0;\ncode_r0x001028ed:\n  FUN_00107c10(unaff_RBX,param_2);\nLAB_001028f5:\n  uVar12 \u003d DAT_0010d638;\n  if (unaff_R13D !\u003d 3) {\n    while( true ) {\n      if ((undefined8 *)*unaff_R12 \u003d\u003d (undefined8 *)0x0) goto LAB_0010571f;\n      iVar3 \u003d filename_cmp(*(undefined8 *)*unaff_R12,uVar12);\n      if (iVar3 \u003d\u003d 0) break;\n      unaff_R12 \u003d (char **)(*unaff_R12 + 0xf0);\n    }\n    if (unaff_R13D !\u003d 2) goto LAB_0010571f;\n    unaff_R12 \u003d (char **)(*unaff_R12 + 0xf0);\n    goto LAB_0010571f;\n  }\n  lVar10 \u003d *(long *)(unaff_R14 + 0xf0);\n  if (*(long *)(unaff_R14 + 0xf0) \u003d\u003d 0) goto LAB_0010571f;\nLAB_00105670:\n  do {\n    lVar11 \u003d lVar10;\n    lVar10 \u003d *(long *)(lVar11 + 0xf0);\n  } while (lVar10 !\u003d 0);\n  unaff_R12 \u003d (char **)(lVar11 + 0xf0);\n  unaff_RBX \u003d *unaff_RBP;\n  if (DAT_0010d620 !\u003d 0) goto LAB_00105731;\nLAB_00105698:\n  uVar1 \u003d DAT_0010d5f8;\n  unaff_R13D \u003d (uint)(DAT_0010d60c !\u003d 0);\n  param_2 \u003d bfd_openr(unaff_RBX,DAT_0010d5f0);\n  if (param_2 !\u003d 0) {\n    unaff_RBP \u003d unaff_RBP + 1;\n    bVar2 \u003d FUN_00105af0(unaff_R12,param_2,unaff_R13D,uVar1);\n    param_9._6_1_ \u003d param_9._6_1_ | bVar2;\n    pcVar6 \u003d *unaff_RBP;\n    do {\n      if (pcVar6 \u003d\u003d (char *)0x0) {\n        if (param_9._6_1_ \u003d\u003d 0) {\n          DAT_0010d618 \u003d 0;\n          return 0;\n        }\n        uVar12 \u003d FUN_001058b0();\n        return uVar12;\n      }\n      ppcVar14 \u003d *(char ***)(unaff_R14 + 0xf0);\n      unaff_R12 \u003d param_7;\n      if (param_9._7_1_ \u003d\u003d \u0027\\0\u0027) {\n        ppcVar15 \u003d param_7;\n        if (ppcVar14 !\u003d (char **)0x0) {\n          do {\n            if (DAT_0010d5f9 \u003d\u003d \u0027\\0\u0027) {\n              __s \u003d (char *)lbasename(*ppcVar14);\n              pcVar7 \u003d __s;\n              if (DAT_0010d5fa !\u003d \u0027\\0\u0027) {\n                sVar4 \u003d strlen(__s);\n                uVar13 \u003d (ulong)*(byte *)(*(long *)(unaff_R14 + 8) + 0x1e);\n                if (uVar13 \u003c sVar4) {\n                  pcVar7 \u003d (char *)xmalloc(uVar13 + 1);\n                  lVar10 \u003d *(long *)(unaff_R14 + 8);\n                  pcVar6 \u003d pcVar7;\n                  for (uVar13 \u003d (ulong)*(byte *)(lVar10 + 0x1e); uVar13 !\u003d 0; uVar13 \u003d uVar13 - 1) {\n                    *pcVar6 \u003d *__s;\n                    __s \u003d __s + (ulong)bVar17 * -2 + 1;\n                    pcVar6 \u003d pcVar6 + (ulong)bVar17 * -2 + 1;\n                  }\n                  pcVar7[*(byte *)(lVar10 + 0x1e)] \u003d \u0027\\0\u0027;\n                }\n                pcVar6 \u003d *unaff_RBP;\n                __s \u003d pcVar7;\n                if (DAT_0010d5f9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105611;\n                goto LAB_00102980;\n              }\n              pcVar6 \u003d *unaff_RBP;\n              if (DAT_0010d5f9 !\u003d \u0027\\0\u0027) goto LAB_00102980;\nLAB_00105611:\n              __s_00 \u003d (char *)lbasename(pcVar6);\n              if (DAT_0010d5fa !\u003d \u0027\\0\u0027) {\n                sVar4 \u003d strlen(__s_00);\n                uVar13 \u003d (ulong)*(byte *)(*(long *)(unaff_R14 + 8) + 0x1e);\n                pcVar6 \u003d __s_00;\n                __s \u003d pcVar7;\n                if (uVar13 \u003c sVar4) {\n                  pcVar6 \u003d (char *)xmalloc(uVar13 + 1);\n                  lVar10 \u003d *(long *)(unaff_R14 + 8);\n                  pcVar7 \u003d pcVar6;\n                  for (uVar13 \u003d (ulong)*(byte *)(lVar10 + 0x1e); uVar13 !\u003d 0; uVar13 \u003d uVar13 - 1) {\n                    *pcVar7 \u003d *__s_00;\n                    __s_00 \u003d __s_00 + (ulong)bVar17 * -2 + 1;\n                    pcVar7 \u003d pcVar7 + (ulong)bVar17 * -2 + 1;\n                  }\n                  pcVar6[*(byte *)(lVar10 + 0x1e)] \u003d \u0027\\0\u0027;\n                }\n                goto LAB_00102980;\n              }\n              iVar3 \u003d filename_cmp(__s_00,pcVar7);\n            }\n            else {\n              pcVar6 \u003d *unaff_RBP;\n              __s \u003d *ppcVar14;\nLAB_00102980:\n              iVar3 \u003d filename_cmp(pcVar6,__s);\n            }\n            if ((iVar3 \u003d\u003d 0) \u0026\u0026 (ppcVar14[0x1c] !\u003d (char *)0x0)) {\n              if (_DAT_0010d644 !\u003d 0) {\n                iVar3 \u003d stat(*unaff_RBP,(stat *)\u0026stack0x000000b0);\n                if (iVar3 !\u003d 0) {\n                  piVar5 \u003d __errno_location();\n                  if (*piVar5 !\u003d 2) {\n                    FUN_00107c10(*unaff_RBP);\nLAB_00102b7e:\n                    pcVar6 \u003d *ppcVar14;\n                    uVar12 \u003d dcgettext(0,\"internal stat error on %s\",5);\n                    FUN_00107690(uVar12,pcVar6);\n                    free(unaff_RBP);\n                    return 0;\n                  }\n                  goto LAB_0010577e;\n                }\n                ppcVar8 \u003d (char **)ppcVar14[0x1d];\n                if ((char **)ppcVar14[0x1d] \u003d\u003d (char **)0x0) {\n                  ppcVar8 \u003d ppcVar14;\n                }\n                iVar3 \u003d (**(code **)(ppcVar8[1] + 0x1e8))(ppcVar14,\u0026stack0x00000020);\n                if (iVar3 !\u003d 0) goto LAB_00102b7e;\n                if (in_stack_00000108 \u003c\u003d in_stack_00000078) goto LAB_0010577e;\n              }\n              uVar12 \u003d FUN_00105870(param_7,2,*ppcVar14);\n              if (DAT_0010d620 \u003d\u003d 0) {\nLAB_00102ae2:\n                pcVar6 \u003d *unaff_RBP;\n                bVar16 \u003d DAT_0010d60c !\u003d 0;\n                lVar10 \u003d bfd_openr(pcVar6,DAT_0010d5f0);\n                if (lVar10 \u003d\u003d 0) {\n                  FUN_00107c10(pcVar6,0);\n                  goto LAB_00102b3e;\n                }\n                bVar2 \u003d FUN_00103172(uVar12,lVar10,bVar16);\n              }\n              else {\n                uVar9 \u003d FUN_00105830(*unaff_RBP);\n                iVar3 \u003d filename_cmp(uVar9,\"__.LIBDEP\");\n                if (iVar3 !\u003d 0) goto LAB_00102ae2;\nLAB_00102b3e:\n                bVar2 \u003d FUN_00103172(uVar12,DAT_0010d620,DAT_0010d60c !\u003d 0);\n              }\n              if (bVar2 !\u003d 0) {\n                *ppcVar15 \u003d *(char **)(*ppcVar15 + 0xf0);\n                param_9._6_1_ \u003d bVar2;\n              }\n              goto LAB_0010577e;\n            }\n            ppcVar15 \u003d ppcVar14 + 0x1e;\n            ppcVar14 \u003d (char **)ppcVar14[0x1e];\n          } while (ppcVar14 !\u003d (char **)0x0);\n          goto LAB_0010564c;\n        }\n        unaff_R13D \u003d DAT_0010d640;\n        if (DAT_0010d640 !\u003d 0) goto LAB_001028f5;\n      }\n      else {\nLAB_0010564c:\n        unaff_R13D \u003d DAT_0010d640;\n        if (DAT_0010d640 !\u003d 0) goto LAB_001028f5;\n        lVar10 \u003d *(long *)(unaff_R14 + 0xf0);\n        if (*(long *)(unaff_R14 + 0xf0) !\u003d 0) goto LAB_00105670;\n      }\nLAB_0010571f:\n      unaff_RBX \u003d *unaff_RBP;\n      if (DAT_0010d620 \u003d\u003d 0) goto LAB_00105698;\nLAB_00105731:\n      uVar12 \u003d FUN_00105830(unaff_RBX);\n      iVar3 \u003d filename_cmp(uVar12,\"__.LIBDEP\");\n      if (iVar3 !\u003d 0) goto code_r0x0010574f;\n      bVar2 \u003d FUN_00105ae0(unaff_R12,DAT_0010d620,DAT_0010d60c !\u003d 0,DAT_0010d5f8);\n      param_9._6_1_ \u003d bVar2 | param_9._6_1_;\nLAB_0010577e:\n      unaff_RBP \u003d unaff_RBP + 1;\n      pcVar6 \u003d *unaff_RBP;\n    } while( true );\n  }\n  goto code_r0x001028ed;\ncode_r0x0010574f:\n  unaff_RBX \u003d *unaff_RBP;\n  goto LAB_00105698;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed"
      ],
      "called": [
        "FUN_00105af0",
        "FUN_00105ae0",
        "stat",
        "FUN_00107c10",
        "strlen",
        "FUN_001058b0",
        "FUN_00103172",
        "lbasename",
        "FUN_00107690",
        "FUN_001028ed",
        "FUN_00102943",
        "FUN_00105830",
        "xmalloc",
        "FUN_00105870",
        "bfd_openr",
        "dcgettext",
        "__errno_location",
        "filename_cmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102943": {
      "entrypoint": "0x00102943",
      "current_name": "FUN_00102943",
      "code": "\nvoid FUN_00102943(void)\n\n{\n  DAT_0010d618 \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00105570"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102ba1": {
      "entrypoint": "0x00102ba1",
      "current_name": "FUN_00102ba1",
      "code": "\nundefined  [16] FUN_00102ba1(void)\n\n{\n  undefined auVar1 [16];\n  void *unaff_RBP;\n  ulong unaff_retaddr;\n  \n  free(unaff_RBP);\n  auVar1._8_8_ \u003d 0;\n  auVar1._0_8_ \u003d unaff_retaddr;\n  return auVar1 \u003c\u003c 0x40;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001057a0"
      ],
      "called": [
        "free"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102bb0": {
      "entrypoint": "0x00102bb0",
      "current_name": "FUN_00102bb0",
      "code": "\nundefined  [16] FUN_00102bb0(void)\n\n{\n  long lVar1;\n  char *in_RAX;\n  size_t sVar2;\n  undefined *puVar3;\n  ulong uVar4;\n  undefined *unaff_RBX;\n  long unaff_RBP;\n  undefined *puVar5;\n  byte bVar6;\n  undefined auVar7 [16];\n  undefined8 unaff_retaddr;\n  \n  bVar6 \u003d 0;\n  sVar2 \u003d strlen(in_RAX);\n  uVar4 \u003d (ulong)*(byte *)(*(long *)(unaff_RBP + 8) + 0x1e);\n  puVar3 \u003d unaff_RBX;\n  if (uVar4 \u003c sVar2) {\n    puVar3 \u003d (undefined *)xmalloc(uVar4 + 1);\n    lVar1 \u003d *(long *)(unaff_RBP + 8);\n    puVar5 \u003d puVar3;\n    for (uVar4 \u003d (ulong)*(byte *)(lVar1 + 0x1e); uVar4 !\u003d 0; uVar4 \u003d uVar4 - 1) {\n      *puVar5 \u003d *unaff_RBX;\n      unaff_RBX \u003d unaff_RBX + (ulong)bVar6 * -2 + 1;\n      puVar5 \u003d puVar5 + (ulong)bVar6 * -2 + 1;\n    }\n    puVar3[*(byte *)(lVar1 + 0x1e)] \u003d 0;\n  }\n  auVar7._8_8_ \u003d unaff_retaddr;\n  auVar7._0_8_ \u003d puVar3;\n  return auVar7;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105830"
      ],
      "called": [
        "xmalloc",
        "strlen"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102bf5": {
      "entrypoint": "0x00102bf5",
      "current_name": "FUN_00102bf5",
      "code": "\nvoid FUN_00102bf5(void)\n\n{\n  if (DAT_0010d5e0 !\u003d 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 !\u003d (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107730"
      ],
      "called": [
        "unlink_if_ordinary",
        "bfd_cache_close",
        "fclose"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102c25": {
      "entrypoint": "0x00102c25",
      "current_name": "FUN_00102c25",
      "code": "\n\n\nlong * FUN_00102c25(void)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long **pplVar6;\n  void *__ptr;\n  size_t __n;\n  long lVar7;\n  long **unaff_RBX;\n  long *plVar8;\n  undefined4 *puVar9;\n  ulong uVar10;\n  size_t sVar11;\n  undefined4 *param_7;\n  __mode_t param_11;\n  ulong param_12;\n  \n  puVar9 \u003d param_7;\n  for (lVar7 \u003d 0x24; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n    *puVar9 \u003d 0;\n    puVar9 \u003d puVar9 + 1;\n  }\n  pplVar6 \u003d (long **)unaff_RBX[0x1d];\n  if ((long **)unaff_RBX[0x1d] \u003d\u003d (long **)0x0) {\n    pplVar6 \u003d unaff_RBX;\n  }\n  iVar2 \u003d (*(code *)pplVar6[1][0x3d])();\n  if (iVar2 !\u003d 0) {\n    plVar8 \u003d *unaff_RBX;\n    uVar5 \u003d dcgettext(0,\"internal stat error on %s\",5);\n    iVar2 \u003d FUN_00107690(uVar5,plVar8);\n    uVar5 \u003d DAT_0010d638;\n    if (iVar2 \u003d\u003d 3) {\n      for (; *plVar8 !\u003d 0; plVar8 \u003d (long *)(*plVar8 + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*plVar8 !\u003d (undefined8 *)0x0; plVar8 \u003d (long *)(*plVar8 + 0xf0)) {\n        iVar1 \u003d filename_cmp(*(undefined8 *)*plVar8,uVar5);\n        if (iVar1 \u003d\u003d 0) {\n          if (iVar2 !\u003d 2) {\n            return plVar8;\n          }\n          return (long *)(*plVar8 + 0xf0);\n        }\n      }\n    }\n    return plVar8;\n  }\n  bfd_seek();\n  DAT_0010d5d8 \u003d (FILE *)0x0;\n  if (param_12 \u003d\u003d 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 \u003d (FILE *)FUN_00105a20(*unaff_RBX);\n  }\n  else {\n    uVar10 \u003d 0;\n    __ptr \u003d (void *)xmalloc(0x2000);\n    do {\n      sVar11 \u003d param_12 - uVar10;\n      if (0x2000 \u003c sVar11) {\n        sVar11 \u003d 0x2000;\n      }\n      __n \u003d bfd_bread(__ptr,sVar11);\n      if (sVar11 !\u003d __n) {\nLAB_00102c78:\n        unaff_RBX \u003d (long **)*unaff_RBX[0x1d];\n        uVar5 \u003d dcgettext(0,\"%s is not a valid archive\",5);\n        FUN_00107690(uVar5,unaff_RBX);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 \u003d\u003d (FILE *)0x0) {\n        DAT_0010d5d8 \u003d (FILE *)FUN_00105a20(*unaff_RBX);\n      }\n      sVar11 \u003d fwrite(__ptr,1,__n,DAT_0010d5d8);\n      if (sVar11 !\u003d __n) {\n        piVar3 \u003d __errno_location();\n        pcVar4 \u003d strerror(*piVar3);\n        FUN_00107690(\"%s: %s\",DAT_0010d618,pcVar4);\n        goto LAB_00102c78;\n      }\n      uVar10 \u003d uVar10 + __n;\n    } while (uVar10 \u003c param_12);\n    free(__ptr);\n  }\n  fclose(DAT_0010d5d8);\n  pcVar4 \u003d DAT_0010d618;\n  DAT_0010d5d8 \u003d (FILE *)0x0;\n  chmod(DAT_0010d618,param_11);\n  if (_DAT_0010d600 !\u003d 0) {\n    FUN_00107c80(pcVar4,param_7);\n  }\n  DAT_0010d618 \u003d (char *)0x0;\n  return (long *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107740"
      ],
      "called": [
        "free",
        "bfd_seek",
        "chmod",
        "FUN_00107c80",
        "FUN_00107690",
        "bfd_bread",
        "FUN_00105a20",
        "xmalloc",
        "dcgettext",
        "strerror",
        "__errno_location",
        "fclose",
        "fwrite"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102cd9": {
      "entrypoint": "0x00102cd9",
      "current_name": "FUN_00102cd9",
      "code": "\nlong * FUN_00102cd9(void)\n\n{\n  int in_EAX;\n  int iVar1;\n  long *unaff_RBX;\n  undefined8 param_7;\n  \n  param_7 \u003d DAT_0010d638;\n  if (in_EAX \u003d\u003d 3) {\n    for (; *unaff_RBX !\u003d 0; unaff_RBX \u003d (long *)(*unaff_RBX + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*unaff_RBX !\u003d (undefined8 *)0x0; unaff_RBX \u003d (long *)(*unaff_RBX + 0xf0)) {\n      iVar1 \u003d filename_cmp(*(undefined8 *)*unaff_RBX,param_7);\n      if (iVar1 \u003d\u003d 0) {\n        if (in_EAX !\u003d 2) {\n          return unaff_RBX;\n        }\n        return (long *)(*unaff_RBX + 0xf0);\n      }\n    }\n  }\n  return unaff_RBX;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105870"
      ],
      "called": [
        "filename_cmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102d2f": {
      "entrypoint": "0x00102d2f",
      "current_name": "FUN_00102d2f",
      "code": "\nvoid FUN_00102d2f(void)\n\n{\n  byte bVar1;\n  char cVar2;\n  int iVar3;\n  char *__format;\n  uint uVar4;\n  char **unaff_RBX;\n  FILE *unaff_RBP;\n  long unaff_R12;\n  void *unaff_R13;\n  int unaff_R14D;\n  undefined uStack0000000000000015;\n  char cStack0000000000000016;\n  char cStack0000000000000017;\n  char in_stack_00000018;\n  char cStack0000000000000019;\n  char cStack000000000000001a;\n  char cStack000000000000001b;\n  char cStack000000000000001c;\n  char cStack000000000000001d;\n  char cStack000000000000001e;\n  undefined uStack000000000000001f;\n  uint uStack0000000000000068;\n  uint uStack000000000000006c;\n  uint in_stack_00000070;\n  undefined8 in_stack_00000080;\n  \n  do {\n    bVar1 \u003d FUN_00107c10();\n    *(uint *)((long)unaff_RBX + 0x44) \u003d *(uint *)((long)unaff_RBX + 0x44) | 0x100000;\n    if ((DAT_0010d5f8 !\u003d \u0027\\0\u0027) || ((*(byte *)(unaff_R12 + 0x49) \u0026 0x10) !\u003d 0)) {\n      *(byte *)((long)unaff_RBX + 0x49) \u003d bVar1 | 0x10;\n    }\n    cVar2 \u003d bfd_set_archive_head();\n  } while (cVar2 \u003d\u003d \u0027\\0\u0027);\n  dup(unaff_R14D);\n  cVar2 \u003d bfd_close();\n  if (cVar2 !\u003d \u0027\\0\u0027) {\n    DAT_0010d5e0 \u003d 0;\n    DAT_0010d618 \u003d 0;\n    bfd_close();\n    iVar3 \u003d FUN_00105bc0();\n    if (iVar3 \u003d\u003d 0) {\n      free(unaff_R13);\n      free(unaff_RBP);\n      return;\n    }\n                    \n    xexit(1);\n  }\n  FUN_00107c10();\n  __format \u003d (char *)dcgettext(0,\"\u003ctime data corrupt\u003e\",5);\n  sprintf(\u0026stack0x00000020,__format);\n  uVar4 \u003d uStack0000000000000068 \u0026 0xf000;\n  if (uVar4 \u003d\u003d 0x4000) {\n    uStack0000000000000015 \u003d 100;\n  }\n  else if (uVar4 \u003d\u003d 0xa000) {\n    uStack0000000000000015 \u003d 0x6c;\n  }\n  else if (uVar4 \u003d\u003d 0x6000) {\n    uStack0000000000000015 \u003d 0x62;\n  }\n  else if (uVar4 \u003d\u003d 0x2000) {\n    uStack0000000000000015 \u003d 99;\n  }\n  else if (uVar4 \u003d\u003d 0xc000) {\n    uStack0000000000000015 \u003d 0x73;\n  }\n  else {\n    uStack0000000000000015 \u003d 0x70;\n    if (uVar4 !\u003d 0x1000) {\n      uStack0000000000000015 \u003d 0x2d;\n    }\n  }\n  cStack0000000000000016 \u003d (-((uStack0000000000000068 \u0026 0x100) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n  cStack0000000000000017 \u003d (-((uStack0000000000000068 \u0026 0x80) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n  in_stack_00000018 \u003d (-((uStack0000000000000068 \u0026 0x40) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n  cStack0000000000000019 \u003d (-((uStack0000000000000068 \u0026 0x20) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n  cStack000000000000001a \u003d (-((uStack0000000000000068 \u0026 0x10) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n  cStack000000000000001b \u003d (-((uStack0000000000000068 \u0026 8) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n  cStack000000000000001c \u003d (-((uStack0000000000000068 \u0026 4) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n  cStack000000000000001d \u003d (-((uStack0000000000000068 \u0026 2) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n  cStack000000000000001e \u003d (-((uStack0000000000000068 \u0026 1) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n  if ((uStack0000000000000068 \u0026 0x800) !\u003d 0) {\n    if (in_stack_00000018 \u003d\u003d \u0027x\u0027) {\n      in_stack_00000018 \u003d \u0027s\u0027;\n    }\n    else {\n      in_stack_00000018 \u003d \u0027S\u0027;\n    }\n  }\n  if ((uStack0000000000000068 \u0026 0x400) !\u003d 0) {\n    if (cStack000000000000001b \u003d\u003d \u0027x\u0027) {\n      cStack000000000000001b \u003d \u0027s\u0027;\n    }\n    else {\n      cStack000000000000001b \u003d \u0027S\u0027;\n    }\n  }\n  if ((uStack0000000000000068 \u0026 0x200) !\u003d 0) {\n    if (cStack000000000000001e \u003d\u003d \u0027x\u0027) {\n      cStack000000000000001e \u003d \u0027t\u0027;\n    }\n    else {\n      cStack000000000000001e \u003d \u0027T\u0027;\n    }\n  }\n  uStack000000000000001f \u003d 0;\n  fprintf(unaff_RBP,\"%s %ld/%ld %6lu %s \",\u0026stack0x00000016,(ulong)uStack000000000000006c,\n          (ulong)in_stack_00000070,in_stack_00000080,\u0026stack0x00000020,(ulong)uStack0000000000000068)\n  ;\n  fputs(*unaff_RBX,unaff_RBP);\n  if ((char)unaff_R12 !\u003d \u0027\\0\u0027) {\n    if ((*(byte *)((long)unaff_RBX + 0x49) \u0026 0x10) \u003d\u003d 0) {\n      if (unaff_RBX[0xb] !\u003d (char *)0x0) {\n        fprintf(unaff_RBP,\" 0x%lx\");\n      }\n    }\n    else if (unaff_RBX[0xc] !\u003d (char *)0x0) {\n      fprintf(unaff_RBP,\" 0x%lx\");\n    }\n  }\n  fputc(10,unaff_RBP);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102d2f"
      ],
      "called": [
        "free",
        "xexit",
        "bfd_close",
        "dup",
        "FUN_00105bc0",
        "FUN_00107c10",
        "bfd_set_archive_head",
        "FUN_00102d2f"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102d8c": {
      "entrypoint": "0x00102d8c",
      "current_name": "FUN_00102d8c",
      "code": "\nvoid FUN_00102d8c(void)\n\n{\n  char *__format;\n  uint uVar1;\n  char **unaff_RBX;\n  FILE *unaff_RBP;\n  char unaff_R12B;\n  undefined uStack0000000000000015;\n  char cStack0000000000000016;\n  char cStack0000000000000017;\n  char param_9;\n  char cStack0000000000000019;\n  char cStack000000000000001a;\n  char cStack000000000000001b;\n  char cStack000000000000001c;\n  char cStack000000000000001d;\n  char cStack000000000000001e;\n  undefined uStack000000000000001f;\n  uint param_19;\n  uint uStack000000000000006c;\n  uint param_20;\n  undefined8 param_22;\n  \n  __format \u003d (char *)dcgettext(0,\"\u003ctime data corrupt\u003e\",5);\n  sprintf(\u0026stack0x00000020,__format);\n  uVar1 \u003d param_19 \u0026 0xf000;\n  if (uVar1 \u003d\u003d 0x4000) {\n    uStack0000000000000015 \u003d 100;\n  }\n  else if (uVar1 \u003d\u003d 0xa000) {\n    uStack0000000000000015 \u003d 0x6c;\n  }\n  else if (uVar1 \u003d\u003d 0x6000) {\n    uStack0000000000000015 \u003d 0x62;\n  }\n  else if (uVar1 \u003d\u003d 0x2000) {\n    uStack0000000000000015 \u003d 99;\n  }\n  else if (uVar1 \u003d\u003d 0xc000) {\n    uStack0000000000000015 \u003d 0x73;\n  }\n  else {\n    uStack0000000000000015 \u003d 0x70;\n    if (uVar1 !\u003d 0x1000) {\n      uStack0000000000000015 \u003d 0x2d;\n    }\n  }\n  cStack0000000000000016 \u003d (-((param_19 \u0026 0x100) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n  cStack0000000000000017 \u003d (-((param_19 \u0026 0x80) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n  param_9 \u003d (-((param_19 \u0026 0x40) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n  cStack0000000000000019 \u003d (-((param_19 \u0026 0x20) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n  cStack000000000000001a \u003d (-((param_19 \u0026 0x10) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n  cStack000000000000001b \u003d (-((param_19 \u0026 8) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n  cStack000000000000001c \u003d (-((param_19 \u0026 4) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n  cStack000000000000001d \u003d (-((param_19 \u0026 2) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n  cStack000000000000001e \u003d (-((param_19 \u0026 1) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n  if ((param_19 \u0026 0x800) !\u003d 0) {\n    if (param_9 \u003d\u003d \u0027x\u0027) {\n      param_9 \u003d \u0027s\u0027;\n    }\n    else {\n      param_9 \u003d \u0027S\u0027;\n    }\n  }\n  if ((param_19 \u0026 0x400) !\u003d 0) {\n    if (cStack000000000000001b \u003d\u003d \u0027x\u0027) {\n      cStack000000000000001b \u003d \u0027s\u0027;\n    }\n    else {\n      cStack000000000000001b \u003d \u0027S\u0027;\n    }\n  }\n  if ((param_19 \u0026 0x200) !\u003d 0) {\n    if (cStack000000000000001e \u003d\u003d \u0027x\u0027) {\n      cStack000000000000001e \u003d \u0027t\u0027;\n    }\n    else {\n      cStack000000000000001e \u003d \u0027T\u0027;\n    }\n  }\n  uStack000000000000001f \u003d 0;\n  fprintf(unaff_RBP,\"%s %ld/%ld %6lu %s \",\u0026stack0x00000016,(ulong)uStack000000000000006c,\n          (ulong)param_20,param_22,\u0026stack0x00000020,(ulong)param_19);\n  fputs(*unaff_RBX,unaff_RBP);\n  if (unaff_R12B !\u003d \u0027\\0\u0027) {\n    if ((*(byte *)((long)unaff_RBX + 0x49) \u0026 0x10) \u003d\u003d 0) {\n      if (unaff_RBX[0xb] !\u003d (char *)0x0) {\n        fprintf(unaff_RBP,\" 0x%lx\");\n      }\n    }\n    else if (unaff_RBX[0xc] !\u003d (char *)0x0) {\n      fprintf(unaff_RBP,\" 0x%lx\");\n    }\n  }\n  fputc(10,unaff_RBP);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001079c0"
      ],
      "called": [
        "fputc",
        "sprintf",
        "fprintf",
        "fputs",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102e57": {
      "entrypoint": "0x00102e57",
      "current_name": "FUN_00102e57",
      "code": "\nvoid FUN_00102e57(void)\n\n{\n  FILE *pFVar1;\n  \n  DAT_0010d618 \u003d (char *)concat();\n  if (DAT_0010d60c !\u003d 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  pFVar1 \u003d fopen(DAT_0010d618,\"w\");\n  if (pFVar1 !\u003d (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105a68"
      ],
      "called": [
        "concat"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102e6f": {
      "entrypoint": "0x00102e6f",
      "current_name": "FUN_00102e6f",
      "code": "\nvoid FUN_00102e6f(void)\n\n{\n  char *pcVar1;\n  char *in_RAX;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  FILE *pFVar4;\n  size_t sVar5;\n  char *pcVar6;\n  \n  pcVar1 \u003d DAT_0010d5e8;\n  do {\n    in_RAX \u003d in_RAX + 1;\n    while (*in_RAX !\u003d \u0027/\u0027) {\n      if (*in_RAX \u003d\u003d \u0027\\0\u0027) {\n        if ((DAT_0010d5e8 !\u003d (char *)0x0) \u0026\u0026 (sVar5 \u003d strlen(DAT_0010d5e8), sVar5 !\u003d 0)) {\n          if (pcVar1[sVar5 - 1] \u003d\u003d \u0027/\u0027) {\n            DAT_0010d618 \u003d (char *)concat(pcVar1,DAT_0010d618,0);\n          }\n          else {\n            DAT_0010d618 \u003d (char *)concat(pcVar1,\u0026DAT_00108260,DAT_0010d618,0);\n          }\n        }\n        if (DAT_0010d60c !\u003d 0) {\n          printf(\"x - %s\\n\",DAT_0010d618);\n        }\n        pFVar4 \u003d fopen(DAT_0010d618,\"w\");\n        if (pFVar4 \u003d\u003d (FILE *)0x0) {\n          perror(DAT_0010d618);\n                    \n          xexit(1);\n        }\n        return;\n      }\n      pcVar6 \u003d in_RAX;\n      if ((*in_RAX \u003d\u003d \u0027.\u0027) \u0026\u0026 (pcVar6 \u003d in_RAX + 1, in_RAX[1] \u003d\u003d \u0027.\u0027)) {\n        pcVar6 \u003d in_RAX + 2;\n        if ((in_RAX[2] \u003d\u003d \u0027/\u0027) || (in_RAX[2] \u003d\u003d \u0027\\0\u0027)) {\n          uVar2 \u003d lbasename();\n          pcVar1 \u003d DAT_0010d618;\n          uVar3 \u003d dcgettext(0,\"illegal output pathname for archive member: %s, using \\\u0027%s\\\u0027 instead\"\n                            ,5);\n          FUN_00107920(uVar3,pcVar1,uVar2);\n          DAT_0010d618 \u003d (char *)uVar2;\n          FUN_00105a68();\n          return;\n        }\n      }\n      for (; (in_RAX \u003d pcVar6, *pcVar6 !\u003d \u0027\\0\u0027 \u0026\u0026 (*pcVar6 !\u003d \u0027/\u0027)); pcVar6 \u003d pcVar6 + 1) {\n      }\n    }\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102e6f"
      ],
      "called": [
        "FUN_00102e6f",
        "FUN_00107920",
        "FUN_00105a68",
        "dcgettext",
        "lbasename"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102f08": {
      "entrypoint": "0x00102f08",
      "current_name": "FUN_00102f08",
      "code": "\nundefined8 FUN_00102f08(void)\n\n{\n  undefined8 *unaff_RBX;\n  undefined8 *unaff_R12;\n  \n  printf(\"a - %s\\n\",*unaff_RBX);\n  unaff_RBX[0x1e] \u003d *unaff_R12;\n  *unaff_R12 \u003d unaff_RBX;\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105af0"
      ],
      "called": [
        "printf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102f1e": {
      "entrypoint": "0x00102f1e",
      "current_name": "FUN_00102f1e",
      "code": "\nundefined  [16] FUN_00102f1e(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  ulong unaff_RBP;\n  char *unaff_R12;\n  undefined auVar3 [16];\n  undefined8 unaff_retaddr;\n  \n  piVar1 \u003d __errno_location();\n  strerror(*piVar1);\n  uVar2 \u003d dcgettext(0,\"unable to copy file \\\u0027%s\\\u0027; reason: %s\",5);\n  FUN_00107920(uVar2);\n  unlink(unaff_R12);\n  auVar3._0_8_ \u003d unaff_RBP \u0026 0xffffffff;\n  auVar3._8_8_ \u003d unaff_retaddr;\n  return auVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105bc0"
      ],
      "called": [
        "FUN_00107920",
        "dcgettext",
        "__errno_location",
        "strerror",
        "unlink"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102f55": {
      "entrypoint": "0x00102f55",
      "current_name": "FUN_00102f55",
      "code": "\nundefined8 FUN_00102f55(void)\n\n{\n  int iVar1;\n  int *piVar2;\n  int unaff_R12D;\n  \n  piVar2 \u003d __errno_location();\n  iVar1 \u003d *piVar2;\n  close(unaff_R12D);\n  *piVar2 \u003d iVar1;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105c00"
      ],
      "called": [
        "close",
        "__errno_location"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102f96": {
      "entrypoint": "0x00102f96",
      "current_name": "FUN_00102f96",
      "code": "\n\n\nvoid FUN_00102f96(void)\n\n{\n  undefined8 uVar1;\n  long unaff_RBX;\n  undefined8 unaff_retaddr;\n  \n  uVar1 \u003d dcgettext(0,\"cause of error unknown\",5);\n  fflush(_stdout);\n  if (unaff_RBX !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010d660);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010d660,uVar1,unaff_retaddr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107c20"
      ],
      "called": [
        "fflush",
        "fprintf",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00102fd7": {
      "entrypoint": "0x00102fd7",
      "current_name": "FUN_00102fd7",
      "code": "\nvoid FUN_00102fd7(void)\n\n{\n  int *piVar1;\n  undefined8 uVar2;\n  \n  piVar1 \u003d __errno_location();\n  strerror(*piVar1);\n  uVar2 \u003d dcgettext(0,\"%s: cannot set time: %s\",5);\n  FUN_00107920(uVar2);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107c80"
      ],
      "called": [
        "FUN_00107920",
        "dcgettext",
        "strerror",
        "__errno_location"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010300e": {
      "entrypoint": "0x0010300e",
      "current_name": "FUN_0010300e",
      "code": "\nvoid FUN_0010300e(void)\n\n{\n  bool bVar1;\n  int iVar2;\n  long lVar3;\n  byte bVar4;\n  byte *pbVar5;\n  byte *in_R9;\n  int in_R10D;\n  \n  bVar1 \u003d false;\n  iVar2 \u003d DAT_0010d5d0;\n  for (pbVar5 \u003d DAT_0010d5c8; pbVar5 \u003c DAT_0010d5b0; pbVar5 \u003d pbVar5 + 1) {\n    bVar4 \u003d 1;\n    if (*pbVar5 !\u003d 0) {\n      bVar4 \u003d (\u0026DAT_0010ab00)[*pbVar5];\n    }\n    if (*(short *)(\u0026DAT_0010a980 + (long)iVar2 * 2) !\u003d 0) {\n      bVar1 \u003d true;\n      in_R9 \u003d pbVar5;\n      in_R10D \u003d iVar2;\n    }\n    while( true ) {\n      lVar3 \u003d (long)(int)((int)*(short *)(\u0026DAT_0010a640 + (long)iVar2 * 2) + (uint)bVar4);\n      if (*(short *)(\u0026DAT_0010a440 + lVar3 * 2) \u003d\u003d iVar2) break;\n      iVar2 \u003d (int)*(short *)(\u0026DAT_0010a800 + (long)iVar2 * 2);\n      if (0xb0 \u003c iVar2) {\n        bVar4 \u003d (\u0026DAT_0010a7c0)[(int)(uint)bVar4];\n      }\n    }\n    iVar2 \u003d (int)*(short *)(\u0026DAT_0010a240 + lVar3 * 2);\n  }\n  if (bVar1) {\n    DAT_0010d5b8 \u003d in_R9;\n    DAT_0010d5c0 \u003d in_R10D;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001030ed": {
      "entrypoint": "0x001030ed",
      "current_name": "FUN_001030ed",
      "code": "\nvoid FUN_001030ed(void)\n\n{\n  undefined8 *puVar1;\n  \n  puVar1 \u003d *(undefined8 **)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n  DAT_0010d598 \u003d *(undefined4 *)((long)puVar1 + 0x1c);\n  DAT_0010d5b0 \u003d (undefined *)puVar1[2];\n  DAT_0010d5c8 \u003d DAT_0010d5b0;\n  DAT_0010d590 \u003d *puVar1;\n  DAT_0010d588 \u003d *DAT_0010d5b0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001031cf",
        "FUN_00103e95"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010312d": {
      "entrypoint": "0x0010312d",
      "current_name": "FUN_0010312d",
      "code": "\nvoid FUN_0010312d(long param_1,long param_2)\n\n{\n  long lVar1;\n  \n  if (param_2 !\u003d 0) {\n    *(undefined8 *)(param_2 + 0xf0) \u003d *(undefined8 *)(param_1 + 0xf0);\n  }\n  lVar1 \u003d DAT_0010d558;\n  *(undefined8 *)(param_1 + 0xf0) \u003d *(undefined8 *)(DAT_0010d558 + 0xf8);\n  *(long *)(lVar1 + 0xf8) \u003d param_1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010315d": {
      "entrypoint": "0x0010315d",
      "current_name": "FUN_0010315d",
      "code": "\n\n\nvoid FUN_0010315d(void)\n\n{\n  if (_DAT_0010d608 \u003d\u003d 0) {\n                    \n    xexit(9);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00103c60",
        "FUN_00105300"
      ],
      "called": [
        "xexit"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103172": {
      "entrypoint": "0x00103172",
      "current_name": "FUN_00103172",
      "code": "\nundefined  [16]\nFUN_00103172(undefined8 *param_1,undefined8 *param_2,char param_3,undefined8 param_4)\n\n{\n  undefined8 uVar1;\n  undefined auVar2 [16];\n  \n  if (param_3 !\u003d \u0027\\0\u0027) {\n    printf(\"r - %s\\n\",*param_2);\n  }\n  uVar1 \u003d *param_1;\n  param_2[0x1e] \u003d uVar1;\n  auVar2._1_7_ \u003d (undefined7)((ulong)uVar1 \u003e\u003e 8);\n  auVar2[0] \u003d 1;\n  *param_1 \u003d param_2;\n  auVar2._8_8_ \u003d param_4;\n  return auVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed"
      ],
      "called": [
        "printf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001031a5": {
      "entrypoint": "0x001031a5",
      "current_name": "FUN_001031a5",
      "code": "\nvoid FUN_001031a5(void)\n\n{\n  uint uVar1;\n  char *__format;\n  \n  uVar1 \u003d DAT_0010d554 + 1;\n  __format \u003d (char *)dcgettext(0,\"Syntax error in archive script, line %d\\n\",5);\n  printf(__format,(ulong)uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "dcgettext",
        "printf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001031cf": {
      "entrypoint": "0x001031cf",
      "current_name": "FUN_001031cf",
      "code": "\n\n\nundefined8\nFUN_001031cf(FILE **param_1,FILE *param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  int *piVar4;\n  long lVar5;\n  \n  piVar4 \u003d __errno_location();\n  lVar5 \u003d DAT_0010d5a8;\n  iVar1 \u003d *piVar4;\n  if (param_1 \u003d\u003d (FILE **)0x0) {\n    _DAT_00000034 \u003d 1;\n    _DAT_00000000 \u003d param_2;\n    if (DAT_0010d5a8 !\u003d 0) {\nLAB_00103263:\n      if (param_1 \u003d\u003d *(FILE ***)(lVar5 + DAT_0010d5a0 * 8)) goto LAB_0010327b;\n    }\n  }\n  else {\n    *(undefined4 *)((long)param_1 + 0x1c) \u003d 0;\n    *(undefined *)\u0026param_1[1]-\u003e_flags \u003d 0;\n    *(undefined *)((long)\u0026param_1[1]-\u003e_flags + 1) \u003d 0;\n    *(undefined4 *)(param_1 + 5) \u003d 1;\n    param_1[2] \u003d param_1[1];\n    *(undefined4 *)(param_1 + 7) \u003d 0;\n    if (lVar5 !\u003d 0) {\n      if (param_1 \u003d\u003d *(FILE ***)(lVar5 + DAT_0010d5a0 * 8)) {\n        FUN_001030ed();\n      }\n      *param_1 \u003d param_2;\n      *(undefined4 *)((long)param_1 + 0x34) \u003d 1;\n      goto LAB_00103263;\n    }\n    *param_1 \u003d param_2;\n    *(undefined4 *)((long)param_1 + 0x34) \u003d 1;\n  }\n  *(undefined8 *)((long)param_1 + 0x2c) \u003d 1;\nLAB_0010327b:\n  uVar2 \u003d 0;\n  if (param_2 !\u003d (FILE *)0x0) {\n    iVar3 \u003d fileno(param_2);\n    iVar3 \u003d isatty(iVar3);\n    uVar2 \u003d (uint)(0 \u003c iVar3);\n  }\n  *(uint *)((long)param_1 + 0x24) \u003d uVar2;\n  *piVar4 \u003d iVar1;\n  return param_5;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_001033d6"
      ],
      "called": [
        "isatty",
        "FUN_001030ed",
        "fileno",
        "__errno_location"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001032a8": {
      "entrypoint": "0x001032a8",
      "current_name": "FUN_001032a8",
      "code": "\n\n\nundefined8 FUN_001032a8(long *param_1,code *param_2,undefined8 *param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  undefined8 uVar2;\n  bool bVar3;\n  long *plVar4;\n  int iVar5;\n  char *__format;\n  long *plVar6;\n  long lVar7;\n  long *plVar8;\n  \n  lVar7 \u003d param_1[0x1e];\n  if (param_3 \u003d\u003d (undefined8 *)0x0) {\n    while (lVar7 !\u003d 0) {\n      lVar1 \u003d *(long *)(lVar7 + 0xf0);\n      (*param_2)(lVar7,0);\n      lVar7 \u003d lVar1;\n    }\n  }\n  else {\n    do {\n      bVar3 \u003d false;\n      plVar4 \u003d (long *)param_1[0x1e];\n      plVar8 \u003d param_1;\n      while (plVar6 \u003d plVar4, plVar6 !\u003d (long *)0x0) {\n        if (*plVar6 !\u003d 0) {\n          iVar5 \u003d filename_cmp(*param_3);\n          if (iVar5 \u003d\u003d 0) {\n            bVar3 \u003d true;\n            (*param_2)(plVar6,plVar8);\n          }\n        }\n        plVar8 \u003d plVar6;\n        plVar4 \u003d (long *)plVar6[0x1e];\n      }\n      if (!bVar3) {\n        uVar2 \u003d *param_3;\n        __format \u003d (char *)dcgettext(0,\"No entry %s in archive.\\n\",5);\n        fprintf(_stderr,__format,uVar2);\n      }\n      param_3 \u003d (undefined8 *)param_3[1];\n    } while (param_3 !\u003d (undefined8 *)0x0);\n  }\n  return param_4;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "fprintf",
        "dcgettext",
        "filename_cmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010336b": {
      "entrypoint": "0x0010336b",
      "current_name": "FUN_0010336b",
      "code": "\nvoid FUN_0010336b(FILE *param_1)\n\n{\n  char *pcVar1;\n  \n  pcVar1 \u003d (char *)dcgettext(0,\" emulation options: \\n\",5);\n  fprintf(param_1,pcVar1);\n  pcVar1 \u003d (char *)dcgettext(0,\"  No emulation specific options\\n\",5);\n  fprintf(param_1,pcVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_0010342d"
      ],
      "called": [
        "fprintf",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001033b0": {
      "entrypoint": "0x001033b0",
      "current_name": "FUN_001033b0",
      "code": "\n\n\nvoid FUN_001033b0(undefined8 param_1)\n\n{\n  fprintf(_stderr,\"%s\\n\",param_1);\n                    \n  exit(2);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_001033d6",
        "FUN_00103df9"
      ],
      "called": [
        "exit",
        "fprintf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001033d6": {
      "entrypoint": "0x001033d6",
      "current_name": "FUN_001033d6",
      "code": "\nundefined  [16]\nFUN_001033d6(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  void *pvVar1;\n  void *pvVar2;\n  undefined auVar3 [16];\n  \n  pvVar1 \u003d malloc(0x40);\n  if (pvVar1 !\u003d (void *)0x0) goto LAB_001033f7;\n  do {\n    pvVar1 \u003d (void *)FUN_001033b0(\"out of dynamic memory in yy_create_buffer()\");\nLAB_001033f7:\n    *(undefined4 *)((long)pvVar1 + 0x18) \u003d 0x4000;\n    pvVar2 \u003d malloc(0x4002);\n    *(void **)((long)pvVar1 + 8) \u003d pvVar2;\n  } while (pvVar2 \u003d\u003d (void *)0x0);\n  *(undefined4 *)((long)pvVar1 + 0x20) \u003d 1;\n  FUN_001031cf(pvVar1,param_1);\n  auVar3._8_8_ \u003d param_4;\n  auVar3._0_8_ \u003d pvVar1;\n  return auVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "malloc",
        "FUN_001031cf",
        "FUN_001033b0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010342d": {
      "entrypoint": "0x0010342d",
      "current_name": "FUN_0010342d",
      "code": "\n\n\nvoid FUN_0010342d(uint param_1)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  FILE *__stream;\n  \n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV] [--plugin \u003cname\u003e] [member-name] [count] archive-file file...\\n\"\n                             ,5);\n  __stream \u003d _stderr;\n  if (param_1 !\u003d 0) {\n    __stream \u003d _stdout;\n  }\n  fprintf(__stream,pcVar2,DAT_0010d660);\n  uVar1 \u003d DAT_0010d660;\n  pcVar2 \u003d (char *)dcgettext(0,\"       %s -M [\u003cmri-script]\\n\",5);\n  fprintf(__stream,pcVar2,uVar1);\n  pcVar2 \u003d (char *)dcgettext(0,\" commands:\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  d            - delete file(s) from the archive\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  m[ab]        - move file(s) in the archive\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  p            - print file(s) found in the archive\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  q[f]         - quick append file(s) to the archive\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\\n\"\n                             ,5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  s            - act as ranlib\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  t[O][v]      - display contents of the archive\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  x[o]         - extract file(s) from the archive\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\" command specific modifiers:\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [a]          - put file(s) after [member-name]\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [b]          - put file(s) before [member-name] (same as [i])\\n\",5\n                            );\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [D]          - use zero for timestamps and uids/gids (default)\\n\",\n                             5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [U]          - use actual timestamps and uids/gids\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [N]          - use instance [count] of name\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [f]          - truncate inserted file names\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [P]          - use full path names when matching\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [o]          - preserve original dates\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [O]          - display offsets of files in the archive\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  [u]          - only replace files that are newer than current archive contents\\n\"\n                             ,5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\" generic modifiers:\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [c]          - do not warn if the library had to be created\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [s]          - create an archive index (cf. ranlib)\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [l \u003ctext\u003e ]  - specify the dependencies of this library\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [S]          - do not build a symbol table\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [T]          - deprecated, use --thin instead\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [v]          - be verbose\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  [V]          - display the version number\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  @\u003cfile\u003e      - read options from \u003cfile\u003e\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  --target\u003dBFDNAME - specify the target object format as BFDNAME\\n\",\n                             5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  --output\u003dDIRNAME - specify the output directory for extraction operations\\n\"\n                             ,5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  --record-libdeps\u003d\u003ctext\u003e - specify the dependencies of this library\\n\"\n                             ,5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  --thin       - make a thin archive\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\" optional:\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  --plugin \u003cp\u003e - load the specified plugin\\n\",5);\n  fprintf(__stream,pcVar2);\n  FUN_0010336b(__stream);\n  FUN_0010266f(DAT_0010d660,__stream);\n  if (param_1 !\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(__stream,pcVar2,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n                    \n  xexit(param_1 ^ 1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "xexit",
        "FUN_0010336b",
        "FUN_0010266f",
        "fprintf",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_0010394a": {
      "entrypoint": "0x0010394a",
      "current_name": "FUN_0010394a",
      "code": "\n\n\nvoid FUN_0010394a(uint param_1)\n\n{\n  undefined8 uVar1;\n  char *pcVar2;\n  FILE *__stream;\n  \n  uVar1 \u003d DAT_0010d660;\n  __stream \u003d _stderr;\n  if (param_1 !\u003d 0) {\n    __stream \u003d _stdout;\n  }\n  pcVar2 \u003d (char *)dcgettext(0,\"Usage: %s [options] archive\\n\",5);\n  fprintf(__stream,pcVar2,uVar1);\n  pcVar2 \u003d (char *)dcgettext(0,\" Generate an index to speed access to archives\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \" The options are:\\n  @\u003cfile\u003e                      Read options from \u003cfile\u003e\\n\"\n                             ,5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\"  --plugin \u003cname\u003e              Load the specified plugin\\n\",5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -D                           Use zero for symbol map timestamp (default)\\n  -U                           Use an actual symbol map timestamp\\n\"\n                             ,5);\n  fprintf(__stream,pcVar2);\n  pcVar2 \u003d (char *)dcgettext(0,\n                             \"  -t                           Update the archive\\\u0027s symbol map timestamp\\n  -h --help                    Print this help message\\n  -v --version                 Print version information\\n\"\n                             ,5);\n  fprintf(__stream,pcVar2);\n  FUN_0010266f(DAT_0010d660,__stream);\n  if (param_1 !\u003d 0) {\n    pcVar2 \u003d (char *)dcgettext(0,\"Report bugs to %s\\n\",5);\n    fprintf(__stream,pcVar2,\"\u003chttps://sourceware.org/bugzilla/\u003e\");\n  }\n                    \n  xexit(param_1 ^ 1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "xexit",
        "FUN_0010266f",
        "fprintf",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103a78": {
      "entrypoint": "0x00103a78",
      "current_name": "FUN_00103a78",
      "code": "\n\n\nvoid FUN_00103a78(undefined8 *param_1)\n\n{\n  int iVar1;\n  void *__ptr;\n  undefined8 *puVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  size_t sVar5;\n  int *piVar6;\n  size_t unaff_RBP;\n  char *pcVar7;\n  ulong unaff_R13;\n  ulong unaff_R14;\n  undefined auStack_b8 [48];\n  ulong local_88;\n  \n  __ptr \u003d (void *)xmalloc(0x2000);\n  puVar2 \u003d (undefined8 *)param_1[0x1d];\n  if ((undefined8 *)param_1[0x1d] \u003d\u003d (undefined8 *)0x0) {\n    puVar2 \u003d param_1;\n  }\n  iVar1 \u003d (**(code **)(puVar2[1] + 0x1e8))(param_1,auStack_b8);\n  if (iVar1 \u003d\u003d 0) {\n    if (DAT_0010d60c !\u003d 0) {\n      printf(\"\\n\u003c%s\u003e\\n\\n\",*param_1);\n    }\n    unaff_R13 \u003d 0;\n    bfd_seek(param_1,0,0);\n    goto LAB_00103afd;\n  }\n  param_1 \u003d (undefined8 *)*param_1;\n  pcVar7 \u003d \"internal stat error on %s\";\n  do {\n    uVar4 \u003d dcgettext(0,pcVar7,5);\n    FUN_00107690(uVar4,param_1);\n    local_88 \u003d unaff_R14;\n    do {\n      sVar5 \u003d fwrite(__ptr,1,unaff_RBP,_stdout);\n      if (sVar5 !\u003d unaff_RBP) {\n        piVar6 \u003d __errno_location();\n        pcVar7 \u003d strerror(*piVar6);\n        FUN_00107690(\"stdout: %s\",pcVar7);\nLAB_00103b91:\n        free(__ptr);\n        return;\n      }\n      unaff_R13 \u003d unaff_R13 + sVar5;\nLAB_00103afd:\n      if (local_88 \u003c\u003d unaff_R13) goto LAB_00103b91;\n      unaff_RBP \u003d local_88 - unaff_R13;\n      if (0x2000 \u003c unaff_RBP) {\n        unaff_RBP \u003d 0x2000;\n      }\n      uVar3 \u003d bfd_bread(__ptr,unaff_RBP,param_1);\n    } while (unaff_RBP \u003d\u003d uVar3);\n    pcVar7 \u003d \"%s is not a valid archive\";\n    param_1 \u003d *(undefined8 **)param_1[0x1d];\n    unaff_R14 \u003d local_88;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "free",
        "FUN_00107690",
        "bfd_bread",
        "bfd_seek",
        "xmalloc",
        "dcgettext",
        "printf",
        "strerror",
        "__errno_location",
        "fwrite"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103ba8": {
      "entrypoint": "0x00103ba8",
      "current_name": "FUN_00103ba8",
      "code": "\n\n\nvoid FUN_00103ba8(void)\n\n{\n  if (_DAT_0010d608 !\u003d 0) {\n    printf(\"AR \u003e\");\n    fflush(_stdout);\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "fflush",
        "printf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103bd1": {
      "entrypoint": "0x00103bd1",
      "current_name": "FUN_00103bd1",
      "code": "\n\n\nvoid FUN_00103bd1(long *param_1)\n\n{\n  undefined8 uVar1;\n  char *__format;\n  long *plVar2;\n  \n  fflush(_stdout);\n  uVar1 \u003d DAT_0010d660;\n  __format \u003d (char *)dcgettext(0,\"%s: Matching formats:\",5);\n  fprintf(_stderr,__format,uVar1);\n  for (plVar2 \u003d param_1; *plVar2 !\u003d 0; plVar2 \u003d plVar2 + 1) {\n    fprintf(_stderr,\" %s\");\n  }\n  free(param_1);\n  fputc(10,_stderr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105300",
        "FUN_00105db0"
      ],
      "called": [
        "free",
        "fflush",
        "fputc",
        "fprintf",
        "dcgettext"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103c60": {
      "entrypoint": "0x00103c60",
      "current_name": "FUN_00103c60",
      "code": "\n\n\nvoid FUN_00103c60(char *param_1,int param_2)\n\n{\n  char cVar1;\n  int *piVar2;\n  char *pcVar3;\n  long lVar4;\n  long lVar5;\n  undefined8 uVar6;\n  long *plVar7;\n  \n  DAT_0010d570 \u003d xstrdup();\n  DAT_0010d560 \u003d (char *)FUN_001057a0(DAT_0010d570,\u0026DAT_0010d568);\n  if (DAT_0010d560 \u003d\u003d (char *)0x0) {\n    piVar2 \u003d __errno_location();\n    param_1 \u003d strerror(*piVar2);\n    uVar6 \u003d DAT_0010d660;\n    pcVar3 \u003d (char *)dcgettext(0,\"%s: Can\\\u0027t open temporary file (%s)\\n\",5);\n  }\n  else {\n    DAT_0010d558 \u003d bfd_fdopenw(DAT_0010d560,0,DAT_0010d568);\n    if (DAT_0010d558 \u003d\u003d 0) {\n      pcVar3 \u003d \"%s: Can\\\u0027t open output archive %s\\n\";\n      param_1 \u003d DAT_0010d560;\n    }\n    else {\n      if (param_2 !\u003d 0) {\nLAB_00103d02:\n        bfd_set_format(DAT_0010d558,2);\n        *(byte *)(DAT_0010d558 + 0x49) \u003d *(byte *)(DAT_0010d558 + 0x49) \u0026 0xe7 | 8;\n        return;\n      }\n      lVar4 \u003d bfd_openr(param_1,\"plugin\");\n      if (lVar4 \u003d\u003d 0) {\n        pcVar3 \u003d \"%s: Can\\\u0027t open input archive %s\\n\";\n      }\n      else {\n        cVar1 \u003d bfd_check_format(lVar4,2);\n        if (cVar1 !\u003d \u0027\\0\u0027) {\n          plVar7 \u003d (long *)(DAT_0010d558 + 0xf8);\n          for (lVar5 \u003d bfd_openr_next_archived_file(lVar4,0); lVar5 !\u003d 0;\n              lVar5 \u003d bfd_openr_next_archived_file(lVar4,lVar5)) {\n            *plVar7 \u003d lVar5;\n            plVar7 \u003d (long *)(lVar5 + 0xf0);\n          }\n          goto LAB_00103d02;\n        }\n        pcVar3 \u003d \"%s: file %s is not an archive\\n\";\n      }\n    }\n    uVar6 \u003d DAT_0010d660;\n    pcVar3 \u003d (char *)dcgettext(0,pcVar3,5);\n  }\n  fprintf(_stderr,pcVar3,uVar6,param_1);\n  FUN_0010315d();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "FUN_001057a0",
        "bfd_set_format",
        "bfd_check_format",
        "fprintf",
        "bfd_openr_next_archived_file",
        "dcgettext",
        "bfd_openr",
        "FUN_0010315d",
        "bfd_fdopenw",
        "__errno_location",
        "strerror",
        "xstrdup"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103ddc": {
      "entrypoint": "0x00103ddc",
      "current_name": "FUN_00103ddc",
      "code": "\nvoid FUN_00103ddc(undefined8 param_1)\n\n{\n  FUN_001079c0(DAT_0010d578,param_1,DAT_0010d60c !\u003d 0,0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "FUN_001079c0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103df9": {
      "entrypoint": "0x00103df9",
      "current_name": "FUN_00103df9",
      "code": "\nundefined8 FUN_00103df9(void)\n\n{\n  size_t __size;\n  undefined8 in_RCX;\n  long lVar1;\n  long lVar2;\n  undefined4 *puVar3;\n  byte bVar4;\n  \n  bVar4 \u003d 0;\n  if (DAT_0010d5a8 \u003d\u003d (void *)0x0) {\n    DAT_0010d5a8 \u003d calloc(8,1);\n    if (DAT_0010d5a8 !\u003d (void *)0x0) {\n      DAT_0010d580 \u003d 1;\n      DAT_0010d5a0 \u003d 0;\n      return in_RCX;\n    }\n  }\n  else {\n    if (DAT_0010d5a0 \u003c DAT_0010d580 - 1U) {\n      return in_RCX;\n    }\n    lVar2 \u003d DAT_0010d580 + 8;\n    __size \u003d lVar2 * 8;\n    DAT_0010d5a8 \u003d realloc(DAT_0010d5a8,__size);\n    if (DAT_0010d5a8 !\u003d (void *)0x0) {\n      puVar3 \u003d (undefined4 *)((long)DAT_0010d5a8 + (__size - 0x40));\n      DAT_0010d580 \u003d lVar2;\n      for (lVar1 \u003d 0x10; lVar1 !\u003d 0; lVar1 \u003d lVar1 + -1) {\n        *puVar3 \u003d 0;\n        puVar3 \u003d puVar3 + (ulong)bVar4 * -2 + 1;\n      }\n      return in_RCX;\n    }\n  }\n  FUN_001033b0(\"out of dynamic memory in yyensure_buffer_stack()\");\n  DAT_0010d5a0 \u003d 0;\n  DAT_0010d580 \u003d 1;\n  return in_RCX;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95"
      ],
      "called": [
        "realloc",
        "calloc",
        "FUN_001033b0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00103e95": {
      "entrypoint": "0x00103e95",
      "current_name": "FUN_00103e95",
      "code": "\n\n\nvoid FUN_00103e95(void)\n\n{\n  long **pplVar1;\n  char cVar2;\n  FILE **ppFVar3;\n  FILE *pFVar4;\n  long *plVar5;\n  undefined8 uVar6;\n  byte *pbVar7;\n  int iVar8;\n  char *pcVar10;\n  undefined8 uVar11;\n  int iVar9;\n  long *plVar12;\n  size_t sVar13;\n  void *pvVar14;\n  char *pcVar15;\n  char *pcVar16;\n  long lVar17;\n  long lVar18;\n  ulong uVar19;\n  uint uVar20;\n  long lVar21;\n  undefined8 *puVar22;\n  undefined8 *puVar23;\n  uint uVar24;\n  int iVar25;\n  ulong uVar26;\n  char **ppcVar27;\n  bool bVar28;\n  char **ppcVar29;\n  byte bVar30;\n  long lVar31;\n  byte *pbVar32;\n  byte *pbVar33;\n  int *piVar34;\n  byte *pbVar35;\n  uint uVar36;\n  int iVar37;\n  char **ppcVar38;\n  byte bVar39;\n  undefined auVar40 [16];\n  undefined auVar41 [16];\n  char *local_828;\n  char *local_820;\n  long local_818;\n  char **local_810;\n  int local_800;\n  uint local_7fc;\n  byte *local_7f8;\n  stat local_7d0;\n  char local_740 [200];\n  char *local_678 [201];\n  \n  bVar39 \u003d 0;\n  lVar18 \u003d 0;\n  DAT_0010d550 \u003d -2;\n  ppcVar29 \u003d local_678;\n  local_800 \u003d 0;\n  local_828 \u003d local_740;\n  local_818 \u003d 200;\n  local_820 \u003d local_828;\n  local_810 \u003d ppcVar29;\nLAB_00103ee9:\n  *local_828 \u003d (char)lVar18;\n  if (local_820 + local_818 + -1 \u003c\u003d local_828) {\n    lVar21 \u003d (long)local_828 - (long)local_820;\n    lVar17 \u003d lVar21 + 1;\n    if (local_818 \u003c 10000) {\n      lVar31 \u003d local_818 * 2;\n      local_818 \u003d 10000;\n      if (lVar31 \u003c 0x2711) {\n        local_818 \u003d lVar31;\n      }\n      pcVar10 \u003d (char *)malloc(local_818 * 9 + 7);\n      if (pcVar10 !\u003d (char *)0x0) {\n        lVar31 \u003d lVar17 * 8;\n        pcVar15 \u003d local_820;\n        pcVar16 \u003d pcVar10;\n        for (; lVar17 !\u003d 0; lVar17 \u003d lVar17 + -1) {\n          *pcVar16 \u003d *pcVar15;\n          pcVar15 \u003d pcVar15 + (ulong)bVar39 * -2 + 1;\n          pcVar16 \u003d pcVar16 + (ulong)bVar39 * -2 + 1;\n        }\n        ppcVar38 \u003d (char **)(pcVar10 + local_818);\n        ppcVar29 \u003d ppcVar38;\n        for (; lVar31 !\u003d 0; lVar31 \u003d lVar31 + -1) {\n          *(undefined *)ppcVar29 \u003d *(undefined *)local_810;\n          local_810 \u003d (char **)((long)local_810 + (ulong)bVar39 * -2 + 1);\n          ppcVar29 \u003d (char **)((long)ppcVar29 + (ulong)bVar39 * -2 + 1);\n        }\n        if (local_820 !\u003d local_740) {\n          free(local_820);\n        }\n        local_828 \u003d pcVar10 + lVar21;\n        ppcVar29 \u003d ppcVar38 + lVar21;\n        local_820 \u003d pcVar10;\n        local_810 \u003d ppcVar38;\n        if (pcVar10 + local_818 + -1 \u003c\u003d local_828) goto LAB_00105265;\n        goto LAB_00103fd8;\n      }\n    }\n    FUN_001031a5();\nLAB_0010524c:\n    pcVar10 \u003d local_820;\n    if (local_820 \u003d\u003d local_740) {\n      return;\n    }\nLAB_00105265:\n    free(pcVar10);\n    return;\n  }\nLAB_00103fd8:\n  iVar37 \u003d (int)lVar18;\n  if (iVar37 \u003d\u003d 3) goto LAB_0010524c;\n  cVar2 \u003d (\u0026DAT_0010a200)[iVar37];\n  if (cVar2 !\u003d -0xe) {\n    if (DAT_0010d550 \u003d\u003d -2) {\n      if (_DAT_0010d540 \u003d\u003d 0) {\n        _DAT_0010d540 \u003d 1;\n        if (DAT_0010d5d0 \u003d\u003d 0) {\n          DAT_0010d5d0 \u003d 1;\n        }\n        if (DAT_0010d590 \u003d\u003d (FILE *)0x0) {\n          DAT_0010d590 \u003d _stdin;\n        }\n        if (DAT_0010d538 \u003d\u003d (FILE *)0x0) {\n          DAT_0010d538 \u003d _stdout;\n        }\n        if ((DAT_0010d5a8 \u003d\u003d 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) \u003d\u003d 0)) {\n          FUN_00103df9();\n          puVar22 \u003d (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          uVar11 \u003d FUN_001033d6(DAT_0010d590);\n          *puVar22 \u003d uVar11;\n        }\n        FUN_001030ed();\n      }\nLAB_001040b1:\n      *DAT_0010d5b0 \u003d DAT_0010d588;\n      pbVar32 \u003d DAT_0010d5b0;\n      pbVar35 \u003d DAT_0010d5b0;\n      uVar20 \u003d DAT_0010d5d0;\nLAB_001040d4:\n      uVar19 \u003d (ulong)uVar20;\n      uVar26 \u003d (ulong)local_7fc;\n      bVar28 \u003d false;\n      do {\n        bVar30 \u003d (\u0026DAT_0010ab00)[*pbVar35];\n        if (*(short *)(\u0026DAT_0010a980 + (long)(int)uVar19 * 2) !\u003d 0) {\n          bVar28 \u003d true;\n          uVar26 \u003d uVar19 \u0026 0xffffffff;\n          local_7f8 \u003d pbVar35;\n        }\n        while( true ) {\n          iVar8 \u003d (int)uVar19;\n          lVar18 \u003d (long)(int)((int)*(short *)(\u0026DAT_0010a640 + (long)iVar8 * 2) + (uint)bVar30);\n          if (iVar8 \u003d\u003d *(short *)(\u0026DAT_0010a440 + lVar18 * 2)) break;\n          uVar19 \u003d (ulong)(uint)(int)*(short *)(\u0026DAT_0010a800 + (long)iVar8 * 2);\n          if (0xb0 \u003c *(short *)(\u0026DAT_0010a800 + (long)iVar8 * 2)) {\n            bVar30 \u003d (\u0026DAT_0010a7c0)[(int)(uint)bVar30];\n          }\n        }\n        pbVar35 \u003d pbVar35 + 1;\n        uVar19 \u003d (ulong)*(short *)(\u0026DAT_0010a240 + lVar18 * 2);\n      } while (*(short *)(\u0026DAT_0010a640 + uVar19 * 2) !\u003d 0xc2);\n      local_7fc \u003d (uint)uVar26;\n      pbVar33 \u003d pbVar32;\n      if (bVar28) {\n        DAT_0010d5b8 \u003d local_7f8;\n        DAT_0010d5c0 \u003d local_7fc;\n      }\nLAB_0010419f:\n      iVar8 \u003d (int)*(short *)(\u0026DAT_0010a980 + (long)(int)uVar19 * 2);\n      if (iVar8 \u003d\u003d 0) {\n        iVar8 \u003d (int)*(short *)(\u0026DAT_0010a980 + (long)(int)DAT_0010d5c0 * 2);\n        pbVar35 \u003d DAT_0010d5b8;\n      }\n      DAT_0010d530 \u003d (int)pbVar35 - (int)pbVar33;\n      DAT_0010d588 \u003d *pbVar35;\n      DAT_0010d5b0 \u003d pbVar35;\n      DAT_0010d5c8 \u003d pbVar33;\n      *pbVar35 \u003d 0;\nLAB_001041f0:\n      pbVar32 \u003d DAT_0010d5c8;\n      lVar18 \u003d DAT_0010d5a0;\n      switch(iVar8) {\n      case 0:\n        goto switchD_00104200_caseD_0;\n      case 1:\n      case 0x10:\n        DAT_0010d550 \u003d 0x105;\n        break;\n      case 2:\n      case 0x11:\n        DAT_0010d550 \u003d 0x107;\n        break;\n      case 3:\n      case 0x12:\n        DAT_0010d550 \u003d 0x108;\n        break;\n      case 4:\n      case 0x13:\n        DAT_0010d550 \u003d 0x109;\n        break;\n      case 5:\n      case 0x14:\n        DAT_0010d550 \u003d 0x10a;\n        break;\n      case 6:\n      case 0x15:\n        DAT_0010d550 \u003d 0x10b;\n        break;\n      case 7:\n      case 0x16:\n        DAT_0010d550 \u003d 0x10c;\n        break;\n      case 8:\n      case 0x17:\n        DAT_0010d550 \u003d 0x10d;\n        break;\n      case 9:\n      case 0x18:\n        DAT_0010d550 \u003d 0x10e;\n        break;\n      case 10:\n      case 0x19:\n        DAT_0010d550 \u003d 0x10f;\n        break;\n      case 0xb:\n      case 0x1a:\n        DAT_0010d550 \u003d 0x106;\n        break;\n      case 0xc:\n      case 0x1b:\n        DAT_0010d550 \u003d 0x113;\n        break;\n      case 0xd:\n      case 0x1c:\n        DAT_0010d550 \u003d 0x111;\n        break;\n      case 0xe:\n      case 0x1d:\n        DAT_0010d550 \u003d 0x103;\n        break;\n      case 0x1f:\n        DAT_0010d554 \u003d DAT_0010d554 + 1;\n        goto LAB_001040b1;\n      case 0x20:\n        DAT_0010d550 \u003d 0x28;\n        break;\n      case 0x21:\n        DAT_0010d550 \u003d 0x29;\n        break;\n      case 0x22:\n        DAT_0010d550 \u003d 0x2c;\n        break;\n      case 0x23:\n        DAT_0010d548 \u003d (char *)xstrdup(DAT_0010d5c8);\n        DAT_0010d550 \u003d 0x104;\n        break;\n      case 0x24:\n      case 0x25:\n      case 0x26:\n        goto LAB_001040b1;\n      case 0x27:\n        DAT_0010d554 \u003d DAT_0010d554 + 1;\n        DAT_0010d550 \u003d 0x102;\n        break;\n      case 0x28:\n        fwrite(DAT_0010d5c8,(long)DAT_0010d530,1,DAT_0010d538);\n        goto LAB_001040b1;\n      case 0x29:\n        goto switchD_00104200_caseD_29;\n      case 0x2a:\n        DAT_0010d550 \u003d 0;\n        break;\n      default:\n        FUN_001033b0(\"fatal flex scanner internal error--no action found\");\n      case 0xf:\n      case 0x1e:\n        DAT_0010d550 \u003d 0x112;\n      }\n      lVar18 \u003d (long)iVar37;\n    }\n    if (0 \u003c DAT_0010d550) {\n      if (DAT_0010d550 !\u003d 0x100) {\n        iVar37 \u003d 2;\n        if (DAT_0010d550 \u003c 0x114) {\n          iVar37 \u003d (int)(char)(\u0026DAT_0010a0e0)[DAT_0010d550];\n        }\n        goto LAB_0010497d;\n      }\n      DAT_0010d550 \u003d 0x101;\n      goto LAB_001051f0;\n    }\n    iVar37 \u003d 0;\n    DAT_0010d550 \u003d 0;\nLAB_0010497d:\n    uVar20 \u003d cVar2 + iVar37;\n    if ((0x22 \u003c uVar20) || (iVar37 !\u003d (char)(\u0026DAT_0010a0a0)[(int)uVar20])) goto LAB_001049db;\n    cVar2 \u003d (\u0026DAT_0010a060)[(int)uVar20];\n    lVar18 \u003d (long)cVar2;\n    if (cVar2 \u003c \u0027\\x01\u0027) {\n      iVar37 \u003d -(int)cVar2;\n      goto LAB_00104a0a;\n    }\n    DAT_0010d550 \u003d -2;\n    local_800 \u003d local_800 + -1 + (uint)(local_800 \u003d\u003d 0);\n    ppcVar29 \u003d ppcVar29 + 1;\n    *ppcVar29 \u003d DAT_0010d548;\n    goto LAB_001049d1;\n  }\nLAB_001049db:\n  iVar37 \u003d (int)(char)(\u0026DAT_0010a020)[(int)lVar18];\n  if ((\u0026DAT_0010a020)[(int)lVar18] \u003d\u003d \u0027\\0\u0027) {\n    if (local_800 \u003d\u003d 0) {\n      _DAT_0010d544 \u003d _DAT_0010d544 + 1;\n      FUN_001031a5();\nLAB_001051f0:\n      do {\n        if (((((char)(\u0026DAT_0010a200)[lVar18] !\u003d -0xe) \u0026\u0026\n             (uVar20 \u003d (int)(char)(\u0026DAT_0010a200)[lVar18] + 1, uVar20 \u003c 0x23)) \u0026\u0026\n            ((\u0026DAT_0010a0a0)[(int)uVar20] \u003d\u003d \u0027\\x01\u0027)) \u0026\u0026\n           (lVar18 \u003d (long)(char)(\u0026DAT_0010a060)[(int)uVar20],\n           \u0027\\0\u0027 \u003c (char)(\u0026DAT_0010a060)[(int)uVar20])) goto LAB_00105227;\n        if (local_820 \u003d\u003d local_828) goto LAB_0010524c;\n        local_828 \u003d local_828 + -1;\n        ppcVar29 \u003d ppcVar29 + -1;\n        lVar18 \u003d (long)*local_828;\n      } while( true );\n    }\n    if (local_800 !\u003d 3) goto LAB_001051f0;\n    if (0 \u003c DAT_0010d550) {\n      DAT_0010d550 \u003d -2;\n      goto LAB_001051f0;\n    }\n    if (DAT_0010d550 !\u003d 0) goto LAB_001051f0;\n    goto LAB_0010524c;\n  }\nLAB_00104a0a:\n  uVar11 \u003d DAT_0010d660;\n  ppcVar27 \u003d DAT_0010d558;\n  cVar2 \u003d (\u0026DAT_00109fe0)[iVar37];\n  ppcVar38 \u003d (char **)ppcVar29[1 - cVar2];\n  switch(iVar37) {\n  case 2:\n  case 6:\n    FUN_00103ba8();\n    break;\n  case 0x13:\n    if (DAT_0010d558 \u003d\u003d (char **)0x0) {\n      return;\n    }\n    bfd_cache_close();\n    unlink(*DAT_0010d558);\n    return;\n  case 0x15:\n    FUN_001031a5();\n    break;\n  case 0x17:\n    puVar22 \u003d (undefined8 *)*ppcVar29;\n    if (DAT_0010d558 \u003d\u003d (char **)0x0) {\n      pcVar10 \u003d \"%s: no open archive\\n\";\nLAB_00104b62:\n      pcVar10 \u003d (char *)dcgettext(0,pcVar10,5);\n      fprintf(_stderr,pcVar10,uVar11);\n      FUN_0010315d();\n    }\n    else {\n      for (; puVar22 !\u003d (undefined8 *)0x0; puVar22 \u003d (undefined8 *)puVar22[1]) {\n        for (puVar23 \u003d (undefined8 *)DAT_0010d558[0x1f]; puVar23 !\u003d (undefined8 *)0x0;\n            puVar23 \u003d (undefined8 *)puVar23[0x1e]) {\n          iVar8 \u003d filename_cmp(*puVar23);\n          if (iVar8 \u003d\u003d 0) {\n            FUN_00107740();\n            goto LAB_00104adf;\n          }\n        }\n        bfd_openr(*puVar22,0);\n        uVar6 \u003d DAT_0010d660;\n        uVar11 \u003d *puVar22;\n        pcVar10 \u003d (char *)dcgettext(0,\"%s: can\\\u0027t find module file %s\\n\",5);\n        fprintf(_stderr,pcVar10,uVar6,uVar11);\nLAB_00104adf:\n      }\n    }\n    break;\n  case 0x18:\n    puVar22 \u003d (undefined8 *)*ppcVar29;\n    if (DAT_0010d558 \u003d\u003d (char **)0x0) {\nLAB_00104b4f:\n      pcVar10 \u003d \"%s: no open output archive\\n\";\n      goto LAB_00104b62;\n    }\n    for (; puVar22 !\u003d (undefined8 *)0x0; puVar22 \u003d (undefined8 *)puVar22[1]) {\n      bVar28 \u003d false;\n      ppcVar27 \u003d DAT_0010d558 + 0x1f;\n      for (pcVar10 \u003d DAT_0010d558[0x1f]; pcVar10 !\u003d (char *)0x0;\n          pcVar10 \u003d *(char **)(pcVar10 + 0xf0)) {\n        iVar8 \u003d filename_cmp();\n        if (iVar8 \u003d\u003d 0) {\n          pcVar15 \u003d (char *)bfd_openr(*puVar22,0);\n          uVar11 \u003d DAT_0010d660;\n          if (pcVar15 \u003d\u003d (char *)0x0) {\n            uVar6 \u003d *puVar22;\n            pcVar15 \u003d (char *)dcgettext(0,\"%s: can\\\u0027t open file %s\\n\",5);\n            fprintf(_stderr,pcVar15,uVar11,uVar6);\n            FUN_0010315d();\n          }\n          else {\n            *ppcVar27 \u003d pcVar15;\n            bVar28 \u003d true;\n            *(undefined8 *)(pcVar15 + 0xf0) \u003d *(undefined8 *)(pcVar10 + 0xf0);\n          }\n        }\n        else {\n          ppcVar27 \u003d (char **)(pcVar10 + 0xf0);\n        }\n      }\n      if (!bVar28) {\n        pcVar10 \u003d (char *)bfd_openr(*puVar22,0);\n        uVar6 \u003d DAT_0010d660;\n        uVar11 \u003d *puVar22;\n        pcVar15 \u003d (char *)dcgettext(0,\"%s: can\\\u0027t find module file %s\\n\",5);\n        fprintf(_stderr,pcVar15,uVar6,uVar11);\n        uVar11 \u003d DAT_0010d660;\n        if (pcVar10 \u003d\u003d (char *)0x0) {\n          uVar6 \u003d *puVar22;\n          pcVar10 \u003d (char *)dcgettext(0,\"%s: can\\\u0027t open file %s\\n\",5);\n          fprintf(_stderr,pcVar10,uVar11,uVar6);\n          FUN_0010315d();\n        }\n        else {\n          *ppcVar27 \u003d pcVar10;\n        }\n      }\n    }\n    break;\n  case 0x19:\n    if (DAT_0010d558 !\u003d (char **)0x0) {\n      DAT_0010d558[0x1f] \u003d (char *)0x0;\n    }\n    break;\n  case 0x1a:\n    puVar22 \u003d (undefined8 *)*ppcVar29;\n    if (DAT_0010d558 \u003d\u003d (char **)0x0) goto LAB_00104b4f;\n    for (; puVar22 !\u003d (undefined8 *)0x0; puVar22 \u003d (undefined8 *)puVar22[1]) {\n      bVar28 \u003d false;\n      ppcVar27 \u003d DAT_0010d558 + 0x1f;\n      for (puVar23 \u003d (undefined8 *)DAT_0010d558[0x1f]; uVar11 \u003d DAT_0010d660,\n          puVar23 !\u003d (undefined8 *)0x0; puVar23 \u003d (undefined8 *)puVar23[0x1e]) {\n        iVar8 \u003d filename_cmp(*puVar23,*puVar22);\n        if (iVar8 \u003d\u003d 0) {\n          bVar28 \u003d true;\n          *ppcVar27 \u003d (char *)puVar23[0x1e];\n        }\n        else {\n          ppcVar27 \u003d (char **)(puVar23 + 0x1e);\n        }\n      }\n      if (!bVar28) {\n        uVar6 \u003d *puVar22;\n        pcVar10 \u003d (char *)dcgettext(0,\"%s: can\\\u0027t find module file %s\\n\",5);\n        fprintf(_stderr,pcVar10,uVar11,uVar6);\n        FUN_0010315d();\n      }\n    }\n    break;\n  case 0x1b:\n    puVar22 \u003d (undefined8 *)*ppcVar29;\n    if (DAT_0010d558 \u003d\u003d (char **)0x0) goto LAB_00104b4f;\n    for (; puVar22 !\u003d (undefined8 *)0x0; puVar22 \u003d (undefined8 *)puVar22[1]) {\n      pcVar10 \u003d (char *)bfd_openr(*puVar22,\"plugin\");\n      uVar11 \u003d DAT_0010d660;\n      ppcVar27 \u003d DAT_0010d558;\n      if (pcVar10 \u003d\u003d (char *)0x0) {\n        uVar6 \u003d *puVar22;\n        pcVar10 \u003d (char *)dcgettext(0,\"%s: can\\\u0027t open file %s\\n\",5);\n        fprintf(_stderr,pcVar10,uVar11,uVar6);\n        FUN_0010315d();\n      }\n      else {\n        *(char **)(pcVar10 + 0xf0) \u003d DAT_0010d558[0x1f];\n        ppcVar27[0x1f] \u003d pcVar10;\n      }\n    }\n    break;\n  case 0x1c:\n    if (DAT_0010d558 \u003d\u003d (char **)0x0) goto LAB_00104b4f;\n    pcVar10 \u003d *DAT_0010d558;\n    DAT_0010d60c \u003d 1;\n    DAT_0010d578 \u003d _stdout;\n    pcVar15 \u003d (char *)dcgettext(0,\"Current open archive is %s\\n\",5);\n    printf(pcVar15,pcVar10);\n    for (pcVar10 \u003d DAT_0010d558[0x1f]; pcVar10 !\u003d (char *)0x0; pcVar10 \u003d *(char **)(pcVar10 + 0xf0))\n    {\n      FUN_00103ddc(pcVar10,0);\n    }\n    break;\n  case 0x1d:\n    if (DAT_0010d558 \u003d\u003d (char **)0x0) goto LAB_00104b4f;\n    if (0 \u003c _DAT_0010d2d0) {\n      *(uint *)((long)DAT_0010d558 + 0x44) \u003d *(uint *)((long)DAT_0010d558 + 0x44) | 0x2000;\n    }\n    DAT_0010d568 \u003d dup(DAT_0010d568);\n    bfd_close(ppcVar27);\n    pcVar10 \u003d DAT_0010d570;\n    iVar8 \u003d stat(DAT_0010d570,\u0026local_7d0);\n    if ((iVar8 !\u003d 0) \u0026\u0026 (DAT_0010d558 \u003d (char **)bfd_openw(pcVar10,0), DAT_0010d558 !\u003d (char **)0x0)\n       ) {\n      bfd_set_format(DAT_0010d558,2);\n      bfd_close(DAT_0010d558);\n    }\n    FUN_00105bc0(DAT_0010d560,DAT_0010d570,DAT_0010d568);\n    DAT_0010d558 \u003d (char **)0x0;\n    free(DAT_0010d560);\n    free(DAT_0010d570);\n    break;\n  case 0x1e:\n    FUN_00103c60(*ppcVar29,0);\n    break;\n  case 0x1f:\n    FUN_00103c60(*ppcVar29,1);\n    break;\n  case 0x20:\n    pcVar10 \u003d *ppcVar29;\n    if (DAT_0010d558 \u003d\u003d (char **)0x0) {\n      pcVar10 \u003d \"%s: no output archive specified yet\\n\";\n      goto LAB_00104b62;\n    }\n    lVar18 \u003d FUN_00105300(ppcVar29[-1],0);\n    if (lVar18 !\u003d 0) {\n      FUN_001032a8(lVar18,FUN_0010312d,pcVar10);\n    }\n    break;\n  case 0x21:\n    pcVar10 \u003d *ppcVar29;\n    pcVar15 \u003d ppcVar29[-1];\n    uVar11 \u003d FUN_00105300(ppcVar29[-2],0);\n    if (pcVar10 \u003d\u003d (char *)0x0) {\n      DAT_0010d578 \u003d _stdout;\n    }\n    else {\n      DAT_0010d578 \u003d fopen(pcVar10,\"w\");\n      if (DAT_0010d578 !\u003d (FILE *)0x0) {\n        FUN_001032a8(uVar11,FUN_00103ddc,pcVar15);\n        bfd_close(uVar11);\n        fclose(DAT_0010d578);\n        break;\n      }\n      DAT_0010d578 \u003d _stdout;\n      pcVar16 \u003d (char *)dcgettext(0,\"Can\\\u0027t open file %s\\n\",5);\n      fprintf(_stderr,pcVar16,pcVar10);\n    }\n    FUN_001032a8(uVar11,FUN_00103ddc,pcVar15);\n    bfd_close(uVar11);\n    break;\n  case 0x22:\n    ppcVar38 \u003d (char **)*ppcVar29;\n    break;\n  case 0x23:\n  case 0x25:\n  case 0x27:\n    ppcVar38 \u003d (char **)0x0;\n    break;\n  case 0x24:\n    ppcVar38 \u003d (char **)ppcVar29[-1];\n    break;\n  case 0x26:\n    ppcVar38 \u003d (char **)malloc(0x10);\n    pcVar10 \u003d ppcVar29[-2];\n    *ppcVar38 \u003d *ppcVar29;\n    ppcVar38[1] \u003d pcVar10;\n    break;\n  case 0x2a:\n    DAT_0010d60c \u003d (uint)(DAT_0010d60c \u003d\u003d 0);\n  }\n  lVar18 \u003d (long)cVar2;\n  local_828 \u003d local_828 + -lVar18;\n  ppcVar29[1 - lVar18] \u003d (char *)ppcVar38;\n  ppcVar29 \u003d ppcVar29 + (1 - lVar18);\n  uVar20 \u003d (int)(char)(\u0026DAT_00109f80)[(char)(\u0026DAT_00109fa0)[iVar37] + -0x18] + (int)*local_828;\n  if ((uVar20 \u003c 0x23) \u0026\u0026 (*local_828 \u003d\u003d (\u0026DAT_0010a0a0)[(int)uVar20])) {\n    lVar18 \u003d (long)(char)(\u0026DAT_0010a060)[(int)uVar20];\n  }\n  else {\n    lVar18 \u003d (long)(char)(\u0026DAT_00109f60)[(char)(\u0026DAT_00109fa0)[iVar37] + -0x18];\n  }\n  goto LAB_001049d1;\nswitchD_00104200_caseD_29:\n  iVar8 \u003d ((int)pbVar35 - (int)DAT_0010d5c8) + -1;\n  *pbVar35 \u003d DAT_0010d588;\n  pplVar1 \u003d (long **)(DAT_0010d5a8 + lVar18 * 8);\n  ppFVar3 \u003d (FILE **)*pplVar1;\n  if (*(int *)(ppFVar3 + 7) \u003d\u003d 0) {\n    DAT_0010d598 \u003d *(uint *)((long)ppFVar3 + 0x1c);\n    *(undefined4 *)(ppFVar3 + 7) \u003d 1;\n    *ppFVar3 \u003d DAT_0010d590;\n  }\n  pbVar7 \u003d DAT_0010d5b0;\n  pFVar4 \u003d ppFVar3[1];\n  auVar40._8_8_ \u003d pFVar4;\n  auVar40._0_8_ \u003d ppFVar3;\n  if ((byte *)((long)\u0026pFVar4-\u003e_flags + (long)(int)DAT_0010d598) \u003c DAT_0010d5b0) {\n    if ((byte *)((long)\u0026pFVar4-\u003e_flags + (long)(int)DAT_0010d598 + 1) \u003c DAT_0010d5b0) {\n      auVar40 \u003d FUN_001033b0();\n    }\n    if (*(int *)(auVar40._0_8_ + 0x34) !\u003d 0) {\n      uVar20 \u003d (int)((long)pbVar7 - (long)pbVar32) - 1;\n      for (lVar18 \u003d 0; (int)lVar18 \u003c (int)uVar20; lVar18 \u003d lVar18 + 1) {\n        *(byte *)(auVar40._8_8_ + lVar18) \u003d pbVar32[lVar18];\n      }\n      plVar12 \u003d *pplVar1;\n      if (*(int *)(plVar12 + 7) \u003d\u003d 2) {\n        DAT_0010d598 \u003d 0;\n        *(undefined4 *)((long)plVar12 + 0x1c) \u003d 0;\nLAB_0010475e:\n        pFVar4 \u003d DAT_0010d590;\n        if (uVar20 \u003d\u003d 0) {\n          if ((DAT_0010d5a8 \u003d\u003d 0) || (*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) \u003d\u003d 0)) {\n            FUN_00103df9();\n            puVar22 \u003d (undefined8 *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n            uVar11 \u003d FUN_001033d6(pFVar4);\n            *puVar22 \u003d uVar11;\n          }\n          lVar18 \u003d DAT_0010d5a8;\n          if (DAT_0010d5a8 !\u003d 0) {\n            lVar18 \u003d *(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n          }\n          iVar9 \u003d 1;\n          FUN_001031cf(lVar18);\n          FUN_001030ed();\n        }\n        else {\n          iVar9 \u003d 2;\n          *(undefined4 *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x38) \u003d 2;\n        }\n      }\n      else {\n        while( true ) {\n          plVar5 \u003d *pplVar1;\n          uVar24 \u003d ~uVar20 + *(int *)(plVar12 + 3);\n          if (0 \u003c (int)uVar24) break;\n          uVar24 \u003d (int)DAT_0010d5b0 - (int)(void *)plVar5[1];\n          if (*(int *)(plVar5 + 4) \u003d\u003d 0) {\n            plVar5[1] \u003d 0;\nLAB_00104626:\n            FUN_001033b0();\n            break;\n          }\n          iVar9 \u003d *(int *)(plVar5 + 3);\n          iVar25 \u003d iVar9;\n          if (iVar9 \u003c 1) {\n            iVar25 \u003d iVar9 / 8;\n          }\n          *(int *)(plVar5 + 3) \u003d iVar25 + iVar9;\n          pvVar14 \u003d realloc((void *)plVar5[1],(long)(iVar25 + iVar9 + 2));\n          plVar5[1] \u003d (long)pvVar14;\n          if (pvVar14 \u003d\u003d (void *)0x0) goto LAB_00104626;\n          DAT_0010d5b0 \u003d (byte *)((long)pvVar14 + (long)(int)uVar24);\n          plVar12 \u003d *pplVar1;\n        }\n        if (0x2000 \u003c (int)uVar24) {\n          uVar24 \u003d 0x2000;\n        }\n        uVar26 \u003d (ulong)uVar24;\n        if (*(int *)((long)plVar5 + 0x24) \u003d\u003d 0) {\n          piVar34 \u003d __errno_location();\n          uVar26 \u003d (ulong)(int)uVar24;\n          uVar19 \u003d (ulong)(int)uVar20;\n          *piVar34 \u003d 0;\n          goto LAB_001046c7;\n        }\n        uVar19 \u003d 0;\n        piVar34 \u003d (int *)(long)(int)uVar20;\n        do {\n          iVar9 \u003d getc(DAT_0010d590);\n          uVar36 \u003d (uint)uVar19;\n          if (iVar9 \u003d\u003d -1) {\n            iVar9 \u003d ferror(DAT_0010d590);\n            uVar24 \u003d uVar36;\n            if (iVar9 !\u003d 0) {\n              do {\n                pcVar10 \u003d \"input in flex scanner failed\";\n                FUN_001033b0();\n                do {\n                  *piVar34 \u003d 0;\n                  clearerr((FILE *)pcVar10);\nLAB_001046c7:\n                  sVar13 \u003d fread((void *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)\n                                         + uVar19),1,uVar26,DAT_0010d590);\n                  pcVar10 \u003d (char *)DAT_0010d590;\n                  DAT_0010d598 \u003d (uint)sVar13;\n                  uVar24 \u003d DAT_0010d598;\n                  if ((DAT_0010d598 !\u003d 0) ||\n                     (iVar9 \u003d ferror(DAT_0010d590), uVar24 \u003d DAT_0010d598, iVar9 \u003d\u003d 0))\n                  goto LAB_00104738;\n                } while (*piVar34 \u003d\u003d 4);\n              } while( true );\n            }\n            break;\n          }\n          if (iVar9 \u003d\u003d 10) {\n            *(undefined *)\n             ((long)(int *)(long)(int)uVar20 +\n             (long)(int)uVar36 + *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8)) \u003d 10;\n            uVar24 \u003d uVar36 + 1;\n            break;\n          }\n          uVar19 \u003d (ulong)(uVar36 + 1);\n          *(char *)(*(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8) + (long)piVar34) \u003d\n               (char)iVar9;\n          piVar34 \u003d (int *)((long)piVar34 + 1);\n        } while (uVar24 !\u003d uVar36 + 1);\nLAB_00104738:\n        DAT_0010d598 \u003d uVar24;\n        uVar24 \u003d DAT_0010d598;\n        iVar9 \u003d 0;\n        *(uint *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 0x1c) \u003d DAT_0010d598;\n        if (uVar24 \u003d\u003d 0) goto LAB_0010475e;\n      }\n      plVar12 \u003d (long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8);\n      lVar18 \u003d *plVar12;\n      uVar20 \u003d uVar20 + DAT_0010d598;\n      if (*(int *)(lVar18 + 0x18) \u003c (int)uVar20) {\n        iVar25 \u003d ((int)DAT_0010d598 \u003e\u003e 1) + uVar20;\n        pvVar14 \u003d realloc(*(void **)(lVar18 + 8),(long)iVar25);\n        *(void **)(lVar18 + 8) \u003d pvVar14;\n        auVar41._8_8_ \u003d plVar12;\n        auVar41._0_8_ \u003d *plVar12;\n        if (*(long *)(*plVar12 + 8) \u003d\u003d 0) {\n          auVar41 \u003d FUN_001033b0();\n        }\n        plVar12 \u003d auVar41._8_8_;\n        *(int *)(auVar41._0_8_ + 0x18) \u003d iVar25 + -2;\n      }\n      DAT_0010d598 \u003d uVar20;\n      *(undefined *)(*(long *)(*plVar12 + 8) + (long)(int)uVar20) \u003d 0;\n      *(undefined *)(*(long *)(*plVar12 + 8) + 1 + (long)(int)uVar20) \u003d 0;\n      pbVar32 \u003d *(byte **)(*plVar12 + 8);\n      DAT_0010d5c8 \u003d pbVar32;\n      if (iVar9 \u003d\u003d 1) goto LAB_001048a4;\n      if (iVar9 \u003d\u003d 2) goto LAB_001048ca;\n      pbVar35 \u003d pbVar32 + iVar8;\n      DAT_0010d5b0 \u003d pbVar35;\n      uVar20 \u003d FUN_0010300e();\n      goto LAB_001040d4;\n    }\n    if ((long)pbVar7 - (long)pbVar32 \u003d\u003d 1) goto LAB_001048a4;\nLAB_001048ca:\n    pbVar35 \u003d (byte *)((long)(int)DAT_0010d598 +\n                      *(long *)(*(long *)(DAT_0010d5a8 + DAT_0010d5a0 * 8) + 8));\n    DAT_0010d5b0 \u003d pbVar35;\n    uVar19 \u003d FUN_0010300e();\n    pbVar33 \u003d DAT_0010d5c8;\n    goto LAB_0010419f;\n  }\n  pbVar35 \u003d pbVar32 + iVar8;\n  DAT_0010d5b0 \u003d pbVar35;\n  uVar19 \u003d FUN_0010300e();\n  if (*(short *)(\u0026DAT_0010a980 + (long)(int)(uint)uVar19 * 2) !\u003d 0) {\n    DAT_0010d5b8 \u003d pbVar35;\n    DAT_0010d5c0 \u003d (uint)uVar19;\n  }\n  uVar26 \u003d uVar19 \u0026 0xffffffff;\n  while( true ) {\n    iVar8 \u003d (int)uVar26;\n    if (iVar8 \u003d\u003d *(short *)(\u0026DAT_0010a440 +\n                           (long)(*(short *)(\u0026DAT_0010a640 + (long)iVar8 * 2) + 1) * 2)) break;\n    uVar26 \u003d (ulong)(uint)(int)*(short *)(\u0026DAT_0010a800 + (long)iVar8 * 2);\n  }\n  uVar20 \u003d (uint)*(short *)(\u0026DAT_0010a240 +\n                           (long)(*(short *)(\u0026DAT_0010a640 + (long)iVar8 * 2) + 1) * 2);\n  pbVar33 \u003d pbVar32;\n  if ((*(short *)(\u0026DAT_0010a240 + (long)(*(short *)(\u0026DAT_0010a640 + (long)iVar8 * 2) + 1) * 2) \u003d\u003d 0)\n     || (uVar20 \u003d\u003d 0xb0)) goto LAB_0010419f;\n  pbVar35 \u003d pbVar35 + 1;\n  goto LAB_001040d4;\nLAB_001048a4:\n  DAT_0010d5b0 \u003d DAT_0010d5c8;\n  iVar8 \u003d (int)(DAT_0010d5d0 - 1) / 2 + 0x2a;\n  goto LAB_001041f0;\nswitchD_00104200_caseD_0:\n  *pbVar35 \u003d DAT_0010d588;\n  uVar19 \u003d (ulong)DAT_0010d5c0;\n  pbVar35 \u003d DAT_0010d5b8;\n  goto LAB_0010419f;\nLAB_00105227:\n  ppcVar29 \u003d ppcVar29 + 1;\n  local_800 \u003d 3;\n  *ppcVar29 \u003d DAT_0010d548;\nLAB_001049d1:\n  local_828 \u003d local_828 + 1;\n  goto LAB_00103ee9;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "free",
        "FUN_00107740",
        "FUN_00103ddc",
        "dup",
        "malloc",
        "FUN_001032a8",
        "FUN_0010300e",
        "fread",
        "FUN_001030ed",
        "FUN_00105bc0",
        "clearerr",
        "FUN_00105300",
        "dcgettext",
        "bfd_openr",
        "ferror",
        "getc",
        "__errno_location",
        "FUN_001033b0",
        "filename_cmp",
        "FUN_00103ba8",
        "bfd_close",
        "FUN_001031cf",
        "FUN_001033d6",
        "FUN_001031a5",
        "stat",
        "FUN_00103c60",
        "FUN_00103df9",
        "FUN_0010315d",
        "bfd_cache_close",
        "unlink",
        "bfd_openw",
        "bfd_set_format",
        "realloc",
        "fprintf",
        "FUN_0010312d",
        "fopen",
        "printf",
        "fwrite",
        "fclose",
        "xstrdup"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001052a0": {
      "entrypoint": "0x001052a0",
      "current_name": "FUN_001052a0",
      "code": "\nlong FUN_001052a0(char *param_1)\n\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  stat sStack_a8;\n  \n  if (param_1 !\u003d (char *)0x0) {\n    iVar1 \u003d stat(param_1,\u0026sStack_a8);\n    if (iVar1 \u003c 0) {\n      piVar2 \u003d __errno_location();\n      if (*piVar2 \u003d\u003d 2) {\n        uVar3 \u003d dcgettext(0,\"\\\u0027%s\\\u0027: No such file\",5);\n        FUN_00107920(uVar3,param_1);\n      }\n      else {\n        pcVar4 \u003d strerror(*piVar2);\n        uVar3 \u003d dcgettext(0,\"Warning: could not locate \\\u0027%s\\\u0027.  reason: %s\",5);\n        FUN_00107920(uVar3,param_1,pcVar4);\n      }\n    }\n    else if ((sStack_a8.st_mode \u0026 0xf000) \u003d\u003d 0x4000) {\n      uVar3 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 is a directory\",5);\n      FUN_00107920(uVar3,param_1);\n    }\n    else if ((sStack_a8.st_mode \u0026 0xf000) \u003d\u003d 0x8000) {\n      if (-1 \u003c sStack_a8.st_size) {\n        return sStack_a8.st_size;\n      }\n      uVar3 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 has negative size, probably it is too large\",5);\n      FUN_00107920(uVar3,param_1);\n    }\n    else {\n      uVar3 \u003d dcgettext(0,\"Warning: \\\u0027%s\\\u0027 is not an ordinary file\",5);\n      FUN_00107920(uVar3,param_1);\n    }\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107650",
        "FUN_00105db0"
      ],
      "called": [
        "FUN_00107920",
        "stat",
        "dcgettext",
        "FUN_001025a0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105300": {
      "entrypoint": "0x00105300",
      "current_name": "FUN_00105300",
      "code": "\n\n\nundefined8 * FUN_00105300(char *param_1,undefined8 *param_2)\n\n{\n  long *plVar1;\n  char *pcVar2;\n  byte bVar3;\n  char cVar4;\n  int iVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  long lVar9;\n  undefined8 *puVar10;\n  undefined8 local_b0;\n  stat local_a8;\n  \n  bfd_set_error(0);\n  if (DAT_0010d5f0 \u003d\u003d (char *)0x0) {\n    DAT_0010d5f0 \u003d \"plugin\";\n  }\n  iVar5 \u003d stat(param_1,\u0026local_a8);\n  pcVar2 \u003d DAT_0010d618;\n  if (iVar5 \u003d\u003d 0) goto LAB_001053be;\n  piVar8 \u003d __errno_location();\n  if (*piVar8 \u003d\u003d 2) {\n    if (DAT_0010d604 \u003d\u003d \u0027\\0\u0027) {\n      fprintf(_stderr,\"%s: \",DAT_0010d660);\n      perror(param_1);\n      FUN_0010315d();\n      return (undefined8 *)0x0;\n    }\n    if ((DAT_0010d5f0 \u003d\u003d (char *)0x0) \u0026\u0026 (param_2 !\u003d (undefined8 *)0x0)) {\n      puVar10 \u003d (undefined8 *)FUN_00102710();\n      return puVar10;\n    }\n    param_2 \u003d (undefined8 *)bfd_openw(param_1,DAT_0010d5f0);\n    if (((param_2 !\u003d (undefined8 *)0x0) \u0026\u0026 (cVar4 \u003d bfd_set_format(param_2,2), cVar4 !\u003d \u0027\\0\u0027)) \u0026\u0026\n       (cVar4 \u003d bfd_close(param_2), cVar4 !\u003d \u0027\\0\u0027)) {\n      pcVar2 \u003d param_1;\n      if (_DAT_0010d610 \u003d\u003d 0) goto LAB_00102826;\n      goto LAB_001053be;\n    }\n  }\n  FUN_00107c10(param_1);\n  do {\n    bVar3 \u003d *(byte *)((long)param_2 + 0x49) \u003e\u003e 4 \u0026 1;\n    if (DAT_0010d5f8 \u003d\u003d \u0027\\0\u0027) {\n      if (bVar3 !\u003d 0) {\n        uVar7 \u003d *param_2;\n        uVar6 \u003d dcgettext(0,\"Cannot convert existing thin library %s to normal format\",5);\n        FUN_00107690(uVar6,uVar7);\n        goto LAB_00102812;\n      }\n    }\n    else if (bVar3 \u003d\u003d 0) {\n      uVar7 \u003d *param_2;\n      uVar6 \u003d dcgettext(0,\"Cannot convert existing library %s to thin format\",5);\n      FUN_00107690(uVar6,uVar7);\nLAB_001027cb:\n      FUN_00107c20(param_1);\n      iVar5 \u003d bfd_get_error();\n      if (iVar5 \u003d\u003d 0xd) {\nLAB_00102812:\n        FUN_00103bd1(local_b0);\n      }\n                    \n      xexit(1);\n    }\n    do {\n      plVar1 \u003d param_2 + 0x1e;\n      for (lVar9 \u003d bfd_openr_next_archived_file(param_2,0); lVar9 !\u003d 0;\n          lVar9 \u003d bfd_openr_next_archived_file(param_2,lVar9)) {\n        *plVar1 \u003d lVar9;\n        plVar1 \u003d (long *)(lVar9 + 0xf0);\n      }\n      *plVar1 \u003d 0;\n      iVar5 \u003d bfd_get_error();\n      if (iVar5 \u003d\u003d 9) {\n        return param_2;\n      }\n      do {\n        FUN_00107c10(param_1);\nLAB_00102826:\n        uVar7 \u003d dcgettext(0,\"creating %s\",5);\n        FUN_00107920(uVar7,param_1);\n        pcVar2 \u003d param_1;\nLAB_001053be:\n        DAT_0010d618 \u003d pcVar2;\n        param_2 \u003d (undefined8 *)bfd_openr(param_1,DAT_0010d5f0);\n      } while (param_2 \u003d\u003d (undefined8 *)0x0);\n      cVar4 \u003d bfd_check_format_matches(param_2,2,\u0026local_b0);\n      if (cVar4 \u003d\u003d \u0027\\0\u0027) goto LAB_001027cb;\n    } while (((DAT_0010d64c !\u003d 2) \u0026\u0026 (DAT_0010d64c !\u003d 7)) ||\n            (lVar9 \u003d bfd_openr_next_archived_file(param_2,0), lVar9 \u003d\u003d 0));\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107650",
        "FUN_00103e95",
        "FUN_00105db0"
      ],
      "called": [
        "xexit",
        "bfd_close",
        "FUN_00107920",
        "FUN_00102710",
        "stat",
        "FUN_00107c10",
        "FUN_0010315d",
        "bfd_set_error",
        "FUN_00103bd1",
        "FUN_00107690",
        "bfd_openw",
        "bfd_set_format",
        "bfd_get_error",
        "bfd_check_format_matches",
        "bfd_openr_next_archived_file",
        "fprintf",
        "dcgettext",
        "bfd_openr",
        "perror",
        "FUN_00107c20",
        "__errno_location"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105480": {
      "entrypoint": "0x00105480",
      "current_name": "FUN_00105480",
      "code": "\n\n\nvoid FUN_00105480(long param_1,code *param_2,undefined8 *param_3,int param_4)\n\n{\n  int iVar1;\n  char *__format;\n  long lVar2;\n  long *plVar3;\n  undefined8 uVar4;\n  long *plVar5;\n  int local_cc;\n  undefined local_c8 [152];\n  \n  lVar2 \u003d *(long *)(param_1 + 0xf0);\n  if (param_4 \u003d\u003d 0) {\n    for (; lVar2 !\u003d 0; lVar2 \u003d *(long *)(lVar2 + 0xf0)) {\n      (*param_2)(lVar2);\n    }\n  }\n  else {\n    for (; lVar2 !\u003d 0; lVar2 \u003d *(long *)(lVar2 + 0xf0)) {\n      *(undefined4 *)(lVar2 + 0xac) \u003d 0;\n    }\n    do {\n      plVar5 \u003d *(long **)(param_1 + 0xf0);\n      local_cc \u003d 0;\n      for (; plVar5 !\u003d (long *)0x0; plVar5 \u003d (long *)plVar5[0x1e]) {\n        if (*(int *)((long)plVar5 + 0xac) \u003d\u003d 0) {\n          lVar2 \u003d *plVar5;\n          if (lVar2 \u003d\u003d 0) {\n            plVar3 \u003d (long *)plVar5[0x1d];\n            if ((long *)plVar5[0x1d] \u003d\u003d (long *)0x0) {\n              plVar3 \u003d plVar5;\n            }\n            (**(code **)(plVar3[1] + 0x1e8))(plVar5,local_c8);\n          }\n          else if (((*(byte *)(param_1 + 0x49) \u0026 0x10) \u003d\u003d 0) ||\n                  (lVar2 \u003d FUN_00105830(lVar2,param_1), lVar2 !\u003d 0)) {\n            uVar4 \u003d FUN_00105830(*param_3,param_1);\n            iVar1 \u003d filename_cmp(uVar4,lVar2);\n            if ((iVar1 \u003d\u003d 0) \u0026\u0026\n               ((DAT_0010d634 \u003d\u003d \u0027\\0\u0027 || (local_cc \u003d local_cc + 1, local_cc \u003d\u003d _DAT_0010d630)))) {\n              (*param_2)();\n              *(undefined4 *)((long)plVar5 + 0xac) \u003d 1;\n              goto LAB_0010553e;\n            }\n          }\n        }\n      }\n      uVar4 \u003d *param_3;\n      __format \u003d (char *)dcgettext(0,\"no entry %s in archive\\n\",5);\n      fprintf(_stderr,__format,uVar4);\nLAB_0010553e:\n      param_3 \u003d param_3 + 1;\n      param_4 \u003d param_4 + -1;\n    } while (param_4 !\u003d 0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "FUN_0010285f",
        "FUN_00105830",
        "filename_cmp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105570": {
      "entrypoint": "0x00105570",
      "current_name": "FUN_00105570",
      "code": "\n\n\nundefined8 FUN_00105570(long param_1,char **param_2,char param_3)\n\n{\n  char **ppcVar1;\n  undefined uVar2;\n  byte bVar3;\n  int iVar4;\n  size_t sVar5;\n  int *piVar6;\n  char *pcVar7;\n  char *pcVar8;\n  undefined8 uVar9;\n  char *pcVar10;\n  char *__s;\n  long lVar11;\n  long lVar12;\n  undefined8 uVar13;\n  ulong uVar14;\n  char **ppcVar15;\n  char **ppcVar16;\n  uint uVar17;\n  char **ppcVar18;\n  bool bVar19;\n  byte bVar20;\n  byte local_15a;\n  undefined auStack_158 [88];\n  long lStack_100;\n  stat sStack_c8;\n  \n  bVar20 \u003d 0;\n  ppcVar1 \u003d (char **)(param_1 + 0xf0);\n  local_15a \u003d 0;\n  if (param_2 \u003d\u003d (char **)0x0) {\n    uVar13 \u003d FUN_00102943();\n    return uVar13;\n  }\n  do {\n    pcVar10 \u003d *param_2;\njoined_r0x001055aa:\n    if (pcVar10 \u003d\u003d (char *)0x0) {\n      if (local_15a !\u003d 0) {\n        uVar13 \u003d FUN_001058b0(param_1);\n        return uVar13;\n      }\n      DAT_0010d618 \u003d 0;\n      return 0;\n    }\n    ppcVar15 \u003d *(char ***)(param_1 + 0xf0);\n    ppcVar16 \u003d ppcVar1;\n    if (param_3 !\u003d \u0027\\0\u0027) {\nLAB_0010564c:\n      uVar17 \u003d DAT_0010d640;\n      if (DAT_0010d640 !\u003d 0) goto LAB_001028f5;\n      lVar12 \u003d *(long *)(param_1 + 0xf0);\n      if (*(long *)(param_1 + 0xf0) \u003d\u003d 0) goto LAB_0010571f;\nLAB_00105670:\n      do {\n        lVar11 \u003d lVar12;\n        lVar12 \u003d *(long *)(lVar11 + 0xf0);\n      } while (lVar12 !\u003d 0);\n      ppcVar16 \u003d (char **)(lVar11 + 0xf0);\n      pcVar10 \u003d *param_2;\n      do {\n        if (DAT_0010d620 !\u003d 0) {\n          uVar13 \u003d FUN_00105830(pcVar10,param_1);\n          iVar4 \u003d filename_cmp(uVar13,\"__.LIBDEP\");\n          if (iVar4 \u003d\u003d 0) {\n            bVar3 \u003d FUN_00105ae0(ppcVar16,DAT_0010d620,DAT_0010d60c !\u003d 0,DAT_0010d5f8);\n            local_15a \u003d bVar3 | local_15a;\n            goto LAB_0010577e;\n          }\n          pcVar10 \u003d *param_2;\n        }\n        uVar2 \u003d DAT_0010d5f8;\n        bVar19 \u003d DAT_0010d60c !\u003d 0;\n        lVar12 \u003d bfd_openr(pcVar10,DAT_0010d5f0);\n        if (lVar12 !\u003d 0) {\n          param_2 \u003d param_2 + 1;\n          bVar3 \u003d FUN_00105af0(ppcVar16,lVar12,(uint)bVar19,uVar2);\n          local_15a \u003d local_15a | bVar3;\n          pcVar10 \u003d *param_2;\n          goto joined_r0x001055aa;\n        }\n        FUN_00107c10(pcVar10,0);\n        uVar17 \u003d (uint)bVar19;\nLAB_001028f5:\n        uVar13 \u003d DAT_0010d638;\n        if (uVar17 \u003d\u003d 3) {\n          lVar12 \u003d *(long *)(param_1 + 0xf0);\n          if (*(long *)(param_1 + 0xf0) !\u003d 0) goto LAB_00105670;\n        }\n        else {\n          for (; (undefined8 *)*ppcVar16 !\u003d (undefined8 *)0x0;\n              ppcVar16 \u003d (char **)(*ppcVar16 + 0xf0)) {\n            iVar4 \u003d filename_cmp(*(undefined8 *)*ppcVar16,uVar13);\n            if (iVar4 \u003d\u003d 0) {\n              if (uVar17 \u003d\u003d 2) {\n                ppcVar16 \u003d (char **)(*ppcVar16 + 0xf0);\n              }\n              break;\n            }\n          }\n        }\nLAB_0010571f:\n        pcVar10 \u003d *param_2;\n      } while( true );\n    }\n    ppcVar18 \u003d ppcVar1;\n    if (ppcVar15 \u003d\u003d (char **)0x0) {\n      uVar17 \u003d DAT_0010d640;\n      if (DAT_0010d640 \u003d\u003d 0) goto LAB_0010571f;\n      goto LAB_001028f5;\n    }\nLAB_001055d8:\n    if (DAT_0010d5f9 \u003d\u003d \u0027\\0\u0027) {\n      pcVar10 \u003d (char *)lbasename(*ppcVar15);\n      pcVar8 \u003d pcVar10;\n      if (DAT_0010d5fa !\u003d \u0027\\0\u0027) {\n        sVar5 \u003d strlen(pcVar10);\n        uVar14 \u003d (ulong)*(byte *)(*(long *)(param_1 + 8) + 0x1e);\n        if (uVar14 \u003c sVar5) {\n          pcVar8 \u003d (char *)xmalloc(uVar14 + 1);\n          lVar12 \u003d *(long *)(param_1 + 8);\n          pcVar7 \u003d pcVar8;\n          for (uVar14 \u003d (ulong)*(byte *)(lVar12 + 0x1e); uVar14 !\u003d 0; uVar14 \u003d uVar14 - 1) {\n            *pcVar7 \u003d *pcVar10;\n            pcVar10 \u003d pcVar10 + (ulong)bVar20 * -2 + 1;\n            pcVar7 \u003d pcVar7 + (ulong)bVar20 * -2 + 1;\n          }\n          pcVar8[*(byte *)(lVar12 + 0x1e)] \u003d \u0027\\0\u0027;\n        }\n        pcVar7 \u003d *param_2;\n        pcVar10 \u003d pcVar8;\n        if (DAT_0010d5f9 \u003d\u003d \u0027\\0\u0027) goto LAB_00105611;\n        goto LAB_00102980;\n      }\n      pcVar7 \u003d *param_2;\n      if (DAT_0010d5f9 !\u003d \u0027\\0\u0027) goto LAB_00102980;\nLAB_00105611:\n      __s \u003d (char *)lbasename(pcVar7);\n      if (DAT_0010d5fa !\u003d \u0027\\0\u0027) {\n        sVar5 \u003d strlen(__s);\n        uVar14 \u003d (ulong)*(byte *)(*(long *)(param_1 + 8) + 0x1e);\n        pcVar7 \u003d __s;\n        pcVar10 \u003d pcVar8;\n        if (uVar14 \u003c sVar5) {\n          pcVar7 \u003d (char *)xmalloc(uVar14 + 1);\n          lVar12 \u003d *(long *)(param_1 + 8);\n          pcVar8 \u003d pcVar7;\n          for (uVar14 \u003d (ulong)*(byte *)(lVar12 + 0x1e); uVar14 !\u003d 0; uVar14 \u003d uVar14 - 1) {\n            *pcVar8 \u003d *__s;\n            __s \u003d __s + (ulong)bVar20 * -2 + 1;\n            pcVar8 \u003d pcVar8 + (ulong)bVar20 * -2 + 1;\n          }\n          pcVar7[*(byte *)(lVar12 + 0x1e)] \u003d \u0027\\0\u0027;\n        }\n        goto LAB_00102980;\n      }\n      iVar4 \u003d filename_cmp(__s,pcVar8);\n      if (iVar4 \u003d\u003d 0) goto LAB_00102993;\nLAB_00105639:\n      ppcVar18 \u003d ppcVar15 + 0x1e;\n      ppcVar15 \u003d (char **)ppcVar15[0x1e];\n      if (ppcVar15 \u003d\u003d (char **)0x0) goto LAB_0010564c;\n      goto LAB_001055d8;\n    }\n    pcVar7 \u003d *param_2;\n    pcVar10 \u003d *ppcVar15;\nLAB_00102980:\n    iVar4 \u003d filename_cmp(pcVar7,pcVar10);\n    if (iVar4 !\u003d 0) goto LAB_00105639;\nLAB_00102993:\n    if (ppcVar15[0x1c] \u003d\u003d (char *)0x0) goto LAB_00105639;\n    if (_DAT_0010d644 !\u003d 0) {\n      iVar4 \u003d stat(*param_2,\u0026sStack_c8);\n      if (iVar4 !\u003d 0) {\n        piVar6 \u003d __errno_location();\n        if (*piVar6 !\u003d 2) {\n          FUN_00107c10(*param_2);\nLAB_00102b7e:\n          pcVar10 \u003d *ppcVar15;\n          uVar13 \u003d dcgettext(0,\"internal stat error on %s\",5);\n          FUN_00107690(uVar13,pcVar10);\n          free(param_2);\n          return 0;\n        }\n        goto LAB_0010577e;\n      }\n      ppcVar16 \u003d (char **)ppcVar15[0x1d];\n      if ((char **)ppcVar15[0x1d] \u003d\u003d (char **)0x0) {\n        ppcVar16 \u003d ppcVar15;\n      }\n      iVar4 \u003d (**(code **)(ppcVar16[1] + 0x1e8))(ppcVar15,auStack_158);\n      if (iVar4 !\u003d 0) goto LAB_00102b7e;\n      if (sStack_c8.st_mtim.tv_sec \u003c\u003d lStack_100) goto LAB_0010577e;\n    }\n    uVar13 \u003d FUN_00105870(ppcVar1,2,*ppcVar15);\n    if (DAT_0010d620 \u003d\u003d 0) {\nLAB_00102ae2:\n      pcVar10 \u003d *param_2;\n      bVar19 \u003d DAT_0010d60c !\u003d 0;\n      lVar12 \u003d bfd_openr(pcVar10,DAT_0010d5f0);\n      if (lVar12 \u003d\u003d 0) {\n        FUN_00107c10(pcVar10,0);\n        goto LAB_00102b3e;\n      }\n      bVar3 \u003d FUN_00103172(uVar13,lVar12,bVar19);\n    }\n    else {\n      uVar9 \u003d FUN_00105830(*param_2,param_1);\n      iVar4 \u003d filename_cmp(uVar9,\"__.LIBDEP\");\n      if (iVar4 !\u003d 0) goto LAB_00102ae2;\nLAB_00102b3e:\n      bVar3 \u003d FUN_00103172(uVar13,DAT_0010d620,DAT_0010d60c !\u003d 0);\n    }\n    if (bVar3 !\u003d 0) {\n      *ppcVar18 \u003d *(char **)(*ppcVar18 + 0xf0);\n      local_15a \u003d bVar3;\n    }\nLAB_0010577e:\n    param_2 \u003d param_2 + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "FUN_00102943"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001057a0": {
      "entrypoint": "0x001057a0",
      "current_name": "FUN_001057a0",
      "code": "\nundefined  [16] FUN_001057a0(char *param_1,int *param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  int iVar1;\n  char *pcVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  char *pcVar6;\n  byte bVar7;\n  undefined auVar8 [16];\n  \n  bVar7 \u003d 0;\n  pcVar2 \u003d strrchr(param_1,0x2f);\n  if (pcVar2 \u003d\u003d (char *)0x0) {\n    pcVar2 \u003d (char *)xmalloc(9);\n    lVar3 \u003d 0;\n  }\n  else {\n    lVar5 \u003d (long)pcVar2 - (long)param_1;\n    pcVar2 \u003d (char *)xmalloc(lVar5 + 0xb);\n    lVar3 \u003d lVar5 + 1;\n    pcVar6 \u003d pcVar2;\n    for (lVar4 \u003d lVar5; lVar4 !\u003d 0; lVar4 \u003d lVar4 + -1) {\n      *pcVar6 \u003d *param_1;\n      param_1 \u003d param_1 + (ulong)bVar7 * -2 + 1;\n      pcVar6 \u003d pcVar6 + (ulong)bVar7 * -2 + 1;\n    }\n    pcVar2[lVar5] \u003d \u0027/\u0027;\n  }\n  *(undefined8 *)(pcVar2 + lVar3) \u003d 0x5858585858587473;\n  *(undefined *)((long)(pcVar2 + lVar3) + 8) \u003d 0;\n  iVar1 \u003d mkstemp(pcVar2);\n  if (iVar1 \u003d\u003d -1) {\n    pcVar6 \u003d (char *)0x0;\n    free(pcVar2);\n  }\n  else {\n    *param_2 \u003d iVar1;\n    pcVar6 \u003d pcVar2;\n  }\n  auVar8._8_8_ \u003d param_4;\n  auVar8._0_8_ \u003d pcVar6;\n  return auVar8;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103c60",
        "FUN_001058b0"
      ],
      "called": [
        "strrchr",
        "FUN_00102ba1",
        "xmalloc",
        "mkstemp"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105830": {
      "entrypoint": "0x00105830",
      "current_name": "FUN_00105830",
      "code": "\nundefined  [16] FUN_00105830(char *param_1,long param_2,undefined8 param_3,undefined8 param_4)\n\n{\n  long lVar1;\n  size_t sVar2;\n  char *__s;\n  ulong uVar3;\n  char *pcVar4;\n  byte bVar5;\n  undefined auVar6 [16];\n  \n  bVar5 \u003d 0;\n  if (DAT_0010d5f9 \u003d\u003d \u0027\\0\u0027) {\n    __s \u003d (char *)lbasename();\n    param_1 \u003d __s;\n    if ((DAT_0010d5fa !\u003d \u0027\\0\u0027) \u0026\u0026 (param_2 !\u003d 0)) {\n      sVar2 \u003d strlen(__s);\n      uVar3 \u003d (ulong)*(byte *)(*(long *)(param_2 + 8) + 0x1e);\n      if (uVar3 \u003c sVar2) {\n        param_1 \u003d (char *)xmalloc(uVar3 + 1);\n        lVar1 \u003d *(long *)(param_2 + 8);\n        pcVar4 \u003d param_1;\n        for (uVar3 \u003d (ulong)*(byte *)(lVar1 + 0x1e); uVar3 !\u003d 0; uVar3 \u003d uVar3 - 1) {\n          *pcVar4 \u003d *__s;\n          __s \u003d __s + (ulong)bVar5 * -2 + 1;\n          pcVar4 \u003d pcVar4 + (ulong)bVar5 * -2 + 1;\n        }\n        param_1[*(byte *)(lVar1 + 0x1e)] \u003d \u0027\\0\u0027;\n      }\n    }\n  }\n  auVar6._8_8_ \u003d param_4;\n  auVar6._0_8_ \u003d param_1;\n  return auVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00105480",
        "FUN_00105db0"
      ],
      "called": [
        "FUN_00102bb0",
        "lbasename"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105870": {
      "entrypoint": "0x00105870",
      "current_name": "FUN_00105870",
      "code": "\nlong * FUN_00105870(long *param_1,int param_2,undefined8 param_3)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  int iVar3;\n  \n  uVar2 \u003d DAT_0010d638;\n  iVar3 \u003d DAT_0010d640;\n  if (DAT_0010d640 \u003d\u003d 0) {\n    uVar2 \u003d param_3;\n    iVar3 \u003d param_2;\n  }\n  if (iVar3 \u003d\u003d 3) {\n    for (; *param_1 !\u003d 0; param_1 \u003d (long *)(*param_1 + 0xf0)) {\n    }\n  }\n  else {\n    for (; (undefined8 *)*param_1 !\u003d (undefined8 *)0x0; param_1 \u003d (long *)(*param_1 + 0xf0)) {\n      iVar1 \u003d filename_cmp(*(undefined8 *)*param_1,uVar2);\n      if (iVar1 \u003d\u003d 0) {\n        if (iVar3 !\u003d 2) {\n          return param_1;\n        }\n        return (long *)(*param_1 + 0xf0);\n      }\n    }\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00105db0"
      ],
      "called": [
        "FUN_00102cd9"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001058b0": {
      "entrypoint": "0x001058b0",
      "current_name": "FUN_001058b0",
      "code": "\n\n\nvoid FUN_001058b0(undefined8 *param_1)\n\n{\n  char cVar1;\n  uint uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  char *__format;\n  void *__ptr;\n  FILE *__stream;\n  char **ppcVar5;\n  uint uStack0000000000000020;\n  uint in_stack_00000028;\n  undefined8 in_stack_00000038;\n  int local_3c [2];\n  undefined uStack_33;\n  char cStack_32;\n  char cStack_31;\n  \n  uVar4 \u003d param_1[0x1e];\n  local_3c[0] \u003d -1;\n  __ptr \u003d (void *)xstrdup(*param_1);\n  __stream \u003d (FILE *)FUN_001057a0(__ptr,local_3c);\n  iVar3 \u003d local_3c[0];\n  if (__stream !\u003d (FILE *)0x0) {\n    DAT_0010d618 \u003d __stream;\n    ppcVar5 \u003d (char **)bfd_fdopenw(__stream,*(undefined8 *)param_1[1],local_3c[0]);\n    if (ppcVar5 !\u003d (char **)0x0) {\n      DAT_0010d5e0 \u003d ppcVar5;\n      bfd_set_format(ppcVar5,2);\n      uVar2 \u003d (~DAT_0010d648 \u003e\u003e 0x1f) \u003c\u003c 3 | *(byte *)((long)ppcVar5 + 0x49) \u0026 0xfffffff7;\n      *(char *)((long)ppcVar5 + 0x49) \u003d (char)uVar2;\n      if (DAT_0010d5fa !\u003d \u0027\\0\u0027) {\n        *(uint *)((long)ppcVar5 + 0x44) \u003d *(uint *)((long)ppcVar5 + 0x44) | 0x400;\n      }\n      if (_DAT_0010d2d0 !\u003d 0) {\n        *(uint *)((long)ppcVar5 + 0x44) \u003d *(uint *)((long)ppcVar5 + 0x44) | 0x2000;\n      }\n      if (DAT_0010d5f9 !\u003d \u0027\\0\u0027) goto LAB_00102d37;\n      while( true ) {\n        if ((DAT_0010d5f8 !\u003d \u0027\\0\u0027) || ((*(byte *)((long)param_1 + 0x49) \u0026 0x10) !\u003d 0)) {\n          *(byte *)((long)ppcVar5 + 0x49) \u003d (byte)uVar2 | 0x10;\n        }\n        cVar1 \u003d bfd_set_archive_head(ppcVar5,uVar4);\n        if (cVar1 !\u003d \u0027\\0\u0027) break;\n        uVar2 \u003d FUN_00107c10(__ptr);\nLAB_00102d37:\n        *(uint *)((long)ppcVar5 + 0x44) \u003d *(uint *)((long)ppcVar5 + 0x44) | 0x100000;\n      }\n      iVar3 \u003d dup(iVar3);\n      cVar1 \u003d bfd_close(ppcVar5);\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        FUN_00107c10(__ptr);\n        __format \u003d (char *)dcgettext(0,\"\u003ctime data corrupt\u003e\",5);\n        sprintf(\u0026stack0xffffffffffffffd8,__format);\n        uVar2 \u003d uStack0000000000000020 \u0026 0xf000;\n        if (uVar2 \u003d\u003d 0x4000) {\n          uStack_33 \u003d 100;\n        }\n        else if (uVar2 \u003d\u003d 0xa000) {\n          uStack_33 \u003d 0x6c;\n        }\n        else if (uVar2 \u003d\u003d 0x6000) {\n          uStack_33 \u003d 0x62;\n        }\n        else if (uVar2 \u003d\u003d 0x2000) {\n          uStack_33 \u003d 99;\n        }\n        else if (uVar2 \u003d\u003d 0xc000) {\n          uStack_33 \u003d 0x73;\n        }\n        else {\n          uStack_33 \u003d 0x70;\n          if (uVar2 !\u003d 0x1000) {\n            uStack_33 \u003d 0x2d;\n          }\n        }\n        cStack_32 \u003d (-((_uStack0000000000000020 \u0026 0x100) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n        cStack_31 \u003d (-((_uStack0000000000000020 \u0026 0x80) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n        fprintf(__stream,\"%s %ld/%ld %6lu %s \",\u0026cStack_32,_uStack0000000000000020 \u003e\u003e 0x20,\n                (ulong)in_stack_00000028,in_stack_00000038,\u0026stack0xffffffffffffffd8,\n                _uStack0000000000000020 \u0026 0xffffffff);\n        fputs(*ppcVar5,__stream);\n        if ((char)param_1 !\u003d \u0027\\0\u0027) {\n          if ((*(byte *)((long)ppcVar5 + 0x49) \u0026 0x10) \u003d\u003d 0) {\n            if (ppcVar5[0xb] !\u003d (char *)0x0) {\n              fprintf(__stream,\" 0x%lx\");\n            }\n          }\n          else if (ppcVar5[0xc] !\u003d (char *)0x0) {\n            fprintf(__stream,\" 0x%lx\");\n          }\n        }\n        fputc(10,__stream);\n        return;\n      }\n      DAT_0010d5e0 \u003d (char **)0x0;\n      DAT_0010d618 \u003d (FILE *)0x0;\n      bfd_close(param_1);\n      iVar3 \u003d FUN_00105bc0(__stream,__ptr,iVar3);\n      if (iVar3 \u003d\u003d 0) {\n        free(__ptr);\n        free(__stream);\n        return;\n      }\n      goto LAB_00102d7a;\n    }\n    close(iVar3);\n    FUN_00107c10(__ptr);\n  }\n  uVar4 \u003d dcgettext(0,\"could not create temporary file whilst writing archive\",5);\n  FUN_00107c10(uVar4);\nLAB_00102d7a:\n                    \n  xexit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00107650",
        "FUN_00105db0"
      ],
      "called": [
        "FUN_001057a0",
        "bfd_set_format",
        "FUN_00107c10",
        "dcgettext",
        "close",
        "bfd_fdopenw",
        "xstrdup"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105a20": {
      "entrypoint": "0x00105a20",
      "current_name": "FUN_00105a20",
      "code": "\nvoid FUN_00105a20(char *param_1)\n\n{\n  char *pcVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  FILE *pFVar5;\n  size_t sVar6;\n  \n  pcVar1 \u003d DAT_0010d5e8;\n  DAT_0010d618 \u003d param_1;\n  if (*param_1 \u003d\u003d \u0027/\u0027) {\nLAB_00102e9a:\n    uVar3 \u003d lbasename();\n    pcVar1 \u003d DAT_0010d618;\n    uVar4 \u003d dcgettext(0,\"illegal output pathname for archive member: %s, using \\\u0027%s\\\u0027 instead\",5);\n    FUN_00107920(uVar4,pcVar1,uVar3);\n    DAT_0010d618 \u003d (char *)uVar3;\n    FUN_00105a68();\n    return;\n  }\n  do {\n    if (*param_1 \u003d\u003d \u0027\\0\u0027) {\n      if ((DAT_0010d5e8 !\u003d (char *)0x0) \u0026\u0026 (sVar6 \u003d strlen(DAT_0010d5e8), sVar6 !\u003d 0)) {\n        if (pcVar1[sVar6 - 1] \u003d\u003d \u0027/\u0027) {\n          DAT_0010d618 \u003d (char *)concat(pcVar1,DAT_0010d618,0);\n        }\n        else {\n          DAT_0010d618 \u003d (char *)concat(pcVar1,\u0026DAT_00108260,DAT_0010d618,0);\n        }\n      }\n      if (DAT_0010d60c !\u003d 0) {\n        printf(\"x - %s\\n\",DAT_0010d618);\n      }\n      pFVar5 \u003d fopen(DAT_0010d618,\"w\");\n      if (pFVar5 \u003d\u003d (FILE *)0x0) {\n        perror(DAT_0010d618);\n                    \n        xexit(1);\n      }\n      return;\n    }\n    pcVar2 \u003d param_1;\n    if ((*param_1 \u003d\u003d \u0027.\u0027) \u0026\u0026 (pcVar2 \u003d param_1 + 1, param_1[1] \u003d\u003d \u0027.\u0027)) {\n      pcVar2 \u003d param_1 + 2;\n      if ((param_1[2] \u003d\u003d \u0027/\u0027) || (param_1[2] \u003d\u003d \u0027\\0\u0027)) goto LAB_00102e9a;\n    }\n    for (; (*pcVar2 !\u003d \u0027\\0\u0027 \u0026\u0026 (*pcVar2 !\u003d \u0027/\u0027)); pcVar2 \u003d pcVar2 + 1) {\n    }\n    for (; param_1 \u003d pcVar2, *pcVar2 \u003d\u003d \u0027/\u0027; pcVar2 \u003d pcVar2 + 1) {\n    }\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102c25"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105a68": {
      "entrypoint": "0x00105a68",
      "current_name": "FUN_00105a68",
      "code": "\nvoid FUN_00105a68(void)\n\n{\n  char *pcVar1;\n  FILE *pFVar2;\n  size_t sVar3;\n  \n  pcVar1 \u003d DAT_0010d5e8;\n  if (DAT_0010d5e8 !\u003d (char *)0x0) {\n    sVar3 \u003d strlen(DAT_0010d5e8);\n    if (sVar3 !\u003d 0) {\n      if (pcVar1[sVar3 - 1] \u003d\u003d \u0027/\u0027) {\n        DAT_0010d618 \u003d (char *)concat(pcVar1,DAT_0010d618,0);\n      }\n      else {\n        DAT_0010d618 \u003d (char *)concat(pcVar1,\u0026DAT_00108260,DAT_0010d618,0);\n      }\n    }\n  }\n  if (DAT_0010d60c !\u003d 0) {\n    printf(\"x - %s\\n\",DAT_0010d618);\n  }\n  pFVar2 \u003d fopen(DAT_0010d618,\"w\");\n  if (pFVar2 !\u003d (FILE *)0x0) {\n    return;\n  }\n  perror(DAT_0010d618);\n                    \n  xexit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102e6f"
      ],
      "called": [
        "xexit",
        "FUN_00102e57",
        "perror",
        "strlen",
        "fopen",
        "concat",
        "printf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105ae0": {
      "entrypoint": "0x00105ae0",
      "current_name": "FUN_00105ae0",
      "code": "\nvoid FUN_00105ae0(undefined8 param_1,undefined8 param_2,undefined param_3,undefined param_4)\n\n{\n  FUN_00105af0(param_1,param_2,param_3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed"
      ],
      "called": [
        "FUN_00105af0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105af0": {
      "entrypoint": "0x00105af0",
      "current_name": "FUN_00105af0",
      "code": "\nulong FUN_00105af0(long *param_1,long param_2,char param_3,char param_4)\n\n{\n  char cVar1;\n  uint uVar2;\n  long lVar3;\n  ulong uVar4;\n  \n  if (param_4 \u003d\u003d \u0027\\0\u0027) {\n    if (param_3 !\u003d \u0027\\0\u0027) {\n      uVar4 \u003d FUN_00102f08();\n      return uVar4;\n    }\n  }\n  else {\n    cVar1 \u003d bfd_check_format(param_2,2);\n    if (cVar1 !\u003d \u0027\\0\u0027) {\n      uVar4 \u003d 0;\n      for (lVar3 \u003d bfd_openr_next_archived_file(param_2,0); lVar3 !\u003d 0;\n          lVar3 \u003d bfd_openr_next_archived_file(param_2,lVar3)) {\n        uVar2 \u003d FUN_00105af0(param_1,lVar3,param_3,1);\n        if ((char)uVar2 !\u003d \u0027\\0\u0027) {\n          uVar4 \u003d (ulong)uVar2;\n          param_1 \u003d (long *)(*param_1 + 0xf0);\n        }\n      }\n      return uVar4;\n    }\n    if (param_3 !\u003d \u0027\\0\u0027) {\n      uVar4 \u003d FUN_00102f08();\n      return uVar4;\n    }\n  }\n  *(long *)(param_2 + 0xf0) \u003d *param_1;\n  *param_1 \u003d param_2;\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00105af0",
        "FUN_00105ae0"
      ],
      "called": [
        "bfd_check_format",
        "FUN_00105af0",
        "FUN_00102f08",
        "bfd_openr_next_archived_file"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105bb0": {
      "entrypoint": "0x00105bb0",
      "current_name": "FUN_00105bb0",
      "code": "\nundefined8 FUN_00105bb0(void)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105bc0": {
      "entrypoint": "0x00105bc0",
      "current_name": "FUN_00105bc0",
      "code": "\nundefined  [16] FUN_00105bc0(char *param_1,char *param_2,undefined4 param_3,undefined8 param_4)\n\n{\n  uint uVar1;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  ulong uVar5;\n  undefined auVar6 [16];\n  \n  if (param_2 \u003d\u003d param_1) {\n    uVar5 \u003d 0;\n  }\n  else {\n    uVar1 \u003d FUN_00105c00(param_3);\n    uVar5 \u003d (ulong)uVar1;\n    if (uVar1 !\u003d 0) {\n      piVar2 \u003d __errno_location();\n      pcVar3 \u003d strerror(*piVar2);\n      uVar4 \u003d dcgettext(0,\"unable to copy file \\\u0027%s\\\u0027; reason: %s\",5);\n      FUN_00107920(uVar4,param_2,pcVar3);\n    }\n    unlink(param_1);\n  }\n  auVar6._8_8_ \u003d param_4;\n  auVar6._0_8_ \u003d uVar5;\n  return auVar6;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00102d2f"
      ],
      "called": [
        "FUN_00105c00",
        "FUN_00102f1e"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105c00": {
      "entrypoint": "0x00105c00",
      "current_name": "FUN_00105c00",
      "code": "\nulong FUN_00105c00(int param_1,char *param_2)\n\n{\n  int iVar1;\n  int __fd;\n  int iVar2;\n  __off_t _Var3;\n  ulong uVar4;\n  size_t sVar5;\n  int *piVar6;\n  undefined auStack_2038 [8200];\n  \n  if ((-1 \u003c param_1) \u0026\u0026 (_Var3 \u003d lseek(param_1,0,0), _Var3 \u003d\u003d 0)) {\n    __fd \u003d open(param_2,0x201);\n    if (__fd \u003c 0) {\n      uVar4 \u003d FUN_00102f55();\n      return uVar4;\n    }\n    do {\n      uVar4 \u003d read(param_1,auStack_2038,0x2000);\n      iVar2 \u003d (int)uVar4;\n      if (iVar2 \u003c 1) {\n        piVar6 \u003d __errno_location();\n        iVar1 \u003d *piVar6;\n        close(param_1);\n        close(__fd);\n        if (iVar2 !\u003d 0) {\n          *piVar6 \u003d iVar1;\n          return 0xffffffff;\n        }\n        return uVar4 \u0026 0xffffffff;\n      }\n      sVar5 \u003d write(__fd,auStack_2038,(long)iVar2);\n    } while (sVar5 \u003d\u003d (long)iVar2);\n    piVar6 \u003d __errno_location();\n    iVar2 \u003d *piVar6;\n    close(param_1);\n    close(__fd);\n    *piVar6 \u003d iVar2;\n  }\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105bc0"
      ],
      "called": [
        "open",
        "read",
        "FUN_00102f55",
        "lseek",
        "write",
        "close",
        "__errno_location"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "entry": {
      "entrypoint": "0x00105cc0",
      "current_name": "entry",
      "code": "\nvoid processEntry entry(undefined8 param_1,undefined8 param_2)\n\n{\n  undefined auStack_8 [8];\n  \n  __libc_start_main(FUN_00105db0,param_2,\u0026stack0x00000008,0,0,param_1,auStack_8);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__libc_start_main",
        "FUN_00105db0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105cf0": {
      "entrypoint": "0x00105cf0",
      "current_name": "FUN_00105cf0",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d03) */\n/* WARNING: Removing unreachable block (ram,0x00105d0f) */\n\nvoid FUN_00105cf0(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_FINI_0"
      ],
      "called": [
        "_ITM_deregisterTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105d20": {
      "entrypoint": "0x00105d20",
      "current_name": "FUN_00105d20",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00105d44) */\n/* WARNING: Removing unreachable block (ram,0x00105d50) */\n\nvoid FUN_00105d20(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_INIT_0"
      ],
      "called": [
        "_ITM_registerTMCloneTable"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_FINI_0": {
      "entrypoint": "0x00105d60",
      "current_name": "_FINI_0",
      "code": "\nvoid _FINI_0(void)\n\n{\n  if (DAT_0010d400 !\u003d \u0027\\0\u0027) {\n    return;\n  }\n  __cxa_finalize(PTR_LOOP_0010d2c8);\n  FUN_00105cf0();\n  DAT_0010d400 \u003d 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__cxa_finalize",
        "FUN_00105cf0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_INIT_0": {
      "entrypoint": "0x00105da0",
      "current_name": "_INIT_0",
      "code": "\nvoid _INIT_0(void)\n\n{\n  FUN_00105d20();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "FUN_00105d20"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00105db0": {
      "entrypoint": "0x00105db0",
      "current_name": "FUN_00105db0",
      "code": "\n\n\nvoid FUN_00105db0(uint param_1,FILE *param_2)\n\n{\n  byte *pbVar1;\n  uint *puVar2;\n  byte bVar3;\n  long *plVar4;\n  undefined8 *puVar5;\n  undefined4 uVar6;\n  undefined4 uVar7;\n  bool bVar8;\n  bool bVar9;\n  char **ppcVar10;\n  int *piVar11;\n  undefined *puVar12;\n  byte bVar13;\n  char cVar14;\n  int iVar15;\n  uint uVar16;\n  undefined4 uVar17;\n  FILE *pFVar18;\n  size_t sVar19;\n  size_t sVar20;\n  byte *__ptr;\n  long *plVar21;\n  FILE *pFVar22;\n  char *pcVar23;\n  long lVar24;\n  ulong uVar25;\n  undefined8 *puVar26;\n  undefined8 uVar27;\n  FILE *pFVar28;\n  long **pplVar29;\n  undefined8 uVar30;\n  char **ppcVar31;\n  uint extraout_EDX;\n  char **ppcVar32;\n  byte *pbVar33;\n  long lVar34;\n  long lVar35;\n  undefined **ppuVar36;\n  uint uVar37;\n  char *unaff_RBP;\n  byte *pbVar38;\n  char *pcVar39;\n  ulong uVar40;\n  ulong uVar41;\n  ulong uVar42;\n  FILE *unaff_R12;\n  char *pcVar43;\n  uint uVar44;\n  int iVar45;\n  char *pcVar46;\n  bool bVar47;\n  byte bVar48;\n  undefined8 local_130;\n  FILE *local_128;\n  byte *local_118;\n  char **local_110;\n  size_t local_108;\n  long local_100;\n  undefined local_c8 [2];\n  undefined uStack_c6;\n  undefined5 uStack_c5;\n  uint local_b0;\n  \n  bVar48 \u003d 0;\n  pcVar46 \u003d (char *)(ulong)param_1;\n  setlocale(5,\"\");\n  setlocale(0,\"\");\n  bindtextdomain(\"binutils\",\"/usr/share/locale\");\n  textdomain(\"binutils\");\n  DAT_0010d660 \u003d *(long **)param_2;\n  xmalloc_set_program_name();\n  bfd_set_error_program_name(DAT_0010d660);\n  bfd_plugin_set_program_name(DAT_0010d660);\n  pcVar43 \u003d (char *)param_2;\n  pFVar18 \u003d param_2;\n  if ((int)param_1 \u003c 2) goto LAB_001062c6;\n  local_110 \u003d (char **)0x7d0;\n  unaff_R12 \u003d (FILE *)0x1;\n  local_128 \u003d (FILE *)0x0;\n  pFVar22 \u003d param_2;\n  do {\n    uVar16 \u003d (uint)unaff_R12;\n    unaff_RBP \u003d (char *)(long)(int)uVar16;\n    local_130 \u003d (FILE *)((long)unaff_RBP * 8);\n    pcVar43 \u003d (char *)pFVar22;\n    if (**(char **)(\u0026pFVar22-\u003e_flags + (long)unaff_RBP * 2) \u003d\u003d \u0027@\u0027) {\n      uVar44 \u003d (int)local_110 - 1;\n      local_110 \u003d (char **)(ulong)uVar44;\n      if (uVar44 \u003d\u003d 0) {\n        plVar21 \u003d *(long **)pFVar22;\n        pcVar46 \u003d \"%s: error: too many @-files encountered\\n\";\nLAB_00106ffe:\n        fprintf(_stderr,pcVar46,plVar21);\nLAB_0010700f:\n                    \n        xexit(1);\n      }\n      pcVar39 \u003d *(char **)(\u0026pFVar22-\u003e_flags + (long)unaff_RBP * 2) + 1;\n      iVar15 \u003d stat(pcVar39,(stat *)local_c8);\n      if (-1 \u003c iVar15) {\n        if ((local_b0 \u0026 0xf000) \u003d\u003d 0x4000) {\n          plVar21 \u003d *(long **)pFVar22;\n          pcVar46 \u003d \"%s: error: @-file refers to a directory\\n\";\n          goto LAB_00106ffe;\n        }\n        pFVar18 \u003d fopen(pcVar39,\"r\");\n        if (pFVar18 !\u003d (FILE *)0x0) {\n          iVar15 \u003d fseek(pFVar18,0,2);\n          if (((iVar15 !\u003d -1) \u0026\u0026 (sVar19 \u003d ftell(pFVar18), sVar19 !\u003d 0xffffffffffffffff)) \u0026\u0026\n             (iVar15 \u003d fseek(pFVar18,0,0), iVar15 !\u003d -1)) {\n            local_118 \u003d (byte *)xmalloc(sVar19 + 1);\n            sVar20 \u003d fread(local_118,1,sVar19,pFVar18);\n            if ((sVar19 \u003d\u003d sVar20) || (iVar15 \u003d ferror(pFVar18), iVar15 \u003d\u003d 0)) {\n              local_118[sVar20] \u003d 0;\n              bVar13 \u003d *local_118;\n              pbVar33 \u003d local_118;\n              while( true ) {\n                if (bVar13 \u003d\u003d 0) goto LAB_00106814;\n                if (((\u0026_sch_istable)[(ulong)bVar13 * 2] \u0026 0x40) \u003d\u003d 0) break;\n                bVar13 \u003d pbVar33[1];\n                pbVar33 \u003d pbVar33 + 1;\n              }\n              sVar19 \u003d strlen((char *)local_118);\n              __ptr \u003d (byte *)xmalloc(sVar19 + 1);\n              pFVar28 \u003d (FILE *)0x0;\n              iVar15 \u003d 0;\n              bVar9 \u003d false;\n              bVar47 \u003d false;\n              bVar8 \u003d false;\n              local_100 \u003d 0;\n              pbVar33 \u003d local_118;\n              do {\n                while (((\u0026_sch_istable)[(ulong)*pbVar33 * 2] \u0026 0x40) !\u003d 0) {\n                  pbVar33 \u003d pbVar33 + 1;\n                }\n                if ((iVar15 \u003d\u003d 0) || (iVar15 + -1 \u003c\u003d (int)local_100)) {\n                  if (pFVar28 \u003d\u003d (FILE *)0x0) {\n                    iVar15 \u003d 8;\n                    pFVar28 \u003d (FILE *)xmalloc(0x40);\n                    ppcVar31 \u003d (char **)((long)\u0026pFVar28-\u003e_flags + local_100 * 8);\n                    *ppcVar31 \u003d (char *)0x0;\n                  }\n                  else {\n                    iVar15 \u003d iVar15 * 2;\n                    pFVar28 \u003d (FILE *)xrealloc(pFVar28,(long)iVar15 \u003c\u003c 3);\n                    ppcVar31 \u003d (char **)((long)\u0026pFVar28-\u003e_flags + local_100 * 8);\n                    *ppcVar31 \u003d (char *)0x0;\n                  }\n                }\n                else {\n                  ppcVar31 \u003d (char **)((long)\u0026pFVar28-\u003e_flags + local_100 * 8);\n                }\n                bVar13 \u003d *pbVar33;\n                pbVar38 \u003d __ptr;\n                while (bVar13 !\u003d 0) {\n                  while( true ) {\n                    if ((((\u0026_sch_istable)[(ulong)bVar13 * 2] \u0026 0x40) !\u003d 0) \u0026\u0026\n                       (!(bool)(bVar9 | bVar8 | bVar47))) {\n                      bVar8 \u003d false;\n                      bVar9 \u003d false;\n                      bVar47 \u003d false;\n                      goto LAB_0010606f;\n                    }\n                    if (!bVar8) break;\n                    pbVar33 \u003d pbVar33 + 1;\n                    *pbVar38 \u003d bVar13;\n                    pbVar38 \u003d pbVar38 + 1;\n                    bVar8 \u003d false;\n                    bVar13 \u003d *pbVar33;\n                    if (bVar13 \u003d\u003d 0) goto LAB_0010606f;\n                  }\n                  if (bVar13 \u003d\u003d 0x5c) {\n                    bVar8 \u003d true;\n                  }\n                  else if (bVar47) {\n                    if (bVar13 \u003d\u003d 0x27) {\n                      bVar47 \u003d false;\n                    }\n                    else {\nLAB_001061f1:\n                      *pbVar38 \u003d bVar13;\n                      pbVar38 \u003d pbVar38 + 1;\n                    }\n                  }\n                  else if (bVar9) {\n                    if (bVar13 !\u003d 0x22) goto LAB_001061f1;\n                    bVar9 \u003d false;\n                  }\n                  else if (bVar13 \u003d\u003d 0x27) {\n                    bVar47 \u003d true;\n                  }\n                  else {\n                    if (bVar13 !\u003d 0x22) goto LAB_001061f1;\n                    bVar9 \u003d true;\n                  }\n                  pbVar1 \u003d pbVar33 + 1;\n                  pbVar33 \u003d pbVar33 + 1;\n                  bVar13 \u003d *pbVar1;\n                }\nLAB_0010606f:\n                *pbVar38 \u003d 0;\n                plVar21 \u003d (long *)xstrdup(__ptr);\n                *ppcVar31 \u003d (char *)plVar21;\n                *(undefined8 *)(pFVar28-\u003e_shortbuf + local_100 * 8 + -0x7b) \u003d 0;\n                bVar13 \u003d *pbVar33;\n                bVar3 \u003d (\u0026_sch_istable)[(ulong)bVar13 * 2];\n                while ((bVar3 \u0026 0x40) !\u003d 0) {\n                  bVar13 \u003d pbVar33[1];\n                  pbVar33 \u003d pbVar33 + 1;\n                  bVar3 \u003d (\u0026_sch_istable)[(ulong)bVar13 * 2];\n                }\n                local_100 \u003d local_100 + 1;\n                if (bVar13 \u003d\u003d 0) {\n                  free(__ptr);\n                  if (pFVar22 \u003d\u003d param_2) goto LAB_00106834;\n                  goto LAB_0010610a;\n                }\n              } while( true );\n            }\n            free(local_118);\n          }\n          fclose(pFVar18);\n        }\n      }\n    }\n    if ((int)pcVar46 \u003c\u003d (int)(uVar16 + 1)) {\nLAB_001062c6:\n      do {\n        if (_DAT_0010d65c \u003c 0) goto LAB_001073cc;\nLAB_001062d3:\n        uVar16 \u003d (uint)unaff_R12;\n        iVar15 \u003d bfd_init();\n        pcVar39 \u003d \"fatal error: libbfd ABI mismatch\";\n        if (iVar15 !\u003d 0x118) goto LAB_00106803;\n        pcVar39 \u003d \"x86_64-pc-linux-gnu\";\n        uVar16 \u003d bfd_set_default_target(\"x86_64-pc-linux-gnu\",\"fatal error: libbfd ABI mismatch\",5);\n        puVar12 \u003d PTR_DAT_0010d2e0;\n        unaff_R12 \u003d (FILE *)(ulong)uVar16;\n        if ((char)uVar16 !\u003d \u0027\\0\u0027) {\n          if (__xexit_cleanup \u003d\u003d (code *)0x0) {\n            __xexit_cleanup \u003d FUN_00107cc0;\n          }\n          if (*(int *)(PTR_DAT_0010d2e0 + 8) \u003c 0x20) {\nLAB_0010632b:\n            puVar12 \u003d PTR_DAT_0010d2e0;\n            iVar15 \u003d *(int *)(PTR_DAT_0010d2e0 + 8);\n            *(int *)(PTR_DAT_0010d2e0 + 8) \u003d iVar15 + 1;\n            *(code **)(puVar12 + (long)iVar15 * 8 + 0x10) \u003d FUN_00107730;\n          }\n          else {\n            puVar26 \u003d (undefined8 *)malloc(0x110);\n            if (puVar26 !\u003d (undefined8 *)0x0) {\n              *puVar26 \u003d puVar12;\n              *(undefined4 *)(puVar26 + 1) \u003d 0;\n              PTR_DAT_0010d2e0 \u003d (undefined *)puVar26;\n              goto LAB_0010632b;\n            }\n          }\n          lVar24 \u003d 1;\n          do {\n            lVar35 \u003d lVar24;\n            iVar15 \u003d (int)pcVar46;\n            if (iVar15 \u003c\u003d (int)lVar35) break;\n            cVar14 \u003d FUN_00107640(*(undefined8 *)((int *)pcVar43 + lVar35 * 2));\n            lVar24 \u003d lVar35 + 1;\n          } while (cVar14 !\u003d \u0027\\0\u0027);\n          pcVar46 \u003d (char *)((long)pcVar43 + lVar35 * 8 + -8);\n          uVar44 \u003d iVar15 - ((int)lVar35 + -1);\n          pFVar18 \u003d (FILE *)(ulong)uVar44;\n          if (_DAT_0010d65c !\u003d 0) {\n            pcVar43 \u003d \"DhHUvVt\";\n            uVar37 \u003d 0;\n            while (iVar15 \u003d getopt_long(pFVar18,pcVar46,\"DhHUvVt\",\u0026PTR_DAT_0010d300), iVar15 !\u003d -1)\n            {\n              if (iVar15 \u003c 0x77) {\n                if (0x43 \u003c iVar15) {\n                  switch(iVar15) {\n                  case 0x44:\n                    _DAT_0010d2d0 \u003d 1;\n                    break;\n                  case 0x48:\n                  case 0x68:\n                    _DAT_0010d658 \u003d 1;\n                    break;\n                  case 0x55:\n                    _DAT_0010d2d0 \u003d 0;\n                    break;\n                  case 0x56:\n                  case 0x76:\n                    _DAT_0010d654 \u003d 1;\n                    break;\n                  case 0x74:\n                    uVar37 \u003d uVar16;\n                  }\n                }\n              }\n              else if (iVar15 \u003d\u003d 0xc9) {\n                bfd_plugin_set_plugin(_optarg);\n              }\n            }\n            if ((int)uVar44 \u003c 2) {\nLAB_00107125:\n              pcVar39 \u003d (char *)0x0;\n              FUN_0010394a();\n            }\n            else {\n              if (_DAT_0010d658 !\u003d 0) {\nLAB_0010711b:\n                FUN_0010394a();\n                goto LAB_00107125;\n              }\n              if (_DAT_0010d654 !\u003d 0) {\n                FUN_001075e0(\"ranlib\");\n                goto LAB_0010711b;\n              }\n              if (_DAT_0010d2d0 \u003c 0) {\n                _DAT_0010d2d0 \u003d 1;\n              }\n              unaff_R12 \u003d (FILE *)0x0;\n              pcVar43 \u003d (char *)(long)_optind;\n              while( true ) {\n                if ((int)uVar44 \u003c\u003d (int)pcVar43) goto LAB_00106f8b;\n                pcVar39 \u003d *(char **)((int *)pcVar46 + (long)pcVar43 * 2);\n                if ((char)uVar37 !\u003d \u0027\\0\u0027) break;\n                uVar16 \u003d FUN_00107650();\n                pcVar43 \u003d (char *)((long)(int *)pcVar43 + 1);\n                unaff_R12 \u003d (FILE *)(ulong)((uint)unaff_R12 | uVar16);\n              }\n            }\n            while (lVar24 \u003d FUN_001052a0(pcVar39), lVar24 \u003c 1) {\n              uVar16 \u003d 1;\nLAB_001071c4:\n              piVar11 \u003d (int *)pcVar43;\n              pcVar43 \u003d (char *)((long)piVar11 + 1);\n              unaff_R12 \u003d (FILE *)(ulong)((uint)unaff_R12 | uVar16);\n              if ((int)uVar44 \u003c\u003d (int)pcVar43) {\nLAB_00106f8b:\n                    \n                xexit(unaff_R12);\n              }\n              pcVar39 \u003d *(char **)((char *)((long)pcVar46 + 0x83) + (long)piVar11 * 8 + -0x7b);\n            }\n            iVar15 \u003d open(pcVar39,2,0);\n            if (iVar15 \u003c 0) {\n              bfd_set_error(1);\n              FUN_00107c10(pcVar39);\nLAB_0010737f:\n              FUN_00107c10(pcVar39);\nLAB_00107387:\n              FUN_00107c20(pcVar39);\n              iVar15 \u003d bfd_get_error();\n              if (iVar15 \u003d\u003d 0xd) {\n                FUN_00103bd1(CONCAT53(uStack_c5,\n                                      CONCAT12(uStack_c6,CONCAT11(local_c8[1],local_c8[0]))));\n              }\n              goto LAB_0010700f;\n            }\n            unaff_RBP \u003d (char *)bfd_fdopenr(pcVar39,0);\n            if ((FILE *)unaff_RBP \u003d\u003d (FILE *)0x0) goto LAB_0010737f;\n            cVar14 \u003d bfd_check_format_matches(unaff_RBP,2,local_c8);\n            if (cVar14 \u003d\u003d \u0027\\0\u0027) goto LAB_00107387;\n            if ((*(byte *)((long)((long)unaff_RBP + 0x48) + 1) \u0026 8) !\u003d 0) {\n              if (_DAT_0010d2d0 !\u003d 0) {\n                puVar2 \u003d (uint *)((long)((long)unaff_RBP + 0x40) + 4);\n                *puVar2 \u003d *puVar2 | 0x2000;\n              }\n              (**(code **)(*(char **)((long)unaff_RBP + 8) + 0x1f0))(unaff_RBP);\n              cVar14 \u003d bfd_close(unaff_RBP);\n              if (cVar14 !\u003d \u0027\\0\u0027) {\n                uVar16 \u003d 0;\n                goto LAB_001071c4;\n              }\n              goto LAB_0010737f;\n            }\n            uVar27 \u003d dcgettext(0,\"%s: no archive map to update\",5);\n            FUN_00107690(uVar27,pcVar39);\nLAB_001073cc:\n            pcVar39 \u003d (char *)lbasename(DAT_0010d660);\n            sVar19 \u003d strlen(pcVar39);\n            if ((sVar19 \u003c 6) ||\n               (iVar15 \u003d filename_cmp(pcVar39 + (sVar19 - 6),\"ranlib\"), iVar15 !\u003d 0)) {\n              _DAT_0010d65c \u003d 0;\n            }\n            else {\n              _DAT_0010d65c \u003d 1;\n            }\n            goto LAB_001062d3;\n          }\n          ppuVar36 \u003d \u0026PTR_DAT_0010d300;\n          unaff_RBP \u003d \"hdmpqrtxl:coOVsSuvabiMNfPTDU\";\n          pcVar43 \u003d (char *)\u0026DAT_001096a0;\n          pFVar22 \u003d (FILE *)unaff_RBP;\n          pFVar28 \u003d pFVar18;\n          if ((int)uVar44 \u003c 2) goto switchD_00107462_caseD_1;\n          local_130 \u003d (FILE *)CONCAT71(local_130._1_7_,(char)uVar16);\nLAB_001063a3:\n          pFVar22 \u003d (FILE *)unaff_RBP;\n          if (**(char **)((long)pcVar46 + 8) !\u003d \u0027-\u0027) {\n            local_c8[0] \u003d 0x2d;\n            uStack_c6 \u003d 0;\n            sVar19 \u003d strlen(*(char **)((long)pcVar46 + 8));\n            iVar15 \u003d (int)sVar19 + (int)pFVar18;\n            unaff_R12 \u003d (FILE *)xmalloc((long)iVar15 * 8);\n            uVar17 \u003d *(undefined4 *)((long)pcVar46 + 4);\n            unaff_R12-\u003e_flags \u003d *(int *)pcVar46;\n            *(undefined4 *)\u0026unaff_R12-\u003efield_0x4 \u003d uVar17;\n            ppcVar31 \u003d *(char ***)((long)pcVar46 + 8);\n            local_128 \u003d (FILE *)((long)pcVar46 + 0x10);\n            local_110 \u003d ppcVar31;\n            if (*(char *)ppcVar31 \u003d\u003d \u0027\\0\u0027) {\n              ppcVar32 \u003d \u0026unaff_R12-\u003e_IO_read_ptr;\n            }\n            else {\n              local_118 \u003d local_c8;\n              local_c8[1] \u003d *(char *)ppcVar31;\n              pcVar39 \u003d (char *)xstrdup();\n              ppcVar32 \u003d \u0026unaff_R12-\u003e_IO_read_end;\n              unaff_R12-\u003e_IO_read_ptr \u003d pcVar39;\n              if (*(char *)((long)ppcVar31 + 1) !\u003d \u0027\\0\u0027) {\n                local_c8[1] \u003d *(char *)((long)ppcVar31 + 1);\n                pcVar39 \u003d (char *)xstrdup(local_118);\n                ppcVar32 \u003d \u0026unaff_R12-\u003e_IO_read_base;\n                unaff_R12-\u003e_IO_read_end \u003d pcVar39;\n                if (*(char *)((long)ppcVar31 + 2) !\u003d \u0027\\0\u0027) {\n                  local_c8[1] \u003d *(char *)((long)ppcVar31 + 2);\n                  pcVar39 \u003d (char *)xstrdup(local_118);\n                  ppcVar32 \u003d \u0026unaff_R12-\u003e_IO_write_base;\n                  unaff_R12-\u003e_IO_read_base \u003d pcVar39;\n                  if (*(char *)((long)ppcVar31 + 3) !\u003d \u0027\\0\u0027) {\n                    ppcVar32 \u003d \u0026unaff_R12-\u003e_IO_write_ptr;\n                    local_c8[1] \u003d *(char *)((long)ppcVar31 + 3);\n                    pcVar39 \u003d (char *)xstrdup(local_118);\n                    unaff_R12-\u003e_IO_write_base \u003d pcVar39;\n                    cVar14 \u003d *(char *)((long)ppcVar31 + 4);\n                    local_110 \u003d ppcVar32;\n                    if (cVar14 !\u003d \u0027\\0\u0027) {\n                      pcVar39 \u003d (char *)((long)ppcVar31 + 4);\n                      ppcVar31 \u003d ppcVar32;\n                      do {\n                        ppcVar32 \u003d ppcVar31 + 1;\n                        local_c8[1] \u003d cVar14;\n                        pcVar23 \u003d (char *)xstrdup(local_118);\n                        pcVar39 \u003d pcVar39 + 1;\n                        *ppcVar31 \u003d pcVar23;\n                        cVar14 \u003d *pcVar39;\n                        ppcVar31 \u003d ppcVar32;\n                        local_110 \u003d ppcVar32;\n                      } while (cVar14 !\u003d \u0027\\0\u0027);\n                    }\n                  }\n                }\n              }\n            }\n            lVar24 \u003d (long)(int)pFVar18;\n            piVar11 \u003d (int *)pcVar46 + lVar24 * 2;\n            if (local_128 \u003c piVar11) {\n              uVar25 \u003d lVar24 * 8 - 0x11;\n              if ((uVar25 \u003c 0x18) || (ppcVar32 \u003d\u003d (char **)((long)pcVar46 + 0x18))) {\n                *ppcVar32 \u003d *(char **)((long)pcVar46 + 0x10);\n                if (((char **)((long)pcVar46 + 0x18) \u003c piVar11) \u0026\u0026\n                   ((((ppcVar32[1] \u003d *(char **)((long)pcVar46 + 0x18),\n                      (char **)((long)pcVar46 + 0x20) \u003c piVar11 \u0026\u0026\n                      (ppcVar32[2] \u003d *(char **)((long)pcVar46 + 0x20),\n                      (char **)((long)pcVar46 + 0x28) \u003c piVar11)) \u0026\u0026\n                     (ppcVar32[3] \u003d *(char **)((long)pcVar46 + 0x28),\n                     (char **)((long)pcVar46 + 0x30) \u003c piVar11)) \u0026\u0026\n                    (ppcVar32[4] \u003d *(char **)((long)pcVar46 + 0x30),\n                    (char **)((long)pcVar46 + 0x38) \u003c piVar11)))) {\n                  ppcVar32[5] \u003d *(char **)((long)pcVar46 + 0x38);\n                  ppcVar10 \u003d ppcVar32 + 6;\n                  for (ppcVar31 \u003d (char **)((long)pcVar46 + 0x40); ppcVar31 \u003c piVar11;\n                      ppcVar31 \u003d ppcVar31 + (ulong)bVar48 * -2 + 1) {\n                    *ppcVar10 \u003d *ppcVar31;\n                    ppcVar10 \u003d ppcVar10 + (ulong)bVar48 * -2 + 1;\n                  }\n                }\n              }\n              else {\n                uVar17 \u003d *(undefined4 *)((long)((long)pcVar46 + 0x10) + 4);\n                uVar6 \u003d *(undefined4 *)((long)pcVar46 + 0x18);\n                uVar7 \u003d *(undefined4 *)((long)((long)pcVar46 + 0x18) + 4);\n                uVar40 \u003d (uVar25 \u003e\u003e 3) + 1;\n                *(undefined4 *)ppcVar32 \u003d *(undefined4 *)((long)pcVar46 + 0x10);\n                *(undefined4 *)((long)ppcVar32 + 4) \u003d uVar17;\n                *(undefined4 *)(ppcVar32 + 1) \u003d uVar6;\n                *(undefined4 *)((long)ppcVar32 + 0xc) \u003d uVar7;\n                uVar17 \u003d *(undefined4 *)((long)((long)pcVar46 + 0x20) + 4);\n                uVar6 \u003d *(undefined4 *)((long)pcVar46 + 0x28);\n                uVar7 \u003d *(undefined4 *)((long)((long)pcVar46 + 0x28) + 4);\n                uVar25 \u003d uVar40 \u003e\u003e 1;\n                *(undefined4 *)(ppcVar32 + 2) \u003d *(undefined4 *)((long)pcVar46 + 0x20);\n                *(undefined4 *)((long)ppcVar32 + 0x14) \u003d uVar17;\n                *(undefined4 *)(ppcVar32 + 3) \u003d uVar6;\n                *(undefined4 *)((long)ppcVar32 + 0x1c) \u003d uVar7;\n                if (uVar25 !\u003d 2) {\n                  uVar17 \u003d *(undefined4 *)((long)((long)pcVar46 + 0x30) + 4);\n                  uVar6 \u003d *(undefined4 *)((long)pcVar46 + 0x38);\n                  uVar7 \u003d *(undefined4 *)((long)((long)pcVar46 + 0x38) + 4);\n                  *(undefined4 *)(ppcVar32 + 4) \u003d *(undefined4 *)((long)pcVar46 + 0x30);\n                  *(undefined4 *)((long)ppcVar32 + 0x24) \u003d uVar17;\n                  *(undefined4 *)(ppcVar32 + 5) \u003d uVar6;\n                  *(undefined4 *)((long)ppcVar32 + 0x2c) \u003d uVar7;\n                  if (uVar25 !\u003d 3) {\n                    uVar41 \u003d 3;\n                    do {\n                      uVar42 \u003d uVar41 + 1;\n                      pcVar39 \u003d (char *)((long)pcVar46 + 0x83) + uVar41 * 0x10 + -0x73;\n                      uVar17 \u003d *(undefined4 *)(pcVar39 + 4);\n                      uVar6 \u003d *(undefined4 *)(pcVar39 + 8);\n                      uVar7 \u003d *(undefined4 *)(pcVar39 + 0xc);\n                      ppcVar31 \u003d ppcVar32 + uVar41 * 2;\n                      *(undefined4 *)ppcVar31 \u003d *(undefined4 *)pcVar39;\n                      *(undefined4 *)((long)ppcVar31 + 4) \u003d uVar17;\n                      *(undefined4 *)(ppcVar31 + 1) \u003d uVar6;\n                      *(undefined4 *)((long)ppcVar31 + 0xc) \u003d uVar7;\n                      uVar41 \u003d uVar42;\n                    } while (uVar42 !\u003d uVar25);\n                  }\n                }\n                if ((uVar40 \u0026 1) !\u003d 0) {\n                  ppcVar32[uVar40 \u0026 0xfffffffffffffffe] \u003d\n                       *(char **)((long)local_128 + (uVar40 \u0026 0xfffffffffffffffe) * 8);\n                }\n              }\n              ppcVar32 \u003d ppcVar32 + lVar24 + -2;\n            }\n            pFVar18 \u003d (FILE *)(ulong)(iVar15 - 1);\n            *ppcVar32 \u003d (char *)0x0;\n            pcVar46 \u003d (char *)unaff_R12;\n          }\nLAB_001065a2:\n          while( true ) {\n            uVar16 \u003d (uint)unaff_R12;\n            uVar44 \u003d getopt_long((ulong)pFVar18 \u0026 0xffffffff,pcVar46,pFVar22,ppuVar36,0);\n            unaff_RBP \u003d (char *)pFVar22;\n            if (uVar44 \u003d\u003d 0xffffffff) break;\n            if (((uVar44 - 100 \u003c 0x15) \u0026\u0026 ((0x117201UL \u003e\u003e ((ulong)(uVar44 - 100) \u0026 0x3f) \u0026 1) !\u003d 0))\n               \u0026\u0026 (DAT_0010d64c !\u003d 0)) goto LAB_001067f7;\n            pFVar28 \u003d (FILE *)pcVar46;\n            if (uVar44 \u003c 0xcc) {\n                    /* WARNING: Could not recover jumptable at 0x001065eb. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              (*(code *)((long)(int *)pcVar43 + (long)((int *)pcVar43)[uVar44]))();\n              return;\n            }\nswitchD_00107462_caseD_1:\n            FUN_0010342d(0);\n            pcVar46 \u003d (char *)pFVar28;\nswitchD_00107462_caseD_68:\n            _DAT_0010d658 \u003d 1;\n          }\nLAB_00106680:\n          uVar44 \u003d DAT_0010d64c;\n          pFVar22 \u003d (FILE *)unaff_RBP;\n          if (DAT_0010d64c \u003d\u003d 0) {\n            if (((DAT_0010d648 \u003d\u003d 1) || (_DAT_0010d650 !\u003d 0)) ||\n               (((int)pFVar18 \u003c\u003d _optind || (_optind \u003c 1)))) {\n              uVar44 \u003d 0;\n              goto LAB_001066aa;\n            }\n            pcVar46 \u003d (char *)((long)pcVar46 + (long)_optind * 8 + -8);\n            uVar16 \u003d (int)pFVar18 - (_optind + -1);\n            pFVar18 \u003d (FILE *)(ulong)uVar16;\n            _optind \u003d 0;\n            if (1 \u003c (int)uVar16) goto LAB_001063a3;\n            goto LAB_001065a2;\n          }\nLAB_001066aa:\n          unaff_R12 \u003d (FILE *)((ulong)local_130 \u0026 0xff);\n          uVar16 \u003d (uint)unaff_R12;\n          ppuVar36 \u003d (undefined **)((int *)pcVar46 + (long)_optind * 2);\n          if (_DAT_0010d658 \u003d\u003d 0) {\n            if (_DAT_0010d654 !\u003d 0) {\n              FUN_001075e0(\u0026DAT_0010807c);\n              goto LAB_00107591;\n            }\n            if (_DAT_0010d650 \u003d\u003d 0) {\n              pFVar28 \u003d (FILE *)pcVar46;\n              if (*ppuVar36 \u003d\u003d (undefined *)0x0) goto switchD_00107462_caseD_1;\n              if (DAT_0010d64c \u003d\u003d 7) {\n                if (DAT_0010d648 \u003d\u003d 0) {\n                  if (uVar44 \u003d\u003d 3) goto LAB_00106abc;\n                  if (uVar44 !\u003d 0) goto LAB_00106700;\nLAB_00106eff:\n                  pcVar39 \u003d \"no operation specified\";\n                  goto LAB_00106803;\n                }\n                DAT_0010d64c \u003d 2;\n                if (_DAT_0010d644 !\u003d 0) goto LAB_0010704f;\n              }\n              else if ((uVar44 \u003d\u003d 3) || (uVar44 \u003d\u003d 0)) {\n                if (DAT_0010d648 \u003d\u003d 1) {\n                  uVar17 \u003d FUN_00107650();\n                    \n                  xexit(uVar17);\n                }\nLAB_00106abc:\n                if (uVar44 \u003d\u003d 0) goto LAB_00106eff;\n                if (_DAT_0010d644 !\u003d 0) {\nLAB_00106ad1:\n                  pcVar39 \u003d \"`u\\\u0027 is only meaningful with the `r\\\u0027 option.\";\n                  goto LAB_00106803;\n                }\n              }\n              else {\nLAB_00106700:\n                if (_DAT_0010d644 !\u003d 0) goto LAB_00107548;\n              }\nLAB_0010670d:\n              if (_DAT_0010d2d0 \u003c 0) {\n                _DAT_0010d2d0 \u003d 1;\n              }\nLAB_00106720:\n              unaff_RBP \u003d (char *)0x0;\n              if (DAT_0010d640 !\u003d 0) {\n                DAT_0010d638 \u003d (long)*ppuVar36;\n                unaff_RBP \u003d (char *)0x1;\n                pcVar39 \u003d \"missing position arg.\";\n                if (DAT_0010d638 \u003d\u003d 0) goto LAB_00106803;\n              }\n              if (DAT_0010d634 !\u003d \u0027\\0\u0027) {\n                pcVar39 \u003d \"`N\\\u0027 is only meaningful with the `x\\\u0027 and `d\\\u0027 options.\";\n                if ((DAT_0010d64c \u0026 0xfffffffb) \u003d\u003d 1) {\n                  iVar15 \u003d (int)unaff_RBP;\n                  if (*(char **)((long)ppuVar36 + (long)iVar15 * 2 * 4) \u003d\u003d (char *)0x0) {\n                    uVar27 \u003d dcgettext(0,\"`N\\\u0027 missing value.\",5);\n                    FUN_00107690(uVar27);\n                    uVar44 \u003d extraout_EDX;\nLAB_00107548:\n                    if (uVar44 \u003d\u003d 2) {\nLAB_0010704f:\n                      pcVar39 \u003d \"`u\\\u0027 is not meaningful with the `D\\\u0027 option.\";\n                      if (_DAT_0010d2d0 \u003c 1) goto code_r0x00107068;\n                      goto LAB_00106803;\n                    }\n                    goto LAB_00106ad1;\n                  }\n                  unaff_RBP \u003d (char *)(ulong)(iVar15 + 1);\n                  lVar24 \u003d strtol(*(char **)((long)ppuVar36 + (long)iVar15 * 2 * 4),(char **)0x0,10)\n                  ;\n                  pcVar39 \u003d \"Value for `N\\\u0027 must be positive.\";\n                  _DAT_0010d630 \u003d (int)lVar24;\n                  if (0 \u003c _DAT_0010d630) goto LAB_0010673c;\n                }\n                goto LAB_00106803;\n              }\nLAB_0010673c:\n              lVar24 \u003d (long)(int)unaff_RBP;\n              pFVar22 \u003d (FILE *)unaff_RBP;\n              if (*(long *)(int *)((long)ppuVar36 + lVar24 * 2 * 4) \u003d\u003d 0)\n              goto switchD_00107462_caseD_1;\n              pFVar22 \u003d (FILE *)((long)ppuVar36 + (lVar24 + 1) * 2 * 4);\n              if (*(FILE **)pFVar22 \u003d\u003d (FILE *)0x0) {\n                pcVar43 \u003d (char *)0x0;\n                pFVar22 \u003d (FILE *)0x0;\n              }\n              else if (*(long *)((long)ppuVar36 + (lVar24 + 2) * 2 * 4) \u003d\u003d 0) {\n                pcVar43 \u003d (char *)0x1;\n              }\n              else if (*(long *)((long)ppuVar36 + (lVar24 + 3) * 2 * 4) \u003d\u003d 0) {\n                pcVar43 \u003d (char *)0x2;\n              }\n              else if (*(long *)((long)ppuVar36 + (lVar24 + 4) * 2 * 4) \u003d\u003d 0) {\n                pcVar43 \u003d (char *)0x3;\n              }\n              else if (*(long *)((long)ppuVar36 + (lVar24 + 5) * 2 * 4) \u003d\u003d 0) {\n                pcVar43 \u003d (char *)0x4;\n              }\n              else {\n                pFVar18 \u003d (FILE *)0x5;\n                do {\n                  pcVar43 \u003d (char *)pFVar18;\n                  pFVar18 \u003d (FILE *)((long)(int *)pcVar43 + 1);\n                } while (*(long *)((int *)((long)ppuVar36 + lVar24 * 2 * 4) + (long)pFVar18 * 2) !\u003d\n                         0);\n              }\n              puVar26 \u003d (undefined8 *)FUN_00105300();\n              pFVar18 \u003d pFVar22;\n              if (DAT_0010d64c \u003d\u003d 5) {\n                pcVar39 \u003d \"`x\\\u0027 cannot be used on thin archives.\";\n                if ((*(byte *)((long)puVar26 + 0x49) \u0026 0x10) \u003d\u003d 0) {\n                  unaff_RBP \u003d (char *)pFVar22;\n                  if (DAT_0010d628 !\u003d (char *)0x0) goto LAB_00106d5c;\nswitchD_00106ed8_caseD_5:\n                  FUN_00105480(puVar26,FUN_00107740,unaff_RBP,(ulong)pcVar43 \u0026 0xffffffff);\n                  goto LAB_0010696c;\n                }\n                goto LAB_00106803;\n              }\n              if (DAT_0010d628 !\u003d (char *)0x0) {\nLAB_00106d5c:\n                sVar19 \u003d strlen(DAT_0010d628);\n                pcVar46 \u003d \"__.LIBDEP\";\n                unaff_RBP \u003d (char *)(sVar19 + 1);\n                DAT_0010d620 \u003d bfd_create(\"__.LIBDEP\",puVar26);\n                if (DAT_0010d620 \u003d\u003d 0) {\n                  pcVar39 \u003d \"Cannot create libdeps record.\";\n                }\n                else {\n                  lVar24 \u003d bfd_find_target(\"binary\",DAT_0010d620);\n                  pcVar39 \u003d \"Cannot set libdeps record type to binary.\";\n                  if (lVar24 !\u003d 0) {\n                    cVar14 \u003d bfd_set_format(DAT_0010d620,1,5);\n                    pcVar39 \u003d \"Cannot set libdeps object format.\";\n                    if (cVar14 \u003d\u003d \u0027\\0\u0027) goto LAB_00106803;\n                    cVar14 \u003d bfd_make_writable(DAT_0010d620,\"Cannot set libdeps object format.\",5);\n                    pcVar39 \u003d \"Cannot make libdeps object writable.\";\n                    if (cVar14 \u003d\u003d \u0027\\0\u0027) goto LAB_00106803;\n                    pFVar28 \u003d (FILE *)bfd_bwrite(DAT_0010d628,unaff_RBP,DAT_0010d620);\n                    pcVar39 \u003d \"Cannot write libdeps record.\";\n                    if (pFVar28 !\u003d (FILE *)unaff_RBP) goto LAB_00106803;\n                    cVar14 \u003d bfd_make_readable(DAT_0010d620,\"Cannot write libdeps record.\",5);\n                    pcVar39 \u003d \"Cannot make libdeps object readable.\";\n                    if (cVar14 \u003d\u003d \u0027\\0\u0027) goto LAB_00106803;\n                    lVar24 \u003d bfd_find_target(\"plugin\",DAT_0010d620,5);\n                    pcVar39 \u003d \"Cannot reset libdeps record type.\";\n                    if (lVar24 \u003d\u003d 0) goto LAB_00106803;\n                    iVar15 \u003d (int)pcVar43;\n                    local_130 \u003d (FILE *)((long)(iVar15 + 2) * 8);\n                    unaff_RBP \u003d (char *)xmalloc(local_130,\"Cannot reset libdeps record type.\");\n                    if (iVar15 \u003d\u003d 0) {\n                      lVar24 \u003d 0;\n                    }\n                    else {\n                      uVar17 \u003d *(undefined4 *)\u0026pFVar22-\u003efield_0x4;\n                      *(int *)unaff_RBP \u003d pFVar22-\u003e_flags;\n                      *(undefined4 *)((long)unaff_RBP + 4) \u003d uVar17;\n                      lVar24 \u003d 8;\n                      ppcVar31 \u003d (char **)((long)unaff_RBP + 8);\n                      for (pcVar43 \u003d local_130[-1]._unused2 + 4; pcVar43 !\u003d (char *)0x0;\n                          pcVar43 \u003d pcVar43 + -1) {\n                        *(undefined *)ppcVar31 \u003d *(undefined *)\u0026pFVar22-\u003e_flags;\n                        pFVar22 \u003d (FILE *)((long)pFVar22 + (ulong)bVar48 * -2 + 1);\n                        ppcVar31 \u003d (char **)((long)ppcVar31 + (ulong)bVar48 * -2 + 1);\n                      }\n                    }\n                    *(char **)((long)(char **)unaff_RBP + lVar24) \u003d \"__.LIBDEP\";\n                    pcVar43 \u003d (char *)(ulong)(iVar15 + 1);\n                    *(undefined8 *)\n                     (((FILE *)((long)unaff_RBP + -0xd8))-\u003e_unused2 + 0xc + (long)local_130) \u003d 0;\n                    switch(DAT_0010d64c) {\n                    case 1:\n                      goto switchD_00106ed8_caseD_1;\n                    case 2:\n                    case 7:\n                      break;\n                    case 3:\n                      goto switchD_00106ed8_caseD_3;\n                    case 4:\n                      goto switchD_00106ed8_caseD_4;\n                    case 5:\n                      goto switchD_00106ed8_caseD_5;\n                    case 6:\n                      pFVar22 \u003d (FILE *)unaff_RBP;\n                      if (_DAT_0010d610 \u003d\u003d 0) goto LAB_00106afb;\n                      break;\n                    default:\n                      goto switchD_001067e8_caseD_5;\n                    }\n                    goto switchD_00106ed8_caseD_2;\n                  }\n                }\n                goto LAB_00106803;\n              }\n              switch(DAT_0010d64c) {\n              case 1:\n                unaff_RBP \u003d (char *)pFVar22;\n                if (pFVar22 \u003d\u003d (FILE *)0x0) break;\nswitchD_00106ed8_caseD_1:\n                pFVar18 \u003d (FILE *)0x0;\n                goto LAB_00106b89;\n              case 2:\n              case 7:\nswitchD_001067e8_caseD_2:\n                unaff_RBP \u003d (char *)pFVar22;\n                if ((pFVar22 !\u003d (FILE *)0x0) || (0 \u003c DAT_0010d648)) {\nswitchD_00106ed8_caseD_2:\n                  FUN_00105570(puVar26,unaff_RBP,DAT_0010d64c \u003d\u003d 7);\n                  goto LAB_0010696c;\n                }\n                break;\n              case 3:\n                unaff_RBP \u003d (char *)pFVar22;\nswitchD_00106ed8_caseD_3:\n                FUN_00105480(puVar26,FUN_00107890,unaff_RBP,(ulong)pcVar43 \u0026 0xffffffff);\n                goto LAB_0010696c;\n              case 4:\n                unaff_RBP \u003d (char *)pFVar22;\nswitchD_00106ed8_caseD_4:\n                FUN_00105480(puVar26,FUN_00103a78,unaff_RBP,(ulong)pcVar43 \u0026 0xffffffff);\n                goto LAB_0010696c;\n              default:\nswitchD_001067e8_caseD_5:\n                pcVar39 \u003d \"internal error -- this option not implemented\";\n                goto LAB_00106803;\n              case 6:\n                if (_DAT_0010d610 !\u003d 0) goto switchD_001067e8_caseD_2;\n                if (pFVar22 \u003d\u003d (FILE *)0x0) break;\nLAB_00106afb:\n                pFVar18 \u003d (FILE *)(puVar26 + 0x1e);\n                do {\n                  unaff_R12 \u003d pFVar18;\n                  if (*(FILE **)pFVar22 \u003d\u003d (FILE *)0x0) {\nLAB_00106b9f:\n                    FUN_001058b0(puVar26);\n                    goto LAB_0010696c;\n                  }\n                  while( true ) {\n                    plVar21 \u003d *(long **)unaff_R12;\n                    pcVar46 \u003d *(char **)pFVar22;\n                    if (plVar21 \u003d\u003d (long *)0x0) {\n                      uVar27 \u003d *puVar26;\n                      uVar30 \u003d dcgettext(0,\"no entry %s in archive %s!\",5);\n                      FUN_00107690(uVar30,pcVar46,uVar27);\n                      pcVar43 \u003d (char *)0x0;\n                      goto LAB_00107293;\n                    }\n                    lVar24 \u003d *plVar21;\n                    uVar27 \u003d FUN_00105830(pcVar46,puVar26);\n                    iVar15 \u003d filename_cmp(uVar27,lVar24);\n                    if (iVar15 \u003d\u003d 0) break;\n                    unaff_R12 \u003d (FILE *)(*(long **)unaff_R12 + 0x1e);\n                  }\n                  *(long **)unaff_R12 \u003d (long *)plVar21[0x1e];\n                  pplVar29 \u003d (long **)FUN_00105870(pFVar18,3,0);\n                  bVar47 \u003d DAT_0010d60c !\u003d 0;\n                  plVar4 \u003d *pplVar29;\n                  *pplVar29 \u003d plVar21;\n                  plVar21[0x1e] \u003d (long)plVar4;\n                  if (bVar47) {\n                    printf(\"m - %s\\n\",*(FILE **)pFVar22);\n                  }\n                  pFVar22 \u003d (FILE *)\u0026pFVar22-\u003e_IO_read_ptr;\n                } while( true );\n              }\n              goto LAB_00106d4e;\n            }\n            if (-1 \u003c _DAT_0010d2d0) goto LAB_0010755f;\n          }\n          else {\nLAB_00107591:\n            FUN_0010342d(1);\n          }\n          _DAT_0010d2d0 \u003d 1;\nLAB_0010755f:\n          iVar15 \u003d fileno(_stdin);\n          _DAT_0010d608 \u003d isatty(iVar15);\n          FUN_00103e95();\nLAB_0010696c:\n                    \n          xexit(0);\n        }\n        uVar17 \u003d bfd_get_error();\n        pFVar22 \u003d (FILE *)bfd_errmsg(uVar17);\n        uVar27 \u003d dcgettext(0,\"can\\\u0027t set BFD default target to `%s\\\u0027: %s\",5);\n        iVar15 \u003d FUN_00107690(uVar27,\"x86_64-pc-linux-gnu\",pFVar22);\nLAB_0010751b:\n        if (DAT_0010d64c \u003d\u003d 0) {\nLAB_00107447:\n          ppuVar36 \u003d (undefined **)pcVar39;\n          pFVar28 \u003d (FILE *)pcVar46;\n          switch(iVar15) {\n          case 0:\n            goto switchD_00107462_caseD_0;\n          default:\n            goto switchD_00107462_caseD_1;\n          case 0x44:\n            _DAT_0010d2d0 \u003d 1;\n            goto LAB_001065a2;\n          case 0x4d:\n            _DAT_0010d650 \u003d 1;\n            goto LAB_001065a2;\n          case 0x4e:\n            DAT_0010d634 \u003d \u0027\\x01\u0027;\n            goto LAB_001065a2;\n          case 0x4f:\n            _DAT_0010d5fc \u003d 1;\n            goto LAB_001065a2;\n          case 0x50:\n            DAT_0010d5f9 \u003d 1;\n            goto LAB_001065a2;\n          case 0x53:\n            DAT_0010d648 \u003d -1;\n            goto LAB_001065a2;\n          case 0x54:\n            DAT_0010d5f8 \u003d 1;\n            goto LAB_001065a2;\n          case 0x55:\n            _DAT_0010d2d0 \u003d 0;\n            goto LAB_001065a2;\n          case 0x56:\n            _DAT_0010d654 \u003d 1;\n            goto LAB_001065a2;\n          case 0x61:\n            DAT_0010d640 \u003d 2;\n            goto LAB_001065a2;\n          case 0x62:\n          case 0x69:\n            DAT_0010d640 \u003d 1;\n            goto LAB_001065a2;\n          case 99:\n            _DAT_0010d610 \u003d 1;\n            goto LAB_001065a2;\n          case 100:\n            DAT_0010d64c \u003d 1;\n            DAT_0010d604 \u003d 1;\n            goto LAB_001065a2;\n          case 0x66:\n            DAT_0010d5fa \u003d 1;\n            goto LAB_001065a2;\n          case 0x68:\n            goto switchD_00107462_caseD_68;\n          case 0x6c:\n            if (DAT_0010d628 \u003d\u003d (char *)0x0) {\n              DAT_0010d628 \u003d _optarg;\n              goto LAB_001065a2;\n            }\nLAB_00107293:\n            uVar16 \u003d (uint)unaff_R12;\n            pcVar39 \u003d \"libdeps specified more than once\";\n            unaff_RBP \u003d (char *)pFVar22;\n            break;\n          case 0x6d:\n            DAT_0010d64c \u003d 6;\n            DAT_0010d604 \u003d 1;\n            goto LAB_001065a2;\n          case 0x6f:\n            _DAT_0010d600 \u003d 1;\n            goto LAB_001065a2;\n          case 0x70:\n            DAT_0010d64c \u003d 4;\n            goto LAB_001065a2;\n          case 0x71:\n            DAT_0010d64c \u003d 7;\n            DAT_0010d604 \u003d 1;\n            goto LAB_001065a2;\n          case 0x72:\n            DAT_0010d64c \u003d 2;\n            DAT_0010d604 \u003d 1;\n            goto LAB_001065a2;\n          case 0x73:\n            DAT_0010d648 \u003d 1;\n            goto LAB_001065a2;\n          case 0x74:\n            DAT_0010d64c \u003d 3;\n            goto LAB_001065a2;\n          case 0x75:\n            _DAT_0010d644 \u003d 1;\n            goto LAB_001065a2;\n          case 0x76:\n            DAT_0010d60c \u003d 1;\n            goto LAB_001065a2;\n          case 0x78:\n            DAT_0010d64c \u003d 5;\n            goto LAB_001065a2;\n          case 0xc9:\n            bfd_plugin_set_plugin(_optarg);\n            goto LAB_001065a2;\n          case 0xca:\n            DAT_0010d5f0 \u003d _optarg;\n            goto LAB_001065a2;\n          case 0xcb:\n            DAT_0010d5e8 \u003d _optarg;\n            goto LAB_001065a2;\n          }\n          goto LAB_00106803;\n        }\nLAB_001067f7:\n        pcVar39 \u003d \"two different operation options specified\";\n        unaff_RBP \u003d (char *)pFVar22;\nLAB_00106803:\n        uVar27 \u003d dcgettext(0,pcVar39,5);\n        FUN_00107690(uVar27);\nLAB_00106814:\n        iVar15 \u003d (int)pcVar46;\n        pFVar28 \u003d (FILE *)xmalloc(8);\n        *(long **)pFVar28 \u003d (long *)0x0;\n        if ((FILE *)pcVar43 \u003d\u003d param_2) {\nLAB_00106834:\n          if (*(long **)pcVar43 \u003d\u003d (long *)0x0) {\n            iVar15 \u003d 0;\n          }\n          else {\n            lVar24 \u003d 1;\n            do {\n              iVar15 \u003d (int)lVar24;\n              lVar35 \u003d lVar24 * 2;\n              lVar24 \u003d lVar24 + 1;\n            } while (*(long *)((int *)pcVar43 + lVar35) !\u003d 0);\n          }\n          pFVar22 \u003d (FILE *)xmalloc((long)(iVar15 + 1) \u003c\u003c 3);\n          plVar21 \u003d *(long **)pcVar43;\n          lVar24 \u003d 0;\n          while (plVar21 !\u003d (long *)0x0) {\n            uVar27 \u003d xstrdup();\n            *(undefined8 *)((long)\u0026pFVar22-\u003e_flags + lVar24) \u003d uVar27;\n            plVar21 \u003d *(long **)((char *)((long)pcVar43 + 0x83) + lVar24 + -0x7b);\n            lVar24 \u003d lVar24 + 8;\n          }\n          *(undefined8 *)((long)\u0026pFVar22-\u003e_flags + lVar24) \u003d 0;\nLAB_0010610a:\n          iVar15 \u003d (int)pcVar46;\n          pcVar43 \u003d (char *)pFVar22;\n          if (*(long **)pFVar28 \u003d\u003d (long *)0x0) goto LAB_00106a80;\n          lVar24 \u003d 0;\n          do {\n            lVar34 \u003d lVar24 + 1;\n            lVar35 \u003d lVar24 * 8;\n            lVar24 \u003d lVar34;\n          } while (*(long *)(pFVar28-\u003e_shortbuf + lVar35 + -0x7b) !\u003d 0);\n          local_108 \u003d lVar34 * 8;\n        }\n        else {\nLAB_00106a80:\n          lVar34 \u003d 0;\n          local_108 \u003d 0;\n        }\n        lVar24 \u003d (long)unaff_RBP * 2;\n        unaff_RBP \u003d (char *)((long)(char **)unaff_RBP + lVar34);\n        free(*(void **)((int *)pcVar43 + lVar24));\n        pFVar22 \u003d (FILE *)xrealloc(pcVar43,(lVar34 + 1 + (long)iVar15) * 8);\n        uVar44 \u003d iVar15 + -1 + (int)lVar34;\n        pcVar46 \u003d (char *)(ulong)uVar44;\n        memmove(\u0026pFVar22-\u003e_flags + (long)unaff_RBP * 2,\n                (void *)((long)\u0026pFVar22-\u003e_IO_read_ptr + (long)local_130),\n                (long)(int)(iVar15 - uVar16) \u003c\u003c 3);\n        memcpy((void *)((long)\u0026local_130-\u003e_flags + (long)\u0026pFVar22-\u003e_flags),pFVar28,local_108);\n        free(pFVar28);\n        free(local_118);\n        fclose(pFVar18);\n        uVar16 \u003d (int)local_128 + 1;\n        unaff_R12 \u003d local_130;\n        pcVar43 \u003d (char *)pFVar22;\n        local_130 \u003d pFVar28;\n        if ((int)uVar16 \u003c (int)uVar44) goto LAB_001061ce;\n      } while( true );\n    }\n    uVar16 \u003d uVar16 + 1;\n    local_128 \u003d unaff_R12;\nLAB_001061ce:\n    unaff_R12 \u003d (FILE *)(ulong)uVar16;\n  } while( true );\nswitchD_00107462_caseD_0:\n  iVar15 \u003d getopt_long((ulong)pFVar18 \u0026 0xffffffff,pcVar46,pFVar22,\"x86_64-pc-linux-gnu\");\n  unaff_RBP \u003d (char *)pFVar22;\n  if (iVar15 \u003d\u003d -1) goto LAB_00106680;\n  if ((0x14 \u003c iVar15 - 100U) || ((0x117201UL \u003e\u003e ((byte)(iVar15 - 100U) \u0026 0x3f) \u0026 1) \u003d\u003d 0))\n  goto LAB_00107447;\n  goto LAB_0010751b;\ncode_r0x00107068:\n  if (_DAT_0010d2d0 !\u003d 0) goto code_r0x0010706e;\n  goto LAB_00106720;\ncode_r0x0010706e:\n  uVar27 \u003d dcgettext(0,\"`u\\\u0027 modifier ignored since `D\\\u0027 is the default (see `U\\\u0027)\",5);\n  FUN_00107920(uVar27);\n  goto LAB_0010670d;\nLAB_00106b89:\n  if (*(FILE **)unaff_RBP \u003d\u003d (FILE *)0x0) {\n    if ((char)pFVar18 !\u003d \u0027\\0\u0027) goto LAB_00106b9f;\nLAB_00106d4e:\n    DAT_0010d618 \u003d 0;\n    goto LAB_0010696c;\n  }\n  iVar45 \u003d 0;\n  iVar15 \u003d strcmp((char *)*(FILE **)unaff_RBP,\"__.SYMDEF\");\n  puVar5 \u003d puVar26;\n  if (iVar15 \u003d\u003d 0) {\n    *(byte *)((long)puVar26 + 0x49) \u003d *(byte *)((long)puVar26 + 0x49) \u0026 0xf7;\n    DAT_0010d648 \u003d -1;\n  }\n  else {\n    while( true ) {\n      plVar21 \u003d puVar5 + 0x1e;\n      if ((undefined8 *)*plVar21 \u003d\u003d (undefined8 *)0x0) break;\n      uVar27 \u003d *(undefined8 *)*plVar21;\n      uVar30 \u003d FUN_00105830(*(FILE **)unaff_RBP,puVar26);\n      iVar15 \u003d filename_cmp(uVar30,uVar27);\n      if ((iVar15 \u003d\u003d 0) \u0026\u0026\n         ((DAT_0010d634 \u003d\u003d \u0027\\0\u0027 || (iVar45 \u003d iVar45 + 1, iVar45 \u003d\u003d _DAT_0010d630)))) {\n        if (DAT_0010d60c !\u003d 0) {\n          printf(\"d - %s\\n\",*(FILE **)unaff_RBP);\n        }\n        *plVar21 \u003d *(long *)(*plVar21 + 0xf0);\n        pFVar18 \u003d unaff_R12;\n        goto LAB_00106d38;\n      }\n      puVar5 \u003d (undefined8 *)*plVar21;\n    }\n    if (DAT_0010d60c !\u003d 0) {\n      pFVar22 \u003d *(FILE **)unaff_RBP;\n      pcVar46 \u003d (char *)dcgettext(0,\"No member named `%s\\\u0027\\n\",5);\n      printf(pcVar46,pFVar22);\n    }\n  }\nLAB_00106d38:\n  unaff_RBP \u003d (char *)((long)unaff_RBP + 8);\n  goto LAB_00106b89;\n}\n\n",
      "renaming": {},
      "calling": [
        "entry"
      ],
      "called": [
        "free",
        "FUN_0010342d",
        "setlocale",
        "fileno",
        "FUN_00105570",
        "FUN_001052a0",
        "FUN_001058b0",
        "lbasename",
        "bfd_make_readable",
        "FUN_00107650",
        "open",
        "isatty",
        "FUN_00107640",
        "FUN_00103e95",
        "xrealloc",
        "dcgettext",
        "bfd_close",
        "getopt_long",
        "FUN_00107c10",
        "FUN_0010394a",
        "bfd_plugin_set_program_name",
        "bfd_set_error",
        "FUN_00107690",
        "bfd_set_format",
        "bfd_check_format_matches",
        "strtol",
        "bindtextdomain",
        "FUN_001075e0",
        "fprintf",
        "xmalloc",
        "FUN_00105870",
        "ftell",
        "fopen",
        "printf",
        "FUN_00107730",
        "xstrdup",
        "FUN_00107740",
        "xexit",
        "memcpy",
        "FUN_00105480",
        "strlen",
        "bfd_set_default_target",
        "FUN_00107cc0",
        "malloc",
        "FUN_00103bd1",
        "bfd_get_error",
        "fread",
        "bfd_plugin_set_plugin",
        "FUN_00105300",
        "FUN_00107c20",
        "ferror",
        "xmalloc_set_program_name",
        "filename_cmp",
        "bfd_bwrite",
        "FUN_00107920",
        "bfd_fdopenr",
        "memmove",
        "bfd_find_target",
        "FUN_00107890",
        "stat",
        "strcmp",
        "bfd_errmsg",
        "bfd_make_writable",
        "textdomain",
        "fseek",
        "bfd_set_error_program_name",
        "FUN_00105830",
        "bfd_init",
        "FUN_00103a78",
        "bfd_create",
        "fclose"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001075e0": {
      "entrypoint": "0x001075e0",
      "current_name": "FUN_001075e0",
      "code": "\nvoid FUN_001075e0(undefined8 param_1)\n\n{\n  char *pcVar1;\n  \n  printf(\"GNU %s %s\\n\",param_1,\"(GNU Binutils for Debian) 2.40\");\n  pcVar1 \u003d (char *)dcgettext(0,\"Copyright (C) 2023 Free Software Foundation, Inc.\\n\",5);\n  printf(pcVar1);\n  pcVar1 \u003d (char *)dcgettext(0,\n                             \"This program is free software; you may redistribute it under the terms of\\nthe GNU General Public License version 3 or (at your option) any later version.\\nThis program has absolutely no warranty.\\n\"\n                             ,5);\n  printf(pcVar1);\n                    \n  exit(0);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "exit",
        "dcgettext",
        "printf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107640": {
      "entrypoint": "0x00107640",
      "current_name": "FUN_00107640",
      "code": "\nundefined8 FUN_00107640(void)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107650": {
      "entrypoint": "0x00107650",
      "current_name": "FUN_00107650",
      "code": "\nundefined8 FUN_00107650(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  long lVar2;\n  \n  lVar2 \u003d FUN_001052a0();\n  if (lVar2 \u003c 1) {\n    uVar1 \u003d 1;\n  }\n  else {\n    DAT_0010d648 \u003d 1;\n    lVar2 \u003d FUN_00105300(param_1,0);\n    if (lVar2 \u003d\u003d 0) {\n                    \n      xexit(1);\n    }\n    FUN_001058b0(lVar2);\n    uVar1 \u003d 0;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "xexit",
        "FUN_0010284b",
        "FUN_001052a0",
        "FUN_00105300",
        "FUN_001058b0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107690": {
      "entrypoint": "0x00107690",
      "current_name": "FUN_00107690",
      "code": "\nvoid FUN_00107690(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_88 \u003d param_1;\n    local_78 \u003d param_2;\n    local_68 \u003d param_3;\n    local_58 \u003d param_4;\n    local_48 \u003d param_5;\n    local_38 \u003d param_6;\n    local_28 \u003d param_7;\n    local_18 \u003d param_8;\n  }\n  local_d0 \u003d \u0026stack0x00000008;\n  local_d8 \u003d 8;\n  local_c8 \u003d local_b8;\n  local_d4 \u003d 0x30;\n  local_b0 \u003d param_10;\n  local_a8 \u003d param_11;\n  local_a0 \u003d param_12;\n  local_98 \u003d param_13;\n  local_90 \u003d param_14;\n  FUN_001078c0(param_9,\u0026local_d8);\n                    \n  xexit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00105300",
        "FUN_00105db0",
        "FUN_00103a78",
        "FUN_00102c25"
      ],
      "called": [
        "xexit",
        "FUN_001078c0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107730": {
      "entrypoint": "0x00107730",
      "current_name": "FUN_00107730",
      "code": "\nvoid FUN_00107730(void)\n\n{\n  if (DAT_0010d618 \u003d\u003d 0) {\n    return;\n  }\n  if (DAT_0010d5e0 !\u003d 0) {\n    bfd_cache_close();\n  }\n  if (DAT_0010d5d8 !\u003d (FILE *)0x0) {\n    fclose(DAT_0010d5d8);\n  }\n  unlink_if_ordinary(DAT_0010d618);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "FUN_00102bf5"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107740": {
      "entrypoint": "0x00107740",
      "current_name": "FUN_00107740",
      "code": "\n\n\nlong * FUN_00107740(long **param_1)\n\n{\n  int iVar1;\n  int iVar2;\n  int *piVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long **pplVar6;\n  void *__ptr;\n  size_t __n;\n  long lVar7;\n  long *plVar8;\n  undefined4 *puVar9;\n  ulong uVar10;\n  size_t sVar11;\n  undefined4 local_c8 [6];\n  __mode_t _Stack_b0;\n  ulong uStack_98;\n  undefined8 uStack_80;\n  undefined8 uStack_70;\n  \n  if (_DAT_0010d600 !\u003d 0) {\n    puVar9 \u003d local_c8;\n    for (lVar7 \u003d 0x24; lVar7 !\u003d 0; lVar7 \u003d lVar7 + -1) {\n      *puVar9 \u003d 0;\n      puVar9 \u003d puVar9 + 1;\n    }\n  }\n  pplVar6 \u003d (long **)param_1[0x1d];\n  if ((long **)param_1[0x1d] \u003d\u003d (long **)0x0) {\n    pplVar6 \u003d param_1;\n  }\n  iVar2 \u003d (*(code *)pplVar6[1][0x3d])(param_1,local_c8);\n  if (iVar2 !\u003d 0) {\n    plVar8 \u003d *param_1;\n    uVar5 \u003d dcgettext(0,\"internal stat error on %s\",5);\n    iVar2 \u003d FUN_00107690(uVar5,plVar8);\n    uVar5 \u003d DAT_0010d638;\n    if (iVar2 \u003d\u003d 3) {\n      for (; *plVar8 !\u003d 0; plVar8 \u003d (long *)(*plVar8 + 0xf0)) {\n      }\n    }\n    else {\n      for (; (undefined8 *)*plVar8 !\u003d (undefined8 *)0x0; plVar8 \u003d (long *)(*plVar8 + 0xf0)) {\n        iVar1 \u003d filename_cmp(*(undefined8 *)*plVar8,uVar5);\n        if (iVar1 \u003d\u003d 0) {\n          if (iVar2 !\u003d 2) {\n            return plVar8;\n          }\n          return (long *)(*plVar8 + 0xf0);\n        }\n      }\n    }\n    return plVar8;\n  }\n  bfd_seek(param_1,0,0);\n  DAT_0010d5d8 \u003d (FILE *)0x0;\n  if (uStack_98 \u003d\u003d 0) {\nLAB_00102ca2:\n    DAT_0010d5d8 \u003d (FILE *)FUN_00105a20(*param_1);\n  }\n  else {\n    uVar10 \u003d 0;\n    __ptr \u003d (void *)xmalloc(0x2000);\n    do {\n      sVar11 \u003d uStack_98 - uVar10;\n      if (0x2000 \u003c sVar11) {\n        sVar11 \u003d 0x2000;\n      }\n      __n \u003d bfd_bread(__ptr,sVar11,param_1);\n      if (sVar11 !\u003d __n) {\nLAB_00102c78:\n        param_1 \u003d (long **)*param_1[0x1d];\n        uVar5 \u003d dcgettext(0,\"%s is not a valid archive\",5);\n        FUN_00107690(uVar5,param_1);\n        goto LAB_00102ca2;\n      }\n      if (DAT_0010d5d8 \u003d\u003d (FILE *)0x0) {\n        DAT_0010d5d8 \u003d (FILE *)FUN_00105a20(*param_1);\n      }\n      sVar11 \u003d fwrite(__ptr,1,__n,DAT_0010d5d8);\n      if (sVar11 !\u003d __n) {\n        piVar3 \u003d __errno_location();\n        pcVar4 \u003d strerror(*piVar3);\n        FUN_00107690(\"%s: %s\",DAT_0010d618,pcVar4);\n        goto LAB_00102c78;\n      }\n      uVar10 \u003d uVar10 + __n;\n    } while (uVar10 \u003c uStack_98);\n    free(__ptr);\n  }\n  fclose(DAT_0010d5d8);\n  pcVar4 \u003d DAT_0010d618;\n  DAT_0010d5d8 \u003d (FILE *)0x0;\n  chmod(DAT_0010d618,_Stack_b0);\n  if (_DAT_0010d600 !\u003d 0) {\n    uStack_80 \u003d uStack_70;\n    FUN_00107c80(pcVar4,local_c8);\n  }\n  DAT_0010d618 \u003d (char *)0x0;\n  return (long *)0x0;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103e95",
        "FUN_00105db0"
      ],
      "called": [
        "FUN_00102c25"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107890": {
      "entrypoint": "0x00107890",
      "current_name": "FUN_00107890",
      "code": "\n\n\nvoid FUN_00107890(undefined8 param_1)\n\n{\n  FUN_001079c0(_stdout,param_1,DAT_0010d60c !\u003d 0,_DAT_0010d5fc !\u003d 0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [
        "FUN_001079c0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001078c0": {
      "entrypoint": "0x001078c0",
      "current_name": "FUN_001078c0",
      "code": "\n\n\nvoid FUN_001078c0(char *param_1,__gnuc_va_list param_2)\n\n{\n  fflush(_stdout);\n  fprintf(_stderr,\"%s: \",DAT_0010d660);\n  vfprintf(_stderr,param_1,param_2);\n  putc(10,_stderr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107690",
        "FUN_00107920"
      ],
      "called": [
        "fflush",
        "putc",
        "fprintf",
        "vfprintf"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107920": {
      "entrypoint": "0x00107920",
      "current_name": "FUN_00107920",
      "code": "\nvoid FUN_00107920(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                 undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,\n                 undefined8 param_13,undefined8 param_14)\n\n{\n  char in_AL;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL !\u003d \u0027\\0\u0027) {\n    local_88 \u003d param_1;\n    local_78 \u003d param_2;\n    local_68 \u003d param_3;\n    local_58 \u003d param_4;\n    local_48 \u003d param_5;\n    local_38 \u003d param_6;\n    local_28 \u003d param_7;\n    local_18 \u003d param_8;\n  }\n  local_d0 \u003d \u0026stack0x00000008;\n  local_d8 \u003d 8;\n  local_c8 \u003d local_b8;\n  local_d4 \u003d 0x30;\n  local_b0 \u003d param_10;\n  local_a8 \u003d param_11;\n  local_a0 \u003d param_12;\n  local_98 \u003d param_13;\n  local_90 \u003d param_14;\n  FUN_001078c0(param_9,\u0026local_d8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102e6f",
        "FUN_001052a0",
        "FUN_00105300",
        "FUN_00102fd7",
        "FUN_00105db0",
        "FUN_001025a0",
        "FUN_00102f1e"
      ],
      "called": [
        "FUN_001078c0"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_001079c0": {
      "entrypoint": "0x001079c0",
      "current_name": "FUN_001079c0",
      "code": "\nvoid FUN_001079c0(FILE *param_1,char **param_2,char param_3,char param_4)\n\n{\n  int iVar1;\n  char **ppcVar2;\n  char *pcVar3;\n  uint uVar4;\n  time_t local_100;\n  undefined uStack_f3;\n  char cStack_f2;\n  char cStack_f1;\n  char cStack_f0;\n  char cStack_ef;\n  char cStack_ee;\n  char cStack_ed;\n  char cStack_ec;\n  char cStack_eb;\n  char cStack_ea;\n  undefined uStack_e9;\n  char local_e8 [48];\n  undefined local_b8 [24];\n  uint uStack_a0;\n  uint uStack_9c;\n  uint uStack_98;\n  undefined8 uStack_88;\n  time_t local_60;\n  \n  if (param_3 !\u003d \u0027\\0\u0027) {\n    ppcVar2 \u003d (char **)param_2[0x1d];\n    if ((char **)param_2[0x1d] \u003d\u003d (char **)0x0) {\n      ppcVar2 \u003d param_2;\n    }\n    iVar1 \u003d (**(code **)(ppcVar2[1] + 0x1e8))(param_2,local_b8);\n    if (iVar1 \u003d\u003d 0) {\n      local_100 \u003d local_60;\n      pcVar3 \u003d ctime(\u0026local_100);\n      if (pcVar3 \u003d\u003d (char *)0x0) {\n        pcVar3 \u003d (char *)dcgettext(0,\"\u003ctime data corrupt\u003e\",5);\n        sprintf(local_e8,pcVar3);\n      }\n      else {\n        sprintf(local_e8,\"%.12s %.4s\",pcVar3 + 4);\n      }\n      uVar4 \u003d uStack_a0 \u0026 0xf000;\n      if (uVar4 \u003d\u003d 0x4000) {\n        uStack_f3 \u003d 100;\n      }\n      else if (uVar4 \u003d\u003d 0xa000) {\n        uStack_f3 \u003d 0x6c;\n      }\n      else if (uVar4 \u003d\u003d 0x6000) {\n        uStack_f3 \u003d 0x62;\n      }\n      else if (uVar4 \u003d\u003d 0x2000) {\n        uStack_f3 \u003d 99;\n      }\n      else if (uVar4 \u003d\u003d 0xc000) {\n        uStack_f3 \u003d 0x73;\n      }\n      else {\n        uStack_f3 \u003d 0x70;\n        if (uVar4 !\u003d 0x1000) {\n          uStack_f3 \u003d 0x2d;\n        }\n      }\n      cStack_f2 \u003d (-((uStack_a0 \u0026 0x100) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n      cStack_f1 \u003d (-((uStack_a0 \u0026 0x80) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n      cStack_f0 \u003d (-((uStack_a0 \u0026 0x40) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n      cStack_ef \u003d (-((uStack_a0 \u0026 0x20) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n      cStack_ee \u003d (-((uStack_a0 \u0026 0x10) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n      cStack_ed \u003d (-((uStack_a0 \u0026 8) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n      cStack_ec \u003d (-((uStack_a0 \u0026 4) \u003d\u003d 0) \u0026 0xbbU) + 0x72;\n      cStack_eb \u003d (-((uStack_a0 \u0026 2) \u003d\u003d 0) \u0026 0xb6U) + 0x77;\n      cStack_ea \u003d (-((uStack_a0 \u0026 1) \u003d\u003d 0) \u0026 0xb5U) + 0x78;\n      if ((uStack_a0 \u0026 0x800) !\u003d 0) {\n        if (cStack_f0 \u003d\u003d \u0027x\u0027) {\n          cStack_f0 \u003d \u0027s\u0027;\n        }\n        else {\n          cStack_f0 \u003d \u0027S\u0027;\n        }\n      }\n      if ((uStack_a0 \u0026 0x400) !\u003d 0) {\n        if (cStack_ed \u003d\u003d \u0027x\u0027) {\n          cStack_ed \u003d \u0027s\u0027;\n        }\n        else {\n          cStack_ed \u003d \u0027S\u0027;\n        }\n      }\n      if ((uStack_a0 \u0026 0x200) !\u003d 0) {\n        if (cStack_ea \u003d\u003d \u0027x\u0027) {\n          cStack_ea \u003d \u0027t\u0027;\n        }\n        else {\n          cStack_ea \u003d \u0027T\u0027;\n        }\n      }\n      uStack_e9 \u003d 0;\n      fprintf(param_1,\"%s %ld/%ld %6lu %s \",\u0026cStack_f2,(ulong)uStack_9c,(ulong)uStack_98,uStack_88,\n              local_e8,(ulong)uStack_a0);\n    }\n  }\n  fputs(*param_2,param_1);\n  if (param_4 !\u003d \u0027\\0\u0027) {\n    if ((*(byte *)((long)param_2 + 0x49) \u0026 0x10) \u003d\u003d 0) {\n      if (param_2[0xb] !\u003d (char *)0x0) {\n        fprintf(param_1,\" 0x%lx\");\n      }\n    }\n    else if (param_2[0xc] !\u003d (char *)0x0) {\n      fprintf(param_1,\" 0x%lx\");\n    }\n  }\n  fputc(10,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00103ddc",
        "FUN_00107890"
      ],
      "called": [
        "sprintf",
        "FUN_00102d8c",
        "ctime"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107c10": {
      "entrypoint": "0x00107c10",
      "current_name": "FUN_00107c10",
      "code": "\nvoid FUN_00107c10(void)\n\n{\n  FUN_00107c20();\n                    \n  xexit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_001028ed",
        "FUN_00105300",
        "FUN_00105db0",
        "FUN_001058b0",
        "FUN_00102d2f"
      ],
      "called": [
        "xexit",
        "FUN_00107c20"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107c20": {
      "entrypoint": "0x00107c20",
      "current_name": "FUN_00107c20",
      "code": "\n\n\nvoid FUN_00107c20(long param_1)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 in_R10;\n  \n  iVar1 \u003d bfd_get_error();\n  if (iVar1 \u003d\u003d 0) {\n    uVar2 \u003d dcgettext(0,\"cause of error unknown\",5);\n  }\n  else {\n    uVar2 \u003d bfd_errmsg(iVar1);\n  }\n  fflush(_stdout);\n  if (param_1 !\u003d 0) {\n    fprintf(_stderr,\"%s: %s: %s\\n\",DAT_0010d660,param_1,uVar2,in_R10);\n    return;\n  }\n  fprintf(_stderr,\"%s: %s\\n\",DAT_0010d660,uVar2,in_R10);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00107c10",
        "FUN_00105300",
        "FUN_00105db0"
      ],
      "called": [
        "bfd_get_error",
        "bfd_errmsg",
        "FUN_00102f96"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107c80": {
      "entrypoint": "0x00107c80",
      "current_name": "FUN_00107c80",
      "code": "\nvoid FUN_00107c80(char *param_1,long param_2)\n\n{\n  int iVar1;\n  int *piVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  undefined4 local_38;\n  undefined4 uStack_34;\n  undefined4 uStack_30;\n  undefined4 uStack_2c;\n  undefined4 local_28;\n  undefined4 uStack_24;\n  undefined4 uStack_20;\n  undefined4 uStack_1c;\n  \n  local_28 \u003d *(undefined4 *)(param_2 + 0x58);\n  uStack_24 \u003d *(undefined4 *)(param_2 + 0x5c);\n  uStack_20 \u003d *(undefined4 *)(param_2 + 0x60);\n  uStack_1c \u003d *(undefined4 *)(param_2 + 100);\n  local_38 \u003d *(undefined4 *)(param_2 + 0x48);\n  uStack_34 \u003d *(undefined4 *)(param_2 + 0x4c);\n  uStack_30 \u003d *(undefined4 *)(param_2 + 0x50);\n  uStack_2c \u003d *(undefined4 *)(param_2 + 0x54);\n  iVar1 \u003d utimensat(-100,param_1,(timespec *)\u0026local_38,0);\n  if (iVar1 !\u003d 0) {\n    piVar2 \u003d __errno_location();\n    pcVar3 \u003d strerror(*piVar2);\n    uVar4 \u003d dcgettext(0,\"%s: cannot set time: %s\",5);\n    FUN_00107920(uVar4,param_1,pcVar3);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00102c25"
      ],
      "called": [
        "utimensat",
        "FUN_00102fd7"
      ],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "FUN_00107cc0": {
      "entrypoint": "0x00107cc0",
      "current_name": "FUN_00107cc0",
      "code": "\nvoid FUN_00107cc0(void)\n\n{\n  long lVar1;\n  long lVar2;\n  long lVar3;\n  long *plVar4;\n  uint uVar5;\n  \n  plVar4 \u003d (long *)PTR_DAT_0010d2e0;\n  if (PTR_DAT_0010d2e0 !\u003d (undefined *)0x0) {\n    do {\n      uVar5 \u003d *(int *)(plVar4 + 1) - 1;\n      if (-1 \u003c (int)uVar5) {\n        lVar1 \u003d (long)(int)uVar5;\n        uVar5 \u003d uVar5 \u0026 7;\n        (*(code *)plVar4[lVar1 + 2])();\n        lVar2 \u003d lVar1 + -1;\n        if (-1 \u003c (int)lVar2) {\n          lVar3 \u003d lVar2;\n          if (uVar5 !\u003d 0) {\n            if (uVar5 !\u003d 1) {\n              if (uVar5 !\u003d 2) {\n                if (uVar5 !\u003d 3) {\n                  if (uVar5 !\u003d 4) {\n                    if (uVar5 !\u003d 5) {\n                      if (uVar5 !\u003d 6) {\n                        (*(code *)plVar4[lVar1 + 1])();\n                        lVar2 \u003d lVar1 + -2;\n                      }\n                      (*(code *)plVar4[lVar2 + 2])();\n                      lVar2 \u003d lVar2 + -1;\n                    }\n                    (*(code *)plVar4[lVar2 + 2])();\n                    lVar2 \u003d lVar2 + -1;\n                  }\n                  (*(code *)plVar4[lVar2 + 2])();\n                  lVar2 \u003d lVar2 + -1;\n                }\n                (*(code *)plVar4[lVar2 + 2])();\n                lVar2 \u003d lVar2 + -1;\n              }\n              (*(code *)plVar4[lVar2 + 2])();\n              lVar2 \u003d lVar2 + -1;\n            }\n            (*(code *)plVar4[lVar2 + 2])();\n            lVar3 \u003d lVar2 + -1;\n            if ((int)(lVar2 + -1) \u003c 0) goto LAB_00107d96;\n          }\n          do {\n            (*(code *)plVar4[lVar3 + 2])();\n            lVar1 \u003d lVar3 + -1;\n            (*(code *)plVar4[lVar3 + 1])();\n            (*(code *)plVar4[lVar3])();\n            (*(code *)plVar4[lVar1])();\n            (*(code *)plVar4[lVar3 + -2])();\n            (*(code *)plVar4[lVar3 + -3])();\n            (*(code *)plVar4[lVar3 + -4])();\n            (*(code *)plVar4[lVar3 + -5])();\n            lVar3 \u003d lVar3 + -8;\n          } while (-1 \u003c (int)lVar1 + -7);\n        }\n      }\nLAB_00107d96:\n      plVar4 \u003d (long *)*plVar4;\n    } while (plVar4 !\u003d (long *)0x0);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "FUN_00105db0"
      ],
      "called": [],
      "improved": false,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_DT_FINI": {
      "entrypoint": "0x00107da8",
      "current_name": "_DT_FINI",
      "code": "\nvoid _DT_FINI(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}