{
    "functions": {
        "FUN_0800010c": {
            "entrypoint": "0x0800010c",
            "current_name": "initialize_d_tflag_0800010c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08000118) */\n\nundefined4 initializeDTflag_0800010c(undefined4 inputData)\n\n{\n  if ((char)DAT_20000160 == '\\0') {\n    DAT_20000160._0_1_ = '\\x01';\n  }\n  return inputData;\n}\n\n",
            "renaming": {
                "FUN_0800010c": "initialize_d_tflag_0800010c",
                "param_1": "inputData"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000178": {
            "entrypoint": "0x08000178",
            "current_name": "find_end_of_string_08000178",
            "code": "\nchar * find_end_of_string_08000178(char *string)\n\n{\n  char current_char;\n  char *next_char;\n  char *ptr_string;\n  \n  ptr_string = string;\n  do {\n    next_char = ptr_string + 1;\n    current_char = *ptr_string;\n    ptr_string = next_char;\n  } while (current_char != '\\0');\n  return next_char + (-1 - (int)string);\n}\n\n",
            "renaming": {
                "FUN_08000178": "find_end_of_string_08000178",
                "param_1": "string",
                "cVar1": "current_char",
                "pcVar2": "next_char",
                "pcVar3": "ptr_string"
            },
            "calling": [
                "printNumber",
                "FUN_08005c96"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000190": {
            "entrypoint": "0x08000190",
            "current_name": "calculate_sum_08000190",
            "code": "\nulonglong calculate_sum_08000190(uint x,uint y,uint param_3,uint param_4)\n\n{\n  int shift1;\n  byte carry;\n  uint temp1;\n  uint var1;\n  uint var2;\n  uint x_shifted;\n  uint y_shifted;\n  int shift2;\n  uint partial_sum1;\n  uint partial_sum2;\n  uint sum;\n  uint carry_result;\n  bool condition1;\n  bool condition2;\n  bool overflow;\n  \n  x_shifted = param_4 ^ 0x80000000;\n  partial_sum1 = y << 1;\n  param_4 = param_4 << 1;\n  condition1 = ((y ^ x_shifted) & 0x7fffffff) == 0;\n  condition2 = condition1 && x == param_3;\n  if (!condition1 || x != param_3) {\n    condition2 = (partial_sum1 | x) == 0;\n  }\n  if (!condition2) {\n    condition2 = (param_4 | param_3) == 0;\n  }\n  shift2 = (int)partial_sum1 >> 0x15;\n  if (!condition2) {\n    condition2 = shift2 == -1;\n  }\n  shift1 = (int)param_4 >> 0x15;\n  if (!condition2) {\n    condition2 = shift1 == -1;\n  }\n  if (condition2) {\n    if (shift2 == -1 || shift1 == -1) {\n      partial_sum1 = x_shifted;\n      sum = param_3;\n      if (shift2 == -1) {\n        partial_sum1 = y;\n        sum = x;\n      }\n      if (shift2 != -1 || shift1 != -1) {\n        param_3 = sum;\n        x_shifted = partial_sum1;\n      }\n      condition2 = (sum | partial_sum1 << 0xc) == 0;\n      if (condition2) {\n        condition2 = (param_3 | x_shifted << 0xc) == 0;\n      }\n      if (condition2) {\n        condition2 = partial_sum1 == x_shifted;\n      }\n      if (!condition2) {\n        partial_sum1 = partial_sum1 | 0x80000;\n      }\n      return CONCAT44(partial_sum1,sum);\n    }\n    if (((y ^ x_shifted) & 0x7fffffff) != 0 || x != param_3) {\n      if ((partial_sum1 | x) == 0) {\n        x = param_3;\n        y = x_shifted;\n      }\n      return CONCAT44(y,x);\n    }\n    if (y != x_shifted) {\n      return 0;\n    }\n    if (partial_sum1 >> 0x15 == 0) {\n      condition2 = (x & 0x80000000) != 0;\n      x_shifted = y * 2 + (uint)condition2;\n      if (CARRY4(y,y) || CARRY4(y * 2,(uint)condition2)) {\n        x_shifted = x_shifted | 0x80000000;\n      }\n      return CONCAT44(x_shifted,x << 1);\n    }\n    if (partial_sum1 < 0xffc00000) {\n      return CONCAT44(y + 0x100000,x);\n    }\n    y = y & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(y | 0x7ff00000) << 0x20;\n  }\n  partial_sum1 = partial_sum1 >> 0x15;\n  param_4 = param_4 >> 0x15;\n  sum = param_4 - partial_sum1;\n  condition2 = sum != 0;\n  if (param_4 < partial_sum1) {\n    sum = -sum;\n  }\n  partial_sum2 = x;\n  y_shifted = y;\n  if (condition2 && partial_sum1 <= param_4) {\n    partial_sum1 = partial_sum1 + sum;\n    partial_sum2 = param_3;\n    y_shifted = x_shifted;\n    param_3 = x;\n    x_shifted = y;\n  }\n  if (0x36 < sum) {\n    return CONCAT44(y_shifted,partial_sum2);\n  }\n  var1 = y_shifted & 0xfffff | 0x100000;\n  if ((y_shifted & 0x80000000) != 0) {\n    condition2 = partial_sum2 != 0;\n    partial_sum2 = -partial_sum2;\n    var1 = -var1 - (uint)condition2;\n  }\n  y_shifted = x_shifted & 0xfffff | 0x100000;\n  if ((x_shifted & 0x80000000) != 0) {\n    condition2 = param_3 != 0;\n    param_3 = -param_3;\n    y_shifted = -y_shifted - (uint)condition2;\n  }\n  if (partial_sum1 == sum) {\n    y_shifted = y_shifted ^ 0x100000;\n    if (partial_sum1 == 0) {\n      var1 = var1 ^ 0x100000;\n      partial_sum1 = 1;\n    }\n    else {\n      sum = sum - 1;\n    }\n  }\n  x_shifted = -sum + 0x20;\n  if ((int)sum < 0x21) {\n    carry_result = param_3 << (x_shifted & 0xff);\n    param_3 = param_3 >> (sum & 0xff);\n    temp1 = partial_sum2 + param_3;\n    var2 = y_shifted << (x_shifted & 0xff);\n    x_shifted = temp1 + var2;\n    var1 = var1 + CARRY4(partial_sum2,param_3) + ((int)y_shifted >> (sum & 0xff)) +\n            (uint)CARRY4(temp1,var2);\n  }\n  else {\n    carry_result = y_shifted << (-sum + 0x40 & 0xff);\n    if (param_3 != 0) {\n      carry_result = carry_result | 2;\n    }\n    y_shifted = (int)y_shifted >> (sum - 0x20 & 0xff);\n    x_shifted = partial_sum2 + y_shifted;\n    var1 = var1 + ((int)y_shifted >> 0x1f) + (uint)CARRY4(partial_sum2,y_shifted);\n  }\n  y = var1 & 0x80000000;\n  sum = var1;\n  if ((int)var1 < 0) {\n    condition2 = carry_result == 0;\n    carry_result = -carry_result;\n    sum = -x_shifted;\n    x_shifted = -(uint)!condition2 - x_shifted;\n    sum = -(uint)(condition2 <= sum) - var1;\n  }\n  if (0xfffff < sum) {\n    partial_sum2 = partial_sum1 - 1;\n    if (0x1fffff < sum) {\n      partial_sum2 = sum & 1;\n      sum = sum >> 1;\n      carry = (byte)x_shifted;\n      x_shifted = (uint)(partial_sum2 != 0) << 0x1f | x_shifted >> 1;\n      carry_result = (uint)(carry & 1) << 0x1f | carry_result >> 1;\n      partial_sum2 = partial_sum1;\n      if (0xffbfffff < partial_sum1 * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    condition2 = 0x7fffffff < carry_result;\n    if (carry_result == 0x80000000) {\n      condition2 = (x_shifted & 1) != 0;\n    }\n    return CONCAT44(sum + partial_sum2 * 0x100000 + (uint)CARRY4(x_shifted,(uint)condition2) | y,\n                    x_shifted + condition2);\n  }\n  condition1 = (carry_result & 0x80000000) != 0;\n  carry_result = carry_result << 1;\n  partial_sum2 = x_shifted * 2;\n  condition2 = CARRY4(x_shifted,x_shifted);\n  x_shifted = x_shifted * 2 + (uint)condition1;\n  sum = sum * 2 + (uint)(condition2 || CARRY4(partial_sum2,(uint)condition1));\n  partial_sum2 = partial_sum1 - 2;\n  if ((sum & 0x100000) != 0) goto LAB_080002a0;\n  y_shifted = x_shifted;\n  partial_sum1 = sum;\n  if (sum == 0) {\n    y_shifted = 0;\n    partial_sum1 = x_shifted;\n  }\n  shift2 = LZCOUNT(partial_sum1);\n  if (sum == 0) {\n    shift2 = shift2 + 0x20;\n  }\n  sum = shift2 - 0xb;\n  overflow = SBORROW4(sum,0x20);\n  x_shifted = shift2 - 0x2b;\n  condition2 = (int)x_shifted < 0;\n  condition1 = x_shifted == 0;\n  if ((int)sum < 0x20) {\n    overflow = SCARRY4(x_shifted,0xc);\n    shift2 = shift2 + -0x1f;\n    condition2 = shift2 < 0;\n    condition1 = shift2 == 0;\n    x_shifted = sum;\n    if (!condition1 && condition2 == overflow) {\n      y_shifted = partial_sum1 << (sum & 0xff);\n      partial_sum1 = partial_sum1 >> (0xcU - shift2 & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (condition1 || condition2 != overflow) {\n    carry_result = 0x20 - x_shifted;\n  }\n  partial_sum1 = partial_sum1 << (x_shifted & 0xff);\n  if (condition1 || condition2 != overflow) {\n    partial_sum1 = partial_sum1 | y_shifted >> (carry_result & 0xff);\n  }\n  if (condition1 || condition2 != overflow) {\n    y_shifted = y_shifted << (x_shifted & 0xff);\n  }\nLAB_08000318:\n  if ((int)sum <= (int)partial_sum2) {\n    return CONCAT44(partial_sum1 + (partial_sum2 - sum) * 0x100000 | y,y_shifted);\n  }\n  x_shifted = ~(partial_sum2 - sum);\n  if ((int)x_shifted < 0x1f) {\n    shift2 = x_shifted - 0x13;\n    if (shift2 != 0 && shift2 < 0 == SCARRY4(x_shifted - 0x1f,0xc)) {\n      return CONCAT44(var1,y_shifted >> (0x20 - (0xcU - shift2) & 0xff) | partial_sum1 << (0xcU - shift2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    x_shifted = x_shifted + 1;\n    return CONCAT44(y | partial_sum1 >> (x_shifted & 0xff),\n                    y_shifted >> (x_shifted & 0xff) | partial_sum1 << (0x20 - x_shifted & 0xff));\n  }\n  return CONCAT44(var1,partial_sum1 >> (x_shifted - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000190": "calculate_sum_08000190",
                "param_1": "x",
                "param_2": "y",
                "iVar1": "shift1",
                "bVar2": "carry",
                "uVar3": "temp1",
                "uVar4": "var1",
                "uVar5": "var2",
                "uVar6": "x_shifted",
                "uVar7": "y_shifted",
                "iVar8": "shift2",
                "uVar9": "partial_sum1",
                "uVar10": "partial_sum2",
                "uVar11": "sum",
                "uVar12": "carry_result",
                "bVar13": "condition1",
                "bVar14": "condition2",
                "bVar15": "overflow"
            },
            "calling": [
                "Compute",
                "printFloat",
                "SetControllerDirection",
                "FUN_08001814"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000194": {
            "entrypoint": "0x08000194",
            "current_name": "calculate_unsigned_division_result_08000194",
            "code": "\nulonglong calculateUnsignedDivisionResult_08000194(uint dividend,uint divisor,uint quotient,uint remainder)\n\n{\n  int divisorShifted;\n  byte bit;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int quotientShifted;\n  uint divisorMask;\n  uint dividendTemp;\n  uint remainderTemp;\n  uint quotientTemp;\n  uint bitValue;\n  uint incrementedDivisorShifted;\n  bool isDivisorNegative;\n  bool isQuotientZero;\n  bool isLessThanDivisor;\n  \n  divisorMask = divisor << 1;\n  remainderTemp = remainder << 1;\n  isDivisorNegative = ((divisor ^ remainder) & 0x7fffffff) == 0;\n  isQuotientZero = isDivisorNegative && dividend == quotient;\n  if (!isDivisorNegative || dividend != quotient) {\n    isQuotientZero = (divisorMask | dividend) == 0;\n  }\n  if (!isQuotientZero) {\n    isQuotientZero = (remainderTemp | quotient) == 0;\n  }\n  quotientShifted = (int)divisorMask >> 0x15;\n  if (!isQuotientZero) {\n    isQuotientZero = quotientShifted == -1;\n  }\n  divisorShifted = (int)remainderTemp >> 0x15;\n  if (!isQuotientZero) {\n    isQuotientZero = divisorShifted == -1;\n  }\n  if (isQuotientZero) {\n    if (quotientShifted == -1 || divisorShifted == -1) {\n      remainderTemp = remainder;\n      divisorMask = quotient;\n      if (quotientShifted == -1) {\n        remainderTemp = divisor;\n        divisorMask = dividend;\n      }\n      if (quotientShifted != -1 || divisorShifted != -1) {\n        quotient = divisorMask;\n        remainder = remainderTemp;\n      }\n      isQuotientZero = (divisorMask | remainderTemp << 0xc) == 0;\n      if (isQuotientZero) {\n        isQuotientZero = (quotient | remainder << 0xc) == 0;\n      }\n      if (isQuotientZero) {\n        isQuotientZero = remainderTemp == remainder;\n      }\n      if (!isQuotientZero) {\n        remainderTemp = remainderTemp | 0x80000;\n      }\n      return CONCAT44(remainderTemp,divisorMask);\n    }\n    if (((divisor ^ remainder) & 0x7fffffff) != 0 || dividend != quotient) {\n      if ((divisorMask | dividend) == 0) {\n        dividend = quotient;\n        divisor = remainder;\n      }\n      return CONCAT44(divisor,dividend);\n    }\n    if (divisor != remainder) {\n      return 0;\n    }\n    if (divisorMask >> 0x15 == 0) {\n      isQuotientZero = (dividend & 0x80000000) != 0;\n      remainderTemp = divisor * 2 + (uint)isQuotientZero;\n      if (CARRY4(divisor,divisor) || CARRY4(divisor * 2,(uint)isQuotientZero)) {\n        remainderTemp = remainderTemp | 0x80000000;\n      }\n      return CONCAT44(remainderTemp,dividend << 1);\n    }\n    if (divisorMask < 0xffc00000) {\n      return CONCAT44(divisor + 0x100000,dividend);\n    }\n    divisor = divisor & 0x80000000;\nLAB_080003d4:\n    return (ulonglong)(divisor | 0x7ff00000) << 0x20;\n  }\n  divisorMask = divisorMask >> 0x15;\n  remainderTemp = remainderTemp >> 0x15;\n  quotientTemp = remainderTemp - divisorMask;\n  isQuotientZero = quotientTemp != 0;\n  if (remainderTemp < divisorMask) {\n    quotientTemp = -quotientTemp;\n  }\n  dividendTemp = dividend;\n  temp3 = divisor;\n  if (isQuotientZero && divisorMask <= remainderTemp) {\n    divisorMask = divisorMask + quotientTemp;\n    dividendTemp = quotient;\n    temp3 = remainder;\n    quotient = dividend;\n    remainder = divisor;\n  }\n  if (0x36 < quotientTemp) {\n    return CONCAT44(temp3,dividendTemp);\n  }\n  remainderTemp = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    isQuotientZero = dividendTemp != 0;\n    dividendTemp = -dividendTemp;\n    remainderTemp = -remainderTemp - (uint)isQuotientZero;\n  }\n  temp3 = remainder & 0xfffff | 0x100000;\n  if ((remainder & 0x80000000) != 0) {\n    isQuotientZero = quotient != 0;\n    quotient = -quotient;\n    temp3 = -temp3 - (uint)isQuotientZero;\n  }\n  if (divisorMask == quotientTemp) {\n    temp3 = temp3 ^ 0x100000;\n    if (divisorMask == 0) {\n      remainderTemp = remainderTemp ^ 0x100000;\n      divisorMask = 1;\n    }\n    else {\n      quotientTemp = quotientTemp - 1;\n    }\n  }\n  incrementedDivisorShifted = -quotientTemp + 0x20;\n  if ((int)quotientTemp < 0x21) {\n    bitValue = quotient << (incrementedDivisorShifted & 0xff);\n    quotient = quotient >> (quotientTemp & 0xff);\n    temp1 = dividendTemp + quotient;\n    temp2 = temp3 << (incrementedDivisorShifted & 0xff);\n    incrementedDivisorShifted = temp1 + temp2;\n    remainderTemp = remainderTemp + CARRY4(dividendTemp,quotient) + ((int)temp3 >> (quotientTemp & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    bitValue = temp3 << (-quotientTemp + 0x40 & 0xff);\n    if (quotient != 0) {\n      bitValue = bitValue | 2;\n    }\n    temp3 = (int)temp3 >> (quotientTemp - 0x20 & 0xff);\n    incrementedDivisorShifted = dividendTemp + temp3;\n    remainderTemp = remainderTemp + ((int)temp3 >> 0x1f) + (uint)CARRY4(dividendTemp,temp3);\n  }\n  divisor = remainderTemp & 0x80000000;\n  quotientTemp = remainderTemp;\n  if ((int)remainderTemp < 0) {\n    isQuotientZero = bitValue == 0;\n    bitValue = -bitValue;\n    quotientTemp = -incrementedDivisorShifted;\n    incrementedDivisorShifted = -(uint)!isQuotientZero - incrementedDivisorShifted;\n    quotientTemp = -(uint)(isQuotientZero <= quotientTemp) - remainderTemp;\n  }\n  if (0xfffff < quotientTemp) {\n    dividendTemp = divisorMask - 1;\n    if (0x1fffff < quotientTemp) {\n      remainderTemp = quotientTemp & 1;\n      quotientTemp = quotientTemp >> 1;\n      bit = (byte)incrementedDivisorShifted;\n      incrementedDivisorShifted = (uint)(remainderTemp != 0) << 0x1f | incrementedDivisorShifted >> 1;\n      bitValue = (uint)(bit & 1) << 0x1f | bitValue >> 1;\n      dividendTemp = divisorMask;\n      if (0xffbfffff < divisorMask * 0x200000) goto LAB_080003d4;\n    }\nLAB_080002a0:\n    isQuotientZero = 0x7fffffff < bitValue;\n    if (bitValue == 0x80000000) {\n      isQuotientZero = (incrementedDivisorShifted & 1) != 0;\n    }\n    return CONCAT44(quotientTemp + dividendTemp * 0x100000 + (uint)CARRY4(incrementedDivisorShifted,(uint)isQuotientZero) | divisor,\n                    incrementedDivisorShifted + isQuotientZero);\n  }\n  isDivisorNegative = (bitValue & 0x80000000) != 0;\n  bitValue = bitValue << 1;\n  dividendTemp = incrementedDivisorShifted * 2;\n  isQuotientZero = CARRY4(incrementedDivisorShifted,incrementedDivisorShifted);\n  incrementedDivisorShifted = incrementedDivisorShifted * 2 + (uint)isDivisorNegative;\n  quotientTemp = quotientTemp * 2 + (uint)(isQuotientZero || CARRY4(dividendTemp,(uint)isDivisorNegative));\n  dividendTemp = divisorMask - 2;\n  if ((quotientTemp & 0x100000) != 0) goto LAB_080002a0;\n  temp3 = incrementedDivisorShifted;\n  divisorMask = quotientTemp;\n  if (quotientTemp == 0) {\n    temp3 = 0;\n    divisorMask = incrementedDivisorShifted;\n  }\n  quotientShifted = LZCOUNT(divisorMask);\n  if (quotientTemp == 0) {\n    quotientShifted = quotientShifted + 0x20;\n  }\n  incrementedDivisorShifted = quotientShifted - 0xb;\n  isLessThanDivisor = SBORROW4(incrementedDivisorShifted,0x20);\n  quotientTemp = quotientShifted - 0x2b;\n  isQuotientZero = (int)quotientTemp < 0;\n  isDivisorNegative = quotientTemp == 0;\n  if ((int)incrementedDivisorShifted < 0x20) {\n    isLessThanDivisor = SCARRY4(quotientTemp,0xc);\n    quotientShifted = quotientShifted + -0x1f;\n    isQuotientZero = quotientShifted < 0;\n    isDivisorNegative = quotientShifted == 0;\n    quotientTemp = incrementedDivisorShifted;\n    if (!isDivisorNegative && isQuotientZero == isLessThanDivisor) {\n      temp3 = divisorMask << (incrementedDivisorShifted & 0xff);\n      divisorMask = divisorMask >> (0xcU - quotientShifted & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isDivisorNegative || isQuotientZero != isLessThanDivisor) {\n    bitValue = 0x20 - quotientTemp;\n  }\n  divisorMask = divisorMask << (quotientTemp & 0xff);\n  if (isDivisorNegative || isQuotientZero != isLessThanDivisor) {\n    divisorMask = divisorMask | temp3 >> (bitValue & 0xff);\n  }\n  if (isDivisorNegative || isQuotientZero != isLessThanDivisor) {\n    temp3 = temp3 << (quotientTemp & 0xff);\n  }\nLAB_08000318:\n  if ((int)incrementedDivisorShifted <= (int)dividendTemp) {\n    return CONCAT44(divisorMask + (dividendTemp - incrementedDivisorShifted) * 0x100000 | divisor,temp3);\n  }\n  quotientTemp = ~(dividendTemp - incrementedDivisorShifted);\n  if ((int)quotientTemp < 0x1f) {\n    quotientShifted = quotientTemp - 0x13;\n    if (quotientShifted != 0 && quotientShifted < 0 == SCARRY4(quotientTemp - 0x1f,0xc)) {\n      return CONCAT44(remainderTemp,temp3 >> (0x20 - (0xcU - quotientShifted) & 0xff) | divisorMask << (0xcU - quotientShifted & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    quotientTemp = quotientTemp + 1;\n    return CONCAT44(divisor | divisorMask >> (quotientTemp & 0xff),\n                    temp3 >> (quotientTemp & 0xff) | divisorMask << (0x20 - quotientTemp & 0xff));\n  }\n  return CONCAT44(remainderTemp,divisorMask >> (quotientTemp - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000194": "calculate_unsigned_division_result_08000194",
                "param_1": "dividend",
                "param_2": "divisor",
                "param_3": "quotient",
                "param_4": "remainder",
                "iVar1": "divisorShifted",
                "bVar2": "bit",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "quotientShifted",
                "uVar7": "divisorMask",
                "uVar8": "dividendTemp",
                "uVar9": "remainderTemp",
                "uVar10": "quotientTemp",
                "uVar11": "bitValue",
                "uVar12": "incrementedDivisorShifted",
                "bVar13": "isDivisorNegative",
                "bVar14": "isQuotientZero",
                "bVar15": "isLessThanDivisor"
            },
            "calling": [
                "readThermocouple",
                "Compute",
                "printFloat",
                "loop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800040c": {
            "entrypoint": "0x0800040c",
            "current_name": "shift_and_combine_0800040c",
            "code": "\nulonglong shiftAndCombine_0800040c(uint input)\n\n{\n  uint result_low;\n  uint shift_value;\n  int count;\n  uint shift_amount;\n  uint remaining_shift_amount;\n  bool is_negative;\n  bool is_zero;\n  bool is_carry_set;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result_low = 0;\n  count = LZCOUNT(input);\n  shift_amount = count + 0x15;\n  is_carry_set = SBORROW4(shift_amount,0x20);\n  shift_value = count - 0xb;\n  is_negative = (int)shift_value < 0;\n  is_zero = shift_value == 0;\n  if (shift_amount < 0x20) {\n    is_carry_set = SCARRY4(shift_value,0xc);\n    is_negative = false;\n    is_zero = count + 1 == 0;\n    shift_value = shift_amount;\n    if (!is_zero && is_carry_set == false) {\n      result_low = input << shift_amount;\n      input = input >> (0xcU - (count + 1) & 0xff);\n      goto shift_and_combine_label;\n    }\n  }\n  if (is_zero || is_negative != is_carry_set) {\n    remaining_shift_amount = 0x20 - shift_value;\n  }\n  input = input << (shift_value & 0xff);\n  if (is_zero || is_negative != is_carry_set) {\n    input = input | 0U >> (remaining_shift_amount & 0xff);\n  }\n  if (is_zero || is_negative != is_carry_set) {\n    result_low = 0 << (shift_value & 0xff);\n  }\nshift_and_combine_label:\n  if (shift_amount < 0x433) {\n    return CONCAT44(input + (0x432 - shift_amount) * 0x100000,result_low);\n  }\n  shift_value = ~(0x432 - shift_amount);\n  if (0x1e < (int)shift_value) {\n    return (ulonglong)(input >> (shift_value - 0x1f & 0xff));\n  }\n  count = shift_value - 0x13;\n  if (count == 0 || count < 0 != SCARRY4(shift_value - 0x1f,0xc)) {\n    shift_value = shift_value + 1;\n    return CONCAT44(input >> (shift_value & 0xff),\n                    result_low >> (shift_value & 0xff) | input << (0x20 - shift_value & 0xff));\n  }\n  return (ulonglong)(result_low >> (0x20 - (0xcU - count) & 0xff) | input << (0xcU - count & 0xff));\n}\n\n",
            "renaming": {
                "FUN_0800040c": "shift_and_combine_0800040c",
                "param_1": "input",
                "uVar1": "result_low",
                "uVar2": "shift_value",
                "iVar3": "count",
                "uVar4": "shift_amount",
                "in_r12": "remaining_shift_amount",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "is_carry_set",
                "LAB_08000318": "shift_and_combine_label"
            },
            "calling": [
                "readThermocouple",
                "printFloat",
                "loop",
                "SetSampleTime",
                "FUN_08001814"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800042c": {
            "entrypoint": "0x0800042c",
            "current_name": "bitwise_shift_and_concatenate_0800042c",
            "code": "\nulonglong bitwiseShiftAndConcatenate_0800042c(uint inputValue)\n\n{\n  uint shiftCount;\n  uint tempValue;\n  uint newShiftCount;\n  int bitCount;\n  uint constantValue;\n  uint signBit;\n  uint remainingBits;\n  bool isNegative;\n  bool isZero;\n  bool carryFlag;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  signBit = inputValue & 0x80000000;\n  tempValue = inputValue;\n  if ((int)signBit < 0) {\n    tempValue = -inputValue;\n  }\n  shiftCount = 0;\n  bitCount = LZCOUNT(tempValue);\n  constantValue = bitCount + 0x15;\n  carryFlag = SBORROW4(constantValue,0x20);\n  newShiftCount = bitCount - 0xb;\n  isNegative = (int)newShiftCount < 0;\n  isZero = newShiftCount == 0;\n  if (constantValue < 0x20) {\n    carryFlag = SCARRY4(newShiftCount,0xc);\n    isNegative = false;\n    isZero = bitCount + 1 == 0;\n    newShiftCount = constantValue;\n    if (!isZero && carryFlag == false) {\n      shiftCount = tempValue << constantValue;\n      tempValue = tempValue >> (0xcU - (bitCount + 1) & 0xff);\n      goto LAB_08000318;\n    }\n  }\n  if (isZero || isNegative != carryFlag) {\n    remainingBits = 0x20 - newShiftCount;\n  }\n  tempValue = tempValue << (newShiftCount & 0xff);\n  if (isZero || isNegative != carryFlag) {\n    tempValue = tempValue | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isNegative != carryFlag) {\n    shiftCount = 0 << (newShiftCount & 0xff);\n  }\nLAB_08000318:\n  if (constantValue < 0x433) {\n    return CONCAT44(tempValue + (0x432 - constantValue) * 0x100000 | signBit,shiftCount);\n  }\n  newShiftCount = ~(0x432 - constantValue);\n  if (0x1e < (int)newShiftCount) {\n    return CONCAT44(inputValue,tempValue >> (newShiftCount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  bitCount = newShiftCount - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(newShiftCount - 0x1f,0xc)) {\n    newShiftCount = newShiftCount + 1;\n    return CONCAT44(signBit | tempValue >> (newShiftCount & 0xff),\n                    shiftCount >> (newShiftCount & 0xff) | tempValue << (0x20 - newShiftCount & 0xff));\n  }\n  return CONCAT44(inputValue,shiftCount >> (0x20 - (0xcU - bitCount) & 0xff) | tempValue << (0xcU - bitCount & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800042c": "bitwise_shift_and_concatenate_0800042c",
                "param_1": "inputValue",
                "uVar1": "shiftCount",
                "uVar2": "tempValue",
                "uVar3": "newShiftCount",
                "iVar4": "bitCount",
                "uVar5": "constantValue",
                "uVar6": "signBit",
                "in_r12": "remainingBits",
                "bVar7": "isNegative",
                "bVar8": "isZero",
                "bVar9": "carryFlag"
            },
            "calling": [
                "printFloat",
                "loop",
                "SetSampleTime"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004f8": {
            "entrypoint": "0x080004f8",
            "current_name": "calculate_product_080004f8",
            "code": "\nulonglong calculateProduct_080004f8(undefined4 num1,uint num2,uint num3,uint num4)\n\n{\n  ulonglong result;\n  longlong temp;\n  uint highBitsNum2;\n  uint num2Exponent;\n  int sumExponents;\n  uint temp1;\n  uint num4Exponent;\n  uint num3Exponent;\n  uint carry;\n  bool isZero;\n  bool isGreater;\n  bool isNegative;\n  ulonglong num1AndNum2;\n  \n  num1AndNum2 = CONCAT44(num2,num1);\n  num3Exponent = 0x7ff;\n  num2Exponent = num2 >> 0x14 & 0x7ff;\n  isZero = num2Exponent == 0;\n  if (!isZero) {\n    num4Exponent = num4 >> 0x14 & 0x7ff;\n    isZero = num4Exponent == 0;\n  }\n  if (!isZero) {\n    isZero = num2Exponent == 0x7ff;\n  }\n  if (!isZero) {\n    isZero = num4Exponent == 0x7ff;\n  }\n  if (isZero) {\n    num1AndNum2 = bitwise_operation_080006d4();\n  }\n  highBitsNum2 = (uint)(num1AndNum2 >> 0x20);\n  sumExponents = num2Exponent + num4Exponent;\n  num2Exponent = highBitsNum2 ^ num4;\n  highBitsNum2 = highBitsNum2 & ~(num3Exponent << 0x15);\n  num4 = num4 & ~(num3Exponent << 0x15);\n  isZero = ((uint)num1AndNum2 | highBitsNum2 << 0xc) == 0;\n  if (!isZero) {\n    isZero = (num3 | num4 << 0xc) == 0;\n  }\n  highBitsNum2 = highBitsNum2 | 0x100000;\n  num4 = num4 | 0x100000;\n  if (isZero) {\n    num3 = (uint)num1AndNum2 | num3;\n    num4 = (num2Exponent & 0x80000000 | highBitsNum2) ^ num4;\n    num2Exponent = num3Exponent >> 1;\n    isNegative = SBORROW4(sumExponents,num2Exponent);\n    temp1 = sumExponents - num2Exponent;\n    isZero = temp1 == 0;\n    highBitsNum2 = temp1;\n    if (!isZero && (int)num2Exponent <= sumExponents) {\n      isNegative = SBORROW4(num3Exponent,temp1);\n      highBitsNum2 = num3Exponent - temp1;\n      isZero = num3Exponent == temp1;\n    }\n    if (!isZero && (int)highBitsNum2 < 0 == isNegative) {\n      num4 = num4 | temp1 * 0x100000;\n    }\n    if (!isZero && (int)highBitsNum2 < 0 == isNegative) {\n      return CONCAT44(num4,num3);\n    }\n    num4 = num4 | 0x100000;\n    num3Exponent = 0;\n    isNegative = SBORROW4(temp1,1);\n    temp1 = temp1 - 1;\n    isZero = temp1 == 0;\n    num2Exponent = temp1;\n  }\n  else {\n    result = (num1AndNum2 & 0xffffffff) * (ulonglong)num3;\n    num1AndNum2 = (num1AndNum2 & 0xffffffff) * (ulonglong)num4 +\n             (ulonglong)highBitsNum2 * (ulonglong)num3 + (result >> 0x20);\n    carry = (uint)num1AndNum2;\n    temp = (ulonglong)highBitsNum2 * (ulonglong)num4 + (num1AndNum2 >> 0x20);\n    num3Exponent = (uint)temp;\n    highBitsNum2 = (uint)((ulonglong)temp >> 0x20);\n    if ((int)result != 0) {\n      carry = carry | 1;\n    }\n    temp1 = (sumExponents + -0x3ff) - (uint)(highBitsNum2 < 0x200);\n    if (highBitsNum2 < 0x200) {\n      isZero = (carry & 0x80000000) != 0;\n      carry = carry << 1;\n      temp = CONCAT44(highBitsNum2 * 2 + (uint)(CARRY4(num3Exponent,num3Exponent) || CARRY4(num3Exponent * 2,(uint)isZero)),\n                       num3Exponent * 2 + (uint)isZero);\n    }\n    num4 = num2Exponent & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    num3 = (uint)temp << 0xb | carry >> 0x15;\n    num3Exponent = carry * 0x800;\n    isGreater = 0xfc < temp1;\n    isNegative = SBORROW4(temp1,0xfd);\n    highBitsNum2 = temp1 - 0xfd;\n    isZero = highBitsNum2 == 0;\n    num2Exponent = highBitsNum2;\n    if (isGreater && !isZero) {\n      isGreater = 0x6ff < highBitsNum2;\n      isNegative = SBORROW4(highBitsNum2,0x700);\n      num2Exponent = temp1 - 0x7fd;\n      isZero = highBitsNum2 == 0x700;\n    }\n    if (!isGreater || isZero) {\n      isZero = 0x7fffffff < num3Exponent;\n      if (num3Exponent == 0x80000000) {\n        isZero = (carry >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(num4 + temp1 * 0x100000 + (uint)CARRY4(num3,(uint)isZero),num3 + isZero\n                     );\n    }\n  }\n  if (!isZero && (int)num2Exponent < 0 == isNegative) {\n    return (ulonglong)(num4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  isGreater = SCARRY4(temp1,0x36);\n  isZero = (int)(temp1 + 0x36) < 0;\n  isNegative = temp1 == 0xffffffca;\n  if (isNegative || isZero != isGreater) {\n    num3 = 0;\n  }\n  if (isNegative || isZero != isGreater) {\n    num4 = num4 & 0x80000000;\n  }\n  if (isNegative || isZero != isGreater) {\n    return CONCAT44(num4,num3);\n  }\n  num2Exponent = -temp1;\n  highBitsNum2 = num2Exponent - 0x20;\n  if (0x1f < (int)num2Exponent) {\n    temp1 = num3 >> (highBitsNum2 & 0xff) | num4 << (0x20 - highBitsNum2 & 0xff);\n    num2Exponent = (num4 >> (highBitsNum2 & 0xff) & ~((num4 & 0x80000000) >> (highBitsNum2 & 0xff))) -\n            ((int)temp1 >> 0x1f);\n    if ((num3Exponent | num3 << (0x20 - highBitsNum2 & 0xff) | temp1 << 1) == 0) {\n      num2Exponent = num2Exponent & ~(temp1 >> 0x1f);\n    }\n    return CONCAT44(num4,num2Exponent) & 0x80000000ffffffff;\n  }\n  sumExponents = num2Exponent - 0x14;\n  if (sumExponents == 0 || sumExponents < 0 != SCARRY4(highBitsNum2,0xc)) {\n    carry = num3 << (temp1 + 0x20 & 0xff);\n    highBitsNum2 = num3 >> (num2Exponent & 0xff) | num4 << (temp1 + 0x20 & 0xff);\n    temp1 = highBitsNum2 + -((int)carry >> 0x1f);\n    if ((num3Exponent | carry << 1) == 0) {\n      temp1 = temp1 & ~(carry >> 0x1f);\n    }\n    return CONCAT44((num4 & 0x80000000) +\n                    ((num4 & 0x7fffffff) >> (num2Exponent & 0xff)) +\n                    (uint)CARRY4(highBitsNum2,-((int)carry >> 0x1f)),temp1);\n  }\n  num2Exponent = 0xc - sumExponents;\n  temp1 = num3 << (num2Exponent & 0xff);\n  num2Exponent = num3 >> (0x20 - num2Exponent & 0xff) | num4 << (num2Exponent & 0xff);\n  highBitsNum2 = num2Exponent + -((int)temp1 >> 0x1f);\n  if ((num3Exponent | temp1 << 1) == 0) {\n    highBitsNum2 = highBitsNum2 & ~(temp1 >> 0x1f);\n  }\n  return CONCAT44((num4 & 0x80000000) + (uint)CARRY4(num2Exponent,-((int)temp1 >> 0x1f)),highBitsNum2);\n}\n\n",
            "renaming": {
                "FUN_080004f8": "calculate_product_080004f8",
                "param_1": "num1",
                "param_2": "num2",
                "param_3": "num3",
                "param_4": "num4",
                "uVar1": "result",
                "lVar2": "temp",
                "uVar3": "highBitsNum2",
                "uVar4": "num2Exponent",
                "iVar5": "sumExponents",
                "uVar6": "temp1",
                "unaff_r5": "num4Exponent",
                "uVar7": "num3Exponent",
                "uVar8": "carry",
                "bVar9": "isZero",
                "bVar10": "isGreater",
                "bVar11": "isNegative",
                "uVar12": "num1AndNum2"
            },
            "calling": [
                "readThermocouple",
                "Compute",
                "printFloat",
                "SetSampleTime",
                "FUN_08001814"
            ],
            "called": [
                "FUN_080006d4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006d4": {
            "entrypoint": "0x080006d4",
            "current_name": "bitwise_operation_080006d4",
            "code": "\nulonglong bitwise_operation_080006d4(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint output1;\n  uint temp1;\n  uint temp2;\n  uint output2;\n  uint temp3;\n  bool flag;\n  \n  temp2 = temp3 & input4 >> 0x14;\n  if (temp1 != temp3 && temp2 != temp3) {\n    flag = (input1 | input2 << 1) == 0;\n    if (!flag) {\n      flag = (input3 | input4 << 1) == 0;\n    }\n    if (flag) {\n      return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n    }\n    if (temp1 == 0) {\n      output2 = input2 & 0x80000000;\n      do {\n        output1 = input1 & 0x80000000;\n        input1 = input1 << 1;\n        input2 = input2 * 2 + (uint)(output1 != 0);\n      } while ((input2 & 0x100000) == 0);\n      input2 = input2 | output2;\n      if (temp2 != 0) {\n        return CONCAT44(input2,input1);\n      }\n    }\n    do {\n      temp2 = input3 & 0x80000000;\n      input3 = input3 << 1;\n      input4 = input4 * 2 + (uint)(temp2 != 0);\n    } while ((input4 & 0x100000) == 0);\n    return CONCAT44(input2,input1);\n  }\n  flag = (input1 | input2 << 1) == 0;\n  if (flag) {\n    input2 = input4;\n    input1 = input3;\n  }\n  if (!flag) {\n    flag = (input3 | input4 << 1) == 0;\n  }\n  output2 = input2;\n  if (((!flag) && ((temp1 != temp3 || ((input1 | input2 << 0xc) == 0)))) &&\n     ((temp2 != temp3 || (input1 = input3, output2 = input4, (input3 | input4 << 0xc) == 0)))) {\n    return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(output2,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006d4": "bitwise_operation_080006d4",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "output1",
                "unaff_r4": "temp1",
                "uVar2": "temp2",
                "uVar3": "output2",
                "in_r12": "temp3",
                "bVar4": "flag"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800074c": {
            "entrypoint": "0x0800074c",
            "current_name": "calculate_float_0800074c",
            "code": "\nulonglong calculate_float_0800074c(undefined4 input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint value1;\n  uint value2;\n  uint value3;\n  uint value4;\n  uint value5;\n  uint value6;\n  uint value7;\n  int difference;\n  uint result;\n  uint unaff_r5;\n  uint value10;\n  uint value11;\n  uint value12;\n  uint bitwise_mask;\n  bool condition1;\n  bool condition2;\n  bool condition3;\n  undefined8 updated_value;\n  \n  updated_value = CONCAT44(input_2,input_1);\n  bitwise_mask = 0x7ff;\n  value7 = input_2 >> 0x14 & 0x7ff;\n  condition1 = value7 == 0;\n  if (!condition1) {\n    unaff_r5 = input_4 >> 0x14 & 0x7ff;\n    condition1 = unaff_r5 == 0;\n  }\n  if (!condition1) {\n    condition1 = value7 == 0x7ff;\n  }\n  if (!condition1) {\n    condition1 = unaff_r5 == 0x7ff;\n  }\n  if (condition1) {\n    updated_value = calculate_float_0800074c_080008ba();\n  }\n  result = (uint)((ulonglong)updated_value >> 0x20);\n  value11 = (uint)updated_value;\n  difference = value7 - unaff_r5;\n  if ((input_3 | input_4 << 0xc) == 0) {\n    value7 = (result ^ input_4) & 0x80000000 | result & 0xfffff;\n    condition3 = SCARRY4(difference,bitwise_mask >> 1);\n    result = difference + (bitwise_mask >> 1);\n    condition1 = (int)result < 0;\n    condition2 = result == 0;\n    if (!condition2 && condition1 == condition3) {\n      condition3 = SBORROW4(bitwise_mask,result);\n      condition1 = (int)(bitwise_mask - result) < 0;\n      condition2 = bitwise_mask == result;\n    }\n    if (!condition2 && condition1 == condition3) {\n      value7 = value7 | result * 0x100000;\n    }\n    if (!condition2 && condition1 == condition3) {\n      return CONCAT44(value7,value11);\n    }\n    value7 = value7 | 0x100000;\n    bitwise_mask = 0;\n    condition2 = SBORROW4(result,1);\n    result = result - 1;\n    condition1 = result == 0;\n    value3 = result;\n  }\n  else {\n    value3 = (input_4 << 0xc) >> 4 | 0x10000000 | input_3 >> 0x18;\n    bitwise_mask = input_3 << 8;\n    value10 = (result << 0xc) >> 4 | 0x10000000 | value11 >> 0x18;\n    value11 = value11 * 0x100;\n    value7 = (result ^ input_4) & 0x80000000;\n    condition1 = value3 <= value10;\n    if (value10 == value3) {\n      condition1 = bitwise_mask <= value11;\n    }\n    difference = difference + (uint)condition1;\n    result = difference + 0x3fd;\n    if (condition1 == false) {\n      value3 = value3 >> 1;\n      bitwise_mask = (uint)((input_3 >> 0x18 & 1) != 0) << 0x1f | bitwise_mask >> 1;\n    }\n    value12 = value11 - bitwise_mask;\n    value10 = (value10 - value3) - (uint)(value11 < bitwise_mask);\n    value4 = value3 >> 1;\n    value1 = (uint)((value3 & 1) != 0) << 0x1f | bitwise_mask >> 1;\n    value11 = 0x100000;\n    value3 = 0x80000;\n    while( true ) {\n      condition1 = value1 <= value12;\n      if (value4 < value10 || value10 - value4 < (uint)condition1) {\n        value12 = value12 - value1;\n        value11 = value11 | value3;\n        value10 = (value10 - value4) - (uint)!condition1;\n      }\n      value5 = value4 >> 1;\n      value1 = (uint)((value4 & 1) != 0) << 0x1f | value1 >> 1;\n      condition2 = value1 <= value12;\n      condition1 = value10 - value5 < (uint)condition2;\n      bitwise_mask = value10;\n      if (value5 < value10 || condition1) {\n        value12 = value12 - value1;\n        bitwise_mask = (value10 - value5) - (uint)!condition2;\n      }\n      if (value5 < value10 || condition1) {\n        value11 = value11 | value3 >> 1;\n      }\n      value10 = value4 >> 2;\n      value2 = (uint)((value5 & 1) != 0) << 0x1f | value1 >> 1;\n      condition2 = value2 <= value12;\n      condition1 = bitwise_mask - value10 < (uint)condition2;\n      value5 = bitwise_mask;\n      if (value10 < bitwise_mask || condition1) {\n        value12 = value12 - value2;\n        value5 = (bitwise_mask - value10) - (uint)!condition2;\n      }\n      if (value10 < bitwise_mask || condition1) {\n        value11 = value11 | value3 >> 2;\n      }\n      value6 = value4 >> 3;\n      value1 = (uint)((value10 & 1) != 0) << 0x1f | value2 >> 1;\n      condition2 = value1 <= value12;\n      condition1 = value5 - value6 < (uint)condition2;\n      value10 = value5;\n      if (value6 < value5 || condition1) {\n        value12 = value12 - value1;\n        value10 = (value5 - value6) - (uint)!condition2;\n      }\n      if (value6 < value5 || condition1) {\n        value11 = value11 | value3 >> 3;\n      }\n      bitwise_mask = value10 | value12;\n      if (bitwise_mask == 0) break;\n      value10 = value10 << 4 | value12 >> 0x1c;\n      value12 = value12 << 4;\n      value4 = value4 & 0xfffffff8 | value1 >> 0x1d;\n      value1 = (value2 >> 1) << 3;\n      value3 = value3 >> 4;\n      if (value3 == 0) {\n        value6 = value4;\n        if ((value7 & 0x100000) != 0) goto LAB_0800086a;\n        value7 = value7 | value11;\n        value11 = 0;\n        value3 = 0x80000000;\n      }\n    }\n    if ((value7 & 0x100000) == 0) {\n      value7 = value7 | value11;\n      value11 = 0;\n    }\nLAB_0800086a:\n    condition3 = 0xfc < result;\n    condition2 = SBORROW4(result,0xfd);\n    value4 = difference + 0x300;\n    condition1 = value4 == 0;\n    value3 = value4;\n    if (condition3 && !condition1) {\n      condition3 = 0x6ff < value4;\n      condition2 = SBORROW4(value4,0x700);\n      value3 = difference - 0x400;\n      condition1 = value4 == 0x700;\n    }\n    if (!condition3 || condition1) {\n      condition1 = value6 <= value10;\n      if (value10 == value6) {\n        condition1 = value1 <= value12;\n      }\n      if (value10 == value6 && value12 == value1) {\n        condition1 = (value11 & 1) != 0;\n      }\n      return CONCAT44(value7 + result * 0x100000 + (uint)CARRY4(value11,(uint)condition1),value11 + condition1);\n    }\n  }\n  if (!condition1 && (int)value3 < 0 == condition2) {\n    return (ulonglong)(value7 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  condition3 = SCARRY4(result,0x36);\n  condition1 = (int)(result + 0x36) < 0;\n  condition2 = result == 0xffffffca;\n  if (condition2 || condition1 != condition3) {\n    value11 = 0;\n  }\n  if (condition2 || condition1 != condition3) {\n    value7 = value7 & 0x80000000;\n  }\n  if (condition2 || condition1 != condition3) {\n    return CONCAT44(value7,value11);\n  }\n  value3 = -result;\n  value10 = value3 - 0x20;\n  if (0x1f < (int)value3) {\n    value3 = value11 >> (value10 & 0xff) | value7 << (0x20 - value10 & 0xff);\n    result = (value7 >> (value10 & 0xff) & ~((value7 & 0x80000000) >> (value10 & 0xff))) -\n            ((int)value3 >> 0x1f);\n    if ((bitwise_mask | value11 << (0x20 - value10 & 0xff) | value3 << 1) == 0) {\n      result = result & ~(value3 >> 0x1f);\n    }\n    return CONCAT44(value7,result) & 0x80000000ffffffff;\n  }\n  difference = value3 - 0x14;\n  if (difference != 0 && difference < 0 == SCARRY4(value10,0xc)) {\n    result = 0xc - difference;\n    value3 = value11 << (result & 0xff);\n    value11 = value11 >> (0x20 - result & 0xff) | value7 << (result & 0xff);\n    result = value11 + -((int)value3 >> 0x1f);\n    if ((bitwise_mask | value3 << 1) == 0) {\n      result = result & ~(value3 >> 0x1f);\n    }\n    return CONCAT44((value7 & 0x80000000) + (uint)CARRY4(value11,-((int)value3 >> 0x1f)),result);\n  }\n  value10 = value11 << (result + 0x20 & 0xff);\n  value11 = value11 >> (value3 & 0xff) | value7 << (result + 0x20 & 0xff);\n  result = value11 + -((int)value10 >> 0x1f);\n  if ((bitwise_mask | value10 << 1) == 0) {\n    result = result & ~(value10 >> 0x1f);\n  }\n  return CONCAT44((value7 & 0x80000000) +\n                  ((value7 & 0x7fffffff) >> (value3 & 0xff)) +\n                  (uint)CARRY4(value11,-((int)value10 >> 0x1f)),result);\n}\n\n",
            "renaming": {
                "FUN_0800074c": "calculate_float_0800074c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "value1",
                "uVar2": "value2",
                "uVar3": "value3",
                "uVar4": "value4",
                "uVar5": "value5",
                "uVar6": "value6",
                "uVar7": "value7",
                "iVar8": "difference",
                "uVar9": "result",
                "uVar10": "value10",
                "uVar11": "value11",
                "uVar12": "value12",
                "uVar13": "bitwise_mask",
                "bVar14": "condition1",
                "bVar15": "condition2",
                "bVar16": "condition3",
                "uVar17": "updated_value"
            },
            "calling": [
                "readThermocouple",
                "printFloat",
                "SetSampleTime",
                "FUN_08001814"
            ],
            "called": [
                "FUN_080008ba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008ba": {
            "entrypoint": "0x080008ba",
            "current_name": "calculate_float_080008ba",
            "code": "\nulonglong calculate_float_080008ba(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool isZero;\n  \n  temp3 = temp5 & input4 >> 0x14;\n  temp4 = input2;\n  if (temp2 != temp5 || temp3 != temp5) {\n    if (temp2 == temp5) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, temp4 = input4, temp3 != temp5)\n         ) {\nLAB_0800072c:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (temp3 == temp5) {\n      input1 = input3;\n      temp4 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006f0:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input1 | input2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input3 | input4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (temp2 == 0) {\n          temp4 = input2 & 0x80000000;\n          do {\n            temp1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(temp1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | temp4;\n          if (temp3 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          temp4 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(temp4 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_0800072c;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006f0;\n    }\n  }\n  return CONCAT44(temp4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080008ba": "calculate_float_080008ba",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "temp1",
                "unaff_r4": "temp2",
                "uVar2": "temp3",
                "uVar3": "temp4",
                "in_r12": "temp5",
                "bVar4": "isZero"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800092c": {
            "entrypoint": "0x0800092c",
            "current_name": "check_parameters_0800092c",
            "code": "\nuint check_parameters_0800092c(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result;\n  bool isZero;\n  bool isLess;\n  \n  if (((int)(input_2 << 1) >> 0x15 == -1 || (int)(input_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_2 << 1) >> 0x15 == -1 && ((input_1 | input_2 << 0xc) != 0)) ||\n      (((int)(input_4 << 1) >> 0x15 == -1 && ((input_3 | input_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  isZero = (input_1 | input_2 << 1) == 0;\n  if (isZero) {\n    isZero = (input_3 | input_4 << 1) == 0;\n  }\n  if (!isZero) {\n    isZero = input_2 == input_4;\n  }\n  if (isZero) {\n    isZero = input_1 == input_3;\n  }\n  if (!isZero) {\n    result = input_2 ^ input_4;\n    isZero = result == 0;\n    if (-1 < (int)result) {\n      isZero = input_2 == input_4;\n    }\n    isLess = -1 < (int)result && input_4 <= input_2;\n    if (isZero) {\n      isLess = input_3 <= input_1;\n    }\n    input_4 = (int)input_4 >> 0x1f;\n    if (!isLess) {\n      input_4 = ~input_4;\n    }\n    return input_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800092c": "check_parameters_0800092c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result",
                "bVar2": "isZero",
                "bVar3": "isLess"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009a8": {
            "entrypoint": "0x080009a8",
            "current_name": "compare_floats_080009a8",
            "code": "\nvoid compareFloats_080009a8(undefined4 result,undefined4 status,undefined4 float1,undefined4 float2)\n\n{\n  __aeabi_cdcmpeq(float1,float2,result,status);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080009a8": "compare_floats_080009a8",
                "param_1": "result",
                "param_2": "status",
                "param_3": "float1",
                "param_4": "float2"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009b8": {
            "entrypoint": "0x080009b8",
            "current_name": "calculate_080009b8",
            "code": "\nundefined4 calculate_080009b8(undefined4 input)\n\n{\n  _performArithmetic();\n  return input;\n}\n\n",
            "renaming": {
                "FUN_080009b8": "calculate_080009b8",
                "param_1": "input",
                "_eqdf2": "performArithmetic"
            },
            "calling": [
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__aeabi_dcmple",
                "__aeabi_cdrcmple"
            ],
            "called": [
                "__eqdf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c8": {
            "entrypoint": "0x080009c8",
            "current_name": "check_if_not_equal_zero_080009c8",
            "code": "\nbool checkIfNotEqualZero_080009c8(void)\n\n{\n  char inputChar;\n  \n  __aeabi_cdcmpeq();\n  return inputChar != '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009c8": "check_if_not_equal_zero_080009c8",
                "in_ZR": "inputChar"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009dc": {
            "entrypoint": "0x080009dc",
            "current_name": "check_if_null_character_080009dc",
            "code": "\nbool check_if_null_character_080009dc(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdcmpeq();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009dc": "check_if_null_character_080009dc",
                "in_CY": "input_character"
            },
            "calling": [
                "Compute",
                "Initialize",
                "printFloat",
                "SetOutputLimits",
                "loop",
                "FUN_08001814"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009f0": {
            "entrypoint": "0x080009f0",
            "current_name": "check_equality_080009f0",
            "code": "\nbool check_equality_080009f0(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry;\n  \n  compare_double();\n  return !(bool)is_carry || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009f0": "check_equality_080009f0",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry",
                "__aeabi_cdcmpeq": "compare_double"
            },
            "calling": [
                "printFloat",
                "loop"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a04": {
            "entrypoint": "0x08000a04",
            "current_name": "check_rounded_comparison_result_08000a04",
            "code": "\nbool checkRoundedComparisonResult_08000a04(void)\n\n{\n  undefined isZero;\n  undefined isCarry;\n  \n  __aeabi_cdrcmple();\n  return !(bool)isCarry || (bool)isZero;\n}\n\n",
            "renaming": {
                "FUN_08000a04": "check_rounded_comparison_result_08000a04",
                "in_ZR": "isZero",
                "in_CY": "isCarry"
            },
            "calling": [
                "SetOutputLimits",
                "loop"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a18": {
            "entrypoint": "0x08000a18",
            "current_name": "is_null_terminated_08000a18",
            "code": "\nbool is_null_terminated_08000a18(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000a18": "is_null_terminated_08000a18",
                "in_CY": "input_char"
            },
            "calling": [
                "Compute",
                "Initialize",
                "printFloat",
                "SetOutputLimits",
                "loop"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a2c": {
            "entrypoint": "0x08000a2c",
            "current_name": "check_parameters_08000a2c",
            "code": "\nundefined4 check_parameters_08000a2c(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08000a2c": "check_parameters_08000a2c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000a58": {
            "entrypoint": "0x08000a58",
            "current_name": "apply_transformation_08000a58",
            "code": "\nuint applyTransformation_08000a58(uint inputValue,uint shiftValue)\n\n{\n  uint shiftedValue;\n  int scaleFactor;\n  uint offset;\n  \n  scaleFactor = shiftValue * 2 + 0x200000;\n  if (shiftValue * 2 < 0xffe00000) {\n    if (-1 < scaleFactor) {\n      return 0;\n    }\n    shiftedValue = scaleFactor >> 0x15;\n    offset = -shiftedValue - 0x3e1;\n    if (shiftedValue < 0xfffffc20 && offset != 0) {\n      shiftedValue = (shiftValue << 0xb | 0x80000000 | inputValue >> 0x15) >> (offset & 0xff);\n      if ((shiftValue & 0x80000000) != 0) {\n        shiftedValue = -shiftedValue;\n      }\n      return shiftedValue;\n    }\n  }\n  else if ((inputValue | shiftValue << 0xc) != 0) {\n    return 0;\n  }\n  shiftValue = shiftValue & 0x80000000;\n  if (shiftValue == 0) {\n    shiftValue = 0x7fffffff;\n  }\n  return shiftValue;\n}\n\n",
            "renaming": {
                "FUN_08000a58": "apply_transformation_08000a58",
                "param_1": "inputValue",
                "param_2": "shiftValue",
                "uVar1": "shiftedValue",
                "iVar2": "scaleFactor",
                "uVar3": "offset"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_shifted_value_08000aa8",
            "code": "\nuint calculate_shifted_value_08000aa8(uint input_value,uint shift_amount)\n\n{\n  int shifted_result;\n  uint shifted_value;\n  \n  if ((shift_amount & 0x80000000) != 0) {\n    return 0;\n  }\n  shifted_result = shift_amount * 2 + 0x200000;\n  if (shift_amount * 2 < 0xffe00000) {\n    if (-1 < shifted_result) {\n      return 0;\n    }\n    shifted_value = -(shifted_result >> 0x15) - 0x3e1;\n    if (-1 < (int)shifted_value) {\n      return (shift_amount << 0xb | 0x80000000 | input_value >> 0x15) >> (shifted_value & 0xff);\n    }\n  }\n  else if ((input_value | shift_amount << 0xc) != 0) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_shifted_value_08000aa8",
                "param_1": "input_value",
                "param_2": "shift_amount",
                "iVar1": "shifted_result",
                "uVar2": "shifted_value"
            },
            "calling": [
                "printFloat"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ae8": {
            "entrypoint": "0x08000ae8",
            "current_name": "execute_software_interrupt_08000ae8",
            "code": "\nvoid executeSoftwareInterrupt_08000ae8(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000ae8": "execute_software_interrupt_08000ae8"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aec": {
            "entrypoint": "0x08000aec",
            "current_name": "execute_afl_call_08000aec",
            "code": "\nundefined4 execute_afl_call_08000aec(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  undefined4 result;\n  \n  if (DAT_2000017c != 0) {\n    return 0;\n  }\n  result = aflCall(1,arg1,0,0,arg4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08000aec": "execute_afl_call_08000aec",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "uVar1": "result"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000b08": {
            "entrypoint": "0x08000b08",
            "current_name": "initialize_devices_08000b08",
            "code": "\nvoid initializeDevices_08000b08(int deviceType,int deviceCode)\n\n{\n  if ((deviceType == 1) && (deviceCode == 0xffff)) {\n    configurePID(&DAT_200001c0,&DAT_20000188,&DAT_200001b8,&DAT_20000240,DAT_20000020,DAT_20000024,\n        DAT_20000018,DAT_2000001c,DAT_20000010,DAT_20000014,0);\n    initializeLCD(&DAT_20000194,DAT_2000005c,DAT_20000038,DAT_20000028,DAT_2000002c,DAT_20000030,\n                  DAT_20000034);\n    initializeTemperatureSensor(&DAT_2000024c,DAT_20000074,DAT_20000070,DAT_2000006c);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000b08": "initialize_devices_08000b08",
                "param_1": "deviceType",
                "param_2": "deviceCode",
                "PID": "configurePID",
                "LiquidCrystal": "initializeLCD",
                "MAX31855": "initializeTemperatureSensor"
            },
            "calling": [],
            "called": [
                "PID",
                "MAX31855",
                "LiquidCrystal"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000bcc": {
            "entrypoint": "0x08000bcc",
            "current_name": "initialize_reflow_oven_08000bcc",
            "code": "\nvoid initializeReflowOven_08000bcc(void)\n\n{\n  digitalWrite(DAT_20000064,0);\n  pinMode(DAT_20000064,1);\n  digitalWrite(DAT_20000004,0);\n  pinMode(DAT_20000004,1);\n  digitalWrite(DAT_20000060,0);\n  pinMode(DAT_20000060,1);\n  digitalWrite(DAT_20000004,1);\n  initializeLCD(&DAT_20000194,8,2,0);\n  createCharacter(&DAT_20000194,0,&DAT_20000008);\n  clearScreen(&DAT_20000194);\n  processParameter(&DAT_20000194,\"Reflow\");\n  setCursor(&DAT_20000194,0,1);\n  processParameter(&DAT_20000194,\"Oven 1.2\");\n  digitalWrite(DAT_20000004,0);\n  delayExecution(0x9c4);\n  clearScreen(&DAT_20000194);\n  beginExecution(&DAT_2000036c,0xe100,6);\n  digitalWrite(DAT_20000060,1);\n  DAT_20000258 = 2000;\n  DAT_200001b0 = getMilliseconds();\n  DAT_200001b4 = getMilliseconds();\n  startForkServer(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000bcc": "initialize_reflow_oven_08000bcc",
                "initialize_lcd_080013a4": "initializeLCD",
                "createChar": "createCharacter",
                "clear": "clearScreen",
                "process_param_08005c96": "processParameter",
                "delay": "delayExecution",
                "begin": "beginExecution",
                "millis": "getMilliseconds",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "main"
            ],
            "called": [
                "begin",
                "setCursor",
                "createChar",
                "millis",
                "FUN_080013a4",
                "clear",
                "delay",
                "digitalWrite",
                "startForkserver",
                "FUN_08005c96",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cd0": {
            "entrypoint": "0x08000cd0",
            "current_name": "temperature_control_08000cd0",
            "code": "\nvoid temperatureControl_08000cd0(void)\n\n{\n  uint currentTime;\n  undefined4 temperature;\n  int comparisonResult;\n  undefined4 temperatureUpper;\n  undefined4 extraOutput1;\n  undefined4 extraOutput2;\n  undefined4 extraOutput3;\n  undefined8 result;\n  \n  currentTime = millis();\n  if (DAT_200001b4 < currentTime) {\n    DAT_200001b4 = DAT_200001b4 + 1000;\n    result = readThermocouple(&DAT_2000024c,0);\n    temperatureUpper = (undefined4)((ulonglong)result >> 0x20);\n    temperature = (undefined4)result;\n    DAT_20000188 = temperature;\n    DAT_2000018c = temperatureUpper;\n    comparisonResult = __aeabi_dcmpeq(temperature,temperatureUpper,0,0x40c38800);\n    if (((comparisonResult != 0) || (comparisonResult = __aeabi_dcmpeq(temperature,temperatureUpper,0,0x40c38880), comparisonResult != 0)) ||\n       (comparisonResult = __aeabi_dcmpeq(temperature,temperatureUpper,0,0x40c38900), comparisonResult != 0)) {\n      DAT_20000238 = 7;\n      DAT_20000239 = '\\0';\n    }\n  }\n  currentTime = millis();\n  temperature = DAT_20000060;\n  if (DAT_200001b0 < currentTime) {\n    DAT_200001b0 = DAT_200001b0 + 1000;\n    if (DAT_20000239 == '\\x01') {\n      comparisonResult = digitalRead(DAT_20000060);\n      digitalWrite(temperature,comparisonResult == 0);\n      DAT_20000250 = DAT_20000250 + 1;\n      execute_print_or_code_08005d82(&DAT_2000036c,DAT_20000250,10);\n      process_param_08005c96(&DAT_2000036c,&DAT_08007368);\n      print(&DAT_2000036c,extraOutput1,DAT_20000240,DAT_20000244,2);\n      process_param_08005c96(&DAT_2000036c,&DAT_08007368);\n      print(&DAT_2000036c,extraOutput2,DAT_20000188,DAT_2000018c,2);\n      process_param_08005c96(&DAT_2000036c,&DAT_08007368);\n      println(&DAT_2000036c,extraOutput3,DAT_200001b8,DAT_200001bc,2);\n    }\n    else {\n      digitalWrite(DAT_20000060,1);\n    }\n    clear(&DAT_20000194);\n    process_param_08005c96(&DAT_20000194,(&PTR_s_Ready_2000003c)[DAT_20000238]);\n    setCursor(&DAT_20000194,0,1);\n    if (DAT_20000238 == 7) {\n      process_param_08005c96(&DAT_20000194,\"TC Error!\");\n    }\n    else {\n      print(&DAT_20000194,2,DAT_20000188,DAT_2000018c,2);\n      send_data_0800134e(&DAT_20000194,0);\n      process_param_08005c96(&DAT_20000194,&DAT_08007378);\n    }\n  }\n  temperatureUpper = DAT_2000018c;\n  temperature = DAT_20000188;\n  switch(DAT_20000238) {\n  case 0:\n    comparisonResult = __aeabi_dcmpge(DAT_20000188,DAT_2000018c,0,0x40490000);\n    if (comparisonResult == 0) {\n      if (DAT_20000248 == '\\x01') {\n        calculate_sum_08005cd4(&DAT_2000036c,\"Time Setpoint Input Output\");\n        DAT_20000250 = 0;\n        DAT_2000025c = millis();\n        DAT_20000240 = 0;\n        DAT_20000244 = 0x4062c000;\n        result = __floatsidf(DAT_20000258);\n        SetOutputLimits(&DAT_200001c0,(int)((ulonglong)result >> 0x20),0,0,result);\n        SetSampleTime(&DAT_200001c0,1000);\n        SetMode(&DAT_200001c0,1);\n        DAT_20000238 = 1;\n      }\n    }\n    else {\n      DAT_20000238 = 6;\n    }\n    break;\n  case 1:\n    DAT_20000239 = '\\x01';\n    comparisonResult = __aeabi_dcmpge(DAT_20000188,DAT_2000018c,0,0x4062c000);\n    if (comparisonResult != 0) {\n      result = millis();\n      DAT_20000254 = (int)result + 9000;\n      SetTunings(&DAT_200001c0,(int)((ulonglong)result >> 0x20),0,0x4072c000,0x9999999a,0x3fa99999,0,\n                 0x406f4000);\n      DAT_20000240 = 0;\n      DAT_20000244 = 0x40636000;\n      DAT_20000238 = 2;\n    }\n    break;\n  case 2:\n    currentTime = millis();\n    if (DAT_20000254 < currentTime) {\n      comparisonResult = millis();\n      DAT_20000254 = comparisonResult + 9000;\n      result = __aeabi_dadd(DAT_20000240,DAT_20000244,0,0x40140000);\n      DAT_20000244 = (undefined4)((ulonglong)result >> 0x20);\n      DAT_20000240 = (undefined4)result;\n      result = __aeabi_dcmpgt(DAT_20000240,DAT_20000244,0,0x40690000);\n      if ((int)result != 0) {\n        SetTunings(&DAT_200001c0,(int)((ulonglong)result >> 0x20),0,0x4072c000,0x9999999a,0x3fa99999,\n                   0,0x4075e000);\n        DAT_20000240 = 0;\n        DAT_20000244 = 0x406f4000;\n        DAT_20000238 = 3;\n      }\n    }\n    break;\n  case 3:\n    result = __aeabi_dcmpge(DAT_20000188,DAT_2000018c,0,0x406ea000);\n    if ((int)result != 0) {\n      SetTunings(&DAT_200001c0,(int)((ulonglong)result >> 0x20),0,0x4072c000,0x9999999a,0x3fa99999,0,\n                 0x4075e000);\n      DAT_20000240 = 0;\n      DAT_20000244 = 0x40590000;\n      DAT_20000238 = 4;\n    }\n    break;\n  case 4:\n    comparisonResult = __aeabi_dcmple(DAT_20000188,DAT_2000018c,0,0x40590000);\n    if (comparisonResult != 0) {\n      comparisonResult = millis();\n      DAT_20000180 = comparisonResult + 1000;\n      digitalWrite(DAT_20000004,1);\n      DAT_20000239 = '\\0';\n      DAT_20000238 = 5;\n    }\n    break;\n  case 5:\n    currentTime = millis();\n    if (DAT_20000180 < currentTime) {\n      digitalWrite(DAT_20000004,0);\n      DAT_20000238 = 0;\n    }\n    break;\n  case 6:\n    comparisonResult = __aeabi_dcmplt(DAT_20000188,DAT_2000018c,0,0x40490000);\n    if (comparisonResult != 0) {\n      DAT_20000238 = 0;\n    }\n    break;\n  case 7:\n    comparisonResult = __aeabi_dcmpeq(DAT_20000188,DAT_2000018c,0,0x40c38800);\n    if (((comparisonResult == 0) && (comparisonResult = __aeabi_dcmpeq(temperature,temperatureUpper,0,0x40c38880), comparisonResult == 0)) &&\n       (comparisonResult = __aeabi_dcmpeq(temperature,temperatureUpper,0,0x40c38900), comparisonResult == 0)) {\n      DAT_20000238 = 0;\n    }\n    else {\n      DAT_20000238 = 7;\n    }\n  }\n  if ((DAT_20000248 == '\\x01') && (DAT_20000239 == '\\x01')) {\n    DAT_20000239 = '\\0';\n    DAT_20000238 = 0;\n  }\n  if (DAT_20000184 == '\\x01') {\n    comparisonResult = analogRead(DAT_20000068);\n    if (comparisonResult == 0) {\n      comparisonResult = millis();\n      if (0x32 < (uint)(comparisonResult - DAT_20000190)) {\n        DAT_20000184 = '\\x02';\n      }\n    }\n    else {\n      DAT_20000184 = '\\0';\n    }\n  }\n  else if (DAT_20000184 == '\\0') {\n    DAT_20000248 = '\\0';\n    comparisonResult = analogRead(DAT_20000068);\n    if (comparisonResult == 0) {\n      DAT_20000190 = millis();\n      DAT_20000184 = '\\x01';\n    }\n  }\n  else if ((DAT_20000184 == '\\x02') && (comparisonResult = analogRead(DAT_20000068), comparisonResult != 0)) {\n    DAT_20000248 = '\\x01';\n    DAT_20000184 = '\\0';\n  }\n  if (DAT_20000239 == '\\x01') {\n    comparisonResult = millis();\n    Compute(&DAT_200001c0);\n    if (DAT_20000258 < (uint)(comparisonResult - DAT_2000025c)) {\n      DAT_2000025c = DAT_2000025c + DAT_20000258;\n    }\n    result = __floatunsidf(comparisonResult - DAT_2000025c);\n    comparisonResult = __aeabi_dcmplt((int)result,(int)((ulonglong)result >> 0x20),DAT_200001b8,DAT_200001bc);\n    if (comparisonResult == 0) {\n      digitalWrite(DAT_20000064,0);\n    }\n    else {\n      digitalWrite(DAT_20000064,1);\n    }\n  }\n  else {\n    digitalWrite(DAT_20000064,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000cd0": "temperature_control_08000cd0",
                "uVar1": "currentTime",
                "uVar2": "temperature",
                "iVar3": "comparisonResult",
                "uVar4": "temperatureUpper",
                "extraout_r1": "extraOutput1",
                "extraout_r1_00": "extraOutput2",
                "extraout_r1_01": "extraOutput3",
                "uVar5": "result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__floatsidf",
                "digitalRead",
                "SetMode",
                "__aeabi_dcmpgt",
                "print",
                "FUN_08005d82",
                "Compute",
                "millis",
                "setCursor",
                "digitalWrite",
                "FUN_08005c96",
                "__aeabi_dcmpeq",
                "FUN_0800134e",
                "SetTunings",
                "println",
                "__aeabi_dcmpge",
                "analogRead",
                "readThermocouple",
                "__aeabi_dadd",
                "__aeabi_dcmple",
                "clear",
                "FUN_08005cd4",
                "SetOutputLimits",
                "SetSampleTime",
                "__floatunsidf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001294": {
            "entrypoint": "0x08001294",
            "current_name": "set_params_08001294",
            "code": "\nvoid setParams_08001294(int object,undefined value1,undefined value2,undefined value3,\n                 undefined value4)\n\n{\n  *(undefined *)(object + 0x18) = value1;\n  *(undefined *)(object + 0x19) = value2;\n  *(undefined *)(object + 0x1a) = value3;\n  *(undefined *)(object + 0x1b) = value4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001294": "set_params_08001294",
                "param_1": "object",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "param_5": "value4"
            },
            "calling": [
                "FUN_080013a4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012a2": {
            "entrypoint": "0x080012a2",
            "current_name": "reset_digital_pin_080012a2",
            "code": "\nvoid resetDigitalPin_080012a2(int pinAddress)\n\n{\n  digitalWrite(*(undefined *)(pinAddress + 10),0);\n  digitalWrite(*(undefined *)(pinAddress + 10),1);\n  digitalWrite(*(undefined *)(pinAddress + 10),0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012a2": "reset_digital_pin_080012a2",
                "param_1": "pinAddress"
            },
            "calling": [
                "write8bits",
                "write4bits"
            ],
            "called": [
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012c0": {
            "entrypoint": "0x080012c0",
            "current_name": "update_digital_outputs_080012c0",
            "code": "\nvoid updateDigitalOutputs_080012c0(int baseAddress,int data)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 4; bitIndex = bitIndex + 1) {\n    digitalWrite(*(undefined *)(baseAddress + bitIndex + 0xb),data >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(baseAddress);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012c0": "update_digital_outputs_080012c0",
                "param_1": "baseAddress",
                "param_2": "data",
                "uVar1": "bitIndex"
            },
            "calling": [
                "FUN_080013a4",
                "send"
            ],
            "called": [
                "pulseEnable",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080012e8": {
            "entrypoint": "0x080012e8",
            "current_name": "write_bits_080012e8",
            "code": "\nvoid writeBits_080012e8(int dataPin,int value)\n\n{\n  uint bitIndex;\n  \n  for (bitIndex = 0; (int)bitIndex < 8; bitIndex = bitIndex + 1) {\n    digitalWrite(*(undefined *)(dataPin + bitIndex + 0xb),value >> (bitIndex & 0xff) & 1);\n  }\n  pulseEnable(dataPin);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080012e8": "write_bits_080012e8",
                "param_1": "dataPin",
                "param_2": "value",
                "uVar1": "bitIndex"
            },
            "calling": [
                "send"
            ],
            "called": [
                "pulseEnable",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001310": {
            "entrypoint": "0x08001310",
            "current_name": "write_data_08001310",
            "code": "\nvoid write_data_08001310(int data_ptr,uint value,undefined4 arg1,undefined4 arg2)\n\n{\n  digitalWrite(*(undefined *)(data_ptr + 8),arg1,arg1,arg2,arg2);\n  if (*(char *)(data_ptr + 9) != -1) {\n    digitalWrite(*(char *)(data_ptr + 9),0);\n  }\n  if ((*(byte *)(data_ptr + 0x13) & 0x10) == 0) {\n    write4bits(data_ptr,value >> 4);\n    write4bits(data_ptr,value);\n    return;\n  }\n  write8bits(data_ptr,value);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001310": "write_data_08001310",
                "param_1": "data_ptr",
                "param_2": "value",
                "param_3": "arg1",
                "param_4": "arg2"
            },
            "calling": [
                "FUN_0800134e",
                "display",
                "setCursor",
                "createChar",
                "FUN_080013a4",
                "clear"
            ],
            "called": [
                "write8bits",
                "write4bits",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800134e": {
            "entrypoint": "0x0800134e",
            "current_name": "send_data_0800134e",
            "code": "\nundefined4 send_data_0800134e(undefined4 socket_descriptor,undefined4 data,undefined4 data_length,undefined4 flags)\n\n{\n  send(socket_descriptor,data,1,flags,flags);\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800134e": "send_data_0800134e",
                "param_1": "socket_descriptor",
                "param_2": "data",
                "param_3": "data_length",
                "param_4": "flags"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800135a": {
            "entrypoint": "0x0800135a",
            "current_name": "send_data_0800135a",
            "code": "\nvoid send_data_0800135a(undefined4 socket,undefined4 flag,undefined4 buffer_size,undefined4 data)\n\n{\n  send_data_0800135a(socket,1,0,data,data);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800135a": "send_data_0800135a",
                "param_1": "socket",
                "param_2": "flag",
                "param_3": "buffer_size",
                "param_4": "data",
                "send": "send_data"
            },
            "calling": [
                "setup",
                "FUN_080013a4",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001366": {
            "entrypoint": "0x08001366",
            "current_name": "send_character_over_network_08001366",
            "code": "\nvoid send_character_over_network_08001366(int network_connection,char character,uint character_count,undefined4 additional_data)\n\n{\n  char selected_character;\n  \n  if (3 < character_count) {\n    character_count = 3;\n  }\n  if ((int)(uint)*(byte *)(network_connection + 0x17) <= (int)character_count) {\n    character_count = *(byte *)(network_connection + 0x17) - 1 & 0xff;\n  }\n  selected_character = *(char *)(character_count + network_connection + 0x18);\n  send(network_connection,character + selected_character | 0x80,0,selected_character,additional_data);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001366": "send_character_over_network_08001366",
                "param_1": "network_connection",
                "param_2": "character",
                "param_3": "character_count",
                "param_4": "additional_data",
                "cVar1": "selected_character"
            },
            "calling": [
                "setup",
                "loop"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800138e": {
            "entrypoint": "0x0800138e",
            "current_name": "update_and_send_data_0800138e",
            "code": "\nvoid updateAndSendData_0800138e(int data,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  byte byteValue;\n  \n  byteValue = *(byte *)(data + 0x14);\n  *(byte *)(data + 0x14) = byteValue | 4;\n  send(data,byteValue | 0xc,0,param4,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800138e": "update_and_send_data_0800138e",
                "param_1": "data",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "bVar1": "byteValue"
            },
            "calling": [
                "FUN_080013a4"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080013a4": {
            "entrypoint": "0x080013a4",
            "current_name": "initialize_lcd_080013a4",
            "code": "\nvoid initializeLCD_080013a4(int lcd,int row1,int row2,int isDualLine)\n\n{\n  int numIterations;\n  int counter;\n  \n  if (1 < row2) {\n    *(byte *)(lcd + 0x13) = *(byte *)(lcd + 0x13) | 8;\n  }\n  *(char *)(lcd + 0x17) = (char)row2;\n  setRowOffsets(lcd,0,0x40,row1,row1 + 0x40);\n  if ((isDualLine != 0) && (row2 == 1)) {\n    *(byte *)(lcd + 0x13) = *(byte *)(lcd + 0x13) | 4;\n  }\n  pinMode(*(undefined *)(lcd + 8),1);\n  if (*(char *)(lcd + 9) != -1) {\n    pinMode(*(char *)(lcd + 9),1);\n  }\n  pinMode(*(undefined *)(lcd + 10),1);\n  counter = 0;\n  while( true ) {\n    if ((*(byte *)(lcd + 0x13) & 0x10) == 0) {\n      numIterations = 4;\n    }\n    else {\n      numIterations = 8;\n    }\n    if (numIterations <= counter) break;\n    pinMode(*(undefined *)(lcd + counter + 0xb),1);\n    counter = counter + 1;\n  }\n  digitalWrite(*(undefined *)(lcd + 8),0);\n  digitalWrite(*(undefined *)(lcd + 10),0);\n  if (*(char *)(lcd + 9) != -1) {\n    digitalWrite(*(char *)(lcd + 9),0);\n  }\n  if ((*(byte *)(lcd + 0x13) & 0x10) == 0) {\n    write4bits(lcd,3);\n    write4bits(lcd,3);\n    write4bits(lcd,3);\n    write4bits(lcd,2);\n  }\n  else {\n    send(lcd,*(byte *)(lcd + 0x13) | 0x20,0);\n    send(lcd,*(byte *)(lcd + 0x13) | 0x20,0);\n    send(lcd,*(byte *)(lcd + 0x13) | 0x20,0);\n  }\n  send(lcd,*(byte *)(lcd + 0x13) | 0x20,0);\n  *(undefined *)(lcd + 0x14) = 4;\n  display(lcd);\n  clear(lcd);\n  *(undefined *)(lcd + 0x15) = 2;\n  send(lcd,6,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080013a4": "initialize_lcd_080013a4",
                "param_1": "lcd",
                "param_2": "row1",
                "param_3": "row2",
                "param_4": "isDualLine",
                "iVar1": "numIterations",
                "iVar2": "counter"
            },
            "calling": [
                "setup",
                "FUN_080014ba"
            ],
            "called": [
                "display",
                "clear",
                "write4bits",
                "setRowOffsets",
                "digitalWrite",
                "send",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014ba": {
            "entrypoint": "0x080014ba",
            "current_name": "initialize_lcd_080014ba",
            "code": "\nvoid initialize_lcd_080014ba(int lcd_address,int is_initialized,undefined lcd_undefined1,undefined4 lcd_undefined2,undefined lcd_undefined3,\n                 undefined lcd_undefined4,undefined lcd_undefined5,undefined lcd_undefined6,undefined lcd_undefined7,\n                 undefined lcd_undefined8,undefined lcd_undefined9,undefined lcd_undefined10,undefined lcd_undefined11)\n\n{\n  *(undefined *)(lcd_address + 8) = lcd_undefined1;\n  *(char *)(lcd_address + 9) = (char)lcd_undefined2;\n  *(undefined *)(lcd_address + 10) = lcd_undefined3;\n  *(undefined *)(lcd_address + 0xb) = lcd_undefined4;\n  *(undefined *)(lcd_address + 0xc) = lcd_undefined5;\n  *(undefined *)(lcd_address + 0xd) = lcd_undefined6;\n  *(undefined *)(lcd_address + 0xe) = lcd_undefined7;\n  *(undefined *)(lcd_address + 0xf) = lcd_undefined8;\n  *(undefined *)(lcd_address + 0x10) = lcd_undefined9;\n  *(undefined *)(lcd_address + 0x11) = lcd_undefined10;\n  *(undefined *)(lcd_address + 0x12) = lcd_undefined11;\n  if (is_initialized == 0) {\n    *(undefined *)(lcd_address + 0x13) = 0x10;\n  }\n  else {\n    *(undefined *)(lcd_address + 0x13) = 0;\n  }\n  initialize_lcd_080014ba_080013a4(lcd_address,0x10,1,0,lcd_undefined2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080014ba": "initialize_lcd_080014ba",
                "param_1": "lcd_address",
                "param_2": "is_initialized",
                "param_3": "lcd_undefined1",
                "param_4": "lcd_undefined2",
                "param_5": "lcd_undefined3",
                "param_6": "lcd_undefined4",
                "param_7": "lcd_undefined5",
                "param_8": "lcd_undefined6",
                "param_9": "lcd_undefined7",
                "param_10": "lcd_undefined8",
                "param_11": "lcd_undefined9",
                "param_12": "lcd_undefined10",
                "param_13": "lcd_undefined11"
            },
            "calling": [
                "LiquidCrystal"
            ],
            "called": [
                "FUN_080013a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001510": {
            "entrypoint": "0x08001510",
            "current_name": "initialize_and_configure_lcd_08001510",
            "code": "\nundefined4 *\ninitializeAndConfigureLCD_08001510(undefined4 *lcdBuffer,undefined4 param2,undefined4 param3,undefined4 param4,\n            undefined param5,undefined param6,undefined param7)\n\n{\n  lcdBuffer[1] = 0;\n  *lcdBuffer = &PTR_send_data_0800134e_1_080073f8;\n  initializeLCD(lcdBuffer,1,param2,0xff,param3,param4,param5,param6,param7,0,0,0,0);\n  return lcdBuffer;\n}\n\n",
            "renaming": {
                "FUN_08001510": "initialize_and_configure_lcd_08001510",
                "param_1": "lcdBuffer",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "initialize_lcd_080014ba": "initializeLCD"
            },
            "calling": [
                "FUN_08000b08"
            ],
            "called": [
                "FUN_080014ba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001550": {
            "entrypoint": "0x08001550",
            "current_name": "send_data_08001550",
            "code": "\nvoid sendData_08001550(undefined4 *socket,uint flag,int dataArray)\n\n{\n  int index;\n  \n  send(socket,(flag & 7) << 3 | 0x40,0);\n  for (index = 0; index < 8; index = index + 1) {\n    (**(code **)*socket)(socket,*(undefined *)(dataArray + index));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001550": "send_data_08001550",
                "param_1": "socket",
                "param_2": "flag",
                "param_3": "dataArray",
                "iVar1": "index"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "send"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "initialize_peripherals_0800157c",
            "code": "\nundefined * initializePeripherals_0800157c(undefined *peripheralArray,undefined4 pin1,undefined pin2Mode,undefined pin3Mode)\n\n{\n  *peripheralArray = (char)pin1;\n  peripheralArray[1] = pin2Mode;\n  peripheralArray[2] = pin3Mode;\n  pinMode(pin1,0);\n  pinMode(peripheralArray[1],1);\n  pinMode(peripheralArray[2],1);\n  digitalWrite(peripheralArray[1],1);\n  digitalWrite(peripheralArray[2],0);\n  return peripheralArray;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "initialize_peripherals_0800157c",
                "param_1": "peripheralArray",
                "param_2": "pin1",
                "param_3": "pin2Mode",
                "param_4": "pin3Mode"
            },
            "calling": [
                "FUN_08000b08"
            ],
            "called": [
                "digitalWrite",
                "pinMode"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b2": {
            "entrypoint": "0x080015b2",
            "current_name": "binary_to_decimal_080015b2",
            "code": "\nuint binaryToDecimal_080015b2(undefined *binaryArray)\n\n{\n  int digitalValue;\n  uint bitPosition;\n  uint decimalValue;\n  \n  digitalWrite(binaryArray[1],0);\n  decimalValue = 0;\n  for (bitPosition = 0x1f; -1 < (int)bitPosition; bitPosition = bitPosition - 1) {\n    digitalWrite(binaryArray[2],1);\n    digitalValue = digitalRead(*binaryArray);\n    if (digitalValue != 0) {\n      decimalValue = decimalValue | 1 << (bitPosition & 0xff);\n    }\n    digitalWrite(binaryArray[2],0);\n  }\n  digitalWrite(binaryArray[1],1);\n  return decimalValue;\n}\n\n",
            "renaming": {
                "FUN_080015b2": "binary_to_decimal_080015b2",
                "param_1": "binaryArray",
                "iVar1": "digitalValue",
                "uVar2": "bitPosition",
                "uVar3": "decimalValue"
            },
            "calling": [
                "readThermocouple"
            ],
            "called": [
                "digitalRead",
                "digitalWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015f8": {
            "entrypoint": "0x080015f8",
            "current_name": "calculate_value_080015f8",
            "code": "\nundefined8 calculateValue_080015f8(undefined4 data1,int option,undefined4 data2,undefined4 data3)\n\n{\n  uint readValue;\n  undefined8 result;\n  \n  readValue = readData();\n  if ((readValue & 0x10000) == 0) {\n    readValue = readValue >> 0x12;\n    result = __floatunsidf(readValue & 0x1fff);\n    if ((readValue & 0x2000) != 0) {\n      result = __floatunsidf(~readValue & 0x1fff);\n      result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0,0x3ff00000,data3);\n      result = CONCAT44((int)((ulonglong)result >> 0x20) + -0x80000000,(int)result);\n    }\n    result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x3fd00000);\n    if (option == 1) {\n      result = __muldf3((int)result,(int)((ulonglong)result >> 0x20),0,0x40220000);\n      result = __divdf3((int)result,(int)((ulonglong)result >> 0x20),0,0x40140000);\n      result = __aeabi_dadd((int)result,(int)((ulonglong)result >> 0x20),0,0x40400000);\n      return result;\n    }\n  }\n  else {\n    readValue = readValue & 7;\n    if (readValue == 2) {\n      return 0x40c3888000000000;\n    }\n    if (readValue == 4) {\n      return 0x40c3890000000000;\n    }\n    if (readValue != 1) {\n      return 0;\n    }\n    result = 0x40c3880000000000;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080015f8": "calculate_value_080015f8",
                "param_1": "data1",
                "param_2": "option",
                "param_3": "data2",
                "param_4": "data3",
                "uVar1": "readValue",
                "uVar2": "result"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "readData",
                "__divdf3",
                "__floatunsidf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016b4": {
            "entrypoint": "0x080016b4",
            "current_name": "calculate_new_value_080016b4",
            "code": "\nchar calculateNewValue_080016b4(int inputValue)\n\n{\n  char result;\n  int currentTime;\n  int comparisonResult;\n  undefined4 tempVar4;\n  undefined4 tempVar5;\n  undefined4 tempVar6;\n  undefined4 tempVar7;\n  undefined4 tempVar8;\n  undefined4 tempVar9;\n  undefined4 tempVar10;\n  char shouldContinue;\n  undefined4 minValue;\n  undefined4 maxValue;\n  undefined4 tempVar14;\n  undefined8 tempVar15;\n  undefined8 tempVar16;\n  undefined8 newValue1;\n  undefined8 newValue2;\n  undefined4 tempVar18;\n  undefined4 tempVar19;\n  \n  shouldContinue = *(char *)(inputValue + 0x70);\n  if (shouldContinue != '\\0') {\n    currentTime = millis();\n    if ((uint)(currentTime - *(int *)(inputValue + 0x44)) < *(uint *)(inputValue + 0x58)) {\n      shouldContinue = '\\0';\n    }\n    else {\n      tempVar5 = **(undefined4 **)(inputValue + 0x38);\n      tempVar8 = (*(undefined4 **)(inputValue + 0x38))[1];\n      tempVar15 = __subdf3(**(undefined4 **)(inputValue + 0x40),(*(undefined4 **)(inputValue + 0x40))[1]);\n      tempVar14 = (undefined4)((ulonglong)tempVar15 >> 0x20);\n      tempVar16 = __subdf3(tempVar5,tempVar8,*(undefined4 *)(inputValue + 0x50),*(undefined4 *)(inputValue + 0x54))\n      ;\n      tempVar4 = (undefined4)((ulonglong)tempVar16 >> 0x20);\n      newValue1 = __muldf3((int)tempVar15,tempVar14,*(undefined4 *)(inputValue + 0x20),\n                        *(undefined4 *)(inputValue + 0x24));\n      newValue1 = __aeabi_dadd((int)newValue1,(int)((ulonglong)newValue1 >> 0x20),\n                            *(undefined4 *)(inputValue + 0x48),*(undefined4 *)(inputValue + 0x4c));\n      *(undefined8 *)(inputValue + 0x48) = newValue1;\n      result = *(char *)(inputValue + 0x71);\n      if (result == '\\0') {\n        newValue2 = __muldf3((int)tempVar16,tempVar4,*(undefined4 *)(inputValue + 0x18),\n                          *(undefined4 *)(inputValue + 0x1c));\n        newValue1 = __subdf3((int)newValue1,(int)((ulonglong)newValue1 >> 0x20),(int)newValue2,\n                          (int)((ulonglong)newValue2 >> 0x20));\n        *(undefined8 *)(inputValue + 0x48) = newValue1;\n      }\n      tempVar6 = *(undefined4 *)(inputValue + 0x48);\n      tempVar9 = *(undefined4 *)(inputValue + 0x4c);\n      minValue = *(undefined4 *)(undefined8 *)(inputValue + 0x68);\n      maxValue = *(undefined4 *)(inputValue + 0x6c);\n      newValue1 = *(undefined8 *)(inputValue + 0x68);\n      comparisonResult = __aeabi_dcmpgt(tempVar6,tempVar9,minValue,maxValue);\n      if (comparisonResult == 0) {\n        tempVar7 = *(undefined4 *)(inputValue + 0x60);\n        tempVar10 = *(undefined4 *)(inputValue + 100);\n        comparisonResult = __aeabi_dcmplt(tempVar6,tempVar9);\n        if (comparisonResult != 0) {\n          *(undefined4 *)(inputValue + 0x48) = tempVar7;\n          *(undefined4 *)(inputValue + 0x4c) = tempVar10;\n        }\n      }\n      else {\n        *(undefined4 *)(inputValue + 0x48) = minValue;\n        *(undefined4 *)(inputValue + 0x4c) = maxValue;\n      }\n      if (result == '\\0') {\n        tempVar15 = 0;\n      }\n      else {\n        tempVar15 = __muldf3((int)tempVar15,tempVar14,*(undefined4 *)(inputValue + 0x18),\n                          *(undefined4 *)(inputValue + 0x1c));\n      }\n      tempVar19 = (undefined4)((ulonglong)tempVar15 >> 0x20);\n      tempVar18 = (undefined4)tempVar15;\n      tempVar14 = *(undefined4 *)(inputValue + 0x48);\n      tempVar6 = *(undefined4 *)(inputValue + 0x4c);\n      tempVar15 = __muldf3((int)tempVar16,tempVar4,*(undefined4 *)(inputValue + 0x28),\n                        *(undefined4 *)(inputValue + 0x2c));\n      tempVar15 = __subdf3(tempVar14,tempVar6,(int)tempVar15,(int)((ulonglong)tempVar15 >> 0x20));\n      tempVar15 = __aeabi_dadd(tempVar18,tempVar19,(int)tempVar15,(int)((ulonglong)tempVar15 >> 0x20));\n      tempVar14 = (undefined4)((ulonglong)tempVar15 >> 0x20);\n      comparisonResult = __aeabi_dcmplt(minValue,maxValue,(int)tempVar15,tempVar14);\n      if (comparisonResult == 0) {\n        newValue1 = *(undefined8 *)(inputValue + 0x60);\n        comparisonResult = __aeabi_dcmplt((int)tempVar15,tempVar14,*(undefined4 *)(undefined8 *)(inputValue + 0x60),\n                               *(undefined4 *)(inputValue + 100));\n        if (comparisonResult == 0) {\n          newValue1 = tempVar15;\n        }\n      }\n      **(undefined8 **)(inputValue + 0x3c) = newValue1;\n      *(undefined4 *)(inputValue + 0x50) = tempVar5;\n      *(undefined4 *)(inputValue + 0x54) = tempVar8;\n      *(int *)(inputValue + 0x44) = currentTime;\n    }\n  }\n  return shouldContinue;\n}\n\n",
            "renaming": {
                "FUN_080016b4": "calculate_new_value_080016b4",
                "param_1": "inputValue",
                "cVar1": "result",
                "iVar2": "currentTime",
                "iVar3": "comparisonResult",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "tempVar6",
                "uVar7": "tempVar7",
                "uVar8": "tempVar8",
                "uVar9": "tempVar9",
                "uVar10": "tempVar10",
                "cVar11": "shouldContinue",
                "uVar12": "minValue",
                "uVar13": "maxValue",
                "uVar14": "tempVar14",
                "uVar15": "tempVar15",
                "uVar16": "tempVar16",
                "uVar17": "newValue1",
                "uVar18": "newValue2",
                "local_38": "tempVar18",
                "uStack_34": "tempVar19"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__muldf3",
                "__aeabi_dadd",
                "__subdf3",
                "millis",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001814": {
            "entrypoint": "0x08001814",
            "current_name": "calculate_and_set_values_08001814",
            "code": "\nvoid calculateAndSetValues_08001814(undefined4 *result,undefined4 unused,undefined4 num1,undefined4 num2,\n                 undefined4 num3,undefined4 num4,undefined4 num5,undefined4 num6,\n                 int flag)\n\n{\n  int isLessThanFlag;\n  undefined4 quotient;\n  undefined bitFlag;\n  bool isNotEqualToOne;\n  undefined8 tempVar1;\n  undefined8 tempVar2;\n  undefined8 tempVar3;\n  \n  isLessThanFlag = __aeabi_dcmplt(num1,num2,0,0);\n  if (((isLessThanFlag == 0) && (isLessThanFlag = __aeabi_dcmplt(num3,num4,0,0), isLessThanFlag == 0)) &&\n     (isLessThanFlag = __aeabi_dcmplt(num5,num6,0,0), isLessThanFlag == 0)) {\n    result[0xd] = flag;\n    isNotEqualToOne = flag != 1;\n    if (isNotEqualToOne) {\n      flag = 0;\n    }\n    bitFlag = (undefined)flag;\n    if (!isNotEqualToOne) {\n      bitFlag = 1;\n    }\n    *(undefined *)((int)result + 0x71) = bitFlag;\n    *result = num1;\n    result[1] = num2;\n    result[2] = num3;\n    result[3] = num4;\n    result[4] = num5;\n    result[5] = num6;\n    tempVar1 = __floatunsidf(result[0x16]);\n    tempVar1 = __divdf3((int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20),0,0x408f4000);\n    quotient = (undefined4)((ulonglong)tempVar1 >> 0x20);\n    result[6] = num1;\n    result[7] = num2;\n    tempVar2 = __muldf3(num3,num4,(int)tempVar1,quotient);\n    *(undefined8 *)(result + 8) = tempVar2;\n    tempVar1 = __divdf3(num5,num6,(int)tempVar1,quotient);\n    *(undefined8 *)(result + 10) = tempVar1;\n    if (result[0xc] == 1) {\n      tempVar3 = __subdf3(0,0,num1,num2);\n      *(undefined8 *)(result + 6) = tempVar3;\n      tempVar2 = __subdf3(0,0,(int)tempVar2,(int)((ulonglong)tempVar2 >> 0x20));\n      *(undefined8 *)(result + 8) = tempVar2;\n      tempVar1 = __subdf3(0,0,(int)tempVar1,(int)((ulonglong)tempVar1 >> 0x20));\n      *(undefined8 *)(result + 10) = tempVar1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001814": "calculate_and_set_values_08001814",
                "param_1": "result",
                "param_2": "unused",
                "param_3": "num1",
                "param_4": "num2",
                "param_5": "num3",
                "param_6": "num4",
                "param_7": "num5",
                "param_8": "num6",
                "param_9": "flag",
                "iVar1": "isLessThanFlag",
                "uVar2": "quotient",
                "uVar3": "bitFlag",
                "bVar4": "isNotEqualToOne",
                "uVar5": "tempVar1",
                "uVar6": "tempVar2",
                "uVar7": "tempVar3"
            },
            "calling": [
                "SetTunings",
                "FUN_08001ab0"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__muldf3",
                "__subdf3",
                "__divdf3",
                "__floatunsidf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080018f8": {
            "entrypoint": "0x080018f8",
            "current_name": "initialize_values_080018f8",
            "code": "\nvoid initialize_values_080018f8(void)\n\n{\n  calculate_and_set_values();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080018f8": "initialize_values_080018f8",
                "calculate_and_set_values_08001814": "calculate_and_set_values"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "FUN_08001814"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001918": {
            "entrypoint": "0x08001918",
            "current_name": "calculate_and_update_values_08001918",
            "code": "\nvoid calculateAndUpdateValues_08001918(int inputPointer,int size,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 divResult;\n  undefined8 floatSize;\n  undefined8 floatValue;\n  \n  if (0 < size) {\n    floatSize = __floatsidf(size);\n    floatValue = __floatunsidf(*(undefined4 *)(inputPointer + 0x58));\n    floatSize = __divdf3((int)floatSize,(int)((ulonglong)floatSize >> 0x20),(int)floatValue,\n                     (int)((ulonglong)floatValue >> 0x20),param4);\n    divResult = (undefined4)((ulonglong)floatSize >> 0x20);\n    floatValue = __muldf3((int)floatSize,divResult,*(undefined4 *)(inputPointer + 0x20),\n                     *(undefined4 *)(inputPointer + 0x24));\n    *(undefined8 *)(inputPointer + 0x20) = floatValue;\n    floatSize = __divdf3(*(undefined4 *)(inputPointer + 0x28),*(undefined4 *)(inputPointer + 0x2c),(int)floatSize,\n                     divResult);\n    *(undefined8 *)(inputPointer + 0x28) = floatSize;\n    *(int *)(inputPointer + 0x58) = size;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001918": "calculate_and_update_values_08001918",
                "param_1": "inputPointer",
                "param_2": "size",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "divResult",
                "uVar2": "floatSize",
                "uVar3": "floatValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "__muldf3",
                "__floatsidf",
                "__divdf3",
                "__floatunsidf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001960": {
            "entrypoint": "0x08001960",
            "current_name": "update_params_08001960",
            "code": "\nvoid updateParams_08001960(int paramBase,undefined4 param2,undefined4 currentMin,undefined4 currentMax,\n                 undefined4 newMin,undefined4 newMax)\n\n{\n  int comparisonResult;\n  undefined4 *ptrToParam;\n  undefined4 param1Value;\n  undefined4 param4Value;\n  undefined4 param2Value;\n  undefined4 param3Value;\n  \n  comparisonResult = __aeabi_dcmpge(currentMin,currentMax,newMin,newMax,currentMax);\n  if (comparisonResult == 0) {\n    *(undefined4 *)(paramBase + 0x60) = currentMin;\n    *(undefined4 *)(paramBase + 100) = currentMax;\n    *(undefined4 *)(paramBase + 0x68) = newMin;\n    *(undefined4 *)(paramBase + 0x6c) = newMax;\n    if (*(char *)(paramBase + 0x70) != '\\0') {\n      ptrToParam = *(undefined4 **)(paramBase + 0x3c);\n      param1Value = *ptrToParam;\n      param2Value = ptrToParam[1];\n      comparisonResult = __aeabi_dcmplt(newMin,newMax,param1Value,param2Value);\n      if (comparisonResult == 0) {\n        comparisonResult = __aeabi_dcmpgt(currentMin,currentMax,param1Value,param2Value);\n        if (comparisonResult != 0) {\n          *ptrToParam = currentMin;\n          ptrToParam[1] = currentMax;\n        }\n      }\n      else {\n        *ptrToParam = newMin;\n        ptrToParam[1] = newMax;\n      }\n      param1Value = *(undefined4 *)(paramBase + 0x48);\n      param2Value = *(undefined4 *)(paramBase + 0x4c);\n      param4Value = *(undefined4 *)(paramBase + 0x68);\n      param3Value = *(undefined4 *)(paramBase + 0x6c);\n      comparisonResult = __aeabi_dcmpgt(param1Value,param2Value,param4Value,param3Value);\n      if (comparisonResult != 0) {\n        *(undefined4 *)(paramBase + 0x48) = param4Value;\n        *(undefined4 *)(paramBase + 0x4c) = param3Value;\n        return;\n      }\n      param4Value = *(undefined4 *)(paramBase + 0x60);\n      param3Value = *(undefined4 *)(paramBase + 100);\n      comparisonResult = __aeabi_dcmplt(param1Value,param2Value,param4Value,param3Value);\n      if (comparisonResult != 0) {\n        *(undefined4 *)(paramBase + 0x48) = param4Value;\n        *(undefined4 *)(paramBase + 0x4c) = param3Value;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001960": "update_params_08001960",
                "param_1": "paramBase",
                "param_2": "param2",
                "param_3": "currentMin",
                "param_4": "currentMax",
                "param_5": "newMin",
                "param_6": "newMax",
                "iVar1": "comparisonResult",
                "puVar2": "ptrToParam",
                "uVar3": "param1Value",
                "uVar4": "param4Value",
                "uVar5": "param2Value",
                "uVar6": "param3Value"
            },
            "calling": [
                "FUN_08001ab0",
                "loop"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080019f6": {
            "entrypoint": "0x080019f6",
            "current_name": "update_values_based_on_conditions_080019f6",
            "code": "\nvoid updateValuesBasedOnConditions_080019f6(int arg1)\n\n{\n  int comparisonResult;\n  undefined4 tempVar1;\n  undefined4 var1;\n  undefined4 var2;\n  undefined4 tempVar2;\n  \n  var1 = **(undefined4 **)(arg1 + 0x3c);\n  var2 = (*(undefined4 **)(arg1 + 0x3c))[1];\n  *(undefined4 *)(arg1 + 0x48) = var1;\n  *(undefined4 *)(arg1 + 0x4c) = var2;\n  tempVar1 = (*(undefined4 **)(arg1 + 0x38))[1];\n  *(undefined4 *)(arg1 + 0x50) = **(undefined4 **)(arg1 + 0x38);\n  *(undefined4 *)(arg1 + 0x54) = tempVar1;\n  tempVar1 = *(undefined4 *)(arg1 + 0x68);\n  tempVar2 = *(undefined4 *)(arg1 + 0x6c);\n  comparisonResult = __aeabi_dcmpgt(var1,var2,tempVar1,tempVar2);\n  if (comparisonResult == 0) {\n    tempVar1 = *(undefined4 *)(arg1 + 0x60);\n    tempVar2 = *(undefined4 *)(arg1 + 100);\n    comparisonResult = __aeabi_dcmplt(var1,var2,tempVar1,tempVar2);\n    if (comparisonResult != 0) {\n      *(undefined4 *)(arg1 + 0x48) = tempVar1;\n      *(undefined4 *)(arg1 + 0x4c) = tempVar2;\n    }\n    return;\n  }\n  *(undefined4 *)(arg1 + 0x48) = tempVar1;\n  *(undefined4 *)(arg1 + 0x4c) = tempVar2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080019f6": "update_values_based_on_conditions_080019f6",
                "param_1": "arg1",
                "iVar1": "comparisonResult",
                "uVar2": "tempVar1",
                "uVar3": "var1",
                "uVar4": "var2",
                "uVar5": "tempVar2"
            },
            "calling": [
                "SetMode"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a44": {
            "entrypoint": "0x08001a44",
            "current_name": "update_param_flag_08001a44",
            "code": "\nvoid updateParamFlag_08001a44(int dataAddress,int flagValue)\n\n{\n  undefined newValue;\n  \n  if (flagValue == 1) {\n    newValue = 1;\n    if (*(char *)(dataAddress + 0x70) == '\\0') {\n      Initialize();\n    }\n  }\n  else {\n    newValue = 0;\n  }\n  *(undefined *)(dataAddress + 0x70) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a44": "update_param_flag_08001a44",
                "param_1": "dataAddress",
                "param_2": "flagValue",
                "uVar1": "newValue"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "Initialize"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a66": {
            "entrypoint": "0x08001a66",
            "current_name": "update_values_08001a66",
            "code": "\nvoid updateValues_08001a66(int ptr_data,int new_value,undefined4 ptr_val1,undefined4 ptr_val2)\n\n{\n  undefined8 result;\n  \n  if ((*(char *)(ptr_data + 0x70) != '\\0') && (*(int *)(ptr_data + 0x30) != new_value)) {\n    result = __subdf3(0,0,*(undefined4 *)(ptr_data + 0x18),*(undefined4 *)(ptr_data + 0x1c),ptr_val2);\n    *(undefined8 *)(ptr_data + 0x18) = result;\n    result = __subdf3(0,0,*(undefined4 *)(ptr_data + 0x20),*(undefined4 *)(ptr_data + 0x24));\n    *(undefined8 *)(ptr_data + 0x20) = result;\n    result = __subdf3(0,0,*(undefined4 *)(ptr_data + 0x28),*(undefined4 *)(ptr_data + 0x2c));\n    *(undefined8 *)(ptr_data + 0x28) = result;\n  }\n  *(int *)(ptr_data + 0x30) = new_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a66": "update_values_08001a66",
                "param_1": "ptr_data",
                "param_2": "new_value",
                "param_3": "ptr_val1",
                "param_4": "ptr_val2",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08001ab0"
            ],
            "called": [
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_controller_08001ab0",
            "code": "\nint initializeController_08001ab0(int controller,undefined4 input1,undefined4 input2,undefined4 input3,\n                undefined4 input4,undefined4 input5,undefined4 input6,undefined4 input7,\n                undefined4 input8,undefined4 input9,undefined4 input10,undefined4 input11)\n\n{\n  int currentTime;\n  undefined4 returnValue;\n  \n  *(undefined4 *)(controller + 0x3c) = input2;\n  *(undefined4 *)(controller + 0x38) = input1;\n  *(undefined4 *)(controller + 0x40) = input3;\n  *(undefined *)(controller + 0x70) = 0;\n  setOutputLimits(controller,input1,0,0,0,0x406fe000);\n  *(undefined4 *)(controller + 0x58) = 100;\n  setControllerDirection(controller,input11);\n  calculateAndSetValues(controller,returnValue,input4,input5,input6,input7,input8,input9,input10);\n  currentTime = millis();\n  *(int *)(controller + 0x44) = currentTime - *(int *)(controller + 0x58);\n  return controller;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_controller_08001ab0",
                "param_1": "controller",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3",
                "param_5": "input4",
                "param_6": "input5",
                "param_7": "input6",
                "param_8": "input7",
                "param_9": "input8",
                "param_10": "input9",
                "param_11": "input10",
                "param_12": "input11",
                "iVar1": "currentTime",
                "extraout_r1": "returnValue",
                "SetOutputLimits": "setOutputLimits",
                "SetControllerDirection": "setControllerDirection",
                "calculate_and_set_values_08001814": "calculateAndSetValues"
            },
            "calling": [
                "PID"
            ],
            "called": [
                "millis",
                "SetOutputLimits",
                "SetControllerDirection",
                "FUN_08001814"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b18": {
            "entrypoint": "0x08001b18",
            "current_name": "initialize_and_return_08001b18",
            "code": "\nundefined4 initialize_and_return_08001b18(undefined4 input_param)\n\n{\n  initialize_controller();\n  return input_param;\n}\n\n",
            "renaming": {
                "FUN_08001b18": "initialize_and_return_08001b18",
                "param_1": "input_param",
                "initialize_controller_08001ab0": "initialize_controller"
            },
            "calling": [
                "FUN_08000b08"
            ],
            "called": [
                "FUN_08001ab0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001b48": {
            "entrypoint": "0x08001b48",
            "current_name": "initialize_system_08001b48",
            "code": "\nvoid initializeSystem_08001b48(void)\n\n{\n  int result;\n  uint hclkFrequency;\n  undefined4 oscillatorConfig [2];\n  undefined4 clockConfig;\n  undefined4 clockSourceConfig;\n  undefined4 clockSourceConfigParam1;\n  undefined4 clockSourceConfigParam2;\n  undefined4 clockSourceConfigParam3;\n  undefined4 clockSourceConfigParam4;\n  undefined4 oscillatorParam [4];\n  undefined4 initializeParam1;\n  undefined4 initializeParam2;\n  undefined4 initializeParam3;\n  undefined4 initializeParam4;\n  undefined4 initializeParam5;\n  \n  oscillatorParam[0] = 2;\n  initializeParam1 = 1;\n  initializeParam2 = 0x10;\n  initializeParam3 = 2;\n  initializeParam4 = 0;\n  initializeParam5 = 0x380000;\n  result = HAL_RCC_OscConfig(oscillatorParam);\n  if (result != 0) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x88);\n  }\n  clockSourceConfig = 0xf;\n  clockSourceConfigParam1 = 2;\n  clockSourceConfigParam2 = 0;\n  clockSourceConfigParam3 = 0x400;\n  clockSourceConfigParam4 = 0;\n  result = HAL_RCC_ClockConfig(&clockSourceConfig);\n  if (result != 0) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x95);\n  }\n  oscillatorConfig[0] = 2;\n  clockConfig = 0x8000;\n  result = HAL_RCCEx_PeriphCLKConfig(oscillatorConfig);\n  if (result != 0) {\n    _Error_Handler(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/variants/NUCLEO_F103RB/variant.cpp\"\n                   ,0x9c);\n  }\n  hclkFrequency = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config(hclkFrequency / 1000);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(0xffffffff,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001b48": "initialize_system_08001b48",
                "local_54": "oscillatorConfig",
                "local_4c": "clockConfig",
                "local_44": "clockSourceConfig",
                "local_40": "clockSourceConfigParam1",
                "local_3c": "clockSourceConfigParam2",
                "local_38": "clockSourceConfigParam3",
                "local_34": "clockSourceConfigParam4",
                "local_30": "oscillatorParam",
                "local_20": "initializeParam1",
                "local_1c": "initializeParam2",
                "local_14": "initializeParam3",
                "local_10": "initializeParam4",
                "local_c": "initializeParam5",
                "iVar1": "result",
                "uVar2": "hclkFrequency"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "HAL_RCC_ClockConfig",
                "HAL_RCC_OscConfig",
                "HAL_SYSTICK_Config",
                "HAL_SYSTICK_CLKSourceConfig",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_RCCEx_PeriphCLKConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001be8": {
            "entrypoint": "0x08001be8",
            "current_name": "initialize_system_08001be8",
            "code": "\nvoid initializeSystem_08001be8(void)\n\n{\n  int index;\n  undefined4 *pointer;\n  code *jumpTable;\n  \n  for (index = 0; (undefined *)(index + 0x20000000) < &DAT_2000015c; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(index + 0x8007970);\n  }\n  for (pointer = &DAT_20000160; pointer < &DAT_200006a8; pointer = pointer + 1) {\n    *pointer = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumpTable = (code *)0x8001c1a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x08001c1a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001be8": "initialize_system_08001be8",
                "iVar1": "index",
                "puVar2": "pointer",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [],
            "called": [
                "SystemInit",
                "__libc_init_array",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c32": {
            "entrypoint": "0x08001c32",
            "current_name": "initialize_hardware_configuration_08001c32",
            "code": "\nvoid initializeHardwareConfiguration_08001c32(void)\n\n{\n  hw_config_init();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c32": "initialize_hardware_configuration_08001c32"
            },
            "calling": [
                "premain"
            ],
            "called": [
                "hw_config_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3a": {
            "entrypoint": "0x08001c3a",
            "current_name": "FUNC_08001c3a",
            "code": "\nvoid FUNC_08001c3a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001c3a": "FUNC_08001c3a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001c3c": {
            "entrypoint": "0x08001c3c",
            "current_name": "initialize_sys_tick_08001c3c",
            "code": "\nundefined4 initializeSysTick_08001c3c(uint priority)\n\n{\n  int systickConfigResult;\n  \n  systickConfigResult = HAL_SYSTICK_Config(DAT_20000084 / (1000 / DAT_20000078));\n  if (systickConfigResult != 0) {\n    return 1;\n  }\n  if (0xf < priority) {\n    return 1;\n  }\n  HAL_NVIC_SetPriority(0xffffffff,priority,0);\n  DAT_2000007c = priority;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001c3c": "initialize_sys_tick_08001c3c",
                "param_1": "priority",
                "iVar1": "systickConfigResult"
            },
            "calling": [
                "HAL_Init",
                "FUN_08003afa"
            ],
            "called": [
                "HAL_SYSTICK_Config",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001c88": {
            "entrypoint": "0x08001c88",
            "current_name": "initialize_hardware_08001c88",
            "code": "\n\n\nundefined4 initializeHardware_08001c88(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setPriorityGrouping(3);\n  initializeTick(0xf);\n  initializeMsp();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08001c88": "initialize_hardware_08001c88",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeMsp"
            },
            "calling": [
                "hw_config_init"
            ],
            "called": [
                "HAL_MspInit",
                "HAL_InitTick",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cac": {
            "entrypoint": "0x08001cac",
            "current_name": "update_variable_08001cac",
            "code": "\nvoid updateVariable_08001cac(void)\n\n{\n  DAT_200006a0 = (uint)DAT_20000078 + DAT_200006a0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cac": "update_variable_08001cac"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cc4": {
            "entrypoint": "0x08001cc4",
            "current_name": "get_global_variable_08001cc4",
            "code": "\nundefined4 get_global_variable_08001cc4(void)\n\n{\n  return DAT_200006a0;\n}\n\n",
            "renaming": {
                "FUN_08001cc4": "get_global_variable_08001cc4"
            },
            "calling": [
                "HAL_RCC_OscConfig",
                "ADC_Enable",
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start",
                "GetCurrentMilli",
                "FUN_08003afa",
                "UART_WaitOnFlagUntilTimeout",
                "ADC_ConversionStop_Disable",
                "uart_debug_write",
                "HAL_UART_Transmit",
                "HAL_RCCEx_PeriphCLKConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cd0": {
            "entrypoint": "0x08001cd0",
            "current_name": "calculate_processing_time_08001cd0",
            "code": "\nundefined4 calculateProcessingTime_08001cd0(uint **inputParams,uint timeout)\n\n{\n  int startTime;\n  uint clockFrequency;\n  int elapsedTime;\n  undefined4 result;\n  uint *ptrParams;\n  uint processingTime;\n  uint iterationCount;\n  \n  iterationCount = 0;\n  startTime = HAL_GetTick();\n  processingTime = DAT_20000084;\n  ptrParams = *inputParams;\n  if ((ptrParams[2] & 0x100) == 0) {\n    if (((ptrParams[1] & 0x100) == 0) && ((ptrParams[0xb] & 0xf00000) == 0)) {\n      do {\n        if ((**inputParams & 2) != 0) goto LAB_08001de2;\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - startTime) <= timeout))));\n      inputParams[10] = (uint *)((uint)inputParams[10] | 4);\n      *(undefined *)(inputParams + 9) = 0;\n      result = 3;\n    }\n    else {\n      clockFrequency = HAL_RCCEx_GetPeriphCLKFreq(2);\n      ptrParams = *inputParams;\n      if (((ptrParams[4] & 0x24924924) == 0) && ((ptrParams[3] & 0x924924) == 0)) {\n        if ((ptrParams[4] & 0x12492492) == 0) {\n          if ((ptrParams[3] & 0x492492) == 0) {\n            elapsedTime = 0x14;\n          }\n          else {\n            elapsedTime = 0x29;\n          }\n        }\n        else {\n          elapsedTime = 0x29;\n        }\n      }\n      else if (((ptrParams[4] & 0x12492492) == 0) && ((ptrParams[3] & 0x492492) == 0)) {\n        elapsedTime = 0x54;\n      }\n      else if ((ptrParams[4] & 0x249249) == 0) {\n        if ((ptrParams[3] & 0x249249) == 0) {\n          elapsedTime = 0x54;\n        }\n        else {\n          elapsedTime = 0xfc;\n        }\n      }\n      else {\n        elapsedTime = 0xfc;\n      }\n      processingTime = (processingTime / clockFrequency) * elapsedTime;\n      for (; iterationCount <= processingTime && processingTime - iterationCount != 0; iterationCount = iterationCount + 1) {\n        if ((timeout != 0xffffffff) &&\n           ((timeout == 0 || (elapsedTime = HAL_GetTick(), timeout < (uint)(elapsedTime - startTime))))) {\n          inputParams[10] = (uint *)((uint)inputParams[10] | 4);\n          *(undefined *)(inputParams + 9) = 0;\n          return 3;\n        }\n      }\nLAB_08001de2:\n      **inputParams = 0xffffffed;\n      inputParams[10] = (uint *)((uint)inputParams[10] | 0x200);\n      if (((*inputParams)[2] & 0xe0000) == 0xe0000) {\n        if (inputParams[3] == (uint *)0x0) {\n          inputParams[10] = (uint *)((uint)inputParams[10] & 0xfffffeff);\n          if (((uint)inputParams[10] & 0x1000) == 0) {\n            inputParams[10] = (uint *)((uint)inputParams[10] | 1);\n            result = 0;\n          }\n          else {\n            result = 0;\n          }\n        }\n        else {\n          result = 0;\n        }\n      }\n      else {\n        result = 0;\n      }\n    }\n  }\n  else {\n    inputParams[10] = (uint *)((uint)inputParams[10] | 0x20);\n    *(undefined *)(inputParams + 9) = 0;\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001cd0": "calculate_processing_time_08001cd0",
                "param_1": "inputParams",
                "param_2": "timeout",
                "iVar1": "startTime",
                "uVar2": "clockFrequency",
                "iVar3": "elapsedTime",
                "uVar4": "result",
                "puVar5": "ptrParams",
                "uVar6": "processingTime",
                "local_1c": "iterationCount"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e40": {
            "entrypoint": "0x08001e40",
            "current_name": "get_offset_value_08001e40",
            "code": "\nundefined4 getOffsetValue_08001e40(int *ptrToOffset)\n\n{\n  return *(undefined4 *)(*ptrToOffset + 0x4c);\n}\n\n",
            "renaming": {
                "FUN_08001e40": "get_offset_value_08001e40",
                "param_1": "ptrToOffset"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001e48": {
            "entrypoint": "0x08001e48",
            "current_name": "update_config_08001e48",
            "code": "\nundefined4 updateConfig_08001e48(int *config,uint *values)\n\n{\n  undefined4 status;\n  uint index;\n  int count;\n  \n  if (*(char *)(config + 9) == '\\x01') {\n    status = 2;\n  }\n  else {\n    *(undefined *)(config + 9) = 1;\n    index = values[1];\n    if (index < 7) {\n      index = index * 5 - 5;\n      *(uint *)(*config + 0x34) =\n           *values << (index & 0xff) | *(uint *)(*config + 0x34) & ~(0x1f << (index & 0xff));\n    }\n    else if (index < 0xd) {\n      index = index * 5 - 0x23;\n      *(uint *)(*config + 0x30) =\n           *values << (index & 0xff) | *(uint *)(*config + 0x30) & ~(0x1f << (index & 0xff));\n    }\n    else {\n      index = index * 5 - 0x41;\n      *(uint *)(*config + 0x2c) =\n           *values << (index & 0xff) | *(uint *)(*config + 0x2c) & ~(0x1f << (index & 0xff));\n    }\n    index = *values;\n    if (index < 10) {\n      *(uint *)(*config + 0x10) =\n           values[2] << (index * 3 & 0xff) |\n           *(uint *)(*config + 0x10) & ~(7 << (index * 3 & 0xff));\n    }\n    else {\n      index = index * 3 - 0x1e;\n      *(uint *)(*config + 0xc) =\n           values[2] << (index & 0xff) | *(uint *)(*config + 0xc) & ~(7 << (index & 0xff));\n    }\n    if (*values - 0x10 < 2) {\n      if (*config == 0x40012400) {\n        if ((uRam40012408 & 0x800000) == 0) {\n          uRam40012408 = uRam40012408 | 0x800000;\n          if (*values == 0x10) {\n            for (count = (DAT_20000084 / 1000000) * 10; count != 0; count = count + -1) {\n            }\n            status = 0;\n          }\n          else {\n            status = 0;\n          }\n        }\n        else {\n          status = 0;\n        }\n      }\n      else {\n        config[10] = config[10] | 0x20;\n        status = 1;\n      }\n    }\n    else {\n      status = 0;\n    }\n    *(undefined *)(config + 9) = 0;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001e48": "update_config_08001e48",
                "param_1": "config",
                "param_2": "values",
                "uVar1": "status",
                "uVar2": "index",
                "local_c": "count"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f80": {
            "entrypoint": "0x08001f80",
            "current_name": "get_value_from_offset_08001f80",
            "code": "\nundefined4 get_value_from_offset_08001f80(int input_address)\n\n{\n  return *(undefined4 *)(input_address + 0x28);\n}\n\n",
            "renaming": {
                "FUN_08001f80": "get_value_from_offset_08001f80",
                "param_1": "input_address"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f84": {
            "entrypoint": "0x08001f84",
            "current_name": "initialize_device_08001f84",
            "code": "\nundefined4 initializeDevice_08001f84(int *deviceConfig,undefined4 configValue)\n\n{\n  int currentTick;\n  undefined4 returnValue;\n  int device;\n  uint loopCounter;\n  \n  device = *deviceConfig;\n  if ((*(uint *)(device + 8) & 1) == 0) {\n    *(uint *)(device + 8) = *(uint *)(device + 8) | 1;\n    for (loopCounter = DAT_20000084 / 1000000; loopCounter != 0; loopCounter = loopCounter - 1) {\n    }\n    device = HAL_GetTick(deviceConfig,configValue,DAT_20000084 * 0x431bde83);\n    do {\n      if ((*(uint *)(*deviceConfig + 8) & 1) != 0) {\n        return 0;\n      }\n      currentTick = HAL_GetTick();\n    } while ((uint)(currentTick - device) < 3);\n    deviceConfig[10] = deviceConfig[10] | 0x10;\n    deviceConfig[0xb] = deviceConfig[0xb] | 1;\n    *(undefined *)(deviceConfig + 9) = 0;\n    returnValue = 1;\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001f84": "initialize_device_08001f84",
                "param_1": "deviceConfig",
                "param_2": "configValue",
                "iVar1": "currentTick",
                "uVar2": "returnValue",
                "iVar3": "device",
                "local_14": "loopCounter"
            },
            "calling": [
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_Start"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002004": {
            "entrypoint": "0x08002004",
            "current_name": "enable_adc_08002004",
            "code": "\n\n\nint enableADC_08002004(int *data)\n\n{\n  int result;\n  undefined4 *ptr;\n  int address;\n  \n  if (*(char *)(data + 9) != '\\x01') {\n    *(undefined *)(data + 9) = 1;\n    result = ADC_Enable();\n    if (result == 0) {\n      data[10] = data[10] & 0xfffffcfeU | 0x100;\n      ptr = (undefined4 *)*data;\n      if ((ptr == (undefined4 *)0x40012800) && ((_DAT_40012404 & 0xf0000) != 0)) {\n        data[10] = data[10] | 0x100000;\n        if ((_DAT_40012404 & 0x400) != 0) {\n          data[10] = data[10] & 0xffffcfffU | 0x1000;\n        }\n      }\n      else {\n        data[10] = data[10] & 0xffefffff;\n        if ((ptr[1] & 0x400) != 0) {\n          data[10] = data[10] & 0xffffcfffU | 0x1000;\n        }\n      }\n      if ((data[10] & 0x1000U) == 0) {\n        data[0xb] = 0;\n      }\n      else {\n        data[0xb] = data[0xb] & 0xfffffff9;\n      }\n      *(undefined *)(data + 9) = 0;\n      *ptr = 0xfffffffd;\n      address = *data;\n      if (((*(uint *)(address + 8) & 0xe0000) == 0xe0000) &&\n         ((address != 0x40012800 || ((_DAT_40012404 & 0xf0000) == 0)))) {\n        *(uint *)(address + 8) = *(uint *)(address + 8) | 0x500000;\n      }\n      else {\n        *(uint *)(address + 8) = *(uint *)(address + 8) | 0x100000;\n      }\n    }\n    else {\n      *(undefined *)(data + 9) = 0;\n    }\n    return result;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_08002004": "enable_adc_08002004",
                "param_1": "data",
                "iVar1": "result",
                "puVar2": "ptr",
                "iVar3": "address"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_Enable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080020f0": {
            "entrypoint": "0x080020f0",
            "current_name": "check_and_modify_state_080020f0",
            "code": "\nundefined4 checkAndModifyState_080020f0(int *statePointer)\n\n{\n  int currentTime;\n  int initialTime;\n  \n  initialTime = *statePointer;\n  if ((*(uint *)(initialTime + 8) & 1) == 0) {\n    return 0;\n  }\n  *(uint *)(initialTime + 8) = *(uint *)(initialTime + 8) & 0xfffffffe;\n  initialTime = HAL_GetTick();\n  do {\n    if ((*(uint *)(*statePointer + 8) & 1) == 0) {\n      return 0;\n    }\n    currentTime = HAL_GetTick();\n  } while ((uint)(currentTime - initialTime) < 3);\n  statePointer[10] = statePointer[10] | 0x10;\n  statePointer[0xb] = statePointer[0xb] | 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080020f0": "check_and_modify_state_080020f0",
                "param_1": "statePointer",
                "iVar1": "currentTime",
                "iVar2": "initialTime"
            },
            "calling": [
                "HAL_ADC_Init",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_DeInit",
                "HAL_ADC_Stop"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800213c": {
            "entrypoint": "0x0800213c",
            "current_name": "initialize_adc_0800213c",
            "code": "\nundefined4 initializeADC_0800213c(int *adcParams)\n\n{\n  int stopResult;\n  uint combinedParams1;\n  uint combinedParams2;\n  \n  if (adcParams == (int *)0x0) {\n    return 1;\n  }\n  if (adcParams[10] == 0) {\n    adcParams[0xb] = 0;\n    *(undefined *)(adcParams + 9) = 0;\n    HAL_ADC_MspInit();\n  }\n  stopResult = ADC_ConversionStop_Disable(adcParams);\n  if (((adcParams[10] & 0x10U) == 0) && (stopResult == 0)) {\n    adcParams[10] = adcParams[10] & 0xffffeefdU | 2;\n    combinedParams1 = adcParams[1] | adcParams[7] | adcParams[3] << 1;\n    if (adcParams[2] == 0x100) {\n      combinedParams2 = 0x100;\n    }\n    else {\n      combinedParams2 = 0;\n      if (adcParams[2] == 1) {\n        combinedParams2 = 0x100;\n      }\n    }\n    if (adcParams[5] == 1) {\n      if (adcParams[3] == 0) {\n        combinedParams2 = combinedParams2 | (adcParams[6] + -1) * 0x2000 | 0x800;\n      }\n      else {\n        adcParams[10] = adcParams[10] | 0x20;\n        adcParams[0xb] = adcParams[0xb] | 1;\n      }\n    }\n    *(uint *)(*adcParams + 4) = combinedParams2 | *(uint *)(*adcParams + 4) & 0xffff16ff;\n    *(uint *)(*adcParams + 8) = *(uint *)(*adcParams + 8) & 0xffe1f7fd | combinedParams1;\n    if ((adcParams[2] == 0x100) || (adcParams[2] == 1)) {\n      combinedParams2 = (adcParams[4] + -1) * 0x100000;\n    }\n    else {\n      combinedParams2 = 0;\n    }\n    *(uint *)(*adcParams + 0x2c) = combinedParams2 | *(uint *)(*adcParams + 0x2c) & 0xff0fffff;\n    if (combinedParams1 != (*(uint *)(*adcParams + 8) & 0xff1f0efe)) {\n      adcParams[10] = adcParams[10] & 0xffffffedU | 0x10;\n      adcParams[0xb] = adcParams[0xb] | 1;\n      return 1;\n    }\n    adcParams[0xb] = 0;\n    adcParams[10] = adcParams[10] & 0xfffffffcU | 1;\n    return 0;\n  }\n  adcParams[10] = adcParams[10] | 0x10;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800213c": "initialize_adc_0800213c",
                "param_1": "adcParams",
                "iVar1": "stopResult",
                "uVar2": "combinedParams1",
                "uVar3": "combinedParams2"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable",
                "HAL_ADC_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800224c": {
            "entrypoint": "0x0800224c",
            "current_name": "disable_adc_conversion_0800224c",
            "code": "\nint disableADCConversion_0800224c(int *adcParams)\n\n{\n  int resultCode;\n  \n  if (adcParams == (int *)0x0) {\n    resultCode = 1;\n  }\n  else {\n    adcParams[10] = adcParams[10] | 2;\n    resultCode = ADC_ConversionStop_Disable();\n    if (resultCode == 0) {\n      *(undefined4 *)*adcParams = 0xffffffe0;\n      *(uint *)(*adcParams + 4) = *(uint *)(*adcParams + 4) & 0xff3f0000;\n      *(uint *)(*adcParams + 8) = *(uint *)(*adcParams + 8) & 0xff0106f0;\n      *(uint *)(*adcParams + 0xc) = *(uint *)(*adcParams + 0xc) & 0xff000000;\n      *(uint *)(*adcParams + 0x10) = *(uint *)(*adcParams + 0x10) & 0xc0000000;\n      *(uint *)(*adcParams + 0x14) = *(uint *)(*adcParams + 0x14) & 0xfffff000;\n      *(uint *)(*adcParams + 0x18) = *(uint *)(*adcParams + 0x18) & 0xfffff000;\n      *(uint *)(*adcParams + 0x1c) = *(uint *)(*adcParams + 0x1c) & 0xfffff000;\n      *(uint *)(*adcParams + 0x20) = *(uint *)(*adcParams + 0x20) & 0xfffff000;\n      *(uint *)(*adcParams + 0x24) = *(uint *)(*adcParams + 0x24) & 0xfffff000;\n      *(uint *)(*adcParams + 0x28) = *(uint *)(*adcParams + 0x28) & 0xfffff000;\n      *(uint *)(*adcParams + 0x2c) = *(uint *)(*adcParams + 0x2c) & 0xff000000;\n      *(uint *)(*adcParams + 0x2c) = *(uint *)(*adcParams + 0x2c) & 0xff000000;\n      *(uint *)(*adcParams + 0x30) = *(uint *)(*adcParams + 0x30) & 0xc0000000;\n      *(uint *)(*adcParams + 0x34) = *(uint *)(*adcParams + 0x34) & 0xc0000000;\n      *(uint *)(*adcParams + 0x38) = *(uint *)(*adcParams + 0x38) & 0xffc00000;\n      *(uint *)(*adcParams + 0x38) = *(uint *)(*adcParams + 0x38) & 0xffc00000;\n      deinitializeADC(adcParams);\n      adcParams[0xb] = 0;\n      adcParams[10] = 0;\n    }\n    *(undefined *)(adcParams + 9) = 0;\n  }\n  return resultCode;\n}\n\n",
            "renaming": {
                "FUN_0800224c": "disable_adc_conversion_0800224c",
                "param_1": "adcParams",
                "iVar1": "resultCode",
                "HAL_ADC_MspDeInit": "deinitializeADC"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_ADC_MspDeInit",
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002348": {
            "entrypoint": "0x08002348",
            "current_name": "process_param_08002348",
            "code": "\nint processParam_08002348(int param)\n\n{\n  int result;\n  \n  if (*(char *)(param + 0x24) == '\\x01') {\n    return 2;\n  }\n  *(undefined *)(param + 0x24) = 1;\n  result = disableADCConversionStop();\n  if (result == 0) {\n    *(uint *)(param + 0x28) = *(uint *)(param + 0x28) & 0xffffeefe | 1;\n  }\n  *(undefined *)(param + 0x24) = 0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002348": "process_param_08002348",
                "param_1": "param",
                "iVar1": "result",
                "ADC_ConversionStop_Disable": "disableADCConversionStop"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002384": {
            "entrypoint": "0x08002384",
            "current_name": "initialize_adc_08002384",
            "code": "\nint initialize_ADC_08002384(int *adc_params)\n\n{\n  uint adc_freq;\n  int adc_stop_status;\n  uint pe_clock_freq;\n  int start_time;\n  int current_time;\n  int iteration_count;\n  \n  if (*(char *)(adc_params + 9) == '\\x01') {\n    return 2;\n  }\n  *(undefined *)(adc_params + 9) = 1;\n  adc_stop_status = ADC_ConversionStop_Disable();\n  if (adc_stop_status == 0) {\n    adc_params[10] = adc_params[10] & 0xffffeefdU | 2;\n    adc_freq = DAT_20000084;\n    pe_clock_freq = HAL_RCCEx_GetPeriphCLKFreq(2);\n    for (iteration_count = adc_freq / pe_clock_freq << 1; iteration_count != 0; iteration_count = iteration_count + -1) {\n    }\n    ADC_Enable(adc_params);\n    *(uint *)(*adc_params + 8) = *(uint *)(*adc_params + 8) | 8;\n    start_time = HAL_GetTick();\n    while (current_time = *adc_params, (*(uint *)(current_time + 8) & 8) != 0) {\n      current_time = HAL_GetTick();\n      if (10 < (uint)(current_time - start_time)) {\n        adc_params[10] = adc_params[10] & 0xffffffedU | 0x10;\n        *(undefined *)(adc_params + 9) = 0;\n        return 1;\n      }\n    }\n    *(uint *)(current_time + 8) = *(uint *)(current_time + 8) | 4;\n    start_time = HAL_GetTick();\n    while ((*(uint *)(*adc_params + 8) & 4) != 0) {\n      current_time = HAL_GetTick();\n      if (10 < (uint)(current_time - start_time)) {\n        adc_params[10] = adc_params[10] & 0xffffffedU | 0x10;\n        *(undefined *)(adc_params + 9) = 0;\n        return 1;\n      }\n    }\n    adc_params[10] = adc_params[10] & 0xfffffffcU | 1;\n  }\n  *(undefined *)(adc_params + 9) = 0;\n  return adc_stop_status;\n}\n\n",
            "renaming": {
                "FUN_08002384": "initialize_adc_08002384",
                "param_1": "adc_params",
                "uVar1": "adc_freq",
                "iVar2": "adc_stop_status",
                "uVar3": "pe_clock_freq",
                "iVar4": "start_time",
                "iVar5": "current_time",
                "local_14": "iteration_count"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "HAL_GetTick",
                "ADC_Enable",
                "HAL_RCCEx_GetPeriphCLKFreq",
                "ADC_ConversionStop_Disable"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002470": {
            "entrypoint": "0x08002470",
            "current_name": "set_special_value_08002470",
            "code": "\n\n\nvoid setSpecialValue_08002470(uint inputValue)\n\n{\n  _DAT_e000ed0c = (inputValue & 7) << 8 | _DAT_e000ed0c & 0xf8ff | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002470": "set_special_value_08002470",
                "param_1": "inputValue"
            },
            "calling": [
                "HAL_Init",
                "premain"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002494": {
            "entrypoint": "0x08002494",
            "current_name": "update_memory_08002494",
            "code": "\n\n\nvoid updateMemory_08002494(uint address,uint data,uint mask)\n\n{\n  uint shiftAmount;\n  uint difference;\n  \n  shiftAmount = (uint)(_DAT_e000ed0c << 0x15) >> 0x1d;\n  difference = 7 - shiftAmount;\n  if (3 < difference) {\n    difference = 4;\n  }\n  if (shiftAmount + 4 < 7) {\n    shiftAmount = 0;\n  }\n  else {\n    shiftAmount = shiftAmount - 3;\n  }\n  shiftAmount = (data & (1 << (difference & 0xff)) - 1U) << (shiftAmount & 0xff) |\n          (1 << (shiftAmount & 0xff)) - 1U & mask;\n  if ((int)address < 0) {\n    *(char *)((address & 0xf) + 0xe000ed14) = (char)(shiftAmount << 4);\n  }\n  else {\n    *(char *)(address + 0xe000e400) = (char)(shiftAmount << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002494": "update_memory_08002494",
                "param_1": "address",
                "param_2": "data",
                "param_3": "mask",
                "uVar1": "shiftAmount",
                "uVar2": "difference"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_attach_tx_callback",
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080024f8": {
            "entrypoint": "0x080024f8",
            "current_name": "set_bit_080024f8",
            "code": "\nvoid setBit_080024f8(uint index)\n\n{\n  if (-1 < (int)index) {\n    *(int *)((index >> 5) * 4 + -0x1fff1f00) = 1 << (index & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080024f8": "set_bit_080024f8",
                "param_1": "index"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_attach_tx_callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002514": {
            "entrypoint": "0x08002514",
            "current_name": "initialize_memory_08002514",
            "code": "\n\n\nundefined4 initializeMemory_08002514(int value)\n\n{\n  if (value - 1U < 0x1000000) {\n    _DAT_e000e014 = value - 1U;\n    DAT_e000ed23 = 0xf0;\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002514": "initialize_memory_08002514",
                "param_1": "value"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002540": {
            "entrypoint": "0x08002540",
            "current_name": "set_bit_08002540",
            "code": "\nvoid setBit_08002540(uint bitPosition)\n\n{\n  if (-1 < signedBitPosition) {\n    *(int *)(((bitPosition >> 5) + 0x60) * 4 + -0x1fff1f00) = 1 << (bitPosition & 0x1f);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002540": "set_bit_08002540",
                "param_1": "bitPosition",
                "(int)param_1": "signedBitPosition"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002560": {
            "entrypoint": "0x08002560",
            "current_name": "update_data_register_08002560",
            "code": "\n\n\nvoid updateDataRegister_08002560(int value)\n\n{\n  if (value != 4) {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n    return;\n  }\n  _DAT_e000e010 = _DAT_e000e010 | 4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002560": "update_data_register_08002560",
                "param_1": "value"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002580": {
            "entrypoint": "0x08002580",
            "current_name": "FUNC_08002580",
            "code": "\nvoid FUNC_08002580(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002580": "FUNC_08002580"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002582": {
            "entrypoint": "0x08002582",
            "current_name": "handle_sys_tick_event_08002582",
            "code": "\nvoid handleSysTickEvent_08002582(void)\n\n{\n  systickCallback();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002582": "handle_sys_tick_event_08002582",
                "HAL_SYSTICK_Callback": "systickCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_SYSTICK_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800258c": {
            "entrypoint": "0x0800258c",
            "current_name": "initialize_settings_0800258c",
            "code": "\n\n\nundefined4 initializeSettings_0800258c(uint **settings)\n\n{\n  uint *currentSetting;\n  \n  if (*(char *)((int)settings + 0x21) != '\\x02') {\n    errorCode = (uint *)0x4;\n    return 1;\n  }\n  **settings = **settings & 0xfffffff1;\n  **settings = **settings & 0xfffffffe;\n  currentSetting = *settings;\n  if (currentSetting == (uint *)0x40020008) {\n    _DAT_40020004 = 1;\n  }\n  else if (currentSetting == (uint *)0x4002001c) {\n    _DAT_40020004 = 0x10;\n  }\n  else if (currentSetting == (uint *)0x40020030) {\n    _DAT_40020004 = 0x100;\n  }\n  else if (currentSetting == (uint *)0x40020044) {\n    _DAT_40020004 = 0x1000;\n  }\n  else if (currentSetting == (uint *)0x40020058) {\n    _DAT_40020004 = 0x10000;\n  }\n  else if (currentSetting == (uint *)0x4002006c) {\n    _DAT_40020004 = 0x100000;\n  }\n  else {\n    _DAT_40020004 = 0x1000000;\n  }\n  *(undefined *)((int)settings + 0x21) = 1;\n  *(undefined *)(settings + 8) = 0;\n  if (functionPointer != (uint *)0x0) {\n    (*(code *)functionPointer)();\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800258c": "initialize_settings_0800258c",
                "param_1": "settings",
                "puVar1": "currentSetting",
                "param_1[0xe]": "errorCode",
                "param_1[0xd]": "functionPointer"
            },
            "calling": [
                "I2C_ITError",
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002624": {
            "entrypoint": "0x08002624",
            "current_name": "update_registers_08002624",
            "code": "\n\n\nvoid updateRegisters_08002624(uint *registerValues,uint *instructionSet)\n\n{\n  uint *ptr1;\n  uint bitMask;\n  uint temp;\n  uint counter;\n  uint opcode;\n  uint offset;\n  int shift;\n  int index;\n  \n  offset = 0;\n  counter = 0;\n  do {\n    if (0xf < counter) {\n      return;\n    }\n    bitMask = 1 << (counter & 0xff);\n    temp = *instructionSet & bitMask;\n    if (bitMask == temp) {\n      opcode = instructionSet[1];\n      if (opcode == 0x12) {\n        offset = instructionSet[3] + 0xc;\n      }\n      else if (opcode < 0x13) {\n        if (opcode == 2) {\n          offset = instructionSet[3] + 8;\n        }\n        else if (opcode < 3) {\n          if (opcode == 0) goto LAB_08002776;\n          if (opcode == 1) {\n            offset = instructionSet[3];\n          }\n        }\n        else if (opcode == 3) {\n          offset = 0;\n        }\n        else if (opcode == 0x11) {\n          offset = instructionSet[3] + 4;\n        }\n      }\n      else if (opcode == 0x10210000) {\nLAB_08002776:\n        if (instructionSet[2] == 0) {\n          offset = 4;\n        }\n        else if (instructionSet[2] == 1) {\n          registerValues[4] = bitMask;\n          offset = 8;\n        }\n        else {\n          registerValues[5] = bitMask;\n          offset = 8;\n        }\n      }\n      else if (opcode < 0x10210001) {\n        if ((opcode == 0x10110000) || (opcode == 0x10120000)) goto LAB_08002776;\n      }\n      else if ((opcode == 0x10310000) || ((opcode == 0x10320000 || (opcode == 0x10220000))))\n      goto LAB_08002776;\n      bitMask = counter;\n      ptr1 = registerValues;\n      if (0xff < temp) {\n        bitMask = counter - 8;\n        ptr1 = registerValues + 1;\n      }\n      *ptr1 = *ptr1 & ~(0xf << (bitMask << 2 & 0xff)) | offset << (bitMask << 2 & 0xff);\n      if ((instructionSet[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        shift = (counter & 3) << 2;\n        if (registerValues == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (registerValues == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (registerValues == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (registerValues == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((counter >> 2) + 2) * 4 + 0x40010000) =\n             *(uint *)(((counter >> 2) + 2) * 4 + 0x40010000) & ~(0xf << shift) | index << shift;\n        if ((instructionSet[1] & 0x10000) == 0) {\n          _DAT_40010400 = _DAT_40010400 & ~temp;\n        }\n        else {\n          _DAT_40010400 = _DAT_40010400 | temp;\n        }\n        if ((instructionSet[1] & 0x20000) == 0) {\n          _DAT_40010404 = _DAT_40010404 & ~temp;\n        }\n        else {\n          _DAT_40010404 = _DAT_40010404 | temp;\n        }\n        if ((instructionSet[1] & 0x100000) == 0) {\n          _DAT_40010408 = _DAT_40010408 & ~temp;\n        }\n        else {\n          _DAT_40010408 = _DAT_40010408 | temp;\n        }\n        if ((instructionSet[1] & 0x200000) == 0) {\n          _DAT_4001040c = _DAT_4001040c & ~temp;\n        }\n        else {\n          _DAT_4001040c = temp | _DAT_4001040c;\n        }\n      }\n    }\n    counter = counter + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08002624": "update_registers_08002624",
                "param_1": "registerValues",
                "param_2": "instructionSet",
                "puVar1": "ptr1",
                "uVar2": "bitMask",
                "uVar3": "temp",
                "uVar4": "counter",
                "uVar5": "opcode",
                "uVar6": "offset",
                "iVar7": "shift",
                "iVar8": "index"
            },
            "calling": [
                "uart_init",
                "digital_io_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002810": {
            "entrypoint": "0x08002810",
            "current_name": "check_bitwise_intersection_08002810",
            "code": "\nundefined4 checkBitwiseIntersection_08002810(int inputValue,uint maskValue)\n\n{\n  if ((maskValue & *(uint *)(inputValue + 8)) == 0) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002810": "check_bitwise_intersection_08002810",
                "param_1": "inputValue",
                "param_2": "maskValue"
            },
            "calling": [
                "digital_io_read"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800281e": {
            "entrypoint": "0x0800281e",
            "current_name": "update_data_0800281e",
            "code": "\nvoid updateData_0800281e(int dataAddress,int newValue,int isShifted)\n\n{\n  if (isShifted == 0) {\n    *(int *)(dataAddress + 0x10) = newValue << 0x10;\n    return;\n  }\n  *(int *)(dataAddress + 0x10) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800281e": "update_data_0800281e",
                "param_1": "dataAddress",
                "param_2": "newValue",
                "param_3": "isShifted"
            },
            "calling": [
                "digital_io_write"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800282c": {
            "entrypoint": "0x0800282c",
            "current_name": "update_gpio_state_0800282c",
            "code": "\n\n\nvoid update_GPIO_state_0800282c(uint gpio_state)\n\n{\n  if ((_DAT_40010414 & gpio_state) != 0) {\n    _DAT_40010414 = gpio_state;\n    handle_GPIO_interrupt();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800282c": "update_gpio_state_0800282c",
                "param_1": "gpio_state",
                "HAL_GPIO_EXTI_Callback": "handle_GPIO_interrupt"
            },
            "calling": [],
            "called": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002848": {
            "entrypoint": "0x08002848",
            "current_name": "update_flag_value_08002848",
            "code": "\nundefined4 updateFlagValue_08002848(int *inputData)\n\n{\n  if (*(char *)((int)inputData + 0x3e) == '@') {\n    if (condition1 == 0) {\n      *(uint *)(*inputData + 0x10) = value1 & 0xfe;\n    }\n    else {\n      *(uint *)(*inputData + 0x10) = value1 & 0xffU | 1;\n    }\n  }\n  else if (condition2 == 0x4000) {\n    if (*(char *)((int)inputData + 0x3d) == '!') {\n      *(uint *)(*inputData + 0x10) = value1 & 0xfe;\n    }\n    else {\n      *(uint *)(*inputData + 0x10) = value1 & 0xffU | 1;\n    }\n  }\n  else if (condition1 == 0) {\n    *(uint *)(*inputData + 0x10) = (uint)(value1 << 0x10) >> 0x17 & 6 | 0xf0;\n  }\n  else if (condition1 == 1) {\n    *(uint *)(*inputData + 0x10) = (uint)(value1 << 0x10) >> 0x17 & 6 | 0xf1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002848": "update_flag_value_08002848",
                "param_1": "inputData",
                "param_1[0x14]": "condition1",
                "param_1[0x11]": "value1",
                "param_1[4]": "condition2"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028d2": {
            "entrypoint": "0x080028d2",
            "current_name": "store_parameter_value_080028d2",
            "code": "\nundefined4 storeParameterValue_080028d2(int *parameter)\n\n{\n  *(uint *)(*parameter + 0x10) = value & 0xff;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080028d2": "store_parameter_value_080028d2",
                "param_1": "parameter",
                "param_1[0x11]": "value"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080028de": {
            "entrypoint": "0x080028de",
            "current_name": "update_flags_080028de",
            "code": "\nundefined4 updateFlags_080028de(uint **parameters)\n\n{\n  uint *ptr1;\n  \n  ptr1 = ptr8;\n  if ((*(char *)((int)parameters + 0x3d) == '\\\"') &&\n     ((ptr2 != (uint *)0x0 || (*(char *)((int)parameters + 0x3e) != '@')))) {\n    if ((ptr2 == (uint *)0x0) && (ptr3 == (uint *)0xc000)) {\n      **parameters = **parameters | 0x100;\n      ptr2 = (uint *)((int)ptr2 + 1);\n    }\n    else {\n      if (*(short *)((int)parameters + 0x2a) == 0) {\n        **parameters = **parameters | 0x200;\n      }\n      else if (*(short *)((int)parameters + 0x2a) == 1) {\n        if (ptr1 == (uint *)0xffff0000) {\n          **parameters = **parameters & 0xfffffbff;\n          ptr1 = *parameters;\n          if ((ptr1[1] & 0x800) == 0) {\n            *ptr1 = *ptr1 | 0x200;\n          }\n          else {\n            *ptr1 = *ptr1 & 0xfffffbff;\n          }\n        }\n        else if (((ptr1 == (uint *)0x4) || (ptr1 == (uint *)0x8)) ||\n                (ptr7 == (uint *)0x12)) {\n          **parameters = **parameters & 0xfffffbff;\n          **parameters = **parameters | 0x200;\n        }\n        else if (ptr8 == (uint *)0x2) {\n          **parameters = **parameters | 0x400;\n        }\n        else {\n          **parameters = **parameters & 0xfffffbff;\n        }\n      }\n      else if (*(short *)((int)parameters + 0x2a) == 2) {\n        if (ptr8 == (uint *)0x2) {\n          **parameters = **parameters | 0x400;\n        }\n        else {\n          **parameters = **parameters | 0x800;\n          **parameters = **parameters & 0xfffffbff;\n        }\n        ptr1 = *parameters;\n        if ((ptr1[1] & 0x800) != 0) {\n          ptr1[1] = ptr1[1] | 0x1000;\n        }\n      }\n      else {\n        **parameters = **parameters | 0x400;\n        ptr1 = *parameters;\n        if ((ptr1[1] & 0x800) != 0) {\n          ptr1[1] = ptr1[1] | 0x1000;\n        }\n      }\n      ptr2 = (uint *)0x0;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080028de": "update_flags_080028de",
                "param_1": "parameters",
                "puVar1": "ptr1",
                "param_1[0x14]": "ptr2",
                "param_1[4]": "ptr3",
                "param_1[0xc]": "ptr7",
                "param_1[0xb]": "ptr8"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ab8": {
            "entrypoint": "0x08002ab8",
            "current_name": "update_data_08002ab8",
            "code": "\nundefined4 updateData_08002ab8(int *dataPointer)\n\n{\n  byte *bytePointer;\n  \n  if (*(short *)((int)dataPointer + 0x2a) != 0) {\n    bytePointer = (byte *)dataPointer[9];\n    dataPointer[9] = (int)(bytePointer + 1);\n    *(uint *)(*dataPointer + 0x10) = (uint)*bytePointer;\n    *(short *)((int)dataPointer + 0x2a) = *(short *)((int)dataPointer + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002ab8": "update_data_08002ab8",
                "param_1": "dataPointer",
                "pbVar1": "bytePointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "update_data_08002ad8",
            "code": "\nundefined4 updateData_08002ad8(int *data)\n\n{\n  undefined *pointer;\n  \n  if (*(short *)((int)data + 0x2a) != 0) {\n    pointer = (undefined *)data[9];\n    data[9] = (int)(pointer + 1);\n    *pointer = (char)*(undefined4 *)(*data + 0x10);\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "update_data_08002ad8",
                "param_1": "data",
                "puVar1": "pointer"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002af8": {
            "entrypoint": "0x08002af8",
            "current_name": "validate_input_08002af8",
            "code": "\nundefined4 validate_input_08002af8(uint **validation_data,uint *param_2,int param_3,uint *param_4)\n\n{\n  undefined4 result_code;\n  uint *ptr;\n  \n  if (*(char *)((int)validation_data + 0x3d) == '(') {\n    if (param_2 == (uint *)0x0) {\n      result_code = 1;\n    }\n    else if (param_3 == 0) {\n      result_code = 1;\n    }\n    else if (*(char *)(validation_data + 0xf) == '\\x01') {\n      result_code = 2;\n    }\n    else {\n      *(undefined *)(validation_data + 0xf) = 1;\n      ptr = *validation_data;\n      if ((*ptr & 1) == 0) {\n        *ptr = *ptr | 1;\n      }\n      **validation_data = **validation_data & 0xfffff7ff;\n      *(undefined *)((int)validation_data + 0x3d) = 0x29;\n      *(undefined *)((int)validation_data + 0x3e) = 0x20;\n      result_code = 0;\n      data_pointer1 = (uint *)0x0;\n      data_pointer2 = param_2;\n      *(short *)((int)validation_data + 0x2a) = (short)param_3;\n      data_pointer3 = param_4;\n      *(undefined2 *)(validation_data + 10) = *(undefined2 *)((int)validation_data + 0x2a);\n      *(undefined *)(validation_data + 0xf) = 0;\n      (*validation_data)[1] = (*validation_data)[1] | 0x700;\n    }\n  }\n  else {\n    result_code = 2;\n  }\n  return result_code;\n}\n\n",
            "renaming": {
                "FUN_08002af8": "validate_input_08002af8",
                "param_1": "validation_data",
                "uVar1": "result_code",
                "puVar2": "ptr",
                "param_1[0x10]": "data_pointer1",
                "param_1[9]": "data_pointer2",
                "param_1[0xb]": "data_pointer3"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002b84": {
            "entrypoint": "0x08002b84",
            "current_name": "check_and_update_data_08002b84",
            "code": "\nundefined4 check_and_update_data_08002b84(uint **config_data,uint *optional_data,int size_optional_data,uint *required_data)\n\n{\n  undefined4 return_value;\n  uint *ptr_config_data;\n  \n  if (*(char *)((int)config_data + 0x3d) == '(') {\n    if (optional_data == (uint *)0x0) {\n      return_value = 1;\n    }\n    else if (size_optional_data == 0) {\n      return_value = 1;\n    }\n    else if (*(char *)(config_data + 0xf) == '\\x01') {\n      return_value = 2;\n    }\n    else {\n      *(undefined *)(config_data + 0xf) = 1;\n      ptr_config_data = *config_data;\n      if ((*ptr_config_data & 1) == 0) {\n        *ptr_config_data = *ptr_config_data | 1;\n      }\n      **config_data = **config_data & 0xfffff7ff;\n      *(undefined *)((int)config_data + 0x3d) = 0x2a;\n      *(undefined *)((int)config_data + 0x3e) = 0x20;\n      return_value = 0;\n      config_data[0x10] = (uint *)0x0;\n      config_data[9] = optional_data;\n      *(short *)((int)config_data + 0x2a) = (short)size_optional_data;\n      config_data[0xb] = required_data;\n      *(undefined2 *)(config_data + 10) = *(undefined2 *)((int)config_data + 0x2a);\n      *(undefined *)(config_data + 0xf) = 0;\n      (*config_data)[1] = (*config_data)[1] | 0x700;\n    }\n  }\n  else {\n    return_value = 2;\n  }\n  return return_value;\n}\n\n",
            "renaming": {
                "FUN_08002b84": "check_and_update_data_08002b84",
                "param_1": "config_data",
                "param_2": "optional_data",
                "param_3": "size_optional_data",
                "param_4": "required_data",
                "uVar1": "return_value",
                "puVar2": "ptr_config_data"
            },
            "calling": [
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c10": {
            "entrypoint": "0x08002c10",
            "current_name": "initialize_parameters_08002c10",
            "code": "\nundefined4 initializeParameters_08002c10(uint **params)\n\n{\n  uint *paramValue;\n  \n  if (*(char *)((int)params + 0x3d) != ' ') {\n    return 2;\n  }\n  *(undefined *)((int)params + 0x3d) = 0x28;\n  paramValue = *params;\n  if ((*paramValue & 1) == 0) {\n    *paramValue = *paramValue | 1;\n  }\n  **params = **params | 0x400;\n  (*params)[1] = (*params)[1] | 0x300;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002c10": "initialize_parameters_08002c10",
                "param_1": "params",
                "puVar1": "paramValue"
            },
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c4e": {
            "entrypoint": "0x08002c4e",
            "current_name": "FUNC_08002c4e",
            "code": "\nvoid FUNC_08002c4e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c4e": "FUNC_08002c4e"
            },
            "calling": [
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c50": {
            "entrypoint": "0x08002c50",
            "current_name": "FUNC_08002c50",
            "code": "\nvoid FUNC_08002c50(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c50": "FUNC_08002c50"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c52": {
            "entrypoint": "0x08002c52",
            "current_name": "FUNC_08002c52",
            "code": "\nvoid FUNC_08002c52(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002c52": "FUNC_08002c52"
            },
            "calling": [
                "I2C_Slave_AF",
                "I2C_SlaveTransmit_TXE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002c54": {
            "entrypoint": "0x08002c54",
            "current_name": "update_and_send_data_08002c54",
            "code": "\nundefined4 updateAndSendData_08002c54(int *data)\n\n{\n  char charValue;\n  byte *bytePtr;\n  \n  charValue = *(char *)((int)data + 0x3d);\n  if (*(short *)((int)data + 0x2a) != 0) {\n    bytePtr = (byte *)data[9];\n    data[9] = (int)(bytePtr + 1);\n    *(uint *)(*data + 0x10) = (uint)*bytePtr;\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    if ((*(short *)((int)data + 0x2a) == 0) && (charValue == ')')) {\n      *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xfffffbff;\n      value = 0x21;\n      *(undefined *)((int)data + 0x3d) = 0x28;\n      HAL_I2C_SlaveTxCpltCallback();\n    }\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002c54": "update_and_send_data_08002c54",
                "param_1": "data",
                "cVar1": "charValue",
                "pbVar2": "bytePtr",
                "param_1[0xc]": "value"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca4": {
            "entrypoint": "0x08002ca4",
            "current_name": "FUNC_08002ca4",
            "code": "\nvoid FUNC_08002ca4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002ca4": "FUNC_08002ca4"
            },
            "calling": [
                "I2C_Slave_STOPF",
                "I2C_SlaveReceive_RXNE"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca6": {
            "entrypoint": "0x08002ca6",
            "current_name": "update_data_and_callback_08002ca6",
            "code": "\nundefined4 updateDataAndCallback_08002ca6(int *data)\n\n{\n  char flag;\n  undefined *ptr;\n  \n  flag = *(char *)((int)data + 0x3d);\n  if (*(short *)((int)data + 0x2a) != 0) {\n    ptr = (undefined *)data[9];\n    data[9] = (int)(ptr + 1);\n    *ptr = (char)*(undefined4 *)(*data + 0x10);\n    *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    if ((*(short *)((int)data + 0x2a) == 0) && (flag == '*')) {\n      *(uint *)(*data + 4) = *(uint *)(*data + 4) & 0xfffffbff;\n      data[0xc] = 0x22;\n      *(undefined *)((int)data + 0x3d) = 0x28;\n      HAL_I2C_SlaveRxCpltCallback();\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002ca6": "update_data_and_callback_08002ca6",
                "param_1": "data",
                "cVar1": "flag",
                "puVar2": "ptr"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002cf2": {
            "entrypoint": "0x08002cf2",
            "current_name": "handle_i2_c_address_callback_08002cf2",
            "code": "\nundefined4 handleI2CAddressCallback_08002cf2(int *i2cData,undefined4 param2,undefined4 param3,undefined4 param4)\n\n{\n  undefined2 selectedAddress;\n  uint i2cValue;\n  \n  i2cValue = *(uint *)(*i2cData + 0x18);\n  if ((i2cValue & 0x80) == 0) {\n    selectedAddress = *(undefined2 *)(i2cData + 3);\n  }\n  else {\n    selectedAddress = *(undefined2 *)(i2cData + 6);\n  }\n  HAL_I2C_AddrCallback(i2cData,(*(uint *)(*i2cData + 0x18) & 4) == 0,selectedAddress,i2cValue,param4);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002cf2": "handle_i2_c_address_callback_08002cf2",
                "param_1": "i2cData",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "selectedAddress",
                "uVar2": "i2cValue"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_AddrCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d1c": {
            "entrypoint": "0x08002d1c",
            "current_name": "handle_i2_c_events_08002d1c",
            "code": "\nundefined4 handleI2CEvents_08002d1c(uint **eventData)\n\n{\n  if (((eventData[11] == (uint *)0x4) || (eventData[11] == (uint *)0x8)) &&\n     (*(char *)((int)eventData + 0x3d) == '(')) {\n    eventData[11] = (uint *)0xffff0000;\n    (*eventData)[1] = (*eventData)[1] & 0xfffff8ff;\n    (*eventData)[5] = 0xfffffbff;\n    **eventData = **eventData & 0xfffffbff;\n    eventData[12] = (uint *)0x0;\n    *(undefined *)((int)eventData + 0x3d) = 0x20;\n    *(undefined *)((int)eventData + 0x3e) = 0;\n    handleI2CListenComplete();\n  }\n  else if (*(char *)((int)eventData + 0x3d) == '!') {\n    eventData[11] = (uint *)0xffff0000;\n    eventData[12] = (uint *)0x21;\n    *(undefined *)((int)eventData + 0x3d) = 0x20;\n    *(undefined *)((int)eventData + 0x3e) = 0;\n    (*eventData)[1] = (*eventData)[1] & 0xfffff8ff;\n    (*eventData)[5] = 0xfffffbff;\n    **eventData = **eventData & 0xfffffbff;\n    handleI2CSlaveTxComplete();\n  }\n  else {\n    (*eventData)[5] = 0xfffffbff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002d1c": "handle_i2_c_events_08002d1c",
                "param_1": "eventData",
                "param_1[0xb]": "eventData[11]",
                "param_1[0xc]": "eventData[12]",
                "HAL_I2C_ListenCpltCallback()": "handleI2CListenComplete()",
                "HAL_I2C_SlaveTxCpltCallback()": "handleI2CSlaveTxComplete()"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveTxCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002db0": {
            "entrypoint": "0x08002db0",
            "current_name": "FUNC_08002db0",
            "code": "\nvoid FUNC_08002db0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002db0": "FUNC_08002db0"
            },
            "calling": [
                "I2C_MasterTransmit_TXE",
                "I2C_MasterTransmit_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002db2": {
            "entrypoint": "0x08002db2",
            "current_name": "process_data_08002db2",
            "code": "\nundefined4 processData_08002db2(uint **data)\n\n{\n  char char1;\n  uint *ptr2;\n  \n  char1 = *(char *)((int)data + 0x3d);\n  ptr2 = data[0xb];\n  if ((*(short *)(data + 10) == 0) && (char1 == '!')) {\n    if ((ptr2 == (uint *)0x4) || ((ptr2 == (uint *)0x8 || (ptr2 == (uint *)0xffff0000)))) {\n      (*data)[1] = (*data)[1] & 0xfffff8ff;\n      **data = **data | 0x200;\n      data[0xc] = (uint *)0x0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      if (*(char *)((int)data + 0x3e) == '@') {\n        *(undefined *)((int)data + 0x3e) = 0;\n        HAL_I2C_MemTxCpltCallback();\n      }\n      else {\n        *(undefined *)((int)data + 0x3e) = 0;\n        HAL_I2C_MasterTxCpltCallback();\n      }\n    }\n    else {\n      (*data)[1] = (*data)[1] & 0xfffff8ff;\n      data[0xc] = (uint *)0x11;\n      *(undefined *)((int)data + 0x3e) = 0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      HAL_I2C_MasterTxCpltCallback();\n    }\n  }\n  else if ((char1 == '!') || ((*(char *)((int)data + 0x3e) == '@' && (char1 == '\\\"')))) {\n    if (*(short *)((int)data + 0x2a) == 0) {\n      (*data)[1] = (*data)[1] & 0xfffffbff;\n    }\n    else if (*(char *)((int)data + 0x3e) == '@') {\n      if (data[0x14] == (uint *)0x0) {\n        if (data[0x13] == (uint *)0x1) {\n          (*data)[4] = (uint)data[0x12] & 0xff;\n          data[0x14] = (uint *)((int)data[0x14] + 2);\n        }\n        else {\n          (*data)[4] = (uint)((int)data[0x12] << 0x10) >> 0x18;\n          data[0x14] = (uint *)((int)data[0x14] + 1);\n        }\n      }\n      else if (data[0x14] == (uint *)0x1) {\n        (*data)[4] = (uint)data[0x12] & 0xff;\n        data[0x14] = (uint *)((int)data[0x14] + 1);\n      }\n      else if (data[0x14] == (uint *)0x2) {\n        if (*(char *)((int)data + 0x3d) == '\\\"') {\n          **data = **data | 0x100;\n        }\n        else if (*(char *)((int)data + 0x3d) == '!') {\n          ptr2 = data[9];\n          data[9] = (uint *)((int)ptr2 + 1);\n          (*data)[4] = (uint)*(byte *)ptr2;\n          *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n        }\n      }\n    }\n    else {\n      ptr2 = data[9];\n      data[9] = (uint *)((int)ptr2 + 1);\n      (*data)[4] = (uint)*(byte *)ptr2;\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002db2": "process_data_08002db2",
                "param_1": "data",
                "cVar1": "char1",
                "puVar2": "ptr2"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002efc": {
            "entrypoint": "0x08002efc",
            "current_name": "handle_i2_c_transfer_08002efc",
            "code": "\nundefined4 handleI2CTransfer_08002efc(uint **transferData)\n\n{\n  uint *element;\n  \n  element = transferData[0xb];\n  if (*(char *)((int)transferData + 0x3d) == '!') {\n    if (*(short *)((int)transferData + 0x2a) == 0) {\n      if (((element == (uint *)0x4) || (element == (uint *)0x8)) || (element == (uint *)0xffff0000)) {\n        (*transferData)[1] = (*transferData)[1] & 0xfffff8ff;\n        **transferData = **transferData | 0x200;\n        transferData[0xc] = (uint *)0x0;\n        *(undefined *)((int)transferData + 0x3d) = 0x20;\n        if (*(char *)((int)transferData + 0x3e) == '@') {\n          *(undefined *)((int)transferData + 0x3e) = 0;\n          handleMemoryTransmitComplete();\n        }\n        else {\n          *(undefined *)((int)transferData + 0x3e) = 0;\n          handleMasterTransmitComplete();\n        }\n      }\n      else {\n        (*transferData)[1] = (*transferData)[1] & 0xfffff8ff;\n        transferData[0xc] = (uint *)0x11;\n        *(undefined *)((int)transferData + 0x3e) = 0;\n        *(undefined *)((int)transferData + 0x3d) = 0x20;\n        handleMasterTransmitComplete();\n      }\n    }\n    else {\n      element = transferData[9];\n      transferData[9] = (uint *)((int)element + 1);\n      (*transferData)[4] = (uint)*(byte *)element;\n      *(short *)((int)transferData + 0x2a) = *(short *)((int)transferData + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002efc": "handle_i2_c_transfer_08002efc",
                "param_1": "transferData",
                "puVar1": "element",
                "HAL_I2C_MemTxCpltCallback": "handleMemoryTransmitComplete",
                "HAL_I2C_MasterTxCpltCallback": "handleMasterTransmitComplete"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterTxCpltCallback",
                "HAL_I2C_MemTxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9a": {
            "entrypoint": "0x08002f9a",
            "current_name": "FUNC_08002f9a",
            "code": "\nvoid FUNC_08002f9a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002f9a": "FUNC_08002f9a"
            },
            "calling": [
                "I2C_MasterReceive_RXNE",
                "I2C_MasterReceive_BTF"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002f9c": {
            "entrypoint": "0x08002f9c",
            "current_name": "handle_i2_c_event_08002f9c",
            "code": "\nundefined4 handleI2CEvent_08002f9c(uint **eventData)\n\n{\n  uint *tempPtr;\n  \n  if (*(char *)((int)eventData + 0x3d) == '\\\"') {\n    if (*(ushort *)((int)eventData + 0x2a) < 4) {\n      if (*(ushort *)((int)eventData + 0x2a) - 2 < 2) {\n        if (paramB == (uint *)0x2) {\n          **eventData = **eventData | 0x400;\n        }\n        else {\n          **eventData = **eventData & 0xfffffbff;\n          **eventData = **eventData | 0x800;\n        }\n        (*eventData)[1] = (*eventData)[1] & 0xfffffbff;\n      }\n      else {\n        if (paramB == (uint *)0x2) {\n          **eventData = **eventData | 0x400;\n        }\n        else {\n          **eventData = **eventData & 0xfffffbff;\n        }\n        (*eventData)[1] = (*eventData)[1] & 0xfffff8ff;\n        tempPtr = param9;\n        param9 = (uint *)((int)tempPtr + 1);\n        *(char *)tempPtr = (char)(*eventData)[4];\n        *(short *)((int)eventData + 0x2a) = *(short *)((int)eventData + 0x2a) + -1;\n        *(undefined *)((int)eventData + 0x3d) = 0x20;\n        eventData[0xc] = (uint *)0x0;\n        if (*(char *)((int)eventData + 0x3e) == '@') {\n          *(undefined *)((int)eventData + 0x3e) = 0;\n          HAL_I2C_MemRxCpltCallback();\n        }\n        else {\n          *(undefined *)((int)eventData + 0x3e) = 0;\n          HAL_I2C_MasterRxCpltCallback();\n        }\n      }\n    }\n    else {\n      tempPtr = param9;\n      param9 = (uint *)((int)tempPtr + 1);\n      *(char *)tempPtr = (char)(*eventData)[4];\n      *(short *)((int)eventData + 0x2a) = *(short *)((int)eventData + 0x2a) + -1;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08002f9c": "handle_i2_c_event_08002f9c",
                "param_1": "eventData",
                "puVar1": "tempPtr",
                "param_1[0xb]": "paramB",
                "param_1[9]": "param9"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800306c": {
            "entrypoint": "0x0800306c",
            "current_name": "process_data_0800306c",
            "code": "\nundefined4 processData_0800306c(uint **inputData)\n\n{\n  uint *var1;\n  \n  var1 = inputData[0xb];\n  if (*(short *)((int)inputData + 0x2a) == 3) {\n    if (((var1 == (uint *)0x4) || (var1 == (uint *)0x8)) || (var1 == (uint *)0xffff0000)) {\n      **inputData = **inputData & 0xfffffbff;\n    }\n    var1 = inputData[9];\n    inputData[9] = (uint *)((int)var1 + 1);\n    *(char *)var1 = (char)(*inputData)[4];\n    *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n  }\n  else if (*(short *)((int)inputData + 0x2a) == 2) {\n    if (((var1 == (uint *)0x4) || (var1 == (uint *)0x8)) || (var1 == (uint *)0xffff0000)) {\n      (*inputData)[1] = (*inputData)[1] & 0xfffffcff;\n      **inputData = **inputData | 0x200;\n    }\n    else {\n      if (var1 == (uint *)0x2) {\n        **inputData = **inputData | 0x400;\n      }\n      else {\n        **inputData = **inputData & 0xfffffbff;\n      }\n      (*inputData)[1] = (*inputData)[1] & 0xfffffcff;\n    }\n    var1 = inputData[9];\n    inputData[9] = (uint *)((int)var1 + 1);\n    *(char *)var1 = (char)(*inputData)[4];\n    *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n    var1 = inputData[9];\n    inputData[9] = (uint *)((int)var1 + 1);\n    *(char *)var1 = (char)(*inputData)[4];\n    *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n    *(undefined *)((int)inputData + 0x3d) = 0x20;\n    inputData[0xc] = (uint *)0x0;\n    if (*(char *)((int)inputData + 0x3e) == '@') {\n      *(undefined *)((int)inputData + 0x3e) = 0;\n      HAL_I2C_MemRxCpltCallback();\n    }\n    else {\n      *(undefined *)((int)inputData + 0x3e) = 0;\n      HAL_I2C_MasterRxCpltCallback();\n    }\n  }\n  else {\n    var1 = inputData[9];\n    inputData[9] = (uint *)((int)var1 + 1);\n    *(char *)var1 = (char)(*inputData)[4];\n    *(short *)((int)inputData + 0x2a) = *(short *)((int)inputData + 0x2a) + -1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800306c": "process_data_0800306c",
                "param_1": "inputData",
                "puVar1": "var1"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_MasterRxCpltCallback",
                "HAL_I2C_MemRxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800316a": {
            "entrypoint": "0x0800316a",
            "current_name": "FUNC_0800316a",
            "code": "\nvoid FUNC_0800316a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316a": "FUNC_0800316a"
            },
            "calling": [
                "I2C_ITError"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800316c": {
            "entrypoint": "0x0800316c",
            "current_name": "process_i2_c_event_0800316c",
            "code": "\nvoindexd processI2CEvent_0800316c(uindexnt **i2cData)\n\n{\n  indexnt dmaAbortResult;\n  uindexnt *nextCharPtr;\n  uindexnt *i2cEvent;\n  \n  indexf (*(byte *)((indexnt)i2cData + 0x3d) - 0x29 < 2) {\n    i2cData[0xc] = (uindexnt *)0x0;\n    *(undefindexned *)((indexnt)i2cData + 0x3d) = 0x28;\n  }\n  else {\n    indexf ((*(char *)((indexnt)i2cData + 0x3d) != '`') && (((*i2cData)[1] & 0x800) == 0)) {\n      *(undefindexned *)((indexnt)i2cData + 0x3d) = 0x20;\n    }\n    i2cData[0xc] = (uindexnt *)0x0;\n    *(undefindexned *)((indexnt)i2cData + 0x3e) = 0;\n  }\n  **i2cData = **i2cData & 0xfffff7ff;\n  i2cEvent = *i2cData;\n  indexf ((i2cEvent[1] & 0x800) == 0) {\n    indexf (*(char *)((indexnt)i2cData + 0x3d) == '`') {\n      *(undefindexned *)((indexnt)i2cData + 0x3d) = 0x20;\n      i2cData[0x10] = (uindexnt *)0x0;\n      indexf ((i2cEvent[5] & 0x40) != 0) {\n        nextCharPtr = i2cData[9];\n        i2cData[9] = (uindexnt *)((indexnt)nextCharPtr + 1);\n        *(char *)nextCharPtr = (char)i2cEvent[4];\n      }\n      **i2cData = **i2cData & 0xfffffffe;\n      handleI2CAbortComplete(i2cData);\n    }\n    else {\n      indexf ((i2cEvent[5] & 0x40) != 0) {\n        nextCharPtr = i2cData[9];\n        i2cData[9] = (uindexnt *)((indexnt)nextCharPtr + 1);\n        *(char *)nextCharPtr = (char)i2cEvent[4];\n      }\n      handleI2CError(i2cData);\n    }\n  }\n  else {\n    i2cEvent[1] = i2cEvent[1] & 0xfffff7ff;\n    indexf (*(char *)((indexnt)i2cData[0xd] + 0x21) == '\\x01') {\n      i2cData[0xe][0xd] = (uindexnt)&label_080035fc_1;\n      dmaAbortResult = abortDMAWithInterrupt(i2cData[0xe]);\n      indexf (dmaAbortResult != 0) {\n        indexf (((*i2cData)[5] & 0x40) != 0) {\n          i2cEvent = i2cData[9];\n          i2cData[9] = (uindexnt *)((indexnt)i2cEvent + 1);\n          *(char *)i2cEvent = (char)(*i2cData)[4];\n        }\n        **i2cData = **i2cData & 0xfffffffe;\n        *(undefindexned *)((indexnt)i2cData + 0x3d) = 0x20;\n        (*(code *)i2cData[0xe][0xd])();\n      }\n    }\n    else {\n      i2cData[0xd][0xd] = (uindexnt)&label_080035fc_1;\n      dmaAbortResult = abortDMAWithInterrupt(i2cData[0xd]);\n      indexf (dmaAbortResult != 0) {\n        **i2cData = **i2cData & 0xfffffffe;\n        *(undefindexned *)((indexnt)i2cData + 0x3d) = 0x20;\n        (*(code *)i2cData[0xd][0xd])();\n      }\n    }\n  }\n  indexf ((*(char *)((indexnt)i2cData + 0x3d) == '(') && (((uindexnt)i2cData[0x10] & 4) != 0)) {\n    i2cData[0xb] = (uindexnt *)0xffff0000;\n    i2cData[0xc] = (uindexnt *)0x0;\n    *(undefindexned *)((indexnt)i2cData + 0x3d) = 0x20;\n    *(undefindexned *)((indexnt)i2cData + 0x3e) = 0;\n    HAL_I2C_LindexstenCpltCallback(i2cData);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800316c": "process_i2_c_event_0800316c",
                "param_1": "i2cData",
                "iVar1": "dmaAbortResult",
                "puVar2": "nextCharPtr",
                "puVar3": "i2cEvent",
                "HAL_I2C_AbortCpltCallback": "handleI2CAbortComplete",
                "HAL_I2C_ErrorCallback": "handleI2CError",
                "HAL_DMA_Abort_IT": "abortDMAWithInterrupt",
                "i": "index",
                "LAB_080035fc_1": "label_080035fc_1"
            },
            "calling": [
                "HAL_I2C_ER_IRQHandler",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "HAL_DMA_Abort_IT",
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_AbortCpltCallback",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080032b4": {
            "entrypoint": "0x080032b4",
            "current_name": "process_data_080032b4",
            "code": "\nundefined4 processData_080032b4(uint **data)\n\n{\n  char charValue;\n  uint *pointer1;\n  uint *pointer2;\n  \n  charValue = *(char *)((int)data + 0x3d);\n  (*data)[1] = (*data)[1] & 0xfffff8ff;\n  **data = **data | 1;\n  **data = **data & 0xfffffbff;\n  pointer1 = *data;\n  if ((pointer1[1] & 0x800) != 0) {\n    if ((*(char *)((int)data + 0x3d) == '\\\"') || (*(char *)((int)data + 0x3d) == '*')) {\n      *(short *)((int)data + 0x2a) = (short)*(undefined4 *)(*data[0xe] + 4);\n    }\n    else {\n      *(short *)((int)data + 0x2a) = (short)*(undefined4 *)(*data[0xd] + 4);\n    }\n  }\n  if (*(short *)((int)data + 0x2a) != 0) {\n    if ((pointer1[5] & 4) != 0) {\n      pointer2 = data[9];\n      data[9] = (uint *)((int)pointer2 + 1);\n      *(char *)pointer2 = (char)pointer1[4];\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n    if (((*data)[5] & 0x40) != 0) {\n      pointer1 = data[9];\n      data[9] = (uint *)((int)pointer1 + 1);\n      *(char *)pointer1 = (char)(*data)[4];\n      *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n    }\n    data[0x10] = (uint *)((uint)data[0x10] | 4);\n  }\n  if (data[0x10] == (uint *)0x0) {\n    if (((charValue == '(') || (charValue == '*')) || (charValue == ')')) {\n      data[0xb] = (uint *)0xffff0000;\n      data[0xc] = (uint *)0x0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      *(undefined *)((int)data + 0x3e) = 0;\n      HAL_I2C_ListenCpltCallback();\n    }\n    else if ((data[0xc] == (uint *)0x22) || (charValue == '\\\"')) {\n      data[0xc] = (uint *)0x0;\n      *(undefined *)((int)data + 0x3d) = 0x20;\n      *(undefined *)((int)data + 0x3e) = 0;\n      HAL_I2C_SlaveRxCpltCallback();\n    }\n  }\n  else {\n    I2C_ITError();\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080032b4": "process_data_080032b4",
                "param_1": "data",
                "cVar1": "charValue",
                "puVar2": "pointer1",
                "puVar3": "pointer2"
            },
            "calling": [
                "HAL_I2C_EV_IRQHandler"
            ],
            "called": [
                "HAL_I2C_SlaveRxCpltCallback",
                "I2C_ITError",
                "HAL_I2C_ListenCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080033b8": {
            "entrypoint": "0x080033b8",
            "current_name": "handle_i2_c_operations_080033b8",
            "code": "\nvoid handleI2COperations_080033b8(int *i2cData)\n\n{\n  int address;\n  uint controlReg1;\n  uint controlReg2;\n  uint statusReg;\n  \n  address = *i2cData;\n  statusReg = *(uint *)(address + 0x18);\n  controlReg1 = *(uint *)(address + 0x14);\n  controlReg2 = *(uint *)(address + 4);\n  if ((*(char *)((int)i2cData + 0x3e) == '\\x10') || (*(char *)((int)i2cData + 0x3e) == '@')) {\n    if (((controlReg1 & 0x10001) == 0) || ((controlReg2 & 0x200) == 0)) {\n      if (((controlReg1 & 0x10008) == 0) || ((controlReg2 & 0x200) == 0)) {\n        if (((controlReg1 & 0x10002) != 0) && ((controlReg2 & 0x200) != 0)) {\n          handleI2CMasterAddress(i2cData);\n        }\n      }\n      else {\n        handleI2CMasterADD10(i2cData);\n      }\n    }\n    else {\n      handleI2CMasterSB(i2cData);\n    }\n    if ((statusReg & 0x100004) == 0) {\n      if ((((controlReg1 & 0x10040) != 0) && ((controlReg2 & 0x400) != 0)) && ((controlReg1 & 0x10004) == 0)) {\n        handleI2CMasterReceiveRXNE(i2cData);\n        return;\n      }\n      if (((controlReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        handleI2CMasterReceiveBTF(i2cData);\n        return;\n      }\n    }\n    else {\n      if ((((controlReg1 & 0x10080) != 0) && ((controlReg2 & 0x400) != 0)) && ((controlReg1 & 0x10004) == 0)) {\n        handleI2CMasterTransmitTXE(i2cData);\n        return;\n      }\n      if (((controlReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        handleI2CMasterTransmitBTF(i2cData);\n        return;\n      }\n    }\n  }\n  else {\n    if (((controlReg1 & 0x10002) != 0) && ((controlReg2 & 0x200) != 0)) {\n      handleI2CSlaveAddress();\n      return;\n    }\n    if (((controlReg1 & 0x10010) != 0) && ((controlReg2 & 0x200) != 0)) {\n      handleI2CSlaveSTOPF(i2cData);\n      return;\n    }\n    if ((statusReg & 0x100004) == 0) {\n      if ((((controlReg1 & 0x10040) != 0) && ((controlReg2 & 0x400) != 0)) && ((controlReg1 & 0x10004) == 0)) {\n        handleI2CSlaveReceiveRXNE(i2cData);\n        return;\n      }\n      if (((controlReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        handleI2CSlaveReceiveBTF(i2cData);\n      }\n    }\n    else {\n      if ((((controlReg1 & 0x10080) != 0) && ((controlReg2 & 0x400) != 0)) && ((controlReg1 & 0x10004) == 0)) {\n        handleI2CSlaveTransmitTXE(i2cData);\n        return;\n      }\n      if (((controlReg1 & 0x10004) != 0) && ((controlReg2 & 0x200) != 0)) {\n        handleI2CSlaveTransmitBTF(i2cData);\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080033b8": "handle_i2_c_operations_080033b8",
                "param_1": "i2cData",
                "iVar1": "address",
                "uVar2": "controlReg1",
                "uVar3": "controlReg2",
                "uVar4": "statusReg",
                "I2C_Master_ADDR": "handleI2CMasterAddress",
                "I2C_Master_ADD10": "handleI2CMasterADD10",
                "I2C_Master_SB": "handleI2CMasterSB",
                "I2C_MasterReceive_RXNE": "handleI2CMasterReceiveRXNE",
                "I2C_MasterReceive_BTF": "handleI2CMasterReceiveBTF",
                "I2C_MasterTransmit_TXE": "handleI2CMasterTransmitTXE",
                "I2C_MasterTransmit_BTF": "handleI2CMasterTransmitBTF",
                "I2C_Slave_ADDR": "handleI2CSlaveAddress",
                "I2C_Slave_STOPF": "handleI2CSlaveSTOPF",
                "I2C_SlaveReceive_RXNE": "handleI2CSlaveReceiveRXNE",
                "I2C_SlaveReceive_BTF": "handleI2CSlaveReceiveBTF",
                "I2C_SlaveTransmit_TXE": "handleI2CSlaveTransmitTXE",
                "I2C_SlaveTransmit_BTF": "handleI2CSlaveTransmitBTF"
            },
            "calling": [],
            "called": [
                "I2C_MasterReceive_RXNE",
                "I2C_Master_SB",
                "I2C_SlaveReceive_BTF",
                "I2C_Master_ADD10",
                "I2C_SlaveReceive_RXNE",
                "I2C_Master_ADDR",
                "I2C_MasterTransmit_BTF",
                "I2C_MasterTransmit_TXE",
                "I2C_SlaveTransmit_TXE",
                "I2C_Slave_ADDR",
                "I2C_SlaveTransmit_BTF",
                "I2C_MasterReceive_BTF",
                "I2C_Slave_STOPF"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003520": {
            "entrypoint": "0x08003520",
            "current_name": "update_i2_c_status_08003520",
            "code": "\nvoid updateI2CStatus_08003520(uint **ptr_param)\n\n{\n  char charVar1;\n  uint *ptr_puVar;\n  uint var3;\n  uint var4;\n  \n  ptr_puVar = *ptr_param;\n  var3 = ptr_puVar[5];\n  var4 = ptr_puVar[1];\n  if (((var3 & 0x10100) != 0) && ((var4 & 0x100) != 0)) {\n    ptr_param[0x10] = (uint *)((uint)ptr_param[0x10] | 1);\n    ptr_puVar[5] = 0xfffffeff;\n    **ptr_param = **ptr_param | 0x8000;\n  }\n  if (((var3 & 0x10200) != 0) && ((var4 & 0x100) != 0)) {\n    ptr_param[0x10] = (uint *)((uint)ptr_param[0x10] | 2);\n    (*ptr_param)[5] = 0xfffffdff;\n  }\n  if (((var3 & 0x10400) != 0) && ((var4 & 0x100) != 0)) {\n    charVar1 = *(char *)((int)ptr_param + 0x3d);\n    if (((*(char *)((int)ptr_param + 0x3e) == ' ') && (*(short *)((int)ptr_param + 0x2a) == 0)) &&\n       (((charVar1 == '!' || (charVar1 == ')')) || ((charVar1 == '(' && (ptr_param[0xc] == (uint *)0x21)))))) {\n      I2C_Slave_AF(ptr_param);\n    }\n    else {\n      ptr_param[0x10] = (uint *)((uint)ptr_param[0x10] | 4);\n      if (*(char *)((int)ptr_param + 0x3e) == '\\x10') {\n        **ptr_param = **ptr_param | 0x200;\n      }\n      (*ptr_param)[5] = 0xfffffbff;\n    }\n  }\n  if (((var3 & 0x10800) != 0) && ((var4 & 0x100) != 0)) {\n    ptr_param[0x10] = (uint *)((uint)ptr_param[0x10] | 8);\n    (*ptr_param)[5] = 0xfffff7ff;\n  }\n  if (ptr_param[0x10] != (uint *)0x0) {\n    I2C_ITError(ptr_param);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003520": "update_i2_c_status_08003520",
                "param_1": "ptr_param",
                "cVar1": "charVar1",
                "puVar2": "ptr_puVar",
                "uVar3": "var3",
                "uVar4": "var4"
            },
            "calling": [],
            "called": [
                "I2C_Slave_AF",
                "I2C_ITError"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800365c": {
            "entrypoint": "0x0800365c",
            "current_name": "calculate_iterations_0800365c",
            "code": "\nvoid calculateIterations_0800365c(int inputValue)\n\n{\n  bool isNotZero;\n  int calculatedIterations;\n  \n  calculatedIterations = inputValue * (DAT_20000084 / 8000);\n  do {\n    isNotZero = calculatedIterations != 0;\n    calculatedIterations = calculatedIterations + -1;\n  } while (isNotZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800365c": "calculate_iterations_0800365c",
                "param_1": "inputValue",
                "local_4": "calculatedIterations",
                "bVar1": "isNotZero"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003688": {
            "entrypoint": "0x08003688",
            "current_name": "initialize_communication_08003688",
            "code": "\n\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nundefined4 initializeCommunication_08003688(uint *communicationFlags)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 result;\n  uint paramValue;\n  bool isConditionTrue;\n  \n  if ((*communicationFlags & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) != 0)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (communicationFlags[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      paramValue = communicationFlags[1];\n      if (paramValue == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (paramValue == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (paramValue == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (communicationFlags[1] == 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTime = HAL_GetTick();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTime = HAL_GetTick();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*communicationFlags & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (communicationFlags[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | communicationFlags[5] << 3;\n    }\n    else if (communicationFlags[4] == 0) {\n      _DAT_42420000 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = _DAT_40021000 & 0xffffff07 | communicationFlags[5] << 3;\n    }\n  }\n  if ((*communicationFlags & 8) != 0) {\n    if (communicationFlags[6] == 0) {\n      _DAT_42420480 = 0;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTime = HAL_GetTick();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      RCC_Delay(1);\n    }\n  }\n  if ((*communicationFlags & 4) != 0) {\n    isConditionTrue = (_DAT_4002101c & 0x10000000) == 0;\n    if (isConditionTrue) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    paramValue = communicationFlags[3];\n    if (paramValue == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (paramValue == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (paramValue == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (communicationFlags[3] == 0) {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startTime = HAL_GetTick();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (isConditionTrue) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (communicationFlags[7] == 0) {\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (communicationFlags[7] == 2) {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (communicationFlags[8] == 0x10000) {\n          _DAT_40021004 = _DAT_40021004 & 0xfffdffff | communicationFlags[2];\n        }\n        _DAT_40021004 = _DAT_40021004 & 0xffc2ffff | communicationFlags[8] | communicationFlags[9];\n        _DAT_42420060 = 1;\n        startTime = HAL_GetTick();\n        do {\n          if ((_DAT_40021000 & 0x2000000) != 0) {\n            return 0;\n          }\n          currentTime = HAL_GetTick();\n        } while ((uint)(currentTime - startTime) < 3);\n        return 3;\n      }\n      currentTime = HAL_GetTick();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTime = HAL_GetTick();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        return 0;\n      }\n      currentTime = HAL_GetTick();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003688": "initialize_communication_08003688",
                "param_1": "communicationFlags",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "result",
                "uVar4": "paramValue",
                "bVar5": "isConditionTrue"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a68": {
            "entrypoint": "0x08003a68",
            "current_name": "calculate_delay_08003a68",
            "code": "\n\n\nuint calculateDelay_08003a68(void)\n\n{\n  uint delay;\n  undefined2 constant5;\n  undefined4 constant4;\n  undefined4 constant3;\n  undefined4 constant2;\n  undefined4 constant1;\n  \n  constant1 = 0x10100f0e;\n  constant2 = 0xd0c0b0a;\n  constant3 = 0x9080706;\n  constant4 = 0x5040302;\n  constant5 = 0x201;\n  if ((_DAT_40021004 & 0xc) == 8) {\n    delay = (uint)*(byte *)((int)&constant4 + ((_DAT_40021004 << 10) >> 0x1c));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      delay = delay * 4000000;\n    }\n    else {\n      delay = (delay * 8000000) /\n              (uint)*(byte *)((int)&constant5 - ((int)(_DAT_40021004 << 0xe) >> 0x1f));\n    }\n  }\n  else {\n    delay = 8000000;\n  }\n  return delay;\n}\n\n",
            "renaming": {
                "FUN_08003a68": "calculate_delay_08003a68",
                "uStack_c": "constant1",
                "uStack_10": "constant2",
                "uStack_14": "constant3",
                "uStack_18": "constant4",
                "local_1c": "constant5",
                "uVar1": "delay"
            },
            "calling": [
                "FUN_08003afa"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ad4": {
            "entrypoint": "0x08003ad4",
            "current_name": "init_and_set_clock_08003ad4",
            "code": "\n\n\nundefined4 initAndSetClock_08003ad4(uint *configParams,uint configSize)\n\n{\n  int startTime;\n  int currentTime;\n  uint systemClockFreq;\n  \n  if ((_DAT_40022000 & 7) < configSize) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | configSize;\n    if (configSize != (configSize & 7)) {\n      return 1;\n    }\n  }\n  if ((*configParams & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | configParams[2];\n  }\n  if ((*configParams & 1) != 0) {\n    systemClockFreq = configParams[1];\n    if (systemClockFreq == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return 1;\n      }\n    }\n    else if ((systemClockFreq != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return 1;\n    }\n    _DAT_40021004 = systemClockFreq | _DAT_40021004 & 0xfffffffc;\n    startTime = HAL_GetTick();\n    if (configParams[1] == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else if (configParams[1] == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        currentTime = HAL_GetTick();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n  }\n  if (configSize < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | configSize;\n    if (configSize != (configSize & 7)) {\n      return 1;\n    }\n  }\n  if ((*configParams & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | configParams[3];\n  }\n  if ((*configParams & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | configParams[4] << 3;\n  }\n  systemClockFreq = HAL_RCC_GetSysClockFreq();\n  DAT_20000084 = systemClockFreq >> (&DAT_0800772c)[(_DAT_40021004 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003ad4": "init_and_set_clock_08003ad4",
                "param_1": "configParams",
                "param_2": "configSize",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "systemClockFreq"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "FUN_08003afa"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003afa": {
            "entrypoint": "0x08003afa",
            "current_name": "initialize_hardware_08003afa",
            "code": "\n\n\nundefined4 initializeHardware_08003afa(uint *settings,uint numSettings)\n\n{\n  int startTime;\n  int currentTime;\n  uint clockFreq;\n  \n  if ((*settings & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffff0f | settings[2];\n  }\n  if ((*settings & 1) != 0) {\n    clockFreq = settings[1];\n    if (clockFreq == 1) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        return 1;\n      }\n    }\n    else if ((clockFreq != 2) && ((_DAT_40021000 & 2) == 0)) {\n      return 1;\n    }\n    _DAT_40021004 = clockFreq | _DAT_40021004 & 0xfffffffc;\n    startTime = getCurrentTime();\n    if (settings[1] == 1) {\n      while ((_DAT_40021004 & 0xc) != 4) {\n        currentTime = getCurrentTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else if (settings[1] == 2) {\n      while ((_DAT_40021004 & 0xc) != 8) {\n        currentTime = getCurrentTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      while ((_DAT_40021004 & 0xc) != 0) {\n        currentTime = getCurrentTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n  }\n  if (numSettings < (_DAT_40022000 & 7)) {\n    _DAT_40022000 = _DAT_40022000 & 0xfffffff8 | numSettings;\n    if (numSettings != (numSettings & 7)) {\n      return 1;\n    }\n  }\n  if ((*settings & 4) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xfffff8ff | settings[3];\n  }\n  if ((*settings & 8) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffffc7ff | settings[4] << 3;\n  }\n  clockFreq = getSystemClockFrequency();\n  DAT_20000084 = clockFreq >> (&DAT_0800772c)[(_DAT_40021004 << 0x18) >> 0x1c];\n  HAL_InitTick(0xf);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003afa": "initialize_hardware_08003afa",
                "param_1": "settings",
                "param_2": "numSettings",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "clockFreq",
                "HAL_GetTick": "getCurrentTime",
                "HAL_RCC_GetSysClockFreq": "getSystemClockFrequency"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [
                "HAL_GetTick",
                "HAL_InitTick",
                "HAL_RCC_GetSysClockFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c44": {
            "entrypoint": "0x08003c44",
            "current_name": "get_global_variable_08003c44",
            "code": "\nundefined4 getGlobalVariable_08003c44(void)\n\n{\n  return DAT_20000084;\n}\n\n",
            "renaming": {
                "FUN_08003c44": "get_global_variable_08003c44"
            },
            "calling": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c50": {
            "entrypoint": "0x08003c50",
            "current_name": "get_adjusted_hclk_freq_08003c50",
            "code": "\n\n\nuint getAdjustedHCLKFreq_08003c50(void)\n\n{\n  uint adjustedFreq;\n  \n  adjustedFreq = getHCLKFreq();\n  return adjustedFreq >> (&DAT_0800773c)[(uint)(_DAT_40021004 << 0x15) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c50": "get_adjusted_hclk_freq_08003c50",
                "uVar1": "adjustedFreq",
                "HAL_RCC_GetHCLKFreq": "getHCLKFreq"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c70": {
            "entrypoint": "0x08003c70",
            "current_name": "get_hclk_frequency_08003c70",
            "code": "\n\n\nuint get_HCLK_frequency_08003c70(void)\n\n{\n  uint hclk_frequency;\n  \n  hclk_frequency = HAL_RCC_GetHCLKFreq();\n  return hclk_frequency >> (&DAT_0800773c)[(uint)(_DAT_40021004 << 0x12) >> 0x1d];\n}\n\n",
            "renaming": {
                "FUN_08003c70": "get_hclk_frequency_08003c70",
                "uVar1": "hclk_frequency"
            },
            "calling": [
                "UART_SetConfig",
                "HAL_RCCEx_GetPeriphCLKFreq"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c90": {
            "entrypoint": "0x08003c90",
            "current_name": "initialize_hardware_08003c90",
            "code": "\n\n\nundefined4 initializeHardware_08003c90(uint *hardwareSettings)\n\n{\n  uint tempVar1;\n  uint tempVar2;\n  int startTime;\n  int currentTime;\n  bool isBitSet;\n  \n  if ((*hardwareSettings & 1) != 0) {\n    isBitSet = (_DAT_4002101c & 0x10000000) == 0;\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = HAL_GetTick();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = HAL_GetTick();\n        if (100 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (((_DAT_40021020 & 0x300) != 0) && ((_DAT_40021020 & 0x300) != (hardwareSettings[1] & 0x300))) {\n      tempVar2 = _DAT_40021020 & 0xfffffcff;\n      _DAT_42420440 = 0;\n      tempVar1 = _DAT_40021020 & 1;\n      _DAT_40021020 = tempVar2;\n      if (tempVar1 != 0) {\n        startTime = HAL_GetTick();\n        while ((_DAT_40021020 & 2) == 0) {\n          currentTime = HAL_GetTick();\n          if (5000 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n    _DAT_40021020 = _DAT_40021020 & 0xfffffcff | hardwareSettings[1];\n    if (isBitSet) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if ((*hardwareSettings & 2) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffff3fff | hardwareSettings[2];\n  }\n  if ((*hardwareSettings & 0x10) != 0) {\n    _DAT_40021004 = _DAT_40021004 & 0xffbfffff | hardwareSettings[3];\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08003c90": "initialize_hardware_08003c90",
                "param_1": "hardwareSettings",
                "uVar1": "tempVar1",
                "uVar2": "tempVar2",
                "iVar3": "startTime",
                "iVar4": "currentTime",
                "bVar5": "isBitSet"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003da4": {
            "entrypoint": "0x08003da4",
            "current_name": "get_clock_frequency_08003da4",
            "code": "\n\n\nuint getClockFrequency_08003da4(int inputValue)\n\n{\n  uint frequency;\n  undefined2 constantValue;\n  undefined4 multiplier;\n  undefined4 divider;\n  undefined4 condition1;\n  undefined4 condition2;\n  \n  condition2 = 0x10100f0e;\n  condition1 = 0xd0c0b0a;\n  divider = 0x9080706;\n  multiplier = 0x5040302;\n  constantValue = 0x201;\n  if (inputValue == 2) {\n    frequency = HAL_RCC_GetPCLK2Freq();\n    frequency = frequency / ((((_DAT_40021004 << 0x10) >> 0x1e) + 1) * 2);\n  }\n  else if (inputValue == 0x10) {\n    if ((_DAT_40021000 & 0x1000000) == 0) {\n      frequency = 0;\n    }\n    else {\n      if ((_DAT_40021004 & 0x10000) == 0) {\n        frequency = 4000000;\n      }\n      else {\n        frequency = 8000000 / *(byte *)((int)&constantValue - ((int)(_DAT_40021004 << 0xe) >> 0x1f));\n      }\n      frequency = frequency * *(byte *)((int)&multiplier + ((_DAT_40021004 << 10) >> 0x1c));\n      if ((_DAT_40021004 & 0x400000) == 0) {\n        frequency = (frequency * 2) / 3;\n      }\n    }\n  }\n  else if (inputValue == 1) {\n    if ((_DAT_40021020 & 0x302) == 0x102) {\n      frequency = 0x8000;\n    }\n    else if (((_DAT_40021020 & 0x300) == 0x200) && ((_DAT_40021024 & 2) != 0)) {\n      frequency = 32000;\n    }\n    else if ((_DAT_40021020 & 0x300) == 0x300) {\n      if ((_DAT_40021000 & 0x20000) == 0) {\n        frequency = 0;\n      }\n      else {\n        frequency = 0xf424;\n      }\n    }\n    else {\n      frequency = 0;\n    }\n  }\n  else {\n    frequency = 0;\n  }\n  return frequency;\n}\n\n",
            "renaming": {
                "FUN_08003da4": "get_clock_frequency_08003da4",
                "param_1": "inputValue",
                "uVar1": "frequency",
                "local_24": "constantValue",
                "uStack_20": "multiplier",
                "uStack_1c": "divider",
                "uStack_18": "condition1",
                "uStack_14": "condition2"
            },
            "calling": [
                "HAL_ADC_PollForConversion",
                "HAL_ADCEx_Calibration_Start"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ea0": {
            "entrypoint": "0x08003ea0",
            "current_name": "handle_alarm_event_08003ea0",
            "code": "\n\n\nvoid handleAlarmEvent_08003ea0(uint **alarmData)\n\n{\n  if (((**alarmData & 2) != 0) && (((*alarmData)[1] & 2) != 0)) {\n    handleAlarmACallback();\n    (*alarmData)[1] = 0xfffffffd;\n  }\n  _DAT_40010414 = 0x20000;\n  *(undefined *)((int)alarmData + 0x11) = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ea0": "handle_alarm_event_08003ea0",
                "param_1": "alarmData",
                "HAL_RTC_AlarmAEventCallback": "handleAlarmACallback"
            },
            "calling": [],
            "called": [
                "HAL_RTC_AlarmAEventCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ed8": {
            "entrypoint": "0x08003ed8",
            "current_name": "deinit_pwm_timer_08003ed8",
            "code": "\nvoid deinit_pwm_timer_08003ed8(uint **timer_info)\n\n{\n  uint *timer_data;\n  \n  *(undefined *)((int)timer_info + 0x3d) = 2;\n  timer_data = *timer_info;\n  if ((timer_data[8] & 0x1111) == 0) {\n    if ((timer_data[8] & 0x444) == 0) {\n      *timer_data = *timer_data & 0xfffffffe;\n    }\n  }\n  deinit_specific_pwm(timer_info);\n  *(undefined *)((int)timer_info + 0x3d) = 0;\n  *(undefined *)(timer_info + 0xf) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ed8": "deinit_pwm_timer_08003ed8",
                "param_1": "timer_info",
                "puVar1": "timer_data",
                "HAL_TIM_PWM_MspDeInit": "deinit_specific_pwm"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f12": {
            "entrypoint": "0x08003f12",
            "current_name": "FUNC_08003f12",
            "code": "\nvoid FUNC_08003f12(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f12": "FUNC_08003f12"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f14": {
            "entrypoint": "0x08003f14",
            "current_name": "FUNC_08003f14",
            "code": "\nvoid FUNC_08003f14(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f14": "FUNC_08003f14"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f16": {
            "entrypoint": "0x08003f16",
            "current_name": "FUNC_08003f16",
            "code": "\nvoid FUNC_08003f16(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f16": "FUNC_08003f16"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "handle_timers_callback_08003f18",
            "code": "\nvoid handle_timers_callback_08003f18(int *timer_handles)\n\n{\n  int current_timer;\n  \n  current_timer = *timer_handles;\n  if (((*(uint *)(current_timer + 0x10) & 2) != 0) && ((*(uint *)(current_timer + 0xc) & 2) != 0)) {\n    *(undefined4 *)(current_timer + 0x10) = 0xfffffffd;\n    *(undefined *)(timer_handles + 7) = 1;\n    if ((*(uint *)(*timer_handles + 0x18) & 3) == 0) {\n      handle_oc_delay_elapsed_callback();\n      handle_pwm_pulse_finished_callback(timer_handles);\n    }\n    else {\n      handle_ic_capture_callback();\n    }\n    *(undefined *)(timer_handles + 7) = 0;\n  }\n  current_timer = *timer_handles;\n  if (((*(uint *)(current_timer + 0x10) & 4) != 0) && ((*(uint *)(current_timer + 0xc) & 4) != 0)) {\n    *(undefined4 *)(current_timer + 0x10) = 0xfffffffb;\n    *(undefined *)(timer_handles + 7) = 2;\n    if ((*(uint *)(*timer_handles + 0x18) & 0x300) == 0) {\n      handle_oc_delay_elapsed_callback(timer_handles);\n      handle_pwm_pulse_finished_callback(timer_handles);\n    }\n    else {\n      handle_ic_capture_callback(timer_handles);\n    }\n    *(undefined *)(timer_handles + 7) = 0;\n  }\n  current_timer = *timer_handles;\n  if (((*(uint *)(current_timer + 0x10) & 8) != 0) && ((*(uint *)(current_timer + 0xc) & 8) != 0)) {\n    *(undefined4 *)(current_timer + 0x10) = 0xfffffff7;\n    *(undefined *)(timer_handles + 7) = 4;\n    if ((*(uint *)(*timer_handles + 0x1c) & 3) == 0) {\n      handle_oc_delay_elapsed_callback(timer_handles);\n      handle_pwm_pulse_finished_callback(timer_handles);\n    }\n    else {\n      handle_ic_capture_callback(timer_handles);\n    }\n    *(undefined *)(timer_handles + 7) = 0;\n  }\n  current_timer = *timer_handles;\n  if (((*(uint *)(current_timer + 0x10) & 0x10) != 0) && ((*(uint *)(current_timer + 0xc) & 0x10) != 0)) {\n    *(undefined4 *)(current_timer + 0x10) = 0xffffffef;\n    *(undefined *)(timer_handles + 7) = 8;\n    if ((*(uint *)(*timer_handles + 0x1c) & 0x300) == 0) {\n      handle_oc_delay_elapsed_callback(timer_handles);\n      handle_pwm_pulse_finished_callback(timer_handles);\n    }\n    else {\n      handle_ic_capture_callback(timer_handles);\n    }\n    *(undefined *)(timer_handles + 7) = 0;\n  }\n  current_timer = *timer_handles;\n  if (((*(uint *)(current_timer + 0x10) & 1) != 0) && ((*(uint *)(current_timer + 0xc) & 1) != 0)) {\n    *(undefined4 *)(current_timer + 0x10) = 0xfffffffe;\n    handle_period_elapsed_callback(timer_handles);\n  }\n  current_timer = *timer_handles;\n  if (((*(uint *)(current_timer + 0x10) & 0x80) != 0) && ((*(uint *)(current_timer + 0xc) & 0x80) != 0)) {\n    *(undefined4 *)(current_timer + 0x10) = 0xffffff7f;\n    handle_break_callback(timer_handles);\n  }\n  current_timer = *timer_handles;\n  if (((*(uint *)(current_timer + 0x10) & 0x40) != 0) && ((*(uint *)(current_timer + 0xc) & 0x40) != 0)) {\n    *(undefined4 *)(current_timer + 0x10) = 0xffffffbf;\n    handle_trigger_callback(timer_handles);\n  }\n  current_timer = *timer_handles;\n  if (((*(uint *)(current_timer + 0x10) & 0x20) != 0) && ((*(uint *)(current_timer + 0xc) & 0x20) != 0)) {\n    *(undefined4 *)(current_timer + 0x10) = 0xffffffdf;\n    handle_commutation_callback(timer_handles);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "handle_timers_callback_08003f18",
                "param_1": "timer_handles",
                "iVar1": "current_timer",
                "HAL_TIM_OC_DelayElapsedCallback": "handle_oc_delay_elapsed_callback",
                "HAL_TIM_PWM_PulseFinishedCallback": "handle_pwm_pulse_finished_callback",
                "HAL_TIM_IC_CaptureCallback": "handle_ic_capture_callback",
                "HAL_TIM_PeriodElapsedCallback": "handle_period_elapsed_callback",
                "HAL_TIMEx_BreakCallback": "handle_break_callback",
                "HAL_TIM_TriggerCallback": "handle_trigger_callback",
                "HAL_TIMEx_CommutationCallback": "handle_commutation_callback"
            },
            "calling": [
                "TIM1_UP_IRQHandler"
            ],
            "called": [
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_PWM_PulseFinishedCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_CommutationCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004092": {
            "entrypoint": "0x08004092",
            "current_name": "update_bitwise_value_08004092",
            "code": "\nvoid updateBitwiseValue_08004092(int baseAddress,uint bitPosition,int bitValue)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | bitValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004092": "update_bitwise_value_08004092",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "bitValue"
            },
            "calling": [
                "HAL_TIM_PWM_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040b0": {
            "entrypoint": "0x080040b0",
            "current_name": "initialize_timer_080040b0",
            "code": "\nundefined4 initializeTimer_080040b0(uint **timerPointer,undefined4 channelValue)\n\n{\n  uint *timerDataPointer;\n  \n  TIM_CCxChannelCmd(*timerPointer,channelValue,0);\n  if (((*timerPointer == (uint *)0x40012c00) && ((TIMER_SETTINGS & 0x1111) == 0)) &&\n     ((TIMER_SETTINGS & 0x444) == 0)) {\n    TIMER_FLAG = TIMER_FLAG & 0xffff7fff;\n  }\n  timerDataPointer = *timerPointer;\n  if (((timerDataPointer[8] & 0x1111) == 0) && ((timerDataPointer[8] & 0x444) == 0)) {\n    *timerDataPointer = *timerDataPointer & 0xfffffffe;\n  }\n  *(undefined *)((int)timerPointer + 0x3d) = 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080040b0": "initialize_timer_080040b0",
                "param_1": "timerPointer",
                "param_2": "channelValue",
                "puVar1": "timerDataPointer",
                "uRam40012c20": "TIMER_SETTINGS",
                "uRam40012c44": "TIMER_FLAG"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004110": {
            "entrypoint": "0x08004110",
            "current_name": "update_bitwise_value_08004110",
            "code": "\nvoid updateBitwiseValue_08004110(int memoryAddress,uint bitPosition,int newValue)\n\n{\n  *(uint *)(memoryAddress + 0x20) = *(uint *)(memoryAddress + 0x20) & ~(4 << (bitPosition & 0xff));\n  *(uint *)(memoryAddress + 0x20) = *(uint *)(memoryAddress + 0x20) | newValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004110": "update_bitwise_value_08004110",
                "param_1": "memoryAddress",
                "param_2": "bitPosition",
                "param_3": "newValue"
            },
            "calling": [
                "HAL_TIMEx_PWMN_Stop"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800412c": {
            "entrypoint": "0x0800412c",
            "current_name": "disable_timer_interrupt_0800412c",
            "code": "\nundefined4 disableTimerInterrupt_0800412c(uint **timerConfig,undefined4 channel)\n\n{\n  uint *timerPtr;\n  \n  TIM_CCxNChannelCmd(*timerConfig,channel,0);\n  timerPtr = *timerConfig;\n  if (((timerPtr[8] & 0x1111) == 0) && ((timerPtr[8] & 0x444) == 0)) {\n    timerPtr[0x11] = timerPtr[0x11] & 0xffff7fff;\n  }\n  timerPtr = *timerConfig;\n  if (((timerPtr[8] & 0x1111) == 0) && ((timerPtr[8] & 0x444) == 0)) {\n    *timerPtr = *timerPtr & 0xfffffffe;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800412c": "disable_timer_interrupt_0800412c",
                "param_1": "timerConfig",
                "param_2": "channel",
                "puVar1": "timerPtr"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "TIM_CCxNChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004178": {
            "entrypoint": "0x08004178",
            "current_name": "FUNC_08004178",
            "code": "\nvoid FUNC_08004178(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004178": "FUNC_08004178"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417a": {
            "entrypoint": "0x0800417a",
            "current_name": "FUNC_0800417a",
            "code": "\nvoid FUNC_0800417a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417a": "FUNC_0800417a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800417c": {
            "entrypoint": "0x0800417c",
            "current_name": "clear_flags_0800417c",
            "code": "\nvoid clearFlags_0800417c(int *ptr)\n\n{\n  *(uint *)(*ptr + 0xc) = *(uint *)(*ptr + 0xc) & 0xfffffedf;\n  *(uint *)(*ptr + 0x14) = *(uint *)(*ptr + 0x14) & 0xfffffffe;\n  *(undefined *)((int)ptr + 0x3a) = 0x20;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800417c": "clear_flags_0800417c",
                "param_1": "ptr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004198": {
            "entrypoint": "0x08004198",
            "current_name": "process_data_08004198",
            "code": "\nundefined4 processData_08004198(int *data)\n\n{\n  short count;\n  byte *bytePtr;\n  \n  if (*(char *)((int)data + 0x39) != '!') {\n    return 2;\n  }\n  if (data[2] == 0x1000) {\n    *(uint *)(*data + 4) = *(ushort *)data[8] & 0x1ff;\n    if (data[4] == 0) {\n      data[8] = data[8] + 2;\n    }\n    else {\n      data[8] = data[8] + 1;\n    }\n  }\n  else {\n    bytePtr = (byte *)data[8];\n    data[8] = (int)(bytePtr + 1);\n    *(uint *)(*data + 4) = (uint)*bytePtr;\n  }\n  count = *(short *)((int)data + 0x26) + -1;\n  *(short *)((int)data + 0x26) = count;\n  if (count == 0) {\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) & 0xffffff7f;\n    *(uint *)(*data + 0xc) = *(uint *)(*data + 0xc) | 0x40;\n    return 0;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004198": "process_data_08004198",
                "param_1": "data",
                "sVar1": "count",
                "pbVar2": "bytePtr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004204": {
            "entrypoint": "0x08004204",
            "current_name": "calculate_clock_config_08004204",
            "code": "\nvoid calculateClockConfig_08004204(int *clockConfigParams)\n\n{\n  int pclk1Freq1;\n  int pclk1Freq2;\n  int pclk1Freq3;\n  int pclk1Freq4;\n  int pclk1Freq5;\n  int pclk1Freq6;\n  int pclk1Freq7;\n  int pclk1Freq8;\n  int pclk1Freq9;\n  int currentClock;\n  \n  *(uint *)(*clockConfigParams + 0x10) = *(uint *)(*clockConfigParams + 0x10) & 0xffffcfff | clockConfigParams[3];\n  *(uint *)(*clockConfigParams + 0xc) =\n       clockConfigParams[2] | clockConfigParams[4] | clockConfigParams[5] | *(uint *)(*clockConfigParams + 0xc) & 0xffffe9f3;\n  *(uint *)(*clockConfigParams + 0x14) = *(uint *)(*clockConfigParams + 0x14) & 0xfffffcff | clockConfigParams[6];\n  currentClock = *clockConfigParams;\n  if (currentClock != 0x40013800) {\n    pclk1Freq1 = HAL_RCC_GetPCLK1Freq();\n    pclk1Freq6 = clockConfigParams[1];\n    pclk1Freq2 = HAL_RCC_GetPCLK1Freq();\n    pclk1Freq7 = clockConfigParams[1];\n    pclk1Freq3 = HAL_RCC_GetPCLK1Freq();\n    pclk1Freq8 = clockConfigParams[1];\n    pclk1Freq4 = HAL_RCC_GetPCLK1Freq();\n    pclk1Freq9 = clockConfigParams[1];\n    pclk1Freq5 = HAL_RCC_GetPCLK1Freq();\n    *(uint *)(currentClock + 8) =\n         ((uint)((int)((ulonglong)\n                       (((uint)(pclk1Freq4 * 0x19) / (uint)(pclk1Freq9 << 2) +\n                        (int)(((ulonglong)(uint)(pclk1Freq5 * 0x19) / (ulonglong)(uint)(clockConfigParams[1] << 2))\n                             / 100) * -100) * 0x10 + 0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n         ((((uint)(pclk1Freq2 * 0x19) / (uint)(pclk1Freq7 << 2) +\n           (int)(((ulonglong)(uint)(pclk1Freq3 * 0x19) / (ulonglong)(uint)(pclk1Freq8 << 2)) / 100) * -100) *\n           0x10 + 0x32) / 100 & 0xf0) +\n         (int)(((ulonglong)(uint)(pclk1Freq1 * 0x19) / (ulonglong)(uint)(pclk1Freq6 << 2)) / 100) * 0x10;\n    return;\n  }\n  currentClock = HAL_RCC_GetPCLK2Freq();\n  pclk1Freq5 = clockConfigParams[1];\n  pclk1Freq1 = HAL_RCC_GetPCLK2Freq();\n  pclk1Freq6 = clockConfigParams[1];\n  pclk1Freq2 = HAL_RCC_GetPCLK2Freq();\n  pclk1Freq7 = clockConfigParams[1];\n  pclk1Freq3 = HAL_RCC_GetPCLK2Freq();\n  pclk1Freq8 = clockConfigParams[1];\n  pclk1Freq4 = HAL_RCC_GetPCLK2Freq();\n  newClockConfig = ((uint)((int)((ulonglong)\n                               (((uint)(pclk1Freq3 * 0x19) / (uint)(pclk1Freq8 << 2) +\n                                (int)(((ulonglong)(uint)(pclk1Freq4 * 0x19) /\n                                      (ulonglong)(uint)(clockConfigParams[1] << 2)) / 100) * -100) * 0x10 +\n                               0x32) * 0x51eb851f >> 0x20) << 0x17) >> 0x1c) +\n                 ((((uint)(pclk1Freq1 * 0x19) / (uint)(pclk1Freq6 << 2) +\n                   (int)(((ulonglong)(uint)(pclk1Freq2 * 0x19) / (ulonglong)(uint)(pclk1Freq7 << 2)) / 100) *\n                   -100) * 0x10 + 0x32) / 100 & 0xf0) +\n                 (int)(((ulonglong)(uint)(currentClock * 0x19) / (ulonglong)(uint)(pclk1Freq5 << 2)) / 100) *\n                 0x10;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004204": "calculate_clock_config_08004204",
                "param_1": "clockConfigParams",
                "iVar1": "pclk1Freq1",
                "iVar2": "pclk1Freq2",
                "iVar3": "pclk1Freq3",
                "iVar4": "pclk1Freq4",
                "iVar5": "pclk1Freq5",
                "iVar6": "pclk1Freq6",
                "iVar7": "pclk1Freq7",
                "iVar8": "pclk1Freq8",
                "iVar9": "pclk1Freq9",
                "iVar10": "currentClock",
                "iRam40013808": "newClockConfig"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK1Freq",
                "HAL_RCC_GetPCLK2Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080043b4": {
            "entrypoint": "0x080043b4",
            "current_name": "check_condition_080043b4",
            "code": "\nundefined4 check_condition_080043b4(uint **pointer_array,uint value_1,uint expected_condition,int initial_time,uint timeout)\n\n{\n  int current_time;\n  \n  do {\n    if (((value_1 & ~**pointer_array) == 0) != expected_condition) {\n      return 0;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (current_time = HAL_GetTick(), (uint)(current_time - initial_time) <= timeout))));\n  (*pointer_array)[3] = (*pointer_array)[3] & 0xfffffe5f;\n  (*pointer_array)[5] = (*pointer_array)[5] & 0xfffffffe;\n  *(undefined *)((int)pointer_array + 0x39) = 0x20;\n  *(undefined *)((int)pointer_array + 0x3a) = 0x20;\n  *(undefined *)(pointer_array + 0xe) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_080043b4": "check_condition_080043b4",
                "param_1": "pointer_array",
                "param_2": "value_1",
                "param_3": "expected_condition",
                "param_4": "initial_time",
                "param_5": "timeout",
                "iVar1": "current_time"
            },
            "calling": [
                "HAL_UART_Transmit"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004418": {
            "entrypoint": "0x08004418",
            "current_name": "FUNC_08004418",
            "code": "\nvoid FUNC_08004418(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004418": "FUNC_08004418"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800441a": {
            "entrypoint": "0x0800441a",
            "current_name": "initialize_uart_0800441a",
            "code": "\nundefined4 initializeUART_0800441a(int *uartConfig)\n\n{\n  if (uartConfig != (int *)0x0) {\n    if (*(char *)((int)uartConfig + 0x39) == '\\0') {\n      *(undefined *)(uartConfig + 0xe) = 0;\n      HAL_UART_MspInit();\n    }\n    *(undefined *)((int)uartConfig + 0x39) = 0x24;\n    *(uint *)(*uartConfig + 0xc) = *(uint *)(*uartConfig + 0xc) & 0xffffdfff;\n    setUARTConfig(uartConfig);\n    *(uint *)(*uartConfig + 0x10) = *(uint *)(*uartConfig + 0x10) & 0xffffb7ff;\n    *(uint *)(*uartConfig + 0x14) = *(uint *)(*uartConfig + 0x14) & 0xffffffd5;\n    *(uint *)(*uartConfig + 0xc) = *(uint *)(*uartConfig + 0xc) | 0x2000;\n    uartFlag = 0;\n    *(undefined *)((int)uartConfig + 0x39) = 0x20;\n    *(undefined *)((int)uartConfig + 0x3a) = 0x20;\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_0800441a": "initialize_uart_0800441a",
                "param_1": "uartConfig",
                "UART_SetConfig": "setUARTConfig",
                "param_1[0xf]": "uartFlag"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "UART_SetConfig",
                "HAL_UART_MspInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004478": {
            "entrypoint": "0x08004478",
            "current_name": "process_data_08004478",
            "code": "\nundefined4 processData_08004478(int *data,ushort *buffer,int size,undefined4 timeout)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  if (*(char *)((int)data + 0x39) == ' ') {\n    if (buffer == (ushort *)0x0) {\n      returnValue = 1;\n    }\n    else if (size == 0) {\n      returnValue = 1;\n    }\n    else if (*(char *)(data + 0xe) == '\\x01') {\n      returnValue = 2;\n    }\n    else {\n      *(undefined *)(data + 0xe) = 1;\n      data[0xf] = 0;\n      *(undefined *)((int)data + 0x39) = 0x21;\n      returnValue = HAL_GetTick();\n      *(short *)(data + 9) = (short)size;\n      *(short *)((int)data + 0x26) = (short)size;\n      while (*(short *)((int)data + 0x26) != 0) {\n        *(short *)((int)data + 0x26) = *(short *)((int)data + 0x26) + -1;\n        if (data[2] == 0x1000) {\n          result = UART_WaitOnFlagUntilTimeout(data,0x80,0,returnValue,timeout);\n          if (result != 0) {\n            return 3;\n          }\n          *(uint *)(*data + 4) = *buffer & 0x1ff;\n          if (data[4] == 0) {\n            buffer = buffer + 1;\n          }\n          else {\n            buffer = (ushort *)((int)buffer + 1);\n          }\n        }\n        else {\n          result = UART_WaitOnFlagUntilTimeout(data,0x80,0,returnValue,timeout);\n          if (result != 0) {\n            return 3;\n          }\n          *(uint *)(*data + 4) = (uint)*(byte *)buffer;\n          buffer = (ushort *)((int)buffer + 1);\n        }\n      }\n      result = UART_WaitOnFlagUntilTimeout(data,0x40,0,returnValue,timeout);\n      if (result == 0) {\n        *(undefined *)((int)data + 0x39) = 0x20;\n        *(undefined *)(data + 0xe) = 0;\n        returnValue = 0;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004478": "process_data_08004478",
                "param_1": "data",
                "param_2": "buffer",
                "param_3": "size",
                "param_4": "timeout",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "HAL_GetTick",
                "UART_WaitOnFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800455a": {
            "entrypoint": "0x0800455a",
            "current_name": "process_input_0800455a",
            "code": "\nundefined4 processInput_0800455a(int *inputData,int length,int value)\n\n{\n  if (*(char *)((int)inputData + 0x39) != ' ') {\n    return 2;\n  }\n  if (length == 0) {\n    return 1;\n  }\n  if (value == 0) {\n    return 1;\n  }\n  if (*(char *)(inputData + 0xe) != '\\x01') {\n    inputData1 = length;\n    *(short *)(inputData + 9) = (short)value;\n    *(short *)((int)inputData + 0x26) = (short)value;\n    outputData = 0;\n    *(undefined *)((int)inputData + 0x39) = 0x21;\n    *(undefined *)(inputData + 0xe) = 0;\n    *(uint *)(*inputData + 0xc) = *(uint *)(*inputData + 0xc) | 0x80;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_0800455a": "process_input_0800455a",
                "param_1": "inputData",
                "param_2": "length",
                "param_3": "value",
                "param_1[8]": "inputData1",
                "param_1[0xf]": "outputData"
            },
            "calling": [
                "uart_attach_tx_callback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045a2": {
            "entrypoint": "0x080045a2",
            "current_name": "validate_input_080045a2",
            "code": "\nundefined4 validate_input_080045a2(int *input_array,int value1,int value2)\n\n{\n  if (*(char *)((int)input_array + 0x3a) != ' ') {\n    return 2;\n  }\n  if (value1 == 0) {\n    return 1;\n  }\n  if (value2 == 0) {\n    return 1;\n  }\n  if (*(char *)(input_array + 0xe) != '\\x01') {\n    input_array[10] = value1;\n    *(short *)(input_array + 0xb) = (short)value2;\n    *(short *)((int)input_array + 0x2e) = (short)value2;\n    input_array[0xf] = 0;\n    *(undefined *)((int)input_array + 0x3a) = 0x22;\n    *(undefined *)(input_array + 0xe) = 0;\n    *(uint *)(*input_array + 0xc) = *(uint *)(*input_array + 0xc) | 0x100;\n    *(uint *)(*input_array + 0x14) = *(uint *)(*input_array + 0x14) | 1;\n    *(uint *)(*input_array + 0xc) = *(uint *)(*input_array + 0xc) | 0x20;\n    return 0;\n  }\n  return 2;\n}\n\n",
            "renaming": {
                "FUN_080045a2": "validate_input_080045a2",
                "param_1": "input_array",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[10]": "input_array[10]",
                "param_1[0xf]": "input_array[0xf]"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080045fe": {
            "entrypoint": "0x080045fe",
            "current_name": "clear_bit_and_transmit_data_080045fe",
            "code": "\nundefined4 clearBitAndTransmitData_080045fe(int *dataPointer)\n\n{\n  *(uint *)(*dataPointer + 0xc) = *(uint *)(*dataPointer + 0xc) & 0xffffffbf;\n  *(undefined *)((int)dataPointer + 0x39) = 0x20;\n  HAL_UART_TxCpltCallback();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080045fe": "clear_bit_and_transmit_data_080045fe",
                "param_1": "dataPointer"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_TxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004618": {
            "entrypoint": "0x08004618",
            "current_name": "process_input_08004618",
            "code": "\nundefined4 processInput_08004618(int *inputData)\n\n{\n  byte *bytePtr;\n  short counter;\n  undefined *undefinedPtr;\n  \n  if (*(char *)((int)inputData + 0x3a) != '\\\"') {\n    return 2;\n  }\n  if (inputData[2] == 0x1000) {\n    if (inputData[4] == 0) {\n      *(ushort *)inputData[10] = (ushort)((uint)(*(int *)(*inputData + 4) << 0x17) >> 0x17);\n      inputData[10] = inputData[10] + 2;\n    }\n    else {\n      *(ushort *)inputData[10] = (ushort)*(undefined4 *)(*inputData + 4) & 0xff;\n      inputData[10] = inputData[10] + 1;\n    }\n  }\n  else if (inputData[4] == 0) {\n    undefinedPtr = (undefined *)inputData[10];\n    inputData[10] = (int)(undefinedPtr + 1);\n    *undefinedPtr = (char)*(undefined4 *)(*inputData + 4);\n  }\n  else {\n    bytePtr = (byte *)inputData[10];\n    inputData[10] = (int)(bytePtr + 1);\n    *bytePtr = (byte)*(undefined4 *)(*inputData + 4) & 0x7f;\n  }\n  counter = *(short *)((int)inputData + 0x2e) + -1;\n  *(short *)((int)inputData + 0x2e) = counter;\n  if (counter != 0) {\n    return 0;\n  }\n  *(uint *)(*inputData + 0xc) = *(uint *)(*inputData + 0xc) & 0xffffffdf;\n  *(uint *)(*inputData + 0xc) = *(uint *)(*inputData + 0xc) & 0xfffffeff;\n  *(uint *)(*inputData + 0x14) = *(uint *)(*inputData + 0x14) & 0xfffffffe;\n  *(undefined *)((int)inputData + 0x3a) = 0x20;\n  HAL_UART_RxCpltCallback();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004618": "process_input_08004618",
                "param_1": "inputData",
                "pbVar1": "bytePtr",
                "sVar2": "counter",
                "puVar3": "undefinedPtr"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [
                "HAL_UART_RxCpltCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046b8": {
            "entrypoint": "0x080046b8",
            "current_name": "handle_uart_operations_080046b8",
            "code": "\nvoid handleUARTOperations_080046b8(uint **ioPointer)\n\n{\n  int errorStatus;\n  uint param3;\n  uint *dataPointer;\n  uint isTransmitting;\n  uint param1Data;\n  \n  dataPointer = *ioPointer;\n  param1Data = *dataPointer;\n  param3 = dataPointer[3];\n  if ((((param1Data & 0xf) == 0) && ((param1Data & 0x20) != 0)) && ((param3 & 0x20) != 0)) {\n    initiateUARTReceiveInterrupt(ioPointer);\n    return;\n  }\n  if (((param1Data & 0xf) == 0) || ((isTransmitting = dataPointer[5] & 1, isTransmitting == 0 && ((param3 & 0x120) == 0)))) {\n    if (((param1Data & 0x80) != 0) && ((param3 & 0x80) != 0)) {\n      initiateUARTTransmitInterrupt(ioPointer);\n      return;\n    }\n    if (((param1Data & 0x40) != 0) && ((param3 & 0x40) != 0)) {\n      initiateUARTEndTransmitInterrupt(ioPointer);\n    }\n  }\n  else {\n    if (((param1Data & 1) != 0) && ((param3 & 0x100) != 0)) {\n      ioPointer[0xf] = (uint *)((uint)ioPointer[0xf] | 1);\n    }\n    if (((param1Data & 4) != 0) && (isTransmitting != 0)) {\n      ioPointer[0xf] = (uint *)((uint)ioPointer[0xf] | 2);\n    }\n    if (((param1Data & 2) != 0) && (isTransmitting != 0)) {\n      ioPointer[0xf] = (uint *)((uint)ioPointer[0xf] | 4);\n    }\n    if (((param1Data & 8) != 0) && (isTransmitting != 0)) {\n      ioPointer[0xf] = (uint *)((uint)ioPointer[0xf] | 8);\n    }\n    if (ioPointer[0xf] != (uint *)0x0) {\n      if (((param1Data & 0x20) != 0) && ((param3 & 0x20) != 0)) {\n        initiateUARTReceiveInterrupt(ioPointer);\n      }\n      if ((((uint)ioPointer[0xf] & 8) == 0) && (((*ioPointer)[5] & 0x40) == 0)) {\n        handleUARTError(ioPointer);\n        ioPointer[0xf] = (uint *)0x0;\n        return;\n      }\n      endUARTReceiveTransfer(ioPointer);\n      dataPointer = *ioPointer;\n      if ((dataPointer[5] & 0x40) == 0) {\n        handleUARTError(ioPointer);\n        return;\n      }\n      dataPointer[5] = dataPointer[5] & 0xffffffbf;\n      if (ioPointer[0xd] == (uint *)0x0) {\n        handleUARTError(ioPointer);\n        return;\n      }\n      ioPointer[0xd][0xd] = (uint)&UARTErrorCallback;\n      errorStatus = abortDMAWithInterrupt(ioPointer[0xd]);\n      if (errorStatus != 0) {\n        (*(code *)ioPointer[0xd][0xd])();\n        return;\n      }\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046b8": "handle_uart_operations_080046b8",
                "param_1": "ioPointer",
                "iVar1": "errorStatus",
                "uVar2": "param3",
                "puVar3": "dataPointer",
                "uVar4": "isTransmitting",
                "uVar5": "param1Data",
                "UART_Receive_IT": "initiateUARTReceiveInterrupt",
                "UART_Transmit_IT": "initiateUARTTransmitInterrupt",
                "UART_EndTransmit_IT": "initiateUARTEndTransmitInterrupt",
                "HAL_UART_ErrorCallback": "handleUARTError",
                "UART_EndRxTransfer": "endUARTReceiveTransfer",
                "LAB_080047d8_1": "UARTErrorCallback",
                "HAL_DMA_Abort_IT": "abortDMAWithInterrupt"
            },
            "calling": [],
            "called": [
                "UART_EndTransmit_IT",
                "HAL_DMA_Abort_IT",
                "UART_EndRxTransfer",
                "UART_Transmit_IT",
                "HAL_UART_ErrorCallback",
                "UART_Receive_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047e8": {
            "entrypoint": "0x080047e8",
            "current_name": "logical_or_080047e8",
            "code": "\nbyte logicalOr_080047e8(int baseAddress)\n\n{\n  return *(byte *)(baseAddress + 0x3a) | *(byte *)(baseAddress + 0x39);\n}\n\n",
            "renaming": {
                "FUN_080047e8": "logical_or_080047e8",
                "param_1": "baseAddress"
            },
            "calling": [
                "serial_rx_active",
                "serial_tx_active"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080047f4": {
            "entrypoint": "0x080047f4",
            "current_name": "get_bit_value_080047f4",
            "code": "\nuint get_bit_value_080047f4(uint index,int base_address)\n\n{\n  return *(uint *)(base_address + ((index << 0x18) >> 0x1c) * 4) >> (index & 0xf) & 1;\n}\n\n",
            "renaming": {
                "FUN_080047f4": "get_bit_value_080047f4",
                "param_1": "index",
                "param_2": "base_address"
            },
            "calling": [
                "digitalRead",
                "digitalWrite",
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800480a": {
            "entrypoint": "0x0800480a",
            "current_name": "set_bit_0800480a",
            "code": "\nvoid setBit_0800480a(uint value,int array)\n\n{\n  uint shiftedIndex;\n  \n  shiftedIndex = (value << 0x18) >> 0x1c;\n  *(uint *)(array + shiftedIndex * 4) = *(uint *)(array + shiftedIndex * 4) | 1 << (value & 0xf);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800480a": "set_bit_0800480a",
                "param_1": "value",
                "param_2": "array",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004828": {
            "entrypoint": "0x08004828",
            "current_name": "update_data_at_index_08004828",
            "code": "\nvoid updateDataAtIndex_08004828(uint index,int data)\n\n{\n  uint shiftedIndex;\n  \n  shiftedIndex = (index << 0x18) >> 0x1c;\n  *(uint *)(data + shiftedIndex * 4) = *(uint *)(data + shiftedIndex * 4) & ~(1 << (index & 0xf));\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004828": "update_data_at_index_08004828",
                "param_1": "index",
                "param_2": "data",
                "uVar1": "shiftedIndex"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004848": {
            "entrypoint": "0x08004848",
            "current_name": "get_memory_address_08004848",
            "code": "\nundefined4 getMemoryAddress_08004848(undefined4 value)\n\n{\n  switch(value) {\n  case 0:\n    return 0x40010800;\n  case 1:\n    return 0x40010c00;\n  case 2:\n    return 0x40011000;\n  case 3:\n    return 0x40011400;\n  case 4:\n    return 0x40011800;\n  default:\n    return 0;\n  }\n}\n\n",
            "renaming": {
                "FUN_08004848": "get_memory_address_08004848",
                "param_1": "value"
            },
            "calling": [
                "digitalRead",
                "digitalWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004884": {
            "entrypoint": "0x08004884",
            "current_name": "set_dat_bit_and_return_address_08004884",
            "code": "\n\n\nundefined4 setDatBitAndReturnAddress_08004884(undefined4 input)\n\n{\n  undefined4 returnValue;\n  \n  switch(input) {\n  case 0:\n    _DAT_40021018 = _DAT_40021018 | 4;\n    returnValue = 0x40010800;\n    break;\n  case 1:\n    _DAT_40021018 = _DAT_40021018 | 8;\n    returnValue = 0x40010c00;\n    break;\n  case 2:\n    _DAT_40021018 = _DAT_40021018 | 0x10;\n    returnValue = 0x40011000;\n    break;\n  case 3:\n    _DAT_40021018 = _DAT_40021018 | 0x20;\n    returnValue = 0x40011400;\n    break;\n  case 4:\n    _DAT_40021018 = _DAT_40021018 | 0x40;\n    returnValue = 0x40011800;\n    break;\n  default:\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004884": "set_dat_bit_and_return_address_08004884",
                "param_1": "input",
                "uVar1": "returnValue"
            },
            "calling": [
                "uart_init",
                "digital_io_init",
                "HAL_ADC_MspInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800492c": {
            "entrypoint": "0x0800492c",
            "current_name": "calculate_pinmap_0800492c",
            "code": "\nuint calculatePinmap_0800492c(undefined4 pinmapInput1,undefined4 pinmapInput2,undefined4 pinmapInput3,undefined4 pinmapInput4)\n\n{\n  int result;\n  uint shiftedResult;\n  \n  result = pinmap_function(pinmapInput1,&DAT_08007400,pinmapInput3,pinmapInput4,pinmapInput4);\n  shiftedResult = (uint)(result << 0xc) >> 0x1b;\n  if (0x10 < shiftedResult - 1) {\n    shiftedResult = 0;\n  }\n  return shiftedResult;\n}\n\n",
            "renaming": {
                "FUN_0800492c": "calculate_pinmap_0800492c",
                "param_1": "pinmapInput1",
                "param_2": "pinmapInput2",
                "param_3": "pinmapInput3",
                "param_4": "pinmapInput4",
                "iVar1": "result",
                "uVar2": "shiftedResult"
            },
            "calling": [
                "adc_read_value"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004948": {
            "entrypoint": "0x08004948",
            "current_name": "pinmap_check_08004948",
            "code": "\nundefined4 pinmap_check_08004948(undefined4 input_1,undefined4 input_2,undefined4 input_3,undefined4 input_4)\n\n{\n  int result;\n  uint shifted_result;\n  \n  result = pinmap_function(input_1,&DAT_080074b4,input_3,input_4,input_4);\n  shifted_result = (uint)(result << 0xc) >> 0x1b;\n  if (shifted_result == 3) {\n    return 8;\n  }\n  if (shifted_result != 4) {\n    if (shifted_result != 2) {\n      return 0;\n    }\n    return 4;\n  }\n  return 0xc;\n}\n\n",
            "renaming": {
                "FUN_08004948": "pinmap_check_08004948",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "result",
                "uVar2": "shifted_result"
            },
            "calling": [
                "pwm_stop"
            ],
            "called": [
                "pinmap_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004974": {
            "entrypoint": "0x08004974",
            "current_name": "configure_gpio_port_08004974",
            "code": "\n\n\nvoid configure_GPIO_Port_08004974(int *gpio_config,undefined4 clock_config)\n\n{\n  undefined4 port_Gpio;\n  uint port_cfg_data;\n  int gpio_mode;\n  uint pin_mask;\n  undefined4 pin_mode;\n  undefined4 gpio_init_val;\n  \n  gpio_mode = *gpio_config;\n  if (gpio_mode == 0x40012400) {\n    port_cfg_data = _DAT_40021018 | 0x200;\n    gpio_mode = 0x200;\n    _DAT_40021018 = port_cfg_data;\n  }\n  else {\n    port_cfg_data = 0x40012800;\n    if (gpio_mode == 0x40012800) {\n      port_cfg_data = _DAT_40021018 | 0x400;\n      gpio_mode = 0x400;\n      _DAT_40021018 = port_cfg_data;\n    }\n  }\n  port_Gpio = set_GPIO_Port_Clock((uint)((int)(char)DAT_20000080 << 0x18) >> 0x1c,clock_config,port_cfg_data,gpio_mode);\n  pin_mask = 1 << (DAT_20000080 & 0xf) & 0xffff;\n  pin_mode = 3;\n  gpio_init_val = 0;\n  HAL_GPIO_Init(port_Gpio,&pin_mask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004974": "configure_gpio_port_08004974",
                "param_1": "gpio_config",
                "param_2": "clock_config",
                "uVar1": "port_Gpio",
                "uVar2": "port_cfg_data",
                "iVar3": "gpio_mode",
                "local_18": "pin_mask",
                "local_14": "pin_mode",
                "local_10": "gpio_init_val"
            },
            "calling": [
                "HAL_ADC_Init"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049f0": {
            "entrypoint": "0x080049f0",
            "current_name": "update_control_registers_080049f0",
            "code": "\n\n\nvoid updateControlRegisters_080049f0(int *controlValue)\n\n{\n  if (*controlValue != 0x40012400) {\n    if (*controlValue == 0x40012800) {\n      _DAT_4002100c = _DAT_4002100c & 0xfffffbff;\n      _DAT_40021018 = _DAT_40021018 & 0xfffffbff;\n    }\n    return;\n  }\n  _DAT_4002100c = _DAT_4002100c & 0xfffffdff;\n  _DAT_40021018 = _DAT_40021018 & 0xfffffdff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049f0": "update_control_registers_080049f0",
                "param_1": "controlValue"
            },
            "calling": [
                "HAL_ADC_DeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004a4c": {
            "entrypoint": "0x08004a4c",
            "current_name": "perform_adc_conversion_08004a4c",
            "code": "\nundefined2 perform_adc_conversion_08004a4c(undefined4 peripheral_address)\n\n{\n  int iVar1;\n  uint uVar2;\n  undefined2 conversion_result;\n  uint channel_count;\n  undefined4 calibration_status;\n  undefined4 configuration_status;\n  int peripheral_status;\n  undefined4 var1;\n  undefined4 var2;\n  undefined4 var3;\n  undefined4 var7;\n  undefined4 var4;\n  undefined4 var8;\n  undefined4 var5;\n  undefined4 var6;\n  \n  memset(&peripheral_status,0,0x30);\n  channel_count = 0;\n  calibration_status = 0;\n  configuration_status = 0;\n  conversion_result = 0;\n  peripheral_status = pinmap_peripheral(peripheral_address,&DAT_08007400);\n  if (peripheral_status == 0) {\n    conversion_result = 0;\n  }\n  else {\n    var1 = 0;\n    var2 = 0;\n    var3 = 0;\n    var4 = 0;\n    var5 = 0xe0000;\n    var6 = 0;\n    var7 = 1;\n    var8 = 0;\n    DAT_20000080 = (undefined)peripheral_address;\n    iVar1 = HAL_ADC_Init(&peripheral_status);\n    if (iVar1 == 0) {\n      channel_count = get_adc_channel(peripheral_address);\n      if (channel_count < 0x12) {\n        calibration_status = 1;\n        configuration_status = 2;\n        iVar1 = HAL_ADC_ConfigChannel(&peripheral_status,&channel_count);\n        if (iVar1 == 0) {\n          iVar1 = HAL_ADCEx_Calibration_Start(&peripheral_status);\n          if (iVar1 == 0) {\n            iVar1 = HAL_ADC_Start(&peripheral_status);\n            if (iVar1 == 0) {\n              iVar1 = HAL_ADC_PollForConversion(&peripheral_status,10);\n              if (iVar1 == 0) {\n                uVar2 = HAL_ADC_GetState(&peripheral_status);\n                if ((uVar2 & 0x200) != 0) {\n                  conversion_result = HAL_ADC_GetValue(&peripheral_status);\n                }\n                iVar1 = HAL_ADC_Stop(&peripheral_status);\n                if (iVar1 == 0) {\n                  iVar1 = HAL_ADC_DeInit(&peripheral_status);\n                  if (iVar1 != 0) {\n                    conversion_result = 0;\n                  }\n                }\n                else {\n                  conversion_result = 0;\n                }\n              }\n              else {\n                conversion_result = 0;\n              }\n            }\n            else {\n              conversion_result = 0;\n            }\n          }\n          else {\n            conversion_result = 0;\n          }\n        }\n        else {\n          conversion_result = 0;\n        }\n      }\n      else {\n        conversion_result = 0;\n      }\n    }\n    else {\n      conversion_result = 0;\n    }\n  }\n  return conversion_result;\n}\n\n",
            "renaming": {
                "FUN_08004a4c": "perform_adc_conversion_08004a4c",
                "param_1": "peripheral_address",
                "local_46": "conversion_result",
                "local_44": "channel_count",
                "local_40": "calibration_status",
                "local_3c": "configuration_status",
                "local_38": "peripheral_status",
                "local_34": "var1",
                "local_30": "var2",
                "local_2c": "var3",
                "local_24": "var4",
                "local_1c": "var5",
                "local_10": "var6",
                "local_28": "var7",
                "local_20": "var8"
            },
            "calling": [
                "analogRead"
            ],
            "called": [
                "HAL_ADC_Init",
                "memset",
                "HAL_ADC_GetValue",
                "HAL_ADCEx_Calibration_Start",
                "HAL_ADC_PollForConversion",
                "HAL_ADC_DeInit",
                "HAL_ADC_ConfigChannel",
                "get_adc_channel",
                "pinmap_peripheral",
                "HAL_ADC_Stop",
                "HAL_ADC_Start",
                "HAL_ADC_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b34": {
            "entrypoint": "0x08004b34",
            "current_name": "disable_timer_08004b34",
            "code": "\nvoid disable_timer_08004b34(void)\n\n{\n  disable_clock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b34": "disable_timer_08004b34",
                "timer_disable_clock": "disable_clock"
            },
            "calling": [
                "HAL_TIM_PWM_DeInit"
            ],
            "called": [
                "timer_disable_clock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b3c": {
            "entrypoint": "0x08004b3c",
            "current_name": "stop_pwm_channels_08004b3c",
            "code": "\nvoid stopPwmChannels_08004b3c(undefined4 peripheral)\n\n{\n  int pwmChannel;\n  uint pinmapResult;\n  int channelArray [17];\n  \n  channelArray[0] = pinmap_peripheral(peripheral,&DAT_080074b4);\n  if ((channelArray[0] != 0) &&\n     ((((pwmChannel = get_pwm_channel(peripheral), pwmChannel == 0 || (pwmChannel == 4)) || (pwmChannel == 8)) ||\n      ((pwmChannel == 0xc || (pwmChannel == 0x18)))))) {\n    pinmapResult = pinmap_function(peripheral,&DAT_080074b4);\n    if ((pinmapResult & 0x100000) == 0) {\n      HAL_TIM_PWM_Stop(channelArray,pwmChannel);\n    }\n    else {\n      HAL_TIMEx_PWMN_Stop(channelArray,pwmChannel);\n    }\n    HAL_TIM_PWM_DeInit(channelArray);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b3c": "stop_pwm_channels_08004b3c",
                "param_1": "peripheral",
                "local_50": "channelArray",
                "iVar1": "pwmChannel",
                "uVar2": "pinmapResult"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "HAL_TIMEx_PWMN_Stop",
                "get_pwm_channel",
                "HAL_TIM_PWM_Stop",
                "pinmap_function",
                "pinmap_peripheral",
                "HAL_TIM_PWM_DeInit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b94": {
            "entrypoint": "0x08004b94",
            "current_name": "get_current_tick_08004b94",
            "code": "\nvoid get_current_tick_08004b94(void)\n\n{\n  current_tick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b94": "get_current_tick_08004b94",
                "HAL_GetTick": "current_tick"
            },
            "calling": [
                "millis"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9c": {
            "entrypoint": "0x08004b9c",
            "current_name": "FUNC_08004b9c",
            "code": "\nvoid FUNC_08004b9c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9c": "FUNC_08004b9c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004b9e": {
            "entrypoint": "0x08004b9e",
            "current_name": "handle_system_tick_08004b9e",
            "code": "\nvoid handleSystemTick_08004b9e(void)\n\n{\n  incrementTick();\n  handleSysTickInterrupt();\n  handleNoOsSysTick();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004b9e": "handle_system_tick_08004b9e",
                "HAL_IncTick": "incrementTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt",
                "noOsSystickHandler": "handleNoOsSysTick"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "noOsSystickHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bb0": {
            "entrypoint": "0x08004bb0",
            "current_name": "initialize_gpio_pin_08004bb0",
            "code": "\n\n\nvoid initialize_GPIO_Pin_08004bb0(uint pin_number,undefined4 pin_mode,undefined4 pin_speed)\n\n{\n  undefined4 GPIO_Port_Clock;\n  uint pin_bit_mask;\n  undefined4 new_pin_mode;\n  undefined4 new_pin_speed;\n  undefined4 default_pin_pull;\n  \n  GPIO_Port_Clock = set_GPIO_Port_Clock((pin_number << 0x18) >> 0x1c);\n  pin_bit_mask = 1 << (pin_number & 0xf) & 0xffff;\n  default_pin_pull = 3;\n  _DAT_40021018 = _DAT_40021018 | 1;\n  if ((pin_number - 0xd & 0xff) < 2) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n  }\n  if (((pin_number == 0xf) || (pin_number == 0x13)) || (pin_number == 0x14)) {\n    _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x2000000;\n  }\n  new_pin_mode = pin_mode;\n  new_pin_speed = pin_speed;\n  HAL_GPIO_Init(GPIO_Port_Clock,&pin_bit_mask);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bb0": "initialize_gpio_pin_08004bb0",
                "param_1": "pin_number",
                "param_2": "pin_mode",
                "param_3": "pin_speed",
                "uVar1": "GPIO_Port_Clock",
                "local_20": "pin_bit_mask",
                "local_1c": "new_pin_mode",
                "local_18": "new_pin_speed",
                "local_14": "default_pin_pull"
            },
            "calling": [
                "pinMode"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c30": {
            "entrypoint": "0x08004c30",
            "current_name": "write_pin_based_on_condition_08004c30",
            "code": "\nvoid writePinBasedOnCondition_08004c30(undefined4 pinPort,undefined2 pinNumber,int condition,undefined4 pinConfig)\n\n{\n  if (condition == 0) {\n    HAL_GPIO_WritePin(pinPort,pinNumber,0,pinConfig,pinConfig);\n    return;\n  }\n  HAL_GPIO_WritePin(pinPort,pinNumber,1,pinConfig,pinConfig);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c30": "write_pin_based_on_condition_08004c30",
                "param_1": "pinPort",
                "param_2": "pinNumber",
                "param_3": "condition",
                "param_4": "pinConfig"
            },
            "calling": [
                "digitalWrite"
            ],
            "called": [
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c48": {
            "entrypoint": "0x08004c48",
            "current_name": "read_pin_from_gpio_08004c48",
            "code": "\nvoid readPinFromGPIO_08004c48(undefined4 pinPort,undefined2 pinNumber,undefined4 inputType,undefined4 outputType)\n\n{\n  HAL_GPIO_ReadPin(pinPort,pinNumber,inputType,outputType,outputType);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c48": "read_pin_from_gpio_08004c48",
                "param_1": "pinPort",
                "param_2": "pinNumber",
                "param_3": "inputType",
                "param_4": "outputType"
            },
            "calling": [
                "digitalRead"
            ],
            "called": [
                "HAL_GPIO_ReadPin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c52": {
            "entrypoint": "0x08004c52",
            "current_name": "initialize_system_08004c52",
            "code": "\nvoid initializeSystem_08004c52(void)\n\n{\n  initializeHardwareAbstractionLayer();\n  configureSystemClock();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004c52": "initialize_system_08004c52",
                "HAL_Init": "initializeHardwareAbstractionLayer",
                "SystemClock_Config": "configureSystemClock"
            },
            "calling": [
                "FUN_08001c32"
            ],
            "called": [
                "HAL_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c5e": {
            "entrypoint": "0x08004c5e",
            "current_name": "find_value_in_array_08004c5e",
            "code": "\nundefined4 find_value_in_array_08004c5e(int target_value,char *array)\n\n{\n  while( true ) {\n    if (*array == -1) {\n      return 0;\n    }\n    if (*array == target_value) break;\n    array = array + 0xc;\n  }\n  return *(undefined4 *)(array + 4);\n}\n\n",
            "renaming": {
                "FUN_08004c5e": "find_value_in_array_08004c5e",
                "param_1": "target_value",
                "param_2": "array"
            },
            "calling": [
                "pinmap_find_peripheral",
                "pinmap_peripheral"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c78": {
            "entrypoint": "0x08004c78",
            "current_name": "find_peripheral_08004c78",
            "code": "\nundefined4 find_peripheral_08004c78(int input_value)\n\n{\n  undefined4 peripheral_address;\n  \n  if (input_value != -1) {\n    peripheral_address = pinmap_find_peripheral_08004c78();\n    return peripheral_address;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08004c78": "find_peripheral_08004c78",
                "param_1": "input_value",
                "uVar1": "peripheral_address"
            },
            "calling": [
                "uart_init",
                "adc_read_value",
                "pwm_stop",
                "uart_debug_write",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004c8a": {
            "entrypoint": "0x08004c8a",
            "current_name": "find_value_position_08004c8a",
            "code": "\nint find_value_position_08004c8a(int value,char *data)\n\n{\n  while( true ) {\n    if (*(int *)(data + 4) == 0) {\n      return -1;\n    }\n    if (*(int *)(data + 4) == value) break;\n    data = data + 0xc;\n  }\n  return (int)*data;\n}\n\n",
            "renaming": {
                "FUN_08004c8a": "find_value_position_08004c8a",
                "param_1": "value",
                "param_2": "data"
            },
            "calling": [
                "pinmap_find_pin",
                "pinmap_pin"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ca2": {
            "entrypoint": "0x08004ca2",
            "current_name": "find_pin_from_param_08004ca2",
            "code": "\nundefined4 findPinFromParam_08004ca2(int inputValue)\n\n{\n  undefined4 pinResult;\n  \n  if (inputValue != 0) {\n    pinResult = pinmap_find_pin();\n    return pinResult;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08004ca2": "find_pin_from_param_08004ca2",
                "param_1": "inputValue",
                "uVar1": "pinResult"
            },
            "calling": [
                "HardwareSerial",
                "uart_debug_init"
            ],
            "called": [
                "pinmap_find_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cb2": {
            "entrypoint": "0x08004cb2",
            "current_name": "find_value_in_array_08004cb2",
            "code": "\nundefined4 find_value_in_array_08004cb2(int value_to_find,char *array)\n\n{\n  while( true ) {\n    if (*array == -1) {\n      return 0xffffffff;\n    }\n    if (*array == value_to_find) break;\n    array = array + 0xc;\n  }\n  return *(undefined4 *)(array + 8);\n}\n\n",
            "renaming": {
                "FUN_08004cb2": "find_value_in_array_08004cb2",
                "param_1": "value_to_find",
                "param_2": "array"
            },
            "calling": [
                "pinmap_function",
                "pinmap_find_function"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004cce": {
            "entrypoint": "0x08004cce",
            "current_name": "find_pinmap_function_08004cce",
            "code": "\nundefined4 find_pinmap_function_08004cce(int input_value)\n\n{\n  undefined4 function_result;\n  \n  if (input_value == -1) {\n    return 0xffffffff;\n  }\n  function_result = pinmap_find_function();\n  return function_result;\n}\n\n",
            "renaming": {
                "FUN_08004cce": "find_pinmap_function_08004cce",
                "param_1": "input_value",
                "uVar1": "function_result"
            },
            "calling": [
                "uart_init",
                "get_adc_channel",
                "get_pwm_channel",
                "pwm_stop"
            ],
            "called": [
                "pinmap_find_function"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ce2": {
            "entrypoint": "0x08004ce2",
            "current_name": "check_value_in_array_08004ce2",
            "code": "\nundefined4 check_value_in_array_08004ce2(int value_to_check,char *array)\n\n{\n  if (value_to_check == -1) {\n    return 0;\n  }\n  while( true ) {\n    if (*array == -1) {\n      return 0;\n    }\n    if (value_to_check == *array) break;\n    array = array + 0xc;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08004ce2": "check_value_in_array_08004ce2",
                "param_1": "value_to_check",
                "param_2": "array"
            },
            "calling": [
                "pinMode"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d06": {
            "entrypoint": "0x08004d06",
            "current_name": "return_smaller_value_08004d06",
            "code": "\nint returnSmallerValue_08004d06(int value1,int value2)\n\n{\n  if (value1 != value2) {\n    if (value1 == 0) {\n      return value2;\n    }\n    if (value2 == 0) {\n      return value1;\n    }\n    value1 = 0;\n  }\n  return value1;\n}\n\n",
            "renaming": {
                "FUN_08004d06": "return_smaller_value_08004d06",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "uart_init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d18": {
            "entrypoint": "0x08004d18",
            "current_name": "execute_callback_if_available_08004d18",
            "code": "\nvoid execute_callback_if_available_08004d18(void)\n\n{\n  if (DAT_20000260 != (function_pointer *)0x0) {\n    (*DAT_20000260)(DAT_20000278);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d18": "execute_callback_if_available_08004d18",
                "code": "function_pointer"
            },
            "calling": [
                "HAL_RTC_AlarmIRQHandler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d40": {
            "entrypoint": "0x08004d40",
            "current_name": "infinite_loop_08004d40",
            "code": "\nvoid infiniteLoop_08004d40(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08004d40": "infinite_loop_08004d40"
            },
            "calling": [
                "_Error_Handler",
                "SystemClock_Config"
            ],
            "called": [
                "_Error_Handler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d44": {
            "entrypoint": "0x08004d44",
            "current_name": "initialize_memory_08004d44",
            "code": "\n\n\nvoid initializeMemory_08004d44(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d44": "initialize_memory_08004d44"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d90": {
            "entrypoint": "0x08004d90",
            "current_name": "update_memory_protection_08004d90",
            "code": "\n\n\nvoid updateMemoryProtection_08004d90(int *address)\n\n{\n  if (*address == 0x40012c00) {\n    _DAT_40021018 = _DAT_40021018 & 0xfffff7ff;\n  }\n  if (*address == 0x40000000) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffe;\n  }\n  if (*address == 0x40000400) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffd;\n  }\n  if (*address == 0x40000800) {\n    _DAT_4002101c = _DAT_4002101c & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d90": "update_memory_protection_08004d90",
                "param_1": "address"
            },
            "calling": [
                "HAL_TIM_PWM_MspDeInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df4": {
            "entrypoint": "0x08004df4",
            "current_name": "decrement_param_08004df4",
            "code": "\nint decrement_param_08004df4(int original_param)\n\n{\n  return original_param + -4;\n}\n\n",
            "renaming": {
                "FUN_08004df4": "decrement_param_08004df4",
                "param_1": "original_param"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004df8": {
            "entrypoint": "0x08004df8",
            "current_name": "execute_timer_callback_08004df8",
            "code": "\nvoid executeTimerCallback_08004df8(int timerObj)\n\n{\n  int timer;\n  \n  timer = getTimerObject();\n  if ((*(callback **)(timer + 0x4c) != (callback *)0x0) && (*(char *)(timerObj + 0x1c) == '\\x01')) {\n    (**(callback **)(timer + 0x4c))(timer,0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004df8": "execute_timer_callback_08004df8",
                "param_1": "timerObj",
                "iVar1": "timer",
                "get_timer_obj": "getTimerObject",
                "code": "callback"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e12": {
            "entrypoint": "0x08004e12",
            "current_name": "execute_timer_function_08004e12",
            "code": "\nvoid execute_timer_function_08004e12(void)\n\n{\n  int timer_obj;\n  \n  timer_obj = retrieve_timer_object();\n  if (*(function_pointers **)(timer_obj + 0x48) != (function_pointers *)0x0) {\n    (**(function_pointers **)(timer_obj + 0x48))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e12": "execute_timer_function_08004e12",
                "iVar1": "timer_obj",
                "get_timer_obj": "retrieve_timer_object",
                "code": "function_pointers"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "get_timer_obj"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e20": {
            "entrypoint": "0x08004e20",
            "current_name": "handle_timer_irq_08004e20",
            "code": "\nvoid handleTimerIRQ_08004e20(void)\n\n{\n  if (DAT_2000027c != 0) {\n    HAL_TIM_IRQHandler();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e20": "handle_timer_irq_08004e20"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e70": {
            "entrypoint": "0x08004e70",
            "current_name": "subtract_four_08004e70",
            "code": "\nint subtract_four_08004e70(int input_value)\n\n{\n  return input_value + -4;\n}\n\n",
            "renaming": {
                "FUN_08004e70": "subtract_four_08004e70",
                "param_1": "input_value"
            },
            "calling": [
                "HAL_I2C_ErrorCallback",
                "HAL_I2C_ListenCpltCallback",
                "HAL_I2C_AddrCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "transmit_or_receive_data_08004e74",
            "code": "\nvoid transmitOrReceiveData_08004e74(int deviceAddress,int isReceive,int dataSize,undefined4 callback)\n\n{\n  int i2cObject;\n  \n  i2cObject = getI2CObject();\n  if (dataSize == *(int *)(deviceAddress + 0xc)) {\n    if (isReceive == 0) {\n      *(undefined *)(i2cObject + 0x88) = 0;\n      *(undefined *)(i2cObject + 0x5c) = 0;\n      if (*(code **)(i2cObject + 100) != (code *)0x0) {\n        (**(code **)(i2cObject + 100))();\n      }\n      transmitDataSequentially(deviceAddress,i2cObject + 0x68,*(undefined *)(i2cObject + 0x88),8);\n      return;\n    }\n    *(undefined *)(i2cObject + 0x5c) = 1;\n    receiveDataSequentially(deviceAddress,i2cObject + 0x68,0x20,8,callback);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "transmit_or_receive_data_08004e74",
                "param_1": "deviceAddress",
                "param_2": "isReceive",
                "param_3": "dataSize",
                "param_4": "callback",
                "iVar1": "i2cObject",
                "get_i2c_obj": "getI2CObject",
                "HAL_I2C_Slave_Sequential_Transmit_IT": "transmitDataSequentially",
                "HAL_I2C_Slave_Sequential_Receive_IT": "receiveDataSequentially"
            },
            "calling": [
                "I2C_Slave_ADDR"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_Slave_Sequential_Receive_IT",
                "HAL_I2C_Slave_Sequential_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ec4": {
            "entrypoint": "0x08004ec4",
            "current_name": "initialize_i2c_08004ec4",
            "code": "\nvoid initialize_i2c_08004ec4(undefined4 undefined_parameter)\n\n{\n  int i2c_object;\n  \n  i2c_object = get_i2c_object();\n  if (((*(code **)(i2c_object + 0x60) != (code *)0x0) && (*(char *)(i2c_object + 0x5c) == '\\x01')) &&\n     (*(char *)(i2c_object + 0x2c) != ' ')) {\n    (**(code **)(i2c_object + 0x60))(i2c_object + 0x68);\n  }\n  enable_i2c_listen_interrupt(undefined_parameter);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ec4": "initialize_i2c_08004ec4",
                "param_1": "undefined_parameter",
                "iVar1": "i2c_object",
                "get_i2c_obj": "get_i2c_object",
                "HAL_I2C_EnableListen_IT": "enable_i2c_listen_interrupt"
            },
            "calling": [
                "I2C_Slave_AF",
                "I2C_ITError",
                "I2C_Slave_STOPF"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ef4": {
            "entrypoint": "0x08004ef4",
            "current_name": "enable_i2_c_listen_interrupt_08004ef4",
            "code": "\nvoid enableI2CListenInterrupt_08004ef4(undefined4 i2cDevice)\n\n{\n  int i2cObj;\n  \n  i2cObj = getI2CObject();\n  if (*(char *)(i2cObj + 0x5d) == '\\0') {\n    enableListenInterrupt(i2cDevice);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ef4": "enable_i2_c_listen_interrupt_08004ef4",
                "param_1": "i2cDevice",
                "iVar1": "i2cObj",
                "get_i2c_obj": "getI2CObject",
                "HAL_I2C_EnableListen_IT": "enableListenInterrupt"
            },
            "calling": [
                "I2C_ITError"
            ],
            "called": [
                "get_i2c_obj",
                "HAL_I2C_EnableListen_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f4c": {
            "entrypoint": "0x08004f4c",
            "current_name": "initialize_uart_pins_08004f4c",
            "code": "\n\n\nvoid initializeUARTPins_08004f4c(int *uartPins)\n\n{\n  int peripheral1;\n  int peripheral2;\n  undefined4 gpioClock;\n  uint pinFunction;\n  uint gpioInitValue1;\n  uint gpioInitValue2;\n  uint gpioInitValue3;\n  undefined4 gpioInitStruct;\n  \n  if (uartPins != (int *)0x0) {\n    peripheral1 = pinmap_peripheral((int)*(char *)(uartPins + 0x16),&DAT_0800764c);\n    peripheral2 = pinmap_peripheral((int)*(char *)((int)uartPins + 0x59),&DAT_08007604);\n    if ((peripheral2 == 0) || (peripheral1 == 0)) {\n      iprintf(\"ERROR: at least one UART pin has no peripheral\\n\",peripheral2);\n    }\n    else {\n      peripheral1 = pinmap_merge_peripheral(peripheral1);\n      *uartPins = peripheral1;\n      if (peripheral1 == 0) {\n        iprintf(\"ERROR: U(S)ART pins mismatch\\n\");\n      }\n      else {\n        if (peripheral1 == 0x40013800) {\n          _DAT_4002100c = _DAT_4002100c & 0xffffbfff;\n          _DAT_40021018 = _DAT_40021018 | 0x4000;\n          *(undefined *)(uartPins + 0x11) = 0;\n          *(undefined *)((int)uartPins + 0x5a) = 0x25;\n        }\n        else if (peripheral1 == 0x40004400) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffdffff;\n          _DAT_4002101c = _DAT_4002101c | 0x20000;\n          *(undefined *)(uartPins + 0x11) = 1;\n          *(undefined *)((int)uartPins + 0x5a) = 0x26;\n        }\n        else if (peripheral1 == 0x40004800) {\n          _DAT_40021010 = _DAT_40021010 & 0xfffbffff;\n          _DAT_4002101c = _DAT_4002101c | 0x40000;\n          *(undefined *)(uartPins + 0x11) = 2;\n          *(undefined *)((int)uartPins + 0x5a) = 0x27;\n        }\n        gpioClock = set_GPIO_Port_Clock((uint)((int)*(char *)((int)uartPins + 0x59) << 0x18) >> 0x1c);\n        pinFunction = pinmap_function((int)*(char *)((int)uartPins + 0x59),&DAT_08007604);\n        gpioInitValue1 = 1 << (*(byte *)((int)uartPins + 0x59) & 0xf) & 0xffff;\n        gpioInitValue2 = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitValue3 = (pinFunction << 0x1a) >> 0x1e;\n        _DAT_40021018 = _DAT_40021018 | 1;\n        switch((pinFunction << 0x11) >> 0x19) {\n        case 1:\n          _DAT_40010004 = _DAT_40010004 | 0x7000001;\n          break;\n        case 2:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffffe | 0x7000000;\n          break;\n        case 3:\n          _DAT_40010004 = _DAT_40010004 | 0x7000002;\n          break;\n        case 4:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffffd | 0x7000000;\n          break;\n        case 5:\n          _DAT_40010004 = _DAT_40010004 | 0x7000004;\n          break;\n        case 6:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffffb | 0x7000000;\n          break;\n        case 7:\n          _DAT_40010004 = _DAT_40010004 | 0x7000008;\n          break;\n        case 8:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffff7 | 0x7000000;\n          break;\n        case 9:\n          _DAT_40010004 = _DAT_40010004 | 0x7000030;\n          break;\n        case 10:\n          _DAT_40010004 = _DAT_40010004 & 0xffffffcf | 0x7000010;\n          break;\n        case 0xb:\n          _DAT_40010004 = _DAT_40010004 & 0xffffffcf | 0x7000000;\n          break;\n        case 0xc:\n          _DAT_40010004 = _DAT_40010004 | 0x70000c0;\n          break;\n        case 0xd:\n          _DAT_40010004 = _DAT_40010004 & 0xffffff3f | 0x7000040;\n          break;\n        case 0xe:\n          _DAT_40010004 = _DAT_40010004 & 0xffffff3f | 0x7000000;\n          break;\n        case 0xf:\n          _DAT_40010004 = _DAT_40010004 | 0x7000300;\n          break;\n        case 0x10:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000200;\n          break;\n        case 0x11:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000100;\n          break;\n        case 0x12:\n          _DAT_40010004 = _DAT_40010004 & 0xfffffcff | 0x7000000;\n          break;\n        case 0x13:\n          _DAT_40010004 = _DAT_40010004 | 0x7000c00;\n          break;\n        case 0x14:\n          _DAT_40010004 = _DAT_40010004 & 0xfffff3ff | 0x7000800;\n          break;\n        case 0x15:\n          _DAT_40010004 = _DAT_40010004 & 0xfffff3ff | 0x7000000;\n          break;\n        case 0x16:\n          _DAT_40010004 = _DAT_40010004 | 0x7001000;\n          break;\n        case 0x17:\n          _DAT_40010004 = _DAT_40010004 & 0xffffefff | 0x7000000;\n          break;\n        case 0x1b:\n          _DAT_40010004 = _DAT_40010004 | 0x7008000;\n          break;\n        case 0x1c:\n          _DAT_40010004 = _DAT_40010004 & 0xffff7fff | 0x7000000;\n          break;\n        case 0x21:\n          _DAT_40010004 = _DAT_40010004 & 0xf8ffffff;\n          break;\n        case 0x22:\n          _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x1000000;\n          break;\n        case 0x23:\n          _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x2000000;\n          break;\n        case 0x24:\n          _DAT_40010004 = _DAT_40010004 & 0xf8ffffff | 0x4000000;\n        }\n        gpioInitStruct = 3;\n        initializeGPIO(gpioClock,&gpioInitValue1);\n        gpioClock = set_GPIO_Port_Clock((uint)((int)*(char *)(uartPins + 0x16) << 0x18) >> 0x1c);\n        pinFunction = pinmap_function((int)*(char *)(uartPins + 0x16),&DAT_0800764c);\n        gpioInitValue1 = 1 << (*(byte *)(uartPins + 0x16) & 0xf) & 0xffff;\n        gpioInitValue2 = (pinFunction >> 3 & 1) << 4 | pinFunction & 7;\n        gpioInitValue3 = (pinFunction << 0x1a) >> 0x1e;\n        initializeGPIO(gpioClock,&gpioInitValue1);\n        (&DAT_2000032c)[*(byte *)(uartPins + 0x11)] = uartPins + 1;\n        uartPins[1] = *uartPins;\n        uartPins[2] = uartPins[0x12];\n        uartPins[3] = uartPins[0x13];\n        uartPins[4] = uartPins[0x14];\n        uartPins[5] = uartPins[0x15];\n        uartPins[6] = 0xc;\n        uartPins[7] = 0;\n        uartPins[8] = 0;\n        initializeUART(uartPins + 1);\n      }\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f4c": "initialize_uart_pins_08004f4c",
                "param_1": "uartPins",
                "iVar1": "peripheral1",
                "iVar2": "peripheral2",
                "uVar3": "gpioClock",
                "uVar4": "pinFunction",
                "local_20": "gpioInitValue1",
                "local_1c": "gpioInitValue2",
                "local_18": "gpioInitValue3",
                "local_14": "gpioInitStruct",
                "HAL_GPIO_Init": "initializeGPIO",
                "HAL_UART_Init": "initializeUART"
            },
            "calling": [
                "begin",
                "uart_debug_init"
            ],
            "called": [
                "set_GPIO_Port_Clock",
                "HAL_UART_Init",
                "iprintf",
                "pinmap_merge_peripheral",
                "HAL_GPIO_Init",
                "pinmap_function",
                "pinmap_peripheral"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005384": {
            "entrypoint": "0x08005384",
            "current_name": "initialize_peripherals_08005384",
            "code": "\nvoid initialize_peripherals_08005384(void)\n\n{\n  int result;\n  undefined4 peripheral;\n  \n  result = pinmap_peripheral(2,&DAT_0800764c);\n  if (result != 0) {\n    peripheral = pinmap_peripheral(2,&DAT_0800764c);\n    DAT_200000e1 = pinmap_pin(peripheral,&DAT_08007604);\n    DAT_200000e0 = 2;\n    DAT_200000d0 = 0x2580;\n    DAT_200000dc = 0;\n    DAT_200000d4 = 0;\n    DAT_200000d8 = 0;\n    initialize_uart(&DAT_20000088);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005384": "initialize_peripherals_08005384",
                "iVar1": "result",
                "uVar2": "peripheral",
                "uart_init": "initialize_uart"
            },
            "calling": [
                "uart_debug_write"
            ],
            "called": [
                "uart_init",
                "pinmap_peripheral",
                "pinmap_pin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053d4": {
            "entrypoint": "0x080053d4",
            "current_name": "transmit_data_080053d4",
            "code": "\nuint transmitData_080053d4(undefined4 data,uint dataLength)\n\n{\n  int startTime;\n  int peripheralMapResult;\n  uint index;\n  \n  startTime = HAL_GetTick();\n  peripheralMapResult = pinmap_peripheral(2,&DAT_0800764c);\n  if (peripheralMapResult == 0) {\n    return 0;\n  }\n  for (index = 0;\n      (index < 5 &&\n      (((&DAT_2000032c)[index] == 0 ||\n       (peripheralMapResult = pinmap_peripheral(2,&DAT_0800764c), *(int *)(&DAT_2000032c)[index] != peripheralMapResult))));\n      index = index + 1 & 0xff) {\n  }\n  if (4 < index) {\n    if ((4 < DAT_200000cc) && (uart_debug_init(), 4 < DAT_200000cc)) {\n      return 0;\n    }\n    index = (uint)DAT_200000cc;\n  }\n  do {\n    peripheralMapResult = HAL_UART_Transmit((&DAT_2000032c)[index],data,dataLength & 0xffff,1000);\n    if (peripheralMapResult == 0) {\n      return dataLength;\n    }\n    peripheralMapResult = HAL_GetTick();\n  } while ((uint)(peripheralMapResult - startTime) < 1000);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080053d4": "transmit_data_080053d4",
                "param_1": "data",
                "param_2": "dataLength",
                "iVar1": "startTime",
                "iVar2": "peripheralMapResult",
                "uVar3": "index"
            },
            "calling": [
                "_write"
            ],
            "called": [
                "HAL_GetTick",
                "pinmap_peripheral",
                "uart_debug_init",
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800548c": {
            "entrypoint": "0x0800548c",
            "current_name": "is_uart_state_valid_0800548c",
            "code": "\nbool isUARTStateValid_0800548c(int address)\n\n{\n  uint uartState;\n  \n  uartState = HAL_UART_GetState((&DAT_2000032c)[*(byteValue *)(address + 0x44)]);\n  return (uartState & 0x22) == 0x22;\n}\n\n",
            "renaming": {
                "FUN_0800548c": "is_uart_state_valid_0800548c",
                "param_1": "address",
                "uVar1": "uartState",
                "byte": "byteValue"
            },
            "calling": [
                "uart_attach_rx_callback",
                "uart_getc"
            ],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054b0": {
            "entrypoint": "0x080054b0",
            "current_name": "is_uart_ready_to_receive_080054b0",
            "code": "\nbool is_uart_ready_to_receive_080054b0(int device_handle)\n\n{\n  uint uart_state;\n  \n  uart_state = HAL_UART_GetState((&DAT_2000032c)[*(byte *)(device_handle + 0x44)]);\n  return (uart_state & 0x21) == 0x21;\n}\n\n",
            "renaming": {
                "FUN_080054b0": "is_uart_ready_to_receive_080054b0",
                "param_1": "device_handle",
                "uVar1": "uart_state"
            },
            "calling": [],
            "called": [
                "HAL_UART_GetState"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080054d4": {
            "entrypoint": "0x080054d4",
            "current_name": "process_serial_data_080054d4",
            "code": "\nundefined4 processSerialData_080054d4(int inputData,undefined *outputData,undefined4 param3,undefined4 param4)\n\n{\n  int isSerialRxActive;\n  \n  if (inputData == 0) {\n    return 0xffffffff;\n  }\n  isSerialRxActive = serial_rx_active();\n  if (isSerialRxActive == 0) {\n    *outputData = *(undefined *)(inputData + 0x45);\n    HAL_UART_Receive_IT((&DAT_2000032c)[*(byte *)(inputData + 0x44)],inputData + 0x45,1,&DAT_2000032c,\n                        param4);\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080054d4": "process_serial_data_080054d4",
                "param_1": "inputData",
                "param_2": "outputData",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "isSerialRxActive"
            },
            "calling": [
                "_rx_complete_irq"
            ],
            "called": [
                "HAL_UART_Receive_IT",
                "serial_rx_active"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005510": {
            "entrypoint": "0x08005510",
            "current_name": "initialize_serial_communication_08005510",
            "code": "\nvoid initializeSerialCommunication_08005510(int serialPort,undefined4 data,undefined4 param3,undefined4 param4)\n\n{\n  int isSerialRxActive;\n  uint portIndex;\n  \n  if (serialPort != 0) {\n    isSerialRxActive = serial_rx_active();\n    if (isSerialRxActive == 0) {\n      portIndex = (uint)*(byte *)(serialPort + 0x44);\n      *(undefined4 *)(&DAT_200002dc + portIndex * 4) = data;\n      *(int *)(&DAT_200002f0 + portIndex * 4) = serialPort;\n      HAL_NVIC_SetPriority((int)*(char *)(serialPort + 0x5a),0,1,portIndex,param4);\n      HAL_NVIC_EnableIRQ((int)*(char *)(serialPort + 0x5a));\n      HAL_UART_Receive_IT((&DAT_2000032c)[*(byte *)(serialPort + 0x44)],serialPort + 0x45,1);\n    }\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005510": "initialize_serial_communication_08005510",
                "param_1": "serialPort",
                "param_2": "data",
                "param_3": "param3",
                "param_4": "param4",
                "iVar1": "isSerialRxActive",
                "uVar2": "portIndex"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_UART_Receive_IT",
                "serial_rx_active",
                "HAL_NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005568": {
            "entrypoint": "0x08005568",
            "current_name": "configure_peripheral_08005568",
            "code": "\nvoid configurePeripheral_08005568(int peripheralAddress,undefined4 priorityLevel)\n\n{\n  byte peripheralIndex;\n  \n  if (peripheralAddress != 0) {\n    peripheralIndex = *(byte *)(peripheralAddress + 0x44);\n    *(undefined4 *)(&DAT_20000304 + (uint)peripheralIndex * 4) = priorityLevel;\n    *(int *)(&DAT_20000318 + (uint)peripheralIndex * 4) = peripheralAddress;\n    HAL_NVIC_SetPriority((int)*(char *)(peripheralAddress + 0x5a),0,2);\n    HAL_NVIC_EnableIRQ((int)*(char *)(peripheralAddress + 0x5a));\n    HAL_UART_Transmit_IT\n              ((&DAT_2000032c)[*(byte *)(peripheralAddress + 0x44)],\n               *(int *)(peripheralAddress + 100) + (uint)*(ushort *)(peripheralAddress + 0x6a),1);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005568": "configure_peripheral_08005568",
                "param_1": "peripheralAddress",
                "param_2": "priorityLevel",
                "bVar1": "peripheralIndex"
            },
            "calling": [],
            "called": [
                "HAL_NVIC_EnableIRQ",
                "HAL_NVIC_SetPriority",
                "HAL_UART_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055bc": {
            "entrypoint": "0x080055bc",
            "current_name": "number_lookup_080055bc",
            "code": "\nuint numberLookup_080055bc(int inputNumber)\n\n{\n  uint result;\n  \n  if (inputNumber == 0) {\n    result = 5;\n  }\n  else {\n    result = 0;\n    while( true ) {\n      if (4 < result) {\n        return result;\n      }\n      if (inputNumber == (&DAT_2000032c)[result]) break;\n      result = result + 1 & 0xff;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080055bc": "number_lookup_080055bc",
                "param_1": "inputNumber",
                "uVar1": "result"
            },
            "calling": [
                "HAL_UART_RxCpltCallback",
                "HAL_UART_TxCpltCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055e0": {
            "entrypoint": "0x080055e0",
            "current_name": "execute_uart_command_080055e0",
            "code": "\nvoid execute_uart_command_080055e0(void)\n\n{\n  uint uart_index;\n  \n  uart_index = uart_index();\n  if (uart_index < 5) {\n    (**(code **)(&DAT_200002dc + uart_index * 4))(*(undefined4 *)(&DAT_200002f0 + uart_index * 4));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055e0": "execute_uart_command_080055e0",
                "uVar1": "uart_index"
            },
            "calling": [
                "UART_Receive_IT"
            ],
            "called": [
                "uart_index"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005604": {
            "entrypoint": "0x08005604",
            "current_name": "transmit_data_08005604",
            "code": "\nvoid transmitData_08005604(void)\n\n{\n  uint uartIndex;\n  int result;\n  int uartData;\n  \n  uartIndex = uart_index();\n  uartData = *(int *)(&DAT_20000318 + uartIndex * 4);\n  if ((uartIndex < 5) && (result = (**(code **)(&DAT_20000304 + uartIndex * 4))(uartData), result != -1)) {\n    transmitData_08005604ViaUART\n              ((&DAT_2000032c)[*(byte *)(uartData + 0x44)],\n               *(int *)(uartData + 100) + (uint)*(ushort *)(uartData + 0x6a),1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005604": "transmit_data_08005604",
                "uVar1": "uartIndex",
                "iVar2": "result",
                "iVar3": "uartData",
                "HAL_UART_Transmit_IT": "transmitDataViaUART"
            },
            "calling": [
                "UART_EndTransmit_IT"
            ],
            "called": [
                "uart_index",
                "HAL_UART_Transmit_IT"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005650": {
            "entrypoint": "0x08005650",
            "current_name": "FUNC_08005650",
            "code": "\nvoid FUNC_08005650(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005650": "FUNC_08005650"
            },
            "calling": [
                "HAL_UART_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080056d8": {
            "entrypoint": "0x080056d8",
            "current_name": "allocate_memory_080056d8",
            "code": "\nundefined * allocate_memory_080056d8(int size)\n\n{\n  undefined *allocated_memory;\n  \n  if (DAT_20000340 == (undefined *)0x0) {\n    DAT_20000340 = &DAT_200006a8;\n  }\n  allocated_memory = DAT_20000340;\n  if (DAT_20000340 + size <= &stack0x00000000) {\n    DAT_20000340 = DAT_20000340 + size;\n    return allocated_memory;\n  }\n  DAT_200006a4 = 0xc;\n  return (undefined *)0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080056d8": "allocate_memory_080056d8",
                "param_1": "size",
                "puVar1": "allocated_memory"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "set_return_value_08005714",
            "code": "\nundefined4 setReturnValue_08005714(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08005714": "set_return_value_08005714"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800571a": {
            "entrypoint": "0x0800571a",
            "current_name": "initialize_memory_allocation_0800571a",
            "code": "\nundefined4 initializeMemoryAllocation_0800571a(undefined4 param1,int memOffset)\n\n{\n  *(undefined4 *)(memOffset + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800571a": "initialize_memory_allocation_0800571a",
                "param_1": "param1",
                "param_2": "memOffset"
            },
            "calling": [
                "_fstat_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005724": {
            "entrypoint": "0x08005724",
            "current_name": "initialize_application_08005724",
            "code": "\nvoid initializeApplication_08005724(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005724": "initialize_application_08005724",
                "undefined4": "void"
            },
            "calling": [
                "_isatty_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "initialize_application_08005728",
            "code": "\nundefined4 initializeApplication_08005728(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005728": "initialize_application_08005728"
            },
            "calling": [
                "_lseek_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800572c": {
            "entrypoint": "0x0800572c",
            "current_name": "initialize_some_value_0800572c",
            "code": "\nundefined4 initializeSomeValue_0800572c(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800572c": "initialize_some_value_0800572c"
            },
            "calling": [
                "_read_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005730": {
            "entrypoint": "0x08005730",
            "current_name": "debug_output_08005730",
            "code": "\nvoid debug_output_08005730(undefined4 uint_param,undefined4 data_param,undefined4 length_param,undefined4 port_param)\n\n{\n  uart_debug_write(data_param,length_param,length_param,port_param,port_param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005730": "debug_output_08005730",
                "param_1": "uint_param",
                "param_2": "data_param",
                "param_3": "length_param",
                "param_4": "port_param"
            },
            "calling": [
                "__swrite"
            ],
            "called": [
                "uart_debug_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800573c": {
            "entrypoint": "0x0800573c",
            "current_name": "infinite_loop_0800573c",
            "code": "\nvoid infiniteLoop_0800573c(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800573c": "infinite_loop_0800573c"
            },
            "calling": [
                "_exit",
                "abort"
            ],
            "called": [
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005740": {
            "entrypoint": "0x08005740",
            "current_name": "initialize_data_08005740",
            "code": "\nundefined4 initializeData_08005740(void)\n\n{\n  DAT_200006a4 = 0x16;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08005740": "initialize_data_08005740"
            },
            "calling": [
                "raise"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005750": {
            "entrypoint": "0x08005750",
            "current_name": "initialize_08005750",
            "code": "\nvoid initialize_08005750(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08005750": "initialize_08005750",
                "undefined4": "void"
            },
            "calling": [
                "_getpid_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005754": {
            "entrypoint": "0x08005754",
            "current_name": "get_adc_value_08005754",
            "code": "\nuint get_adc_value_08005754(uint input_value)\n\n{\n  bool is_valid;\n  char char_value;\n  uint adc_value;\n  \n  if (input_value < 0xe) {\n    if (input_value + 0x2e < 0x3c) {\n      is_valid = true;\n    }\n    else {\n      is_valid = false;\n    }\n  }\n  else {\n    is_valid = input_value < 0x3c;\n  }\n  if (is_valid) {\n    if (input_value < 0xe) {\n      input_value = input_value + 0x2e;\n    }\n    char_value = (&DAT_080076f0)[input_value];\n  }\n  else {\n    char_value = -1;\n  }\n  if (char_value == -1) {\n    adc_value = 0;\n  }\n  else {\n    adc_value = adc_read_value();\n    if (DAT_200000f4 != 0xc) {\n      if (DAT_200000f4 < 0xc) {\n        return adc_value >> (0xc - DAT_200000f4 & 0xff);\n      }\n      return adc_value << (DAT_200000f4 - 0xc & 0xff);\n    }\n  }\n  return adc_value;\n}\n\n",
            "renaming": {
                "FUN_08005754": "get_adc_value_08005754",
                "param_1": "input_value",
                "bVar1": "is_valid",
                "cVar2": "char_value",
                "uVar3": "adc_value"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "adc_read_value"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057b4": {
            "entrypoint": "0x080057b4",
            "current_name": "configure_and_init_pin_080057b4",
            "code": "\nvoid configureAndInitPin_080057b4(uint pinIndex,undefined4 digitalIOOption,undefined4 option3,undefined *pinConfig)\n\n{\n  int isPinConfigured;\n  undefined *pinData;\n  int pinValue;\n  \n  if (pinIndex < 0x3c) {\n    pinValue = (int)(char)(&DAT_080076f0)[pinIndex];\n    pinData = &DAT_080076f0;\n  }\n  else {\n    pinValue = -1;\n    pinData = pinConfig;\n  }\n  if (pinValue != -1) {\n    isPinConfigured = is_pin_configured(pinValue,&DAT_20000344,option3,pinData,pinConfig);\n    if (isPinConfigured != 0) {\n      isPinConfigured = pin_in_pinmap(pinValue,&DAT_080074b4);\n      if (isPinConfigured != 0) {\n        pwm_stop(pinValue);\n      }\n      reset_pin_configured(pinValue,&DAT_20000344);\n    }\n    switch(digitalIOOption) {\n    case 0:\n      digital_io_init(pinValue,0);\n      break;\n    case 1:\n      digital_io_init(pinValue,1,0);\n      break;\n    case 2:\n      digital_io_init(pinValue,0,1);\n      break;\n    case 3:\n      digital_io_init(pinValue,0,2);\n    }\n    set_pin_configured(pinValue,&DAT_20000358);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057b4": "configure_and_init_pin_080057b4",
                "param_1": "pinIndex",
                "param_2": "digitalIOOption",
                "param_3": "option3",
                "param_4": "pinConfig",
                "iVar1": "isPinConfigured",
                "puVar2": "pinData",
                "iVar3": "pinValue"
            },
            "calling": [
                "setup",
                "MAX31855",
                "FUN_080013a4"
            ],
            "called": [
                "reset_pin_configured",
                "pin_in_pinmap",
                "digital_io_init",
                "pwm_stop",
                "set_pin_configured",
                "is_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005848": {
            "entrypoint": "0x08005848",
            "current_name": "configure_pin_and_write_08005848",
            "code": "\nvoid configure_pin_and_write_08005848(uint pin_index,undefined4 value,undefined4 config_param,undefined *pin_config_array)\n\n{\n  int config_result;\n  undefined4 gpio_port;\n  undefined *pin_base;\n  uint pin_value;\n  \n  if (pin_index < 0x3c) {\n    pin_value = (uint)(char)(&DAT_080076f0)[pin_index];\n    pin_base = &DAT_080076f0;\n  }\n  else {\n    pin_value = 0xffffffff;\n    pin_base = pin_config_array;\n  }\n  if ((pin_value != 0xffffffff) &&\n     (config_result = is_pin_configured(pin_value,&DAT_20000358,config_param,pin_base,pin_config_array), config_result != 0)) {\n    gpio_port = get_GPIO_Port((pin_value << 0x18) >> 0x1c);\n    digital_io_write(gpio_port,1 << (pin_value & 0xf) & 0xffff,value);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005848": "configure_pin_and_write_08005848",
                "param_1": "pin_index",
                "param_2": "value",
                "param_3": "config_param",
                "param_4": "pin_config_array",
                "iVar1": "config_result",
                "uVar2": "gpio_port",
                "puVar3": "pin_base",
                "uVar4": "pin_value"
            },
            "calling": [
                "setup",
                "readData",
                "MAX31855",
                "pulseEnable",
                "FUN_080013a4",
                "write8bits",
                "write4bits",
                "loop",
                "send"
            ],
            "called": [
                "get_GPIO_Port",
                "digital_io_write",
                "is_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005890": {
            "entrypoint": "0x08005890",
            "current_name": "check_gpio_status_08005890",
            "code": "\nchar checkGPIOStatus_08005890(uint pinNumber)\n\n{\n  char status;\n  int isConfigured;\n  undefined4 GPIO_Port;\n  uint pinValue;\n  \n  if (pinNumber < 0x3c) {\n    pinValue = (uint)(char)(&DAT_080076f0)[pinNumber];\n  }\n  else {\n    pinValue = 0xffffffff;\n  }\n  if (pinValue == 0xffffffff) {\n    status = '\\0';\n  }\n  else {\n    isConfigured = is_pin_configured(pinValue,&DAT_20000358);\n    if (isConfigured == 0) {\n      status = '\\0';\n    }\n    else {\n      GPIO_Port = get_GPIO_Port((pinValue << 0x18) >> 0x1c);\n      status = digital_io_read(GPIO_Port,1 << (pinValue & 0xf) & 0xffff);\n    }\n  }\n  if (status != '\\0') {\n    status = '\\x01';\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08005890": "check_gpio_status_08005890",
                "param_1": "pinNumber",
                "cVar1": "status",
                "iVar2": "isConfigured",
                "uVar3": "GPIO_Port",
                "uVar4": "pinValue"
            },
            "calling": [
                "readData",
                "loop"
            ],
            "called": [
                "digital_io_read",
                "get_GPIO_Port",
                "is_pin_configured"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e0": {
            "entrypoint": "0x080058e0",
            "current_name": "get_current_time_in_millis_080058e0",
            "code": "\nvoid getCurrentTimeInMillis_080058e0(void)\n\n{\n  GetCurrentMilli();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058e0": "get_current_time_in_millis_080058e0"
            },
            "calling": [
                "setup",
                "Compute",
                "FUN_08001ab0",
                "loop"
            ],
            "called": [
                "GetCurrentMilli"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080058e8": {
            "entrypoint": "0x080058e8",
            "current_name": "FUNC_080058e8",
            "code": "\nvoid FUNC_080058e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080058e8": "FUNC_080058e8"
            },
            "calling": [
                "setup"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800591e": {
            "entrypoint": "0x0800591e",
            "current_name": "calculate_offset_0800591e",
            "code": "\nushort calculateOffset_0800591e(int memoryLocation)\n\n{\n  return (*(short *)(memoryLocation + 0x134) + 0x40) - *(short *)(memoryLocation + 0x136) & 0x3f;\n}\n\n",
            "renaming": {
                "FUN_0800591e": "calculate_offset_0800591e",
                "param_1": "memoryLocation"
            },
            "calling": [
                "serialEventRun"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800598a": {
            "entrypoint": "0x0800598a",
            "current_name": "process_uart_input_0800598a",
            "code": "\nvoid process_uart_input_0800598a(int uart_port)\n\n{\n  int input_result;\n  ushort next_index;\n  undefined input_char;\n  \n  input_result = uart_getc(uart_port,&input_char);\n  if ((input_result == 0) &&\n     (next_index = *(short *)(uart_port + 0x60) + 1U & 0x3f, next_index != *(ushort *)(uart_port + 0x62))) {\n    *(undefined *)(*(int *)(uart_port + 0x5c) + (uint)*(ushort *)(uart_port + 0x60)) = input_char;\n    *(ushort *)(uart_port + 0x60) = next_index;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800598a": "process_uart_input_0800598a",
                "param_1": "uart_port",
                "iVar1": "input_result",
                "uVar2": "next_index",
                "local_9": "input_char"
            },
            "calling": [],
            "called": [
                "uart_getc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a18": {
            "entrypoint": "0x08005a18",
            "current_name": "FUNC_08005a18",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005a1e) */\n/* WARNING: Removing unreachable block (ram,0x08005a30) */\n/* WARNING: Removing unreachable block (ram,0x08005a26) */\n/* WARNING: Removing unreachable block (ram,0x08005a38) */\n\nvoid FUNC_08005a18(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a18": "FUNC_08005a18"
            },
            "calling": [
                "main"
            ],
            "called": [
                "available"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005a44": {
            "entrypoint": "0x08005a44",
            "current_name": "initialize_function_08005a44",
            "code": "\nvoid initializeFunction_08005a44(int functionParameter)\n\n{\n  *(int *)(functionParameter + 0x130) = functionParameter + 0x11;\n  *(undefined2 *)(functionParameter + 0x134) = 0;\n  *(undefined2 *)(functionParameter + 0x136) = 0;\n  *(int *)(functionParameter + 0x138) = functionParameter + 0x51;\n  *(undefined2 *)(functionParameter + 0x13c) = 0;\n  *(undefined2 *)(functionParameter + 0x13e) = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a44": "initialize_function_08005a44",
                "param_1": "functionParameter"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005a68": {
            "entrypoint": "0x08005a68",
            "current_name": "initialize_serial_port_08005a68",
            "code": "\nvoid initializeSerialPort_08005a68(int serialPortAddress,undefined4 baudRate,byte configuration)\n\n{\n  uint extraOutputReg1;\n  char *errorMessage;\n  byte configurationFlags;\n  int dataFormat;\n  byte *bytePointer;\n  char unaffectedReg4;\n  int unaffectedReg6;\n  code *jumpTable;\n  \n  *(undefined4 *)(serialPortAddress + 0x11c) = baudRate;\n  *(byte *)(serialPortAddress + 0x140) = configuration;\n  configurationFlags = configuration & 7;\n  if (configurationFlags == 4) {\n    dataFormat = 7;\n  }\n  else if (configurationFlags == 6) {\n    dataFormat = 8;\n  }\n  else if (configurationFlags == 2) {\n    dataFormat = 6;\n  }\n  else {\n    dataFormat = 0;\n  }\n  if ((configuration & 0x30) == 0x30) {\n    *(undefined4 *)(serialPortAddress + 0x128) = 0x600;\n    dataFormat = dataFormat + 1;\n  }\n  else if ((configuration & 0x20) == 0) {\n    *(undefined4 *)(serialPortAddress + 0x128) = 0;\n  }\n  else {\n    *(undefined4 *)(serialPortAddress + 0x128) = 0x400;\n    dataFormat = dataFormat + 1;\n  }\n  if ((configuration & 8) == 0) {\n    *(undefined4 *)(serialPortAddress + 0x124) = 0;\n  }\n  else {\n    *(undefined4 *)(serialPortAddress + 0x124) = 0x2000;\n  }\n  if (dataFormat == 8) {\n    *(undefined4 *)(serialPortAddress + 0x120) = 0;\n  }\n  else if (dataFormat == 9) {\n    *(undefined4 *)(serialPortAddress + 0x120) = 0x1000;\n  }\n  else {\n    dataFormat = 0;\n  }\n  if (dataFormat != 0) {\n    uart_init(serialPortAddress + 0xd4);\n    uart_attach_rx_callback(serialPortAddress + 0xd4,0x800598b);\n    return;\n  }\n  errorMessage = \"void HardwareSerial::begin(long unsigned int, byte)\";\n  jumpTable = (code *)0x8005b12;\n  __assert_func(\"/home/bo/.arduino15/packages/STM32/hardware/stm32/1.3.0/cores/arduino/HardwareSerial.cpp\"\n                ,299,\"void HardwareSerial::begin(long unsigned int, byte)\",\"databits!=0\");\n  bytePointer = *(byte **)(extraOutputReg1 + unaffectedReg6);\n  errorMessage[0x1e] = unaffectedReg4;\n  *(undefined *)(*bytePointer + 0x1e) = 0;\n  if (extraOutputReg1 < 0x3c) {\n    uRam0000012d = (&DAT_080076f0)[extraOutputReg1];\n  }\n  else {\n    uRam0000012d = 0xff;\n  }\n                    /* WARNING: Could not recover jumptable at 0x08005b30. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005a68": "initialize_serial_port_08005a68",
                "param_1": "serialPortAddress",
                "param_2": "baudRate",
                "param_3": "configuration",
                "extraout_r1": "extraOutputReg1",
                "pcVar1": "errorMessage",
                "bVar2": "configurationFlags",
                "iVar3": "dataFormat",
                "pbVar4": "bytePointer",
                "unaff_r4": "unaffectedReg4",
                "unaff_r6": "unaffectedReg6",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "setup"
            ],
            "called": [
                "uart_attach_rx_callback",
                "uart_init",
                "__assert_func"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b24": {
            "entrypoint": "0x08005b24",
            "current_name": "set_op_code_08005b24",
            "code": "\nvoid setOpCode_08005b24(int address,uint opcodeValue)\n\n{\n  undefined opcode;\n  code *jumpTable;\n  \n  if (opcodeValue < 0x3c) {\n    opcode = (&DAT_080076f0)[opcodeValue];\n  }\n  else {\n    opcode = 0xff;\n  }\n  *(undefined *)(address + 0x12d) = opcode;\n                    /* WARNING: Could not recover jumptable at 0x08005b30. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b24": "set_op_code_08005b24",
                "param_1": "address",
                "param_2": "opcodeValue",
                "uVar1": "opcode",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b3c": {
            "entrypoint": "0x08005b3c",
            "current_name": "copy_byte_to_offset_08005b3c",
            "code": "\nvoid copyByteToOffset_08005b3c(int offset,uint index)\n\n{\n  undefined value;\n  \n  if (index < 0x3c) {\n    value = (&DAT_080076f0)[index];\n  }\n  else {\n    value = 0xff;\n  }\n  *(undefined *)(offset + 300) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005b3c": "copy_byte_to_offset_08005b3c",
                "param_1": "offset",
                "param_2": "index",
                "uVar1": "value"
            },
            "calling": [
                "HardwareSerial"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005b54": {
            "entrypoint": "0x08005b54",
            "current_name": "initialize_communication_08005b54",
            "code": "\nundefined4 *\ninitializeCommunication_08005b54(undefined4 *communicationBuffer,undefined4 pin,undefined4 param3Value,undefined4 param4Value)\n\n{\n  undefined pinMappedValue;\n  \n  communicationBuffer[1] = 0;\n  communicationBuffer[2] = 1000;\n  *communicationBuffer = &PTR_LAB_080059c8_1_08007804;\n  if (communicationBuffer == (undefined4 *)&DAT_2000036c) {\n    setReceivingMode(&DAT_2000036c,0,param3Value,&DAT_2000036c,param4Value);\n    setTransmittingMode(&DAT_2000036c,1);\n  }\n  else {\n    pinMappedValue = pinmap_pin(pin,&DAT_08007604);\n    *(undefined *)((int)communicationBuffer + 0x12d) = pinMappedValue;\n    pinMappedValue = pinmap_pin(pin,&DAT_0800764c);\n    *(undefined *)(communicationBuffer + 0x4b) = pinMappedValue;\n  }\n  initialize(communicationBuffer);\n  return communicationBuffer;\n}\n\n",
            "renaming": {
                "FUN_08005b54": "initialize_communication_08005b54",
                "param_1": "communicationBuffer",
                "param_2": "pin",
                "param_3": "param3Value",
                "param_4": "param4Value",
                "uVar1": "pinMappedValue",
                "setRx": "setReceivingMode",
                "setTx": "setTransmittingMode",
                "init": "initialize"
            },
            "calling": [
                "FUN_08005bb0"
            ],
            "called": [
                "init",
                "pinmap_pin",
                "setRx",
                "setTx"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005bb0": {
            "entrypoint": "0x08005bb0",
            "current_name": "initialize_serial_communication_08005bb0",
            "code": "\nvoid initializeSerialCommunication_08005bb0(int mode,int baudRate,undefined4 dataBits,undefined4 stopBits)\n\n{\n  if (mode != 1) {\n    return;\n  }\n  if (baudRate == 0xffff) {\n    HardwareSerial(&DAT_2000036c,0x40004400,dataBits,0xffff,stopBits);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005bb0": "initialize_serial_communication_08005bb0",
                "param_1": "mode",
                "param_2": "baudRate",
                "param_3": "dataBits",
                "param_4": "stopBits"
            },
            "calling": [],
            "called": [
                "HardwareSerial"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c1c": {
            "entrypoint": "0x08005c1c",
            "current_name": "initialize_data_08005c1c",
            "code": "\nvoid initializeData_08005c1c(undefined4 *dataPointer,undefined value1,undefined value2,undefined value3,\n                 undefined value4)\n\n{\n  *dataPointer = &DAT_08007858;\n  *(undefined *)(dataPointer + 1) = value1;\n  *(undefined *)((int)dataPointer + 5) = value2;\n  *(undefined *)((int)dataPointer + 6) = value3;\n  *(undefined *)((int)dataPointer + 7) = value4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c1c": "initialize_data_08005c1c",
                "param_1": "dataPointer",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "param_5": "value4"
            },
            "calling": [
                "FUN_08005c38"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c38": {
            "entrypoint": "0x08005c38",
            "current_name": "initialize_ip_address_08005c38",
            "code": "\nvoid initializeIPAddress_08005c38(int flag,int value)\n\n{\n  if ((flag == 1) && (value == 0xffff)) {\n    IPAddress(&DAT_200004b0,0,0,0,0);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005c38": "initialize_ip_address_08005c38",
                "param_1": "flag",
                "param_2": "value"
            },
            "calling": [],
            "called": [
                "IPAddress"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005c96": {
            "entrypoint": "0x08005c96",
            "current_name": "process_param_08005c96",
            "code": "\nundefined4 processParam_08005c96(int *paramArray,int paramLength,undefined4 paramA,undefined4 paramB)\n\n{\n  undefined4 stringLength;\n  \n  if (paramLength != 0) {\n    stringLength = strlen(paramLength);\n    stringLength = (**(code **)(*paramArray + 4))(paramArray,paramLength,stringLength,*(code **)(*paramArray + 4),paramB);\n    return stringLength;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08005c96": "process_param_08005c96",
                "param_1": "paramArray",
                "param_2": "paramLength",
                "param_3": "paramA",
                "param_4": "paramB",
                "uVar1": "stringLength"
            },
            "calling": [
                "setup",
                "printFloat",
                "FUN_08005cd4",
                "loop"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cb6": {
            "entrypoint": "0x08005cb6",
            "current_name": "execute_code_function_08005cb6",
            "code": "\nvoid execute_code_function_08005cb6(undefined4 *function_pointer)\n\n{\n  (**(code **)*function_pointer)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005cb6": "execute_code_function_08005cb6",
                "param_1": "function_pointer"
            },
            "calling": [
                "printFloat",
                "FUN_08005d42"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cc0": {
            "entrypoint": "0x08005cc0",
            "current_name": "execute_callback_08005cc0",
            "code": "\nvoid executeCallback_08005cc0(int *callbackFunction,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  (**(code **)(*callbackFunction + 4))(callbackFunction,&DAT_0800786c,2,*(code **)(*callbackFunction + 4),arg3);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005cc0": "execute_callback_08005cc0",
                "param_1": "callbackFunction",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3"
            },
            "calling": [
                "println",
                "FUN_08005cd4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005cd4": {
            "entrypoint": "0x08005cd4",
            "current_name": "calculate_sum_08005cd4",
            "code": "\nint calculate_sum_08005cd4(undefined4 input_param)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = process_param_08005c96();\n  result2 = execute_callback_08005cc0(input_param);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_08005cd4": "calculate_sum_08005cd4",
                "param_1": "input_param",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "FUN_08005cc0",
                "FUN_08005c96"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005ce8": {
            "entrypoint": "0x08005ce8",
            "current_name": "convert_base_08005ce8",
            "code": "\nundefined4 convert_base_08005ce8(int *array_ptr,uint value,uint base)\n\n{\n  char converted_digit;\n  undefined4 result;\n  uint remainder;\n  uint quotient;\n  char *digit_ptr;\n  char converted_value [9];\n  \n  converted_value[1] = 0;\n  if ((int)base < 2) {\n    base = 10;\n  }\n  digit_ptr = converted_value + 1;\n  do {\n    quotient = value / base;\n    remainder = (value & 0xff) - (quotient * base & 0xff) & 0xff;\n    digit_ptr = digit_ptr + -1;\n    converted_digit = (char)remainder;\n    if (remainder < 10) {\n      converted_digit = converted_digit + '0';\n    }\n    else {\n      converted_digit = converted_digit + '7';\n    }\n    *digit_ptr = converted_digit;\n    value = quotient;\n  } while (quotient != 0);\n  if (digit_ptr == (char *)0x0) {\n    result = 0;\n  }\n  else {\n    result = strlen(digit_ptr);\n    result = (**(code **)(*array_ptr + 4))(array_ptr,digit_ptr,result);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08005ce8": "convert_base_08005ce8",
                "param_1": "array_ptr",
                "param_2": "value",
                "param_3": "base",
                "cVar1": "converted_digit",
                "uVar2": "result",
                "uVar3": "remainder",
                "uVar4": "quotient",
                "pcVar5": "digit_ptr",
                "local_15": "converted_value"
            },
            "calling": [
                "FUN_08005d8a",
                "FUN_08005d42"
            ],
            "called": [
                "strlen"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d42": {
            "entrypoint": "0x08005d42",
            "current_name": "print_number_or_execute_code_08005d42",
            "code": "\nint printNumberOrExecuteCode_08005d42(undefined4 *pointer,uint number,uint base)\n\n{\n  int result;\n  int negResult;\n  \n  if (base == 0) {\n    result = (**(code **)*pointer)(pointer,number & 0xff);\n    return result;\n  }\n  if (base != 10) {\n    result = printNumber(pointer,number,base & 0xff);\n    return result;\n  }\n  if (-1 < (int)number) {\n    result = printNumber(pointer,number,10);\n    return result;\n  }\n  result = execute_code_function_08005cb6(pointer,0x2d);\n  negResult = printNumber(pointer,-number,10);\n  return negResult + result;\n}\n\n",
            "renaming": {
                "FUN_08005d42": "print_number_or_execute_code_08005d42",
                "param_1": "pointer",
                "param_2": "number",
                "param_3": "base",
                "iVar1": "result",
                "iVar2": "negResult"
            },
            "calling": [
                "FUN_08005d82"
            ],
            "called": [
                "FUN_08005cb6",
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d82": {
            "entrypoint": "0x08005d82",
            "current_name": "execute_print_or_code_08005d82",
            "code": "\nvoid execute_print_or_code_08005d82(void)\n\n{\n  print_or_execute();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d82": "execute_print_or_code_08005d82",
                "print_number_or_execute_code_08005d42": "print_or_execute"
            },
            "calling": [
                "printFloat",
                "loop"
            ],
            "called": [
                "FUN_08005d42"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d8a": {
            "entrypoint": "0x08005d8a",
            "current_name": "print_number_or_call_code_08005d8a",
            "code": "\nvoid printNumberOrCallCode_08005d8a(undefined4 *functionPointer,uint valueA,uint valueB,undefined4 valueC)\n\n{\n  if (valueB != 0) {\n    printNumber(functionPointer,valueA,valueB & 0xff);\n    return;\n  }\n  (**(code **)*functionPointer)(functionPointer,valueA & 0xff,0,*(code **)*functionPointer,valueC);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d8a": "print_number_or_call_code_08005d8a",
                "param_1": "functionPointer",
                "param_2": "valueA",
                "param_3": "valueB",
                "param_4": "valueC"
            },
            "calling": [
                "printFloat"
            ],
            "called": [
                "printNumber"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005da8": {
            "entrypoint": "0x08005da8",
            "current_name": "process_number_08005da8",
            "code": "\nint processNumber_08005da8(undefined4 input,undefined4 unknown1,undefined4 unknown2,uint num1,byte num2)\n\n{\n  int result1;\n  undefined4 result2;\n  int result3;\n  byte counter;\n  undefined8 temp1;\n  undefined8 temp2;\n  \n  result1 = __unorddf2(unknown2,num1,unknown2,num1);\n  if (result1 == 0) {\n    result1 = __unorddf2(unknown2,num1 & 0x7fffffff,0xffffffff,0x7fefffff);\n    if ((result1 == 0) &&\n       (result1 = __aeabi_dcmple(unknown2,num1 & 0x7fffffff,0xffffffff,0x7fefffff), result1 == 0)) {\n      result1 = process_param_08005c96(input,&DAT_08007860);\n    }\n    else {\n      result1 = __aeabi_dcmpgt(unknown2,num1,0xe0000000,0x41efffff);\n      if (result1 == 0) {\n        result1 = __aeabi_dcmplt(unknown2,num1,0xe0000000,0xc1efffff);\n        if (result1 == 0) {\n          result1 = __aeabi_dcmplt(unknown2,num1,0,0);\n          if (result1 == 0) {\n            result1 = 0;\n          }\n          else {\n            result1 = execute_code_function_08005cb6(input,0x2d);\n            num1 = num1 + 0x80000000;\n          }\n          temp1 = 0x3fe0000000000000;\n          for (counter = 0; result2 = (undefined4)((ulonglong)temp1 >> 0x20), counter < num2;\n              counter = counter + 1) {\n            temp1 = __divdf3((int)temp1,result2,0,0x40240000);\n          }\n          temp1 = __aeabi_dadd(unknown2,num1,(int)temp1,result2);\n          result2 = __fixunsdfsi();\n          temp2 = __floatunsidf();\n          temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                           (int)((ulonglong)temp2 >> 0x20));\n          result3 = print_number_or_call_code_08005d8a(input,result2,10);\n          result1 = result1 + result3;\n          if (num2 != 0) {\n            result3 = process_param_08005c96(input,&DAT_08007868);\n            result1 = result1 + result3;\n          }\n          while (num2 != 0) {\n            temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40240000);\n            result2 = __fixdfsi();\n            result3 = execute_print_or_code_08005d82(input,result2,10);\n            result1 = result1 + result3;\n            temp2 = __floatsidf(result2);\n            temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                             (int)((ulonglong)temp2 >> 0x20));\n            num2 = num2 - 1;\n          }\n        }\n        else {\n          result1 = process_param_08005c96(input,&DAT_08007864);\n        }\n      }\n      else {\n        result1 = process_param_08005c96(input,&DAT_08007864);\n      }\n    }\n  }\n  else {\n    result1 = process_param_08005c96(input,&DAT_0800785c);\n  }\n  return result1;\n}\n\n",
            "renaming": {
                "FUN_08005da8": "process_number_08005da8",
                "param_1": "input",
                "param_2": "unknown1",
                "param_3": "unknown2",
                "param_4": "num1",
                "param_5": "num2",
                "iVar1": "result1",
                "uVar2": "result2",
                "iVar3": "result3",
                "bVar4": "counter",
                "uVar5": "temp1",
                "uVar6": "temp2"
            },
            "calling": [
                "print"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__fixdfsi",
                "__floatsidf",
                "FUN_08005d8a",
                "__aeabi_dcmpgt",
                "FUN_08005d82",
                "__muldf3",
                "__aeabi_dadd",
                "FUN_08005cb6",
                "__subdf3",
                "__aeabi_dcmple",
                "__divdf3",
                "__fixunsdfsi",
                "__unorddf2",
                "FUN_08005c96",
                "__floatunsidf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f2c": {
            "entrypoint": "0x08005f2c",
            "current_name": "print_float_wrapper_08005f2c",
            "code": "\nvoid printFloatWrapper_08005f2c(void)\n\n{\n  printFloat();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f2c": "print_float_wrapper_08005f2c"
            },
            "calling": [
                "println",
                "loop"
            ],
            "called": [
                "printFloat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f40": {
            "entrypoint": "0x08005f40",
            "current_name": "calculate_sum_08005f40",
            "code": "\nint calculateSum_08005f40(undefined4 input)\n\n{\n  int printResult;\n  int callbackResult;\n  \n  printResult = print();\n  callbackResult = execute_callback_08005cc0(input);\n  return callbackResult + printResult;\n}\n\n",
            "renaming": {
                "FUN_08005f40": "calculate_sum_08005f40",
                "param_1": "input",
                "iVar1": "printResult",
                "iVar2": "callbackResult"
            },
            "calling": [
                "loop"
            ],
            "called": [
                "FUN_08005cc0",
                "print"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5c": {
            "entrypoint": "0x08005f5c",
            "current_name": "FUNC_08005f5c",
            "code": "\nvoid FUNC_08005f5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5c": "FUNC_08005f5c"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005f5e": {
            "entrypoint": "0x08005f5e",
            "current_name": "configure_hardware_08005f5e",
            "code": "\nvoid configureHardware_08005f5e(void)\n\n{\n  setPriorityGrouping(3);\n  initializeHardwareConfiguration();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005f5e": "configure_hardware_08005f5e",
                "initialize_hardware_configuration_08001c32": "initializeHardwareConfiguration",
                "HAL_NVIC_SetPriorityGrouping": "setPriorityGrouping"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "FUN_08001c32",
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f6c": {
            "entrypoint": "0x08005f6c",
            "current_name": "initialize_and_run_08005f6c",
            "code": "\nvoid initializeAndRun_08005f6c(void)\n\n{\n  initializeVariant();\n  performSetup();\n  do {\n    executeLoop();\n    runSerialEvent();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005f6c": "initialize_and_run_08005f6c",
                "initVariant": "initializeVariant",
                "setup": "performSetup",
                "loop": "executeLoop",
                "serialEventRun": "runSerialEvent"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "initVariant",
                "setup",
                "serialEventRun",
                "loop"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005f8c": {
            "entrypoint": "0x08005f8c",
            "current_name": "count_set_bits_08005f8c",
            "code": "\nchar countSetBits_08005f8c(uint number)\n\n{\n  char bitCount;\n  \n  bitCount = '\\0';\n  for (; number != 1; number = number >> 1) {\n    bitCount = bitCount + '\\x01';\n  }\n  return bitCount;\n}\n\n",
            "renaming": {
                "FUN_08005f8c": "count_set_bits_08005f8c",
                "param_1": "number",
                "cVar1": "bitCount"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005fc8": {
            "entrypoint": "0x08005fc8",
            "current_name": "initialize_data_08005fc8",
            "code": "\nvoid initializeData_08005fc8(int status,int value,undefined4 unused_1,undefined4 unused_2)\n\n{\n  if (status != 1) {\n    return;\n  }\n  if (value == 0xffff) {\n    DAT_200004b8 = 6;\n    DAT_200004c4 = 0;\n    DAT_200004cc = 7;\n    DAT_200004d8 = 0;\n    DAT_200004e0 = 8;\n    DAT_200004ec = 0;\n    DAT_200004f4 = 9;\n    DAT_20000500 = 0;\n    DAT_20000508 = 10;\n    DAT_20000514 = 0;\n    DAT_2000051c = 0x17;\n    DAT_20000528 = 0;\n    DAT_20000530 = 0x17;\n    DAT_2000053c = 0;\n    DAT_20000544 = 0x17;\n    DAT_20000550 = 0;\n    DAT_20000558 = 0x17;\n    DAT_20000564 = 0;\n    DAT_2000056c = 0x17;\n    DAT_20000578 = 0;\n    DAT_20000580 = 0x28;\n    DAT_2000058c = 0;\n    DAT_20000594 = 0x28;\n    DAT_200005a0 = 0;\n    DAT_200005a8 = 0x28;\n    DAT_200005b4 = 0;\n    DAT_200005bc = 0x28;\n    DAT_200005c8 = 0;\n    DAT_200005d0 = 0x28;\n    DAT_200005dc = 0;\n    DAT_200005e4 = 0x28;\n    DAT_200005f0 = 0;\n    registerCleanupFunction(0,functionPointer_1,&DAT_20000000,&DAT_200004b8,unused_2);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005fc8": "initialize_data_08005fc8",
                "param_1": "status",
                "param_2": "value",
                "param_3": "unused_1",
                "param_4": "unused_2",
                "__aeabi_atexit": "registerCleanupFunction",
                "&LAB_08005fa0_1": "functionPointer_1"
            },
            "calling": [],
            "called": [
                "__aeabi_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060d4": {
            "entrypoint": "0x080060d4",
            "current_name": "check_and_execute_080060d4",
            "code": "\nvoid checkAndExecute_080060d4(int input)\n\n{\n  int pinId;\n  \n  if (*(int *)(input + 8) != 0) {\n    (**(code **)(input + 0xc))();\n    return;\n  }\n  __throw_bad_function_call();\n  pinId = get_pin_id();\n  if ((&DAT_200004c4)[pinId * 5] != 0) {\n    checkAndExecute_080060d4();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060d4": "check_and_execute_080060d4",
                "param_1": "input",
                "iVar1": "pinId"
            },
            "calling": [
                "HAL_GPIO_EXTI_Callback"
            ],
            "called": [
                "__throw_bad_function_call"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080060e4": {
            "entrypoint": "0x080060e4",
            "current_name": "check_pin_and_invoke_operator_080060e4",
            "code": "\nvoid checkPinAndInvokeOperator_080060e4(void)\n\n{\n  int pinId;\n  \n  pinId = getPinId();\n  if ((&DAT_200004c4)[pinId * 5] != 0) {\n    invokeOperator();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080060e4": "check_pin_and_invoke_operator_080060e4",
                "iVar1": "pinId",
                "get_pin_id": "getPinId",
                "operator()": "invokeOperator"
            },
            "calling": [
                "HAL_GPIO_EXTI_IRQHandler"
            ],
            "called": [
                "get_pin_id",
                "operator()"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006112": {
            "entrypoint": "0x08006112",
            "current_name": "register_cleanup_function_08006112",
            "code": "\nvoid registerCleanupFunction_08006112(undefined4 cleanupFunction,undefined4 cleanupData)\n\n{\n  __cxa_atexit(cleanupData,cleanupFunction);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006112": "register_cleanup_function_08006112",
                "param_1": "cleanupFunction",
                "param_2": "cleanupData"
            },
            "calling": [
                "__static_initialization_and_destruction_0"
            ],
            "called": [
                "__cxa_atexit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800611c": {
            "entrypoint": "0x0800611c",
            "current_name": "print_assertion_error_0800611c",
            "code": "\nvoid printAssertionError_0800611c(undefined4 file,undefined4 line,char *message,undefined4 function)\n\n{\n  undefined4 fileHandle;\n  char *prefix;\n  undefined8 result;\n  undefined4 functionArg;\n  \n  fileHandle = *(undefined4 *)(DAT_200000f8 + 0xc);\n  functionArg = function;\n  if (message == (char *)0x0) goto LAB_08006140;\n  prefix = \", function: \";\n  do {\n    fiprintf(fileHandle,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",function,file,line,\n             prefix,message,functionArg);\n    result = abort();\n    line = (undefined4)((ulonglong)result >> 0x20);\n    fileHandle = (undefined4)result;\nLAB_08006140:\n    message = \"\";\n    prefix = message;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_0800611c": "print_assertion_error_0800611c",
                "param_1": "file",
                "param_2": "line",
                "param_3": "message",
                "param_4": "function",
                "uVar1": "fileHandle",
                "pcVar2": "prefix",
                "uVar3": "result",
                "uVar4": "functionArg"
            },
            "calling": [
                "begin"
            ],
            "called": [
                "abort",
                "fiprintf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006158": {
            "entrypoint": "0x08006158",
            "current_name": "left_shift_64bit_08006158",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006160) */\n\nlonglong left_shift_64bit_08006158(undefined4 unused_param,uint input_value)\n\n{\n  return (unsigned_long_long)input_value << 0x20;\n}\n\n",
            "renaming": {
                "FUN_08006158": "left_shift_64bit_08006158",
                "param_1": "unused_param",
                "param_2": "input_value",
                "ulonglong": "unsigned_long_long"
            },
            "calling": [
                "__aeabi_atexit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006174": {
            "entrypoint": "0x08006174",
            "current_name": "printf_wrapper_08006174",
            "code": "\nvoid printfWrapper_08006174(undefined4 formatString,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  undefined4 arg2Copy;\n  undefined4 arg3Copy;\n  \n  arg2Copy = arg2;\n  arg3Copy = arg3;\n  _vfiprintf_r(DAT_200000f8,formatString,arg1,&arg2Copy,formatString,&arg2Copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006174": "printf_wrapper_08006174",
                "param_1": "formatString",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "uStack_8": "arg2Copy",
                "uStack_4": "arg3Copy"
            },
            "calling": [
                "__assert_func"
            ],
            "called": [
                "_vfiprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006198": {
            "entrypoint": "0x08006198",
            "current_name": "execute_functions_08006198",
            "code": "\nvoid executeFunctions_08006198(void)\n\n{\n  int index;\n  \n  for (index = 0; index != 0; index = index + 1) {\n    (*(code *)(&DAT_08007944)[index])();\n  }\n  _init();\n  for (index = 0; index != 10; index = index + 1) {\n    (*(code *)(&DAT_08007944)[index])();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006198": "execute_functions_08006198",
                "iVar1": "index"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "premain",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061e0": {
            "entrypoint": "0x080061e0",
            "current_name": "initialize_memory_block_080061e0",
            "code": "\nvoid initializeMemoryBlock_080061e0(undefined *memoryBlock,undefined initialValue,int blockSize)\n\n{\n  undefined *endOfBlock;\n  \n  endOfBlock = memoryBlock + blockSize;\n  for (; memoryBlock != endOfBlock; memoryBlock = memoryBlock + 1) {\n    *memoryBlock = initialValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080061e0": "initialize_memory_block_080061e0",
                "param_1": "memoryBlock",
                "param_2": "initialValue",
                "param_3": "blockSize",
                "puVar1": "endOfBlock"
            },
            "calling": [
                "std.isra.0",
                "adc_read_value",
                "__sfp",
                "__sfmoreglue"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080061f0": {
            "entrypoint": "0x080061f0",
            "current_name": "allocate_memory_080061f0",
            "code": "\nvoid allocateMemory_080061f0(undefined4 *outputPtr,int size,undefined4 param3,undefined4 param4)\n\n{\n  int **tempPtr;\n  int **firstPtr;\n  int **currentPtr;\n  int *temp1;\n  int **previousPtr;\n  int **newPtr;\n  \n  if (size == 0) {\n    return;\n  }\n  newPtr = (int **)(size + -4);\n  if (*(int *)(size + -4) < 0) {\n    newPtr = (int **)((int)newPtr + *(int *)(size + -4));\n  }\n  __malloc_lock();\n  currentPtr = (int **)&DAT_200005f8;\n  if (DAT_200005f8 == (int **)0x0) {\n    newPtr[1] = (int *)0x0;\n    firstPtr = tempPtr;\n    DAT_200005f8 = newPtr;\n  }\n  else {\n    currentPtr = DAT_200005f8;\n    if (newPtr < DAT_200005f8) {\n      firstPtr = (int **)*newPtr;\n      currentPtr = (int **)((int)newPtr + (int)firstPtr);\n      if (DAT_200005f8 == currentPtr) {\n        temp1 = *DAT_200005f8;\n        DAT_200005f8 = (int **)DAT_200005f8[1];\n        currentPtr = (int **)((int)temp1 + (int)firstPtr);\n        *newPtr = (int *)currentPtr;\n      }\n      newPtr[1] = (int *)DAT_200005f8;\n      DAT_200005f8 = newPtr;\n    }\n    else {\n      do {\n        previousPtr = currentPtr;\n        currentPtr = (int **)previousPtr[1];\n        if (currentPtr == (int **)0x0) break;\n      } while (currentPtr <= newPtr);\n      firstPtr = (int **)*previousPtr;\n      if ((int **)((int)previousPtr + (int)firstPtr) == newPtr) {\n        firstPtr = (int **)((int)firstPtr + (int)*newPtr);\n        *previousPtr = (int *)firstPtr;\n        if (currentPtr == (int **)((int)previousPtr + (int)firstPtr)) {\n          temp1 = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          firstPtr = (int **)((int)firstPtr + (int)temp1);\n          *previousPtr = (int *)firstPtr;\n          previousPtr[1] = (int *)currentPtr;\n        }\n      }\n      else if (newPtr < (int **)((int)previousPtr + (int)firstPtr)) {\n        *outputPtr = 0xc;\n      }\n      else {\n        firstPtr = (int **)((int)newPtr + (int)*newPtr);\n        if (currentPtr == firstPtr) {\n          temp1 = *currentPtr;\n          currentPtr = (int **)currentPtr[1];\n          firstPtr = (int **)((int)temp1 + (int)*newPtr);\n          *newPtr = (int *)firstPtr;\n        }\n        newPtr[1] = (int *)currentPtr;\n        previousPtr[1] = (int *)newPtr;\n      }\n    }\n  }\n  __malloc_unlock(outputPtr,firstPtr,currentPtr,param4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080061f0": "allocate_memory_080061f0",
                "param_1": "outputPtr",
                "param_2": "size",
                "param_3": "param3",
                "param_4": "param4",
                "extraout_r1": "tempPtr",
                "ppiVar1": "firstPtr",
                "ppiVar2": "currentPtr",
                "piVar3": "temp1",
                "ppiVar4": "previousPtr",
                "ppiVar5": "newPtr"
            },
            "calling": [
                "__swsetup_r",
                "abort"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006288": {
            "entrypoint": "0x08006288",
            "current_name": "allocate_memory_08006288",
            "code": "\nuint allocate_memory_08006288(undefined4 *size_ptr,uint size)\n\n{\n  uint *current_block;\n  int remaining_size;\n  uint *prev_block;\n  uint block_diff;\n  uint *next_block;\n  uint allocated_size;\n  \n  allocated_size = (size + 3 & 0xfffffffc) + 8;\n  if (allocated_size < 0xc) {\n    allocated_size = 0xc;\n  }\n  if (((int)allocated_size < 0) || (allocated_size < size)) {\n    *size_ptr = 0xc;\n  }\n  else {\n    __malloc_lock();\n    current_block = DAT_200005f8;\n    next_block = DAT_200005f8;\n    while (prev_block = current_block, prev_block != (uint *)0x0) {\n      block_diff = *prev_block - allocated_size;\n      if (-1 < (int)block_diff) {\n        if (block_diff < 0xc) {\n          if (next_block == prev_block) {\n            current_block = (uint *)next_block[1];\n            DAT_200005f8 = current_block;\n          }\n          else {\n            current_block = (uint *)prev_block[1];\n          }\n          if (next_block != prev_block) {\n            next_block[1] = (uint)current_block;\n            next_block = prev_block;\n          }\n        }\n        else {\n          *prev_block = block_diff;\n          *(uint *)((int)prev_block + block_diff) = allocated_size;\n          next_block = (uint *)((int)prev_block + block_diff);\n        }\n        goto LAB_080062ec;\n      }\n      next_block = prev_block;\n      current_block = (uint *)prev_block[1];\n    }\n    if (DAT_200005fc == 0) {\n      DAT_200005fc = _sbrk_r(size_ptr);\n    }\n    current_block = (uint *)_sbrk_r(size_ptr,allocated_size);\n    if ((current_block != (uint *)0xffffffff) &&\n       ((next_block = (uint *)((int)current_block + 3U & 0xfffffffc), current_block == next_block ||\n        (remaining_size = _sbrk_r(size_ptr,(int)next_block - (int)current_block), remaining_size != -1)))) {\n      *next_block = allocated_size;\nLAB_080062ec:\n      __malloc_unlock(size_ptr);\n      allocated_size = (int)next_block + 0xbU & 0xfffffff8;\n      remaining_size = allocated_size - (int)(next_block + 1);\n      if (remaining_size != 0) {\n        *(int *)((int)next_block + remaining_size) = -remaining_size;\n        return allocated_size;\n      }\n      return allocated_size;\n    }\n    *size_ptr = 0xc;\n    __malloc_unlock(size_ptr);\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006288": "allocate_memory_08006288",
                "param_1": "size_ptr",
                "param_2": "size",
                "puVar1": "current_block",
                "iVar2": "remaining_size",
                "puVar3": "prev_block",
                "uVar4": "block_diff",
                "puVar5": "next_block",
                "uVar6": "allocated_size"
            },
            "calling": [
                "__smakebuf_r",
                "__sfmoreglue"
            ],
            "called": [
                "__malloc_unlock",
                "__malloc_lock",
                "_sbrk_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006344": {
            "entrypoint": "0x08006344",
            "current_name": "process_data_08006344",
            "code": "\nuint processData_08006344(int input,byte byteValue,byte **data)\n\n{\n  int tempVar1;\n  byte *tempVar2;\n  byte *tempVar3;\n  uint result;\n  \n  tempVar2 = data[2] + -1;\n  data[2] = tempVar2;\n  if ((-1 < (int)tempVar2) ||\n     (((int)data[6] <= (int)tempVar2 && (tempVar2 = (byte *)(uint)byteValue, tempVar2 != (byte *)0xa))))\n  {\n    tempVar2 = *data;\n    *data = tempVar2 + 1;\n    *tempVar2 = byteValue;\n    return (uint)byteValue;\n  }\n  if ((input != 0) && (*(int *)(input + 0x18) == 0)) {\n    __sinit();\n  }\n  if (data == (byte **)&DAT_08007904) {\n    data = *(byte ***)(input + 4);\n  }\n  else if (data == (byte **)&DAT_08007924) {\n    data = *(byte ***)(input + 8);\n  }\n  else if (data == (byte **)&DAT_080078e4) {\n    data = *(byte ***)(input + 0xc);\n  }\n  data[2] = data[6];\n  tempVar3 = (byte *)(uint)*(ushort *)(data + 3);\n  tempVar1 = (int)tempVar3 << 0x1c;\n  if (((tempVar1 < 0) && (tempVar3 = data[4], tempVar3 != (byte *)0x0)) ||\n     (tempVar1 = __swsetup_r(input,data,tempVar1,tempVar3,tempVar2), tempVar1 == 0)) {\n    result = (uint)byteValue;\n    tempVar1 = (int)*data - (int)data[4];\n    if ((tempVar1 < (int)data[5]) || (tempVar1 = _fflush_r(input,data), tempVar1 == 0)) {\n      data[2] = data[2] + -1;\n      tempVar2 = *data;\n      *data = tempVar2 + 1;\n      *tempVar2 = byteValue;\n      if ((byte *)(tempVar1 + 1) != data[5]) {\n        if (-1 < (int)((uint)*(ushort *)(data + 3) << 0x1f)) {\n          return result;\n        }\n        if (result != 10) {\n          return result;\n        }\n      }\n      tempVar1 = _fflush_r(input,data);\n      if (tempVar1 == 0) {\n        return result;\n      }\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08006344": "process_data_08006344",
                "param_1": "input",
                "param_2": "byteValue",
                "param_3": "data",
                "iVar1": "tempVar1",
                "pbVar2": "tempVar2",
                "pbVar3": "tempVar3",
                "uVar4": "result"
            },
            "calling": [
                "__sfputs_r"
            ],
            "called": [
                "_fflush_r",
                "__swsetup_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006370": {
            "entrypoint": "0x08006370",
            "current_name": "write_characters_to_file_08006370",
            "code": "\nint writeCharactersToFile_08006370(undefined4 file,undefined4 buffer,undefined *inputString,int length)\n\n{\n  int result;\n  undefined *endOfInput;\n  int currentLength;\n  \n  endOfInput = inputString + length;\n  currentLength = length;\n  do {\n    if (inputString == endOfInput) {\n      return 0;\n    }\n    result = __sfputc_r(file,*inputString,buffer,length,currentLength);\n    length = result + 1;\n    inputString = inputString + 1;\n  } while (length != 0);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08006370": "write_characters_to_file_08006370",
                "param_1": "file",
                "param_2": "buffer",
                "param_3": "inputString",
                "param_4": "length",
                "iVar1": "result",
                "puVar2": "endOfInput",
                "iVar3": "currentLength"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "__sfputc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006394": {
            "entrypoint": "0x08006394",
            "current_name": "print_formatted_string_08006394",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08006568) */\n\nint printFormattedString_08006394(int stream,undefined4 *format,byte *str,int *args)\n\n{\n  int result;\n  int *argPtr;\n  bool isNum;\n  byte *currentChar;\n  byte *nextChar;\n  int swsetupResult;\n  int tempVar;\n  int *argIndex;\n  uint flags;\n  int precision;\n  undefined4 width;\n  int fieldWidth;\n  int totalChars;\n  byte conversionChar;\n  undefined spaceFlag;\n  undefined plusFlag;\n  undefined zeroFlag;\n  undefined4 sizeModifier;\n  \n  argIndex = args;\n  if ((stream != 0) && (*(int *)(stream + 0x18) == 0)) {\n    __sinit();\n  }\n  if (format == &DAT_08007904) {\n    format = *(undefined4 **)(stream + 4);\n  }\n  else if (format == (undefined4 *)&DAT_08007924) {\n    format = *(undefined4 **)(stream + 8);\n  }\n  else if (format == (undefined4 *)&DAT_080078e4) {\n    format = *(undefined4 **)(stream + 0xc);\n  }\n  if (((-1 < (int)((uint)*(ushort *)(format + 3) << 0x1c)) || (format[4] == 0)) &&\n     (tempVar = __swsetup_r(stream,format), tempVar != 0)) {\n    return -1;\n  }\n  totalChars = 0;\n  spaceFlag = 0x20;\n  plusFlag = 0x30;\n  currentChar = str;\nLAB_080063d6:\n  nextChar = currentChar;\n  if (*nextChar != 0) goto LAB_0800648c;\n  goto LAB_080063e0;\nLAB_0800648c:\n  currentChar = nextChar + 1;\n  if (*nextChar != 0x25) goto LAB_080063d6;\nLAB_080063e0:\n  tempVar = (int)nextChar - (int)str;\n  if (tempVar != 0) {\n    result = __sfputs_r(stream,format,str,tempVar);\n    if (result == -1) {\nLAB_08006580:\n      if ((int)((uint)*(ushort *)(format + 3) << 0x19) < 0) {\n        return -1;\n      }\n      return totalChars;\n    }\n    totalChars = totalChars + tempVar;\n  }\n  if (*nextChar == 0) goto LAB_08006580;\n  flags = 0;\n  fieldWidth = 0;\n  precision = -1;\n  width = 0;\n  zeroFlag = 0;\n  sizeModifier = 0;\n  currentChar = nextChar + 1;\n  while( true ) {\n    tempVar = memchr(\"#-0+ \",*currentChar);\n    str = currentChar + 1;\n    if (tempVar == 0) break;\n    flags = 1 << (tempVar + 0xf7ff8750U & 0xff) | flags;\n    currentChar = str;\n  }\n  if ((int)(flags << 0x1b) < 0) {\n    zeroFlag = 0x20;\n  }\n  if ((int)(flags << 0x1c) < 0) {\n    zeroFlag = 0x2b;\n  }\n  if (*currentChar == 0x2a) {\n    argPtr = argIndex + 1;\n    tempVar = *argIndex;\n    argIndex = argPtr;\n    if (tempVar < 0) {\n      fieldWidth = -tempVar;\n      flags = flags | 2;\n      goto LAB_080064be;\n    }\n  }\n  else {\n    isNum = false;\n    tempVar = fieldWidth;\n    str = currentChar;\n    while( true ) {\n      if (9 < *str - 0x30) break;\n      tempVar = tempVar * 10 + (*str - 0x30);\n      isNum = true;\n      str = str + 1;\n    }\n    if (!isNum) goto LAB_080064be;\n  }\n  fieldWidth = tempVar;\nLAB_080064be:\n  if (*str == 0x2e) {\n    if (str[1] == 0x2a) {\n      str = str + 2;\n      argPtr = argIndex + 1;\n      precision = *argIndex;\n      argIndex = argPtr;\n      if (precision < 0) {\n        precision = -1;\n      }\n    }\n    else {\n      isNum = false;\n      tempVar = 0;\n      precision = 0;\n      while( true ) {\n        str = str + 1;\n        if (9 < *str - 0x30) break;\n        tempVar = tempVar * 10 + (*str - 0x30);\n        isNum = true;\n      }\n      if (isNum) {\n        precision = tempVar;\n      }\n    }\n  }\n  tempVar = memchr(&DAT_080078b6,*str,3);\n  if (tempVar != 0) {\n    str = str + 1;\n    flags = flags | 0x40 << (tempVar + 0xf7ff874aU & 0xff);\n  }\n  conversionChar = *str;\n  str = str + 1;\n  tempVar = memchr(\"efgEFG\",conversionChar,6);\n  if (tempVar == 0) {\n    swsetupResult = _printf_i(stream,&flags,format,0x8006371,&argIndex);\n    if (swsetupResult == -1) goto LAB_08006580;\n  }\n  else {\n    argIndex = (int *)(((int)argIndex + 7U & 0xfffffff8) + 8);\n  }\n  totalChars = totalChars + swsetupResult;\n  currentChar = str;\n  goto LAB_080063d6;\n}\n\n",
            "renaming": {
                "FUN_08006394": "print_formatted_string_08006394",
                "param_1": "stream",
                "param_2": "format",
                "param_3": "str",
                "param_4": "args",
                "iVar1": "result",
                "piVar2": "argPtr",
                "bVar3": "isNum",
                "pbVar4": "currentChar",
                "pbVar5": "nextChar",
                "unaff_r9": "swsetupResult",
                "iVar6": "tempVar",
                "local_8c": "argIndex",
                "local_88": "flags",
                "local_84": "precision",
                "local_80": "width",
                "local_7c": "fieldWidth",
                "local_74": "totalChars",
                "local_70": "conversionChar",
                "local_6f": "spaceFlag",
                "local_6e": "plusFlag",
                "local_45": "zeroFlag",
                "local_30": "sizeModifier"
            },
            "calling": [
                "iprintf",
                "fiprintf"
            ],
            "called": [
                "memchr",
                "_printf_i",
                "__swsetup_r",
                "__sfputs_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080065c0": {
            "entrypoint": "0x080065c0",
            "current_name": "calculate_final_size_080065c0",
            "code": "\nundefined4\ncalculateFinalSize_080065c0(undefined4 input,uint *values,uint *finalSize,undefined4 param4,code *callback)\n\n{\n  int i;\n  int temp;\n  uint maxValue;\n  uint var;\n  bool isTrue;\n  \n  maxValue = values[4];\n  if ((int)values[4] < (int)values[2]) {\n    maxValue = values[2];\n  }\n  *finalSize = maxValue;\n  if (*(char *)((int)values + 0x43) != '\\0') {\n    *finalSize = maxValue + 1;\n  }\n  if ((int)(*values << 0x1a) < 0) {\n    *finalSize = *finalSize + 2;\n  }\n  if ((*values & 6) == 0) {\n    for (i = 0; i < (int)(values[3] - *finalSize); i = i + 1) {\n      temp = (*callback)(input,param4,(int)values + 0x19,1);\n      if (temp == -1) {\n        return 0xffffffff;\n      }\n    }\n  }\n  maxValue = (uint)*(byte *)((int)values + 0x43);\n  if (maxValue != 0) {\n    maxValue = 1;\n  }\n  var = maxValue;\n  if ((int)(*values << 0x1a) < 0) {\n    *(undefined *)((int)values + maxValue + 0x43) = 0x30;\n    var = maxValue + 2;\n    *(undefined *)((int)values + maxValue + 0x44) = *(undefined *)((int)values + 0x45);\n  }\n  i = (*callback)(input,param4,(int)values + 0x43,var);\n  if (i != -1) {\n    maxValue = values[3];\n    isTrue = (*values & 6) != 4;\n    if (isTrue) {\n      maxValue = 0;\n    }\n    var = 0;\n    if (!isTrue) {\n      maxValue = maxValue - *finalSize;\n    }\n    if (!isTrue) {\n      maxValue = maxValue & ~((int)maxValue >> 0x1f);\n    }\n    if ((int)values[4] < (int)values[2]) {\n      maxValue = maxValue + (values[2] - values[4]);\n    }\n    while( true ) {\n      if (maxValue == var) {\n        return 0;\n      }\n      i = (*callback)(input,param4,(int)values + 0x1a,1);\n      if (i == -1) break;\n      var = var + 1;\n    }\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_080065c0": "calculate_final_size_080065c0",
                "param_1": "input",
                "param_2": "values",
                "param_3": "finalSize",
                "param_4": "param4",
                "param_5": "callback",
                "iVar1": "i",
                "iVar2": "temp",
                "uVar3": "maxValue",
                "uVar4": "var",
                "bVar5": "isTrue"
            },
            "calling": [
                "_printf_i"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080066b0": {
            "entrypoint": "0x080066b0",
            "current_name": "reformatted_print_function_080066b0",
            "code": "\nuint reformatted_print_function_080066b0(undefined4 format_string,uint *arg_ptr,undefined4 width,code *print_func,uint **arg_list)\n\n{\n  byte byte_value;\n  int loop_variable_1;\n  uint *ptr_1;\n  int loop_variable_2;\n  char *char_ptr_1;\n  uint temp_1;\n  uint **ppuVar7;\n  char **ppcVar8;\n  uint temp_2;\n  uint temp_3;\n  char *char_ptr_2;\n  char *char_ptr_3;\n  uint result_array [2];\n  \n  byte_value = *(byte *)(arg_ptr + 6);\n  char_ptr_3 = (char *)((int)arg_ptr + 0x43);\n  if (byte_value != 0x6e) {\n    if (byte_value < 0x6f) {\n      if (byte_value != 99) {\n        if (byte_value < 100) {\n          if (byte_value == 0) goto LAB_0800686a;\n          if (byte_value != 0x58) goto LAB_080066e0;\n          *(undefined *)((int)arg_ptr + 0x45) = 0x58;\n          char_ptr_1 = \"0123456789ABCDEF\";\nLAB_080067fa:\n          temp_1 = *arg_ptr;\n          ptr_1 = *arg_list;\n          *arg_list = ptr_1 + 1;\n          if (((temp_1 & 0x80) == 0) && ((int)(temp_1 << 0x19) < 0)) {\n            temp_2 = (uint)*(ushort *)ptr_1;\n          }\n          else {\n            temp_2 = *ptr_1;\n          }\n          if ((int)(temp_1 << 0x1f) < 0) {\n            *arg_ptr = temp_1 | 0x20;\n          }\n          if (temp_2 == 0) {\n            *arg_ptr = *arg_ptr & 0xffffffdf;\n          }\n          temp_1 = 0x10;\nLAB_08006790:\n          *(undefined *)((int)arg_ptr + 0x43) = 0;\n        }\n        else {\n          if ((byte_value != 100) && (byte_value != 0x69)) goto LAB_080066e0;\n          temp_2 = *arg_ptr;\n          ptr_1 = *arg_list;\n          if ((temp_2 & 0x80) == 0) {\n            *arg_list = ptr_1 + 1;\n            if ((temp_2 & 0x40) == 0) goto LAB_08006700;\n            temp_2 = (uint)(short)*(ushort *)ptr_1;\n          }\n          else {\n            *arg_list = ptr_1 + 1;\nLAB_08006700:\n            temp_2 = *ptr_1;\n          }\n          if ((int)temp_2 < 0) {\n            temp_2 = -temp_2;\n            *(undefined *)((int)arg_ptr + 0x43) = 0x2d;\n          }\n          char_ptr_1 = \"0123456789ABCDEF\";\n          temp_1 = 10;\n        }\n        temp_3 = arg_ptr[1];\n        arg_ptr[2] = temp_3;\n        char_ptr_2 = char_ptr_3;\n        if ((int)temp_3 < 0) {\n          if (temp_2 != 0) goto LAB_0800682e;\nLAB_080068dc:\n          *(char *)((int)arg_ptr + 0x42) = *char_ptr_1;\n          char_ptr_2 = (char *)((int)arg_ptr + 0x42);\n        }\n        else {\n          *arg_ptr = *arg_ptr & 0xfffffffb;\n          if (temp_2 == 0) {\n            if (temp_3 != 0) goto LAB_080068dc;\n          }\n          else {\nLAB_0800682e:\n            do {\n              temp_3 = temp_2 / temp_1;\n              char_ptr_2 = char_ptr_2 + -1;\n              *char_ptr_2 = char_ptr_1[temp_2 - temp_1 * temp_3];\n              temp_2 = temp_3;\n            } while (temp_3 != 0);\n          }\n        }\n        if (((temp_1 == 8) && ((int)(*arg_ptr << 0x1f) < 0)) && ((int)arg_ptr[1] <= (int)arg_ptr[4]))\n        {\n          char_ptr_2[-1] = '0';\n          char_ptr_2 = char_ptr_2 + -1;\n        }\n        arg_ptr[4] = (int)char_ptr_3 - (int)char_ptr_2;\n        char_ptr_3 = char_ptr_2;\n        goto LAB_080067d6;\n      }\n      ptr_1 = *arg_list;\n      *arg_list = ptr_1 + 1;\n      *(char *)((int)arg_ptr + 0x42) = (char)*ptr_1;\nLAB_08006740:\n      char_ptr_3 = (char *)((int)arg_ptr + 0x42);\n      temp_2 = 1;\n    }\n    else {\n      if (byte_value != 0x73) {\n        if (byte_value < 0x74) {\n          if (byte_value == 0x6f) {\nLAB_08006766:\n            temp_2 = *arg_ptr;\n            ptr_1 = *arg_list;\n            if ((temp_2 & 0x80) == 0) {\n              *arg_list = ptr_1 + 1;\n              if ((temp_2 & 0x40) == 0) goto LAB_08006774;\n              temp_2 = (uint)*(ushort *)ptr_1;\n            }\n            else {\n              *arg_list = ptr_1 + 1;\nLAB_08006774:\n              temp_2 = *ptr_1;\n            }\n            if (byte_value == 0x6f) {\n              temp_1 = 8;\n            }\n            else {\n              temp_1 = 10;\n            }\n            char_ptr_1 = \"0123456789ABCDEF\";\n            goto LAB_08006790;\n          }\n          if (byte_value == 0x70) {\n            *arg_ptr = *arg_ptr | 0x20;\nLAB_08006726:\n            char_ptr_1 = \"0123456789abcdef\";\n            *(undefined *)((int)arg_ptr + 0x45) = 0x78;\n            goto LAB_080067fa;\n          }\n        }\n        else {\n          if (byte_value == 0x75) goto LAB_08006766;\n          if (byte_value == 0x78) goto LAB_08006726;\n        }\nLAB_080066e0:\n        *(byte *)((int)arg_ptr + 0x42) = byte_value;\n        goto LAB_08006740;\n      }\n      ppcVar8 = (char **)*arg_list;\n      *arg_list = (uint *)(ppcVar8 + 1);\n      char_ptr_3 = *ppcVar8;\n      loop_variable_1 = memchr(char_ptr_3,0,arg_ptr[1]);\n      if (loop_variable_1 != 0) {\n        arg_ptr[1] = loop_variable_1 - (int)char_ptr_3;\n      }\n      temp_2 = arg_ptr[1];\n    }\n    arg_ptr[4] = temp_2;\n    *(undefined *)((int)arg_ptr + 0x43) = 0;\n    goto LAB_080067d6;\n  }\n  temp_2 = *arg_ptr;\n  ppuVar7 = (uint **)*arg_list;\n  temp_1 = arg_ptr[5];\n  if ((temp_2 & 0x80) == 0) {\n    *arg_list = (uint *)(ppuVar7 + 1);\n    ptr_1 = *ppuVar7;\n    if ((temp_2 & 0x40) == 0) goto LAB_08006856;\n    *(short *)ptr_1 = (short)temp_1;\n  }\n  else {\n    *arg_list = (uint *)(ppuVar7 + 1);\n    ptr_1 = *ppuVar7;\nLAB_08006856:\n    *ptr_1 = temp_1;\n  }\nLAB_0800686a:\n  arg_ptr[4] = 0;\nLAB_080067d6:\n  loop_variable_1 = _printf_common(format_string,arg_ptr,result_array,width,print_func);\n  if ((loop_variable_1 == -1) || (loop_variable_1 = (*print_func)(format_string,width,char_ptr_3,arg_ptr[4]), loop_variable_1 == -1)) {\nLAB_080067ea:\n    temp_2 = 0xffffffff;\n  }\n  else {\n    if ((int)(*arg_ptr << 0x1e) < 0) {\n      for (loop_variable_1 = 0; loop_variable_1 < (int)(arg_ptr[3] - result_array[0]); loop_variable_1 = loop_variable_1 + 1) {\n        loop_variable_2 = (*print_func)(format_string,width,(int)arg_ptr + 0x19,1);\n        if (loop_variable_2 == -1) goto LAB_080067ea;\n      }\n    }\n    temp_2 = arg_ptr[3];\n    if ((int)arg_ptr[3] < (int)result_array[0]) {\n      temp_2 = result_array[0];\n    }\n  }\n  return temp_2;\n}\n\n",
            "renaming": {
                "FUN_080066b0": "reformatted_print_function_080066b0",
                "param_1": "format_string",
                "param_2": "arg_ptr",
                "param_3": "width",
                "param_4": "print_func",
                "param_5": "arg_list",
                "bVar1": "byte_value",
                "iVar2": "loop_variable_1",
                "puVar3": "ptr_1",
                "iVar4": "loop_variable_2",
                "pcVar5": "char_ptr_1",
                "uVar6": "temp_1",
                "uVar9": "temp_2",
                "uVar10": "temp_3",
                "pcVar11": "char_ptr_2",
                "pcVar12": "char_ptr_3",
                "local_24": "result_array"
            },
            "calling": [
                "_vfiprintf_r"
            ],
            "called": [
                "memchr",
                "_printf_common"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080068f0": {
            "entrypoint": "0x080068f0",
            "current_name": "print_formatted_output_080068f0",
            "code": "\nvoid printFormattedOutput_080068f0(undefined4 formatString,undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  int dataPointer;\n  undefined4 formatStringCopy;\n  undefined4 arg1Copy;\n  undefined4 arg2Copy;\n  undefined4 arg3Copy;\n  \n  dataPointer = DAT_200000f8;\n  formatStringCopy = formatString;\n  arg1Copy = arg1;\n  arg2Copy = arg2;\n  arg3Copy = arg3;\n  if ((DAT_200000f8 != 0) && (*(int *)(DAT_200000f8 + 0x18) == 0)) {\n    __sinit(DAT_200000f8);\n  }\n  _vfiprintf_r(dataPointer,*(undefined4 *)(dataPointer + 8),formatString,&arg1Copy,formatStringCopy,&arg1Copy);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080068f0": "print_formatted_output_080068f0",
                "param_1": "formatString",
                "param_2": "arg1",
                "param_3": "arg2",
                "param_4": "arg3",
                "iVar1": "dataPointer",
                "uVar2": "formatStringCopy",
                "uStack_c": "arg1Copy",
                "uStack_8": "arg2Copy",
                "uStack_4": "arg3Copy"
            },
            "calling": [
                "uart_init"
            ],
            "called": [
                "_vfiprintf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006920": {
            "entrypoint": "0x08006920",
            "current_name": "initialize_memory_allocation_08006920",
            "code": "\nvoid initializeMemoryAllocation_08006920(int *memoryLocation,undefined4 allocationSize)\n\n{\n  int allocationResult;\n  \n  DAT_200006a4 = 0;\n  allocationResult = _sbrk(allocationSize);\n  if ((allocationResult == -1) && (DAT_200006a4 != 0)) {\n    *memoryLocation = DAT_200006a4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006920": "initialize_memory_allocation_08006920",
                "param_1": "memoryLocation",
                "param_2": "allocationSize",
                "iVar1": "allocationResult"
            },
            "calling": [
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080069e4": {
            "entrypoint": "0x080069e4",
            "current_name": "process_data_080069e4",
            "code": "\nuint processData_080069e4(undefined4 *outputBuffer,undefined4 *inputBuffer)\n\n{\n  int baseAddress;\n  uint returnValue;\n  ushort flag;\n  \n  baseAddress = DAT_200000f8;\n  if ((DAT_200000f8 != 0) && (*(int *)(DAT_200000f8 + 0x18) == 0)) {\n    initializeStruct(DAT_200000f8);\n  }\n  if (inputBuffer == &DAT_08007904) {\n    inputBuffer = *(undefined4 **)(baseAddress + 4);\n  }\n  else if (inputBuffer == (undefined4 *)&DAT_08007924) {\n    inputBuffer = *(undefined4 **)(baseAddress + 8);\n  }\n  else if (inputBuffer == (undefined4 *)&DAT_080078e4) {\n    inputBuffer = *(undefined4 **)(baseAddress + 0xc);\n  }\n  flag = *(ushort *)(inputBuffer + 3);\n  returnValue = (uint)flag;\n  if (-1 < (int)(returnValue << 0x1c)) {\n    if (-1 < (int)(returnValue << 0x1b)) {\n      *outputBuffer = 9;\n      goto LAB_08006a14;\n    }\n    if ((int)(returnValue << 0x1d) < 0) {\n      if ((undefined4 *)inputBuffer[0xd] != (undefined4 *)0x0) {\n        if ((undefined4 *)inputBuffer[0xd] != inputBuffer + 0x11) {\n          freeMemory(outputBuffer);\n        }\n        inputBuffer[0xd] = 0;\n      }\n      *(ushort *)(inputBuffer + 3) = *(ushort *)(inputBuffer + 3) & 0xffdb;\n      inputBuffer[1] = 0;\n      *inputBuffer = inputBuffer[4];\n    }\n    *(ushort *)(inputBuffer + 3) = *(ushort *)(inputBuffer + 3) | 8;\n  }\n  if ((inputBuffer[4] == 0) && ((*(ushort *)(inputBuffer + 3) & 0x280) != 0x200)) {\n    __smakebuf_r(outputBuffer,inputBuffer);\n  }\n  flag = *(ushort *)(inputBuffer + 3);\n  returnValue = flag & 1;\n  if ((flag & 1) == 0) {\n    if (-1 < (int)((uint)flag << 0x1e)) {\n      returnValue = inputBuffer[5];\n    }\n    inputBuffer[2] = returnValue;\n  }\n  else {\n    inputBuffer[2] = 0;\n    inputBuffer[6] = -inputBuffer[5];\n  }\n  if (inputBuffer[4] == 0) {\n    flag = *(ushort *)(inputBuffer + 3);\n    returnValue = (int)(short)flag & 0x80;\n    if (returnValue != 0) {\nLAB_08006a14:\n      *(ushort *)(inputBuffer + 3) = flag | 0x40;\n      return 0xffffffff;\n    }\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080069e4": "process_data_080069e4",
                "param_1": "outputBuffer",
                "param_2": "inputBuffer",
                "iVar1": "baseAddress",
                "uVar2": "returnValue",
                "uVar3": "flag",
                "__sinit": "initializeStruct",
                "_free_r": "freeMemory"
            },
            "calling": [
                "__sfputc_r",
                "_vfiprintf_r"
            ],
            "called": [
                "_free_r",
                "__smakebuf_r",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006ac0": {
            "entrypoint": "0x08006ac0",
            "current_name": "execute_exit_function_08006ac0",
            "code": "\nvoid executeExitFunction_08006ac0(void)\n\n{\n  uint *returnValues;\n  int tempVar1;\n  int *functionParams;\n  int *tempVar2;\n  uint ushortValue;\n  ushort flagValue;\n  int tempVar3;\n  code *functionPointer;\n  int tempVar4;\n  uint tempVar5;\n  code *jumpTableFunction;\n  bool boolVar;\n  undefined8 returnValue;\n  \n  raise(6);\n  jumpTableFunction = (code *)0x8006acf;\n  returnValue = _exit(1);\n  functionParams = (int *)((ulonglong)returnValue >> 0x20);\n  returnValues = (uint *)returnValue;\n  flagValue = *(ushort *)(functionParams + 3);\n  ushortValue = (uint)flagValue;\n  if ((int)(ushortValue << 0x1c) < 0) {\n    tempVar1 = functionParams[4];\n    if (tempVar1 != 0) {\n      tempVar3 = ushortValue << 0x1e;\n      boolVar = tempVar3 != 0;\n      if (boolVar) {\n        tempVar3 = 0;\n      }\n      tempVar4 = *functionParams;\n      if (!boolVar) {\n        tempVar3 = functionParams[5];\n      }\n      *functionParams = tempVar1;\n      functionParams[2] = tempVar3;\n      for (tempVar4 = tempVar4 - tempVar1; 0 < tempVar4; tempVar4 = tempVar4 - tempVar3) {\n        tempVar3 = (*(code *)functionParams[10])(returnValues,functionParams[8],tempVar1,tempVar4);\n        if (tempVar3 < 1) {\n          flagValue = *(ushort *)(functionParams + 3);\n          goto LAB_08006bc6;\n        }\n        tempVar1 = tempVar1 + tempVar3;\n      }\n    }\n  }\n  else if (((0 < functionParams[1]) || (0 < functionParams[0x10])) &&\n          (functionPointer = (code *)functionParams[0xb], functionPointer != (code *)0x0)) {\n    tempVar5 = *returnValues;\n    *returnValues = 0;\n    if ((flagValue & 0x1000) == 0) {\n      tempVar1 = (*functionPointer)(returnValues,functionParams[8],ushortValue & 0x1000,1);\n      if ((tempVar1 == -1) && (ushortValue = *returnValues, ushortValue != 0)) {\n        if ((ushortValue != 0x1d) && (ushortValue != 0x16)) {\n          *(ushort *)(functionParams + 3) = *(ushort *)(functionParams + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08006b90. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          (*jumpTableFunction)();\n          return;\n        }\n        *returnValues = tempVar5;\n        goto LAB_08006aea;\n      }\n    }\n    else {\n      tempVar1 = functionParams[0x15];\n    }\n    if (((int)((uint)*(ushort *)(functionParams + 3) << 0x1d) < 0) &&\n       (tempVar1 = tempVar1 - functionParams[1], functionParams[0xd] != 0)) {\n      tempVar1 = tempVar1 - functionParams[0x10];\n    }\n    tempVar1 = (*(code *)functionParams[0xb])(returnValues,functionParams[8],tempVar1,0);\n    flagValue = *(ushort *)(functionParams + 3);\n    if ((tempVar1 == -1) &&\n       ((0x1d < *returnValues || (-1 < (int)((0x20400001U >> (*returnValues & 0xff)) << 0x1f))))) {\nLAB_08006bc6:\n      *(ushort *)(functionParams + 3) = flagValue | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08006bd0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTableFunction)(0xffffffff);\n      return;\n    }\n    functionParams[1] = 0;\n    *functionParams = functionParams[4];\n    if (((int)((uint)flagValue << 0x13) < 0) && ((tempVar1 != -1 || (*returnValues == 0)))) {\n      functionParams[0x15] = tempVar1;\n    }\n    tempVar2 = (int *)functionParams[0xd];\n    *returnValues = tempVar5;\n    if (tempVar2 != (int *)0x0) {\n      if (tempVar2 != functionParams + 0x11) {\n        _free_r(returnValues);\n      }\n      functionParams[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08006b66. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTableFunction)();\n      return;\n    }\n  }\nLAB_08006aea:\n                    /* WARNING: Could not recover jumptable at 0x08006aec. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTableFunction)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006ac0": "execute_exit_function_08006ac0",
                "piVar3": "functionParams",
                "puVar1": "returnValues",
                "iVar2": "tempVar1",
                "piVar4": "tempVar2",
                "uVar5": "ushortValue",
                "uVar6": "flagValue",
                "iVar7": "tempVar3",
                "pcVar8": "functionPointer",
                "iVar9": "tempVar4",
                "uVar10": "tempVar5",
                "UNRECOVERED_JUMPTABLE_00": "jumpTableFunction",
                "bVar11": "boolVar",
                "uVar12": "returnValue"
            },
            "calling": [
                "__throw_bad_function_call",
                "__assert_func"
            ],
            "called": [
                "_free_r",
                "raise",
                "_exit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006be0": {
            "entrypoint": "0x08006be0",
            "current_name": "process_data_08006be0",
            "code": "\nundefined4 processData_08006be0(uint *dataPtr,int *infoPtr)\n\n{\n  undefined4 result;\n  int count;\n  int *ptr;\n  uint value;\n  ushort flag;\n  int offset;\n  undefined4 unused1;\n  undefined4 unused2;\n  code *callback;\n  int temp;\n  uint temp2;\n  code *UNRECOVERED_JUMPTABLE_00;\n  bool bVar10;\n  \n  if (infoPtr[4] != 0) {\n    if ((dataPtr != (uint *)0x0) && (dataPtr[6] == 0)) {\n      __sinit();\n    }\n    if (infoPtr == &DAT_08007904) {\n      infoPtr = (int *)dataPtr[1];\n    }\n    else if (infoPtr == (int *)&DAT_08007924) {\n      infoPtr = (int *)dataPtr[2];\n    }\n    else if (infoPtr == (int *)&DAT_080078e4) {\n      infoPtr = (int *)dataPtr[3];\n    }\n    if (*(short *)(infoPtr + 3) != 0) {\n      flag = *(ushort *)(infoPtr + 3);\n      value = (uint)flag;\n      if ((int)(value << 0x1c) < 0) {\n        count = infoPtr[4];\n        if (count != 0) {\n          offset = value << 0x1e;\n          bVar10 = offset != 0;\n          if (bVar10) {\n            offset = 0;\n          }\n          temp = *infoPtr;\n          if (!bVar10) {\n            offset = infoPtr[5];\n          }\n          *infoPtr = count;\n          infoPtr[2] = offset;\n          for (temp = temp - count; 0 < temp; temp = temp - offset) {\n            offset = (*(code *)infoPtr[10])(dataPtr,infoPtr[8],count,temp,unused1,unused2);\n            if (offset < 1) {\n              flag = *(ushort *)(infoPtr + 3);\n              goto LAB_08006bc6;\n            }\n            count = count + offset;\n          }\n        }\n      }\n      else if (((0 < infoPtr[1]) || (0 < infoPtr[0x10])) &&\n              (callback = (code *)infoPtr[0xb], callback != (code *)0x0)) {\n        temp2 = *dataPtr;\n        *dataPtr = 0;\n        if ((flag & 0x1000) == 0) {\n          count = (*callback)(dataPtr,infoPtr[8],value & 0x1000,1);\n          if ((count == -1) && (value = *dataPtr, value != 0)) {\n            if ((value != 0x1d) && (value != 0x16)) {\n              *(ushort *)(infoPtr + 3) = *(ushort *)(infoPtr + 3) | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08006b90. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n              result = (*UNRECOVERED_JUMPTABLE_00)();\n              return result;\n            }\n            *dataPtr = temp2;\n            goto LAB_08006aea;\n          }\n        }\n        else {\n          count = infoPtr[0x15];\n        }\n        if (((int)((uint)*(ushort *)(infoPtr + 3) << 0x1d) < 0) &&\n           (count = count - infoPtr[1], infoPtr[0xd] != 0)) {\n          count = count - infoPtr[0x10];\n        }\n        count = (*(code *)infoPtr[0xb])(dataPtr,infoPtr[8],count,0);\n        flag = *(ushort *)(infoPtr + 3);\n        if ((count == -1) &&\n           ((0x1d < *dataPtr || (-1 < (int)((0x20400001U >> (*dataPtr & 0xff)) << 0x1f))))) {\nLAB_08006bc6:\n          *(ushort *)(infoPtr + 3) = flag | 0x40;\n                    /* WARNING: Could not recover jumptable at 0x08006bd0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          result = (*UNRECOVERED_JUMPTABLE_00)(0xffffffff);\n          return result;\n        }\n        infoPtr[1] = 0;\n        *infoPtr = infoPtr[4];\n        if (((int)((uint)flag << 0x13) < 0) && ((count != -1 || (*dataPtr == 0)))) {\n          infoPtr[0x15] = count;\n        }\n        ptr = (int *)infoPtr[0xd];\n        *dataPtr = temp2;\n        if (ptr != (int *)0x0) {\n          if (ptr != infoPtr + 0x11) {\n            _free_r(dataPtr);\n          }\n          infoPtr[0xd] = 0;\n                    /* WARNING: Could not recover jumptable at 0x08006b66. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n          result = (*UNRECOVERED_JUMPTABLE_00)();\n          return result;\n        }\n      }\nLAB_08006aea:\n                    /* WARNING: Could not recover jumptable at 0x08006aec. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      result = (*UNRECOVERED_JUMPTABLE_00)(0);\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006be0": "process_data_08006be0",
                "param_1": "dataPtr",
                "param_2": "infoPtr",
                "uVar1": "result",
                "iVar2": "count",
                "piVar3": "ptr",
                "uVar4": "value",
                "uVar5": "flag",
                "iVar6": "offset",
                "unaff_r4": "unused1",
                "unaff_r5": "unused2",
                "pcVar7": "callback",
                "iVar8": "temp",
                "uVar9": "temp2"
            },
            "calling": [
                "__sfputc_r"
            ],
            "called": [
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c40": {
            "entrypoint": "0x08006c40",
            "current_name": "initialize_parameters_08006c40",
            "code": "\nvoid initializeParameters_08006c40(undefined4 *outputArray,undefined2 value1,undefined2 value2)\n\n{\n  *outputArray = 0;\n  outputArray[1] = 0;\n  outputArray[2] = 0;\n  *(undefined2 *)(outputArray + 3) = value1;\n  outputArray[25] = 0;\n  *(undefined2 *)((int)outputArray + 0xe) = value2;\n  outputArray[4] = 0;\n  outputArray[5] = 0;\n  outputArray[6] = 0;\n  memset(outputArray + 0x17,0,8);\n  outputArray[8] = outputArray;\n  outputArray[9] = 0x8006f39;\n  outputArray[10] = 0x8006f5b;\n  outputArray[11] = 0x8006f93;\n  outputArray[12] = &LAB_08006fb6_1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006c40": "initialize_parameters_08006c40",
                "param_1": "outputArray",
                "param_2": "value1",
                "param_3": "value2",
                "param_1[1]": "outputArray[1]",
                "param_1[2]": "outputArray[2]",
                "param_1[0x19]": "outputArray[25]",
                "param_1[4]": "outputArray[4]",
                "param_1[5]": "outputArray[5]",
                "param_1[6]": "outputArray[6]",
                "param_1[8]": "outputArray[8]",
                "param_1[9]": "outputArray[9]",
                "param_1[10]": "outputArray[10]",
                "param_1[0xb]": "outputArray[11]",
                "param_1[0xc]": "outputArray[12]"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006c88": {
            "entrypoint": "0x08006c88",
            "current_name": "allocate_memory_08006c88",
            "code": "\nundefined4 * allocateMemory_08006c88(undefined4 size,int count)\n\n{\n  undefined4 *ptr;\n  int offset;\n  \n  offset = (count + -1) * 0x68;\n  ptr = (undefined4 *)_malloc_r(size,offset + 0x74);\n  if (ptr != (undefined4 *)0x0) {\n    *ptr = 0;\n    ptr[1] = count;\n    ptr[2] = ptr + 3;\n    memset(ptr + 3,0,offset + 0x68);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08006c88": "allocate_memory_08006c88",
                "param_1": "size",
                "param_2": "count",
                "iVar2": "offset",
                "puVar1": "ptr"
            },
            "calling": [
                "__sfp"
            ],
            "called": [
                "memset",
                "_malloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006cb4": {
            "entrypoint": "0x08006cb4",
            "current_name": "initialize_data_08006cb4",
            "code": "\nvoid initializeData_08006cb4(undefined4 *data)\n\n{\n  undefined4 result;\n  undefined4 *ptr;\n  \n  if (data[6] == 0) {\n    data[0x12] = 0;\n    data[0x13] = 0;\n    data[0x14] = 0;\n    ptr = &DAT_200000fc;\n    data[10] = &LAB_08006c34_1;\n    if (data == &DAT_200000fc) {\n      ptr = (undefined4 *)0x1;\n    }\n    if (data == &DAT_200000fc) {\n      data[6] = ptr;\n    }\n    result = __sfp();\n    data[1] = result;\n    result = __sfp(data);\n    data[2] = result;\n    result = __sfp(data);\n    data[3] = result;\n    std_isra_0(data[1],4,0);\n    std_isra_0(data[2],9,1);\n    std_isra_0(data[3],0x12,2);\n    data[6] = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006cb4": "initialize_data_08006cb4",
                "param_1": "data",
                "uVar1": "result",
                "puVar2": "ptr"
            },
            "calling": [
                "_fflush_r",
                "iprintf",
                "__sfputc_r",
                "__sfp",
                "_vfiprintf_r",
                "__swsetup_r"
            ],
            "called": [
                "std.isra.0",
                "__sfp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006d14": {
            "entrypoint": "0x08006d14",
            "current_name": "initialize_data_structures_08006d14",
            "code": "\nint * initializeDataStructures_08006d14(undefined4 *errorFlag,undefined4 parameter2,undefined4 parameter3,undefined4 parameter4)\n\n{\n  int *pointer1;\n  int *pointer2;\n  int **pointerPointer;\n  \n  if (DAT_20000114 == 0) {\n    initialize(&DAT_200000fc);\n  }\n  pointerPointer = (int **)&DAT_20000144;\n  do {\n    pointer2 = pointerPointer[2];\n    pointer1 = pointerPointer[1];\n    while (pointer1 = (int *)((int)pointer1 + -1), -1 < (int)pointer1) {\n      if (*(short *)(pointer2 + 3) == 0) {\n        *(undefined2 *)((int)pointer2 + 0xe) = 0xffff;\n        pointer2[0x19] = 0;\n        *(undefined2 *)(pointer2 + 3) = 1;\n        *pointer2 = 0;\n        pointer2[2] = 0;\n        pointer2[1] = 0;\n        pointer2[4] = 0;\n        pointer2[5] = 0;\n        pointer2[6] = 0;\n        fillMemory(pointer2 + 0x17,0,8,1,parameter4);\n        pointer2[0xd] = 0;\n        pointer2[0xe] = 0;\n        pointer2[0x12] = 0;\n        pointer2[0x13] = 0;\n        return pointer2;\n      }\n      pointer2 = pointer2 + 0x1a;\n    }\n    if (*pointerPointer == (int *)0x0) {\n      pointer1 = (int *)allocateMemory(errorFlag,4);\n      *pointerPointer = pointer1;\n      if (pointer1 == (int *)0x0) {\n        *errorFlag = 0xc;\n        return (int *)0x0;\n      }\n    }\n    pointerPointer = (int **)*pointerPointer;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08006d14": "initialize_data_structures_08006d14",
                "param_1": "errorFlag",
                "param_2": "parameter2",
                "param_3": "parameter3",
                "param_4": "parameter4",
                "piVar1": "pointer1",
                "piVar2": "pointer2",
                "ppiVar3": "pointerPointer",
                "__sinit": "initialize",
                "memset": "fillMemory",
                "__sfmoreglue": "allocateMemory"
            },
            "calling": [
                "__sinit"
            ],
            "called": [
                "memset",
                "__sfmoreglue",
                "__sinit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006dc8": {
            "entrypoint": "0x08006dc8",
            "current_name": "check_file_permissions_08006dc8",
            "code": "\nundefined4 checkFilePermissions_08006dc8(undefined4 fileDescriptor,int fileStatStruct,undefined4 *permissionFlag,uint *isExecutable)\n\n{\n  int fileStatResult;\n  undefined4 permissionValue;\n  undefined stackVariable [4];\n  uint fileMode;\n  \n  if ((*(short *)(fileStatStruct + 0xe) < 0) ||\n     (fileStatResult = _fstat_r(fileDescriptor,(int)*(short *)(fileStatStruct + 0xe),stackVariable), fileStatResult < 0)) {\n    *isExecutable = 0;\n    if ((int)((uint)*(ushort *)(fileStatStruct + 0xc) << 0x18) < 0) {\n      permissionValue = 0x40;\n      goto LAB_08006e08;\n    }\n  }\n  else {\n    *isExecutable = (uint)((fileMode & 0xf000) == 0x2000);\n  }\n  permissionValue = 0x400;\nLAB_08006e08:\n  *permissionFlag = permissionValue;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_08006dc8": "check_file_permissions_08006dc8",
                "param_1": "fileDescriptor",
                "param_2": "fileStatStruct",
                "param_3": "permissionFlag",
                "param_4": "isExecutable",
                "iVar1": "fileStatResult",
                "uVar2": "permissionValue",
                "auStack_4c": "stackVariable",
                "local_48": "fileMode"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_fstat_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e10": {
            "entrypoint": "0x08006e10",
            "current_name": "decode_and_allocate_memory_08006e10",
            "code": "\nvoid decode_and_allocate_memory_08006e10(int memory_manager,int *data_array)\n\n{\n  ushort result_code;\n  int allocated_memory;\n  int data_length;\n  int *optional_data;\n  \n  if (-1 < (int)((uint)*(ushort *)(data_array + 3) << 0x1e)) {\n    data_length = memory_manager;\n    optional_data = data_array;\n    result_code = __swhatbuf_r(memory_manager,data_array,&data_length,&optional_data);\n    allocated_memory = _malloc_r(memory_manager,data_length);\n    if (allocated_memory != 0) {\n      *(undefined **)(memory_manager + 0x28) = &LAB_08006c34_1;\n      *data_array = allocated_memory;\n      *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) | 0x80;\n      data_array[4] = allocated_memory;\n      data_array[5] = data_length;\n      if ((optional_data != (int *)0x0) &&\n         (allocated_memory = _isatty_r(memory_manager,(int)*(short *)((int)data_array + 0xe)), allocated_memory != 0)) {\n        *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 1;\n      }\n      *(ushort *)(data_array + 3) = result_code | *(ushort *)(data_array + 3);\n      return;\n    }\n    if ((int)(short)*(ushort *)(data_array + 3) << 0x16 < 0) {\n      return;\n    }\n    *(ushort *)(data_array + 3) = *(ushort *)(data_array + 3) & 0xfffc | 2;\n  }\n  *data_array = (int)data_array + 0x47;\n  data_array[4] = (int)data_array + 0x47;\n  data_array[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006e10": "decode_and_allocate_memory_08006e10",
                "param_1": "memory_manager",
                "param_2": "data_array",
                "uVar1": "result_code",
                "iVar2": "allocated_memory",
                "local_18": "data_length",
                "local_14": "optional_data"
            },
            "calling": [
                "__swsetup_r"
            ],
            "called": [
                "_malloc_r",
                "_isatty_r",
                "__swhatbuf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006e90": {
            "entrypoint": "0x08006e90",
            "current_name": "find_character_08006e90",
            "code": "\nchar * find_character_08006e90(char *string,char character,int length)\n\n{\n  char *current_char;\n  char *next_char;\n  \n  current_char = string;\n  do {\n    next_char = current_char;\n    if (next_char == string + length) {\n      return (char *)0x0;\n    }\n    current_char = next_char + 1;\n  } while (*next_char != character);\n  return next_char;\n}\n\n",
            "renaming": {
                "FUN_08006e90": "find_character_08006e90",
                "param_1": "string",
                "param_2": "character",
                "param_3": "length",
                "pcVar1": "current_char",
                "pcVar2": "next_char"
            },
            "calling": [
                "_printf_i",
                "_vfiprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006eac": {
            "entrypoint": "0x08006eac",
            "current_name": "FUNC_08006eac",
            "code": "\nvoid FUNC_08006eac(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eac": "FUNC_08006eac"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006eae": {
            "entrypoint": "0x08006eae",
            "current_name": "FUNC_08006eae",
            "code": "\nvoid FUNC_08006eae(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006eae": "FUNC_08006eae"
            },
            "calling": [
                "_free_r",
                "_malloc_r"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08006f00": {
            "entrypoint": "0x08006f00",
            "current_name": "handle_code_execution_08006f00",
            "code": "\nint handleCodeExecution_08006f00(uint codeIndex)\n\n{\n  int *dataPointer;\n  undefined4 processID;\n  int returnValue;\n  code *functionPointer;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 unusedVar3;\n  undefined4 *dataPointerPtr;\n  \n  dataPointer = DAT_200000f8;\n  dataPointerPtr = &DAT_200000f8;\n  if (0x1f < codeIndex) {\n    *DAT_200000f8 = 0x16;\n    return -1;\n  }\n  returnValue = DAT_200000f8[0x11];\n  if ((returnValue != 0) && (functionPointer = *(code **)(returnValue + codeIndex * 4), functionPointer != (code *)0x0)) {\n    if (functionPointer != (code *)0x1) {\n      if (functionPointer == (code *)0xffffffff) {\n        *DAT_200000f8 = 0x16;\n        return 1;\n      }\n      *(undefined4 *)(returnValue + codeIndex * 4) = 0;\n      (*functionPointer)(codeIndex);\n    }\n    return 0;\n  }\n  processID = _getpid_r(DAT_200000f8);\n  DAT_200006a4 = 0;\n  returnValue = _kill(processID,codeIndex,codeIndex,0,dataPointerPtr,unusedVar1,unusedVar2,unusedVar3);\n  if ((returnValue == -1) && (DAT_200006a4 != 0)) {\n    *dataPointer = DAT_200006a4;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08006f00": "handle_code_execution_08006f00",
                "param_1": "codeIndex",
                "piVar1": "dataPointer",
                "uVar2": "processID",
                "iVar3": "returnValue",
                "pcVar4": "functionPointer",
                "unaff_r4": "unusedVar1",
                "unaff_r5": "unusedVar2",
                "in_lr": "unusedVar3",
                "puVar5": "dataPointerPtr"
            },
            "calling": [
                "abort"
            ],
            "called": [
                "_getpid_r",
                "_kill"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f34": {
            "entrypoint": "0x08006f34",
            "current_name": "FUN_08006f34",
            "code": "\nundefined4 _getpid(void)\n\n{\n  return 1;\n}\n\n",
            "renaming": {},
            "calling": [
                "raise"
            ],
            "called": [
                "_getpid"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f38": {
            "entrypoint": "0x08006f38",
            "current_name": "update_data_08006f38",
            "code": "\nvoid updateData_08006f38(undefined4 stream,int data)\n\n{\n  int readResult;\n  uint updatedValue;\n  bool isSuccessful;\n  \n  readResult = _read_r(stream,(int)*(short *)(data + 0xe));\n  isSuccessful = -1 < readResult;\n  if (isSuccessful) {\n    updatedValue = *(int *)(data + 0x54) + readResult;\n  }\n  else {\n    updatedValue = *(ushort *)(data + 0xc) & 0xffffefff;\n  }\n  if (isSuccessful) {\n    *(uint *)(data + 0x54) = updatedValue;\n  }\n  if (!isSuccessful) {\n    *(short *)(data + 0xc) = (short)updatedValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f38": "update_data_08006f38",
                "param_1": "stream",
                "param_2": "data",
                "iVar1": "readResult",
                "uVar2": "updatedValue",
                "bVar3": "isSuccessful"
            },
            "calling": [],
            "called": [
                "_read_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f5a": {
            "entrypoint": "0x08006f5a",
            "current_name": "write_file_and_seek_if_needed_08006f5a",
            "code": "\nvoid writeFileAndSeekIfNeeded_08006f5a(int *fileDescriptor,int bufferAddress,undefined4 dataAddress,undefined4 size)\n\n{\n  int writeResult;\n  undefined4 unused1;\n  undefined4 unused2;\n  undefined4 unused3;\n  \n  if ((int)((uint)*(ushort *)(bufferAddress + 0xc) << 0x17) < 0) {\n    _lseek_r(fileDescriptor,(int)*(short *)(bufferAddress + 0xe),0,2);\n  }\n  *(ushort *)(bufferAddress + 0xc) = *(ushort *)(bufferAddress + 0xc) & 0xefff;\n  DAT_200006a4 = 0;\n  writeResult = _write((int)*(short *)(bufferAddress + 0xe),dataAddress,size,size,size,unused1,unused2,\n                 unused3);\n  if ((writeResult == -1) && (DAT_200006a4 != 0)) {\n    *fileDescriptor = DAT_200006a4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f5a": "write_file_and_seek_if_needed_08006f5a",
                "param_1": "fileDescriptor",
                "param_2": "bufferAddress",
                "param_3": "dataAddress",
                "param_4": "size",
                "iVar1": "writeResult",
                "unaff_r4": "unused1",
                "unaff_r5": "unused2",
                "in_lr": "unused3"
            },
            "calling": [],
            "called": [
                "_lseek_r",
                "_write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08006f92": {
            "entrypoint": "0x08006f92",
            "current_name": "update_file_status_08006f92",
            "code": "\nvoid updateFileStatus_08006f92(undefined4 fileDescriptor,int structAddress)\n\n{\n  int seekResult;\n  ushort updatedFlags;\n  bool isSeekError;\n  \n  seekResult = _lseek_r(fileDescriptor,(int)*(short *)(structAddress + 0xe));\n  isSeekError = seekResult == -1;\n  if (isSeekError) {\n    updatedFlags = *(ushort *)(structAddress + 0xc) & 0xefff;\n  }\n  else {\n    *(int *)(structAddress + 0x54) = seekResult;\n    updatedFlags = *(ushort *)(structAddress + 0xc) | 0x1000;\n  }\n  if (isSeekError) {\n    *(ushort *)(structAddress + 0xc) = updatedFlags;\n  }\n  if (!isSeekError) {\n    *(ushort *)(structAddress + 0xc) = updatedFlags;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08006f92": "update_file_status_08006f92",
                "param_1": "fileDescriptor",
                "param_2": "structAddress",
                "iVar1": "seekResult",
                "uVar2": "updatedFlags",
                "bVar3": "isSeekError"
            },
            "calling": [],
            "called": [
                "_lseek_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007004": {
            "entrypoint": "0x08007004",
            "current_name": "get_file_status_08007004",
            "code": "\nvoid getFileStatus_08007004(int *outputFileStatus,undefined4 fileDescriptor,undefined4 statBuffer,undefined4 bufferSize)\n\n{\n  int fileStatus;\n  \n  DAT_200006a4 = 0;\n  fileStatus = _fstat(fileDescriptor,statBuffer,statBuffer,0,bufferSize);\n  if ((fileStatus == -1) && (DAT_200006a4 != 0)) {\n    *outputFileStatus = DAT_200006a4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007004": "get_file_status_08007004",
                "param_1": "outputFileStatus",
                "param_2": "fileDescriptor",
                "param_3": "statBuffer",
                "param_4": "bufferSize",
                "iVar1": "fileStatus"
            },
            "calling": [
                "__swhatbuf_r"
            ],
            "called": [
                "_fstat"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007028": {
            "entrypoint": "0x08007028",
            "current_name": "check_and_set_tty_08007028",
            "code": "\nvoid checkAndSetTTY_08007028(int *result,undefined4 fileDescriptor)\n\n{\n  int isTTY;\n  \n  DAT_200006a4 = 0;\n  isTTY = _isatty(fileDescriptor);\n  if ((isTTY == -1) && (DAT_200006a4 != 0)) {\n    *result = DAT_200006a4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007028": "check_and_set_tty_08007028",
                "param_1": "result",
                "param_2": "fileDescriptor",
                "iVar1": "isTTY"
            },
            "calling": [
                "__smakebuf_r"
            ],
            "called": [
                "_isatty"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007048": {
            "entrypoint": "0x08007048",
            "current_name": "update_file_pointer_08007048",
            "code": "\nvoid updateFilePointer_08007048(int *result,undefined4 fileDescriptor,undefined4 offset,undefined4 origin)\n\n{\n  int seekResult;\n  \n  DAT_200006a4 = 0;\n  seekResult = _lseek(fileDescriptor,offset,origin,origin,origin);\n  if ((seekResult == -1) && (DAT_200006a4 != 0)) {\n    *result = DAT_200006a4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007048": "update_file_pointer_08007048",
                "param_1": "result",
                "param_2": "fileDescriptor",
                "param_3": "offset",
                "param_4": "origin",
                "iVar1": "seekResult"
            },
            "calling": [
                "__swrite",
                "__sseek"
            ],
            "called": [
                "_lseek"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800706c": {
            "entrypoint": "0x0800706c",
            "current_name": "read_and_store_error_0800706c",
            "code": "\nvoid readAndStoreError_0800706c(int *result,undefined4 fileDescriptor,undefined4 buffer,undefined4 count)\n\n{\n  int readResult;\n  \n  DAT_200006a4 = 0;\n  readResult = _read(fileDescriptor,buffer,count,count,count);\n  if ((readResult == -1) && (DAT_200006a4 != 0)) {\n    *result = DAT_200006a4;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800706c": "read_and_store_error_0800706c",
                "param_1": "result",
                "param_2": "fileDescriptor",
                "param_3": "buffer",
                "param_4": "count",
                "iVar1": "readResult"
            },
            "calling": [
                "__sread"
            ],
            "called": [
                "_read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007090": {
            "entrypoint": "0x08007090",
            "current_name": "initialize_data_08007090",
            "code": "\nvoid initializeData_08007090(void)\n\n{\n  code *jumpTable;\n  \n  jumpTable = initializeData_08007090;\n  abort();\n  if (-1 < DAT_2000062c << 0x1f) {\n    DAT_2000062c = 1;\n  }\n  if (-1 < DAT_20000628 << 0x1f) {\n    DAT_20000628 = 1;\n  }\n  if (-1 < DAT_20000624 << 0x1f) {\n    DAT_20000624 = 1;\n  }\n  if (-1 < DAT_20000620 << 0x1f) {\n    DAT_20000620 = 1;\n  }\n  if (-1 < DAT_2000061c << 0x1f) {\n    DAT_2000061c = 1;\n  }\n  if (-1 < DAT_20000618 << 0x1f) {\n    DAT_20000618 = 1;\n  }\n  if (-1 < DAT_20000614 << 0x1f) {\n    DAT_20000614 = 1;\n  }\n  if (-1 < DAT_20000610 << 0x1f) {\n    DAT_20000610 = 1;\n  }\n  if (-1 < DAT_2000060c << 0x1f) {\n    DAT_2000060c = 1;\n  }\n  if (-1 < DAT_20000608 << 0x1f) {\n    DAT_20000608 = 1;\n  }\n  if (-1 < DAT_20000604 << 0x1f) {\n    DAT_20000604 = 1;\n  }\n  if (-1 < DAT_20000600 << 0x1f) {\n    DAT_20000600 = 1;\n  }\n                    /* WARNING: Could not recover jumptable at 0x08007128. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007090": "initialize_data_08007090",
                "UNRECOVERED_JUMPTABLE": "jumpTable"
            },
            "calling": [
                "operator()"
            ],
            "called": [
                "abort"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08007328": {
            "entrypoint": "0x08007328",
            "current_name": "FUNC_08007328",
            "code": "\nvoid FUNC_08007328(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007328": "FUNC_08007328"
            },
            "calling": [
                "__libc_init_array",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08007334": {
            "entrypoint": "0x08007334",
            "current_name": "FUNC_08007334",
            "code": "\nvoid FUNC_08007334(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08007334": "FUNC_08007334"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 176124,
    "layers": [
        [
            "FUN_0800010c",
            "FUN_08000178",
            "FUN_08000190",
            "FUN_08000194",
            "FUN_0800040c",
            "FUN_0800042c",
            "FUN_080006d4",
            "FUN_080008ba",
            "FUN_0800092c",
            "FUN_080009a8",
            "FUN_080009b8",
            "FUN_080009c8",
            "FUN_080009dc",
            "FUN_080009f0",
            "FUN_08000a04",
            "FUN_08000a18",
            "FUN_08000a2c",
            "FUN_08000a58",
            "FUN_08000aa8",
            "FUN_08000ae8",
            "FUN_08000aec",
            "FUN_08000b08",
            "FUN_08001294",
            "FUN_080012a2",
            "FUN_080012c0",
            "FUN_080012e8",
            "FUN_08001310",
            "FUN_0800134e",
            "FUN_0800135a",
            "FUN_08001366",
            "FUN_0800138e",
            "FUN_080013a4",
            "FUN_08001550",
            "FUN_0800157c",
            "FUN_080015b2",
            "FUN_080015f8",
            "FUN_080016b4",
            "FUN_08001814",
            "FUN_08001918",
            "FUN_08001960",
            "FUN_080019f6",
            "FUN_08001a44",
            "FUN_08001a66",
            "FUN_08001b48",
            "FUN_08001be8",
            "FUN_08001c32",
            "FUN_08001c3c",
            "FUN_08001c88",
            "FUN_08001cac",
            "FUN_08001cc4",
            "FUN_08001cd0",
            "FUN_08001e40",
            "FUN_08001e48",
            "FUN_08001f80",
            "FUN_08001f84",
            "FUN_08002004",
            "FUN_080020f0",
            "FUN_0800213c",
            "FUN_0800224c",
            "FUN_08002348",
            "FUN_08002384",
            "FUN_08002470",
            "FUN_08002494",
            "FUN_080024f8",
            "FUN_08002514",
            "FUN_08002540",
            "FUN_08002560",
            "FUN_08002582",
            "FUN_0800258c",
            "FUN_08002624",
            "FUN_08002810",
            "FUN_0800281e",
            "FUN_0800282c",
            "FUN_08002848",
            "FUN_080028d2",
            "FUN_080028de",
            "FUN_08002ab8",
            "FUN_08002ad8",
            "FUN_08002af8",
            "FUN_08002b84",
            "FUN_08002c10",
            "FUN_08002c54",
            "FUN_08002ca6",
            "FUN_08002cf2",
            "FUN_08002d1c",
            "FUN_08002db2",
            "FUN_08002efc",
            "FUN_08002f9c",
            "FUN_0800306c",
            "FUN_0800316c",
            "FUN_080032b4",
            "FUN_080033b8",
            "FUN_08003520",
            "FUN_0800365c",
            "FUN_08003688",
            "FUN_08003a68",
            "FUN_08003ad4",
            "FUN_08003afa",
            "FUN_08003c44",
            "FUN_08003c50",
            "FUN_08003c70",
            "FUN_08003c90",
            "FUN_08003da4",
            "FUN_08003ea0",
            "FUN_08003ed8",
            "FUN_08003f18",
            "FUN_08004092",
            "FUN_080040b0",
            "FUN_08004110",
            "FUN_0800412c",
            "FUN_0800417c",
            "FUN_08004198",
            "FUN_08004204",
            "FUN_080043b4",
            "FUN_0800441a",
            "FUN_08004478",
            "FUN_0800455a",
            "FUN_080045a2",
            "FUN_080045fe",
            "FUN_08004618",
            "FUN_080046b8",
            "FUN_080047e8",
            "FUN_080047f4",
            "FUN_0800480a",
            "FUN_08004828",
            "FUN_08004848",
            "FUN_08004884",
            "FUN_0800492c",
            "FUN_08004948",
            "FUN_08004974",
            "FUN_080049f0",
            "FUN_08004a4c",
            "FUN_08004b34",
            "FUN_08004b3c",
            "FUN_08004b94",
            "FUN_08004b9e",
            "FUN_08004bb0",
            "FUN_08004c30",
            "FUN_08004c48",
            "FUN_08004c52",
            "FUN_08004c5e",
            "FUN_08004c78",
            "FUN_08004c8a",
            "FUN_08004ca2",
            "FUN_08004cb2",
            "FUN_08004cce",
            "FUN_08004ce2",
            "FUN_08004d06",
            "FUN_08004d18",
            "FUN_08004d40",
            "FUN_08004d44",
            "FUN_08004d90",
            "FUN_08004df4",
            "FUN_08004df8",
            "FUN_08004e12",
            "FUN_08004e20",
            "FUN_08004e70",
            "FUN_08004e74",
            "FUN_08004ec4",
            "FUN_08004ef4",
            "FUN_08004f4c",
            "FUN_08005384",
            "FUN_080053d4",
            "FUN_0800548c",
            "FUN_080054b0",
            "FUN_080054d4",
            "FUN_08005510",
            "FUN_08005568",
            "FUN_080055bc",
            "FUN_080055e0",
            "FUN_08005604",
            "FUN_080056d8",
            "FUN_08005714",
            "FUN_0800571a",
            "FUN_08005724",
            "FUN_08005728",
            "FUN_0800572c",
            "FUN_08005730",
            "FUN_0800573c",
            "FUN_08005740",
            "FUN_08005750",
            "FUN_08005754",
            "FUN_080057b4",
            "FUN_08005848",
            "FUN_08005890",
            "FUN_080058e0",
            "FUN_0800591e",
            "FUN_0800598a",
            "FUN_08005a44",
            "FUN_08005a68",
            "FUN_08005b24",
            "FUN_08005b3c",
            "FUN_08005b54",
            "FUN_08005bb0",
            "FUN_08005c1c",
            "FUN_08005c38",
            "FUN_08005c96",
            "FUN_08005cb6",
            "FUN_08005cc0",
            "FUN_08005ce8",
            "FUN_08005d8a",
            "FUN_08005f2c",
            "FUN_08005f6c",
            "FUN_08005f8c",
            "FUN_08005fc8",
            "FUN_080060e4",
            "FUN_08006112",
            "FUN_0800611c",
            "FUN_08006158",
            "FUN_08006174",
            "FUN_08006198",
            "FUN_080061e0",
            "FUN_080061f0",
            "FUN_08006288",
            "FUN_08006344",
            "FUN_08006370",
            "FUN_08006394",
            "FUN_080065c0",
            "FUN_080066b0",
            "FUN_080068f0",
            "FUN_08006920",
            "FUN_080069e4",
            "FUN_08006ac0",
            "FUN_08006be0",
            "FUN_08006c40",
            "FUN_08006c88",
            "FUN_08006cb4",
            "FUN_08006d14",
            "FUN_08006dc8",
            "FUN_08006e10",
            "FUN_08006e90",
            "FUN_08006f00",
            "FUN_08006f38",
            "FUN_08006f5a",
            "FUN_08006f92",
            "FUN_08007004",
            "FUN_08007028",
            "FUN_08007048",
            "FUN_0800706c"
        ],
        [
            "FUN_080004f8",
            "FUN_0800074c",
            "FUN_08000bcc",
            "FUN_080014ba",
            "FUN_080018f8",
            "FUN_08001ab0",
            "FUN_08005cd4",
            "FUN_08005d42",
            "FUN_08005f40",
            "FUN_08005f5e"
        ],
        [
            "FUN_08001510",
            "FUN_08001b18",
            "FUN_08005d82"
        ],
        [
            "FUN_08000cd0",
            "FUN_08005da8"
        ],
        [
            "FUN_080060d4",
            "FUN_08007090"
        ]
    ],
    "locked_functions": []
}