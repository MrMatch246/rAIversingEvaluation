{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_flag_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeFlag_08000110(undefined4 input)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return input;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_flag_08000110",
                "param_1": "input"
            },
            "calling": [],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_64_bit_numbers_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_64_bit_numbers_08000134(undefined4 num1,undefined4 num2)\n\n{\n  return CONCAT44(num2,num1);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_64_bit_numbers_08000134",
                "param_1": "num1",
                "param_2": "num2"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "reverse_bitwise_calculation_08000158",
            "code": "\nulonglong reverseBitwiseCalculation_08000158(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int tempVar1;\n  byte tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  uint computedValue1;\n  uint tempVar6;\n  int tempVar7;\n  uint computedValue2;\n  uint computedValue3;\n  uint computedValue4;\n  uint computedValue5;\n  bool isCondition1True;\n  bool isCondition2True;\n  bool isCondition3True;\n  \n  computedValue1 = input4 ^ 0x80000000;\n  computedValue2 = input2 << 1;\n  input4 = input4 << 1;\n  isCondition1True = ((input2 ^ computedValue1) & 0x7fffffff) == 0;\n  isCondition2True = isCondition1True && input1 == input3;\n  if (!isCondition1True || input1 != input3) {\n    isCondition2True = (computedValue2 | input1) == 0;\n  }\n  if (!isCondition2True) {\n    isCondition2True = (input4 | input3) == 0;\n  }\n  tempVar7 = (int)computedValue2 >> 0x15;\n  if (!isCondition2True) {\n    isCondition2True = tempVar7 == -1;\n  }\n  tempVar1 = (int)input4 >> 0x15;\n  if (!isCondition2True) {\n    isCondition2True = tempVar1 == -1;\n  }\n  if (isCondition2True) {\n    if (tempVar7 == -1 || tempVar1 == -1) {\n      computedValue2 = computedValue1;\n      computedValue4 = input3;\n      if (tempVar7 == -1) {\n        computedValue2 = input2;\n        computedValue4 = input1;\n      }\n      if (tempVar7 != -1 || tempVar1 != -1) {\n        input3 = computedValue4;\n        computedValue1 = computedValue2;\n      }\n      isCondition2True = (computedValue4 | computedValue2 << 0xc) == 0;\n      if (isCondition2True) {\n        isCondition2True = (input3 | computedValue1 << 0xc) == 0;\n      }\n      if (isCondition2True) {\n        isCondition2True = computedValue2 == computedValue1;\n      }\n      if (!isCondition2True) {\n        computedValue2 = computedValue2 | 0x80000;\n      }\n      return CONCAT44(computedValue2,computedValue4);\n    }\n    if (((input2 ^ computedValue1) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((computedValue2 | input1) == 0) {\n        input1 = input3;\n        input2 = computedValue1;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != computedValue1) {\n      return 0;\n    }\n    if (computedValue2 >> 0x15 == 0) {\n      isCondition2True = (input1 & 0x80000000) != 0;\n      computedValue1 = input2 * 2 + (uint)isCondition2True;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)isCondition2True)) {\n        computedValue1 = computedValue1 | 0x80000000;\n      }\n      return CONCAT44(computedValue1,input1 << 1);\n    }\n    if (computedValue2 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  computedValue2 = computedValue2 >> 0x15;\n  input4 = input4 >> 0x15;\n  computedValue4 = input4 - computedValue2;\n  isCondition2True = computedValue4 != 0;\n  if (input4 < computedValue2) {\n    computedValue4 = -computedValue4;\n  }\n  computedValue3 = input1;\n  tempVar6 = input2;\n  if (isCondition2True && computedValue2 <= input4) {\n    computedValue2 = computedValue2 + computedValue4;\n    computedValue3 = input3;\n    tempVar6 = computedValue1;\n    input3 = input1;\n    computedValue1 = input2;\n  }\n  if (0x36 < computedValue4) {\n    return CONCAT44(tempVar6,computedValue3);\n  }\n  tempVar4 = tempVar6 & 0xfffff | 0x100000;\n  if ((tempVar6 & 0x80000000) != 0) {\n    isCondition2True = computedValue3 != 0;\n    computedValue3 = -computedValue3;\n    tempVar4 = -tempVar4 - (uint)isCondition2True;\n  }\n  tempVar6 = computedValue1 & 0xfffff | 0x100000;\n  if ((computedValue1 & 0x80000000) != 0) {\n    isCondition2True = input3 != 0;\n    input3 = -input3;\n    tempVar6 = -tempVar6 - (uint)isCondition2True;\n  }\n  if (computedValue2 == computedValue4) {\n    tempVar6 = tempVar6 ^ 0x100000;\n    if (computedValue2 == 0) {\n      tempVar4 = tempVar4 ^ 0x100000;\n      computedValue2 = 1;\n    }\n    else {\n      computedValue4 = computedValue4 - 1;\n    }\n  }\n  computedValue1 = -computedValue4 + 0x20;\n  if ((int)computedValue4 < 0x21) {\n    computedValue5 = input3 << (computedValue1 & 0xff);\n    input3 = input3 >> (computedValue4 & 0xff);\n    tempVar3 = computedValue3 + input3;\n    tempVar5 = tempVar6 << (computedValue1 & 0xff);\n    computedValue1 = tempVar3 + tempVar5;\n    tempVar4 = tempVar4 + CARRY4(computedValue3,input3) + ((int)tempVar6 >> (computedValue4 & 0xff)) +\n            (uint)CARRY4(tempVar3,tempVar5);\n  }\n  else {\n    computedValue5 = tempVar6 << (-computedValue4 + 0x40 & 0xff);\n    if (input3 != 0) {\n      computedValue5 = computedValue5 | 2;\n    }\n    tempVar6 = (int)tempVar6 >> (computedValue4 - 0x20 & 0xff);\n    computedValue1 = computedValue3 + tempVar6;\n    tempVar4 = tempVar4 + ((int)tempVar6 >> 0x1f) + (uint)CARRY4(computedValue3,tempVar6);\n  }\n  input2 = tempVar4 & 0x80000000;\n  computedValue4 = tempVar4;\n  if ((int)tempVar4 < 0) {\n    isCondition2True = computedValue5 == 0;\n    computedValue5 = -computedValue5;\n    computedValue4 = -computedValue1;\n    computedValue1 = -(uint)!isCondition2True - computedValue1;\n    computedValue4 = -(uint)(isCondition2True <= computedValue4) - tempVar4;\n  }\n  if (0xfffff < computedValue4) {\n    computedValue3 = computedValue2 - 1;\n    if (0x1fffff < computedValue4) {\n      computedValue3 = computedValue4 & 1;\n      computedValue4 = computedValue4 >> 1;\n      tempVar2 = (byte)computedValue1;\n      computedValue1 = (uint)(computedValue3 != 0) << 0x1f | computedValue1 >> 1;\n      computedValue5 = (uint)(tempVar2 & 1) << 0x1f | computedValue5 >> 1;\n      computedValue3 = computedValue2;\n      if (0xffbfffff < computedValue2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    isCondition2True = 0x7fffffff < computedValue5;\n    if (computedValue5 == 0x80000000) {\n      isCondition2True = (computedValue1 & 1) != 0;\n    }\n    return CONCAT44(computedValue4 + computedValue3 * 0x100000 + (uint)CARRY4(computedValue1,(uint)isCondition2True) | input2,\n                    computedValue1 + isCondition2True);\n  }\n  isCondition1True = (computedValue5 & 0x80000000) != 0;\n  computedValue5 = computedValue5 << 1;\n  computedValue3 = computedValue1 * 2;\n  isCondition2True = CARRY4(computedValue1,computedValue1);\n  computedValue1 = computedValue1 * 2 + (uint)isCondition1True;\n  computedValue4 = computedValue4 * 2 + (uint)(isCondition2True || CARRY4(computedValue3,(uint)isCondition1True));\n  computedValue3 = computedValue2 - 2;\n  if ((computedValue4 & 0x100000) != 0) goto LAB_08000268;\n  tempVar6 = computedValue1;\n  computedValue2 = computedValue4;\n  if (computedValue4 == 0) {\n    tempVar6 = 0;\n    computedValue2 = computedValue1;\n  }\n  tempVar7 = LZCOUNT(computedValue2);\n  if (computedValue4 == 0) {\n    tempVar7 = tempVar7 + 0x20;\n  }\n  computedValue4 = tempVar7 - 0xb;\n  isCondition3True = SBORROW4(computedValue4,0x20);\n  computedValue1 = tempVar7 - 0x2b;\n  isCondition2True = (int)computedValue1 < 0;\n  isCondition1True = computedValue1 == 0;\n  if ((int)computedValue4 < 0x20) {\n    isCondition3True = SCARRY4(computedValue1,0xc);\n    tempVar7 = tempVar7 + -0x1f;\n    isCondition2True = tempVar7 < 0;\n    isCondition1True = tempVar7 == 0;\n    computedValue1 = computedValue4;\n    if (!isCondition1True && isCondition2True == isCondition3True) {\n      tempVar6 = computedValue2 << (computedValue4 & 0xff);\n      computedValue2 = computedValue2 >> (0xcU - tempVar7 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isCondition1True || isCondition2True != isCondition3True) {\n    computedValue5 = 0x20 - computedValue1;\n  }\n  computedValue2 = computedValue2 << (computedValue1 & 0xff);\n  if (isCondition1True || isCondition2True != isCondition3True) {\n    computedValue2 = computedValue2 | tempVar6 >> (computedValue5 & 0xff);\n  }\n  if (isCondition1True || isCondition2True != isCondition3True) {\n    tempVar6 = tempVar6 << (computedValue1 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)computedValue4 <= (int)computedValue3) {\n    return CONCAT44(computedValue2 + (computedValue3 - computedValue4) * 0x100000 | input2,tempVar6);\n  }\n  computedValue1 = ~(computedValue3 - computedValue4);\n  if ((int)computedValue1 < 0x1f) {\n    tempVar7 = computedValue1 - 0x13;\n    if (tempVar7 != 0 && tempVar7 < 0 == SCARRY4(computedValue1 - 0x1f,0xc)) {\n      return CONCAT44(tempVar4,tempVar6 >> (0x20 - (0xcU - tempVar7) & 0xff) | computedValue2 << (0xcU - tempVar7 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    computedValue1 = computedValue1 + 1;\n    return CONCAT44(input2 | computedValue2 >> (computedValue1 & 0xff),\n                    tempVar6 >> (computedValue1 & 0xff) | computedValue2 << (0x20 - computedValue1 & 0xff));\n  }\n  return CONCAT44(tempVar4,computedValue2 >> (computedValue1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "reverse_bitwise_calculation_08000158",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar6": "computedValue1",
                "uVar9": "computedValue2",
                "uVar10": "computedValue3",
                "uVar11": "computedValue4",
                "uVar12": "computedValue5",
                "bVar13": "isCondition1True",
                "bVar14": "isCondition2True",
                "bVar15": "isCondition3True",
                "iVar1": "tempVar1",
                "bVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar7": "tempVar6",
                "iVar8": "tempVar7"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_unsigned_long_long_0800015c",
            "code": "\nulonglong calculateUnsignedLongLong_0800015c(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int shiftedBy23Input2;\n  byte carryFlag;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  int shiftedBy23Input4;\n  uint shiftedBy1Input2;\n  uint shiftedBy1Input4;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  bool isZeroDiffInputs;\n  bool cond1;\n  bool cond2;\n  \n  shiftedBy1Input2 = input2 << 1;\n  temp4 = input4 << 1;\n  isZeroDiffInputs = ((input2 ^ input4) & 0x7fffffff) == 0;\n  cond1 = isZeroDiffInputs && input1 == input3;\n  if (!isZeroDiffInputs || input1 != input3) {\n    cond1 = (shiftedBy1Input2 | input1) == 0;\n  }\n  if (!cond1) {\n    cond1 = (temp4 | input3) == 0;\n  }\n  shiftedBy23Input4 = (int)shiftedBy1Input2 >> 0x15;\n  if (!cond1) {\n    cond1 = shiftedBy23Input4 == -1;\n  }\n  shiftedBy23Input2 = (int)temp4 >> 0x15;\n  if (!cond1) {\n    cond1 = shiftedBy23Input2 == -1;\n  }\n  if (cond1) {\n    if (shiftedBy23Input4 == -1 || shiftedBy23Input2 == -1) {\n      temp4 = input4;\n      shiftedBy1Input2 = input3;\n      if (shiftedBy23Input4 == -1) {\n        temp4 = input2;\n        shiftedBy1Input2 = input1;\n      }\n      if (shiftedBy23Input4 != -1 || shiftedBy23Input2 != -1) {\n        input3 = shiftedBy1Input2;\n        input4 = temp4;\n      }\n      cond1 = (shiftedBy1Input2 | temp4 << 0xc) == 0;\n      if (cond1) {\n        cond1 = (input3 | input4 << 0xc) == 0;\n      }\n      if (cond1) {\n        cond1 = temp4 == input4;\n      }\n      if (!cond1) {\n        temp4 = temp4 | 0x80000;\n      }\n      return CONCAT44(temp4,shiftedBy1Input2);\n    }\n    if (((input2 ^ input4) & 0x7fffffff) != 0 || input1 != input3) {\n      if ((shiftedBy1Input2 | input1) == 0) {\n        input1 = input3;\n        input2 = input4;\n      }\n      return CONCAT44(input2,input1);\n    }\n    if (input2 != input4) {\n      return 0;\n    }\n    if (shiftedBy1Input2 >> 0x15 == 0) {\n      cond1 = (input1 & 0x80000000) != 0;\n      temp4 = input2 * 2 + (uint)cond1;\n      if (CARRY4(input2,input2) || CARRY4(input2 * 2,(uint)cond1)) {\n        temp4 = temp4 | 0x80000000;\n      }\n      return CONCAT44(temp4,input1 << 1);\n    }\n    if (shiftedBy1Input2 < 0xffc00000) {\n      return CONCAT44(input2 + 0x100000,input1);\n    }\n    input2 = input2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input2 | 0x7ff00000) << 0x20;\n  }\n  shiftedBy1Input2 = shiftedBy1Input2 >> 0x15;\n  temp4 = temp4 >> 0x15;\n  temp5 = temp4 - shiftedBy1Input2;\n  cond1 = temp5 != 0;\n  if (temp4 < shiftedBy1Input2) {\n    temp5 = -temp5;\n  }\n  shiftedBy1Input4 = input1;\n  temp3 = input2;\n  if (cond1 && shiftedBy1Input2 <= temp4) {\n    shiftedBy1Input2 = shiftedBy1Input2 + temp5;\n    shiftedBy1Input4 = input3;\n    temp3 = input4;\n    input3 = input1;\n    input4 = input2;\n  }\n  if (0x36 < temp5) {\n    return CONCAT44(temp3,shiftedBy1Input4);\n  }\n  temp4 = temp3 & 0xfffff | 0x100000;\n  if ((temp3 & 0x80000000) != 0) {\n    cond1 = shiftedBy1Input4 != 0;\n    shiftedBy1Input4 = -shiftedBy1Input4;\n    temp4 = -temp4 - (uint)cond1;\n  }\n  temp3 = input4 & 0xfffff | 0x100000;\n  if ((input4 & 0x80000000) != 0) {\n    cond1 = input3 != 0;\n    input3 = -input3;\n    temp3 = -temp3 - (uint)cond1;\n  }\n  if (shiftedBy1Input2 == temp5) {\n    temp3 = temp3 ^ 0x100000;\n    if (shiftedBy1Input2 == 0) {\n      temp4 = temp4 ^ 0x100000;\n      shiftedBy1Input2 = 1;\n    }\n    else {\n      temp5 = temp5 - 1;\n    }\n  }\n  temp7 = -temp5 + 0x20;\n  if ((int)temp5 < 0x21) {\n    temp6 = input3 << (temp7 & 0xff);\n    input3 = input3 >> (temp5 & 0xff);\n    temp1 = shiftedBy1Input4 + input3;\n    temp2 = temp3 << (temp7 & 0xff);\n    temp7 = temp1 + temp2;\n    temp4 = temp4 + CARRY4(shiftedBy1Input4,input3) + ((int)temp3 >> (temp5 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    temp6 = temp3 << (-temp5 + 0x40 & 0xff);\n    if (input3 != 0) {\n      temp6 = temp6 | 2;\n    }\n    temp3 = (int)temp3 >> (temp5 - 0x20 & 0xff);\n    temp7 = shiftedBy1Input4 + temp3;\n    temp4 = temp4 + ((int)temp3 >> 0x1f) + (uint)CARRY4(shiftedBy1Input4,temp3);\n  }\n  input2 = temp4 & 0x80000000;\n  temp5 = temp4;\n  if ((int)temp4 < 0) {\n    cond1 = temp6 == 0;\n    temp6 = -temp6;\n    temp5 = -temp7;\n    temp7 = -(uint)!cond1 - temp7;\n    temp5 = -(uint)(cond1 <= temp5) - temp4;\n  }\n  if (0xfffff < temp5) {\n    shiftedBy1Input4 = shiftedBy1Input2 - 1;\n    if (0x1fffff < temp5) {\n      temp4 = temp5 & 1;\n      temp5 = temp5 >> 1;\n      carryFlag = (byte)temp7;\n      temp7 = (uint)(temp4 != 0) << 0x1f | temp7 >> 1;\n      temp6 = (uint)(carryFlag & 1) << 0x1f | temp6 >> 1;\n      shiftedBy1Input4 = shiftedBy1Input2;\n      if (0xffbfffff < shiftedBy1Input2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    cond1 = 0x7fffffff < temp6;\n    if (temp6 == 0x80000000) {\n      cond1 = (temp7 & 1) != 0;\n    }\n    return CONCAT44(temp5 + shiftedBy1Input4 * 0x100000 + (uint)CARRY4(temp7,(uint)cond1) | input2,\n                    temp7 + cond1);\n  }\n  isZeroDiffInputs = (temp6 & 0x80000000) != 0;\n  temp6 = temp6 << 1;\n  shiftedBy1Input4 = temp7 * 2;\n  cond1 = CARRY4(temp7,temp7);\n  temp7 = temp7 * 2 + (uint)isZeroDiffInputs;\n  temp5 = temp5 * 2 + (uint)(cond1 || CARRY4(shiftedBy1Input4,(uint)isZeroDiffInputs));\n  shiftedBy1Input4 = shiftedBy1Input2 - 2;\n  if ((temp5 & 0x100000) != 0) goto LAB_08000268;\n  temp3 = temp7;\n  shiftedBy1Input2 = temp5;\n  if (temp5 == 0) {\n    temp3 = 0;\n    shiftedBy1Input2 = temp7;\n  }\n  shiftedBy23Input4 = LZCOUNT(shiftedBy1Input2);\n  if (temp5 == 0) {\n    shiftedBy23Input4 = shiftedBy23Input4 + 0x20;\n  }\n  temp7 = shiftedBy23Input4 - 0xb;\n  cond2 = SBORROW4(temp7,0x20);\n  temp5 = shiftedBy23Input4 - 0x2b;\n  cond1 = (int)temp5 < 0;\n  isZeroDiffInputs = temp5 == 0;\n  if ((int)temp7 < 0x20) {\n    cond2 = SCARRY4(temp5,0xc);\n    shiftedBy23Input4 = shiftedBy23Input4 + -0x1f;\n    cond1 = shiftedBy23Input4 < 0;\n    isZeroDiffInputs = shiftedBy23Input4 == 0;\n    temp5 = temp7;\n    if (!isZeroDiffInputs && cond1 == cond2) {\n      temp3 = shiftedBy1Input2 << (temp7 & 0xff);\n      shiftedBy1Input2 = shiftedBy1Input2 >> (0xcU - shiftedBy23Input4 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isZeroDiffInputs || cond1 != cond2) {\n    temp6 = 0x20 - temp5;\n  }\n  shiftedBy1Input2 = shiftedBy1Input2 << (temp5 & 0xff);\n  if (isZeroDiffInputs || cond1 != cond2) {\n    shiftedBy1Input2 = shiftedBy1Input2 | temp3 >> (temp6 & 0xff);\n  }\n  if (isZeroDiffInputs || cond1 != cond2) {\n    temp3 = temp3 << (temp5 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp7 <= (int)shiftedBy1Input4) {\n    return CONCAT44(shiftedBy1Input2 + (shiftedBy1Input4 - temp7) * 0x100000 | input2,temp3);\n  }\n  temp5 = ~(shiftedBy1Input4 - temp7);\n  if ((int)temp5 < 0x1f) {\n    shiftedBy23Input4 = temp5 - 0x13;\n    if (shiftedBy23Input4 != 0 && shiftedBy23Input4 < 0 == SCARRY4(temp5 - 0x1f,0xc)) {\n      return CONCAT44(temp4,temp3 >> (0x20 - (0xcU - shiftedBy23Input4) & 0xff) | shiftedBy1Input2 << (0xcU - shiftedBy23Input4 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    temp5 = temp5 + 1;\n    return CONCAT44(input2 | shiftedBy1Input2 >> (temp5 & 0xff),\n                    temp3 >> (temp5 & 0xff) | shiftedBy1Input2 << (0x20 - temp5 & 0xff));\n  }\n  return CONCAT44(temp4,shiftedBy1Input2 >> (temp5 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_unsigned_long_long_0800015c",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftedBy23Input2",
                "bVar2": "carryFlag",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "uVar5": "temp3",
                "iVar6": "shiftedBy23Input4",
                "uVar7": "shiftedBy1Input2",
                "uVar8": "shiftedBy1Input4",
                "uVar9": "temp4",
                "uVar10": "temp5",
                "uVar11": "temp6",
                "uVar12": "temp7",
                "bVar13": "isZeroDiffInputs",
                "bVar14": "cond1",
                "bVar15": "cond2"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "extract_bits_080003d4",
            "code": "\nulonglong extract_bits_080003d4(uint input)\n\n{\n  uint result;\n  uint shift_amount;\n  int leading_zeros;\n  uint adjusted_shift;\n  uint mask;\n  bool is_negative;\n  bool is_zero;\n  bool overflow;\n  \n  if (input == 0) {\n    return 0;\n  }\n  result = 0;\n  leading_zeros = LZCOUNT(input);\n  adjusted_shift = leading_zeros + 0x15;\n  overflow = SBORROW4(adjusted_shift,0x20);\n  shift_amount = leading_zeros - 0xb;\n  is_negative = (int)shift_amount < 0;\n  is_zero = shift_amount == 0;\n  if (adjusted_shift < 0x20) {\n    overflow = SCARRY4(shift_amount,0xc);\n    is_negative = false;\n    is_zero = leading_zeros + 1 == 0;\n    shift_amount = adjusted_shift;\n    if (!is_zero && overflow == false) {\n      result = input << adjusted_shift;\n      input = input >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero || is_negative != overflow) {\n    mask = 0x20 - shift_amount;\n  }\n  input = input << (shift_amount & 0xff);\n  if (is_zero || is_negative != overflow) {\n    input = input | 0U >> (mask & 0xff);\n  }\n  if (is_zero || is_negative != overflow) {\n    result = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if (adjusted_shift < 0x433) {\n    return CONCAT44(input + (0x432 - adjusted_shift) * 0x100000,result);\n  }\n  shift_amount = ~(0x432 - adjusted_shift);\n  if (0x1e < (int)shift_amount) {\n    return (ulonglong)(input >> (shift_amount - 0x1f & 0xff));\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(input >> (shift_amount & 0xff),\n                    result >> (shift_amount & 0xff) | input << (0x20 - shift_amount & 0xff));\n  }\n  return (ulonglong)(result >> (0x20 - (0xcU - leading_zeros) & 0xff) | input << (0xcU - leading_zeros & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "extract_bits_080003d4",
                "param_1": "input",
                "uVar1": "result",
                "uVar2": "shift_amount",
                "iVar3": "leading_zeros",
                "uVar4": "adjusted_shift",
                "in_r12": "mask",
                "bVar5": "is_negative",
                "bVar6": "is_zero",
                "bVar7": "overflow"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "shift_and_combine_080003f4",
            "code": "\nulonglong shift_and_combine_080003f4(uint number)\n\n{\n  uint temp1;\n  uint absolute_number;\n  uint shift_amount;\n  int leading_zeros;\n  uint adjusted_shift_amount;\n  uint sign_bit;\n  uint remaining_bits;\n  bool is_negative;\n  bool is_zero;\n  bool carry;\n  \n  if (number == 0) {\n    return 0;\n  }\n  sign_bit = number & 0x80000000;\n  absolute_number = number;\n  if ((int)sign_bit < 0) {\n    absolute_number = -number;\n  }\n  temp1 = 0;\n  leading_zeros = leading_zero_count(absolute_number);\n  adjusted_shift_amount = leading_zeros + 0x15;\n  carry = signed_borrow_4(adjusted_shift_amount,0x20);\n  shift_amount = leading_zeros - 0xb;\n  is_negative = (int)shift_amount < 0;\n  is_zero = shift_amount == 0;\n  if (adjusted_shift_amount < 0x20) {\n    carry = signed_carry_4(shift_amount,0xc);\n    is_negative = false;\n    is_zero = leading_zeros + 1 == 0;\n    shift_amount = adjusted_shift_amount;\n    if (!is_zero && carry == false) {\n      temp1 = absolute_number << adjusted_shift_amount;\n      absolute_number = absolute_number >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_zero || is_negative != carry) {\n    remaining_bits = 0x20 - shift_amount;\n  }\n  absolute_number = absolute_number << (shift_amount & 0xff);\n  if (is_zero || is_negative != carry) {\n    absolute_number = absolute_number | 0U >> (remaining_bits & 0xff);\n  }\n  if (is_zero || is_negative != carry) {\n    temp1 = 0 << (shift_amount & 0xff);\n  }\nLAB_080002e0:\n  if (adjusted_shift_amount < 0x433) {\n    return CONCAT44(absolute_number + (0x432 - adjusted_shift_amount) * 0x100000 | sign_bit,temp1);\n  }\n  shift_amount = ~(0x432 - adjusted_shift_amount);\n  if (0x1e < (int)shift_amount) {\n    return CONCAT44(number,absolute_number >> (shift_amount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shift_amount - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != signed_carry_4(shift_amount - 0x1f,0xc)) {\n    shift_amount = shift_amount + 1;\n    return CONCAT44(sign_bit | absolute_number >> (shift_amount & 0xff),\n                    temp1 >> (shift_amount & 0xff) | absolute_number << (0x20 - shift_amount & 0xff));\n  }\n  return CONCAT44(number,temp1 >> (0x20 - (0xcU - leading_zeros) & 0xff) | absolute_number << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "shift_and_combine_080003f4",
                "param_1": "number",
                "uVar1": "temp1",
                "uVar2": "absolute_number",
                "uVar3": "shift_amount",
                "iVar4": "leading_zeros",
                "uVar5": "adjusted_shift_amount",
                "uVar6": "sign_bit",
                "in_r12": "remaining_bits",
                "bVar7": "is_negative",
                "bVar8": "is_zero",
                "bVar9": "carry",
                "LZCOUNT": "leading_zero_count",
                "SBORROW4": "signed_borrow_4",
                "SCARRY4": "signed_carry_4"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "bitwise_computation_08000418",
            "code": "\nulonglong bitwiseComputation_08000418(uint input,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint bit31Shifted;\n  uint temp1;\n  uint bit31ShiftedOrRightShifted;\n  uint rightShiftedValue;\n  uint multipliedBy2;\n  int numberOfLeadingZeros;\n  uint subtract11;\n  uint subtract32MinusShiftAmount;\n  bool lessThan32;\n  bool param4Equals0;\n  bool subtract11Equals0;\n  \n  multipliedBy2 = input << 1;\n  param4Equals0 = multipliedBy2 == 0;\n  bit31Shifted = (uint)((input & 0x80000000) != 0) << 0x1f;\n  rightShiftedValue = (uint)((int)multipliedBy2 >> 3) >> 1;\n  bit31ShiftedOrRightShifted = bit31Shifted | rightShiftedValue;\n  input = input << 0x1d;\n  if (!param4Equals0) {\n    param4 = multipliedBy2 & 0xff000000;\n    param4Equals0 = param4 == 0;\n  }\n  if (!param4Equals0) {\n    param4Equals0 = param4 == 0xff000000;\n  }\n  if (!param4Equals0) {\n    return concatenate(bit31ShiftedOrRightShifted,input) ^ 0x3800000000000000;\n  }\n  if ((multipliedBy2 & 0xffffff) == 0) {\n    return concatenate(bit31ShiftedOrRightShifted,input);\n  }\n  if (param4 == 0xff000000) {\n    return concatenate(bit31ShiftedOrRightShifted,input) | 0x8000000000000;\n  }\n  temp1 = input;\n  multipliedBy2 = rightShiftedValue;\n  if (rightShiftedValue == 0) {\n    temp1 = 0;\n    multipliedBy2 = input;\n  }\n  numberOfLeadingZeros = countLeadingZeros(multipliedBy2);\n  if (rightShiftedValue == 0) {\n    numberOfLeadingZeros = numberOfLeadingZeros + 0x20;\n  }\n  subtract11 = numberOfLeadingZeros - 0xb;\n  subtract11Equals0 = subtractBorrow4(subtract11,0x20);\n  rightShiftedValue = numberOfLeadingZeros - 0x2b;\n  param4Equals0 = (int)rightShiftedValue < 0;\n  lessThan32 = rightShiftedValue == 0;\n  if ((int)subtract11 < 0x20) {\n    subtract11Equals0 = subtractCarry4(rightShiftedValue,0xc);\n    numberOfLeadingZeros = numberOfLeadingZeros + -0x1f;\n    param4Equals0 = numberOfLeadingZeros < 0;\n    lessThan32 = numberOfLeadingZeros == 0;\n    rightShiftedValue = subtract11;\n    if (!lessThan32 && param4Equals0 == subtract11Equals0) {\n      temp1 = multipliedBy2 << (subtract11 & 0xff);\n      multipliedBy2 = multipliedBy2 >> (0xcU - numberOfLeadingZeros & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (lessThan32 || param4Equals0 != subtract11Equals0) {\n    subtract32MinusShiftAmount = 0x20 - rightShiftedValue;\n  }\n  multipliedBy2 = multipliedBy2 << (rightShiftedValue & 0xff);\n  if (lessThan32 || param4Equals0 != subtract11Equals0) {\n    multipliedBy2 = multipliedBy2 | temp1 >> (subtract32MinusShiftAmount & 0xff);\n  }\n  if (lessThan32 || param4Equals0 != subtract11Equals0) {\n    temp1 = temp1 << (rightShiftedValue & 0xff);\n  }\nLAB_080002e0:\n  if ((int)subtract11 < 0x381) {\n    return concatenate(multipliedBy2 + (0x380 - subtract11) * 0x100000 | bit31Shifted,temp1);\n  }\n  rightShiftedValue = ~(0x380 - subtract11);\n  if (0x1e < (int)rightShiftedValue) {\n    return concatenate(bit31ShiftedOrRightShifted,multipliedBy2 >> (rightShiftedValue - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  numberOfLeadingZeros = rightShiftedValue - 0x13;\n  if (numberOfLeadingZeros == 0 || numberOfLeadingZeros < 0 != subtractCarry4(rightShiftedValue - 0x1f,0xc)) {\n    rightShiftedValue = rightShiftedValue + 1;\n    return concatenate(bit31Shifted | multipliedBy2 >> (rightShiftedValue & 0xff),\n                    temp1 >> (rightShiftedValue & 0xff) | multipliedBy2 << (0x20 - rightShiftedValue & 0xff));\n  }\n  return concatenate(bit31ShiftedOrRightShifted,temp1 >> (0x20 - (0xcU - numberOfLeadingZeros) & 0xff) | multipliedBy2 << (0xcU - numberOfLeadingZeros & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "bitwise_computation_08000418",
                "param_1": "input",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "bit31Shifted",
                "uVar2": "temp1",
                "uVar3": "bit31ShiftedOrRightShifted",
                "uVar4": "rightShiftedValue",
                "uVar5": "multipliedBy2",
                "iVar6": "numberOfLeadingZeros",
                "uVar7": "subtract11",
                "in_r12": "subtract32MinusShiftAmount",
                "bVar8": "lessThan32",
                "bVar9": "param4Equals0",
                "bVar10": "subtract11Equals0",
                "LZCOUNT": "countLeadingZeros",
                "SCARRY4": "subtractCarry4",
                "CONCAT44": "concatenate",
                "SBORROW4": "subtractBorrow4"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_080004c8",
            "code": "\nulonglong calculate_080004c8(undefined4 arg1,uint arg2,uint arg3,uint arg4)\n\n{\n  ulonglong result;\n  longlong temp;\n  uint highBitsArg2;\n  uint highBitsArg2Shifted;\n  int sumHighBits;\n  uint difference;\n  uint highBitsArg4;\n  uint carry;\n  uint resultHighBits;\n  bool isZero;\n  bool isNegative;\n  bool isLess;\n  ulonglong concatData;\n  \n  concatData = CONCAT44(arg2,arg1);\n  carry = 0x7ff;\n  highBitsArg2Shifted = arg2 >> 0x14 & 0x7ff;\n  isZero = highBitsArg2Shifted == 0;\n  if (!isZero) {\n    highBitsArg4 = arg4 >> 0x14 & 0x7ff;\n    isZero = highBitsArg4 == 0;\n  }\n  if (!isZero) {\n    isZero = highBitsArg2Shifted == 0x7ff;\n  }\n  if (!isZero) {\n    isZero = highBitsArg4 == 0x7ff;\n  }\n  if (isZero) {\n    concatData = calculate_080004c8_bitwise_result_080006a4();\n  }\n  highBitsArg2 = (uint)(concatData >> 0x20);\n  sumHighBits = highBitsArg2Shifted + highBitsArg4;\n  highBitsArg2Shifted = highBitsArg2 ^ arg4;\n  highBitsArg2 = highBitsArg2 & ~(carry << 0x15);\n  arg4 = arg4 & ~(carry << 0x15);\n  isZero = ((uint)concatData | highBitsArg2 << 0xc) == 0;\n  if (!isZero) {\n    isZero = (arg3 | arg4 << 0xc) == 0;\n  }\n  highBitsArg2 = highBitsArg2 | 0x100000;\n  arg4 = arg4 | 0x100000;\n  if (isZero) {\n    arg3 = (uint)concatData | arg3;\n    arg4 = (highBitsArg2Shifted & 0x80000000 | highBitsArg2) ^ arg4;\n    highBitsArg2Shifted = carry >> 1;\n    isLess = SBORROW4(sumHighBits,highBitsArg2Shifted);\n    difference = sumHighBits - highBitsArg2Shifted;\n    isZero = difference == 0;\n    highBitsArg2 = difference;\n    if (!isZero && (int)highBitsArg2Shifted <= sumHighBits) {\n      isLess = SBORROW4(carry,difference);\n      highBitsArg2 = carry - difference;\n      isZero = carry == difference;\n    }\n    if (!isZero && (int)highBitsArg2 < 0 == isLess) {\n      arg4 = arg4 | difference * 0x100000;\n    }\n    if (!isZero && (int)highBitsArg2 < 0 == isLess) {\n      return CONCAT44(arg4,arg3);\n    }\n    arg4 = arg4 | 0x100000;\n    carry = 0;\n    isLess = SBORROW4(difference,1);\n    difference = difference - 1;\n    isZero = difference == 0;\n    highBitsArg2Shifted = difference;\n  }\n  else {\n    result = (concatData & 0xffffffff) * (ulonglong)arg3;\n    concatData = (concatData & 0xffffffff) * (ulonglong)arg4 +\n             (ulonglong)highBitsArg2 * (ulonglong)arg3 + (result >> 0x20);\n    resultHighBits = (uint)concatData;\n    temp = (ulonglong)highBitsArg2 * (ulonglong)arg4 + (concatData >> 0x20);\n    carry = (uint)temp;\n    highBitsArg2 = (uint)((ulonglong)temp >> 0x20);\n    if ((int)result != 0) {\n      resultHighBits = resultHighBits | 1;\n    }\n    difference = (sumHighBits + -0x3ff) - (uint)(highBitsArg2 < 0x200);\n    if (highBitsArg2 < 0x200) {\n      isZero = (resultHighBits & 0x80000000) != 0;\n      resultHighBits = resultHighBits << 1;\n      temp = CONCAT44(highBitsArg2 * 2 + (uint)(CARRY4(carry,carry) || CARRY4(carry * 2,(uint)isZero)),\n                       carry * 2 + (uint)isZero);\n    }\n    arg4 = highBitsArg2Shifted & 0x80000000 | (int)((ulonglong)temp >> 0x20) << 0xb | (uint)temp >> 0x15;\n    arg3 = (uint)temp << 0xb | resultHighBits >> 0x15;\n    carry = resultHighBits * 0x800;\n    isNegative = 0xfc < difference;\n    isLess = SBORROW4(difference,0xfd);\n    highBitsArg2 = difference - 0xfd;\n    isZero = highBitsArg2 == 0;\n    highBitsArg2Shifted = highBitsArg2;\n    if (isNegative && !isZero) {\n      isNegative = 0x6ff < highBitsArg2;\n      isLess = SBORROW4(highBitsArg2,0x700);\n      highBitsArg2Shifted = difference - 0x7fd;\n      isZero = highBitsArg2 == 0x700;\n    }\n    if (!isNegative || isZero) {\n      isZero = 0x7fffffff < carry;\n      if (carry == 0x80000000) {\n        isZero = (resultHighBits >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(arg4 + difference * 0x100000 + (uint)CARRY4(arg3,(uint)isZero),arg3 + isZero\n                     );\n    }\n  }\n  if (!isZero && (int)highBitsArg2Shifted < 0 == isLess) {\n    return (ulonglong)(arg4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  isNegative = SCARRY4(difference,0x36);\n  isZero = (int)(difference + 0x36) < 0;\n  isLess = difference == 0xffffffca;\n  if (isLess || isZero != isNegative) {\n    arg3 = 0;\n  }\n  if (isLess || isZero != isNegative) {\n    arg4 = arg4 & 0x80000000;\n  }\n  if (isLess || isZero != isNegative) {\n    return CONCAT44(arg4,arg3);\n  }\n  highBitsArg2Shifted = -difference;\n  highBitsArg2 = highBitsArg2Shifted - 0x20;\n  if (0x1f < (int)highBitsArg2Shifted) {\n    difference = arg3 >> (highBitsArg2 & 0xff) | arg4 << (0x20 - highBitsArg2 & 0xff);\n    highBitsArg2Shifted = (arg4 >> (highBitsArg2 & 0xff) & ~((arg4 & 0x80000000) >> (highBitsArg2 & 0xff))) -\n            ((int)difference >> 0x1f);\n    if ((carry | arg3 << (0x20 - highBitsArg2 & 0xff) | difference << 1) == 0) {\n      highBitsArg2Shifted = highBitsArg2Shifted & ~(difference >> 0x1f);\n    }\n    return CONCAT44(arg4,highBitsArg2Shifted) & 0x80000000ffffffff;\n  }\n  sumHighBits = highBitsArg2Shifted - 0x14;\n  if (sumHighBits == 0 || sumHighBits < 0 != SCARRY4(highBitsArg2,0xc)) {\n    resultHighBits = arg3 << (difference + 0x20 & 0xff);\n    highBitsArg2 = arg3 >> (highBitsArg2Shifted & 0xff) | arg4 << (difference + 0x20 & 0xff);\n    difference = highBitsArg2 + -((int)resultHighBits >> 0x1f);\n    if ((carry | resultHighBits << 1) == 0) {\n      difference = difference & ~(resultHighBits >> 0x1f);\n    }\n    return CONCAT44((arg4 & 0x80000000) +\n                    ((arg4 & 0x7fffffff) >> (highBitsArg2Shifted & 0xff)) +\n                    (uint)CARRY4(highBitsArg2,-((int)resultHighBits >> 0x1f)),difference);\n  }\n  highBitsArg2Shifted = 0xc - sumHighBits;\n  difference = arg3 << (highBitsArg2Shifted & 0xff);\n  highBitsArg2Shifted = arg3 >> (0x20 - highBitsArg2Shifted & 0xff) | arg4 << (highBitsArg2Shifted & 0xff);\n  highBitsArg2 = highBitsArg2Shifted + -((int)difference >> 0x1f);\n  if ((carry | difference << 1) == 0) {\n    highBitsArg2 = highBitsArg2 & ~(difference >> 0x1f);\n  }\n  return CONCAT44((arg4 & 0x80000000) + (uint)CARRY4(highBitsArg2Shifted,-((int)difference >> 0x1f)),highBitsArg2);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_080004c8",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "uVar1": "result",
                "lVar2": "temp",
                "uVar3": "highBitsArg2",
                "uVar4": "highBitsArg2Shifted",
                "iVar5": "sumHighBits",
                "uVar6": "difference",
                "unaff_r5": "highBitsArg4",
                "uVar7": "carry",
                "uVar8": "resultHighBits",
                "bVar9": "isZero",
                "bVar10": "isNegative",
                "bVar11": "isLess",
                "uVar12": "concatData"
            },
            "calling": [
                "frexp",
                "atan",
                "_dtoa_r",
                "mpu6050_calc_pitch",
                "_svfprintf_r",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "calculate_bitwise_result_080006a4",
            "code": "\nulonglong calculate_bitwise_result_080006a4(uint input_param_1,uint input_param_2,uint input_param_3,uint input_param_4)\n\n{\n  uint temp_var_1;\n  uint temp_var_2;\n  uint temp_var_3;\n  uint temp_var_4;\n  uint temp_var_5;\n  bool temp_var_6;\n  \n  temp_var_3 = temp_var_5 & input_param_4 >> 0x14;\n  if (temp_var_2 != temp_var_5 && temp_var_3 != temp_var_5) {\n    temp_var_6 = (input_param_1 | input_param_2 << 1) == 0;\n    if (!temp_var_6) {\n      temp_var_6 = (input_param_3 | input_param_4 << 1) == 0;\n    }\n    if (temp_var_6) {\n      return (ulonglong)((input_param_2 ^ input_param_4) & 0x80000000) << 0x20;\n    }\n    if (temp_var_2 == 0) {\n      temp_var_4 = input_param_2 & 0x80000000;\n      do {\n        temp_var_1 = input_param_1 & 0x80000000;\n        input_param_1 = input_param_1 << 1;\n        input_param_2 = input_param_2 * 2 + (uint)(temp_var_1 != 0);\n      } while ((input_param_2 & 0x100000) == 0);\n      input_param_2 = input_param_2 | temp_var_4;\n      if (temp_var_3 != 0) {\n        return CONCAT44(input_param_2,input_param_1);\n      }\n    }\n    do {\n      temp_var_3 = input_param_3 & 0x80000000;\n      input_param_3 = input_param_3 << 1;\n      input_param_4 = input_param_4 * 2 + (uint)(temp_var_3 != 0);\n    } while ((input_param_4 & 0x100000) == 0);\n    return CONCAT44(input_param_2,input_param_1);\n  }\n  temp_var_6 = (input_param_1 | input_param_2 << 1) == 0;\n  if (temp_var_6) {\n    input_param_2 = input_param_4;\n    input_param_1 = input_param_3;\n  }\n  if (!temp_var_6) {\n    temp_var_6 = (input_param_3 | input_param_4 << 1) == 0;\n  }\n  temp_var_4 = input_param_2;\n  if (((!temp_var_6) && ((temp_var_2 != temp_var_5 || ((input_param_1 | input_param_2 << 0xc) == 0)))) &&\n     ((temp_var_3 != temp_var_5 || (input_param_1 = input_param_3, temp_var_4 = input_param_4, (input_param_3 | input_param_4 << 0xc) == 0)))) {\n    return (ulonglong)((input_param_2 ^ input_param_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(temp_var_4,input_param_1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "calculate_bitwise_result_080006a4",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "temp_var_1",
                "unaff_r4": "temp_var_2",
                "uVar2": "temp_var_3",
                "uVar3": "temp_var_4",
                "in_r12": "temp_var_5",
                "bVar4": "temp_var_6"
            },
            "calling": [
                "__muldf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "calculate_floating_point_0800071c",
            "code": "\nulonglong calculateFloatingPoint_0800071c(undefined4 inputSign,uint inputExponent,uint inputMantissaH,uint inputMantissaL)\n\n{\n  uint normalizedMantissaH;\n  uint normalizedMantissaL;\n  uint exponentDistance;\n  uint exponentDiff;\n  uint shiftedMantissaH;\n  uint shiftedMantissaL;\n  uint resultSign;\n  int exponentDiffSign;\n  uint exponentSum;\n  uint inputExponentL;\n  uint bitSum1;\n  uint resultExponent;\n  uint mantissaDiff;\n  uint resultMantissaH;\n  bool isNormal;\n  bool isZero;\n  bool carry;\n  undefined8 result;\n  \n  result = CONCAT44(inputExponent,inputSign);\n  resultMantissaH = 0x7ff;\n  resultSign = inputExponent >> 0x14 & 0x7ff;\n  isNormal = resultSign == 0;\n  if (!isNormal) {\n    inputExponentL = inputMantissaL >> 0x14 & 0x7ff;\n    isNormal = inputExponentL == 0;\n  }\n  if (!isNormal) {\n    isNormal = resultSign == 0x7ff;\n  }\n  if (!isNormal) {\n    isNormal = inputExponentL == 0x7ff;\n  }\n  if (isNormal) {\n    result = binary_to_double_0800088a();\n  }\n  exponentSum = (uint)((ulonglong)result >> 0x20);\n  resultExponent = (uint)result;\n  exponentDiffSign = resultSign - inputExponentL;\n  if ((inputMantissaH | inputMantissaL << 0xc) == 0) {\n    resultSign = (exponentSum ^ inputMantissaL) & 0x80000000 | exponentSum & 0xfffff;\n    carry = SCARRY4(exponentDiffSign,resultMantissaH >> 1);\n    exponentSum = exponentDiffSign + (resultMantissaH >> 1);\n    isNormal = (int)exponentSum < 0;\n    isZero = exponentSum == 0;\n    if (!isZero && isNormal == carry) {\n      carry = SBORROW4(resultMantissaH,exponentSum);\n      isNormal = (int)(resultMantissaH - exponentSum) < 0;\n      isZero = resultMantissaH == exponentSum;\n    }\n    if (!isZero && isNormal == carry) {\n      resultSign = resultSign | exponentSum * 0x100000;\n    }\n    if (!isZero && isNormal == carry) {\n      return CONCAT44(resultSign,resultExponent);\n    }\n    resultSign = resultSign | 0x100000;\n    resultMantissaH = 0;\n    isZero = SBORROW4(exponentSum,1);\n    exponentSum = exponentSum - 1;\n    isNormal = exponentSum == 0;\n    exponentDistance = exponentSum;\n  }\n  else {\n    exponentDistance = (inputMantissaL << 0xc) >> 4 | 0x10000000 | inputMantissaH >> 0x18;\n    resultMantissaH = inputMantissaH << 8;\n    bitSum1 = (exponentSum << 0xc) >> 4 | 0x10000000 | resultExponent >> 0x18;\n    resultExponent = resultExponent * 0x100;\n    resultSign = (exponentSum ^ inputMantissaL) & 0x80000000;\n    isNormal = exponentDistance <= bitSum1;\n    if (bitSum1 == exponentDistance) {\n      isNormal = resultMantissaH <= resultExponent;\n    }\n    exponentDiffSign = exponentDiffSign + (uint)isNormal;\n    exponentSum = exponentDiffSign + 0x3fd;\n    if (isNormal == false) {\n      exponentDistance = exponentDistance >> 1;\n      resultMantissaH = (uint)((inputMantissaH >> 0x18 & 1) != 0) << 0x1f | resultMantissaH >> 1;\n    }\n    mantissaDiff = resultExponent - resultMantissaH;\n    bitSum1 = (bitSum1 - exponentDistance) - (uint)(resultExponent < resultMantissaH);\n    exponentDiff = exponentDistance >> 1;\n    normalizedMantissaH = (uint)((exponentDistance & 1) != 0) << 0x1f | resultMantissaH >> 1;\n    resultExponent = 0x100000;\n    exponentDistance = 0x80000;\n    while( true ) {\n      isNormal = normalizedMantissaH <= mantissaDiff;\n      if (exponentDiff < bitSum1 || bitSum1 - exponentDiff < (uint)isNormal) {\n        mantissaDiff = mantissaDiff - normalizedMantissaH;\n        resultExponent = resultExponent | exponentDistance;\n        bitSum1 = (bitSum1 - exponentDiff) - (uint)!isNormal;\n      }\n      shiftedMantissaH = exponentDiff >> 1;\n      normalizedMantissaH = (uint)((exponentDiff & 1) != 0) << 0x1f | normalizedMantissaH >> 1;\n      isZero = normalizedMantissaH <= mantissaDiff;\n      isNormal = bitSum1 - shiftedMantissaH < (uint)isZero;\n      resultMantissaH = bitSum1;\n      if (shiftedMantissaH < bitSum1 || isNormal) {\n        mantissaDiff = mantissaDiff - normalizedMantissaH;\n        resultMantissaH = (bitSum1 - shiftedMantissaH) - (uint)!isZero;\n      }\n      if (shiftedMantissaH < bitSum1 || isNormal) {\n        resultExponent = resultExponent | exponentDistance >> 1;\n      }\n      bitSum1 = exponentDiff >> 2;\n      normalizedMantissaL = (uint)((shiftedMantissaH & 1) != 0) << 0x1f | normalizedMantissaH >> 1;\n      isZero = normalizedMantissaL <= mantissaDiff;\n      isNormal = resultMantissaH - bitSum1 < (uint)isZero;\n      shiftedMantissaH = resultMantissaH;\n      if (bitSum1 < resultMantissaH || isNormal) {\n        mantissaDiff = mantissaDiff - normalizedMantissaL;\n        shiftedMantissaH = (resultMantissaH - bitSum1) - (uint)!isZero;\n      }\n      if (bitSum1 < resultMantissaH || isNormal) {\n        resultExponent = resultExponent | exponentDistance >> 2;\n      }\n      shiftedMantissaL = exponentDiff >> 3;\n      normalizedMantissaH = (uint)((bitSum1 & 1) != 0) << 0x1f | normalizedMantissaL >> 1;\n      isZero = normalizedMantissaH <= mantissaDiff;\n      isNormal = shiftedMantissaH - shiftedMantissaL < (uint)isZero;\n      bitSum1 = shiftedMantissaH;\n      if (shiftedMantissaL < shiftedMantissaH || isNormal) {\n        mantissaDiff = mantissaDiff - normalizedMantissaH;\n        bitSum1 = (shiftedMantissaH - shiftedMantissaL) - (uint)!isZero;\n      }\n      if (shiftedMantissaL < shiftedMantissaH || isNormal) {\n        resultExponent = resultExponent | exponentDistance >> 3;\n      }\n      resultMantissaH = bitSum1 | mantissaDiff;\n      if (resultMantissaH == 0) break;\n      bitSum1 = bitSum1 << 4 | mantissaDiff >> 0x1c;\n      mantissaDiff = mantissaDiff << 4;\n      exponentDiff = exponentDiff & 0xfffffff8 | normalizedMantissaH >> 0x1d;\n      normalizedMantissaH = (normalizedMantissaL >> 1) << 3;\n      exponentDistance = exponentDistance >> 4;\n      if (exponentDistance == 0) {\n        shiftedMantissaL = exponentDiff;\n        if ((resultSign & 0x100000) != 0) goto LAB_0800083a;\n        resultSign = resultSign | resultExponent;\n        resultExponent = 0;\n        exponentDistance = 0x80000000;\n      }\n    }\n    if ((resultSign & 0x100000) == 0) {\n      resultSign = resultSign | resultExponent;\n      resultExponent = 0;\n    }\nLAB_0800083a:\n    carry = 0xfc < exponentSum;\n    isZero = SBORROW4(exponentSum,0xfd);\n    exponentDiff = exponentDiffSign + 0x300;\n    isNormal = exponentDiff == 0;\n    exponentDistance = exponentDiff;\n    if (carry && !isNormal) {\n      carry = 0x6ff < exponentDiff;\n      isZero = SBORROW4(exponentDiff,0x700);\n      exponentDistance = exponentDiffSign - 0x400;\n      isNormal = exponentDiff == 0x700;\n    }\n    if (!carry || isNormal) {\n      isNormal = shiftedMantissaL <= bitSum1;\n      if (bitSum1 == shiftedMantissaL) {\n        isNormal = normalizedMantissaH <= mantissaDiff;\n      }\n      if (bitSum1 == shiftedMantissaL && mantissaDiff == normalizedMantissaH) {\n        isNormal = (resultExponent & 1) != 0;\n      }\n      return CONCAT44(resultSign + exponentSum * 0x100000 + (uint)CARRY4(resultExponent,(uint)isNormal),resultExponent + isNormal);\n    }\n  }\n  if (!isNormal && (int)exponentDistance < 0 == isZero) {\n    return (ulonglong)(resultSign & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  carry = SCARRY4(exponentSum,0x36);\n  isNormal = (int)(exponentSum + 0x36) < 0;\n  isZero = exponentSum == 0xffffffca;\n  if (isZero || isNormal != carry) {\n    resultExponent = 0;\n  }\n  if (isZero || isNormal != carry) {\n    resultSign = resultSign & 0x80000000;\n  }\n  if (isZero || isNormal != carry) {\n    return CONCAT44(resultSign,resultExponent);\n  }\n  exponentDistance = -exponentSum;\n  bitSum1 = exponentDistance - 0x20;\n  if (0x1f < (int)exponentDistance) {\n    exponentDistance = resultExponent >> (bitSum1 & 0xff) | resultSign << (0x20 - bitSum1 & 0xff);\n    exponentSum = (resultSign >> (bitSum1 & 0xff) & ~((resultSign & 0x80000000) >> (bitSum1 & 0xff))) -\n            ((int)exponentDistance >> 0x1f);\n    if ((resultMantissaH | resultExponent << (0x20 - bitSum1 & 0xff) | exponentDistance << 1) == 0) {\n      exponentSum = exponentSum & ~(exponentDistance >> 0x1f);\n    }\n    return CONCAT44(resultSign,exponentSum) & 0x80000000ffffffff;\n  }\n  exponentDiffSign = exponentDistance - 0x14;\n  if (exponentDiffSign != 0 && exponentDiffSign < 0 == SCARRY4(bitSum1,0xc)) {\n    exponentSum = 0xc - exponentDiffSign;\n    exponentDistance = resultExponent << (exponentSum & 0xff);\n    resultExponent = resultExponent >> (0x20 - exponentSum & 0xff) | resultSign << (exponentSum & 0xff);\n    exponentSum = resultExponent + -((int)exponentDistance >> 0x1f);\n    if ((resultMantissaH | exponentDistance << 1) == 0) {\n      exponentSum = exponentSum & ~(exponentDistance >> 0x1f);\n    }\n    return CONCAT44((resultSign & 0x80000000) + (uint)CARRY4(resultExponent,-((int)exponentDistance >> 0x1f)),exponentSum);\n  }\n  bitSum1 = resultExponent << (exponentSum + 0x20 & 0xff);\n  resultExponent = resultExponent >> (exponentDistance & 0xff) | resultSign << (exponentSum + 0x20 & 0xff);\n  exponentSum = resultExponent + -((int)bitSum1 >> 0x1f);\n  if ((resultMantissaH | bitSum1 << 1) == 0) {\n    exponentSum = exponentSum & ~(bitSum1 >> 0x1f);\n  }\n  return CONCAT44((resultSign & 0x80000000) +\n                  ((resultSign & 0x7fffffff) >> (exponentDistance & 0xff)) +\n                  (uint)CARRY4(resultExponent,-((int)bitSum1 >> 0x1f)),exponentSum);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "calculate_floating_point_0800071c",
                "param_1": "inputSign",
                "param_2": "inputExponent",
                "param_3": "inputMantissaH",
                "param_4": "inputMantissaL",
                "uVar1": "normalizedMantissaH",
                "uVar2": "normalizedMantissaL",
                "uVar3": "exponentDistance",
                "uVar4": "exponentDiff",
                "uVar5": "shiftedMantissaH",
                "uVar6": "shiftedMantissaL",
                "uVar7": "resultSign",
                "iVar8": "exponentDiffSign",
                "uVar9": "exponentSum",
                "unaff_r5": "inputExponentL",
                "uVar10": "bitSum1",
                "uVar11": "resultExponent",
                "uVar12": "mantissaDiff",
                "uVar13": "resultMantissaH",
                "bVar14": "isNormal",
                "bVar15": "isZero",
                "bVar16": "carry",
                "uVar17": "result"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "__ieee754_atan2",
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "binary_to_double_0800088a",
            "code": "\nulonglong binary_to_double_0800088a(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint bit5;\n  bool check;\n  \n  bit3 = bit5 & input4 >> 0x14;\n  bit4 = input2;\n  if (bit2 != bit5 || bit3 != bit5) {\n    if (bit2 == bit5) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, bit4 = input4, bit3 != bit5)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit3 == bit5) {\n      input1 = input3;\n      bit4 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      check = (input1 | input2 << 1) == 0;\n      if (!check) {\n        check = (input3 | input4 << 1) == 0;\n      }\n      if (!check) {\n        if (bit2 == 0) {\n          bit4 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | bit4;\n          if (bit3 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          bit4 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(bit4 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_080006fc;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(bit4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "binary_to_double_0800088a",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "bit5",
                "bVar4": "check"
            },
            "calling": [
                "__divdf3"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_params_080008fc",
            "code": "\nuint check_params_080008fc(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint result;\n  bool areInputsZero;\n  bool isParam4SmallerOrEqual;\n  \n  if (((int)(input2 << 1) >> 0x15 == -1 || (int)(input4 << 1) >> 0x15 == -1) &&\n     ((((int)(input2 << 1) >> 0x15 == -1 && ((input1 | input2 << 0xc) != 0)) ||\n      (((int)(input4 << 1) >> 0x15 == -1 && ((input3 | input4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  areInputsZero = (input1 | input2 << 1) == 0;\n  if (areInputsZero) {\n    areInputsZero = (input3 | input4 << 1) == 0;\n  }\n  if (!areInputsZero) {\n    areInputsZero = input2 == input4;\n  }\n  if (areInputsZero) {\n    areInputsZero = input1 == input3;\n  }\n  if (!areInputsZero) {\n    result = input2 ^ input4;\n    areInputsZero = result == 0;\n    if (-1 < (int)result) {\n      areInputsZero = input2 == input4;\n    }\n    isParam4SmallerOrEqual = -1 < (int)result && input4 <= input2;\n    if (areInputsZero) {\n      isParam4SmallerOrEqual = input3 <= input1;\n    }\n    input4 = (int)input4 >> 0x1f;\n    if (!isParam4SmallerOrEqual) {\n      input4 = ~input4;\n    }\n    return input4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_params_080008fc",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result",
                "bVar2": "areInputsZero",
                "bVar3": "isParam4SmallerOrEqual"
            },
            "calling": [
                "__aeabi_cdcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "compare_floats_08000978",
            "code": "\nvoid compareFloats_08000978(undefined4 result,undefined4 status,undefined4 x,undefined4 y)\n\n{\n  __aeabi_cdcmpeq(x,y,result,status);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "compare_floats_08000978",
                "param_1": "result",
                "param_2": "status",
                "param_3": "x",
                "param_4": "y"
            },
            "calling": [
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "convert_float_to_undefined_08000988",
            "code": "\nundefined4 convertFloatToUndefined_08000988(undefined4 inputValue)\n\n{\n  __nedf2();\n  return inputValue;\n}\n\n",
            "renaming": {
                "FUN_08000988": "convert_float_to_undefined_08000988",
                "param_1": "inputValue"
            },
            "calling": [
                "__aeabi_dcmple",
                "__aeabi_dcmpeq",
                "__aeabi_dcmplt",
                "__aeabi_cdrcmple"
            ],
            "called": [
                "__nedf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "compare_characters_08000998",
            "code": "\nbool compareCharacters_08000998(void)\n\n{\n  char result;\n  \n  compareCharacters_08000998ABICall();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "compare_characters_08000998",
                "in_ZR": "result",
                "__aeabi_cdcmpeq": "compareCharactersABICall"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_if_null_080009ac",
            "code": "\nbool check_if_null_080009ac(void)\n\n{\n  char input_char;\n  \n  __aeabi_cdcmpeq();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_if_null_080009ac",
                "in_CY": "input_char"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_equal_or_zero_080009c0",
            "code": "\nbool check_equal_or_zero_080009c0(void)\n\n{\n  undefined is_zero;\n  undefined is_equal;\n  \n  compare_absolute_values();\n  return !(bool)is_equal || (bool)is_zero;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_equal_or_zero_080009c0",
                "in_ZR": "is_zero",
                "in_CY": "is_equal",
                "__aeabi_cdcmpeq": "compare_absolute_values"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "check_lower_or_equal_080009d4",
            "code": "\nbool check_lower_or_equal_080009d4(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_set;\n  \n  __aeabi_cdrcmple();\n  return !(bool)is_carry_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "check_lower_or_equal_080009d4",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_set"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "is_zero_character_080009e8",
            "code": "\nbool is_zero_character_080009e8(void)\n\n{\n  char input_character;\n  \n  __aeabi_cdrcmple();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "is_zero_character_080009e8",
                "in_CY": "input_character"
            },
            "calling": [
                "atan",
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [
                "__aeabi_cdrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_floating_point_value_080009fc",
            "code": "\nuint calculateFloatingPointValue_080009fc(uint inputValue,uint inputFlag)\n\n{\n  uint result;\n  uint multipliedValue;\n  uint shiftedValue;\n  uint alternateValue;\n  bool isZero;\n  bool isLessThanThreshold;\n  \n  multipliedValue = inputFlag * 2;\n  isLessThanThreshold = multipliedValue < 0x70000000;\n  shiftedValue = multipliedValue + 0x90000000;\n  result = shiftedValue;\n  if (!isLessThanThreshold) {\n    alternateValue = multipliedValue + 0x8fe00000;\n    result = alternateValue;\n  }\n  isZero = result == 0;\n  if (!isLessThanThreshold && shiftedValue >= 0x200000) {\n    isZero = alternateValue == 0x1fc00000;\n  }\n  if (((isLessThanThreshold || shiftedValue < 0x200000) || 0x1fc00000 < alternateValue) || isZero) {\n    if ((inputFlag & 0x40000000) != 0) {\n      if (((int)multipliedValue >> 0x15 == -1) && ((inputValue | inputFlag << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return inputFlag & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(multipliedValue + 0x92e00000) < 0 != SCARRY4(shiftedValue,0x2e00000)) {\n      return inputFlag & 0x80000000;\n    }\n    multipliedValue = 0x18 - (multipliedValue + 0x92e00000 >> 0x15);\n    result = inputValue >> (multipliedValue & 0xff);\n    if (inputValue << (0x20 - multipliedValue & 0xff) != 0) {\n      result = result | 1;\n    }\n    shiftedValue = inputFlag & 0x1fffff | 0x100000;\n    inputValue = result | shiftedValue << (0x20 - multipliedValue & 0xff);\n    shiftedValue = (shiftedValue >> (multipliedValue & 0xff)) << 1;\n  }\n  result = (inputFlag & 0x80000000 | inputValue >> 0x1d) + shiftedValue * 4 + (uint)(0x7fffffff < inputValue * 8);\n  if (inputValue * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_floating_point_value_080009fc",
                "param_1": "inputValue",
                "param_2": "inputFlag",
                "uVar1": "result",
                "uVar2": "multipliedValue",
                "uVar3": "shiftedValue",
                "in_r12": "alternateValue",
                "bVar4": "isZero",
                "bVar5": "isLessThanThreshold"
            },
            "calling": [
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_new_float_08000aa4",
            "code": "\nuint calculateNewFloat_08000aa4(uint inputFloat,uint inputBitMask,undefined4 paddingValue,uint shiftAmount)\n\n{\n  int bitShiftedFloat;\n  int bitShiftedFloatPart;\n  uint floatXOR;\n  uint floatXORPart;\n  uint shiftedInputFloat;\n  uint bitShiftedFloatTemp;\n  uint difference;\n  bool isZero;\n  \n  floatXOR = inputBitMask ^ 0x80000000;\n  shiftedInputFloat = inputFloat << 1;\n  isZero = shiftedInputFloat == 0;\n  if (!isZero) {\n    shiftAmount = inputBitMask << 1;\n    isZero = shiftAmount == 0;\n  }\n  if (!isZero) {\n    isZero = shiftedInputFloat == shiftAmount;\n  }\n  bitShiftedFloat = (int)shiftedInputFloat >> 0x18;\n  if (!isZero) {\n    isZero = bitShiftedFloat == -1;\n  }\n  if (!isZero) {\n    isZero = (int)shiftAmount >> 0x18 == -1;\n  }\n  if (isZero) {\n    bitShiftedFloatPart = (int)(inputBitMask << 1) >> 0x18;\n    if (bitShiftedFloat == -1 || bitShiftedFloatPart == -1) {\n      shiftedInputFloat = floatXOR;\n      if (bitShiftedFloat == -1) {\n        shiftedInputFloat = inputFloat;\n      }\n      if (bitShiftedFloat != -1 || bitShiftedFloatPart != -1) {\n        floatXOR = shiftedInputFloat;\n      }\n      isZero = (shiftedInputFloat & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (floatXOR & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = shiftedInputFloat == floatXOR;\n      }\n      if (!isZero) {\n        shiftedInputFloat = shiftedInputFloat | 0x400000;\n      }\n      return shiftedInputFloat;\n    }\n    if (((inputFloat ^ floatXOR) & 0x7fffffff) != 0) {\n      if (shiftedInputFloat == 0) {\n        inputFloat = floatXOR;\n      }\n      return inputFloat;\n    }\n    if (inputFloat != floatXOR) {\n      return 0;\n    }\n    if ((shiftedInputFloat & 0xff000000) == 0) {\n      floatXOR = inputFloat << 1;\n      if ((inputFloat & 0x80000000) != 0) {\n        floatXOR = floatXOR | 0x80000000;\n      }\n      return floatXOR;\n    }\n    if (shiftedInputFloat < 0xfe000000) {\n      return inputFloat + 0x800000;\n    }\n    inputFloat = inputFloat & 0x80000000;\nLAB_08000bde:\n    return inputFloat | 0x7f800000;\n  }\n  shiftedInputFloat = shiftedInputFloat >> 0x18;\n  shiftAmount = shiftAmount >> 0x18;\n  difference = shiftAmount - shiftedInputFloat;\n  isZero = difference != 0;\n  bitShiftedFloatTemp = shiftedInputFloat;\n  if (isZero && shiftedInputFloat <= shiftAmount) {\n    bitShiftedFloatTemp = shiftedInputFloat + difference;\n  }\n  if (isZero && shiftedInputFloat <= shiftAmount) {\n    floatXOR = floatXOR ^ inputFloat;\n  }\n  if (isZero && shiftedInputFloat <= shiftAmount) {\n    inputFloat = inputFloat ^ floatXOR;\n  }\n  if (isZero && shiftedInputFloat <= shiftAmount) {\n    floatXOR = floatXOR ^ inputFloat;\n  }\n  if (shiftAmount < shiftedInputFloat) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return inputFloat;\n  }\n  shiftedInputFloat = inputFloat & 0xffffff | 0x800000;\n  if ((inputFloat & 0x80000000) != 0) {\n    shiftedInputFloat = -shiftedInputFloat;\n  }\n  floatXORPart = floatXOR & 0xffffff | 0x800000;\n  if ((floatXOR & 0x80000000) != 0) {\n    floatXORPart = -floatXORPart;\n  }\n  if (bitShiftedFloatTemp == difference) {\n    floatXORPart = floatXORPart ^ 0x800000;\n    if (bitShiftedFloatTemp == 0) {\n      shiftedInputFloat = shiftedInputFloat ^ 0x800000;\n      bitShiftedFloatTemp = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  shiftedInputFloat = shiftedInputFloat + ((int)floatXORPart >> (difference & 0xff));\n  floatXORPart = floatXORPart << (0x20 - difference & 0xff);\n  inputFloat = shiftedInputFloat & 0x80000000;\n  if ((int)shiftedInputFloat < 0) {\n    isZero = floatXORPart != 0;\n    floatXORPart = -floatXORPart;\n    shiftedInputFloat = -shiftedInputFloat - (uint)isZero;\n  }\n  if (shiftedInputFloat < 0x800000) {\n    floatXOR = floatXORPart & 0x80000000;\n    floatXORPart = floatXORPart << 1;\n    shiftedInputFloat = shiftedInputFloat * 2 + (uint)(floatXOR != 0);\n    floatXOR = bitShiftedFloatTemp - 2;\n    if ((shiftedInputFloat & 0x800000) == 0) {\n      difference = LZCOUNT(shiftedInputFloat) - 8;\n      shiftedInputFloat = shiftedInputFloat << (difference & 0xff);\n      if ((int)floatXOR < (int)difference) {\n        shiftedInputFloat = shiftedInputFloat >> (-(floatXOR - difference) & 0xff);\n      }\n      else {\n        shiftedInputFloat = shiftedInputFloat + (floatXOR - difference) * 0x800000;\n      }\n      return shiftedInputFloat | inputFloat;\n    }\n  }\n  else {\n    floatXOR = bitShiftedFloatTemp - 1;\n    if (0xffffff < shiftedInputFloat) {\n      floatXOR = shiftedInputFloat & 1;\n      shiftedInputFloat = shiftedInputFloat >> 1;\n      floatXORPart = (uint)(floatXOR != 0) << 0x1f | floatXORPart >> 1;\n      floatXOR = bitShiftedFloatTemp;\n      if (0xfd < bitShiftedFloatTemp) goto LAB_08000bde;\n    }\n  }\n  shiftedInputFloat = shiftedInputFloat + floatXOR * 0x800000 + (uint)(0x7fffffff < floatXORPart);\n  if (floatXORPart == 0x80000000) {\n    shiftedInputFloat = shiftedInputFloat & 0xfffffffe;\n  }\n  return shiftedInputFloat | inputFloat;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_new_float_08000aa4",
                "param_1": "inputFloat",
                "param_2": "inputBitMask",
                "param_3": "paddingValue",
                "param_4": "shiftAmount",
                "iVar1": "bitShiftedFloat",
                "iVar2": "bitShiftedFloatPart",
                "uVar3": "floatXOR",
                "uVar4": "floatXORPart",
                "uVar5": "shiftedInputFloat",
                "uVar6": "bitShiftedFloatTemp",
                "uVar7": "difference",
                "bVar8": "isZero"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calc_pitch"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_float_08000aa8",
            "code": "\nuint calculateFloat_08000aa8(uint input1,uint input2,undefined4 input3,uint input4)\n\n{\n  int shiftCount;\n  int shiftedInput;\n  uint absInput1;\n  uint absInput2;\n  uint shiftedValue;\n  uint difference;\n  bool isEqual;\n  \n  absInput2 = input1 << 1;\n  isEqual = absInput2 == 0;\n  if (!isEqual) {\n    input4 = input2 << 1;\n    isEqual = input4 == 0;\n  }\n  if (!isEqual) {\n    isEqual = absInput2 == input4;\n  }\n  shiftCount = (int)absInput2 >> 0x18;\n  if (!isEqual) {\n    isEqual = shiftCount == -1;\n  }\n  if (!isEqual) {\n    isEqual = (int)input4 >> 0x18 == -1;\n  }\n  if (isEqual) {\n    shiftedInput = (int)(input2 << 1) >> 0x18;\n    if (shiftCount == -1 || shiftedInput == -1) {\n      absInput2 = input2;\n      if (shiftCount == -1) {\n        absInput2 = input1;\n      }\n      if (shiftCount != -1 || shiftedInput != -1) {\n        input2 = absInput2;\n      }\n      isEqual = (absInput2 & 0x7fffff) == 0;\n      if (isEqual) {\n        isEqual = (input2 & 0x7fffff) == 0;\n      }\n      if (isEqual) {\n        isEqual = absInput2 == input2;\n      }\n      if (!isEqual) {\n        absInput2 = absInput2 | 0x400000;\n      }\n      return absInput2;\n    }\n    if (((input1 ^ input2) & 0x7fffffff) != 0) {\n      if (absInput2 == 0) {\n        input1 = input2;\n      }\n      return input1;\n    }\n    if (input1 != input2) {\n      return 0;\n    }\n    if ((absInput2 & 0xff000000) == 0) {\n      absInput2 = input1 << 1;\n      if ((input1 & 0x80000000) != 0) {\n        absInput2 = absInput2 | 0x80000000;\n      }\n      return absInput2;\n    }\n    if (absInput2 < 0xfe000000) {\n      return input1 + 0x800000;\n    }\n    input1 = input1 & 0x80000000;\nLAB_08000bde:\n    return input1 | 0x7f800000;\n  }\n  absInput2 = absInput2 >> 0x18;\n  input4 = input4 >> 0x18;\n  difference = input4 - absInput2;\n  isEqual = difference != 0;\n  shiftedValue = absInput2;\n  if (isEqual && absInput2 <= input4) {\n    shiftedValue = absInput2 + difference;\n  }\n  if (isEqual && absInput2 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (isEqual && absInput2 <= input4) {\n    input1 = input1 ^ input2;\n  }\n  if (isEqual && absInput2 <= input4) {\n    input2 = input2 ^ input1;\n  }\n  if (input4 < absInput2) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input1;\n  }\n  absInput2 = input1 & 0xffffff | 0x800000;\n  if ((input1 & 0x80000000) != 0) {\n    absInput2 = -absInput2;\n  }\n  absInput1 = input2 & 0xffffff | 0x800000;\n  if ((input2 & 0x80000000) != 0) {\n    absInput1 = -absInput1;\n  }\n  if (shiftedValue == difference) {\n    absInput1 = absInput1 ^ 0x800000;\n    if (shiftedValue == 0) {\n      absInput2 = absInput2 ^ 0x800000;\n      shiftedValue = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  absInput2 = absInput2 + ((int)absInput1 >> (difference & 0xff));\n  absInput1 = absInput1 << (0x20 - difference & 0xff);\n  input1 = absInput2 & 0x80000000;\n  if ((int)absInput2 < 0) {\n    isEqual = absInput1 != 0;\n    absInput1 = -absInput1;\n    absInput2 = -absInput2 - (uint)isEqual;\n  }\n  if (absInput2 < 0x800000) {\n    difference = absInput1 & 0x80000000;\n    absInput1 = absInput1 << 1;\n    absInput2 = absInput2 * 2 + (uint)(difference != 0);\n    difference = shiftedValue - 2;\n    if ((absInput2 & 0x800000) == 0) {\n      shiftedValue = LZCOUNT(absInput2) - 8;\n      absInput2 = absInput2 << (shiftedValue & 0xff);\n      if ((int)difference < (int)shiftedValue) {\n        absInput2 = absInput2 >> (-(difference - shiftedValue) & 0xff);\n      }\n      else {\n        absInput2 = absInput2 + (difference - shiftedValue) * 0x800000;\n      }\n      return absInput2 | input1;\n    }\n  }\n  else {\n    difference = shiftedValue - 1;\n    if (0xffffff < absInput2) {\n      difference = absInput2 & 1;\n      absInput2 = absInput2 >> 1;\n      absInput1 = (uint)(difference != 0) << 0x1f | absInput1 >> 1;\n      difference = shiftedValue;\n      if (0xfd < shiftedValue) goto LAB_08000bde;\n    }\n  }\n  absInput2 = absInput2 + difference * 0x800000 + (uint)(0x7fffffff < absInput1);\n  if (absInput1 == 0x80000000) {\n    absInput2 = absInput2 & 0xfffffffe;\n  }\n  return absInput2 | input1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_float_08000aa8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "shiftCount",
                "iVar2": "shiftedInput",
                "uVar3": "absInput1",
                "uVar4": "absInput2",
                "uVar5": "shiftedValue",
                "uVar6": "difference",
                "bVar7": "isEqual"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_hash_08000c08",
            "code": "\nuint calculate_hash_08000c08(uint input_value)\n\n{\n  uint leading_zero_count;\n  uint shift_amount;\n  int constant_value;\n  uint temp_value;\n  \n  if (input_value == 0) {\n    return 0;\n  }\n  leading_zero_count = LZCOUNT(input_value);\n  shift_amount = leading_zero_count - 8;\n  constant_value = shift_amount * -0x800000 + 0x4a800000;\n  if (7 < leading_zero_count) {\n    temp_value = 0 << (shift_amount & 0xff);\n    leading_zero_count = constant_value + (input_value << (shift_amount & 0xff)) +\n            (0U >> (0x20 - shift_amount & 0xff)) + (uint)(0x7fffffff < temp_value);\n    if (temp_value == 0x80000000) {\n      leading_zero_count = leading_zero_count & 0xfffffffe;\n    }\n    return leading_zero_count;\n  }\n  shift_amount = input_value << leading_zero_count + 0x18;\n  leading_zero_count = constant_value + ((input_value >> (0x20 - (leading_zero_count + 0x18) & 0xff)) - ((int)shift_amount >> 0x1f));\n  if ((shift_amount & 0x7fffffff) == 0) {\n    leading_zero_count = leading_zero_count & ~(shift_amount >> 0x1f);\n  }\n  return leading_zero_count;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_hash_08000c08",
                "param_1": "input_value",
                "uVar1": "leading_zero_count",
                "uVar2": "shift_amount",
                "iVar3": "constant_value",
                "uVar4": "temp_value"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "count_set_bits_08000c10",
            "code": "\nuint countSetBits_08000c10(uint input)\n\n{\n  uint numSetBits;\n  uint shiftedValue;\n  uint signBit;\n  int result;\n  \n  signBit = input & 0x80000000;\n  if ((int)signBit < 0) {\n    input = -input;\n  }\n  if (input == 0) {\n    return 0;\n  }\n  numSetBits = leadingZeroCount(input);\n  shiftedValue = numSetBits - 8;\n  result = ((signBit | 0x4b000000) - 0x800000) + shiftedValue * -0x800000;\n  if (7 < numSetBits) {\n    numSetBits = 0 << (shiftedValue & 0xff);\n    signBit = result + (input << (shiftedValue & 0xff)) +\n            (0U >> (0x20 - shiftedValue & 0xff)) + (uint)(0x7fffffff < numSetBits);\n    if (numSetBits == 0x80000000) {\n      signBit = signBit & 0xfffffffe;\n    }\n    return signBit;\n  }\n  shiftedValue = input << numSetBits + 0x18;\n  signBit = result + ((input >> (0x20 - (numSetBits + 0x18) & 0xff)) - ((int)shiftedValue >> 0x1f));\n  if ((shiftedValue & 0x7fffffff) == 0) {\n    signBit = signBit & ~(shiftedValue >> 0x1f);\n  }\n  return signBit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "count_set_bits_08000c10",
                "param_1": "input",
                "uVar1": "numSetBits",
                "uVar2": "shiftedValue",
                "uVar3": "signBit",
                "iVar4": "result",
                "LZCOUNT": "leadingZeroCount"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_update",
                "mpu6050_calibrate"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_floating_point_08000cb8",
            "code": "\nuint calculateFloatingPoint_08000cb8(uint firstOperand,uint secondOperand,undefined4 param_3,uint param_4)\n\n{\n  longlong tempLong;\n  uint result;\n  uint firstBits;\n  int sum;\n  int tempInt1;\n  uint tempResult;\n  int tempInt2;\n  uint tempBits;\n  bool isZeroOrNonZero;\n  bool isNegative;\n  \n  firstBits = firstOperand >> 0x17 & 0xff;\n  isZeroOrNonZero = firstBits == 0;\n  if (!isZeroOrNonZero) {\n    param_4 = secondOperand >> 0x17 & 0xff;\n    isZeroOrNonZero = param_4 == 0;\n  }\n  if (!isZeroOrNonZero) {\n    isZeroOrNonZero = firstBits == 0xff;\n  }\n  if (!isZeroOrNonZero) {\n    isZeroOrNonZero = param_4 == 0xff;\n  }\n  if (isZeroOrNonZero) {\n    param_4 = secondOperand >> 0x17 & 0xff;\n    if (firstBits == 0xff || param_4 == 0xff) {\n      isZeroOrNonZero = firstOperand == 0 || firstOperand == 0x80000000;\n      result = secondOperand;\n      if (firstOperand != 0 && firstOperand != 0x80000000) {\n        isZeroOrNonZero = secondOperand == 0;\n        result = firstOperand;\n      }\n      if (!isZeroOrNonZero) {\n        isZeroOrNonZero = secondOperand == 0x80000000;\n      }\n      tempBits = result;\n      if (((isZeroOrNonZero) || ((firstBits == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((param_4 == 0xff && (tempBits = secondOperand, (secondOperand & 0x7fffff) != 0)))) {\n        return tempBits | 0x7fc00000;\n      }\n      result = result ^ secondOperand;\n      goto LAB_08000e08;\n    }\n    isZeroOrNonZero = (firstOperand & 0x7fffffff) == 0;\n    if (!isZeroOrNonZero) {\n      isZeroOrNonZero = (secondOperand & 0x7fffffff) == 0;\n    }\n    if (isZeroOrNonZero) {\n      return (firstOperand ^ secondOperand) & 0x80000000;\n    }\n    isZeroOrNonZero = firstBits == 0;\n    result = firstOperand & 0x80000000;\n    while( true ) {\n      if (isZeroOrNonZero) {\n        firstOperand = firstOperand << 1;\n        isZeroOrNonZero = (firstOperand & 0x800000) == 0;\n      }\n      if (!isZeroOrNonZero) break;\n      firstBits = firstBits - 1;\n    }\n    firstOperand = firstOperand | result;\n    isZeroOrNonZero = param_4 == 0;\n    result = secondOperand & 0x80000000;\n    while( true ) {\n      if (isZeroOrNonZero) {\n        secondOperand = secondOperand << 1;\n        isZeroOrNonZero = (secondOperand & 0x800000) == 0;\n      }\n      if (!isZeroOrNonZero) break;\n      param_4 = param_4 - 1;\n    }\n    secondOperand = secondOperand | result;\n  }\n  sum = firstBits + param_4;\n  tempBits = firstOperand ^ secondOperand;\n  firstBits = firstOperand << 9;\n  isZeroOrNonZero = firstBits == 0;\n  if (!isZeroOrNonZero) {\n    secondOperand = secondOperand << 9;\n    isZeroOrNonZero = secondOperand == 0;\n  }\n  if (isZeroOrNonZero) {\n    if (firstBits == 0) {\n      secondOperand = secondOperand << 9;\n    }\n    result = tempBits & 0x80000000 | firstOperand & 0x7fffff | secondOperand >> 9;\n    isNegative = signedBorrow(sum,0x7f);\n    tempInt1 = sum + -0x7f;\n    isZeroOrNonZero = tempInt1 == 0;\n    tempInt2 = tempInt1;\n    if (!isZeroOrNonZero && 0x7e < sum) {\n      isNegative = signedBorrow(0xff,tempInt1);\n      tempInt2 = 0xff - tempInt1;\n      isZeroOrNonZero = tempInt1 == 0xff;\n    }\n    if (!isZeroOrNonZero && tempInt2 < 0 == isNegative) {\n      result = result | tempInt1 * 0x800000;\n    }\n    if (!isZeroOrNonZero && tempInt2 < 0 == isNegative) {\n      return result;\n    }\n    result = result | 0x800000;\n    tempResult = 0;\n    isNegative = signedBorrow(tempInt1,1);\n    tempBits = sum - 0x80;\n    isZeroOrNonZero = tempBits == 0;\n    firstBits = tempBits;\n  }\n  else {\n    tempLong = (ulonglong)(firstBits >> 5 | 0x8000000) * (ulonglong)(secondOperand >> 5 | 0x8000000);\n    tempResult = (uint)tempLong;\n    result = (uint)((ulonglong)tempLong >> 0x20);\n    isZeroOrNonZero = result < 0x800000;\n    if (isZeroOrNonZero) {\n      result = result << 1;\n    }\n    if (isZeroOrNonZero) {\n      result = result | tempResult >> 0x1f;\n      tempResult = tempResult << 1;\n    }\n    result = tempBits & 0x80000000 | result;\n    tempBits = (sum + -0x7f) - (uint)isZeroOrNonZero;\n    isNegative = signedBorrow(tempBits,0xfd);\n    isZeroOrNonZero = tempBits == 0xfd;\n    firstBits = tempBits - 0xfd;\n    if (tempBits < 0xfe) {\n      result = result + tempBits * 0x800000 + (uint)(0x7fffffff < tempResult);\n      if (tempResult == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (isZeroOrNonZero || (int)firstBits < 0 != isNegative) {\n    isZeroOrNonZero = (int)(tempBits + 0x19) < 0;\n    if (tempBits == 0xffffffe7 || isZeroOrNonZero != signedCarry(tempBits,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (tempBits != 0xffffffe7 && isZeroOrNonZero == signedCarry(tempBits,0x19)) {\n      firstBits = (result << 1) >> (-tempBits & 0xff);\n      tempBits = result << (tempBits + 0x20 & 0xff);\n      firstBits = ((uint)((result & 0x80000000) != 0) << 0x1f | firstBits >> 1) + (uint)((byte)firstBits & 1);\n      if ((tempResult | tempBits << 1) == 0) {\n        firstBits = firstBits & ~(tempBits >> 0x1f);\n      }\n      return firstBits;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_floating_point_08000cb8",
                "param_1": "firstOperand",
                "param_2": "secondOperand",
                "lVar1": "tempLong",
                "uVar2": "result",
                "uVar3": "firstBits",
                "iVar4": "sum",
                "iVar5": "tempInt1",
                "uVar6": "tempResult",
                "iVar7": "tempInt2",
                "uVar8": "tempBits",
                "bVar9": "isZeroOrNonZero",
                "bVar10": "isNegative",
                "SBORROW4": "signedBorrow",
                "SCARRY4": "signedCarry"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "improved_code_08000e20",
            "code": "\nuint improved_code_08000e20(uint input_1,uint input_2,undefined4 input_3,uint input_4)\n\n{\n  uint temp_1;\n  uint temp_2;\n  int temp_3;\n  uint temp_4;\n  int temp_5;\n  uint temp_6;\n  bool is_zero;\n  bool overflow_flag;\n  bool carry_flag;\n  \n  temp_2 = input_1 >> 0x17 & 0xff;\n  is_zero = temp_2 == 0;\n  if (!is_zero) {\n    input_4 = input_2 >> 0x17 & 0xff;\n    is_zero = input_4 == 0;\n  }\n  if (!is_zero) {\n    is_zero = temp_2 == 0xff;\n  }\n  if (!is_zero) {\n    is_zero = input_4 == 0xff;\n  }\n  if (is_zero) {\n    input_4 = input_2 >> 0x17 & 0xff;\n    temp_6 = input_1;\n    if (temp_2 == 0xff) {\n      if (((input_1 & 0x7fffff) != 0) || (temp_6 = input_2, input_4 == 0xff)) {\nLAB_08000e16:\n        return temp_6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (input_4 == 0xff) {\n        temp_6 = input_2;\n        if ((input_2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (input_1 ^ input_2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      is_zero = (input_1 & 0x7fffffff) == 0;\n      if (!is_zero) {\n        is_zero = (input_2 & 0x7fffffff) == 0;\n      }\n      if (!is_zero) {\n        is_zero = temp_2 == 0;\n        temp_6 = input_1 & 0x80000000;\n        while( true ) {\n          if (is_zero) {\n            input_1 = input_1 << 1;\n            is_zero = (input_1 & 0x800000) == 0;\n          }\n          if (!is_zero) break;\n          temp_2 = temp_2 - 1;\n        }\n        input_1 = input_1 | temp_6;\n        is_zero = input_4 == 0;\n        temp_6 = input_2 & 0x80000000;\n        while( true ) {\n          if (is_zero) {\n            input_2 = input_2 << 1;\n            is_zero = (input_2 & 0x800000) == 0;\n          }\n          if (!is_zero) break;\n          input_4 = input_4 - 1;\n        }\n        input_2 = input_2 | temp_6;\n        goto LAB_08000e38;\n      }\n      if ((input_1 & 0x7fffffff) == 0) {\n        if ((input_2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    input_1 = input_1 ^ input_2;\n  }\n  else {\nLAB_08000e38:\n    temp_3 = temp_2 - input_4;\n    if (input_2 << 9 == 0) {\n      input_1 = (input_1 ^ input_2) & 0x80000000 | input_1 & 0x7fffff;\n      carry_flag = SCARRY4(temp_3,0x7f);\n      temp_5 = temp_3 + 0x7f;\n      is_zero = temp_5 < 0;\n      overflow_flag = temp_5 == 0;\n      if (!overflow_flag && is_zero == carry_flag) {\n        carry_flag = SBORROW4(0xff,temp_5);\n        is_zero = 0xff - temp_5 < 0;\n        overflow_flag = temp_5 == 0xff;\n      }\n      if (!overflow_flag && is_zero == carry_flag) {\n        input_1 = input_1 | temp_5 * 0x800000;\n      }\n      if (!overflow_flag && is_zero == carry_flag) {\n        return input_1;\n      }\n      input_1 = input_1 | 0x800000;\n      temp_2 = 0;\n      overflow_flag = SBORROW4(temp_5,1);\n      temp_4 = temp_3 + 0x7e;\n      is_zero = temp_4 == 0;\n      temp_6 = temp_4;\n    }\n    else {\n      temp_1 = (input_2 << 9) >> 4 | 0x10000000;\n      temp_2 = (input_1 << 9) >> 4 | 0x10000000;\n      input_1 = (input_1 ^ input_2) & 0x80000000;\n      is_zero = temp_1 <= temp_2;\n      if (!is_zero) {\n        temp_2 = temp_2 << 1;\n      }\n      temp_4 = temp_3 + 0x7d + (uint)is_zero;\n      temp_6 = 0x800000;\n      do {\n        if (temp_1 <= temp_2) {\n          temp_2 = temp_2 - temp_1;\n          input_1 = input_1 | temp_6;\n        }\n        is_zero = temp_1 >> 1 <= temp_2;\n        if (is_zero) {\n          temp_2 = temp_2 - (temp_1 >> 1);\n        }\n        if (is_zero) {\n          input_1 = input_1 | temp_6 >> 1;\n        }\n        is_zero = temp_1 >> 2 <= temp_2;\n        if (is_zero) {\n          temp_2 = temp_2 - (temp_1 >> 2);\n        }\n        if (is_zero) {\n          input_1 = input_1 | temp_6 >> 2;\n        }\n        is_zero = temp_1 >> 3 <= temp_2;\n        if (is_zero) {\n          temp_2 = temp_2 - (temp_1 >> 3);\n        }\n        if (is_zero) {\n          input_1 = input_1 | temp_6 >> 3;\n        }\n        temp_2 = temp_2 * 0x10;\n        is_zero = temp_2 == 0;\n        if (!is_zero) {\n          temp_6 = temp_6 >> 4;\n          is_zero = temp_6 == 0;\n        }\n      } while (!is_zero);\n      overflow_flag = SBORROW4(temp_4,0xfd);\n      is_zero = temp_4 == 0xfd;\n      temp_6 = temp_4 - 0xfd;\n      if (temp_4 < 0xfe) {\n        input_1 = input_1 + temp_4 * 0x800000 + (uint)(temp_1 <= temp_2);\n        if (temp_2 - temp_1 == 0) {\n          input_1 = input_1 & 0xfffffffe;\n        }\n        return input_1;\n      }\n    }\n    if (is_zero || (int)temp_6 < 0 != overflow_flag) {\n      is_zero = (int)(temp_4 + 0x19) < 0;\n      if (temp_4 == 0xffffffe7 || is_zero != SCARRY4(temp_4,0x19)) {\n        input_1 = input_1 & 0x80000000;\n      }\n      if (temp_4 == 0xffffffe7 || is_zero != SCARRY4(temp_4,0x19)) {\n        return input_1;\n      }\n      temp_6 = (input_1 << 1) >> (-temp_4 & 0xff);\n      temp_4 = input_1 << (temp_4 + 0x20 & 0xff);\n      temp_6 = ((uint)((input_1 & 0x80000000) != 0) << 0x1f | temp_6 >> 1) + (uint)((byte)temp_6 & 1);\n      if ((temp_2 | temp_4 << 1) == 0) {\n        temp_6 = temp_6 & ~(temp_4 >> 0x1f);\n      }\n      return temp_6;\n    }\n  }\n  return input_1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "improved_code_08000e20",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "temp_1",
                "uVar2": "temp_2",
                "iVar3": "temp_3",
                "uVar4": "temp_4",
                "iVar5": "temp_5",
                "uVar6": "temp_6",
                "bVar7": "is_zero",
                "bVar8": "overflow_flag",
                "bVar9": "carry_flag"
            },
            "calling": [
                "mpu6050_calibrate",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "calculate_unsigned_greater_08000f68",
            "code": "\nuint calculate_unsigned_greater_08000f68(uint input_num1,uint input_num2)\n\n{\n  bool is_overflow;\n  uint doubled_input_num1;\n  uint doubled_input_num2;\n  uint result;\n  bool is_zero_result;\n  \n  doubled_input_num1 = input_num1 * 2;\n  doubled_input_num2 = input_num2 * 2;\n  if (((int)doubled_input_num1 >> 0x18 == -1 || (int)doubled_input_num2 >> 0x18 == -1) &&\n     ((((int)doubled_input_num1 >> 0x18 == -1 && ((input_num1 & 0x7fffff) != 0)) ||\n      (((int)doubled_input_num2 >> 0x18 == -1 && ((input_num2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  result = doubled_input_num1 | input_num2 & 0x7fffffff;\n  is_zero_result = result == 0;\n  if (!is_zero_result) {\n    result = input_num1 ^ input_num2;\n    is_zero_result = result == 0;\n  }\n  is_overflow = -1 < (int)result;\n  if (is_overflow) {\n    input_num1 = doubled_input_num1 + input_num2 * -2;\n    is_zero_result = input_num1 == 0;\n  }\n  if ((is_overflow && doubled_input_num2 <= doubled_input_num1) && !is_zero_result) {\n    input_num1 = (int)input_num2 >> 0x1f;\n  }\n  if (!is_overflow || doubled_input_num2 > doubled_input_num1) {\n    input_num1 = ~((int)input_num2 >> 0x1f);\n  }\n  if (!is_zero_result) {\n    input_num1 = input_num1 | 1;\n  }\n  return input_num1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "calculate_unsigned_greater_08000f68",
                "param_1": "input_num1",
                "param_2": "input_num2",
                "bVar1": "is_overflow",
                "uVar2": "doubled_input_num1",
                "uVar3": "doubled_input_num2",
                "uVar4": "result",
                "bVar5": "is_zero_result"
            },
            "calling": [
                "__aeabi_cfcmpeq"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "compare_floating_point_values_08000fc8",
            "code": "\nvoid compareFloatingPointValues_08000fc8(undefined4 value1,undefined4 value2)\n\n{\n  __aeabi_cfcmpeq(value2,value1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "compare_floating_point_values_08000fc8",
                "param_1": "value1",
                "param_2": "value2"
            },
            "calling": [
                "__aeabi_fcmpgt"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_params_08000fd0",
            "code": "\nundefined8 concatenateParams_08000fd0(undefined4 param1,undefined4 param2)\n\n{\n  __cmpsf2();\n  return CONCAT44(param2,param1);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_params_08000fd0",
                "param_1": "param1",
                "param_2": "param2"
            },
            "calling": [
                "__aeabi_cfrcmple",
                "__aeabi_fcmplt"
            ],
            "called": [
                "__cmpsf2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "check_if_character_is_null_08000ff4",
            "code": "\nbool check_if_character_is_null_08000ff4(void)\n\n{\n  char character_input;\n  \n  __aeabi_cfcmpeq();\n  return character_input == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "check_if_character_is_null_08000ff4",
                "in_CY": "character_input"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfcmpeq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "is_null_terminate_08001030",
            "code": "\nbool is_null_terminate_08001030(void)\n\n{\n  char input_char;\n  \n  __aeabi_cfrcmple();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "is_null_terminate_08001030",
                "in_CY": "input_char"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_cfrcmple"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "check_input_08001044",
            "code": "\nuint checkInput_08001044(uint inputValue)\n\n{\n  uint shiftedValue;\n  \n  if (((inputValue & 0x80000000) != 0) || (inputValue << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftedValue = 0x9e - ((inputValue << 1) >> 0x18);\n  if (-1 < (int)shiftedValue) {\n    return (inputValue << 8 | 0x80000000) >> (shiftedValue & 0xff);\n  }\n  if ((shiftedValue == 0xffffff9f) && ((inputValue & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "check_input_08001044",
                "param_1": "inputValue",
                "uVar1": "shiftedValue"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "copy_memory_08001084",
            "code": "\nundefined4 * copyMemory_08001084(undefined4 *destination,undefined4 *source,uint length)\n\n{\n  undefined4 *destPtr;\n  undefined4 *destEndPtr;\n  undefined4 *srcPtr;\n  uint remainingLength;\n  uint loopLength;\n  bool isLooping;\n  \n  destEndPtr = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (length < 8) {\n      loopLength = length - 4;\n      if (3 < length) {\n        do {\n          destPtr = source;\n          srcPtr = destEndPtr;\n          isLooping = loopLength != 0;\n          loopLength = loopLength - 1;\n          *(undefined *)srcPtr = *(undefined *)destPtr;\n          destEndPtr = (undefined4 *)((int)srcPtr + 1);\n          source = (undefined4 *)((int)destPtr + 1);\n        } while (isLooping);\n        *(undefined *)(undefined4 *)((int)srcPtr + 1) =\n             *(undefined *)(undefined4 *)((int)destPtr + 1);\n        *(undefined *)((int)srcPtr + 2) = *(undefined *)((int)destPtr + 2);\n        *(undefined *)((int)srcPtr + 3) = *(undefined *)((int)destPtr + 3);\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      loopLength = 4 - ((uint)destination & 3);\n      length = length - loopLength;\n      destPtr = destination;\n      srcPtr = source;\n      if (((uint)destination & 1) != 0) {\n        srcPtr = (undefined4 *)((int)source + 1);\n        destPtr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      destEndPtr = destPtr;\n      source = srcPtr;\n      if ((loopLength & 2) != 0) {\n        source = (undefined4 *)((int)srcPtr + 2);\n        destEndPtr = (undefined4 *)((int)destPtr + 2);\n        *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n      }\n    }\n  }\n  while (0x3f < length) {\n    *destEndPtr = *source;\n    destEndPtr[1] = source[1];\n    destEndPtr[2] = source[2];\n    destEndPtr[3] = source[3];\n    destEndPtr[4] = source[4];\n    destEndPtr[5] = source[5];\n    destEndPtr[6] = source[6];\n    destEndPtr[7] = source[7];\n    destEndPtr[8] = source[8];\n    destEndPtr[9] = source[9];\n    destEndPtr[10] = source[10];\n    destEndPtr[0xb] = source[0xb];\n    destEndPtr[0xc] = source[0xc];\n    destEndPtr[0xd] = source[0xd];\n    destEndPtr[0xe] = source[0xe];\n    destEndPtr[0xf] = source[0xf];\n    destEndPtr = destEndPtr + 0x10;\n    source = source + 0x10;\n    length = length - 0x40;\n  }\n  remainingLength = length - 0x10;\n  if (0xffffffcf < length - 0x40) {\n    do {\n      *destEndPtr = *source;\n      destEndPtr[1] = source[1];\n      destEndPtr[2] = source[2];\n      destEndPtr[3] = source[3];\n      destEndPtr = destEndPtr + 4;\n      source = source + 4;\n      isLooping = 0xf < remainingLength;\n      remainingLength = remainingLength - 0x10;\n    } while (isLooping);\n  }\n  loopLength = remainingLength + 0xc;\n  srcPtr = destEndPtr;\n  destPtr = source;\n  if (0xfffffff3 < remainingLength) {\n    do {\n      source = destPtr + 1;\n      *srcPtr = *destPtr;\n      isLooping = 3 < loopLength;\n      loopLength = loopLength - 4;\n      destEndPtr = srcPtr + 1;\n      srcPtr = srcPtr + 1;\n      destPtr = source;\n    } while (isLooping);\n  }\nLAB_08001108:\n  if (loopLength + 4 != 0) {\n    destPtr = destEndPtr;\n    srcPtr = source;\n    if ((loopLength & 1) != 0) {\n      srcPtr = (undefined4 *)((int)source + 1);\n      destPtr = (undefined4 *)((int)destEndPtr + 1);\n      *(undefined *)destEndPtr = *(undefined *)source;\n    }\n    if ((loopLength + 4 & 2) != 0) {\n      *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "copy_memory_08001084",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "puVar1": "destPtr",
                "puVar2": "destEndPtr",
                "puVar3": "srcPtr",
                "uVar4": "remainingLength",
                "uVar5": "loopLength",
                "bVar6": "isLooping"
            },
            "calling": [
                "_dtoa_r",
                "__ssprint_r",
                "__multadd"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_validity_08001170",
            "code": "\nundefined4 checkValidity_08001170(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_validity_08001170",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "perform_calculation_0800119c",
            "code": "\nuint performCalculation_0800119c(uint inputValue1,uint modifiedInputValue2)\n\n{\n  uint result;\n  int modifiedInputValue2;\n  uint mask;\n  \n  modifiedInputValue2 = modifiedInputValue2 * 2 + 0x200000;\n  if (modifiedInputValue2 * 2 < 0xffe00000) {\n    if (-1 < modifiedInputValue2) {\n      return 0;\n    }\n    result = modifiedInputValue2 >> 0x15;\n    mask = -result - 0x3e1;\n    if (result < 0xfffffc20 && mask != 0) {\n      result = (modifiedInputValue2 << 0xb | 0x80000000 | inputValue1 >> 0x15) >> (mask & 0xff);\n      if ((modifiedInputValue2 & 0x80000000) != 0) {\n        result = -result;\n      }\n      return result;\n    }\n  }\n  else if ((inputValue1 | modifiedInputValue2 << 0xc) != 0) {\n    return 0;\n  }\n  modifiedInputValue2 = modifiedInputValue2 & 0x80000000;\n  if (modifiedInputValue2 == 0) {\n    modifiedInputValue2 = 0x7fffffff;\n  }\n  return modifiedInputValue2;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "perform_calculation_0800119c",
                "param_1": "inputValue1",
                "param_2": "modifiedInputValue2",
                "uVar1": "result",
                "iVar2": "modifiedInputValue2",
                "uVar3": "mask"
            },
            "calling": [
                "_dtoa_r",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "calculate_result_080011ec",
            "code": "\nundefined8 calculateResult_080011ec(int input1,int input2,int input3,int input4)\n\n{\n  undefined8 result;\n  \n  if ((input4 == 0) && (input3 == 0)) {\n    if (input2 != 0 || input1 != 0) {\n      input2 = -1;\n      input1 = -1;\n    }\n    return CONCAT44(input2,input1);\n  }\n  result = __udivmoddi4();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "calculate_result_080011ec",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "result"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__udivmoddi4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "perform_division_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 performDivision_0800121c(uint dividend,uint dividend_high,uint divisor,uint divisor_high,uint *quotient)\n\n{\n  code *UNRECOVERED_JUMPTABLE;\n  ulonglong temp;\n  uint quotient_low;\n  uint remainder_low;\n  uint temp_low;\n  int shift_amount;\n  uint quotient_high;\n  uint temp_high;\n  uint remainder_high;\n  uint *puVar9;\n  uint temp_div;\n  uint temp_div_high;\n  uint temp_div_low;\n  bool carry_flag;\n  undefined8 result;\n  \n  if (divisor_high == 0) {\n    if (dividend_high < divisor) {\n      shift_amount = LZCOUNT(divisor);\n      temp_high = divisor;\n      if (shift_amount != 0) {\n        temp_high = divisor << shift_amount;\n        dividend_high = dividend >> (0x20U - shift_amount & 0xff) | dividend_high << shift_amount;\n        dividend = dividend << shift_amount;\n      }\n      temp_div_high = temp_high >> 0x10;\n      remainder_high = dividend_high / temp_div_high;\n      temp_div = remainder_high * (temp_high & 0xffff);\n      quotient_high = dividend >> 0x10 | (dividend_high - temp_div_high * remainder_high) * 0x10000;\n      remainder_low = remainder_high;\n      if (quotient_high <= temp_div && temp_div - quotient_high != 0) {\n        carry_flag = CARRY4(temp_high,quotient_high);\n        quotient_high = temp_high + quotient_high;\n        remainder_low = remainder_high - 1;\n        if ((carry_flag == false) && (quotient_high <= temp_div && temp_div - quotient_high != 0)) {\n          remainder_low = remainder_high - 2;\n          quotient_high = quotient_high + temp_high;\n        }\n      }\n      quotient_low = (quotient_high - temp_div) / temp_div_high;\n      temp_low = quotient_low * (temp_high & 0xffff);\n      remainder_high = dividend & 0xffff | ((quotient_high - temp_div) - temp_div_high * quotient_low) * 0x10000;\n      quotient_high = quotient_low;\n      if (remainder_high <= temp_low && temp_low - remainder_high != 0) {\n        carry_flag = CARRY4(temp_high,remainder_high);\n        remainder_high = temp_high + remainder_high;\n        quotient_high = quotient_low - 1;\n        if ((carry_flag == false) && (remainder_high <= temp_low && temp_low - remainder_high != 0)) {\n          quotient_high = quotient_low - 2;\n          remainder_high = remainder_high + temp_high;\n        }\n      }\n      quotient_high = quotient_high | remainder_low << 0x10;\n      puVar9 = (uint *)0x0;\n      remainder_high = remainder_high - temp_low;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        UNRECOVERED_JUMPTABLE = (code *)software_udf(0xff,0x8001302);\n        result = (*UNRECOVERED_JUMPTABLE)();\n        return result;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        puVar9 = (uint *)0x1;\n        dividend_high = dividend_high - divisor;\n        temp_div_high = divisor >> 0x10;\n        quotient_low = divisor & 0xffff;\n        temp_high = divisor;\n      }\n      else {\n        temp_high = divisor << shift_amount;\n        quotient_high = dividend_high >> (0x20U - shift_amount & 0xff);\n        temp_div_high = temp_high >> 0x10;\n        temp_div = quotient_high / temp_div_high;\n        quotient_low = temp_high & 0xffff;\n        temp_low = temp_div * quotient_low;\n        remainder_high = dividend >> (0x20U - shift_amount & 0xff) | dividend_high << shift_amount;\n        remainder_low = remainder_high >> 0x10 | (quotient_high - temp_div_high * temp_div) * 0x10000;\n        dividend = dividend << shift_amount;\n        quotient_high = temp_div;\n        if (remainder_low <= temp_low && temp_low - remainder_low != 0) {\n          carry_flag = CARRY4(temp_high,remainder_low);\n          remainder_low = temp_high + remainder_low;\n          quotient_high = temp_div - 1;\n          if ((carry_flag == false) && (remainder_low <= temp_low && temp_low - remainder_low != 0)) {\n            quotient_high = temp_div - 2;\n            remainder_low = remainder_low + temp_high;\n          }\n        }\n        temp_div = (remainder_low - temp_low) / temp_div_high;\n        temp_div_low = temp_div * quotient_low;\n        dividend_high = remainder_high & 0xffff | ((remainder_low - temp_low) - temp_div_high * temp_div) * 0x10000;\n        remainder_low = temp_div;\n        if (dividend_high <= temp_div_low && temp_div_low - dividend_high != 0) {\n          carry_flag = CARRY4(temp_high,dividend_high);\n          dividend_high = temp_high + dividend_high;\n          remainder_low = temp_div - 1;\n          if ((carry_flag == false) && (dividend_high <= temp_div_low && temp_div_low - dividend_high != 0)) {\n            remainder_low = temp_div - 2;\n            dividend_high = dividend_high + temp_high;\n          }\n        }\n        dividend_high = dividend_high - temp_div_low;\n        puVar9 = (uint *)(remainder_low | quotient_high << 0x10);\n      }\n      temp_div = dividend_high / temp_div_high;\n      quotient_high = quotient_low * temp_div;\n      remainder_high = dividend >> 0x10 | (dividend_high - temp_div_high * temp_div) * 0x10000;\n      remainder_low = temp_div;\n      if (remainder_high <= quotient_high && quotient_high - remainder_high != 0) {\n        carry_flag = CARRY4(temp_high,remainder_high);\n        remainder_high = temp_high + remainder_high;\n        remainder_low = temp_div - 1;\n        if ((carry_flag == false) && (remainder_high <= quotient_high && quotient_high - remainder_high != 0)) {\n          remainder_low = temp_div - 2;\n          remainder_high = remainder_high + temp_high;\n        }\n      }\n      temp_div = (remainder_high - quotient_high) / temp_div_high;\n      quotient_low = quotient_low * temp_div;\n      remainder_high = dividend & 0xffff | ((remainder_high - quotient_high) - temp_div_high * temp_div) * 0x10000;\n      quotient_high = temp_div;\n      if (remainder_high <= quotient_low && quotient_low - remainder_high != 0) {\n        carry_flag = CARRY4(temp_high,remainder_high);\n        remainder_high = temp_high + remainder_high;\n        quotient_high = temp_div - 1;\n        if ((carry_flag == false) && (remainder_high <= quotient_low && quotient_low - remainder_high != 0)) {\n          quotient_high = temp_div - 2;\n          remainder_high = remainder_high + temp_high;\n        }\n      }\n      remainder_high = remainder_high - quotient_low;\n      quotient_high = quotient_high | remainder_low << 0x10;\n    }\n    if (quotient != (uint *)0x0) {\n      *quotient = remainder_high >> LZCOUNT(divisor);\n      quotient[1] = 0;\n    }\n  }\n  else {\n    puVar9 = quotient;\n    if (dividend_high < divisor_high) {\n      if (quotient != (uint *)0x0) {\n        *quotient = dividend;\n        quotient[1] = dividend_high;\n        return 0;\n      }\n      quotient_high = 0;\n    }\n    else {\n      shift_amount = LZCOUNT(divisor_high);\n      if (shift_amount == 0) {\n        if ((divisor_high < dividend_high) || (divisor <= dividend)) {\n          carry_flag = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_high = (dividend_high - divisor_high) - (uint)carry_flag;\n          quotient_high = 1;\n        }\n        else {\n          quotient_high = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (quotient != (uint *)0x0) {\n          *quotient = dividend;\n          quotient[1] = dividend_high;\n        }\n      }\n      else {\n        remainder_high = 0x20 - shift_amount;\n        quotient_low = divisor >> (remainder_high & 0xff) | divisor_high << shift_amount;\n        temp_high = dividend_high >> (remainder_high & 0xff);\n        temp_low = quotient_low >> 0x10;\n        temp_div = temp_high / temp_low;\n        temp_div_high = temp_div * (quotient_low & 0xffff);\n        quotient_high = dividend_high << shift_amount | dividend >> (remainder_high & 0xff);\n        remainder_low = quotient_high >> 0x10 | (temp_high - temp_low * temp_div) * 0x10000;\n        dividend = dividend << shift_amount;\n        temp_high = temp_div;\n        if (remainder_low <= temp_div_high && temp_div_high - remainder_low != 0) {\n          carry_flag = CARRY4(quotient_low,remainder_low);\n          remainder_low = quotient_low + remainder_low;\n          temp_high = temp_div - 1;\n          if ((carry_flag == false) && (remainder_low <= temp_div_high && temp_div_high - remainder_low != 0)) {\n            temp_high = temp_div - 2;\n            remainder_low = remainder_low + quotient_low;\n          }\n        }\n        temp_div = (remainder_low - temp_div_high) / temp_low;\n        temp_div_low = temp_div * (quotient_low & 0xffff);\n        remainder_low = quotient_high & 0xffff | ((remainder_low - temp_div_high) - temp_low * temp_div) * 0x10000;\n        quotient_high = temp_div;\n        if (remainder_low <= temp_div_low && temp_div_low - remainder_low != 0) {\n          carry_flag = CARRY4(quotient_low,remainder_low);\n          remainder_low = quotient_low + remainder_low;\n          quotient_high = temp_div - 1;\n          if ((carry_flag == false) && (remainder_low <= temp_div_low && temp_div_low - remainder_low != 0)) {\n            quotient_high = temp_div - 2;\n            remainder_low = remainder_low + quotient_low;\n          }\n        }\n        quotient_high = quotient_high | temp_high << 0x10;\n        temp = (ulonglong)quotient_high * (ulonglong)(divisor << shift_amount);\n        if (CONCAT44(remainder_low - temp_div_low,dividend) < temp) {\n          quotient_high = quotient_high - 1;\n          temp = temp - CONCAT44(quotient_low,divisor << shift_amount);\n        }\n        if (quotient != (uint *)0x0) {\n          temp_high = ((remainder_low - temp_div_low) - (int)(temp >> 0x20)) - (uint)(dividend < (uint)temp);\n          *quotient = temp_high << (remainder_high & 0xff) | dividend - (uint)temp >> shift_amount;\n          quotient[1] = temp_high >> shift_amount;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,quotient_high);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "perform_division_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "param_5": "quotient",
                "uVar1": "temp",
                "uVar2": "quotient_low",
                "uVar3": "remainder_low",
                "uVar4": "temp_low",
                "iVar5": "shift_amount",
                "uVar6": "quotient_high",
                "uVar7": "temp_high",
                "uVar8": "remainder_high",
                "uVar10": "temp_div",
                "uVar11": "temp_div_high",
                "uVar12": "temp_div_low",
                "bVar13": "carry_flag",
                "uVar14": "result"
            },
            "calling": [
                "__aeabi_uldivmod"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_hardware_080014f0",
            "code": "\n\n\nundefined4 initializeHardware_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  setInterruptPriorityGroup(3);\n  initializeTick(0xf);\n  initializeHardware_080014f0Specific();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_hardware_080014f0",
                "HAL_NVIC_SetPriorityGrouping": "setInterruptPriorityGroup",
                "HAL_InitTick": "initializeTick",
                "HAL_MspInit": "initializeHardwareSpecific"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_NVIC_SetPriorityGrouping",
                "HAL_MspInit",
                "HAL_InitTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "configure_systick_and_nvic_priority_0800151c",
            "code": "\nundefined4 configureSystickAndNVICPriority_0800151c(uint priority)\n\n{\n  int systickConfigResult;\n  undefined4 actionResult;\n  \n  systickConfigResult = HAL_SYSTICK_Config((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (systickConfigResult == 0) {\n    if (priority < 0x10) {\n      HAL_NVIC_SetPriority(0xffffffff,priority,0);\n      actionResult = 0;\n      DAT_20000000 = priority;\n    }\n    else {\n      actionResult = 1;\n    }\n  }\n  else {\n    actionResult = 1;\n  }\n  return actionResult;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "configure_systick_and_nvic_priority_0800151c",
                "param_1": "priority",
                "iVar1": "systickConfigResult",
                "uVar2": "actionResult"
            },
            "calling": [
                "HAL_RCC_ClockConfig",
                "HAL_Init"
            ],
            "called": [
                "HAL_NVIC_SetPriority",
                "HAL_SYSTICK_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "increment_value_0800157c",
            "code": "\nvoid incrementValue_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "increment_value_0800157c"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_data_value_080015a0",
            "code": "\nundefined4 get_data_value_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_data_value_080015a0"
            },
            "calling": [
                "_get_ms_tick",
                "HAL_I2C_Mem_Read",
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_I2C_Mem_Write",
                "HAL_RCC_ClockConfig",
                "I2C_RequestMemoryRead",
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "I2C_WaitOnMasterAddressFlagUntilTimeout",
                "HAL_UART_Transmit",
                "HAL_RCC_OscConfig",
                "I2C_RequestMemoryWrite"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "set_params_and_flags_080015b4",
            "code": "\n\n\nvoid set_params_and_flags_080015b4(uint input_value)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (input_value & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "set_params_and_flags_080015b4",
                "param_1": "input_value"
            },
            "calling": [
                "HAL_NVIC_SetPriorityGrouping"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_shifted_bitmask_080015fc",
            "code": "\n\n\nuint getShiftedBitmask_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 bitwiseAndOperator 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_shifted_bitmask_080015fc",
                "&": "bitwiseAndOperator"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "write_value_to_memory_08001618",
            "code": "\nvoid writeValueToMemory_08001618(byte address,uint value)\n\n{\n  if (isNegative < '\\0') {\n    *(char *)((address & 0xf) + 0xe000ed14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)(isNegative + -0x1fff1c00) = (char)((value & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "write_value_to_memory_08001618",
                "param_1": "address",
                "param_2": "value",
                "(char)param_1": "isNegative"
            },
            "calling": [
                "HAL_NVIC_SetPriority",
                "SysTick_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "bitwise_operation_0800166c",
            "code": "\nuint bitwiseOperation_0800166c(uint inputValue,uint mask,uint result)\n\n{\n  uint shiftAmount;\n  \n  inputValue = inputValue & 7;\n  shiftAmount = 7 - inputValue;\n  if (3 < shiftAmount) {\n    shiftAmount = 4;\n  }\n  if (inputValue + 4 < 7) {\n    inputValue = 0;\n  }\n  else {\n    inputValue = inputValue - 3;\n  }\n  return result & ~(-1 << (inputValue & 0xff)) |\n         (~(-1 << (shiftAmount & 0xff)) & mask) << (inputValue & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "bitwise_operation_0800166c",
                "param_1": "inputValue",
                "param_2": "mask",
                "param_3": "result",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "HAL_NVIC_SetPriority"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_priority_and_set_080016d0",
            "code": "\n\n\nbool checkPriorityAndSet_080016d0(int priority)\n\n{\n  bool isPriorityValid;\n  \n  isPriorityValid = priority - 1U < 0x1000000;\n  if (isPriorityValid) {\n    _DAT_e000e014 = priority + -1;\n    NVIC_SetPriority(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isPriorityValid;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_priority_and_set_080016d0",
                "param_1": "priority",
                "bVar1": "isPriorityValid"
            },
            "calling": [
                "HAL_SYSTICK_Config"
            ],
            "called": [
                "NVIC_SetPriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_nvic_priority_grouping_08001714",
            "code": "\nvoid setNVICPriorityGrouping_08001714(undefined4 priorityGroup)\n\n{\n  setPriorityGrouping(priorityGroup);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_nvic_priority_grouping_08001714",
                "param_1": "priorityGroup",
                "NVIC_SetPriorityGrouping": "setPriorityGrouping"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [
                "NVIC_SetPriorityGrouping"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "set_priority_with_encoded_value_0800172a",
            "code": "\nvoid setPriorityWithEncodedValue_0800172a(char peripheral,undefined4 priorityGroup,undefined4 preemptPriority)\n\n{\n  undefined4 priorityGrouping;\n  \n  priorityGrouping = getPriorityGrouping();\n  priorityGrouping = encodePriority(priorityGrouping,priorityGroup,preemptPriority);\n  setPriority((int)peripheral,priorityGrouping);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "set_priority_with_encoded_value_0800172a",
                "param_1": "peripheral",
                "param_2": "priorityGroup",
                "param_3": "preemptPriority",
                "uVar1": "priorityGrouping",
                "NVIC_GetPriorityGrouping": "getPriorityGrouping",
                "NVIC_EncodePriority": "encodePriority",
                "NVIC_SetPriority": "setPriority"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "NVIC_SetPriority",
                "NVIC_GetPriorityGrouping",
                "NVIC_EncodePriority"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "configure_sys_tick_08001762",
            "code": "\nundefined4 configureSysTick_08001762(undefined4 configValue)\n\n{\n  undefined4 result;\n  \n  result = SysTick_Config(configValue);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001762": "configure_sys_tick_08001762",
                "param_1": "configValue",
                "uVar1": "result"
            },
            "calling": [
                "HAL_InitTick",
                "SystemClock_Config"
            ],
            "called": [
                "SysTick_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_permission_flag_0800177c",
            "code": "\n\n\nvoid setPermissionFlag_0800177c(int permissionLevel)\n\n{\n  if (permissionLevel == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_permission_flag_0800177c",
                "param_1": "permissionLevel"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "handle_timer_period_elapsed_080017b4",
            "code": "\nvoid handleTimerPeriodElapsed_080017b4(void)\n\n{\n  timerCallback(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "handle_timer_period_elapsed_080017b4",
                "HAL_TIM_PeriodElapsedCallback": "timerCallback"
            },
            "calling": [
                "SysTick_Handler"
            ],
            "called": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "update_flags_080017c4",
            "code": "\n\n\nvoid updateFlags_080017c4(uint *outputArray,uint *inputArray)\n\n{\n  uint bitMask;\n  uint bitCheck;\n  uint value;\n  uint *outputPtr;\n  int index;\n  uint newValue;\n  uint bitIndex;\n  \n  newValue = 0;\n  bitIndex = 0;\n  do {\n    if (0xf < bitIndex) {\n      return;\n    }\n    bitMask = 1 << (bitIndex & 0xff);\n    bitCheck = *inputArray & bitMask;\n    if (bitCheck == bitMask) {\n      value = inputArray[1];\n      if (value == 0x12) {\n        newValue = inputArray[3] + 0xc;\n      }\n      else if (value < 0x13) {\n        if (value == 2) {\n          newValue = inputArray[3] + 8;\n        }\n        else if (value < 3) {\n          if (value == 0) goto LAB_08001882;\n          if (value == 1) {\n            newValue = inputArray[3];\n          }\n        }\n        else if (value == 3) {\n          newValue = 0;\n        }\n        else if (value == 0x11) {\n          newValue = inputArray[3] + 4;\n        }\n      }\n      else if (value == 0x10210000) {\nLAB_08001882:\n        if (inputArray[2] == 0) {\n          newValue = 4;\n        }\n        else if (inputArray[2] == 1) {\n          newValue = 8;\n          outputArray[4] = bitMask;\n        }\n        else {\n          newValue = 8;\n          outputArray[5] = bitMask;\n        }\n      }\n      else if (value < 0x10210001) {\n        if ((value == 0x10110000) || (value == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((value == 0x10310000) || (value == 0x10320000)) || (value == 0x10220000))\n      goto LAB_08001882;\n      if (bitCheck < 0x100) {\n        bitMask = bitIndex << 2;\n        outputPtr = outputArray;\n      }\n      else {\n        outputPtr = outputArray + 1;\n        bitMask = (bitIndex - 8) * 4;\n      }\n      *outputPtr = *outputPtr & ~(0xf << (bitMask & 0xff)) | newValue << (bitMask & 0xff);\n      if ((inputArray[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (outputArray == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (outputArray == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (outputArray == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (outputArray == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000) =\n             index << ((bitIndex & 3) << 2) |\n             ~(0xf << ((bitIndex & 3) << 2)) & *(uint *)(((bitIndex >> 2) + 2) * 4 + 0x40010000);\n        if ((inputArray[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~bitCheck & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = bitCheck | _DAT_40010400;\n        }\n        if ((inputArray[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~bitCheck & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = bitCheck | _DAT_40010404;\n        }\n        if ((inputArray[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~bitCheck & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = bitCheck | _DAT_40010408;\n        }\n        if ((inputArray[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~bitCheck & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = bitCheck | _DAT_4001040c;\n        }\n      }\n    }\n    bitIndex = bitIndex + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "update_flags_080017c4",
                "param_1": "outputArray",
                "param_2": "inputArray",
                "uVar1": "bitMask",
                "uVar2": "bitCheck",
                "uVar3": "value",
                "puVar4": "outputPtr",
                "iVar5": "index",
                "local_10": "newValue",
                "local_c": "bitIndex"
            },
            "calling": [
                "MX_GPIO_Init",
                "HAL_TIM_MspPostInit"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "update_parameter_value_08001a80",
            "code": "\nvoid updateParameterValue_08001a80(int baseAddress,ushort newValue,char isShifted)\n\n{\n  if (isShifted == '\\0') {\n    *(unsignedInt *)(baseAddress + 0x10) = (unsignedInt)newValue << 0x10;\n  }\n  else {\n    *(unsignedInt *)(baseAddress + 0x10) = (unsignedInt)newValue;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "update_parameter_value_08001a80",
                "param_1": "baseAddress",
                "param_2": "newValue",
                "param_3": "isShifted",
                "uint": "unsignedInt"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "MX_GPIO_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "initialize_i2_c_08001ab0",
            "code": "\nundefined4 initializeI2C_08001ab0(uint **i2cParams)\n\n{\n  uint pclk1Freq;\n  char validFreq;\n  undefined4 status;\n  uint divider;\n  bool isZeroFreq;\n  \n  if (i2cParams == (uint **)0x0) {\n    status = 1;\n  }\n  else {\n    if (*(char *)((int)i2cParams + 0x3d) == '\\0') {\n      *(undefined *)(i2cParams + 0xf) = 0;\n      HAL_I2C_MspInit(i2cParams);\n    }\n    *(undefined *)((int)i2cParams + 0x3d) = 0x24;\n    **i2cParams = **i2cParams & 0xfffffffe;\n    pclk1Freq = HAL_RCC_GetPCLK1Freq();\n    if (i2cParams[1] < (uint *)0x186a1) {\n      divider = pclk1Freq;\n      if (pclk1Freq < 2000000) {\n        divider = 1;\n      }\n      validFreq = (char)divider;\n      if (1999999 < pclk1Freq) {\n        validFreq = '\\0';\n      }\n    }\n    else {\n      divider = pclk1Freq;\n      if (pclk1Freq < 4000000) {\n        divider = 1;\n      }\n      validFreq = (char)divider;\n      if (3999999 < pclk1Freq) {\n        validFreq = '\\0';\n      }\n    }\n    if (validFreq == '\\0') {\n      divider = pclk1Freq / 1000000;\n      (*i2cParams)[1] = divider;\n      if ((uint *)0x186a0 < i2cParams[1]) {\n        divider = (divider * 300) / 1000;\n      }\n      (*i2cParams)[8] = divider + 1;\n      if (i2cParams[1] < (uint *)0x186a1) {\n        pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cParams[1] << 1) + 1 & 0xfff;\n        if (pclk1Freq < 4) {\n          pclk1Freq = 4;\n        }\n      }\n      else {\n        if (i2cParams[2] == (uint *)0x0) {\n          divider = (pclk1Freq - 1) / (uint)((int)i2cParams[1] * 3) + 1 & 0xfff;\n          isZeroFreq = divider == 0;\n          if (isZeroFreq) {\n            divider = 1;\n          }\n          validFreq = (char)divider;\n          if (!isZeroFreq) {\n            validFreq = '\\0';\n          }\n        }\n        else {\n          divider = (pclk1Freq - 1) / (uint)((int)i2cParams[1] * 0x19) + 1 & 0xfff;\n          isZeroFreq = divider == 0;\n          if (isZeroFreq) {\n            divider = 1;\n          }\n          validFreq = (char)divider;\n          if (!isZeroFreq) {\n            validFreq = '\\0';\n          }\n        }\n        if (validFreq == '\\0') {\n          if (i2cParams[2] == (uint *)0x0) {\n            pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cParams[1] * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            pclk1Freq = (pclk1Freq - 1) / (uint)((int)i2cParams[1] * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          pclk1Freq = 1;\n        }\n      }\n      (*i2cParams)[7] = pclk1Freq;\n      **i2cParams = (uint)i2cParams[8] | (uint)i2cParams[7];\n      (*i2cParams)[2] = (uint)i2cParams[3] | (uint)i2cParams[4];\n      (*i2cParams)[3] = (uint)i2cParams[6] | (uint)i2cParams[5];\n      **i2cParams = **i2cParams | 1;\n      i2cParams[0x10] = (uint *)0x0;\n      *(undefined *)((int)i2cParams + 0x3d) = 0x20;\n      i2cParams[0xc] = (uint *)0x0;\n      *(undefined *)((int)i2cParams + 0x3e) = 0;\n      status = 0;\n    }\n    else {\n      status = 1;\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "initialize_i2_c_08001ab0",
                "param_1": "i2cParams",
                "uVar1": "pclk1Freq",
                "cVar2": "validFreq",
                "uVar3": "status",
                "uVar4": "divider",
                "bVar5": "isZeroFreq"
            },
            "calling": [
                "MX_I2C1_Init"
            ],
            "called": [
                "HAL_I2C_MspInit",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "HAL_I2C_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "perform_i2_c_transfer_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nperformI2CTransfer_08001ccc(uint **transferParams,undefined2 deviceAddress,undefined2 memoryAddress,undefined2 memAddressSize,uint *data,\n            undefined2 dataSize,undefined4 timeout)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 result;\n  uint *dataPtr;\n  \n  startTime = HAL_GetTick();\n  if (*(char *)((int)transferParams + 0x3d) == ' ') {\n    do {\n      if ((~(*transferParams)[6] & 2) != 0) {\n        currentTime = 0;\n        goto LAB_08001d9c;\n      }\n      currentTime = HAL_GetTick();\n    } while ((uint)(currentTime - startTime) < 0x1a);\n    transferParams[0xc] = (uint *)0x0;\n    *(undefined *)((int)transferParams + 0x3d) = 0x20;\n    *(undefined *)((int)transferParams + 0x3e) = 0;\n    *(undefined *)(transferParams + 0xf) = 0;\n    currentTime = 3;\nLAB_08001d9c:\n    if (currentTime == 0) {\n      if (*(char *)(transferParams + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(transferParams + 0xf) = 1;\n        if ((**transferParams & 1) != 1) {\n          **transferParams = **transferParams | 1;\n        }\n        **transferParams = **transferParams & 0xfffff7ff;\n        *(undefined *)((int)transferParams + 0x3d) = 0x21;\n        *(undefined *)((int)transferParams + 0x3e) = 0x40;\n        transferParams[0x10] = (uint *)0x0;\n        transferParams[9] = data;\n        *(undefined2 *)((int)transferParams + 0x2a) = dataSize;\n        transferParams[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(transferParams + 10) = *(undefined2 *)((int)transferParams + 0x2a);\n        currentTime = I2C_RequestMemoryWrite(transferParams,deviceAddress,memoryAddress,memAddressSize,timeout,startTime);\n        if (currentTime == 0) {\n          while (*(short *)(transferParams + 10) != 0) {\n            currentTime = I2C_WaitOnTXEFlagUntilTimeout(transferParams,timeout,startTime);\n            if (currentTime != 0) {\n              if (transferParams[0x10] == (uint *)0x4) {\n                **transferParams = **transferParams | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            dataPtr = transferParams[9];\n            transferParams[9] = (uint *)((int)dataPtr + 1);\n            (*transferParams)[4] = (uint)*(byte *)dataPtr;\n            *(short *)(transferParams + 10) = *(short *)(transferParams + 10) + -1;\n            *(short *)((int)transferParams + 0x2a) = *(short *)((int)transferParams + 0x2a) + -1;\n            if ((((*transferParams)[5] & 4) == 4) && (*(short *)(transferParams + 10) != 0)) {\n              dataPtr = transferParams[9];\n              transferParams[9] = (uint *)((int)dataPtr + 1);\n              (*transferParams)[4] = (uint)*(byte *)dataPtr;\n              *(short *)(transferParams + 10) = *(short *)(transferParams + 10) + -1;\n              *(short *)((int)transferParams + 0x2a) = *(short *)((int)transferParams + 0x2a) + -1;\n            }\n          }\n          startTime = I2C_WaitOnBTFFlagUntilTimeout(transferParams,timeout,startTime);\n          if (startTime == 0) {\n            **transferParams = **transferParams | 0x200;\n            *(undefined *)((int)transferParams + 0x3d) = 0x20;\n            *(undefined *)((int)transferParams + 0x3e) = 0;\n            *(undefined *)(transferParams + 0xf) = 0;\n            result = 0;\n          }\n          else if (transferParams[0x10] == (uint *)0x4) {\n            **transferParams = **transferParams | 0x200;\n            result = 1;\n          }\n          else {\n            result = 3;\n          }\n        }\n        else if (transferParams[0x10] == (uint *)0x4) {\n          *(undefined *)(transferParams + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(transferParams + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "perform_i2_c_transfer_08001ccc",
                "param_1": "transferParams",
                "param_2": "deviceAddress",
                "param_3": "memoryAddress",
                "param_4": "memAddressSize",
                "param_5": "data",
                "param_6": "dataSize",
                "param_7": "timeout",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "result",
                "puVar4": "dataPtr"
            },
            "calling": [
                "_i2c_write_reg"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_RequestMemoryWrite"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "perform_i2_c_read_operation_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nperformI2CReadOperation_08001f6c(uint **i2cData,undefined2 registerAddress,undefined2 subAddressSize,undefined2 deviceAddress,uint *receiveBuffer,\n            undefined2 bufferSize,uint timeout)\n\n{\n  int startTick;\n  uint dataValue;\n  int currentTime;\n  undefined4 result;\n  uint *bufferPtr;\n  \n  startTick = HAL_GetTick();\n  if (*(char *)((int)i2cData + 0x3d) == ' ') {\n    do {\n      if ((~(*i2cData)[6] & 2) != 0) {\n        currentTime = 0;\n        goto LAB_08002040;\n      }\n      currentTime = HAL_GetTick();\n    } while ((uint)(currentTime - startTick) < 0x1a);\n    i2cData[0xc] = (uint *)0x0;\n    *(undefined *)((int)i2cData + 0x3d) = 0x20;\n    *(undefined *)((int)i2cData + 0x3e) = 0;\n    *(undefined *)(i2cData + 0xf) = 0;\n    currentTime = 3;\nLAB_08002040:\n    if (currentTime == 0) {\n      if (*(char *)(i2cData + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(i2cData + 0xf) = 1;\n        if ((**i2cData & 1) != 1) {\n          **i2cData = **i2cData | 1;\n        }\n        **i2cData = **i2cData & 0xfffff7ff;\n        *(undefined *)((int)i2cData + 0x3d) = 0x22;\n        *(undefined *)((int)i2cData + 0x3e) = 0x40;\n        i2cData[0x10] = (uint *)0x0;\n        i2cData[9] = receiveBuffer;\n        *(undefined2 *)((int)i2cData + 0x2a) = bufferSize;\n        i2cData[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(i2cData + 10) = *(undefined2 *)((int)i2cData + 0x2a);\n        currentTime = I2C_RequestMemoryRead(i2cData,registerAddress,subAddressSize,deviceAddress,timeout,startTick);\n        if (currentTime == 0) {\n          if (*(short *)(i2cData + 10) == 0) {\n            **i2cData = **i2cData | 0x200;\n          }\n          else if (*(short *)(i2cData + 10) == 1) {\n            **i2cData = **i2cData & 0xfffffbff;\n            disableIRQinterrupts();\n            **i2cData = **i2cData | 0x200;\n            enableIRQinterrupts();\n          }\n          else if (*(short *)(i2cData + 10) == 2) {\n            **i2cData = **i2cData | 0x800;\n            disableIRQinterrupts();\n            **i2cData = **i2cData & 0xfffffbff;\n            enableIRQinterrupts();\n          }\n          else {\n            **i2cData = **i2cData | 0x400;\n          }\n          while (*(short *)(i2cData + 10) != 0) {\n            if (*(ushort *)(i2cData + 10) < 4) {\n              if (*(short *)(i2cData + 10) == 1) {\n                currentTime = I2C_WaitOnRXNEFlagUntilTimeout(i2cData,timeout,startTick);\n                if (currentTime != 0) {\n                  if (i2cData[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                dataValue = (*i2cData)[4];\n                bufferPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)bufferPtr + 1);\n                *(char *)bufferPtr = (char)dataValue;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              }\n              else if (*(short *)(i2cData + 10) == 2) {\n                do {\n                  if ((~(*i2cData)[5] & 4) == 0) {\n                    currentTime = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (currentTime = HAL_GetTick(), (uint)(currentTime - startTick) <= timeout))\n                        ));\n                i2cData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cData + 0x3e) = 0;\n                *(undefined *)(i2cData + 0xf) = 0;\n                currentTime = 3;\nLAB_080022fa:\n                if (currentTime != 0) {\n                  return 3;\n                }\n                disableIRQinterrupts();\n                **i2cData = **i2cData | 0x200;\n                dataValue = (*i2cData)[4];\n                bufferPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)bufferPtr + 1);\n                *(char *)bufferPtr = (char)dataValue;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n                enableIRQinterrupts();\n                dataValue = (*i2cData)[4];\n                bufferPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)bufferPtr + 1);\n                *(char *)bufferPtr = (char)dataValue;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*i2cData)[5] & 4) == 0) {\n                    currentTime = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (currentTime = HAL_GetTick(), (uint)(currentTime - startTick) <= timeout))\n                        ));\n                i2cData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cData + 0x3e) = 0;\n                *(undefined *)(i2cData + 0xf) = 0;\n                currentTime = 3;\nLAB_08002418:\n                if (currentTime != 0) {\n                  return 3;\n                }\n                **i2cData = **i2cData & 0xfffffbff;\n                disableIRQinterrupts();\n                dataValue = (*i2cData)[4];\n                bufferPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)bufferPtr + 1);\n                *(char *)bufferPtr = (char)dataValue;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n                do {\n                  if ((~(*i2cData)[5] & 4) == 0) {\n                    currentTime = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((timeout == 0xffffffff) ||\n                        ((timeout != 0 && (currentTime = HAL_GetTick(), (uint)(currentTime - startTick) <= timeout))\n                        ));\n                i2cData[0xc] = (uint *)0x0;\n                *(undefined *)((int)i2cData + 0x3d) = 0x20;\n                *(undefined *)((int)i2cData + 0x3e) = 0;\n                *(undefined *)(i2cData + 0xf) = 0;\n                currentTime = 3;\nLAB_0800250a:\n                if (currentTime != 0) {\n                  return 3;\n                }\n                **i2cData = **i2cData | 0x200;\n                dataValue = (*i2cData)[4];\n                bufferPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)bufferPtr + 1);\n                *(char *)bufferPtr = (char)dataValue;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n                enableIRQinterrupts();\n                dataValue = (*i2cData)[4];\n                bufferPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)bufferPtr + 1);\n                *(char *)bufferPtr = (char)dataValue;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              }\n            }\n            else {\n              currentTime = I2C_WaitOnRXNEFlagUntilTimeout(i2cData,timeout,startTick);\n              if (currentTime != 0) {\n                if (i2cData[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              dataValue = (*i2cData)[4];\n              bufferPtr = i2cData[9];\n              i2cData[9] = (uint *)((int)bufferPtr + 1);\n              *(char *)bufferPtr = (char)dataValue;\n              *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n              *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              if (((*i2cData)[5] & 4) == 4) {\n                dataValue = (*i2cData)[4];\n                bufferPtr = i2cData[9];\n                i2cData[9] = (uint *)((int)bufferPtr + 1);\n                *(char *)bufferPtr = (char)dataValue;\n                *(short *)(i2cData + 10) = *(short *)(i2cData + 10) + -1;\n                *(short *)((int)i2cData + 0x2a) = *(short *)((int)i2cData + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)i2cData + 0x3d) = 0x20;\n          *(undefined *)((int)i2cData + 0x3e) = 0;\n          *(undefined *)(i2cData + 0xf) = 0;\n          result = 0;\n        }\n        else if (i2cData[0x10] == (uint *)0x4) {\n          *(undefined *)(i2cData + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(i2cData + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "perform_i2_c_read_operation_08001f6c",
                "param_1": "i2cData",
                "param_2": "registerAddress",
                "param_3": "subAddressSize",
                "param_4": "deviceAddress",
                "param_5": "receiveBuffer",
                "param_6": "bufferSize",
                "param_7": "timeout",
                "iVar1": "startTick",
                "uVar2": "dataValue",
                "iVar3": "currentTime",
                "uVar4": "result",
                "puVar5": "bufferPtr"
            },
            "calling": [
                "_i2c_read_reg"
            ],
            "called": [
                "I2C_WaitOnRXNEFlagUntilTimeout",
                "I2C_RequestMemoryRead",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "perform_transmission_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nperformTransmission_08002640(uint **data,byte control,undefined2 address,short dataBytes,uint timeout,int startTick)\n\n{\n  int status;\n  undefined4 result;\n  \n  **data = **data | 0x100;\n  do {\n    if ((~(*data)[5] & 1) == 0) {\n      status = 0;\n      goto LAB_0800270a;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (status = HAL_GetTick(), (uint)(status - startTick) <= timeout))));\n  data[0xc] = (uint *)0x0;\n  *(undefined *)((int)data + 0x3d) = 0x20;\n  *(undefined *)((int)data + 0x3e) = 0;\n  *(undefined *)(data + 0xf) = 0;\n  status = 3;\nLAB_0800270a:\n  if (status == 0) {\n    (*data)[4] = control & 0xfe;\n    status = I2C_WaitOnMasterAddressFlagUntilTimeout(data,0x10002,timeout,startTick);\n    if (status == 0) {\n      status = I2C_WaitOnTXEFlagUntilTimeout(data,timeout,startTick,(*data)[6]);\n      if (status == 0) {\n        if (dataBytes == 1) {\n          (*data)[4] = (uint)(byte)address;\n        }\n        else {\n          (*data)[4] = (uint)(byte)((ushort)address >> 8);\n          status = I2C_WaitOnTXEFlagUntilTimeout(data,timeout,startTick);\n          if (status != 0) {\n            if (data[0x10] == (uint *)0x4) {\n              **data = **data | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data)[4] = (uint)(byte)address;\n        }\n        result = 0;\n      }\n      else if (data[0x10] == (uint *)0x4) {\n        **data = **data | 0x200;\n        result = 1;\n      }\n      else {\n        result = 3;\n      }\n    }\n    else if (data[0x10] == (uint *)0x4) {\n      result = 1;\n    }\n    else {\n      result = 3;\n    }\n  }\n  else {\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002640": "perform_transmission_08002640",
                "param_1": "data",
                "param_2": "control",
                "param_3": "address",
                "param_4": "dataBytes",
                "param_5": "timeout",
                "param_6": "startTick",
                "iVar1": "status",
                "uVar2": "result"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "perform_i2_c_communication_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nperformI2CCommunication_080027f4(uint **i2cDevice,byte address,undefined2 data,short dataLength,uint timeout,int startTime)\n\n{\n  int result;\n  undefined4 errorCode;\n  \n  **i2cDevice = **i2cDevice | 0x400;\n  **i2cDevice = **i2cDevice | 0x100;\n  do {\n    if ((~(*i2cDevice)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (result = HAL_GetTick(), (uint)(result - startTime) <= timeout))));\n  i2cDevice[0xc] = (uint *)0x0;\n  *(undefined *)((int)i2cDevice + 0x3d) = 0x20;\n  *(undefined *)((int)i2cDevice + 0x3e) = 0;\n  *(undefined *)(i2cDevice + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*i2cDevice)[4] = address & 0xfe;\n    result = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cDevice,0x10002,timeout,startTime);\n    if (result == 0) {\n      result = I2C_WaitOnTXEFlagUntilTimeout(i2cDevice,timeout,startTime,(*i2cDevice)[6]);\n      if (result == 0) {\n        if (dataLength == 1) {\n          (*i2cDevice)[4] = (uint)(byte)data;\n        }\n        else {\n          (*i2cDevice)[4] = (uint)(byte)((ushort)data >> 8);\n          result = I2C_WaitOnTXEFlagUntilTimeout(i2cDevice,timeout,startTime);\n          if (result != 0) {\n            if (i2cDevice[0x10] == (uint *)0x4) {\n              **i2cDevice = **i2cDevice | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*i2cDevice)[4] = (uint)(byte)data;\n        }\n        result = I2C_WaitOnTXEFlagUntilTimeout(i2cDevice,timeout,startTime);\n        if (result == 0) {\n          **i2cDevice = **i2cDevice | 0x100;\n          do {\n            if ((~(*i2cDevice)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (result = HAL_GetTick(), (uint)(result - startTime) <= timeout))));\n          i2cDevice[0xc] = (uint *)0x0;\n          *(undefined *)((int)i2cDevice + 0x3d) = 0x20;\n          *(undefined *)((int)i2cDevice + 0x3e) = 0;\n          *(undefined *)(i2cDevice + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*i2cDevice)[4] = (uint)(address | 1);\n            result = I2C_WaitOnMasterAddressFlagUntilTimeout(i2cDevice,0x10002,timeout,startTime);\n            if (result == 0) {\n              errorCode = 0;\n            }\n            else if (i2cDevice[0x10] == (uint *)0x4) {\n              errorCode = 1;\n            }\n            else {\n              errorCode = 3;\n            }\n          }\n          else {\n            errorCode = 3;\n          }\n        }\n        else if (i2cDevice[0x10] == (uint *)0x4) {\n          **i2cDevice = **i2cDevice | 0x200;\n          errorCode = 1;\n        }\n        else {\n          errorCode = 3;\n        }\n      }\n      else if (i2cDevice[0x10] == (uint *)0x4) {\n        **i2cDevice = **i2cDevice | 0x200;\n        errorCode = 1;\n      }\n      else {\n        errorCode = 3;\n      }\n    }\n    else if (i2cDevice[0x10] == (uint *)0x4) {\n      errorCode = 1;\n    }\n    else {\n      errorCode = 3;\n    }\n  }\n  else {\n    errorCode = 3;\n  }\n  return errorCode;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "perform_i2_c_communication_080027f4",
                "param_1": "i2cDevice",
                "param_2": "address",
                "param_3": "data",
                "param_4": "dataLength",
                "param_5": "timeout",
                "param_6": "startTime",
                "iVar1": "result",
                "uVar2": "errorCode"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "HAL_GetTick",
                "I2C_WaitOnMasterAddressFlagUntilTimeout"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_value_08002ad8",
            "code": "\nundefined4 checkValue_08002ad8(uint **inputPointer,uint value,uint timeout,int startTick)\n\n{\n  int currentTick;\n  char result;\n  uint tempValue;\n  bool isNonZero;\n  \n  do {\n    if ((value >> 0x10 & 0xff) == 1) {\n      tempValue = value & ~(*inputPointer)[5] & 0xffff;\n      isNonZero = tempValue != 0;\n      if (isNonZero) {\n        tempValue = 1;\n      }\n      result = (char)tempValue;\n      if (!isNonZero) {\n        result = '\\0';\n      }\n    }\n    else {\n      tempValue = value & ~(*inputPointer)[6] & 0xffff;\n      isNonZero = tempValue != 0;\n      if (isNonZero) {\n        tempValue = 1;\n      }\n      result = (char)tempValue;\n      if (!isNonZero) {\n        result = '\\0';\n      }\n    }\n    if (result == '\\0') {\n      return 0;\n    }\n    if (((*inputPointer)[5] & 0x400) == 0x400) {\n      **inputPointer = **inputPointer | 0x200;\n      (*inputPointer)[5] = 0xfffffbff;\n      inputPointer[0x10] = (uint *)0x4;\n      inputPointer[0xc] = (uint *)0x0;\n      *(undefined *)((int)inputPointer + 0x3d) = 0x20;\n      *(undefined *)(inputPointer + 0xf) = 0;\n      return 1;\n    }\n  } while ((timeout == 0xffffffff) ||\n          ((timeout != 0 && (currentTick = HAL_GetTick(), (uint)(currentTick - startTick) <= timeout))));\n  inputPointer[0xc] = (uint *)0x0;\n  *(undefined *)((int)inputPointer + 0x3d) = 0x20;\n  *(undefined *)(inputPointer + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_value_08002ad8",
                "param_1": "inputPointer",
                "param_2": "value",
                "param_3": "timeout",
                "param_4": "startTick",
                "iVar1": "currentTick",
                "cVar2": "result",
                "uVar3": "tempValue",
                "bVar4": "isNonZero"
            },
            "calling": [
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_i2c_acknowledge_08002bb4",
            "code": "\nundefined4 checkI2cAcknowledge_08002bb4(int *device,uint timeout,int startTick)\n\n{\n  int acknowledgeFailed;\n  \n  while( true ) {\n    if ((*(uint *)(*device + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    acknowledgeFailed = isAcknowledgeFailed(device);\n    if (acknowledgeFailed != 0) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (acknowledgeFailed = getCurrentTick(), timeout < (uint)(acknowledgeFailed - startTick))))) {\n      device[0x10] = device[0x10] | 0x20;\n      device[0xc] = 0;\n      *(undefined *)((int)device + 0x3d) = 0x20;\n      *(undefined *)(device + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_i2c_acknowledge_08002bb4",
                "param_1": "device",
                "param_2": "timeout",
                "param_3": "startTick",
                "iVar1": "acknowledgeFailed",
                "I2C_IsAcknowledgeFailed": "isAcknowledgeFailed",
                "HAL_GetTick": "getCurrentTick"
            },
            "calling": [
                "HAL_I2C_Mem_Write",
                "I2C_RequestMemoryRead",
                "I2C_RequestMemoryWrite"
            ],
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "handle_i2_c_communication_08002c2e",
            "code": "\nundefined4 handleI2CCommunication_08002c2e(int *dataBuffer,uint timeout,int startTime)\n\n{\n  int isAcknowledgeFailed;\n  \n  while( true ) {\n    if ((*(uint *)(*dataBuffer + 0x14) & 4) == 4) {\n      return 0;\n    }\n    isAcknowledgeFailed = checkAcknowledgeFailed(dataBuffer);\n    if (isAcknowledgeFailed != 0) break;\n    if ((timeout != 0xffffffff) &&\n       ((timeout == 0 || (isAcknowledgeFailed = getCurrentTime(), timeout < (uint)(isAcknowledgeFailed - startTime))))) {\n      dataBuffer[0x10] = dataBuffer[0x10] | 0x20;\n      dataBuffer[0xc] = 0;\n      *(undefined *)((int)dataBuffer + 0x3d) = 0x20;\n      *(undefined *)(dataBuffer + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "handle_i2_c_communication_08002c2e",
                "param_1": "dataBuffer",
                "param_2": "timeout",
                "param_3": "startTime",
                "iVar1": "isAcknowledgeFailed",
                "I2C_IsAcknowledgeFailed": "checkAcknowledgeFailed",
                "HAL_GetTick": "getCurrentTime"
            },
            "calling": [
                "HAL_I2C_Mem_Write"
            ],
            "called": [
                "I2C_IsAcknowledgeFailed",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_and_set_flags_08002ca8",
            "code": "\nundefined4 checkAndSetFlags_08002ca8(int *dataPointer,uint timeout,int startTick)\n\n{\n  int currentTick;\n  \n  while( true ) {\n    if ((*(uint *)(*dataPointer + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*dataPointer + 0x14) & 0x10) == 0x10) break;\n    if ((timeout == 0) || (currentTick = HAL_GetTick(), timeout < (uint)(currentTick - startTick))) {\n      dataPointer[0x10] = dataPointer[0x10] | 0x20;\n      *(undefined *)((int)dataPointer + 0x3d) = 0x20;\n      *(undefined *)(dataPointer + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*dataPointer + 0x14) = 0xffffffef;\n  dataPointer[0x10] = 0;\n  dataPointer[0xc] = 0;\n  *(undefined *)((int)dataPointer + 0x3d) = 0x20;\n  *(undefined *)(dataPointer + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_and_set_flags_08002ca8",
                "param_1": "dataPointer",
                "param_2": "timeout",
                "param_3": "startTick",
                "iVar1": "currentTick"
            },
            "calling": [
                "HAL_I2C_Mem_Read"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_flag_status_08002d3c",
            "code": "\nbool checkFlagStatus_08002d3c(int *dataPointer)\n\n{\n  bool isFlagSet;\n  \n  isFlagSet = (*(uint *)(*dataPointer + 0x14) & 0x400) == 0x400;\n  if (isFlagSet) {\n    *(undefined4 *)(*dataPointer + 0x14) = 0xfffffbff;\n    errorCode = 4;\n    counter = 0;\n    *(undefined *)((int)dataPointer + 0x3d) = 0x20;\n    *(undefined *)(dataPointer + 0xf) = 0;\n  }\n  return isFlagSet;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_flag_status_08002d3c",
                "param_1": "dataPointer",
                "bVar1": "isFlagSet",
                "param_1[0x10]": "errorCode",
                "param_1[0xc]": "counter"
            },
            "calling": [
                "I2C_WaitOnTXEFlagUntilTimeout",
                "I2C_WaitOnBTFFlagUntilTimeout"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "HAL_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "check_and_control_08002d98",
            "code": "\n\n\nundefined4 checkAndControl_08002d98(uint *flags)\n\n{\n  int startTime;\n  int currentTime;\n  undefined4 result;\n  bool isOrWasOff;\n  \n  if ((*flags & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (flags[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (flags[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (flags[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (flags[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (flags[1] == 0) {\n        startTime = getElapsedTime();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentTime = getElapsedTime();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startTime = getElapsedTime();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentTime = getElapsedTime();\n          if (100 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*flags & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (flags[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = flags[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (flags[4] == 0) {\n      _DAT_42420000 = 0;\n      startTime = getElapsedTime();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentTime = getElapsedTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startTime = getElapsedTime();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentTime = getElapsedTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = flags[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*flags & 8) != 0) {\n    if (flags[6] == 0) {\n      _DAT_42420480 = 0;\n      startTime = getElapsedTime();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentTime = getElapsedTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startTime = getElapsedTime();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentTime = getElapsedTime();\n        if (2 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n      delayFunction(1);\n    }\n  }\n  if ((*flags & 4) != 0) {\n    isOrWasOff = (_DAT_4002101c & 0x10000000) == 0;\n    if (isOrWasOff) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startTime = getElapsedTime();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentTime = getElapsedTime();\n        if (100 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (flags[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (flags[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (flags[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (flags[3] == 0) {\n      startTime = getElapsedTime();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentTime = getElapsedTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startTime = getElapsedTime();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentTime = getElapsedTime();\n        if (5000 < (uint)(currentTime - startTime)) {\n          return 3;\n        }\n      }\n    }\n    if (isOrWasOff) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (flags[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (flags[7] == 2) {\n    _DAT_42420060 = 0;\n    startTime = getElapsedTime();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (flags[8] == 0x10000) {\n          _DAT_40021004 = flags[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = flags[9] | flags[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startTime = getElapsedTime();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentTime = getElapsedTime();\n          if (2 < (uint)(currentTime - startTime)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentTime = getElapsedTime();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startTime = getElapsedTime();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentTime = getElapsedTime();\n    } while ((uint)(currentTime - startTime) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "check_and_control_08002d98",
                "param_1": "flags",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "result",
                "bVar4": "isOrWasOff",
                "HAL_GetTick": "getElapsedTime",
                "RCC_Delay": "delayFunction"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_GetTick",
                "RCC_Delay"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "initialize_system_08003260",
            "code": "\n\n\nundefined4 initializeSystem_08003260(uint *configuration,uint param)\n\n{\n  int startTime;\n  int currentTime;\n  uint systemClock;\n  undefined4 status;\n  \n  if (((_DAT_40022000 & 7) < param) &&\n     (_DAT_40022000 = param | _DAT_40022000 & 0xfffffff8, param != (param & 7))) {\n    status = 1;\n  }\n  else {\n    if ((*configuration & 2) != 0) {\n      _DAT_40021004 = configuration[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*configuration & 1) == 0) {\nLAB_08003394:\n      if ((param < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = param | _DAT_40022000 & 0xfffffff8, param != (param & 7))) {\n        status = 1;\n      }\n      else {\n        if ((*configuration & 4) != 0) {\n          _DAT_40021004 = configuration[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*configuration & 8) != 0) {\n          _DAT_40021004 = configuration[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        systemClock = HAL_RCC_GetSysClockFreq();\n        DAT_20000018 = systemClock >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        HAL_InitTick(0xf);\n        status = 0;\n      }\n    }\n    else {\n      if (configuration[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((configuration[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = configuration[1] | _DAT_40021004 & 0xfffffffc;\n      startTime = HAL_GetTick();\n      if (configuration[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          currentTime = HAL_GetTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        status = 3;\n      }\n      else if (configuration[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          currentTime = HAL_GetTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        status = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          currentTime = HAL_GetTick();\n        } while ((uint)(currentTime - startTime) < 0x1389);\n        status = 3;\n      }\n    }\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_08003260": "initialize_system_08003260",
                "param_1": "configuration",
                "param_2": "param",
                "iVar1": "startTime",
                "iVar2": "currentTime",
                "uVar3": "systemClock",
                "uVar4": "status"
            },
            "calling": [
                "SystemClock_Config"
            ],
            "called": [
                "HAL_RCC_GetSysClockFreq",
                "HAL_InitTick",
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_clock_speed_08003440",
            "code": "\n\n\nuint calculateClockSpeed_08003440(void)\n\n{\n  undefined2 configFlag;\n  undefined4 flag1;\n  undefined4 flag2;\n  undefined4 flag3;\n  undefined4 flag4;\n  uint multiplier;\n  undefined4 temp;\n  uint local_14;\n  uint clockSpeed;\n  uint temp2;\n  \n  flag1 = 0x5040302;\n  flag2 = 0x9080706;\n  flag3 = 0xd0c0b0a;\n  flag4 = 0x10100f0e;\n  configFlag = 0x201;\n  temp = 0;\n  temp2 = 0;\n  multiplier = 0;\n  clockSpeed = 0;\n  local_14 = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    clockSpeed = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    multiplier = (uint)*(byte *)((int)&flag1 + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      temp2 = multiplier * 4000000;\n    }\n    else {\n      temp2 = (multiplier * 8000000) / (uint)*(byte *)((int)&configFlag + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    clockSpeed = temp2;\n  }\n  else {\n    clockSpeed = 8000000;\n  }\n  return clockSpeed;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_clock_speed_08003440",
                "local_30": "configFlag",
                "local_2c": "flag1",
                "uStack_28": "flag2",
                "uStack_24": "flag3",
                "uStack_20": "flag4",
                "local_1c": "multiplier",
                "local_18": "temp",
                "local_10": "clockSpeed",
                "local_c": "temp2"
            },
            "calling": [
                "HAL_RCC_ClockConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_data_08003504",
            "code": "\nundefined4 get_data_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_data_08003504"
            },
            "calling": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq",
                "SystemClock_Config"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "get_hclk_freq_08003518",
            "code": "\n\n\nuint getHCLKFreq_08003518(void)\n\n{\n  uint frequency;\n  \n  frequency = HAL_RCC_GetHCLKFreq();\n  return frequency >> *(shiftAmount *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "get_hclk_freq_08003518",
                "uVar1": "frequency",
                "sbyte": "shiftAmount"
            },
            "calling": [
                "HAL_I2C_Init",
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "get_adjusted_clock_frequency_08003540",
            "code": "\n\n\nuint getAdjustedClockFrequency_08003540(void)\n\n{\n  uint clockFrequency;\n  \n  clockFrequency = HAL_RCC_GetHCLKFreq();\n  return clockFrequency >> *(sbyte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "get_adjusted_clock_frequency_08003540",
                "uVar1": "clockFrequency"
            },
            "calling": [
                "UART_SetConfig"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_function_08003568",
            "code": "\nvoid delayFunction_08003568(int inputValue)\n\n{\n  bool continueLoop;\n  int calculatedValue;\n  \n  calculatedValue = inputValue * (DAT_20000018 / 8000);\n  do {\n    continueLoop = calculatedValue != 0;\n    calculatedValue = calculatedValue + -1;\n  } while (continueLoop);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_function_08003568",
                "param_1": "inputValue",
                "local_c": "calculatedValue",
                "bVar1": "continueLoop"
            },
            "calling": [
                "HAL_RCC_OscConfig"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "initialize_timer_080035a4",
            "code": "\nundefined4 initializeTimer_080035a4(undefined4 *timerParams)\n\n{\n  undefined4 result;\n  \n  if (timerParams == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)timerParams + 0x3d) == '\\0') {\n      *(undefined *)(timerParams + 0xf) = 0;\n      initializeTimer_080035a4Base(timerParams);\n    }\n    *(undefined *)((int)timerParams + 0x3d) = 2;\n    setTimerConfig(*timerParams,timerParams + 1);\n    *(undefined *)((int)timerParams + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "initialize_timer_080035a4",
                "param_1": "timerParams",
                "uVar1": "result",
                "HAL_TIM_Base_MspInit": "initializeTimerBase",
                "TIM_Base_SetConfig": "setTimerConfig"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [
                "HAL_TIM_Base_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_0800360c",
            "code": "\nundefined4 setFlags_0800360c(uint **ptrToUintPtr)\n\n{\n  (*ptrToUintPtr)[3] = (*ptrToUintPtr)[3] | 1;\n  **ptrToUintPtr = **ptrToUintPtr | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_0800360c",
                "param_1": "ptrToUintPtr"
            },
            "calling": [
                "main"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "initialize_timers_08003640",
            "code": "\nundefined4 initializeTimers_08003640(undefined4 *timerConfig)\n\n{\n  undefined4 result;\n  \n  if (timerConfig == (undefined4 *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)timerConfig + 0x3d) == '\\0') {\n      *(undefined *)(timerConfig + 0xf) = 0;\n      initializePwmMSP(timerConfig);\n    }\n    *(undefined *)((int)timerConfig + 0x3d) = 2;\n    setTimerConfig(*timerConfig,timerConfig + 1);\n    *(undefined *)((int)timerConfig + 0x3d) = 1;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003640": "initialize_timers_08003640",
                "param_1": "timerConfig",
                "uVar1": "result",
                "HAL_TIM_PWM_MspInit": "initializePwmMSP",
                "TIM_Base_SetConfig": "setTimerConfig"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_TIM_PWM_MspInit",
                "TIM_Base_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "HAL_TIM_PWM_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "initialize_peripheral_080036a8",
            "code": "\nundefined4 initializePeripheral_080036a8(uint **ptrPeripheral,undefined4 value)\n\n{\n  enableTimerChannel(*ptrPeripheral,value,1);\n  if (*ptrPeripheral == (uint *)0x40012c00) {\n    (*ptrPeripheral)[0x11] = (*ptrPeripheral)[0x11] | 0x8000;\n  }\n  **ptrPeripheral = **ptrPeripheral | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "initialize_peripheral_080036a8",
                "param_1": "ptrPeripheral",
                "param_2": "value",
                "TIM_CCxChannelCmd": "enableTimerChannel"
            },
            "calling": [
                "main"
            ],
            "called": [
                "TIM_CCxChannelCmd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "process_timers_080036f8",
            "code": "\nvoid processTimers_080036f8(int *timer)\n\n{\n  if (((*(uint *)(*timer + 0x10) & 2) == 2) && ((*(uint *)(*timer + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*timer + 0x10) = 0xfffffffd;\n    *(undefined *)(timer + 7) = 1;\n    if ((*(uint *)(*timer + 0x18) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    *(undefined *)(timer + 7) = 0;\n  }\n  if (((*(uint *)(*timer + 0x10) & 4) == 4) && ((*(uint *)(*timer + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*timer + 0x10) = 0xfffffffb;\n    *(undefined *)(timer + 7) = 2;\n    if ((*(uint *)(*timer + 0x18) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    *(undefined *)(timer + 7) = 0;\n  }\n  if (((*(uint *)(*timer + 0x10) & 8) == 8) && ((*(uint *)(*timer + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*timer + 0x10) = 0xfffffff7;\n    *(undefined *)(timer + 7) = 4;\n    if ((*(uint *)(*timer + 0x1c) & 3) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    *(undefined *)(timer + 7) = 0;\n  }\n  if (((*(uint *)(*timer + 0x10) & 0x10) == 0x10) && ((*(uint *)(*timer + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*timer + 0x10) = 0xffffffef;\n    *(undefined *)(timer + 7) = 8;\n    if ((*(uint *)(*timer + 0x1c) & 0x300) == 0) {\n      HAL_TIM_OC_DelayElapsedCallback(timer);\n      HAL_TIM_PWM_PulseFinishedCallback(timer);\n    }\n    else {\n      HAL_TIM_IC_CaptureCallback(timer);\n    }\n    *(undefined *)(timer + 7) = 0;\n  }\n  if (((*(uint *)(*timer + 0x10) & 1) == 1) && ((*(uint *)(*timer + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*timer + 0x10) = 0xfffffffe;\n    HAL_TIM_PeriodElapsedCallback(timer);\n  }\n  if (((*(uint *)(*timer + 0x10) & 0x80) == 0x80) && ((*(uint *)(*timer + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*timer + 0x10) = 0xffffff7f;\n    HAL_TIMEx_BreakCallback(timer);\n  }\n  if (((*(uint *)(*timer + 0x10) & 0x40) == 0x40) && ((*(uint *)(*timer + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*timer + 0x10) = 0xffffffbf;\n    HAL_TIM_TriggerCallback(timer);\n  }\n  if (((*(uint *)(*timer + 0x10) & 0x20) == 0x20) && ((*(uint *)(*timer + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*timer + 0x10) = 0xffffffdf;\n    HAL_TIMEx_CommutationCallback(timer);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "process_timers_080036f8",
                "param_1": "timer"
            },
            "calling": [
                "TIM2_IRQHandler"
            ],
            "called": [
                "HAL_TIMEx_CommutationCallback",
                "HAL_TIM_PeriodElapsedCallback",
                "HAL_TIM_OC_DelayElapsedCallback",
                "HAL_TIMEx_BreakCallback",
                "HAL_TIM_TriggerCallback",
                "HAL_TIM_IC_CaptureCallback",
                "HAL_TIM_PWM_PulseFinishedCallback"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "configure_output_compare_08003908",
            "code": "\nundefined4 configureOutputCompare_08003908(int *timerConfig,int outputCompareConfig,undefined4 channel)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(timerConfig + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(timerConfig + 0xf) = 1;\n    *(undefined *)((int)timerConfig + 0x3d) = 2;\n    switch(channel) {\n    case 0:\n      configureOutputCompare_08003908Channel1(*timerConfig,outputCompareConfig);\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(*timerConfig + 0x18) | 8;\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(*timerConfig + 0x18) & 0xfffffffb;\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(outputCompareConfig + 0x10) | *(uint *)(*timerConfig + 0x18);\n      break;\n    case 4:\n      configureOutputCompare_08003908Channel2(*timerConfig,outputCompareConfig);\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(*timerConfig + 0x18) | 0x800;\n      *(uint *)(*timerConfig + 0x18) = *(uint *)(*timerConfig + 0x18) & 0xfffffbff;\n      *(uint *)(*timerConfig + 0x18) = *(int *)(outputCompareConfig + 0x10) << 8 | *(uint *)(*timerConfig + 0x18);\n      break;\n    case 8:\n      configureOutputCompare_08003908Channel3(*timerConfig,outputCompareConfig);\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(*timerConfig + 0x1c) | 8;\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(*timerConfig + 0x1c) & 0xfffffffb;\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(outputCompareConfig + 0x10) | *(uint *)(*timerConfig + 0x1c);\n      break;\n    case 0xc:\n      configureOutputCompare_08003908Channel4(*timerConfig,outputCompareConfig);\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(*timerConfig + 0x1c) | 0x800;\n      *(uint *)(*timerConfig + 0x1c) = *(uint *)(*timerConfig + 0x1c) & 0xfffffbff;\n      *(uint *)(*timerConfig + 0x1c) = *(int *)(outputCompareConfig + 0x10) << 8 | *(uint *)(*timerConfig + 0x1c);\n    }\n    *(undefined *)((int)timerConfig + 0x3d) = 1;\n    *(undefined *)(timerConfig + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003908": "configure_output_compare_08003908",
                "param_1": "timerConfig",
                "param_2": "outputCompareConfig",
                "param_3": "channel",
                "uVar1": "result",
                "TIM_OC1_SetConfig": "configureOutputCompareChannel1",
                "TIM_OC2_SetConfig": "configureOutputCompareChannel2",
                "TIM_OC3_SetConfig": "configureOutputCompareChannel3",
                "TIM_OC4_SetConfig": "configureOutputCompareChannel4"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "TIM_OC2_SetConfig",
                "TIM_OC4_SetConfig",
                "TIM_OC1_SetConfig",
                "TIM_OC3_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "configure_timer_inputs_08003a94",
            "code": "\nundefined4 configureTimerInputs_08003a94(int *timerConfig,uint *inputConfig)\n\n{\n  undefined4 result;\n  uint inputType;\n  \n  if (*(char *)(timerConfig + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(timerConfig + 0xf) = 1;\n    *(undefined *)((int)timerConfig + 0x3d) = 2;\n    *(uint *)(*timerConfig + 8) = *(uint *)(*timerConfig + 8) & 0xffff0088;\n    inputType = *inputConfig;\n    if (inputType == 0x40) {\n      TIM_TI1_ConfigInputStage(*timerConfig,inputConfig[1],inputConfig[3]);\n      TIM_ITRx_SetConfig(*timerConfig,0x40);\n    }\n    else if (inputType < 0x41) {\n      if (inputType == 0x10) {\n        TIM_ITRx_SetConfig(*timerConfig,0x10);\n      }\n      else if (inputType < 0x11) {\n        if (inputType == 0) {\n          TIM_ITRx_SetConfig(*timerConfig,0);\n        }\n      }\n      else if (inputType == 0x20) {\n        TIM_ITRx_SetConfig(*timerConfig,0x20);\n      }\n      else if (inputType == 0x30) {\n        TIM_ITRx_SetConfig(*timerConfig,0x30);\n      }\n    }\n    else if (inputType == 0x70) {\n      TIM_ETR_SetConfig(*timerConfig,inputConfig[2],inputConfig[1],inputConfig[3]);\n      *(uint *)(*timerConfig + 8) = *(uint *)(*timerConfig + 8) & 0xffffff88 | 0x77;\n    }\n    else if (inputType < 0x71) {\n      if (inputType == 0x50) {\n        TIM_TI1_ConfigInputStage(*timerConfig,inputConfig[1],inputConfig[3]);\n        TIM_ITRx_SetConfig(*timerConfig,0x50);\n      }\n      else if (inputType == 0x60) {\n        TIM_TI2_ConfigInputStage(*timerConfig,inputConfig[1],inputConfig[3]);\n        TIM_ITRx_SetConfig(*timerConfig,0x60);\n      }\n    }\n    else if (inputType == 0x1000) {\n      *(uint *)(*timerConfig + 8) = *(uint *)(*timerConfig + 8) & 0xfffffff8;\n    }\n    else if (inputType == 0x2000) {\n      TIM_ETR_SetConfig(*timerConfig,inputConfig[2],inputConfig[1],inputConfig[3]);\n      *(uint *)(*timerConfig + 8) = *(uint *)(*timerConfig + 8) | 0x4000;\n    }\n    *(undefined *)((int)timerConfig + 0x3d) = 1;\n    *(undefined *)(timerConfig + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "configure_timer_inputs_08003a94",
                "param_1": "timerConfig",
                "param_2": "inputConfig",
                "uVar1": "result",
                "uVar2": "inputType"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [
                "TIM_ITRx_SetConfig",
                "TIM_TI1_ConfigInputStage",
                "TIM_TI2_ConfigInputStage",
                "TIM_ETR_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "update_parameters_08003c94",
            "code": "\nvoid updateParameters_08003c94(uint *destination,uint *source)\n\n{\n  uint tempValue;\n  \n  tempValue = *destination;\n  if ((((destination == (uint *)0x40012c00) || (destination == (uint *)0x40000000)) ||\n      (destination == (uint *)0x40000400)) || (destination == (uint *)0x40000800)) {\n    tempValue = source[1] | tempValue & 0xffffff8f;\n  }\n  if (((destination == (uint *)0x40012c00) || (destination == (uint *)0x40000000)) ||\n     ((destination == (uint *)0x40000400 || (destination == (uint *)0x40000800)))) {\n    tempValue = source[3] | tempValue & 0xfffffcff;\n  }\n  *destination = source[5] | tempValue & 0xffffff7f;\n  destination[0xb] = source[2];\n  destination[10] = *source;\n  if (destination == (uint *)0x40012c00) {\n    uRam40012c30 = source[4];\n  }\n  destination[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "update_parameters_08003c94",
                "param_1": "destination",
                "param_2": "source",
                "local_c": "tempValue"
            },
            "calling": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_Base_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "update_parameter_values_08003d60",
            "code": "\nvoid updateParameterValues_08003d60(int param_ptr,uint *param_values)\n\n{\n  uint value1;\n  uint value2;\n  uint local_value;\n  \n  *(uint *)(param_ptr + 0x20) = *(uint *)(param_ptr + 0x20) & 0xfffffffe;\n  local_value = *(uint *)(param_ptr + 4);\n  value1 = *param_values;\n  value2 = param_value5 | *(uint *)(param_ptr + 0x20) & 0xfffffffd;\n  if (param_ptr == 0x40012c00) {\n    value2 = (param_value6 | value2 & 0xfffffff7) & 0xfffffffb;\n    local_value = param_value7 | param_value8 | local_value & 0xfffffcff;\n  }\n  *(uint *)(param_ptr + 4) = local_value;\n  *(uint *)(param_ptr + 0x18) = value1 | *(uint *)(param_ptr + 0x18) & 0xffffff8c;\n  *(uint *)(param_ptr + 0x34) = param_values[1];\n  *(uint *)(param_ptr + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "update_parameter_values_08003d60",
                "param_1": "param_ptr",
                "param_2": "param_values",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "local_value",
                "param_2[2]": "param_value5",
                "param_2[3]": "param_value6",
                "param_2[6]": "param_value7",
                "param_2[5]": "param_value8"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "update_params_08003e38",
            "code": "\nvoid updateParams_08003e38(int baseAddress,int *paramsArray)\n\n{\n  int localVar1;\n  uint localVar2;\n  uint localVar3;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffffef;\n  localVar3 = *(uint *)(baseAddress + 4);\n  localVar1 = *paramsArray;\n  localVar2 = paramsArray[2] << 4 | *(uint *)(baseAddress + 0x20) & 0xffffffdf;\n  if (baseAddress == 0x40012c00) {\n    localVar2 = (paramsArray[3] << 4 | localVar2 & 0xffffff7f) & 0xffffffbf;\n    localVar3 = paramsArray[6] << 2 | paramsArray[5] << 2 | localVar3 & 0xfffff3ff;\n  }\n  *(uint *)(baseAddress + 4) = localVar3;\n  *(uint *)(baseAddress + 0x18) = localVar1 << 8 | *(uint *)(baseAddress + 0x18) & 0xffff8cff;\n  *(int *)(baseAddress + 0x38) = paramsArray[1];\n  *(uint *)(baseAddress + 0x20) = localVar2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "update_params_08003e38",
                "param_1": "baseAddress",
                "param_2": "paramsArray",
                "iVar1": "localVar1",
                "uVar2": "localVar2",
                "local_10": "localVar3"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "update_params_08003f18",
            "code": "\nvoid updateParams_08003f18(int paramAddr,uint *paramValues)\n\n{\n  uint value1;\n  uint value2;\n  uint localValue;\n  \n  *(uint *)(paramAddr + 0x20) = *(uint *)(paramAddr + 0x20) & 0xfffffeff;\n  localValue = *(uint *)(paramAddr + 4);\n  value1 = *paramValues;\n  value2 = paramValues[2] << 8 | *(uint *)(paramAddr + 0x20) & 0xfffffdff;\n  if (paramAddr == 0x40012c00) {\n    value2 = (paramValues[3] << 8 | value2 & 0xfffff7ff) & 0xfffffbff;\n    localValue = paramValues[6] << 4 | paramValues[5] << 4 | localValue & 0xffffcfff;\n  }\n  *(uint *)(paramAddr + 4) = localValue;\n  *(uint *)(paramAddr + 0x1c) = value1 | *(uint *)(paramAddr + 0x1c) & 0xffffff8c;\n  *(uint *)(paramAddr + 0x3c) = paramValues[1];\n  *(uint *)(paramAddr + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "update_params_08003f18",
                "param_1": "paramAddr",
                "param_2": "paramValues",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "localValue"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_flags_and_values_08003ff8",
            "code": "\nvoid updateFlagsAndValues_08003ff8(int address,int *parameters)\n\n{\n  int value1;\n  int value2;\n  uint flag;\n  \n  *(uint *)(address + 0x20) = *(uint *)(address + 0x20) & 0xffffefff;\n  flag = *(uint *)(address + 4);\n  value1 = *parameters;\n  value2 = parameters[2];\n  if (address == 0x40012c00) {\n    flag = parameters[5] << 6 | flag & 0xffffbfff;\n  }\n  *(uint *)(address + 4) = flag;\n  *(uint *)(address + 0x1c) = value1 << 8 | *(uint *)(address + 0x1c) & 0xffff8cff;\n  *(int *)(address + 0x40) = parameters[1];\n  *(uint *)(address + 0x20) = value2 << 0xc | *(uint *)(address + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_flags_and_values_08003ff8",
                "param_1": "address",
                "param_2": "parameters",
                "iVar1": "value1",
                "iVar2": "value2",
                "local_c": "flag"
            },
            "calling": [
                "HAL_TIM_PWM_ConfigChannel"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_data_080040a0",
            "code": "\nvoid updateData_080040a0(int dataPtr,uint newValue,int shiftValue)\n\n{\n  uint existingValue;\n  \n  existingValue = *(uint *)(dataPtr + 0x20);\n  *(uint *)(dataPtr + 0x20) = *(uint *)(dataPtr + 0x20) & 0xfffffffe;\n  *(uint *)(dataPtr + 0x18) = shiftValue << 4 | *(uint *)(dataPtr + 0x18) & 0xffffff0f;\n  *(uint *)(dataPtr + 0x20) = newValue | existingValue & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_data_080040a0",
                "param_1": "dataPtr",
                "param_2": "newValue",
                "param_3": "shiftValue",
                "uVar1": "existingValue"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_parameter_values_08004104",
            "code": "\nvoid updateParameterValues_08004104(int baseAddress,int value1,int value2)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffffef;\n  *(uint *)(baseAddress + 0x18) = value2 << 0xc | *(uint *)(baseAddress + 0x18) & 0xffff0fff;\n  *(uint *)(baseAddress + 0x20) = value1 << 4 | *(uint *)(baseAddress + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_parameter_values_08004104",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "set_bit_field_0800416a",
            "code": "\nvoid setBitField_0800416a(int baseAddress,ushort newValue)\n\n{\n  *(uint *)(baseAddress + 8) = *(uint *)(baseAddress + 8) bitwiseAnd 0xffffff8f | (uint)(newValue | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "set_bit_field_0800416a",
                "param_1": "baseAddress",
                "param_2": "newValue",
                "&": "bitwiseAnd"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "update_data_080041a8",
            "code": "\nvoid updateData_080041a8(int dataAddress,uint value1,uint value2,int value3)\n\n{\n  *(uint *)(dataAddress + 8) = value1 | value3 << 8 | value2 | *(uint *)(dataAddress + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "update_data_080041a8",
                "param_1": "dataAddress",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3"
            },
            "calling": [
                "HAL_TIM_ConfigClockSource"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bit_080041ea",
            "code": "\nvoid updateBit_080041ea(int baseAddress,uint bitPosition,int bitValue)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | bitValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bit_080041ea",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "bitValue"
            },
            "calling": [
                "HAL_TIM_PWM_Start"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "set_flag_if_equal_to_one_0800422e",
            "code": "\nundefined4 setFlagIfEqualToOne_0800422e(int *inputArray,uint *userData)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(inputArray + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(inputArray + 0xf) = 1;\n    *(uint *)(*inputArray + 0x44) =\n         userData[6] |\n         (userData[6] |\n         (userData[5] |\n         (userData[4] |\n         (*userData | (userData[1] | (userData[2] | userData[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(inputArray + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "set_flag_if_equal_to_one_0800422e",
                "param_1": "inputArray",
                "param_2": "userData",
                "uVar1": "result",
                "param_2[6]": "userData[6]",
                "param_2[5]": "userData[5]",
                "param_2[4]": "userData[4]",
                "param_2[1]": "userData[1]",
                "param_2[2]": "userData[2]"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "update_flags_and_values_080042de",
            "code": "\nundefined4 updateFlagsAndValues_080042de(int *array_ptr,uint *value_ptr)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(array_ptr + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(array_ptr + 0xf) = 1;\n    *(undefined *)((int)array_ptr + 0x3d) = 2;\n    *(uint *)(*array_ptr + 4) = *(uint *)(*array_ptr + 4) & 0xffffff8f;\n    *(uint *)(*array_ptr + 4) = *value_ptr | *(uint *)(*array_ptr + 4);\n    *(uint *)(*array_ptr + 8) = *(uint *)(*array_ptr + 8) & 0xffffff7f;\n    *(uint *)(*array_ptr + 8) = second_value_ptr | *(uint *)(*array_ptr + 8);\n    *(undefined *)((int)array_ptr + 0x3d) = 1;\n    *(undefined *)(array_ptr + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080042de": "update_flags_and_values_080042de",
                "param_1": "array_ptr",
                "param_2": "value_ptr",
                "uVar1": "result",
                "param_2[1]": "second_value_ptr"
            },
            "calling": [
                "MX_TIM1_Init",
                "MX_TIM2_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "HAL_TIM_IRQHandler"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_uart_0800438a",
            "code": "\nundefined4 initializeUART_0800438a(int *uartConfig)\n\n{\n  undefined4 result;\n  \n  if (uartConfig == (int *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)uartConfig + 0x39) == '\\0') {\n      *(undefined *)(uartConfig + 0xe) = 0;\n      HAL_UART_MspInit(uartConfig);\n    }\n    *(undefined *)((int)uartConfig + 0x39) = 0x24;\n    *(uint *)(*uartConfig + 0xc) = *(uint *)(*uartConfig + 0xc) & 0xffffdfff;\n    UART_SetConfig(uartConfig);\n    *(uint *)(*uartConfig + 0x10) = *(uint *)(*uartConfig + 0x10) & 0xffffb7ff;\n    *(uint *)(*uartConfig + 0x14) = *(uint *)(*uartConfig + 0x14) & 0xffffffd5;\n    *(uint *)(*uartConfig + 0xc) = *(uint *)(*uartConfig + 0xc) | 0x2000;\n    uartConfig[0xf] = 0;\n    *(undefined *)((int)uartConfig + 0x39) = 0x20;\n    *(undefined *)((int)uartConfig + 0x3a) = 0x20;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_uart_0800438a",
                "param_1": "uartConfig",
                "uVar1": "result"
            },
            "calling": [
                "MX_USART1_UART_Init"
            ],
            "called": [
                "HAL_UART_MspInit",
                "UART_SetConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "process_data_08004436",
            "code": "\nundefined4 processData_08004436(uint **inputArray,ushort *data,short dataLength,uint timeout)\n\n{\n  int currentTime;\n  int elapsedTime;\n  undefined4 result;\n  ushort *dataPtr;\n  \n  if (*(char *)((int)inputArray + 0x39) == ' ') {\n    if ((data == (ushort *)0x0) || (dataLength == 0)) {\n      result = 1;\n    }\n    else if (*(char *)(inputArray + 0xe) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(inputArray + 0xe) = 1;\n      inputArray[0xf] = (uint *)0x0;\n      *(undefined *)((int)inputArray + 0x39) = 0x21;\n      currentTime = HAL_GetTick();\n      *(short *)(inputArray + 9) = dataLength;\n      *(short *)((int)inputArray + 0x26) = dataLength;\n      dataPtr = data;\n      while (*(short *)((int)inputArray + 0x26) != 0) {\n        *(short *)((int)inputArray + 0x26) = *(short *)((int)inputArray + 0x26) + -1;\n        if (inputArray[2] == (uint *)0x1000) {\n          do {\n            if ((**inputArray & 0x80) == 0x80) {\n              elapsedTime = 0;\n              goto LAB_0800454c;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - currentTime) <= timeout))));\n          (*inputArray)[3] = (*inputArray)[3] & 0xfffffe5f;\n          (*inputArray)[5] = (*inputArray)[5] & 0xfffffffe;\n          *(undefined *)((int)inputArray + 0x39) = 0x20;\n          *(undefined *)((int)inputArray + 0x3a) = 0x20;\n          *(undefined *)(inputArray + 0xe) = 0;\n          elapsedTime = 3;\nLAB_0800454c:\n          if (elapsedTime != 0) {\n            return 3;\n          }\n          (*inputArray)[1] = *dataPtr & 0x1ff;\n          if (inputArray[4] == (uint *)0x0) {\n            dataPtr = dataPtr + 1;\n          }\n          else {\n            dataPtr = (ushort *)((int)dataPtr + 1);\n          }\n        }\n        else {\n          do {\n            if ((**inputArray & 0x80) == 0x80) {\n              elapsedTime = 0;\n              goto LAB_08004614;\n            }\n          } while ((timeout == 0xffffffff) ||\n                  ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - currentTime) <= timeout))));\n          (*inputArray)[3] = (*inputArray)[3] & 0xfffffe5f;\n          (*inputArray)[5] = (*inputArray)[5] & 0xfffffffe;\n          *(undefined *)((int)inputArray + 0x39) = 0x20;\n          *(undefined *)((int)inputArray + 0x3a) = 0x20;\n          *(undefined *)(inputArray + 0xe) = 0;\n          elapsedTime = 3;\nLAB_08004614:\n          if (elapsedTime != 0) {\n            return 3;\n          }\n          (*inputArray)[1] = (uint)*(byte *)dataPtr;\n          dataPtr = (ushort *)((int)dataPtr + 1);\n        }\n      }\n      do {\n        if ((**inputArray & 0x40) == 0x40) {\n          currentTime = 0;\n          goto LAB_080046c6;\n        }\n      } while ((timeout == 0xffffffff) ||\n              ((timeout != 0 && (elapsedTime = HAL_GetTick(), (uint)(elapsedTime - currentTime) <= timeout))));\n      (*inputArray)[3] = (*inputArray)[3] & 0xfffffe5f;\n      (*inputArray)[5] = (*inputArray)[5] & 0xfffffffe;\n      *(undefined *)((int)inputArray + 0x39) = 0x20;\n      *(undefined *)((int)inputArray + 0x3a) = 0x20;\n      *(undefined *)(inputArray + 0xe) = 0;\n      currentTime = 3;\nLAB_080046c6:\n      if (currentTime == 0) {\n        *(undefined *)((int)inputArray + 0x39) = 0x20;\n        *(undefined *)(inputArray + 0xe) = 0;\n        result = 0;\n      }\n      else {\n        result = 3;\n      }\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004436": "process_data_08004436",
                "param_1": "inputArray",
                "param_2": "data",
                "param_3": "dataLength",
                "param_4": "timeout",
                "iVar1": "currentTime",
                "iVar2": "elapsedTime",
                "uVar3": "result",
                "local_58": "dataPtr"
            },
            "calling": [
                "uart_print"
            ],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "calculate_clock_frequency_080046ec",
            "code": "\nvoid calculateClockFrequency_080046ec(int *clockParams)\n\n{\n  ulonglong frequencyRatio;\n  int pclkFreq1;\n  int clockParam1;\n  uint frequencyOffset;\n  int clockParam2;\n  undefined8 pclkFreq2;\n  \n  *(uint *)(*clockParams + 0x10) = clockParams[3] | *(uint *)(*clockParams + 0x10) & 0xffffcfff;\n  *(uint *)(*clockParams + 0xc) =\n       *(uint *)(*clockParams + 0xc) & 0xffffe9f3 | clockParams[5] | clockParams[2] | clockParams[4];\n  *(uint *)(*clockParams + 0x14) = clockParams[6] | *(uint *)(*clockParams + 0x14) & 0xfffffcff;\n  if (*clockParams == 0x40013800) {\n    pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n    frequencyRatio = (ulonglong)(uint)((int)pclkFreq2 * 0x19) / (ulonglong)(uint)(clockParams[1] << 2);\n    pclkFreq1 = HAL_RCC_GetPCLK2Freq\n                      ((int)pclkFreq2,(int)((ulonglong)pclkFreq2 >> 0x20),(int)(frequencyRatio * 0x51eb851f));\n    clockParam1 = clockParams[1];\n    pclkFreq2 = HAL_RCC_GetPCLK2Freq();\n    frequencyOffset = ((uint)(pclkFreq1 * 0x19) / (uint)(clockParam1 << 2) +\n            (int)(((ulonglong)(uint)((int)pclkFreq2 * 0x19) / (ulonglong)(uint)(clockParams[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    pclkFreq1 = HAL_RCC_GetPCLK2Freq((int)pclkFreq2,(int)((ulonglong)pclkFreq2 >> 0x20),frequencyOffset * 0x51eb851f);\n    clockParam2 = clockParams[1];\n    clockParam1 = HAL_RCC_GetPCLK2Freq();\n    *(uint *)(*clockParams + 8) =\n         ((((uint)(pclkFreq1 * 0x19) / (uint)(clockParam2 << 2) +\n           (int)(((ulonglong)(uint)(clockParam1 * 0x19) / (ulonglong)(uint)(clockParams[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(frequencyRatio / 100) * 0x10 + (frequencyOffset / 100 & 0xf0);\n  }\n  else {\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    frequencyRatio = (ulonglong)(uint)((int)pclkFreq2 * 0x19) / (ulonglong)(uint)(clockParams[1] << 2);\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq\n                      ((int)pclkFreq2,(int)((ulonglong)pclkFreq2 >> 0x20),(int)(frequencyRatio * 0x51eb851f));\n    clockParam1 = clockParams[1];\n    pclkFreq2 = HAL_RCC_GetPCLK1Freq();\n    frequencyOffset = ((uint)(pclkFreq1 * 0x19) / (uint)(clockParam1 << 2) +\n            (int)(((ulonglong)(uint)((int)pclkFreq2 * 0x19) / (ulonglong)(uint)(clockParams[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    pclkFreq1 = HAL_RCC_GetPCLK1Freq((int)pclkFreq2,(int)((ulonglong)pclkFreq2 >> 0x20),frequencyOffset * 0x51eb851f);\n    clockParam2 = clockParams[1];\n    clockParam1 = HAL_RCC_GetPCLK1Freq();\n    *(uint *)(*clockParams + 8) =\n         ((((uint)(pclkFreq1 * 0x19) / (uint)(clockParam2 << 2) +\n           (int)(((ulonglong)(uint)(clockParam1 * 0x19) / (ulonglong)(uint)(clockParams[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(frequencyRatio / 100) * 0x10 + (frequencyOffset / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "calculate_clock_frequency_080046ec",
                "param_1": "clockParams",
                "uVar1": "frequencyRatio",
                "iVar2": "pclkFreq1",
                "iVar3": "clockParam1",
                "uVar4": "frequencyOffset",
                "iVar5": "clockParam2",
                "uVar6": "pclkFreq2"
            },
            "calling": [
                "HAL_UART_Init"
            ],
            "called": [
                "HAL_RCC_GetPCLK2Freq",
                "HAL_RCC_GetPCLK1Freq"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_mpu6050_0800491c",
            "code": "\nvoid initializeMPU6050_0800491c(undefined4 *dataBuffer)\n\n{\n  undefined value_1;\n  undefined value_2;\n  undefined buffer [5];\n  \n  value_1 = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&value_1,1);\n  value_2 = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&value_2,1);\n  buffer[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,buffer,1);\n  *dataBuffer = 0;\n  dataBuffer[1] = 0;\n  dataBuffer[2] = 0;\n  dataBuffer[3] = 0;\n  dataBuffer[4] = 0;\n  dataBuffer[5] = 0;\n  dataBuffer[6] = 0;\n  dataBuffer[7] = 0;\n  dataBuffer[8] = 0;\n  dataBuffer[9] = 0;\n  dataBuffer[10] = 0;\n  calibrateMPU6050(dataBuffer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_mpu6050_0800491c",
                "param_1": "dataBuffer",
                "local_13": "value_1",
                "local_12": "value_2",
                "local_11": "buffer",
                "mpu6050_calibrate": "calibrateMPU6050"
            },
            "calling": [
                "main"
            ],
            "called": [
                "mpu6050_calibrate"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_average_sensor_values_080049cc",
            "code": "\nvoid calculateAverageSensorValues_080049cc(int sensorData)\n\n{\n  undefined4 average;\n  undefined4 roll;\n  undefined4 pitch;\n  undefined4 getCurrentTime;\n  int iterations;\n  int count;\n  undefined4 totalRoll;\n  undefined4 totalPitch;\n  undefined4 totalX;\n  undefined4 totalY;\n  \n  iterations = 1;\n  totalY = 0;\n  totalX = 0;\n  totalPitch = 0;\n  totalRoll = 0;\n  getCurrentTime = (*DAT_20000a50)();\n  count = 0;\n  while( true ) {\n    if (iterations <= count) break;\n    pitch = 0;\n    roll = 0;\n    mpu6050_update(sensorData);\n    mpu6050_calc_acc_pitch_roll(sensorData,&pitch,&roll);\n    totalPitch = __addsf3(totalPitch,pitch);\n    totalRoll = __addsf3(totalRoll,roll);\n    totalY = __addsf3(totalY,*(undefined4 *)(sensorData + 0x10));\n    totalX = __addsf3(totalX,*(undefined4 *)(sensorData + 0x14));\n    getCurrentTime = (*DAT_20000a50)();\n    count = count + 1;\n  }\n  average = __floatsisf(iterations);\n  average = __aeabi_fdiv(totalY,average);\n  *(undefined4 *)(sensorData + 0x1c) = average;\n  average = __floatsisf(iterations);\n  average = __aeabi_fdiv(totalX,average);\n  *(undefined4 *)(sensorData + 0x20) = average;\n  average = __floatsisf(iterations);\n  average = __aeabi_fdiv(totalPitch,average);\n  *(undefined4 *)(sensorData + 0x24) = average;\n  average = __floatsisf(iterations);\n  average = __aeabi_fdiv(totalRoll,average);\n  *(undefined4 *)(sensorData + 0x28) = average;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_average_sensor_values_080049cc",
                "param_1": "sensorData",
                "uVar1": "average",
                "local_2c": "roll",
                "local_28": "pitch",
                "local_24": "getCurrentTime",
                "local_20": "iterations",
                "local_1c": "count",
                "local_18": "totalRoll",
                "local_14": "totalPitch",
                "local_10": "totalX",
                "local_c": "totalY"
            },
            "calling": [
                "mpu6050_init"
            ],
            "called": [
                "__aeabi_fdiv",
                "__addsf3",
                "mpu6050_update",
                "mpu6050_calc_acc_pitch_roll",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "convert_to_floats_08004ae0",
            "code": "\nvoid convertToFloats_08004ae0(undefined4 *float_values)\n\n{\n  undefined4 converted_float;\n  undefined val_1;\n  undefined val_2;\n  undefined val_3;\n  undefined val_4;\n  undefined val_5;\n  undefined val_6;\n  undefined val_7;\n  undefined val_8;\n  undefined val_9;\n  undefined val_10;\n  undefined val_11;\n  undefined val_12;\n  undefined val_13;\n  undefined val_14;\n  short val_15;\n  short val_16;\n  short val_17;\n  short val_18;\n  short val_19;\n  short val_20;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&val_1,0xe);\n  val_20 = CONCAT11(val_3,val_4);\n  val_19 = CONCAT11(val_5,val_6);\n  val_18 = CONCAT11(val_7,val_8);\n  val_17 = CONCAT11(val_9,val_10);\n  val_16 = CONCAT11(val_11,val_12);\n  val_15 = CONCAT11(val_13,val_14);\n  converted_float = __floatsisf((int)CONCAT11(val_1,val_2));\n  *float_values = converted_float;\n  converted_float = __floatsisf((int)val_20);\n  float_values[1] = converted_float;\n  converted_float = __floatsisf((int)val_19);\n  float_values[2] = converted_float;\n  converted_float = __floatsisf((int)val_18);\n  float_values[3] = converted_float;\n  converted_float = __floatsisf((int)val_17);\n  float_values[4] = converted_float;\n  converted_float = __floatsisf((int)val_16);\n  float_values[5] = converted_float;\n  converted_float = __floatsisf((int)val_15);\n  float_values[6] = converted_float;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "convert_to_floats_08004ae0",
                "param_1": "float_values",
                "local_2c": "val_1",
                "local_2b": "val_2",
                "local_2a": "val_3",
                "local_29": "val_4",
                "local_28": "val_5",
                "local_27": "val_6",
                "local_26": "val_7",
                "local_25": "val_8",
                "local_24": "val_9",
                "local_23": "val_10",
                "local_22": "val_11",
                "local_21": "val_12",
                "local_20": "val_13",
                "local_1f": "val_14",
                "local_1e": "val_15",
                "local_1c": "val_16",
                "local_1a": "val_17",
                "local_18": "val_18",
                "local_16": "val_19",
                "local_14": "val_20",
                "uVar1": "converted_float"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "mpu6050_calibrate"
            ],
            "called": [
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_result_08004bd8",
            "code": "\nvoid calculate_result_08004bd8(int input_data,undefined4 *result)\n\n{\n  undefined4 difference;\n  undefined8 temp1;\n  undefined8 temp2;\n  \n  difference = __aeabi_fsub(*(undefined4 *)(input_data + 0x10),*(undefined4 *)(input_data + 0x1c));\n  temp1 = __aeabi_f2d(DAT_200009e4);\n  temp2 = __aeabi_f2d(difference);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x83f5c366,0x3f340215);\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                       (int)((ulonglong)temp2 >> 0x20));\n  DAT_200009e4 = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  temp1 = __aeabi_f2d(*(undefined4 *)(input_data + 4));\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40b00000);\n  temp2 = __aeabi_f2d(*(undefined4 *)(input_data + 8));\n  temp2 = __divdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,0x40b00000);\n  temp1 = atan2((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40668000);\n  temp1 = __divdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x54442d18,0x400921fb);\n  temp2 = __aeabi_f2d(*(undefined4 *)(input_data + 0x24));\n  temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                   (int)((ulonglong)temp2 >> 0x20));\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40568000);\n  difference = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    temp1 = __aeabi_f2d(DAT_200009e4);\n    temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x9999999a,0x3fe99999);\n    temp2 = __aeabi_f2d(difference);\n    temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x9999999a,0x3fc99999);\n    temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                         (int)((ulonglong)temp2 >> 0x20));\n    DAT_200009e4 = __truncdfsf2((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = difference;\n  }\n  *result = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_result_08004bd8",
                "param_1": "input_data",
                "param_2": "result",
                "uVar1": "difference",
                "uVar2": "temp1",
                "uVar3": "temp2"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "__aeabi_fsub",
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__truncdfsf2",
                "atan2",
                "__subdf3",
                "__aeabi_f2d"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_angle_08004d78",
            "code": "\nvoid calculateAngle_08004d78(undefined4 *dividendArray,undefined4 *quotientArray1,undefined4 *quotientArray2)\n\n{\n  undefined4 quotient1;\n  undefined4 quotient2;\n  undefined4 quotient3;\n  undefined8 angle1;\n  undefined8 angle2;\n  \n  quotient1 = __aeabi_fdiv(*dividendArray,0x45800000);\n  quotient2 = __aeabi_fdiv(dividendArray[1],0x45800000);\n  quotient3 = __aeabi_fdiv(dividendArray[2],0x45800000);\n  angle1 = __aeabi_f2d(quotient2);\n  angle2 = __aeabi_f2d(quotient3);\n  angle1 = atan2((int)angle1,(int)((ulonglong)angle1 >> 0x20),(int)angle2,\n                (int)((ulonglong)angle2 >> 0x20));\n  angle1 = __muldf3((int)angle1,(int)((ulonglong)angle1 >> 0x20),0,0x40668000);\n  angle1 = __divdf3((int)angle1,(int)((ulonglong)angle1 >> 0x20),0x54442d18,0x400921fb);\n  quotient2 = __truncdfsf2((int)angle1,(int)((ulonglong)angle1 >> 0x20));\n  angle1 = __aeabi_f2d(quotient1);\n  angle2 = __aeabi_f2d(quotient3);\n  angle1 = atan2((int)angle1,(int)((ulonglong)angle1 >> 0x20),(int)angle2,\n                (int)((ulonglong)angle2 >> 0x20));\n  angle1 = __muldf3((int)angle1,(int)((ulonglong)angle1 >> 0x20),0,0x40668000);\n  angle1 = __divdf3((int)angle1,(int)((ulonglong)angle1 >> 0x20),0x54442d18,0x400921fb);\n  quotient1 = __truncdfsf2((int)angle1,(int)((ulonglong)angle1 >> 0x20));\n  *quotientArray1 = quotient2;\n  *quotientArray2 = quotient1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_angle_08004d78",
                "param_1": "dividendArray",
                "param_2": "quotientArray1",
                "param_3": "quotientArray2",
                "uVar1": "quotient1",
                "uVar2": "quotient2",
                "uVar3": "quotient3",
                "uVar4": "angle1",
                "uVar5": "angle2"
            },
            "calling": [
                "mpu6050_calibrate"
            ],
            "called": [
                "__aeabi_fdiv",
                "__muldf3",
                "__divdf3",
                "__truncdfsf2",
                "atan2",
                "__aeabi_f2d"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "trigger_software_interrupt_08004e6c",
            "code": "\nvoid triggerSoftwareInterrupt_08004e6c(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "trigger_software_interrupt_08004e6c"
            },
            "calling": [
                "startForkserver"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "call_afl_or_zero_08004e74",
            "code": "\nundefined4 call_afl_or_zero_08004e74(undefined4 input)\n\n{\n  undefined4 result;\n  \n  if (DAT_200009f0 == 0) {\n    result = aflCall(1,input,0);\n  }\n  else {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "call_afl_or_zero_08004e74",
                "param_1": "input",
                "uVar1": "result"
            },
            "calling": [
                "main"
            ],
            "called": [
                "aflCall"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "write_i2_c_memory_08004ea4",
            "code": "\nvoid writeI2CMemory_08004ea4(undefined deviceAddress,undefined registerAddress,undefined4 data,undefined2 size)\n\n{\n  HAL_I2C_Mem_Write(&DAT_20000a88,deviceAddress,registerAddress,1,data,size,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "write_i2_c_memory_08004ea4",
                "param_1": "deviceAddress",
                "param_2": "registerAddress",
                "param_3": "data",
                "param_4": "size"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Write"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "read_from_i2_c_08004ee8",
            "code": "\nvoid readFromI2C_08004ee8(undefined deviceAddress,undefined memoryAddress,undefined4 dataSize,undefined2 buffer)\n\n{\n  HAL_I2C_Mem_Read(&DAT_20000a88,deviceAddress,memoryAddress,1,dataSize,buffer,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "read_from_i2_c_08004ee8",
                "param_1": "deviceAddress",
                "param_2": "memoryAddress",
                "param_3": "dataSize",
                "param_4": "buffer"
            },
            "calling": [],
            "called": [
                "HAL_I2C_Mem_Read"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_current_tick_08004f2c",
            "code": "\nundefined4 get_current_tick_08004f2c(void)\n\n{\n  undefined4 current_tick;\n  \n  current_tick = HAL_GetTick();\n  return current_tick;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_current_tick_08004f2c",
                "uVar1": "current_tick"
            },
            "calling": [],
            "called": [
                "HAL_GetTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "transmit_data_08004f3c",
            "code": "\nvoid transmitData_08004f3c(undefined4 dataBuffer,undefined2 dataLength)\n\n{\n  transmitUART(&DAT_20000adc,dataBuffer,dataLength,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "transmit_data_08004f3c",
                "param_1": "dataBuffer",
                "param_2": "dataLength",
                "HAL_UART_Transmit": "transmitUART"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "HAL_UART_Transmit"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_memory_08004f60",
            "code": "\nvoid initializeMemory_08004f60(void)\n\n{\n  memset(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_memory_08004f60"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "calculate_and_print_pitch_08004f78",
            "code": "\nvoid calculateAndPrintPitch_08004f78(void)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined4 uVar3;\n  uint uVar4;\n  undefined8 uVar5;\n  byte pitchValue;\n  \n  mpu6050_update(&DAT_20000a5c);\n  mpu6050_calc_pitch(&DAT_20000a5c,&DAT_20000ba0);\n  flush_strbuf();\n  uVar5 = __aeabi_f2d(DAT_20000ba0);\n  sprintf(&DAT_20000ba8,\"Pitch: %f\\n\",(int)uVar5,(int)((ulonglong)uVar5 >> 0x20));\n  uVar1 = strlen(&DAT_20000ba8);\n  uart_print(&DAT_20000ba8,uVar1);\n  DAT_200009f8 = __aeabi_fsub(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = __aeabi_fmul(DAT_20000a00,DAT_200009f8);\n  uVar1 = __aeabi_fmul(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = __addsf3(uVar1,DAT_20000b5c);\n  uVar1 = __floatsisf(DAT_20000010);\n  iVar2 = __aeabi_fcmplt(uVar1,DAT_20000b5c);\n  if (iVar2 == 0) {\n    uVar1 = __floatsisf(DAT_200009f4);\n    iVar2 = __aeabi_fcmpgt(uVar1,DAT_20000b5c);\n    if (iVar2 != 0) {\n      DAT_20000b5c = __floatunsisf(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = __floatunsisf(DAT_20000010);\n  }\n  uVar4 = DAT_20000a08 ^ 0x80000000;\n  uVar1 = __aeabi_fsub(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = __aeabi_fmul(uVar4,uVar1);\n  uVar1 = __addsf3(DAT_20000be8,DAT_20000b5c);\n  uVar1 = __addsf3(uVar1,DAT_20000a58);\n  uVar3 = __floatsisf(DAT_20000010);\n  iVar2 = __aeabi_fcmpgt(uVar1,uVar3);\n  if (iVar2 == 0) {\n    uVar3 = __floatsisf(DAT_200009f4);\n    iVar2 = __aeabi_fcmplt(uVar1,uVar3);\n    if (iVar2 == 0) {\n      pitchValue = __fixunssfsi(uVar1);\n    }\n    else {\n      pitchValue = DAT_200009f4;\n    }\n  }\n  else {\n    pitchValue = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  iVar2 = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,2,iVar2 != 0);\n  iVar2 = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,4,iVar2 == 0);\n  iVar2 = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,8,iVar2 != 0);\n  iVar2 = __aeabi_fcmpgt(DAT_200009f8,0);\n  HAL_GPIO_WritePin(0x40010800,0x10,iVar2 == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)pitchValue;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)pitchValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "calculate_and_print_pitch_08004f78",
                "local_11": "pitchValue"
            },
            "calling": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_TIM_IRQHandler"
            ],
            "called": [
                "__aeabi_fsub",
                "__aeabi_fmul",
                "HAL_GPIO_WritePin",
                "__aeabi_fcmpgt",
                "__floatunsisf",
                "flush_strbuf",
                "mpu6050_calc_pitch",
                "__aeabi_f2d",
                "__fixunssfsi",
                "__aeabi_fcmplt",
                "sprintf",
                "__addsf3",
                "mpu6050_update",
                "strlen",
                "uart_print",
                "__floatsisf"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\nvoid initializeSystem_08005224(void)\n\n{\n  initializeHardware();\n  configureSystemClock();\n  initializeGPIO();\n  initializeI2C1();\n  initializeUART1();\n  initializeTIM2();\n  initializeTIM1();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  startPWM(&DAT_20000b1c,0);\n  startPWM(&DAT_20000b1c,0xc);\n  initializeMPU6050(&DAT_20000a5c);\n  startBaseTimerInterrupt(&DAT_20000b60);\n  startForkServer(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "HAL_Init": "initializeHardware",
                "SystemClock_Config": "configureSystemClock",
                "MX_GPIO_Init": "initializeGPIO",
                "MX_I2C1_Init": "initializeI2C1",
                "MX_USART1_UART_Init": "initializeUART1",
                "MX_TIM2_Init": "initializeTIM2",
                "MX_TIM1_Init": "initializeTIM1",
                "HAL_TIM_PWM_Start": "startPWM",
                "mpu6050_init": "initializeMPU6050",
                "HAL_TIM_Base_Start_IT": "startBaseTimerInterrupt",
                "startForkserver": "startForkServer"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "startForkserver",
                "MX_USART1_UART_Init",
                "MX_TIM1_Init",
                "MX_GPIO_Init",
                "mpu6050_init",
                "HAL_TIM_Base_Start_IT",
                "MX_I2C1_Init",
                "HAL_Init",
                "HAL_TIM_PWM_Start",
                "MX_TIM2_Init",
                "SystemClock_Config"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_system_080052a0",
            "code": "\nvoid initializeSystem_080052a0(void)\n\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined4 oscillatorConfig;\n  undefined4 clockSource;\n  undefined4 PLLSource;\n  undefined4 pllState;\n  undefined4 ahiState;\n  undefined4 lSiFrequency;\n  undefined4 hSiFrequency;\n  undefined4 lSiState;\n  undefined4 hseState;\n  undefined4 msiState;\n  undefined4 hSeFrequency;\n  undefined4 pLlFrequency;\n  \n  lSiFrequency = 1;\n  hSiFrequency = 0x10000;\n  lSiState = 0;\n  hseState = 1;\n  msiState = 2;\n  hSeFrequency = 0x10000;\n  pLlFrequency = 0x1c0000;\n  iVar1 = HAL_RCC_OscConfig(&lSiFrequency);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x151);\n  }\n  oscillatorConfig = 0xf;\n  clockSource = 2;\n  PLLSource = 0x80;\n  pllState = 0;\n  ahiState = 0;\n  iVar1 = HAL_RCC_ClockConfig(&oscillatorConfig,2);\n  if (iVar1 != 0) {\n    _Error_Handler(\"../src/main.c\",0x15e);\n  }\n  uVar2 = HAL_RCC_GetHCLKFreq();\n  HAL_SYSTICK_Config((uint)uVar2 / 1000,(int)((ulonglong)uVar2 >> 0x20),(uint)uVar2 * 0x10624dd3);\n  HAL_SYSTICK_CLKSourceConfig(4);\n  HAL_NVIC_SetPriority(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_system_080052a0",
                "local_44": "oscillatorConfig",
                "local_40": "clockSource",
                "local_3c": "PLLSource",
                "local_38": "pllState",
                "local_34": "ahiState",
                "local_30": "lSiFrequency",
                "local_2c": "hSiFrequency",
                "local_28": "lSiState",
                "local_20": "hseState",
                "local_14": "msiState",
                "local_10": "hSeFrequency",
                "local_c": "pLlFrequency"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_RCC_GetHCLKFreq",
                "_Error_Handler",
                "HAL_NVIC_SetPriority",
                "HAL_RCC_ClockConfig",
                "HAL_SYSTICK_CLKSourceConfig",
                "HAL_SYSTICK_Config",
                "HAL_RCC_OscConfig"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_i2_c_08005348",
            "code": "\nvoid initializeI2C_08005348(void)\n\n{\n  int initResult;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  initResult = HAL_I2C_Init(&DAT_20000a88);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_i2_c_08005348",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_I2C_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_timers_080053b0",
            "code": "\nvoid initializeTimers_080053b0(void)\n\n{\n  int result;\n  undefined4 breakDeadTime;\n  undefined4 localVar1;\n  undefined4 localVar2;\n  undefined4 localVar3;\n  undefined4 localVar4;\n  undefined4 localVar5;\n  undefined4 localVar6;\n  undefined4 pwmConfig;\n  undefined4 localVar7;\n  undefined4 localVar8;\n  undefined4 localVar9;\n  undefined4 localVar10;\n  undefined4 localVar11;\n  undefined4 localVar12;\n  undefined4 localVar13;\n  undefined4 localVar14;\n  undefined4 localArray [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  result = HAL_TIM_Base_Init(&DAT_20000b1c);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",399);\n  }\n  localArray[0] = 0x1000;\n  result = HAL_TIM_ConfigClockSource(&DAT_20000b1c,localArray);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x194);\n  }\n  result = HAL_TIM_PWM_Init(&DAT_20000b1c);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x198);\n  }\n  localVar13 = 0;\n  localVar14 = 0;\n  result = HAL_TIMEx_MasterConfigSynchronization(&DAT_20000b1c,&localVar13);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x19f);\n  }\n  pwmConfig = 0x60;\n  localVar7 = 0;\n  localVar8 = 0;\n  localVar9 = 0;\n  localVar10 = 0;\n  localVar11 = 0;\n  localVar12 = 0;\n  result = HAL_TIM_PWM_ConfigChannel(&DAT_20000b1c,&pwmConfig,0);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x1ab);\n  }\n  result = HAL_TIM_PWM_ConfigChannel(&DAT_20000b1c,&pwmConfig,0xc);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x1b0);\n  }\n  breakDeadTime = 0;\n  localVar1 = 0;\n  localVar2 = 0;\n  localVar3 = 0;\n  localVar4 = 0;\n  localVar5 = 0x2000;\n  localVar6 = 0;\n  result = HAL_TIMEx_ConfigBreakDeadTime(&DAT_20000b1c,&breakDeadTime);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x1bc);\n  }\n  HAL_TIM_MspPostInit(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_timers_080053b0",
                "iVar1": "result",
                "local_58": "breakDeadTime",
                "local_54": "localVar1",
                "local_50": "localVar2",
                "local_4c": "localVar3",
                "local_48": "localVar4",
                "local_44": "localVar5",
                "local_40": "localVar6",
                "local_3c": "pwmConfig",
                "local_38": "localVar7",
                "local_34": "localVar8",
                "local_30": "localVar9",
                "local_2c": "localVar10",
                "local_28": "localVar11",
                "local_24": "localVar12",
                "local_20": "localVar13",
                "local_1c": "localVar14",
                "local_18": "localArray"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIM_PWM_Init",
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIM_Base_Init",
                "HAL_TIMEx_ConfigBreakDeadTime",
                "HAL_TIM_PWM_ConfigChannel",
                "HAL_TIM_MspPostInit",
                "HAL_TIMEx_MasterConfigSynchronization"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_timer_08005500",
            "code": "\nvoid initializeTimer_08005500(void)\n\n{\n  int result;\n  undefined4 clockDivision;\n  undefined4 synchronization;\n  undefined4 clockSource [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  result = HAL_TIM_Base_Init(&DAT_20000b60);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x1d0);\n  }\n  clockSource[0] = 0x1000;\n  result = HAL_TIM_ConfigClockSource(&DAT_20000b60,clockSource);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x1d5);\n  }\n  clockDivision = 0x20;\n  synchronization = 0;\n  result = HAL_TIMEx_MasterConfigSynchronization(&DAT_20000b60,&clockDivision);\n  if (result != 0) {\n    _Error_Handler(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_timer_08005500",
                "iVar1": "result",
                "local_20": "clockDivision",
                "local_1c": "synchronization",
                "local_18": "clockSource"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_TIM_ConfigClockSource",
                "_Error_Handler",
                "HAL_TIM_Base_Init",
                "HAL_TIMEx_MasterConfigSynchronization"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_uart_08005598",
            "code": "\nvoid initializeUART_08005598(void)\n\n{\n  int initResult;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  initResult = HAL_UART_Init(&DAT_20000adc);\n  if (initResult != 0) {\n    _Error_Handler(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_uart_08005598",
                "iVar1": "initResult"
            },
            "calling": [
                "main"
            ],
            "called": [
                "_Error_Handler",
                "HAL_UART_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "initialize_gpio_080055f4",
            "code": "\n\n\nvoid initializeGPIO_080055f4(void)\n\n{\n  undefined4 pin;\n  undefined4 state;\n  undefined4 mode;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  HAL_GPIO_WritePin(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  pin = 0x1e;\n  state = 1;\n  mode = 2;\n  HAL_GPIO_Init(0x40010800,&pin);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "initialize_gpio_080055f4",
                "local_18": "pin",
                "local_14": "state",
                "local_c": "mode"
            },
            "calling": [
                "main"
            ],
            "called": [
                "HAL_GPIO_Init",
                "HAL_GPIO_WritePin"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "infinite_loop_08005674",
            "code": "\nvoid infiniteLoop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "infinite_loop_08005674"
            },
            "calling": [
                "MX_USART1_UART_Init",
                "MX_TIM1_Init",
                "MX_I2C1_Init",
                "SystemClock_Config",
                "MX_TIM2_Init"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "initialize_gpio_08005680",
            "code": "\nvoid initializeGPIO_08005680(int *gpioAddress)\n\n{\n  undefined4 gpioMode;\n  undefined4 variable1;\n  undefined4 variable2;\n  \n  if (*gpioAddress == 0x40012c00) {\n    gpioMode = 0x900;\n    variable1 = 2;\n    variable2 = 2;\n    HAL_GPIO_Init(0x40010800,&gpioMode);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "initialize_gpio_08005680",
                "param_1": "gpioAddress",
                "local_18": "gpioMode",
                "local_14": "variable1",
                "local_c": "variable2"
            },
            "calling": [
                "MX_TIM1_Init"
            ],
            "called": [
                "HAL_GPIO_Init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "handle_system_tick_08005704",
            "code": "\nvoid handleSystemTick_08005704(void)\n\n{\n  incrementSystemTick();\n  handleSysTickInterrupt();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "handle_system_tick_08005704",
                "HAL_IncTick": "incrementSystemTick",
                "HAL_SYSTICK_IRQHandler": "handleSysTickInterrupt"
            },
            "calling": [],
            "called": [
                "HAL_SYSTICK_IRQHandler",
                "HAL_IncTick"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "handle_tim_interrupt_08005714",
            "code": "\nvoid handle_TIM_interrupt_08005714(void)\n\n{\n  HAL_TIM_IRQHandler(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "handle_tim_interrupt_08005714"
            },
            "calling": [],
            "called": [
                "HAL_TIM_IRQHandler"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nundefined * allocateMemory_08005728(int size)\n\n{\n  undefined4 *errnoPtr;\n  undefined *allocatedMemory;\n  undefined tempMemory [4];\n  int requestedSize;\n  undefined *memoryBlock;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  memoryBlock = DAT_20000a10;\n  if (tempMemory < DAT_20000a10 + size) {\n    requestedSize = size;\n    errnoPtr = (undefined4 *)__errno();\n    *errnoPtr = 0xc;\n    allocatedMemory = (undefined *)0xffffffff;\n  }\n  else {\n    allocatedMemory = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + size;\n  }\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "param_1": "size",
                "puVar1": "errnoPtr",
                "puVar2": "allocatedMemory",
                "auStack_18": "tempMemory",
                "local_14": "requestedSize",
                "local_c": "memoryBlock"
            },
            "calling": [
                "_sbrk_r"
            ],
            "called": [
                "__errno"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_hardware_08005780",
            "code": "\n\n\nvoid initializeHardware_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_hardware_08005780"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080057e8": {
            "entrypoint": "0x080057e8",
            "current_name": "initialize_data_080057e8",
            "code": "\nvoid initializeData_080057e8(void)\n\n{\n  int index;\n  undefined4 *ptr;\n  code *jumptable;\n  \n  for (index = 0; (undefined4 *)(index + 0x20000000) < &DAT_200009c8; index = index + 4) {\n    *(undefined4 *)(index + 0x20000000) = *(undefined4 *)(index + 0x800a1a4);\n  }\n  for (ptr = &DAT_200009c8; ptr < &DAT_20000c14; ptr = ptr + 1) {\n    *ptr = 0;\n  }\n  SystemInit();\n  __libc_init_array();\n  jumptable = (code *)0x800581a;\n  main();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumptable)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_080057e8": "initialize_data_080057e8",
                "iVar1": "index",
                "puVar2": "ptr",
                "UNRECOVERED_JUMPTABLE": "jumptable"
            },
            "calling": [],
            "called": [
                "__libc_init_array",
                "SystemInit",
                "main"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005834": {
            "entrypoint": "0x08005834",
            "current_name": "FUN_08005834",
            "code": "\nuint __ieee754_atan2(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  int iVar1;\n  undefined4 uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  undefined8 uVar6;\n  \n  uVar4 = param_4 & 0x7fffffff;\n  if ((0x7ff00000 < (uVar4 | (-param_3 | param_3) >> 0x1f)) ||\n     (uVar5 = param_2 & 0x7fffffff, 0x7ff00000 < (uVar5 | (-param_1 | param_1) >> 0x1f))) {\n    uVar4 = __aeabi_dadd(param_3,param_4,param_1,param_2);\n    return uVar4;\n  }\n  if ((param_4 + 0xc0100000 | param_3) == 0) {\n    uVar4 = atan();\n    return uVar4;\n  }\n  uVar3 = (int)param_4 >> 0x1e & 2U | param_2 >> 0x1f;\n  if ((uVar5 | param_1) == 0) {\n    if (uVar3 == 2) {\n      return 0x54442d18;\n    }\n    if (uVar3 != 3) {\n      return param_1;\n    }\n  }\n  else if ((uVar4 | param_3) != 0) {\n    if (uVar4 == 0x7ff00000) {\n      if (uVar5 == 0x7ff00000) {\n        if (uVar3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (uVar3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (uVar3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (uVar3 == 2) {\n        return 0x54442d18;\n      }\n      if (uVar3 != 3) {\n        if (uVar3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (uVar5 != 0x7ff00000) {\n      iVar1 = (int)(uVar5 - uVar4) >> 0x14;\n      if (iVar1 < 0x3d) {\n        if (((int)param_4 < 0) && (iVar1 + 0x3c < 0 != SCARRY4(iVar1,0x3c))) {\n          uVar6 = 0;\n        }\n        else {\n          __divdf3(param_1,param_2,param_3,param_4,param_4);\n          fabs();\n          uVar6 = atan();\n        }\n      }\n      else {\n        uVar6 = 0x3ff921fb54442d18;\n      }\n      uVar2 = (undefined4)((ulonglong)uVar6 >> 0x20);\n      uVar4 = (uint)uVar6;\n      if (uVar3 == 1) {\n        return uVar4;\n      }\n      if (uVar3 == 2) {\n        uVar6 = __subdf3(uVar4,uVar2,0x33145c07,0x3ca1a626);\n        uVar4 = __subdf3(0x54442d18,0x400921fb,(int)uVar6,(int)((ulonglong)uVar6 >> 0x20));\n        return uVar4;\n      }\n      if (uVar3 != 0) {\n        uVar6 = __subdf3(uVar4,uVar2,0x33145c07,0x3ca1a626);\n        uVar4 = __subdf3((int)uVar6,(int)((ulonglong)uVar6 >> 0x20),0x54442d18,0x400921fb);\n        return uVar4;\n      }\n      return uVar4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {},
            "calling": [
                "mpu6050_calc_pitch",
                "mpu6050_calc_acc_pitch_roll"
            ],
            "called": [
                "__ieee754_atan2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "calculate_arc_tangent_08005838",
            "code": "\nuint calculateArcTangent_08005838(uint angle1,uint angle2,uint param1,uint param2)\n\n{\n  int angleDifference;\n  undefined4 result1;\n  uint conditionFlag;\n  uint param2_positive;\n  uint param1_positive;\n  undefined8 result2;\n  \n  param2_positive = param2 & 0x7fffffff;\n  if ((0x7ff00000 < (param2_positive | (-param1 | param1) >> 0x1f)) ||\n     (param1_positive = angle2 & 0x7fffffff, 0x7ff00000 < (param1_positive | (-angle1 | angle1) >> 0x1f))) {\n    param2_positive = __aeabi_dadd(param1,param2,angle1,angle2);\n    return param2_positive;\n  }\n  if ((param2 + 0xc0100000 | param1) == 0) {\n    param2_positive = atan();\n    return param2_positive;\n  }\n  conditionFlag = (int)param2 >> 0x1e & 2U | angle2 >> 0x1f;\n  if ((param1_positive | angle1) == 0) {\n    if (conditionFlag == 2) {\n      return 0x54442d18;\n    }\n    if (conditionFlag != 3) {\n      return angle1;\n    }\n  }\n  else if ((param2_positive | param1) != 0) {\n    if (param2_positive == 0x7ff00000) {\n      if (param1_positive == 0x7ff00000) {\n        if (conditionFlag == 2) {\n          return 0x7f3321d2;\n        }\n        if (conditionFlag == 3) {\n          return 0x7f3321d2;\n        }\n        if (conditionFlag == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (conditionFlag == 2) {\n        return 0x54442d18;\n      }\n      if (conditionFlag != 3) {\n        if (conditionFlag != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (param1_positive != 0x7ff00000) {\n      angleDifference = (int)(param1_positive - param2_positive) >> 0x14;\n      if (angleDifference < 0x3d) {\n        if (((int)param2 < 0) && (angleDifference + 0x3c < 0 != SCARRY4(angleDifference,0x3c))) {\n          result2 = 0;\n        }\n        else {\n          __divdf3(angle1,angle2,param1,param2,param2);\n          fabs();\n          result2 = atan();\n        }\n      }\n      else {\n        result2 = 0x3ff921fb54442d18;\n      }\n      result1 = (undefined4)((ulonglong)result2 >> 0x20);\n      param2_positive = (uint)result2;\n      if (conditionFlag == 1) {\n        return param2_positive;\n      }\n      if (conditionFlag == 2) {\n        result2 = __subdf3(param2_positive,result1,0x33145c07,0x3ca1a626);\n        param2_positive = __subdf3(0x54442d18,0x400921fb,(int)result2,(int)((ulonglong)result2 >> 0x20));\n        return param2_positive;\n      }\n      if (conditionFlag != 0) {\n        result2 = __subdf3(param2_positive,result1,0x33145c07,0x3ca1a626);\n        param2_positive = __subdf3((int)result2,(int)((ulonglong)result2 >> 0x20),0x54442d18,0x400921fb);\n        return param2_positive;\n      }\n      return param2_positive;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "calculate_arc_tangent_08005838",
                "param_1": "angle1",
                "param_2": "angle2",
                "param_3": "param1",
                "param_4": "param2",
                "iVar1": "angleDifference",
                "uVar2": "result1",
                "uVar3": "conditionFlag",
                "uVar4": "param2_positive",
                "uVar5": "param1_positive",
                "uVar6": "result2"
            },
            "calling": [
                "atan2"
            ],
            "called": [
                "__aeabi_dadd",
                "atan",
                "__divdf3",
                "fabs",
                "__subdf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_something_080059f0",
            "code": "\nundefined8 calculate_something_080059f0(int value1,uint value2,undefined4 value3,undefined4 value4)\n\n{\n  undefined4 result1;\n  undefined4 result2;\n  undefined4 result3;\n  undefined4 result4;\n  undefined4 result5;\n  undefined4 result6;\n  uint abs_param_2;\n  int comparison_result;\n  undefined8 final_result;\n  undefined8 operand;\n  \n  operand = CONCAT44(value2,value1);\n  abs_param_2 = value2 & 0x7fffffff;\n  if (abs_param_2 < 0x44100000) {\n    if (abs_param_2 < 0x3fdc0000) {\n      if (abs_param_2 < 0x3e200000) {\n        final_result = add_double(value1,value2,0x8800759c,0x7e37e43c,value4);\n        comparison_result = compare_double((int)final_result,(int)((ulonglong)final_result >> 0x20),0,0x3ff00000);\n        if (comparison_result != 0) {\n          return CONCAT44(value2,value1);\n        }\n      }\n      comparison_result = -1;\n    }\n    else {\n      operand = absolute_value;\n      result4 = (undefined4)((ulonglong)operand >> 0x20);\n      result1 = (undefined4)operand;\n      if (abs_param_2 < 0x3ff30000) {\n        if (abs_param_2 < 0x3fe60000) {\n          operand = add_double(result1,result4,result1,result4);\n          operand = subtract_double((int)operand,(int)((ulonglong)operand >> 0x20),0,0x3ff00000);\n          final_result = add_double(result1,result4,0,0x40000000);\n          operand = divide_double((int)operand,(int)((ulonglong)operand >> 0x20),(int)final_result,\n                            (int)((ulonglong)final_result >> 0x20));\n          comparison_result = 0;\n        }\n        else {\n          operand = subtract_double(result1,result4,0,0x3ff00000);\n          final_result = add_double(result1,result4,0,0x3ff00000);\n          operand = divide_double((int)operand,(int)((ulonglong)operand >> 0x20),(int)final_result,\n                            (int)((ulonglong)final_result >> 0x20));\n          comparison_result = 1;\n        }\n      }\n      else if (abs_param_2 < 0x40038000) {\n        operand = subtract_double(result1,result4,0,0x3ff80000);\n        final_result = multiply_double(result1,result4,0,0x3ff80000);\n        final_result = add_double((int)final_result,(int)((ulonglong)final_result >> 0x20),0,0x3ff00000);\n        operand = divide_double((int)operand,(int)((ulonglong)operand >> 0x20),(int)final_result,\n                          (int)((ulonglong)final_result >> 0x20));\n        comparison_result = 2;\n      }\n      else {\n        operand = divide_double(0,0xbff00000,result1,result4);\n        comparison_result = 3;\n      }\n    }\n    result6 = (undefined4)((ulonglong)operand >> 0x20);\n    result5 = (undefined4)operand;\n    operand = multiply_double(result5,result6,result5,result6);\n    result2 = (undefined4)((ulonglong)operand >> 0x20);\n    result1 = (undefined4)operand;\n    operand = multiply_double(result1,result2,result1,result2);\n    result3 = (undefined4)((ulonglong)operand >> 0x20);\n    result4 = (undefined4)operand;\n    operand = multiply_double(result4,result3,0xe322da11,0x3f90ad3a);\n    operand = add_double((int)operand,(int)((ulonglong)operand >> 0x20),0x24760deb,0x3fa97b4b);\n    operand = multiply_double((int)operand,(int)((ulonglong)operand >> 0x20),result4,result3);\n    operand = add_double((int)operand,(int)((ulonglong)operand >> 0x20),0xa0d03d51,0x3fb10d66);\n    operand = multiply_double((int)operand,(int)((ulonglong)operand >> 0x20),result4,result3);\n    operand = add_double((int)operand,(int)((ulonglong)operand >> 0x20),0xc54c206e,0x3fb745cd);\n    operand = multiply_double((int)operand,(int)((ulonglong)operand >> 0x20),result4,result3);\n    operand = add_double((int)operand,(int)((ulonglong)operand >> 0x20),0x920083ff,0x3fc24924);\n    operand = multiply_double((int)operand,(int)((ulonglong)operand >> 0x20),result4,result3);\n    operand = add_double((int)operand,(int)((ulonglong)operand >> 0x20),0x5555550d,0x3fd55555);\n    operand = multiply_double((int)operand,(int)((ulonglong)operand >> 0x20),result1,result2);\n    final_result = multiply_double(result4,result3,0x2c6a6c2f,0xbfa2b444);\n    final_result = subtract_double((int)final_result,(int)((ulonglong)final_result >> 0x20),0x52defd9a,0x3fadde2d);\n    final_result = multiply_double((int)final_result,(int)((ulonglong)final_result >> 0x20),result4,result3);\n    final_result = subtract_double((int)final_result,(int)((ulonglong)final_result >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    final_result = multiply_double((int)final_result,(int)((ulonglong)final_result >> 0x20),result4,result3);\n    final_result = subtract_double((int)final_result,(int)((ulonglong)final_result >> 0x20),0xfe231671,0x3fbc71c6);\n    final_result = multiply_double((int)final_result,(int)((ulonglong)final_result >> 0x20),result4,result3);\n    final_result = subtract_double((int)final_result,(int)((ulonglong)final_result >> 0x20),0x9998ebc4,0x3fc99999);\n    final_result = multiply_double((int)final_result,(int)((ulonglong)final_result >> 0x20),result4,result3);\n    operand = add_double((int)operand,(int)((ulonglong)operand >> 0x20),(int)final_result,\n                          (int)((ulonglong)final_result >> 0x20));\n    operand = multiply_double((int)operand,(int)((ulonglong)operand >> 0x20),result5,result6);\n    result1 = (undefined4)((ulonglong)operand >> 0x20);\n    if (comparison_result == -1) {\n      operand = subtract_double(result5,result6,(int)operand,result1);\n      return operand;\n    }\n    comparison_result = comparison_result * 8;\n    operand = subtract_double((int)operand,result1,*(undefined4 *)(&UNK_08009ee8 + comparison_result),\n                      *(undefined4 *)(&UNK_08009eec + comparison_result));\n    operand = subtract_double((int)operand,(int)((ulonglong)operand >> 0x20),result5,result6);\n    operand = subtract_double(*(undefined4 *)(&UNK_08009ec8 + comparison_result),*(undefined4 *)(&UNK_08009ecc + comparison_result),\n                      (int)operand,(int)((ulonglong)operand >> 0x20));\n    if ((int)value2 < 0) {\n      return CONCAT44((int)((ulonglong)operand >> 0x20) + -0x80000000,(int)operand);\n    }\n  }\n  else {\n    if ((abs_param_2 < 0x7ff00001) && ((abs_param_2 != 0x7ff00000 || (value1 == 0)))) {\n      result1 = 0xbff921fb;\n      if (0 < (int)value2) {\n        result1 = 0x3ff921fb;\n      }\n      return CONCAT44(result1,0x54442d18);\n    }\n    operand = add_double(value1,value2,value1,value2,value4);\n  }\n  return operand;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_something_080059f0",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "result1",
                "uVar2": "result2",
                "uVar3": "result3",
                "uVar4": "result4",
                "uVar5": "result5",
                "uVar6": "result6",
                "uVar7": "abs_param_2",
                "iVar8": "comparison_result",
                "uVar9": "final_result",
                "uVar10": "operand",
                "__aeabi_dadd": "add_double",
                "__aeabi_dcmpgt": "compare_double",
                "fabs()": "absolute_value",
                "__subdf3": "subtract_double",
                "__divdf3": "divide_double",
                "__muldf3": "multiply_double"
            },
            "calling": [
                "__ieee754_atan2"
            ],
            "called": [
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "fabs",
                "__subdf3",
                "__aeabi_dcmpgt"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "atan",
                "__ieee754_atan2"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_data_08005d14",
            "code": "\nundefined4 get_data_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_data_08005d14"
            },
            "calling": [
                "_sbrk"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "initialize_and_execute_functions_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid initializeAndExecuteFunctions_08005d20(void)\n\n{\n  int counter;\n  code **functionPointer;\n  \n  initialize();\n  counter = 0;\n  functionPointer = (code **)&DAT_0800a198;\n  do {\n    counter = counter + 1;\n    (**functionPointer)();\n    functionPointer = functionPointer + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "initialize_and_execute_functions_08005d20",
                "iVar1": "counter",
                "ppcVar2": "functionPointer",
                "_init": "initialize"
            },
            "calling": [
                "Reset_Handler"
            ],
            "called": [
                "register_fini",
                "frame_dummy",
                "_init"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "fill_memory_with_byte_08005d68",
            "code": "\nvoid fillMemoryWithByte_08005d68(undefined4 *destination,undefined value,uint size)\n\n{\n  undefined4 *destPointer;\n  undefined4 *nextDestPointer;\n  uint remainingSize;\n  undefined4 bytePattern;\n  bool isEndOfSize;\n  \n  if (((uint)destination & 3) != 0) {\n    remainingSize = size - 1;\n    destPointer = destination;\n    if (size == 0) {\n      return;\n    }\n    while( true ) {\n      destination = (undefined4 *)((int)destPointer + 1);\n      *(undefined *)destPointer = value;\n      size = remainingSize;\n      if (((uint)destination & 3) == 0) break;\n      isEndOfSize = remainingSize == 0;\n      remainingSize = remainingSize - 1;\n      destPointer = destination;\n      if (isEndOfSize) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    bytePattern = CONCAT22(CONCAT11(value,value),CONCAT11(value,value));\n    remainingSize = size;\n    destPointer = destination;\n    if (0xf < size) {\n      remainingSize = size - 0x10;\n      destPointer = destination + 4;\n      do {\n        destPointer[-4] = bytePattern;\n        destPointer[-3] = bytePattern;\n        destPointer[-2] = bytePattern;\n        destPointer[-1] = bytePattern;\n        destPointer = destPointer + 4;\n      } while (destPointer != (undefined4 *)((int)destination + (remainingSize & 0xfffffff0) + 0x20));\n      size = size & 0xf;\n      destination = destination + ((remainingSize >> 4) + 1) * 4;\n      remainingSize = size;\n      destPointer = destination;\n      if (size < 4) goto LAB_08005de4;\n    }\n    do {\n      size = size - 4;\n      *destination = bytePattern;\n      destination = destination + 1;\n    } while (3 < size);\n    destination = (undefined4 *)((int)destPointer + (remainingSize - 4 & 0xfffffffc) + 4);\n    size = remainingSize & 3;\n  }\nLAB_08005de4:\n  if (size != 0) {\n    destPointer = destination;\n    do {\n      nextDestPointer = (undefined4 *)((int)destPointer + 1);\n      *(undefined *)destPointer = value;\n      destPointer = nextDestPointer;\n    } while ((undefined4 *)(size + (int)destination) != nextDestPointer);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "fill_memory_with_byte_08005d68",
                "param_1": "destination",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "destPointer",
                "puVar2": "nextDestPointer",
                "uVar3": "remainingSize",
                "uVar4": "bytePattern",
                "bVar5": "isEndOfSize"
            },
            "calling": [
                "_calloc_r",
                "flush_strbuf"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "print_error_message_08005dfc",
            "code": "\nvoid printErrorMessage_08005dfc(undefined *errorMessage,undefined4 buffSize,undefined4 format,undefined4 args)\n\n{\n  undefined *buffer [2];\n  undefined4 maxBuffSize;\n  undefined4 constantValue;\n  undefined *currentBuffPtr;\n  undefined4 maxValue;\n  undefined4 formatPtr;\n  undefined4 argsPtr;\n  \n  maxValue = 0x7fffffff;\n  maxBuffSize = 0x7fffffff;\n  constantValue = 0xffff0208;\n  buffer[0] = errorMessage;\n  currentBuffPtr = errorMessage;\n  formatPtr = format;\n  argsPtr = args;\n  _svfprintf_r(DAT_2000001c,buffer,buffSize,&formatPtr);\n  *buffer[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "print_error_message_08005dfc",
                "param_1": "errorMessage",
                "param_2": "buffSize",
                "param_3": "format",
                "param_4": "args",
                "local_80": "buffer",
                "local_78": "maxBuffSize",
                "uStack_74": "constantValue",
                "local_70": "currentBuffPtr",
                "local_6c": "maxValue",
                "uStack_8": "formatPtr",
                "uStack_4": "argsPtr"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback"
            ],
            "called": [
                "_svfprintf_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "calculate_lz_count_08005e40",
            "code": "\nint calculateLZCount_08005e40(uint inputValue)\n\n{\n  int negativeOffset;\n  uint *dataPointer;\n  uint variableU;\n  \n  dataPointer = (uint *)(inputValue & 0xfffffffc);\n  negativeOffset = -(inputValue & 3);\n  variableU = *dataPointer;\n  if ((inputValue & 3) != 0) {\n    variableU = variableU | 0xffffffffU >> ((negativeOffset + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    dataPointer = dataPointer + 1;\n    variableU = variableU + 0xfefefeff & ~variableU & 0x80808080;\n    if (variableU != 0) break;\n    variableU = *dataPointer;\n    negativeOffset = negativeOffset + 4;\n  }\n  return negativeOffset + (0x1fU - LZCOUNT(variableU & -variableU) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "calculate_lz_count_08005e40",
                "param_1": "inputValue",
                "iVar1": "negativeOffset",
                "puVar2": "dataPointer",
                "uVar3": "variableU"
            },
            "calling": [
                "HAL_TIM_PeriodElapsedCallback",
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)_localeconv_r();\n  local_114 = *ppiVar2;\n  local_118 = (int *)strlen(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = _malloc_r(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = _localeconv_r(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)strlen(local_110);\n      local_104 = piVar24;\n      iVar3 = _localeconv_r(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = __unorddf2(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) &&\n         (iVar3 = __aeabi_dcmple(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)) {\n        iVar3 = __aeabi_dcmplt(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = __unorddf2(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)_malloc_r(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = frexp(local_128,uVar19,&local_f0);\n          local_150 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = __aeabi_dcmpeq((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                                 local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = frexp(local_128,uVar19,&local_f0);\n          local_150 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = __aeabi_dcmpeq((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                                 local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = __aeabi_dcmpeq(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)_dtoa_r(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = __aeabi_dcmpeq(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)strlen(piVar23);\n        }\n        else {\n          iVar3 = memchr(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        __aeabi_uldivmod(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          strncpy(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = __aeabi_uldivmod(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    __ssprint_r(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = __aeabi_dcmpeq((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = __muldf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = __aeabi_d2iz();\n    uVar34 = __aeabi_i2d();\n    uVar33 = __subdf3((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                      (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = __aeabi_dcmpgt((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = __aeabi_dcmpeq((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = __ssprint_r(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = __ssprint_r(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = __ssprint_r(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = __aeabi_dcmpeq(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = __aeabi_dcmpeq(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = __ssprint_r(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = __ssprint_r(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = __ssprint_r(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = __ssprint_r(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = __ssprint_r(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = __ssprint_r(local_16c,local_160,&local_d8), iVar3 == 0)) {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      _free_r(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    _free_r(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "sprintf"
            ],
            "called": [
                "__aeabi_dcmplt",
                "__ssprint_r",
                "__aeabi_dcmpgt",
                "__unorddf2",
                "__aeabi_dcmple",
                "__aeabi_dcmpeq",
                "memchr",
                "__muldf3",
                "frexp",
                "_dtoa_r",
                "__aeabi_i2d",
                "_malloc_r",
                "__aeabi_uldivmod",
                "__aeabi_d2iz",
                "__subdf3",
                "strncpy",
                "strlen",
                "_free_r",
                "_localeconv_r"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "__libc_init_array"
            ],
            "called": [
                "__register_exitproc"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_division_080078c0",
            "code": "\nuint calculateDivision_080078c0(int numerator,int denominator)\n\n{\n  uint quotient;\n  uint *numeratorPtr;\n  int temp1;\n  int temp2;\n  int index;\n  uint result;\n  uint *denominatorPtr;\n  uint *numeratorArrayPtr;\n  uint *denominatorArrayPtr;\n  uint carry;\n  uint *denominatorElementPtr;\n  uint *nextDenominatorElementPtr;\n  \n  temp2 = *(int *)(denominator + 0x10);\n  if (*(int *)(numerator + 0x10) < temp2) {\n    return 0;\n  }\n  index = temp2 + -1;\n  denominatorPtr = (uint *)(denominator + 0x14);\n  numeratorArrayPtr = (uint *)(numerator + 0x14);\n  result = numeratorArrayPtr[index] / (denominatorPtr[index] + 1);\n  denominatorArrayPtr = denominatorPtr + index;\n  if (result != 0) {\n    quotient = 0;\n    temp1 = 0;\n    numeratorPtr = numeratorArrayPtr;\n    denominatorElementPtr = denominatorPtr;\n    do {\n      nextDenominatorElementPtr = denominatorElementPtr + 1;\n      quotient = result * (*denominatorElementPtr & 0xffff) + quotient;\n      carry = result * (*denominatorElementPtr >> 0x10) + (quotient >> 0x10);\n      quotient = (temp1 - (quotient & 0xffff)) + (*numeratorPtr & 0xffff);\n      temp1 = ((*numeratorPtr >> 0x10) - (carry & 0xffff)) + ((int)quotient >> 0x10);\n      *numeratorPtr = quotient & 0xffff | temp1 * 0x10000;\n      temp1 = temp1 >> 0x10;\n      quotient = carry >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorElementPtr = nextDenominatorElementPtr;\n    } while (nextDenominatorElementPtr <= denominatorArrayPtr);\n    if (numeratorArrayPtr[index] == 0) {\n      if ((numeratorArrayPtr < numeratorArrayPtr + temp2 + -2) && (numeratorArrayPtr[temp2 + -2] == 0)) {\n        numeratorPtr = numeratorArrayPtr + temp2 + -3;\n        do {\n          index = index + -1;\n          if (numeratorPtr <= numeratorArrayPtr) break;\n          quotient = *numeratorPtr;\n          numeratorPtr = numeratorPtr + -1;\n        } while (quotient == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  temp2 = __mcmp();\n  if (-1 < temp2) {\n    temp2 = 0;\n    result = result + 1;\n    numeratorPtr = numeratorArrayPtr;\n    do {\n      denominatorElementPtr = denominatorPtr + 1;\n      quotient = (temp2 - (*denominatorPtr & 0xffff)) + (*numeratorPtr & 0xffff);\n      temp2 = ((*numeratorPtr >> 0x10) - (*denominatorPtr >> 0x10)) + ((int)quotient >> 0x10);\n      *numeratorPtr = quotient & 0xffff | temp2 * 0x10000;\n      temp2 = temp2 >> 0x10;\n      numeratorPtr = numeratorPtr + 1;\n      denominatorPtr = denominatorElementPtr;\n    } while (denominatorElementPtr <= denominatorArrayPtr);\n    if (numeratorArrayPtr[index] == 0) {\n      if ((numeratorArrayPtr < numeratorArrayPtr + index + -1) && (numeratorArrayPtr[index + -1] == 0)) {\n        denominatorPtr = numeratorArrayPtr + index + -2;\n        do {\n          index = index + -1;\n          if (denominatorPtr <= numeratorArrayPtr) break;\n          quotient = *denominatorPtr;\n          denominatorPtr = denominatorPtr + -1;\n        } while (quotient == 0);\n      }\n      *(int *)(numerator + 0x10) = index;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_division_080078c0",
                "param_1": "numerator",
                "param_2": "denominator",
                "uVar1": "quotient",
                "puVar2": "numeratorPtr",
                "iVar3": "temp1",
                "iVar4": "temp2",
                "iVar5": "index",
                "uVar6": "result",
                "puVar7": "denominatorPtr",
                "puVar8": "numeratorArrayPtr",
                "puVar9": "denominatorArrayPtr",
                "uVar10": "carry",
                "puVar11": "denominatorElementPtr",
                "puVar12": "nextDenominatorElementPtr"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__mcmp"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "format_double_080079e8",
            "code": "\nchar * formatDouble_080079e8(int buffer,undefined4 arg2,uint significand,uint exponent,uint minIntegerDigits,\n                   uint minFractionDigits,int *outIntegerDigits,uint *outIsNegative,char **outFractionDigits)\n\n{\n  bool isInfinity;\n  bool decrementExponent;\n  bool addOne;\n  char digit;\n  byte lessThanOne;\n  undefined4 significandInt;\n  int numLeadingZeros;\n  int numTrailingZeros;\n  int numTrailingDigitsToRemove;\n  char *result;\n  uint isNegative;\n  undefined4 fractionalPart;\n  undefined4 temp;\n  int expDigits;\n  int expCount;\n  undefined4 uVar16;\n  uint uVar17;\n  uint uVar18;\n  int numFractionDigitsToShow;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 uVar23;\n  int adjustedExponent;\n  bool isNegativeExponent;\n  undefined8 temp1;\n  undefined8 temp2;\n  undefined8 temp3;\n  uint temp1;\n  uint absoluteExponent;\n  uint truncatedExponent;\n  int adjustedExponent;\n  uint fractionalPartDigitsToShow;\n  int integerPartDigitsToShow;\n  int numMostSignificantDigitsToRemove;\n  uint isRoundingUp;\n  uint numFractionalDigits;\n  uint numFractionalDigitsWithTrailingZeros;\n  uint numFractionalDigitsWithoutTrailingZeros;\n  uint truncatedFraction;\n  int numUnprocessedDigits;\n  int exponentDigits [2];\n  \n  expDigits = *(int *)(buffer + 0x40);\n  if (expDigits != 0) {\n    uVar18 = *(uint *)(buffer + 0x44);\n    *(uint *)(expDigits + 4) = uVar18;\n    *(int *)(expDigits + 8) = 1 << (uVar18 & 0xff);\n    _Bfree(buffer,expDigits);\n    *(undefined4 *)(buffer + 0x40) = 0;\n  }\n  isNegativeExponent = (int)exponent < 0;\n  uVar18 = exponent;\n  if (isNegativeExponent) {\n    uVar18 = exponent & 0x7fffffff;\n  }\n  *outIsNegative = (uint)isNegativeExponent;\n  absoluteExponent = exponent;\n  if (isNegativeExponent) {\n    absoluteExponent = uVar18;\n  }\n  uVar17 = absoluteExponent;\n  if ((~uVar18 & 0x7ff00000) == 0) {\n    *outIntegerDigits = 9999;\n    if ((significand == 0) && ((uVar18 & 0xfffff) == 0)) {\n      result = \"Infinity\";\n      if (outFractionDigits == (char **)0x0) {\n        return result;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      result = \"NaN\";\n      if (outFractionDigits == (char **)0x0) {\n        return result;\n      }\n      pcVar21 = \"\";\n    }\n    *outFractionDigits = pcVar21;\n    return result;\n  }\n  temp1 = __aeabi_dcmpeq(significand,absoluteExponent,0,0);\n  if ((int)temp1 != 0) {\n    *outIntegerDigits = 1;\n    if (outFractionDigits != (char **)0x0) {\n      *outFractionDigits = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  significandInt = __d2b(buffer,(int)((ulonglong)temp1 >> 0x20),significand,absoluteExponent,exponentDigits,&numUnprocessedDigits);\n  expDigits = numUnprocessedDigits;\n  if (uVar18 >> 0x14 == 0) {\n    numFractionDigitsToShow = exponentDigits[0] + numUnprocessedDigits;\n    expCount = numFractionDigitsToShow + 0x432;\n    if (expCount < 0x21) {\n      uVar18 = significand << (0x20U - expCount & 0xff);\n    }\n    else {\n      uVar18 = significand >> (numFractionDigitsToShow + 0x412U & 0xff) | uVar18 << (0x40U - expCount & 0xff);\n    }\n    temp1 = __floatunsidf(uVar18);\n    numFractionDigitsToShow = numFractionDigitsToShow + -1;\n    isNegativeExponent = true;\n    isNegative = (int)((ulonglong)temp1 >> 0x20) + 0xfe100000;\n    uVar18 = (uint)temp1;\n  }\n  else {\n    numFractionDigitsToShow = (uVar18 >> 0x14) - 0x3ff;\n    isNegative = absoluteExponent & 0xfffff | 0x3ff00000;\n    isNegativeExponent = false;\n    uVar18 = significand;\n  }\n  temp1 = __subdf3(uVar18,isNegative,0,0x3ff80000);\n  temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x636f4361,0x3fd287a7);\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),0x8b60c8b3,0x3fc68a28);\n  temp2 = __aeabi_i2d(numFractionDigitsToShow);\n  temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0x509f79fb,0x3fd34413);\n  temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp2,\n                        (int)((ulonglong)temp2 >> 0x20));\n  temp = (undefined4)((ulonglong)temp1 >> 0x20);\n  truncatedExponent = __aeabi_d2iz();\n  expCount = __aeabi_dcmplt((int)temp1,temp,0,0);\n  if (expCount != 0) {\n    temp2 = __aeabi_i2d(truncatedExponent);\n    expCount = __aeabi_dcmpeq((int)temp2,(int)((ulonglong)temp2 >> 0x20),(int)temp1,temp);\n    if (expCount == 0) {\n      truncatedExponent = truncatedExponent - 1;\n    }\n  }\n  if (truncatedExponent < 0x17) {\n    expCount = __aeabi_dcmpgt(*(undefined4 *)(&DAT_08009fa8 + truncatedExponent * 8),\n                            *(undefined4 *)(&DAT_08009fac + truncatedExponent * 8),significand,absoluteExponent);\n    if (expCount == 0) {\n      decrementExponent = false;\n    }\n    else {\n      truncatedExponent = truncatedExponent - 1;\n      decrementExponent = false;\n    }\n  }\n  else {\n    decrementExponent = true;\n  }\n  expCount = (expDigits - numFractionDigitsToShow) + -1;\n  if (expCount < 0) {\n    adjustedExponent = 1 - (expDigits - numFractionDigitsToShow);\n    expCount = 0;\n  }\n  else {\n    adjustedExponent = 0;\n  }\n  if ((int)truncatedExponent < 0) {\n    isRoundingUp = 0;\n    adjustedExponent = adjustedExponent - truncatedExponent;\n    numMostSignificantDigitsToRemove = -truncatedExponent;\n  }\n  else {\n    expCount = expCount + truncatedExponent;\n    isRoundingUp = truncatedExponent;\n    numMostSignificantDigitsToRemove = 0;\n  }\n  if (9 < minIntegerDigits) {\n    numFractionalDigitsWithoutTrailingZeros = 0xffffffff;\n    isInfinity = true;\n    fractionalPartDigitsToShow = 0xffffffff;\n    addOne = true;\n    minIntegerDigits = 0;\n    minFractionDigits = 0;\n    goto LAB_08007c24;\n  }\n  isInfinity = (int)minIntegerDigits < 6;\n  if (!isInfinity) {\n    minIntegerDigits = minIntegerDigits - 4;\n  }\n  switch(minIntegerDigits) {\n  case 2:\n    addOne = false;\n    break;\n  case 3:\n    addOne = false;\n    goto LAB_08008300;\n  case 4:\n    addOne = true;\n    break;\n  case 5:\n    addOne = true;\nLAB_08008300:\n    numFractionalDigitsWithoutTrailingZeros = truncatedExponent + minFractionDigits;\n    fractionalPartDigitsToShow = numFractionalDigitsWithoutTrailingZeros + 1;\n    uVar18 = fractionalPartDigitsToShow;\n    if ((int)fractionalPartDigitsToShow < 1) {\n      uVar18 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(buffer + 0x44) = 0;\n    result = (char *)_Balloc(buffer,0);\n    numFractionalDigitsWithoutTrailingZeros = 0xffffffff;\n    fractionalPartDigitsToShow = 0xffffffff;\n    minFractionDigits = 0;\n    *(char **)(buffer + 0x40) = result;\n    addOne = true;\n    goto LAB_08007e36;\n  }\n  if ((int)minFractionDigits < 1) {\n    numFractionalDigitsWithoutTrailingZeros = 1;\n    minFractionDigits = 1;\n    fractionalPartDigitsToShow = 1;\nLAB_08007c24:\n    *(undefined4 *)(buffer + 0x44) = 0;\n    isNegative = numFractionalDigitsWithoutTrailingZeros;\n  }\n  else {\n    numFractionalDigitsWithoutTrailingZeros = minFractionDigits;\n    fractionalPartDigitsToShow = minFractionDigits;\n    uVar18 = minFractionDigits;\nLAB_08008314:\n    *(undefined4 *)(buffer + 0x44) = 0;\n    isNegative = fractionalPartDigitsToShow;\n    if (0x17 < (int)uVar18) {\n      numFractionDigitsToShow = 4;\n      expDigits = 1;\n      do {\n        numLeadingZeros = expDigits;\n        numFractionDigitsToShow = numFractionDigitsToShow * 2;\n        expDigits = numLeadingZeros + 1;\n      } while (numFractionDigitsToShow + 0x14U <= uVar18);\n      *(int *)(buffer + 0x44) = numLeadingZeros;\n    }\n  }\n  result = (char *)_Balloc(buffer);\n  *(char **)(buffer + 0x40) = result;\n  if ((isNegative < 0xf) && (isInfinity)) {\n    if ((int)truncatedExponent < 1) {\n      if (truncatedExponent == 0) {\n        expDigits = 2;\n        temp1 = significand;\n      }\n      else {\n        expDigits = (-truncatedExponent & 0xf) * 8;\n        temp1 = __muldf3(significand,absoluteExponent,*(undefined4 *)(&DAT_08009fa8 + expDigits),\n                          *(undefined4 *)(&DAT_08009fac + expDigits));\n        absoluteExponent = (uint)((ulonglong)temp1 >> 0x20);\n        temp1 = (uint)temp1;\n        numFractionDigitsToShow = (int)-truncatedExponent >> 4;\n        if (numFractionDigitsToShow == 0) {\n          expDigits = 2;\n        }\n        else {\n          isInfinity = false;\n          expDigits = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (numFractionDigitsToShow << 0x1f < 0) {\n              temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),*puVar22,puVar22[1]);\n              isInfinity = true;\n              expDigits = expDigits + 1;\n            }\n            numFractionDigitsToShow = numFractionDigitsToShow >> 1;\n            puVar22 = puVar22 + 2;\n          } while (numFractionDigitsToShow != 0);\n          if (isInfinity) {\n            temp1 = (uint)temp1;\n            absoluteExponent = (uint)((ulonglong)temp1 >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      uVar18 = (int)truncatedExponent >> 4;\n      temp2 = *(undefined8 *)(&DAT_08009fa8 + (truncatedExponent & 0xf) * 8);\n      temp1 = *(undefined8 *)(&DAT_08009fa8 + (truncatedExponent & 0xf) * 8);\n      if ((int)(uVar18 << 0x1b) < 0) {\n        temp3 = __divdf3(significand,absoluteExponent,0x7f73bf3c,0x75154fdd);\n        numFractionalDigitsWithTrailingZeros = (uint)((ulonglong)temp3 >> 0x20);\n        numFractionalDigits = (uint)temp3;\n        expDigits = 3;\n        uVar18 = uVar18 & 0xf;\n      }\n      else {\n        expDigits = 2;\n        numFractionalDigitsWithTrailingZeros = absoluteExponent;\n        numFractionalDigits = significand;\n      }\n      if (uVar18 != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(uVar18 << 0x1f) < 0) {\n            temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),*puVar22,puVar22[1]);\n            expDigits = expDigits + 1;\n          }\n          uVar18 = (int)uVar18 >> 1;\n          puVar22 = puVar22 + 2;\n          temp2 = temp1;\n        } while (uVar18 != 0);\n      }\n      absoluteExponent = (uint)((ulonglong)temp2 >> 0x20);\n      temp1 = (uint)temp2;\n      temp1 = __divdf3(numFractionalDigits,numFractionalDigitsWithTrailingZeros,temp1,absoluteExponent);\n      temp1 = (uint)temp1;\n      absoluteExponent = (uint)((ulonglong)temp1 >> 0x20);\n    }\n    temp1 = CONCAT44(absoluteExponent,temp1);\n    if ((decrementExponent) && (numFractionDigitsToShow = __aeabi_dcmplt(temp1,absoluteExponent,0,0x3ff00000), numFractionDigitsToShow != 0)) {\n      if (fractionalPartDigitsToShow == 0) {\n        temp1 = __aeabi_i2d(expDigits);\n        temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),temp1,absoluteExponent);\n        temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x401c0000);\n        temp = (undefined4)temp1;\n        expDigits = (int)((ulonglong)temp1 >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)numFractionalDigitsWithoutTrailingZeros) {\n        temp1 = __muldf3(temp1,absoluteExponent,0,0x40240000);\n        temp2 = __aeabi_i2d(expDigits + 1);\n        temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),(int)temp1,\n                          (int)((ulonglong)temp1 >> 0x20));\n        temp2 = __aeabi_dadd((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,0x401c0000);\n        temp = (undefined4)temp2;\n        numFractionalDigits = numFractionalDigitsWithoutTrailingZeros;\n        truncatedFraction = truncatedExponent - 1;\n        expDigits = (int)((ulonglong)temp2 >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    temp2 = __aeabi_i2d(expDigits);\n    temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),temp1,absoluteExponent);\n    temp2 = __aeabi_dadd((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,0x401c0000);\n    temp = (undefined4)temp2;\n    expDigits = (int)((ulonglong)temp2 >> 0x20) + -0x3400000;\n    if (fractionalPartDigitsToShow != 0) {\n      truncatedFraction = truncatedExponent;\n      numFractionalDigits = fractionalPartDigitsToShow;\nLAB_08007cfa:\n      absoluteExponent = (uint)((ulonglong)temp1 >> 0x20);\n      temp1 = (uint)temp1;\n      digit = __aeabi_d2iz(temp1,absoluteExponent);\n      digit = digit + '0';\n      uVar16 = (&DAT_08009fa0)[numFractionalDigits * 2];\n      fractionalPart = (&DAT_08009fa4)[numFractionalDigits * 2];\n      temp1 = __aeabi_i2d();\n      temp1 = __subdf3(temp1,absoluteExponent,(int)temp1,(int)((ulonglong)temp1 >> 0x20));\n      uVar23 = (undefined4)((ulonglong)temp1 >> 0x20);\n      pcVar21 = result + 1;\n      if (addOne) {\n        temp2 = __divdf3(0,0x3fe00000,uVar16,fractionalPart);\n        temp2 = __subdf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),temp,expDigits);\n        temp = (undefined4)((ulonglong)temp2 >> 0x20);\n        *result = digit;\n        expDigits = __aeabi_dcmpgt((int)temp2,temp,(int)temp1,uVar23);\n        if (expDigits != 0) {\nLAB_08008784:\n          truncatedExponent = truncatedFraction;\n          goto LAB_08008294;\n        }\n        temp3 = __subdf3(0,0x3ff00000,(int)temp1,uVar23);\n        expDigits = __aeabi_dcmpgt((int)temp2,temp,(int)temp3,(int)((ulonglong)temp3 >> 0x20));\n        if (expDigits == 0) {\n          if (numFractionalDigits != 1) {\n            pcVar20 = pcVar21;\n            do {\n              temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),0,0x40240000);\n              temp = (undefined4)((ulonglong)temp2 >> 0x20);\n              temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40240000);\n              digit = __aeabi_d2iz();\n              temp3 = __aeabi_i2d();\n              temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp3,\n                                (int)((ulonglong)temp3 >> 0x20));\n              uVar16 = (undefined4)((ulonglong)temp1 >> 0x20);\n              digit = digit + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = digit;\n              expDigits = __aeabi_dcmplt((int)temp1,uVar16,(int)temp2,temp);\n              if (expDigits != 0) {\n                truncatedExponent = truncatedFraction;\n                goto LAB_08008294;\n              }\n              temp3 = __subdf3(0,0x3ff00000,(int)temp1,uVar16);\n              expDigits = __aeabi_dcmplt((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp2,\n                                      temp);\n              if (expDigits != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != result + numFractionalDigits);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        truncatedExponent = truncatedFraction;\n      }\n      else {\n        temp2 = __muldf3(temp,expDigits,uVar16,fractionalPart);\n        temp = (undefined4)((ulonglong)temp2 >> 0x20);\n        *result = digit;\n        if (numFractionalDigits != 1) {\n          pcVar20 = pcVar21;\n          do {\n            temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40240000);\n            digit = __aeabi_d2iz();\n            temp3 = __aeabi_i2d();\n            temp1 = __subdf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),(int)temp3,\n                              (int)((ulonglong)temp3 >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = digit + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != result + numFractionalDigits);\n        }\n        uVar16 = (undefined4)((ulonglong)temp1 >> 0x20);\n        temp3 = __aeabi_dadd((int)temp2,temp,0,0x3fe00000);\n        expDigits = __aeabi_dcmplt((int)temp3,(int)((ulonglong)temp3 >> 0x20),(int)temp1,uVar16);\n        if (expDigits == 0) {\n          temp2 = __subdf3(0,0x3fe00000,(int)temp2,temp);\n          expDigits = __aeabi_dcmpgt((int)temp2,(int)((ulonglong)temp2 >> 0x20),(int)temp1,uVar16);\n          pcVar20 = pcVar21;\n          if (expDigits == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        truncatedExponent = truncatedFraction;\n        digit = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    temp1 = __subdf3(temp1,absoluteExponent,0,0x40140000);\n    uVar16 = (undefined4)((ulonglong)temp1 >> 0x20);\n    numFractionDigitsToShow = __aeabi_dcmpgt((int)temp1,uVar16,temp,expDigits);\n    if (numFractionDigitsToShow == 0) {\n      expDigits = __aeabi_dcmplt((int)temp1,uVar16,temp,expDigits + -0x80000000);\n      if (expDigits == 0) goto LAB_08007e36;\n      numFractionDigitsToShow = 0;\n      expDigits = 0;\n      pcVar21 = result;\n      goto LAB_080084f0;\n    }\n    expCount = 0;\n    numLeadingZeros = 0;\nLAB_08008406:\n    *result = '1';\n    truncatedExponent = truncatedExponent + 1;\n    pcVar21 = result + 1;\n    numFractionDigitsToShow = numLeadingZeros;\n    expDigits = expCount;\nLAB_08008416:\n    _Bfree(buffer,expDigits);\n    if (numFractionDigitsToShow == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = result;\n    if ((-1 < exponentDigits[0]) && ((int)truncatedExponent < 0xf)) {\n      temp = *(undefined4 *)(&DAT_08009fa8 + truncatedExponent * 8);\n      uVar16 = *(undefined4 *)(&DAT_08009fac + truncatedExponent * 8);\n      if ((-1 < (int)minFractionDigits) || (0 < (int)fractionalPartDigitsToShow)) {\n        __divdf3(significand,uVar17,temp,uVar16);\n        lessThanOne = __aeabi_d2iz();\n        temp1 = __aeabi_i2d();\n        temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),temp,uVar16);\n        temp1 = __subdf3(significand,uVar17,(int)temp1,(int)((ulonglong)temp1 >> 0x20));\n        *result = lessThanOne + 0x30;\n        pcVar21 = result + 1;\n        if (fractionalPartDigitsToShow != 1) {\n          temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40240000);\n          expDigits = __aeabi_dcmpeq((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0);\n          while (expDigits == 0) {\n            uVar23 = (undefined4)((ulonglong)temp1 >> 0x20);\n            __divdf3((int)temp1,uVar23,temp,uVar16);\n            lessThanOne = __aeabi_d2iz();\n            temp2 = __aeabi_i2d();\n            temp2 = __muldf3((int)temp2,(int)((ulonglong)temp2 >> 0x20),temp,uVar16);\n            temp1 = __subdf3((int)temp1,uVar23,(int)temp2,(int)((ulonglong)temp2 >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = lessThanOne + 0x30;\n            pcVar21 = pcVar20;\n            if (fractionalPartDigitsToShow == (int)pcVar20 - (int)result) goto LAB_08007f3a;\n            temp1 = __muldf3((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0x40240000);\n            expDigits = __aeabi_dcmpeq((int)temp1,(int)((ulonglong)temp1 >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        temp1 = __aeabi_dadd((int)temp1,(int)((ulonglong)temp1 >> 0x20));\n        uVar23 = (undefined4)((ulonglong)temp1 >> 0x20);\n        expDigits = __aeabi_dcmpgt((int)temp1,uVar23,temp,uVar16);\n        if ((expDigits == 0) &&\n           ((expDigits = __aeabi_dcmpeq((int)temp1,uVar23,temp,uVar16), expDigits == 0 ||\n            ((lessThanOne & 1) == 0)))) goto LAB_08008294;\n        digit = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, digit == '9') {\n          if (result == pcVar20) {\n            *result = '0';\n            digit = pcVar21[-1];\n            truncatedExponent = truncatedExponent + 1;\n            pcVar20 = result;\n            break;\n          }\n          digit = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = digit + '\\x01';\n        goto LAB_08008294;\n      }\n      if (fractionalPartDigitsToShow == 0) {\n        temp1 = __muldf3(temp,uVar16,0,0x40140000);\n        numTrailingDigitsToRemove = __aeabi_dcmpge((int)temp1,(int)((ulonglong)temp1 >> 0x20),significand,uVar17);\n        numFractionDigitsToShow = 0;\n        expCount = 0;\n        numLeadingZeros = 0;\n        expDigits = 0;\n        if (numTrailingDigitsToRemove == 0) goto LAB_08008406;\n      }\n      else {\n        numFractionDigitsToShow = 0;\n        expDigits = 0;\n      }\nLAB_080084f0:\n      truncatedExponent = ~minFractionDigits;\n      result = pcVar21;\n      goto LAB_08008416;\n    }\n    expDigits = numMostSignificantDigitsToRemove;\n    if (addOne) {\n      if ((int)minIntegerDigits < 2) {\n        if (isNegativeExponent) {\n          integerPartDigitsToShow = adjustedExponent;\n          adjustedExponent = adjustedExponent + exponentDigits[0] + 0x433;\n          expCount = expCount + exponentDigits[0] + 0x433;\n        }\n        else {\n          integerPartDigitsToShow = adjustedExponent;\n          adjustedExponent = adjustedExponent + (0x36 - numUnprocessedDigits);\n          expCount = expCount + (0x36 - numUnprocessedDigits);\n        }\n      }\n      else {\n        numFractionDigitsToShow = fractionalPartDigitsToShow - 1;\n        if (numMostSignificantDigitsToRemove < numFractionDigitsToShow) {\n          isRoundingUp = isRoundingUp + (numFractionDigitsToShow - numMostSignificantDigitsToRemove);\n          expDigits = 0;\n          numMostSignificantDigitsToRemove = numFractionDigitsToShow;\n        }\n        else {\n          expDigits = numMostSignificantDigitsToRemove - numFractionDigitsToShow;\n        }\n        if ((int)fractionalPartDigitsToShow < 0) {\n          integerPartDigitsToShow = adjustedExponent - fractionalPartDigitsToShow;\n        }\n        else {\n          expCount = expCount + fractionalPartDigitsToShow;\n          integerPartDigitsToShow = adjustedExponent;\n          adjustedExponent = adjustedExponent + fractionalPartDigitsToShow;\n        }\n      }\n      numFractionDigitsToShow = __i2b(buffer,1);\n    }\n    else {\n      integerPartDigitsToShow = adjustedExponent;\n      numFractionDigitsToShow = 0;\n    }\n    if ((0 < integerPartDigitsToShow) && (0 < expCount)) {\n      numLeadingZeros = integerPartDigitsToShow;\n      if (expCount <= integerPartDigitsToShow) {\n        numLeadingZeros = expCount;\n      }\n      expCount = expCount - numLeadingZeros;\n      adjustedExponent = adjustedExponent - numLeadingZeros;\n      integerPartDigitsToShow = integerPartDigitsToShow - numLeadingZeros;\n    }\n    if (numMostSignificantDigitsToRemove != 0) {\n      if (addOne) {\n        temp = significandInt;\n        if (expDigits != 0) {\n          numFractionDigitsToShow = __pow5mult(buffer,numFractionDigitsToShow,expDigits);\n          temp = __multiply(buffer,numFractionDigitsToShow,significandInt);\n          _Bfree(buffer,significandInt);\n          significandInt = temp;\n          if (numMostSignificantDigitsToRemove - expDigits == 0) goto LAB_08008062;\n        }\n        significandInt = __pow5mult(buffer,temp,numMostSignificantDigitsToRemove - expDigits);\n      }\n      else {\n        significandInt = __pow5mult(buffer,significandInt,numMostSignificantDigitsToRemove);\n      }\n    }\nLAB_08008062:\n    expDigits = __i2b(buffer,1);\n    if (isRoundingUp == 0) {\n      if (((int)minIntegerDigits < 2) && (significand == 0)) {\nLAB_0800835a:\n        if ((uVar17 & 0xfffff) == 0) {\n          uVar17 = uVar17 & 0x7ff00000;\n          if (uVar17 != 0) {\n            expCount = expCount + 1;\n            adjustedExponent = adjustedExponent + 1;\n            uVar17 = 1;\n          }\n        }\n        else {\n          uVar17 = 0;\n        }\n        isNegativeExponent = isRoundingUp != 0;\n        uVar18 = significand;\n        isRoundingUp = uVar17;\n        if (isNegativeExponent) goto LAB_080082d4;\n      }\n      numLeadingZeros = 1;\n    }\n    else {\n      temp1 = __pow5mult(buffer,expDigits);\n      expDigits = (int)temp1;\n      if (((int)minIntegerDigits < 2) && (significand == 0)) goto LAB_0800835a;\n      isRoundingUp = 0;\n      uVar18 = (uint)((ulonglong)temp1 >> 0x20);\nLAB_080082d4:\n      numLeadingZeros = __hi0bits(*(undefined4 *)(expDigits + *(int *)(expDigits + 0x10) * 4 + 0x10),uVar18);\n      numLeadingZeros = 0x20 - numLeadingZeros;\n    }\n    uVar18 = numLeadingZeros + expCount & 0x1f;\n    if (uVar18 == 0) {\n      numLeadingZeros = 0x1c;\nLAB_08008096:\n      expCount = expCount + numLeadingZeros;\n      adjustedExponent = adjustedExponent + numLeadingZeros;\n      integerPartDigitsToShow = integerPartDigitsToShow + numLeadingZeros;\n    }\n    else {\n      if (4 < (int)(0x20 - uVar18)) {\n        numLeadingZeros = 0x1c - uVar18;\n        goto LAB_08008096;\n      }\n      if (0x20 - uVar18 != 4) {\n        numLeadingZeros = 0x3c - uVar18;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < adjustedExponent) {\n      significandInt = __lshift(buffer,significandInt,adjustedExponent);\n    }\n    if (0 < expCount) {\n      expDigits = __lshift(buffer,expDigits,expCount);\n    }\n    pcVar20 = result;\n    if ((decrementExponent) && (expCount = __mcmp(significandInt,expDigits), expCount < 0)) {\n      truncatedExponent = truncatedExponent - 1;\n      significandInt = __multadd(buffer,significandInt,10,0);\n      if (addOne) {\n        numFractionDigitsToShow = __multadd(buffer,numFractionDigitsToShow,10,0);\n        if ((0 < (int)numFractionalDigitsWithoutTrailingZeros) || ((int)minIntegerDigits < 3)) {\n          fractionalPartDigitsToShow = numFractionalDigitsWithoutTrailingZeros;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)numFractionalDigitsWithoutTrailingZeros) || ((int)minIntegerDigits < 3)) {\n        fractionalPartDigitsToShow = numFractionalDigitsWithoutTrailingZeros;\n        goto LAB_0800820a;\n      }\n      fractionalPartDigitsToShow = numFractionalDigitsWithoutTrailingZeros;\nLAB_080084e8:\n      if (fractionalPartDigitsToShow == 0) {\n        expCount = __multadd(buffer,expDigits,5);\n        numTrailingDigitsToRemove = __mcmp(significandInt,expCount);\n        numLeadingZeros = numFractionDigitsToShow;\n        expDigits = expCount;\n        if (0 < numTrailingDigitsToRemove) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)fractionalPartDigitsToShow < 1) && (2 < (int)minIntegerDigits)) goto LAB_080084e8;\n    if (addOne) {\nLAB_080080de:\n      temp1 = numFractionDigitsToShow;\n      if (0 < integerPartDigitsToShow) {\n        temp1 = __lshift(buffer,numFractionDigitsToShow,integerPartDigitsToShow);\n      }\n      numFractionDigitsToShow = temp1;\n      if (isRoundingUp != 0) {\n        numFractionDigitsToShow = _Balloc(buffer,*(undefined4 *)(temp1 + 4));\n        memcpy(numFractionDigitsToShow + 0xc,temp1 + 0xc,(*(int *)(temp1 + 0x10) + 2) * 4);\n        numFractionDigitsToShow = __lshift(buffer,numFractionDigitsToShow,1);\n      }\nLAB_08008108:\n      expCount = quorem(significandInt,expDigits);\n      numLeadingZeros = __mcmp(significandInt,temp1);\n      numTrailingDigitsToRemove = __mdiff(buffer,expDigits,numFractionDigitsToShow);\n      adjustedExponent = expCount + 0x30;\n      if (*(int *)(numTrailingDigitsToRemove + 0xc) == 0) {\n        numTrailingZeros = __mcmp(significandInt);\n        _Bfree(buffer,numTrailingDigitsToRemove);\n        if ((numTrailingZeros != 0) || (minIntegerDigits != 0)) goto LAB_0800815a;\n        if ((significand & 1) != 0) {\n          numTrailingZeros = 0;\n          goto LAB_0800815a;\n        }\n        if (adjustedExponent != 0x39) {\n          if (0 < numLeadingZeros) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        digit = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      _Bfree(buffer,numTrailingDigitsToRemove);\n      numTrailingZeros = 1;\nLAB_0800815a:\n      if ((numLeadingZeros < 0) || (((numLeadingZeros == 0 && (minIntegerDigits == 0)) && ((significand & 1) == 0)))) {\n        if (0 < numTrailingZeros) {\n          significandInt = __lshift(buffer,significandInt,1);\n          numLeadingZeros = __mcmp(significandInt,expDigits);\n          if ((0 < numLeadingZeros) || ((numLeadingZeros == 0 && (expCount << 0x1f < 0)))) {\n            if (adjustedExponent == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            adjustedExponent = expCount + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)adjustedExponent;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < numTrailingZeros) {\n        if (adjustedExponent == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)expCount + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)adjustedExponent;\n      if (result + (fractionalPartDigitsToShow - 1) != pcVar20) {\n        significandInt = __multadd(buffer,significandInt,10,0);\n        pcVar20 = pcVar21;\n        if (temp1 == numFractionDigitsToShow) {\n          temp1 = __multadd(buffer,temp1,10,0);\n          numFractionDigitsToShow = temp1;\n        }\n        else {\n          temp1 = __multadd(buffer,temp1,10,0);\n          numFractionDigitsToShow = __multadd(buffer,numFractionDigitsToShow,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        adjustedExponent = quorem(significandInt,expDigits);\n        adjustedExponent = adjustedExponent + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)adjustedExponent;\n        if ((int)fractionalPartDigitsToShow <= (int)pcVar21 - (int)result) break;\n        significandInt = __multadd(buffer,significandInt,10,0);\n        pcVar20 = pcVar21;\n      }\n      temp1 = 0;\n    }\n    significandInt = __lshift(buffer,significandInt,1);\n    expCount = __mcmp(significandInt,expDigits);\n    digit = pcVar21[-1];\n    if ((0 < expCount) || ((expCount == 0 && (adjustedExponent << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (digit != '9') goto code_r0x08008270;\n        if (result == pcVar20) {\n          *result = '1';\n          truncatedExponent = truncatedExponent + 1;\n          goto LAB_08008274;\n        }\n        digit = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (digit == '0') {\n      digit = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    _Bfree(buffer,expDigits);\n    if (numFractionDigitsToShow == 0) goto LAB_08008294;\n    if ((temp1 != 0) && (temp1 != numFractionDigitsToShow)) {\n      _Bfree(buffer);\n    }\n  }\n  _Bfree(buffer,numFractionDigitsToShow);\nLAB_08008294:\n  _Bfree(buffer,significandInt);\n  *pcVar21 = '\\0';\n  *outIntegerDigits = truncatedExponent + 1;\n  if (outFractionDigits == (char **)0x0) {\n    return result;\n  }\n  *outFractionDigits = pcVar21;\n  return result;\ncode_r0x08008270:\n  *pcVar20 = digit + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "format_double_080079e8",
                "param_1": "buffer",
                "param_2": "arg2",
                "param_3": "significand",
                "param_4": "exponent",
                "param_5": "minIntegerDigits",
                "param_6": "minFractionDigits",
                "param_7": "outIntegerDigits",
                "param_8": "outIsNegative",
                "param_9": "outFractionDigits",
                "bVar1": "isInfinity",
                "bVar2": "decrementExponent",
                "bVar3": "addOne",
                "cVar4": "digit",
                "bVar5": "lessThanOne",
                "uVar6": "significandInt",
                "iVar7": "numLeadingZeros",
                "iVar8": "numTrailingZeros",
                "iVar9": "numTrailingDigitsToRemove",
                "pcVar10": "result",
                "uVar11": "isNegative",
                "uVar12": "fractionalPart",
                "uVar13": "temp",
                "iVar14": "expDigits",
                "iVar15": "expCount",
                "iVar19": "numFractionDigitsToShow",
                "iVar24": "adjustedExponent",
                "bVar25": "isNegativeExponent",
                "uVar26": "temp1",
                "uVar27": "temp2",
                "uVar28": "temp3",
                "local_80": "temp1",
                "local_7c": "absoluteExponent",
                "local_74": "truncatedExponent",
                "local_70": "adjustedExponent",
                "local_68": "fractionalPartDigitsToShow",
                "local_60": "integerPartDigitsToShow",
                "local_5c": "numMostSignificantDigitsToRemove",
                "local_58": "isRoundingUp",
                "local_48": "numFractionalDigits",
                "uStack_44": "numFractionalDigitsWithTrailingZeros",
                "local_38": "numFractionalDigitsWithoutTrailingZeros",
                "local_34": "truncatedFraction",
                "local_30": "numUnprocessedDigits",
                "local_2c": "exponentDigits"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "_Bfree",
                "__floatunsidf",
                "memcpy",
                "quorem",
                "__aeabi_dcmplt",
                "__multiply",
                "__aeabi_dcmpge",
                "__aeabi_dcmpgt",
                "_Balloc",
                "__pow5mult",
                "__i2b",
                "__mcmp",
                "__hi0bits",
                "__aeabi_dcmpeq",
                "__d2b",
                "__muldf3",
                "__aeabi_dadd",
                "__divdf3",
                "__aeabi_i2d",
                "__aeabi_d2iz",
                "__subdf3",
                "__mdiff",
                "__multadd",
                "__lshift"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "allocate_memory_0800884c",
            "code": "\nundefined4 allocate_memory_0800884c(undefined4 allocation_size,int offset)\n\n{\n  int result1;\n  int result2;\n  uint page_size;\n  \n  lock_memory();\n  page_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  result2 = ((0xfef - offset) + page_size & 0xfffff000) - 0x1000;\n  if (0xfff < result2) {\n    result1 = update_heap(allocation_size,0);\n    if (result1 == DAT_20000454 + page_size) {\n      result1 = update_heap(allocation_size,-result2);\n      if (result1 != -1) {\n        DAT_20000a14 = DAT_20000a14 - result2;\n        *(uint *)(DAT_20000454 + 4) = page_size - result2 | 1;\n        unlock_memory(allocation_size);\n        return 1;\n      }\n      result2 = update_heap(allocation_size,0);\n      if (0xf < result2 - DAT_20000454) {\n        DAT_20000a14 = result2 - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = result2 - DAT_20000454 | 1;\n      }\n    }\n  }\n  unlock_memory(allocation_size);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "allocate_memory_0800884c",
                "param_1": "allocation_size",
                "param_2": "offset",
                "iVar1": "result1",
                "iVar2": "result2",
                "uVar3": "page_size",
                "_sbrk_r": "update_heap",
                "__malloc_lock": "lock_memory",
                "__malloc_unlock": "unlock_memory"
            },
            "calling": [
                "_free_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "release_memory_block_080088ec",
            "code": "\nvoid releaseMemoryBlock_080088ec(undefined4 param_1,int memoryBlock,undefined4 param_3,undefined4 param_4)\n\n{\n  int index;\n  uint *blockPtr;\n  uint *nextBlockPtr;\n  undefined *prevBlockPtr;\n  uint blockSize;\n  uint nextBlockSize;\n  undefined *currBlockPtr;\n  undefined *newPrevBlockPtr;\n  undefined4 *foundBlockPtr;\n  int divisor;\n  uint hasNextBlock;\n  uint newNextBlockPtr;\n  \n  if (memoryBlock == 0) {\n    return;\n  }\n  __malloc_lock();\n  hasNextBlock = *(uint *)(memoryBlock + -4);\n  blockPtr = (uint *)(memoryBlock + -8);\n  blockSize = hasNextBlock & 0xfffffffe;\n  nextBlockPtr = (uint *)((int)blockPtr + blockSize);\n  nextBlockSize = nextBlockPtr[1] & 0xfffffffc;\n  if (DAT_20000454 == nextBlockPtr) {\n    blockSize = blockSize + nextBlockSize;\n    if ((hasNextBlock & 1) == 0) {\n      blockPtr = (uint *)((int)blockPtr - *(int *)(memoryBlock + -8));\n      nextBlockSize = blockPtr[2];\n      hasNextBlock = blockPtr[3];\n      blockSize = blockSize + *(int *)(memoryBlock + -8);\n      *(uint *)(nextBlockSize + 0xc) = hasNextBlock;\n      *(uint *)(hasNextBlock + 8) = nextBlockSize;\n    }\n    nextBlockSize = DAT_20000858;\n    blockPtr[1] = blockSize | 1;\n    DAT_20000454 = blockPtr;\n    if (nextBlockSize <= blockSize) {\n      _malloc_trim_r(param_1,DAT_20000a44);\n    }\nLAB_080089f0:\n    __malloc_unlock(param_1);\n    return;\n  }\n  nextBlockPtr[1] = nextBlockSize;\n  if ((hasNextBlock & 1) == 0) {\n    blockPtr = (uint *)((int)blockPtr - *(int *)(memoryBlock + -8));\n    foundBlockPtr = (undefined4 *)blockPtr[2];\n    blockSize = blockSize + *(int *)(memoryBlock + -8);\n    hasNextBlock = *(uint *)((int)nextBlockPtr + nextBlockSize + 4) & 1;\n    if ((uint **)foundBlockPtr == &DAT_20000454) {\n      if (hasNextBlock == 0) {\n        hasNextBlock = nextBlockPtr[2];\n        newNextBlockPtr = nextBlockPtr[3];\n        blockSize = blockSize + nextBlockSize;\n        *(uint *)(hasNextBlock + 0xc) = newNextBlockPtr;\n        *(uint *)(newNextBlockPtr + 8) = hasNextBlock;\n        blockPtr[1] = blockSize | 1;\n        *(uint *)((int)blockPtr + blockSize) = blockSize;\n      }\n      else {\n        blockPtr[1] = blockSize | 1;\n        *nextBlockPtr = blockSize;\n      }\n      goto LAB_080089f0;\n    }\n    newNextBlockPtr = blockPtr[3];\n    foundBlockPtr[3] = newNextBlockPtr;\n    *(undefined4 **)(newNextBlockPtr + 8) = foundBlockPtr;\n  }\n  else {\n    hasNextBlock = *(uint *)((int)nextBlockPtr + nextBlockSize + 4) & 1;\n  }\n  if (hasNextBlock == 0) {\n    foundBlockPtr = (undefined4 *)nextBlockPtr[2];\n    blockSize = blockSize + nextBlockSize;\n    if ((uint **)foundBlockPtr == &DAT_20000454) {\n      DAT_2000045c = blockPtr;\n      DAT_20000460 = blockPtr;\n      blockPtr[2] = (uint)&DAT_20000454;\n      blockPtr[3] = (uint)&DAT_20000454;\n      blockPtr[1] = blockSize | 1;\n      *(uint *)((int)blockPtr + blockSize) = blockSize;\n      goto LAB_080089f0;\n    }\n    nextBlockSize = nextBlockPtr[3];\n    foundBlockPtr[3] = nextBlockSize;\n    *(undefined4 **)(nextBlockSize + 8) = foundBlockPtr;\n    blockPtr[1] = blockSize | 1;\n    *(uint *)((int)blockPtr + blockSize) = blockSize;\n  }\n  else {\n    blockPtr[1] = blockSize | 1;\n    *(uint *)((int)blockPtr + blockSize) = blockSize;\n  }\n  if (blockSize < 0x200) {\n    divisor = (blockSize >> 3) + 1;\n    blockSize = 1 << ((int)(blockSize >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    nextBlockSize = *(uint *)(&DAT_2000044c + divisor * 8);\n    blockPtr[2] = nextBlockSize;\n    blockPtr[3] = (uint)(&DAT_20000444 + divisor * 8);\n    DAT_20000450 = (undefined *)blockSize;\n    *(uint **)(&DAT_2000044c + divisor * 8) = blockPtr;\n    *(uint **)(nextBlockSize + 0xc) = blockPtr;\n    __malloc_unlock(param_1,blockPtr,blockSize,param_4);\n    return;\n  }\n  nextBlockSize = blockSize >> 9;\n  if (nextBlockSize < 5) {\n    divisor = ((blockSize >> 6) + 0x39) * 8;\n    index = (blockSize >> 6) + 0x38;\n  }\n  else if (nextBlockSize < 0x15) {\n    divisor = (nextBlockSize + 0x5c) * 8;\n    index = nextBlockSize + 0x5b;\n  }\n  else if (nextBlockSize < 0x55) {\n    divisor = ((blockSize >> 0xc) + 0x6f) * 8;\n    index = (blockSize >> 0xc) + 0x6e;\n  }\n  else if (nextBlockSize < 0x155) {\n    divisor = ((blockSize >> 0xf) + 0x78) * 8;\n    index = (blockSize >> 0xf) + 0x77;\n  }\n  else if (nextBlockSize < 0x555) {\n    divisor = ((blockSize >> 0x12) + 0x7d) * 8;\n    index = (blockSize >> 0x12) + 0x7c;\n  }\n  else {\n    divisor = 0x3f8;\n    index = 0x7e;\n  }\n  prevBlockPtr = *(undefined **)(&DAT_2000044c + divisor);\n  currBlockPtr = &DAT_20000444 + divisor;\n  if (currBlockPtr == prevBlockPtr) {\n    prevBlockPtr = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    newPrevBlockPtr = currBlockPtr;\n    DAT_20000450 = prevBlockPtr;\n  }\n  else {\n    do {\n      newPrevBlockPtr = prevBlockPtr;\n      if ((*(uint *)(prevBlockPtr + 4) & 0xfffffffc) <= blockSize) break;\n      prevBlockPtr = *(undefined **)(prevBlockPtr + 8);\n      newPrevBlockPtr = currBlockPtr;\n    } while (currBlockPtr != prevBlockPtr);\n    currBlockPtr = *(undefined **)(newPrevBlockPtr + 0xc);\n  }\n  blockPtr[2] = (uint)newPrevBlockPtr;\n  blockPtr[3] = (uint)currBlockPtr;\n  *(uint **)(currBlockPtr + 8) = blockPtr;\n  *(uint **)(newPrevBlockPtr + 0xc) = blockPtr;\n  __malloc_unlock(param_1,blockPtr,prevBlockPtr,param_4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "release_memory_block_080088ec",
                "param_2": "memoryBlock",
                "iVar1": "index",
                "puVar2": "blockPtr",
                "puVar3": "nextBlockPtr",
                "puVar4": "prevBlockPtr",
                "uVar5": "blockSize",
                "uVar6": "nextBlockSize",
                "puVar7": "currBlockPtr",
                "puVar8": "newPrevBlockPtr",
                "puVar9": "foundBlockPtr",
                "iVar10": "divisor",
                "uVar11": "hasNextBlock",
                "uVar12": "newNextBlockPtr"
            },
            "calling": [
                "_malloc_r",
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r"
            ],
            "called": [
                "_malloc_trim_r",
                "__malloc_unlock",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "get_adjusted_value_08008ad4",
            "code": "\nint getAdjustedValue_08008ad4(void)\n\n{\n  int value;\n  \n  value = *(int *)(DAT_2000001c + 0x34);\n  if (value == 0) {\n    value = 0x2000085c;\n  }\n  return value + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "get_adjusted_value_08008ad4",
                "iVar1": "value"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_lock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "__register_exitproc",
                "__malloc_unlock"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_memory_08008af8(undefined4 *param_lock,uint size)\n\n{\n  undefined *ptr1;\n  uint var2;\n  uint var3;\n  int var4;\n  undefined *ptr5;\n  uint var6;\n  uint var7;\n  undefined4 *ptr8;\n  undefined *ptr9;\n  undefined *ptr10;\n  int *ptrResult;\n  uint calculatedSize;\n  uint alignedSize;\n  int var14;\n  undefined4 *ptr15;\n  undefined4 *ptr16;\n  \n  calculatedSize = size + 0xb;\n  if (calculatedSize < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    __malloc_lock();\n    alignedSize = 0x10;\n    var4 = 0x18;\n    calculatedSize = 2;\nLAB_08008b18:\n    ptr10 = *(undefined **)((int)&DAT_20000450 + var4);\n    if ((ptr10 != &DAT_20000444 + var4) ||\n       (ptr10 = *(undefined **)((int)&DAT_20000458 + var4), &DAT_2000044c + var4 != ptr10)) {\n      var4 = *(int *)(ptr10 + 0xc);\n      ptr5 = ptr10 + (*(uint *)(ptr10 + 4) & 0xfffffffc);\n      calculatedSize = *(uint *)(ptr5 + 4);\nLAB_08008b34:\n      var14 = *(int *)(ptr10 + 8);\n      *(int *)(var14 + 0xc) = var4;\n      *(int *)(var4 + 8) = var14;\n      *(uint *)(ptr5 + 4) = calculatedSize | 1;\n      __malloc_unlock(param_lock);\n      return (int *)(ptr10 + 8);\n    }\n    calculatedSize = calculatedSize + 2;\n  }\n  else {\n    alignedSize = calculatedSize & 0xfffffff8;\n    if (((int)alignedSize < 0) || (alignedSize < size)) {\nLAB_08008c7a:\n      *param_lock = 0xc;\n      return (int *)0x0;\n    }\n    __malloc_lock();\n    if (alignedSize < 0x1f8) {\n      calculatedSize = calculatedSize >> 3;\n      var4 = alignedSize + 8;\n      goto LAB_08008b18;\n    }\n    var2 = calculatedSize >> 9;\n    if (var2 == 0) {\n      var4 = 0x200;\n      var6 = 0x40;\n      var2 = 0x3f;\n    }\n    else if (var2 < 5) {\n      var6 = (calculatedSize >> 6) + 0x39;\n      var2 = (calculatedSize >> 6) + 0x38;\n      var4 = var6 * 8;\n    }\n    else if (var2 < 0x15) {\n      var6 = var2 + 0x5c;\n      var2 = var2 + 0x5b;\n      var4 = var6 * 8;\n    }\n    else if (var2 < 0x55) {\n      var6 = (calculatedSize >> 0xc) + 0x6f;\n      var2 = (calculatedSize >> 0xc) + 0x6e;\n      var4 = var6 * 8;\n    }\n    else if (var2 < 0x155) {\n      var6 = (calculatedSize >> 0xf) + 0x78;\n      var2 = (calculatedSize >> 0xf) + 0x77;\n      var4 = var6 * 8;\n    }\n    else if (var2 < 0x555) {\n      var6 = (calculatedSize >> 0x12) + 0x7d;\n      var2 = (calculatedSize >> 0x12) + 0x7c;\n      var4 = var6 * 8;\n    }\n    else {\n      var4 = 0x3f8;\n      var6 = 0x7f;\n      var2 = 0x7e;\n    }\n    for (ptr10 = *(undefined **)((int)&DAT_20000450 + var4); calculatedSize = var6,\n        &DAT_20000444 + var4 != ptr10; ptr10 = *(undefined **)(ptr10 + 0xc)) {\n      var14 = (*(uint *)(ptr10 + 4) & 0xfffffffc) - alignedSize;\n      calculatedSize = var2;\n      if (0xf < var14) break;\n      if (-1 < var14) {\n        ptr5 = ptr10 + (*(uint *)(ptr10 + 4) & 0xfffffffc);\n        calculatedSize = *(uint *)(ptr5 + 4);\n        var4 = *(int *)(ptr10 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  ptr15 = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    var6 = 1 << ((int)calculatedSize >> 2 & 0xffU);\n    var2 = DAT_20000450;\n    if (var6 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    var6 = DAT_2000045c[1];\n    var7 = var6 & 0xfffffffc;\n    var2 = var7 - alignedSize;\n    if (0xf < (int)var2) {\n      ptr16 = (undefined4 *)(alignedSize + (int)DAT_2000045c);\n      DAT_2000045c[1] = alignedSize | 1;\n      DAT_2000045c = ptr16;\n      DAT_20000460 = ptr16;\n      ptr16[2] = &DAT_20000454;\n      ptr16[3] = &DAT_20000454;\n      ptr16[1] = var2 | 1;\n      *(uint *)((int)ptr15 + var7) = var2;\n      __malloc_unlock(param_lock);\n      return ptr15 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)var2) {\n      *(uint *)((int)ptr15 + var7 + 4) = *(uint *)((int)ptr15 + var7 + 4) | 1;\n      __malloc_unlock(param_lock);\n      return ptr15 + 2;\n    }\n    if (var7 < 0x200) {\n      var4 = (var6 >> 3) + 1;\n      var14 = *(int *)(&DAT_2000044c + var4 * 8);\n      var2 = 1 << ((int)(var6 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      ptr15[2] = var14;\n      ptr15[3] = &DAT_20000444 + var4 * 8;\n      DAT_20000450 = var2;\n      *(undefined4 **)(&DAT_2000044c + var4 * 8) = ptr15;\n      *(undefined4 **)(var14 + 0xc) = ptr15;\n    }\n    else {\n      var2 = var6 >> 9;\n      if (var2 < 5) {\n        var4 = ((var6 >> 6) + 0x39) * 8;\n        var14 = (var6 >> 6) + 0x38;\n      }\n      else if (var2 < 0x15) {\n        var4 = (var2 + 0x5c) * 8;\n        var14 = var2 + 0x5b;\n      }\n      else if (var2 < 0x55) {\n        var4 = ((var6 >> 0xc) + 0x6f) * 8;\n        var14 = (var6 >> 0xc) + 0x6e;\n      }\n      else if (var2 < 0x155) {\n        var4 = ((var6 >> 0xf) + 0x78) * 8;\n        var14 = (var6 >> 0xf) + 0x77;\n      }\n      else if (var2 < 0x555) {\n        var4 = ((var6 >> 0x12) + 0x7d) * 8;\n        var14 = (var6 >> 0x12) + 0x7c;\n      }\n      else {\n        var4 = 0x3f8;\n        var14 = 0x7e;\n      }\n      ptr10 = *(undefined **)(&DAT_2000044c + var4);\n      ptr5 = &DAT_20000444 + var4;\n      if (ptr5 == ptr10) {\n        DAT_20000450 = 1 << (var14 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr10 + 4) & 0xfffffffc) <= var7) break;\n          ptr10 = *(undefined **)(ptr10 + 8);\n        } while (ptr5 != ptr10);\n        ptr5 = *(undefined **)(ptr10 + 0xc);\n      }\n      var2 = DAT_20000450;\n      ptr15[2] = ptr10;\n      ptr15[3] = ptr5;\n      *(undefined4 **)(ptr5 + 8) = ptr15;\n      *(undefined4 **)(ptr10 + 0xc) = ptr15;\n    }\n    var6 = 1 << ((int)calculatedSize >> 2 & 0xffU);\n    if (var6 <= var2) {\nLAB_08008c06:\n      if ((var6 & var2) == 0) {\n        calculatedSize = calculatedSize & 0xfffffffc;\n        do {\n          var6 = var6 << 1;\n          calculatedSize = calculatedSize + 4;\n        } while ((var6 & var2) == 0);\n      }\n      do {\n        ptr16 = (undefined4 *)(&DAT_2000044c + calculatedSize * 8);\n        var2 = calculatedSize;\n        ptr15 = ptr16;\n        do {\n          for (ptr8 = (undefined4 *)ptr15[3]; ptr15 != ptr8;\n              ptr8 = (undefined4 *)ptr8[3]) {\n            var7 = ptr8[1] & 0xfffffffc;\n            var3 = var7 - alignedSize;\n            if (0xf < (int)var3) {\n              var14 = ptr8[2];\n              var4 = ptr8[3];\n              ptr15 = (undefined4 *)(alignedSize + (int)ptr8);\n              ptr8[1] = alignedSize | 1;\n              *(int *)(var14 + 0xc) = var4;\n              *(int *)(var4 + 8) = var14;\n              DAT_2000045c = ptr15;\n              DAT_20000460 = ptr15;\n              ptr15[2] = &DAT_20000454;\n              ptr15[3] = &DAT_20000454;\n              ptr15[1] = var3 | 1;\n              *(uint *)((int)ptr8 + var7) = var3;\n              __malloc_unlock(param_lock);\n              return ptr8 + 2;\n            }\n            if (-1 < (int)var3) {\n              var4 = ptr8[3];\n              var14 = ptr8[2];\n              *(uint *)((int)ptr8 + var7 + 4) = *(uint *)((int)ptr8 + var7 + 4) | 1;\n              *(int *)(var14 + 0xc) = var4;\n              *(int *)(var4 + 8) = var14;\n              __malloc_unlock(param_lock);\n              return ptr8 + 2;\n            }\n          }\n          var2 = var2 + 1;\n          ptr15 = ptr15 + 2;\n        } while ((var2 & 3) != 0);\n        do {\n          var7 = calculatedSize & 3;\n          ptr15 = ptr16 + -2;\n          calculatedSize = calculatedSize - 1;\n          if (var7 == 0) {\n            DAT_20000450 = DAT_20000450 & ~var6;\n            break;\n          }\n          ptr16 = (undefined4 *)*ptr16;\n        } while (ptr16 == ptr15);\n        var6 = var6 * 2;\n        if ((DAT_20000450 <= var6 && var6 - DAT_20000450 != 0) || (calculatedSize = var2, var6 == 0))\n        break;\n        for (; (var6 & DAT_20000450) == 0; var6 = var6 << 1) {\n          calculatedSize = calculatedSize + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr10 = DAT_20000454;\n  calculatedSize = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((alignedSize <= calculatedSize) && (var2 = calculatedSize - alignedSize, 0xf < (int)var2)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    var2 = alignedSize + DAT_20000a44 + 0x10;\n  }\n  else {\n    var2 = alignedSize + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  ptr5 = (undefined *)_sbrk_r(param_lock,var2);\n  if (ptr5 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    calculatedSize = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    ptr1 = ptr10 + calculatedSize;\n    if (ptr1 < ptr5 || ptr1 == ptr5) {\n      ptr9 = DAT_20000a14 + var2;\n      if ((ptr1 != ptr5) || (((uint)ptr1 & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = ptr9;\n      *(uint *)(DAT_20000454 + 4) = calculatedSize + var2 | 1;\n    }\n    else {\n      if (ptr10 != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + var2;\n      ptr9 = ptr5;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)ptr5 - (int)ptr1);\n        ptr9 = DAT_20000854;\n      }\n      DAT_20000854 = ptr9;\n      var6 = (uint)ptr5 & 7;\n      if (var6 == 0) {\n        var4 = 0x1000;\n      }\n      else {\n        ptr5 = ptr5 + (8 - var6);\n        var4 = 0x1008 - var6;\n      }\n      var4 = var4 - ((uint)(ptr5 + var2) & 0xfff);\n      var14 = _sbrk_r(param_lock,var4);\n      if (var14 == -1) {\n        var2 = 1;\n        var4 = 0;\n      }\n      else {\n        var2 = (var14 - (int)ptr5) + var4 | 1;\n      }\n      ptr9 = DAT_20000a14 + var4;\n      DAT_20000454 = ptr5;\n      DAT_20000a14 = ptr9;\n      *(uint *)(ptr5 + 4) = var2;\n      if (ptr10 != &DAT_2000044c) {\n        if (calculatedSize < 0x10) {\n          *(undefined4 *)(ptr5 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        calculatedSize = calculatedSize - 0xc & 0xfffffff8;\n        *(uint *)(ptr10 + 4) = *(uint *)(ptr10 + 4) & 1 | calculatedSize;\n        *(undefined4 *)(ptr10 + calculatedSize + 4) = 5;\n        *(undefined4 *)(ptr10 + calculatedSize + 8) = 5;\n        if (0xf < calculatedSize) {\n          _free_r(param_lock,ptr10 + 8);\n          ptr9 = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < ptr9) {\n      DAT_20000a3c = ptr9;\n    }\n    calculatedSize = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < ptr9) {\n      DAT_20000a40 = ptr9;\n    }\n  }\n  var2 = (calculatedSize & 0xfffffffc) - alignedSize;\n  if ((alignedSize <= (calculatedSize & 0xfffffffc)) && (0xf < (int)var2)) {\nLAB_08008dac:\n    ptr10 = DAT_20000454 + alignedSize;\n    *(uint *)(DAT_20000454 + 4) = alignedSize | 1;\n    ptrResult = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = ptr10;\n    *(uint *)(ptr10 + 4) = var2 | 1;\n    __malloc_unlock(param_lock);\n    return ptrResult;\n  }\nLAB_08008eee:\n  __malloc_unlock(param_lock);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_memory_08008af8",
                "param_1": "param_lock",
                "param_2": "size",
                "puVar1": "ptr1",
                "uVar2": "var2",
                "uVar3": "var3",
                "iVar4": "var4",
                "puVar5": "ptr5",
                "uVar6": "var6",
                "uVar7": "var7",
                "puVar8": "ptr8",
                "puVar9": "ptr9",
                "puVar10": "ptr10",
                "piVar11": "ptrResult",
                "uVar12": "calculatedSize",
                "uVar13": "alignedSize",
                "iVar14": "var14",
                "puVar15": "ptr15",
                "puVar16": "ptr16"
            },
            "calling": [
                "_calloc_r",
                "__ssprint_r",
                "_svfprintf_r",
                "_realloc_r"
            ],
            "called": [
                "_sbrk_r",
                "__malloc_unlock",
                "_free_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_first_occurrence_0800901c",
            "code": "\nuint * findFirstOccurrence_0800901c(uint *arr,uint val,uint size)\n\n{\n  uint temp;\n  uint combinedVal;\n  uint *ptr;\n  uint maskedVal;\n  bool isSizeZero;\n  \n  maskedVal = val & 0xff;\n  if (((uint)arr & 3) == 0) {\nLAB_0800904a:\n    if (3 < size) {\n      combinedVal = (val & 0xff) << 8 | maskedVal;\n      ptr = arr;\n      do {\n        temp = *ptr ^ (combinedVal | combinedVal << 0x10);\n        arr = ptr + 1;\n        if ((temp + 0xfefefeff & ~temp & 0x80808080) != 0) goto LAB_08009050;\n        size = size - 4;\n        ptr = arr;\n      } while (3 < size);\n    }\n    ptr = arr;\n    if (size == 0) {\n      arr = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      arr = ptr;\n      if (*(byte *)arr != maskedVal) {\n        ptr = (uint *)(size + (int)arr);\n        do {\n          arr = (uint *)((int)arr + 1);\n          if (ptr == arr) goto LAB_0800906c;\n        } while (*(byte *)arr != maskedVal);\n      }\n    }\n  }\n  else {\n    combinedVal = size - 1;\n    if (size == 0) {\nLAB_0800906c:\n      arr = (uint *)0x0;\n    }\n    else if (*(byte *)arr != maskedVal) {\n      ptr = (uint *)((int)arr + 1);\n      do {\n        arr = ptr;\n        size = combinedVal;\n        if (((uint)arr & 3) == 0) goto LAB_0800904a;\n        isSizeZero = combinedVal == 0;\n        combinedVal = combinedVal - 1;\n        if (isSizeZero) goto LAB_0800906c;\n        ptr = (uint *)((int)arr + 1);\n      } while (*(byte *)arr != maskedVal);\n    }\n  }\n  return arr;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_first_occurrence_0800901c",
                "param_1": "arr",
                "param_2": "val",
                "param_3": "size",
                "uVar1": "temp",
                "uVar2": "combinedVal",
                "puVar3": "ptr",
                "uVar4": "maskedVal",
                "bVar5": "isSizeZero"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "acquire_recursive_lock_080090a8",
            "code": "\nvoid acquireRecursiveLock_080090a8(void)\n\n{\n  __retarget_lock_acquire_recursive(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "acquire_recursive_lock_080090a8"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_free_r",
                "_realloc_r"
            ],
            "called": [
                "__retarget_lock_acquire_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "release_recursive_lock_080090b4",
            "code": "\nvoid releaseRecursiveLock_080090b4(void)\n\n{\n  __retarget_lock_release_recursive(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "release_recursive_lock_080090b4"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r",
                "_realloc_r",
                "_free_r"
            ],
            "called": [
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "allocate_or_get_pointer_080090c0",
            "code": "\nundefined4 * allocateOrGetPointer_080090c0(int ptrToAllocSize,uint index)\n\n{\n  undefined4 *pointer;\n  int existingPointer;\n  \n  existingPointer = *(int *)(ptrToAllocSize + 0x4c);\n  if (existingPointer == 0) {\n    existingPointer = _calloc_r(ptrToAllocSize,4,0x21);\n    *(int *)(ptrToAllocSize + 0x4c) = existingPointer;\n    if (existingPointer == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  pointer = *(undefined4 **)(existingPointer + index * 4);\n  if (pointer == (undefined4 *)0x0) {\n    existingPointer = 1 << (index & 0xff);\n    pointer = (undefined4 *)_calloc_r(ptrToAllocSize,1,(existingPointer + 5) * 4);\n    if (pointer == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    pointer[1] = index;\n    pointer[2] = existingPointer;\n  }\n  else {\n    *(undefined4 *)(existingPointer + index * 4) = *pointer;\n  }\n  pointer[3] = 0;\n  pointer[4] = 0;\n  return pointer;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "allocate_or_get_pointer_080090c0",
                "param_1": "ptrToAllocSize",
                "param_2": "index",
                "puVar1": "pointer",
                "iVar2": "existingPointer"
            },
            "calling": [
                "__d2b",
                "_dtoa_r",
                "__multiply",
                "__i2b",
                "__mdiff",
                "__pow5mult",
                "__multadd",
                "__lshift"
            ],
            "called": [
                "_calloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "update_pointer_0800910c",
            "code": "\nvoid updatePointer_0800910c(int baseAddress,undefined4 *newPointer)\n\n{\n  int pointerOffset;\n  \n  if (newPointer != (undefined4 *)0x0) {\n    pointerOffset = *(int *)(baseAddress + 0x4c);\n    *newPointer = *(undefined4 *)(pointerOffset + newPointer[1] * 4);\n    *(undefined4 **)(pointerOffset + newPointer[1] * 4) = newPointer;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "update_pointer_0800910c",
                "param_1": "baseAddress",
                "param_2": "newPointer",
                "iVar1": "pointerOffset"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "update_array_with_multiplication_08009120",
            "code": "\nundefined4 * updateArrayWithMultiplication_08009120(int arraySize,undefined4 *array,int multiplier,uint carry)\n\n{\n  undefined4 *updatedArray;\n  uint tempValue;\n  int arrayLength;\n  uint *currentValuePtr;\n  int iterationCount;\n  \n  iterationCount = 0;\n  arrayLength = array[4];\n  currentValuePtr = array + 5;\n  do {\n    iterationCount = iterationCount + 1;\n    carry = multiplier * (*currentValuePtr & 0xffff) + carry;\n    tempValue = multiplier * (*currentValuePtr >> 0x10) + (carry >> 0x10);\n    *currentValuePtr = (carry & 0xffff) + tempValue * 0x10000;\n    carry = tempValue >> 0x10;\n    currentValuePtr = currentValuePtr + 1;\n  } while (iterationCount < arrayLength);\n  updatedArray = array;\n  if (carry != 0) {\n    if ((int)array[2] <= arrayLength) {\n      updatedArray = (undefined4 *)_Balloc(arraySize,array[1] + 1);\n      memcpy(updatedArray + 3,array + 3,(array[4] + 2) * 4);\n      iterationCount = *(int *)(arraySize + 0x4c);\n      *array = *(undefined4 *)(iterationCount + array[1] * 4);\n      *(undefined4 **)(iterationCount + array[1] * 4) = array;\n    }\n    updatedArray[arrayLength + 5] = carry;\n    updatedArray[4] = arrayLength + 1;\n  }\n  return updatedArray;\n}\n\n",
            "renaming": {
                "FUN_08009120": "update_array_with_multiplication_08009120",
                "param_1": "arraySize",
                "param_2": "array",
                "param_3": "multiplier",
                "param_4": "carry",
                "puVar1": "updatedArray",
                "uVar2": "tempValue",
                "iVar3": "arrayLength",
                "puVar4": "currentValuePtr",
                "iVar5": "iterationCount"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "memcpy",
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "get_leading_zeros_080091a4",
            "code": "\nint getLeadingZeros_080091a4(uint input)\n\n{\n  int leadingZerosCount;\n  \n  if ((input & 0xffff0000) == 0) {\n    input = input << 0x10;\n    leadingZerosCount = 0x10;\n  }\n  else {\n    leadingZerosCount = 0;\n  }\n  if ((input & 0xff000000) == 0) {\n    input = input << 8;\n    leadingZerosCount = leadingZerosCount + 8;\n  }\n  if ((input & 0xf0000000) == 0) {\n    input = input << 4;\n    leadingZerosCount = leadingZerosCount + 4;\n  }\n  if ((input & 0xc0000000) == 0) {\n    input = input << 2;\n    leadingZerosCount = leadingZerosCount + 2;\n  }\n  if (-1 < (int)input) {\n    if ((int)(input << 1) < 0) {\n      return leadingZerosCount + 1;\n    }\n    leadingZerosCount = 0x20;\n  }\n  return leadingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "get_leading_zeros_080091a4",
                "param_1": "input",
                "iVar1": "leadingZerosCount"
            },
            "calling": [
                "__d2b",
                "_dtoa_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "count_leading_zeros_080091e4",
            "code": "\nint count_leading_zeros_080091e4(uint *input)\n\n{\n  int leading_zeros;\n  uint value;\n  \n  value = *input;\n  if ((value & 7) == 0) {\n    if ((value & 0xffff) == 0) {\n      value = value >> 0x10;\n      leading_zeros = 0x10;\n    }\n    else {\n      leading_zeros = 0;\n    }\n    if ((value & 0xff) == 0) {\n      value = value >> 8;\n      leading_zeros = leading_zeros + 8;\n    }\n    if ((value & 0xf) == 0) {\n      value = value >> 4;\n      leading_zeros = leading_zeros + 4;\n    }\n    if ((value & 3) == 0) {\n      value = value >> 2;\n      leading_zeros = leading_zeros + 2;\n    }\n    if (-1 < (int)(value << 0x1f)) {\n      value = value >> 1;\n      if (value == 0) {\n        return 0x20;\n      }\n      leading_zeros = leading_zeros + 1;\n    }\n    *input = value;\n    return leading_zeros;\n  }\n  if ((int)(value << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(value << 0x1e)) {\n    *input = value >> 2;\n    return 2;\n  }\n  *input = value >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "count_leading_zeros_080091e4",
                "param_1": "input",
                "iVar1": "leading_zeros",
                "uVar2": "value"
            },
            "calling": [
                "__d2b"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_data_structure_08009244",
            "code": "\nvoid initializeDataStructure_08009244(undefined4 size,undefined4 data)\n\n{\n  int allocatedMemory;\n  \n  allocatedMemory = _Balloc(size,1);\n  *(undefined4 *)(allocatedMemory + 0x10) = 1;\n  *(undefined4 *)(allocatedMemory + 0x14) = data;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_data_structure_08009244",
                "param_1": "size",
                "param_2": "data",
                "iVar1": "allocatedMemory"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "calculate_checksum_08009258",
            "code": "\nvoid calculateChecksum_08009258(undefined4 buffer,int data1,int data2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int dataSize;\n  uint temp;\n  uint *ptr3;\n  uint startOffset;\n  uint *ptr4;\n  uint temp2;\n  int maxSize;\n  int size;\n  uint endOffset;\n  int size1;\n  int size2;\n  uint *ptr6;\n  uint *ptr7;\n  uint *ptr5;\n  uint *ptr8;\n  uint *ptr9;\n  \n  size1 = *(int *)(data1 + 0x10);\n  maxSize = *(int *)(data2 + 0x10);\n  size = maxSize;\n  size2 = data1;\n  if (size1 < maxSize) {\n    size = size1;\n    size1 = maxSize;\n    size2 = data2;\n    data2 = data1;\n  }\n  maxSize = size1 + size;\n  dataSize = *(int *)(size2 + 4);\n  if (*(int *)(size2 + 8) < maxSize) {\n    dataSize = dataSize + 1;\n  }\n  dataSize = _Balloc(buffer,dataSize);\n  ptr9 = (uint *)(dataSize + 0x14);\n  ptr8 = ptr9 + maxSize;\n  for (ptr3 = ptr9; ptr3 < ptr8; ptr3 = ptr3 + 1) {\n    *ptr3 = 0;\n  }\n  startOffset = data2 + 0x14;\n  endOffset = startOffset + size * 4;\n  ptr3 = (uint *)(size2 + 0x14);\n  if (startOffset < endOffset) {\n    ptr4 = (uint *)(startOffset + ((endOffset - data2) - 0x15 & 0xfffffffc));\n    ptr5 = (uint *)(data2 + 0x10);\n    do {\n      while( true ) {\n        ptr5 = ptr5 + 1;\n        startOffset = *ptr5 & 0xffff;\n        if (startOffset != 0) break;\n        startOffset = *ptr5 >> 0x10;\n        if (startOffset == 0) goto LAB_080092d2;\nLAB_0800932c:\n        temp2 = *ptr9;\n        temp = 0;\n        ptr1 = ptr3;\n        ptr6 = ptr9;\n        endOffset = temp2;\n        do {\n          ptr7 = ptr6;\n          temp = temp + startOffset * *(ushort *)ptr1 + (endOffset >> 0x10);\n          *ptr7 = temp2 & 0xffff | temp * 0x10000;\n          ptr2 = ptr1 + 1;\n          endOffset = ptr7[1];\n          temp2 = startOffset * (*ptr1 >> 0x10) + (endOffset & 0xffff) + (temp >> 0x10);\n          temp = temp2 >> 0x10;\n          ptr1 = ptr2;\n          ptr6 = ptr7 + 1;\n        } while (ptr2 < ptr3 + size1);\n        ptr7[1] = temp2;\n        ptr9 = ptr9 + 1;\n        if (ptr4 == ptr5) goto LAB_0800937a;\n      }\n      endOffset = 0;\n      ptr1 = ptr9;\n      ptr6 = ptr3;\n      do {\n        ptr2 = ptr1;\n        ptr7 = ptr6 + 1;\n        temp2 = startOffset * (*ptr6 & 0xffff) + (*ptr2 & 0xffff) + endOffset;\n        temp = startOffset * (*ptr6 >> 0x10) + (*ptr2 >> 0x10) + (temp2 >> 0x10);\n        endOffset = temp >> 0x10;\n        *ptr2 = temp2 & 0xffff | temp * 0x10000;\n        ptr1 = ptr2 + 1;\n        ptr6 = ptr7;\n      } while (ptr7 < ptr3 + size1);\n      ptr2[1] = endOffset;\n      startOffset = *ptr5 >> 0x10;\n      if (startOffset != 0) goto LAB_0800932c;\nLAB_080092d2:\n      ptr9 = ptr9 + 1;\n    } while (ptr4 != ptr5);\n  }\nLAB_0800937a:\n  if (0 < maxSize) {\n    startOffset = ptr8[-1];\n    ptr8 = ptr8 + -1;\n    while ((startOffset == 0 && (maxSize = maxSize + -1, maxSize != 0))) {\n      ptr8 = ptr8 + -1;\n      startOffset = *ptr8;\n    }\n  }\n  *(int *)(dataSize + 0x10) = maxSize;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "calculate_checksum_08009258",
                "param_1": "buffer",
                "param_2": "data1",
                "param_3": "data2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "dataSize",
                "uVar4": "temp",
                "puVar5": "ptr3",
                "uVar6": "startOffset",
                "uVar11": "endOffset",
                "puVar7": "ptr4",
                "puVar16": "ptr5",
                "uVar8": "temp2",
                "iVar9": "maxSize",
                "iVar10": "size",
                "iVar12": "size1",
                "iVar13": "size2",
                "puVar14": "ptr6",
                "puVar15": "ptr7",
                "puVar17": "ptr8",
                "puVar18": "ptr9"
            },
            "calling": [
                "_dtoa_r",
                "__pow5mult"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "calculate_result_080093a4",
            "code": "\nundefined4 * calculateResult_080093a4(int input,undefined4 *result,uint size)\n\n{\n  int index;\n  int loopCount;\n  undefined4 *temp1;\n  undefined4 *temp2;\n  \n  if ((size & 3) != 0) {\n    result = (undefined4 *)\n              __multadd(input,result,*(undefined4 *)(&DAT_0800a070 + ((size & 3) - 1) * 4),0);\n  }\n  loopCount = (int)size >> 2;\n  if (loopCount != 0) {\n    temp2 = *(undefined4 **)(input + 0x48);\n    if (temp2 == (undefined4 *)0x0) {\n      temp2 = (undefined4 *)_Balloc(input,1);\n      temp2[4] = 1;\n      temp2[5] = 0x271;\n      *(undefined4 **)(input + 0x48) = temp2;\n      *temp2 = 0;\n    }\n    temp1 = result;\n    if (loopCount << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    loopCount = loopCount >> 1;\n    temp1 = temp2;\n    if (loopCount != 0) {\n      while( true ) {\n        temp2 = (undefined4 *)*temp1;\n        if (temp2 == (undefined4 *)0x0) {\n          temp2 = (undefined4 *)__multiply(input,temp1,temp1);\n          *temp1 = temp2;\n          *temp2 = 0;\n        }\n        temp1 = result;\n        if (-1 < loopCount << 0x1f) break;\nLAB_080093d2:\n        result = (undefined4 *)__multiply(input,temp1,temp2);\n        if (temp1 == (undefined4 *)0x0) break;\n        index = *(int *)(input + 0x4c);\n        loopCount = loopCount >> 1;\n        *temp1 = *(undefined4 *)(index + temp1[1] * 4);\n        *(undefined4 **)(index + temp1[1] * 4) = temp1;\n        temp1 = temp2;\n        if (loopCount == 0) {\n          return result;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "calculate_result_080093a4",
                "param_1": "input",
                "param_2": "result",
                "param_3": "size",
                "iVar1": "index",
                "iVar2": "loopCount",
                "puVar3": "temp1",
                "puVar4": "temp2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__multiply",
                "_Balloc",
                "__multadd"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "reverse_bits_08009444",
            "code": "\nvoid reverseBits_08009444(int inputSize,undefined4 *data,uint shiftAmount)\n\n{\n  int temp1;\n  int temp2;\n  int temp3;\n  undefined4 temp4;\n  int offset;\n  int temp6;\n  uint *output;\n  uint *iterator;\n  uint *iterator2;\n  uint *dataPtr;\n  int shiftDiv;\n  int newOffset;\n  uint shiftRem;\n  uint *outputPtr;\n  \n  offset = data[4];\n  shiftDiv = (int)shiftAmount >> 5;\n  newOffset = shiftDiv + offset + 1;\n  temp3 = data[1];\n  temp2 = data[2];\n  if ((int)data[2] < newOffset) {\n    do {\n      temp6 = temp2 * 2;\n      temp1 = temp2 * -2;\n      temp3 = temp3 + 1;\n      temp2 = temp6;\n    } while (newOffset != temp6 && newOffset + temp1 < 0 == SBORROW4(newOffset,temp6));\n  }\n  temp2 = _Balloc(inputSize,temp3);\n  output = (uint *)(temp2 + 0x14);\n  if (0 < shiftDiv) {\n    dataPtr = output + shiftDiv;\n    iterator = output;\n    do {\n      outputPtr = iterator + 1;\n      *iterator = 0;\n      output = dataPtr;\n      iterator = outputPtr;\n    } while (outputPtr != dataPtr);\n  }\n  temp3 = data[4];\n  iterator = data + 5;\n  shiftAmount = shiftAmount & 0x1f;\n  if (shiftAmount == 0) {\n    output = output + -1;\n    dataPtr = iterator;\n    do {\n      outputPtr = dataPtr + 1;\n      output = output + 1;\n      *output = *dataPtr;\n      dataPtr = outputPtr;\n    } while (outputPtr < iterator + temp3);\n  }\n  else {\n    shiftRem = 0;\n    dataPtr = iterator;\n    do {\n      outputPtr = output;\n      *outputPtr = *dataPtr << shiftAmount | shiftRem;\n      iterator2 = dataPtr + 1;\n      shiftRem = *dataPtr >> (0x20 - shiftAmount & 0xff);\n      output = outputPtr + 1;\n      dataPtr = iterator2;\n    } while (iterator2 < iterator + temp3);\n    outputPtr[1] = shiftRem;\n    if (shiftRem != 0) {\n      newOffset = shiftDiv + offset + 2;\n    }\n  }\n  offset = *(int *)(inputSize + 0x4c);\n  temp3 = data[1];\n  temp4 = *(undefined4 *)(offset + temp3 * 4);\n  *(int *)(temp2 + 0x10) = newOffset + -1;\n  *data = temp4;\n  *(undefined4 **)(offset + temp3 * 4) = data;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "reverse_bits_08009444",
                "param_1": "inputSize",
                "param_2": "data",
                "param_3": "shiftAmount",
                "iVar1": "temp1",
                "iVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "offset",
                "iVar6": "temp6",
                "puVar7": "output",
                "puVar8": "iterator",
                "puVar9": "outputPtr",
                "puVar10": "iterator2",
                "puVar11": "dataPtr",
                "iVar12": "shiftDiv",
                "iVar13": "newOffset",
                "uVar14": "shiftRem"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compare_arrays_080094f8(int array1,int array2)\n\n{\n  int array_difference;\n  uint *array2_end_ptr;\n  int array2_length;\n  uint *array1_end_ptr;\n  \n  array2_length = *(int *)(array2 + 0x10);\n  array_difference = *(int *)(array1 + 0x10) - array2_length;\n  if (array_difference == 0) {\n    array2_end_ptr = (uint *)(array2 + 0x14 + array2_length * 4);\n    array1_end_ptr = (uint *)(array1 + 0x14) + array2_length;\n    do {\n      array1_end_ptr = array1_end_ptr + -1;\n      array2_end_ptr = array2_end_ptr + -1;\n      if (*array1_end_ptr != *array2_end_ptr) {\n        if (*array2_end_ptr <= *array1_end_ptr) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < array1_end_ptr);\n  }\n  return array_difference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "array_difference",
                "iVar3": "array2_length",
                "puVar2": "array2_end_ptr",
                "puVar4": "array1_end_ptr"
            },
            "calling": [
                "_dtoa_r",
                "quorem"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "verify_arrays_08009530",
            "code": "\nvoid verifyArrays_08009530(undefined4 errorCode,uint *array1,uint *array2,undefined4 param4)\n\n{\n  int result;\n  uint *ptrArray;\n  uint count1;\n  uint count2;\n  undefined4 isLess;\n  uint *ptr1;\n  uint *ptr2;\n  uint *ptrArray1;\n  uint *ptrArray2;\n  uint *ptrEnd1;\n  int carry;\n  uint *ptrStart1;\n  uint resultCount;\n  uint *ptrResult;\n  \n  ptrArray = (uint *)array2[4];\n  ptrEnd1 = array1 + 5;\n  ptrStart1 = array2 + 5;\n  ptr2 = ptrEnd1;\n  ptrArray1 = array1;\n  if ((uint *)array1[4] == ptrArray) {\n    ptr1 = ptrEnd1 + (int)ptrArray;\n    ptrArray = ptrStart1 + (int)ptrArray;\n    while( true ) {\n      ptr1 = ptr1 + -1;\n      ptrArray = ptrArray + -1;\n      if (*ptr1 != *ptrArray) break;\n      if (ptr1 <= ptrEnd1) {\n        carry = _Balloc(errorCode,0,ptr1,ptrArray,param4);\n        *(undefined4 *)(carry + 0x10) = 1;\n        *(undefined4 *)(carry + 0x14) = 0;\n        return;\n      }\n    }\n    isLess = 0;\n    if (*ptrArray <= *ptr1) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)array1[4] - (int)ptrArray) {\n    isLess = 0;\n    ptr1 = array2;\n    goto LAB_08009578;\n  }\n  isLess = 1;\n  ptr1 = ptrEnd1;\n  ptrArray = array1;\n  ptr2 = ptrStart1;\n  ptrArray1 = array2;\n  array2 = array1;\n  ptrStart1 = ptrEnd1;\nLAB_08009578:\n  result = _Balloc(errorCode,ptrArray1[1],ptr1,ptrArray,param4);\n  carry = 0;\n  resultCount = ptrArray1[4];\n  count1 = array2[4];\n  *(undefined4 *)(result + 0xc) = isLess;\n  ptrEnd1 = ptr2 + resultCount;\n  ptrArray = (uint *)(result + 0x14);\n  ptrArray1 = ptrStart1;\n  do {\n    ptrResult = ptr2 + 1;\n    ptrArray2 = ptrArray1 + 1;\n    count2 = ((*ptr2 & 0xffff) + carry) - (*ptrArray1 & 0xffff);\n    carry = ((*ptr2 >> 0x10) - (*ptrArray1 >> 0x10)) + ((int)count2 >> 0x10);\n    count2 = count2 & 0xffff | carry * 0x10000;\n    ptr1 = ptrArray + 1;\n    *ptrArray = count2;\n    carry = carry >> 0x10;\n    ptrArray = ptr1;\n    ptr2 = ptrResult;\n    ptrArray1 = ptrArray2;\n  } while (ptrArray2 < ptrStart1 + count1);\n  ptrArray = ptrResult;\n  ptr2 = ptr1;\n  if (ptrResult < ptrEnd1) {\n    do {\n      ptrArray1 = ptrArray + 1;\n      count1 = (*ptrArray & 0xffff) + carry;\n      carry = ((int)count1 >> 0x10) + (*ptrArray >> 0x10);\n      count2 = count1 & 0xffff | carry * 0x10000;\n      *ptr2 = count2;\n      carry = carry >> 0x10;\n      ptrArray = ptrArray1;\n      ptr2 = ptr2 + 1;\n    } while (ptrArray1 < ptrEnd1);\n    ptr1 = (uint *)((int)ptr1 + ((int)ptrEnd1 + ~(uint)ptrResult & 0xfffffffc) + 4);\n  }\n  ptr1 = ptr1 + -1;\n  while (count2 == 0) {\n    ptr1 = ptr1 + -1;\n    resultCount = resultCount - 1;\n    count2 = *ptr1;\n  }\n  *(uint *)(result + 0x10) = resultCount;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "verify_arrays_08009530",
                "param_1": "errorCode",
                "param_2": "array1",
                "param_3": "array2",
                "param_4": "param4",
                "iVar1": "result",
                "puVar2": "ptrArray",
                "uVar3": "count1",
                "uVar4": "count2",
                "uVar5": "isLess",
                "puVar6": "ptr1",
                "puVar7": "ptr2",
                "puVar8": "ptrResult",
                "puVar9": "ptrArray1",
                "puVar10": "ptrArray2",
                "puVar11": "ptrEnd1",
                "iVar12": "carry",
                "puVar13": "ptrStart1",
                "uVar14": "resultCount"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "_Balloc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "extract_bits_08009630",
            "code": "\nint extract_bits_08009630(undefined4 input_value_1,undefined4 input_value_2,uint bit_position,uint bit_length,int *result_value_1,\n                int *result_value_2)\n\n{\n  int result;\n  uint shifted_bits;\n  int least_significant_bit;\n  int condition;\n  uint shifted_result;\n  uint uVar6;\n  undefined8 uVar7;\n  uint local_value_1;\n  uint local_value_2;\n  \n  result = _Balloc(input_value_1,1);\n  uVar6 = (bit_length << 1) >> 0x15;\n  local_value_2 = bit_length & 0xfffff;\n  if (uVar6 != 0) {\n    local_value_2 = local_value_2 | 0x100000;\n  }\n  if (bit_position == 0) {\n    least_significant_bit = __lo0bits(&local_value_2);\n    condition = 1;\n    shifted_bits = least_significant_bit + 0x20;\n    *(undefined4 *)(result + 0x10) = 1;\n    *(uint *)(result + 0x14) = local_value_2;\n  }\n  else {\n    local_value_1 = bit_position;\n    shifted_bits = __lo0bits(&local_value_1);\n    if (shifted_bits == 0) {\n      *(uint *)(result + 0x14) = local_value_1;\n    }\n    else {\n      shifted_result = local_value_2 << (0x20 - shifted_bits & 0xff);\n      local_value_2 = local_value_2 >> (shifted_bits & 0xff);\n      *(uint *)(result + 0x14) = shifted_result | local_value_1;\n    }\n    if (local_value_2 == 0) {\n      condition = 1;\n    }\n    else {\n      condition = 2;\n    }\n    *(uint *)(result + 0x18) = local_value_2;\n    *(int *)(result + 0x10) = condition;\n  }\n  if (uVar6 == 0) {\n    *result_value_1 = shifted_bits - 0x432;\n    uVar7 = __hi0bits(*(undefined4 *)(result + condition * 4 + 0x10));\n    *result_value_2 = (int)((ulonglong)uVar7 >> 0x20) * 0x20 - (int)uVar7;\n    return result;\n  }\n  *result_value_1 = (uVar6 - 0x433) + shifted_bits;\n  *result_value_2 = 0x35 - shifted_bits;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009630": "extract_bits_08009630",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "param_3": "bit_position",
                "param_4": "bit_length",
                "param_5": "result_value_1",
                "param_6": "result_value_2",
                "iVar1": "result",
                "uVar2": "shifted_bits",
                "iVar3": "least_significant_bit",
                "iVar4": "condition",
                "uVar5": "shifted_result",
                "local_20": "local_value_1",
                "local_1c": "local_value_2"
            },
            "calling": [
                "_dtoa_r"
            ],
            "called": [
                "__lo0bits",
                "_Balloc",
                "__hi0bits"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "decode_and_calculate_floating_point_080096e0",
            "code": "\nundefined8 decodeAndCalculateFloatingPoint_080096e0(uint inputValue1,uint inputValue2,int *outputValue,undefined4 extraParameter)\n\n{\n  int counter;\n  uint maskedInputValue2;\n  undefined8 concatenatedValues;\n  \n  concatenatedValues = CONCAT44(inputValue2,inputValue1);\n  counter = 0;\n  maskedInputValue2 = inputValue2 & 0x7fffffff;\n  *outputValue = 0;\n  if ((maskedInputValue2 < 0x7ff00000) && ((maskedInputValue2 | inputValue1) != 0)) {\n    if (maskedInputValue2 < 0x100000) {\n      concatenatedValues = __muldf3(inputValue1,inputValue2,0,0x43500000,extraParameter);\n      counter = -0x36;\n      maskedInputValue2 = (uint)((ulonglong)concatenatedValues >> 0x20) & 0x7fffffff;\n    }\n    inputValue1 = (uint)concatenatedValues;\n    inputValue2 = (uint)((ulonglong)concatenatedValues >> 0x20) & 0x800fffff | 0x3fe00000;\n    *outputValue = ((int)maskedInputValue2 >> 0x14) + -0x3fe + counter;\n  }\n  return CONCAT44(inputValue2,inputValue1);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "decode_and_calculate_floating_point_080096e0",
                "param_1": "inputValue1",
                "param_2": "inputValue2",
                "param_3": "outputValue",
                "param_4": "extraParameter",
                "iVar1": "counter",
                "uVar2": "maskedInputValue2",
                "uVar3": "concatenatedValues"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "__muldf3"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "allocate_memory_08009744",
            "code": "\nvoid allocateMemory_08009744(int *outputPtr,undefined4 size)\n\n{\n  int allocatedAddr;\n  \n  DAT_20000c10 = 0;\n  allocatedAddr = _sbrk(size);\n  if ((allocatedAddr == -1) && (DAT_20000c10 != 0)) {\n    *outputPtr = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "allocate_memory_08009744",
                "param_1": "outputPtr",
                "param_2": "size",
                "iVar1": "allocatedAddr"
            },
            "calling": [
                "_malloc_trim_r",
                "_malloc_r"
            ],
            "called": [
                "_sbrk"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_and_fill_buffer_08009768",
            "code": "\nvoid copy_and_fill_buffer_08009768(uint *src_buffer,uint *dest_buffer,uint num_bytes)\n\n{\n  char current_char;\n  uint *src_ptr;\n  uint *dest_ptr;\n  uint current_byte;\n  \n  if (((((uint)src_buffer | (uint)dest_buffer) & 3) == 0) &&\n     (dest_ptr = src_buffer, src_ptr = dest_buffer, 3 < num_bytes)) {\n    do {\n      dest_buffer = src_ptr + 1;\n      current_byte = *src_ptr;\n      src_buffer = dest_ptr;\n      if ((current_byte + 0xfefefeff & ~current_byte & 0x80808080) != 0) goto LAB_0800979c;\n      num_bytes = num_bytes - 4;\n      src_buffer = dest_ptr + 1;\n      *dest_ptr = current_byte;\n      dest_ptr = src_buffer;\n      src_ptr = dest_buffer;\n    } while (3 < num_bytes);\n  }\n  src_ptr = dest_buffer;\n  if (num_bytes != 0) {\nLAB_0800979c:\n    current_char = *(char *)src_ptr;\n    *(char *)src_buffer = current_char;\n    while( true ) {\n      src_buffer = (uint *)((int)src_buffer + 1);\n      num_bytes = num_bytes - 1;\n      if (current_char == '\\0') break;\n      if (num_bytes == 0) {\n        return;\n      }\n      src_ptr = (uint *)((int)src_ptr + 1);\n      current_char = *(char *)src_ptr;\n      *(char *)src_buffer = current_char;\n    }\n    if (num_bytes != 0) {\n      src_ptr = src_buffer;\n      do {\n        dest_ptr = (uint *)((int)src_ptr + 1);\n        *(char *)src_ptr = '\\0';\n        src_ptr = dest_ptr;\n      } while (dest_ptr != (uint *)(num_bytes + (int)src_buffer));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_and_fill_buffer_08009768",
                "param_1": "src_buffer",
                "param_2": "dest_buffer",
                "param_3": "num_bytes",
                "puVar2": "src_ptr",
                "puVar3": "dest_ptr",
                "uVar4": "current_byte",
                "cVar1": "current_char"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "expand_and_copy_data_080097cc",
            "code": "\nundefined4 expandAndCopyData_080097cc(undefined4 *destination,int *source,int *params)\n\n{\n  int sourceOffset;\n  uint dataSize;\n  int newDataPtr;\n  int sourceSize;\n  uint sourceCapacity;\n  uint dataLength;\n  undefined4 *nextDataPtr;\n  undefined4 *currentDataPtr;\n  undefined4 dataValue;\n  \n  if (params[2] != 0) {\n    sourceOffset = *source;\n    sourceCapacity = source[2];\n    currentDataPtr = (undefined4 *)*params;\n    do {\n      do {\n        nextDataPtr = currentDataPtr + 2;\n        dataValue = *currentDataPtr;\n        dataLength = currentDataPtr[1];\n        currentDataPtr = nextDataPtr;\n      } while (dataLength == 0);\n      dataSize = dataLength;\n      if ((sourceCapacity <= dataLength) && (dataSize = sourceCapacity, (*(ushort *)(source + 3) & 0x480) != 0)) {\n        sourceSize = sourceOffset - source[4];\n        sourceCapacity = (source[5] * 3) / 2;\n        dataSize = dataLength + 1 + sourceSize;\n        if (sourceCapacity < dataSize) {\n          sourceCapacity = dataSize;\n        }\n        if ((int)((uint)*(ushort *)(source + 3) << 0x15) < 0) {\n          newDataPtr = _malloc_r(destination,sourceCapacity);\n          if (newDataPtr == 0) {\nLAB_08009896:\n            *destination = 0xc;\n            *(ushort *)(source + 3) = *(ushort *)(source + 3) | 0x40;\n            params[1] = 0;\n            params[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy(newDataPtr,source[4],sourceSize);\n          *(ushort *)(source + 3) = *(ushort *)(source + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          newDataPtr = _realloc_r(destination);\n          if (newDataPtr == 0) {\n            _free_r(destination,source[4]);\n            goto LAB_08009896;\n          }\n        }\n        sourceOffset = newDataPtr + sourceSize;\n        source[5] = sourceCapacity;\n        source[4] = newDataPtr;\n        *source = sourceOffset;\n        source[2] = sourceCapacity - sourceSize;\n        dataSize = dataLength;\n      }\n      memmove(sourceOffset,dataValue,dataSize);\n      sourceSize = params[2];\n      sourceCapacity = source[2] - dataSize;\n      sourceOffset = *source + dataSize;\n      source[2] = sourceCapacity;\n      *source = sourceOffset;\n      params[2] = sourceSize - dataLength;\n    } while (sourceSize - dataLength != 0);\n  }\n  params[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "expand_and_copy_data_080097cc",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "params",
                "iVar1": "sourceOffset",
                "uVar2": "dataSize",
                "iVar3": "newDataPtr",
                "iVar4": "sourceSize",
                "uVar5": "sourceCapacity",
                "uVar6": "dataLength",
                "puVar7": "nextDataPtr",
                "puVar8": "currentDataPtr",
                "uVar9": "dataValue"
            },
            "calling": [
                "_svfprintf_r"
            ],
            "called": [
                "memcpy",
                "_malloc_r",
                "memmove",
                "_free_r",
                "_realloc_r"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_data_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateData_080098c0(int flag,undefined4 value,undefined4 data1,undefined4 data2)\n\n{\n  undefined *dataPtr;\n  undefined4 returnValue;\n  uint bitMask;\n  uint count;\n  \n  __retarget_lock_acquire_recursive(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  dataPtr = DAT_20000168;\n  count = *(uint *)(DAT_20000168 + 4);\n  if ((int)count < 0x20) {\n    if (flag != 0) {\n      *(undefined4 *)(DAT_20000168 + count * 4 + 0x88) = data1;\n      bitMask = 1 << (count & 0xff);\n      *(uint *)(dataPtr + 0x188) = *(uint *)(dataPtr + 0x188) | bitMask;\n      *(undefined4 *)(dataPtr + count * 4 + 0x108) = data2;\n      if (flag == 2) {\n        *(uint *)(dataPtr + 0x18c) = bitMask | *(uint *)(dataPtr + 0x18c);\n      }\n    }\n    *(uint *)(dataPtr + 4) = count + 1;\n    returnValue = DAT_20000448;\n    *(undefined4 *)(dataPtr + (count + 2) * 4) = value;\n    __retarget_lock_release_recursive(returnValue);\n    returnValue = 0;\n  }\n  else {\n    __retarget_lock_release_recursive(DAT_20000448);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_data_080098c0",
                "param_1": "flag",
                "param_2": "value",
                "param_3": "data1",
                "param_4": "data2",
                "puVar1": "dataPtr",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "count"
            },
            "calling": [
                "register_fini"
            ],
            "called": [
                "__retarget_lock_acquire_recursive",
                "__retarget_lock_release_recursive"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "allocate_memory_08009980",
            "code": "\nundefined4 * allocate_memory_08009980(undefined4 size,int element_size,int num_elements)\n\n{\n  undefined4 *allocated_memory;\n  uint adjusted_size;\n  undefined4 *initialized_memory;\n  \n  allocated_memory = (undefined4 *)_malloc_r(size,num_elements * element_size);\n  if (allocated_memory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  adjusted_size = (allocated_memory[-1] & 0xfffffffc) - 4;\n  if (adjusted_size < 0x25) {\n    initialized_memory = allocated_memory;\n    if (0x13 < adjusted_size) {\n      *allocated_memory = 0;\n      allocated_memory[1] = 0;\n      if (0x1b < adjusted_size) {\n        allocated_memory[2] = 0;\n        allocated_memory[3] = 0;\n        if (adjusted_size == 0x24) {\n          allocated_memory[4] = 0;\n          allocated_memory[5] = 0;\n          initialized_memory = allocated_memory + 6;\n        }\n        else {\n          initialized_memory = allocated_memory + 4;\n        }\n        *initialized_memory = 0;\n        initialized_memory[1] = 0;\n        initialized_memory[2] = 0;\n        return allocated_memory;\n      }\n      initialized_memory = allocated_memory + 2;\n    }\n    *initialized_memory = 0;\n    initialized_memory[1] = 0;\n    initialized_memory[2] = 0;\n    return allocated_memory;\n  }\n  memset(allocated_memory,0);\n  return allocated_memory;\n}\n\n",
            "renaming": {
                "FUN_08009980": "allocate_memory_08009980",
                "param_1": "size",
                "param_2": "element_size",
                "param_3": "num_elements",
                "puVar1": "allocated_memory",
                "uVar2": "adjusted_size",
                "puVar3": "initialized_memory"
            },
            "calling": [
                "_Balloc"
            ],
            "called": [
                "_malloc_r",
                "memset"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "copy_memory_08009a18",
            "code": "\nvoid copyMemory_08009a18(undefined4 *destination,undefined4 *source,uint length)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  int iteration_count;\n  undefined *dest_byte_ptr;\n  undefined4 *src_byte_ptr;\n  uint remaining_length;\n  uint remaining_length_mod_16;\n  \n  if ((source < destination) && (src_ptr = (undefined4 *)((int)source + length), destination < src_ptr)) {\n    dest_byte_ptr = (undefined *)((int)destination + length);\n    if (length != 0) {\n      do {\n        src_ptr = (undefined4 *)((int)src_ptr + -1);\n        dest_byte_ptr = dest_byte_ptr + -1;\n        *dest_byte_ptr = *(undefined *)src_ptr;\n      } while (source != src_ptr);\n    }\n  }\n  else {\n    remaining_length_mod_16 = length;\n    if (0xf < length) {\n      if ((((uint)destination | (uint)source) & 3) != 0) goto LAB_08009abc;\n      src_ptr = source + 4;\n      dest_ptr = destination + 4;\n      do {\n        src_byte_ptr = src_ptr + 4;\n        dest_ptr[-4] = src_ptr[-4];\n        dest_ptr[-3] = src_ptr[-3];\n        dest_ptr[-2] = src_ptr[-2];\n        dest_ptr[-1] = src_ptr[-1];\n        src_ptr = src_byte_ptr;\n        dest_ptr = dest_ptr + 4;\n      } while (src_byte_ptr != (undefined4 *)((int)source + (length - 0x10 & 0xfffffff0) + 0x20));\n      iteration_count = (length - 0x10 >> 4) + 1;\n      remaining_length_mod_16 = length & 0xf;\n      source = source + iteration_count * 4;\n      destination = destination + iteration_count * 4;\n      if (3 < remaining_length_mod_16) {\n        src_ptr = destination + -1;\n        remaining_length = remaining_length_mod_16;\n        dest_ptr = source;\n        do {\n          remaining_length = remaining_length - 4;\n          src_ptr = src_ptr + 1;\n          *src_ptr = *dest_ptr;\n          dest_ptr = dest_ptr + 1;\n        } while (3 < remaining_length);\n        iteration_count = (remaining_length_mod_16 - 4 & 0xfffffffc) + 4;\n        destination = (undefined4 *)((int)destination + iteration_count);\n        source = (undefined4 *)((int)source + iteration_count);\n        remaining_length_mod_16 = length & 3;\n      }\n    }\n    length = remaining_length_mod_16;\n    if (remaining_length_mod_16 != 0) {\nLAB_08009abc:\n      dest_byte_ptr = (undefined *)((int)destination + -1);\n      src_ptr = source;\n      do {\n        dest_ptr = (undefined4 *)((int)src_ptr + 1);\n        dest_byte_ptr = dest_byte_ptr + 1;\n        *dest_byte_ptr = *(undefined *)src_ptr;\n        src_ptr = dest_ptr;\n      } while (dest_ptr != (undefined4 *)(length + (int)source));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "copy_memory_08009a18",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr",
                "iVar3": "iteration_count",
                "puVar4": "dest_byte_ptr",
                "puVar5": "src_byte_ptr",
                "uVar6": "remaining_length",
                "uVar7": "remaining_length_mod_16"
            },
            "calling": [
                "__ssprint_r",
                "_realloc_r"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_memory_08009adc",
            "code": "\nint * allocate_memory_08009adc(undefined4 *param_ptr,int *ptr,uint size)\n\n{\n  int *new_ptr;\n  int offset;\n  int *old_ptr;\n  uint temp;\n  int offset2;\n  uint value;\n  int *temp_ptr;\n  uint aligned_size;\n  uint old_size;\n  uint new_size;\n  int end_addr;\n  \n  if (ptr == (int *)0x0) {\n    old_ptr = (int *)_malloc_r(param_ptr,size);\n    return old_ptr;\n  }\n  __malloc_lock();\n  value = ptr[-1];\n  old_size = value & 0xfffffffc;\n  old_ptr = ptr + -2;\n  if (size + 0xb < 0x17) {\n    aligned_size = 0x10;\n  }\n  else {\n    aligned_size = size + 0xb & 0xfffffff8;\n    if ((int)aligned_size < 0) goto LAB_08009b8e;\n  }\n  if (aligned_size < size) {\nLAB_08009b8e:\n    *param_ptr = 0xc;\n    return (int *)0x0;\n  }\n  end_addr = (int)old_ptr + old_size;\n  new_size = old_size;\n  if ((int)old_size < (int)aligned_size) {\n    if (DAT_20000454 == end_addr) {\n      end_addr = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + old_size;\n      if ((int)(aligned_size + 0x10) <= end_addr) {\n        DAT_20000454 = (int)old_ptr + aligned_size;\n        *(uint *)(DAT_20000454 + 4) = end_addr - aligned_size | 1;\n        ptr[-1] = aligned_size | ptr[-1] & 1U;\n        __malloc_unlock(param_ptr);\n        return ptr;\n      }\n      if (-1 < (int)(value << 0x1f)) {\n        new_ptr = (int *)((int)old_ptr - ptr[-2]);\n        value = new_ptr[1] & 0xfffffffc;\n        if ((int)(aligned_size + 0x10) <= (int)(end_addr + value)) {\n          offset2 = new_ptr[3];\n          old_ptr = new_ptr + 2;\n          offset = *old_ptr;\n          old_size = old_size - 4;\n          *(int *)(offset + 0xc) = offset2;\n          *(int *)(offset2 + 8) = offset;\n          if (old_size < 0x25) {\n            offset = *ptr;\n            temp_ptr = old_ptr;\n            if (0x13 < old_size) {\n              new_ptr[2] = offset;\n              new_ptr[3] = ptr[1];\n              offset = ptr[2];\n              if (old_size < 0x1c) {\n                ptr = ptr + 2;\n                temp_ptr = new_ptr + 4;\n              }\n              else {\n                new_ptr[4] = offset;\n                new_ptr[5] = ptr[3];\n                offset = ptr[4];\n                if (old_size == 0x24) {\n                  new_ptr[6] = offset;\n                  new_ptr[7] = ptr[5];\n                  offset = ptr[6];\n                  ptr = ptr + 6;\n                  temp_ptr = new_ptr + 8;\n                }\n                else {\n                  ptr = ptr + 4;\n                  temp_ptr = new_ptr + 6;\n                }\n              }\n            }\n            *temp_ptr = offset;\n            temp_ptr[1] = ptr[1];\n            temp_ptr[2] = ptr[2];\n          }\n          else {\n            memmove(old_ptr,ptr);\n          }\n          DAT_20000454 = (int)new_ptr + aligned_size;\n          *(uint *)(DAT_20000454 + 4) = (end_addr + value) - aligned_size | 1;\n          new_ptr[1] = aligned_size | new_ptr[1] & 1U;\n          __malloc_unlock(param_ptr);\n          return old_ptr;\n        }\nLAB_08009bb0:\n        new_size = old_size + value;\n        if ((int)aligned_size <= (int)new_size) {\n          offset2 = new_ptr[3];\n          temp_ptr = new_ptr + 2;\n          offset = *temp_ptr;\n          *(int *)(offset + 0xc) = offset2;\n          end_addr = (int)new_ptr + new_size;\n          *(int *)(offset2 + 8) = offset;\n          old_ptr = new_ptr;\n          if (old_size - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          memmove(temp_ptr,ptr);\n          ptr = temp_ptr;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(end_addr + 4) & 0xfffffffe) + end_addr + 4) << 0x1f) {\n        temp = *(uint *)(end_addr + 4) & 0xfffffffc;\n        new_size = old_size + temp;\n        if ((int)new_size < (int)aligned_size) {\n          if ((int)(value << 0x1f) < 0) goto LAB_08009b36;\n          new_ptr = (int *)((int)old_ptr - ptr[-2]);\n          value = new_ptr[1] & 0xfffffffc;\n          new_size = temp + value + old_size;\n          if ((int)new_size < (int)aligned_size) goto LAB_08009bb0;\n          offset = *(int *)(end_addr + 8);\n          end_addr = *(int *)(end_addr + 0xc);\n          *(int *)(offset + 0xc) = end_addr;\n          *(int *)(end_addr + 8) = offset;\n          temp_ptr = new_ptr + 2;\n          offset = *temp_ptr;\n          offset2 = new_ptr[3];\n          *(int *)(offset + 0xc) = offset2;\n          end_addr = (int)new_ptr + new_size;\n          *(int *)(offset2 + 8) = offset;\n          old_ptr = new_ptr;\n          if (0x24 < old_size - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          old_size = old_size - 4;\n          offset = *ptr;\n          new_ptr = temp_ptr;\n          if (0x13 < old_size) {\n            old_ptr[2] = offset;\n            old_ptr[3] = ptr[1];\n            offset = ptr[2];\n            if (old_size < 0x1c) {\n              ptr = ptr + 2;\n              new_ptr = old_ptr + 4;\n            }\n            else {\n              old_ptr[4] = offset;\n              old_ptr[5] = ptr[3];\n              offset = ptr[4];\n              if (old_size == 0x24) {\n                old_ptr[6] = offset;\n                old_ptr[7] = ptr[5];\n                offset = ptr[6];\n                ptr = ptr + 6;\n                new_ptr = old_ptr + 8;\n              }\n              else {\n                ptr = ptr + 4;\n                new_ptr = old_ptr + 6;\n              }\n            }\n          }\n          *new_ptr = offset;\n          new_ptr[1] = ptr[1];\n          new_ptr[2] = ptr[2];\n          ptr = temp_ptr;\n        }\n        else {\n          offset = *(int *)(end_addr + 8);\n          offset2 = *(int *)(end_addr + 0xc);\n          *(int *)(offset + 0xc) = offset2;\n          end_addr = (int)old_ptr + new_size;\n          *(int *)(offset2 + 8) = offset;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(value << 0x1f)) {\n        new_ptr = (int *)((int)old_ptr - ptr[-2]);\n        value = new_ptr[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    new_ptr = (int *)_malloc_r(param_ptr,size);\n    if (new_ptr != (int *)0x0) {\n      if ((int *)((ptr[-1] & 0xfffffffeU) + (int)old_ptr) == new_ptr + -2) {\n        new_size = old_size + (new_ptr[-1] & 0xfffffffcU);\n        end_addr = (int)old_ptr + new_size;\n        goto LAB_08009c00;\n      }\n      old_size = old_size - 4;\n      if (old_size < 0x25) {\n        end_addr = *ptr;\n        old_ptr = ptr;\n        temp_ptr = new_ptr;\n        if (0x13 < old_size) {\n          *new_ptr = end_addr;\n          new_ptr[1] = ptr[1];\n          if (old_size < 0x1c) {\n            end_addr = ptr[2];\n            old_ptr = ptr + 2;\n            temp_ptr = new_ptr + 2;\n          }\n          else {\n            new_ptr[2] = ptr[2];\n            new_ptr[3] = ptr[3];\n            if (old_size == 0x24) {\n              new_ptr[4] = ptr[4];\n              new_ptr[5] = ptr[5];\n              end_addr = ptr[6];\n              old_ptr = ptr + 6;\n              temp_ptr = new_ptr + 6;\n            }\n            else {\n              end_addr = ptr[4];\n              old_ptr = ptr + 4;\n              temp_ptr = new_ptr + 4;\n            }\n          }\n        }\n        *temp_ptr = end_addr;\n        temp_ptr[1] = old_ptr[1];\n        temp_ptr[2] = old_ptr[2];\n      }\n      else {\n        memmove(new_ptr,ptr);\n      }\n      _free_r(param_ptr,ptr);\n    }\n    __malloc_unlock(param_ptr);\n    ptr = new_ptr;\n  }\n  else {\nLAB_08009c00:\n    if (new_size - aligned_size < 0x10) {\n      old_ptr[1] = old_ptr[1] & 1U | new_size;\n      *(uint *)(end_addr + 4) = *(uint *)(end_addr + 4) | 1;\n    }\n    else {\n      old_ptr[1] = old_ptr[1] & 1U | aligned_size;\n      *(uint *)((int)old_ptr + aligned_size + 4) = new_size - aligned_size | 1;\n      *(uint *)(end_addr + 4) = *(uint *)(end_addr + 4) | 1;\n      _free_r(param_ptr,(int)old_ptr + aligned_size + 8);\n    }\n    __malloc_unlock(param_ptr);\n  }\n  return ptr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_memory_08009adc",
                "param_1": "param_ptr",
                "param_2": "ptr",
                "param_3": "size",
                "piVar1": "new_ptr",
                "iVar2": "offset",
                "piVar3": "old_ptr",
                "uVar4": "temp",
                "iVar5": "offset2",
                "uVar6": "value",
                "piVar7": "temp_ptr",
                "uVar8": "aligned_size",
                "uVar9": "old_size",
                "uVar10": "new_size",
                "iVar11": "end_addr"
            },
            "calling": [
                "__ssprint_r"
            ],
            "called": [
                "_malloc_r",
                "memmove",
                "__malloc_unlock",
                "_free_r",
                "__malloc_lock"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "__libc_init_array",
                "frame_dummy",
                "__do_global_dtors_aux"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 151820,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_08000978",
            "FUN_08000988",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08000fc8",
            "FUN_08000fd0",
            "FUN_08000ff4",
            "FUN_08001030",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_080011ec",
            "FUN_0800121c",
            "FUN_080014f0",
            "FUN_0800151c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08001762",
            "FUN_0800177c",
            "FUN_080017b4",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08001ab0",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d3c",
            "FUN_08002d98",
            "FUN_08003260",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_08003568",
            "FUN_080035a4",
            "FUN_0800360c",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_080036f8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_0800438a",
            "FUN_08004436",
            "FUN_080046ec",
            "FUN_0800491c",
            "FUN_080049cc",
            "FUN_08004ae0",
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08004e6c",
            "FUN_08004e74",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08004f2c",
            "FUN_08004f3c",
            "FUN_08004f60",
            "FUN_08004f78",
            "FUN_08005224",
            "FUN_080052a0",
            "FUN_08005348",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_08005598",
            "FUN_080055f4",
            "FUN_08005674",
            "FUN_08005680",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_08005728",
            "FUN_08005780",
            "FUN_080057e8",
            "FUN_08005838",
            "FUN_080059f0",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_080078c0",
            "FUN_080079e8",
            "FUN_0800884c",
            "FUN_080088ec",
            "FUN_08008ad4",
            "FUN_08008af8",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_080090c0",
            "FUN_0800910c",
            "FUN_08009120",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_080093a4",
            "FUN_08009444",
            "FUN_080094f8",
            "FUN_08009530",
            "FUN_08009630",
            "FUN_080096e0",
            "FUN_08009744",
            "FUN_08009768",
            "FUN_080097cc",
            "FUN_080098c0",
            "FUN_08009980",
            "FUN_08009a18",
            "FUN_08009adc"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c"
        ]
    ],
    "locked_functions": []
}