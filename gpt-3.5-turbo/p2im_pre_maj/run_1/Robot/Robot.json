{
    "functions": {
        "FUN_08000110": {
            "entrypoint": "0x08000110",
            "current_name": "initialize_data_08000110",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800011c) */\n\nundefined4 initializeData_08000110(undefined4 inputData)\n\n{\n  if ((char)DAT_200009c8 == '\\0') {\n    DAT_200009c8._0_1_ = '\\x01';\n  }\n  return inputData;\n}\n\n",
            "renaming": {
                "FUN_08000110": "initialize_data_08000110",
                "param_1": "inputData"
            },
            "calling": [],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000134": {
            "entrypoint": "0x08000134",
            "current_name": "concatenate_parameters_08000134",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0800013a) */\n\nundefined8 concatenate_parameters_08000134(undefined4 first_parameter,undefined4 second_parameter)\n\n{\n  return CONCAT44(second_parameter,first_parameter);\n}\n\n",
            "renaming": {
                "FUN_08000134": "concatenate_parameters_08000134",
                "param_1": "first_parameter",
                "param_2": "second_parameter"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_08009e68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000158": {
            "entrypoint": "0x08000158",
            "current_name": "unsigned_long_long_binary_operation_08000158",
            "code": "\nulonglong unsignedLongLongBinaryOperation_08000158(uint operand1,uint operand2,uint operand3,uint operand4)\n\n{\n  int shiftCount1;\n  byte carryFlag;\n  uint temp1;\n  uint operand2Modified;\n  uint temp2;\n  uint result1;\n  uint result2;\n  int shiftCount2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  uint temp6;\n  bool isTrue;\n  bool isFalse;\n  bool isOverflow;\n  \n  result1 = operand4 ^ 0x80000000;\n  temp3 = operand2 << 1;\n  operand4 = operand4 << 1;\n  isTrue = ((operand2 ^ result1) & 0x7fffffff) == 0;\n  isFalse = isTrue && operand1 == operand3;\n  if (!isTrue || operand1 != operand3) {\n    isFalse = (temp3 | operand1) == 0;\n  }\n  if (!isFalse) {\n    isFalse = (operand4 | operand3) == 0;\n  }\n  shiftCount2 = (int)temp3 >> 0x15;\n  if (!isFalse) {\n    isFalse = shiftCount2 == -1;\n  }\n  shiftCount1 = (int)operand4 >> 0x15;\n  if (!isFalse) {\n    isFalse = shiftCount1 == -1;\n  }\n  if (isFalse) {\n    if (shiftCount2 == -1 || shiftCount1 == -1) {\n      temp3 = result1;\n      temp5 = operand3;\n      if (shiftCount2 == -1) {\n        temp3 = operand2;\n        temp5 = operand1;\n      }\n      if (shiftCount2 != -1 || shiftCount1 != -1) {\n        operand3 = temp5;\n        result1 = temp3;\n      }\n      isFalse = (temp5 | temp3 << 0xc) == 0;\n      if (isFalse) {\n        isFalse = (operand3 | result1 << 0xc) == 0;\n      }\n      if (isFalse) {\n        isFalse = temp3 == result1;\n      }\n      if (!isFalse) {\n        temp3 = temp3 | 0x80000;\n      }\n      return CONCAT44(temp3,temp5);\n    }\n    if (((operand2 ^ result1) & 0x7fffffff) != 0 || operand1 != operand3) {\n      if ((temp3 | operand1) == 0) {\n        operand1 = operand3;\n        operand2 = result1;\n      }\n      return CONCAT44(operand2,operand1);\n    }\n    if (operand2 != result1) {\n      return 0;\n    }\n    if (temp3 >> 0x15 == 0) {\n      isFalse = (operand1 & 0x80000000) != 0;\n      result1 = operand2 * 2 + (uint)isFalse;\n      if (CARRY4(operand2,operand2) || CARRY4(operand2 * 2,(uint)isFalse)) {\n        result1 = result1 | 0x80000000;\n      }\n      return CONCAT44(result1,operand1 << 1);\n    }\n    if (temp3 < 0xffc00000) {\n      return CONCAT44(operand2 + 0x100000,operand1);\n    }\n    operand2 = operand2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(operand2 | 0x7ff00000) << 0x20;\n  }\n  temp3 = temp3 >> 0x15;\n  operand4 = operand4 >> 0x15;\n  temp5 = operand4 - temp3;\n  isFalse = temp5 != 0;\n  if (operand4 < temp3) {\n    temp5 = -temp5;\n  }\n  temp4 = operand1;\n  result2 = operand2;\n  if (isFalse && temp3 <= operand4) {\n    temp3 = temp3 + temp5;\n    temp4 = operand3;\n    result2 = result1;\n    operand3 = operand1;\n    result1 = operand2;\n  }\n  if (0x36 < temp5) {\n    return CONCAT44(result2,temp4);\n  }\n  operand2Modified = result2 & 0xfffff | 0x100000;\n  if ((result2 & 0x80000000) != 0) {\n    isFalse = temp4 != 0;\n    temp4 = -temp4;\n    operand2Modified = -operand2Modified - (uint)isFalse;\n  }\n  result2 = result1 & 0xfffff | 0x100000;\n  if ((result1 & 0x80000000) != 0) {\n    isFalse = operand3 != 0;\n    operand3 = -operand3;\n    result2 = -result2 - (uint)isFalse;\n  }\n  if (temp3 == temp5) {\n    result2 = result2 ^ 0x100000;\n    if (temp3 == 0) {\n      operand2Modified = operand2Modified ^ 0x100000;\n      temp3 = 1;\n    }\n    else {\n      temp5 = temp5 - 1;\n    }\n  }\n  result1 = -temp5 + 0x20;\n  if ((int)temp5 < 0x21) {\n    temp6 = operand3 << (result1 & 0xff);\n    operand3 = operand3 >> (temp5 & 0xff);\n    temp1 = temp4 + operand3;\n    temp2 = result2 << (result1 & 0xff);\n    result1 = temp1 + temp2;\n    operand2Modified = operand2Modified + CARRY4(temp4,operand3) + ((int)result2 >> (temp5 & 0xff)) +\n            (uint)CARRY4(temp1,temp2);\n  }\n  else {\n    temp6 = result2 << (-temp5 + 0x40 & 0xff);\n    if (operand3 != 0) {\n      temp6 = temp6 | 2;\n    }\n    result2 = (int)result2 >> (temp5 - 0x20 & 0xff);\n    result1 = temp4 + result2;\n    operand2Modified = operand2Modified + ((int)result2 >> 0x1f) + (uint)CARRY4(temp4,result2);\n  }\n  operand2 = operand2Modified & 0x80000000;\n  temp5 = operand2Modified;\n  if ((int)operand2Modified < 0) {\n    isFalse = temp6 == 0;\n    temp6 = -temp6;\n    temp5 = -result1;\n    result1 = -(uint)!isFalse - result1;\n    temp5 = -(uint)(isFalse <= temp5) - operand2Modified;\n  }\n  if (0xfffff < temp5) {\n    temp4 = temp3 - 1;\n    if (0x1fffff < temp5) {\n      temp4 = temp5 & 1;\n      temp5 = temp5 >> 1;\n      carryFlag = (byte)result1;\n      result1 = (uint)(temp4 != 0) << 0x1f | result1 >> 1;\n      temp6 = (uint)(carryFlag & 1) << 0x1f | temp6 >> 1;\n      temp4 = temp3;\n      if (0xffbfffff < temp3 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    isFalse = 0x7fffffff < temp6;\n    if (temp6 == 0x80000000) {\n      isFalse = (result1 & 1) != 0;\n    }\n    return CONCAT44(temp5 + temp4 * 0x100000 + (uint)CARRY4(result1,(uint)isFalse) | operand2,\n                    result1 + isFalse);\n  }\n  isTrue = (temp6 & 0x80000000) != 0;\n  temp6 = temp6 << 1;\n  temp4 = result1 * 2;\n  isFalse = CARRY4(result1,result1);\n  result1 = result1 * 2 + (uint)isTrue;\n  temp5 = temp5 * 2 + (uint)(isFalse || CARRY4(temp4,(uint)isTrue));\n  temp4 = temp3 - 2;\n  if ((temp5 & 0x100000) != 0) goto LAB_08000268;\n  result2 = result1;\n  temp3 = temp5;\n  if (temp5 == 0) {\n    result2 = 0;\n    temp3 = result1;\n  }\n  shiftCount2 = LZCOUNT(temp3);\n  if (temp5 == 0) {\n    shiftCount2 = shiftCount2 + 0x20;\n  }\n  temp5 = shiftCount2 - 0xb;\n  isOverflow = SBORROW4(temp5,0x20);\n  result1 = shiftCount2 - 0x2b;\n  isFalse = (int)result1 < 0;\n  isTrue = result1 == 0;\n  if ((int)temp5 < 0x20) {\n    isOverflow = SCARRY4(result1,0xc);\n    shiftCount2 = shiftCount2 + -0x1f;\n    isFalse = shiftCount2 < 0;\n    isTrue = shiftCount2 == 0;\n    result1 = temp5;\n    if (!isTrue && isFalse == isOverflow) {\n      result2 = temp3 << (temp5 & 0xff);\n      temp3 = temp3 >> (0xcU - shiftCount2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isTrue || isFalse != isOverflow) {\n    temp6 = 0x20 - result1;\n  }\n  temp3 = temp3 << (result1 & 0xff);\n  if (isTrue || isFalse != isOverflow) {\n    temp3 = temp3 | result2 >> (temp6 & 0xff);\n  }\n  if (isTrue || isFalse != isOverflow) {\n    result2 = result2 << (result1 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)temp5 <= (int)temp4) {\n    return CONCAT44(temp3 + (temp4 - temp5) * 0x100000 | operand2,result2);\n  }\n  result1 = ~(temp4 - temp5);\n  if ((int)result1 < 0x1f) {\n    shiftCount2 = result1 - 0x13;\n    if (shiftCount2 != 0 && shiftCount2 < 0 == SCARRY4(result1 - 0x1f,0xc)) {\n      return CONCAT44(operand2Modified,result2 >> (0x20 - (0xcU - shiftCount2) & 0xff) | temp3 << (0xcU - shiftCount2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result1 = result1 + 1;\n    return CONCAT44(operand2 | temp3 >> (result1 & 0xff),\n                    result2 >> (result1 & 0xff) | temp3 << (0x20 - result1 & 0xff));\n  }\n  return CONCAT44(operand2Modified,temp3 >> (result1 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000158": "unsigned_long_long_binary_operation_08000158",
                "param_1": "operand1",
                "param_2": "operand2",
                "param_3": "operand3",
                "param_4": "operand4",
                "iVar1": "shiftCount1",
                "bVar2": "carryFlag",
                "uVar3": "temp1",
                "uVar4": "operand2Modified",
                "uVar5": "temp2",
                "uVar6": "result1",
                "uVar7": "result2",
                "iVar8": "shiftCount2",
                "uVar9": "temp3",
                "uVar10": "temp4",
                "uVar11": "temp5",
                "uVar12": "temp6",
                "bVar13": "isTrue",
                "bVar14": "isFalse",
                "bVar15": "isOverflow"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005e9c",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800015c": {
            "entrypoint": "0x0800015c",
            "current_name": "calculate_result_0800015c",
            "code": "\nulonglong calculate_result_0800015c(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  int shift_amount_1;\n  byte carry_flag_1;\n  uint temp_1;\n  uint shifted_value_1;\n  uint temp_2;\n  int shift_amount_2;\n  uint shifted_input_2;\n  uint result_1;\n  uint shifted_input_4;\n  uint result_2;\n  uint carry_toggle;\n  uint result_3;\n  bool is_equal;\n  bool is_zero;\n  bool borrow_flag;\n  \n  shifted_input_2 = input_2 << 1;\n  shifted_input_4 = input_4 << 1;\n  is_equal = ((input_2 ^ input_4) & 0x7fffffff) == 0;\n  is_zero = is_equal && input_1 == input_3;\n  if (!is_equal || input_1 != input_3) {\n    is_zero = (shifted_input_2 | input_1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = (shifted_input_4 | input_3) == 0;\n  }\n  shift_amount_2 = (int)shifted_input_2 >> 0x15;\n  if (!is_zero) {\n    is_zero = shift_amount_2 == -1;\n  }\n  shift_amount_1 = (int)shifted_input_4 >> 0x15;\n  if (!is_zero) {\n    is_zero = shift_amount_1 == -1;\n  }\n  if (is_zero) {\n    if (shift_amount_2 == -1 || shift_amount_1 == -1) {\n      shifted_input_4 = input_4;\n      shifted_input_2 = input_3;\n      if (shift_amount_2 == -1) {\n        shifted_input_4 = input_2;\n        shifted_input_2 = input_1;\n      }\n      if (shift_amount_2 != -1 || shift_amount_1 != -1) {\n        input_3 = shifted_input_2;\n        input_4 = shifted_input_4;\n      }\n      is_zero = (shifted_input_2 | shifted_input_4 << 0xc) == 0;\n      if (is_zero) {\n        is_zero = (input_3 | input_4 << 0xc) == 0;\n      }\n      if (is_zero) {\n        is_zero = shifted_input_4 == input_4;\n      }\n      if (!is_zero) {\n        shifted_input_4 = shifted_input_4 | 0x80000;\n      }\n      return CONCAT44(shifted_input_4,shifted_input_2);\n    }\n    if (((input_2 ^ input_4) & 0x7fffffff) != 0 || input_1 != input_3) {\n      if ((shifted_input_2 | input_1) == 0) {\n        input_1 = input_3;\n        input_2 = input_4;\n      }\n      return CONCAT44(input_2,input_1);\n    }\n    if (input_2 != input_4) {\n      return 0;\n    }\n    if (shifted_input_2 >> 0x15 == 0) {\n      is_zero = (input_1 & 0x80000000) != 0;\n      shifted_input_4 = input_2 * 2 + (uint)is_zero;\n      if (CARRY4(input_2,input_2) || CARRY4(input_2 * 2,(uint)is_zero)) {\n        shifted_input_4 = shifted_input_4 | 0x80000000;\n      }\n      return CONCAT44(shifted_input_4,input_1 << 1);\n    }\n    if (shifted_input_2 < 0xffc00000) {\n      return CONCAT44(input_2 + 0x100000,input_1);\n    }\n    input_2 = input_2 & 0x80000000;\nLAB_0800039c:\n    return (ulonglong)(input_2 | 0x7ff00000) << 0x20;\n  }\n  shifted_input_2 = shifted_input_2 >> 0x15;\n  shifted_input_4 = shifted_input_4 >> 0x15;\n  result_2 = shifted_input_4 - shifted_input_2;\n  is_zero = result_2 != 0;\n  if (shifted_input_4 < shifted_input_2) {\n    result_2 = -result_2;\n  }\n  result_1 = input_1;\n  temp_2 = input_2;\n  if (is_zero && shifted_input_2 <= shifted_input_4) {\n    shifted_input_2 = shifted_input_2 + result_2;\n    result_1 = input_3;\n    temp_2 = input_4;\n    input_3 = input_1;\n    input_4 = input_2;\n  }\n  if (0x36 < result_2) {\n    return CONCAT44(temp_2,result_1);\n  }\n  shifted_input_4 = temp_2 & 0xfffff | 0x100000;\n  if ((temp_2 & 0x80000000) != 0) {\n    is_zero = result_1 != 0;\n    result_1 = -result_1;\n    shifted_input_4 = -shifted_input_4 - (uint)is_zero;\n  }\n  temp_2 = input_4 & 0xfffff | 0x100000;\n  if ((input_4 & 0x80000000) != 0) {\n    is_zero = input_3 != 0;\n    input_3 = -input_3;\n    temp_2 = -temp_2 - (uint)is_zero;\n  }\n  if (shifted_input_2 == result_2) {\n    temp_2 = temp_2 ^ 0x100000;\n    if (shifted_input_2 == 0) {\n      shifted_input_4 = shifted_input_4 ^ 0x100000;\n      shifted_input_2 = 1;\n    }\n    else {\n      result_2 = result_2 - 1;\n    }\n  }\n  result_3 = -result_2 + 0x20;\n  if ((int)result_2 < 0x21) {\n    carry_toggle = input_3 << (result_3 & 0xff);\n    input_3 = input_3 >> (result_2 & 0xff);\n    temp_1 = result_1 + input_3;\n    shifted_value_1 = temp_2 << (result_3 & 0xff);\n    result_3 = temp_1 + shifted_value_1;\n    shifted_input_4 = shifted_input_4 + CARRY4(result_1,input_3) + ((int)temp_2 >> (result_2 & 0xff)) +\n            (uint)CARRY4(temp_1,shifted_value_1);\n  }\n  else {\n    carry_toggle = temp_2 << (-result_2 + 0x40 & 0xff);\n    if (input_3 != 0) {\n      carry_toggle = carry_toggle | 2;\n    }\n    temp_2 = (int)temp_2 >> (result_2 - 0x20 & 0xff);\n    result_3 = result_1 + temp_2;\n    shifted_input_4 = shifted_input_4 + ((int)temp_2 >> 0x1f) + (uint)CARRY4(result_1,temp_2);\n  }\n  input_2 = shifted_input_4 & 0x80000000;\n  result_2 = shifted_input_4;\n  if ((int)shifted_input_4 < 0) {\n    is_zero = carry_toggle == 0;\n    carry_toggle = -carry_toggle;\n    result_2 = -result_3;\n    result_3 = -(uint)!is_zero - result_3;\n    result_2 = -(uint)(is_zero <= result_2) - shifted_input_4;\n  }\n  if (0xfffff < result_2) {\n    result_1 = shifted_input_2 - 1;\n    if (0x1fffff < result_2) {\n      shifted_input_4 = result_2 & 1;\n      result_2 = result_2 >> 1;\n      carry_flag_1 = (byte)result_3;\n      result_3 = (uint)(shifted_input_4 != 0) << 0x1f | result_3 >> 1;\n      carry_toggle = (uint)(carry_flag_1 & 1) << 0x1f | carry_toggle >> 1;\n      result_1 = shifted_input_2;\n      if (0xffbfffff < shifted_input_2 * 0x200000) goto LAB_0800039c;\n    }\nLAB_08000268:\n    is_zero = 0x7fffffff < carry_toggle;\n    if (carry_toggle == 0x80000000) {\n      is_zero = (result_3 & 1) != 0;\n    }\n    return CONCAT44(result_2 + result_1 * 0x100000 + (uint)CARRY4(result_3,(uint)is_zero) | input_2,\n                    result_3 + is_zero);\n  }\n  is_equal = (carry_toggle & 0x80000000) != 0;\n  carry_toggle = carry_toggle << 1;\n  result_1 = result_3 * 2;\n  is_zero = CARRY4(result_3,result_3);\n  result_3 = result_3 * 2 + (uint)is_equal;\n  result_2 = result_2 * 2 + (uint)(is_zero || CARRY4(result_1,(uint)is_equal));\n  result_1 = shifted_input_2 - 2;\n  if ((result_2 & 0x100000) != 0) goto LAB_08000268;\n  temp_2 = result_3;\n  shifted_input_2 = result_2;\n  if (result_2 == 0) {\n    temp_2 = 0;\n    shifted_input_2 = result_3;\n  }\n  shift_amount_2 = LZCOUNT(shifted_input_2);\n  if (result_2 == 0) {\n    shift_amount_2 = shift_amount_2 + 0x20;\n  }\n  result_3 = shift_amount_2 - 0xb;\n  borrow_flag = SBORROW4(result_3,0x20);\n  result_2 = shift_amount_2 - 0x2b;\n  is_zero = (int)result_2 < 0;\n  is_equal = result_2 == 0;\n  if ((int)result_3 < 0x20) {\n    borrow_flag = SCARRY4(result_2,0xc);\n    shift_amount_2 = shift_amount_2 + -0x1f;\n    is_zero = shift_amount_2 < 0;\n    is_equal = shift_amount_2 == 0;\n    result_2 = result_3;\n    if (!is_equal && is_zero == borrow_flag) {\n      temp_2 = shifted_input_2 << (result_3 & 0xff);\n      shifted_input_2 = shifted_input_2 >> (0xcU - shift_amount_2 & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (is_equal || is_zero != borrow_flag) {\n    carry_toggle = 0x20 - result_2;\n  }\n  shifted_input_2 = shifted_input_2 << (result_2 & 0xff);\n  if (is_equal || is_zero != borrow_flag) {\n    shifted_input_2 = shifted_input_2 | temp_2 >> (carry_toggle & 0xff);\n  }\n  if (is_equal || is_zero != borrow_flag) {\n    temp_2 = temp_2 << (result_2 & 0xff);\n  }\nLAB_080002e0:\n  if ((int)result_3 <= (int)result_1) {\n    return CONCAT44(shifted_input_2 + (result_1 - result_3) * 0x100000 | input_2,temp_2);\n  }\n  result_2 = ~(result_1 - result_3);\n  if ((int)result_2 < 0x1f) {\n    shift_amount_2 = result_2 - 0x13;\n    if (shift_amount_2 != 0 && shift_amount_2 < 0 == SCARRY4(result_2 - 0x1f,0xc)) {\n      return CONCAT44(shifted_input_4,temp_2 >> (0x20 - (0xcU - shift_amount_2) & 0xff) | shifted_input_2 << (0xcU - shift_amount_2 & 0xff)\n                     ) & 0x80000000ffffffff;\n    }\n    result_2 = result_2 + 1;\n    return CONCAT44(input_2 | shifted_input_2 >> (result_2 & 0xff),\n                    temp_2 >> (result_2 & 0xff) | shifted_input_2 << (0x20 - result_2 & 0xff));\n  }\n  return CONCAT44(shifted_input_4,shifted_input_2 >> (result_2 - 0x1f & 0xff)) & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_0800015c": "calculate_result_0800015c",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "iVar1": "shift_amount_1",
                "bVar2": "carry_flag_1",
                "uVar3": "temp_1",
                "uVar4": "shifted_value_1",
                "uVar5": "temp_2",
                "iVar6": "shift_amount_2",
                "uVar7": "shifted_input_2",
                "uVar8": "result_1",
                "uVar9": "shifted_input_4",
                "uVar10": "result_2",
                "uVar11": "carry_toggle",
                "uVar12": "result_3",
                "bVar13": "is_equal",
                "bVar14": "is_zero",
                "bVar15": "borrow_flag"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003d4": {
            "entrypoint": "0x080003d4",
            "current_name": "revised_function_080003d4",
            "code": "\nulonglong revisedFunction_080003d4(uint inputValue)\n\n{\n  uint result;\n  uint shiftAmount;\n  int bitCount;\n  uint shiftedBitCount;\n  uint remainingBits;\n  bool isLessThanZero;\n  bool isZero;\n  bool hasBorrow;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  result = 0;\n  bitCount = LZCOUNT(inputValue);\n  shiftedBitCount = bitCount + 0x15;\n  hasBorrow = SBORROW4(shiftedBitCount,0x20);\n  shiftAmount = bitCount - 0xb;\n  isLessThanZero = (int)shiftAmount < 0;\n  isZero = shiftAmount == 0;\n  if (shiftedBitCount < 0x20) {\n    hasBorrow = SCARRY4(shiftAmount,0xc);\n    isLessThanZero = false;\n    isZero = bitCount + 1 == 0;\n    shiftAmount = shiftedBitCount;\n    if (!isZero && hasBorrow == false) {\n      result = inputValue << shiftedBitCount;\n      inputValue = inputValue >> (0xcU - (bitCount + 1) & 0xff);\n      goto endOfFunction;\n    }\n  }\n  if (isZero || isLessThanZero != hasBorrow) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  inputValue = inputValue << (shiftAmount & 0xff);\n  if (isZero || isLessThanZero != hasBorrow) {\n    inputValue = inputValue | 0U >> (remainingBits & 0xff);\n  }\n  if (isZero || isLessThanZero != hasBorrow) {\n    result = 0 << (shiftAmount & 0xff);\n  }\nendOfFunction:\n  if (shiftedBitCount < 0x433) {\n    return CONCAT44(inputValue + (0x432 - shiftedBitCount) * 0x100000,result);\n  }\n  shiftAmount = ~(0x432 - shiftedBitCount);\n  if (0x1e < (int)shiftAmount) {\n    return (ulonglong)(inputValue >> (shiftAmount - 0x1f & 0xff));\n  }\n  bitCount = shiftAmount - 0x13;\n  if (bitCount == 0 || bitCount < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(inputValue >> (shiftAmount & 0xff),\n                    result >> (shiftAmount & 0xff) | inputValue << (0x20 - shiftAmount & 0xff));\n  }\n  return (ulonglong)(result >> (0x20 - (0xcU - bitCount) & 0xff) | inputValue << (0xcU - bitCount & 0xff));\n}\n\n",
            "renaming": {
                "FUN_080003d4": "revised_function_080003d4",
                "param_1": "inputValue",
                "uVar1": "result",
                "uVar2": "shiftAmount",
                "iVar3": "bitCount",
                "uVar4": "shiftedBitCount",
                "in_r12": "remainingBits",
                "bVar5": "isLessThanZero",
                "bVar6": "isZero",
                "bVar7": "hasBorrow",
                "LAB_080002e0": "endOfFunction"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080003f4": {
            "entrypoint": "0x080003f4",
            "current_name": "shift_and_adjust_080003f4",
            "code": "\nulonglong shift_and_adjust_080003f4(uint input)\n\n{\n  uint shifted_value;\n  uint abs_value;\n  uint shift;\n  int leading_zeros;\n  uint shifted_plus_0x15;\n  uint sign_bit;\n  uint mask;\n  bool is_negative;\n  bool is_zero;\n  bool is_carry;\n  \n  if (input == 0) {\n    return 0;\n  }\n  sign_bit = input & 0x80000000;\n  abs_value = input;\n  if ((int)sign_bit < 0) {\n    abs_value = -input;\n  }\n  shifted_value = 0;\n  leading_zeros = LZCOUNT(abs_value);\n  shifted_plus_0x15 = leading_zeros + 0x15;\n  is_carry = SBORROW4(shifted_plus_0x15,0x20);\n  shift = leading_zeros - 0xb;\n  is_negative = (int)shift < 0;\n  is_zero = shift == 0;\n  if (shifted_plus_0x15 < 0x20) {\n    is_carry = SCARRY4(shift,0xc);\n    is_negative = false;\n    is_zero = leading_zeros + 1 == 0;\n    shift = shifted_plus_0x15;\n    if (!is_zero && is_carry == false) {\n      shifted_value = abs_value << shifted_plus_0x15;\n      abs_value = abs_value >> (0xcU - (leading_zeros + 1) & 0xff);\n      goto calculation_result;\n    }\n  }\n  if (is_zero || is_negative != is_carry) {\n    mask = 0x20 - shift;\n  }\n  abs_value = abs_value << (shift & 0xff);\n  if (is_zero || is_negative != is_carry) {\n    abs_value = abs_value | 0U >> (mask & 0xff);\n  }\n  if (is_zero || is_negative != is_carry) {\n    shifted_value = 0 << (shift & 0xff);\n  }\ncalculation_result:\n  if (shifted_plus_0x15 < 0x433) {\n    return CONCAT44(abs_value + (0x432 - shifted_plus_0x15) * 0x100000 | sign_bit,shifted_value);\n  }\n  shift = ~(0x432 - shifted_plus_0x15);\n  if (0x1e < (int)shift) {\n    return CONCAT44(input,abs_value >> (shift - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leading_zeros = shift - 0x13;\n  if (leading_zeros == 0 || leading_zeros < 0 != SCARRY4(shift - 0x1f,0xc)) {\n    shift = shift + 1;\n    return CONCAT44(sign_bit | abs_value >> (shift & 0xff),\n                    shifted_value >> (shift & 0xff) | abs_value << (0x20 - shift & 0xff));\n  }\n  return CONCAT44(input,shifted_value >> (0x20 - (0xcU - leading_zeros) & 0xff) | abs_value << (0xcU - leading_zeros & 0xff))\n         & 0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_080003f4": "shift_and_adjust_080003f4",
                "param_1": "input",
                "uVar1": "shifted_value",
                "uVar2": "abs_value",
                "uVar3": "shift",
                "iVar4": "leading_zeros",
                "uVar5": "shifted_plus_0x15",
                "uVar6": "sign_bit",
                "in_r12": "mask",
                "bVar7": "is_negative",
                "bVar8": "is_zero",
                "bVar9": "is_carry",
                "LAB_080002e0": "calculation_result"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000418": {
            "entrypoint": "0x08000418",
            "current_name": "reverse_bits_08000418",
            "code": "\nulonglong reverseBits_08000418(uint input,undefined4 param2,undefined4 param3,uint param4)\n\n{\n  uint msbMask;\n  uint tempInput;\n  uint result;\n  uint shiftAmount;\n  uint tempShiftedInput;\n  int leadingZeros;\n  uint shiftedInput;\n  uint remainingBits;\n  bool isNegative;\n  bool isZeroInput;\n  bool hasLeadingZeros;\n  \n  tempShiftedInput = input << 1;\n  isZeroInput = tempShiftedInput == 0;\n  msbMask = (uint)((input & 0x80000000) != 0) << 0x1f;\n  shiftAmount = (uint)((int)tempShiftedInput >> 3) >> 1;\n  result = msbMask | shiftAmount;\n  input = input << 0x1d;\n  if (!isZeroInput) {\n    param4 = tempShiftedInput & 0xff000000;\n    isZeroInput = param4 == 0;\n  }\n  if (!isZeroInput) {\n    isZeroInput = param4 == 0xff000000;\n  }\n  if (!isZeroInput) {\n    return CONCAT44(result,input) ^ 0x3800000000000000;\n  }\n  if ((tempShiftedInput & 0xffffff) == 0) {\n    return CONCAT44(result,input);\n  }\n  if (param4 == 0xff000000) {\n    return CONCAT44(result,input) | 0x8000000000000;\n  }\n  tempInput = input;\n  tempShiftedInput = shiftAmount;\n  if (shiftAmount == 0) {\n    tempInput = 0;\n    tempShiftedInput = input;\n  }\n  leadingZeros = LZCOUNT(tempShiftedInput);\n  if (shiftAmount == 0) {\n    leadingZeros = leadingZeros + 0x20;\n  }\n  shiftedInput = leadingZeros - 0xb;\n  hasLeadingZeros = SBORROW4(shiftedInput,0x20);\n  shiftAmount = leadingZeros - 0x2b;\n  isZeroInput = (int)shiftAmount < 0;\n  isNegative = shiftAmount == 0;\n  if ((int)shiftedInput < 0x20) {\n    hasLeadingZeros = SCARRY4(shiftAmount,0xc);\n    leadingZeros = leadingZeros + -0x1f;\n    isZeroInput = leadingZeros < 0;\n    isNegative = leadingZeros == 0;\n    shiftAmount = shiftedInput;\n    if (!isNegative && isZeroInput == hasLeadingZeros) {\n      tempInput = tempShiftedInput << (shiftedInput & 0xff);\n      tempShiftedInput = tempShiftedInput >> (0xcU - leadingZeros & 0xff);\n      goto LAB_080002e0;\n    }\n  }\n  if (isNegative || isZeroInput != hasLeadingZeros) {\n    remainingBits = 0x20 - shiftAmount;\n  }\n  tempShiftedInput = tempShiftedInput << (shiftAmount & 0xff);\n  if (isNegative || isZeroInput != hasLeadingZeros) {\n    tempShiftedInput = tempShiftedInput | tempInput >> (remainingBits & 0xff);\n  }\n  if (isNegative || isZeroInput != hasLeadingZeros) {\n    tempInput = tempInput << (shiftAmount & 0xff);\n  }\nLAB_080002e0:\n  if ((int)shiftedInput < 0x381) {\n    return CONCAT44(tempShiftedInput + (0x380 - shiftedInput) * 0x100000 | msbMask,tempInput);\n  }\n  shiftAmount = ~(0x380 - shiftedInput);\n  if (0x1e < (int)shiftAmount) {\n    return CONCAT44(result,tempShiftedInput >> (shiftAmount - 0x1f & 0xff)) & 0x80000000ffffffff;\n  }\n  leadingZeros = shiftAmount - 0x13;\n  if (leadingZeros == 0 || leadingZeros < 0 != SCARRY4(shiftAmount - 0x1f,0xc)) {\n    shiftAmount = shiftAmount + 1;\n    return CONCAT44(msbMask | tempShiftedInput >> (shiftAmount & 0xff),\n                    tempInput >> (shiftAmount & 0xff) | tempShiftedInput << (0x20 - shiftAmount & 0xff));\n  }\n  return CONCAT44(result,tempInput >> (0x20 - (0xcU - leadingZeros) & 0xff) | tempShiftedInput << (0xcU - leadingZeros & 0xff)) &\n         0x80000000ffffffff;\n}\n\n",
            "renaming": {
                "FUN_08000418": "reverse_bits_08000418",
                "param_1": "input",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "msbMask",
                "uVar2": "tempInput",
                "uVar3": "result",
                "uVar4": "shiftAmount",
                "uVar5": "tempShiftedInput",
                "iVar6": "leadingZeros",
                "uVar7": "shiftedInput",
                "in_r12": "remainingBits",
                "bVar8": "isNegative",
                "bVar9": "isZeroInput",
                "bVar10": "hasLeadingZeros"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080004c8": {
            "entrypoint": "0x080004c8",
            "current_name": "calculate_product_and_addition_080004c8",
            "code": "\nulonglong calculateProductAndAddition_080004c8(undefined4 value1,uint value2,uint value3,uint value4)\n\n{\n  ulonglong product1;\n  longlong product2;\n  uint temp1;\n  uint temp2;\n  int result1;\n  uint result2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  bool cond1;\n  bool cond2;\n  bool cond3;\n  ulonglong combinedValue;\n  \n  combinedValue = CONCAT44(value2,value1);\n  temp4 = 0x7ff;\n  temp2 = value2 >> 0x14 & 0x7ff;\n  cond1 = temp2 == 0;\n  if (!cond1) {\n    temp3 = value4 >> 0x14 & 0x7ff;\n    cond1 = temp3 == 0;\n  }\n  if (!cond1) {\n    cond1 = temp2 == 0x7ff;\n  }\n  if (!cond1) {\n    cond1 = temp3 == 0x7ff;\n  }\n  if (cond1) {\n    combinedValue = extract_bits_080006a4();\n  }\n  temp1 = (uint)(combinedValue >> 0x20);\n  result1 = temp2 + temp3;\n  temp2 = temp1 ^ value4;\n  temp1 = temp1 & ~(temp4 << 0x15);\n  value4 = value4 & ~(temp4 << 0x15);\n  cond1 = ((uint)combinedValue | temp1 << 0xc) == 0;\n  if (!cond1) {\n    cond1 = (value3 | value4 << 0xc) == 0;\n  }\n  temp1 = temp1 | 0x100000;\n  value4 = value4 | 0x100000;\n  if (cond1) {\n    value3 = (uint)combinedValue | value3;\n    value4 = (temp2 & 0x80000000 | temp1) ^ value4;\n    temp2 = temp4 >> 1;\n    cond3 = SBORROW4(result1,temp2);\n    result2 = result1 - temp2;\n    cond1 = result2 == 0;\n    temp1 = result2;\n    if (!cond1 && (int)temp2 <= result1) {\n      cond3 = SBORROW4(temp4,result2);\n      temp1 = temp4 - result2;\n      cond1 = temp4 == result2;\n    }\n    if (!cond1 && (int)temp1 < 0 == cond3) {\n      value4 = value4 | result2 * 0x100000;\n    }\n    if (!cond1 && (int)temp1 < 0 == cond3) {\n      return CONCAT44(value4,value3);\n    }\n    value4 = value4 | 0x100000;\n    temp4 = 0;\n    cond3 = SBORROW4(result2,1);\n    result2 = result2 - 1;\n    cond1 = result2 == 0;\n    temp2 = result2;\n  }\n  else {\n    product1 = (combinedValue & 0xffffffff) * (ulonglong)value3;\n    combinedValue = (combinedValue & 0xffffffff) * (ulonglong)value4 +\n             (ulonglong)temp1 * (ulonglong)value3 + (product1 >> 0x20);\n    temp5 = (uint)combinedValue;\n    product2 = (ulonglong)temp1 * (ulonglong)value4 + (combinedValue >> 0x20);\n    temp4 = (uint)product2;\n    temp1 = (uint)((ulonglong)product2 >> 0x20);\n    if ((int)product1 != 0) {\n      temp5 = temp5 | 1;\n    }\n    result2 = (result1 + -0x3ff) - (uint)(temp1 < 0x200);\n    if (temp1 < 0x200) {\n      cond1 = (temp5 & 0x80000000) != 0;\n      temp5 = temp5 << 1;\n      product2 = CONCAT44(temp1 * 2 + (uint)(CARRY4(temp4,temp4) || CARRY4(temp4 * 2,(uint)cond1)),\n                       temp4 * 2 + (uint)cond1);\n    }\n    value4 = temp2 & 0x80000000 | (int)((ulonglong)product2 >> 0x20) << 0xb | (uint)product2 >> 0x15;\n    value3 = (uint)product2 << 0xb | temp5 >> 0x15;\n    temp4 = temp5 * 0x800;\n    cond2 = 0xfc < result2;\n    cond3 = SBORROW4(result2,0xfd);\n    temp1 = result2 - 0xfd;\n    cond1 = temp1 == 0;\n    temp2 = temp1;\n    if (cond2 && !cond1) {\n      cond2 = 0x6ff < temp1;\n      cond3 = SBORROW4(temp1,0x700);\n      temp2 = result2 - 0x7fd;\n      cond1 = temp1 == 0x700;\n    }\n    if (!cond2 || cond1) {\n      cond1 = 0x7fffffff < temp4;\n      if (temp4 == 0x80000000) {\n        cond1 = (temp5 >> 0x15 & 1) != 0;\n      }\n      return CONCAT44(value4 + result2 * 0x100000 + (uint)CARRY4(value3,(uint)cond1),value3 + cond1\n                     );\n    }\n  }\n  if (!cond1 && (int)temp2 < 0 == cond3) {\n    return (ulonglong)(value4 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  cond2 = SCARRY4(result2,0x36);\n  cond1 = (int)(result2 + 0x36) < 0;\n  cond3 = result2 == 0xffffffca;\n  if (cond3 || cond1 != cond2) {\n    value3 = 0;\n  }\n  if (cond3 || cond1 != cond2) {\n    value4 = value4 & 0x80000000;\n  }\n  if (cond3 || cond1 != cond2) {\n    return CONCAT44(value4,value3);\n  }\n  temp2 = -result2;\n  temp1 = temp2 - 0x20;\n  if (0x1f < (int)temp2) {\n    result2 = value3 >> (temp1 & 0xff) | value4 << (0x20 - temp1 & 0xff);\n    temp2 = (value4 >> (temp1 & 0xff) & ~((value4 & 0x80000000) >> (temp1 & 0xff))) -\n            ((int)result2 >> 0x1f);\n    if ((temp4 | value3 << (0x20 - temp1 & 0xff) | result2 << 1) == 0) {\n      temp2 = temp2 & ~(result2 >> 0x1f);\n    }\n    return CONCAT44(value4,temp2) & 0x80000000ffffffff;\n  }\n  result1 = temp2 - 0x14;\n  if (result1 == 0 || result1 < 0 != SCARRY4(temp1,0xc)) {\n    temp5 = value3 << (result2 + 0x20 & 0xff);\n    temp1 = value3 >> (temp2 & 0xff) | value4 << (result2 + 0x20 & 0xff);\n    result2 = temp1 + -((int)temp5 >> 0x1f);\n    if ((temp4 | temp5 << 1) == 0) {\n      result2 = result2 & ~(temp5 >> 0x1f);\n    }\n    return CONCAT44((value4 & 0x80000000) +\n                    ((value4 & 0x7fffffff) >> (temp2 & 0xff)) +\n                    (uint)CARRY4(temp1,-((int)temp5 >> 0x1f)),result2);\n  }\n  temp2 = 0xc - result1;\n  result2 = value3 << (temp2 & 0xff);\n  temp2 = value3 >> (0x20 - temp2 & 0xff) | value4 << (temp2 & 0xff);\n  temp1 = temp2 + -((int)result2 >> 0x1f);\n  if ((temp4 | result2 << 1) == 0) {\n    temp1 = temp1 & ~(result2 >> 0x1f);\n  }\n  return CONCAT44((value4 & 0x80000000) + (uint)CARRY4(temp2,-((int)result2 >> 0x1f)),temp1);\n}\n\n",
            "renaming": {
                "FUN_080004c8": "calculate_product_and_addition_080004c8",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4",
                "uVar1": "product1",
                "lVar2": "product2",
                "uVar3": "temp1",
                "uVar4": "temp2",
                "iVar5": "result1",
                "uVar6": "result2",
                "unaff_r5": "temp3",
                "uVar7": "temp4",
                "uVar8": "temp5",
                "bVar9": "cond1",
                "bVar10": "cond2",
                "bVar11": "cond3",
                "uVar12": "combinedValue"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08005e9c",
                "FUN_080096e0",
                "FUN_08004d78",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080006a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080006a4": {
            "entrypoint": "0x080006a4",
            "current_name": "extract_bits_080006a4",
            "code": "\nulonglong extract_bits_080006a4(uint temp_2,uint temp_1,uint temp_3,uint temp_4)\n\n{\n  uint bit_1;\n  uint mask_2;\n  uint bit_2;\n  uint bit_3;\n  uint mask_3;\n  bool is_zero;\n  \n  bit_2 = mask_3 & temp_4 >> 0x14;\n  if (mask_2 != mask_3 && bit_2 != mask_3) {\n    is_zero = (temp_2 | temp_1 << 1) == 0;\n    if (!is_zero) {\n      is_zero = (temp_3 | temp_4 << 1) == 0;\n    }\n    if (is_zero) {\n      return (ulonglong)((temp_1 ^ temp_4) & 0x80000000) << 0x20;\n    }\n    if (mask_2 == 0) {\n      bit_3 = temp_1 & 0x80000000;\n      do {\n        bit_1 = temp_2 & 0x80000000;\n        temp_2 = temp_2 << 1;\n        temp_1 = temp_1 * 2 + (uint)(bit_1 != 0);\n      } while ((temp_1 & 0x100000) == 0);\n      temp_1 = temp_1 | bit_3;\n      if (bit_2 != 0) {\n        return CONCAT44(temp_1,temp_2);\n      }\n    }\n    do {\n      bit_2 = temp_3 & 0x80000000;\n      temp_3 = temp_3 << 1;\n      temp_4 = temp_4 * 2 + (uint)(bit_2 != 0);\n    } while ((temp_4 & 0x100000) == 0);\n    return CONCAT44(temp_1,temp_2);\n  }\n  is_zero = (temp_2 | temp_1 << 1) == 0;\n  if (is_zero) {\n    temp_1 = temp_4;\n    temp_2 = temp_3;\n  }\n  if (!is_zero) {\n    is_zero = (temp_3 | temp_4 << 1) == 0;\n  }\n  bit_3 = temp_1;\n  if (((!is_zero) && ((mask_2 != mask_3 || ((temp_2 | temp_1 << 0xc) == 0)))) &&\n     ((bit_2 != mask_3 || (temp_2 = temp_3, bit_3 = temp_4, (temp_3 | temp_4 << 0xc) == 0)))) {\n    return (ulonglong)((temp_1 ^ temp_4) & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  return CONCAT44(bit_3,temp_2) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_080006a4": "extract_bits_080006a4",
                "param_1": "temp_2",
                "param_2": "temp_1",
                "param_3": "temp_3",
                "param_4": "temp_4",
                "uVar1": "bit_1",
                "unaff_r4": "mask_2",
                "uVar2": "bit_2",
                "uVar3": "bit_3",
                "in_r12": "mask_3",
                "bVar4": "is_zero"
            },
            "calling": [
                "FUN_080004c8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800071c": {
            "entrypoint": "0x0800071c",
            "current_name": "convert_value_to_double_0800071c",
            "code": "\nulonglong convertValueToDouble_0800071c(undefined4 decimalVal,uint highBits,uint bits,uint extraBits)\n\n{\n  uint firstBit;\n  uint secondBit;\n  uint thirdBit;\n  uint fourthBit;\n  uint fifthBit;\n  uint tempVar1;\n  uint tempVar2;\n  int bitDifference;\n  uint bitCount;\n  uint extraBitCount;\n  uint mask1;\n  uint mask2;\n  uint mask3;\n  uint exponentMask;\n  bool checkFlag;\n  bool equalFlag;\n  bool carryFlag;\n  undefined8 concatenatedVal;\n  \n  concatenatedVal = CONCAT44(highBits,decimalVal);\n  exponentMask = 0x7ff;\n  tempVar2 = highBits >> 0x14 & 0x7ff;\n  checkFlag = tempVar2 == 0;\n  if (!checkFlag) {\n    extraBitCount = extraBits >> 0x14 & 0x7ff;\n    checkFlag = extraBitCount == 0;\n  }\n  if (!checkFlag) {\n    checkFlag = tempVar2 == 0x7ff;\n  }\n  if (!checkFlag) {\n    checkFlag = extraBitCount == 0x7ff;\n  }\n  if (checkFlag) {\n    concatenatedVal = convert_to_double_0800088a();\n  }\n  bitCount = (uint)((ulonglong)concatenatedVal >> 0x20);\n  mask2 = (uint)concatenatedVal;\n  bitDifference = tempVar2 - extraBitCount;\n  if ((bits | extraBits << 0xc) == 0) {\n    tempVar2 = (bitCount ^ extraBits) & 0x80000000 | bitCount & 0xfffff;\n    carryFlag = SCARRY4(bitDifference,exponentMask >> 1);\n    bitCount = bitDifference + (exponentMask >> 1);\n    checkFlag = (int)bitCount < 0;\n    equalFlag = bitCount == 0;\n    if (!equalFlag && checkFlag == carryFlag) {\n      carryFlag = SBORROW4(exponentMask,bitCount);\n      checkFlag = (int)(exponentMask - bitCount) < 0;\n      equalFlag = exponentMask == bitCount;\n    }\n    if (!equalFlag && checkFlag == carryFlag) {\n      tempVar2 = tempVar2 | bitCount * 0x100000;\n    }\n    if (!equalFlag && checkFlag == carryFlag) {\n      return CONCAT44(tempVar2,mask2);\n    }\n    tempVar2 = tempVar2 | 0x100000;\n    exponentMask = 0;\n    equalFlag = SBORROW4(bitCount,1);\n    bitCount = bitCount - 1;\n    checkFlag = bitCount == 0;\n    thirdBit = bitCount;\n  }\n  else {\n    thirdBit = (extraBits << 0xc) >> 4 | 0x10000000 | bits >> 0x18;\n    exponentMask = bits << 8;\n    mask1 = (bitCount << 0xc) >> 4 | 0x10000000 | mask2 >> 0x18;\n    mask2 = mask2 * 0x100;\n    tempVar2 = (bitCount ^ extraBits) & 0x80000000;\n    checkFlag = thirdBit <= mask1;\n    if (mask1 == thirdBit) {\n      checkFlag = exponentMask <= mask2;\n    }\n    bitDifference = bitDifference + (uint)checkFlag;\n    bitCount = bitDifference + 0x3fd;\n    if (checkFlag == false) {\n      thirdBit = thirdBit >> 1;\n      exponentMask = (uint)((bits >> 0x18 & 1) != 0) << 0x1f | exponentMask >> 1;\n    }\n    mask3 = mask2 - exponentMask;\n    mask1 = (mask1 - thirdBit) - (uint)(mask2 < exponentMask);\n    fourthBit = thirdBit >> 1;\n    firstBit = (uint)((thirdBit & 1) != 0) << 0x1f | exponentMask >> 1;\n    mask2 = 0x100000;\n    thirdBit = 0x80000;\n    while( true ) {\n      checkFlag = firstBit <= mask3;\n      if (fourthBit < mask1 || mask1 - fourthBit < (uint)checkFlag) {\n        mask3 = mask3 - firstBit;\n        mask2 = mask2 | thirdBit;\n        mask1 = (mask1 - fourthBit) - (uint)!checkFlag;\n      }\n      fifthBit = fourthBit >> 1;\n      firstBit = (uint)((fourthBit & 1) != 0) << 0x1f | firstBit >> 1;\n      equalFlag = firstBit <= mask3;\n      checkFlag = mask1 - fifthBit < (uint)equalFlag;\n      exponentMask = mask1;\n      if (fifthBit < mask1 || checkFlag) {\n        mask3 = mask3 - firstBit;\n        exponentMask = (mask1 - fifthBit) - (uint)!equalFlag;\n      }\n      if (fifthBit < mask1 || checkFlag) {\n        mask2 = mask2 | thirdBit >> 1;\n      }\n      mask1 = fourthBit >> 2;\n      secondBit = (uint)((fifthBit & 1) != 0) << 0x1f | firstBit >> 1;\n      equalFlag = secondBit <= mask3;\n      checkFlag = exponentMask - mask1 < (uint)equalFlag;\n      fifthBit = exponentMask;\n      if (mask1 < exponentMask || checkFlag) {\n        mask3 = mask3 - secondBit;\n        fifthBit = (exponentMask - mask1) - (uint)!equalFlag;\n      }\n      if (mask1 < exponentMask || checkFlag) {\n        mask2 = mask2 | thirdBit >> 2;\n      }\n      tempVar1 = fourthBit >> 3;\n      firstBit = (uint)((mask1 & 1) != 0) << 0x1f | secondBit >> 1;\n      equalFlag = firstBit <= mask3;\n      checkFlag = fifthBit - tempVar1 < (uint)equalFlag;\n      mask1 = fifthBit;\n      if (tempVar1 < fifthBit || checkFlag) {\n        mask3 = mask3 - firstBit;\n        mask1 = (fifthBit - tempVar1) - (uint)!equalFlag;\n      }\n      if (tempVar1 < fifthBit || checkFlag) {\n        mask2 = mask2 | thirdBit >> 3;\n      }\n      exponentMask = mask1 | mask3;\n      if (exponentMask == 0) break;\n      mask1 = mask1 << 4 | mask3 >> 0x1c;\n      mask3 = mask3 << 4;\n      fourthBit = fourthBit & 0xfffffff8 | firstBit >> 0x1d;\n      firstBit = (secondBit >> 1) << 3;\n      thirdBit = thirdBit >> 4;\n      if (thirdBit == 0) {\n        tempVar1 = fourthBit;\n        if ((tempVar2 & 0x100000) != 0) goto LAB_0800083a;\n        tempVar2 = tempVar2 | mask2;\n        mask2 = 0;\n        thirdBit = 0x80000000;\n      }\n    }\n    if ((tempVar2 & 0x100000) == 0) {\n      tempVar2 = tempVar2 | mask2;\n      mask2 = 0;\n    }\nLAB_0800083a:\n    carryFlag = 0xfc < bitCount;\n    equalFlag = SBORROW4(bitCount,0xfd);\n    fourthBit = bitDifference + 0x300;\n    checkFlag = fourthBit == 0;\n    thirdBit = fourthBit;\n    if (carryFlag && !checkFlag) {\n      carryFlag = 0x6ff < fourthBit;\n      equalFlag = SBORROW4(fourthBit,0x700);\n      thirdBit = bitDifference - 0x400;\n      checkFlag = fourthBit == 0x700;\n    }\n    if (!carryFlag || checkFlag) {\n      checkFlag = tempVar1 <= mask1;\n      if (mask1 == tempVar1) {\n        checkFlag = firstBit <= mask3;\n      }\n      if (mask1 == tempVar1 && mask3 == firstBit) {\n        checkFlag = (mask2 & 1) != 0;\n      }\n      return CONCAT44(tempVar2 + bitCount * 0x100000 + (uint)CARRY4(mask2,(uint)checkFlag),mask2 + checkFlag);\n    }\n  }\n  if (!checkFlag && (int)thirdBit < 0 == equalFlag) {\n    return (ulonglong)(tempVar2 & 0x80000000 | 0x7ff00000) << 0x20;\n  }\n  carryFlag = SCARRY4(bitCount,0x36);\n  checkFlag = (int)(bitCount + 0x36) < 0;\n  equalFlag = bitCount == 0xffffffca;\n  if (equalFlag || checkFlag != carryFlag) {\n    mask2 = 0;\n  }\n  if (equalFlag || checkFlag != carryFlag) {\n    tempVar2 = tempVar2 & 0x80000000;\n  }\n  if (equalFlag || checkFlag != carryFlag) {\n    return CONCAT44(tempVar2,mask2);\n  }\n  thirdBit = -bitCount;\n  mask1 = thirdBit - 0x20;\n  if (0x1f < (int)thirdBit) {\n    thirdBit = mask2 >> (mask1 & 0xff) | tempVar2 << (0x20 - mask1 & 0xff);\n    bitCount = (tempVar2 >> (mask1 & 0xff) & ~((tempVar2 & 0x80000000) >> (mask1 & 0xff))) -\n            ((int)thirdBit >> 0x1f);\n    if ((exponentMask | mask2 << (0x20 - mask1 & 0xff) | thirdBit << 1) == 0) {\n      bitCount = bitCount & ~(thirdBit >> 0x1f);\n    }\n    return CONCAT44(tempVar2,bitCount) & 0x80000000ffffffff;\n  }\n  bitDifference = thirdBit - 0x14;\n  if (bitDifference != 0 && bitDifference < 0 == SCARRY4(mask1,0xc)) {\n    bitCount = 0xc - bitDifference;\n    thirdBit = mask2 << (bitCount & 0xff);\n    mask2 = mask2 >> (0x20 - bitCount & 0xff) | tempVar2 << (bitCount & 0xff);\n    bitCount = mask2 + -((int)thirdBit >> 0x1f);\n    if ((exponentMask | thirdBit << 1) == 0) {\n      bitCount = bitCount & ~(thirdBit >> 0x1f);\n    }\n    return CONCAT44((tempVar2 & 0x80000000) + (uint)CARRY4(mask2,-((int)thirdBit >> 0x1f)),bitCount);\n  }\n  mask1 = mask2 << (bitCount + 0x20 & 0xff);\n  mask2 = mask2 >> (thirdBit & 0xff) | tempVar2 << (bitCount + 0x20 & 0xff);\n  bitCount = mask2 + -((int)mask1 >> 0x1f);\n  if ((exponentMask | mask1 << 1) == 0) {\n    bitCount = bitCount & ~(mask1 >> 0x1f);\n  }\n  return CONCAT44((tempVar2 & 0x80000000) +\n                  ((tempVar2 & 0x7fffffff) >> (thirdBit & 0xff)) +\n                  (uint)CARRY4(mask2,-((int)mask1 >> 0x1f)),bitCount);\n}\n\n",
            "renaming": {
                "FUN_0800071c": "convert_value_to_double_0800071c",
                "param_1": "decimalVal",
                "param_2": "highBits",
                "param_3": "bits",
                "param_4": "extraBits",
                "uVar1": "firstBit",
                "uVar2": "secondBit",
                "uVar3": "thirdBit",
                "uVar4": "fourthBit",
                "uVar5": "fifthBit",
                "uVar6": "tempVar1",
                "uVar7": "tempVar2",
                "iVar8": "bitDifference",
                "uVar9": "bitCount",
                "unaff_r5": "extraBitCount",
                "uVar10": "mask1",
                "uVar11": "mask2",
                "uVar12": "mask3",
                "uVar13": "exponentMask",
                "bVar14": "checkFlag",
                "bVar15": "equalFlag",
                "bVar16": "carryFlag",
                "uVar17": "concatenatedVal"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08004bd8",
                "FUN_08004d78",
                "FUN_08005838",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_0800088a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800088a": {
            "entrypoint": "0x0800088a",
            "current_name": "convert_to_double_0800088a",
            "code": "\nulonglong convertToDouble_0800088a(uint input1,uint input2,uint input3,uint input4)\n\n{\n  uint bit1;\n  uint bit2;\n  uint bit3;\n  uint bit4;\n  uint constant1;\n  bool isZero;\n  \n  bit3 = constant1 & input4 >> 0x14;\n  bit4 = input2;\n  if (bit2 != constant1 || bit3 != constant1) {\n    if (bit2 == constant1) {\n      if (((input1 | input2 << 0xc) == 0) && (input1 = input3, bit4 = input4, bit3 != constant1)\n         ) {\nLAB_080006fc:\n        return (ulonglong)((input2 ^ input4) & 0x80000000 | 0x7ff00000) << 0x20;\n      }\n    }\n    else if (bit3 == constant1) {\n      input1 = input3;\n      bit4 = input4;\n      if ((input3 | input4 << 0xc) == 0) {\nLAB_080006c0:\n        return (ulonglong)((input2 ^ input4) & 0x80000000) << 0x20;\n      }\n    }\n    else {\n      isZero = (input1 | input2 << 1) == 0;\n      if (!isZero) {\n        isZero = (input3 | input4 << 1) == 0;\n      }\n      if (!isZero) {\n        if (bit2 == 0) {\n          bit4 = input2 & 0x80000000;\n          do {\n            bit1 = input1 & 0x80000000;\n            input1 = input1 << 1;\n            input2 = input2 * 2 + (uint)(bit1 != 0);\n          } while ((input2 & 0x100000) == 0);\n          input2 = input2 | bit4;\n          if (bit3 != 0) {\n            return CONCAT44(input2,input1);\n          }\n        }\n        do {\n          bit4 = input3 & 0x80000000;\n          input3 = input3 << 1;\n          input4 = input4 * 2 + (uint)(bit4 != 0);\n        } while ((input4 & 0x100000) == 0);\n        return CONCAT44(input2,input1);\n      }\n      if ((input1 | input2 << 1) != 0) goto LAB_080006fc;\n      if ((input3 | input4 << 1) != 0) goto LAB_080006c0;\n    }\n  }\n  return CONCAT44(bit4,input1) | 0x7ff8000000000000;\n}\n\n",
            "renaming": {
                "FUN_0800088a": "convert_to_double_0800088a",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "uVar1": "bit1",
                "unaff_r4": "bit2",
                "uVar2": "bit3",
                "uVar3": "bit4",
                "in_r12": "constant1",
                "bVar4": "isZero"
            },
            "calling": [
                "FUN_0800071c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080008fc": {
            "entrypoint": "0x080008fc",
            "current_name": "check_conditions_and_evaluate_080008fc",
            "code": "\nuint check_conditions_and_evaluate_080008fc(uint input_1,uint input_2,uint input_3,uint input_4)\n\n{\n  uint result;\n  bool is_zero;\n  bool is_less_than_or_equal;\n  \n  if (((int)(input_2 << 1) >> 0x15 == -1 || (int)(input_4 << 1) >> 0x15 == -1) &&\n     ((((int)(input_2 << 1) >> 0x15 == -1 && ((input_1 | input_2 << 0xc) != 0)) ||\n      (((int)(input_4 << 1) >> 0x15 == -1 && ((input_3 | input_4 << 0xc) != 0)))))) {\n    return 1;\n  }\n  is_zero = (input_1 | input_2 << 1) == 0;\n  if (is_zero) {\n    is_zero = (input_3 | input_4 << 1) == 0;\n  }\n  if (!is_zero) {\n    is_zero = input_2 == input_4;\n  }\n  if (is_zero) {\n    is_zero = input_1 == input_3;\n  }\n  if (!is_zero) {\n    result = input_2 ^ input_4;\n    is_zero = result == 0;\n    if (-1 < (int)result) {\n      is_zero = input_2 == input_4;\n    }\n    is_less_than_or_equal = -1 < (int)result && input_4 <= input_2;\n    if (is_zero) {\n      is_less_than_or_equal = input_3 <= input_1;\n    }\n    input_4 = (int)input_4 >> 0x1f;\n    if (!is_less_than_or_equal) {\n      input_4 = ~input_4;\n    }\n    return input_4 | 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080008fc": "check_conditions_and_evaluate_080008fc",
                "param_1": "input_1",
                "param_2": "input_2",
                "param_3": "input_3",
                "param_4": "input_4",
                "uVar1": "result",
                "bVar2": "is_zero",
                "bVar3": "is_less_than_or_equal"
            },
            "calling": [
                "FUN_08000988"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000978": {
            "entrypoint": "0x08000978",
            "current_name": "evaluate_conditions_08000978",
            "code": "\nvoid evaluate_conditions_08000978(undefined4 input_param1,undefined4 input_param2,undefined4 condition_param1,undefined4 condition_param2)\n\n{\n  evaluate_conditions_08000978_08000988(condition_param1,condition_param2,input_param1,input_param2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000978": "evaluate_conditions_08000978",
                "param_1": "input_param1",
                "param_2": "input_param2",
                "param_3": "condition_param1",
                "param_4": "condition_param2"
            },
            "calling": [
                "FUN_080009d4",
                "FUN_080009e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000988": {
            "entrypoint": "0x08000988",
            "current_name": "evaluate_conditions_08000988",
            "code": "\nundefined4 evaluate_conditions_08000988(undefined4 input_param)\n\n{\n  evaluate_conditions_08000988_with_check();\n  return input_param;\n}\n\n",
            "renaming": {
                "FUN_08000988": "evaluate_conditions_08000988",
                "param_1": "input_param",
                "check_conditions_and_evaluate_080008fc": "evaluate_conditions_with_check"
            },
            "calling": [
                "FUN_080009ac",
                "FUN_080009c0",
                "FUN_08000978",
                "FUN_08000998"
            ],
            "called": [
                "FUN_080008fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000998": {
            "entrypoint": "0x08000998",
            "current_name": "check_conditions_08000998",
            "code": "\nbool check_conditions_08000998(void)\n\n{\n  char result;\n  \n  evaluate_conditions_08000988();\n  return result != '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000998": "check_conditions_08000998",
                "in_ZR": "result"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009ac": {
            "entrypoint": "0x080009ac",
            "current_name": "check_condition_080009ac",
            "code": "\nbool check_condition_080009ac(void)\n\n{\n  char input_character;\n  \n  evaluate_conditions_08000988();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009ac": "check_condition_080009ac",
                "in_CY": "input_character"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009c0": {
            "entrypoint": "0x080009c0",
            "current_name": "check_conditions_080009c0",
            "code": "\nbool check_conditions_080009c0(void)\n\n{\n  undefined zero_result;\n  undefined carry_flag;\n  \n  evaluate_conditions_08000988();\n  return !(bool)carry_flag || (bool)zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009c0": "check_conditions_080009c0",
                "in_ZR": "zero_result",
                "in_CY": "carry_flag"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08000988"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009d4": {
            "entrypoint": "0x080009d4",
            "current_name": "is_condition_evaluated_080009d4",
            "code": "\nbool is_condition_evaluated_080009d4(void)\n\n{\n  undefined is_zero_result;\n  undefined is_carry_flag_set;\n  \n  evaluate_conditions_08000978();\n  return !(bool)is_carry_flag_set || (bool)is_zero_result;\n}\n\n",
            "renaming": {
                "FUN_080009d4": "is_condition_evaluated_080009d4",
                "in_ZR": "is_zero_result",
                "in_CY": "is_carry_flag_set"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009e8": {
            "entrypoint": "0x080009e8",
            "current_name": "check_evaluation_result_080009e8",
            "code": "\nbool check_evaluation_result_080009e8(void)\n\n{\n  char input_character;\n  \n  evaluate_conditions_08000978();\n  return input_character == '\\0';\n}\n\n",
            "renaming": {
                "FUN_080009e8": "check_evaluation_result_080009e8",
                "in_CY": "input_character"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08000978"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080009fc": {
            "entrypoint": "0x080009fc",
            "current_name": "calculate_float_080009fc",
            "code": "\nuint calculateFloat_080009fc(uint floatValue1,uint floatValue2)\n\n{\n  uint result;\n  uint doubleValue2;\n  uint newValue;\n  uint temp;\n  bool isZero;\n  bool isLessThan;\n  \n  doubleValue2 = floatValue2 * 2;\n  isLessThan = doubleValue2 < 0x70000000;\n  newValue = doubleValue2 + 0x90000000;\n  result = newValue;\n  if (!isLessThan) {\n    temp = doubleValue2 + 0x8fe00000;\n    result = temp;\n  }\n  isZero = result == 0;\n  if (!isLessThan && newValue >= 0x200000) {\n    isZero = temp == 0x1fc00000;\n  }\n  if (((isLessThan || newValue < 0x200000) || 0x1fc00000 < temp) || isZero) {\n    if ((floatValue2 & 0x40000000) != 0) {\n      if (((int)doubleValue2 >> 0x15 == -1) && ((floatValue1 | floatValue2 << 0xc) != 0)) {\n        return 0x7fc00000;\n      }\n      return floatValue2 & 0x80000000 | 0x7f800000;\n    }\n    if ((int)(doubleValue2 + 0x92e00000) < 0 != SCARRY4(newValue,0x2e00000)) {\n      return floatValue2 & 0x80000000;\n    }\n    doubleValue2 = 0x18 - (doubleValue2 + 0x92e00000 >> 0x15);\n    result = floatValue1 >> (doubleValue2 & 0xff);\n    if (floatValue1 << (0x20 - doubleValue2 & 0xff) != 0) {\n      result = result | 1;\n    }\n    newValue = floatValue2 & 0x1fffff | 0x100000;\n    floatValue1 = result | newValue << (0x20 - doubleValue2 & 0xff);\n    newValue = (newValue >> (doubleValue2 & 0xff)) << 1;\n  }\n  result = (floatValue2 & 0x80000000 | floatValue1 >> 0x1d) + newValue * 4 + (uint)(0x7fffffff < floatValue1 * 8);\n  if (floatValue1 * 8 == 0x80000000) {\n    result = result & 0xfffffffe;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080009fc": "calculate_float_080009fc",
                "param_1": "floatValue1",
                "param_2": "floatValue2",
                "uVar1": "result",
                "uVar2": "doubleValue2",
                "uVar3": "newValue",
                "in_r12": "temp",
                "bVar4": "isZero",
                "bVar5": "isLessThan"
            },
            "calling": [
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa4": {
            "entrypoint": "0x08000aa4",
            "current_name": "calculate_updated_value_08000aa4",
            "code": "\nuint calculate_updated_value_08000aa4(uint input_value_1,uint input_value_2,undefined4 input_flag,uint input_value_3)\n\n{\n  int shifted_value;\n  int shifted_value_2;\n  uint result_value;\n  uint result_value_2;\n  uint temp_value;\n  uint temp_value_2;\n  uint difference;\n  bool is_equal;\n  \n  result_value = input_value_2 ^ 0x80000000;\n  temp_value = input_value_1 << 1;\n  is_equal = temp_value == 0;\n  if (!is_equal) {\n    input_value_3 = input_value_2 << 1;\n    is_equal = input_value_3 == 0;\n  }\n  if (!is_equal) {\n    is_equal = temp_value == input_value_3;\n  }\n  shifted_value = (int)temp_value >> 0x18;\n  if (!is_equal) {\n    is_equal = shifted_value == -1;\n  }\n  if (!is_equal) {\n    is_equal = (int)input_value_3 >> 0x18 == -1;\n  }\n  if (is_equal) {\n    shifted_value_2 = (int)(input_value_2 << 1) >> 0x18;\n    if (shifted_value == -1 || shifted_value_2 == -1) {\n      temp_value = result_value;\n      if (shifted_value == -1) {\n        temp_value = input_value_1;\n      }\n      if (shifted_value != -1 || shifted_value_2 != -1) {\n        result_value = temp_value;\n      }\n      is_equal = (temp_value & 0x7fffff) == 0;\n      if (is_equal) {\n        is_equal = (result_value & 0x7fffff) == 0;\n      }\n      if (is_equal) {\n        is_equal = temp_value == result_value;\n      }\n      if (!is_equal) {\n        temp_value = temp_value | 0x400000;\n      }\n      return temp_value;\n    }\n    if (((input_value_1 ^ result_value) & 0x7fffffff) != 0) {\n      if (temp_value == 0) {\n        input_value_1 = result_value;\n      }\n      return input_value_1;\n    }\n    if (input_value_1 != result_value) {\n      return 0;\n    }\n    if ((temp_value & 0xff000000) == 0) {\n      result_value = input_value_1 << 1;\n      if ((input_value_1 & 0x80000000) != 0) {\n        result_value = result_value | 0x80000000;\n      }\n      return result_value;\n    }\n    if (temp_value < 0xfe000000) {\n      return input_value_1 + 0x800000;\n    }\n    input_value_1 = input_value_1 & 0x80000000;\nLAB_08000bde:\n    return input_value_1 | 0x7f800000;\n  }\n  temp_value = temp_value >> 0x18;\n  input_value_3 = input_value_3 >> 0x18;\n  difference = input_value_3 - temp_value;\n  is_equal = difference != 0;\n  temp_value_2 = temp_value;\n  if (is_equal && temp_value <= input_value_3) {\n    temp_value_2 = temp_value + difference;\n  }\n  if (is_equal && temp_value <= input_value_3) {\n    result_value = result_value ^ input_value_1;\n  }\n  if (is_equal && temp_value <= input_value_3) {\n    input_value_1 = input_value_1 ^ result_value;\n  }\n  if (is_equal && temp_value <= input_value_3) {\n    result_value = result_value ^ input_value_1;\n  }\n  if (input_value_3 < temp_value) {\n    difference = -difference;\n  }\n  if (0x19 < difference) {\n    return input_value_1;\n  }\n  temp_value = input_value_1 & 0xffffff | 0x800000;\n  if ((input_value_1 & 0x80000000) != 0) {\n    temp_value = -temp_value;\n  }\n  result_value_2 = result_value & 0xffffff | 0x800000;\n  if ((result_value & 0x80000000) != 0) {\n    result_value_2 = -result_value_2;\n  }\n  if (temp_value_2 == difference) {\n    result_value_2 = result_value_2 ^ 0x800000;\n    if (temp_value_2 == 0) {\n      temp_value = temp_value ^ 0x800000;\n      temp_value_2 = 1;\n    }\n    else {\n      difference = difference - 1;\n    }\n  }\n  temp_value = temp_value + ((int)result_value_2 >> (difference & 0xff));\n  result_value_2 = result_value_2 << (0x20 - difference & 0xff);\n  input_value_1 = temp_value & 0x80000000;\n  if ((int)temp_value < 0) {\n    is_equal = result_value_2 != 0;\n    result_value_2 = -result_value_2;\n    temp_value = -temp_value - (uint)is_equal;\n  }\n  if (temp_value < 0x800000) {\n    result_value = result_value_2 & 0x80000000;\n    result_value_2 = result_value_2 << 1;\n    temp_value = temp_value * 2 + (uint)(result_value != 0);\n    result_value = temp_value_2 - 2;\n    if ((temp_value & 0x800000) == 0) {\n      difference = LZCOUNT(temp_value) - 8;\n      temp_value = temp_value << (difference & 0xff);\n      if ((int)result_value < (int)difference) {\n        temp_value = temp_value >> (-(result_value - difference) & 0xff);\n      }\n      else {\n        temp_value = temp_value + (result_value - difference) * 0x800000;\n      }\n      return temp_value | input_value_1;\n    }\n  }\n  else {\n    result_value = temp_value_2 - 1;\n    if (0xffffff < temp_value) {\n      result_value = temp_value & 1;\n      temp_value = temp_value >> 1;\n      result_value_2 = (uint)(result_value != 0) << 0x1f | result_value_2 >> 1;\n      result_value = temp_value_2;\n      if (0xfd < temp_value_2) goto LAB_08000bde;\n    }\n  }\n  temp_value = temp_value + result_value * 0x800000 + (uint)(0x7fffffff < result_value_2);\n  if (result_value_2 == 0x80000000) {\n    temp_value = temp_value & 0xfffffffe;\n  }\n  return temp_value | input_value_1;\n}\n\n",
            "renaming": {
                "FUN_08000aa4": "calculate_updated_value_08000aa4",
                "param_1": "input_value_1",
                "param_2": "input_value_2",
                "param_3": "input_flag",
                "param_4": "input_value_3",
                "iVar1": "shifted_value",
                "iVar2": "shifted_value_2",
                "uVar3": "result_value",
                "uVar4": "result_value_2",
                "uVar5": "temp_value",
                "uVar6": "temp_value_2",
                "uVar7": "difference",
                "bVar8": "is_equal"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004bd8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000aa8": {
            "entrypoint": "0x08000aa8",
            "current_name": "calculate_float_addition_08000aa8",
            "code": "\nuint calculateFloatAddition_08000aa8(uint operand1,uint operand2,undefined4 flags,uint status)\n\n{\n  int exponent1;\n  int exponent2;\n  uint fraction1;\n  uint fraction2;\n  uint temp1;\n  uint temp2;\n  bool isZero;\n  \n  fraction2 = operand1 << 1;\n  isZero = fraction2 == 0;\n  if (!isZero) {\n    status = operand2 << 1;\n    isZero = status == 0;\n  }\n  if (!isZero) {\n    isZero = fraction2 == status;\n  }\n  exponent1 = (int)fraction2 >> 0x18;\n  if (!isZero) {\n    isZero = exponent1 == -1;\n  }\n  if (!isZero) {\n    isZero = (int)status >> 0x18 == -1;\n  }\n  if (isZero) {\n    exponent2 = (int)(operand2 << 1) >> 0x18;\n    if (exponent1 == -1 || exponent2 == -1) {\n      fraction2 = operand2;\n      if (exponent1 == -1) {\n        fraction2 = operand1;\n      }\n      if (exponent1 != -1 || exponent2 != -1) {\n        operand2 = fraction2;\n      }\n      isZero = (fraction2 & 0x7fffff) == 0;\n      if (isZero) {\n        isZero = (operand2 & 0x7fffff) == 0;\n      }\n      if (isZero) {\n        isZero = fraction2 == operand2;\n      }\n      if (!isZero) {\n        fraction2 = fraction2 | 0x400000;\n      }\n      return fraction2;\n    }\n    if (((operand1 ^ operand2) & 0x7fffffff) != 0) {\n      if (fraction2 == 0) {\n        operand1 = operand2;\n      }\n      return operand1;\n    }\n    if (operand1 != operand2) {\n      return 0;\n    }\n    if ((fraction2 & 0xff000000) == 0) {\n      fraction2 = operand1 << 1;\n      if ((operand1 & 0x80000000) != 0) {\n        fraction2 = fraction2 | 0x80000000;\n      }\n      return fraction2;\n    }\n    if (fraction2 < 0xfe000000) {\n      return operand1 + 0x800000;\n    }\n    operand1 = operand1 & 0x80000000;\nLAB_08000bde:\n    return operand1 | 0x7f800000;\n  }\n  fraction2 = fraction2 >> 0x18;\n  status = status >> 0x18;\n  temp2 = status - fraction2;\n  isZero = temp2 != 0;\n  temp1 = fraction2;\n  if (isZero && fraction2 <= status) {\n    temp1 = fraction2 + temp2;\n  }\n  if (isZero && fraction2 <= status) {\n    operand2 = operand2 ^ operand1;\n  }\n  if (isZero && fraction2 <= status) {\n    operand1 = operand1 ^ operand2;\n  }\n  if (isZero && fraction2 <= status) {\n    operand2 = operand2 ^ operand1;\n  }\n  if (status < fraction2) {\n    temp2 = -temp2;\n  }\n  if (0x19 < temp2) {\n    return operand1;\n  }\n  fraction2 = operand1 & 0xffffff | 0x800000;\n  if ((operand1 & 0x80000000) != 0) {\n    fraction2 = -fraction2;\n  }\n  fraction1 = operand2 & 0xffffff | 0x800000;\n  if ((operand2 & 0x80000000) != 0) {\n    fraction1 = -fraction1;\n  }\n  if (temp1 == temp2) {\n    fraction1 = fraction1 ^ 0x800000;\n    if (temp1 == 0) {\n      fraction2 = fraction2 ^ 0x800000;\n      temp1 = 1;\n    }\n    else {\n      temp2 = temp2 - 1;\n    }\n  }\n  fraction2 = fraction2 + ((int)fraction1 >> (temp2 & 0xff));\n  fraction1 = fraction1 << (0x20 - temp2 & 0xff);\n  operand1 = fraction2 & 0x80000000;\n  if ((int)fraction2 < 0) {\n    isZero = fraction1 != 0;\n    fraction1 = -fraction1;\n    fraction2 = -fraction2 - (uint)isZero;\n  }\n  if (fraction2 < 0x800000) {\n    temp2 = fraction1 & 0x80000000;\n    fraction1 = fraction1 << 1;\n    fraction2 = fraction2 * 2 + (uint)(temp2 != 0);\n    temp2 = temp1 - 2;\n    if ((fraction2 & 0x800000) == 0) {\n      temp1 = LZCOUNT(fraction2) - 8;\n      fraction2 = fraction2 << (temp1 & 0xff);\n      if ((int)temp2 < (int)temp1) {\n        fraction2 = fraction2 >> (-(temp2 - temp1) & 0xff);\n      }\n      else {\n        fraction2 = fraction2 + (temp2 - temp1) * 0x800000;\n      }\n      return fraction2 | operand1;\n    }\n  }\n  else {\n    temp2 = temp1 - 1;\n    if (0xffffff < fraction2) {\n      temp2 = fraction2 & 1;\n      fraction2 = fraction2 >> 1;\n      fraction1 = (uint)(temp2 != 0) << 0x1f | fraction1 >> 1;\n      temp2 = temp1;\n      if (0xfd < temp1) goto LAB_08000bde;\n    }\n  }\n  fraction2 = fraction2 + temp2 * 0x800000 + (uint)(0x7fffffff < fraction1);\n  if (fraction1 == 0x80000000) {\n    fraction2 = fraction2 & 0xfffffffe;\n  }\n  return fraction2 | operand1;\n}\n\n",
            "renaming": {
                "FUN_08000aa8": "calculate_float_addition_08000aa8",
                "param_1": "operand1",
                "param_2": "operand2",
                "param_3": "flags",
                "param_4": "status",
                "iVar1": "exponent1",
                "iVar2": "exponent2",
                "uVar3": "fraction1",
                "uVar4": "fraction2",
                "uVar5": "temp1",
                "uVar6": "temp2",
                "bVar7": "isZero"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080049cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c08": {
            "entrypoint": "0x08000c08",
            "current_name": "calculate_new_value_08000c08",
            "code": "\nuint calculateNewValue_08000c08(uint inputValue)\n\n{\n  uint leadingZerosCount;\n  uint shiftAmount;\n  int intermediateValue;\n  uint mask;\n  \n  if (inputValue == 0) {\n    return 0;\n  }\n  leadingZerosCount = LZCOUNT(inputValue);\n  shiftAmount = leadingZerosCount - 8;\n  intermediateValue = shiftAmount * -0x800000 + 0x4a800000;\n  if (7 < leadingZerosCount) {\n    mask = 0 << (shiftAmount & 0xff);\n    leadingZerosCount = intermediateValue + (inputValue << (shiftAmount & 0xff)) +\n            (0U >> (0x20 - shiftAmount & 0xff)) + (uint)(0x7fffffff < mask);\n    if (mask == 0x80000000) {\n      leadingZerosCount = leadingZerosCount & 0xfffffffe;\n    }\n    return leadingZerosCount;\n  }\n  shiftAmount = inputValue << leadingZerosCount + 0x18;\n  leadingZerosCount = intermediateValue + ((inputValue >> (0x20 - (leadingZerosCount + 0x18) & 0xff)) - ((int)shiftAmount >> 0x1f));\n  if ((shiftAmount & 0x7fffffff) == 0) {\n    leadingZerosCount = leadingZerosCount & ~(shiftAmount >> 0x1f);\n  }\n  return leadingZerosCount;\n}\n\n",
            "renaming": {
                "FUN_08000c08": "calculate_new_value_08000c08",
                "param_1": "inputValue",
                "uVar1": "leadingZerosCount",
                "uVar2": "shiftAmount",
                "iVar3": "intermediateValue",
                "uVar4": "mask"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000c10": {
            "entrypoint": "0x08000c10",
            "current_name": "decode_uint_08000c10",
            "code": "\nuint decode_uint_08000c10(uint input_value)\n\n{\n  uint leading_zeros;\n  uint shift_distance;\n  uint sign_bit;\n  int offset;\n  \n  sign_bit = input_value & 0x80000000;\n  if ((int)sign_bit < 0) {\n    input_value = -input_value;\n  }\n  if (input_value == 0) {\n    return 0;\n  }\n  leading_zeros = count_leading_zeros(input_value);\n  shift_distance = leading_zeros - 8;\n  offset = ((sign_bit | 0x4b000000) - 0x800000) + shift_distance * -0x800000;\n  if (7 < leading_zeros) {\n    leading_zeros = 0 << (shift_distance & 0xff);\n    sign_bit = offset + (input_value << (shift_distance & 0xff)) +\n            (0U >> (0x20 - shift_distance & 0xff)) + (uint)(0x7fffffff < leading_zeros);\n    if (leading_zeros == 0x80000000) {\n      sign_bit = sign_bit & 0xfffffffe;\n    }\n    return sign_bit;\n  }\n  shift_distance = input_value << leading_zeros + 0x18;\n  sign_bit = offset + ((input_value >> (0x20 - (leading_zeros + 0x18) & 0xff)) - ((int)shift_distance >> 0x1f));\n  if ((shift_distance & 0x7fffffff) == 0) {\n    sign_bit = sign_bit & ~(shift_distance >> 0x1f);\n  }\n  return sign_bit;\n}\n\n",
            "renaming": {
                "FUN_08000c10": "decode_uint_08000c10",
                "param_1": "input_value",
                "uVar1": "leading_zeros",
                "uVar2": "shift_distance",
                "uVar3": "sign_bit",
                "iVar4": "offset",
                "LZCOUNT": "count_leading_zeros"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08004ae0",
                "FUN_080049cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000cb8": {
            "entrypoint": "0x08000cb8",
            "current_name": "calculate_floating_point_08000cb8",
            "code": "\nuint calculateFloatingPoint_08000cb8(uint input1,uint input2,undefined4 constant1,uint constant2)\n\n{\n  longlong product;\n  uint result;\n  uint shift1;\n  int sum;\n  int diff;\n  uint mul_result;\n  int mul_diff;\n  uint normalized_input;\n  bool is_equal;\n  bool is_negative;\n  \n  shift1 = input1 >> 0x17 & 0xff;\n  is_equal = shift1 == 0;\n  if (!is_equal) {\n    constant2 = input2 >> 0x17 & 0xff;\n    is_equal = constant2 == 0;\n  }\n  if (!is_equal) {\n    is_equal = shift1 == 0xff;\n  }\n  if (!is_equal) {\n    is_equal = constant2 == 0xff;\n  }\n  if (is_equal) {\n    constant2 = input2 >> 0x17 & 0xff;\n    if (shift1 == 0xff || constant2 == 0xff) {\n      is_equal = input1 == 0 || input1 == 0x80000000;\n      result = input2;\n      if (input1 != 0 && input1 != 0x80000000) {\n        is_equal = input2 == 0;\n        result = input1;\n      }\n      if (!is_equal) {\n        is_equal = input2 == 0x80000000;\n      }\n      normalized_input = result;\n      if (((is_equal) || ((shift1 == 0xff && ((result & 0x7fffff) != 0)))) ||\n         ((constant2 == 0xff && (normalized_input = input2, (input2 & 0x7fffff) != 0)))) {\n        return normalized_input | 0x7fc00000;\n      }\n      result = result ^ input2;\n      goto LAB_08000e08;\n    }\n    is_equal = (input1 & 0x7fffffff) == 0;\n    if (!is_equal) {\n      is_equal = (input2 & 0x7fffffff) == 0;\n    }\n    if (is_equal) {\n      return (input1 ^ input2) & 0x80000000;\n    }\n    is_equal = shift1 == 0;\n    result = input1 & 0x80000000;\n    while( true ) {\n      if (is_equal) {\n        input1 = input1 << 1;\n        is_equal = (input1 & 0x800000) == 0;\n      }\n      if (!is_equal) break;\n      shift1 = shift1 - 1;\n    }\n    input1 = input1 | result;\n    is_equal = constant2 == 0;\n    result = input2 & 0x80000000;\n    while( true ) {\n      if (is_equal) {\n        input2 = input2 << 1;\n        is_equal = (input2 & 0x800000) == 0;\n      }\n      if (!is_equal) break;\n      constant2 = constant2 - 1;\n    }\n    input2 = input2 | result;\n  }\n  sum = shift1 + constant2;\n  normalized_input = input1 ^ input2;\n  shift1 = input1 << 9;\n  is_equal = shift1 == 0;\n  if (!is_equal) {\n    input2 = input2 << 9;\n    is_equal = input2 == 0;\n  }\n  if (is_equal) {\n    if (shift1 == 0) {\n      input2 = input2 << 9;\n    }\n    result = normalized_input & 0x80000000 | input1 & 0x7fffff | input2 >> 9;\n    is_negative = SBORROW4(sum,0x7f);\n    diff = sum + -0x7f;\n    is_equal = diff == 0;\n    mul_diff = diff;\n    if (!is_equal && 0x7e < sum) {\n      is_negative = SBORROW4(0xff,diff);\n      mul_diff = 0xff - diff;\n      is_equal = diff == 0xff;\n    }\n    if (!is_equal && mul_diff < 0 == is_negative) {\n      result = result | diff * 0x800000;\n    }\n    if (!is_equal && mul_diff < 0 == is_negative) {\n      return result;\n    }\n    result = result | 0x800000;\n    mul_result = 0;\n    is_negative = SBORROW4(diff,1);\n    normalized_input = sum - 0x80;\n    is_equal = normalized_input == 0;\n    shift1 = normalized_input;\n  }\n  else {\n    product = (ulonglong)(shift1 >> 5 | 0x8000000) * (ulonglong)(input2 >> 5 | 0x8000000);\n    mul_result = (uint)product;\n    result = (uint)((ulonglong)product >> 0x20);\n    is_equal = result < 0x800000;\n    if (is_equal) {\n      result = result << 1;\n    }\n    if (is_equal) {\n      result = result | mul_result >> 0x1f;\n      mul_result = mul_result << 1;\n    }\n    result = normalized_input & 0x80000000 | result;\n    normalized_input = (sum + -0x7f) - (uint)is_equal;\n    is_negative = SBORROW4(normalized_input,0xfd);\n    is_equal = normalized_input == 0xfd;\n    shift1 = normalized_input - 0xfd;\n    if (normalized_input < 0xfe) {\n      result = result + normalized_input * 0x800000 + (uint)(0x7fffffff < mul_result);\n      if (mul_result == 0x80000000) {\n        result = result & 0xfffffffe;\n      }\n      return result;\n    }\n  }\n  if (is_equal || (int)shift1 < 0 != is_negative) {\n    is_equal = (int)(normalized_input + 0x19) < 0;\n    if (normalized_input == 0xffffffe7 || is_equal != SCARRY4(normalized_input,0x19)) {\n      result = result & 0x80000000;\n    }\n    if (normalized_input != 0xffffffe7 && is_equal == SCARRY4(normalized_input,0x19)) {\n      shift1 = (result << 1) >> (-normalized_input & 0xff);\n      normalized_input = result << (normalized_input + 0x20 & 0xff);\n      shift1 = ((uint)((result & 0x80000000) != 0) << 0x1f | shift1 >> 1) + (uint)((byte)shift1 & 1);\n      if ((mul_result | normalized_input << 1) == 0) {\n        shift1 = shift1 & ~(normalized_input >> 0x1f);\n      }\n      return shift1;\n    }\n    return result;\n  }\nLAB_08000e08:\n  return result & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000cb8": "calculate_floating_point_08000cb8",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "constant1",
                "param_4": "constant2",
                "lVar1": "product",
                "uVar2": "result",
                "uVar3": "shift1",
                "iVar4": "sum",
                "iVar5": "diff",
                "uVar6": "mul_result",
                "iVar7": "mul_diff",
                "uVar8": "normalized_input",
                "bVar9": "is_equal",
                "bVar10": "is_negative"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000e20": {
            "entrypoint": "0x08000e20",
            "current_name": "calculate_float_08000e20",
            "code": "\nuint calculateFloat_08000e20(uint input1,uint input2,undefined4 undefined,uint input3)\n\n{\n  uint temp1;\n  uint temp2;\n  int temp3;\n  uint temp4;\n  int temp5;\n  uint temp6;\n  bool flag1;\n  bool flag2;\n  bool flag3;\n  \n  temp2 = input1 >> 0x17 & 0xff;\n  flag1 = temp2 == 0;\n  if (!flag1) {\n    input3 = input2 >> 0x17 & 0xff;\n    flag1 = input3 == 0;\n  }\n  if (!flag1) {\n    flag1 = temp2 == 0xff;\n  }\n  if (!flag1) {\n    flag1 = input3 == 0xff;\n  }\n  if (flag1) {\n    input3 = input2 >> 0x17 & 0xff;\n    temp6 = input1;\n    if (temp2 == 0xff) {\n      if (((input1 & 0x7fffff) != 0) || (temp6 = input2, input3 == 0xff)) {\nLAB_08000e16:\n        return temp6 | 0x7fc00000;\n      }\n    }\n    else {\n      if (input3 == 0xff) {\n        temp6 = input2;\n        if ((input2 & 0x7fffff) == 0) {\nLAB_08000dcc:\n          return (input1 ^ input2) & 0x80000000;\n        }\n        goto LAB_08000e16;\n      }\n      flag1 = (input1 & 0x7fffffff) == 0;\n      if (!flag1) {\n        flag1 = (input2 & 0x7fffffff) == 0;\n      }\n      if (!flag1) {\n        flag1 = temp2 == 0;\n        temp6 = input1 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            input1 = input1 << 1;\n            flag1 = (input1 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          temp2 = temp2 - 1;\n        }\n        input1 = input1 | temp6;\n        flag1 = input3 == 0;\n        temp6 = input2 & 0x80000000;\n        while( true ) {\n          if (flag1) {\n            input2 = input2 << 1;\n            flag1 = (input2 & 0x800000) == 0;\n          }\n          if (!flag1) break;\n          input3 = input3 - 1;\n        }\n        input2 = input2 | temp6;\n        goto LAB_08000e38;\n      }\n      if ((input1 & 0x7fffffff) == 0) {\n        if ((input2 & 0x7fffffff) != 0) goto LAB_08000dcc;\n        goto LAB_08000e16;\n      }\n    }\n    input1 = input1 ^ input2;\n  }\n  else {\nLAB_08000e38:\n    temp3 = temp2 - input3;\n    if (input2 << 9 == 0) {\n      input1 = (input1 ^ input2) & 0x80000000 | input1 & 0x7fffff;\n      flag3 = SCARRY4(temp3,0x7f);\n      temp5 = temp3 + 0x7f;\n      flag1 = temp5 < 0;\n      flag2 = temp5 == 0;\n      if (!flag2 && flag1 == flag3) {\n        flag3 = SBORROW4(0xff,temp5);\n        flag1 = 0xff - temp5 < 0;\n        flag2 = temp5 == 0xff;\n      }\n      if (!flag2 && flag1 == flag3) {\n        input1 = input1 | temp5 * 0x800000;\n      }\n      if (!flag2 && flag1 == flag3) {\n        return input1;\n      }\n      input1 = input1 | 0x800000;\n      temp2 = 0;\n      flag2 = SBORROW4(temp5,1);\n      temp4 = temp3 + 0x7e;\n      flag1 = temp4 == 0;\n      temp6 = temp4;\n    }\n    else {\n      temp1 = (input2 << 9) >> 4 | 0x10000000;\n      temp2 = (input1 << 9) >> 4 | 0x10000000;\n      input1 = (input1 ^ input2) & 0x80000000;\n      flag1 = temp1 <= temp2;\n      if (!flag1) {\n        temp2 = temp2 << 1;\n      }\n      temp4 = temp3 + 0x7d + (uint)flag1;\n      temp6 = 0x800000;\n      do {\n        if (temp1 <= temp2) {\n          temp2 = temp2 - temp1;\n          input1 = input1 | temp6;\n        }\n        flag1 = temp1 >> 1 <= temp2;\n        if (flag1) {\n          temp2 = temp2 - (temp1 >> 1);\n        }\n        if (flag1) {\n          input1 = input1 | temp6 >> 1;\n        }\n        flag1 = temp1 >> 2 <= temp2;\n        if (flag1) {\n          temp2 = temp2 - (temp1 >> 2);\n        }\n        if (flag1) {\n          input1 = input1 | temp6 >> 2;\n        }\n        flag1 = temp1 >> 3 <= temp2;\n        if (flag1) {\n          temp2 = temp2 - (temp1 >> 3);\n        }\n        if (flag1) {\n          input1 = input1 | temp6 >> 3;\n        }\n        temp2 = temp2 * 0x10;\n        flag1 = temp2 == 0;\n        if (!flag1) {\n          temp6 = temp6 >> 4;\n          flag1 = temp6 == 0;\n        }\n      } while (!flag1);\n      flag2 = SBORROW4(temp4,0xfd);\n      flag1 = temp4 == 0xfd;\n      temp6 = temp4 - 0xfd;\n      if (temp4 < 0xfe) {\n        input1 = input1 + temp4 * 0x800000 + (uint)(temp1 <= temp2);\n        if (temp2 - temp1 == 0) {\n          input1 = input1 & 0xfffffffe;\n        }\n        return input1;\n      }\n    }\n    if (flag1 || (int)temp6 < 0 != flag2) {\n      flag1 = (int)(temp4 + 0x19) < 0;\n      if (temp4 == 0xffffffe7 || flag1 != SCARRY4(temp4,0x19)) {\n        input1 = input1 & 0x80000000;\n      }\n      if (temp4 == 0xffffffe7 || flag1 != SCARRY4(temp4,0x19)) {\n        return input1;\n      }\n      temp6 = (input1 << 1) >> (-temp4 & 0xff);\n      temp4 = input1 << (temp4 + 0x20 & 0xff);\n      temp6 = ((uint)((input1 & 0x80000000) != 0) << 0x1f | temp6 >> 1) + (uint)((byte)temp6 & 1);\n      if ((temp2 | temp4 << 1) == 0) {\n        temp6 = temp6 & ~(temp4 >> 0x1f);\n      }\n      return temp6;\n    }\n  }\n  return input1 & 0x80000000 | 0x7f800000;\n}\n\n",
            "renaming": {
                "FUN_08000e20": "calculate_float_08000e20",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "undefined",
                "param_4": "input3",
                "uVar1": "temp1",
                "uVar2": "temp2",
                "iVar3": "temp3",
                "uVar4": "temp4",
                "iVar5": "temp5",
                "uVar6": "temp6",
                "bVar7": "flag1",
                "bVar8": "flag2",
                "bVar9": "flag3"
            },
            "calling": [
                "FUN_080049cc",
                "FUN_08004d78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000f68": {
            "entrypoint": "0x08000f68",
            "current_name": "determine_overflow_and_sign_08000f68",
            "code": "\nuint determine_overflow_and_sign_08000f68(uint input_1,uint input_2)\n\n{\n  bool is_positive;\n  uint input_1_times_2;\n  uint input_2_times_2;\n  uint combined_input;\n  bool is_zero;\n  \n  input_1_times_2 = input_1 * 2;\n  input_2_times_2 = input_2 * 2;\n  if (((int)input_1_times_2 >> 0x18 == -1 || (int)input_2_times_2 >> 0x18 == -1) &&\n     ((((int)input_1_times_2 >> 0x18 == -1 && ((input_1 & 0x7fffff) != 0)) ||\n      (((int)input_2_times_2 >> 0x18 == -1 && ((input_2 & 0x7fffff) != 0)))))) {\n    return 1;\n  }\n  combined_input = input_1_times_2 | input_2 & 0x7fffffff;\n  is_zero = combined_input == 0;\n  if (!is_zero) {\n    combined_input = input_1 ^ input_2;\n    is_zero = combined_input == 0;\n  }\n  is_positive = -1 < (int)combined_input;\n  if (is_positive) {\n    input_1 = input_1_times_2 + input_2 * -2;\n    is_zero = input_1 == 0;\n  }\n  if ((is_positive && input_2_times_2 <= input_1_times_2) && !is_zero) {\n    input_1 = (int)input_2 >> 0x1f;\n  }\n  if (!is_positive || input_2_times_2 > input_1_times_2) {\n    input_1 = ~((int)input_2 >> 0x1f);\n  }\n  if (!is_zero) {\n    input_1 = input_1 | 1;\n  }\n  return input_1;\n}\n\n",
            "renaming": {
                "FUN_08000f68": "determine_overflow_and_sign_08000f68",
                "param_1": "input_1",
                "param_2": "input_2",
                "uVar2": "input_1_times_2",
                "uVar3": "input_2_times_2",
                "uVar4": "combined_input",
                "bVar1": "is_positive",
                "bVar5": "is_zero"
            },
            "calling": [
                "FUN_08000fd0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fc8": {
            "entrypoint": "0x08000fc8",
            "current_name": "concatenate_parameters_08000fc8",
            "code": "\nvoid concatenateParameters_08000fc8(undefined4 destination,undefined4 source)\n\n{\n  concatenate_parameters_08000fd0(source,destination);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08000fc8": "concatenate_parameters_08000fc8",
                "param_1": "destination",
                "param_2": "source"
            },
            "calling": [
                "FUN_08001030"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000fd0": {
            "entrypoint": "0x08000fd0",
            "current_name": "concatenate_parameters_08000fd0",
            "code": "\nundefined8 concatenateParameters_08000fd0(undefined4 firstParameter,undefined4 secondParameter)\n\n{\n  determine_overflow_and_sign_08000f68();\n  return CONCAT44(secondParameter,firstParameter);\n}\n\n",
            "renaming": {
                "FUN_08000fd0": "concatenate_parameters_08000fd0",
                "param_1": "firstParameter",
                "param_2": "secondParameter"
            },
            "calling": [
                "FUN_08000fc8",
                "FUN_08000ff4"
            ],
            "called": [
                "FUN_08000f68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08000ff4": {
            "entrypoint": "0x08000ff4",
            "current_name": "is_null_terminated_08000ff4",
            "code": "\nbool is_null_terminated_08000ff4(void)\n\n{\n  char input_char;\n  \n  concatenate_parameters_08000fd0();\n  return input_char == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08000ff4": "is_null_terminated_08000ff4",
                "in_CY": "input_char"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fd0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001030": {
            "entrypoint": "0x08001030",
            "current_name": "check_if_concatenation_is_empty_08001030",
            "code": "\nbool check_if_concatenation_is_empty_08001030(void)\n\n{\n  char concatenation_result;\n  \n  concatenate_parameters_08000fc8();\n  return concatenation_result == '\\0';\n}\n\n",
            "renaming": {
                "FUN_08001030": "check_if_concatenation_is_empty_08001030",
                "in_CY": "concatenation_result"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08000fc8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001044": {
            "entrypoint": "0x08001044",
            "current_name": "calculate_shifted_value_08001044",
            "code": "\nuint calculateShiftedValue_08001044(uint inputValue)\n\n{\n  uint shiftAmount;\n  \n  if (((inputValue & 0x80000000) != 0) || (inputValue << 1 < 0x7f000000)) {\n    return 0;\n  }\n  shiftAmount = 0x9e - ((inputValue << 1) >> 0x18);\n  if (-1 < (int)shiftAmount) {\n    return (inputValue << 8 | 0x80000000) >> (shiftAmount & 0xff);\n  }\n  if ((shiftAmount == 0xffffff9f) && ((inputValue & 0x7fffff) != 0)) {\n    return 0;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_08001044": "calculate_shifted_value_08001044",
                "param_1": "inputValue",
                "uVar1": "shiftAmount"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001084": {
            "entrypoint": "0x08001084",
            "current_name": "memcpy_aligned_08001084",
            "code": "\nundefined4 * memcpy_aligned_08001084(undefined4 *destination,undefined4 *source,uint size)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *dest_next_ptr;\n  undefined4 *src_ptr;\n  uint remaining_size;\n  uint copy_size;\n  bool should_copy;\n  \n  dest_next_ptr = destination;\n  if ((((uint)source | (uint)destination) & 3) != 0) {\n    if (size < 8) {\n      copy_size = size - 4;\n      if (3 < size) {\n        do {\n          dest_ptr = source;\n          src_ptr = dest_next_ptr;\n          should_copy = copy_size != 0;\n          copy_size = copy_size - 1;\n          *(undefined *)src_ptr = *(undefined *)dest_ptr;\n          dest_next_ptr = (undefined4 *)((int)src_ptr + 1);\n          source = (undefined4 *)((int)dest_ptr + 1);\n        } while (should_copy);\n        *(undefined *)(undefined4 *)((int)src_ptr + 1) =\n             *(undefined *)(undefined4 *)((int)dest_ptr + 1);\n        *(undefined *)((int)src_ptr + 2) = *(undefined *)((int)dest_ptr + 2);\n        *(undefined *)((int)src_ptr + 3) = *(undefined *)((int)dest_ptr + 3);\n        return destination;\n      }\n      goto LAB_08001108;\n    }\n    if ((((uint)source & 3) != 0) && (((uint)destination & 3) != 0)) {\n      copy_size = 4 - ((uint)destination & 3);\n      size = size - copy_size;\n      dest_ptr = destination;\n      src_ptr = source;\n      if (((uint)destination & 1) != 0) {\n        src_ptr = (undefined4 *)((int)source + 1);\n        dest_ptr = (undefined4 *)((int)destination + 1);\n        *(undefined *)destination = *(undefined *)source;\n      }\n      dest_next_ptr = dest_ptr;\n      source = src_ptr;\n      if ((copy_size & 2) != 0) {\n        source = (undefined4 *)((int)src_ptr + 2);\n        dest_next_ptr = (undefined4 *)((int)dest_ptr + 2);\n        *(undefined2 *)dest_ptr = *(undefined2 *)src_ptr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *dest_next_ptr = *source;\n    dest_next_ptr[1] = source[1];\n    dest_next_ptr[2] = source[2];\n    dest_next_ptr[3] = source[3];\n    dest_next_ptr[4] = source[4];\n    dest_next_ptr[5] = source[5];\n    dest_next_ptr[6] = source[6];\n    dest_next_ptr[7] = source[7];\n    dest_next_ptr[8] = source[8];\n    dest_next_ptr[9] = source[9];\n    dest_next_ptr[10] = source[10];\n    dest_next_ptr[0xb] = source[0xb];\n    dest_next_ptr[0xc] = source[0xc];\n    dest_next_ptr[0xd] = source[0xd];\n    dest_next_ptr[0xe] = source[0xe];\n    dest_next_ptr[0xf] = source[0xf];\n    dest_next_ptr = dest_next_ptr + 0x10;\n    source = source + 0x10;\n    size = size - 0x40;\n  }\n  remaining_size = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *dest_next_ptr = *source;\n      dest_next_ptr[1] = source[1];\n      dest_next_ptr[2] = source[2];\n      dest_next_ptr[3] = source[3];\n      dest_next_ptr = dest_next_ptr + 4;\n      source = source + 4;\n      should_copy = 0xf < remaining_size;\n      remaining_size = remaining_size - 0x10;\n    } while (should_copy);\n  }\n  copy_size = remaining_size + 0xc;\n  src_ptr = dest_next_ptr;\n  dest_ptr = source;\n  if (0xfffffff3 < remaining_size) {\n    do {\n      source = dest_ptr + 1;\n      *src_ptr = *dest_ptr;\n      should_copy = 3 < copy_size;\n      copy_size = copy_size - 4;\n      dest_next_ptr = src_ptr + 1;\n      src_ptr = src_ptr + 1;\n      dest_ptr = source;\n    } while (should_copy);\n  }\nLAB_08001108:\n  if (copy_size + 4 != 0) {\n    dest_ptr = dest_next_ptr;\n    src_ptr = source;\n    if ((copy_size & 1) != 0) {\n      src_ptr = (undefined4 *)((int)source + 1);\n      dest_ptr = (undefined4 *)((int)dest_next_ptr + 1);\n      *(undefined *)dest_next_ptr = *(undefined *)source;\n    }\n    if ((copy_size + 4 & 2) != 0) {\n      *(undefined2 *)dest_ptr = *(undefined2 *)src_ptr;\n    }\n  }\n  return destination;\n}\n\n",
            "renaming": {
                "FUN_08001084": "memcpy_aligned_08001084",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "size",
                "puVar1": "dest_ptr",
                "puVar2": "dest_next_ptr",
                "puVar3": "src_ptr",
                "uVar4": "remaining_size",
                "uVar5": "copy_size",
                "bVar6": "should_copy"
            },
            "calling": [
                "FUN_08009120",
                "FUN_080097cc",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001170": {
            "entrypoint": "0x08001170",
            "current_name": "check_params_08001170",
            "code": "\nundefined4 checkParams_08001170(uint input1,int input2,uint input3,int input4)\n\n{\n  if ((((input2 << 1) >> 0x15 != -1) || ((input1 | input2 << 0xc) == 0)) &&\n     (((input4 << 1) >> 0x15 != -1 || ((input3 | input4 << 0xc) == 0)))) {\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08001170": "check_params_08001170",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800119c": {
            "entrypoint": "0x0800119c",
            "current_name": "calculate_modified_value_0800119c",
            "code": "\nuint calculateModifiedValue_0800119c(uint inputValue,uint flagValue)\n\n{\n  uint shiftedValue;\n  int calculationResult;\n  uint modifiedValue;\n  \n  calculationResult = flagValue * 2 + 0x200000;\n  if (flagValue * 2 < 0xffe00000) {\n    if (-1 < calculationResult) {\n      return 0;\n    }\n    shiftedValue = calculationResult >> 0x15;\n    modifiedValue = -shiftedValue - 0x3e1;\n    if (shiftedValue < 0xfffffc20 && modifiedValue != 0) {\n      shiftedValue = (flagValue << 0xb | 0x80000000 | inputValue >> 0x15) >> (modifiedValue & 0xff);\n      if ((flagValue & 0x80000000) != 0) {\n        shiftedValue = -shiftedValue;\n      }\n      return shiftedValue;\n    }\n  }\n  else if ((inputValue | flagValue << 0xc) != 0) {\n    return 0;\n  }\n  flagValue = flagValue & 0x80000000;\n  if (flagValue == 0) {\n    flagValue = 0x7fffffff;\n  }\n  return flagValue;\n}\n\n",
            "renaming": {
                "FUN_0800119c": "calculate_modified_value_0800119c",
                "param_1": "inputValue",
                "param_2": "flagValue",
                "uVar1": "shiftedValue",
                "iVar2": "calculationResult",
                "uVar3": "modifiedValue"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080011ec": {
            "entrypoint": "0x080011ec",
            "current_name": "calculate_result_080011ec",
            "code": "\nundefined8 calculate_result_080011ec(int input_param_1,int input_param_2,int input_param_3,int input_param_4)\n\n{\n  undefined8 result;\n  \n  if ((input_param_4 == 0) && (input_param_3 == 0)) {\n    if (input_param_2 != 0 || input_param_1 != 0) {\n      input_param_2 = -1;\n      input_param_1 = -1;\n    }\n    return CONCAT44(input_param_2,input_param_1);\n  }\n  result = calculate_remainder_0800121c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080011ec": "calculate_result_080011ec",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4",
                "uVar1": "result"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_0800121c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800121c": {
            "entrypoint": "0x0800121c",
            "current_name": "calculate_remainder_0800121c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080014b2) */\n\nundefined8 calculate_remainder_0800121c(uint dividend,uint dividend_lower_32,uint divisor,uint divisor_lower_32,uint *remainder)\n\n{\n  code *software_udf;\n  ulonglong result_lower_32;\n  uint quotient1;\n  uint quotient2;\n  uint remainder1;\n  int shift_count;\n  uint quotient;\n  uint divisor_upper_32;\n  uint remainder2;\n  uint *puVar9;\n  uint quotient_upper_32;\n  uint divisor_quotient;\n  uint divisor_remainder;\n  bool carry_flag;\n  undefined8 result;\n  \n  if (divisor_lower_32 == 0) {\n    if (dividend_lower_32 < divisor) {\n      shift_count = LZCOUNT(divisor);\n      divisor_upper_32 = divisor;\n      if (shift_count != 0) {\n        divisor_upper_32 = divisor << shift_count;\n        dividend_lower_32 = dividend >> (0x20U - shift_count & 0xff) | dividend_lower_32 << shift_count;\n        dividend = dividend << shift_count;\n      }\n      divisor_quotient = divisor_upper_32 >> 0x10;\n      remainder2 = dividend_lower_32 / divisor_quotient;\n      quotient_upper_32 = remainder2 * (divisor_upper_32 & 0xffff);\n      quotient = dividend >> 0x10 | (dividend_lower_32 - divisor_quotient * remainder2) * 0x10000;\n      quotient2 = remainder2;\n      if (quotient <= quotient_upper_32 && quotient_upper_32 - quotient != 0) {\n        carry_flag = CARRY4(divisor_upper_32,quotient);\n        quotient = divisor_upper_32 + quotient;\n        quotient2 = remainder2 - 1;\n        if ((carry_flag == false) && (quotient <= quotient_upper_32 && quotient_upper_32 - quotient != 0)) {\n          quotient2 = remainder2 - 2;\n          quotient = quotient + divisor_upper_32;\n        }\n      }\n      quotient1 = (quotient - quotient_upper_32) / divisor_quotient;\n      remainder1 = quotient1 * (divisor_upper_32 & 0xffff);\n      remainder2 = dividend & 0xffff | ((quotient - quotient_upper_32) - divisor_quotient * quotient1) * 0x10000;\n      quotient = quotient1;\n      if (remainder2 <= remainder1 && remainder1 - remainder2 != 0) {\n        carry_flag = CARRY4(divisor_upper_32,remainder2);\n        remainder2 = divisor_upper_32 + remainder2;\n        quotient = quotient1 - 1;\n        if ((carry_flag == false) && (remainder2 <= remainder1 && remainder1 - remainder2 != 0)) {\n          quotient = quotient1 - 2;\n          remainder2 = remainder2 + divisor_upper_32;\n        }\n      }\n      quotient = quotient | quotient2 << 0x10;\n      puVar9 = (uint *)0x0;\n      remainder2 = remainder2 - remainder1;\n    }\n    else {\n      if (divisor == 0) {\n                    /* WARNING: Treating indirect jump as call */\n        software_udf = (code *)software_udf(0xff,0x8001302);\n        result = (*software_udf)();\n        return result;\n      }\n      shift_count = LZCOUNT(divisor);\n      if (shift_count == 0) {\n        puVar9 = (uint *)0x1;\n        dividend_lower_32 = dividend_lower_32 - divisor;\n        divisor_quotient = divisor >> 0x10;\n        quotient1 = divisor & 0xffff;\n        divisor_upper_32 = divisor;\n      }\n      else {\n        divisor_upper_32 = divisor << shift_count;\n        quotient = dividend_lower_32 >> (0x20U - shift_count & 0xff);\n        divisor_quotient = divisor_upper_32 >> 0x10;\n        quotient_upper_32 = quotient / divisor_quotient;\n        quotient1 = divisor_upper_32 & 0xffff;\n        remainder1 = quotient_upper_32 * quotient1;\n        remainder2 = dividend >> (0x20U - shift_count & 0xff) | dividend_lower_32 << shift_count;\n        quotient2 = remainder2 >> 0x10 | (quotient - divisor_quotient * quotient_upper_32) * 0x10000;\n        dividend = dividend << shift_count;\n        quotient = quotient_upper_32;\n        if (quotient2 <= remainder1 && remainder1 - quotient2 != 0) {\n          carry_flag = CARRY4(divisor_upper_32,quotient2);\n          quotient2 = divisor_upper_32 + quotient2;\n          quotient = quotient_upper_32 - 1;\n          if ((carry_flag == false) && (quotient2 <= remainder1 && remainder1 - quotient2 != 0)) {\n            quotient = quotient_upper_32 - 2;\n            quotient2 = quotient2 + divisor_upper_32;\n          }\n        }\n        quotient_upper_32 = (quotient2 - remainder1) / divisor_quotient;\n        divisor_remainder = quotient_upper_32 * quotient1;\n        dividend_lower_32 = remainder2 & 0xffff | ((quotient2 - remainder1) - divisor_quotient * quotient_upper_32) * 0x10000;\n        quotient2 = quotient_upper_32;\n        if (dividend_lower_32 <= divisor_remainder && divisor_remainder - dividend_lower_32 != 0) {\n          carry_flag = CARRY4(divisor_upper_32,dividend_lower_32);\n          dividend_lower_32 = divisor_upper_32 + dividend_lower_32;\n          quotient2 = quotient_upper_32 - 1;\n          if ((carry_flag == false) && (dividend_lower_32 <= divisor_remainder && divisor_remainder - dividend_lower_32 != 0)) {\n            quotient2 = quotient_upper_32 - 2;\n            dividend_lower_32 = dividend_lower_32 + divisor_upper_32;\n          }\n        }\n        dividend_lower_32 = dividend_lower_32 - divisor_remainder;\n        puVar9 = (uint *)(quotient2 | quotient << 0x10);\n      }\n      quotient_upper_32 = dividend_lower_32 / divisor_quotient;\n      quotient = quotient1 * quotient_upper_32;\n      remainder2 = dividend >> 0x10 | (dividend_lower_32 - divisor_quotient * quotient_upper_32) * 0x10000;\n      quotient2 = quotient_upper_32;\n      if (remainder2 <= quotient && quotient - remainder2 != 0) {\n        carry_flag = CARRY4(divisor_upper_32,remainder2);\n        remainder2 = divisor_upper_32 + remainder2;\n        quotient2 = quotient_upper_32 - 1;\n        if ((carry_flag == false) && (remainder2 <= quotient && quotient - remainder2 != 0)) {\n          quotient2 = quotient_upper_32 - 2;\n          remainder2 = remainder2 + divisor_upper_32;\n        }\n      }\n      quotient_upper_32 = (remainder2 - quotient) / divisor_quotient;\n      quotient1 = quotient1 * quotient_upper_32;\n      remainder2 = dividend & 0xffff | ((remainder2 - quotient) - divisor_quotient * quotient_upper_32) * 0x10000;\n      quotient = quotient_upper_32;\n      if (remainder2 <= quotient1 && quotient1 - remainder2 != 0) {\n        carry_flag = CARRY4(divisor_upper_32,remainder2);\n        remainder2 = divisor_upper_32 + remainder2;\n        quotient = quotient_upper_32 - 1;\n        if ((carry_flag == false) && (remainder2 <= quotient1 && quotient1 - remainder2 != 0)) {\n          quotient = quotient_upper_32 - 2;\n          remainder2 = remainder2 + divisor_upper_32;\n        }\n      }\n      remainder2 = remainder2 - quotient1;\n      quotient = quotient | quotient2 << 0x10;\n    }\n    if (remainder != (uint *)0x0) {\n      *remainder = remainder2 >> LZCOUNT(divisor);\n      remainder[1] = 0;\n    }\n  }\n  else {\n    puVar9 = remainder;\n    if (dividend_lower_32 < divisor_lower_32) {\n      if (remainder != (uint *)0x0) {\n        *remainder = dividend;\n        remainder[1] = dividend_lower_32;\n        return 0;\n      }\n      quotient = 0;\n    }\n    else {\n      shift_count = LZCOUNT(divisor_lower_32);\n      if (shift_count == 0) {\n        if ((divisor_lower_32 < dividend_lower_32) || (divisor <= dividend)) {\n          carry_flag = dividend < divisor;\n          dividend = dividend - divisor;\n          dividend_lower_32 = (dividend_lower_32 - divisor_lower_32) - (uint)carry_flag;\n          quotient = 1;\n        }\n        else {\n          quotient = 0;\n        }\n        puVar9 = (uint *)0x0;\n        if (remainder != (uint *)0x0) {\n          *remainder = dividend;\n          remainder[1] = dividend_lower_32;\n        }\n      }\n      else {\n        remainder2 = 0x20 - shift_count;\n        quotient1 = divisor >> (remainder2 & 0xff) | divisor_lower_32 << shift_count;\n        divisor_upper_32 = dividend_lower_32 >> (remainder2 & 0xff);\n        remainder1 = quotient1 >> 0x10;\n        quotient_upper_32 = divisor_upper_32 / remainder1;\n        divisor_quotient = quotient_upper_32 * (quotient1 & 0xffff);\n        quotient = dividend_lower_32 << shift_count | dividend >> (remainder2 & 0xff);\n        quotient2 = quotient >> 0x10 | (divisor_upper_32 - remainder1 * quotient_upper_32) * 0x10000;\n        dividend = dividend << shift_count;\n        divisor_upper_32 = quotient_upper_32;\n        if (quotient2 <= divisor_quotient && divisor_quotient - quotient2 != 0) {\n          carry_flag = CARRY4(quotient1,quotient2);\n          quotient2 = quotient1 + quotient2;\n          divisor_upper_32 = quotient_upper_32 - 1;\n          if ((carry_flag == false) && (quotient2 <= divisor_quotient && divisor_quotient - quotient2 != 0)) {\n            divisor_upper_32 = quotient_upper_32 - 2;\n            quotient2 = quotient2 + quotient1;\n          }\n        }\n        quotient_upper_32 = (quotient2 - divisor_quotient) / remainder1;\n        divisor_remainder = quotient_upper_32 * (quotient1 & 0xffff);\n        quotient2 = quotient & 0xffff | ((quotient2 - divisor_quotient) - remainder1 * quotient_upper_32) * 0x10000;\n        quotient = quotient_upper_32;\n        if (quotient2 <= divisor_remainder && divisor_remainder - quotient2 != 0) {\n          carry_flag = CARRY4(quotient1,quotient2);\n          quotient2 = quotient1 + quotient2;\n          quotient = quotient_upper_32 - 1;\n          if ((carry_flag == false) && (quotient2 <= divisor_remainder && divisor_remainder - quotient2 != 0)) {\n            quotient = quotient_upper_32 - 2;\n            quotient2 = quotient2 + quotient1;\n          }\n        }\n        quotient = quotient | divisor_upper_32 << 0x10;\n        result_lower_32 = (ulonglong)quotient * (ulonglong)(divisor << shift_count);\n        if (CONCAT44(quotient2 - divisor_remainder,dividend) < result_lower_32) {\n          quotient = quotient - 1;\n          result_lower_32 = result_lower_32 - CONCAT44(quotient1,divisor << shift_count);\n        }\n        if (remainder != (uint *)0x0) {\n          divisor_upper_32 = ((quotient2 - divisor_remainder) - (int)(result_lower_32 >> 0x20)) - (uint)(dividend < (uint)result_lower_32);\n          *remainder = divisor_upper_32 << (remainder2 & 0xff) | dividend - (uint)result_lower_32 >> shift_count;\n          remainder[1] = divisor_upper_32 >> shift_count;\n          puVar9 = (uint *)0x0;\n        }\n      }\n    }\n  }\n  return CONCAT44(puVar9,quotient);\n}\n\n",
            "renaming": {
                "FUN_0800121c": "calculate_remainder_0800121c",
                "param_1": "dividend",
                "param_2": "dividend_lower_32",
                "param_3": "divisor",
                "param_4": "divisor_lower_32",
                "param_5": "remainder",
                "UNRECOVERED_JUMPTABLE": "software_udf",
                "uVar1": "result_lower_32",
                "uVar2": "quotient1",
                "uVar3": "quotient2",
                "uVar4": "remainder1",
                "iVar5": "shift_count",
                "uVar6": "quotient",
                "uVar7": "divisor_upper_32",
                "uVar8": "remainder2",
                "uVar10": "quotient_upper_32",
                "uVar11": "divisor_quotient",
                "uVar12": "divisor_remainder",
                "bVar13": "carry_flag",
                "uVar14": "result"
            },
            "calling": [
                "FUN_080011ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080014f0": {
            "entrypoint": "0x080014f0",
            "current_name": "initialize_system_080014f0",
            "code": "\n\n\nundefined4 initialize_system_080014f0(void)\n\n{\n  _DAT_40022000 = _DAT_40022000 | 0x10;\n  set_bit_pattern(3);\n  validate_and_update_param(0xf);\n  FUNC_08002d8a();\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080014f0": "initialize_system_080014f0",
                "set_bit_pattern_08001714": "set_bit_pattern",
                "validate_and_update_param_0800151c": "validate_and_update_param"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_0800151c",
                "FUN_08002d8a",
                "FUN_08001714"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800151c": {
            "entrypoint": "0x0800151c",
            "current_name": "validate_and_update_param_0800151c",
            "code": "\nundefined4 validateAndUpdateParam_0800151c(uint inputParam)\n\n{\n  int updateResult;\n  undefined4 returnValue;\n  \n  updateResult = update_value_08001762((int)((ulonglong)DAT_20000018 / (1000 / (ulonglong)DAT_20000004)));\n  if (updateResult == 0) {\n    if (inputParam < 0x10) {\n      write_value_to_memory_0800172a(0xffffffff,inputParam,0);\n      returnValue = 0;\n      DAT_20000000 = inputParam;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  else {\n    returnValue = 1;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800151c": "validate_and_update_param_0800151c",
                "param_1": "inputParam",
                "iVar1": "updateResult",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_080014f0",
                "FUN_08003260"
            ],
            "called": [
                "FUN_0800172a",
                "FUN_08001762"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800157c": {
            "entrypoint": "0x0800157c",
            "current_name": "increment_dat20000a48_0800157c",
            "code": "\nvoid incrementDAT20000a48_0800157c(void)\n\n{\n  DAT_20000a48 = DAT_20000a48 + (uint)DAT_20000004;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800157c": "increment_dat20000a48_0800157c"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015a0": {
            "entrypoint": "0x080015a0",
            "current_name": "get_data_value_080015a0",
            "code": "\nundefined4 get_data_value_080015a0(void)\n\n{\n  return DAT_20000a48;\n}\n\n",
            "renaming": {
                "FUN_080015a0": "get_data_value_080015a0"
            },
            "calling": [
                "FUN_08004436",
                "FUN_08001ccc",
                "FUN_08002c2e",
                "FUN_080027f4",
                "FUN_08002ca8",
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_08004f2c",
                "FUN_08002d98",
                "FUN_08003260",
                "FUN_08002640",
                "FUN_08001f6c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015b4": {
            "entrypoint": "0x080015b4",
            "current_name": "set_bit_pattern_080015b4",
            "code": "\n\n\nvoid setBitPattern_080015b4(uint input)\n\n{\n  _DAT_e000ed0c = _DAT_e000ed0c & 0xf8ff | (input & 7) << 8 | 0x5fa0000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080015b4": "set_bit_pattern_080015b4",
                "param_1": "input"
            },
            "calling": [
                "FUN_08001714"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080015fc": {
            "entrypoint": "0x080015fc",
            "current_name": "get_bits_from_register_080015fc",
            "code": "\n\n\nuint getBitsFromRegister_080015fc(void)\n\n{\n  return _DAT_e000ed0c >> 8 & 7;\n}\n\n",
            "renaming": {
                "FUN_080015fc": "get_bits_from_register_080015fc"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001618": {
            "entrypoint": "0x08001618",
            "current_name": "write_value_to_memory_08001618",
            "code": "\nvoid writeValueToMemory_08001618(byte address,uint value)\n\n{\n  if ((char)address < '\\0') {\n    *(char *)((address & 0xf) + 0xe000ed14) = (char)((value & 0xff) << 4);\n  }\n  else {\n    *(char *)((char)address + -0x1fff1c00) = (char)((value & 0xff) << 4);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001618": "write_value_to_memory_08001618",
                "param_1": "address",
                "param_2": "value"
            },
            "calling": [
                "FUN_0800172a",
                "FUN_080016d0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800166c": {
            "entrypoint": "0x0800166c",
            "current_name": "mask_bits_0800166c",
            "code": "\nuint maskBits_0800166c(uint inputBits,uint inputValue,uint outputValue)\n\n{\n  uint remainingBits;\n  \n  inputBits = inputBits & 7;\n  remainingBits = 7 - inputBits;\n  if (3 < remainingBits) {\n    remainingBits = 4;\n  }\n  if (inputBits + 4 < 7) {\n    inputBits = 0;\n  }\n  else {\n    inputBits = inputBits - 3;\n  }\n  return outputValue & ~(-1 << (inputBits & 0xff)) |\n         (~(-1 << (remainingBits & 0xff)) & inputValue) << (inputBits & 0xff);\n}\n\n",
            "renaming": {
                "FUN_0800166c": "mask_bits_0800166c",
                "param_1": "inputBits",
                "param_2": "inputValue",
                "param_3": "outputValue",
                "uVar1": "remainingBits"
            },
            "calling": [
                "FUN_0800172a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080016d0": {
            "entrypoint": "0x080016d0",
            "current_name": "check_and_update_value_080016d0",
            "code": "\n\n\nbool checkAndUpdateValue_080016d0(int value)\n\n{\n  bool isLessThanThreshold;\n  \n  isLessThanThreshold = value - 1U < 0x1000000;\n  if (isLessThanThreshold) {\n    _DAT_e000e014 = value + -1;\n    write_value_to_memory_08001618(0xffffffff,0xf);\n    _DAT_e000e018 = 0;\n    _DAT_e000e010 = 7;\n  }\n  return !isLessThanThreshold;\n}\n\n",
            "renaming": {
                "FUN_080016d0": "check_and_update_value_080016d0",
                "param_1": "value",
                "bVar1": "isLessThanThreshold"
            },
            "calling": [
                "FUN_08001762"
            ],
            "called": [
                "FUN_08001618"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001714": {
            "entrypoint": "0x08001714",
            "current_name": "set_bit_pattern_08001714",
            "code": "\nvoid setBitPattern_08001714(undefined4 pattern)\n\n{\n  setBitPattern_08001714Helper(pattern);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001714": "set_bit_pattern_08001714",
                "param_1": "pattern",
                "set_bit_pattern_080015b4": "setBitPatternHelper"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [
                "FUN_080015b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800172a": {
            "entrypoint": "0x0800172a",
            "current_name": "write_value_to_memory_0800172a",
            "code": "\nvoid writeValueToMemory_0800172a(char inputCharacter,undefined4 bitMask1,undefined4 bitMask2)\n\n{\n  undefined4 bitsFromRegister;\n  \n  bitsFromRegister = getBitsFromRegister();\n  bitsFromRegister = maskBits(bitsFromRegister,bitMask1,bitMask2);\n  writeValueToMemory_0800172a((int)inputCharacter,bitsFromRegister);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800172a": "write_value_to_memory_0800172a",
                "param_1": "inputCharacter",
                "param_2": "bitMask1",
                "param_3": "bitMask2",
                "uVar1": "bitsFromRegister",
                "get_bits_from_register_080015fc": "getBitsFromRegister",
                "mask_bits_0800166c": "maskBits",
                "write_value_to_memory_08001618": "writeValueToMemory"
            },
            "calling": [
                "FUN_0800151c",
                "FUN_080052a0"
            ],
            "called": [
                "FUN_08001618",
                "FUN_080015fc",
                "FUN_0800166c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001762": {
            "entrypoint": "0x08001762",
            "current_name": "update_value_08001762",
            "code": "\nundefined4 update_value_08001762(undefined4 value)\n\n{\n  undefined4 result;\n  \n  result = check_and_update_value_08001762_080016d0(value);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001762": "update_value_08001762",
                "param_1": "value",
                "uVar1": "result"
            },
            "calling": [
                "FUN_0800151c",
                "FUN_080052a0"
            ],
            "called": [
                "FUN_080016d0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800177c": {
            "entrypoint": "0x0800177c",
            "current_name": "set_e000e010_bit_0800177c",
            "code": "\n\n\nvoid set_e000e010_bit_0800177c(int value)\n\n{\n  if (value == 4) {\n    _DAT_e000e010 = _DAT_e000e010 | 4;\n  }\n  else {\n    _DAT_e000e010 = _DAT_e000e010 & 0xfffffffb;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800177c": "set_e000e010_bit_0800177c",
                "param_1": "value"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017b4": {
            "entrypoint": "0x080017b4",
            "current_name": "initialize_values_080017b4",
            "code": "\nvoid initialize_values_080017b4(void)\n\n{\n  decode_and_update_values(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080017b4": "initialize_values_080017b4",
                "decode_and_update_values_08004f78": "decode_and_update_values"
            },
            "calling": [
                "FUN_08005704"
            ],
            "called": [
                "FUN_08004f78"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080017c4": {
            "entrypoint": "0x080017c4",
            "current_name": "update_memory_values_080017c4",
            "code": "\n\n\nvoid updateMemoryValues_080017c4(uint *targetMemory,uint *sourceMemory)\n\n{\n  uint mask;\n  uint bitCheck;\n  uint value;\n  uint *ptr;\n  int index;\n  uint newValue;\n  uint counter;\n  \n  newValue = 0;\n  counter = 0;\n  do {\n    if (0xf < counter) {\n      return;\n    }\n    mask = 1 << (counter & 0xff);\n    bitCheck = *sourceMemory & mask;\n    if (bitCheck == mask) {\n      value = sourceMemory[1];\n      if (value == 0x12) {\n        newValue = sourceMemory[3] + 0xc;\n      }\n      else if (value < 0x13) {\n        if (value == 2) {\n          newValue = sourceMemory[3] + 8;\n        }\n        else if (value < 3) {\n          if (value == 0) goto LAB_08001882;\n          if (value == 1) {\n            newValue = sourceMemory[3];\n          }\n        }\n        else if (value == 3) {\n          newValue = 0;\n        }\n        else if (value == 0x11) {\n          newValue = sourceMemory[3] + 4;\n        }\n      }\n      else if (value == 0x10210000) {\nLAB_08001882:\n        if (sourceMemory[2] == 0) {\n          newValue = 4;\n        }\n        else if (sourceMemory[2] == 1) {\n          newValue = 8;\n          targetMemory[4] = mask;\n        }\n        else {\n          newValue = 8;\n          targetMemory[5] = mask;\n        }\n      }\n      else if (value < 0x10210001) {\n        if ((value == 0x10110000) || (value == 0x10120000)) goto LAB_08001882;\n      }\n      else if (((value == 0x10310000) || (value == 0x10320000)) || (value == 0x10220000))\n      goto LAB_08001882;\n      if (bitCheck < 0x100) {\n        mask = counter << 2;\n        ptr = targetMemory;\n      }\n      else {\n        ptr = targetMemory + 1;\n        mask = (counter - 8) * 4;\n      }\n      *ptr = *ptr & ~(0xf << (mask & 0xff)) | newValue << (mask & 0xff);\n      if ((sourceMemory[1] & 0x10000000) != 0) {\n        _DAT_40021018 = _DAT_40021018 | 1;\n        if (targetMemory == (uint *)0x40010800) {\n          index = 0;\n        }\n        else if (targetMemory == (uint *)0x40010c00) {\n          index = 1;\n        }\n        else if (targetMemory == (uint *)0x40011000) {\n          index = 2;\n        }\n        else if (targetMemory == (uint *)0x40011400) {\n          index = 3;\n        }\n        else {\n          index = 4;\n        }\n        *(uint *)(((counter >> 2) + 2) * 4 + 0x40010000) =\n             index << ((counter & 3) << 2) |\n             ~(0xf << ((counter & 3) << 2)) & *(uint *)(((counter >> 2) + 2) * 4 + 0x40010000);\n        if ((sourceMemory[1] & 0x10000) == 0) {\n          _DAT_40010400 = ~bitCheck & _DAT_40010400;\n        }\n        else {\n          _DAT_40010400 = bitCheck | _DAT_40010400;\n        }\n        if ((sourceMemory[1] & 0x20000) == 0) {\n          _DAT_40010404 = ~bitCheck & _DAT_40010404;\n        }\n        else {\n          _DAT_40010404 = bitCheck | _DAT_40010404;\n        }\n        if ((sourceMemory[1] & 0x100000) == 0) {\n          _DAT_40010408 = ~bitCheck & _DAT_40010408;\n        }\n        else {\n          _DAT_40010408 = bitCheck | _DAT_40010408;\n        }\n        if ((sourceMemory[1] & 0x200000) == 0) {\n          _DAT_4001040c = ~bitCheck & _DAT_4001040c;\n        }\n        else {\n          _DAT_4001040c = bitCheck | _DAT_4001040c;\n        }\n      }\n    }\n    counter = counter + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_080017c4": "update_memory_values_080017c4",
                "param_1": "targetMemory",
                "param_2": "sourceMemory",
                "uVar1": "mask",
                "uVar2": "bitCheck",
                "uVar3": "value",
                "puVar4": "ptr",
                "iVar5": "index",
                "local_10": "newValue",
                "local_c": "counter"
            },
            "calling": [
                "FUN_08005680",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001a80": {
            "entrypoint": "0x08001a80",
            "current_name": "update_parameter_08001a80",
            "code": "\nvoid updateParameter_08001a80(int buffer,ushort value,char isShifted)\n\n{\n  if (isShifted == '\\0') {\n    *(uint *)(buffer + 0x10) = (uint)value << 0x10;\n  }\n  else {\n    *(uint *)(buffer + 0x10) = (uint)value;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001a80": "update_parameter_08001a80",
                "param_1": "buffer",
                "param_2": "value",
                "param_3": "isShifted"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080055f4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001ab0": {
            "entrypoint": "0x08001ab0",
            "current_name": "calculate_param_values_08001ab0",
            "code": "\nundefined4 calculateParamValues_08001ab0(uint **inputParams)\n\n{\n  uint shiftedValue;\n  char isWithinRange;\n  undefined4 returnValue;\n  uint adjustedValue;\n  bool isZero;\n  \n  if (inputParams == (uint **)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)inputParams + 0x3d) == '\\0') {\n      *(undefined *)(inputParams + 0xf) = 0;\n      FUNC_08001cb8(inputParams);\n    }\n    *(undefined *)((int)inputParams + 0x3d) = 0x24;\n    **inputParams = **inputParams & 0xfffffffe;\n    shiftedValue = retrieveShiftedValue();\n    if (param1 < (uint *)0x186a1) {\n      adjustedValue = shiftedValue;\n      if (shiftedValue < 2000000) {\n        adjustedValue = 1;\n      }\n      isWithinRange = (char)adjustedValue;\n      if (1999999 < shiftedValue) {\n        isWithinRange = '\\0';\n      }\n    }\n    else {\n      adjustedValue = shiftedValue;\n      if (shiftedValue < 4000000) {\n        adjustedValue = 1;\n      }\n      isWithinRange = (char)adjustedValue;\n      if (3999999 < shiftedValue) {\n        isWithinRange = '\\0';\n      }\n    }\n    if (isWithinRange == '\\0') {\n      adjustedValue = shiftedValue / 1000000;\n      (*inputParams)[1] = adjustedValue;\n      if ((uint *)0x186a0 < param1) {\n        adjustedValue = (adjustedValue * 300) / 1000;\n      }\n      (*inputParams)[8] = adjustedValue + 1;\n      if (param1 < (uint *)0x186a1) {\n        shiftedValue = (shiftedValue - 1) / (uint)((int)param1 << 1) + 1 & 0xfff;\n        if (shiftedValue < 4) {\n          shiftedValue = 4;\n        }\n      }\n      else {\n        if (inputParams[2] == (uint *)0x0) {\n          adjustedValue = (shiftedValue - 1) / (uint)((int)param1 * 3) + 1 & 0xfff;\n          isZero = adjustedValue == 0;\n          if (isZero) {\n            adjustedValue = 1;\n          }\n          isWithinRange = (char)adjustedValue;\n          if (!isZero) {\n            isWithinRange = '\\0';\n          }\n        }\n        else {\n          adjustedValue = (shiftedValue - 1) / (uint)((int)param1 * 0x19) + 1 & 0xfff;\n          isZero = adjustedValue == 0;\n          if (isZero) {\n            adjustedValue = 1;\n          }\n          isWithinRange = (char)adjustedValue;\n          if (!isZero) {\n            isWithinRange = '\\0';\n          }\n        }\n        if (isWithinRange == '\\0') {\n          if (inputParams[2] == (uint *)0x0) {\n            shiftedValue = (shiftedValue - 1) / (uint)((int)param1 * 3) + 1 & 0xfff | 0x8000;\n          }\n          else {\n            shiftedValue = (shiftedValue - 1) / (uint)((int)param1 * 0x19) + 1 & 0xfff | 0xc000;\n          }\n        }\n        else {\n          shiftedValue = 1;\n        }\n      }\n      (*inputParams)[7] = shiftedValue;\n      **inputParams = (uint)inputParams[8] | (uint)inputParams[7];\n      (*inputParams)[2] = (uint)inputParams[3] | (uint)inputParams[4];\n      (*inputParams)[3] = (uint)inputParams[6] | (uint)inputParams[5];\n      **inputParams = **inputParams | 1;\n      tempArray = (uint *)0x0;\n      *(undefined *)((int)inputParams + 0x3d) = 0x20;\n      inputParams[0xc] = (uint *)0x0;\n      *(undefined *)((int)inputParams + 0x3e) = 0;\n      returnValue = 0;\n    }\n    else {\n      returnValue = 1;\n    }\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001ab0": "calculate_param_values_08001ab0",
                "param_1": "inputParams",
                "uVar1": "shiftedValue",
                "cVar2": "isWithinRange",
                "uVar3": "returnValue",
                "uVar4": "adjustedValue",
                "bVar5": "isZero",
                "retrieve_shifted_value_08003518": "retrieveShiftedValue",
                "param_1[1]": "param1",
                "param_1[0x10]": "tempArray"
            },
            "calling": [
                "FUN_08005348"
            ],
            "called": [
                "FUN_08003518",
                "FUN_08001cb8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001cb8": {
            "entrypoint": "0x08001cb8",
            "current_name": "FUNC_08001cb8",
            "code": "\nvoid FUNC_08001cb8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08001cb8": "FUNC_08001cb8"
            },
            "calling": [
                "FUN_08001ab0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08001ccc": {
            "entrypoint": "0x08001ccc",
            "current_name": "process_data_08001ccc",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08001d5e) */\n/* WARNING: Removing unreachable block (ram,0x08001d70) */\n/* WARNING: Removing unreachable block (ram,0x08001d72) */\n/* WARNING: Removing unreachable block (ram,0x08001d74) */\n\nundefined4\nprocessData_08001ccc(uint **inputList,undefined2 param2,undefined2 param3,undefined2 param4,uint *param5,\n            undefined2 param6,undefined4 param7)\n\n{\n  int dataValue1;\n  int dataValue2;\n  undefined4 result;\n  uint *bytePointer;\n  \n  dataValue1 = get_data_value_080015a0();\n  if (*(char *)((int)inputList + 0x3d) == ' ') {\n    do {\n      if ((~(*inputList)[6] & 2) != 0) {\n        dataValue2 = 0;\n        goto LAB_08001d9c;\n      }\n      dataValue2 = get_data_value_080015a0();\n    } while ((uint)(dataValue2 - dataValue1) < 0x1a);\n    inputList[0xc] = (uint *)0x0;\n    *(undefined *)((int)inputList + 0x3d) = 0x20;\n    *(undefined *)((int)inputList + 0x3e) = 0;\n    *(undefined *)(inputList + 0xf) = 0;\n    dataValue2 = 3;\nLAB_08001d9c:\n    if (dataValue2 == 0) {\n      if (*(char *)(inputList + 0xf) == '\\x01') {\n        result = 2;\n      }\n      else {\n        *(undefined *)(inputList + 0xf) = 1;\n        if ((**inputList & 1) != 1) {\n          **inputList = **inputList | 1;\n        }\n        **inputList = **inputList & 0xfffff7ff;\n        *(undefined *)((int)inputList + 0x3d) = 0x21;\n        *(undefined *)((int)inputList + 0x3e) = 0x40;\n        inputList[0x10] = (uint *)0x0;\n        inputList[9] = param5;\n        *(undefined2 *)((int)inputList + 0x2a) = param6;\n        inputList[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(inputList + 10) = *(undefined2 *)((int)inputList + 0x2a);\n        dataValue2 = update_and_handle_parameters_08002640(inputList,param2,param3,param4,param7,dataValue1);\n        if (dataValue2 == 0) {\n          while (*(short *)(inputList + 10) != 0) {\n            dataValue2 = check_and_handle_flag_08002bb4(inputList,param7,dataValue1);\n            if (dataValue2 != 0) {\n              if (inputList[0x10] == (uint *)0x4) {\n                **inputList = **inputList | 0x200;\n                return 1;\n              }\n              return 3;\n            }\n            bytePointer = inputList[9];\n            inputList[9] = (uint *)((int)bytePointer + 1);\n            (*inputList)[4] = (uint)*(byte *)bytePointer;\n            *(short *)(inputList + 10) = *(short *)(inputList + 10) + -1;\n            *(short *)((int)inputList + 0x2a) = *(short *)((int)inputList + 0x2a) + -1;\n            if ((((*inputList)[5] & 4) == 4) && (*(short *)(inputList + 10) != 0)) {\n              bytePointer = inputList[9];\n              inputList[9] = (uint *)((int)bytePointer + 1);\n              (*inputList)[4] = (uint)*(byte *)bytePointer;\n              *(short *)(inputList + 10) = *(short *)(inputList + 10) + -1;\n              *(short *)((int)inputList + 0x2a) = *(short *)((int)inputList + 0x2a) + -1;\n            }\n          }\n          dataValue1 = check_data_validity_08002c2e(inputList,param7,dataValue1);\n          if (dataValue1 == 0) {\n            **inputList = **inputList | 0x200;\n            *(undefined *)((int)inputList + 0x3d) = 0x20;\n            *(undefined *)((int)inputList + 0x3e) = 0;\n            *(undefined *)(inputList + 0xf) = 0;\n            result = 0;\n          }\n          else if (inputList[0x10] == (uint *)0x4) {\n            **inputList = **inputList | 0x200;\n            result = 1;\n          }\n          else {\n            result = 3;\n          }\n        }\n        else if (inputList[0x10] == (uint *)0x4) {\n          *(undefined *)(inputList + 0xf) = 0;\n          result = 1;\n        }\n        else {\n          *(undefined *)(inputList + 0xf) = 0;\n          result = 3;\n        }\n      }\n    }\n    else {\n      result = 2;\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08001ccc": "process_data_08001ccc",
                "param_1": "inputList",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6",
                "param_7": "param7",
                "iVar1": "dataValue1",
                "iVar2": "dataValue2",
                "uVar3": "result",
                "puVar4": "bytePointer"
            },
            "calling": [
                "FUN_08004ea4"
            ],
            "called": [
                "FUN_08002c2e",
                "FUN_08002bb4",
                "FUN_080015a0",
                "FUN_08002640"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08001f6c": {
            "entrypoint": "0x08001f6c",
            "current_name": "process_data_08001f6c",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080024e6) */\n/* WARNING: Removing unreachable block (ram,0x080024f8) */\n/* WARNING: Removing unreachable block (ram,0x080024fa) */\n/* WARNING: Removing unreachable block (ram,0x080024fc) */\n/* WARNING: Removing unreachable block (ram,0x08002000) */\n/* WARNING: Removing unreachable block (ram,0x08002012) */\n/* WARNING: Removing unreachable block (ram,0x08002014) */\n/* WARNING: Removing unreachable block (ram,0x08002016) */\n/* WARNING: Removing unreachable block (ram,0x080023f4) */\n/* WARNING: Removing unreachable block (ram,0x08002406) */\n/* WARNING: Removing unreachable block (ram,0x08002408) */\n/* WARNING: Removing unreachable block (ram,0x0800240a) */\n/* WARNING: Removing unreachable block (ram,0x080022d6) */\n/* WARNING: Removing unreachable block (ram,0x080022e8) */\n/* WARNING: Removing unreachable block (ram,0x080022ea) */\n/* WARNING: Removing unreachable block (ram,0x080022ec) */\n\nundefined4\nprocessData_08001f6c(uint **data,undefined2 param2,undefined2 param3,undefined2 param4,uint *inputData,\n            undefined2 param6,uint param7)\n\n{\n  int dataValue1;\n  uint dataValue2;\n  int dataValue3;\n  undefined4 returnValue;\n  uint *pointer;\n  \n  dataValue1 = getDataValue();\n  if (*(char *)((int)data + 0x3d) == ' ') {\n    do {\n      if ((~(*data)[6] & 2) != 0) {\n        dataValue3 = 0;\n        goto LAB_08002040;\n      }\n      dataValue3 = getDataValue();\n    } while ((uint)(dataValue3 - dataValue1) < 0x1a);\n    data[0xc] = (uint *)0x0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)((int)data + 0x3e) = 0;\n    *(undefined *)(data + 0xf) = 0;\n    dataValue3 = 3;\nLAB_08002040:\n    if (dataValue3 == 0) {\n      if (*(char *)(data + 0xf) == '\\x01') {\n        returnValue = 2;\n      }\n      else {\n        *(undefined *)(data + 0xf) = 1;\n        if ((**data & 1) != 1) {\n          **data = **data | 1;\n        }\n        **data = **data & 0xfffff7ff;\n        *(undefined *)((int)data + 0x3d) = 0x22;\n        *(undefined *)((int)data + 0x3e) = 0x40;\n        data[0x10] = (uint *)0x0;\n        data[9] = inputData;\n        *(undefined2 *)((int)data + 0x2a) = param6;\n        data[0xb] = (uint *)0xffff0000;\n        *(undefined2 *)(data + 10) = *(undefined2 *)((int)data + 0x2a);\n        dataValue3 = processData_08001f6c(data,param2,param3,param4,param7,dataValue1);\n        if (dataValue3 == 0) {\n          if (*(short *)(data + 10) == 0) {\n            **data = **data | 0x200;\n          }\n          else if (*(short *)(data + 10) == 1) {\n            **data = **data & 0xfffffbff;\n            disableIRQ();\n            **data = **data | 0x200;\n            enableIRQ();\n          }\n          else if (*(short *)(data + 10) == 2) {\n            **data = **data | 0x800;\n            disableIRQ();\n            **data = **data & 0xfffffbff;\n            enableIRQ();\n          }\n          else {\n            **data = **data | 0x400;\n          }\n          while (*(short *)(data + 10) != 0) {\n            if (*(ushort *)(data + 10) < 4) {\n              if (*(short *)(data + 10) == 1) {\n                dataValue3 = checkDataIntegrity(data,param7,dataValue1);\n                if (dataValue3 != 0) {\n                  if (data[0x10] == (uint *)0x20) {\n                    return 3;\n                  }\n                  return 1;\n                }\n                dataValue2 = (*data)[4];\n                pointer = data[9];\n                data[9] = (uint *)((int)pointer + 1);\n                *(char *)pointer = (char)dataValue2;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n              else if (*(short *)(data + 10) == 2) {\n                do {\n                  if ((~(*data)[5] & 4) == 0) {\n                    dataValue3 = 0;\n                    goto LAB_080022fa;\n                  }\n                } while ((param7 == 0xffffffff) ||\n                        ((param7 != 0 && (dataValue3 = getDataValue(), (uint)(dataValue3 - dataValue1) <= param7)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                dataValue3 = 3;\nLAB_080022fa:\n                if (dataValue3 != 0) {\n                  return 3;\n                }\n                disableIRQ();\n                **data = **data | 0x200;\n                dataValue2 = (*data)[4];\n                pointer = data[9];\n                data[9] = (uint *)((int)pointer + 1);\n                *(char *)pointer = (char)dataValue2;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                enableIRQ();\n                dataValue2 = (*data)[4];\n                pointer = data[9];\n                data[9] = (uint *)((int)pointer + 1);\n                *(char *)pointer = (char)dataValue2;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n              else {\n                do {\n                  if ((~(*data)[5] & 4) == 0) {\n                    dataValue3 = 0;\n                    goto LAB_08002418;\n                  }\n                } while ((param7 == 0xffffffff) ||\n                        ((param7 != 0 && (dataValue3 = getDataValue(), (uint)(dataValue3 - dataValue1) <= param7)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                dataValue3 = 3;\nLAB_08002418:\n                if (dataValue3 != 0) {\n                  return 3;\n                }\n                **data = **data & 0xfffffbff;\n                disableIRQ();\n                dataValue2 = (*data)[4];\n                pointer = data[9];\n                data[9] = (uint *)((int)pointer + 1);\n                *(char *)pointer = (char)dataValue2;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                do {\n                  if ((~(*data)[5] & 4) == 0) {\n                    dataValue3 = 0;\n                    goto LAB_0800250a;\n                  }\n                } while ((param7 == 0xffffffff) ||\n                        ((param7 != 0 && (dataValue3 = getDataValue(), (uint)(dataValue3 - dataValue1) <= param7)\n                         )));\n                data[0xc] = (uint *)0x0;\n                *(undefined *)((int)data + 0x3d) = 0x20;\n                *(undefined *)((int)data + 0x3e) = 0;\n                *(undefined *)(data + 0xf) = 0;\n                dataValue3 = 3;\nLAB_0800250a:\n                if (dataValue3 != 0) {\n                  return 3;\n                }\n                **data = **data | 0x200;\n                dataValue2 = (*data)[4];\n                pointer = data[9];\n                data[9] = (uint *)((int)pointer + 1);\n                *(char *)pointer = (char)dataValue2;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n                enableIRQ();\n                dataValue2 = (*data)[4];\n                pointer = data[9];\n                data[9] = (uint *)((int)pointer + 1);\n                *(char *)pointer = (char)dataValue2;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n            }\n            else {\n              dataValue3 = checkDataIntegrity(data,param7,dataValue1);\n              if (dataValue3 != 0) {\n                if (data[0x10] == (uint *)0x20) {\n                  return 3;\n                }\n                return 1;\n              }\n              dataValue2 = (*data)[4];\n              pointer = data[9];\n              data[9] = (uint *)((int)pointer + 1);\n              *(char *)pointer = (char)dataValue2;\n              *(short *)(data + 10) = *(short *)(data + 10) + -1;\n              *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              if (((*data)[5] & 4) == 4) {\n                dataValue2 = (*data)[4];\n                pointer = data[9];\n                data[9] = (uint *)((int)pointer + 1);\n                *(char *)pointer = (char)dataValue2;\n                *(short *)(data + 10) = *(short *)(data + 10) + -1;\n                *(short *)((int)data + 0x2a) = *(short *)((int)data + 0x2a) + -1;\n              }\n            }\n          }\n          *(undefined *)((int)data + 0x3d) = 0x20;\n          *(undefined *)((int)data + 0x3e) = 0;\n          *(undefined *)(data + 0xf) = 0;\n          returnValue = 0;\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          *(undefined *)(data + 0xf) = 0;\n          returnValue = 1;\n        }\n        else {\n          *(undefined *)(data + 0xf) = 0;\n          returnValue = 3;\n        }\n      }\n    }\n    else {\n      returnValue = 2;\n    }\n  }\n  else {\n    returnValue = 2;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08001f6c": "process_data_08001f6c",
                "param_1": "data",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "inputData",
                "param_6": "param6",
                "param_7": "param7",
                "iVar1": "dataValue1",
                "uVar2": "dataValue2",
                "iVar3": "dataValue3",
                "uVar4": "returnValue",
                "puVar5": "pointer",
                "get_data_value_080015a0": "getDataValue",
                "process_data_080027f4": "processData",
                "check_data_integrity_08002ca8": "checkDataIntegrity",
                "disableIRQinterrupts": "disableIRQ",
                "enableIRQinterrupts": "enableIRQ"
            },
            "calling": [
                "FUN_08004ee8"
            ],
            "called": [
                "FUN_08002ca8",
                "FUN_080027f4",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002640": {
            "entrypoint": "0x08002640",
            "current_name": "update_and_handle_parameters_08002640",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080026e8) */\n/* WARNING: Removing unreachable block (ram,0x080026fa) */\n/* WARNING: Removing unreachable block (ram,0x080026fc) */\n/* WARNING: Removing unreachable block (ram,0x080026fe) */\n\nundefined4\nupdateAndHandleParameters_08002640(uint **paramPtr,byte byteVal,undefined2 shortVal,short flag,uint value,int comparison)\n\n{\n  int result;\n  undefined4 returnValue;\n  \n  **paramPtr = **paramPtr | 0x100;\n  do {\n    if ((~(*paramPtr)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_0800270a;\n    }\n  } while ((value == 0xffffffff) ||\n          ((value != 0 && (result = get_data_value_080015a0(), (uint)(result - comparison) <= value))));\n  paramPtr[0xc] = (uint *)0x0;\n  *(undefined *)((int)paramPtr + 0x3d) = 0x20;\n  *(undefined *)((int)paramPtr + 0x3e) = 0;\n  *(undefined *)(paramPtr + 0xf) = 0;\n  result = 3;\nLAB_0800270a:\n  if (result == 0) {\n    (*paramPtr)[4] = byteVal & 0xfe;\n    result = check_and_update_parameters_08002ad8(paramPtr,0x10002,value,comparison);\n    if (result == 0) {\n      result = check_and_handle_flag_08002bb4(paramPtr,value,comparison,(*paramPtr)[6]);\n      if (result == 0) {\n        if (flag == 1) {\n          (*paramPtr)[4] = (uint)(byte)shortVal;\n        }\n        else {\n          (*paramPtr)[4] = (uint)(byte)((ushort)shortVal >> 8);\n          result = check_and_handle_flag_08002bb4(paramPtr,value,comparison);\n          if (result != 0) {\n            if (paramPtr[0x10] == (uint *)0x4) {\n              **paramPtr = **paramPtr | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*paramPtr)[4] = (uint)(byte)shortVal;\n        }\n        returnValue = 0;\n      }\n      else if (paramPtr[0x10] == (uint *)0x4) {\n        **paramPtr = **paramPtr | 0x200;\n        returnValue = 1;\n      }\n      else {\n        returnValue = 3;\n      }\n    }\n    else if (paramPtr[0x10] == (uint *)0x4) {\n      returnValue = 1;\n    }\n    else {\n      returnValue = 3;\n    }\n  }\n  else {\n    returnValue = 3;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08002640": "update_and_handle_parameters_08002640",
                "param_1": "paramPtr",
                "param_2": "byteVal",
                "param_3": "shortVal",
                "param_4": "flag",
                "param_5": "value",
                "param_6": "comparison",
                "iVar1": "result",
                "uVar2": "returnValue"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080027f4": {
            "entrypoint": "0x080027f4",
            "current_name": "process_data_080027f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080028ae) */\n/* WARNING: Removing unreachable block (ram,0x080028c0) */\n/* WARNING: Removing unreachable block (ram,0x080028c2) */\n/* WARNING: Removing unreachable block (ram,0x080028c4) */\n/* WARNING: Removing unreachable block (ram,0x08002a6c) */\n/* WARNING: Removing unreachable block (ram,0x08002a7e) */\n/* WARNING: Removing unreachable block (ram,0x08002a80) */\n/* WARNING: Removing unreachable block (ram,0x08002a82) */\n\nundefined4\nprocessData_080027f4(uint **data,byte flag,undefined2 value,short condition,uint limit,int offset)\n\n{\n  int result;\n  undefined4 status;\n  \n  **data = **data | 0x400;\n  **data = **data | 0x100;\n  do {\n    if ((~(*data)[5] & 1) == 0) {\n      result = 0;\n      goto LAB_080028d2;\n    }\n  } while ((limit == 0xffffffff) ||\n          ((limit != 0 && (result = getDataValue(), (uint)(result - offset) <= limit))));\n  data[0xc] = (uint *)0x0;\n  *(undefined *)((int)data + 0x3d) = 0x20;\n  *(undefined *)((int)data + 0x3e) = 0;\n  *(undefined *)(data + 0xf) = 0;\n  result = 3;\nLAB_080028d2:\n  if (result == 0) {\n    (*data)[4] = flag & 0xfe;\n    result = checkAndUpdateParameters(data,0x10002,limit,offset);\n    if (result == 0) {\n      result = checkAndHandleFlag(data,limit,offset,(*data)[6]);\n      if (result == 0) {\n        if (condition == 1) {\n          (*data)[4] = (uint)(byte)value;\n        }\n        else {\n          (*data)[4] = (uint)(byte)((ushort)value >> 8);\n          result = checkAndHandleFlag(data,limit,offset);\n          if (result != 0) {\n            if (data[0x10] == (uint *)0x4) {\n              **data = **data | 0x200;\n              return 1;\n            }\n            return 3;\n          }\n          (*data)[4] = (uint)(byte)value;\n        }\n        result = checkAndHandleFlag(data,limit,offset);\n        if (result == 0) {\n          **data = **data | 0x100;\n          do {\n            if ((~(*data)[5] & 1) == 0) {\n              result = 0;\n              goto LAB_08002a90;\n            }\n          } while ((limit == 0xffffffff) ||\n                  ((limit != 0 && (result = getDataValue(), (uint)(result - offset) <= limit))));\n          data[0xc] = (uint *)0x0;\n          *(undefined *)((int)data + 0x3d) = 0x20;\n          *(undefined *)((int)data + 0x3e) = 0;\n          *(undefined *)(data + 0xf) = 0;\n          result = 3;\nLAB_08002a90:\n          if (result == 0) {\n            (*data)[4] = (uint)(flag | 1);\n            result = checkAndUpdateParameters(data,0x10002,limit,offset);\n            if (result == 0) {\n              status = 0;\n            }\n            else if (data[0x10] == (uint *)0x4) {\n              status = 1;\n            }\n            else {\n              status = 3;\n            }\n          }\n          else {\n            status = 3;\n          }\n        }\n        else if (data[0x10] == (uint *)0x4) {\n          **data = **data | 0x200;\n          status = 1;\n        }\n        else {\n          status = 3;\n        }\n      }\n      else if (data[0x10] == (uint *)0x4) {\n        **data = **data | 0x200;\n        status = 1;\n      }\n      else {\n        status = 3;\n      }\n    }\n    else if (data[0x10] == (uint *)0x4) {\n      status = 1;\n    }\n    else {\n      status = 3;\n    }\n  }\n  else {\n    status = 3;\n  }\n  return status;\n}\n\n",
            "renaming": {
                "FUN_080027f4": "process_data_080027f4",
                "param_1": "data",
                "param_2": "flag",
                "param_3": "value",
                "param_4": "condition",
                "param_5": "limit",
                "param_6": "offset",
                "iVar1": "result",
                "uVar2": "status",
                "get_data_value_080015a0": "getDataValue",
                "check_and_update_parameters_08002ad8": "checkAndUpdateParameters",
                "check_and_handle_flag_08002bb4": "checkAndHandleFlag"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_08002bb4",
                "FUN_08002ad8",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ad8": {
            "entrypoint": "0x08002ad8",
            "current_name": "check_and_update_parameters_08002ad8",
            "code": "\nundefined4 checkAndUpdateParameters_08002ad8(uint **paramArray,uint paramValue1,uint paramValue2,int paramValue3)\n\n{\n  int dataValue;\n  char conditionValue;\n  uint updatedValue;\n  bool isUpdated;\n  \n  do {\n    if ((paramValue1 >> 0x10 & 0xff) == 1) {\n      updatedValue = paramValue1 & ~(*paramArray)[5] & 0xffff;\n      isUpdated = updatedValue != 0;\n      if (isUpdated) {\n        updatedValue = 1;\n      }\n      conditionValue = (char)updatedValue;\n      if (!isUpdated) {\n        conditionValue = '\\0';\n      }\n    }\n    else {\n      updatedValue = paramValue1 & ~(*paramArray)[6] & 0xffff;\n      isUpdated = updatedValue != 0;\n      if (isUpdated) {\n        updatedValue = 1;\n      }\n      conditionValue = (char)updatedValue;\n      if (!isUpdated) {\n        conditionValue = '\\0';\n      }\n    }\n    if (conditionValue == '\\0') {\n      return 0;\n    }\n    if (((*paramArray)[5] & 0x400) == 0x400) {\n      **paramArray = **paramArray | 0x200;\n      (*paramArray)[5] = 0xfffffbff;\n      paramArray[0x10] = (uint *)0x4;\n      paramArray[0xc] = (uint *)0x0;\n      *(undefined *)((int)paramArray + 0x3d) = 0x20;\n      *(undefined *)(paramArray + 0xf) = 0;\n      return 1;\n    }\n  } while ((paramValue2 == 0xffffffff) ||\n          ((paramValue2 != 0 && (dataValue = get_data_value_080015a0(), (uint)(dataValue - paramValue3) <= paramValue2))));\n  paramArray[0xc] = (uint *)0x0;\n  *(undefined *)((int)paramArray + 0x3d) = 0x20;\n  *(undefined *)(paramArray + 0xf) = 0;\n  return 3;\n}\n\n",
            "renaming": {
                "FUN_08002ad8": "check_and_update_parameters_08002ad8",
                "param_1": "paramArray",
                "param_2": "paramValue1",
                "param_3": "paramValue2",
                "param_4": "paramValue3",
                "iVar1": "dataValue",
                "cVar2": "conditionValue",
                "uVar3": "updatedValue",
                "bVar4": "isUpdated"
            },
            "calling": [
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002bb4": {
            "entrypoint": "0x08002bb4",
            "current_name": "check_and_handle_flag_08002bb4",
            "code": "\nundefined4 check_and_handle_flag_08002bb4(int *data_array,uint data_length,int value_to_compare)\n\n{\n  int flag_check_result;\n  \n  while( true ) {\n    if ((*(uint *)(*data_array + 0x14) & 0x80) == 0x80) {\n      return 0;\n    }\n    flag_check_result = check_flag_and_set_08002d3c(data_array);\n    if (flag_check_result != 0) break;\n    if ((data_length != 0xffffffff) &&\n       ((data_length == 0 || (flag_check_result = get_data_value_080015a0(), data_length < (uint)(flag_check_result - value_to_compare))))) {\n      data_array[0x10] = data_array[0x10] | 0x20;\n      data_array[0xc] = 0;\n      *(undefined *)((int)data_array + 0x3d) = 0x20;\n      *(undefined *)(data_array + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002bb4": "check_and_handle_flag_08002bb4",
                "param_1": "data_array",
                "param_2": "data_length",
                "param_3": "value_to_compare",
                "iVar1": "flag_check_result"
            },
            "calling": [
                "FUN_08001ccc",
                "FUN_080027f4",
                "FUN_08002640"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002c2e": {
            "entrypoint": "0x08002c2e",
            "current_name": "check_data_validity_08002c2e",
            "code": "\nundefined4 check_data_validity_08002c2e(int *data_ptr,uint size,int offset)\n\n{\n  int result;\n  \n  while( true ) {\n    if ((*(uint *)(*data_ptr + 0x14) & 4) == 4) {\n      return 0;\n    }\n    result = check_flag_and_set(data_ptr);\n    if (result != 0) break;\n    if ((size != 0xffffffff) &&\n       ((size == 0 || (result = get_data_value(), size < (uint)(result - offset))))) {\n      data_ptr[0x10] = data_ptr[0x10] | 0x20;\n      data_ptr[0xc] = 0;\n      *(undefined *)((int)data_ptr + 0x3d) = 0x20;\n      *(undefined *)(data_ptr + 0xf) = 0;\n      return 3;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002c2e": "check_data_validity_08002c2e",
                "param_1": "data_ptr",
                "param_2": "size",
                "param_3": "offset",
                "iVar1": "result",
                "check_flag_and_set_08002d3c": "check_flag_and_set",
                "get_data_value_080015a0": "get_data_value"
            },
            "calling": [
                "FUN_08001ccc"
            ],
            "called": [
                "FUN_080015a0",
                "FUN_08002d3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002ca8": {
            "entrypoint": "0x08002ca8",
            "current_name": "check_data_integrity_08002ca8",
            "code": "\nundefined4 check_data_integrity_08002ca8(int *data_pointer,uint data_size,int expected_size)\n\n{\n  int data_value;\n  \n  while( true ) {\n    if ((*(uint *)(*data_pointer + 0x14) & 0x40) == 0x40) {\n      return 0;\n    }\n    if ((*(uint *)(*data_pointer + 0x14) & 0x10) == 0x10) break;\n    if ((data_size == 0) || (data_value = get_data_value(), data_size < (uint)(data_value - expected_size))) {\n      data_pointer[0x10] = data_pointer[0x10] | 0x20;\n      *(undefined *)((int)data_pointer + 0x3d) = 0x20;\n      *(undefined *)(data_pointer + 0xf) = 0;\n      return 3;\n    }\n  }\n  *(undefined4 *)(*data_pointer + 0x14) = 0xffffffef;\n  data_pointer[0x10] = 0;\n  data_pointer[0xc] = 0;\n  *(undefined *)((int)data_pointer + 0x3d) = 0x20;\n  *(undefined *)(data_pointer + 0xf) = 0;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_08002ca8": "check_data_integrity_08002ca8",
                "param_1": "data_pointer",
                "param_2": "data_size",
                "param_3": "expected_size",
                "iVar1": "data_value",
                "get_data_value_080015a0": "get_data_value"
            },
            "calling": [
                "FUN_08001f6c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d3c": {
            "entrypoint": "0x08002d3c",
            "current_name": "check_flag_and_set_08002d3c",
            "code": "\nbool checkFlagAndSet_08002d3c(int *data)\n\n{\n  bool isFlagSet;\n  \n  isFlagSet = (*(uint *)(*data + 0x14) & 0x400) == 0x400;\n  if (isFlagSet) {\n    *(undefined4 *)(*data + 0x14) = 0xfffffbff;\n    data[0x10] = 4;\n    data[0xc] = 0;\n    *(undefined *)((int)data + 0x3d) = 0x20;\n    *(undefined *)(data + 0xf) = 0;\n  }\n  return isFlagSet;\n}\n\n",
            "renaming": {
                "FUN_08002d3c": "check_flag_and_set_08002d3c",
                "param_1": "data",
                "bVar1": "isFlagSet"
            },
            "calling": [
                "FUN_08002c2e",
                "FUN_08002bb4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08002d8a": {
            "entrypoint": "0x08002d8a",
            "current_name": "FUNC_08002d8a",
            "code": "\nvoid FUNC_08002d8a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08002d8a": "FUNC_08002d8a"
            },
            "calling": [
                "FUN_080014f0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08002d98": {
            "entrypoint": "0x08002d98",
            "current_name": "perform_operation_08002d98",
            "code": "\n\n\nundefined4 performOperation_08002d98(uint *flags)\n\n{\n  int startValue;\n  int currentValue;\n  undefined4 result;\n  bool shouldModifyFlags;\n  \n  if ((*flags & 1) != 0) {\n    if (((_DAT_40021004 & 0xc) == 4) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0x10000)))) {\n      if (((_DAT_40021000 & 0x20000) != 0) && (flags[1] == 0)) {\n        return 1;\n      }\n    }\n    else {\n      if (flags[1] == 0x10000) {\n        _DAT_40021000 = _DAT_40021000 | 0x10000;\n      }\n      else if (flags[1] == 0) {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      else if (flags[1] == 0x50000) {\n        _DAT_40021000 = _DAT_40021000 | 0x50000;\n      }\n      else {\n        _DAT_40021000 = _DAT_40021000 & 0xfffaffff;\n      }\n      if (flags[1] == 0) {\n        startValue = get_data_value_080015a0();\n        while ((_DAT_40021000 & 0x20000) != 0) {\n          currentValue = get_data_value_080015a0();\n          if (100 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n      }\n      else {\n        startValue = get_data_value_080015a0();\n        while ((_DAT_40021000 & 0x20000) == 0) {\n          currentValue = get_data_value_080015a0();\n          if (100 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n      }\n    }\n  }\n  if ((*flags & 2) != 0) {\n    if (((_DAT_40021004 & 0xc) == 0) ||\n       (((_DAT_40021004 & 0xc) == 8 && ((_DAT_40021004 & 0x10000) == 0)))) {\n      if (((_DAT_40021000 & 2) != 0) && (flags[4] != 1)) {\n        return 1;\n      }\n      _DAT_40021000 = flags[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n    else if (flags[4] == 0) {\n      _DAT_42420000 = 0;\n      startValue = get_data_value_080015a0();\n      while ((_DAT_40021000 & 2) != 0) {\n        currentValue = get_data_value_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420000 = 1;\n      startValue = get_data_value_080015a0();\n      while ((_DAT_40021000 & 2) == 0) {\n        currentValue = get_data_value_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n      _DAT_40021000 = flags[5] << 3 | _DAT_40021000 & 0xffffff07;\n    }\n  }\n  if ((*flags & 8) != 0) {\n    if (flags[6] == 0) {\n      _DAT_42420480 = 0;\n      startValue = get_data_value_080015a0();\n      while ((_DAT_40021024 & 2) != 0) {\n        currentValue = get_data_value_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      _DAT_42420480 = 1;\n      startValue = get_data_value_080015a0();\n      while ((_DAT_40021024 & 2) == 0) {\n        currentValue = get_data_value_080015a0();\n        if (2 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n      delay_function_08003568(1);\n    }\n  }\n  if ((*flags & 4) != 0) {\n    shouldModifyFlags = (_DAT_4002101c & 0x10000000) == 0;\n    if (shouldModifyFlags) {\n      _DAT_4002101c = _DAT_4002101c | 0x10000000;\n    }\n    if ((_DAT_40007000 & 0x100) == 0) {\n      _DAT_40007000 = _DAT_40007000 | 0x100;\n      startValue = get_data_value_080015a0();\n      while ((_DAT_40007000 & 0x100) == 0) {\n        currentValue = get_data_value_080015a0();\n        if (100 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    if (flags[3] == 1) {\n      _DAT_40021020 = _DAT_40021020 | 1;\n    }\n    else if (flags[3] == 0) {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    else if (flags[3] == 5) {\n      _DAT_40021020 = _DAT_40021020 | 5;\n    }\n    else {\n      _DAT_40021020 = _DAT_40021020 & 0xfffffffa;\n    }\n    if (flags[3] == 0) {\n      startValue = get_data_value_080015a0();\n      while ((_DAT_40021020 & 2) != 0) {\n        currentValue = get_data_value_080015a0();\n        if (5000 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    else {\n      startValue = get_data_value_080015a0();\n      while ((_DAT_40021020 & 2) == 0) {\n        currentValue = get_data_value_080015a0();\n        if (5000 < (uint)(currentValue - startValue)) {\n          return 3;\n        }\n      }\n    }\n    if (shouldModifyFlags) {\n      _DAT_4002101c = _DAT_4002101c & 0xefffffff;\n    }\n  }\n  if (flags[7] == 0) {\nLAB_0800324a:\n    result = 0;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    result = 1;\n  }\n  else if (flags[7] == 2) {\n    _DAT_42420060 = 0;\n    startValue = get_data_value_080015a0();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) {\n        if (flags[8] == 0x10000) {\n          _DAT_40021004 = flags[2] | _DAT_40021004 & 0xfffdffff;\n        }\n        _DAT_40021004 = flags[9] | flags[8] | _DAT_40021004 & 0xffc2ffff;\n        _DAT_42420060 = 1;\n        startValue = get_data_value_080015a0();\n        while ((_DAT_40021000 & 0x2000000) == 0) {\n          currentValue = get_data_value_080015a0();\n          if (2 < (uint)(currentValue - startValue)) {\n            return 3;\n          }\n        }\n        goto LAB_0800324a;\n      }\n      currentValue = get_data_value_080015a0();\n    } while ((uint)(currentValue - startValue) < 3);\n    result = 3;\n  }\n  else {\n    _DAT_42420060 = 0;\n    startValue = get_data_value_080015a0();\n    do {\n      if ((_DAT_40021000 & 0x2000000) == 0) goto LAB_0800324a;\n      currentValue = get_data_value_080015a0();\n    } while ((uint)(currentValue - startValue) < 3);\n    result = 3;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08002d98": "perform_operation_08002d98",
                "param_1": "flags",
                "iVar1": "startValue",
                "iVar2": "currentValue",
                "bVar4": "shouldModifyFlags",
                "uVar3": "result"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_08003568",
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003260": {
            "entrypoint": "0x08003260",
            "current_name": "process_data_08003260",
            "code": "\n\n\nundefined4 processData_08003260(uint *parameters,uint length)\n\n{\n  int dataValue1;\n  int dataValue2;\n  uint delay;\n  undefined4 result;\n  \n  if (((_DAT_40022000 & 7) < length) &&\n     (_DAT_40022000 = length | _DAT_40022000 & 0xfffffff8, length != (length & 7))) {\n    result = 1;\n  }\n  else {\n    if ((*parameters & 2) != 0) {\n      _DAT_40021004 = parameters[2] | _DAT_40021004 & 0xffffff0f;\n    }\n    if ((*parameters & 1) == 0) {\nLAB_08003394:\n      if ((length < (_DAT_40022000 & 7)) &&\n         (_DAT_40022000 = length | _DAT_40022000 & 0xfffffff8, length != (length & 7))) {\n        result = 1;\n      }\n      else {\n        if ((*parameters & 4) != 0) {\n          _DAT_40021004 = parameters[3] | _DAT_40021004 & 0xfffff8ff;\n        }\n        if ((*parameters & 8) != 0) {\n          _DAT_40021004 = parameters[4] << 3 | _DAT_40021004 & 0xffffc7ff;\n        }\n        delay = calculate_delay_08003440();\n        DAT_20000018 = delay >> (&DAT_08009eb0)[_DAT_40021004 >> 4 & 0xf];\n        validate_and_update_param_0800151c(0xf);\n        result = 0;\n      }\n    }\n    else {\n      if (parameters[1] == 1) {\n        if ((_DAT_40021000 & 0x20000) == 0) {\n          return 1;\n        }\n      }\n      else if ((parameters[1] != 2) && ((_DAT_40021000 & 2) == 0)) {\n        return 1;\n      }\n      _DAT_40021004 = parameters[1] | _DAT_40021004 & 0xfffffffc;\n      dataValue1 = get_data_value_080015a0();\n      if (parameters[1] == 1) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 4) goto LAB_08003394;\n          dataValue2 = get_data_value_080015a0();\n        } while ((uint)(dataValue2 - dataValue1) < 0x1389);\n        result = 3;\n      }\n      else if (parameters[1] == 2) {\n        do {\n          if ((_DAT_40021004 & 0xc) == 8) goto LAB_08003394;\n          dataValue2 = get_data_value_080015a0();\n        } while ((uint)(dataValue2 - dataValue1) < 0x1389);\n        result = 3;\n      }\n      else {\n        do {\n          if ((_DAT_40021004 & 0xc) == 0) goto LAB_08003394;\n          dataValue2 = get_data_value_080015a0();\n        } while ((uint)(dataValue2 - dataValue1) < 0x1389);\n        result = 3;\n      }\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003260": "process_data_08003260",
                "param_1": "parameters",
                "param_2": "length",
                "iVar1": "dataValue1",
                "iVar2": "dataValue2",
                "uVar3": "delay",
                "uVar4": "result"
            },
            "calling": [
                "FUN_080052a0"
            ],
            "called": [
                "FUN_0800151c",
                "FUN_080015a0",
                "FUN_08003440"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003440": {
            "entrypoint": "0x08003440",
            "current_name": "calculate_delay_08003440",
            "code": "\n\n\nuint calculate_delay_08003440(void)\n\n{\n  undefined2 constant_value;\n  undefined4 initial_value;\n  undefined4 stack_value1;\n  undefined4 stack_value2;\n  undefined4 stack_value3;\n  uint condition_value1;\n  undefined4 condition_value2;\n  uint local_14;\n  uint delay_value;\n  uint calculated_delay;\n  \n  initial_value = 0x5040302;\n  stack_value1 = 0x9080706;\n  stack_value2 = 0xd0c0b0a;\n  stack_value3 = 0x10100f0e;\n  constant_value = 0x201;\n  condition_value2 = 0;\n  calculated_delay = 0;\n  condition_value1 = 0;\n  delay_value = 0;\n  local_14 = _DAT_40021004;\n  if ((_DAT_40021004 & 0xc) == 4) {\n    delay_value = 8000000;\n  }\n  else if ((_DAT_40021004 & 0xc) == 8) {\n    condition_value1 = (uint)*(byte *)((int)&initial_value + (_DAT_40021004 >> 0x12 & 0xf));\n    if ((_DAT_40021004 & 0x10000) == 0) {\n      calculated_delay = condition_value1 * 4000000;\n    }\n    else {\n      calculated_delay = (condition_value1 * 8000000) / (uint)*(byte *)((int)&constant_value + (_DAT_40021004 >> 0x11 & 1))\n      ;\n    }\n    delay_value = calculated_delay;\n  }\n  else {\n    delay_value = 8000000;\n  }\n  return delay_value;\n}\n\n",
            "renaming": {
                "FUN_08003440": "calculate_delay_08003440",
                "local_30": "constant_value",
                "local_2c": "initial_value",
                "uStack_28": "stack_value1",
                "uStack_24": "stack_value2",
                "uStack_20": "stack_value3",
                "local_1c": "condition_value1",
                "local_18": "condition_value2",
                "local_10": "delay_value",
                "local_c": "calculated_delay"
            },
            "calling": [
                "FUN_08003260"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003504": {
            "entrypoint": "0x08003504",
            "current_name": "get_data_08003504",
            "code": "\nundefined4 get_data_08003504(void)\n\n{\n  return DAT_20000018;\n}\n\n",
            "renaming": {
                "FUN_08003504": "get_data_08003504"
            },
            "calling": [
                "FUN_08003518",
                "FUN_080052a0",
                "FUN_08003540"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003518": {
            "entrypoint": "0x08003518",
            "current_name": "retrieve_shifted_value_08003518",
            "code": "\n\n\nuint retrieve_shifted_value_08003518(void)\n\n{\n  uint data;\n  \n  data = retrieve_data();\n  return data >> *(signed_byte *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 8 & 7));\n}\n\n",
            "renaming": {
                "FUN_08003518": "retrieve_shifted_value_08003518",
                "uVar1": "data",
                "get_data_08003504": "retrieve_data",
                "sbyte": "signed_byte"
            },
            "calling": [
                "FUN_08001ab0",
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003540": {
            "entrypoint": "0x08003540",
            "current_name": "shift_data_by_constant_08003540",
            "code": "\n\n\nuint shiftDataByConstant_08003540(void)\n\n{\n  uint data;\n  \n  data = getDataFromAddress();\n  return data >> *(mask *)((int)&DAT_08009ec0 + (_DAT_40021004 >> 0xb & 7));\n}\n\n",
            "renaming": {
                "FUN_08003540": "shift_data_by_constant_08003540",
                "uVar1": "data",
                "sbyte": "mask",
                "get_data_08003504": "getDataFromAddress"
            },
            "calling": [
                "FUN_080046ec"
            ],
            "called": [
                "FUN_08003504"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003568": {
            "entrypoint": "0x08003568",
            "current_name": "delay_function_08003568",
            "code": "\nvoid delayFunction_08003568(int inputValue)\n\n{\n  bool isNonZero;\n  int iterationCount;\n  \n  iterationCount = inputValue * (DAT_20000018 / 8000);\n  do {\n    isNonZero = iterationCount != 0;\n    iterationCount = iterationCount + -1;\n  } while (isNonZero);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003568": "delay_function_08003568",
                "param_1": "inputValue",
                "local_c": "iterationCount",
                "bVar1": "isNonZero"
            },
            "calling": [
                "FUN_08002d98"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035a4": {
            "entrypoint": "0x080035a4",
            "current_name": "check_and_update_memory_080035a4",
            "code": "\nundefined4 checkAndUpdateMemory_080035a4(undefined4 *memoryPointer)\n\n{\n  undefined4 returnValue;\n  \n  if (memoryPointer == (undefined4 *)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)memoryPointer + 0x3d) == '\\0') {\n      *(undefined *)(memoryPointer + 0xf) = 0;\n      FUNC_080035fa(memoryPointer);\n    }\n    *(undefined *)((int)memoryPointer + 0x3d) = 2;\n    update_memory_08003c94(*memoryPointer,memoryPointer + 1);\n    *(undefined *)((int)memoryPointer + 0x3d) = 1;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080035a4": "check_and_update_memory_080035a4",
                "param_1": "memoryPointer",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_080035fa",
                "FUN_08003c94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080035fa": {
            "entrypoint": "0x080035fa",
            "current_name": "FUNC_080035fa",
            "code": "\nvoid FUNC_080035fa(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080035fa": "FUNC_080035fa"
            },
            "calling": [
                "FUN_080035a4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800360c": {
            "entrypoint": "0x0800360c",
            "current_name": "set_flags_0800360c",
            "code": "\nundefined4 setFlags_0800360c(uint **ptrToUint)\n\n{\n  (*ptrToUint)[3] = (*ptrToUint)[3] | 1;\n  **ptrToUint = **ptrToUint | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800360c": "set_flags_0800360c",
                "param_1": "ptrToUint"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003640": {
            "entrypoint": "0x08003640",
            "current_name": "check_and_update_buffer_08003640",
            "code": "\nundefined4 checkAndUpdateBuffer_08003640(undefined4 *buffer)\n\n{\n  undefined4 returnValue;\n  \n  if (buffer == (undefined4 *)0x0) {\n    returnValue = 1;\n  }\n  else {\n    if (*(char *)((int)buffer + 0x3d) == '\\0') {\n      *(undefined *)(buffer + 0xf) = 0;\n      FUNC_08003696(buffer);\n    }\n    *(undefined *)((int)buffer + 0x3d) = 2;\n    update_memory_08003c94(*buffer,buffer + 1);\n    *(undefined *)((int)buffer + 0x3d) = 1;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003640": "check_and_update_buffer_08003640",
                "param_1": "buffer",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003696",
                "FUN_08003c94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003696": {
            "entrypoint": "0x08003696",
            "current_name": "FUNC_08003696",
            "code": "\nvoid FUNC_08003696(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003696": "FUNC_08003696"
            },
            "calling": [
                "FUN_08003640"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080036a8": {
            "entrypoint": "0x080036a8",
            "current_name": "update_and_set_values_080036a8",
            "code": "\nundefined4 update_and_set_values_080036a8(uint **ptr_to_param_1,undefined4 param_2)\n\n{\n  update_bitwise_value_080041ea(*ptr_to_param_1,param_2,1);\n  if (*ptr_to_param_1 == (uint *)0x40012c00) {\n    (*ptr_to_param_1)[0x11] = (*ptr_to_param_1)[0x11] | 0x8000;\n  }\n  **ptr_to_param_1 = **ptr_to_param_1 | 1;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080036a8": "update_and_set_values_080036a8",
                "param_1": "ptr_to_param_1"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080041ea"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080036f8": {
            "entrypoint": "0x080036f8",
            "current_name": "handle_param_080036f8",
            "code": "\nvoid handleParam_080036f8(int *param)\n\n{\n  if (((*(uint *)(*param + 0x10) & 2) == 2) && ((*(uint *)(*param + 0xc) & 2) == 2)) {\n    *(undefined4 *)(*param + 0x10) = 0xfffffffd;\n    *(undefined *)(param + 7) = 1;\n    if ((*(uint *)(*param + 0x18) & 3) == 0) {\n      FUNC_08003c4a(param);\n      FUNC_08003c6e(param);\n    }\n    else {\n      FUNC_08003c5c(param);\n    }\n    *(undefined *)(param + 7) = 0;\n  }\n  if (((*(uint *)(*param + 0x10) & 4) == 4) && ((*(uint *)(*param + 0xc) & 4) == 4)) {\n    *(undefined4 *)(*param + 0x10) = 0xfffffffb;\n    *(undefined *)(param + 7) = 2;\n    if ((*(uint *)(*param + 0x18) & 0x300) == 0) {\n      FUNC_08003c4a(param);\n      FUNC_08003c6e(param);\n    }\n    else {\n      FUNC_08003c5c(param);\n    }\n    *(undefined *)(param + 7) = 0;\n  }\n  if (((*(uint *)(*param + 0x10) & 8) == 8) && ((*(uint *)(*param + 0xc) & 8) == 8)) {\n    *(undefined4 *)(*param + 0x10) = 0xfffffff7;\n    *(undefined *)(param + 7) = 4;\n    if ((*(uint *)(*param + 0x1c) & 3) == 0) {\n      FUNC_08003c4a(param);\n      FUNC_08003c6e(param);\n    }\n    else {\n      FUNC_08003c5c(param);\n    }\n    *(undefined *)(param + 7) = 0;\n  }\n  if (((*(uint *)(*param + 0x10) & 0x10) == 0x10) && ((*(uint *)(*param + 0xc) & 0x10) == 0x10))\n  {\n    *(undefined4 *)(*param + 0x10) = 0xffffffef;\n    *(undefined *)(param + 7) = 8;\n    if ((*(uint *)(*param + 0x1c) & 0x300) == 0) {\n      FUNC_08003c4a(param);\n      FUNC_08003c6e(param);\n    }\n    else {\n      FUNC_08003c5c(param);\n    }\n    *(undefined *)(param + 7) = 0;\n  }\n  if (((*(uint *)(*param + 0x10) & 1) == 1) && ((*(uint *)(*param + 0xc) & 1) == 1)) {\n    *(undefined4 *)(*param + 0x10) = 0xfffffffe;\n    decode_and_update_values_08004f78(param);\n  }\n  if (((*(uint *)(*param + 0x10) & 0x80) == 0x80) && ((*(uint *)(*param + 0xc) & 0x80) == 0x80))\n  {\n    *(undefined4 *)(*param + 0x10) = 0xffffff7f;\n    FUNC_08004378(param);\n  }\n  if (((*(uint *)(*param + 0x10) & 0x40) == 0x40) && ((*(uint *)(*param + 0xc) & 0x40) == 0x40))\n  {\n    *(undefined4 *)(*param + 0x10) = 0xffffffbf;\n    FUNC_08003c80(param);\n  }\n  if (((*(uint *)(*param + 0x10) & 0x20) == 0x20) && ((*(uint *)(*param + 0xc) & 0x20) == 0x20))\n  {\n    *(undefined4 *)(*param + 0x10) = 0xffffffdf;\n    FUNC_08004366(param);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080036f8": "handle_param_080036f8",
                "param_1": "param"
            },
            "calling": [
                "FUN_08005714"
            ],
            "called": [
                "FUN_08004f78",
                "FUN_08003c6e",
                "FUN_08004378",
                "FUN_08003c4a",
                "FUN_08004366",
                "FUN_08003c80",
                "FUN_08003c5c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003908": {
            "entrypoint": "0x08003908",
            "current_name": "update_registers_and_flags_08003908",
            "code": "\nundefined4 update_registers_and_flags_08003908(int *registers,int flags,undefined4 operation)\n\n{\n  undefined4 result;\n  \n  if (*(char *)(registers + 0xf) == '\\x01') {\n    result = 2;\n  }\n  else {\n    *(undefined *)(registers + 0xf) = 1;\n    *(undefined *)((int)registers + 0x3d) = 2;\n    switch(operation) {\n    case 0:\n      update_registers(*registers,flags);\n      *(uint *)(*registers + 0x18) = *(uint *)(*registers + 0x18) | 8;\n      *(uint *)(*registers + 0x18) = *(uint *)(*registers + 0x18) & 0xfffffffb;\n      *(uint *)(*registers + 0x18) = *(uint *)(flags + 0x10) | *(uint *)(*registers + 0x18);\n      break;\n    case 4:\n      clear_flags_and_set_values(*registers,flags);\n      *(uint *)(*registers + 0x18) = *(uint *)(*registers + 0x18) | 0x800;\n      *(uint *)(*registers + 0x18) = *(uint *)(*registers + 0x18) & 0xfffffbff;\n      *(uint *)(*registers + 0x18) = *(int *)(flags + 0x10) << 8 | *(uint *)(*registers + 0x18);\n      break;\n    case 8:\n      initialize_memory(*registers,flags);\n      *(uint *)(*registers + 0x1c) = *(uint *)(*registers + 0x1c) | 8;\n      *(uint *)(*registers + 0x1c) = *(uint *)(*registers + 0x1c) & 0xfffffffb;\n      *(uint *)(*registers + 0x1c) = *(uint *)(flags + 0x10) | *(uint *)(*registers + 0x1c);\n      break;\n    case 0xc:\n      update_parameters(*registers,flags);\n      *(uint *)(*registers + 0x1c) = *(uint *)(*registers + 0x1c) | 0x800;\n      *(uint *)(*registers + 0x1c) = *(uint *)(*registers + 0x1c) & 0xfffffbff;\n      *(uint *)(*registers + 0x1c) = *(int *)(flags + 0x10) << 8 | *(uint *)(*registers + 0x1c);\n    }\n    *(undefined *)((int)registers + 0x3d) = 1;\n    *(undefined *)(registers + 0xf) = 0;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08003908": "update_registers_and_flags_08003908",
                "param_1": "registers",
                "param_2": "flags",
                "param_3": "operation",
                "uVar1": "result",
                "update_registers_08003d60": "update_registers",
                "update_parameters_08003ff8": "update_parameters",
                "clear_flags_and_set_values_08003e38": "clear_flags_and_set_values",
                "initialize_memory_08003f18": "initialize_memory"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_08003ff8",
                "FUN_08003d60",
                "FUN_08003f18",
                "FUN_08003e38"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003a94": {
            "entrypoint": "0x08003a94",
            "current_name": "update_parameter_value_08003a94",
            "code": "\nundefined4 updateParameterValue_08003a94(int *paramArray,uint *inputArray)\n\n{\n  undefined4 returnValue;\n  uint inputValue;\n  \n  if (*(char *)(paramArray + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(paramArray + 0xf) = 1;\n    *(undefined *)((int)paramArray + 0x3d) = 2;\n    *(uint *)(*paramArray + 8) = *(uint *)(*paramArray + 8) & 0xffff0088;\n    inputValue = *inputArray;\n    if (inputValue == 0x40) {\n      update_flags_and_values_080040a0(*paramArray,inputArray[1],inputArray[3]);\n      update_value_with_param_0800416a(*paramArray,0x40);\n    }\n    else if (inputValue < 0x41) {\n      if (inputValue == 0x10) {\n        update_value_with_param_0800416a(*paramArray,0x10);\n      }\n      else if (inputValue < 0x11) {\n        if (inputValue == 0) {\n          update_value_with_param_0800416a(*paramArray,0);\n        }\n      }\n      else if (inputValue == 0x20) {\n        update_value_with_param_0800416a(*paramArray,0x20);\n      }\n      else if (inputValue == 0x30) {\n        update_value_with_param_0800416a(*paramArray,0x30);\n      }\n    }\n    else if (inputValue == 0x70) {\n      update_param_with_mask_080041a8(*paramArray,inputArray[2],inputArray[1],inputArray[3]);\n      *(uint *)(*paramArray + 8) = *(uint *)(*paramArray + 8) & 0xffffff88 | 0x77;\n    }\n    else if (inputValue < 0x71) {\n      if (inputValue == 0x50) {\n        update_flags_and_values_080040a0(*paramArray,inputArray[1],inputArray[3]);\n        update_value_with_param_0800416a(*paramArray,0x50);\n      }\n      else if (inputValue == 0x60) {\n        update_params_08004104(*paramArray,inputArray[1],inputArray[3]);\n        update_value_with_param_0800416a(*paramArray,0x60);\n      }\n    }\n    else if (inputValue == 0x1000) {\n      *(uint *)(*paramArray + 8) = *(uint *)(*paramArray + 8) & 0xfffffff8;\n    }\n    else if (inputValue == 0x2000) {\n      update_param_with_mask_080041a8(*paramArray,inputArray[2],inputArray[1],inputArray[3]);\n      *(uint *)(*paramArray + 8) = *(uint *)(*paramArray + 8) | 0x4000;\n    }\n    *(undefined *)((int)paramArray + 0x3d) = 1;\n    *(undefined *)(paramArray + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08003a94": "update_parameter_value_08003a94",
                "param_1": "paramArray",
                "param_2": "inputArray",
                "uVar1": "returnValue",
                "uVar2": "inputValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [
                "FUN_08004104",
                "FUN_080040a0",
                "FUN_0800416a",
                "FUN_080041a8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003c4a": {
            "entrypoint": "0x08003c4a",
            "current_name": "FUNC_08003c4a",
            "code": "\nvoid FUNC_08003c4a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c4a": "FUNC_08003c4a"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c5c": {
            "entrypoint": "0x08003c5c",
            "current_name": "FUNC_08003c5c",
            "code": "\nvoid FUNC_08003c5c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c5c": "FUNC_08003c5c"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c6e": {
            "entrypoint": "0x08003c6e",
            "current_name": "FUNC_08003c6e",
            "code": "\nvoid FUNC_08003c6e(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c6e": "FUNC_08003c6e"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c80": {
            "entrypoint": "0x08003c80",
            "current_name": "FUNC_08003c80",
            "code": "\nvoid FUNC_08003c80(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c80": "FUNC_08003c80"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08003c94": {
            "entrypoint": "0x08003c94",
            "current_name": "update_memory_08003c94",
            "code": "\nvoid updateMemory_08003c94(uint *memoryAddress,uint *newValue)\n\n{\n  uint currentValue;\n  \n  currentValue = *memoryAddress;\n  if ((((memoryAddress == (uint *)0x40012c00) || (memoryAddress == (uint *)0x40000000)) ||\n      (memoryAddress == (uint *)0x40000400)) || (memoryAddress == (uint *)0x40000800)) {\n    currentValue = newValue[1] | currentValue & 0xffffff8f;\n  }\n  if (((memoryAddress == (uint *)0x40012c00) || (memoryAddress == (uint *)0x40000000)) ||\n     ((memoryAddress == (uint *)0x40000400 || (memoryAddress == (uint *)0x40000800)))) {\n    currentValue = newValue[3] | currentValue & 0xfffffcff;\n  }\n  *memoryAddress = newValue[5] | currentValue & 0xffffff7f;\n  memoryAddress[0xb] = newValue[2];\n  memoryAddress[10] = *newValue;\n  if (memoryAddress == (uint *)0x40012c00) {\n    updatedValue = newValue[4];\n  }\n  memoryAddress[5] = 1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003c94": "update_memory_08003c94",
                "param_1": "memoryAddress",
                "param_2": "newValue",
                "local_c": "currentValue",
                "uRam40012c30": "updatedValue"
            },
            "calling": [
                "FUN_08003640",
                "FUN_080035a4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003d60": {
            "entrypoint": "0x08003d60",
            "current_name": "update_registers_08003d60",
            "code": "\nvoid updateRegisters_08003d60(int regAddress,uint *regValues)\n\n{\n  uint value1;\n  uint value2;\n  uint localValue;\n  \n  *(uint *)(regAddress + 0x20) = *(uint *)(regAddress + 0x20) & 0xfffffffe;\n  localValue = *(uint *)(regAddress + 4);\n  value1 = *regValues;\n  value2 = regValues[2] | *(uint *)(regAddress + 0x20) & 0xfffffffd;\n  if (regAddress == 0x40012c00) {\n    value2 = (regValues[3] | value2 & 0xfffffff7) & 0xfffffffb;\n    localValue = regValues[6] | regValues[5] | localValue & 0xfffffcff;\n  }\n  *(uint *)(regAddress + 4) = localValue;\n  *(uint *)(regAddress + 0x18) = value1 | *(uint *)(regAddress + 0x18) & 0xffffff8c;\n  *(uint *)(regAddress + 0x34) = register3;\n  *(uint *)(regAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003d60": "update_registers_08003d60",
                "param_1": "regAddress",
                "param_2": "regValues",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "localValue",
                "param_2[1]": "register3"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003e38": {
            "entrypoint": "0x08003e38",
            "current_name": "clear_flags_and_set_values_08003e38",
            "code": "\nvoid clearFlagsAndSetValues_08003e38(int flagAddress,int *data)\n\n{\n  int dataValue;\n  uint updatedValue;\n  uint currentValue;\n  \n  *(uint *)(flagAddress + 0x20) = *(uint *)(flagAddress + 0x20) & 0xffffffef;\n  currentValue = *(uint *)(flagAddress + 4);\n  dataValue = *data;\n  updatedValue = data[2] << 4 | *(uint *)(flagAddress + 0x20) & 0xffffffdf;\n  if (flagAddress == 0x40012c00) {\n    updatedValue = (data[3] << 4 | updatedValue & 0xffffff7f) & 0xffffffbf;\n    currentValue = data[6] << 2 | data[5] << 2 | currentValue & 0xfffff3ff;\n  }\n  *(uint *)(flagAddress + 4) = currentValue;\n  *(uint *)(flagAddress + 0x18) = dataValue << 8 | *(uint *)(flagAddress + 0x18) & 0xffff8cff;\n  *(int *)(flagAddress + 0x38) = data[1];\n  *(uint *)(flagAddress + 0x20) = updatedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003e38": "clear_flags_and_set_values_08003e38",
                "param_1": "flagAddress",
                "param_2": "data",
                "iVar1": "dataValue",
                "uVar2": "updatedValue",
                "local_10": "currentValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003f18": {
            "entrypoint": "0x08003f18",
            "current_name": "initialize_memory_08003f18",
            "code": "\nvoid initializeMemory_08003f18(int memoryAddress,uint *data)\n\n{\n  uint value1;\n  uint value2;\n  uint localVariable;\n  \n  *(uint *)(memoryAddress + 0x20) = *(uint *)(memoryAddress + 0x20) & 0xfffffeff;\n  localVariable = *(uint *)(memoryAddress + 4);\n  value1 = *data;\n  value2 = data[2] << 8 | *(uint *)(memoryAddress + 0x20) & 0xfffffdff;\n  if (memoryAddress == 0x40012c00) {\n    value2 = (data[3] << 8 | value2 & 0xfffff7ff) & 0xfffffbff;\n    localVariable = data[6] << 4 | data[5] << 4 | localVariable & 0xffffcfff;\n  }\n  *(uint *)(memoryAddress + 4) = localVariable;\n  *(uint *)(memoryAddress + 0x1c) = value1 | *(uint *)(memoryAddress + 0x1c) & 0xffffff8c;\n  *(uint *)(memoryAddress + 0x3c) = data[1];\n  *(uint *)(memoryAddress + 0x20) = value2;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003f18": "initialize_memory_08003f18",
                "param_1": "memoryAddress",
                "param_2": "data",
                "uVar1": "value1",
                "uVar2": "value2",
                "local_10": "localVariable"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08003ff8": {
            "entrypoint": "0x08003ff8",
            "current_name": "update_parameters_08003ff8",
            "code": "\nvoid updateParameters_08003ff8(int baseAddress,int *paramsArray)\n\n{\n  int value1;\n  int value2;\n  uint currentValue;\n  \n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffefff;\n  currentValue = *(uint *)(baseAddress + 4);\n  value1 = *paramsArray;\n  value2 = paramsArray[2];\n  if (baseAddress == 0x40012c00) {\n    currentValue = paramsArray[5] << 6 | currentValue & 0xffffbfff;\n  }\n  *(uint *)(baseAddress + 4) = currentValue;\n  *(uint *)(baseAddress + 0x1c) = value1 << 8 | *(uint *)(baseAddress + 0x1c) & 0xffff8cff;\n  *(int *)(baseAddress + 0x40) = paramsArray[1];\n  *(uint *)(baseAddress + 0x20) = value2 << 0xc | *(uint *)(baseAddress + 0x20) & 0xffffdfff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08003ff8": "update_parameters_08003ff8",
                "param_1": "baseAddress",
                "param_2": "paramsArray",
                "iVar1": "value1",
                "iVar2": "value2",
                "local_c": "currentValue"
            },
            "calling": [
                "FUN_08003908"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080040a0": {
            "entrypoint": "0x080040a0",
            "current_name": "update_flags_and_values_080040a0",
            "code": "\nvoid updateFlagsAndValues_080040a0(int data,uint flag,int value)\n\n{\n  uint tempValue;\n  \n  tempValue = *(uint *)(data + 0x20);\n  *(uint *)(data + 0x20) = *(uint *)(data + 0x20) & 0xfffffffe;\n  *(uint *)(data + 0x18) = value << 4 | *(uint *)(data + 0x18) & 0xffffff0f;\n  *(uint *)(data + 0x20) = flag | tempValue & 0xfffffff5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080040a0": "update_flags_and_values_080040a0",
                "param_1": "data",
                "param_2": "flag",
                "param_3": "value",
                "uVar1": "tempValue"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004104": {
            "entrypoint": "0x08004104",
            "current_name": "update_params_08004104",
            "code": "\nvoid updateParams_08004104(int baseAddress,int value,int bitMask)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & 0xffffffef;\n  *(uint *)(baseAddress + 0x18) = bitMask << 0xc | *(uint *)(baseAddress + 0x18) & 0xffff0fff;\n  *(uint *)(baseAddress + 0x20) = value << 4 | *(uint *)(baseAddress + 0x20) & 0xffffff5f;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004104": "update_params_08004104",
                "param_1": "baseAddress",
                "param_2": "value",
                "param_3": "bitMask"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800416a": {
            "entrypoint": "0x0800416a",
            "current_name": "update_value_with_param_0800416a",
            "code": "\nvoid updateValueWithParam_0800416a(int baseAddress,ushort newValue)\n\n{\n  *(uint *)(baseAddress + 8) = *(uint *)(baseAddress + 8) & 0xffffff8f | (uint)(newValue | 7);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800416a": "update_value_with_param_0800416a",
                "param_1": "baseAddress",
                "param_2": "newValue"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041a8": {
            "entrypoint": "0x080041a8",
            "current_name": "update_param_with_mask_080041a8",
            "code": "\nvoid updateParamWithMask_080041a8(int ptr,unsignedInt newValue,unsignedInt bitMask1,int bitShift)\n\n{\n  *(unsignedInt *)(ptr + 8) = newValue | bitShift << 8 | bitMask1 | *(unsignedInt *)(ptr + 8) & 0xffff00ff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041a8": "update_param_with_mask_080041a8",
                "param_1": "ptr",
                "param_2": "newValue",
                "param_3": "bitMask1",
                "param_4": "bitShift",
                "uint": "unsignedInt"
            },
            "calling": [
                "FUN_08003a94"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080041ea": {
            "entrypoint": "0x080041ea",
            "current_name": "update_bitwise_value_080041ea",
            "code": "\nvoid updateBitwiseValue_080041ea(int baseAddress,uint bitPosition,int bitValue)\n\n{\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) & ~(1 << (bitPosition & 0xff));\n  *(uint *)(baseAddress + 0x20) = *(uint *)(baseAddress + 0x20) | bitValue << (bitPosition & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080041ea": "update_bitwise_value_080041ea",
                "param_1": "baseAddress",
                "param_2": "bitPosition",
                "param_3": "bitValue"
            },
            "calling": [
                "FUN_080036a8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800422e": {
            "entrypoint": "0x0800422e",
            "current_name": "update_configuration_0800422e",
            "code": "\nundefined4 updateConfiguration_0800422e(int *configPtr,uint *dataPtr)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(configPtr + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(configPtr + 0xf) = 1;\n    *(uint *)(*configPtr + 0x44) =\n         dataPtr[6] |\n         (dataPtr[6] |\n         (dataPtr[5] |\n         (dataPtr[4] |\n         (*dataPtr | (dataPtr[1] | (dataPtr[2] | dataPtr[3] & 0xfffffcff) & 0xfffffbff) & 0xfffff7ff\n         ) & 0xffffefff) & 0xffffdfff) & 0xffffbfff) & 0xffff7fff;\n    *(undefined *)(configPtr + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_0800422e": "update_configuration_0800422e",
                "param_1": "configPtr",
                "param_2": "dataPtr",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080042de": {
            "entrypoint": "0x080042de",
            "current_name": "update_parameter_080042de",
            "code": "\nundefined4 updateParameter_080042de(int *parameterArray,uint *valueArray)\n\n{\n  undefined4 returnValue;\n  \n  if (*(char *)(parameterArray + 0xf) == '\\x01') {\n    returnValue = 2;\n  }\n  else {\n    *(undefined *)(parameterArray + 0xf) = 1;\n    *(undefined *)((int)parameterArray + 0x3d) = 2;\n    *(uint *)(*parameterArray + 4) = *(uint *)(*parameterArray + 4) & 0xffffff8f;\n    *(uint *)(*parameterArray + 4) = *valueArray | *(uint *)(*parameterArray + 4);\n    *(uint *)(*parameterArray + 8) = *(uint *)(*parameterArray + 8) & 0xffffff7f;\n    *(uint *)(*parameterArray + 8) = valueArray[1] | *(uint *)(*parameterArray + 8);\n    *(undefined *)((int)parameterArray + 0x3d) = 1;\n    *(undefined *)(parameterArray + 0xf) = 0;\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080042de": "update_parameter_080042de",
                "param_1": "parameterArray",
                "param_2": "valueArray",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004366": {
            "entrypoint": "0x08004366",
            "current_name": "FUNC_08004366",
            "code": "\nvoid FUNC_08004366(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004366": "FUNC_08004366"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004378": {
            "entrypoint": "0x08004378",
            "current_name": "FUNC_08004378",
            "code": "\nvoid FUNC_08004378(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004378": "FUNC_08004378"
            },
            "calling": [
                "FUN_080036f8"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0800438a": {
            "entrypoint": "0x0800438a",
            "current_name": "initialize_param_0800438a",
            "code": "\nundefined4 initializeParam_0800438a(int *param)\n\n{\n  undefined4 result;\n  \n  if (param == (int *)0x0) {\n    result = 1;\n  }\n  else {\n    if (*(char *)((int)param + 0x39) == '\\0') {\n      *(undefined *)(param + 0xe) = 0;\n      FUNC_08004424(param);\n    }\n    *(undefined *)((int)param + 0x39) = 0x24;\n    *(uint *)(*param + 0xc) = *(uint *)(*param + 0xc) & 0xffffdfff;\n    calculateShiftedValue(param);\n    *(uint *)(*param + 0x10) = *(uint *)(*param + 0x10) & 0xffffb7ff;\n    *(uint *)(*param + 0x14) = *(uint *)(*param + 0x14) & 0xffffffd5;\n    *(uint *)(*param + 0xc) = *(uint *)(*param + 0xc) | 0x2000;\n    paramF = 0;\n    *(undefined *)((int)param + 0x39) = 0x20;\n    *(undefined *)((int)param + 0x3a) = 0x20;\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0800438a": "initialize_param_0800438a",
                "param_1": "param",
                "uVar1": "result",
                "calculate_shifted_value_080046ec": "calculateShiftedValue",
                "param_1[0xf]": "paramF"
            },
            "calling": [
                "FUN_08005598"
            ],
            "called": [
                "FUN_08004424",
                "FUN_080046ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004424": {
            "entrypoint": "0x08004424",
            "current_name": "FUNC_08004424",
            "code": "\nvoid FUNC_08004424(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004424": "FUNC_08004424"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08004436": {
            "entrypoint": "0x08004436",
            "current_name": "extract_data_from_binary_08004436",
            "code": "\nundefined4 extractDataFromBinary_08004436(uint **binaryData,ushort *sourceData,short sourceSize,uint maxDataSize)\n\n{\n  int initialValue;\n  int comparisonValue;\n  undefined4 result;\n  ushort *currentData;\n  \n  if (*(char *)((int)binaryData + 0x39) == ' ') {\n    if ((sourceData == (ushort *)0x0) || (sourceSize == 0)) {\n      result = 1;\n    }\n    else if (*(char *)(binaryData + 0xe) == '\\x01') {\n      result = 2;\n    }\n    else {\n      *(undefined *)(binaryData + 0xe) = 1;\n      binaryData[0xf] = (uint *)0x0;\n      *(undefined *)((int)binaryData + 0x39) = 0x21;\n      initialValue = get_data_value_080015a0();\n      *(short *)(binaryData + 9) = sourceSize;\n      *(short *)((int)binaryData + 0x26) = sourceSize;\n      currentData = sourceData;\n      while (*(short *)((int)binaryData + 0x26) != 0) {\n        *(short *)((int)binaryData + 0x26) = *(short *)((int)binaryData + 0x26) + -1;\n        if (binaryData[2] == (uint *)0x1000) {\n          do {\n            if ((**binaryData & 0x80) == 0x80) {\n              comparisonValue = 0;\n              goto LAB_0800454c;\n            }\n          } while ((maxDataSize == 0xffffffff) ||\n                  ((maxDataSize != 0 && (comparisonValue = get_data_value_080015a0(), (uint)(comparisonValue - initialValue) <= maxDataSize))));\n          (*binaryData)[3] = (*binaryData)[3] & 0xfffffe5f;\n          (*binaryData)[5] = (*binaryData)[5] & 0xfffffffe;\n          *(undefined *)((int)binaryData + 0x39) = 0x20;\n          *(undefined *)((int)binaryData + 0x3a) = 0x20;\n          *(undefined *)(binaryData + 0xe) = 0;\n          comparisonValue = 3;\nLAB_0800454c:\n          if (comparisonValue != 0) {\n            return 3;\n          }\n          (*binaryData)[1] = *currentData & 0x1ff;\n          if (binaryData[4] == (uint *)0x0) {\n            currentData = currentData + 1;\n          }\n          else {\n            currentData = (ushort *)((int)currentData + 1);\n          }\n        }\n        else {\n          do {\n            if ((**binaryData & 0x80) == 0x80) {\n              comparisonValue = 0;\n              goto LAB_08004614;\n            }\n          } while ((maxDataSize == 0xffffffff) ||\n                  ((maxDataSize != 0 && (comparisonValue = get_data_value_080015a0(), (uint)(comparisonValue - initialValue) <= maxDataSize))));\n          (*binaryData)[3] = (*binaryData)[3] & 0xfffffe5f;\n          (*binaryData)[5] = (*binaryData)[5] & 0xfffffffe;\n          *(undefined *)((int)binaryData + 0x39) = 0x20;\n          *(undefined *)((int)binaryData + 0x3a) = 0x20;\n          *(undefined *)(binaryData + 0xe) = 0;\n          comparisonValue = 3;\nLAB_08004614:\n          if (comparisonValue != 0) {\n            return 3;\n          }\n          (*binaryData)[1] = (uint)*(byte *)currentData;\n          currentData = (ushort *)((int)currentData + 1);\n        }\n      }\n      do {\n        if ((**binaryData & 0x40) == 0x40) {\n          initialValue = 0;\n          goto LAB_080046c6;\n        }\n      } while ((maxDataSize == 0xffffffff) ||\n              ((maxDataSize != 0 && (comparisonValue = get_data_value_080015a0(), (uint)(comparisonValue - initialValue) <= maxDataSize))));\n      (*binaryData)[3] = (*binaryData)[3] & 0xfffffe5f;\n      (*binaryData)[5] = (*binaryData)[5] & 0xfffffffe;\n      *(undefined *)((int)binaryData + 0x39) = 0x20;\n      *(undefined *)((int)binaryData + 0x3a) = 0x20;\n      *(undefined *)(binaryData + 0xe) = 0;\n      initialValue = 3;\nLAB_080046c6:\n      if (initialValue == 0) {\n        *(undefined *)((int)binaryData + 0x39) = 0x20;\n        *(undefined *)(binaryData + 0xe) = 0;\n        result = 0;\n      }\n      else {\n        result = 3;\n      }\n    }\n  }\n  else {\n    result = 2;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08004436": "extract_data_from_binary_08004436",
                "param_1": "binaryData",
                "param_2": "sourceData",
                "param_3": "sourceSize",
                "param_4": "maxDataSize",
                "iVar1": "initialValue",
                "iVar2": "comparisonValue",
                "uVar3": "result",
                "local_58": "currentData"
            },
            "calling": [
                "FUN_08004f3c"
            ],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080046ec": {
            "entrypoint": "0x080046ec",
            "current_name": "calculate_shifted_value_080046ec",
            "code": "\nvoid calculateShiftedValue_080046ec(int *inputArray)\n\n{\n  ulonglong shiftedValue;\n  int tempValue1;\n  int tempValue2;\n  uint shiftedValue2;\n  int tempValue3;\n  undefined8 shiftedValue3;\n  \n  *(uint *)(*inputArray + 0x10) = inputArray[3] | *(uint *)(*inputArray + 0x10) & 0xffffcfff;\n  *(uint *)(*inputArray + 0xc) =\n       *(uint *)(*inputArray + 0xc) & 0xffffe9f3 | inputArray[5] | inputArray[2] | inputArray[4];\n  *(uint *)(*inputArray + 0x14) = inputArray[6] | *(uint *)(*inputArray + 0x14) & 0xfffffcff;\n  if (*inputArray == 0x40013800) {\n    shiftedValue3 = shift_data_by_constant_08003540();\n    shiftedValue = (ulonglong)(uint)((int)shiftedValue3 * 0x19) / (ulonglong)(uint)(inputArray[1] << 2);\n    tempValue1 = shift_data_by_constant_08003540((int)shiftedValue3,(int)((ulonglong)shiftedValue3 >> 0x20),(int)(shiftedValue * 0x51eb851f));\n    tempValue2 = inputArray[1];\n    shiftedValue3 = shift_data_by_constant_08003540();\n    shiftedValue2 = ((uint)(tempValue1 * 0x19) / (uint)(tempValue2 << 2) +\n            (int)(((ulonglong)(uint)((int)shiftedValue3 * 0x19) / (ulonglong)(uint)(inputArray[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    tempValue1 = shift_data_by_constant_08003540((int)shiftedValue3,(int)((ulonglong)shiftedValue3 >> 0x20),shiftedValue2 * 0x51eb851f);\n    tempValue3 = inputArray[1];\n    tempValue2 = shift_data_by_constant_08003540();\n    *(uint *)(*inputArray + 8) =\n         ((((uint)(tempValue1 * 0x19) / (uint)(tempValue3 << 2) +\n           (int)(((ulonglong)(uint)(tempValue2 * 0x19) / (ulonglong)(uint)(inputArray[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(shiftedValue / 100) * 0x10 + (shiftedValue2 / 100 & 0xf0);\n  }\n  else {\n    shiftedValue3 = retrieve_shifted_value_08003518();\n    shiftedValue = (ulonglong)(uint)((int)shiftedValue3 * 0x19) / (ulonglong)(uint)(inputArray[1] << 2);\n    tempValue1 = retrieve_shifted_value_08003518((int)shiftedValue3,(int)((ulonglong)shiftedValue3 >> 0x20),(int)(shiftedValue * 0x51eb851f));\n    tempValue2 = inputArray[1];\n    shiftedValue3 = retrieve_shifted_value_08003518();\n    shiftedValue2 = ((uint)(tempValue1 * 0x19) / (uint)(tempValue2 << 2) +\n            (int)(((ulonglong)(uint)((int)shiftedValue3 * 0x19) / (ulonglong)(uint)(inputArray[1] << 2)) / 100)\n            * -100) * 0x10 + 0x32;\n    tempValue1 = retrieve_shifted_value_08003518((int)shiftedValue3,(int)((ulonglong)shiftedValue3 >> 0x20),shiftedValue2 * 0x51eb851f);\n    tempValue3 = inputArray[1];\n    tempValue2 = retrieve_shifted_value_08003518();\n    *(uint *)(*inputArray + 8) =\n         ((((uint)(tempValue1 * 0x19) / (uint)(tempValue3 << 2) +\n           (int)(((ulonglong)(uint)(tempValue2 * 0x19) / (ulonglong)(uint)(inputArray[1] << 2)) / 100) *\n           -100) * 0x10 + 0x32) / 100 & 0xf) + (int)(shiftedValue / 100) * 0x10 + (shiftedValue2 / 100 & 0xf0);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_080046ec": "calculate_shifted_value_080046ec",
                "param_1": "inputArray",
                "uVar1": "shiftedValue",
                "iVar2": "tempValue1",
                "iVar3": "tempValue2",
                "uVar4": "shiftedValue2",
                "iVar5": "tempValue3",
                "uVar6": "shiftedValue3"
            },
            "calling": [
                "FUN_0800438a"
            ],
            "called": [
                "FUN_08003518",
                "FUN_08003540"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800491c": {
            "entrypoint": "0x0800491c",
            "current_name": "initialize_data_0800491c",
            "code": "\nvoid initializeData_0800491c(undefined4 *dataPointer)\n\n{\n  undefined byteZero;\n  undefined byteTen;\n  undefined byteArray [5];\n  \n  byteZero = 0;\n  (*DAT_20000a54)(0xd0,0x6b,&byteZero,1);\n  byteTen = 0x10;\n  (*DAT_20000a54)(0xd0,0x1c,&byteTen,1);\n  byteArray[0] = 8;\n  (*DAT_20000a54)(0xd0,0x1b,byteArray,1);\n  *dataPointer = 0;\n  dataPointer[1] = 0;\n  dataPointer[2] = 0;\n  dataPointer[3] = 0;\n  dataPointer[4] = 0;\n  dataPointer[5] = 0;\n  dataPointer[6] = 0;\n  dataPointer[7] = 0;\n  dataPointer[8] = 0;\n  dataPointer[9] = 0;\n  dataPointer[10] = 0;\n  calculate_floating_point_results_080049cc(dataPointer);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800491c": "initialize_data_0800491c",
                "param_1": "dataPointer",
                "local_13": "byteZero",
                "local_12": "byteTen",
                "local_11": "byteArray"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_080049cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080049cc": {
            "entrypoint": "0x080049cc",
            "current_name": "calculate_floating_point_results_080049cc",
            "code": "\nvoid calculateFloatingPointResults_080049cc(int inputValue)\n\n{\n  undefined4 uVar1;\n  undefined4 decodedValue1;\n  undefined4 decodedValue2;\n  undefined4 timeVal;\n  int iterationCount;\n  int counter;\n  undefined4 sum1;\n  undefined4 sum2;\n  undefined4 sum3;\n  undefined4 sum4;\n  \n  iterationCount = 1;\n  sum4 = 0;\n  sum3 = 0;\n  sum2 = 0;\n  sum1 = 0;\n  timeVal = (*DAT_20000a50)();\n  counter = 0;\n  while( true ) {\n    if (iterationCount <= counter) break;\n    decodedValue2 = 0;\n    decodedValue1 = 0;\n    decodeAndAssignValues(inputValue);\n    calculateDoubleResult(inputValue,&decodedValue2,&decodedValue1);\n    sum2 = calculateFloatAddition(sum2,decodedValue2);\n    sum1 = calculateFloatAddition(sum1,decodedValue1);\n    sum4 = calculateFloatAddition(sum4,*(undefined4 *)(inputValue + 0x10));\n    sum3 = calculateFloatAddition(sum3,*(undefined4 *)(inputValue + 0x14));\n    timeVal = (*DAT_20000a50)();\n    counter = counter + 1;\n  }\n  uVar1 = decodeUnsignedInteger(iterationCount);\n  uVar1 = calculateFloat(sum4,uVar1);\n  *(undefined4 *)(inputValue + 0x1c) = uVar1;\n  uVar1 = decodeUnsignedInteger(iterationCount);\n  uVar1 = calculateFloat(sum3,uVar1);\n  *(undefined4 *)(inputValue + 0x20) = uVar1;\n  uVar1 = decodeUnsignedInteger(iterationCount);\n  uVar1 = calculateFloat(sum2,uVar1);\n  *(undefined4 *)(inputValue + 0x24) = uVar1;\n  uVar1 = decodeUnsignedInteger(iterationCount);\n  uVar1 = calculateFloat(sum1,uVar1);\n  *(undefined4 *)(inputValue + 0x28) = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_080049cc": "calculate_floating_point_results_080049cc",
                "param_1": "inputValue",
                "local_2c": "decodedValue1",
                "local_28": "decodedValue2",
                "local_24": "timeVal",
                "local_20": "iterationCount",
                "local_1c": "counter",
                "local_18": "sum1",
                "local_14": "sum2",
                "local_10": "sum3",
                "local_c": "sum4",
                "decode_and_assign_values_08004ae0": "decodeAndAssignValues",
                "calculate_double_result_08004d78": "calculateDoubleResult",
                "calculate_float_addition_08000aa8": "calculateFloatAddition",
                "decode_uint_08000c10": "decodeUnsignedInteger",
                "calculate_float_08000e20": "calculateFloat"
            },
            "calling": [
                "FUN_0800491c"
            ],
            "called": [
                "FUN_08000e20",
                "FUN_08000aa8",
                "FUN_08004ae0",
                "FUN_08004d78",
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ae0": {
            "entrypoint": "0x08004ae0",
            "current_name": "decode_and_assign_values_08004ae0",
            "code": "\nvoid decode_and_assign_values_08004ae0(undefined4 *output_array)\n\n{\n  undefined4 uVar1;\n  undefined decoded_value_1;\n  undefined decoded_value_2;\n  undefined decoded_value_3;\n  undefined decoded_value_4;\n  undefined decoded_value_5;\n  undefined decoded_value_6;\n  undefined decoded_value_7;\n  undefined decoded_value_8;\n  undefined decoded_value_9;\n  undefined decoded_value_10;\n  undefined decoded_value_11;\n  undefined decoded_value_12;\n  undefined decoded_value_13;\n  undefined decoded_value_14;\n  short decoded_value_15;\n  short decoded_value_16;\n  short decoded_value_17;\n  short decoded_value_18;\n  short decoded_value_19;\n  short decoded_value_20;\n  \n  (*DAT_20000a4c)(0xd0,0x3b,&decoded_value_1,0xe);\n  decoded_value_20 = CONCAT11(decoded_value_3,decoded_value_4);\n  decoded_value_19 = CONCAT11(decoded_value_5,decoded_value_6);\n  decoded_value_18 = CONCAT11(decoded_value_7,decoded_value_8);\n  decoded_value_17 = CONCAT11(decoded_value_9,decoded_value_10);\n  decoded_value_16 = CONCAT11(decoded_value_11,decoded_value_12);\n  decoded_value_15 = CONCAT11(decoded_value_13,decoded_value_14);\n  uVar1 = decode_uint((int)CONCAT11(decoded_value_1,decoded_value_2));\n  *output_array = uVar1;\n  uVar1 = decode_uint((int)decoded_value_20);\n  output_array[1] = uVar1;\n  uVar1 = decode_uint((int)decoded_value_19);\n  output_array[2] = uVar1;\n  uVar1 = decode_uint((int)decoded_value_18);\n  output_array[3] = uVar1;\n  uVar1 = decode_uint((int)decoded_value_17);\n  output_array[4] = uVar1;\n  uVar1 = decode_uint((int)decoded_value_16);\n  output_array[5] = uVar1;\n  uVar1 = decode_uint((int)decoded_value_15);\n  output_array[6] = uVar1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ae0": "decode_and_assign_values_08004ae0",
                "param_1": "output_array",
                "local_2c": "decoded_value_1",
                "local_2b": "decoded_value_2",
                "local_2a": "decoded_value_3",
                "local_29": "decoded_value_4",
                "local_28": "decoded_value_5",
                "local_27": "decoded_value_6",
                "local_26": "decoded_value_7",
                "local_25": "decoded_value_8",
                "local_24": "decoded_value_9",
                "local_23": "decoded_value_10",
                "local_22": "decoded_value_11",
                "local_21": "decoded_value_12",
                "local_20": "decoded_value_13",
                "local_1f": "decoded_value_14",
                "local_1e": "decoded_value_15",
                "local_1c": "decoded_value_16",
                "local_1a": "decoded_value_17",
                "local_18": "decoded_value_18",
                "local_16": "decoded_value_19",
                "local_14": "decoded_value_20",
                "decode_uint_08000c10": "decode_uint"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_080049cc"
            ],
            "called": [
                "FUN_08000c10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004bd8": {
            "entrypoint": "0x08004bd8",
            "current_name": "calculate_updated_result_08004bd8",
            "code": "\nvoid calculate_updated_result_08004bd8(int input_param,undefined4 *output_param)\n\n{\n  undefined4 updated_value1;\n  undefined8 updated_value2;\n  undefined8 updated_value3;\n  \n  updated_value1 = calculate_updated_value_08000aa4(*(undefined4 *)(input_param + 0x10),*(undefined4 *)(input_param + 0x1c));\n  updated_value2 = reverse_bits_08000418(DAT_200009e4);\n  updated_value3 = reverse_bits_08000418(updated_value1);\n  updated_value3 = calculate_product_and_addition_080004c8((int)updated_value3,(int)((ulonglong)updated_value3 >> 0x20),0x83f5c366,0x3f340215);\n  updated_value2 = calculate_result_0800015c((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),(int)updated_value3,\n                       (int)((ulonglong)updated_value3 >> 0x20));\n  DAT_200009e4 = calculate_float_080009fc((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20));\n  updated_value2 = reverse_bits_08000418(*(undefined4 *)(input_param + 4));\n  updated_value2 = convert_value_to_double_0800071c((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),0,0x40b00000);\n  updated_value3 = reverse_bits_08000418(*(undefined4 *)(input_param + 8));\n  updated_value3 = convert_value_to_double_0800071c((int)updated_value3,(int)((ulonglong)updated_value3 >> 0x20),0,0x40b00000);\n  updated_value2 = calculate_result_thunk_08005838((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),(int)updated_value3,\n                             (int)((ulonglong)updated_value3 >> 0x20));\n  updated_value2 = calculate_product_and_addition_080004c8((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),0,0x40668000);\n  updated_value2 = convert_value_to_double_0800071c((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),0x54442d18,0x400921fb);\n  updated_value3 = reverse_bits_08000418(*(undefined4 *)(input_param + 0x24));\n  updated_value2 = unsigned_long_long_binary_operation_08000158((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),(int)updated_value3,\n                       (int)((ulonglong)updated_value3 >> 0x20));\n  updated_value2 = calculate_result_0800015c((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),0,0x40568000);\n  updated_value1 = calculate_float_080009fc((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20));\n  if (DAT_20000005 == '\\0') {\n    updated_value2 = reverse_bits_08000418(DAT_200009e4);\n    updated_value2 = calculate_product_and_addition_080004c8((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),0x9999999a,0x3fe99999);\n    updated_value3 = reverse_bits_08000418(updated_value1);\n    updated_value3 = calculate_product_and_addition_080004c8((int)updated_value3,(int)((ulonglong)updated_value3 >> 0x20),0x9999999a,0x3fc99999);\n    updated_value2 = calculate_result_0800015c((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20),(int)updated_value3,\n                         (int)((ulonglong)updated_value3 >> 0x20));\n    DAT_200009e4 = calculate_float_080009fc((int)updated_value2,(int)((ulonglong)updated_value2 >> 0x20));\n  }\n  else {\n    DAT_20000005 = '\\0';\n    DAT_200009e4 = updated_value1;\n  }\n  *output_param = DAT_200009e4;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004bd8": "calculate_updated_result_08004bd8",
                "param_1": "input_param",
                "param_2": "output_param",
                "uVar1": "updated_value1",
                "uVar2": "updated_value2",
                "uVar3": "updated_value3"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08000158",
                "FUN_080009fc",
                "thunk_FUN_08005838",
                "FUN_08000418",
                "FUN_0800015c",
                "FUN_0800071c",
                "FUN_08000aa4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004d78": {
            "entrypoint": "0x08004d78",
            "current_name": "calculate_double_result_08004d78",
            "code": "\nvoid calculate_double_result_08004d78(undefined4 *input_array,undefined4 *output_1,undefined4 *output_2)\n\n{\n  undefined4 result_1;\n  undefined4 result_2;\n  undefined4 result_3;\n  undefined8 calculation_1;\n  undefined8 calculation_2;\n  \n  result_1 = calculate_float_08000e20(*input_array,0x45800000);\n  result_2 = calculate_float_08000e20(input_array[1],0x45800000);\n  result_3 = calculate_float_08000e20(input_array[2],0x45800000);\n  calculation_1 = reverse_bits_08000418(result_2);\n  calculation_2 = reverse_bits_08000418(result_3);\n  calculation_1 = calculate_result_thunk_08005838((int)calculation_1,(int)((ulonglong)calculation_1 >> 0x20),(int)calculation_2,\n                             (int)((ulonglong)calculation_2 >> 0x20));\n  calculation_1 = calculate_product_and_addition_080004c8((int)calculation_1,(int)((ulonglong)calculation_1 >> 0x20),0,0x40668000);\n  calculation_1 = convert_value_to_double_0800071c((int)calculation_1,(int)((ulonglong)calculation_1 >> 0x20),0x54442d18,0x400921fb);\n  result_2 = calculate_float_080009fc((int)calculation_1,(int)((ulonglong)calculation_1 >> 0x20));\n  calculation_1 = reverse_bits_08000418(result_1);\n  calculation_2 = reverse_bits_08000418(result_3);\n  calculation_1 = calculate_result_thunk_08005838((int)calculation_1,(int)((ulonglong)calculation_1 >> 0x20),(int)calculation_2,\n                             (int)((ulonglong)calculation_2 >> 0x20));\n  calculation_1 = calculate_product_and_addition_080004c8((int)calculation_1,(int)((ulonglong)calculation_1 >> 0x20),0,0x40668000);\n  calculation_1 = convert_value_to_double_0800071c((int)calculation_1,(int)((ulonglong)calculation_1 >> 0x20),0x54442d18,0x400921fb);\n  result_1 = calculate_float_080009fc((int)calculation_1,(int)((ulonglong)calculation_1 >> 0x20));\n  *output_1 = result_2;\n  *output_2 = result_1;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004d78": "calculate_double_result_08004d78",
                "param_1": "input_array",
                "param_2": "output_1",
                "param_3": "output_2",
                "uVar1": "result_1",
                "uVar2": "result_2",
                "uVar3": "result_3",
                "uVar4": "calculation_1",
                "uVar5": "calculation_2"
            },
            "calling": [
                "FUN_080049cc"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_080009fc",
                "FUN_08000e20",
                "thunk_FUN_08005838",
                "FUN_08000418",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e6c": {
            "entrypoint": "0x08004e6c",
            "current_name": "send_software_interrupt_08004e6c",
            "code": "\nvoid sendSoftwareInterrupt_08004e6c(void)\n\n{\n  software_interrupt(0x3f);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004e6c": "send_software_interrupt_08004e6c"
            },
            "calling": [
                "FUN_08004e74"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004e74": {
            "entrypoint": "0x08004e74",
            "current_name": "check_software_interrupt_08004e74",
            "code": "\nundefined4 checkSoftwareInterrupt_08004e74(undefined4 inputValue)\n\n{\n  undefined4 returnValue;\n  \n  if (DAT_200009f0 == 0) {\n    returnValue = send_software_interrupt_08004e6c(1,inputValue,0);\n  }\n  else {\n    returnValue = 0;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08004e74": "check_software_interrupt_08004e74",
                "param_1": "inputValue",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08004e6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ea4": {
            "entrypoint": "0x08004ea4",
            "current_name": "process_data_08004ea4",
            "code": "\nvoid process_data_08004ea4(undefined input_param_1,undefined input_param_2,undefined4 input_param_3,undefined2 input_param_4)\n\n{\n  process_data_08004ea4_08001ccc(&DAT_20000a88,input_param_1,input_param_2,1,input_param_3,input_param_4,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ea4": "process_data_08004ea4",
                "param_1": "input_param_1",
                "param_2": "input_param_2",
                "param_3": "input_param_3",
                "param_4": "input_param_4"
            },
            "calling": [],
            "called": [
                "FUN_08001ccc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004ee8": {
            "entrypoint": "0x08004ee8",
            "current_name": "process_and_update_data_08004ee8",
            "code": "\nvoid process_and_update_data_08004ee8(undefined data1,undefined data2,undefined4 value1,undefined2 value2)\n\n{\n  process_data_08001f6c(&DAT_20000a88,data1,data2,1,value1,value2,DAT_20000008);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004ee8": "process_and_update_data_08004ee8",
                "param_1": "data1",
                "param_2": "data2",
                "param_3": "value1",
                "param_4": "value2"
            },
            "calling": [],
            "called": [
                "FUN_08001f6c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f2c": {
            "entrypoint": "0x08004f2c",
            "current_name": "get_data_value_08004f2c",
            "code": "\nundefined4 get_data_value_08004f2c(void)\n\n{\n  undefined4 data_value;\n  \n  data_value = get_data_value_08004f2c_080015a0();\n  return data_value;\n}\n\n",
            "renaming": {
                "FUN_08004f2c": "get_data_value_08004f2c",
                "uVar1": "data_value"
            },
            "calling": [],
            "called": [
                "FUN_080015a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f3c": {
            "entrypoint": "0x08004f3c",
            "current_name": "extract_and_process_data_08004f3c",
            "code": "\nvoid extract_and_process_data_08004f3c(undefined4 data_ptr,undefined2 data_size)\n\n{\n  extract_data(&DAT_20000adc,data_ptr,data_size,0x32);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f3c": "extract_and_process_data_08004f3c",
                "param_1": "data_ptr",
                "param_2": "data_size",
                "extract_data_from_binary_08004436": "extract_data"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08004436"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f60": {
            "entrypoint": "0x08004f60",
            "current_name": "initialize_memory_08004f60",
            "code": "\nvoid initializeMemory_08004f60(void)\n\n{\n  fillMemoryWithByte(&DAT_20000ba8,0,0x40);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f60": "initialize_memory_08004f60",
                "fill_memory_with_byte_08005d68": "fillMemoryWithByte"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005d68"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08004f78": {
            "entrypoint": "0x08004f78",
            "current_name": "decode_and_update_values_08004f78",
            "code": "\nvoid decode_and_update_values_08004f78(void)\n\n{\n  undefined4 value1;\n  int result;\n  undefined4 value2;\n  uint flippedValue;\n  undefined8 reversedBits;\n  byte shiftedValue;\n  \n  decode_and_assign_values_08004ae0(&DAT_20000a5c);\n  calculate_updated_result_08004bd8(&DAT_20000a5c,&DAT_20000ba0);\n  initialize_memory_08004f60();\n  reversedBits = reverse_bits_08000418(DAT_20000ba0);\n  initialize_pointer_08005dfc(&DAT_20000ba8,\"Pitch: %f\\n\",(int)reversedBits,(int)((ulonglong)reversedBits >> 0x20));\n  value1 = count_trailing_zeroes_08005e40(&DAT_20000ba8);\n  extract_and_process_data_08004f3c(&DAT_20000ba8,value1);\n  DAT_200009f8 = calculate_updated_value_08000aa4(DAT_20000014,DAT_20000ba0);\n  DAT_20000be8 = calculate_floating_point_08000cb8(DAT_20000a00,DAT_200009f8);\n  value1 = calculate_floating_point_08000cb8(DAT_20000a04,DAT_200009f8);\n  DAT_20000b5c = calculate_float_addition_08000aa8(value1,DAT_20000b5c);\n  value1 = decode_uint_08000c10(DAT_20000010);\n  result = is_null_terminated_08000ff4(value1,DAT_20000b5c);\n  if (result == 0) {\n    value1 = decode_uint_08000c10(DAT_200009f4);\n    result = check_if_concatenation_is_empty_08001030(value1,DAT_20000b5c);\n    if (result != 0) {\n      DAT_20000b5c = calculate_new_value_08000c08(DAT_200009f4);\n    }\n  }\n  else {\n    DAT_20000b5c = calculate_new_value_08000c08(DAT_20000010);\n  }\n  flippedValue = DAT_20000a08 ^ 0x80000000;\n  value1 = calculate_updated_value_08000aa4(DAT_200009f8,DAT_200009fc);\n  DAT_20000a58 = calculate_floating_point_08000cb8(flippedValue,value1);\n  value1 = calculate_float_addition_08000aa8(DAT_20000be8,DAT_20000b5c);\n  value1 = calculate_float_addition_08000aa8(value1,DAT_20000a58);\n  value2 = decode_uint_08000c10(DAT_20000010);\n  result = check_if_concatenation_is_empty_08001030(value1,value2);\n  if (result == 0) {\n    value2 = decode_uint_08000c10(DAT_200009f4);\n    result = is_null_terminated_08000ff4(value1,value2);\n    if (result == 0) {\n      shiftedValue = calculate_shifted_value_08001044(value1);\n    }\n    else {\n      shiftedValue = DAT_200009f4;\n    }\n  }\n  else {\n    shiftedValue = DAT_20000010;\n  }\n  DAT_200009fc = DAT_200009f8;\n  result = check_if_concatenation_is_empty_08001030(DAT_200009f8,0);\n  update_parameter_08001a80(0x40010800,2,result != 0);\n  result = check_if_concatenation_is_empty_08001030(DAT_200009f8,0);\n  update_parameter_08001a80(0x40010800,4,result == 0);\n  result = check_if_concatenation_is_empty_08001030(DAT_200009f8,0);\n  update_parameter_08001a80(0x40010800,8,result != 0);\n  result = check_if_concatenation_is_empty_08001030(DAT_200009f8,0);\n  update_parameter_08001a80(0x40010800,0x10,result == 0);\n  *(uint *)(DAT_20000b1c + 0x34) = (uint)shiftedValue;\n  *(uint *)(DAT_20000b1c + 0x40) = (uint)shiftedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08004f78": "decode_and_update_values_08004f78",
                "uVar1": "value1",
                "iVar2": "result",
                "uVar3": "value2",
                "uVar4": "flippedValue",
                "uVar5": "reversedBits",
                "local_11": "shiftedValue"
            },
            "calling": [
                "FUN_080017b4",
                "FUN_080036f8"
            ],
            "called": [
                "FUN_08004bd8",
                "FUN_08005e40",
                "FUN_08000418",
                "FUN_08000ff4",
                "FUN_08001030",
                "FUN_08004ae0",
                "FUN_08000c10",
                "FUN_08000cb8",
                "FUN_08005dfc",
                "FUN_08001044",
                "FUN_08001a80",
                "FUN_08000c08",
                "FUN_08000aa8",
                "FUN_08004f60",
                "FUN_08000aa4",
                "FUN_08004f3c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005224": {
            "entrypoint": "0x08005224",
            "current_name": "initialize_system_08005224",
            "code": "\nvoid initialize_system_08005224(void)\n\n{\n  init_system_1();\n  init_system_2();\n  update_memory_values();\n  init_data_1();\n  init_data_2();\n  init_memory();\n  init_memory_config();\n  DAT_20000a54 = 0x8004ea5;\n  DAT_20000a4c = 0x8004ee9;\n  DAT_20000a50 = 0x8004f2d;\n  update_set_values(&DAT_20000b1c,0);\n  update_set_values(&DAT_20000b1c,0xc);\n  init_data_3(&DAT_20000a5c);\n  set_flags(&DAT_20000b60);\n  check_interrupt(0);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005224": "initialize_system_08005224",
                "initialize_system_080014f0": "init_system_1",
                "initialize_system_080052a0": "init_system_2",
                "update_memory_values_080055f4": "update_memory_values",
                "initialize_data_08005348": "init_data_1",
                "initialize_data_08005598": "init_data_2",
                "initialize_memory_08005500": "init_memory",
                "initialize_memory_and_configuration_080053b0": "init_memory_config",
                "update_and_set_values_080036a8": "update_set_values",
                "initialize_data_0800491c": "init_data_3",
                "set_flags_0800360c": "set_flags",
                "check_software_interrupt_08004e74": "check_interrupt"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_080053b0",
                "FUN_0800360c",
                "FUN_080014f0",
                "FUN_08005500",
                "FUN_08005598",
                "FUN_080052a0",
                "FUN_0800491c",
                "FUN_080036a8",
                "FUN_08005348",
                "FUN_080055f4",
                "FUN_08004e74"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080052a0": {
            "entrypoint": "0x080052a0",
            "current_name": "initialize_system_080052a0",
            "code": "\nvoid initializeSystem_080052a0(void)\n\n{\n  int result;\n  undefined8 uVar2;\n  undefined4 errorCode;\n  undefined4 param1;\n  undefined4 param2;\n  undefined4 param3;\n  undefined4 param4;\n  undefined4 flag;\n  undefined4 constant1;\n  undefined4 constant2;\n  undefined4 constant3;\n  undefined4 constant4;\n  undefined4 constant5;\n  undefined4 constant6;\n  \n  flag = 1;\n  constant1 = 0x10000;\n  constant2 = 0;\n  constant3 = 1;\n  constant4 = 2;\n  constant5 = 0x10000;\n  constant6 = 0x1c0000;\n  result = perform_operation_08002d98(&flag);\n  if (result != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x151);\n  }\n  errorCode = 0xf;\n  param1 = 2;\n  param2 = 0x80;\n  param3 = 0;\n  param4 = 0;\n  result = process_data_08003260(&errorCode,2);\n  if (result != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x15e);\n  }\n  uVar2 = get_data_08003504();\n  update_value_08001762((uint)uVar2 / 1000,(int)((ulonglong)uVar2 >> 0x20),(uint)uVar2 * 0x10624dd3);\n  set_e000e010_bit_0800177c(4);\n  write_value_to_memory_0800172a(0xffffffff,0,0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080052a0": "initialize_system_080052a0",
                "local_44": "errorCode",
                "local_40": "param1",
                "local_3c": "param2",
                "local_38": "param3",
                "local_34": "param4",
                "local_30": "flag",
                "local_2c": "constant1",
                "local_28": "constant2",
                "local_20": "constant3",
                "local_14": "constant4",
                "local_10": "constant5",
                "local_c": "constant6",
                "iVar1": "result"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003504",
                "FUN_0800172a",
                "FUN_08005674",
                "FUN_08002d98",
                "FUN_08003260",
                "FUN_08001762",
                "FUN_0800177c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005348": {
            "entrypoint": "0x08005348",
            "current_name": "initialize_data_08005348",
            "code": "\nvoid initializeData_08005348(void)\n\n{\n  int result;\n  \n  DAT_20000a88 = 0x40005400;\n  DAT_20000a8c = 400000;\n  DAT_20000a90 = 0;\n  DAT_20000a94 = 0;\n  DAT_20000a98 = 0x4000;\n  DAT_20000a9c = 0;\n  DAT_20000aa0 = 0;\n  DAT_20000aa4 = 0;\n  DAT_20000aa8 = 0;\n  result = calculateParamValues(&DAT_20000a88);\n  if (result != 0) {\n    runInfiniteLoop(\"../src/main.c\",0x17a);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005348": "initialize_data_08005348",
                "iVar1": "result",
                "calculate_param_values_08001ab0": "calculateParamValues",
                "run_infinite_loop_08005674": "runInfiniteLoop"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001ab0",
                "FUN_08005674"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080053b0": {
            "entrypoint": "0x080053b0",
            "current_name": "initialize_memory_and_configuration_080053b0",
            "code": "\nvoid initializeMemoryAndConfiguration_080053b0(void)\n\n{\n  int iVar1;\n  undefined4 parameter1;\n  undefined4 parameter2;\n  undefined4 parameter3;\n  undefined4 parameter4;\n  undefined4 parameter5;\n  undefined4 parameter6;\n  undefined4 parameter7;\n  undefined4 parameter8;\n  undefined4 parameter9;\n  undefined4 parameter10;\n  undefined4 parameter11;\n  undefined4 parameter12;\n  undefined4 parameter13;\n  undefined4 parameter14;\n  undefined4 parameter15;\n  undefined4 parameter16;\n  undefined4 parameter_array [4];\n  \n  DAT_20000b1c = 0x40012c00;\n  DAT_20000b20 = 0x708;\n  DAT_20000b24 = 0;\n  DAT_20000b28 = 100;\n  DAT_20000b2c = 0;\n  DAT_20000b30 = 0;\n  DAT_20000b34 = 0;\n  iVar1 = check_and_update_memory_080035a4(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",399);\n  }\n  parameter_array[0] = 0x1000;\n  iVar1 = update_parameter_value_08003a94(&DAT_20000b1c,parameter_array);\n  if (iVar1 != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x194);\n  }\n  iVar1 = check_and_update_buffer_08003640(&DAT_20000b1c);\n  if (iVar1 != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x198);\n  }\n  parameter15 = 0;\n  parameter16 = 0;\n  iVar1 = update_parameter_080042de(&DAT_20000b1c,&parameter15);\n  if (iVar1 != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x19f);\n  }\n  parameter8 = 0x60;\n  parameter9 = 0;\n  parameter10 = 0;\n  parameter11 = 0;\n  parameter12 = 0;\n  parameter13 = 0;\n  parameter14 = 0;\n  iVar1 = update_registers_and_flags_08003908(&DAT_20000b1c,&parameter8,0);\n  if (iVar1 != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x1ab);\n  }\n  iVar1 = update_registers_and_flags_08003908(&DAT_20000b1c,&parameter8,0xc);\n  if (iVar1 != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x1b0);\n  }\n  parameter1 = 0;\n  parameter2 = 0;\n  parameter3 = 0;\n  parameter4 = 0;\n  parameter5 = 0;\n  parameter6 = 0x2000;\n  parameter7 = 0;\n  iVar1 = update_configuration_0800422e(&DAT_20000b1c,&parameter1);\n  if (iVar1 != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x1bc);\n  }\n  update_memory_values_08005680(&DAT_20000b1c);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080053b0": "initialize_memory_and_configuration_080053b0",
                "local_58": "parameter1",
                "local_54": "parameter2",
                "local_50": "parameter3",
                "local_4c": "parameter4",
                "local_48": "parameter5",
                "local_44": "parameter6",
                "local_40": "parameter7",
                "local_3c": "parameter8",
                "local_38": "parameter9",
                "local_34": "parameter10",
                "local_30": "parameter11",
                "local_2c": "parameter12",
                "local_28": "parameter13",
                "local_24": "parameter14",
                "local_20": "parameter15",
                "local_1c": "parameter16",
                "local_18": "parameter_array"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003a94",
                "FUN_08003908",
                "FUN_0800422e",
                "FUN_08003640",
                "FUN_080035a4",
                "FUN_08005674",
                "FUN_08005680",
                "FUN_080042de"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005500": {
            "entrypoint": "0x08005500",
            "current_name": "initialize_memory_08005500",
            "code": "\nvoid initializeMemory_08005500(void)\n\n{\n  int returnValue;\n  undefined4 pageCount;\n  undefined4 pageNumber;\n  undefined4 parameterValues [4];\n  \n  DAT_20000b60 = 0x40000000;\n  DAT_20000b64 = 36000;\n  DAT_20000b68 = 0;\n  DAT_20000b6c = 0x14;\n  DAT_20000b70 = 0;\n  DAT_20000b78 = 0;\n  returnValue = check_and_update_memory_080035a4(&DAT_20000b60);\n  if (returnValue != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x1d0);\n  }\n  parameterValues[0] = 0x1000;\n  returnValue = update_parameter_value_08003a94(&DAT_20000b60,parameterValues);\n  if (returnValue != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x1d5);\n  }\n  pageCount = 0x20;\n  pageNumber = 0;\n  returnValue = update_parameter_080042de(&DAT_20000b60,&pageCount);\n  if (returnValue != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x1dc);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005500": "initialize_memory_08005500",
                "local_20": "pageCount",
                "local_1c": "pageNumber",
                "local_18": "parameterValues",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08003a94",
                "FUN_080035a4",
                "FUN_08005674",
                "FUN_080042de"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005598": {
            "entrypoint": "0x08005598",
            "current_name": "initialize_data_08005598",
            "code": "\nvoid initializeData_08005598(void)\n\n{\n  int returnValue;\n  \n  DAT_20000adc = 0x40013800;\n  DAT_20000ae0 = 0x1c200;\n  DAT_20000ae4 = 0;\n  DAT_20000ae8 = 0;\n  DAT_20000aec = 0;\n  DAT_20000af0 = 0xc;\n  DAT_20000af4 = 0;\n  DAT_20000af8 = 0;\n  returnValue = initialize_param_0800438a(&DAT_20000adc);\n  if (returnValue != 0) {\n    run_infinite_loop_08005674(\"../src/main.c\",0x1ed);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005598": "initialize_data_08005598",
                "iVar1": "returnValue"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_0800438a",
                "FUN_08005674"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080055f4": {
            "entrypoint": "0x080055f4",
            "current_name": "update_memory_values_080055f4",
            "code": "\n\n\nvoid updateMemoryValues_080055f4(void)\n\n{\n  undefined4 parameter1;\n  undefined4 parameter2;\n  undefined4 parameter3;\n  \n  _DAT_40021018 = _DAT_40021018 | 0x2c;\n  update_parameter_08001a80(0x40010800,0x1e,0,_DAT_40021018 & 8);\n  parameter1 = 0x1e;\n  parameter2 = 1;\n  parameter3 = 2;\n  update_memory_values_080017c4(0x40010800,&parameter1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080055f4": "update_memory_values_080055f4",
                "local_18": "parameter1",
                "local_14": "parameter2",
                "local_c": "parameter3"
            },
            "calling": [
                "FUN_08005224"
            ],
            "called": [
                "FUN_08001a80",
                "FUN_080017c4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005674": {
            "entrypoint": "0x08005674",
            "current_name": "run_infinite_loop_08005674",
            "code": "\nvoid runInfiniteLoop_08005674(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_08005674": "run_infinite_loop_08005674"
            },
            "calling": [
                "FUN_080053b0",
                "FUN_08005500",
                "FUN_080052a0",
                "FUN_08005598",
                "FUN_08005348"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005680": {
            "entrypoint": "0x08005680",
            "current_name": "update_memory_values_08005680",
            "code": "\nvoid updateMemoryValues_08005680(int *memoryValue)\n\n{\n  undefined4 newValue1;\n  undefined4 newValue2;\n  undefined4 newValue3;\n  \n  if (*memoryValue == 0x40012c00) {\n    newValue1 = 0x900;\n    newValue2 = 2;\n    newValue3 = 2;\n    update_memory_values_080017c4(0x40010800,&newValue1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005680": "update_memory_values_08005680",
                "param_1": "memoryValue",
                "local_18": "newValue1",
                "local_14": "newValue2",
                "local_c": "newValue3"
            },
            "calling": [
                "FUN_080053b0"
            ],
            "called": [
                "FUN_080017c4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005704": {
            "entrypoint": "0x08005704",
            "current_name": "initialize_and_increment_08005704",
            "code": "\nvoid initialize_and_increment_08005704(void)\n\n{\n  increment_data();\n  initialize_values();\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005704": "initialize_and_increment_08005704",
                "increment_dat20000a48_0800157c": "increment_data",
                "initialize_values_080017b4": "initialize_values"
            },
            "calling": [],
            "called": [
                "FUN_080017b4",
                "FUN_0800157c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005714": {
            "entrypoint": "0x08005714",
            "current_name": "initialize_data_08005714",
            "code": "\nvoid initializeData_08005714(void)\n\n{\n  processData(&DAT_20000b60);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005714": "initialize_data_08005714",
                "handle_param_080036f8": "processData"
            },
            "calling": [],
            "called": [
                "FUN_080036f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005728": {
            "entrypoint": "0x08005728",
            "current_name": "allocate_memory_08005728",
            "code": "\nundefined * allocateMemory_08005728(int size)\n\n{\n  undefined4 *ptr;\n  undefined *returnValue;\n  undefined tempStack [4];\n  int remainingSize;\n  undefined *currentMemory;\n  \n  if (DAT_20000a10 == (undefined *)0x0) {\n    DAT_20000a10 = &DAT_20000c18;\n  }\n  currentMemory = DAT_20000a10;\n  if (tempStack < DAT_20000a10 + size) {\n    remainingSize = size;\n    ptr = (undefined4 *)get_data_from_memory_08005d14();\n    *ptr = 0xc;\n    returnValue = (undefined *)0xffffffff;\n  }\n  else {\n    returnValue = DAT_20000a10;\n    DAT_20000a10 = DAT_20000a10 + size;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_08005728": "allocate_memory_08005728",
                "param_1": "size",
                "puVar1": "ptr",
                "puVar2": "returnValue",
                "auStack_18": "tempStack",
                "local_14": "remainingSize",
                "local_c": "currentMemory"
            },
            "calling": [
                "FUN_08009744"
            ],
            "called": [
                "FUN_08005d14"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005780": {
            "entrypoint": "0x08005780",
            "current_name": "initialize_hardware_08005780",
            "code": "\n\n\nvoid initializeHardware_08005780(void)\n\n{\n  _DAT_40021000 = _DAT_40021000 & 0xfef2ffff | 1;\n  _DAT_40021004 = _DAT_40021004 & 0xf8800000;\n  _DAT_40021008 = 0x9f0000;\n  _DAT_e000ed08 = 0x8000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005780": "initialize_hardware_08005780"
            },
            "calling": [
                "entry"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x080057e8",
            "current_name": "entry",
            "code": "\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  code *UNRECOVERED_JUMPTABLE;\n  \n  for (iVar1 = 0; (undefined4 *)(iVar1 + 0x20000000) < &DAT_200009c8; iVar1 = iVar1 + 4) {\n    *(undefined4 *)(iVar1 + 0x20000000) = *(undefined4 *)(iVar1 + 0x800a1a4);\n  }\n  for (puVar2 = &DAT_200009c8; puVar2 < &DAT_20000c14; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  initialize_hardware_08005780();\n  execute_functions_08005d20();\n  UNRECOVERED_JUMPTABLE = (code *)0x800581a;\n  initialize_system_08005224();\n                    /* WARNING: Could not recover jumptable at 0x0800581a. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*UNRECOVERED_JUMPTABLE)();\n  return;\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_08005d20",
                "FUN_08005780",
                "FUN_08005224"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_08005838": {
            "entrypoint": "0x08005834",
            "current_name": "calculate_result_thunk_08005838",
            "code": "\nuint calculate_result_thunk_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int temp1;\n  undefined4 temp2;\n  uint temp3;\n  uint temp4;\n  uint temp5;\n  undefined8 temp6;\n  \n  temp4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (temp4 | (-input3 | input3) >> 0x1f)) ||\n     (temp5 = input2 & 0x7fffffff, 0x7ff00000 < (temp5 | (-input1 | input1) >> 0x1f))) {\n    temp4 = calculate_result_thunk_08005838_0800015c(input3,input4,input1,input2);\n    return temp4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    temp4 = calculate_080059f0();\n    return temp4;\n  }\n  temp3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((temp5 | input1) == 0) {\n    if (temp3 == 2) {\n      return 0x54442d18;\n    }\n    if (temp3 != 3) {\n      return input1;\n    }\n  }\n  else if ((temp4 | input3) != 0) {\n    if (temp4 == 0x7ff00000) {\n      if (temp5 == 0x7ff00000) {\n        if (temp3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (temp3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (temp3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (temp3 == 2) {\n        return 0x54442d18;\n      }\n      if (temp3 != 3) {\n        if (temp3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (temp5 != 0x7ff00000) {\n      temp1 = (int)(temp5 - temp4) >> 0x14;\n      if (temp1 < 0x3d) {\n        if (((int)input4 < 0) && (temp1 + 0x3c < 0 != SCARRY4(temp1,0x3c))) {\n          temp6 = 0;\n        }\n        else {\n          convert_value_to_double_0800071c(input1,input2,input3,input4,input4);\n          FUNC_08005d0c();\n          temp6 = calculate_080059f0();\n        }\n      }\n      else {\n        temp6 = 0x3ff921fb54442d18;\n      }\n      temp2 = (undefined4)((ulonglong)temp6 >> 0x20);\n      temp4 = (uint)temp6;\n      if (temp3 == 1) {\n        return temp4;\n      }\n      if (temp3 == 2) {\n        temp6 = unsigned_long_long_binary_operation_08000158(temp4,temp2,0x33145c07,0x3ca1a626);\n        temp4 = unsigned_long_long_binary_operation_08000158(0x54442d18,0x400921fb,(int)temp6,(int)((ulonglong)temp6 >> 0x20));\n        return temp4;\n      }\n      if (temp3 != 0) {\n        temp6 = unsigned_long_long_binary_operation_08000158(temp4,temp2,0x33145c07,0x3ca1a626);\n        temp4 = unsigned_long_long_binary_operation_08000158((int)temp6,(int)((ulonglong)temp6 >> 0x20),0x54442d18,0x400921fb);\n        return temp4;\n      }\n      return temp4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "thunk_FUN_08005838": "calculate_result_thunk_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "temp1",
                "uVar2": "temp2",
                "uVar3": "temp3",
                "uVar4": "temp4",
                "uVar5": "temp5",
                "uVar6": "temp6"
            },
            "calling": [
                "FUN_08004bd8",
                "FUN_08004d78"
            ],
            "called": [
                "FUN_08005838"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005838": {
            "entrypoint": "0x08005838",
            "current_name": "perform_calculation_08005838",
            "code": "\nuint performCalculation_08005838(uint input1,uint input2,uint input3,uint input4)\n\n{\n  int tempVar1;\n  undefined4 tempVar2;\n  uint tempVar3;\n  uint tempVar4;\n  uint tempVar5;\n  undefined8 result;\n  \n  tempVar4 = input4 & 0x7fffffff;\n  if ((0x7ff00000 < (tempVar4 | (-input3 | input3) >> 0x1f)) ||\n     (tempVar5 = input2 & 0x7fffffff, 0x7ff00000 < (tempVar5 | (-input1 | input1) >> 0x1f))) {\n    tempVar4 = calculateResult(input3,input4,input1,input2);\n    return tempVar4;\n  }\n  if ((input4 + 0xc0100000 | input3) == 0) {\n    tempVar4 = calculateValue();\n    return tempVar4;\n  }\n  tempVar3 = (int)input4 >> 0x1e & 2U | input2 >> 0x1f;\n  if ((tempVar5 | input1) == 0) {\n    if (tempVar3 == 2) {\n      return 0x54442d18;\n    }\n    if (tempVar3 != 3) {\n      return input1;\n    }\n  }\n  else if ((tempVar4 | input3) != 0) {\n    if (tempVar4 == 0x7ff00000) {\n      if (tempVar5 == 0x7ff00000) {\n        if (tempVar3 == 2) {\n          return 0x7f3321d2;\n        }\n        if (tempVar3 == 3) {\n          return 0x7f3321d2;\n        }\n        if (tempVar3 == 1) {\n          return 0x54442d18;\n        }\n        return 0x54442d18;\n      }\n      if (tempVar3 == 2) {\n        return 0x54442d18;\n      }\n      if (tempVar3 != 3) {\n        if (tempVar3 != 1) {\n          return 0;\n        }\n        return 0;\n      }\n    }\n    else if (tempVar5 != 0x7ff00000) {\n      tempVar1 = (int)(tempVar5 - tempVar4) >> 0x14;\n      if (tempVar1 < 0x3d) {\n        if (((int)input4 < 0) && (tempVar1 + 0x3c < 0 != SCARRY4(tempVar1,0x3c))) {\n          result = 0;\n        }\n        else {\n          convertToDouble(input1,input2,input3,input4,input4);\n          FUNC_08005d0c();\n          result = calculateValue();\n        }\n      }\n      else {\n        result = 0x3ff921fb54442d18;\n      }\n      tempVar2 = (undefined4)((ulonglong)result >> 0x20);\n      tempVar4 = (uint)result;\n      if (tempVar3 == 1) {\n        return tempVar4;\n      }\n      if (tempVar3 == 2) {\n        result = unsignedBinaryOperation(tempVar4,tempVar2,0x33145c07,0x3ca1a626);\n        tempVar4 = unsignedBinaryOperation(0x54442d18,0x400921fb,(int)result,(int)((ulonglong)result >> 0x20));\n        return tempVar4;\n      }\n      if (tempVar3 != 0) {\n        result = unsignedBinaryOperation(tempVar4,tempVar2,0x33145c07,0x3ca1a626);\n        tempVar4 = unsignedBinaryOperation((int)result,(int)((ulonglong)result >> 0x20),0x54442d18,0x400921fb);\n        return tempVar4;\n      }\n      return tempVar4;\n    }\n  }\n  return 0x54442d18;\n}\n\n",
            "renaming": {
                "FUN_08005838": "perform_calculation_08005838",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "tempVar1",
                "uVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4",
                "uVar5": "tempVar5",
                "uVar6": "result",
                "calculate_result_0800015c": "calculateResult",
                "calculate_080059f0": "calculateValue",
                "convert_value_to_double_0800071c": "convertToDouble",
                "unsigned_long_long_binary_operation_08000158": "unsignedBinaryOperation"
            },
            "calling": [
                "thunk_FUN_08005838"
            ],
            "called": [
                "FUN_08000158",
                "FUN_080059f0",
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080059f0": {
            "entrypoint": "0x080059f0",
            "current_name": "calculate_080059f0",
            "code": "\nundefined8 calculate_080059f0(int input1,uint input2,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 var1;\n  undefined4 var2;\n  undefined4 var3;\n  undefined4 var4;\n  undefined4 var5;\n  undefined4 var6;\n  uint var7;\n  int var8;\n  undefined8 result1;\n  undefined8 result2;\n  \n  result2 = CONCAT44(input2,input1);\n  var7 = input2 & 0x7fffffff;\n  if (var7 < 0x44100000) {\n    if (var7 < 0x3fdc0000) {\n      if (var7 < 0x3e200000) {\n        result1 = calculate_080059f0_result_0800015c(input1,input2,0x8800759c,0x7e37e43c,param4);\n        var8 = check_evaluation_result_080009e8((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x3ff00000);\n        if (var8 != 0) {\n          return CONCAT44(input2,input1);\n        }\n      }\n      var8 = -1;\n    }\n    else {\n      result2 = FUNC_08005d0c();\n      var4 = (undefined4)((ulonglong)result2 >> 0x20);\n      var1 = (undefined4)result2;\n      if (var7 < 0x3ff30000) {\n        if (var7 < 0x3fe60000) {\n          result2 = calculate_080059f0_result_0800015c(var1,var4,var1,var4);\n          result2 = unsigned_long_long_binary_operation_08000158((int)result2,(int)((ulonglong)result2 >> 0x20),0,0x3ff00000);\n          result1 = calculate_080059f0_result_0800015c(var1,var4,0,0x40000000);\n          result2 = convert_value_to_double_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                                (int)((ulonglong)result1 >> 0x20));\n          var8 = 0;\n        }\n        else {\n          result2 = unsigned_long_long_binary_operation_08000158(var1,var4,0,0x3ff00000);\n          result1 = calculate_080059f0_result_0800015c(var1,var4,0,0x3ff00000);\n          result2 = convert_value_to_double_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                                (int)((ulonglong)result1 >> 0x20));\n          var8 = 1;\n        }\n      }\n      else if (var7 < 0x40038000) {\n        result2 = unsigned_long_long_binary_operation_08000158(var1,var4,0,0x3ff80000);\n        result1 = calculate_080059f0_product_and_addition_080004c8(var1,var4,0,0x3ff80000);\n        result1 = calculate_080059f0_result_0800015c((int)result1,(int)((ulonglong)result1 >> 0x20),0,0x3ff00000);\n        result2 = convert_value_to_double_0800071c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                              (int)((ulonglong)result1 >> 0x20));\n        var8 = 2;\n      }\n      else {\n        result2 = convert_value_to_double_0800071c(0,0xbff00000,var1,var4);\n        var8 = 3;\n      }\n    }\n    var6 = (undefined4)((ulonglong)result2 >> 0x20);\n    var5 = (undefined4)result2;\n    result2 = calculate_080059f0_product_and_addition_080004c8(var5,var6,var5,var6);\n    var2 = (undefined4)((ulonglong)result2 >> 0x20);\n    var1 = (undefined4)result2;\n    result2 = calculate_080059f0_product_and_addition_080004c8(var1,var2,var1,var2);\n    var3 = (undefined4)((ulonglong)result2 >> 0x20);\n    var4 = (undefined4)result2;\n    result2 = calculate_080059f0_product_and_addition_080004c8(var4,var3,0xe322da11,0x3f90ad3a);\n    result2 = calculate_080059f0_result_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0x24760deb,0x3fa97b4b);\n    result2 = calculate_080059f0_product_and_addition_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),var4,var3);\n    result2 = calculate_080059f0_result_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0xa0d03d51,0x3fb10d66);\n    result2 = calculate_080059f0_product_and_addition_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),var4,var3);\n    result2 = calculate_080059f0_result_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0xc54c206e,0x3fb745cd);\n    result2 = calculate_080059f0_product_and_addition_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),var4,var3);\n    result2 = calculate_080059f0_result_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0x920083ff,0x3fc24924);\n    result2 = calculate_080059f0_product_and_addition_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),var4,var3);\n    result2 = calculate_080059f0_result_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),0x5555550d,0x3fd55555);\n    result2 = calculate_080059f0_product_and_addition_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),var1,var2);\n    result1 = calculate_080059f0_product_and_addition_080004c8(var4,var3,0x2c6a6c2f,0xbfa2b444);\n    result1 = unsigned_long_long_binary_operation_08000158((int)result1,(int)((ulonglong)result1 >> 0x20),0x52defd9a,0x3fadde2d);\n    result1 = calculate_080059f0_product_and_addition_080004c8((int)result1,(int)((ulonglong)result1 >> 0x20),var4,var3);\n    result1 = unsigned_long_long_binary_operation_08000158((int)result1,(int)((ulonglong)result1 >> 0x20),0xaf749a6d,0x3fb3b0f2);\n    result1 = calculate_080059f0_product_and_addition_080004c8((int)result1,(int)((ulonglong)result1 >> 0x20),var4,var3);\n    result1 = unsigned_long_long_binary_operation_08000158((int)result1,(int)((ulonglong)result1 >> 0x20),0xfe231671,0x3fbc71c6);\n    result1 = calculate_080059f0_product_and_addition_080004c8((int)result1,(int)((ulonglong)result1 >> 0x20),var4,var3);\n    result1 = unsigned_long_long_binary_operation_08000158((int)result1,(int)((ulonglong)result1 >> 0x20),0x9998ebc4,0x3fc99999);\n    result1 = calculate_080059f0_product_and_addition_080004c8((int)result1,(int)((ulonglong)result1 >> 0x20),var4,var3);\n    result2 = calculate_080059f0_result_0800015c((int)result2,(int)((ulonglong)result2 >> 0x20),(int)result1,\n                          (int)((ulonglong)result1 >> 0x20));\n    result2 = calculate_080059f0_product_and_addition_080004c8((int)result2,(int)((ulonglong)result2 >> 0x20),var5,var6);\n    var1 = (undefined4)((ulonglong)result2 >> 0x20);\n    if (var8 == -1) {\n      result2 = unsigned_long_long_binary_operation_08000158(var5,var6,(int)result2,var1);\n      return result2;\n    }\n    var8 = var8 * 8;\n    result2 = unsigned_long_long_binary_operation_08000158((int)result2,var1,*(undefined4 *)(&UNK_08009ee8 + var8),\n                          *(undefined4 *)(&UNK_08009eec + var8));\n    result2 = unsigned_long_long_binary_operation_08000158((int)result2,(int)((ulonglong)result2 >> 0x20),var5,var6);\n    result2 = unsigned_long_long_binary_operation_08000158(*(undefined4 *)(&UNK_08009ec8 + var8),\n                          *(undefined4 *)(&UNK_08009ecc + var8),(int)result2,\n                          (int)((ulonglong)result2 >> 0x20));\n    if ((int)input2 < 0) {\n      return CONCAT44((int)((ulonglong)result2 >> 0x20) + -0x80000000,(int)result2);\n    }\n  }\n  else {\n    if ((var7 < 0x7ff00001) && ((var7 != 0x7ff00000 || (input1 == 0)))) {\n      var1 = 0xbff921fb;\n      if (0 < (int)input2) {\n        var1 = 0x3ff921fb;\n      }\n      return CONCAT44(var1,0x54442d18);\n    }\n    result2 = calculate_080059f0_result_0800015c(input1,input2,input1,input2,param4);\n  }\n  return result2;\n}\n\n",
            "renaming": {
                "FUN_080059f0": "calculate_080059f0",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "var1",
                "uVar2": "var2",
                "uVar3": "var3",
                "uVar4": "var4",
                "uVar5": "var5",
                "uVar6": "var6",
                "uVar7": "var7",
                "iVar8": "var8",
                "uVar9": "result1",
                "uVar10": "result2"
            },
            "calling": [
                "FUN_08005838"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08000158",
                "FUN_080009e8",
                "FUN_08005d0c",
                "FUN_0800015c",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d0c": {
            "entrypoint": "0x08005d0c",
            "current_name": "FUNC_08005d0c",
            "code": "\nvoid FUNC_08005d0c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d0c": "FUNC_08005d0c"
            },
            "calling": [
                "FUN_080059f0",
                "FUN_08005838"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08005d14": {
            "entrypoint": "0x08005d14",
            "current_name": "get_data_from_memory_08005d14",
            "code": "\nundefined4 get_data_from_memory_08005d14(void)\n\n{\n  return DAT_2000001c;\n}\n\n",
            "renaming": {
                "FUN_08005d14": "get_data_from_memory_08005d14"
            },
            "calling": [
                "FUN_08005728"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d20": {
            "entrypoint": "0x08005d20",
            "current_name": "execute_functions_08005d20",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08005d2c) */\n/* WARNING: Removing unreachable block (ram,0x08005d2e) */\n\nvoid executeFunctions_08005d20(void)\n\n{\n  int counter;\n  code **functionPointers;\n  \n  FUNC_08009e68();\n  counter = 0;\n  functionPointers = (code **)&DAT_0800a198;\n  do {\n    counter = counter + 1;\n    (**functionPointers)();\n    functionPointers = functionPointers + 1;\n  } while (counter != 2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d20": "execute_functions_08005d20",
                "iVar1": "counter",
                "ppcVar2": "functionPointers"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_08000134",
                "FUN_08009e68",
                "FUN_080078a0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005d68": {
            "entrypoint": "0x08005d68",
            "current_name": "fill_memory_with_byte_08005d68",
            "code": "\nvoid fillMemoryWithByte_08005d68(undefined4 *destination,undefined byte,uint length)\n\n{\n  undefined4 *destPtr;\n  undefined4 *nextDestPtr;\n  uint remainingLength;\n  undefined4 bytePattern;\n  bool isLengthZero;\n  \n  if (((uint)destination & 3) != 0) {\n    remainingLength = length - 1;\n    destPtr = destination;\n    if (length == 0) {\n      return;\n    }\n    while( true ) {\n      destination = (undefined4 *)((int)destPtr + 1);\n      *(undefined *)destPtr = byte;\n      length = remainingLength;\n      if (((uint)destination & 3) == 0) break;\n      isLengthZero = remainingLength == 0;\n      remainingLength = remainingLength - 1;\n      destPtr = destination;\n      if (isLengthZero) {\n        return;\n      }\n    }\n  }\n  if (3 < length) {\n    bytePattern = CONCAT22(CONCAT11(byte,byte),CONCAT11(byte,byte));\n    remainingLength = length;\n    destPtr = destination;\n    if (0xf < length) {\n      remainingLength = length - 0x10;\n      destPtr = destination + 4;\n      do {\n        destPtr[-4] = bytePattern;\n        destPtr[-3] = bytePattern;\n        destPtr[-2] = bytePattern;\n        destPtr[-1] = bytePattern;\n        destPtr = destPtr + 4;\n      } while (destPtr != (undefined4 *)((int)destination + (remainingLength & 0xfffffff0) + 0x20));\n      length = length & 0xf;\n      destination = destination + ((remainingLength >> 4) + 1) * 4;\n      remainingLength = length;\n      destPtr = destination;\n      if (length < 4) goto LAB_08005de4;\n    }\n    do {\n      length = length - 4;\n      *destination = bytePattern;\n      destination = destination + 1;\n    } while (3 < length);\n    destination = (undefined4 *)((int)destPtr + (remainingLength - 4 & 0xfffffffc) + 4);\n    length = remainingLength & 3;\n  }\nLAB_08005de4:\n  if (length != 0) {\n    destPtr = destination;\n    do {\n      nextDestPtr = (undefined4 *)((int)destPtr + 1);\n      *(undefined *)destPtr = byte;\n      destPtr = nextDestPtr;\n    } while ((undefined4 *)(length + (int)destination) != nextDestPtr);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005d68": "fill_memory_with_byte_08005d68",
                "param_1": "destination",
                "param_2": "byte",
                "param_3": "length",
                "puVar1": "destPtr",
                "puVar2": "nextDestPtr",
                "uVar3": "remainingLength",
                "uVar4": "bytePattern",
                "bVar5": "isLengthZero"
            },
            "calling": [
                "FUN_08004f60",
                "FUN_08009980"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005dfc": {
            "entrypoint": "0x08005dfc",
            "current_name": "initialize_pointer_08005dfc",
            "code": "\nvoid initializePointer_08005dfc(undefined *buffer,undefined4 length,undefined4 value1,undefined4 value2)\n\n{\n  undefined *pointersList [2];\n  undefined4 maxValue1;\n  undefined4 fixedValue;\n  undefined *currentPointer;\n  undefined4 maxValue2;\n  undefined4 value3;\n  undefined4 value4;\n  \n  maxValue2 = 0x7fffffff;\n  maxValue1 = 0x7fffffff;\n  fixedValue = 0xffff0208;\n  pointersList[0] = buffer;\n  currentPointer = buffer;\n  value3 = value1;\n  value4 = value2;\n  FUNC_08005e9c(DAT_2000001c,pointersList,length,&value3);\n  *pointersList[0] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08005dfc": "initialize_pointer_08005dfc",
                "param_1": "buffer",
                "param_2": "length",
                "param_3": "value1",
                "param_4": "value2",
                "local_80": "pointersList",
                "local_78": "maxValue1",
                "uStack_74": "fixedValue",
                "local_70": "currentPointer",
                "local_6c": "maxValue2",
                "uStack_8": "value3",
                "uStack_4": "value4"
            },
            "calling": [
                "FUN_08004f78"
            ],
            "called": [
                "FUN_08005e9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e40": {
            "entrypoint": "0x08005e40",
            "current_name": "count_trailing_zeroes_08005e40",
            "code": "\nint countTrailingZeroes_08005e40(uint input)\n\n{\n  int leadingOnes;\n  uint *ptr;\n  uint value;\n  \n  ptr = (uint *)(input & 0xfffffffc);\n  leadingOnes = -(input & 3);\n  value = *ptr;\n  if ((input & 3) != 0) {\n    value = value | 0xffffffffU >> ((leadingOnes + 4U & 0x1f) << 3);\n  }\n  while( true ) {\n    ptr = ptr + 1;\n    value = value + 0xfefefeff & ~value & 0x80808080;\n    if (value != 0) break;\n    value = *ptr;\n    leadingOnes = leadingOnes + 4;\n  }\n  return leadingOnes + (0x1fU - LZCOUNT(value & -value) >> 3);\n}\n\n",
            "renaming": {
                "FUN_08005e40": "count_trailing_zeroes_08005e40",
                "param_1": "input",
                "iVar1": "leadingOnes",
                "puVar2": "ptr",
                "uVar3": "value"
            },
            "calling": [
                "FUN_08004f78",
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08005e9c": {
            "entrypoint": "0x08005e9c",
            "current_name": "FUNC_08005e9c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nbyte * FUNC_08005e9c(undefined4 *param_1,int *param_2,int *param_3,int **param_4)\n\n{\n  byte bVar1;\n  int **ppiVar2;\n  int iVar3;\n  uint uVar4;\n  byte *pbVar5;\n  char cVar6;\n  byte bVar7;\n  int iVar8;\n  int *piVar9;\n  undefined4 uVar10;\n  int **ppiVar11;\n  undefined uVar12;\n  ushort uVar13;\n  int **ppiVar14;\n  byte **ppbVar15;\n  int *piVar16;\n  int **ppiVar17;\n  char *pcVar18;\n  uint uVar19;\n  undefined *puVar20;\n  int *piVar21;\n  int *piVar22;\n  int *piVar23;\n  int *piVar24;\n  int *piVar25;\n  byte *pbVar26;\n  int *piVar27;\n  int *piVar28;\n  undefined4 *puVar29;\n  byte *pbVar30;\n  bool bVar31;\n  longlong lVar32;\n  undefined8 uVar33;\n  undefined8 uVar34;\n  undefined4 local_188;\n  int *piStack_184;\n  int **local_180;\n  undefined *puStack_17c;\n  int **local_178;\n  undefined4 *local_16c;\n  int *local_168;\n  byte *local_164;\n  int *local_160;\n  int *local_15c;\n  char *local_158;\n  int **local_154;\n  undefined8 local_150;\n  int *local_148;\n  int *local_144;\n  int *local_140;\n  int **local_13c;\n  int *local_138;\n  int *local_134;\n  int *local_130;\n  uint local_12c;\n  undefined4 local_128;\n  undefined4 local_124;\n  undefined4 local_120;\n  char *local_11c;\n  int *local_118;\n  int *local_114;\n  int *local_110;\n  int *local_10c;\n  byte *local_108;\n  int *local_104;\n  int *local_100;\n  int *local_fc;\n  byte local_f5;\n  undefined2 local_f4;\n  int *local_f0;\n  undefined auStack_ec [4];\n  char local_e8;\n  undefined local_e7;\n  char local_e6 [6];\n  int *local_e0;\n  byte abStack_dc [4];\n  int **local_d8;\n  int *local_d4;\n  int *local_d0;\n  int *local_cc [16];\n  undefined local_8c;\n  byte bStack_2a;\n  undefined local_29;\n  int iStack_28;\n  \n  local_16c = param_1;\n  local_160 = param_2;\n  local_154 = param_4;\n  ppiVar2 = (int **)calculate_adjusted_value_08008ad4();\n  local_114 = *ppiVar2;\n  local_118 = (int *)count_trailing_zeroes_08005e40(local_114);\n  if (((int)((uint)*(ushort *)(param_2 + 3) << 0x18) < 0) && (param_2[4] == 0)) {\n    iVar3 = allocate_and_set_memory_08008af8(local_16c,0x40);\n    *local_160 = iVar3;\n    local_160[4] = iVar3;\n    if (iVar3 == 0) {\n      *local_16c = 0xc;\n      return (byte *)0xffffffff;\n    }\n    local_160[5] = 0x40;\n  }\n  local_128 = 0;\n  local_138 = (int *)0x0;\n  local_12c = 0;\n  local_d4 = (int *)0x0;\n  local_d0 = (int *)0x0;\n  local_11c = (char *)0x0;\n  local_10c = (int *)0x0;\n  local_108 = (byte *)0x0;\n  local_104 = (int *)0x0;\n  local_110 = (int *)0x0;\n  local_164 = (byte *)0x0;\n  local_124 = 0;\n  local_120 = 0;\n  ppiVar2 = local_cc;\n  bVar1 = *(byte *)param_3;\n  local_d8 = ppiVar2;\njoined_r0x08005ef2:\n  if (bVar1 != 0) {\n    piVar28 = param_3;\n    if (bVar1 != 0x25) {\n      do {\n        piVar28 = (int *)((int)piVar28 + 1);\n        if (*(byte *)piVar28 == 0) break;\n      } while (*(byte *)piVar28 != 0x25);\n      piVar27 = (int *)((int)piVar28 - (int)param_3);\n      if (piVar27 != (int *)0x0) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)piVar27);\n        *ppiVar2 = param_3;\n        *(int **)((int)ppiVar2 + 4) = piVar27;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = (int **)((int)ppiVar2 + 8);\n        }\n        else {\n          iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800604a;\n          ppiVar2 = local_cc;\n        }\n        local_164 = local_164 + (int)piVar27;\n      }\n      if (*(byte *)piVar28 == 0) goto LAB_08006216;\n    }\n    piVar27 = (int *)0xffffffff;\n    piVar25 = (int *)0x0;\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    local_15c = (int *)0x0;\n    local_f5 = 0;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4a:\n    puVar29 = local_16c;\n    piVar28 = (int *)((int)piVar28 + 1);\nLAB_08005f4e:\n    switch(piVar24) {\n    case (int *)0x20:\n      goto switchD_08005f58_caseD_20;\n    default:\n      if (piVar24 == (int *)0x0) goto LAB_08006216;\n      piVar16 = (int *)0x0;\n      local_168 = (int *)0x1;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_158 = (char *)0x1;\n      piVar23 = (int *)&local_8c;\n      piVar22 = piVar16;\n      local_8c = (char)piVar24;\n      goto LAB_08006298;\n    case (int *)0x23:\n      piVar25 = (int *)((uint)piVar25 | 1);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x27:\n      iVar3 = calculate_adjusted_value_08008ad4(local_16c);\n      local_110 = *(int **)(iVar3 + 4);\n      piVar24 = (int *)count_trailing_zeroes_08005e40(local_110);\n      local_104 = piVar24;\n      iVar3 = calculate_adjusted_value_08008ad4(puVar29);\n      local_108 = *(byte **)(iVar3 + 8);\n      if (piVar24 == (int *)0x0) goto switchD_08005f58_caseD_74;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if ((local_108 != (byte *)0x0) && (*local_108 != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 0x400);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2a:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      local_15c = *local_154;\n      local_154 = local_154 + 1;\n      if ((int)local_15c < 0) {\n        local_15c = (int *)-(int)local_15c;\n        goto LAB_08006602;\n      }\n      goto LAB_08005f4a;\n    case (int *)0x2b:\n      local_f5 = 0x2b;\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x2d:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\nLAB_08006602:\n      piVar25 = (int *)((uint)piVar25 | 4);\n      goto LAB_08005f4a;\n    case (int *)0x2e:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x2a) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar27 = (int *)((uint)*local_154 | (int)*local_154 >> 0x1f);\n        local_154 = local_154 + 1;\n        piVar28 = (int *)((int)piVar28 + 1);\n        goto LAB_08005f4a;\n      }\n      piVar27 = (int *)0x0;\n      piVar28 = (int *)((int)piVar28 + 1);\n      while (piVar24 + -0xc < (int *)0xa) {\n        piVar27 = (int *)((int)(piVar24 + -0xc) + (int)piVar27 * 10);\n        piVar24 = (int *)(uint)*(byte *)piVar28;\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      goto LAB_08005f4e;\n    case (int *)0x30:\n      piVar25 = (int *)((uint)piVar25 | 0x80);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x31:\n    case (int *)0x32:\n    case (int *)0x33:\n    case (int *)0x34:\n    case (int *)0x35:\n    case (int *)0x36:\n    case (int *)0x37:\n    case (int *)0x38:\n    case (int *)0x39:\n      goto switchD_08005f58_caseD_31;\n    case (int *)0x41:\n    case (int *)0x45:\n    case (int *)0x46:\n    case (int *)0x47:\n    case (int *)0x61:\n    case (int *)0x65:\n    case (int *)0x66:\n    case (int *)0x67:\n      puVar29 = (undefined4 *)((int)local_154 + 7U & 0xfffffff8);\n      uVar10 = *puVar29;\n      local_12c = puVar29[1];\n      local_168 = (int *)(local_12c & 0x7fffffff);\n      local_154 = (int **)(puVar29 + 2);\n      local_128 = uVar10;\n      iVar3 = check_params_08001170(uVar10,local_168,0xffffffff,0x7fefffff);\n      if ((iVar3 == 0) && (iVar3 = check_conditions_080009c0(uVar10,local_168,0xffffffff,0x7fefffff), iVar3 == 0)\n         ) {\n        iVar3 = check_condition_080009ac(local_128,local_12c,local_124,local_120);\n        if (iVar3 == 0) {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        else {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        piVar23 = (int *)&UNK_08009f10;\n        piVar27 = (int *)&UNK_08009f0c;\nLAB_08006524:\n        local_148 = (int *)0x0;\n        local_168 = (int *)0x3;\n        if (piVar24 < (int *)0x48) {\n          piVar23 = piVar27;\n        }\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar25 = (int *)((uint)piVar25 & 0xffffff7f);\n        local_158 = (char *)0x3;\n        local_13c = (int **)0x0;\n        piVar22 = (int *)0x0;\n        goto LAB_08006538;\n      }\n      iVar3 = check_params_08001170(local_128,local_12c,local_128,local_12c);\n      if (iVar3 != 0) {\n        if ((int)local_12c < 0) {\n          piVar16 = (int *)0x2d;\n          local_f5 = 0x2d;\n        }\n        else {\n          piVar16 = (int *)(uint)local_f5;\n        }\n        piVar23 = (int *)&UNK_08009f18;\n        piVar27 = (int *)&UNK_08009f14;\n        goto LAB_08006524;\n      }\n      if (piVar24 == (int *)0x61) {\n        uVar12 = 0x78;\nLAB_08007224:\n        local_f4 = CONCAT11(uVar12,0x30);\n        if ((int)piVar27 < 100) {\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          local_148 = (int *)0x0;\n          param_3 = (int *)&local_8c;\n          piVar25 = (int *)((uint)piVar25 | 2);\n        }\n        else {\n          param_3 = (int *)allocate_and_set_memory_08008af8(local_16c,(byte *)((int)piVar27 + 1));\n          if (param_3 == (int *)0x0) {\n            uVar13 = *(ushort *)(local_160 + 3) | 0x40;\n            *(ushort *)(local_160 + 3) = uVar13;\n            goto LAB_0800604e;\n          }\n          local_140 = (int *)((uint)piVar25 | 0x102);\n          piVar25 = (int *)((uint)piVar25 | 2);\n          local_148 = param_3;\n        }\nLAB_0800724a:\n        if ((int)local_12c < 0) {\nLAB_08007414:\n          local_144 = (int *)0x2d;\n          uVar19 = local_12c + 0x80000000;\n        }\n        else {\n          local_144 = (int *)0x0;\n          uVar19 = local_12c;\n        }\n        local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n        piVar22 = piVar27;\n        local_158 = (char *)local_128;\n        if (piVar24 == (int *)0x61) {\n          uVar33 = calculate_float_exponent_080096e0(local_128,uVar19,&local_f0);\n          local_150 = calculate_product_and_addition_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = check_conditions_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 != 0) {\n            local_f0 = (int *)0x1;\n          }\n          local_158 = \"0123456789abcdef\";\n          local_13c = ppiVar2;\n          local_138 = piVar28;\n          local_134 = piVar24;\n          local_130 = piVar27;\n          local_100 = piVar25;\n          local_fc = param_3;\n          pcVar18 = local_158;\n          uVar33 = local_150;\n          goto LAB_080072ba;\n        }\n        if (piVar24 == (int *)0x41) {\n          uVar33 = calculate_float_exponent_080096e0(local_128,uVar19,&local_f0);\n          local_150 = calculate_product_and_addition_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x3fc00000);\n          iVar3 = check_conditions_08000998((int)local_150,(int)((ulonglong)local_150 >> 0x20),local_124,\n                               local_120);\n          if (iVar3 == 0) {\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          else {\n            local_f0 = (int *)0x1;\n            local_158 = \"0123456789ABCDEF\";\n            local_13c = ppiVar2;\n            local_138 = piVar28;\n            local_134 = piVar24;\n            local_130 = piVar27;\n            local_100 = piVar25;\n            local_fc = param_3;\n            pcVar18 = local_158;\n            uVar33 = local_150;\n          }\n          goto LAB_080072ba;\n        }\n      }\n      else {\n        if (piVar24 == (int *)0x41) {\n          uVar12 = 0x58;\n          goto LAB_08007224;\n        }\n        local_140 = (int *)((uint)piVar25 | 0x100);\n        local_148 = (int *)0x0;\n        if (piVar27 == (int *)0xffffffff) {\n          piVar27 = (int *)0x6;\n          goto LAB_0800724a;\n        }\n        if (((uint)piVar24 & 0xffffffdf) == 0x47) {\n          if (piVar27 == (int *)0x0) {\n            piVar27 = (int *)0x1;\n            local_148 = (int *)0x0;\n          }\n          goto LAB_0800724a;\n        }\n        if ((int)local_12c < 0) goto LAB_08007414;\n        local_144 = (int *)0x0;\n        uVar19 = local_12c;\n      }\n      local_168 = (int *)((uint)piVar24 & 0xffffffdf);\n      piStack_184 = piVar27;\n      local_158 = (char *)local_128;\n      if (piVar24 == (int *)0x66) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)convert_unsigned_int_to_string_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar22 = (int *)((int)piVar23 + (int)piVar27);\n        local_150._0_4_ = piVar27;\nLAB_0800764c:\n        if ((*(byte *)piVar23 == 0x30) &&\n           (iVar3 = check_conditions_08000998(local_158,uVar19,local_124,local_120), iVar3 == 0)) {\n          local_f0 = (int *)(1 - (int)(int *)local_150);\n        }\n        piVar22 = (int *)((int)piVar22 + (int)local_f0);\n      }\n      else if (piVar24 == (int *)0x46) {\n        local_178 = &local_e0;\n        local_188 = 3;\n        puStack_17c = auStack_ec;\n        local_180 = &local_f0;\n        piVar23 = (int *)convert_unsigned_int_to_string_080079e8(local_16c,local_180,local_128,uVar19);\n        local_150._0_4_ = piVar27;\nLAB_08007760:\n        piVar22 = (int *)((int)piVar23 + (int)(int *)local_150);\n        if (piVar24 == (int *)0x46) goto LAB_0800764c;\n      }\n      else {\n        local_178 = &local_e0;\n        local_150._0_4_ = piVar27;\n        if (local_168 == (int *)0x45) {\n          local_150._0_4_ = (int *)((int)piVar27 + 1);\n        }\n        local_188 = 2;\n        piStack_184 = (int *)local_150;\n        local_180 = &local_f0;\n        puStack_17c = auStack_ec;\n        piVar23 = (int *)convert_unsigned_int_to_string_080079e8(local_16c,local_180,local_128,uVar19);\n        piVar16 = local_e0;\n        if (piVar24 == (int *)0x67) {\n          if (((uint)piVar25 & 1) == 0) goto LAB_08006ca6;\n        }\n        else if (piVar24 == (int *)0x47) {\n          if (((uint)piVar25 & 1) != 0) goto LAB_08007760;\n          goto LAB_08006ca6;\n        }\n        piVar22 = (int *)((int)(int *)local_150 + (int)piVar23);\n      }\n      iVar3 = check_conditions_08000998(local_158,uVar19,local_124,local_120);\n      piVar16 = piVar22;\n      if (iVar3 == 0) {\n        for (; piVar16 = local_e0, local_e0 < piVar22; local_e0 = (int *)((int)local_e0 + 1)) {\n          *(byte *)local_e0 = 0x30;\n        }\n      }\nLAB_08006ca6:\n      local_138 = (int *)((int)piVar16 - (int)piVar23);\n      goto LAB_08006cb0;\n    case (int *)0x43:\n    case (int *)0x63:\n      piVar16 = (int *)0x0;\n      piVar27 = *local_154;\n      local_f5 = 0;\n      local_148 = (int *)0x0;\n      piVar22 = (int *)0x0;\n      local_13c = (int **)0x0;\n      local_134 = (int *)0x0;\n      local_130 = (int *)0x0;\n      local_154 = local_154 + 1;\n      local_168 = (int *)0x1;\n      local_158 = (char *)0x1;\n      local_8c = SUB41(piVar27,0);\n      piVar23 = (int *)&local_8c;\n      goto LAB_08006298;\n    case (int *)0x44:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080065a8;\nLAB_080060ec:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_08006102;\n    case (int *)0x4c:\n      piVar25 = (int *)((uint)piVar25 | 8);\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x4f:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n    case (int *)0x6f:\n      if (((uint)piVar25 & 0x20) == 0) {\n        ppiVar14 = local_154 + 1;\n        if (((uint)piVar25 & 0x10) == 0) {\n          if (((uint)piVar25 & 0x40) == 0) {\n            if (((uint)piVar25 & 0x200) == 0) goto LAB_08006be2;\n            piVar22 = (int *)(uint)*(byte *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n          else {\n            piVar22 = (int *)(uint)*(ushort *)local_154;\n            piVar16 = (int *)0x0;\n            local_154 = ppiVar14;\n          }\n        }\n        else {\nLAB_08006be2:\n          piVar22 = *local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\n        ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n        piVar22 = *ppiVar14;\n        piVar16 = ppiVar14[1];\n        local_154 = ppiVar14 + 2;\n      }\n      iVar3 = 0;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n      break;\n    case (int *)0x53:\n    case (int *)0x73:\n      local_f5 = 0;\n      piVar23 = *local_154;\n      ppiVar14 = local_154 + 1;\n      if (piVar23 == (int *)0x0) {\n        if ((int *)0x5 < piVar27) {\n          piVar27 = (int *)0x6;\n        }\n        piVar23 = (int *)&UNK_08009f44;\n        piVar16 = (int *)0x0;\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar22 = (int *)0x0;\n        local_168 = piVar27;\n        local_158 = (char *)piVar27;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (piVar27 == (int *)0xffffffff) {\n          local_158 = (char *)count_trailing_zeroes_08005e40(piVar23);\n        }\n        else {\n          iVar3 = find_next_occurrence_0800901c(piVar23,0,piVar27);\n          if (iVar3 == 0) {\n            piVar16 = (int *)(uint)local_f5;\n            local_148 = (int *)0x0;\n            local_13c = (int **)0x0;\n            local_134 = (int *)0x0;\n            local_130 = (int *)0x0;\n            piVar22 = (int *)0x0;\n            local_168 = piVar27;\n            local_158 = (char *)piVar27;\n            local_154 = ppiVar14;\n            goto LAB_08006538;\n          }\n          local_158 = (char *)(iVar3 - (int)piVar23);\n        }\n        local_148 = (int *)0x0;\n        local_13c = (int **)0x0;\n        local_134 = (int *)0x0;\n        local_130 = (int *)0x0;\n        piVar16 = (int *)(uint)local_f5;\n        piVar22 = (int *)0x0;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        local_154 = ppiVar14;\n      }\n      goto LAB_08006538;\n    case (int *)0x55:\n      piVar25 = (int *)((uint)piVar25 | 0x10);\n      if (-1 < (int)piVar25 << 0x1a) goto LAB_080066c0;\nLAB_0800618a:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      iVar3 = 1;\n      local_154 = ppiVar14 + 2;\n      break;\n    case (int *)0x58:\n      local_11c = \"0123456789ABCDEF\";\n      if (((uint)piVar25 & 0x20) == 0) goto LAB_08006696;\nLAB_080061ac:\n      ppiVar14 = (int **)((int)local_154 + 7U & 0xfffffff8);\n      piVar22 = *ppiVar14;\n      piVar16 = ppiVar14[1];\n      local_154 = ppiVar14 + 2;\n      goto LAB_080061be;\n    case (int *)0x64:\n    case (int *)0x69:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_080060ec;\nLAB_080065a8:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bcc:\n        piVar22 = *local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(int)*(short *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bcc;\n        piVar22 = (int *)(int)*(char *)local_154;\n        piVar16 = (int *)((int)piVar22 >> 0x1f);\n        local_154 = ppiVar14;\n      }\nLAB_08006102:\n      if ((int)piVar16 < 0) {\n        bVar31 = piVar22 != (int *)0x0;\n        piVar22 = (int *)-(int)piVar22;\n        piVar16 = (int *)(-(int)piVar16 - (uint)bVar31);\n        local_f5 = 0x2d;\n      }\n      if (piVar27 != (int *)0xffffffff) {\n        iVar3 = 1;\n        iVar8 = 1;\n        piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n        if (((uint)piVar22 | (uint)piVar16) == 0) goto LAB_080060a4;\n        goto LAB_08006130;\n      }\n      piVar21 = piVar25;\n      if (piVar16 != (int *)0x0 || (int *)0x9 < piVar22) goto LAB_08006f16;\n      goto LAB_0800698a;\n    case (int *)0x68:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      if (piVar24 == (int *)0x68) {\n        piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n        piVar25 = (int *)((uint)piVar25 | 0x200);\n        piVar28 = (int *)((int)piVar28 + 1);\n      }\n      else {\n        piVar25 = (int *)((uint)piVar25 | 0x40);\n      }\n      goto LAB_08005f4a;\n    case (int *)0x6a:\n    case (int *)0x71:\n      piVar25 = (int *)((uint)piVar25 | 0x20);\n    case (int *)0x74:\n    case (int *)0x7a:\nswitchD_08005f58_caseD_74:\n      piVar24 = (int *)(uint)*(byte *)piVar28;\n      goto LAB_08005f4a;\n    case (int *)0x6c:\n      goto switchD_08005f58_caseD_6c;\n    case (int *)0x6e:\n      ppiVar14 = local_154 + 1;\n      ppbVar15 = (byte **)*local_154;\n      local_154 = ppiVar14;\n      if (((uint)piVar25 & 0x20) != 0) {\n        *ppbVar15 = local_164;\n        ppbVar15[1] = (byte *)((int)local_164 >> 0x1f);\n        goto LAB_0800620e;\n      }\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) != 0) {\n          *(short *)ppbVar15 = (short)local_164;\n          goto LAB_0800620e;\n        }\n        if (((uint)piVar25 & 0x200) != 0) {\n          *(char *)ppbVar15 = (char)local_164;\n          goto LAB_0800620e;\n        }\n      }\n      *ppbVar15 = local_164;\n      goto LAB_0800620e;\n    case (int *)0x70:\n      local_f4 = 0x7830;\n      piVar22 = *local_154;\n      local_11c = \"0123456789abcdef\";\n      piVar25 = (int *)((uint)piVar25 | 2);\n      piVar16 = (int *)0x0;\n      iVar3 = 2;\n      piVar24 = (int *)0x78;\n      local_154 = local_154 + 1;\n      break;\n    case (int *)0x75:\n      if ((int)piVar25 << 0x1a < 0) goto LAB_0800618a;\nLAB_080066c0:\n      ppiVar14 = local_154 + 1;\n      if ((int)piVar25 << 0x1b < 0) {\nLAB_08006bf2:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else if ((int)piVar25 << 0x19 < 0) {\n        piVar22 = (int *)(uint)*(ushort *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      else {\n        if (-1 < (int)piVar25 << 0x16) goto LAB_08006bf2;\n        piVar22 = (int *)(uint)*(byte *)local_154;\n        piVar16 = (int *)0x0;\n        iVar3 = 1;\n        local_154 = ppiVar14;\n      }\n      break;\n    case (int *)0x78:\n      local_11c = \"0123456789abcdef\";\n      if (((uint)piVar25 & 0x20) != 0) goto LAB_080061ac;\nLAB_08006696:\n      ppiVar14 = local_154 + 1;\n      if (((uint)piVar25 & 0x10) == 0) {\n        if (((uint)piVar25 & 0x40) == 0) {\n          if (((uint)piVar25 & 0x200) == 0) goto LAB_08006bbc;\n          piVar22 = (int *)(uint)*(byte *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n        else {\n          piVar22 = (int *)(uint)*(ushort *)local_154;\n          piVar16 = (int *)0x0;\n          local_154 = ppiVar14;\n        }\n      }\n      else {\nLAB_08006bbc:\n        piVar22 = *local_154;\n        piVar16 = (int *)0x0;\n        local_154 = ppiVar14;\n      }\nLAB_080061be:\n      if ((((uint)piVar25 & 1) != 0) && (((uint)piVar22 | (uint)piVar16) != 0)) {\n        piVar25 = (int *)((uint)piVar25 | 2);\n        local_f4 = CONCAT11((char)piVar24,0x30);\n      }\n      iVar3 = 2;\n      piVar25 = (int *)((uint)piVar25 & 0xfffffbff);\n    }\n    local_f5 = 0;\n    if (piVar27 == (int *)0xffffffff) {\n      if (iVar3 != 1) goto LAB_08006136;\nLAB_08006980:\n      piVar21 = piVar25;\n      if (piVar16 == (int *)0x0 && piVar22 < (int *)0xa) goto LAB_0800698a;\nLAB_08006f16:\n      lVar32 = CONCAT44(piVar16,piVar22);\n      piVar23 = (int *)(&bStack_2a + 2);\n      piVar22 = (int *)0x0;\n      pbVar26 = local_108;\n      local_168 = piVar23;\n      local_158 = (char *)ppiVar2;\n      local_150._0_4_ = piVar25;\n      local_148 = piVar24;\n      do {\n        iVar3 = (int)((ulonglong)lVar32 >> 0x20);\n        uVar19 = (uint)lVar32;\n        cVar6 = '\\n';\n        calculate_result_080011ec(uVar19,iVar3,10,0);\n        *(byte *)((int)piVar23 + -1) = cVar6 + 0x30;\n        piVar22 = (int *)((int)piVar22 + 1);\n        piVar23 = (int *)((int)piVar23 + -1);\n        if ((((((uint)piVar25 & 0x400) != 0) && (piVar22 == (int *)(uint)*pbVar26)) &&\n            (piVar22 != (int *)0xff)) && (iVar3 != 0 || 9 < uVar19)) {\n          piVar23 = (int *)((int)piVar23 - (int)local_104);\n          copy_and_zero_out_string_08009768(piVar23,local_110,local_104);\n          if (pbVar26[1] == 0) {\n            piVar22 = (int *)0x0;\n          }\n          else {\n            pbVar26 = pbVar26 + 1;\n            piVar22 = (int *)0x0;\n          }\n        }\n        lVar32 = calculate_result_080011ec(uVar19,iVar3,10,0);\n      } while (lVar32 != 0);\n      piVar24 = local_148;\n      piVar25 = (int *)local_150;\n      ppiVar2 = (int **)local_158;\n      local_158 = (char *)((int)local_168 - (int)piVar23);\n      local_138 = piVar22;\n      local_108 = pbVar26;\n    }\n    else {\n      piVar21 = (int *)((uint)piVar25 & 0xffffff7f);\n      iVar8 = iVar3;\n      if (((uint)piVar22 | (uint)piVar16) == 0) {\nLAB_080060a4:\n        if (piVar27 == (int *)0x0) {\n          if (iVar3 == 0) {\n            local_158 = (char *)((uint)piVar25 & 1);\n            if ((int *)local_158 == (int *)0x0) {\n              piVar23 = (int *)(&bStack_2a + 2);\n              piVar25 = piVar21;\n            }\n            else {\n              piVar23 = (int *)(&bStack_2a + 1);\n              local_29 = '0';\n              piVar25 = piVar21;\n            }\n          }\n          else {\n            piVar23 = (int *)(&bStack_2a + 2);\n            piVar25 = piVar21;\n            local_158 = (char *)piVar27;\n          }\n        }\n        else {\n          piVar25 = piVar21;\n          if (iVar3 != 1) goto LAB_08006136;\nLAB_0800698a:\n          local_29 = (char)piVar22 + '0';\n          piVar23 = (int *)(&bStack_2a + 1);\n          local_158 = (char *)0x1;\n          piVar25 = piVar21;\n        }\n      }\n      else {\nLAB_08006130:\n        iVar3 = iVar8;\n        piVar25 = piVar21;\n        if (iVar8 == 1) goto LAB_08006980;\nLAB_08006136:\n        if (iVar3 == 2) {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = (int *)((uint)piVar22 >> 4 | (int)piVar16 << 0x1c);\n            piVar16 = (int *)((uint)piVar16 >> 4);\n            piVar23 = (int *)((int)piVar23 + -1);\n            *(char *)piVar23 = local_11c[(uint)piVar22 & 0xf];\n            piVar22 = piVar21;\n          } while (((uint)piVar21 | (uint)piVar16) != 0);\n        }\n        else {\n          piVar23 = (int *)(&bStack_2a + 2);\n          do {\n            piVar21 = piVar23;\n            piVar9 = (int *)((uint)piVar22 >> 3 | (int)piVar16 << 0x1d);\n            piVar16 = (int *)((uint)piVar16 >> 3);\n            iVar3 = ((uint)piVar22 & 7) + 0x30;\n            *(byte *)((int)piVar21 + -1) = (byte)iVar3;\n            piVar23 = (int *)((int)piVar21 + -1);\n            piVar22 = piVar9;\n          } while (((uint)piVar9 | (uint)piVar16) != 0);\n          if ((((uint)piVar25 & 1) != 0) && (iVar3 != 0x30)) {\n            piVar23 = (int *)((int)piVar21 + -2);\n            *(byte *)((int)piVar21 + -2) = 0x30;\n            local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n            goto LAB_0800675a;\n          }\n        }\n        local_158 = (char *)(&bStack_2a + (2 - (int)piVar23));\n      }\n    }\nLAB_0800675a:\n    local_148 = (int *)0x0;\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = piVar27;\n    local_168 = (int *)local_158;\n    if ((int)local_158 < (int)piVar27) {\n      local_168 = piVar27;\n    }\n    goto LAB_08006538;\n  }\nLAB_08006216:\n  piVar28 = local_160;\n  if (local_d0 == (int *)0x0) {\nLAB_0800604a:\n    uVar13 = *(ushort *)(local_160 + 3);\n  }\n  else {\n    copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n    uVar13 = *(ushort *)(piVar28 + 3);\n  }\nLAB_0800604e:\n  if ((uVar13 & 0x40) != 0) {\n    local_164 = (byte *)0xffffffff;\n  }\n  return local_164;\nswitchD_08005f58_caseD_6c:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (piVar24 == (int *)0x6c) {\n    piVar24 = (int *)(uint)*(byte *)((int)piVar28 + 1);\n    piVar25 = (int *)((uint)piVar25 | 0x20);\n    piVar28 = (int *)((int)piVar28 + 1);\n  }\n  else {\n    piVar25 = (int *)((uint)piVar25 | 0x10);\n  }\n  goto LAB_08005f4a;\n  while( true ) {\n    iVar8 = check_conditions_08000998((int)uVar33,uVar10,local_124,local_120);\n    if (iVar8 != 0) break;\nLAB_080072ba:\n    piVar16 = param_3;\n    piVar22 = (int *)((int)piVar22 + -1);\n    uVar33 = calculate_product_and_addition_080004c8((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),0,0x40300000);\n    iVar3 = calculate_modified_value_0800119c();\n    uVar34 = shift_and_adjust_080003f4();\n    uVar33 = unsigned_long_long_binary_operation_08000158((int)uVar33,(int)((ulonglong)uVar33 >> 0x20),(int)uVar34,\n                          (int)((ulonglong)uVar34 >> 0x20));\n    uVar10 = (undefined4)((ulonglong)uVar33 >> 0x20);\n    param_3 = (int *)((int)piVar16 + 1);\n    *(char *)piVar16 = pcVar18[iVar3];\n    if (piVar22 == (int *)0xffffffff) break;\n  }\n  piVar23 = local_fc;\n  piVar25 = local_100;\n  piVar27 = local_130;\n  piVar24 = local_134;\n  piVar28 = local_138;\n  ppiVar2 = local_13c;\n  local_13c = (int **)piVar22;\n  local_134 = piVar16;\n  local_150 = uVar33;\n  iVar8 = check_evaluation_result_080009e8((int)uVar33,uVar10,0,0x3fe00000);\n  if (iVar8 == 0) {\n    iVar8 = check_conditions_08000998((int *)local_150,local_150._4_4_,0,0x3fe00000);\n    if ((iVar8 != 0) && (iVar3 << 0x1f < 0)) goto LAB_0800748a;\n    if (-1 < (int)local_13c) {\n      piVar16 = (int *)((byte *)((int)local_13c + 1) + (int)param_3);\n      piVar22 = param_3;\n      do {\n        param_3 = (int *)((int)piVar22 + 1);\n        *(byte *)piVar22 = 0x30;\n        piVar22 = param_3;\n      } while (piVar16 != param_3);\n    }\n  }\n  else {\nLAB_0800748a:\n    bVar1 = local_158[0xf];\n    bVar7 = *(byte *)piVar16;\n    piVar22 = param_3;\n    local_e0 = local_134;\n    while (bVar1 == bVar7) {\n      *(byte *)((int)piVar22 + -1) = 0x30;\n      bVar7 = *(byte *)((int)local_e0 + -1);\n      piVar22 = local_e0;\n      local_e0 = (int *)((int)local_e0 + -1);\n    }\n    if (bVar7 == 0x39) {\n      bVar7 = local_158[10];\n    }\n    else {\n      bVar7 = bVar7 + 1;\n    }\n    *(byte *)((int)piVar22 + -1) = bVar7;\n  }\n  local_138 = (int *)((int)param_3 - (int)piVar23);\nLAB_08006cb0:\n  local_134 = local_f0;\n  if (local_168 == (int *)0x47) {\n    if (((int)((int)local_f0 + 3) < 0 == SCARRY4((int)local_f0,3)) &&\n       ((int)local_f0 <= (int)piVar27)) {\n      if ((int)local_f0 < (int)local_138) {\n        local_158 = (char *)((int)local_138 + (int)local_118);\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074f8;\n        }\n        local_158 = (char *)((int)local_158 + (1 - (int)local_f0));\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        piVar24 = (int *)0x67;\n      }\n      else {\n        if ((int)piVar25 << 0x1f < 0) {\n          local_158 = (char *)((int)local_f0 + (int)local_118);\n        }\n        else {\n          local_158 = (char *)local_f0;\n        }\n        if (-1 < (int)piVar25 << 0x15) {\n          piVar24 = (int *)0x67;\n          goto LAB_0800754a;\n        }\n        if (0 < (int)local_f0) {\n          piVar24 = (int *)0x67;\n          goto LAB_080074fc;\n        }\n        piVar24 = (int *)0x67;\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\n      goto LAB_080073d6;\n    }\n    piVar24 = (int *)((int)piVar24 + -2);\n    local_168 = (int *)((uint)piVar24 & 0xffffffdf);\nLAB_08006cc4:\n    local_e8 = (char)piVar24;\n    if (local_168 == (int *)0x41) {\n      local_e8 = local_e8 + '\\x0f';\n    }\n    piVar27 = (int *)((int)local_f0 + -1);\n    if ((int)piVar27 < 0) {\n      local_e7 = 0x2d;\n      local_f0 = (int *)(1 - (int)local_f0);\n    }\n    else {\n      local_e7 = 0x2b;\n      local_f0 = piVar27;\n    }\n    if ((int)local_f0 < 10) {\n      if (local_168 == (int *)0x41) {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n      else {\n        local_e6[0] = 0x30;\n        pcVar18 = (char *)((int)&local_e8 + 3);\n      }\n      *pcVar18 = (char)local_f0 + '0';\n      pcVar18 = pcVar18 + 1;\n    }\n    else {\n      pbVar30 = abStack_dc + 3;\n      pbVar26 = pbVar30;\n      do {\n        pbVar5 = pbVar26;\n        piVar22 = (int *)((uint)local_f0 / 10);\n        pbVar5[-1] = (char)local_f0 + (char)piVar22 * -10 + 0x30;\n        pbVar26 = pbVar5 + -1;\n        local_f0 = piVar22;\n      } while ((int *)0x9 < piVar22);\n      uVar19 = (uint)(piVar22 + 0xc) & 0xff;\n      pbVar5[-2] = (byte)uVar19;\n      if (pbVar5 + -2 < pbVar30) {\n        pbVar5 = pbVar26;\n        puVar20 = (undefined *)((int)&local_e8 + 2);\n        while( true ) {\n          *puVar20 = (char)uVar19;\n          if (pbVar30 == pbVar5) break;\n          uVar19 = (uint)*pbVar5;\n          pbVar5 = pbVar5 + 1;\n          puVar20 = puVar20 + 1;\n        }\n        pcVar18 = (char *)(((int)&local_188 * 2 - (int)pbVar26) + 0x152);\n      }\n      else {\n        pcVar18 = (char *)((int)&local_e8 + 2);\n      }\n    }\n    local_10c = (int *)(pcVar18 + -(int)&local_e8);\n    local_158 = (char *)((int)local_10c + (int)local_138);\n    if ((1 < (int)local_138) || ((int)piVar25 << 0x1f < 0)) {\n      local_158 = (char *)((int)local_158 + (int)local_118);\n    }\n    local_13c = (int **)0x0;\n    local_134 = (int *)0x0;\n    local_130 = (int *)0x0;\n    local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n    piVar25 = (int *)((uint)piVar25 & 0xfffffbff | 0x100);\n    local_f0 = piVar27;\n  }\n  else {\n    if (local_168 != (int *)0x46) goto LAB_08006cc4;\n    if ((int)local_f0 < 1) {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_168 = (int *)0x1;\n        local_158 = (char *)0x1;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_118 + 1) + (int)piVar27);\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      }\nLAB_080073d6:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      piVar25 = local_140;\n    }\n    else {\n      if ((piVar27 == (int *)0x0) && (-1 < (int)piVar25 << 0x1f)) {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)local_f0;\n      }\n      else {\n        piVar24 = (int *)0x66;\n        local_158 = (char *)((byte *)((int)local_f0 + (int)local_118) + (int)piVar27);\n      }\nLAB_080074f8:\n      if (-1 < (int)piVar25 << 0x15) {\nLAB_0800754a:\n        local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n        goto LAB_080073d6;\n      }\nLAB_080074fc:\n      local_13c = (int **)0x0;\n      local_130 = (int *)0x0;\n      uVar19 = (uint)*local_108;\n      while (uVar19 != 0xff) {\n        while( true ) {\n          if ((int)local_134 <= (int)uVar19) goto LAB_08007524;\n          uVar4 = (uint)local_108[1];\n          local_134 = (int *)((int)local_134 - uVar19);\n          if (uVar4 == 0) break;\n          local_108 = local_108 + 1;\n          local_130 = (int *)((int)local_130 + 1);\n          uVar19 = uVar4;\n          if (uVar4 == 0xff) goto LAB_08007524;\n        }\n        local_13c = (int **)((int)local_13c + 1);\n      }\nLAB_08007524:\n      local_158 = (char *)((int)local_158 + (int)local_104 * ((int)local_130 + (int)local_13c));\n      local_168 = (int *)((uint)local_158 & ~((int)local_158 >> 0x1f));\n      piVar25 = local_140;\n    }\n  }\n  if (local_144 == (int *)0x0) {\n    piVar16 = (int *)(uint)local_f5;\n    piVar22 = (int *)0x0;\nLAB_08006538:\n    if (piVar16 != (int *)0x0) goto LAB_0800653e;\n  }\n  else {\n    piVar16 = (int *)0x2d;\n    piVar22 = (int *)0x0;\n    local_f5 = 0x2d;\nLAB_0800653e:\n    local_168 = (int *)((int)local_168 + 1);\n  }\nLAB_08006298:\n  piVar27 = local_160;\n  puVar29 = local_16c;\n  local_150._0_4_ = (int *)((uint)piVar25 & 2);\n  if ((int *)local_150 != (int *)0x0) {\n    local_168 = (int *)((int)local_168 + 2);\n  }\n  local_144 = (int *)((uint)piVar25 & 0x84);\n  if ((local_144 == (int *)0x0) &&\n     (piVar21 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar21)) {\n    if (0x10 < (int)piVar21) {\n      piVar16 = (int *)0x10;\n      local_100 = piVar24;\n      do {\n        piVar9 = piVar21;\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = piVar16;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n          piVar24 = local_100;\n        }\n        else {\n          local_140 = piVar16;\n          iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = local_140;\n          piVar24 = local_100;\n        }\n        piVar21 = piVar9 + -4;\n        local_100 = piVar24;\n      } while (0x10 < (int)piVar21);\n      piVar21 = piVar9 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar21);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar21;\n    if ((int)local_d4 < 8) {\n      piVar16 = (int *)(uint)local_f5;\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar16 = (int *)(uint)local_f5;\n    }\n  }\n  if (piVar16 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 1);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f5;\n    ppiVar2[1] = (int *)0x1;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  if ((int *)local_150 != (int *)0x0) {\n    local_d0 = (int *)((int)local_d0 + 2);\n    local_d4 = (int *)((int)local_d4 + 1);\n    *ppiVar2 = (int *)&local_f4;\n    ppiVar2[1] = (int *)0x2;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  if ((local_144 == (int *)0x80) &&\n     (piVar16 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar16)) {\n    if (0x10 < (int)piVar16) {\n      do {\n        while( true ) {\n          piVar21 = piVar16;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = copy_and_allocate_memory_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar16 = piVar21 + -4;\n          if ((int)(piVar21 + -4) < 0x11) goto LAB_08006882;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar16 = piVar21 + -4;\n      } while (0x10 < (int)(piVar21 + -4));\nLAB_08006882:\n      piVar16 = piVar21 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar16);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar16;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_160;\n  piVar22 = (int *)((int)piVar22 - (int)local_158);\n  if (0 < (int)piVar22) {\n    if (0x10 < (int)piVar22) {\n      do {\n        while( true ) {\n          piVar16 = piVar22;\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = local_d0 + 4;\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = (int *)0x10;\n          if ((int)local_d4 < 8) break;\n          iVar3 = copy_and_allocate_memory_080097cc(local_16c,piVar27,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n          piVar22 = piVar16 + -4;\n          if ((int)(piVar16 + -4) < 0x11) goto LAB_080063d2;\n        }\n        ppiVar2 = ppiVar2 + 2;\n        piVar22 = piVar16 + -4;\n      } while (0x10 < (int)(piVar16 + -4));\nLAB_080063d2:\n      piVar22 = piVar16 + -4;\n    }\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar22);\n    *ppiVar2 = (int *)0x8009f60;\n    ppiVar2[1] = piVar22;\n    if ((int)local_d4 < 8) {\n      ppiVar2 = ppiVar2 + 2;\n    }\n    else {\n      iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n    }\n  }\n  piVar27 = local_d0;\n  if (((uint)piVar25 & 0x100) == 0) {\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)local_158);\n    *ppiVar2 = piVar23;\n    ppiVar2[1] = (int *)local_158;\n    if ((int)local_d4 < 8) {\nLAB_0800640e:\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\n    else {\nLAB_08006a20:\n      iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else if ((int)piVar24 < 0x66) {\n    local_158 = (char *)((int)local_d0 + 1);\n    piVar27 = (int *)((int)local_d4 + 1);\n    ppiVar14 = ppiVar2 + 2;\n    local_d0 = (int *)local_158;\n    if (((int)local_138 < 2) && (((uint)piVar25 & 1) == 0)) {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)piVar27 < 8) {\n        local_150._0_4_ = (int *)((int)local_d4 + 2);\n        ppiVar2 = ppiVar2 + 4;\n      }\n      else {\n        local_d4 = piVar27;\n        iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        local_150._0_4_ = (int *)((int)local_d4 + 1);\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n        ppiVar2 = local_cc + 2;\n      }\n    }\n    else {\n      *ppiVar2 = piVar23;\n      ppiVar2[1] = (int *)0x1;\n      local_d4 = piVar27;\n      if (7 < (int)piVar27) {\n        iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar14 = local_cc;\n        local_158 = (char *)local_d0;\n      }\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_158 = (char *)((int)local_158 + (int)local_118);\n      *ppiVar14 = local_114;\n      ppiVar14[1] = local_118;\n      local_d0 = (int *)local_158;\n      if ((int)local_d4 < 8) {\n        ppiVar17 = ppiVar14 + 2;\n      }\n      else {\n        iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar17 = local_cc;\n      }\n      piVar24 = local_d4;\n      local_150._0_4_ = (int *)((int)local_d4 + 1);\n      piVar22 = (int *)((int)local_138 + -1);\n      ppiVar11 = ppiVar17 + 2;\n      local_158 = (char *)local_d0;\n      local_144 = (int *)local_150;\n      iVar3 = check_conditions_08000998(local_128,local_12c,local_124,local_120);\n      piVar27 = local_160;\n      puVar29 = local_16c;\n      if (iVar3 == 0) {\n        local_158 = (char *)((int)local_158 + (int)piVar22);\n        *ppiVar17 = (int *)((int)piVar23 + 1);\n        ppiVar17[1] = piVar22;\n        local_d0 = (int *)local_158;\n        if ((int)(int *)local_150 < 8) {\n          local_150._0_4_ = (int *)((int)piVar24 + 2);\n          ppiVar14 = ppiVar11;\n          ppiVar2 = ppiVar17 + 4;\n        }\n        else {\nLAB_08006d9c:\n          local_158 = (char *)local_d0;\n          local_d4 = (int *)local_150;\n          iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          local_150._0_4_ = (int *)((int)local_d4 + 1);\n          local_158 = (char *)local_d0;\n          ppiVar14 = local_cc;\n          ppiVar2 = local_cc + 2;\n        }\n      }\n      else {\n        ppiVar14 = ppiVar17;\n        ppiVar2 = ppiVar11;\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)local_158;\n          local_d4 = local_144;\n          if (0x10 < (int)piVar22) {\n            while( true ) {\n              local_d0 = local_d0 + 4;\n              *ppiVar17 = (int *)0x8009f60;\n              ppiVar17[1] = (int *)0x10;\n              if ((int)local_d4 < 8) {\n                ppiVar17 = ppiVar17 + 2;\n              }\n              else {\n                iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar27,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar17 = local_cc;\n              }\n              piVar22 = piVar22 + -4;\n              if ((int)piVar22 < 0x11) break;\n              local_d4 = (int *)((int)local_d4 + 1);\n            }\n            local_150._0_4_ = (int *)((int)local_d4 + 1);\n            ppiVar11 = ppiVar17 + 2;\n            local_158 = (char *)local_d0;\n          }\n          *ppiVar17 = (int *)0x8009f60;\n          ppiVar17[1] = piVar22;\n          local_158 = (char *)((int)local_158 + (int)piVar22);\n          local_d0 = (int *)local_158;\n          if (7 < (int)(int *)local_150) goto LAB_08006d9c;\n          local_150._0_4_ = (int *)((int)(int *)local_150 + 1);\n          ppiVar2 = ppiVar11 + 2;\n          ppiVar14 = ppiVar11;\n        }\n      }\n    }\n    ppiVar14[1] = local_10c;\n    local_d0 = (int *)((int)local_158 + (int)local_10c);\n    local_d4 = (int *)local_150;\n    *ppiVar14 = (int *)&local_e8;\n    piVar27 = local_d0;\n    if (7 < (int)(int *)local_150) {\n      iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n      if (iVar3 != 0) goto LAB_0800603e;\n      ppiVar2 = local_cc;\n      piVar27 = local_d0;\n    }\n  }\n  else {\n    iVar3 = check_conditions_08000998(local_128,local_12c,local_124,local_120);\n    if (iVar3 == 0) {\n      if ((int)local_f0 < 1) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)piVar27 + 1);\n        *ppiVar2 = (int *)&DAT_08009f4c;\n        ppiVar2[1] = (int *)0x1;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        if (((local_f0 != (int *)0x0) || (local_138 != (int *)0x0)) ||\n           (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)local_d0 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n          }\n          puVar29 = local_16c;\n          if ((int)local_f0 < 0) {\n            piVar27 = (int *)-(int)local_f0;\n            if ((int)(local_f0 + 4) < 0 != SCARRY4((int)local_f0,0x10)) {\n              do {\n                local_d4 = (int *)((int)local_d4 + 1);\n                local_d0 = local_d0 + 4;\n                *ppiVar2 = (int *)0x8009f60;\n                ppiVar2[1] = (int *)0x10;\n                if ((int)local_d4 < 8) {\n                  ppiVar2 = ppiVar2 + 2;\n                }\n                else {\n                  iVar3 = copy_and_allocate_memory_080097cc(puVar29,local_160,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  ppiVar2 = local_cc;\n                }\n                piVar27 = piVar27 + -4;\n              } while (0x10 < (int)piVar27);\n            }\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)local_d0 + (int)piVar27);\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = piVar27;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\n          local_d0 = (int *)((int)local_d0 + (int)local_138);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = local_138;\n          goto joined_r0x08006a1c;\n        }\n      }\n      else {\n        piVar24 = local_134;\n        if ((int)local_138 <= (int)local_134) {\n          piVar24 = local_138;\n        }\n        if (0 < (int)piVar24) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar24);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar23;\n          ppiVar2[1] = piVar24;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        piVar22 = local_134;\n        if (-1 < (int)piVar24) {\n          piVar22 = (int *)((int)local_134 - (int)piVar24);\n        }\n        if (0 < (int)piVar22) {\n          for (; 0x10 < (int)piVar22; piVar22 = piVar22 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = piVar27 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          local_d4 = (int *)((int)local_d4 + 1);\n          piVar27 = (int *)((int)piVar27 + (int)piVar22);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar22;\n          local_d0 = piVar27;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n          }\n          else {\n            iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar22 = local_104;\n        piVar24 = local_160;\n        puVar29 = local_16c;\n        piVar16 = (int *)((int)local_134 + (int)piVar23);\n        if (((uint)piVar25 & 0x400) != 0) {\n          local_158 = (char *)((int)piVar23 + (int)local_138);\n          pbVar26 = local_108;\n          local_150._0_4_ = piVar28;\n          local_144 = piVar25;\n          local_140 = piVar23;\n          if (local_130 == (int *)0x0) goto LAB_08007176;\nLAB_080070ba:\n          if (local_13c != (int **)0x0) goto LAB_0800717e;\n          pbVar26 = pbVar26 + -1;\n          local_130 = (int *)((int)local_130 + -1);\n          do {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = (int *)((int)piVar27 + (int)piVar22);\n            *ppiVar2 = local_110;\n            ppiVar2[1] = piVar22;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar24,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = (int *)(uint)*pbVar26;\n            piVar28 = (int *)((int)local_158 - (int)piVar16);\n            if ((int)piVar27 <= (int)(int *)((int)local_158 - (int)piVar16)) {\n              piVar28 = piVar27;\n            }\n            if (0 < (int)piVar28) {\n              local_d0 = (int *)((int)local_d0 + (int)piVar28);\n              local_d4 = (int *)((int)local_d4 + 1);\n              *ppiVar2 = piVar16;\n              ppiVar2[1] = piVar28;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                ppiVar2 = local_cc;\n                piVar27 = (int *)(uint)*pbVar26;\n              }\n            }\n            piVar25 = piVar27;\n            if (-1 < (int)piVar28) {\n              piVar25 = (int *)((int)piVar27 - (int)piVar28);\n            }\n            if (0 < (int)piVar25) {\n              for (; 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n                while( true ) {\n                  local_d4 = (int *)((int)local_d4 + 1);\n                  local_d0 = local_d0 + 4;\n                  *ppiVar2 = (int *)0x8009f60;\n                  ppiVar2[1] = (int *)0x10;\n                  if ((int)local_d4 < 8) break;\n                  iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar24,&local_d8);\n                  if (iVar3 != 0) goto LAB_0800603e;\n                  piVar25 = piVar25 + -4;\n                  ppiVar2 = local_cc;\n                  if ((int)piVar25 < 0x11) goto LAB_08007156;\n                }\n                ppiVar2 = ppiVar2 + 2;\n              }\nLAB_08007156:\n              local_d4 = (int *)((int)local_d4 + 1);\n              local_d0 = (int *)((int)local_d0 + (int)piVar25);\n              *ppiVar2 = (int *)0x8009f60;\n              ppiVar2[1] = piVar25;\n              if ((int)local_d4 < 8) {\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = ppiVar2 + 2;\n              }\n              else {\n                iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar24,&local_d8);\n                if (iVar3 != 0) goto LAB_0800603e;\n                piVar27 = (int *)(uint)*pbVar26;\n                ppiVar2 = local_cc;\n              }\n            }\n            piVar16 = (int *)((int)piVar16 + (int)piVar27);\n            piVar27 = local_d0;\n            if (local_130 != (int *)0x0) goto LAB_080070ba;\nLAB_08007176:\n            if (local_13c == (int **)0x0) {\n              piVar23 = local_140;\n              piVar25 = local_144;\n              piVar28 = (int *)local_150;\n              local_108 = pbVar26;\n              if ((int *)((int)local_140 + (int)local_138) <= piVar16) {\n                piVar16 = (int *)((int)local_140 + (int)local_138);\n              }\n              break;\n            }\nLAB_0800717e:\n            local_13c = (int **)((int)local_13c + -1);\n          } while( true );\n        }\n        if (((int)local_f0 < (int)local_138) || (((uint)piVar25 & 1) != 0)) {\n          local_d4 = (int *)((int)local_d4 + 1);\n          local_d0 = (int *)((int)piVar27 + (int)local_118);\n          *ppiVar2 = local_114;\n          ppiVar2[1] = local_118;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar27 = local_d0;\n          }\n        }\n        piVar24 = (int *)((int)local_138 - (int)local_f0);\n        piVar22 = (int *)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16);\n        if ((int)piVar24 <= (int)((byte *)((int)piVar23 + (int)local_138) + -(int)piVar16)) {\n          piVar22 = piVar24;\n        }\n        if (0 < (int)piVar22) {\n          local_d0 = (int *)((int)piVar27 + (int)piVar22);\n          local_d4 = (int *)((int)local_d4 + 1);\n          *ppiVar2 = piVar16;\n          ppiVar2[1] = piVar22;\n          if ((int)local_d4 < 8) {\n            ppiVar2 = ppiVar2 + 2;\n            piVar27 = local_d0;\n          }\n          else {\n            iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n            if (iVar3 != 0) goto LAB_0800603e;\n            ppiVar2 = local_cc;\n            piVar24 = (int *)((int)local_138 - (int)local_f0);\n            piVar27 = local_d0;\n          }\n        }\n        piVar16 = local_160;\n        puVar29 = local_16c;\n        if (-1 < (int)piVar22) {\n          piVar24 = (int *)((int)piVar24 - (int)piVar22);\n        }\n        if (0 < (int)piVar24) {\n          for (; local_d0 = piVar27, 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar16,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n            piVar27 = local_d0;\n          }\n          goto LAB_08007014;\n        }\n      }\n    }\n    else {\n      local_d4 = (int *)((int)local_d4 + 1);\n      local_d0 = (int *)((int)piVar27 + 1);\n      *ppiVar2 = (int *)&DAT_08009f4c;\n      ppiVar2[1] = (int *)0x1;\n      if ((int)local_d4 < 8) {\n        ppiVar2 = ppiVar2 + 2;\n      }\n      else {\n        iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        ppiVar2 = local_cc;\n      }\n      if (((int)local_f0 < (int)local_138) || (piVar27 = local_d0, ((uint)piVar25 & 1) != 0)) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = (int *)((int)local_d0 + (int)local_118);\n        *ppiVar2 = local_114;\n        ppiVar2[1] = local_118;\n        if ((int)local_d4 < 8) {\n          ppiVar2 = ppiVar2 + 2;\n        }\n        else {\n          iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8);\n          if (iVar3 != 0) goto LAB_0800603e;\n          ppiVar2 = local_cc;\n        }\n        piVar22 = local_160;\n        puVar29 = local_16c;\n        piVar24 = (int *)((int)local_138 + -1);\n        piVar27 = local_d0;\n        if (0 < (int)piVar24) {\n          for (; 0x10 < (int)piVar24; piVar24 = piVar24 + -4) {\n            local_d4 = (int *)((int)local_d4 + 1);\n            local_d0 = local_d0 + 4;\n            *ppiVar2 = (int *)0x8009f60;\n            ppiVar2[1] = (int *)0x10;\n            if ((int)local_d4 < 8) {\n              ppiVar2 = ppiVar2 + 2;\n            }\n            else {\n              iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar22,&local_d8);\n              if (iVar3 != 0) goto LAB_0800603e;\n              ppiVar2 = local_cc;\n            }\n          }\nLAB_08007014:\n          local_d0 = (int *)((int)local_d0 + (int)piVar24);\n          *ppiVar2 = (int *)0x8009f60;\n          ppiVar2[1] = piVar24;\njoined_r0x08006a1c:\n          local_d4 = (int *)((int)local_d4 + 1);\n          if (7 < (int)local_d4) goto LAB_08006a20;\n          goto LAB_0800640e;\n        }\n      }\n    }\n  }\n  piVar24 = local_160;\n  puVar29 = local_16c;\n  if ((((uint)piVar25 & 4) != 0) &&\n     (piVar25 = (int *)((int)local_15c - (int)local_168), 0 < (int)piVar25)) {\n    for (; local_d0 = piVar27, 0x10 < (int)piVar25; piVar25 = piVar25 + -4) {\n      while( true ) {\n        local_d4 = (int *)((int)local_d4 + 1);\n        local_d0 = local_d0 + 4;\n        *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n        ppiVar2[1] = (int *)0x10;\n        if ((int)local_d4 < 8) break;\n        iVar3 = copy_and_allocate_memory_080097cc(puVar29,piVar24,&local_d8);\n        if (iVar3 != 0) goto LAB_0800603e;\n        piVar25 = piVar25 + -4;\n        ppiVar2 = local_cc;\n        if ((int)piVar25 < 0x11) goto LAB_0800647a;\n      }\n      ppiVar2 = ppiVar2 + 2;\n      piVar27 = local_d0;\n    }\nLAB_0800647a:\n    local_d4 = (int *)((int)local_d4 + 1);\n    local_d0 = (int *)((int)local_d0 + (int)piVar25);\n    *ppiVar2 = (int *)\"                0000000000000000Infinity\";\n    ppiVar2[1] = piVar25;\n    piVar27 = local_d0;\n    if ((7 < (int)local_d4) &&\n       (iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8), piVar27 = local_d0, iVar3 != 0))\n    goto LAB_0800603e;\n  }\n  piVar24 = local_15c;\n  if ((int)local_15c < (int)local_168) {\n    piVar24 = local_168;\n  }\n  local_164 = local_164 + (int)piVar24;\n  if ((piVar27 == (int *)0x0) || (iVar3 = copy_and_allocate_memory_080097cc(local_16c,local_160,&local_d8), iVar3 == 0))\n  {\n    local_d4 = (int *)0x0;\n    if (local_148 != (int *)0x0) {\n      initialize_and_allocate_memory_080088ec(local_16c,local_148);\n    }\n    ppiVar2 = local_cc;\nLAB_0800620e:\n    bVar1 = *(byte *)piVar28;\n    param_3 = piVar28;\n    goto joined_r0x08005ef2;\n  }\nLAB_0800603e:\n  if (local_148 != (int *)0x0) {\n    initialize_and_allocate_memory_080088ec(local_16c,local_148);\n  }\n  goto LAB_0800604a;\nswitchD_08005f58_caseD_31:\n  local_15c = (int *)0x0;\n  piVar16 = piVar24 + -0xc;\n  piVar22 = piVar28;\n  do {\n    piVar28 = (int *)((int)piVar22 + 1);\n    piVar24 = (int *)(uint)*(byte *)piVar22;\n    local_15c = (int *)((int)piVar16 + (int)local_15c * 10);\n    piVar16 = piVar24 + -0xc;\n    piVar22 = piVar28;\n  } while (piVar16 < (int *)0xa);\n  goto LAB_08005f4e;\nswitchD_08005f58_caseD_20:\n  piVar24 = (int *)(uint)*(byte *)piVar28;\n  if (local_f5 == 0) {\n    local_f5 = 0x20;\n  }\n  goto LAB_08005f4a;\n}\n\n",
            "renaming": {
                "FUN_08005e9c": "FUNC_08005e9c"
            },
            "calling": [
                "FUN_08005dfc"
            ],
            "called": [
                "FUN_080004c8",
                "FUN_08005e40",
                "FUN_0800119c",
                "FUN_080011ec",
                "FUN_080009c0",
                "FUN_08008ad4",
                "FUN_080003f4",
                "FUN_08000998",
                "FUN_08001170",
                "FUN_08008af8",
                "FUN_08000158",
                "FUN_08009768",
                "FUN_080009e8",
                "FUN_0800901c",
                "FUN_080009ac",
                "FUN_080097cc",
                "FUN_080096e0",
                "FUN_080088ec",
                "FUN_080079e8"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078a0": {
            "entrypoint": "0x080078a0",
            "current_name": "FUNC_080078a0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x080078a4) */\n\nvoid FUNC_080078a0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_080078a0": "FUNC_080078a0"
            },
            "calling": [
                "FUN_08005d20"
            ],
            "called": [
                "FUN_080098c0"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_080078c0": {
            "entrypoint": "0x080078c0",
            "current_name": "calculate_division_080078c0",
            "code": "\nuint calculateDivision_080078c0(int inputArray1,int inputArray2)\n\n{\n  uint quotient;\n  uint *ptrArray1;\n  int carry;\n  int length;\n  int index;\n  uint result;\n  uint *ptrArray2;\n  uint *ptrArray3;\n  uint *ptrArray4;\n  uint tmpQuotient;\n  uint *ptrIter1;\n  uint *ptrIter2;\n  \n  length = *(int *)(inputArray2 + 0x10);\n  if (*(int *)(inputArray1 + 0x10) < length) {\n    return 0;\n  }\n  index = length + -1;\n  ptrArray2 = (uint *)(inputArray2 + 0x14);\n  ptrArray3 = (uint *)(inputArray1 + 0x14);\n  result = ptrArray3[index] / (ptrArray2[index] + 1);\n  ptrArray4 = ptrArray2 + index;\n  if (result != 0) {\n    quotient = 0;\n    carry = 0;\n    ptrArray1 = ptrArray3;\n    ptrIter1 = ptrArray2;\n    do {\n      ptrIter2 = ptrIter1 + 1;\n      quotient = result * (*ptrIter1 & 0xffff) + quotient;\n      tmpQuotient = result * (*ptrIter1 >> 0x10) + (quotient >> 0x10);\n      quotient = (carry - (quotient & 0xffff)) + (*ptrArray1 & 0xffff);\n      carry = ((*ptrArray1 >> 0x10) - (tmpQuotient & 0xffff)) + ((int)quotient >> 0x10);\n      *ptrArray1 = quotient & 0xffff | carry * 0x10000;\n      carry = carry >> 0x10;\n      quotient = tmpQuotient >> 0x10;\n      ptrArray1 = ptrArray1 + 1;\n      ptrIter1 = ptrIter2;\n    } while (ptrIter2 <= ptrArray4);\n    if (ptrArray3[index] == 0) {\n      if ((ptrArray3 < ptrArray3 + length + -2) && (ptrArray3[length + -2] == 0)) {\n        ptrArray1 = ptrArray3 + length + -3;\n        do {\n          index = index + -1;\n          if (ptrArray1 <= ptrArray3) break;\n          quotient = *ptrArray1;\n          ptrArray1 = ptrArray1 + -1;\n        } while (quotient == 0);\n      }\n      *(int *)(inputArray1 + 0x10) = index;\n    }\n  }\n  length = compare_arrays_080094f8();\n  if (-1 < length) {\n    length = 0;\n    result = result + 1;\n    ptrArray1 = ptrArray3;\n    do {\n      ptrIter1 = ptrArray2 + 1;\n      quotient = (length - (*ptrArray2 & 0xffff)) + (*ptrArray1 & 0xffff);\n      length = ((*ptrArray1 >> 0x10) - (*ptrArray2 >> 0x10)) + ((int)quotient >> 0x10);\n      *ptrArray1 = quotient & 0xffff | length * 0x10000;\n      length = length >> 0x10;\n      ptrArray1 = ptrArray1 + 1;\n      ptrArray2 = ptrIter1;\n    } while (ptrIter1 <= ptrArray4);\n    if (ptrArray3[index] == 0) {\n      if ((ptrArray3 < ptrArray3 + index + -1) && (ptrArray3[index + -1] == 0)) {\n        ptrArray2 = ptrArray3 + index + -2;\n        do {\n          index = index + -1;\n          if (ptrArray2 <= ptrArray3) break;\n          quotient = *ptrArray2;\n          ptrArray2 = ptrArray2 + -1;\n        } while (quotient == 0);\n      }\n      *(int *)(inputArray1 + 0x10) = index;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_080078c0": "calculate_division_080078c0",
                "param_1": "inputArray1",
                "param_2": "inputArray2",
                "uVar1": "quotient",
                "puVar2": "ptrArray1",
                "iVar3": "carry",
                "iVar4": "length",
                "iVar5": "index",
                "uVar6": "result",
                "puVar7": "ptrArray2",
                "puVar8": "ptrArray3",
                "puVar9": "ptrArray4",
                "uVar10": "tmpQuotient",
                "puVar11": "ptrIter1",
                "puVar12": "ptrIter2"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080094f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080079e8": {
            "entrypoint": "0x080079e8",
            "current_name": "convert_unsigned_int_to_string_080079e8",
            "code": "\nchar * convertUnsignedIntToString_080079e8(int number,undefined4 param1,uint highBits,uint signedBits,uint numBits,\n                   uint scaleDivisor,int *numDigits,uint *isNegative,char **outputString)\n\n{\n  bool isInfinity;\n  bool isRounded;\n  bool isDivisorLessThan1;\n  char charValue;\n  byte byteValue;\n  undefined4 bitValue;\n  int i;\n  int j;\n  int index;\n  char *result;\n  uint temp;\n  undefined4 funcReturn;\n  undefined4 bitMask;\n  int numEntries;\n  int divisor;\n  undefined4 uVar16;\n  uint uVar17;\n  uint uVar18;\n  int divisorBits;\n  char *pcVar20;\n  char *pcVar21;\n  undefined4 *puVar22;\n  undefined4 uVar23;\n  int tempValue;\n  bool isNegativeSignedBits;\n  undefined8 combinedValue;\n  undefined8 adjustedValue;\n  undefined8 tempValue;\n  uint currentEntry;\n  uint signedInput;\n  uint highBitsMask;\n  int shiftedBits;\n  uint scaleExponent;\n  int tempExponent;\n  int exponentDifference;\n  uint highBitsExponent;\n  uint exponentRatio;\n  uint uStack_44;\n  uint shiftAmount;\n  uint tempBits;\n  int tempDivisor;\n  int bitsList [2];\n  \n  numEntries = *(int *)(number + 0x40);\n  if (numEntries != 0) {\n    uVar18 = *(uint *)(number + 0x44);\n    *(uint *)(numEntries + 4) = uVar18;\n    *(int *)(numEntries + 8) = 1 << (uVar18 & 0xff);\n    extract_and_swap_0800910c(number,numEntries);\n    *(undefined4 *)(number + 0x40) = 0;\n  }\n  isNegativeSignedBits = (int)signedBits < 0;\n  uVar18 = signedBits;\n  if (isNegativeSignedBits) {\n    uVar18 = signedBits & 0x7fffffff;\n  }\n  *isNegative = (uint)isNegativeSignedBits;\n  signedInput = signedBits;\n  if (isNegativeSignedBits) {\n    signedInput = uVar18;\n  }\n  uVar17 = signedInput;\n  if ((~uVar18 & 0x7ff00000) == 0) {\n    *numDigits = 9999;\n    if ((highBits == 0) && ((uVar18 & 0xfffff) == 0)) {\n      result = \"Infinity\";\n      if (outputString == (char **)0x0) {\n        return result;\n      }\n      pcVar21 = \"\";\n    }\n    else {\n      result = \"NaN\";\n      if (outputString == (char **)0x0) {\n        return result;\n      }\n      pcVar21 = \"\";\n    }\n    *outputString = pcVar21;\n    return result;\n  }\n  combinedValue = check_conditions_08000998(highBits,signedInput,0,0);\n  if ((int)combinedValue != 0) {\n    *numDigits = 1;\n    if (outputString != (char **)0x0) {\n      *outputString = \"\";\n      return \"0\";\n    }\n    return \"0\";\n  }\n  bitValue = reorder_bits_and_count_08009630(number,(int)((ulonglong)combinedValue >> 0x20),highBits,signedInput,bitsList,&tempDivisor)\n  ;\n  numEntries = tempDivisor;\n  if (uVar18 >> 0x14 == 0) {\n    divisorBits = bitsList[0] + tempDivisor;\n    divisor = divisorBits + 0x432;\n    if (divisor < 0x21) {\n      uVar18 = highBits << (0x20U - divisor & 0xff);\n    }\n    else {\n      uVar18 = highBits >> (divisorBits + 0x412U & 0xff) | uVar18 << (0x40U - divisor & 0xff);\n    }\n    combinedValue = revised_function_080003d4(uVar18);\n    divisorBits = divisorBits + -1;\n    isNegativeSignedBits = true;\n    temp = (int)((ulonglong)combinedValue >> 0x20) + 0xfe100000;\n    uVar18 = (uint)combinedValue;\n  }\n  else {\n    divisorBits = (uVar18 >> 0x14) - 0x3ff;\n    temp = signedInput & 0xfffff | 0x3ff00000;\n    isNegativeSignedBits = false;\n    uVar18 = highBits;\n  }\n  combinedValue = unsigned_long_long_binary_operation_08000158(uVar18,temp,0,0x3ff80000);\n  combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0x636f4361,0x3fd287a7);\n  combinedValue = calculate_result_0800015c((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0x8b60c8b3,0x3fc68a28);\n  adjustedValue = shift_and_adjust_080003f4(divisorBits);\n  adjustedValue = calculate_product_and_addition_080004c8((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),0x509f79fb,0x3fd34413);\n  combinedValue = calculate_result_0800015c((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),(int)adjustedValue,\n                        (int)((ulonglong)adjustedValue >> 0x20));\n  bitMask = (undefined4)((ulonglong)combinedValue >> 0x20);\n  highBitsMask = calculate_modified_value_0800119c();\n  divisor = check_condition_080009ac((int)combinedValue,bitMask,0,0);\n  if (divisor != 0) {\n    adjustedValue = shift_and_adjust_080003f4(highBitsMask);\n    divisor = check_conditions_08000998((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),(int)combinedValue,bitMask);\n    if (divisor == 0) {\n      highBitsMask = highBitsMask - 1;\n    }\n  }\n  if (highBitsMask < 0x17) {\n    divisor = check_evaluation_result_080009e8(*(undefined4 *)(&DAT_08009fa8 + highBitsMask * 8),\n                          *(undefined4 *)(&DAT_08009fac + highBitsMask * 8),highBits,signedInput);\n    if (divisor == 0) {\n      isRounded = false;\n    }\n    else {\n      highBitsMask = highBitsMask - 1;\n      isRounded = false;\n    }\n  }\n  else {\n    isRounded = true;\n  }\n  divisor = (numEntries - divisorBits) + -1;\n  if (divisor < 0) {\n    shiftedBits = 1 - (numEntries - divisorBits);\n    divisor = 0;\n  }\n  else {\n    shiftedBits = 0;\n  }\n  if ((int)highBitsMask < 0) {\n    highBitsExponent = 0;\n    shiftedBits = shiftedBits - highBitsMask;\n    exponentDifference = -highBitsMask;\n  }\n  else {\n    divisor = divisor + highBitsMask;\n    highBitsExponent = highBitsMask;\n    exponentDifference = 0;\n  }\n  if (9 < numBits) {\n    shiftAmount = 0xffffffff;\n    isInfinity = true;\n    scaleExponent = 0xffffffff;\n    isDivisorLessThan1 = true;\n    numBits = 0;\n    scaleDivisor = 0;\n    goto LAB_08007c24;\n  }\n  isInfinity = (int)numBits < 6;\n  if (!isInfinity) {\n    numBits = numBits - 4;\n  }\n  switch(numBits) {\n  case 2:\n    isDivisorLessThan1 = false;\n    break;\n  case 3:\n    isDivisorLessThan1 = false;\n    goto LAB_08008300;\n  case 4:\n    isDivisorLessThan1 = true;\n    break;\n  case 5:\n    isDivisorLessThan1 = true;\nLAB_08008300:\n    shiftAmount = highBitsMask + scaleDivisor;\n    scaleExponent = shiftAmount + 1;\n    uVar18 = scaleExponent;\n    if ((int)scaleExponent < 1) {\n      uVar18 = 1;\n    }\n    goto LAB_08008314;\n  default:\n    *(undefined4 *)(number + 0x44) = 0;\n    result = (char *)initialize_or_get_entry_080090c0(number,0);\n    shiftAmount = 0xffffffff;\n    scaleExponent = 0xffffffff;\n    scaleDivisor = 0;\n    *(char **)(number + 0x40) = result;\n    isDivisorLessThan1 = true;\n    goto LAB_08007e36;\n  }\n  if ((int)scaleDivisor < 1) {\n    shiftAmount = 1;\n    scaleDivisor = 1;\n    scaleExponent = 1;\nLAB_08007c24:\n    *(undefined4 *)(number + 0x44) = 0;\n    temp = shiftAmount;\n  }\n  else {\n    shiftAmount = scaleDivisor;\n    scaleExponent = scaleDivisor;\n    uVar18 = scaleDivisor;\nLAB_08008314:\n    *(undefined4 *)(number + 0x44) = 0;\n    temp = scaleExponent;\n    if (0x17 < (int)uVar18) {\n      divisorBits = 4;\n      numEntries = 1;\n      do {\n        i = numEntries;\n        divisorBits = divisorBits * 2;\n        numEntries = i + 1;\n      } while (divisorBits + 0x14U <= uVar18);\n      *(int *)(number + 0x44) = i;\n    }\n  }\n  result = (char *)initialize_or_get_entry_080090c0(number);\n  *(char **)(number + 0x40) = result;\n  if ((temp < 0xf) && (isInfinity)) {\n    if ((int)highBitsMask < 1) {\n      if (highBitsMask == 0) {\n        numEntries = 2;\n        currentEntry = highBits;\n      }\n      else {\n        numEntries = (-highBitsMask & 0xf) * 8;\n        combinedValue = calculate_product_and_addition_080004c8(highBits,signedInput,*(undefined4 *)(&DAT_08009fa8 + numEntries),\n                              *(undefined4 *)(&DAT_08009fac + numEntries));\n        signedInput = (uint)((ulonglong)combinedValue >> 0x20);\n        currentEntry = (uint)combinedValue;\n        divisorBits = (int)-highBitsMask >> 4;\n        if (divisorBits == 0) {\n          numEntries = 2;\n        }\n        else {\n          isInfinity = false;\n          numEntries = 2;\n          puVar22 = &DAT_08009f80;\n          do {\n            if (divisorBits << 0x1f < 0) {\n              combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),*puVar22,puVar22[1]\n                                   );\n              isInfinity = true;\n              numEntries = numEntries + 1;\n            }\n            divisorBits = divisorBits >> 1;\n            puVar22 = puVar22 + 2;\n          } while (divisorBits != 0);\n          if (isInfinity) {\n            currentEntry = (uint)combinedValue;\n            signedInput = (uint)((ulonglong)combinedValue >> 0x20);\n          }\n        }\n      }\n    }\n    else {\n      uVar18 = (int)highBitsMask >> 4;\n      adjustedValue = *(undefined8 *)(&DAT_08009fa8 + (highBitsMask & 0xf) * 8);\n      combinedValue = *(undefined8 *)(&DAT_08009fa8 + (highBitsMask & 0xf) * 8);\n      if ((int)(uVar18 << 0x1b) < 0) {\n        tempValue = convert_value_to_double_0800071c(highBits,signedInput,0x7f73bf3c,0x75154fdd);\n        uStack_44 = (uint)((ulonglong)tempValue >> 0x20);\n        exponentRatio = (uint)tempValue;\n        numEntries = 3;\n        uVar18 = uVar18 & 0xf;\n      }\n      else {\n        numEntries = 2;\n        uStack_44 = signedInput;\n        exponentRatio = highBits;\n      }\n      if (uVar18 != 0) {\n        puVar22 = &DAT_08009f80;\n        do {\n          if ((int)(uVar18 << 0x1f) < 0) {\n            combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),*puVar22,puVar22[1]);\n            numEntries = numEntries + 1;\n          }\n          uVar18 = (int)uVar18 >> 1;\n          puVar22 = puVar22 + 2;\n          adjustedValue = combinedValue;\n        } while (uVar18 != 0);\n      }\n      signedInput = (uint)((ulonglong)adjustedValue >> 0x20);\n      currentEntry = (uint)adjustedValue;\n      combinedValue = convert_value_to_double_0800071c(exponentRatio,uStack_44,currentEntry,signedInput);\n      currentEntry = (uint)combinedValue;\n      signedInput = (uint)((ulonglong)combinedValue >> 0x20);\n    }\n    combinedValue = CONCAT44(signedInput,currentEntry);\n    if ((isRounded) && (divisorBits = check_condition_080009ac(currentEntry,signedInput,0,0x3ff00000), divisorBits != 0)) {\n      if (scaleExponent == 0) {\n        combinedValue = shift_and_adjust_080003f4(numEntries);\n        combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),currentEntry,signedInput);\n        combinedValue = calculate_result_0800015c((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0,0x401c0000);\n        bitMask = (undefined4)combinedValue;\n        numEntries = (int)((ulonglong)combinedValue >> 0x20) + -0x3400000;\n        goto LAB_0800852e;\n      }\n      if (0 < (int)shiftAmount) {\n        combinedValue = calculate_product_and_addition_080004c8(currentEntry,signedInput,0,0x40240000);\n        adjustedValue = shift_and_adjust_080003f4(numEntries + 1);\n        adjustedValue = calculate_product_and_addition_080004c8((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),(int)combinedValue,\n                              (int)((ulonglong)combinedValue >> 0x20));\n        adjustedValue = calculate_result_0800015c((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),0,0x401c0000);\n        bitMask = (undefined4)adjustedValue;\n        exponentRatio = shiftAmount;\n        tempBits = highBitsMask - 1;\n        numEntries = (int)((ulonglong)adjustedValue >> 0x20) + -0x3400000;\n        goto LAB_08007cfa;\n      }\n      goto LAB_08007e36;\n    }\n    adjustedValue = shift_and_adjust_080003f4(numEntries);\n    adjustedValue = calculate_product_and_addition_080004c8((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),currentEntry,signedInput);\n    adjustedValue = calculate_result_0800015c((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),0,0x401c0000);\n    bitMask = (undefined4)adjustedValue;\n    numEntries = (int)((ulonglong)adjustedValue >> 0x20) + -0x3400000;\n    if (scaleExponent != 0) {\n      tempBits = highBitsMask;\n      exponentRatio = scaleExponent;\nLAB_08007cfa:\n      signedInput = (uint)((ulonglong)combinedValue >> 0x20);\n      currentEntry = (uint)combinedValue;\n      charValue = calculate_modified_value_0800119c(currentEntry,signedInput);\n      charValue = charValue + '0';\n      uVar16 = (&DAT_08009fa0)[exponentRatio * 2];\n      funcReturn = (&DAT_08009fa4)[exponentRatio * 2];\n      combinedValue = shift_and_adjust_080003f4();\n      combinedValue = unsigned_long_long_binary_operation_08000158(currentEntry,signedInput,(int)combinedValue,(int)((ulonglong)combinedValue >> 0x20));\n      uVar23 = (undefined4)((ulonglong)combinedValue >> 0x20);\n      pcVar21 = result + 1;\n      if (isDivisorLessThan1) {\n        adjustedValue = convert_value_to_double_0800071c(0,0x3fe00000,uVar16,funcReturn);\n        adjustedValue = unsigned_long_long_binary_operation_08000158((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),bitMask,numEntries);\n        bitMask = (undefined4)((ulonglong)adjustedValue >> 0x20);\n        *result = charValue;\n        numEntries = check_evaluation_result_080009e8((int)adjustedValue,bitMask,(int)combinedValue,uVar23);\n        if (numEntries != 0) {\nLAB_08008784:\n          highBitsMask = tempBits;\n          goto LAB_08008294;\n        }\n        tempValue = unsigned_long_long_binary_operation_08000158(0,0x3ff00000,(int)combinedValue,uVar23);\n        numEntries = check_evaluation_result_080009e8((int)adjustedValue,bitMask,(int)tempValue,(int)((ulonglong)tempValue >> 0x20));\n        if (numEntries == 0) {\n          if (exponentRatio != 1) {\n            pcVar20 = pcVar21;\n            do {\n              adjustedValue = calculate_product_and_addition_080004c8((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),0,0x40240000);\n              bitMask = (undefined4)((ulonglong)adjustedValue >> 0x20);\n              combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0,0x40240000);\n              charValue = calculate_modified_value_0800119c();\n              tempValue = shift_and_adjust_080003f4();\n              combinedValue = unsigned_long_long_binary_operation_08000158((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),(int)tempValue,\n                                    (int)((ulonglong)tempValue >> 0x20));\n              uVar16 = (undefined4)((ulonglong)combinedValue >> 0x20);\n              charValue = charValue + '0';\n              pcVar21 = pcVar20 + 1;\n              *pcVar20 = charValue;\n              numEntries = check_condition_080009ac((int)combinedValue,uVar16,(int)adjustedValue,bitMask);\n              if (numEntries != 0) {\n                highBitsMask = tempBits;\n                goto LAB_08008294;\n              }\n              tempValue = unsigned_long_long_binary_operation_08000158(0,0x3ff00000,(int)combinedValue,uVar16);\n              numEntries = check_condition_080009ac((int)tempValue,(int)((ulonglong)tempValue >> 0x20),(int)adjustedValue,bitMask)\n              ;\n              if (numEntries != 0) goto LAB_08008798;\n              pcVar20 = pcVar21;\n            } while (pcVar21 != result + exponentRatio);\n          }\n          goto LAB_08007e36;\n        }\nLAB_08008798:\n        highBitsMask = tempBits;\n      }\n      else {\n        adjustedValue = calculate_product_and_addition_080004c8(bitMask,numEntries,uVar16,funcReturn);\n        bitMask = (undefined4)((ulonglong)adjustedValue >> 0x20);\n        *result = charValue;\n        if (exponentRatio != 1) {\n          pcVar20 = pcVar21;\n          do {\n            combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0,0x40240000);\n            charValue = calculate_modified_value_0800119c();\n            tempValue = shift_and_adjust_080003f4();\n            combinedValue = unsigned_long_long_binary_operation_08000158((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),(int)tempValue,\n                                  (int)((ulonglong)tempValue >> 0x20));\n            pcVar21 = pcVar20 + 1;\n            *pcVar20 = charValue + '0';\n            pcVar20 = pcVar21;\n          } while (pcVar21 != result + exponentRatio);\n        }\n        uVar16 = (undefined4)((ulonglong)combinedValue >> 0x20);\n        tempValue = calculate_result_0800015c((int)adjustedValue,bitMask,0,0x3fe00000);\n        numEntries = check_condition_080009ac((int)tempValue,(int)((ulonglong)tempValue >> 0x20),(int)combinedValue,uVar16);\n        if (numEntries == 0) {\n          adjustedValue = unsigned_long_long_binary_operation_08000158(0,0x3fe00000,(int)adjustedValue,bitMask);\n          numEntries = check_evaluation_result_080009e8((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),(int)combinedValue,uVar16);\n          pcVar20 = pcVar21;\n          if (numEntries == 0) goto LAB_08007e36;\n          do {\n            pcVar21 = pcVar20;\n            pcVar20 = pcVar21 + -1;\n          } while (pcVar21[-1] == '0');\n          goto LAB_08008784;\n        }\n        highBitsMask = tempBits;\n        charValue = pcVar21[-1];\n      }\n      goto LAB_08007f7c;\n    }\nLAB_0800852e:\n    combinedValue = unsigned_long_long_binary_operation_08000158(currentEntry,signedInput,0,0x40140000);\n    uVar16 = (undefined4)((ulonglong)combinedValue >> 0x20);\n    divisorBits = check_evaluation_result_080009e8((int)combinedValue,uVar16,bitMask,numEntries);\n    if (divisorBits == 0) {\n      numEntries = check_condition_080009ac((int)combinedValue,uVar16,bitMask,numEntries + -0x80000000);\n      if (numEntries == 0) goto LAB_08007e36;\n      divisorBits = 0;\n      numEntries = 0;\n      pcVar21 = result;\n      goto LAB_080084f0;\n    }\n    divisor = 0;\n    i = 0;\nLAB_08008406:\n    *result = '1';\n    highBitsMask = highBitsMask + 1;\n    pcVar21 = result + 1;\n    divisorBits = i;\n    numEntries = divisor;\nLAB_08008416:\n    extract_and_swap_0800910c(number,numEntries);\n    if (divisorBits == 0) goto LAB_08008294;\n  }\n  else {\nLAB_08007e36:\n    pcVar21 = result;\n    if ((-1 < bitsList[0]) && ((int)highBitsMask < 0xf)) {\n      bitMask = *(undefined4 *)(&DAT_08009fa8 + highBitsMask * 8);\n      uVar16 = *(undefined4 *)(&DAT_08009fac + highBitsMask * 8);\n      if ((-1 < (int)scaleDivisor) || (0 < (int)scaleExponent)) {\n        convert_value_to_double_0800071c(highBits,uVar17,bitMask,uVar16);\n        byteValue = calculate_modified_value_0800119c();\n        combinedValue = shift_and_adjust_080003f4();\n        combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),bitMask,uVar16);\n        combinedValue = unsigned_long_long_binary_operation_08000158(highBits,uVar17,(int)combinedValue,(int)((ulonglong)combinedValue >> 0x20));\n        *result = byteValue + 0x30;\n        pcVar21 = result + 1;\n        if (scaleExponent != 1) {\n          combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0,0x40240000);\n          numEntries = check_conditions_08000998((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0,0);\n          while (numEntries == 0) {\n            uVar23 = (undefined4)((ulonglong)combinedValue >> 0x20);\n            convert_value_to_double_0800071c((int)combinedValue,uVar23,bitMask,uVar16);\n            byteValue = calculate_modified_value_0800119c();\n            adjustedValue = shift_and_adjust_080003f4();\n            adjustedValue = calculate_product_and_addition_080004c8((int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20),bitMask,uVar16);\n            combinedValue = unsigned_long_long_binary_operation_08000158((int)combinedValue,uVar23,(int)adjustedValue,(int)((ulonglong)adjustedValue >> 0x20));\n            pcVar20 = pcVar21 + 1;\n            *pcVar21 = byteValue + 0x30;\n            pcVar21 = pcVar20;\n            if (scaleExponent == (int)pcVar20 - (int)result) goto LAB_08007f3a;\n            combinedValue = calculate_product_and_addition_080004c8((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0,0x40240000);\n            numEntries = check_conditions_08000998((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),0,0);\n          }\n          goto LAB_08008294;\n        }\nLAB_08007f3a:\n        combinedValue = calculate_result_0800015c((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20));\n        uVar23 = (undefined4)((ulonglong)combinedValue >> 0x20);\n        numEntries = check_evaluation_result_080009e8((int)combinedValue,uVar23,bitMask,uVar16);\n        if ((numEntries == 0) &&\n           ((numEntries = check_conditions_08000998((int)combinedValue,uVar23,bitMask,uVar16), numEntries == 0 ||\n            ((byteValue & 1) == 0)))) goto LAB_08008294;\n        charValue = pcVar21[-1];\nLAB_08007f7c:\n        while (pcVar20 = pcVar21 + -1, charValue == '9') {\n          if (result == pcVar20) {\n            *result = '0';\n            charValue = pcVar21[-1];\n            highBitsMask = highBitsMask + 1;\n            pcVar20 = result;\n            break;\n          }\n          charValue = pcVar21[-2];\n          pcVar21 = pcVar20;\n        }\n        *pcVar20 = charValue + '\\x01';\n        goto LAB_08008294;\n      }\n      if (scaleExponent == 0) {\n        combinedValue = calculate_product_and_addition_080004c8(bitMask,uVar16,0,0x40140000);\n        index = is_condition_evaluated_080009d4((int)combinedValue,(int)((ulonglong)combinedValue >> 0x20),highBits,uVar17);\n        divisorBits = 0;\n        divisor = 0;\n        i = 0;\n        numEntries = 0;\n        if (index == 0) goto LAB_08008406;\n      }\n      else {\n        divisorBits = 0;\n        numEntries = 0;\n      }\nLAB_080084f0:\n      highBitsMask = ~scaleDivisor;\n      result = pcVar21;\n      goto LAB_08008416;\n    }\n    numEntries = exponentDifference;\n    if (isDivisorLessThan1) {\n      if ((int)numBits < 2) {\n        if (isNegativeSignedBits) {\n          tempExponent = shiftedBits;\n          shiftedBits = shiftedBits + bitsList[0] + 0x433;\n          divisor = divisor + bitsList[0] + 0x433;\n        }\n        else {\n          tempExponent = shiftedBits;\n          shiftedBits = shiftedBits + (0x36 - tempDivisor);\n          divisor = divisor + (0x36 - tempDivisor);\n        }\n      }\n      else {\n        divisorBits = scaleExponent - 1;\n        if (exponentDifference < divisorBits) {\n          highBitsExponent = highBitsExponent + (divisorBits - exponentDifference);\n          numEntries = 0;\n          exponentDifference = divisorBits;\n        }\n        else {\n          numEntries = exponentDifference - divisorBits;\n        }\n        if ((int)scaleExponent < 0) {\n          tempExponent = shiftedBits - scaleExponent;\n        }\n        else {\n          divisor = divisor + scaleExponent;\n          tempExponent = shiftedBits;\n          shiftedBits = shiftedBits + scaleExponent;\n        }\n      }\n      divisorBits = initialize_entry_08009244(number,1);\n    }\n    else {\n      tempExponent = shiftedBits;\n      divisorBits = 0;\n    }\n    if ((0 < tempExponent) && (0 < divisor)) {\n      i = tempExponent;\n      if (divisor <= tempExponent) {\n        i = divisor;\n      }\n      divisor = divisor - i;\n      shiftedBits = shiftedBits - i;\n      tempExponent = tempExponent - i;\n    }\n    if (exponentDifference != 0) {\n      if (isDivisorLessThan1) {\n        bitMask = bitValue;\n        if (numEntries != 0) {\n          divisorBits = reverse_and_update_array_080093a4(number,divisorBits,numEntries);\n          bitMask = initialize_and_fill_entries_08009258(number,divisorBits,bitValue);\n          extract_and_swap_0800910c(number,bitValue);\n          bitValue = bitMask;\n          if (exponentDifference - numEntries == 0) goto LAB_08008062;\n        }\n        bitValue = reverse_and_update_array_080093a4(number,bitMask,exponentDifference - numEntries);\n      }\n      else {\n        bitValue = reverse_and_update_array_080093a4(number,bitValue,exponentDifference);\n      }\n    }\nLAB_08008062:\n    numEntries = initialize_entry_08009244(number,1);\n    if (highBitsExponent == 0) {\n      if (((int)numBits < 2) && (highBits == 0)) {\nLAB_0800835a:\n        if ((uVar17 & 0xfffff) == 0) {\n          uVar17 = uVar17 & 0x7ff00000;\n          if (uVar17 != 0) {\n            divisor = divisor + 1;\n            shiftedBits = shiftedBits + 1;\n            uVar17 = 1;\n          }\n        }\n        else {\n          uVar17 = 0;\n        }\n        isNegativeSignedBits = highBitsExponent != 0;\n        uVar18 = highBits;\n        highBitsExponent = uVar17;\n        if (isNegativeSignedBits) goto LAB_080082d4;\n      }\n      i = 1;\n    }\n    else {\n      combinedValue = reverse_and_update_array_080093a4(number,numEntries);\n      numEntries = (int)combinedValue;\n      if (((int)numBits < 2) && (highBits == 0)) goto LAB_0800835a;\n      highBitsExponent = 0;\n      uVar18 = (uint)((ulonglong)combinedValue >> 0x20);\nLAB_080082d4:\n      i = count_leading_zeros_080091a4(*(undefined4 *)(numEntries + *(int *)(numEntries + 0x10) * 4 + 0x10),uVar18);\n      i = 0x20 - i;\n    }\n    uVar18 = i + divisor & 0x1f;\n    if (uVar18 == 0) {\n      i = 0x1c;\nLAB_08008096:\n      divisor = divisor + i;\n      shiftedBits = shiftedBits + i;\n      tempExponent = tempExponent + i;\n    }\n    else {\n      if (4 < (int)(0x20 - uVar18)) {\n        i = 0x1c - uVar18;\n        goto LAB_08008096;\n      }\n      if (0x20 - uVar18 != 4) {\n        i = 0x3c - uVar18;\n        goto LAB_08008096;\n      }\n    }\n    if (0 < shiftedBits) {\n      bitValue = initialize_or_get_entry_08009444(number,bitValue,shiftedBits);\n    }\n    if (0 < divisor) {\n      numEntries = initialize_or_get_entry_08009444(number,numEntries,divisor);\n    }\n    pcVar20 = result;\n    if ((isRounded) && (divisor = compare_arrays_080094f8(bitValue,numEntries), divisor < 0)) {\n      highBitsMask = highBitsMask - 1;\n      bitValue = update_array_08009120(number,bitValue,10,0);\n      if (isDivisorLessThan1) {\n        divisorBits = update_array_08009120(number,divisorBits,10,0);\n        if ((0 < (int)shiftAmount) || ((int)numBits < 3)) {\n          scaleExponent = shiftAmount;\n          goto LAB_080080de;\n        }\n      }\n      else if ((0 < (int)shiftAmount) || ((int)numBits < 3)) {\n        scaleExponent = shiftAmount;\n        goto LAB_0800820a;\n      }\n      scaleExponent = shiftAmount;\nLAB_080084e8:\n      if (scaleExponent == 0) {\n        divisor = update_array_08009120(number,numEntries,5);\n        index = compare_arrays_080094f8(bitValue,divisor);\n        i = divisorBits;\n        numEntries = divisor;\n        if (0 < index) goto LAB_08008406;\n      }\n      goto LAB_080084f0;\n    }\n    if (((int)scaleExponent < 1) && (2 < (int)numBits)) goto LAB_080084e8;\n    if (isDivisorLessThan1) {\nLAB_080080de:\n      currentEntry = divisorBits;\n      if (0 < tempExponent) {\n        currentEntry = initialize_or_get_entry_08009444(number,divisorBits,tempExponent);\n      }\n      divisorBits = currentEntry;\n      if (highBitsExponent != 0) {\n        divisorBits = initialize_or_get_entry_080090c0(number,*(undefined4 *)(currentEntry + 4));\n        memcpy_aligned_08001084(divisorBits + 0xc,currentEntry + 0xc,(*(int *)(currentEntry + 0x10) + 2) * 4);\n        divisorBits = initialize_or_get_entry_08009444(number,divisorBits,1);\n      }\nLAB_08008108:\n      divisor = calculate_division_080078c0(bitValue,numEntries);\n      i = compare_arrays_080094f8(bitValue,currentEntry);\n      index = reverse_and_update_entries_08009530(number,numEntries,divisorBits);\n      tempValue = divisor + 0x30;\n      if (*(int *)(index + 0xc) == 0) {\n        j = compare_arrays_080094f8(bitValue);\n        extract_and_swap_0800910c(number,index);\n        if ((j != 0) || (numBits != 0)) goto LAB_0800815a;\n        if ((highBits & 1) != 0) {\n          j = 0;\n          goto LAB_0800815a;\n        }\n        if (tempValue != 0x39) {\n          if (0 < i) goto LAB_0800874c;\n          goto LAB_080085a4;\n        }\nLAB_08008752:\n        pcVar21 = pcVar20 + 1;\n        charValue = '9';\n        *pcVar20 = '9';\n        goto LAB_08008268;\n      }\n      extract_and_swap_0800910c(number,index);\n      j = 1;\nLAB_0800815a:\n      if ((i < 0) || (((i == 0 && (numBits == 0)) && ((highBits & 1) == 0)))) {\n        if (0 < j) {\n          bitValue = initialize_or_get_entry_08009444(number,bitValue,1);\n          i = compare_arrays_080094f8(bitValue,numEntries);\n          if ((0 < i) || ((i == 0 && (divisor << 0x1f < 0)))) {\n            if (tempValue == 0x39) goto LAB_08008752;\nLAB_0800874c:\n            tempValue = divisor + 0x31;\n          }\n        }\nLAB_080085a4:\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)tempValue;\n        goto LAB_08008274;\n      }\n      pcVar21 = pcVar20 + 1;\n      if (0 < j) {\n        if (tempValue == 0x39) goto LAB_08008752;\n        *pcVar20 = (char)divisor + '1';\n        goto LAB_08008274;\n      }\n      *pcVar20 = (char)tempValue;\n      if (result + (scaleExponent - 1) != pcVar20) {\n        bitValue = update_array_08009120(number,bitValue,10,0);\n        pcVar20 = pcVar21;\n        if (currentEntry == divisorBits) {\n          currentEntry = update_array_08009120(number,currentEntry,10,0);\n          divisorBits = currentEntry;\n        }\n        else {\n          currentEntry = update_array_08009120(number,currentEntry,10,0);\n          divisorBits = update_array_08009120(number,divisorBits,10,0);\n        }\n        goto LAB_08008108;\n      }\n    }\n    else {\nLAB_0800820a:\n      while( true ) {\n        tempValue = calculate_division_080078c0(bitValue,numEntries);\n        tempValue = tempValue + 0x30;\n        pcVar21 = pcVar20 + 1;\n        *pcVar20 = (char)tempValue;\n        if ((int)scaleExponent <= (int)pcVar21 - (int)result) break;\n        bitValue = update_array_08009120(number,bitValue,10,0);\n        pcVar20 = pcVar21;\n      }\n      currentEntry = 0;\n    }\n    bitValue = initialize_or_get_entry_08009444(number,bitValue,1);\n    divisor = compare_arrays_080094f8(bitValue,numEntries);\n    charValue = pcVar21[-1];\n    if ((0 < divisor) || ((divisor == 0 && (tempValue << 0x1f < 0)))) {\nLAB_08008268:\n      do {\n        pcVar20 = pcVar21 + -1;\n        if (charValue != '9') goto code_r0x08008270;\n        if (result == pcVar20) {\n          *result = '1';\n          highBitsMask = highBitsMask + 1;\n          goto LAB_08008274;\n        }\n        charValue = pcVar21[-2];\n        pcVar21 = pcVar20;\n      } while( true );\n    }\n    while (charValue == '0') {\n      charValue = pcVar21[-2];\n      pcVar21 = pcVar21 + -1;\n    }\nLAB_08008274:\n    extract_and_swap_0800910c(number,numEntries);\n    if (divisorBits == 0) goto LAB_08008294;\n    if ((currentEntry != 0) && (currentEntry != divisorBits)) {\n      extract_and_swap_0800910c(number);\n    }\n  }\n  extract_and_swap_0800910c(number,divisorBits);\nLAB_08008294:\n  extract_and_swap_0800910c(number,bitValue);\n  *pcVar21 = '\\0';\n  *numDigits = highBitsMask + 1;\n  if (outputString == (char **)0x0) {\n    return result;\n  }\n  *outputString = pcVar21;\n  return result;\ncode_r0x08008270:\n  *pcVar20 = charValue + '\\x01';\n  goto LAB_08008274;\n}\n\n",
            "renaming": {
                "FUN_080079e8": "convert_unsigned_int_to_string_080079e8",
                "param_1": "number",
                "param_2": "param1",
                "param_3": "highBits",
                "param_4": "signedBits",
                "param_5": "numBits",
                "param_6": "scaleDivisor",
                "param_7": "numDigits",
                "param_8": "isNegative",
                "param_9": "outputString",
                "bVar1": "isInfinity",
                "bVar2": "isRounded",
                "bVar3": "isDivisorLessThan1",
                "cVar4": "charValue",
                "bVar5": "byteValue",
                "uVar6": "bitValue",
                "iVar7": "i",
                "iVar8": "j",
                "iVar9": "index",
                "pcVar10": "result",
                "uVar11": "temp",
                "uVar12": "funcReturn",
                "uVar13": "bitMask",
                "iVar14": "numEntries",
                "iVar15": "divisor",
                "iVar19": "divisorBits",
                "iVar24": "tempValue",
                "bVar25": "isNegativeSignedBits",
                "uVar26": "combinedValue",
                "uVar27": "adjustedValue",
                "uVar28": "tempValue",
                "local_80": "currentEntry",
                "local_7c": "signedInput",
                "local_74": "highBitsMask",
                "local_70": "shiftedBits",
                "local_68": "scaleExponent",
                "local_60": "tempExponent",
                "local_5c": "exponentDifference",
                "local_58": "highBitsExponent",
                "local_48": "exponentRatio",
                "local_38": "shiftAmount",
                "local_34": "tempBits",
                "local_30": "tempDivisor",
                "local_2c": "bitsList"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_080009d4",
                "FUN_080004c8",
                "FUN_08009244",
                "FUN_08009530",
                "FUN_08009630",
                "FUN_0800119c",
                "FUN_080091a4",
                "FUN_080090c0",
                "FUN_0800015c",
                "FUN_080003f4",
                "FUN_08000998",
                "FUN_080094f8",
                "FUN_08000158",
                "FUN_08009120",
                "FUN_080009e8",
                "FUN_080093a4",
                "FUN_080078c0",
                "FUN_080003d4",
                "FUN_080009ac",
                "FUN_0800910c",
                "FUN_08001084",
                "FUN_08009258",
                "FUN_08009444",
                "FUN_0800071c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800884c": {
            "entrypoint": "0x0800884c",
            "current_name": "allocate_and_initialize_memory_0800884c",
            "code": "\nundefined4 allocate_and_initialize_memory_0800884c(undefined4 memory_buffer,int offset)\n\n{\n  int result;\n  int aligned_address;\n  uint data_size;\n  \n  initialize_data();\n  data_size = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  aligned_address = ((0xfef - offset) + data_size & 0xfffff000) - 0x1000;\n  if (0xfff < aligned_address) {\n    result = allocate_and_set_memory(memory_buffer,0);\n    if (result == DAT_20000454 + data_size) {\n      result = allocate_and_set_memory(memory_buffer,-aligned_address);\n      if (result != -1) {\n        DAT_20000a14 = DAT_20000a14 - aligned_address;\n        *(uint *)(DAT_20000454 + 4) = data_size - aligned_address | 1;\n        initialize_data_again(memory_buffer);\n        return 1;\n      }\n      aligned_address = allocate_and_set_memory(memory_buffer,0);\n      if (0xf < aligned_address - DAT_20000454) {\n        DAT_20000a14 = aligned_address - DAT_20000854;\n        *(uint *)(DAT_20000454 + 4) = aligned_address - DAT_20000454 | 1;\n      }\n    }\n  }\n  initialize_data_again(memory_buffer);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0800884c": "allocate_and_initialize_memory_0800884c",
                "param_1": "memory_buffer",
                "param_2": "offset",
                "iVar1": "result",
                "iVar2": "aligned_address",
                "uVar3": "data_size",
                "initialize_data_080090a8": "initialize_data",
                "allocate_and_set_memory_08009744": "allocate_and_set_memory",
                "initialize_data_080090b4": "initialize_data_again"
            },
            "calling": [
                "FUN_080088ec"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009744",
                "FUN_080090b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080088ec": {
            "entrypoint": "0x080088ec",
            "current_name": "initialize_and_allocate_memory_080088ec",
            "code": "\nvoid initializeAndAllocateMemory_080088ec(undefined4 arg1,int arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  int index;\n  uint *pointer1;\n  uint *pointer2;\n  undefined *pointer3;\n  uint size;\n  uint value;\n  undefined *pointer4;\n  undefined *pointer5;\n  undefined4 *pointer6;\n  int count;\n  uint flag1;\n  uint flag2;\n  \n  if (arg2 == 0) {\n    return;\n  }\n  initialize_data_080090a8();\n  flag1 = *(uint *)(arg2 + -4);\n  pointer1 = (uint *)(arg2 + -8);\n  size = flag1 & 0xfffffffe;\n  pointer2 = (uint *)((int)pointer1 + size);\n  value = pointer2[1] & 0xfffffffc;\n  if (DAT_20000454 == pointer2) {\n    size = size + value;\n    if ((flag1 & 1) == 0) {\n      pointer1 = (uint *)((int)pointer1 - *(int *)(arg2 + -8));\n      value = pointer1[2];\n      flag1 = pointer1[3];\n      size = size + *(int *)(arg2 + -8);\n      *(uint *)(value + 0xc) = flag1;\n      *(uint *)(flag1 + 8) = value;\n    }\n    value = DAT_20000858;\n    pointer1[1] = size | 1;\n    DAT_20000454 = pointer1;\n    if (value <= size) {\n      allocate_and_initialize_memory_0800884c(arg1,DAT_20000a44);\n    }\nLAB_080089f0:\n    initialize_data_080090b4(arg1);\n    return;\n  }\n  pointer2[1] = value;\n  if ((flag1 & 1) == 0) {\n    pointer1 = (uint *)((int)pointer1 - *(int *)(arg2 + -8));\n    pointer6 = (undefined4 *)pointer1[2];\n    size = size + *(int *)(arg2 + -8);\n    flag1 = *(uint *)((int)pointer2 + value + 4) & 1;\n    if ((uint **)pointer6 == &DAT_20000454) {\n      if (flag1 == 0) {\n        flag1 = pointer2[2];\n        flag2 = pointer2[3];\n        size = size + value;\n        *(uint *)(flag1 + 0xc) = flag2;\n        *(uint *)(flag2 + 8) = flag1;\n        pointer1[1] = size | 1;\n        *(uint *)((int)pointer1 + size) = size;\n      }\n      else {\n        pointer1[1] = size | 1;\n        *pointer2 = size;\n      }\n      goto LAB_080089f0;\n    }\n    flag2 = pointer1[3];\n    pointer6[3] = flag2;\n    *(undefined4 **)(flag2 + 8) = pointer6;\n  }\n  else {\n    flag1 = *(uint *)((int)pointer2 + value + 4) & 1;\n  }\n  if (flag1 == 0) {\n    pointer6 = (undefined4 *)pointer2[2];\n    size = size + value;\n    if ((uint **)pointer6 == &DAT_20000454) {\n      DAT_2000045c = pointer1;\n      DAT_20000460 = pointer1;\n      pointer1[2] = (uint)&DAT_20000454;\n      pointer1[3] = (uint)&DAT_20000454;\n      pointer1[1] = size | 1;\n      *(uint *)((int)pointer1 + size) = size;\n      goto LAB_080089f0;\n    }\n    value = pointer2[3];\n    pointer6[3] = value;\n    *(undefined4 **)(value + 8) = pointer6;\n    pointer1[1] = size | 1;\n    *(uint *)((int)pointer1 + size) = size;\n  }\n  else {\n    pointer1[1] = size | 1;\n    *(uint *)((int)pointer1 + size) = size;\n  }\n  if (size < 0x200) {\n    count = (size >> 3) + 1;\n    size = 1 << ((int)(size >> 3) >> 2 & 0xffU) | (uint)DAT_20000450;\n    value = *(uint *)(&DAT_2000044c + count * 8);\n    pointer1[2] = value;\n    pointer1[3] = (uint)(&DAT_20000444 + count * 8);\n    DAT_20000450 = (undefined *)size;\n    *(uint **)(&DAT_2000044c + count * 8) = pointer1;\n    *(uint **)(value + 0xc) = pointer1;\n    initialize_data_080090b4(arg1,pointer1,size,arg4);\n    return;\n  }\n  value = size >> 9;\n  if (value < 5) {\n    count = ((size >> 6) + 0x39) * 8;\n    index = (size >> 6) + 0x38;\n  }\n  else if (value < 0x15) {\n    count = (value + 0x5c) * 8;\n    index = value + 0x5b;\n  }\n  else if (value < 0x55) {\n    count = ((size >> 0xc) + 0x6f) * 8;\n    index = (size >> 0xc) + 0x6e;\n  }\n  else if (value < 0x155) {\n    count = ((size >> 0xf) + 0x78) * 8;\n    index = (size >> 0xf) + 0x77;\n  }\n  else if (value < 0x555) {\n    count = ((size >> 0x12) + 0x7d) * 8;\n    index = (size >> 0x12) + 0x7c;\n  }\n  else {\n    count = 0x3f8;\n    index = 0x7e;\n  }\n  pointer3 = *(undefined **)(&DAT_2000044c + count);\n  pointer4 = &DAT_20000444 + count;\n  if (pointer4 == pointer3) {\n    pointer3 = (undefined *)(1 << (index >> 2 & 0xffU) | (uint)DAT_20000450);\n    pointer5 = pointer4;\n    DAT_20000450 = pointer3;\n  }\n  else {\n    do {\n      pointer5 = pointer3;\n      if ((*(uint *)(pointer3 + 4) & 0xfffffffc) <= size) break;\n      pointer3 = *(undefined **)(pointer3 + 8);\n      pointer5 = pointer4;\n    } while (pointer4 != pointer3);\n    pointer4 = *(undefined **)(pointer5 + 0xc);\n  }\n  pointer1[2] = (uint)pointer5;\n  pointer1[3] = (uint)pointer4;\n  *(uint **)(pointer4 + 8) = pointer1;\n  *(uint **)(pointer5 + 0xc) = pointer1;\n  initialize_data_080090b4(arg1,pointer1,pointer3,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080088ec": "initialize_and_allocate_memory_080088ec",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4",
                "iVar1": "index",
                "puVar2": "pointer1",
                "puVar3": "pointer2",
                "puVar4": "pointer3",
                "uVar5": "size",
                "uVar6": "value",
                "puVar7": "pointer4",
                "puVar8": "pointer5",
                "puVar9": "pointer6",
                "iVar10": "count",
                "uVar11": "flag1",
                "uVar12": "flag2"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_08009adc",
                "FUN_080097cc",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_080090b4",
                "FUN_0800884c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008ad4": {
            "entrypoint": "0x08008ad4",
            "current_name": "calculate_adjusted_value_08008ad4",
            "code": "\nint calculateAdjustedValue_08008ad4(void)\n\n{\n  int storedValue;\n  \n  storedValue = *(int *)(DAT_2000001c + 0x34);\n  if (storedValue == 0) {\n    storedValue = 0x2000085c;\n  }\n  return storedValue + 0xf0;\n}\n\n",
            "renaming": {
                "FUN_08008ad4": "calculate_adjusted_value_08008ad4",
                "iVar1": "storedValue"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08008af0": {
            "entrypoint": "0x08008af0",
            "current_name": "FUNC_08008af0",
            "code": "\nvoid FUNC_08008af0(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af0": "FUNC_08008af0"
            },
            "calling": [
                "FUN_080090a8",
                "FUN_080098c0"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af4": {
            "entrypoint": "0x08008af4",
            "current_name": "FUNC_08008af4",
            "code": "\nvoid FUNC_08008af4(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08008af4": "FUNC_08008af4"
            },
            "calling": [
                "FUN_080098c0",
                "FUN_080090b4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08008af8": {
            "entrypoint": "0x08008af8",
            "current_name": "allocate_and_set_memory_08008af8",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_and_set_memory_08008af8(undefined4 *context_ptr,uint size)\n\n{\n  undefined *ptr;\n  uint temp1;\n  uint temp2;\n  int temp3;\n  undefined *ptr2;\n  uint temp4;\n  uint temp5;\n  undefined4 *ptr3;\n  undefined *ptr4;\n  undefined *ptr5;\n  int *result_ptr;\n  uint size_temp;\n  uint aligned_size;\n  int temp6;\n  undefined4 *ptr6;\n  undefined4 *ptr7;\n  \n  size_temp = size + 0xb;\n  if (size_temp < 0x17) {\n    if (0x10 < size) goto LAB_08008c7a;\n    initialize_data_080090a8();\n    aligned_size = 0x10;\n    temp3 = 0x18;\n    size_temp = 2;\nLAB_08008b18:\n    ptr5 = *(undefined **)((int)&DAT_20000450 + temp3);\n    if ((ptr5 != &DAT_20000444 + temp3) ||\n       (ptr5 = *(undefined **)((int)&DAT_20000458 + temp3), &DAT_2000044c + temp3 != ptr5)) {\n      temp3 = *(int *)(ptr5 + 0xc);\n      ptr2 = ptr5 + (*(uint *)(ptr5 + 4) & 0xfffffffc);\n      size_temp = *(uint *)(ptr2 + 4);\nLAB_08008b34:\n      temp6 = *(int *)(ptr5 + 8);\n      *(int *)(temp6 + 0xc) = temp3;\n      *(int *)(temp3 + 8) = temp6;\n      *(uint *)(ptr2 + 4) = size_temp | 1;\n      initialize_data_080090b4(context_ptr);\n      return (int *)(ptr5 + 8);\n    }\n    size_temp = size_temp + 2;\n  }\n  else {\n    aligned_size = size_temp & 0xfffffff8;\n    if (((int)aligned_size < 0) || (aligned_size < size)) {\nLAB_08008c7a:\n      *context_ptr = 0xc;\n      return (int *)0x0;\n    }\n    initialize_data_080090a8();\n    if (aligned_size < 0x1f8) {\n      size_temp = size_temp >> 3;\n      temp3 = aligned_size + 8;\n      goto LAB_08008b18;\n    }\n    temp1 = size_temp >> 9;\n    if (temp1 == 0) {\n      temp3 = 0x200;\n      temp4 = 0x40;\n      temp1 = 0x3f;\n    }\n    else if (temp1 < 5) {\n      temp4 = (size_temp >> 6) + 0x39;\n      temp1 = (size_temp >> 6) + 0x38;\n      temp3 = temp4 * 8;\n    }\n    else if (temp1 < 0x15) {\n      temp4 = temp1 + 0x5c;\n      temp1 = temp1 + 0x5b;\n      temp3 = temp4 * 8;\n    }\n    else if (temp1 < 0x55) {\n      temp4 = (size_temp >> 0xc) + 0x6f;\n      temp1 = (size_temp >> 0xc) + 0x6e;\n      temp3 = temp4 * 8;\n    }\n    else if (temp1 < 0x155) {\n      temp4 = (size_temp >> 0xf) + 0x78;\n      temp1 = (size_temp >> 0xf) + 0x77;\n      temp3 = temp4 * 8;\n    }\n    else if (temp1 < 0x555) {\n      temp4 = (size_temp >> 0x12) + 0x7d;\n      temp1 = (size_temp >> 0x12) + 0x7c;\n      temp3 = temp4 * 8;\n    }\n    else {\n      temp3 = 0x3f8;\n      temp4 = 0x7f;\n      temp1 = 0x7e;\n    }\n    for (ptr5 = *(undefined **)((int)&DAT_20000450 + temp3); size_temp = temp4,\n        &DAT_20000444 + temp3 != ptr5; ptr5 = *(undefined **)(ptr5 + 0xc)) {\n      temp6 = (*(uint *)(ptr5 + 4) & 0xfffffffc) - aligned_size;\n      size_temp = temp1;\n      if (0xf < temp6) break;\n      if (-1 < temp6) {\n        ptr2 = ptr5 + (*(uint *)(ptr5 + 4) & 0xfffffffc);\n        size_temp = *(uint *)(ptr2 + 4);\n        temp3 = *(int *)(ptr5 + 0xc);\n        goto LAB_08008b34;\n      }\n    }\n  }\n  ptr6 = DAT_2000045c;\n  if ((undefined **)DAT_2000045c == &DAT_20000454) {\n    temp4 = 1 << ((int)size_temp >> 2 & 0xffU);\n    temp1 = DAT_20000450;\n    if (temp4 <= DAT_20000450) goto LAB_08008c06;\n  }\n  else {\n    temp4 = DAT_2000045c[1];\n    temp5 = temp4 & 0xfffffffc;\n    temp1 = temp5 - aligned_size;\n    if (0xf < (int)temp1) {\n      ptr7 = (undefined4 *)(aligned_size + (int)DAT_2000045c);\n      DAT_2000045c[1] = aligned_size | 1;\n      DAT_2000045c = ptr7;\n      DAT_20000460 = ptr7;\n      ptr7[2] = &DAT_20000454;\n      ptr7[3] = &DAT_20000454;\n      ptr7[1] = temp1 | 1;\n      *(uint *)((int)ptr6 + temp5) = temp1;\n      initialize_data_080090b4(context_ptr);\n      return ptr6 + 2;\n    }\n    DAT_2000045c = &DAT_20000454;\n    DAT_20000460 = &DAT_20000454;\n    if (-1 < (int)temp1) {\n      *(uint *)((int)ptr6 + temp5 + 4) = *(uint *)((int)ptr6 + temp5 + 4) | 1;\n      initialize_data_080090b4(context_ptr);\n      return ptr6 + 2;\n    }\n    if (temp5 < 0x200) {\n      temp3 = (temp4 >> 3) + 1;\n      temp6 = *(int *)(&DAT_2000044c + temp3 * 8);\n      temp1 = 1 << ((int)(temp4 >> 3) >> 2 & 0xffU) | DAT_20000450;\n      ptr6[2] = temp6;\n      ptr6[3] = &DAT_20000444 + temp3 * 8;\n      DAT_20000450 = temp1;\n      *(undefined4 **)(&DAT_2000044c + temp3 * 8) = ptr6;\n      *(undefined4 **)(temp6 + 0xc) = ptr6;\n    }\n    else {\n      temp1 = temp4 >> 9;\n      if (temp1 < 5) {\n        temp3 = ((temp4 >> 6) + 0x39) * 8;\n        temp6 = (temp4 >> 6) + 0x38;\n      }\n      else if (temp1 < 0x15) {\n        temp3 = (temp1 + 0x5c) * 8;\n        temp6 = temp1 + 0x5b;\n      }\n      else if (temp1 < 0x55) {\n        temp3 = ((temp4 >> 0xc) + 0x6f) * 8;\n        temp6 = (temp4 >> 0xc) + 0x6e;\n      }\n      else if (temp1 < 0x155) {\n        temp3 = ((temp4 >> 0xf) + 0x78) * 8;\n        temp6 = (temp4 >> 0xf) + 0x77;\n      }\n      else if (temp1 < 0x555) {\n        temp3 = ((temp4 >> 0x12) + 0x7d) * 8;\n        temp6 = (temp4 >> 0x12) + 0x7c;\n      }\n      else {\n        temp3 = 0x3f8;\n        temp6 = 0x7e;\n      }\n      ptr5 = *(undefined **)(&DAT_2000044c + temp3);\n      ptr2 = &DAT_20000444 + temp3;\n      if (ptr2 == ptr5) {\n        DAT_20000450 = 1 << (temp6 >> 2 & 0xffU) | DAT_20000450;\n      }\n      else {\n        do {\n          if ((*(uint *)(ptr5 + 4) & 0xfffffffc) <= temp5) break;\n          ptr5 = *(undefined **)(ptr5 + 8);\n        } while (ptr2 != ptr5);\n        ptr2 = *(undefined **)(ptr5 + 0xc);\n      }\n      temp1 = DAT_20000450;\n      ptr6[2] = ptr5;\n      ptr6[3] = ptr2;\n      *(undefined4 **)(ptr2 + 8) = ptr6;\n      *(undefined4 **)(ptr5 + 0xc) = ptr6;\n    }\n    temp4 = 1 << ((int)size_temp >> 2 & 0xffU);\n    if (temp4 <= temp1) {\nLAB_08008c06:\n      if ((temp4 & temp1) == 0) {\n        size_temp = size_temp & 0xfffffffc;\n        do {\n          temp4 = temp4 << 1;\n          size_temp = size_temp + 4;\n        } while ((temp4 & temp1) == 0);\n      }\n      do {\n        ptr7 = (undefined4 *)(&DAT_2000044c + size_temp * 8);\n        temp1 = size_temp;\n        ptr6 = ptr7;\n        do {\n          for (ptr3 = (undefined4 *)ptr6[3]; ptr6 != ptr3;\n              ptr3 = (undefined4 *)ptr3[3]) {\n            temp5 = ptr3[1] & 0xfffffffc;\n            temp2 = temp5 - aligned_size;\n            if (0xf < (int)temp2) {\n              temp6 = ptr3[2];\n              temp3 = ptr3[3];\n              ptr6 = (undefined4 *)(aligned_size + (int)ptr3);\n              ptr3[1] = aligned_size | 1;\n              *(int *)(temp6 + 0xc) = temp3;\n              *(int *)(temp3 + 8) = temp6;\n              DAT_2000045c = ptr6;\n              DAT_20000460 = ptr6;\n              ptr6[2] = &DAT_20000454;\n              ptr6[3] = &DAT_20000454;\n              ptr6[1] = temp2 | 1;\n              *(uint *)((int)ptr3 + temp5) = temp2;\n              initialize_data_080090b4(context_ptr);\n              return ptr3 + 2;\n            }\n            if (-1 < (int)temp2) {\n              temp3 = ptr3[3];\n              temp6 = ptr3[2];\n              *(uint *)((int)ptr3 + temp5 + 4) = *(uint *)((int)ptr3 + temp5 + 4) | 1;\n              *(int *)(temp6 + 0xc) = temp3;\n              *(int *)(temp3 + 8) = temp6;\n              initialize_data_080090b4(context_ptr);\n              return ptr3 + 2;\n            }\n          }\n          temp1 = temp1 + 1;\n          ptr6 = ptr6 + 2;\n        } while ((temp1 & 3) != 0);\n        do {\n          temp5 = size_temp & 3;\n          ptr6 = ptr7 + -2;\n          size_temp = size_temp - 1;\n          if (temp5 == 0) {\n            DAT_20000450 = DAT_20000450 & ~temp4;\n            break;\n          }\n          ptr7 = (undefined4 *)*ptr7;\n        } while (ptr7 == ptr6);\n        temp4 = temp4 * 2;\n        if ((DAT_20000450 <= temp4 && temp4 - DAT_20000450 != 0) || (size_temp = temp1, temp4 == 0))\n        break;\n        for (; (temp4 & DAT_20000450) == 0; temp4 = temp4 << 1) {\n          size_temp = size_temp + 4;\n        }\n      } while( true );\n    }\n  }\n  ptr5 = DAT_20000454;\n  size_temp = *(uint *)(DAT_20000454 + 4) & 0xfffffffc;\n  if ((aligned_size <= size_temp) && (temp1 = size_temp - aligned_size, 0xf < (int)temp1)) goto LAB_08008dac;\n  if (DAT_20000854 == (undefined *)0xffffffff) {\n    temp1 = aligned_size + DAT_20000a44 + 0x10;\n  }\n  else {\n    temp1 = aligned_size + DAT_20000a44 + 0x100f & 0xfffff000;\n  }\n  ptr2 = (undefined *)allocate_and_set_memory_08008af8_08009744(context_ptr,temp1);\n  if (ptr2 == (undefined *)0xffffffff) {\nLAB_08008ed8:\n    size_temp = *(uint *)(DAT_20000454 + 4);\n  }\n  else {\n    ptr = ptr5 + size_temp;\n    if (ptr < ptr2 || ptr == ptr2) {\n      ptr4 = DAT_20000a14 + temp1;\n      if ((ptr != ptr2) || (((uint)ptr & 0xfff) != 0)) goto LAB_08008d02;\n      DAT_20000a14 = ptr4;\n      *(uint *)(DAT_20000454 + 4) = size_temp + temp1 | 1;\n    }\n    else {\n      if (ptr5 != &DAT_2000044c) goto LAB_08008ed8;\nLAB_08008d02:\n      DAT_20000a14 = DAT_20000a14 + temp1;\n      ptr4 = ptr2;\n      if (DAT_20000854 != (undefined *)0xffffffff) {\n        DAT_20000a14 = DAT_20000a14 + ((int)ptr2 - (int)ptr);\n        ptr4 = DAT_20000854;\n      }\n      DAT_20000854 = ptr4;\n      temp4 = (uint)ptr2 & 7;\n      if (temp4 == 0) {\n        temp3 = 0x1000;\n      }\n      else {\n        ptr2 = ptr2 + (8 - temp4);\n        temp3 = 0x1008 - temp4;\n      }\n      temp3 = temp3 - ((uint)(ptr2 + temp1) & 0xfff);\n      temp6 = allocate_and_set_memory_08008af8_08009744(context_ptr,temp3);\n      if (temp6 == -1) {\n        temp1 = 1;\n        temp3 = 0;\n      }\n      else {\n        temp1 = (temp6 - (int)ptr2) + temp3 | 1;\n      }\n      ptr4 = DAT_20000a14 + temp3;\n      DAT_20000454 = ptr2;\n      DAT_20000a14 = ptr4;\n      *(uint *)(ptr2 + 4) = temp1;\n      if (ptr5 != &DAT_2000044c) {\n        if (size_temp < 0x10) {\n          *(undefined4 *)(ptr2 + 4) = 1;\n          goto LAB_08008eee;\n        }\n        size_temp = size_temp - 0xc & 0xfffffff8;\n        *(uint *)(ptr5 + 4) = *(uint *)(ptr5 + 4) & 1 | size_temp;\n        *(undefined4 *)(ptr5 + size_temp + 4) = 5;\n        *(undefined4 *)(ptr5 + size_temp + 8) = 5;\n        if (0xf < size_temp) {\n          initialize_and_allocate_memory_080088ec(context_ptr,ptr5 + 8);\n          ptr4 = DAT_20000a14;\n        }\n      }\n    }\n    if (DAT_20000a3c < ptr4) {\n      DAT_20000a3c = ptr4;\n    }\n    size_temp = *(uint *)(DAT_20000454 + 4);\n    if (DAT_20000a40 < ptr4) {\n      DAT_20000a40 = ptr4;\n    }\n  }\n  temp1 = (size_temp & 0xfffffffc) - aligned_size;\n  if ((aligned_size <= (size_temp & 0xfffffffc)) && (0xf < (int)temp1)) {\nLAB_08008dac:\n    ptr5 = DAT_20000454 + aligned_size;\n    *(uint *)(DAT_20000454 + 4) = aligned_size | 1;\n    result_ptr = (int *)(DAT_20000454 + 8);\n    DAT_20000454 = ptr5;\n    *(uint *)(ptr5 + 4) = temp1 | 1;\n    initialize_data_080090b4(context_ptr);\n    return result_ptr;\n  }\nLAB_08008eee:\n  initialize_data_080090b4(context_ptr);\n  return (int *)0x0;\n}\n\n",
            "renaming": {
                "FUN_08008af8": "allocate_and_set_memory_08008af8",
                "param_1": "context_ptr",
                "param_2": "size",
                "puVar1": "ptr",
                "uVar2": "temp1",
                "uVar3": "temp2",
                "iVar4": "temp3",
                "puVar5": "ptr2",
                "uVar6": "temp4",
                "uVar7": "temp5",
                "puVar8": "ptr3",
                "puVar9": "ptr4",
                "puVar10": "ptr5",
                "piVar11": "result_ptr",
                "uVar12": "size_temp",
                "uVar13": "aligned_size",
                "iVar14": "temp6",
                "puVar15": "ptr6",
                "puVar16": "ptr7"
            },
            "calling": [
                "FUN_08005e9c",
                "FUN_08009adc",
                "FUN_080097cc",
                "FUN_08009980"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009744",
                "FUN_080090b4",
                "FUN_080088ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800901c": {
            "entrypoint": "0x0800901c",
            "current_name": "find_next_occurrence_0800901c",
            "code": "\nuint * find_next_occurrence_0800901c(uint *input_array,uint search_value,uint array_length)\n\n{\n  uint temp_var_1;\n  uint temp_var_2;\n  uint *current_ptr;\n  uint masked_search_value;\n  bool is_array_empty;\n  \n  masked_search_value = search_value & 0xff;\n  if (((uint)input_array & 3) == 0) {\nLAB_0800904a:\n    if (3 < array_length) {\n      temp_var_2 = (search_value & 0xff) << 8 | masked_search_value;\n      current_ptr = input_array;\n      do {\n        temp_var_1 = *current_ptr ^ (temp_var_2 | temp_var_2 << 0x10);\n        input_array = current_ptr + 1;\n        if ((temp_var_1 + 0xfefefeff & ~temp_var_1 & 0x80808080) != 0) goto LAB_08009050;\n        array_length = array_length - 4;\n        current_ptr = input_array;\n      } while (3 < array_length);\n    }\n    current_ptr = input_array;\n    if (array_length == 0) {\n      input_array = (uint *)0x0;\n    }\n    else {\nLAB_08009050:\n      input_array = current_ptr;\n      if (*(byte *)input_array != masked_search_value) {\n        current_ptr = (uint *)(array_length + (int)input_array);\n        do {\n          input_array = (uint *)((int)input_array + 1);\n          if (current_ptr == input_array) goto LAB_0800906c;\n        } while (*(byte *)input_array != masked_search_value);\n      }\n    }\n  }\n  else {\n    temp_var_2 = array_length - 1;\n    if (array_length == 0) {\nLAB_0800906c:\n      input_array = (uint *)0x0;\n    }\n    else if (*(byte *)input_array != masked_search_value) {\n      current_ptr = (uint *)((int)input_array + 1);\n      do {\n        input_array = current_ptr;\n        array_length = temp_var_2;\n        if (((uint)input_array & 3) == 0) goto LAB_0800904a;\n        is_array_empty = temp_var_2 == 0;\n        temp_var_2 = temp_var_2 - 1;\n        if (is_array_empty) goto LAB_0800906c;\n        current_ptr = (uint *)((int)input_array + 1);\n      } while (*(byte *)input_array != masked_search_value);\n    }\n  }\n  return input_array;\n}\n\n",
            "renaming": {
                "FUN_0800901c": "find_next_occurrence_0800901c",
                "param_1": "input_array",
                "param_2": "search_value",
                "param_3": "array_length",
                "uVar1": "temp_var_1",
                "uVar2": "temp_var_2",
                "puVar3": "current_ptr",
                "uVar4": "masked_search_value",
                "bVar5": "is_array_empty"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090a8": {
            "entrypoint": "0x080090a8",
            "current_name": "initialize_data_080090a8",
            "code": "\nvoid initializeData_080090a8(void)\n\n{\n  FUNC_08008af0(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090a8": "initialize_data_080090a8"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090b4": {
            "entrypoint": "0x080090b4",
            "current_name": "initialize_data_080090b4",
            "code": "\nvoid initializeData_080090b4(void)\n\n{\n  FUNC_08008af4(&DAT_20000bfc);\n  return;\n}\n\n",
            "renaming": {
                "FUN_080090b4": "initialize_data_080090b4"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08008af4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080090c0": {
            "entrypoint": "0x080090c0",
            "current_name": "initialize_or_get_entry_080090c0",
            "code": "\nundefined4 * initializeOrGetEntry_080090c0(int entry,uint index)\n\n{\n  undefined4 *entryPtr;\n  int entryMemory;\n  \n  entryMemory = *(int *)(entry + 0x4c);\n  if (entryMemory == 0) {\n    entryMemory = initializeMemory(entry,4,0x21);\n    *(int *)(entry + 0x4c) = entryMemory;\n    if (entryMemory == 0) {\n      return (undefined4 *)0x0;\n    }\n  }\n  entryPtr = *(undefined4 **)(entryMemory + index * 4);\n  if (entryPtr == (undefined4 *)0x0) {\n    entryMemory = 1 << (index & 0xff);\n    entryPtr = (undefined4 *)initializeMemory(entry,1,(entryMemory + 5) * 4);\n    if (entryPtr == (undefined4 *)0x0) {\n      return (undefined4 *)0x0;\n    }\n    entryPtr[1] = index;\n    entryPtr[2] = entryMemory;\n  }\n  else {\n    *(undefined4 *)(entryMemory + index * 4) = *entryPtr;\n  }\n  entryPtr[3] = 0;\n  entryPtr[4] = 0;\n  return entryPtr;\n}\n\n",
            "renaming": {
                "FUN_080090c0": "initialize_or_get_entry_080090c0",
                "param_1": "entry",
                "param_2": "index",
                "puVar1": "entryPtr",
                "iVar2": "entryMemory",
                "initialize_memory_08009980": "initializeMemory",
                "puVar1[1]": "entryPtr[1]",
                "puVar1[2]": "entryPtr[2]",
                "puVar1[3]": "entryPtr[3]",
                "puVar1[4]": "entryPtr[4]"
            },
            "calling": [
                "FUN_08009244",
                "FUN_08009530",
                "FUN_08009630",
                "FUN_08009120",
                "FUN_080093a4",
                "FUN_08009258",
                "FUN_08009444",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08009980"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0800910c": {
            "entrypoint": "0x0800910c",
            "current_name": "extract_and_swap_0800910c",
            "code": "\nvoid extract_and_swap_0800910c(int input_offset,undefined4 *output_ptr)\n\n{\n  int data_ptr;\n  \n  if (output_ptr != (undefined4 *)0x0) {\n    data_ptr = *(int *)(input_offset + 0x4c);\n    *output_ptr = *(undefined4 *)(data_ptr + output_ptr[1] * 4);\n    *(undefined4 **)(data_ptr + output_ptr[1] * 4) = output_ptr;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0800910c": "extract_and_swap_0800910c",
                "param_1": "input_offset",
                "param_2": "output_ptr",
                "iVar1": "data_ptr"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009120": {
            "entrypoint": "0x08009120",
            "current_name": "update_array_08009120",
            "code": "\nundefined4 * updateArray_08009120(int input,undefined4 *array,int multiplier,uint carry)\n\n{\n  undefined4 *result;\n  uint temp;\n  int arrayLength;\n  uint *arrayPtr;\n  int i;\n  \n  i = 0;\n  arrayLength = array[4];\n  arrayPtr = array + 5;\n  do {\n    i = i + 1;\n    carry = multiplier * (*arrayPtr & 0xffff) + carry;\n    temp = multiplier * (*arrayPtr >> 0x10) + (carry >> 0x10);\n    *arrayPtr = (carry & 0xffff) + temp * 0x10000;\n    carry = temp >> 0x10;\n    arrayPtr = arrayPtr + 1;\n  } while (i < arrayLength);\n  result = array;\n  if (carry != 0) {\n    if ((int)array[2] <= arrayLength) {\n      result = (undefined4 *)initialize_or_get_entry_080090c0(input,array[1] + 1);\n      memcpy_aligned_08001084(result + 3,array + 3,(array[4] + 2) * 4);\n      i = *(int *)(input + 0x4c);\n      *array = *(undefined4 *)(i + array[1] * 4);\n      *(undefined4 **)(i + array[1] * 4) = array;\n    }\n    result[arrayLength + 5] = carry;\n    result[4] = arrayLength + 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_08009120": "update_array_08009120",
                "param_1": "input",
                "param_2": "array",
                "param_3": "multiplier",
                "param_4": "carry",
                "puVar1": "result",
                "uVar2": "temp",
                "iVar3": "arrayLength",
                "puVar4": "arrayPtr",
                "iVar5": "i"
            },
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08001084",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091a4": {
            "entrypoint": "0x080091a4",
            "current_name": "count_leading_zeros_080091a4",
            "code": "\nint countLeadingZeros_080091a4(uint value)\n\n{\n  int leadingZeros;\n  \n  if ((value & 0xffff0000) == 0) {\n    value = value << 0x10;\n    leadingZeros = 0x10;\n  }\n  else {\n    leadingZeros = 0;\n  }\n  if ((value & 0xff000000) == 0) {\n    value = value << 8;\n    leadingZeros = leadingZeros + 8;\n  }\n  if ((value & 0xf0000000) == 0) {\n    value = value << 4;\n    leadingZeros = leadingZeros + 4;\n  }\n  if ((value & 0xc0000000) == 0) {\n    value = value << 2;\n    leadingZeros = leadingZeros + 2;\n  }\n  if (-1 < (int)value) {\n    if ((int)(value << 1) < 0) {\n      return leadingZeros + 1;\n    }\n    leadingZeros = 0x20;\n  }\n  return leadingZeros;\n}\n\n",
            "renaming": {
                "FUN_080091a4": "count_leading_zeros_080091a4",
                "param_1": "value",
                "iVar1": "leadingZeros"
            },
            "calling": [
                "FUN_08009630",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080091e4": {
            "entrypoint": "0x080091e4",
            "current_name": "find_highest_set_bit_080091e4",
            "code": "\nint find_highest_set_bit_080091e4(uint *input_ptr)\n\n{\n  int result;\n  uint value;\n  \n  value = *input_ptr;\n  if ((value & 7) == 0) {\n    if ((value & 0xffff) == 0) {\n      value = value >> 0x10;\n      result = 0x10;\n    }\n    else {\n      result = 0;\n    }\n    if ((value & 0xff) == 0) {\n      value = value >> 8;\n      result = result + 8;\n    }\n    if ((value & 0xf) == 0) {\n      value = value >> 4;\n      result = result + 4;\n    }\n    if ((value & 3) == 0) {\n      value = value >> 2;\n      result = result + 2;\n    }\n    if (-1 < (int)(value << 0x1f)) {\n      value = value >> 1;\n      if (value == 0) {\n        return 0x20;\n      }\n      result = result + 1;\n    }\n    *input_ptr = value;\n    return result;\n  }\n  if ((int)(value << 0x1f) < 0) {\n    return 0;\n  }\n  if (-1 < (int)(value << 0x1e)) {\n    *input_ptr = value >> 2;\n    return 2;\n  }\n  *input_ptr = value >> 1;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_080091e4": "find_highest_set_bit_080091e4",
                "param_1": "input_ptr",
                "iVar1": "result",
                "uVar2": "value"
            },
            "calling": [
                "FUN_08009630"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009244": {
            "entrypoint": "0x08009244",
            "current_name": "initialize_entry_08009244",
            "code": "\nvoid initializeEntry_08009244(undefined4 entryAddress,undefined4 newValue)\n\n{\n  int entryIndex;\n  \n  entryIndex = initialize_or_get_entry_080090c0(entryAddress,1);\n  *(undefined4 *)(entryIndex + 0x10) = 1;\n  *(undefined4 *)(entryIndex + 0x14) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009244": "initialize_entry_08009244",
                "param_1": "entryAddress",
                "param_2": "newValue",
                "iVar1": "entryIndex"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009258": {
            "entrypoint": "0x08009258",
            "current_name": "initialize_and_fill_entries_08009258",
            "code": "\nvoid initialize_and_fill_entries_08009258(undefined4 entry_size,int array1,int array2)\n\n{\n  uint *ptr1;\n  uint *ptr2;\n  int length;\n  uint temp1;\n  uint *ptr3;\n  uint start;\n  uint *ptr4;\n  uint temp2;\n  int array1Length;\n  int array2Length;\n  uint end;\n  int temp;\n  int tempArray;\n  uint *ptr5;\n  uint *ptr6;\n  uint *ptr7;\n  uint *ptr8;\n  uint *ptr9;\n  \n  temp = *(int *)(array1 + 0x10);\n  array1Length = *(int *)(array2 + 0x10);\n  array2Length = array1Length;\n  tempArray = array1;\n  if (temp < array1Length) {\n    array2Length = temp;\n    temp = array1Length;\n    tempArray = array2;\n    array2 = array1;\n  }\n  array1Length = temp + array2Length;\n  length = *(int *)(tempArray + 4);\n  if (*(int *)(tempArray + 8) < array1Length) {\n    length = length + 1;\n  }\n  length = initialize_or_get_entry_080090c0(entry_size,length);\n  ptr9 = (uint *)(length + 0x14);\n  ptr8 = ptr9 + array1Length;\n  for (ptr3 = ptr9; ptr3 < ptr8; ptr3 = ptr3 + 1) {\n    *ptr3 = 0;\n  }\n  start = array2 + 0x14;\n  end = start + array2Length * 4;\n  ptr3 = (uint *)(tempArray + 0x14);\n  if (start < end) {\n    ptr4 = (uint *)(start + ((end - array2) - 0x15 & 0xfffffffc));\n    ptr7 = (uint *)(array2 + 0x10);\n    do {\n      while( true ) {\n        ptr7 = ptr7 + 1;\n        start = *ptr7 & 0xffff;\n        if (start != 0) break;\n        start = *ptr7 >> 0x10;\n        if (start == 0) goto LAB_080092d2;\nLAB_0800932c:\n        temp2 = *ptr9;\n        temp1 = 0;\n        ptr1 = ptr3;\n        ptr5 = ptr9;\n        end = temp2;\n        do {\n          ptr6 = ptr5;\n          temp1 = temp1 + start * *(ushort *)ptr1 + (end >> 0x10);\n          *ptr6 = temp2 & 0xffff | temp1 * 0x10000;\n          ptr2 = ptr1 + 1;\n          end = ptr6[1];\n          temp2 = start * (*ptr1 >> 0x10) + (end & 0xffff) + (temp1 >> 0x10);\n          temp1 = temp2 >> 0x10;\n          ptr1 = ptr2;\n          ptr5 = ptr6 + 1;\n        } while (ptr2 < ptr3 + temp);\n        ptr6[1] = temp2;\n        ptr9 = ptr9 + 1;\n        if (ptr4 == ptr7) goto LAB_0800937a;\n      }\n      end = 0;\n      ptr1 = ptr9;\n      ptr5 = ptr3;\n      do {\n        ptr2 = ptr1;\n        ptr6 = ptr5 + 1;\n        temp2 = start * (*ptr5 & 0xffff) + (*ptr2 & 0xffff) + end;\n        temp1 = start * (*ptr5 >> 0x10) + (*ptr2 >> 0x10) + (temp2 >> 0x10);\n        end = temp1 >> 0x10;\n        *ptr2 = temp2 & 0xffff | temp1 * 0x10000;\n        ptr1 = ptr2 + 1;\n        ptr5 = ptr6;\n      } while (ptr6 < ptr3 + temp);\n      ptr2[1] = end;\n      start = *ptr7 >> 0x10;\n      if (start != 0) goto LAB_0800932c;\nLAB_080092d2:\n      ptr9 = ptr9 + 1;\n    } while (ptr4 != ptr7);\n  }\nLAB_0800937a:\n  if (0 < array1Length) {\n    start = ptr8[-1];\n    ptr8 = ptr8 + -1;\n    while ((start == 0 && (array1Length = array1Length + -1, array1Length != 0))) {\n      ptr8 = ptr8 + -1;\n      start = *ptr8;\n    }\n  }\n  *(int *)(length + 0x10) = array1Length;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009258": "initialize_and_fill_entries_08009258",
                "param_1": "entry_size",
                "param_2": "array1",
                "param_3": "array2",
                "puVar1": "ptr1",
                "puVar2": "ptr2",
                "iVar3": "length",
                "uVar4": "temp1",
                "puVar5": "ptr3",
                "uVar6": "start",
                "puVar7": "ptr4",
                "uVar8": "temp2",
                "iVar9": "array1Length",
                "iVar10": "array2Length",
                "uVar11": "end",
                "iVar12": "temp",
                "iVar13": "tempArray",
                "puVar14": "ptr5",
                "puVar15": "ptr6",
                "puVar16": "ptr7",
                "puVar17": "ptr8",
                "puVar18": "ptr9"
            },
            "calling": [
                "FUN_080093a4",
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080093a4": {
            "entrypoint": "0x080093a4",
            "current_name": "reverse_and_update_array_080093a4",
            "code": "\nundefined4 * reverse_and_update_array_080093a4(int array_start,undefined4 *array,uint array_length)\n\n{\n  int index;\n  int num_iterations;\n  undefined4 *current_entry;\n  undefined4 *new_entry;\n  \n  if ((array_length & 3) != 0) {\n    array = (undefined4 *)\n              update_array_08009120(array_start,array,*(undefined4 *)(&DAT_0800a070 + ((array_length & 3) - 1) * 4),\n                           0);\n  }\n  num_iterations = (int)array_length >> 2;\n  if (num_iterations != 0) {\n    new_entry = *(undefined4 **)(array_start + 0x48);\n    if (new_entry == (undefined4 *)0x0) {\n      new_entry = (undefined4 *)initialize_or_get_entry_080090c0(array_start,1);\n      new_entry[4] = 1;\n      new_entry[5] = 0x271;\n      *(undefined4 **)(array_start + 0x48) = new_entry;\n      *new_entry = 0;\n    }\n    current_entry = array;\n    if (num_iterations << 0x1f < 0) goto LAB_080093d2;\nLAB_080093c4:\n    num_iterations = num_iterations >> 1;\n    current_entry = new_entry;\n    if (num_iterations != 0) {\n      while( true ) {\n        new_entry = (undefined4 *)*current_entry;\n        if (new_entry == (undefined4 *)0x0) {\n          new_entry = (undefined4 *)initialize_and_fill_entries_08009258(array_start,current_entry,current_entry);\n          *current_entry = new_entry;\n          *new_entry = 0;\n        }\n        current_entry = array;\n        if (-1 < num_iterations << 0x1f) break;\nLAB_080093d2:\n        array = (undefined4 *)initialize_and_fill_entries_08009258(array_start,current_entry,new_entry);\n        if (current_entry == (undefined4 *)0x0) break;\n        index = *(int *)(array_start + 0x4c);\n        num_iterations = num_iterations >> 1;\n        *current_entry = *(undefined4 *)(index + current_entry[1] * 4);\n        *(undefined4 **)(index + current_entry[1] * 4) = current_entry;\n        current_entry = new_entry;\n        if (num_iterations == 0) {\n          return array;\n        }\n      }\n      goto LAB_080093c4;\n    }\n  }\n  return array;\n}\n\n",
            "renaming": {
                "FUN_080093a4": "reverse_and_update_array_080093a4",
                "param_1": "array_start",
                "param_2": "array",
                "param_3": "array_length",
                "iVar1": "index",
                "iVar2": "num_iterations",
                "puVar3": "current_entry",
                "puVar4": "new_entry"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_08009120",
                "FUN_08009258",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009444": {
            "entrypoint": "0x08009444",
            "current_name": "initialize_or_get_entry_08009444",
            "code": "\nvoid initialize_or_get_entry_08009444(int entry,undefined4 *params,uint bit_count)\n\n{\n  int step;\n  int multiplier;\n  int initial_value;\n  undefined4 entry_value;\n  int offset;\n  int doubled_multiplier;\n  uint *destination;\n  uint *source;\n  uint *current_source;\n  uint *end_ptr;\n  int divisor;\n  int result;\n  uint overflow;\n  uint *current_destination;\n  \n  offset = params[4];\n  divisor = (int)bit_count >> 5;\n  result = divisor + offset + 1;\n  initial_value = params[1];\n  multiplier = params[2];\n  if ((int)params[2] < result) {\n    do {\n      doubled_multiplier = multiplier * 2;\n      step = multiplier * -2;\n      initial_value = initial_value + 1;\n      multiplier = doubled_multiplier;\n    } while (result != doubled_multiplier && result + step < 0 == SBORROW4(result,doubled_multiplier));\n  }\n  multiplier = initialize_or_get_entry_08009444_080090c0(entry,initial_value);\n  destination = (uint *)(multiplier + 0x14);\n  if (0 < divisor) {\n    end_ptr = destination + divisor;\n    source = destination;\n    do {\n      current_destination = source + 1;\n      *source = 0;\n      destination = end_ptr;\n      source = current_destination;\n    } while (current_destination != end_ptr);\n  }\n  initial_value = params[4];\n  source = params + 5;\n  bit_count = bit_count & 0x1f;\n  if (bit_count == 0) {\n    destination = destination + -1;\n    end_ptr = source;\n    do {\n      current_destination = end_ptr + 1;\n      destination = destination + 1;\n      *destination = *end_ptr;\n      end_ptr = current_destination;\n    } while (current_destination < source + initial_value);\n  }\n  else {\n    overflow = 0;\n    end_ptr = source;\n    do {\n      current_destination = destination;\n      *current_destination = *end_ptr << bit_count | overflow;\n      current_source = end_ptr + 1;\n      overflow = *end_ptr >> (0x20 - bit_count & 0xff);\n      destination = current_destination + 1;\n      end_ptr = current_source;\n    } while (current_source < source + initial_value);\n    current_destination[1] = overflow;\n    if (overflow != 0) {\n      result = divisor + offset + 2;\n    }\n  }\n  offset = *(int *)(entry + 0x4c);\n  initial_value = params[1];\n  entry_value = *(undefined4 *)(offset + initial_value * 4);\n  *(int *)(multiplier + 0x10) = result + -1;\n  *params = entry_value;\n  *(undefined4 **)(offset + initial_value * 4) = params;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009444": "initialize_or_get_entry_08009444",
                "param_1": "entry",
                "param_2": "params",
                "param_3": "bit_count",
                "iVar1": "step",
                "iVar2": "multiplier",
                "iVar3": "initial_value",
                "uVar4": "entry_value",
                "iVar5": "offset",
                "iVar6": "doubled_multiplier",
                "puVar7": "destination",
                "puVar8": "source",
                "puVar9": "current_destination",
                "puVar10": "current_source",
                "puVar11": "end_ptr",
                "iVar12": "divisor",
                "iVar13": "result",
                "uVar14": "overflow"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080094f8": {
            "entrypoint": "0x080094f8",
            "current_name": "compare_arrays_080094f8",
            "code": "\nint compareArrays_080094f8(int array1,int array2)\n\n{\n  int sizeDifference;\n  uint *ptrArray2;\n  int offset;\n  uint *ptrArray1;\n  \n  offset = *(int *)(array2 + 0x10);\n  sizeDifference = *(int *)(array1 + 0x10) - offset;\n  if (sizeDifference == 0) {\n    ptrArray2 = (uint *)(array2 + 0x14 + offset * 4);\n    ptrArray1 = (uint *)(array1 + 0x14) + offset;\n    do {\n      ptrArray1 = ptrArray1 + -1;\n      ptrArray2 = ptrArray2 + -1;\n      if (*ptrArray1 != *ptrArray2) {\n        if (*ptrArray2 <= *ptrArray1) {\n          return 1;\n        }\n        return -1;\n      }\n    } while ((uint *)(array1 + 0x14) < ptrArray1);\n  }\n  return sizeDifference;\n}\n\n",
            "renaming": {
                "FUN_080094f8": "compare_arrays_080094f8",
                "param_1": "array1",
                "param_2": "array2",
                "iVar1": "sizeDifference",
                "iVar3": "offset",
                "puVar2": "ptrArray2",
                "puVar4": "ptrArray1"
            },
            "calling": [
                "FUN_080078c0",
                "FUN_080079e8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009530": {
            "entrypoint": "0x08009530",
            "current_name": "reverse_and_update_entries_08009530",
            "code": "\nvoid reverse_and_update_entries_08009530(undefined4 param_1,uint *original_array,uint *updated_array,undefined4 param_4)\n\n{\n  int entry_index;\n  uint *puVar2;\n  uint original_array_length;\n  uint carry;\n  undefined4 is_equal;\n  uint *puVar6;\n  uint *original_ptr;\n  uint *original_ptr_2;\n  uint *ptr_2;\n  uint *original_ptr_end;\n  int temp;\n  uint *updated_ptr;\n  uint updated_array_length;\n  uint *ptr_1;\n  \n  puVar2 = (uint *)updated_array[4];\n  original_ptr_end = original_array + 5;\n  updated_ptr = updated_array + 5;\n  original_ptr = original_ptr_end;\n  original_ptr_2 = original_array;\n  if ((uint *)original_array[4] == puVar2) {\n    puVar6 = original_ptr_end + (int)puVar2;\n    puVar2 = updated_ptr + (int)puVar2;\n    while( true ) {\n      puVar6 = puVar6 + -1;\n      puVar2 = puVar2 + -1;\n      if (*puVar6 != *puVar2) break;\n      if (puVar6 <= original_ptr_end) {\n        temp = initialize_or_get_entry_080090c0(param_1,0,puVar6,puVar2,param_4);\n        *(undefined4 *)(temp + 0x10) = 1;\n        *(undefined4 *)(temp + 0x14) = 0;\n        return;\n      }\n    }\n    is_equal = 0;\n    if (*puVar2 <= *puVar6) goto LAB_08009578;\n  }\n  else if (-1 < (int)(uint *)original_array[4] - (int)puVar2) {\n    is_equal = 0;\n    puVar6 = updated_array;\n    goto LAB_08009578;\n  }\n  is_equal = 1;\n  puVar6 = original_ptr_end;\n  puVar2 = original_array;\n  original_ptr = updated_ptr;\n  original_ptr_2 = updated_array;\n  updated_array = original_array;\n  updated_ptr = original_ptr_end;\nLAB_08009578:\n  entry_index = initialize_or_get_entry_080090c0(param_1,original_ptr_2[1],puVar6,puVar2,param_4);\n  temp = 0;\n  updated_array_length = original_ptr_2[4];\n  original_array_length = updated_array[4];\n  *(undefined4 *)(entry_index + 0xc) = is_equal;\n  original_ptr_end = original_ptr + updated_array_length;\n  puVar2 = (uint *)(entry_index + 0x14);\n  original_ptr_2 = updated_ptr;\n  do {\n    ptr_1 = original_ptr + 1;\n    ptr_2 = original_ptr_2 + 1;\n    carry = ((*original_ptr & 0xffff) + temp) - (*original_ptr_2 & 0xffff);\n    temp = ((*original_ptr >> 0x10) - (*original_ptr_2 >> 0x10)) + ((int)carry >> 0x10);\n    carry = carry & 0xffff | temp * 0x10000;\n    puVar6 = puVar2 + 1;\n    *puVar2 = carry;\n    temp = temp >> 0x10;\n    puVar2 = puVar6;\n    original_ptr = ptr_1;\n    original_ptr_2 = ptr_2;\n  } while (ptr_2 < updated_ptr + original_array_length);\n  puVar2 = ptr_1;\n  original_ptr = puVar6;\n  if (ptr_1 < original_ptr_end) {\n    do {\n      original_ptr_2 = puVar2 + 1;\n      original_array_length = (*puVar2 & 0xffff) + temp;\n      temp = ((int)original_array_length >> 0x10) + (*puVar2 >> 0x10);\n      carry = original_array_length & 0xffff | temp * 0x10000;\n      *original_ptr = carry;\n      temp = temp >> 0x10;\n      puVar2 = original_ptr_2;\n      original_ptr = original_ptr + 1;\n    } while (original_ptr_2 < original_ptr_end);\n    puVar6 = (uint *)((int)puVar6 + ((int)original_ptr_end + ~(uint)ptr_1 & 0xfffffffc) + 4);\n  }\n  puVar6 = puVar6 + -1;\n  while (carry == 0) {\n    puVar6 = puVar6 + -1;\n    updated_array_length = updated_array_length - 1;\n    carry = *puVar6;\n  }\n  *(uint *)(entry_index + 0x10) = updated_array_length;\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009530": "reverse_and_update_entries_08009530",
                "param_2": "original_array",
                "param_3": "updated_array",
                "iVar1": "entry_index",
                "uVar3": "original_array_length",
                "uVar4": "carry",
                "uVar5": "is_equal",
                "puVar7": "original_ptr",
                "puVar8": "ptr_1",
                "puVar9": "original_ptr_2",
                "puVar10": "ptr_2",
                "puVar11": "original_ptr_end",
                "iVar12": "temp",
                "puVar13": "updated_ptr",
                "uVar14": "updated_array_length"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009630": {
            "entrypoint": "0x08009630",
            "current_name": "reorder_bits_and_count_08009630",
            "code": "\nint reorderBitsAndCount_08009630(undefined4 entry,undefined4 count,uint bit1,uint bit2,int *output1,\n                int *output2)\n\n{\n  int entry;\n  uint result;\n  int bitIndex1;\n  int bitIndex2;\n  uint bitMask;\n  uint shiftCount;\n  undefined8 leadingZerosCount;\n  uint tempBit1;\n  uint tempBit2;\n  \n  entry = initialize_or_get_entry_080090c0(entry,1);\n  shiftCount = (bit2 << 1) >> 0x15;\n  tempBit2 = bit2 & 0xfffff;\n  if (shiftCount != 0) {\n    tempBit2 = tempBit2 | 0x100000;\n  }\n  if (bit1 == 0) {\n    bitIndex1 = find_highest_set_bit_080091e4(&tempBit2);\n    bitIndex2 = 1;\n    result = bitIndex1 + 0x20;\n    *(undefined4 *)(entry + 0x10) = 1;\n    *(uint *)(entry + 0x14) = tempBit2;\n  }\n  else {\n    tempBit1 = bit1;\n    result = find_highest_set_bit_080091e4(&tempBit1);\n    if (result == 0) {\n      *(uint *)(entry + 0x14) = tempBit1;\n    }\n    else {\n      bitMask = tempBit2 << (0x20 - result & 0xff);\n      tempBit2 = tempBit2 >> (result & 0xff);\n      *(uint *)(entry + 0x14) = bitMask | tempBit1;\n    }\n    if (tempBit2 == 0) {\n      bitIndex2 = 1;\n    }\n    else {\n      bitIndex2 = 2;\n    }\n    *(uint *)(entry + 0x18) = tempBit2;\n    *(int *)(entry + 0x10) = bitIndex2;\n  }\n  if (shiftCount == 0) {\n    *output1 = result - 0x432;\n    leadingZerosCount = count_leading_zeros_080091a4(*(undefined4 *)(entry + bitIndex2 * 4 + 0x10));\n    *output2 = (int)((ulonglong)leadingZerosCount >> 0x20) * 0x20 - (int)leadingZerosCount;\n    return entry;\n  }\n  *output1 = (shiftCount - 0x433) + result;\n  *output2 = 0x35 - result;\n  return entry;\n}\n\n",
            "renaming": {
                "FUN_08009630": "reorder_bits_and_count_08009630",
                "param_1": "entry",
                "param_2": "count",
                "param_3": "bit1",
                "param_4": "bit2",
                "param_5": "output1",
                "param_6": "output2",
                "iVar1": "entry",
                "uVar2": "result",
                "iVar3": "bitIndex1",
                "iVar4": "bitIndex2",
                "uVar5": "bitMask",
                "uVar6": "shiftCount",
                "uVar7": "leadingZerosCount",
                "local_20": "tempBit1",
                "local_1c": "tempBit2"
            },
            "calling": [
                "FUN_080079e8"
            ],
            "called": [
                "FUN_080091e4",
                "FUN_080091a4",
                "FUN_080090c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080096e0": {
            "entrypoint": "0x080096e0",
            "current_name": "calculate_float_exponent_080096e0",
            "code": "\nundefined8 calculate_float_exponent_080096e0(uint input_mantissa,uint input_exponent,int *output_exponent,undefined4 param_4)\n\n{\n  int temp_var;\n  uint modified_input_exponent;\n  undefined8 modified_input;\n  \n  modified_input = CONCAT44(input_exponent,input_mantissa);\n  temp_var = 0;\n  modified_input_exponent = input_exponent & 0x7fffffff;\n  *output_exponent = 0;\n  if ((modified_input_exponent < 0x7ff00000) && ((modified_input_exponent | input_mantissa) != 0)) {\n    if (modified_input_exponent < 0x100000) {\n      modified_input = perform_product_and_addition(input_mantissa,input_exponent,0,0x43500000,param_4);\n      temp_var = -0x36;\n      modified_input_exponent = (uint)((ulonglong)modified_input >> 0x20) & 0x7fffffff;\n    }\n    input_mantissa = (uint)modified_input;\n    input_exponent = (uint)((ulonglong)modified_input >> 0x20) & 0x800fffff | 0x3fe00000;\n    *output_exponent = ((int)modified_input_exponent >> 0x14) + -0x3fe + temp_var;\n  }\n  return CONCAT44(input_exponent,input_mantissa);\n}\n\n",
            "renaming": {
                "FUN_080096e0": "calculate_float_exponent_080096e0",
                "param_1": "input_mantissa",
                "param_2": "input_exponent",
                "param_3": "output_exponent",
                "iVar1": "temp_var",
                "uVar2": "modified_input_exponent",
                "uVar3": "modified_input",
                "calculate_product_and_addition_080004c8": "perform_product_and_addition"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_080004c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009744": {
            "entrypoint": "0x08009744",
            "current_name": "allocate_and_set_memory_08009744",
            "code": "\nvoid allocate_and_set_memory_08009744(int *output_ptr,undefined4 size)\n\n{\n  int allocation_result;\n  \n  DAT_20000c10 = 0;\n  allocation_result = allocate_memory_08005728(size);\n  if ((allocation_result == -1) && (DAT_20000c10 != 0)) {\n    *output_ptr = DAT_20000c10;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009744": "allocate_and_set_memory_08009744",
                "param_1": "output_ptr",
                "param_2": "size",
                "iVar1": "allocation_result"
            },
            "calling": [
                "FUN_0800884c",
                "FUN_08008af8"
            ],
            "called": [
                "FUN_08005728"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009768": {
            "entrypoint": "0x08009768",
            "current_name": "copy_and_zero_out_string_08009768",
            "code": "\nvoid copyAndZeroOutString_08009768(uint *destination,uint *source,uint length)\n\n{\n  char currentChar;\n  uint *sourcePtr;\n  uint *destinationPtr;\n  uint currentCharacter;\n  \n  if (((((uint)destination | (uint)source) & 3) == 0) &&\n     (destinationPtr = destination, sourcePtr = source, 3 < length)) {\n    do {\n      source = sourcePtr + 1;\n      currentCharacter = *sourcePtr;\n      destination = destinationPtr;\n      if ((currentCharacter + 0xfefefeff & ~currentCharacter & 0x80808080) != 0) goto LAB_0800979c;\n      length = length - 4;\n      destination = destinationPtr + 1;\n      *destinationPtr = currentCharacter;\n      destinationPtr = destination;\n      sourcePtr = source;\n    } while (3 < length);\n  }\n  sourcePtr = source;\n  if (length != 0) {\nLAB_0800979c:\n    currentChar = *(char *)sourcePtr;\n    *(char *)destination = currentChar;\n    while( true ) {\n      destination = (uint *)((int)destination + 1);\n      length = length - 1;\n      if (currentChar == '\\0') break;\n      if (length == 0) {\n        return;\n      }\n      sourcePtr = (uint *)((int)sourcePtr + 1);\n      currentChar = *(char *)sourcePtr;\n      *(char *)destination = currentChar;\n    }\n    if (length != 0) {\n      sourcePtr = destination;\n      do {\n        destinationPtr = (uint *)((int)sourcePtr + 1);\n        *(char *)sourcePtr = '\\0';\n        sourcePtr = destinationPtr;\n      } while (destinationPtr != (uint *)(length + (int)destination));\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009768": "copy_and_zero_out_string_08009768",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "puVar2": "sourcePtr",
                "puVar3": "destinationPtr",
                "uVar4": "currentCharacter",
                "cVar1": "currentChar"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080097cc": {
            "entrypoint": "0x080097cc",
            "current_name": "copy_and_allocate_memory_080097cc",
            "code": "\nundefined4 copy_and_allocate_memory_080097cc(undefined4 *dest_ptr,int *src_ptr,int *size_ptr)\n\n{\n  int dest_offset;\n  uint src_length;\n  int allocated_memory_ptr;\n  int src_offset;\n  uint allocated_memory_size;\n  uint src_length_remaining;\n  undefined4 *current_src_ptr;\n  undefined4 *next_src_ptr;\n  undefined4 current_src_value;\n  \n  if (size_ptr[2] != 0) {\n    dest_offset = *src_ptr;\n    allocated_memory_size = src_ptr[2];\n    next_src_ptr = (undefined4 *)*size_ptr;\n    do {\n      do {\n        current_src_ptr = next_src_ptr + 2;\n        current_src_value = *next_src_ptr;\n        src_length_remaining = next_src_ptr[1];\n        next_src_ptr = current_src_ptr;\n      } while (src_length_remaining == 0);\n      src_length = src_length_remaining;\n      if ((allocated_memory_size <= src_length_remaining) && (src_length = allocated_memory_size, (*(ushort *)(src_ptr + 3) & 0x480) != 0)) {\n        src_offset = dest_offset - src_ptr[4];\n        allocated_memory_size = (src_ptr[5] * 3) / 2;\n        src_length = src_length_remaining + 1 + src_offset;\n        if (allocated_memory_size < src_length) {\n          allocated_memory_size = src_length;\n        }\n        if ((int)((uint)*(ushort *)(src_ptr + 3) << 0x15) < 0) {\n          allocated_memory_ptr = allocate_and_set_memory_08008af8(dest_ptr,allocated_memory_size);\n          if (allocated_memory_ptr == 0) {\nLAB_08009896:\n            *dest_ptr = 0xc;\n            *(ushort *)(src_ptr + 3) = *(ushort *)(src_ptr + 3) | 0x40;\n            size_ptr[1] = 0;\n            size_ptr[2] = 0;\n            return 0xffffffff;\n          }\n          memcpy_aligned_08001084(allocated_memory_ptr,src_ptr[4],src_offset);\n          *(ushort *)(src_ptr + 3) = *(ushort *)(src_ptr + 3) & 0xfb7f | 0x80;\n        }\n        else {\n          allocated_memory_ptr = allocate_or_initialize_memory_08009adc(dest_ptr);\n          if (allocated_memory_ptr == 0) {\n            initialize_and_allocate_memory_080088ec(dest_ptr,src_ptr[4]);\n            goto LAB_08009896;\n          }\n        }\n        dest_offset = allocated_memory_ptr + src_offset;\n        src_ptr[5] = allocated_memory_size;\n        src_ptr[4] = allocated_memory_ptr;\n        *src_ptr = dest_offset;\n        src_ptr[2] = allocated_memory_size - src_offset;\n        src_length = src_length_remaining;\n      }\n      copy_memory_08009a18(dest_offset,current_src_value,src_length);\n      src_offset = size_ptr[2];\n      allocated_memory_size = src_ptr[2] - src_length;\n      dest_offset = *src_ptr + src_length;\n      src_ptr[2] = allocated_memory_size;\n      *src_ptr = dest_offset;\n      size_ptr[2] = src_offset - src_length_remaining;\n    } while (src_offset - src_length_remaining != 0);\n  }\n  size_ptr[1] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_080097cc": "copy_and_allocate_memory_080097cc",
                "param_1": "dest_ptr",
                "param_2": "src_ptr",
                "param_3": "size_ptr",
                "iVar1": "dest_offset",
                "uVar2": "src_length",
                "iVar3": "allocated_memory_ptr",
                "iVar4": "src_offset",
                "uVar5": "allocated_memory_size",
                "uVar6": "src_length_remaining",
                "puVar7": "current_src_ptr",
                "puVar8": "next_src_ptr",
                "uVar9": "current_src_value"
            },
            "calling": [
                "FUN_08005e9c"
            ],
            "called": [
                "FUN_08009a18",
                "FUN_08001084",
                "FUN_08009adc",
                "FUN_080088ec",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_080098c0": {
            "entrypoint": "0x080098c0",
            "current_name": "update_config_080098c0",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x08009906) */\n/* WARNING: Removing unreachable block (ram,0x08009912) */\n\nundefined4 updateConfig_080098c0(int flag,undefined4 data1,undefined4 data2,undefined4 data3)\n\n{\n  undefined *config;\n  undefined4 returnValue;\n  uint bitMask;\n  uint index;\n  \n  FUNC_08008af0(DAT_20000448);\n  if (DAT_20000168 == (undefined *)0x0) {\n    DAT_20000168 = &DAT_2000016c;\n  }\n  config = DAT_20000168;\n  index = *(uint *)(DAT_20000168 + 4);\n  if ((int)index < 0x20) {\n    if (flag != 0) {\n      *(undefined4 *)(DAT_20000168 + index * 4 + 0x88) = data2;\n      bitMask = 1 << (index & 0xff);\n      *(uint *)(config + 0x188) = *(uint *)(config + 0x188) | bitMask;\n      *(undefined4 *)(config + index * 4 + 0x108) = data3;\n      if (flag == 2) {\n        *(uint *)(config + 0x18c) = bitMask | *(uint *)(config + 0x18c);\n      }\n    }\n    *(uint *)(config + 4) = index + 1;\n    returnValue = DAT_20000448;\n    *(undefined4 *)(config + (index + 2) * 4) = data1;\n    FUNC_08008af4(returnValue);\n    returnValue = 0;\n  }\n  else {\n    FUNC_08008af4(DAT_20000448);\n    returnValue = 0xffffffff;\n  }\n  return returnValue;\n}\n\n",
            "renaming": {
                "FUN_080098c0": "update_config_080098c0",
                "param_1": "flag",
                "param_2": "data1",
                "param_3": "data2",
                "param_4": "data3",
                "puVar1": "config",
                "uVar2": "returnValue",
                "uVar3": "bitMask",
                "uVar4": "index"
            },
            "calling": [
                "FUN_080078a0"
            ],
            "called": [
                "FUN_08008af4",
                "FUN_08008af0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009980": {
            "entrypoint": "0x08009980",
            "current_name": "initialize_memory_08009980",
            "code": "\nundefined4 * initializeMemory_08009980(undefined4 input,int size,int elements)\n\n{\n  undefined4 *allocatedMemory;\n  uint adjustedSize;\n  undefined4 *initializedMemory;\n  \n  allocatedMemory = (undefined4 *)allocate_and_set_memory_08008af8(input,elements * size);\n  if (allocatedMemory == (undefined4 *)0x0) {\n    return (undefined4 *)0x0;\n  }\n  adjustedSize = (allocatedMemory[-1] & 0xfffffffc) - 4;\n  if (adjustedSize < 0x25) {\n    initializedMemory = allocatedMemory;\n    if (0x13 < adjustedSize) {\n      *allocatedMemory = 0;\n      allocatedMemory[1] = 0;\n      if (0x1b < adjustedSize) {\n        allocatedMemory[2] = 0;\n        allocatedMemory[3] = 0;\n        if (adjustedSize == 0x24) {\n          allocatedMemory[4] = 0;\n          allocatedMemory[5] = 0;\n          initializedMemory = allocatedMemory + 6;\n        }\n        else {\n          initializedMemory = allocatedMemory + 4;\n        }\n        *initializedMemory = 0;\n        initializedMemory[1] = 0;\n        initializedMemory[2] = 0;\n        return allocatedMemory;\n      }\n      initializedMemory = allocatedMemory + 2;\n    }\n    *initializedMemory = 0;\n    initializedMemory[1] = 0;\n    initializedMemory[2] = 0;\n    return allocatedMemory;\n  }\n  fill_memory_with_byte_08005d68(allocatedMemory,0);\n  return allocatedMemory;\n}\n\n",
            "renaming": {
                "FUN_08009980": "initialize_memory_08009980",
                "param_1": "input",
                "param_2": "size",
                "param_3": "elements",
                "puVar1": "allocatedMemory",
                "uVar2": "adjustedSize",
                "puVar3": "initializedMemory"
            },
            "calling": [
                "FUN_080090c0"
            ],
            "called": [
                "FUN_08005d68",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009a18": {
            "entrypoint": "0x08009a18",
            "current_name": "copy_memory_08009a18",
            "code": "\nvoid copyMemory_08009a18(undefined4 *dest,undefined4 *src,uint length)\n\n{\n  undefined4 *dest_ptr;\n  undefined4 *src_ptr;\n  int num_loops;\n  undefined *dest_end;\n  undefined4 *src_end;\n  uint remaining_length;\n  uint temp_length;\n  \n  if ((src < dest) && (src_ptr = (undefined4 *)((int)src + length), dest < src_ptr)) {\n    dest_end = (undefined *)((int)dest + length);\n    if (length != 0) {\n      do {\n        src_ptr = (undefined4 *)((int)src_ptr + -1);\n        dest_end = dest_end + -1;\n        *dest_end = *(undefined *)src_ptr;\n      } while (src != src_ptr);\n    }\n  }\n  else {\n    temp_length = length;\n    if (0xf < length) {\n      if ((((uint)dest | (uint)src) & 3) != 0) goto LAB_08009abc;\n      src_ptr = src + 4;\n      dest_ptr = dest + 4;\n      do {\n        src_end = src_ptr + 4;\n        dest_ptr[-4] = src_ptr[-4];\n        dest_ptr[-3] = src_ptr[-3];\n        dest_ptr[-2] = src_ptr[-2];\n        dest_ptr[-1] = src_ptr[-1];\n        src_ptr = src_end;\n        dest_ptr = dest_ptr + 4;\n      } while (src_end != (undefined4 *)((int)src + (length - 0x10 & 0xfffffff0) + 0x20));\n      num_loops = (length - 0x10 >> 4) + 1;\n      temp_length = length & 0xf;\n      src = src + num_loops * 4;\n      dest = dest + num_loops * 4;\n      if (3 < temp_length) {\n        src_ptr = dest + -1;\n        remaining_length = temp_length;\n        dest_ptr = src;\n        do {\n          remaining_length = remaining_length - 4;\n          src_ptr = src_ptr + 1;\n          *src_ptr = *dest_ptr;\n          dest_ptr = dest_ptr + 1;\n        } while (3 < remaining_length);\n        num_loops = (temp_length - 4 & 0xfffffffc) + 4;\n        dest = (undefined4 *)((int)dest + num_loops);\n        src = (undefined4 *)((int)src + num_loops);\n        temp_length = length & 3;\n      }\n    }\n    length = temp_length;\n    if (temp_length != 0) {\nLAB_08009abc:\n      dest_end = (undefined *)((int)dest + -1);\n      src_ptr = src;\n      do {\n        dest_ptr = (undefined4 *)((int)src_ptr + 1);\n        dest_end = dest_end + 1;\n        *dest_end = *(undefined *)src_ptr;\n        src_ptr = dest_ptr;\n      } while (dest_ptr != (undefined4 *)(length + (int)src));\n      return;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009a18": "copy_memory_08009a18",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "length",
                "puVar1": "dest_ptr",
                "puVar2": "src_ptr",
                "iVar3": "num_loops",
                "puVar4": "dest_end",
                "puVar5": "src_end",
                "uVar6": "remaining_length",
                "uVar7": "temp_length"
            },
            "calling": [
                "FUN_08009adc",
                "FUN_080097cc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009adc": {
            "entrypoint": "0x08009adc",
            "current_name": "allocate_or_initialize_memory_08009adc",
            "code": "\nint * allocate_or_initialize_memory_08009adc(undefined4 *memory_ptr,int *prev_memory_ptr,uint size)\n\n{\n  int *temp_ptr_1;\n  int temp_var_1;\n  int *temp_ptr_2;\n  uint temp_var_2;\n  int temp_var_3;\n  uint temp_var_4;\n  int *temp_ptr_3;\n  uint aligned_size;\n  uint temp_var_5;\n  uint temp_var_6;\n  int alloc_ptr;\n  \n  if (prev_memory_ptr == (int *)0x0) {\n    temp_ptr_2 = (int *)allocate_and_set_memory_08008af8(memory_ptr,size);\n    return temp_ptr_2;\n  }\n  initialize_data_080090a8();\n  temp_var_4 = prev_memory_ptr[-1];\n  temp_var_5 = temp_var_4 & 0xfffffffc;\n  temp_ptr_2 = prev_memory_ptr + -2;\n  if (size + 0xb < 0x17) {\n    aligned_size = 0x10;\n  }\n  else {\n    aligned_size = size + 0xb & 0xfffffff8;\n    if ((int)aligned_size < 0) goto LAB_08009b8e;\n  }\n  if (aligned_size < size) {\nLAB_08009b8e:\n    *memory_ptr = 0xc;\n    return (int *)0x0;\n  }\n  alloc_ptr = (int)temp_ptr_2 + temp_var_5;\n  temp_var_6 = temp_var_5;\n  if ((int)temp_var_5 < (int)aligned_size) {\n    if (DAT_20000454 == alloc_ptr) {\n      alloc_ptr = (*(uint *)(DAT_20000454 + 4) & 0xfffffffc) + temp_var_5;\n      if ((int)(aligned_size + 0x10) <= alloc_ptr) {\n        DAT_20000454 = (int)temp_ptr_2 + aligned_size;\n        *(uint *)(DAT_20000454 + 4) = alloc_ptr - aligned_size | 1;\n        prev_memory_ptr[-1] = aligned_size | prev_memory_ptr[-1] & 1U;\n        initialize_data_080090b4(memory_ptr);\n        return prev_memory_ptr;\n      }\n      if (-1 < (int)(temp_var_4 << 0x1f)) {\n        temp_ptr_1 = (int *)((int)temp_ptr_2 - prev_memory_ptr[-2]);\n        temp_var_4 = temp_ptr_1[1] & 0xfffffffc;\n        if ((int)(aligned_size + 0x10) <= (int)(alloc_ptr + temp_var_4)) {\n          temp_var_3 = temp_ptr_1[3];\n          temp_ptr_2 = temp_ptr_1 + 2;\n          temp_var_1 = *temp_ptr_2;\n          temp_var_5 = temp_var_5 - 4;\n          *(int *)(temp_var_1 + 0xc) = temp_var_3;\n          *(int *)(temp_var_3 + 8) = temp_var_1;\n          if (temp_var_5 < 0x25) {\n            temp_var_1 = *prev_memory_ptr;\n            temp_ptr_3 = temp_ptr_2;\n            if (0x13 < temp_var_5) {\n              temp_ptr_1[2] = temp_var_1;\n              temp_ptr_1[3] = prev_memory_ptr[1];\n              temp_var_1 = prev_memory_ptr[2];\n              if (temp_var_5 < 0x1c) {\n                prev_memory_ptr = prev_memory_ptr + 2;\n                temp_ptr_3 = temp_ptr_1 + 4;\n              }\n              else {\n                temp_ptr_1[4] = temp_var_1;\n                temp_ptr_1[5] = prev_memory_ptr[3];\n                temp_var_1 = prev_memory_ptr[4];\n                if (temp_var_5 == 0x24) {\n                  temp_ptr_1[6] = temp_var_1;\n                  temp_ptr_1[7] = prev_memory_ptr[5];\n                  temp_var_1 = prev_memory_ptr[6];\n                  prev_memory_ptr = prev_memory_ptr + 6;\n                  temp_ptr_3 = temp_ptr_1 + 8;\n                }\n                else {\n                  prev_memory_ptr = prev_memory_ptr + 4;\n                  temp_ptr_3 = temp_ptr_1 + 6;\n                }\n              }\n            }\n            *temp_ptr_3 = temp_var_1;\n            temp_ptr_3[1] = prev_memory_ptr[1];\n            temp_ptr_3[2] = prev_memory_ptr[2];\n          }\n          else {\n            copy_memory_08009a18(temp_ptr_2,prev_memory_ptr);\n          }\n          DAT_20000454 = (int)temp_ptr_1 + aligned_size;\n          *(uint *)(DAT_20000454 + 4) = (alloc_ptr + temp_var_4) - aligned_size | 1;\n          temp_ptr_1[1] = aligned_size | temp_ptr_1[1] & 1U;\n          initialize_data_080090b4(memory_ptr);\n          return temp_ptr_2;\n        }\nLAB_08009bb0:\n        temp_var_6 = temp_var_5 + temp_var_4;\n        if ((int)aligned_size <= (int)temp_var_6) {\n          temp_var_3 = temp_ptr_1[3];\n          temp_ptr_3 = temp_ptr_1 + 2;\n          temp_var_1 = *temp_ptr_3;\n          *(int *)(temp_var_1 + 0xc) = temp_var_3;\n          alloc_ptr = (int)temp_ptr_1 + temp_var_6;\n          *(int *)(temp_var_3 + 8) = temp_var_1;\n          temp_ptr_2 = temp_ptr_1;\n          if (temp_var_5 - 4 < 0x25) goto LAB_08009bd0;\nLAB_08009d4c:\n          copy_memory_08009a18(temp_ptr_3,prev_memory_ptr);\n          prev_memory_ptr = temp_ptr_3;\n          goto LAB_08009c00;\n        }\n      }\n    }\n    else {\n      if (-1 < *(int *)((*(uint *)(alloc_ptr + 4) & 0xfffffffe) + alloc_ptr + 4) << 0x1f) {\n        temp_var_2 = *(uint *)(alloc_ptr + 4) & 0xfffffffc;\n        temp_var_6 = temp_var_5 + temp_var_2;\n        if ((int)temp_var_6 < (int)aligned_size) {\n          if ((int)(temp_var_4 << 0x1f) < 0) goto LAB_08009b36;\n          temp_ptr_1 = (int *)((int)temp_ptr_2 - prev_memory_ptr[-2]);\n          temp_var_4 = temp_ptr_1[1] & 0xfffffffc;\n          temp_var_6 = temp_var_2 + temp_var_4 + temp_var_5;\n          if ((int)temp_var_6 < (int)aligned_size) goto LAB_08009bb0;\n          temp_var_1 = *(int *)(alloc_ptr + 8);\n          alloc_ptr = *(int *)(alloc_ptr + 0xc);\n          *(int *)(temp_var_1 + 0xc) = alloc_ptr;\n          *(int *)(alloc_ptr + 8) = temp_var_1;\n          temp_ptr_3 = temp_ptr_1 + 2;\n          temp_var_1 = *temp_ptr_3;\n          temp_var_3 = temp_ptr_1[3];\n          *(int *)(temp_var_1 + 0xc) = temp_var_3;\n          alloc_ptr = (int)temp_ptr_1 + temp_var_6;\n          *(int *)(temp_var_3 + 8) = temp_var_1;\n          temp_ptr_2 = temp_ptr_1;\n          if (0x24 < temp_var_5 - 4) goto LAB_08009d4c;\nLAB_08009bd0:\n          temp_var_5 = temp_var_5 - 4;\n          temp_var_1 = *prev_memory_ptr;\n          temp_ptr_1 = temp_ptr_3;\n          if (0x13 < temp_var_5) {\n            temp_ptr_2[2] = temp_var_1;\n            temp_ptr_2[3] = prev_memory_ptr[1];\n            temp_var_1 = prev_memory_ptr[2];\n            if (temp_var_5 < 0x1c) {\n              prev_memory_ptr = prev_memory_ptr + 2;\n              temp_ptr_1 = temp_ptr_2 + 4;\n            }\n            else {\n              temp_ptr_2[4] = temp_var_1;\n              temp_ptr_2[5] = prev_memory_ptr[3];\n              temp_var_1 = prev_memory_ptr[4];\n              if (temp_var_5 == 0x24) {\n                temp_ptr_2[6] = temp_var_1;\n                temp_ptr_2[7] = prev_memory_ptr[5];\n                temp_var_1 = prev_memory_ptr[6];\n                prev_memory_ptr = prev_memory_ptr + 6;\n                temp_ptr_1 = temp_ptr_2 + 8;\n              }\n              else {\n                prev_memory_ptr = prev_memory_ptr + 4;\n                temp_ptr_1 = temp_ptr_2 + 6;\n              }\n            }\n          }\n          *temp_ptr_1 = temp_var_1;\n          temp_ptr_1[1] = prev_memory_ptr[1];\n          temp_ptr_1[2] = prev_memory_ptr[2];\n          prev_memory_ptr = temp_ptr_3;\n        }\n        else {\n          temp_var_1 = *(int *)(alloc_ptr + 8);\n          temp_var_3 = *(int *)(alloc_ptr + 0xc);\n          *(int *)(temp_var_1 + 0xc) = temp_var_3;\n          alloc_ptr = (int)temp_ptr_2 + temp_var_6;\n          *(int *)(temp_var_3 + 8) = temp_var_1;\n        }\n        goto LAB_08009c00;\n      }\n      if (-1 < (int)(temp_var_4 << 0x1f)) {\n        temp_ptr_1 = (int *)((int)temp_ptr_2 - prev_memory_ptr[-2]);\n        temp_var_4 = temp_ptr_1[1] & 0xfffffffc;\n        goto LAB_08009bb0;\n      }\n    }\nLAB_08009b36:\n    temp_ptr_1 = (int *)allocate_and_set_memory_08008af8(memory_ptr,size);\n    if (temp_ptr_1 != (int *)0x0) {\n      if ((int *)((prev_memory_ptr[-1] & 0xfffffffeU) + (int)temp_ptr_2) == temp_ptr_1 + -2) {\n        temp_var_6 = temp_var_5 + (temp_ptr_1[-1] & 0xfffffffcU);\n        alloc_ptr = (int)temp_ptr_2 + temp_var_6;\n        goto LAB_08009c00;\n      }\n      temp_var_5 = temp_var_5 - 4;\n      if (temp_var_5 < 0x25) {\n        alloc_ptr = *prev_memory_ptr;\n        temp_ptr_2 = prev_memory_ptr;\n        temp_ptr_3 = temp_ptr_1;\n        if (0x13 < temp_var_5) {\n          *temp_ptr_1 = alloc_ptr;\n          temp_ptr_1[1] = prev_memory_ptr[1];\n          if (temp_var_5 < 0x1c) {\n            alloc_ptr = prev_memory_ptr[2];\n            temp_ptr_2 = prev_memory_ptr + 2;\n            temp_ptr_3 = temp_ptr_1 + 2;\n          }\n          else {\n            temp_ptr_1[2] = prev_memory_ptr[2];\n            temp_ptr_1[3] = prev_memory_ptr[3];\n            if (temp_var_5 == 0x24) {\n              temp_ptr_1[4] = prev_memory_ptr[4];\n              temp_ptr_1[5] = prev_memory_ptr[5];\n              alloc_ptr = prev_memory_ptr[6];\n              temp_ptr_2 = prev_memory_ptr + 6;\n              temp_ptr_3 = temp_ptr_1 + 6;\n            }\n            else {\n              alloc_ptr = prev_memory_ptr[4];\n              temp_ptr_2 = prev_memory_ptr + 4;\n              temp_ptr_3 = temp_ptr_1 + 4;\n            }\n          }\n        }\n        *temp_ptr_3 = alloc_ptr;\n        temp_ptr_3[1] = temp_ptr_2[1];\n        temp_ptr_3[2] = temp_ptr_2[2];\n      }\n      else {\n        copy_memory_08009a18(temp_ptr_1,prev_memory_ptr);\n      }\n      initialize_and_allocate_memory_080088ec(memory_ptr,prev_memory_ptr);\n    }\n    initialize_data_080090b4(memory_ptr);\n    prev_memory_ptr = temp_ptr_1;\n  }\n  else {\nLAB_08009c00:\n    if (temp_var_6 - aligned_size < 0x10) {\n      temp_ptr_2[1] = temp_ptr_2[1] & 1U | temp_var_6;\n      *(uint *)(alloc_ptr + 4) = *(uint *)(alloc_ptr + 4) | 1;\n    }\n    else {\n      temp_ptr_2[1] = temp_ptr_2[1] & 1U | aligned_size;\n      *(uint *)((int)temp_ptr_2 + aligned_size + 4) = temp_var_6 - aligned_size | 1;\n      *(uint *)(alloc_ptr + 4) = *(uint *)(alloc_ptr + 4) | 1;\n      initialize_and_allocate_memory_080088ec(memory_ptr,(int)temp_ptr_2 + aligned_size + 8);\n    }\n    initialize_data_080090b4(memory_ptr);\n  }\n  return prev_memory_ptr;\n}\n\n",
            "renaming": {
                "FUN_08009adc": "allocate_or_initialize_memory_08009adc",
                "param_1": "memory_ptr",
                "param_2": "prev_memory_ptr",
                "param_3": "size",
                "piVar1": "temp_ptr_1",
                "iVar2": "temp_var_1",
                "piVar3": "temp_ptr_2",
                "uVar4": "temp_var_2",
                "iVar5": "temp_var_3",
                "uVar6": "temp_var_4",
                "piVar7": "temp_ptr_3",
                "uVar8": "aligned_size",
                "uVar9": "temp_var_5",
                "uVar10": "temp_var_6",
                "iVar11": "alloc_ptr"
            },
            "calling": [
                "FUN_080097cc"
            ],
            "called": [
                "FUN_080090a8",
                "FUN_08009a18",
                "FUN_080090b4",
                "FUN_080088ec",
                "FUN_08008af8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_08009e68": {
            "entrypoint": "0x08009e68",
            "current_name": "FUNC_08009e68",
            "code": "\nvoid FUNC_08009e68(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e68": "FUNC_08009e68"
            },
            "calling": [
                "FUN_08005d20",
                "FUN_08000134",
                "FUN_08000110"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_08009e74": {
            "entrypoint": "0x08009e74",
            "current_name": "FUNC_08009e74",
            "code": "\nvoid FUNC_08009e74(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_08009e74": "FUNC_08009e74"
            },
            "calling": [],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 163314,
    "layers": [
        [
            "FUN_08000110",
            "FUN_08000134",
            "FUN_08000158",
            "FUN_0800015c",
            "FUN_080003d4",
            "FUN_080003f4",
            "FUN_08000418",
            "FUN_080006a4",
            "FUN_0800088a",
            "FUN_080008fc",
            "FUN_080009fc",
            "FUN_08000aa4",
            "FUN_08000aa8",
            "FUN_08000c08",
            "FUN_08000c10",
            "FUN_08000cb8",
            "FUN_08000e20",
            "FUN_08000f68",
            "FUN_08001044",
            "FUN_08001084",
            "FUN_08001170",
            "FUN_0800119c",
            "FUN_0800121c",
            "FUN_0800157c",
            "FUN_080015a0",
            "FUN_080015b4",
            "FUN_080015fc",
            "FUN_08001618",
            "FUN_0800166c",
            "FUN_0800177c",
            "FUN_080017c4",
            "FUN_08001a80",
            "FUN_08002d3c",
            "FUN_08003440",
            "FUN_08003504",
            "FUN_08003568",
            "FUN_0800360c",
            "FUN_08003c94",
            "FUN_08003d60",
            "FUN_08003e38",
            "FUN_08003f18",
            "FUN_08003ff8",
            "FUN_080040a0",
            "FUN_08004104",
            "FUN_0800416a",
            "FUN_080041a8",
            "FUN_080041ea",
            "FUN_0800422e",
            "FUN_080042de",
            "FUN_08004e6c",
            "FUN_08005674",
            "FUN_08005780",
            "FUN_08005d14",
            "FUN_08005d20",
            "FUN_08005d68",
            "FUN_08005dfc",
            "FUN_08005e40",
            "FUN_08008ad4",
            "FUN_0800901c",
            "FUN_080090a8",
            "FUN_080090b4",
            "FUN_0800910c",
            "FUN_080091a4",
            "FUN_080091e4",
            "FUN_080094f8",
            "FUN_08009768",
            "FUN_080098c0",
            "FUN_08009a18"
        ],
        [
            "FUN_080004c8",
            "FUN_0800071c",
            "FUN_08000988",
            "FUN_08000fd0",
            "FUN_080011ec",
            "FUN_080016d0",
            "FUN_08001714",
            "FUN_0800172a",
            "FUN_08002ad8",
            "FUN_08002bb4",
            "FUN_08002c2e",
            "FUN_08002ca8",
            "FUN_08002d98",
            "FUN_08003518",
            "FUN_08003540",
            "FUN_080035a4",
            "FUN_08003640",
            "FUN_080036a8",
            "FUN_08003908",
            "FUN_08003a94",
            "FUN_08004436",
            "FUN_08004ae0",
            "FUN_08004e74",
            "FUN_08004f2c",
            "FUN_08004f60",
            "FUN_080055f4",
            "FUN_08005680",
            "FUN_08005728",
            "FUN_080078c0"
        ],
        [
            "FUN_08000978",
            "FUN_08000998",
            "FUN_080009ac",
            "FUN_080009c0",
            "FUN_08000fc8",
            "FUN_08000ff4",
            "FUN_08001762",
            "FUN_08001ab0",
            "FUN_08002640",
            "FUN_080027f4",
            "FUN_080046ec",
            "FUN_08004f3c",
            "FUN_080053b0",
            "FUN_08005500",
            "FUN_080096e0",
            "FUN_08009744"
        ],
        [
            "FUN_080009d4",
            "FUN_080009e8",
            "FUN_08001030",
            "FUN_0800151c",
            "FUN_08001ccc",
            "FUN_08001f6c",
            "FUN_0800438a",
            "FUN_08005348",
            "FUN_0800884c"
        ],
        [
            "FUN_080014f0",
            "FUN_08003260",
            "FUN_08004ea4",
            "FUN_08004ee8",
            "FUN_08005598",
            "FUN_080059f0",
            "FUN_080088ec"
        ],
        [
            "FUN_080052a0",
            "thunk_FUN_08005838",
            "FUN_08005838",
            "FUN_08008af8"
        ],
        [
            "FUN_08004bd8",
            "FUN_08004d78",
            "FUN_08009980",
            "FUN_08009adc"
        ],
        [
            "FUN_080049cc",
            "FUN_08004f78",
            "FUN_080090c0",
            "FUN_080097cc"
        ],
        [
            "FUN_080017b4",
            "FUN_080036f8",
            "FUN_0800491c",
            "FUN_08009120",
            "FUN_08009244",
            "FUN_08009258",
            "FUN_08009444",
            "FUN_08009530",
            "FUN_08009630"
        ],
        [
            "FUN_08005224",
            "FUN_08005704",
            "FUN_08005714",
            "FUN_080093a4"
        ],
        [
            "FUN_080079e8"
        ]
    ],
    "locked_functions": []
}