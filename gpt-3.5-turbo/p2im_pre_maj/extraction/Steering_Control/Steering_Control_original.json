{
  "functions": {
    "__do_global_dtors_aux": {
      "entrypoint": "0x000800f4",
      "current_name": "__do_global_dtors_aux",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 __do_global_dtors_aux(undefined4 param_1)\n\n{\n  if ((char)completed_7857 \u003d\u003d \u0027\\0\u0027) {\n    completed_7857._0_1_ \u003d \u0027\\x01\u0027;\n  }\n  return param_1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_fini_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "frame_dummy": {
      "entrypoint": "0x00080118",
      "current_name": "frame_dummy",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid frame_dummy(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "aflCall": {
      "entrypoint": "0x00080148",
      "current_name": "aflCall",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t aflCall(uint32_t a0,uint32_t a1,int32_t a2)\n\n{\n  software_interrupt(0x3f);\n  return a0;\n}\n\n",
      "renaming": {},
      "calling": [
        "startForkserver"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "startForkserver": {
      "entrypoint": "0x0008014c",
      "current_name": "startForkserver",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint startForkserver(int ticks)\n\n{\n  uint32_t uVar1;\n  \n  if (noHyperCall \u003d\u003d 0) {\n    uVar1 \u003d aflCall(1,ticks,0);\n    return uVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "aflCall"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "straightAndStop": {
      "entrypoint": "0x00080164",
      "current_name": "straightAndStop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid straightAndStop(void)\n\n{\n  void *in_r2;\n  size_t in_r3;\n  \n  Servo::write(\u0026throttle,0x5a,in_r2,in_r3);\n  Servo::write(\u0026steering,0x5a,in_r2,in_r3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "loop"
      ],
      "called": [
        "write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_steering": {
      "entrypoint": "0x00080184",
      "current_name": "_GLOBAL__sub_I_steering",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I_steering(void)\n\n{\n  undefined4 in_r3;\n  \n  Servo::Servo(\u0026steering);\n  Servo::Servo(\u0026throttle);\n  String::String(\u0026command,\"\");\n  __aeabi_atexit(\u0026command,0x81473,\u0026__dso_handle);\n  String::String(\u0026value,\"\");\n  __aeabi_atexit(\u0026value,0x81473,\u0026__dso_handle,in_r3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "String",
        "Servo",
        "__aeabi_atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "setup": {
      "entrypoint": "0x000801e0",
      "current_name": "setup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid setup(void)\n\n{\n  UARTClass::begin(\u0026Serial,0xe100);\n  pinMode(0xd,1);\n  pinMode(6,1);\n  pinMode(0x39,0);\n  pinMode(4,0);\n  pinMode(3,0);\n  pinMode(2,0);\n  Servo::attach(\u0026steering,5);\n  Servo::attach(\u0026throttle,6);\n  straightAndStop();\n  delay(1000);\n  startForkserver(0);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "startForkserver",
        "delay",
        "pinMode",
        "straightAndStop",
        "attach",
        "begin"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "loop": {
      "entrypoint": "0x00080250",
      "current_name": "loop",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid loop(void)\n\n{\n  uchar uVar1;\n  uint32_t x;\n  int rxMotorRaw;\n  int iVar2;\n  long __fd;\n  Servo *this;\n  uint uVar3;\n  int __fd_00;\n  int __in_chrg;\n  int __in_chrg_00;\n  int __fd_01;\n  void *pvVar4;\n  size_t sVar5;\n  String SStack_1c;\n  \n  rxMode \u003d pulseIn(4,1,20000);\n  delay(10);\n  uVar3 \u003d (uint)LEDstatus;\n  LEDstatus \u003d SUB41(uVar3 ^ 1,0);\n  digitalWrite(0xd,uVar3 ^ 1);\n  if (rxMode \u003c 0x641) {\n    if (rxMode - 0x385U \u003c 299) {\n      if (mode !\u003d false) {\n        straightAndStop();\n        Print::println((Print *)\u0026Serial,\"Entered manual control mode.\");\n        mode \u003d false;\n      }\n      delay(10);\n      x \u003d pulseIn(3,1,20000);\n      rxSteer \u003d map(0,1000,2000,0x28,0x96);\n      pvVar4 \u003d (void *)0x7d0;\n      sVar5 \u003d 0x28;\n      rxMotor \u003d map(x,1000,2000,0x28,0x96);\n      while (iVar2 \u003d UARTClass::available(\u0026Serial), 0 \u003c iVar2) {\n        UARTClass::read(\u0026Serial,__fd_00,pvVar4,sVar5);\n        Print::print((Print *)\u0026Serial,rxSteer,10);\n        Print::print((Print *)\u0026Serial,\",\");\n        pvVar4 \u003d (void *)0xa;\n        Print::println((Print *)\u0026Serial,rxMotor,10);\n      }\n      Servo::write(\u0026throttle,rxMotor,pvVar4,sVar5);\n      Servo::write(\u0026steering,rxSteer,pvVar4,sVar5);\n    }\n    else {\n      if (mode \u003d\u003d false) {\n        straightAndStop();\n        Print::println((Print *)\u0026Serial,\"Entered autonomous control mode.\");\n      }\n      sVar5 \u003d 1;\n      mode \u003d true;\nLAB_00080346:\n      iVar2 \u003d UARTClass::available(\u0026Serial);\n      if (0 \u003c iVar2) {\n        Stream::readStringUntil((Stream *)\u0026Serial,\u0027,\u0027);\n        String::operator\u003d(\u0026command,\u0026SStack_1c);\n        String::~String(\u0026SStack_1c,__in_chrg);\n        pvVar4 \u003d (void *)0xa;\n        Stream::readStringUntil((Stream *)\u0026Serial,\u0027\\n\u0027);\n        String::operator\u003d(\u0026value,\u0026SStack_1c);\n        String::~String(\u0026SStack_1c,__in_chrg_00);\n        UARTClass::read(\u0026Serial,__fd_01,pvVar4,sVar5);\n        uVar1 \u003d String::equals(\u0026command,\"steer\");\n        if (uVar1 \u003d\u003d \u0027\\0\u0027) goto LAB_0008039c;\n        __fd \u003d String::toInt(\u0026value);\n        this \u003d \u0026steering;\n        goto LAB_000803b2;\n      }\n    }\n  }\n  else {\n    straightAndStop();\n    Print::println((Print *)\u0026Serial,\"error\");\n  }\n  return;\nLAB_0008039c:\n  uVar1 \u003d String::equals(\u0026command,\"motor\");\n  if (uVar1 !\u003d \u0027\\0\u0027) {\n    __fd \u003d String::toInt(\u0026value);\n    this \u003d \u0026throttle;\nLAB_000803b2:\n    Servo::write(this,__fd,pvVar4,sVar5);\n  }\n  goto LAB_00080346;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "map",
        "print",
        "equals",
        "readStringUntil",
        "delay",
        "print",
        "read",
        "operator\u003d",
        "println",
        "write",
        "available",
        "toInt",
        "digitalWrite",
        "pulseIn",
        "~String",
        "straightAndStop",
        "println"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_initISR": {
      "entrypoint": "0x000803fc",
      "current_name": "_initISR",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _initISR(Tc *tc,uint32_t channel,uint32_t id,IRQn_Type irqn)\n\n{\n  pmc_enable_periph_clk(id);\n  TC_Configure(tc,channel,0xc002);\n  TC_SetRA(tc,channel,0xa41);\n  *(int *)(((uint)(int)irqn \u003e\u003e 5) * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c ((int)irqn \u0026 0x1fU);\n  tc-\u003eTC_CHANNEL[channel].TC_IER \u003d 4;\n  TC_Start(tc,channel);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "attach"
      ],
      "called": [
        "TC_SetRA",
        "TC_Configure",
        "pmc_enable_periph_clk",
        "TC_Start"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Servo_Handler": {
      "entrypoint": "0x0008044c",
      "current_name": "Servo_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid Servo_Handler(timer16_Sequence_t timer,Tc *tc,uint8_t channel)\n\n{\n  uint uVar1;\n  uint uVar2;\n  RwReg RVar3;\n  int iVar4;\n  \n  uVar1 \u003d (uint)timer;\n  if ((Channel[uVar1] \u0026 0x80U) \u003d\u003d 0) {\n    iVar4 \u003d uVar1 * 0xc;\n    if ((Channel[uVar1] + iVar4 \u003c (int)(uint)ServoCount) \u0026\u0026\n       ((int)((uint)(byte)servos[Channel[uVar1] + iVar4].Pin \u003c\u003c 0x19) \u003c 0)) {\n      digitalWrite((byte)servos[iVar4 + Channel[uVar1]].Pin \u0026 0x3f,0);\n    }\n  }\n  else {\n    tc-\u003eTC_CHANNEL[channel].TC_CCR \u003d tc-\u003eTC_CHANNEL[channel].TC_CCR | 4;\n  }\n  uVar2 \u003d (uint)ServoCount;\n  Channel[uVar1] \u003d Channel[uVar1] + \u0027\\x01\u0027;\n  iVar4 \u003d uVar1 * 0xc;\n  if ((Channel[uVar1] + iVar4 \u003c (int)uVar2) \u0026\u0026 (Channel[uVar1] \u003c \u0027\\f\u0027)) {\n    tc-\u003eTC_CHANNEL[channel].TC_RA \u003d\n         tc-\u003eTC_CHANNEL[channel].TC_CV + servos[Channel[uVar1] + iVar4].ticks;\n    if (-1 \u003c (int)((uint)(byte)servos[Channel[uVar1] + iVar4].Pin \u003c\u003c 0x19)) {\n      return;\n    }\n    digitalWrite((byte)servos[iVar4 + Channel[uVar1]].Pin \u0026 0x3f,1);\n    return;\n  }\n  RVar3 \u003d (SystemCoreClock / 1000000) * 20000 \u003e\u003e 5;\n  if (RVar3 \u003c\u003d tc-\u003eTC_CHANNEL[channel].TC_CV + 4) {\n    RVar3 \u003d tc-\u003eTC_CHANNEL[channel].TC_CV + 4;\n  }\n  tc-\u003eTC_CHANNEL[channel].TC_RA \u003d RVar3;\n  Channel[uVar1] \u003d -1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "TC0_Handler",
        "TC3_Handler",
        "TC4_Handler",
        "TC5_Handler",
        "TC2_Handler"
      ],
      "called": [
        "digitalWrite"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TC3_Handler": {
      "entrypoint": "0x00080558",
      "current_name": "TC3_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TC3_Handler(void)\n\n{\n  Servo_Handler(_timer1,(Tc *)0x40084000,\u0027\\0\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "Servo_Handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TC4_Handler": {
      "entrypoint": "0x00080568",
      "current_name": "TC4_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TC4_Handler(void)\n\n{\n  Servo_Handler(_timer2,(Tc *)0x40084000,\u0027\\x01\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "Servo_Handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TC5_Handler": {
      "entrypoint": "0x00080578",
      "current_name": "TC5_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TC5_Handler(void)\n\n{\n  Servo_Handler(_timer3,(Tc *)0x40084000,\u0027\\x02\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "Servo_Handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TC2_Handler": {
      "entrypoint": "0x00080588",
      "current_name": "TC2_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TC2_Handler(void)\n\n{\n  Servo_Handler(_timer4,(Tc *)0x40080000,\u0027\\x02\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "Servo_Handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TC0_Handler": {
      "entrypoint": "0x00080598",
      "current_name": "TC0_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid TC0_Handler(void)\n\n{\n  Servo_Handler(_timer5,(Tc *)0x40080000,\u0027\\0\u0027);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "Servo_Handler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Servo": {
      "entrypoint": "0x000805a8",
      "current_name": "Servo",
      "code": "\n/* DWARF original prototype: Servo *  Servo(Servo * this) */\n\nServo * __thiscall Servo::Servo(Servo *this)\n\n{\n  uint8_t uVar1;\n  uint uVar2;\n  \n  uVar2 \u003d (uint)ServoCount;\n  if (uVar2 \u003c 0x3c) {\n    uVar1 \u003d ServoCount + \u0027\\x01\u0027;\n    this-\u003eservoIndex \u003d ServoCount;\n    ServoCount \u003d uVar1;\n    servos[uVar2].ticks \u003d (SystemCoreClock / 1000000) * 0x5dc \u003e\u003e 5;\n    return this;\n  }\n  this-\u003eservoIndex \u003d 0xff;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_steering"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "attach": {
      "entrypoint": "0x000806a0",
      "current_name": "attach",
      "code": "\n/* DWARF original prototype: uint8_t  attach(Servo * this, int pin) */\n\nuint8_t __thiscall Servo::attach(Servo *this,int pin)\n\n{\n  uint8_t uVar1;\n  \n  uVar1 \u003d attach(this,pin,0x220,0x960);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup"
      ],
      "called": [
        "attach"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "writeMicroseconds": {
      "entrypoint": "0x000806ac",
      "current_name": "writeMicroseconds",
      "code": "\n/* DWARF original prototype: void  writeMicroseconds(Servo * this, int value) */\n\nvoid __thiscall Servo::writeMicroseconds(Servo *this,int value)\n\n{\n  byte *channel;\n  int iVar1;\n  int iVar2;\n  \n  if (this-\u003eservoIndex \u003c 0x3c) {\n    iVar1 \u003d 0x88 - this-\u003emin;\n    iVar2 \u003d iVar1 * 4;\n    if ((value + iVar1 * -4 \u003c 0 \u003d\u003d SBORROW4(value,iVar2)) \u0026\u0026\n       (iVar2 \u003d (600 - this-\u003emax) * 4, value \u003c\u003d iVar2)) {\n      iVar2 \u003d value;\n    }\n    servos[this-\u003eservoIndex].ticks \u003d (SystemCoreClock / 1000000) * (iVar2 + -2) \u003e\u003e 5;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "write": {
      "entrypoint": "0x000812b8",
      "current_name": "write",
      "code": "\n/* DWARF original prototype: size_t  write(UARTClass * this, uint8_t uc_data) */\n\nssize_t __thiscall UARTClass::write(UARTClass *this,int __fd,void *__buf,size_t __n)\n\n{\n  RingBuffer *pRVar1;\n  uint uVar2;\n  \n  pRVar1 \u003d this-\u003e_tx_buffer;\n  if (((int)(this-\u003e_pUart-\u003eUART_SR \u003c\u003c 0x1e) \u003c 0) \u0026\u0026 (pRVar1-\u003e_iTail \u003d\u003d pRVar1-\u003e_iHead)) {\n    this-\u003e_pUart-\u003eUART_THR \u003d __fd;\n  }\n  else {\n    uVar2 \u003d pRVar1-\u003e_iHead + 1U \u0026 0x8000007f;\n    if ((int)uVar2 \u003c 0) {\n      uVar2 \u003d (uVar2 - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (pRVar1-\u003e_iTail \u003d\u003d uVar2);\n    pRVar1-\u003e_aucBuffer[pRVar1-\u003e_iHead] \u003d (uchar)__fd;\n    this-\u003e_tx_buffer-\u003e_iHead \u003d uVar2;\n    this-\u003e_pUart-\u003eUART_IER \u003d 2;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEvent": {
      "entrypoint": "0x0008073a",
      "current_name": "serialEvent",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEvent(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UART_Handler": {
      "entrypoint": "0x0008073c",
      "current_name": "UART_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid UART_Handler(void)\n\n{\n  UARTClass::IrqHandler(\u0026Serial);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "IrqHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEvent1": {
      "entrypoint": "0x00080748",
      "current_name": "serialEvent1",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEvent1(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEvent2": {
      "entrypoint": "0x0008074a",
      "current_name": "serialEvent2",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEvent2(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEvent3": {
      "entrypoint": "0x0008074c",
      "current_name": "serialEvent3",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEvent3(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART0_Handler": {
      "entrypoint": "0x00080750",
      "current_name": "USART0_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART0_Handler(void)\n\n{\n  UARTClass::IrqHandler(\u0026Serial1.super_UARTClass);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "IrqHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART1_Handler": {
      "entrypoint": "0x0008075c",
      "current_name": "USART1_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART1_Handler(void)\n\n{\n  UARTClass::IrqHandler(\u0026Serial2.super_UARTClass);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "IrqHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USART3_Handler": {
      "entrypoint": "0x00080768",
      "current_name": "USART3_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid USART3_Handler(void)\n\n{\n  UARTClass::IrqHandler(\u0026Serial3.super_UARTClass);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "IrqHandler"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "init": {
      "entrypoint": "0x0008136c",
      "current_name": "init",
      "code": "\n/* DWARF original prototype: void  init(UARTClass * this, uint32_t dwBaudRate, uint32_t modeReg) */\n\nint __thiscall UARTClass::init(UARTClass *this,EVP_PKEY_CTX *ctx)\n\n{\n  uint uVar1;\n  RingBuffer *pRVar2;\n  RwReg in_r2;\n  Uart *pUVar3;\n  \n  pmc_enable_periph_clk(this-\u003e_dwId);\n  pUVar3 \u003d this-\u003e_pUart;\n  pUVar3-\u003eUART_PTCR \u003d 0x202;\n  pUVar3-\u003eUART_CR \u003d 0xac;\n  pUVar3-\u003eUART_MR \u003d in_r2;\n  pUVar3-\u003eUART_BRGR \u003d SystemCoreClock / (uint)ctx \u003e\u003e 4;\n  pUVar3-\u003eUART_IDR \u003d 0xffffffff;\n  pUVar3-\u003eUART_IER \u003d 0x61;\n  uVar1 \u003d (uint)(int)this-\u003e_dwIrq \u003e\u003e 5;\n  *(int *)(uVar1 * 4 + -0x1fff1f00) \u003d 1 \u003c\u003c (uint)(byte)(this-\u003e_dwIrq \u0026 0x1f);\n  pRVar2 \u003d this-\u003e_rx_buffer;\n  pRVar2-\u003e_iTail \u003d 0;\n  pRVar2-\u003e_iHead \u003d 0;\n  pRVar2 \u003d this-\u003e_tx_buffer;\n  pRVar2-\u003e_iTail \u003d 0;\n  pRVar2-\u003e_iHead \u003d 0;\n  pUVar3-\u003eUART_CR \u003d 0x50;\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "begin",
        "begin"
      ],
      "called": [
        "pmc_enable_periph_clk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_GLOBAL__sub_I_g_APinDescription": {
      "entrypoint": "0x0008089c",
      "current_name": "_GLOBAL__sub_I_g_APinDescription",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _GLOBAL__sub_I_g_APinDescription(void)\n\n{\n  RingBuffer::RingBuffer(\u0026rx_buffer1);\n  RingBuffer::RingBuffer(\u0026tx_buffer1);\n  UARTClass::UARTClass(\u0026Serial,(Uart *)0x400e0800,UART_IRQn,8,\u0026rx_buffer1,\u0026tx_buffer1);\n  RingBuffer::RingBuffer(\u0026rx_buffer2);\n  RingBuffer::RingBuffer(\u0026rx_buffer3);\n  RingBuffer::RingBuffer(\u0026rx_buffer4);\n  RingBuffer::RingBuffer(\u0026tx_buffer2);\n  RingBuffer::RingBuffer(\u0026tx_buffer3);\n  RingBuffer::RingBuffer(\u0026tx_buffer4);\n  USARTClass::USARTClass(\u0026Serial1,(Usart *)0x40098000,USART0_IRQn,0x11,\u0026rx_buffer2,\u0026tx_buffer2);\n  USARTClass::USARTClass(\u0026Serial2,(Usart *)0x4009c000,USART1_IRQn,0x12,\u0026rx_buffer3,\u0026tx_buffer3);\n  USARTClass::USARTClass(\u0026Serial3,(Usart *)0x400a4000,USART3_IRQn,0x14,\u0026rx_buffer4,\u0026tx_buffer4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "UARTClass",
        "RingBuffer",
        "USARTClass"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "serialEventRun": {
      "entrypoint": "0x00080970",
      "current_name": "serialEventRun",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid serialEventRun(void)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d UARTClass::available(\u0026Serial);\n  if (iVar1 !\u003d 0) {\n    serialEvent();\n  }\n  iVar1 \u003d UARTClass::available(\u0026Serial1.super_UARTClass);\n  if (iVar1 !\u003d 0) {\n    serialEvent1();\n  }\n  iVar1 \u003d UARTClass::available(\u0026Serial2.super_UARTClass);\n  if (iVar1 !\u003d 0) {\n    serialEvent2();\n  }\n  iVar1 \u003d UARTClass::available(\u0026Serial3.super_UARTClass);\n  if (iVar1 !\u003d 0) {\n    serialEvent3();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "serialEvent2",
        "serialEvent3",
        "serialEvent1",
        "serialEvent",
        "available"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_PullUp": {
      "entrypoint": "0x000809b4",
      "current_name": "PIO_PullUp",
      "code": "\nvoid PIO_PullUp(int param_1,undefined4 param_2,int param_3)\n\n{\n  if (param_3 !\u003d 0) {\n    *(undefined4 *)(param_1 + 100) \u003d param_2;\n    return;\n  }\n  *(undefined4 *)(param_1 + 0x60) \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_SetPeripheral": {
      "entrypoint": "0x000809be",
      "current_name": "PIO_SetPeripheral",
      "code": "\nvoid PIO_SetPeripheral(int param_1,undefined4 param_2,uint param_3)\n\n{\n  uint uVar1;\n  \n  *(uint *)(param_1 + 0x44) \u003d param_3;\n  switch(param_2) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    uVar1 \u003d *(uint *)(param_1 + 0x70) \u0026 *(uint *)(param_1 + 0x70) \u0026 ~param_3;\n    break;\n  case 2:\n    uVar1 \u003d *(uint *)(param_1 + 0x70) | param_3;\n    break;\n  default:\n    goto switchD_000809c4_caseD_6;\n  }\n  *(uint *)(param_1 + 0x70) \u003d uVar1;\nswitchD_000809c4_caseD_6:\n  *(uint *)(param_1 + 4) \u003d param_3;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PIO_Configure"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_SetInput": {
      "entrypoint": "0x000809e4",
      "current_name": "PIO_SetInput",
      "code": "\nvoid PIO_SetInput(undefined4 *param_1,undefined4 param_2,uint param_3)\n\n{\n  bool bVar1;\n  \n  bVar1 \u003d (int)(param_3 \u003c\u003c 0x1f) \u003c 0;\n  param_1[0x11] \u003d param_2;\n  if (bVar1) {\n    param_1[0x19] \u003d param_2;\n  }\n  if (!bVar1) {\n    param_1[0x18] \u003d param_2;\n  }\n  bVar1 \u003d (param_3 \u0026 10) !\u003d 0;\n  if (bVar1) {\n    param_1[8] \u003d param_2;\n  }\n  if (!bVar1) {\n    param_1[9] \u003d param_2;\n  }\n  if (((int)(param_3 \u003c\u003c 0x1e) \u003c 0) || ((int)(param_3 \u003c\u003c 0x1c) \u003c 0)) {\n    param_1[0x20] \u003d param_2;\n  }\n  param_1[5] \u003d param_2;\n  *param_1 \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PIO_Configure"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_SetOutput": {
      "entrypoint": "0x00080a0a",
      "current_name": "PIO_SetOutput",
      "code": "\nvoid PIO_SetOutput(undefined4 *param_1,undefined4 param_2,int param_3,int param_4,int param_5)\n\n{\n  param_1[0x11] \u003d param_2;\n  if (param_5 \u003d\u003d 0) {\n    param_1[0x18] \u003d param_2;\n  }\n  else {\n    param_1[0x19] \u003d param_2;\n  }\n  if (param_4 \u003d\u003d 0) {\n    param_1[0x15] \u003d param_2;\n  }\n  else {\n    param_1[0x14] \u003d param_2;\n  }\n  if (param_3 \u003d\u003d 0) {\n    param_1[0xd] \u003d param_2;\n  }\n  else {\n    param_1[0xc] \u003d param_2;\n  }\n  param_1[4] \u003d param_2;\n  *param_1 \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "PIO_Configure",
        "digitalWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_Configure": {
      "entrypoint": "0x00080a30",
      "current_name": "PIO_Configure",
      "code": "\nundefined4 PIO_Configure(int param_1,int param_2,undefined4 param_3,uint param_4)\n\n{\n  bool bVar1;\n  \n  switch(param_2) {\n  case 1:\n  case 2:\n    PIO_SetPeripheral(param_1,param_2,param_3);\n    bVar1 \u003d (int)(param_4 \u003c\u003c 0x1f) \u003c 0;\n    *(undefined4 *)(param_1 + 0x44) \u003d param_3;\n    if (bVar1) {\n      *(undefined4 *)(param_1 + 100) \u003d param_3;\n    }\n    if (!bVar1) {\n      *(undefined4 *)(param_1 + 0x60) \u003d param_3;\n    }\n    break;\n  case 3:\n    PIO_SetInput(param_1,param_3,param_4,0x809e5,param_1);\n    break;\n  case 4:\n  case 5:\n    PIO_SetOutput(param_1,param_3,param_2 \u003d\u003d 5,(param_4 \u003c\u003c 0x1d) \u003e\u003e 0x1f,param_4 \u0026 1,param_2,param_3\n                 );\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode",
        "init"
      ],
      "called": [
        "PIO_SetPeripheral",
        "PIO_SetOutput",
        "PIO_SetInput"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIO_GetOutputDataStatus": {
      "entrypoint": "0x00080a94",
      "current_name": "PIO_GetOutputDataStatus",
      "code": "\nuint PIO_GetOutputDataStatus(int param_1,uint param_2)\n\n{\n  uint uVar1;\n  \n  uVar1 \u003d *(uint *)(param_1 + 8) \u0026 param_2;\n  if (uVar1 !\u003d 0) {\n    if ((param_2 \u0026 *(uint *)(param_1 + 0x18)) \u003d\u003d 0) {\n      uVar1 \u003d 0;\n    }\n    else {\n      uVar1 \u003d 1;\n    }\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "digitalWrite"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pmc_enable_periph_clk": {
      "entrypoint": "0x00080aa8",
      "current_name": "pmc_enable_periph_clk",
      "code": "\n\n\nundefined4 pmc_enable_periph_clk(uint param_1)\n\n{\n  uint uVar1;\n  \n  if (param_1 \u003c 0x2d) {\n    if (param_1 \u003c 0x20) {\n      uVar1 \u003d 1 \u003c\u003c (param_1 \u0026 0xff);\n      if ((uVar1 \u0026 _DAT_400e0618) !\u003d uVar1) {\n        _DAT_400e0610 \u003d uVar1;\n      }\n    }\n    else {\n      uVar1 \u003d 1 \u003c\u003c (param_1 - 0x20 \u0026 0xff);\n      if ((uVar1 \u0026 _DAT_400e0708) !\u003d uVar1) {\n        _DAT_400e0700 \u003d uVar1;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "init",
        "_initISR",
        "pinMode",
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pmc_disable_periph_clk": {
      "entrypoint": "0x00080aec",
      "current_name": "pmc_disable_periph_clk",
      "code": "\n\n\nundefined4 pmc_disable_periph_clk(uint param_1)\n\n{\n  uint uVar1;\n  uint uVar2;\n  \n  if (param_1 \u003c 0x2d) {\n    if (param_1 \u003c 0x20) {\n      uVar1 \u003d 1 \u003c\u003c (param_1 \u0026 0xff);\n      uVar2 \u003d _DAT_400e0618 \u0026 uVar1;\n      if (uVar2 \u003d\u003d uVar1) {\n        _DAT_400e0614 \u003d uVar2;\n      }\n    }\n    else {\n      uVar1 \u003d 1 \u003c\u003c (param_1 - 0x20 \u0026 0xff);\n      uVar2 \u003d _DAT_400e0708 \u0026 uVar1;\n      if (uVar2 \u003d\u003d uVar1) {\n        _DAT_400e0704 \u003d uVar2;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode",
        "end"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TC_Configure": {
      "entrypoint": "0x00080b2c",
      "current_name": "TC_Configure",
      "code": "\nvoid TC_Configure(undefined4 param_1,uint param_2,char *param_3)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined8 uVar3;\n  \n  uVar3 \u003d CONCAT44(param_2,param_1);\n  if (2 \u003c param_2) {\n    param_3 \u003d \"TC_Configure\";\n    uVar3 \u003d __assert_func(\"../source/tc.c\",0x40,\"TC_Configure\",\n                          \"dwChannel \u003c (sizeof( pTc-\u003eTC_CHANNEL )/sizeof( pTc-\u003eTC_CHANNEL[0] ))\");\n  }\n  iVar1 \u003d (int)((ulonglong)uVar3 \u003e\u003e 0x20) * 0x40;\n  iVar2 \u003d (int)uVar3 + iVar1;\n  *(undefined4 *)((int)uVar3 + iVar1) \u003d 2;\n  *(undefined4 *)(iVar2 + 0x28) \u003d 0xffffffff;\n  *(char **)(iVar2 + 4) \u003d param_3;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_initISR"
      ],
      "called": [
        "__assert_func"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TC_Start": {
      "entrypoint": "0x00080b64",
      "current_name": "TC_Start",
      "code": "\nvoid TC_Start(undefined4 param_1,uint param_2)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 \u003d CONCAT44(param_2,param_1);\n  if (2 \u003c param_2) {\n    uVar1 \u003d __assert_func(\"../source/tc.c\",0x5c,\"TC_Start\",\n                          \"dwChannel \u003c (sizeof( pTc-\u003eTC_CHANNEL )/sizeof( pTc-\u003eTC_CHANNEL[0] ))\");\n  }\n  *(undefined4 *)((int)uVar1 + (int)((ulonglong)uVar1 \u003e\u003e 0x20) * 0x40) \u003d 5;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_initISR"
      ],
      "called": [
        "__assert_func"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TC_SetRA": {
      "entrypoint": "0x00080b90",
      "current_name": "TC_SetRA",
      "code": "\nvoid TC_SetRA(int param_1,int param_2,undefined4 param_3)\n\n{\n  *(undefined4 *)(param_1 + param_2 * 0x40 + 0x14) \u003d param_3;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_initISR"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SystemInit": {
      "entrypoint": "0x00080b98",
      "current_name": "SystemInit",
      "code": "\n\n\nvoid SystemInit(void)\n\n{\n  _DAT_400e0a00 \u003d 0x400;\n  _DAT_400e0c00 \u003d 0x400;\n  _DAT_400e0620 \u003d _DAT_400e0620 \u003c\u003c 7;\n  while (-1 \u003c _DAT_400e0620) {\n    _DAT_400e0620 \u003d _DAT_400e0668 \u003c\u003c 0x1f;\n  }\n  _DAT_400e0620 \u003d 0x1370809;\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0xf);\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0x1c);\n  _DAT_400e0628 \u003d 0x200d3f01;\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0x1e);\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0x1c);\n  _DAT_400e0630 \u003d 0x12;\n  do {\n  } while (-1 \u003c _DAT_400e0668 \u003c\u003c 0x1c);\n  SystemCoreClock \u003d 84000000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "Reset_Handler": {
      "entrypoint": "0x00080c20",
      "current_name": "Reset_Handler",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00080c6a) */\n\n\nvoid Reset_Handler(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  for (iVar1 \u003d 0; banzai + iVar1 \u003c \u0026completed_7857; iVar1 \u003d iVar1 + 4) {\n    *(undefined4 *)(banzai + iVar1) \u003d *(undefined4 *)(\u0026_etext + iVar1);\n  }\n  for (puVar2 \u003d \u0026completed_7857; puVar2 \u003c \u0026_ebss; puVar2 \u003d puVar2 + 1) {\n    *puVar2 \u003d 0;\n  }\n  _DAT_e000ed08 \u003d 0x80000;\n  main();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "banzai",
        "main"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_init": {
      "entrypoint": "0x00080c98",
      "current_name": "adc_init",
      "code": "\nundefined4 adc_init(undefined4 *param_1,uint param_2,int param_3,int param_4)\n\n{\n  uint uVar1;\n  uint uVar2;\n  uint local_58 [16];\n  \n  local_58[0] \u003d 0;\n  local_58[1] \u003d 8;\n  local_58[2] \u003d 0x10;\n  local_58[3] \u003d 0x18;\n  local_58[4] \u003d 0x40;\n  local_58[5] \u003d 0x50;\n  local_58[6] \u003d 0x60;\n  local_58[7] \u003d 0x70;\n  local_58[8] \u003d 0x200;\n  local_58[9] \u003d 0x240;\n  local_58[10] \u003d 0x280;\n  local_58[11] \u003d 0x2c0;\n  local_58[12] \u003d 0x300;\n  local_58[13] \u003d 0x340;\n  local_58[14] \u003d 0x380;\n  local_58[15] \u003d 0x3c0;\n  *param_1 \u003d 1;\n  param_1[1] \u003d 0;\n  param_1[0x48] \u003d 0x202;\n  param_1[0x41] \u003d 0;\n  param_1[0x45] \u003d 0;\n  uVar1 \u003d param_2 / (uint)(param_3 * 2);\n  if (param_2 \u003d\u003d param_3 * 2 * uVar1) {\n    uVar1 \u003d uVar1 - 1;\n  }\n  uVar2 \u003d 0;\n  do {\n    if ((uint)(param_4 * (int)(((ulonglong)param_2 / (ulonglong)((uVar1 + 1) * 2)) / 1000000)) \u003c\u003d\n        local_58[uVar2]) {\n      param_1[1] \u003d (uVar2 \u0026 0xf) \u003c\u003c 0x10 | (uVar1 \u0026 0xff) \u003c\u003c 8 | param_1[1];\n      return 0;\n    }\n    uVar2 \u003d uVar2 + 1;\n  } while (uVar2 !\u003d 0x10);\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_configure_trigger": {
      "entrypoint": "0x00080d30",
      "current_name": "adc_configure_trigger",
      "code": "\nvoid adc_configure_trigger(int param_1,uint param_2,uint param_3)\n\n{\n  *(uint *)(param_1 + 4) \u003d param_2 | *(uint *)(param_1 + 4) | (param_3 \u0026 1) \u003c\u003c 7;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_configure_timing": {
      "entrypoint": "0x00080d3e",
      "current_name": "adc_configure_timing",
      "code": "\nvoid adc_configure_timing(int param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  *(uint *)(param_1 + 4) \u003d\n       param_3 | *(uint *)(param_1 + 4) | (param_2 \u0026 0xf) \u003c\u003c 0x18 | (param_4 \u0026 3) \u003c\u003c 0x1c;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_disable_channel": {
      "entrypoint": "0x00080d58",
      "current_name": "adc_disable_channel",
      "code": "\nvoid adc_disable_channel(int param_1,uint param_2)\n\n{\n  *(int *)(param_1 + 0x14) \u003d 1 \u003c\u003c (param_2 \u0026 0xff);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "pinMode"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_disable_all_channel": {
      "entrypoint": "0x00080d62",
      "current_name": "adc_disable_all_channel",
      "code": "\nvoid adc_disable_all_channel(int param_1)\n\n{\n  *(undefined4 *)(param_1 + 0x14) \u003d 0xffff;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "adc_disable_interrupt": {
      "entrypoint": "0x00080d6a",
      "current_name": "adc_disable_interrupt",
      "code": "\nvoid adc_disable_interrupt(int param_1,undefined4 param_2)\n\n{\n  *(undefined4 *)(param_1 + 0x28) \u003d param_2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UOTGHS_Handler": {
      "entrypoint": "0x00080d70",
      "current_name": "UOTGHS_Handler",
      "code": "\nvoid UOTGHS_Handler(void)\n\n{\n  if (gpf_isr !\u003d (code *)0x0) {\n    (*gpf_isr)();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIOA_Handler": {
      "entrypoint": "0x00080d80",
      "current_name": "PIOA_Handler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid PIOA_Handler(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t isr;\n  uint uVar1;\n  \n  for (isr \u003d _DAT_400e0e4c; (uint)LZCOUNT(isr) \u003c 0x20; isr \u003d isr \u0026 ~(1 \u003c\u003c uVar1)) {\n    uVar1 \u003d 0x1fU - LZCOUNT(isr) \u0026 0xff;\n    if (callbacksPioA[uVar1] !\u003d (interruptCB)0x0) {\n      (*callbacksPioA[uVar1])();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIOB_Handler": {
      "entrypoint": "0x00080db8",
      "current_name": "PIOB_Handler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid PIOB_Handler(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t isr;\n  uint uVar1;\n  \n  for (isr \u003d _DAT_400e104c; (uint)LZCOUNT(isr) \u003c 0x20; isr \u003d isr \u0026 ~(1 \u003c\u003c uVar1)) {\n    uVar1 \u003d 0x1fU - LZCOUNT(isr) \u0026 0xff;\n    if (callbacksPioB[uVar1] !\u003d (interruptCB)0x0) {\n      (*callbacksPioB[uVar1])();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIOC_Handler": {
      "entrypoint": "0x00080df0",
      "current_name": "PIOC_Handler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid PIOC_Handler(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t isr;\n  uint uVar1;\n  \n  for (isr \u003d _DAT_400e124c; (uint)LZCOUNT(isr) \u003c 0x20; isr \u003d isr \u0026 ~(1 \u003c\u003c uVar1)) {\n    uVar1 \u003d 0x1fU - LZCOUNT(isr) \u0026 0xff;\n    if (callbacksPioC[uVar1] !\u003d (interruptCB)0x0) {\n      (*callbacksPioC[uVar1])();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PIOD_Handler": {
      "entrypoint": "0x00080e28",
      "current_name": "PIOD_Handler",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nvoid PIOD_Handler(void)\n\n{\n  uint8_t leading_zeros;\n  uint32_t isr;\n  uint uVar1;\n  \n  for (isr \u003d _DAT_400e144c; (uint)LZCOUNT(isr) \u003c 0x20; isr \u003d isr \u0026 ~(1 \u003c\u003c uVar1)) {\n    uVar1 \u003d 0x1fU - LZCOUNT(isr) \u0026 0xff;\n    if (callbacksPioD[uVar1] !\u003d (interruptCB)0x0) {\n      (*callbacksPioD[uVar1])();\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__halt": {
      "entrypoint": "0x00080e84",
      "current_name": "__halt",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid __halt(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__halt",
        "PendSV_Handler",
        "SVC_Handler"
      ],
      "called": [
        "__halt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SVC_Handler": {
      "entrypoint": "0x00080e62",
      "current_name": "SVC_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SVC_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__halt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "PendSV_Handler": {
      "entrypoint": "0x00080e66",
      "current_name": "PendSV_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid PendSV_Handler(void)\n\n{\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__halt"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "SysTick_Handler": {
      "entrypoint": "0x00080e6a",
      "current_name": "SysTick_Handler",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid SysTick_Handler(void)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d __false();\n  if (iVar1 \u003d\u003d 0) {\n    tickReset();\n    TimeTick_Increment();\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "TimeTick_Increment",
        "__false",
        "tickReset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__false": {
      "entrypoint": "0x00080e80",
      "current_name": "__false",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint __false(void)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk": {
      "entrypoint": "0x00080e88",
      "current_name": "_sbrk",
      "code": "\nvoid * _sbrk(intptr_t __delta)\n\n{\n  uchar *puVar1;\n  uchar *prev_heap;\n  \n  if (_sbrk::heap \u003d\u003d (uchar *)0x0) {\n    _sbrk::heap \u003d \u0026_ebss;\n  }\n  puVar1 \u003d _sbrk::heap;\n  _sbrk::heap \u003d _sbrk::heap + __delta;\n  return puVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_sbrk_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "link": {
      "entrypoint": "0x00080ea4",
      "current_name": "link",
      "code": "\nint link(char *__from,char *__to)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close": {
      "entrypoint": "0x00080eaa",
      "current_name": "_close",
      "code": "\nint _close(int __fd)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_close_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat": {
      "entrypoint": "0x00080eb0",
      "current_name": "_fstat",
      "code": "\nint _fstat(int __fd,stat *__buf)\n\n{\n  *(undefined4 *)((int)\u0026__buf-\u003est_dev + 4) \u003d 0x2000;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fstat_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty": {
      "entrypoint": "0x00080eba",
      "current_name": "_isatty",
      "code": "\nint _isatty(int __fd)\n\n{\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_isatty_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek": {
      "entrypoint": "0x00080ebe",
      "current_name": "_lseek",
      "code": "\n__off_t _lseek(int __fd,__off_t __offset,int __whence)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_lseek_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read": {
      "entrypoint": "0x00080ec2",
      "current_name": "_read",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint _read(int file_UNUSED,char *ptr_UNUSED,int len_UNUSED)\n\n{\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_read_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write": {
      "entrypoint": "0x00080ec8",
      "current_name": "_write",
      "code": "\n\n/* WARNING: Unknown calling convention */\n\nint _write(int file_UNUSED,char *ptr,int len)\n\n{\n  int iVar1;\n  \n  for (iVar1 \u003d 0; iVar1 \u003c len; iVar1 \u003d iVar1 + 1) {\n    do {\n    } while (-1 \u003c _DAT_400e0814 \u003c\u003c 0x1e);\n    _DAT_400e081c \u003d (uint)(byte)ptr[iVar1];\n  }\n  return len \u0026 ~(len \u003e\u003e 0x1f);\n}\n\n",
      "renaming": {},
      "calling": [
        "_write_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_exit": {
      "entrypoint": "0x00080eec",
      "current_name": "_exit",
      "code": "\nvoid _exit(int __status)\n\n{\n  iprintf(\"Exiting with status %d.\\n\",__status);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "abort"
      ],
      "called": [
        "iprintf"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_kill": {
      "entrypoint": "0x00080efc",
      "current_name": "_kill",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _kill(int pid_UNUSED,int sig_UNUSED)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_kill_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getpid": {
      "entrypoint": "0x00080efe",
      "current_name": "_getpid",
      "code": "\n\n\n__pid_t _getpid(void)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_getpid_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "millis": {
      "entrypoint": "0x00080f04",
      "current_name": "millis",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t millis(void)\n\n{\n  return _dwTickCount;\n}\n\n",
      "renaming": {},
      "calling": [
        "timedRead"
      ],
      "called": [
        "GetTickCount"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "delay": {
      "entrypoint": "0x00080f08",
      "current_name": "delay",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid delay(uint32_t ms)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "loop",
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "analogOutputInit": {
      "entrypoint": "0x00080f0a",
      "current_name": "analogOutputInit",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid analogOutputInit(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pinMode": {
      "entrypoint": "0x00080f0c",
      "current_name": "pinMode",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid pinMode(uint32_t ulPin,uint32_t ulMode)\n\n{\n  undefined4 uVar1;\n  byte bVar2;\n  byte bVar3;\n  Pio *pPVar4;\n  \n  if (g_APinDescription[ulPin].ulPinType !\u003d PIO_NOT_A_PIN) {\n    if ((g_pinStatus[ulPin] \u0026 0xf) \u003d\u003d 4) {\n      adc_disable_channel(0x400c0000,g_APinDescription[ulPin].ulADCChannelNumber);\n    }\n    bVar3 \u003d g_pinStatus[ulPin];\n    bVar2 \u003d bVar3 \u0026 0xf;\n    if ((bVar2 \u003c 3) \u0026\u0026 (bVar3 !\u003d 0)) {\n      if (bVar2 \u003d\u003d 2) {\n        if (ulMode \u003d\u003d 0) {\n          return;\n        }\n      }\n      else if (bVar2 \u003d\u003d 1) {\n        if (ulMode \u003d\u003d 2) {\n          return;\n        }\n      }\n      else if (bVar2 \u003d\u003d 3) {\n        if (ulMode \u003d\u003d 1) {\n          return;\n        }\n        goto LAB_00080f68;\n      }\n    }\n    if (ulMode !\u003d 1) {\nLAB_00080f68:\n      if (ulMode \u003d\u003d 0) {\n        pmc_enable_periph_clk(g_APinDescription[ulPin].ulPeripheralId);\n        PIO_Configure(g_APinDescription[ulPin].pPort,3,g_APinDescription[ulPin].ulPin,0);\n        bVar3 \u003d g_pinStatus[ulPin] \u0026 0xf0 | 2;\n      }\n      else {\n        if (ulMode !\u003d 2) {\n          return;\n        }\n        pmc_enable_periph_clk(g_APinDescription[ulPin].ulPeripheralId);\n        PIO_Configure(g_APinDescription[ulPin].pPort,3,g_APinDescription[ulPin].ulPin,1);\n        bVar3 \u003d g_pinStatus[ulPin] \u0026 0xf0 | 1;\n      }\n      g_pinStatus[ulPin] \u003d bVar3;\n      return;\n    }\n    pPVar4 \u003d g_APinDescription[ulPin].pPort;\n    if (bVar3 \u003e\u003e 4 \u003d\u003d 0) {\n      uVar1 \u003d 4;\n    }\n    else {\n      uVar1 \u003d 5;\n    }\n    PIO_Configure(pPVar4,uVar1,g_APinDescription[ulPin].ulPin,\n                  g_APinDescription[ulPin].ulPinConfiguration);\n    g_pinStatus[ulPin] \u003d g_pinStatus[ulPin] \u0026 0xf0 | 3;\n    if (pPVar4-\u003ePIO_OSR \u003d\u003d 0xffffffff) {\n      pmc_disable_periph_clk(g_APinDescription[ulPin].ulPeripheralId);\n      return;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "setup",
        "attach",
        "digitalWrite"
      ],
      "called": [
        "pmc_disable_periph_clk",
        "pmc_enable_periph_clk",
        "adc_disable_channel",
        "PIO_Configure"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "digitalWrite": {
      "entrypoint": "0x00081014",
      "current_name": "digitalWrite",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid digitalWrite(uint32_t ulPin,uint32_t ulVal)\n\n{\n  int iVar1;\n  uint32_t uVar2;\n  Pio *pPVar3;\n  uint32_t uVar4;\n  \n  if (g_APinDescription[ulPin].ulPinType !\u003d PIO_NOT_A_PIN) {\n    uVar4 \u003d ulVal;\n    if ((g_pinStatus[ulPin] \u0026 0xf) \u003d\u003d 5) {\n      pinMode(ulPin,1);\n    }\n    g_pinStatus[ulPin] \u003d g_pinStatus[ulPin] \u0026 0xf | (byte)(ulVal \u003c\u003c 4);\n    pPVar3 \u003d g_APinDescription[ulPin].pPort;\n    uVar2 \u003d g_APinDescription[ulPin].ulPin;\n    iVar1 \u003d PIO_GetOutputDataStatus(pPVar3,uVar2);\n    if (iVar1 \u003d\u003d 0) {\n      PIO_PullUp(pPVar3,uVar2,ulVal);\n      return;\n    }\n    PIO_SetOutput(pPVar3,uVar2,ulVal,0,1,uVar4);\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "Servo_Handler",
        "loop",
        "init"
      ],
      "called": [
        "PIO_GetOutputDataStatus",
        "PIO_PullUp",
        "pinMode",
        "PIO_SetOutput"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "print": {
      "entrypoint": "0x00081176",
      "current_name": "print",
      "code": "\n/* WARNING: Heritage AFTER dead removal. Example location: r0 : 0x0008114a */\n/* WARNING: Restarted to delay deadcode elimination for space: register */\n/* WARNING: Exceeded maximum restarts with more pending */\n/* DWARF original prototype: size_t  print(Print * this, int n, int base) */\n\nsize_t __thiscall Print::print(Print *this,int n,int base)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  uint8_t base_00;\n  \n  if (base \u003d\u003d 0) {\n    sVar1 \u003d (**this-\u003e_vptr_Print)(this,n \u0026 0xff);\n    return sVar1;\n  }\n  base_00 \u003d (uint8_t)base;\n  if ((base \u003d\u003d 10) \u0026\u0026 (base_00 \u003d \u0027\\n\u0027, n \u003c 0)) {\n    sVar1 \u003d print(this,\u0027-\u0027);\n    sVar2 \u003d printNumber(this,-n,(uint8_t)base);\n    return sVar2 + sVar1;\n  }\n  sVar1 \u003d printNumber(this,n,base_00);\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "print"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "println": {
      "entrypoint": "0x0008117a",
      "current_name": "println",
      "code": "\n/* DWARF original prototype: size_t  println(Print * this, int num, int base) */\n\nsize_t __thiscall Print::println(Print *this,int num,int base)\n\n{\n  size_t sVar1;\n  size_t sVar2;\n  \n  sVar1 \u003d print(this,num,base);\n  sVar2 \u003d println(this);\n  return sVar2 + sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "println",
        "print"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "printNumber": {
      "entrypoint": "0x000810fc",
      "current_name": "printNumber",
      "code": "\n/* DWARF original prototype: size_t  printNumber(Print * this, ulong n, uint8_t base) */\n\nsize_t __thiscall Print::printNumber(Print *this,ulong n,uint8_t base)\n\n{\n  char *pcVar1;\n  size_t sVar2;\n  void *__buf;\n  char c;\n  uint uVar3;\n  char *__fd;\n  char cVar4;\n  uint uVar5;\n  char buf [33];\n  \n  __buf \u003d (void *)(uint)base;\n  buf[32] \u003d \u0027\\0\u0027;\n  if (__buf \u003c (void *)0x2) {\n    __buf \u003d (void *)0xa;\n  }\n  pcVar1 \u003d buf + 0x1f;\n  do {\n    __fd \u003d pcVar1;\n    uVar3 \u003d n / (uint)__buf;\n    uVar5 \u003d n - (int)__buf * uVar3 \u0026 0xff;\n    cVar4 \u003d (char)uVar5;\n    if (uVar5 \u003c 10) {\n      cVar4 \u003d cVar4 + \u00270\u0027;\n    }\n    else {\n      cVar4 \u003d cVar4 + \u00277\u0027;\n    }\n    *__fd \u003d cVar4;\n    n \u003d uVar3;\n    pcVar1 \u003d __fd + -1;\n  } while (uVar3 !\u003d 0);\n  sVar2 \u003d write(this,(int)__fd,__buf,0);\n  return sVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "print"
      ],
      "called": [
        "write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "tickReset": {
      "entrypoint": "0x00081190",
      "current_name": "tickReset",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid tickReset(void)\n\n{\n  if ((ticks !\u003d -1) \u0026\u0026 (ticks \u003d ticks + -1, ticks \u003d\u003d 0)) {\n    banzai();\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [
        "banzai"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "RingBuffer": {
      "entrypoint": "0x000811b0",
      "current_name": "RingBuffer",
      "code": "\n/* DWARF original prototype: RingBuffer *  RingBuffer(RingBuffer * this) */\n\nRingBuffer * __thiscall RingBuffer::RingBuffer(RingBuffer *this)\n\n{\n  memset(this,0,0x80);\n  this-\u003e_iHead \u003d 0;\n  this-\u003e_iTail \u003d 0;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_g_APinDescription"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "store_char": {
      "entrypoint": "0x000811ca",
      "current_name": "store_char",
      "code": "\n/* DWARF original prototype: void  store_char(RingBuffer * this, uint8_t c) */\n\nvoid __thiscall RingBuffer::store_char(RingBuffer *this,uint8_t c)\n\n{\n  int i;\n  uint uVar1;\n  \n  i \u003d this-\u003e_iHead;\n  uVar1 \u003d i + 1U \u0026 0x7f;\n  if (uVar1 !\u003d this-\u003e_iTail) {\n    this-\u003e_aucBuffer[this-\u003e_iHead] \u003d c;\n    this-\u003e_iHead \u003d uVar1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "IrqHandler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "timedRead": {
      "entrypoint": "0x000811e8",
      "current_name": "timedRead",
      "code": "\n/* DWARF original prototype: int  timedRead(Stream * this) */\n\nint __thiscall Stream::timedRead(Stream *this)\n\n{\n  uint32_t uVar1;\n  int iVar2;\n  int c;\n  \n  uVar1 \u003d millis();\n  this-\u003e_startMillis \u003d uVar1;\n  do {\n    iVar2 \u003d (*(this-\u003esuper_Print)._vptr_Print[3])();\n    if (-1 \u003c iVar2) {\n      return iVar2;\n    }\n    uVar1 \u003d millis();\n  } while (uVar1 - this-\u003e_startMillis \u003c this-\u003e_timeout);\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "readStringUntil"
      ],
      "called": [
        "millis"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "readStringUntil": {
      "entrypoint": "0x00081214",
      "current_name": "readStringUntil",
      "code": "\n/* DWARF original prototype: String  readStringUntil(Stream * this, char terminator) */\n\nString * __thiscall Stream::readStringUntil(Stream *this,char terminator)\n\n{\n  String *in_r0;\n  String *ret;\n  int iVar1;\n  int c;\n  \n  String::String(in_r0,\"\");\n  while( true ) {\n    iVar1 \u003d timedRead(this);\n    if ((iVar1 \u003c 0) || (iVar1 \u003d\u003d terminator)) break;\n    String::concat(in_r0,(char)iVar1);\n  }\n  return in_r0;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "concat",
        "String",
        "timedRead"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "operator_bool": {
      "entrypoint": "0x00081244",
      "current_name": "operator_bool",
      "code": "\n/* DWARF original name: operator bool\n   DWARF original prototype: bool  operator_bool(UARTClass * this) */\n\nbool __thiscall UARTClass::operator_bool(UARTClass *this)\n\n{\n  return true;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "available": {
      "entrypoint": "0x00081248",
      "current_name": "available",
      "code": "\n/* DWARF original prototype: int  available(UARTClass * this) */\n\nint __thiscall UARTClass::available(UARTClass *this)\n\n{\n  return this-\u003e_rx_buffer-\u003e_iHead - this-\u003e_rx_buffer-\u003e_iTail \u0026 0x7f;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "serialEventRun"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "peek": {
      "entrypoint": "0x0008125a",
      "current_name": "peek",
      "code": "\n/* DWARF original prototype: int  peek(UARTClass * this) */\n\nint __thiscall UARTClass::peek(UARTClass *this)\n\n{\n  uint uVar1;\n  RingBuffer *pRVar2;\n  \n  pRVar2 \u003d this-\u003e_rx_buffer;\n  if (pRVar2-\u003e_iHead \u003d\u003d pRVar2-\u003e_iTail) {\n    uVar1 \u003d 0xffffffff;\n  }\n  else {\n    uVar1 \u003d (uint)pRVar2-\u003e_aucBuffer[pRVar2-\u003e_iTail];\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "read": {
      "entrypoint": "0x00081276",
      "current_name": "read",
      "code": "\n/* DWARF original prototype: int  read(UARTClass * this) */\n\nssize_t __thiscall UARTClass::read(UARTClass *this,int __fd,void *__buf,size_t __nbytes)\n\n{\n  byte bVar1;\n  uint8_t uc;\n  RingBuffer *pRVar2;\n  \n  pRVar2 \u003d this-\u003e_rx_buffer;\n  if (pRVar2-\u003e_iHead !\u003d pRVar2-\u003e_iTail) {\n    bVar1 \u003d pRVar2-\u003e_aucBuffer[pRVar2-\u003e_iTail];\n    pRVar2-\u003e_iTail \u003d pRVar2-\u003e_iTail + 1U \u0026 0x7f;\n    return (uint)bVar1;\n  }\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "flush": {
      "entrypoint": "0x000812a0",
      "current_name": "flush",
      "code": "\n/* DWARF original prototype: void  flush(UARTClass * this) */\n\nvoid __thiscall UARTClass::flush(UARTClass *this)\n\n{\n  do {\n  } while (this-\u003e_tx_buffer-\u003e_iHead !\u003d this-\u003e_tx_buffer-\u003e_iTail);\n  do {\n  } while (-1 \u003c (int)(this-\u003e_pUart-\u003eUART_SR \u003c\u003c 0x16));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "end": {
      "entrypoint": "0x0008130c",
      "current_name": "end",
      "code": "\n/* DWARF original prototype: void  end(UARTClass * this) */\n\nvoid __thiscall UARTClass::end(UARTClass *this)\n\n{\n  this-\u003e_rx_buffer-\u003e_iHead \u003d this-\u003e_rx_buffer-\u003e_iTail;\n  (**(code **)(*(int *)this + 0x14))();\n  *(int *)((((uint)(int)this-\u003e_dwIrq \u003e\u003e 5) + 0x20) * 4 + -0x1fff1f00) \u003d\n       1 \u003c\u003c (uint)(byte)(this-\u003e_dwIrq \u0026 0x1f);\n  pmc_disable_periph_clk(this-\u003e_dwId);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "pmc_disable_periph_clk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "UARTClass": {
      "entrypoint": "0x00081348",
      "current_name": "UARTClass",
      "code": "\n/* DWARF original prototype: UARTClass *  UARTClass(UARTClass * this, Uart * pUart, IRQn_Type dwIrq,\n   uint32_t dwId, RingBuffer * pRx_buffer, RingBuffer * pTx_buffer) */\n\nUARTClass * __thiscall\nUARTClass::UARTClass\n          (UARTClass *this,Uart *pUart,IRQn_Type dwIrq,uint32_t dwId,RingBuffer *pRx_buffer,\n          RingBuffer *pTx_buffer)\n\n{\n  *(undefined4 *)\u0026this-\u003efield_0x4 \u003d 0;\n  *(undefined4 *)\u0026this-\u003efield_0x8 \u003d 1000;\n  this-\u003e_pUart \u003d pUart;\n  *(undefined ***)this \u003d \u0026PTR_write_1_00085650;\n  this-\u003e_dwIrq \u003d dwIrq;\n  this-\u003e_rx_buffer \u003d pRx_buffer;\n  this-\u003e_dwId \u003d dwId;\n  this-\u003e_tx_buffer \u003d pTx_buffer;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_g_APinDescription",
        "USARTClass"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "begin": {
      "entrypoint": "0x0008142e",
      "current_name": "begin",
      "code": "\n/* DWARF original prototype: void  begin(USARTClass * this, uint32_t dwBaudRate) */\n\nvoid __thiscall USARTClass::begin(USARTClass *this,uint32_t dwBaudRate)\n\n{\n  UARTClass::init(\u0026this-\u003esuper_UARTClass,(EVP_PKEY_CTX *)dwBaudRate);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "IrqHandler": {
      "entrypoint": "0x000813e4",
      "current_name": "IrqHandler",
      "code": "\n/* DWARF original prototype: void  IrqHandler(UARTClass * this) */\n\nvoid __thiscall UARTClass::IrqHandler(UARTClass *this)\n\n{\n  RingBuffer *pRVar1;\n  uint32_t status;\n  RoReg RVar2;\n  \n  RVar2 \u003d this-\u003e_pUart-\u003eUART_SR;\n  if ((int)(RVar2 \u003c\u003c 0x1f) \u003c 0) {\n    RingBuffer::store_char(this-\u003e_rx_buffer,(uint8_t)this-\u003e_pUart-\u003eUART_RHR);\n  }\n  if ((int)(RVar2 \u003c\u003c 0x1e) \u003c 0) {\n    pRVar1 \u003d this-\u003e_tx_buffer;\n    if (pRVar1-\u003e_iTail !\u003d pRVar1-\u003e_iHead) {\n      this-\u003e_pUart-\u003eUART_THR \u003d (uint)pRVar1-\u003e_aucBuffer[pRVar1-\u003e_iTail];\n      pRVar1-\u003e_iTail \u003d pRVar1-\u003e_iTail + 1U \u0026 0x7f;\n      return;\n    }\n    this-\u003e_pUart-\u003eUART_IDR \u003d 2;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "USART0_Handler",
        "UART_Handler",
        "USART3_Handler",
        "USART1_Handler"
      ],
      "called": [
        "store_char"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "USARTClass": {
      "entrypoint": "0x00081438",
      "current_name": "USARTClass",
      "code": "\n/* DWARF original prototype: USARTClass *  USARTClass(USARTClass * this, Usart * pUsart, IRQn_Type\n   dwIrq, uint32_t dwId, RingBuffer * pRx_buffer, RingBuffer * pTx_buffer) */\n\nUSARTClass * __thiscall\nUSARTClass::USARTClass\n          (USARTClass *this,Usart *pUsart,IRQn_Type dwIrq,uint32_t dwId,RingBuffer *pRx_buffer,\n          RingBuffer *pTx_buffer)\n\n{\n  UARTClass::UARTClass(\u0026this-\u003esuper_UARTClass,(Uart *)pUsart,dwIrq,dwId,pRx_buffer,pTx_buffer);\n  *(undefined ***)\u0026this-\u003esuper_UARTClass \u003d \u0026PTR_write_1_00085680;\n  this-\u003e_pUsart \u003d pUsart;\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_g_APinDescription"
      ],
      "called": [
        "UARTClass"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "map": {
      "entrypoint": "0x0008145c",
      "current_name": "map",
      "code": "\n/* WARNING: Unknown calling convention */\n\nlong map(long x,long in_min,long in_max,long out_min,long out_max)\n\n{\n  return (uint)((x - in_min) * (out_max - out_min)) / (uint)(in_max - in_min) + out_min;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop",
        "write"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "StringIfHelper": {
      "entrypoint": "0x00081470",
      "current_name": "StringIfHelper",
      "code": "\n/* DWARF original prototype: void  StringIfHelper(String * this) */\n\nvoid __thiscall String::StringIfHelper(String *this)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "~String": {
      "entrypoint": "0x00081472",
      "current_name": "~String",
      "code": "\n/* DWARF original prototype: void *  ~String(String * this, int __in_chrg) */\n\nvoid * __thiscall String::~String(String *this,int __in_chrg)\n\n{\n  free(this-\u003ebuffer);\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "invalidate": {
      "entrypoint": "0x00081480",
      "current_name": "invalidate",
      "code": "\n/* DWARF original prototype: void  invalidate(String * this) */\n\nvoid __thiscall String::invalidate(String *this)\n\n{\n  if (this-\u003ebuffer !\u003d (char *)0x0) {\n    free(this-\u003ebuffer);\n  }\n  this-\u003ebuffer \u003d (char *)0x0;\n  this-\u003elen \u003d 0;\n  this-\u003ecapacity \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy"
      ],
      "called": [
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "changeBuffer": {
      "entrypoint": "0x00081496",
      "current_name": "changeBuffer",
      "code": "\n/* DWARF original prototype: uchar  changeBuffer(String * this, uint maxStrLen) */\n\nuchar __thiscall String::changeBuffer(String *this,uint maxStrLen)\n\n{\n  char *pcVar1;\n  char *newbuffer;\n  \n  pcVar1 \u003d (char *)realloc(this-\u003ebuffer,maxStrLen + 1);\n  if (pcVar1 !\u003d (char *)0x0) {\n    this-\u003ebuffer \u003d pcVar1;\n    this-\u003ecapacity \u003d maxStrLen;\n    pcVar1 \u003d (char *)0x1;\n  }\n  return (uchar)pcVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "reserve"
      ],
      "called": [
        "realloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "reserve": {
      "entrypoint": "0x000814ae",
      "current_name": "reserve",
      "code": "\n/* DWARF original prototype: uchar  reserve(String * this, uint size) */\n\nuchar __thiscall String::reserve(String *this,uint size)\n\n{\n  uchar uVar1;\n  \n  if ((this-\u003ebuffer \u003d\u003d (char *)0x0) || (this-\u003ecapacity \u003c size)) {\n    uVar1 \u003d changeBuffer(this,size);\n    if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n      return \u0027\\0\u0027;\n    }\n    if (this-\u003elen \u003d\u003d 0) {\n      *this-\u003ebuffer \u003d \u0027\\0\u0027;\n    }\n  }\n  return \u0027\\x01\u0027;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy",
        "concat"
      ],
      "called": [
        "changeBuffer"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "copy": {
      "entrypoint": "0x000814d0",
      "current_name": "copy",
      "code": "\n/* DWARF original prototype: String *  copy(String * this, char * cstr, uint length) */\n\nint __thiscall String::copy(String *this,EVP_PKEY_CTX *dst,EVP_PKEY_CTX *src)\n\n{\n  uchar uVar1;\n  \n  uVar1 \u003d reserve(this,(uint)src);\n  if (uVar1 \u003d\u003d \u0027\\0\u0027) {\n    invalidate(this);\n  }\n  else {\n    this-\u003elen \u003d (uint)src;\n    strcpy(this-\u003ebuffer,(char *)dst);\n  }\n  return (int)this;\n}\n\n",
      "renaming": {},
      "calling": [
        "String"
      ],
      "called": [
        "invalidate",
        "strcpy",
        "reserve"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "String": {
      "entrypoint": "0x000814f6",
      "current_name": "String",
      "code": "\n/* DWARF original prototype: String *  String(String * this, char * cstr) */\n\nString * __thiscall String::String(String *this,char *cstr)\n\n{\n  EVP_PKEY_CTX *src;\n  \n  this-\u003ebuffer \u003d (char *)0x0;\n  this-\u003ecapacity \u003d 0;\n  this-\u003elen \u003d 0;\n  if (cstr !\u003d (char *)0x0) {\n    src \u003d (EVP_PKEY_CTX *)strlen(cstr);\n    copy(this,(EVP_PKEY_CTX *)cstr,src);\n  }\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_steering",
        "readStringUntil"
      ],
      "called": [
        "copy",
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "move": {
      "entrypoint": "0x0008151c",
      "current_name": "move",
      "code": "\n/* DWARF original prototype: void  move(String * this, String * rhs) */\n\nvoid __thiscall String::move(String *this,String *rhs)\n\n{\n  char *__dest;\n  \n  __dest \u003d this-\u003ebuffer;\n  if (__dest !\u003d (char *)0x0) {\n    if ((rhs-\u003ebuffer !\u003d (char *)0x0) \u0026\u0026 (rhs-\u003elen \u003c\u003d this-\u003ecapacity)) {\n      strcpy(__dest,rhs-\u003ebuffer);\n      this-\u003elen \u003d rhs-\u003elen;\n      goto LAB_00081558;\n    }\n    free(__dest);\n  }\n  this-\u003ebuffer \u003d rhs-\u003ebuffer;\n  this-\u003ecapacity \u003d rhs-\u003ecapacity;\n  this-\u003elen \u003d rhs-\u003elen;\n  rhs-\u003ebuffer \u003d (char *)0x0;\n  rhs-\u003ecapacity \u003d 0;\nLAB_00081558:\n  rhs-\u003elen \u003d 0;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "operator\u003d"
      ],
      "called": [
        "strcpy",
        "free"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "operator\u003d": {
      "entrypoint": "0x00081560",
      "current_name": "operator\u003d",
      "code": "\n/* DWARF original prototype: String *  operator\u003d(String * this, String * rval) */\n\nString * __thiscall String::operator\u003d(String *this,String *rval)\n\n{\n  if (this !\u003d rval) {\n    move(this,rval);\n  }\n  return this;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "move"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "concat": {
      "entrypoint": "0x0008159e",
      "current_name": "concat",
      "code": "\n/* DWARF original prototype: uchar  concat(String * this, char c) */\n\nuchar __thiscall String::concat(String *this,char c)\n\n{\n  uchar uVar1;\n  char buf [2];\n  short sStack_a;\n  \n  uVar1 \u003d concat(this,buf,1);\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "readStringUntil"
      ],
      "called": [
        "concat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "equals": {
      "entrypoint": "0x000815b8",
      "current_name": "equals",
      "code": "\n/* DWARF original prototype: uchar  equals(String * this, char * cstr) */\n\nuchar __thiscall String::equals(String *this,char *cstr)\n\n{\n  uchar uVar1;\n  uint uVar2;\n  \n  if (this-\u003elen \u003d\u003d 0) {\n    if (cstr \u003d\u003d (char *)0x0) {\n      return \u0027\\x01\u0027;\n    }\n  }\n  else {\n    if (cstr !\u003d (char *)0x0) {\n      uVar2 \u003d strcmp(this-\u003ebuffer,cstr);\n      goto LAB_000815d4;\n    }\n    cstr \u003d this-\u003ebuffer;\n  }\n  uVar2 \u003d (uint)(byte)*cstr;\nLAB_000815d4:\n  uVar1 \u003d \u0027\\x01\u0027 - (char)uVar2;\n  if (1 \u003c uVar2) {\n    uVar1 \u003d \u0027\\0\u0027;\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "strcmp"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "toInt": {
      "entrypoint": "0x000815de",
      "current_name": "toInt",
      "code": "\n/* DWARF original prototype: long  toInt(String * this) */\n\nlong __thiscall String::toInt(String *this)\n\n{\n  long lVar1;\n  \n  if (this-\u003ebuffer !\u003d (char *)0x0) {\n    lVar1 \u003d atol(this-\u003ebuffer);\n    return lVar1;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "atol"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "initVariant": {
      "entrypoint": "0x000815e8",
      "current_name": "initVariant",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid initVariant(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "main": {
      "entrypoint": "0x000815ec",
      "current_name": "main",
      "code": "\n/* WARNING: Unknown calling convention */\n\nint main(void)\n\n{\n  EVP_PKEY_CTX *in_r0;\n  \n  _watchdogDefaultSetup();\n  init(in_r0);\n  initVariant();\n  delay(1);\n  setup();\n  do {\n    loop();\n    serialEventRun();\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler"
      ],
      "called": [
        "setup",
        "loop",
        "delay",
        "_watchdogDefaultSetup",
        "serialEventRun",
        "initVariant",
        "init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_watchdogDefaultSetup": {
      "entrypoint": "0x00081618",
      "current_name": "_watchdogDefaultSetup",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid _watchdogDefaultSetup(void)\n\n{\n  WDT_Disable(0x400e1a50);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "main"
      ],
      "called": [
        "WDT_Disable"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "pulseIn": {
      "entrypoint": "0x00081624",
      "current_name": "pulseIn",
      "code": "\n/* WARNING: Unknown calling convention */\n\nuint32_t pulseIn(uint32_t pin,uint32_t state,uint32_t timeout)\n\n{\n  uint32_t uVar1;\n  uint32_t width;\n  uint32_t stateMask;\n  uint32_t bit;\n  \n  stateMask \u003d g_APinDescription[pin].ulPin;\n  if (state \u003d\u003d 0) {\n    stateMask \u003d 0;\n  }\n  uVar1 \u003d countPulseASM(\u0026(g_APinDescription[pin].pPort)-\u003ePIO_PDSR,g_APinDescription[pin].ulPin,\n                        stateMask,((SystemCoreClock / 1000000) * timeout) / 0x12);\n  if (uVar1 !\u003d 0) {\n    uVar1 \u003d (uint32_t)((ulonglong)(uVar1 * 18000 + 16000) / ((ulonglong)SystemCoreClock / 1000));\n  }\n  return uVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "loop"
      ],
      "called": [
        "countPulseASM"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "countPulseASM": {
      "entrypoint": "0x00081684",
      "current_name": "countPulseASM",
      "code": "\nint countPulseASM(uint *param_1,uint param_2,uint param_3,int param_4)\n\n{\n  int iVar1;\n  \n  do {\n    if ((*param_1 \u0026 param_2) !\u003d param_3) {\n      do {\n        if ((*param_1 \u0026 param_2) \u003d\u003d param_3) {\n          iVar1 \u003d 0;\n          do {\n            if ((*param_1 \u0026 param_2) !\u003d param_3) {\n              return iVar1;\n            }\n            iVar1 \u003d iVar1 + 1;\n          } while (param_4 !\u003d iVar1);\n          return 0;\n        }\n        param_4 \u003d param_4 + -1;\n      } while (param_4 !\u003d 0);\n      return 0;\n    }\n    param_4 \u003d param_4 + -1;\n  } while (param_4 !\u003d 0);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "pulseIn"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "TimeTick_Increment": {
      "entrypoint": "0x000816c8",
      "current_name": "TimeTick_Increment",
      "code": "\nvoid TimeTick_Increment(void)\n\n{\n  _dwTickCount \u003d _dwTickCount + 1;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "SysTick_Handler"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "GetTickCount": {
      "entrypoint": "0x000816d8",
      "current_name": "GetTickCount",
      "code": "\nundefined4 GetTickCount(void)\n\n{\n  return _dwTickCount;\n}\n\n",
      "renaming": {},
      "calling": [
        "millis"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "WDT_Disable": {
      "entrypoint": "0x000816e4",
      "current_name": "WDT_Disable",
      "code": "\nvoid WDT_Disable(int param_1)\n\n{\n  *(undefined4 *)(param_1 + 4) \u003d 0x8000;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_watchdogDefaultSetup"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_atexit": {
      "entrypoint": "0x000816ec",
      "current_name": "__aeabi_atexit",
      "code": "\nvoid __aeabi_atexit(undefined4 param_1,undefined4 param_2)\n\n{\n  __cxa_atexit(param_2,param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_GLOBAL__sub_I_steering"
      ],
      "called": [
        "__cxa_atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__assert_func": {
      "entrypoint": "0x000816f8",
      "current_name": "__assert_func",
      "code": "\nvoid __assert_func(undefined4 param_1,undefined4 param_2,char *param_3,undefined4 param_4)\n\n{\n  char *pcVar1;\n  \n  if (param_3 \u003d\u003d (char *)0x0) {\n    param_3 \u003d \"\";\n    pcVar1 \u003d param_3;\n  }\n  else {\n    pcVar1 \u003d \", function: \";\n  }\n  fiprintf(*(undefined4 *)(_impure_ptr + 0xc),\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",\n           param_4,param_1,param_2,pcVar1,param_3);\n                    \n  abort();\n}\n\n",
      "renaming": {},
      "calling": [
        "TC_Configure",
        "TC_Start"
      ],
      "called": [
        "fiprintf",
        "abort"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "atol": {
      "entrypoint": "0x00081734",
      "current_name": "atol",
      "code": "\nlong atol(char *__nptr)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d strtol(__nptr,(char **)0x0,10);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "toInt"
      ],
      "called": [
        "strtol"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__cxa_atexit": {
      "entrypoint": "0x0008173c",
      "current_name": "__cxa_atexit",
      "code": "\nvoid __cxa_atexit(undefined4 param_1,undefined4 param_2,undefined4 param_3)\n\n{\n  __register_exitproc(2,param_1,param_2,param_3);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_atexit"
      ],
      "called": [
        "__register_exitproc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fiprintf": {
      "entrypoint": "0x00081750",
      "current_name": "fiprintf",
      "code": "\nvoid fiprintf(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_8 \u003d param_3;\n  uStack_4 \u003d param_4;\n  _vfiprintf_r(_impure_ptr,param_1,param_2,\u0026uStack_8);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__assert_func"
      ],
      "called": [
        "_vfiprintf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_init_array": {
      "entrypoint": "0x00081778",
      "current_name": "__libc_init_array",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x00081784) */\n/* WARNING: Removing unreachable block (ram,0x00081788) */\n/* WARNING: Removing unreachable block (ram,0x000817b4) */\n\nvoid __libc_init_array(void)\n\n{\n  int iVar1;\n  code **ppcVar2;\n  \n  _init();\n  ppcVar2 \u003d (code **)0x8584c;\n  iVar1 \u003d 0;\n  do {\n    iVar1 \u003d iVar1 + 1;\n    ppcVar2 \u003d ppcVar2 + 1;\n    (**ppcVar2)();\n  } while (iVar1 !\u003d 4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "init"
      ],
      "called": [
        "register_fini",
        "frame_dummy",
        "_init"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "iprintf": {
      "entrypoint": "0x000817c8",
      "current_name": "iprintf",
      "code": "\nvoid iprintf(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 uStack_c;\n  undefined4 uStack_8;\n  undefined4 uStack_4;\n  \n  uStack_c \u003d param_2;\n  uStack_8 \u003d param_3;\n  uStack_4 \u003d param_4;\n  _vfiprintf_r(_impure_ptr,*(undefined4 *)(_impure_ptr + 8),param_1,\u0026uStack_c);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_exit"
      ],
      "called": [
        "_vfiprintf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "malloc": {
      "entrypoint": "0x000817f0",
      "current_name": "malloc",
      "code": "\nvoid * malloc(size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d (void *)_malloc_r(_impure_ptr,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "__register_exitproc"
      ],
      "called": [
        "_malloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "free": {
      "entrypoint": "0x00081800",
      "current_name": "free",
      "code": "\nvoid free(void *__ptr)\n\n{\n  _free_r(_impure_ptr,__ptr);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "invalidate",
        "move",
        "~String"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_r": {
      "entrypoint": "0x00081810",
      "current_name": "_malloc_r",
      "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * _malloc_r(undefined4 *param_1,uint param_2)\n\n{\n  undefined1 *puVar1;\n  int iVar2;\n  uint uVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  undefined4 *puVar9;\n  undefined1 *puVar10;\n  undefined1 *puVar11;\n  undefined1 *puVar12;\n  uint uVar13;\n  undefined4 *puVar14;\n  undefined4 *puVar15;\n  undefined1 *puVar16;\n  \n  if (param_2 + 0xb \u003c 0x17) {\n    uVar13 \u003d 0x10;\n    if (0x10 \u003c param_2) goto LAB_00081876;\n  }\n  else {\n    uVar13 \u003d param_2 + 0xb \u0026 0xfffffff8;\n    if (((int)uVar13 \u003c 0) || (uVar13 \u003c param_2)) {\nLAB_00081876:\n      *param_1 \u003d 0xc;\n      return (int *)0x0;\n    }\n  }\n  __malloc_lock(param_1);\n  puVar14 \u003d DAT_20070474;\n  if (uVar13 \u003c 0x1f8) {\n    puVar12 \u003d *(undefined1 **)((int)\u0026DAT_20070470 + uVar13);\n    if ((puVar12 !\u003d \u0026__malloc_av_ + uVar13) ||\n       (puVar11 \u003d puVar12 + 8, puVar12 \u003d *(undefined1 **)(puVar12 + 0x14), puVar11 !\u003d puVar12)) {\n      uVar8 \u003d *(uint *)(puVar12 + 4);\n      iVar5 \u003d *(int *)(puVar12 + 0xc);\n      uVar13 \u003d *(uint *)(puVar12 + (uVar8 \u0026 0xfffffffc) + 4);\n      iVar2 \u003d *(int *)(puVar12 + 8);\n      *(int *)(iVar2 + 0xc) \u003d iVar5;\n      *(int *)(iVar5 + 8) \u003d iVar2;\n      *(uint *)(puVar12 + (uVar8 \u0026 0xfffffffc) + 4) \u003d uVar13 | 1;\n      __malloc_unlock(param_1);\n      return (int *)(puVar12 + 8);\n    }\n    uVar8 \u003d (uVar13 \u003e\u003e 3) + 2;\n  }\n  else {\n    uVar8 \u003d uVar13 \u003e\u003e 9;\n    if (uVar8 \u003d\u003d 0) {\n      iVar5 \u003d 0x7e;\n      iVar2 \u003d 0x3f;\n    }\n    else if (uVar8 \u003c 5) {\n      iVar2 \u003d (uVar13 \u003e\u003e 6) + 0x38;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else if (uVar8 \u003c 0x15) {\n      iVar2 \u003d uVar8 + 0x5b;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else if (uVar8 \u003c 0x55) {\n      iVar2 \u003d (uVar13 \u003e\u003e 0xc) + 0x6e;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else if (uVar8 \u003c 0x155) {\n      iVar2 \u003d (uVar13 \u003e\u003e 0xf) + 0x77;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else if (uVar8 \u003c 0x555) {\n      iVar2 \u003d (uVar13 \u003e\u003e 0x12) + 0x7c;\n      iVar5 \u003d iVar2 * 2;\n    }\n    else {\n      iVar5 \u003d 0xfc;\n      iVar2 \u003d 0x7e;\n    }\n    for (puVar12 \u003d (undefined1 *)(\u0026DAT_20070470)[iVar5]; \u0026__malloc_av_ + iVar5 * 4 !\u003d puVar12;\n        puVar12 \u003d *(undefined1 **)(puVar12 + 0xc)) {\n      uVar8 \u003d *(uint *)(puVar12 + 4) \u0026 0xfffffffc;\n      if (0xf \u003c (int)(uVar8 - uVar13)) {\n        iVar2 \u003d iVar2 + -1;\n        break;\n      }\n      if (-1 \u003c (int)(uVar8 - uVar13)) {\n        uVar13 \u003d *(uint *)(puVar12 + uVar8 + 4);\n        iVar5 \u003d *(int *)(puVar12 + 0xc);\n        iVar2 \u003d *(int *)(puVar12 + 8);\n        *(int *)(iVar2 + 0xc) \u003d iVar5;\n        *(int *)(iVar5 + 8) \u003d iVar2;\n        *(uint *)(puVar12 + uVar8 + 4) \u003d uVar13 | 1;\n        __malloc_unlock(param_1);\n        return (int *)(puVar12 + 8);\n      }\n    }\n    uVar8 \u003d iVar2 + 1;\n  }\n  uVar3 \u003d DAT_20070468;\n  if ((undefined1 **)DAT_20070474 !\u003d \u0026DAT_2007046c) {\n    uVar3 \u003d DAT_20070474[1];\n    uVar4 \u003d uVar3 \u0026 0xfffffffc;\n    uVar6 \u003d uVar4 - uVar13;\n    if (0xf \u003c (int)uVar6) {\n      puVar15 \u003d (undefined4 *)(uVar13 + (int)DAT_20070474);\n      DAT_20070474[1] \u003d uVar13 | 1;\n      DAT_20070474 \u003d puVar15;\n      DAT_20070478 \u003d puVar15;\n      puVar15[3] \u003d \u0026DAT_2007046c;\n      puVar15[2] \u003d \u0026DAT_2007046c;\n      puVar15[1] \u003d uVar6 | 1;\n      *(uint *)((int)puVar15 + uVar6) \u003d uVar6;\n      __malloc_unlock(param_1);\n      return puVar14 + 2;\n    }\n    DAT_20070478 \u003d \u0026DAT_2007046c;\n    DAT_20070474 \u003d \u0026DAT_2007046c;\n    if (-1 \u003c (int)uVar6) {\n      *(uint *)((int)puVar14 + uVar4 + 4) \u003d *(uint *)((int)puVar14 + uVar4 + 4) | 1;\n      __malloc_unlock(param_1);\n      return puVar14 + 2;\n    }\n    if (uVar4 \u003c 0x200) {\n      uVar4 \u003d uVar3 \u0026 0xfffffff8;\n      iVar2 \u003d *(int *)((int)\u0026DAT_2007046c + uVar4);\n      uVar3 \u003d 1 \u003c\u003c ((int)(uVar3 \u003e\u003e 3) \u003e\u003e 2 \u0026 0xffU) | DAT_20070468;\n      puVar14[2] \u003d iVar2;\n      puVar14[3] \u003d \u0026__malloc_av_ + uVar4;\n      DAT_20070468 \u003d uVar3;\n      *(undefined4 **)((int)\u0026DAT_2007046c + uVar4) \u003d puVar14;\n      *(undefined4 **)(iVar2 + 0xc) \u003d puVar14;\n    }\n    else {\n      uVar6 \u003d uVar3 \u003e\u003e 9;\n      if (uVar6 \u003c 5) {\n        iVar5 \u003d (uVar3 \u003e\u003e 6) + 0x38;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else if (uVar6 \u003c 0x15) {\n        iVar5 \u003d uVar6 + 0x5b;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else if (uVar6 \u003c 0x55) {\n        iVar5 \u003d (uVar3 \u003e\u003e 0xc) + 0x6e;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else if (uVar6 \u003c 0x155) {\n        iVar5 \u003d (uVar3 \u003e\u003e 0xf) + 0x77;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else if (uVar6 \u003c 0x555) {\n        iVar5 \u003d (uVar3 \u003e\u003e 0x12) + 0x7c;\n        iVar2 \u003d iVar5 * 2;\n      }\n      else {\n        iVar2 \u003d 0xfc;\n        iVar5 \u003d 0x7e;\n      }\n      puVar12 \u003d (\u0026DAT_2007046c)[iVar2];\n      if (puVar12 \u003d\u003d \u0026__malloc_av_ + iVar2 * 4) {\n        DAT_20070468 \u003d DAT_20070468 | 1 \u003c\u003c (iVar5 \u003e\u003e 2 \u0026 0xffU);\n        puVar11 \u003d puVar12;\n      }\n      else {\n        do {\n          puVar11 \u003d puVar12;\n          if ((*(uint *)(puVar12 + 4) \u0026 0xfffffffc) \u003c\u003d uVar4) break;\n          puVar12 \u003d *(undefined1 **)(puVar12 + 8);\n          puVar11 \u003d puVar12;\n        } while (\u0026__malloc_av_ + iVar2 * 4 !\u003d puVar12);\n        puVar12 \u003d *(undefined1 **)(puVar11 + 0xc);\n      }\n      uVar3 \u003d DAT_20070468;\n      puVar14[3] \u003d puVar12;\n      puVar14[2] \u003d puVar11;\n      *(undefined4 **)(puVar12 + 8) \u003d puVar14;\n      *(undefined4 **)(puVar11 + 0xc) \u003d puVar14;\n    }\n  }\n  puVar12 \u003d DAT_2007046c;\n  uVar4 \u003d 1 \u003c\u003c ((int)uVar8 \u003e\u003e 2 \u0026 0xffU);\n  if (uVar4 \u003c\u003d uVar3) {\n    if ((uVar3 \u0026 uVar4) \u003d\u003d 0) {\n      uVar8 \u003d uVar8 \u0026 0xfffffffc;\n      do {\n        uVar4 \u003d uVar4 \u003c\u003c 1;\n        uVar8 \u003d uVar8 + 4;\n      } while ((uVar3 \u0026 uVar4) \u003d\u003d 0);\n    }\n    do {\n      puVar15 \u003d (undefined4 *)(\u0026__malloc_av_ + uVar8 * 8);\n      puVar14 \u003d puVar15;\n      uVar3 \u003d uVar8;\n      do {\n        for (puVar9 \u003d (undefined4 *)puVar14[3]; puVar14 !\u003d puVar9; puVar9 \u003d (undefined4 *)puVar9[3])\n        {\n          uVar6 \u003d puVar9[1] \u0026 0xfffffffc;\n          uVar7 \u003d uVar6 - uVar13;\n          if (0xf \u003c (int)uVar7) {\n            iVar5 \u003d puVar9[2];\n            iVar2 \u003d puVar9[3];\n            puVar14 \u003d (undefined4 *)(uVar13 + (int)puVar9);\n            puVar9[1] \u003d uVar13 | 1;\n            *(int *)(iVar5 + 0xc) \u003d iVar2;\n            *(int *)(iVar2 + 8) \u003d iVar5;\n            DAT_20070474 \u003d puVar14;\n            DAT_20070478 \u003d puVar14;\n            puVar14[3] \u003d \u0026DAT_2007046c;\n            puVar14[2] \u003d \u0026DAT_2007046c;\n            puVar14[1] \u003d uVar7 | 1;\n            *(uint *)((int)puVar14 + uVar7) \u003d uVar7;\n            __malloc_unlock(param_1);\n            return puVar9 + 2;\n          }\n          if (-1 \u003c (int)uVar7) {\n            iVar2 \u003d puVar9[2];\n            iVar5 \u003d puVar9[3];\n            *(uint *)((int)puVar9 + uVar6 + 4) \u003d *(uint *)((int)puVar9 + uVar6 + 4) | 1;\n            *(int *)(iVar2 + 0xc) \u003d iVar5;\n            *(int *)(iVar5 + 8) \u003d iVar2;\n            __malloc_unlock(param_1);\n            return puVar9 + 2;\n          }\n        }\n        uVar3 \u003d uVar3 + 1;\n        puVar14 \u003d puVar14 + 2;\n      } while ((uVar3 \u0026 3) !\u003d 0);\n      do {\n        uVar6 \u003d uVar8 \u0026 3;\n        puVar14 \u003d puVar15 + -2;\n        uVar8 \u003d uVar8 - 1;\n        if (uVar6 \u003d\u003d 0) {\n          DAT_20070468 \u003d DAT_20070468 \u0026 ~uVar4;\n          break;\n        }\n        puVar15 \u003d (undefined4 *)*puVar15;\n      } while (puVar15 \u003d\u003d puVar14);\n      uVar4 \u003d uVar4 * 2;\n      if ((DAT_20070468 \u003c\u003d uVar4 \u0026\u0026 uVar4 - DAT_20070468 !\u003d 0) || (uVar8 \u003d uVar3, uVar4 \u003d\u003d 0))\n      break;\n      for (; (DAT_20070468 \u0026 uVar4) \u003d\u003d 0; uVar4 \u003d uVar4 \u003c\u003c 1) {\n        uVar8 \u003d uVar8 + 4;\n      }\n    } while( true );\n  }\n  uVar8 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n  if ((uVar13 \u003c\u003d uVar8) \u0026\u0026 (uVar3 \u003d uVar8 - uVar13, puVar11 \u003d DAT_2007046c, 0xf \u003c (int)uVar3))\n  goto LAB_00081b1a;\n  puVar16 \u003d DAT_2007046c + uVar8;\n  if (__malloc_sbrk_base \u003d\u003d (undefined1 *)0xffffffff) {\n    uVar3 \u003d uVar13 + __malloc_top_pad + 0x10;\n  }\n  else {\n    uVar3 \u003d uVar13 + __malloc_top_pad + 0x100f \u0026 0xfffff000;\n  }\n  puVar11 \u003d (undefined1 *)_sbrk_r(param_1,uVar3);\n  if ((puVar11 \u003d\u003d (undefined1 *)0xffffffff) || ((puVar11 \u003c puVar16 \u0026\u0026 (puVar12 !\u003d \u0026__malloc_av_))))\n  {\n    uVar8 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n    puVar11 \u003d DAT_2007046c;\n  }\n  else {\n    puVar10 \u003d __malloc_current_mallinfo + uVar3;\n    __malloc_current_mallinfo \u003d puVar10;\n    if ((puVar16 \u003d\u003d puVar11) \u0026\u0026 (((uint)puVar16 \u0026 0xfff) \u003d\u003d 0)) {\n      *(uint *)(DAT_2007046c + 4) \u003d uVar3 + uVar8 | 1;\n    }\n    else {\n      puVar1 \u003d puVar11;\n      if (__malloc_sbrk_base !\u003d (undefined1 *)0xffffffff) {\n        puVar1 \u003d __malloc_sbrk_base;\n        __malloc_current_mallinfo \u003d puVar10 + ((int)puVar11 - (int)puVar16);\n      }\n      __malloc_sbrk_base \u003d puVar1;\n      uVar4 \u003d (uint)puVar11 \u0026 7;\n      if (uVar4 \u003d\u003d 0) {\n        iVar2 \u003d 0x1000;\n      }\n      else {\n        puVar11 \u003d puVar11 + (8 - uVar4);\n        iVar2 \u003d 0x1008 - uVar4;\n      }\n      iVar2 \u003d iVar2 - ((uint)(puVar11 + uVar3) \u0026 0xfff);\n      iVar5 \u003d _sbrk_r(param_1,iVar2);\n      if (iVar5 \u003d\u003d -1) {\n        uVar3 \u003d 1;\n        iVar2 \u003d 0;\n      }\n      else {\n        uVar3 \u003d (iVar5 - (int)puVar11) + iVar2 | 1;\n      }\n      puVar10 \u003d __malloc_current_mallinfo + iVar2;\n      DAT_2007046c \u003d puVar11;\n      __malloc_current_mallinfo \u003d puVar10;\n      *(uint *)(puVar11 + 4) \u003d uVar3;\n      if (puVar12 !\u003d \u0026__malloc_av_) {\n        if (uVar8 \u003c 0x10) {\n          *(undefined4 *)(puVar11 + 4) \u003d 1;\n          uVar8 \u003d 0;\n          goto LAB_00081b04;\n        }\n        uVar8 \u003d uVar8 - 0xc \u0026 0xfffffff8;\n        *(uint *)(puVar12 + 4) \u003d uVar8 | *(uint *)(puVar12 + 4) \u0026 1;\n        *(undefined4 *)(puVar12 + uVar8 + 4) \u003d 5;\n        *(undefined4 *)(puVar12 + uVar8 + 8) \u003d 5;\n        if (0xf \u003c uVar8) {\n          _free_r(param_1,puVar12 + 8);\n          puVar10 \u003d __malloc_current_mallinfo;\n        }\n      }\n    }\n    if (__malloc_max_sbrked_mem \u003c puVar10) {\n      __malloc_max_sbrked_mem \u003d puVar10;\n    }\n    if (__malloc_max_total_mem \u003c puVar10) {\n      __malloc_max_total_mem \u003d puVar10;\n    }\n    uVar8 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n    puVar11 \u003d DAT_2007046c;\n  }\nLAB_00081b04:\n  uVar3 \u003d uVar8 - uVar13;\n  if ((uVar8 \u003c uVar13) || ((int)uVar3 \u003c 0x10)) {\n    __malloc_unlock(param_1);\n    return (int *)0x0;\n  }\nLAB_00081b1a:\n  DAT_2007046c \u003d puVar11 + uVar13;\n  *(uint *)(puVar11 + 4) \u003d uVar13 | 1;\n  *(uint *)(DAT_2007046c + 4) \u003d uVar3 | 1;\n  __malloc_unlock(param_1);\n  return (int *)(puVar11 + 8);\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "malloc",
        "_realloc_r",
        "__smakebuf_r"
      ],
      "called": [
        "_sbrk_r",
        "__malloc_lock",
        "__malloc_unlock",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memcpy": {
      "entrypoint": "0x00081d48",
      "current_name": "memcpy",
      "code": "\nvoid * memcpy(void *__dest,void *__src,size_t __n)\n\n{\n  undefined *puVar1;\n  undefined4 *puVar2;\n  undefined4 *puVar3;\n  undefined *puVar4;\n  undefined4 *puVar5;\n  undefined *puVar6;\n  uint uVar7;\n  uint uVar8;\n  bool bVar9;\n  \n  puVar3 \u003d (undefined4 *)__dest;\n  if ((((uint)__src | (uint)__dest) \u0026 3) !\u003d 0) {\n    if (__n \u003c 8) {\n      uVar8 \u003d __n - 4;\n      puVar1 \u003d (undefined *)__dest;\n      if (3 \u003c __n) {\n        do {\n          puVar6 \u003d (undefined *)__src;\n          puVar4 \u003d puVar1;\n          bVar9 \u003d uVar8 !\u003d 0;\n          uVar8 \u003d uVar8 - 1;\n          *puVar4 \u003d *puVar6;\n          puVar1 \u003d puVar4 + 1;\n          __src \u003d puVar6 + 1;\n        } while (bVar9);\n        puVar4[1] \u003d puVar6[1];\n        puVar4[2] \u003d puVar6[2];\n        puVar4[3] \u003d puVar6[3];\n        return __dest;\n      }\n      goto LAB_00081dcc;\n    }\n    if ((((uint)__src \u0026 3) !\u003d 0) \u0026\u0026 (((uint)__dest \u0026 3) !\u003d 0)) {\n      uVar8 \u003d 4 - ((uint)__dest \u0026 3);\n      __n \u003d __n - uVar8;\n      puVar2 \u003d (undefined4 *)__dest;\n      puVar5 \u003d (undefined4 *)__src;\n                    /* WARNING: Load size is inaccurate */\n      if (((uint)__dest \u0026 1) !\u003d 0) {\n        puVar5 \u003d (undefined4 *)((int)__src + 1);\n        puVar2 \u003d (undefined4 *)((int)__dest + 1);\n        *(undefined *)__dest \u003d *__src;\n      }\n      puVar3 \u003d puVar2;\n      __src \u003d puVar5;\n      if ((uVar8 \u0026 2) !\u003d 0) {\n        __src \u003d (void *)((int)puVar5 + 2);\n        puVar3 \u003d (undefined4 *)((int)puVar2 + 2);\n        *(undefined2 *)puVar2 \u003d *(undefined2 *)puVar5;\n      }\n    }\n  }\n  while (0x3f \u003c __n) {\n                    /* WARNING: Load size is inaccurate */\n    *puVar3 \u003d *__src;\n    puVar3[1] \u003d *(undefined4 *)((int)__src + 4);\n    puVar3[2] \u003d *(undefined4 *)((int)__src + 8);\n    puVar3[3] \u003d *(undefined4 *)((int)__src + 0xc);\n    puVar3[4] \u003d *(undefined4 *)((int)__src + 0x10);\n    puVar3[5] \u003d *(undefined4 *)((int)__src + 0x14);\n    puVar3[6] \u003d *(undefined4 *)((int)__src + 0x18);\n    puVar3[7] \u003d *(undefined4 *)((int)__src + 0x1c);\n    puVar3[8] \u003d *(undefined4 *)((int)__src + 0x20);\n    puVar3[9] \u003d *(undefined4 *)((int)__src + 0x24);\n    puVar3[10] \u003d *(undefined4 *)((int)__src + 0x28);\n    puVar3[0xb] \u003d *(undefined4 *)((int)__src + 0x2c);\n    puVar3[0xc] \u003d *(undefined4 *)((int)__src + 0x30);\n    puVar3[0xd] \u003d *(undefined4 *)((int)__src + 0x34);\n    puVar3[0xe] \u003d *(undefined4 *)((int)__src + 0x38);\n    puVar3[0xf] \u003d *(undefined4 *)((int)__src + 0x3c);\n    puVar3 \u003d puVar3 + 0x10;\n    __src \u003d (undefined4 *)((int)__src + 0x40);\n    __n \u003d __n - 0x40;\n  }\n  uVar7 \u003d __n - 0x10;\n  if (0xffffffcf \u003c __n - 0x40) {\n    do {\n                    /* WARNING: Load size is inaccurate */\n      *puVar3 \u003d *__src;\n      puVar3[1] \u003d *(undefined4 *)((int)__src + 4);\n      puVar3[2] \u003d *(undefined4 *)((int)__src + 8);\n      puVar3[3] \u003d *(undefined4 *)((int)__src + 0xc);\n      puVar3 \u003d puVar3 + 4;\n      __src \u003d (void *)((int)__src + 0x10);\n      bVar9 \u003d 0xf \u003c uVar7;\n      uVar7 \u003d uVar7 - 0x10;\n    } while (bVar9);\n  }\n  uVar8 \u003d uVar7 + 0xc;\n  puVar5 \u003d puVar3;\n  puVar2 \u003d (undefined4 *)__src;\n  if (0xfffffff3 \u003c uVar7) {\n    do {\n      __src \u003d puVar2 + 1;\n      *puVar5 \u003d *puVar2;\n      bVar9 \u003d 3 \u003c uVar8;\n      uVar8 \u003d uVar8 - 4;\n      puVar3 \u003d puVar5 + 1;\n      puVar5 \u003d puVar5 + 1;\n      puVar2 \u003d (undefined4 *)__src;\n    } while (bVar9);\n  }\nLAB_00081dcc:\n  if (uVar8 + 4 !\u003d 0) {\n    puVar2 \u003d puVar3;\n    puVar5 \u003d (undefined4 *)__src;\n                    /* WARNING: Load size is inaccurate */\n    if ((uVar8 \u0026 1) !\u003d 0) {\n      puVar5 \u003d (undefined4 *)((int)__src + 1);\n      puVar2 \u003d (undefined4 *)((int)puVar3 + 1);\n      *(undefined *)puVar3 \u003d *__src;\n    }\n    if ((uVar8 + 4 \u0026 2) !\u003d 0) {\n      *(undefined2 *)puVar2 \u003d *(undefined2 *)puVar5;\n    }\n  }\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memmove": {
      "entrypoint": "0x00081e34",
      "current_name": "memmove",
      "code": "\nvoid * memmove(void *__dest,void *__src,size_t __n)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  undefined4 *puVar3;\n  undefined4 *puVar4;\n  undefined *puVar5;\n  uint uVar6;\n  undefined *puVar7;\n  uint uVar8;\n  \n  if ((__src \u003c __dest) \u0026\u0026 (puVar5 \u003d (undefined *)((int)__src + __n), __dest \u003c puVar5)) {\n    puVar7 \u003d (undefined *)((int)__dest + __n);\n    iVar1 \u003d __n - 1;\n    if (__n !\u003d 0) {\n      do {\n        puVar5 \u003d puVar5 + -1;\n        iVar1 \u003d iVar1 + -1;\n        puVar7 \u003d puVar7 + -1;\n        *puVar7 \u003d *puVar5;\n      } while (iVar1 !\u003d -1);\n    }\n    return __dest;\n  }\n  puVar2 \u003d (undefined4 *)__dest;\n  if (__n \u003c 0x10) {\n    if (__n \u003d\u003d 0) {\n      return __dest;\n    }\n  }\n  else if ((((uint)__dest | (uint)__src) \u0026 3) \u003d\u003d 0) {\n    puVar3 \u003d (undefined4 *)__src;\n    do {\n      puVar4 \u003d puVar2 + 4;\n      *puVar2 \u003d *puVar3;\n      puVar2[1] \u003d puVar3[1];\n      puVar2[2] \u003d puVar3[2];\n      puVar2[3] \u003d puVar3[3];\n      puVar2 \u003d puVar4;\n      puVar3 \u003d puVar3 + 4;\n    } while (puVar4 !\u003d (undefined4 *)((int)__dest + (__n - 0x10 \u0026 0xfffffff0) + 0x10));\n    uVar8 \u003d __n \u0026 0xf;\n    iVar1 \u003d ((__n - 0x10 \u003e\u003e 4) + 1) * 0x10;\n    __src \u003d (void *)((int)__src + iVar1);\n    puVar2 \u003d (undefined4 *)(iVar1 + (int)__dest);\n    uVar6 \u003d uVar8;\n    puVar3 \u003d puVar2;\n    puVar4 \u003d (undefined4 *)__src;\n    if (3 \u003c uVar8) {\n      do {\n        uVar6 \u003d uVar6 - 4;\n        *puVar3 \u003d *puVar4;\n        puVar3 \u003d puVar3 + 1;\n        puVar4 \u003d puVar4 + 1;\n      } while (3 \u003c uVar6);\n      iVar1 \u003d (uVar8 - 4 \u0026 0xfffffffc) + 4;\n      puVar2 \u003d (undefined4 *)((int)puVar2 + iVar1);\n      __src \u003d (void *)((int)__src + iVar1);\n      uVar8 \u003d __n \u0026 3;\n    }\n    __n \u003d uVar8;\n    if (__n \u003d\u003d 0) {\n      return __dest;\n    }\n  }\n  puVar3 \u003d puVar2;\n  do {\n                    /* WARNING: Load size is inaccurate */\n    puVar4 \u003d (undefined4 *)((int)puVar3 + 1);\n    *(undefined *)puVar3 \u003d *__src;\n    __src \u003d (undefined4 *)((int)__src + 1);\n    puVar3 \u003d puVar4;\n  } while (puVar4 !\u003d (undefined4 *)(__n + (int)puVar2));\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "_realloc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memset": {
      "entrypoint": "0x00081f00",
      "current_name": "memset",
      "code": "\nvoid * memset(void *__s,int __c,size_t __n)\n\n{\n  uint *puVar1;\n  uint *puVar2;\n  uint *puVar3;\n  uint uVar4;\n  uint uVar5;\n  bool bVar6;\n  \n  puVar2 \u003d (uint *)__s;\n  if (((uint)__s \u0026 3) !\u003d 0) {\n    bVar6 \u003d __n \u003d\u003d 0;\n    puVar1 \u003d (uint *)__s;\n    __n \u003d __n - 1;\n    if (bVar6) {\n      return __s;\n    }\n    while( true ) {\n      puVar2 \u003d (uint *)((int)puVar1 + 1);\n      *(char *)puVar1 \u003d (char)__c;\n      if (((uint)puVar2 \u0026 3) \u003d\u003d 0) break;\n      bVar6 \u003d __n \u003d\u003d 0;\n      puVar1 \u003d puVar2;\n      __n \u003d __n - 1;\n      if (bVar6) {\n        return __s;\n      }\n    }\n  }\n  if (3 \u003c __n) {\n    uVar4 \u003d __c \u0026 0xffU | (__c \u0026 0xffU) \u003c\u003c 8;\n    uVar4 \u003d uVar4 | uVar4 \u003c\u003c 0x10;\n    uVar5 \u003d __n;\n    puVar1 \u003d puVar2;\n    if (0xf \u003c __n) {\n      uVar5 \u003d __n - 0x10;\n      do {\n        *puVar1 \u003d uVar4;\n        puVar1[1] \u003d uVar4;\n        puVar1[2] \u003d uVar4;\n        puVar1[3] \u003d uVar4;\n        puVar1 \u003d puVar1 + 4;\n      } while (puVar1 !\u003d (uint *)((int)puVar2 + (uVar5 \u0026 0xfffffff0) + 0x10));\n      __n \u003d __n \u0026 0xf;\n      puVar2 \u003d puVar2 + ((uVar5 \u003e\u003e 4) + 1) * 4;\n      uVar5 \u003d __n;\n      puVar1 \u003d puVar2;\n      if (__n \u003c 4) goto LAB_00081f7c;\n    }\n    do {\n      __n \u003d __n - 4;\n      *puVar2 \u003d uVar4;\n      puVar2 \u003d puVar2 + 1;\n    } while (3 \u003c __n);\n    puVar2 \u003d (uint *)((int)puVar1 + (uVar5 - 4 \u0026 0xfffffffc) + 4);\n    __n \u003d uVar5 \u0026 3;\n  }\nLAB_00081f7c:\n  if (__n !\u003d 0) {\n    puVar1 \u003d puVar2;\n    do {\n      puVar3 \u003d (uint *)((int)puVar1 + 1);\n      *(char *)puVar1 \u003d (char)__c;\n      puVar1 \u003d puVar3;\n    } while (puVar3 !\u003d (uint *)(__n + (int)puVar2));\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "RingBuffer",
        "__sinit"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_lock": {
      "entrypoint": "0x00081f94",
      "current_name": "__malloc_lock",
      "code": "\nvoid __malloc_lock(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r",
        "_realloc_r",
        "_malloc_trim_r",
        "_free_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__malloc_unlock": {
      "entrypoint": "0x00081f98",
      "current_name": "__malloc_unlock",
      "code": "\nvoid __malloc_unlock(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r",
        "_realloc_r",
        "_malloc_trim_r",
        "_free_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "realloc": {
      "entrypoint": "0x00081f9c",
      "current_name": "realloc",
      "code": "\nvoid * realloc(void *__ptr,size_t __size)\n\n{\n  void *pvVar1;\n  \n  pvVar1 \u003d (void *)_realloc_r(_impure_ptr,__ptr,__size);\n  return pvVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "changeBuffer"
      ],
      "called": [
        "_realloc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_realloc_r": {
      "entrypoint": "0x00081fac",
      "current_name": "_realloc_r",
      "code": "\nint * _realloc_r(undefined4 *param_1,int *param_2,uint param_3)\n\n{\n  int iVar1;\n  int *piVar2;\n  uint uVar3;\n  size_t sVar4;\n  uint uVar5;\n  int iVar6;\n  int *piVar7;\n  uint uVar8;\n  uint uVar9;\n  int *piVar10;\n  \n  if (param_2 \u003d\u003d (int *)0x0) {\n    piVar2 \u003d (int *)_malloc_r(param_1,param_3);\n    return piVar2;\n  }\n  __malloc_lock();\n  uVar5 \u003d param_2[-1];\n  uVar8 \u003d uVar5 \u0026 0xfffffffc;\n  piVar2 \u003d param_2 + -2;\n  if (param_3 + 0xb \u003c 0x17) {\n    uVar9 \u003d 0x10;\n  }\n  else {\n    uVar9 \u003d param_3 + 0xb \u0026 0xfffffff8;\n    if ((int)uVar9 \u003c 0) goto LAB_00082078;\n  }\n  if (uVar9 \u003c param_3) {\nLAB_00082078:\n    *param_1 \u003d 0xc;\n    return (int *)0x0;\n  }\n  if ((int)uVar8 \u003c (int)uVar9) {\n    iVar1 \u003d (int)piVar2 + uVar8;\n    if (DAT_2007046c \u003d\u003d iVar1) {\n      uVar3 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n      iVar1 \u003d DAT_2007046c;\n      if ((int)(uVar9 + 0x10) \u003c\u003d (int)(uVar3 + uVar8)) {\n        DAT_2007046c \u003d (int)piVar2 + uVar9;\n        *(uint *)(DAT_2007046c + 4) \u003d (uVar3 + uVar8) - uVar9 | 1;\n        param_2[-1] \u003d uVar9 | param_2[-1] \u0026 1U;\n        __malloc_unlock(param_1);\n        return param_2;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(iVar1 + 4) \u0026 0xfffffffe) + iVar1 + 4) \u0026 1) \u003d\u003d 0) {\n      uVar3 \u003d *(uint *)(iVar1 + 4) \u0026 0xfffffffc;\n      if ((int)uVar9 \u003c\u003d (int)(uVar3 + uVar8)) {\n        iVar6 \u003d *(int *)(iVar1 + 0xc);\n        iVar1 \u003d *(int *)(iVar1 + 8);\n        *(int *)(iVar1 + 0xc) \u003d iVar6;\n        *(int *)(iVar6 + 8) \u003d iVar1;\n        uVar8 \u003d uVar3 + uVar8;\n        goto LAB_00082088;\n      }\n    }\n    else {\n      uVar3 \u003d 0;\n      iVar1 \u003d 0;\n    }\n    if (-1 \u003c (int)(uVar5 \u003c\u003c 0x1f)) {\n      piVar10 \u003d (int *)((int)piVar2 - param_2[-2]);\n      uVar5 \u003d (piVar10[1] \u0026 0xfffffffcU) + uVar8;\n      if (iVar1 !\u003d 0) {\n        if (iVar1 \u003d\u003d DAT_2007046c) {\n          if ((int)(uVar9 + 0x10) \u003c\u003d (int)(uVar3 + uVar5)) {\n            piVar2 \u003d piVar10 + 2;\n            iVar1 \u003d *piVar2;\n            iVar6 \u003d piVar10[3];\n            sVar4 \u003d uVar8 - 4;\n            *(int *)(iVar1 + 0xc) \u003d iVar6;\n            *(int *)(iVar6 + 8) \u003d iVar1;\n            if (sVar4 \u003c 0x25) {\n              piVar7 \u003d piVar2;\n              if (0x13 \u003c sVar4) {\n                piVar10[2] \u003d *param_2;\n                piVar10[3] \u003d param_2[1];\n                if (sVar4 \u003c 0x1c) {\n                  param_2 \u003d param_2 + 2;\n                  piVar7 \u003d piVar10 + 4;\n                }\n                else {\n                  piVar10[4] \u003d param_2[2];\n                  piVar10[5] \u003d param_2[3];\n                  if (sVar4 \u003d\u003d 0x24) {\n                    piVar10[6] \u003d param_2[4];\n                    piVar7 \u003d param_2 + 5;\n                    param_2 \u003d param_2 + 6;\n                    piVar10[7] \u003d *piVar7;\n                    piVar7 \u003d piVar10 + 8;\n                  }\n                  else {\n                    param_2 \u003d param_2 + 4;\n                    piVar7 \u003d piVar10 + 6;\n                  }\n                }\n              }\n              *piVar7 \u003d *param_2;\n              piVar7[1] \u003d param_2[1];\n              piVar7[2] \u003d param_2[2];\n            }\n            else {\n              memmove(piVar2,param_2,sVar4);\n            }\n            DAT_2007046c \u003d (int)piVar10 + uVar9;\n            *(uint *)(DAT_2007046c + 4) \u003d (uVar3 + uVar5) - uVar9 | 1;\n            piVar10[1] \u003d uVar9 | piVar10[1] \u0026 1U;\n            __malloc_unlock(param_1);\n            return piVar2;\n          }\n        }\n        else {\n          uVar3 \u003d uVar3 + uVar5;\n          if ((int)uVar9 \u003c\u003d (int)uVar3) {\n            iVar6 \u003d *(int *)(iVar1 + 0xc);\n            iVar1 \u003d *(int *)(iVar1 + 8);\n            *(int *)(iVar1 + 0xc) \u003d iVar6;\n            *(int *)(iVar6 + 8) \u003d iVar1;\n            piVar7 \u003d piVar10 + 2;\n            iVar1 \u003d *piVar7;\n            iVar6 \u003d piVar10[3];\n            sVar4 \u003d uVar8 - 4;\n            *(int *)(iVar1 + 0xc) \u003d iVar6;\n            *(int *)(iVar6 + 8) \u003d iVar1;\n            uVar8 \u003d uVar3;\n            if (sVar4 \u003c 0x25) {\n              piVar2 \u003d piVar7;\n              if (0x13 \u003c sVar4) {\n                piVar10[2] \u003d *param_2;\n                piVar10[3] \u003d param_2[1];\n                if (sVar4 \u003c 0x1c) {\n                  param_2 \u003d param_2 + 2;\n                  piVar2 \u003d piVar10 + 4;\n                }\n                else {\n                  piVar10[4] \u003d param_2[2];\n                  piVar10[5] \u003d param_2[3];\n                  if (sVar4 \u003d\u003d 0x24) {\n                    piVar10[6] \u003d param_2[4];\n                    piVar2 \u003d param_2 + 5;\n                    param_2 \u003d param_2 + 6;\n                    piVar10[7] \u003d *piVar2;\n                    piVar2 \u003d piVar10 + 8;\n                  }\n                  else {\n                    param_2 \u003d param_2 + 4;\n                    piVar2 \u003d piVar10 + 6;\n                  }\n                }\n              }\n              *piVar2 \u003d *param_2;\n              piVar2[1] \u003d param_2[1];\n              piVar2[2] \u003d param_2[2];\n              uVar5 \u003d piVar10[1];\n              piVar2 \u003d piVar10;\n              param_2 \u003d piVar7;\n            }\n            else {\n              memmove(piVar7,param_2,sVar4);\n              uVar5 \u003d piVar10[1];\n              piVar2 \u003d piVar10;\n              param_2 \u003d piVar7;\n            }\n            goto LAB_00082088;\n          }\n        }\n      }\n      if ((int)uVar9 \u003c\u003d (int)uVar5) {\n        piVar7 \u003d piVar10 + 2;\n        iVar1 \u003d *piVar7;\n        iVar6 \u003d piVar10[3];\n        sVar4 \u003d uVar8 - 4;\n        *(int *)(iVar1 + 0xc) \u003d iVar6;\n        *(int *)(iVar6 + 8) \u003d iVar1;\n        uVar8 \u003d uVar5;\n        if (sVar4 \u003c 0x25) {\n          piVar2 \u003d piVar7;\n          if (0x13 \u003c sVar4) {\n            piVar10[2] \u003d *param_2;\n            piVar10[3] \u003d param_2[1];\n            if (sVar4 \u003c 0x1c) {\n              param_2 \u003d param_2 + 2;\n              piVar2 \u003d piVar10 + 4;\n            }\n            else {\n              piVar10[4] \u003d param_2[2];\n              piVar10[5] \u003d param_2[3];\n              if (sVar4 \u003d\u003d 0x24) {\n                piVar10[6] \u003d param_2[4];\n                piVar2 \u003d param_2 + 5;\n                param_2 \u003d param_2 + 6;\n                piVar10[7] \u003d *piVar2;\n                piVar2 \u003d piVar10 + 8;\n              }\n              else {\n                param_2 \u003d param_2 + 4;\n                piVar2 \u003d piVar10 + 6;\n              }\n            }\n          }\n          *piVar2 \u003d *param_2;\n          piVar2[1] \u003d param_2[1];\n          piVar2[2] \u003d param_2[2];\n          uVar5 \u003d piVar10[1];\n          piVar2 \u003d piVar10;\n          param_2 \u003d piVar7;\n        }\n        else {\n          memmove(piVar7,param_2,sVar4);\n          uVar5 \u003d piVar10[1];\n          piVar2 \u003d piVar10;\n          param_2 \u003d piVar7;\n        }\n        goto LAB_00082088;\n      }\n    }\n    piVar10 \u003d (int *)_malloc_r(param_1,param_3);\n    if (piVar10 \u003d\u003d (int *)0x0) goto LAB_000820a0;\n    uVar5 \u003d param_2[-1];\n    if (piVar10 + -2 !\u003d (int *)((uVar5 \u0026 0xfffffffe) + (int)piVar2)) {\n      sVar4 \u003d uVar8 - 4;\n      if (sVar4 \u003c 0x25) {\n        piVar2 \u003d param_2;\n        piVar7 \u003d piVar10;\n        if (0x13 \u003c sVar4) {\n          *piVar10 \u003d *param_2;\n          piVar10[1] \u003d param_2[1];\n          if (sVar4 \u003c 0x1c) {\n            piVar2 \u003d param_2 + 2;\n            piVar7 \u003d piVar10 + 2;\n          }\n          else {\n            piVar10[2] \u003d param_2[2];\n            piVar10[3] \u003d param_2[3];\n            if (sVar4 \u003d\u003d 0x24) {\n              piVar10[4] \u003d param_2[4];\n              piVar10[5] \u003d param_2[5];\n              piVar2 \u003d param_2 + 6;\n              piVar7 \u003d piVar10 + 6;\n            }\n            else {\n              piVar2 \u003d param_2 + 4;\n              piVar7 \u003d piVar10 + 4;\n            }\n          }\n        }\n        *piVar7 \u003d *piVar2;\n        piVar7[1] \u003d piVar2[1];\n        piVar7[2] \u003d piVar2[2];\n      }\n      else {\n        memmove(piVar10,param_2,sVar4);\n      }\n      _free_r(param_1,param_2);\n      goto LAB_000820a0;\n    }\n    uVar8 \u003d uVar8 + (piVar10[-1] \u0026 0xfffffffcU);\n  }\nLAB_00082088:\n  uVar3 \u003d uVar8 - uVar9;\n  piVar10 \u003d param_2;\n  if (uVar3 \u003c 0x10) {\n    piVar2[1] \u003d uVar5 \u0026 1 | uVar8;\n    *(uint *)((int)piVar2 + uVar8 + 4) \u003d *(uint *)((int)piVar2 + uVar8 + 4) | 1;\n  }\n  else {\n    piVar2[1] \u003d uVar5 \u0026 1 | uVar9;\n    *(uint *)((int)piVar2 + uVar9 + 4) \u003d uVar3 | 1;\n    *(uint *)((int)piVar2 + uVar3 + uVar9 + 4) \u003d *(uint *)((int)piVar2 + uVar3 + uVar9 + 4) | 1;\n    _free_r(param_1,(int)piVar2 + uVar9 + 8);\n  }\nLAB_000820a0:\n  __malloc_unlock(param_1);\n  return piVar10;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "realloc"
      ],
      "called": [
        "_malloc_r",
        "__malloc_lock",
        "__malloc_unlock",
        "memmove",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_sbrk_r": {
      "entrypoint": "0x0008236c",
      "current_name": "_sbrk_r",
      "code": "\nvoid _sbrk_r(int *param_1,intptr_t param_2)\n\n{\n  void *pvVar1;\n  \n  errno \u003d 0;\n  pvVar1 \u003d _sbrk(param_2);\n  if ((pvVar1 \u003d\u003d (void *)0xffffffff) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_malloc_r",
        "_malloc_trim_r"
      ],
      "called": [
        "_sbrk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcmp": {
      "entrypoint": "0x00082390",
      "current_name": "strcmp",
      "code": "\nint strcmp(char *__s1,char *__s2)\n\n{\n  uint *puVar1;\n  int iVar2;\n  byte *pbVar3;\n  byte *pbVar4;\n  uint *puVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  \n  if ((((uint)__s1 | (uint)__s2) \u0026 7) !\u003d 0) {\n    puVar1 \u003d (uint *)__s1;\n    if (((uint)__s1 \u0026 3) !\u003d 0) {\n      puVar1 \u003d (uint *)((uint)__s1 \u0026 0xfffffffc) + 1;\n      uVar6 \u003d *(uint *)((uint)__s1 \u0026 0xfffffffc);\n      pbVar3 \u003d (byte *)__s2;\n      if (((uint)__s1 \u0026 1) \u003d\u003d 0) {\nLAB_00082410:\n        pbVar4 \u003d pbVar3 + 1;\n        uVar7 \u003d uVar6 \u003e\u003e 0x10 \u0026 0xff;\n        iVar2 \u003d uVar7 - *pbVar3;\n        if (iVar2 !\u003d 0) {\n          return iVar2;\n        }\n        if (uVar7 \u003d\u003d 0) {\n          return 0;\n        }\n      }\n      else {\n        pbVar4 \u003d (byte *)__s2;\n        if (((uint)__s1 \u0026 2) \u003d\u003d 0) {\n          pbVar3 \u003d (byte *)(__s2 + 1);\n          uVar7 \u003d uVar6 \u003e\u003e 8 \u0026 0xff;\n          iVar2 \u003d uVar7 - (byte)*__s2;\n          if (iVar2 !\u003d 0) {\n            return iVar2;\n          }\n          if (uVar7 \u003d\u003d 0) {\n            return 0;\n          }\n          goto LAB_00082410;\n        }\n      }\n      __s2 \u003d (char *)(pbVar4 + 1);\n      iVar2 \u003d (uVar6 \u003e\u003e 0x18) - (uint)*pbVar4;\n      if ((iVar2 !\u003d 0) || (uVar6 \u003e\u003e 0x18 \u003d\u003d 0)) {\n        return iVar2;\n      }\n    }\n    uVar6 \u003d (uint)__s2 \u0026 3;\n    if (uVar6 !\u003d 0) {\n      puVar5 \u003d (uint *)((uint)__s2 \u0026 0xfffffffc);\n      if (uVar6 \u003d\u003d 2) {\n        uVar6 \u003d *puVar5;\n        do {\n          puVar5 \u003d puVar5 + 1;\n          uVar8 \u003d *puVar1;\n          uVar6 \u003d uVar6 \u003e\u003e 0x10;\n          uVar9 \u003d uVar8 + 0xfefefeff \u0026 ~uVar8;\n          uVar10 \u003d uVar9 \u0026 0x80808080;\n          uVar7 \u003d uVar8 \u0026 0xffff;\n          if ((uVar9 \u0026 0x8080) !\u003d 0 || uVar7 !\u003d uVar6) goto LAB_0008258e;\n          uVar6 \u003d *puVar5;\n          uVar7 \u003d uVar7 ^ uVar8;\n          uVar8 \u003d uVar6 * 0x10000;\n          puVar1 \u003d puVar1 + 1;\n        } while (uVar10 \u003d\u003d 0 \u0026\u0026 uVar7 \u003d\u003d uVar8);\n      }\n      else if (uVar6 \u003c 2) {\n        uVar6 \u003d *puVar5;\n        do {\n          puVar5 \u003d puVar5 + 1;\n          uVar8 \u003d *puVar1;\n          uVar6 \u003d uVar6 \u003e\u003e 8;\n          uVar9 \u003d uVar8 + 0xfefefeff \u0026 ~uVar8;\n          uVar10 \u003d uVar9 \u0026 0x80808080;\n          uVar7 \u003d uVar8 \u0026 0xffffff;\n          if ((uVar9 \u0026 0x808080) !\u003d 0 || uVar7 !\u003d uVar6) goto LAB_0008258e;\n          uVar6 \u003d *puVar5;\n          uVar7 \u003d uVar7 ^ uVar8;\n          uVar8 \u003d uVar6 * 0x1000000;\n          puVar1 \u003d puVar1 + 1;\n        } while (uVar10 \u003d\u003d 0 \u0026\u0026 uVar7 \u003d\u003d uVar8);\n      }\n      else {\n        uVar6 \u003d *puVar5;\n        do {\n          puVar5 \u003d puVar5 + 1;\n          uVar8 \u003d *puVar1;\n          uVar6 \u003d uVar6 \u003e\u003e 0x18;\n          uVar9 \u003d uVar8 + 0xfefefeff \u0026 ~uVar8;\n          uVar10 \u003d uVar9 \u0026 0x80808080;\n          uVar7 \u003d uVar8 \u0026 0xff;\n          if ((uVar9 \u0026 0x80) !\u003d 0 || uVar7 !\u003d uVar6) goto LAB_0008258e;\n          uVar6 \u003d *puVar5;\n          uVar7 \u003d uVar7 ^ uVar8;\n          uVar8 \u003d uVar6 * 0x100;\n          puVar1 \u003d puVar1 + 1;\n        } while (uVar10 \u003d\u003d 0 \u0026\u0026 uVar7 \u003d\u003d uVar8);\n      }\n      uVar7 \u003d uVar7 \u003c\u003c 0x18 | (uVar7 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar7 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 |\n              uVar7 \u003e\u003e 0x18;\n      uVar6 \u003d (uVar8 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar8 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 | uVar8 \u003e\u003e 0x18;\n      goto LAB_0008259e;\n    }\n    __s1 \u003d (char *)puVar1;\n    puVar5 \u003d (uint *)__s2;\n    if (((uint)puVar1 \u0026 4) !\u003d 0) {\n      __s1 \u003d (char *)(puVar1 + 1);\n      uVar6 \u003d *puVar1;\n      puVar5 \u003d (uint *)((int)__s2 + 4);\n      uVar8 \u003d *(uint *)__s2;\n      uVar10 \u003d uVar6 + 0xfefefeff \u0026 ~uVar6 \u0026 0x80808080;\n      if (uVar6 !\u003d uVar8 || uVar10 !\u003d 0) {\nLAB_0008259a:\n        uVar7 \u003d uVar6 \u003c\u003c 0x18 | (uVar6 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar6 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 |\n                uVar6 \u003e\u003e 0x18;\n        uVar6 \u003d uVar8 \u003c\u003c 0x18 | (uVar8 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar8 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 |\n                uVar8 \u003e\u003e 0x18;\n        goto LAB_0008259e;\n      }\n    }\n    __s2 \u003d (char *)puVar5;\n    if (((uint)puVar5 \u0026 4) !\u003d 0) {\n      uVar6 \u003d *puVar5;\n      puVar1 \u003d puVar5 + 1;\n      do {\n        uVar7 \u003d *(uint *)__s1;\n        uVar8 \u003d *(uint *)((int)__s1 + 4);\n        uVar10 \u003d uVar7 + 0xfefefeff \u0026 ~uVar7 \u0026 0x80808080;\n        if (uVar7 !\u003d uVar6 || uVar10 !\u003d 0) goto LAB_0008258e;\n        uVar9 \u003d *puVar1;\n        uVar6 \u003d puVar1[1];\n        uVar10 \u003d uVar8 + 0xfefefeff \u0026 ~uVar8 \u0026 0x80808080;\n        __s1 \u003d (char *)((int)__s1 + 8);\n        puVar1 \u003d puVar1 + 2;\n      } while (uVar8 \u003d\u003d uVar9 \u0026\u0026 uVar10 \u003d\u003d 0);\n      uVar7 \u003d uVar8 \u003c\u003c 0x18 | (uVar8 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar8 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 |\n              uVar8 \u003e\u003e 0x18;\n      uVar6 \u003d uVar9 \u003c\u003c 0x18 | (uVar9 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar9 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 |\n              uVar9 \u003e\u003e 0x18;\n      goto LAB_0008259e;\n    }\n  }\n  do {\n    uVar6 \u003d *(uint *)__s1;\n    uVar7 \u003d *(uint *)((int)__s1 + 4);\n    uVar8 \u003d *(uint *)__s2;\n    uVar9 \u003d *(uint *)((int)__s2 + 4);\n    uVar10 \u003d uVar6 + 0xfefefeff \u0026 ~uVar6 \u0026 0x80808080;\n    if (uVar6 !\u003d uVar8 || uVar10 !\u003d 0) goto LAB_0008259a;\n    uVar10 \u003d uVar7 + 0xfefefeff \u0026 ~uVar7 \u0026 0x80808080;\n    __s1 \u003d (char *)((int)__s1 + 8);\n    __s2 \u003d (char *)((int)__s2 + 8);\n  } while (uVar7 \u003d\u003d uVar9 \u0026\u0026 uVar10 \u003d\u003d 0);\n  uVar7 \u003d uVar7 \u003c\u003c 0x18 | (uVar7 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar7 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 | uVar7 \u003e\u003e 0x18;\n  uVar6 \u003d uVar9 \u003c\u003c 0x18 | (uVar9 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar9 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 | uVar9 \u003e\u003e 0x18;\nLAB_0008259e:\n  uVar8 \u003d uVar10 \u003c\u003c 0x18 | (uVar10 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar10 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 |\n          uVar10 \u003e\u003e 0x18;\n  if (uVar8 !\u003d 0) {\n    uVar8 \u003d 0x18 - LZCOUNT(uVar8);\n    uVar7 \u003d uVar7 \u003e\u003e (uVar8 \u0026 0xff);\n    uVar6 \u003d uVar6 \u003e\u003e (uVar8 \u0026 0xff);\n  }\n  iVar2 \u003d 1;\n  if (uVar7 \u003c\u003d uVar6) {\n    iVar2 \u003d -(uint)(uVar7 \u003c uVar6);\n  }\n  return iVar2;\nLAB_0008258e:\n  uVar7 \u003d uVar7 \u003c\u003c 0x18 | (uVar7 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar7 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 | uVar7 \u003e\u003e 0x18;\n  uVar6 \u003d uVar6 \u003c\u003c 0x18 | (uVar6 \u003e\u003e 8 \u0026 0xff) \u003c\u003c 0x10 | (uVar6 \u003e\u003e 0x10 \u0026 0xff) \u003c\u003c 8 | uVar6 \u003e\u003e 0x18;\n  goto LAB_0008259e;\n}\n\n",
      "renaming": {},
      "calling": [
        "equals"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strcpy": {
      "entrypoint": "0x000825cc",
      "current_name": "strcpy",
      "code": "\nchar * strcpy(char *__dest,char *__src)\n\n{\n  char cVar1;\n  ushort uVar2;\n  uint *puVar3;\n  uint *puVar4;\n  uint uVar5;\n  uint uVar6;\n  uint *puVar7;\n  uint *puVar8;\n  char *pcVar9;\n  bool bVar10;\n  \n  pcVar9 \u003d __dest;\n  if ((((uint)__dest ^ (uint)__src) \u0026 3) !\u003d 0) {\n    do {\n      cVar1 \u003d *__src;\n      *pcVar9 \u003d cVar1;\n      __src \u003d __src + 1;\n      pcVar9 \u003d pcVar9 + 1;\n    } while (cVar1 !\u003d \u0027\\0\u0027);\n    return __dest;\n  }\n  puVar8 \u003d (uint *)__dest;\n  if (((uint)__src \u0026 3) !\u003d 0) {\n    puVar4 \u003d (uint *)__src;\n    if (((uint)__src \u0026 1) !\u003d 0) {\n      puVar4 \u003d (uint *)(__src + 1);\n      cVar1 \u003d *__src;\n      puVar8 \u003d (uint *)(__dest + 1);\n      *__dest \u003d cVar1;\n      if (cVar1 \u003d\u003d \u0027\\0\u0027) {\n        return __dest;\n      }\n    }\n    __src \u003d (char *)puVar4;\n    if (((uint)puVar4 \u0026 2) !\u003d 0) {\n      __src \u003d (char *)((int)puVar4 + 2);\n      uVar2 \u003d *(ushort *)puVar4;\n      bVar10 \u003d (uVar2 \u0026 0xff) \u003d\u003d 0;\n      if (bVar10) {\n        *(char *)puVar8 \u003d (char)uVar2;\n      }\n      else {\n        *(ushort *)puVar8 \u003d uVar2;\n        bVar10 \u003d (uVar2 \u0026 0xff00) \u003d\u003d 0;\n        puVar8 \u003d (uint *)((int)puVar8 + 2);\n      }\n      if (bVar10) {\n        return __dest;\n      }\n    }\n  }\n  uVar5 \u003d *(uint *)__src;\n  puVar4 \u003d (uint *)((int)__src + 4);\n  puVar7 \u003d puVar8;\n  if (((uint)__src \u0026 4) !\u003d 0) {\n    if ((uVar5 + 0xfefefeff \u0026 ~uVar5 \u0026 0x80808080) !\u003d 0) goto LAB_00082630;\n    puVar7 \u003d puVar8 + 1;\n    *puVar8 \u003d uVar5;\n    puVar4 \u003d (uint *)((int)__src + 8);\n    uVar5 \u003d *(uint *)((int)__src + 4);\n  }\n  while( true ) {\n    puVar3 \u003d puVar4 + 1;\n    uVar6 \u003d *puVar4;\n    puVar8 \u003d puVar7;\n    if ((uVar5 + 0xfefefeff \u0026 ~uVar5 \u0026 0x80808080) !\u003d 0) break;\n    puVar8 \u003d puVar7 + 1;\n    *puVar7 \u003d uVar5;\n    uVar5 \u003d uVar6;\n    if ((uVar6 + 0xfefefeff \u0026 ~uVar6 \u0026 0x80808080) !\u003d 0) break;\n    puVar4 \u003d puVar4 + 2;\n    uVar5 \u003d *puVar3;\n    puVar7 \u003d puVar7 + 2;\n    *puVar8 \u003d uVar6;\n  }\nLAB_00082630:\n  do {\n    *(char *)puVar8 \u003d (char)uVar5;\n    uVar6 \u003d uVar5 \u0026 0xff;\n    uVar5 \u003d uVar5 \u003e\u003e 8 | uVar5 \u003c\u003c 0x18;\n    puVar8 \u003d (uint *)((int)puVar8 + 1);\n  } while (uVar6 !\u003d 0);\n  return __dest;\n}\n\n",
      "renaming": {},
      "calling": [
        "copy",
        "move",
        "concat"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strlen": {
      "entrypoint": "0x00082688",
      "current_name": "strlen",
      "code": "\nsize_t strlen(char *__s)\n\n{\n  size_t sVar1;\n  uint *puVar2;\n  uint uVar3;\n  bool bVar4;\n  \n  puVar2 \u003d (uint *)((uint)__s \u0026 0xfffffffc);\n  sVar1 \u003d -((uint)__s \u0026 3);\n  uVar3 \u003d *puVar2;\n  if (((uint)__s \u0026 3) !\u003d 0) {\n    uVar3 \u003d uVar3 | 0xffffffffU \u003e\u003e ((sVar1 + 4 \u0026 0x1f) \u003c\u003c 3);\n  }\n  while (puVar2 \u003d puVar2 + 1, (uVar3 + 0xfefefeff \u0026 ~uVar3 \u0026 0x80808080) \u003d\u003d 0) {\n    sVar1 \u003d sVar1 + 4;\n    uVar3 \u003d *puVar2;\n  }\n  bVar4 \u003d (uVar3 \u0026 0xff) \u003d\u003d 0;\n  if (!bVar4) {\n    sVar1 \u003d sVar1 + 1;\n    bVar4 \u003d (uVar3 \u0026 0xff00) \u003d\u003d 0;\n  }\n  if (!bVar4) {\n    sVar1 \u003d sVar1 + 1;\n    bVar4 \u003d (uVar3 \u0026 0xff0000) \u003d\u003d 0;\n  }\n  if (!bVar4) {\n    sVar1 \u003d sVar1 + 1;\n  }\n  return sVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "String",
        "write",
        "_vfiprintf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_strtol_r": {
      "entrypoint": "0x000826e8",
      "current_name": "_strtol_r",
      "code": "\nuint _strtol_r(undefined4 *param_1,byte *param_2,byte **param_3,uint param_4)\n\n{\n  byte bVar1;\n  byte bVar2;\n  uint uVar3;\n  byte *pbVar4;\n  uint uVar5;\n  byte *pbVar6;\n  int iVar7;\n  int iVar8;\n  uint uVar9;\n  uint uVar10;\n  \n  pbVar4 \u003d param_2;\n  do {\n    pbVar6 \u003d pbVar4;\n    pbVar4 \u003d pbVar6 + 1;\n    uVar5 \u003d (uint)*pbVar6;\n    bVar1 \u003d *(byte *)(__ctype_ptr__ + uVar5 + 1);\n    bVar2 \u003d bVar1 \u0026 8;\n  } while ((bVar1 \u0026 8) !\u003d 0);\n  if (uVar5 \u003d\u003d 0x2d) {\n    pbVar4 \u003d pbVar6 + 2;\n    uVar5 \u003d (uint)pbVar6[1];\n    bVar2 \u003d 1;\n  }\n  else if (uVar5 \u003d\u003d 0x2b) {\n    uVar5 \u003d (uint)pbVar6[1];\n    pbVar4 \u003d pbVar6 + 2;\n  }\n  if ((param_4 \u0026 0xffffffef) \u003d\u003d 0) {\n    if (uVar5 \u003d\u003d 0x30) {\n      if ((*pbVar4 \u0026 0xdf) \u003d\u003d 0x58) {\n        uVar5 \u003d (uint)pbVar4[1];\n        param_4 \u003d 0x10;\n        pbVar4 \u003d pbVar4 + 2;\n      }\n      else if (param_4 \u003d\u003d 0) {\n        param_4 \u003d 8;\n      }\n    }\n    else if (param_4 \u003d\u003d 0) {\n      param_4 \u003d 10;\n    }\n  }\n  if (bVar2 \u003d\u003d 0) {\n    uVar10 \u003d 0x7fffffff;\n  }\n  else {\n    uVar10 \u003d 0x80000000;\n  }\n  uVar9 \u003d uVar10 / param_4;\n  iVar8 \u003d 0;\n  uVar3 \u003d 0;\n  do {\n    bVar1 \u003d *(byte *)(__ctype_ptr__ + uVar5 + 1);\n    if ((bVar1 \u0026 4) \u003d\u003d 0) {\n      if ((bVar1 \u0026 3) \u003d\u003d 0) break;\n      if ((bVar1 \u0026 3) \u003d\u003d 1) {\n        iVar7 \u003d 0x37;\n      }\n      else {\n        iVar7 \u003d 0x57;\n      }\n      iVar7 \u003d uVar5 - iVar7;\n    }\n    else {\n      iVar7 \u003d uVar5 - 0x30;\n    }\n    if ((int)param_4 \u003c\u003d iVar7) break;\n    if (iVar8 !\u003d -1) {\n      if ((uVar9 \u003c\u003d uVar3 \u0026\u0026 uVar3 !\u003d uVar9) ||\n         ((uVar3 \u003d\u003d uVar9 \u0026\u0026 ((int)(uVar10 - param_4 * uVar9) \u003c iVar7)))) {\n        iVar8 \u003d -1;\n      }\n      else {\n        uVar3 \u003d param_4 * uVar3 + iVar7;\n        iVar8 \u003d 1;\n      }\n    }\n    uVar5 \u003d (uint)*pbVar4;\n    pbVar4 \u003d pbVar4 + 1;\n  } while( true );\n  if (iVar8 \u003d\u003d -1) {\n    if (bVar2 \u003d\u003d 0) {\n      uVar3 \u003d 0x7fffffff;\n    }\n    else {\n      uVar3 \u003d 0x80000000;\n    }\n    *param_1 \u003d 0x22;\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar3;\n    }\n  }\n  else {\n    if (bVar2 !\u003d 0) {\n      uVar3 \u003d -uVar3;\n    }\n    if (param_3 \u003d\u003d (byte **)0x0) {\n      return uVar3;\n    }\n    if (iVar8 \u003d\u003d 0) goto LAB_0008278c;\n  }\n  param_2 \u003d pbVar4 + -1;\nLAB_0008278c:\n  *param_3 \u003d param_2;\n  return uVar3;\n}\n\n",
      "renaming": {},
      "calling": [
        "strtol"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "strtol": {
      "entrypoint": "0x000827fc",
      "current_name": "strtol",
      "code": "\nlong strtol(char *__nptr,char **__endptr,int __base)\n\n{\n  long lVar1;\n  \n  lVar1 \u003d _strtol_r(_impure_ptr,__nptr,__endptr,__base);\n  return lVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "atol"
      ],
      "called": [
        "_strtol_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "kill": {
      "entrypoint": "0x00082814",
      "current_name": "kill",
      "code": "\nint kill(__pid_t __pid,int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _kill_r(_impure_ptr,__pid,__sig);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_kill_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sprint_r.part.0": {
      "entrypoint": "0x00082824",
      "current_name": "__sprint_r.part.0",
      "code": "\nint __sprint_r_part_0(undefined4 param_1,int param_2,int **param_3)\n\n{\n  int *piVar1;\n  int iVar2;\n  int *piVar3;\n  uint uVar4;\n  undefined4 *puVar5;\n  uint uVar6;\n  uint uVar7;\n  \n  if (-1 \u003c *(int *)(param_2 + 100) \u003c\u003c 0x12) {\n    iVar2 \u003d __sfvwrite_r();\n    param_3[2] \u003d (int *)0x0;\n    param_3[1] \u003d (int *)0x0;\n    return iVar2;\n  }\n  piVar3 \u003d param_3[2];\n  piVar1 \u003d *param_3;\n  while (piVar3 !\u003d (int *)0x0) {\n    uVar6 \u003d piVar1[1];\n    uVar7 \u003d uVar6 \u003e\u003e 2;\n    if (uVar7 !\u003d 0) {\n      puVar5 \u003d (undefined4 *)(*piVar1 + -4);\n      uVar4 \u003d 0;\n      do {\n        puVar5 \u003d puVar5 + 1;\n        iVar2 \u003d _fputwc_r(param_1,*puVar5,param_2);\n        uVar4 \u003d uVar4 + 1;\n        if (iVar2 \u003d\u003d -1) goto LAB_00082864;\n      } while (uVar7 !\u003d uVar4);\n      piVar3 \u003d param_3[2];\n    }\n    piVar3 \u003d (int *)((int)piVar3 - (uVar6 \u0026 0xfffffffc));\n    param_3[2] \u003d piVar3;\n    piVar1 \u003d piVar1 + 2;\n  }\n  iVar2 \u003d 0;\nLAB_00082864:\n  param_3[2] \u003d (int *)0x0;\n  param_3[1] \u003d (int *)0x0;\n  return iVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "__sfvwrite_r",
        "_fputwc_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_vfiprintf_r": {
      "entrypoint": "0x0008289c",
      "current_name": "_vfiprintf_r",
      "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint _vfiprintf_r(int param_1,int param_2,int *******param_3,int **param_4)\n\n{\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  char cVar4;\n  bool bVar5;\n  void *pvVar6;\n  int ********ppppppppiVar7;\n  int *piVar8;\n  int iVar9;\n  char cVar10;\n  int *******pppppppiVar11;\n  uint uVar12;\n  int **ppiVar13;\n  uint uVar14;\n  uint uVar15;\n  int iVar16;\n  int ********ppppppppiVar17;\n  int iVar18;\n  int *******pppppppiVar19;\n  int *piVar20;\n  int *******pppppppiVar21;\n  uint uVar22;\n  int *piVar23;\n  int *******pppppppiVar24;\n  undefined4 uVar25;\n  int ********__s;\n  bool bVar26;\n  longlong lVar27;\n  int *******local_dc;\n  int *******local_d4;\n  int **local_c8;\n  int local_c4;\n  char *local_c0;\n  char local_a1;\n  undefined local_a0;\n  undefined local_9f;\n  int ********local_9c;\n  int local_98;\n  int *******local_94;\n  undefined local_90;\n  char cStack_6a;\n  undefined local_69;\n  undefined local_68 [4];\n  int *******local_64 [16];\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x38) \u003d\u003d 0)) {\n    __sinit();\n  }\n  uVar14 \u003d (uint)*(ushort *)(param_2 + 0xc);\n  if (-1 \u003c (int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x12)) {\n    uVar14 \u003d uVar14 | 0x2000;\n    *(short *)(param_2 + 0xc) \u003d (short)uVar14;\n    *(uint *)(param_2 + 100) \u003d *(uint *)(param_2 + 100) \u0026 0xffffdfff;\n  }\n  if (((int)(uVar14 \u003c\u003c 0x1c) \u003c 0) \u0026\u0026 (*(int *)(param_2 + 0x10) !\u003d 0)) {\n    if ((uVar14 \u0026 0x1a) !\u003d 10) goto LAB_000828ee;\n  }\n  else {\n    iVar9 \u003d __swsetup_r(param_1,param_2);\n    if (iVar9 !\u003d 0) {\n      return -1;\n    }\n    if ((*(ushort *)(param_2 + 0xc) \u0026 0x1a) !\u003d 10) goto LAB_000828ee;\n  }\n  if (-1 \u003c *(short *)(param_2 + 0xe)) {\n    iVar9 \u003d __sbprintf(param_1,param_2,param_3,param_4);\n    return iVar9;\n  }\nLAB_000828ee:\n  local_c0 \u003d (char *)0x0;\n  local_94 \u003d (int *******)0x0;\n  local_98 \u003d 0;\n  local_c4 \u003d 0;\n  ppppppppiVar7 \u003d (int ********)local_68;\n  local_c8 \u003d param_4;\n  local_9c \u003d (int ********)local_68;\nLAB_00082902:\n  pppppppiVar11 \u003d param_3;\n  if ((*(char *)param_3 !\u003d \u0027\\0\u0027) \u0026\u0026 (*(char *)param_3 !\u003d \u0027%\u0027)) {\n    do {\n      pppppppiVar11 \u003d (int *******)((int)pppppppiVar11 + 1);\n      if (*(char *)pppppppiVar11 \u003d\u003d \u0027\\0\u0027) break;\n    } while (*(char *)pppppppiVar11 !\u003d \u0027%\u0027);\n    pppppppiVar21 \u003d (int *******)((int)pppppppiVar11 - (int)param_3);\n    if (pppppppiVar21 !\u003d (int *******)0x0) {\n      local_98 \u003d local_98 + 1;\n      local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar21);\n      *ppppppppiVar7 \u003d param_3;\n      ppppppppiVar7[1] \u003d pppppppiVar21;\n      if (local_98 \u003c 8) {\n        ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n      }\n      else {\n        if (local_94 \u003d\u003d (int *******)0x0) {\n          local_c4 \u003d local_c4 + (int)pppppppiVar21;\n          local_98 \u003d 0;\n          ppppppppiVar7 \u003d (int ********)local_68;\n          goto LAB_00082952;\n        }\n        iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n        ppppppppiVar7 \u003d (int ********)local_68;\n        if (iVar9 !\u003d 0) goto LAB_00083142;\n      }\n      local_c4 \u003d local_c4 + (int)pppppppiVar21;\n    }\n  }\nLAB_00082952:\n  if (*(char *)pppppppiVar11 !\u003d \u0027\\0\u0027) {\n    local_a1 \u003d \u0027\\0\u0027;\n    uVar15 \u003d (uint)*(byte *)((int)pppppppiVar11 + 1);\n    uVar14 \u003d 0;\n    bVar5 \u003d false;\n    bVar2 \u003d false;\n    bVar1 \u003d false;\n    bVar3 \u003d false;\n    bVar26 \u003d false;\n    pppppppiVar21 \u003d (int *******)0x0;\n    local_d4 \u003d (int *******)0xffffffff;\n    param_3 \u003d (int *******)((int)pppppppiVar11 + 1);\nLAB_00082976:\n    param_3 \u003d (int *******)((int)param_3 + 1);\nLAB_0008297a:\n    switch(uVar15) {\n    case 0x20:\n      goto switchD_00082984_caseD_20;\n    default:\n      if (uVar15 !\u003d 0) {\n        local_dc \u003d (int *******)0x1;\n        local_d4 \u003d (int *******)0x1;\n        __s \u003d (int ********)\u0026local_90;\n        local_90 \u003d (char)uVar15;\n        goto LAB_00082d76;\n      }\n      goto LAB_00083134;\n    case 0x23:\n      bVar3 \u003d true;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082976;\n    case 0x2a:\n      pppppppiVar21 \u003d (int *******)*local_c8;\n      local_c8 \u003d local_c8 + 1;\n      if ((int)pppppppiVar21 \u003c 0) {\n        pppppppiVar21 \u003d (int *******)-(int)pppppppiVar21;\n        goto switchD_00082984_caseD_2d;\n      }\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082976;\n    case 0x2b:\n      uVar15 \u003d (uint)*(byte *)param_3;\n      local_a1 \u003d \u0027+\u0027;\n      goto LAB_00082976;\n    case 0x2d:\nswitchD_00082984_caseD_2d:\n      uVar14 \u003d uVar14 | 4;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082976;\n    case 0x2e:\n      uVar15 \u003d (uint)*(byte *)param_3;\n      pppppppiVar11 \u003d (int *******)((int)param_3 + 1);\n      if (uVar15 \u003d\u003d 0x2a) {\n        uVar15 \u003d (uint)*(byte *)((int)param_3 + 1);\n        local_d4 \u003d (int *******)*local_c8;\n        local_c8 \u003d local_c8 + 1;\n        param_3 \u003d pppppppiVar11;\n        if ((int)local_d4 \u003c 0) {\n          local_d4 \u003d (int *******)0xffffffff;\n        }\n        goto LAB_00082976;\n      }\n      uVar12 \u003d uVar15 - 0x30;\n      if (uVar12 \u003c 10) {\n        uVar22 \u003d 0;\n        do {\n          param_3 \u003d (int *******)((int)pppppppiVar11 + 1);\n          uVar15 \u003d (uint)*(byte *)pppppppiVar11;\n          uVar22 \u003d uVar12 + uVar22 * 10;\n          uVar12 \u003d uVar15 - 0x30;\n          pppppppiVar11 \u003d param_3;\n        } while (uVar12 \u003c 10);\n        local_d4 \u003d (int *******)(uVar22 | (int)uVar22 \u003e\u003e 0x1f);\n      }\n      else {\n        local_d4 \u003d (int *******)0x0;\n        param_3 \u003d pppppppiVar11;\n      }\n      goto LAB_0008297a;\n    case 0x30:\n      uVar14 \u003d uVar14 | 0x80;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082976;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082984_caseD_31;\n    case 0x44:\n      bVar2 \u003d true;\n      if (bVar1 \u003d\u003d false) goto LAB_00082d8c;\nLAB_00082bfc:\n      local_c8 \u003d (int **)((int)local_c8 + 7U \u0026 0xfffffff8);\n      piVar20 \u003d *local_c8;\n      piVar23 \u003d local_c8[1];\n      local_c8 \u003d local_c8 + 2;\n      goto LAB_00082c10;\n    case 0x4f:\n      bVar2 \u003d true;\n      if (bVar1 !\u003d false) goto LAB_00082aa6;\nLAB_00082c8e:\n      iVar9 \u003d (uint)bVar2 \u003c\u003c 4;\n      iVar16 \u003d (uint)bVar1 \u003c\u003c 5;\n      if ((bVar2 \u003d\u003d 0) \u0026\u0026 (iVar16 \u003d (uint)bVar26 \u003c\u003c 6, bVar26 !\u003d 0)) {\n        piVar20 \u003d (int *)(uint)*(ushort *)local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)0x0;\n      }\n      else {\n        iVar9 \u003d iVar16;\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)0x0;\n      }\n      break;\n    case 0x55:\n      bVar2 \u003d true;\n      if (bVar1 !\u003d false) goto LAB_00082bc6;\nLAB_00082ce0:\n      if ((bVar2) || (bVar26 \u003d\u003d false)) {\n        iVar9 \u003d 1;\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)0x0;\n      }\n      else {\n        piVar23 \u003d (int *)0x0;\n        piVar20 \u003d (int *)(uint)*(ushort *)local_c8;\n        local_c8 \u003d local_c8 + 1;\n        iVar9 \u003d 1;\n      }\n      break;\n    case 0x58:\n      local_c0 \u003d \"0123456789ABCDEF\";\n      if (bVar1 \u003d\u003d false) goto LAB_00082efa;\nLAB_00082d1a:\n      ppiVar13 \u003d (int **)((int)local_c8 + 7U \u0026 0xfffffff8);\n      local_c8 \u003d ppiVar13 + 2;\n      piVar20 \u003d *ppiVar13;\n      piVar23 \u003d ppiVar13[1];\n      goto LAB_00082d2e;\n    case 99:\n      piVar20 \u003d *local_c8;\n      local_c8 \u003d local_c8 + 1;\n      local_dc \u003d (int *******)0x1;\n      local_90 \u003d SUB41(piVar20,0);\n      local_d4 \u003d (int *******)0x1;\n      __s \u003d (int ********)\u0026local_90;\n      goto LAB_00082d76;\n    case 100:\n    case 0x69:\n      if (bVar1 !\u003d false) goto LAB_00082bfc;\nLAB_00082d8c:\n      if ((bVar2 \u003d\u003d false) \u0026\u0026 (bVar26 !\u003d false)) {\n        piVar20 \u003d (int *)(int)*(short *)local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)((int)piVar20 \u003e\u003e 0x1f);\n      }\n      else {\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)((int)piVar20 \u003e\u003e 0x1f);\n      }\nLAB_00082c10:\n      if ((int)piVar23 \u003c 0) {\n        bVar26 \u003d piVar20 !\u003d (int *)0x0;\n        piVar20 \u003d (int *)-(int)piVar20;\n        piVar23 \u003d (int *)(-(int)piVar23 - (uint)bVar26);\n        local_a1 \u003d \u0027-\u0027;\n        cVar4 \u003d \u0027-\u0027;\n        iVar9 \u003d 1;\n        goto LAB_00082ace;\n      }\n      if (-1 \u003c (int)local_d4) {\n        uVar14 \u003d uVar14 \u0026 0xffffff7f;\n      }\n      bVar5 \u003d false;\n      uVar15 \u003d (uint)piVar20 | (uint)piVar23;\n      iVar9 \u003d 1;\n      cVar4 \u003d local_a1;\n      goto joined_r0x00082adc;\n    case 0x68:\n      bVar26 \u003d true;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082976;\n    case 0x6c:\n      uVar15 \u003d (uint)*(byte *)param_3;\n      if (uVar15 \u003d\u003d 0x6c) {\n        bVar1 \u003d true;\n        uVar15 \u003d (uint)*(byte *)((int)param_3 + 1);\n        param_3 \u003d (int *******)((int)param_3 + 1);\n      }\n      else {\n        bVar2 \u003d true;\n      }\n      goto LAB_00082976;\n    case 0x6e:\n      if (bVar1 \u003d\u003d false) {\n        if (bVar2 \u003d\u003d false) {\n          if (bVar26) {\n            piVar20 \u003d *local_c8;\n            local_c8 \u003d local_c8 + 1;\n            *(short *)piVar20 \u003d (short)local_c4;\n          }\n          else {\n            piVar20 \u003d *local_c8;\n            local_c8 \u003d local_c8 + 1;\n            *piVar20 \u003d local_c4;\n          }\n        }\n        else {\n          piVar20 \u003d *local_c8;\n          local_c8 \u003d local_c8 + 1;\n          *piVar20 \u003d local_c4;\n        }\n      }\n      else {\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        *piVar20 \u003d local_c4;\n        piVar20[1] \u003d local_c4 \u003e\u003e 0x1f;\n      }\n      goto LAB_00082902;\n    case 0x6f:\n      if (bVar1 \u003d\u003d false) goto LAB_00082c8e;\nLAB_00082aa6:\n      ppiVar13 \u003d (int **)((int)local_c8 + 7U \u0026 0xfffffff8);\n      local_c8 \u003d ppiVar13 + 2;\n      piVar20 \u003d *ppiVar13;\n      piVar23 \u003d ppiVar13[1];\n      iVar9 \u003d 0;\n      break;\n    case 0x70:\n      piVar20 \u003d *local_c8;\n      local_c8 \u003d local_c8 + 1;\n      local_9f \u003d 0x78;\n      bVar5 \u003d true;\n      piVar23 \u003d (int *)0x0;\n      local_a0 \u003d 0x30;\n      local_c0 \u003d \"0123456789abcdef\";\n      iVar9 \u003d 2;\n      break;\n    case 0x71:\n      bVar1 \u003d true;\n      uVar15 \u003d (uint)*(byte *)param_3;\n      goto LAB_00082976;\n    case 0x73:\n      __s \u003d (int ********)*local_c8;\n      local_a1 \u003d \u0027\\0\u0027;\n      local_c8 \u003d local_c8 + 1;\n      if (__s !\u003d (int ********)0x0) {\n        if ((int)local_d4 \u003c 0) {\n          local_d4 \u003d (int *******)strlen((char *)__s);\n          pppppppiVar11 \u003d (int *******)0x0;\n          cVar4 \u003d local_a1;\n        }\n        else {\n          pvVar6 \u003d memchr(__s,0,(size_t)local_d4);\n          cVar4 \u003d local_a1;\n          if (pvVar6 \u003d\u003d (void *)0x0) {\n            pppppppiVar11 \u003d (int *******)0x0;\n          }\n          else {\n            pppppppiVar19 \u003d (int *******)((int)pvVar6 - (int)__s);\n            if ((int)local_d4 \u003c\u003d (int)(int *******)((int)pvVar6 - (int)__s)) {\n              pppppppiVar19 \u003d local_d4;\n            }\n            pppppppiVar11 \u003d (int *******)0x0;\n            local_d4 \u003d pppppppiVar19;\n          }\n        }\n        goto LAB_00082b04;\n      }\n      if ((int *******)0x5 \u003c local_d4) {\n        local_d4 \u003d (int *******)0x6;\n      }\n      local_dc \u003d (int *******)((uint)local_d4 \u0026 ~((int)local_d4 \u003e\u003e 0x1f));\n      __s \u003d (int ********)\u0026UNK_00085728;\nLAB_00082d76:\n      local_a1 \u003d \u0027\\0\u0027;\n      pppppppiVar11 \u003d (int *******)0x0;\n      goto LAB_00082b1e;\n    case 0x75:\n      if (!bVar1) goto LAB_00082ce0;\nLAB_00082bc6:\n      ppiVar13 \u003d (int **)((int)local_c8 + 7U \u0026 0xfffffff8);\n      local_c8 \u003d ppiVar13 + 2;\n      piVar20 \u003d *ppiVar13;\n      piVar23 \u003d ppiVar13[1];\n      iVar9 \u003d 1;\n      break;\n    case 0x78:\n      local_c0 \u003d \"0123456789abcdef\";\n      if (bVar1 !\u003d false) goto LAB_00082d1a;\nLAB_00082efa:\n      if ((bVar2 \u003d\u003d false) \u0026\u0026 (bVar26 !\u003d false)) {\n        piVar23 \u003d (int *)0x0;\n        piVar20 \u003d (int *)(uint)*(ushort *)local_c8;\n        local_c8 \u003d local_c8 + 1;\n      }\n      else {\n        piVar20 \u003d *local_c8;\n        local_c8 \u003d local_c8 + 1;\n        piVar23 \u003d (int *)0x0;\n      }\nLAB_00082d2e:\n      if ((bVar3) \u0026\u0026 (((uint)piVar20 | (uint)piVar23) !\u003d 0)) {\n        bVar5 \u003d true;\n        local_a0 \u003d 0x30;\n        iVar9 \u003d 2;\n        local_9f \u003d (char)uVar15;\n      }\n      else {\n        iVar9 \u003d 2;\n      }\n    }\n    local_a1 \u003d \u0027\\0\u0027;\n    cVar4 \u003d \u0027\\0\u0027;\nLAB_00082ace:\n    if (-1 \u003c (int)local_d4) {\n      uVar14 \u003d uVar14 \u0026 0xffffff7f;\n    }\n    uVar15 \u003d (uint)piVar20 | (uint)piVar23;\njoined_r0x00082adc:\n    lVar27 \u003d CONCAT44(piVar23,piVar20);\n    pppppppiVar11 \u003d local_d4;\n    if ((uVar15 \u003d\u003d 0) \u0026\u0026 (local_d4 \u003d\u003d (int *******)0x0)) {\n      __s \u003d (int ********)local_68;\n      if ((iVar9 !\u003d 0) || (!bVar3)) goto LAB_00082b04;\n      __s \u003d (int ********)(\u0026cStack_6a + 1);\n      local_69 \u003d \u00270\u0027;\n      goto LAB_00082afe;\n    }\n    if (iVar9 \u003d\u003d 1) {\n      if (piVar23 !\u003d (int *)0x0 || (int *)0x9 \u003c piVar20) {\n        ppppppppiVar17 \u003d (int ********)(\u0026cStack_6a + 1);\n        do {\n          __s \u003d ppppppppiVar17;\n          uVar25 \u003d (undefined4)((ulonglong)lVar27 \u003e\u003e 0x20);\n          cVar10 \u003d \u0027\\n\u0027;\n          __aeabi_uldivmod((int)lVar27,uVar25,10,0);\n          *(char *)__s \u003d cVar10 + \u00270\u0027;\n          lVar27 \u003d __aeabi_uldivmod((int)lVar27,uVar25,10,0);\n          ppppppppiVar17 \u003d (int ********)((int)__s + -1);\n        } while (lVar27 !\u003d 0);\n        local_d4 \u003d (int *******)((int)local_68 - (int)__s);\n        goto LAB_00082b04;\n      }\n      local_69 \u003d (char)piVar20 + \u00270\u0027;\n      __s \u003d (int ********)(\u0026cStack_6a + 1);\n      goto LAB_00083282;\n    }\n    ppppppppiVar17 \u003d (int ********)(\u0026cStack_6a + 1);\n    if (iVar9 !\u003d 2) goto LAB_000830e2;\n    do {\n      __s \u003d ppppppppiVar17;\n      uVar15 \u003d (uint)piVar20 \u0026 0xf;\n      piVar20 \u003d (int *)((uint)piVar20 \u003e\u003e 4 | (int)piVar23 \u003c\u003c 0x1c);\n      piVar23 \u003d (int *)((uint)piVar23 \u003e\u003e 4);\n      *(char *)__s \u003d local_c0[uVar15];\n      ppppppppiVar17 \u003d (int ********)((int)__s + -1);\n    } while (((uint)piVar20 | (uint)piVar23) !\u003d 0);\n    local_d4 \u003d (int *******)((int)local_68 - (int)__s);\n    goto LAB_00082b04;\n  }\nLAB_00083134:\n  if (local_94 !\u003d (int *******)0x0) {\n    __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n  }\nLAB_00083142:\n  if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x19) \u003c 0) {\n    return -1;\n  }\n  return local_c4;\nLAB_000830e2:\n  do {\n    __s \u003d ppppppppiVar17;\n    piVar8 \u003d (int *)((uint)piVar20 \u003e\u003e 3 | (int)piVar23 \u003c\u003c 0x1d);\n    piVar23 \u003d (int *)((uint)piVar23 \u003e\u003e 3);\n    iVar9 \u003d ((uint)piVar20 \u0026 7) + 0x30;\n    *(char *)__s \u003d (char)iVar9;\n    ppppppppiVar17 \u003d (int ********)((int)__s + -1);\n    piVar20 \u003d piVar8;\n  } while (((uint)piVar8 | (uint)piVar23) !\u003d 0);\n  if (bVar3) {\n    if (iVar9 \u003d\u003d 0x30) {\nLAB_00082afe:\n      local_d4 \u003d (int *******)((int)local_68 - (int)__s);\n    }\n    else {\n      *(undefined *)((int)__s + -1) \u003d 0x30;\n      __s \u003d ppppppppiVar17;\n      local_d4 \u003d (int *******)((int)local_68 - (int)ppppppppiVar17);\n    }\n  }\n  else {\nLAB_00083282:\n    local_d4 \u003d (int *******)((int)local_68 - (int)__s);\n  }\nLAB_00082b04:\n  local_dc \u003d local_d4;\n  if ((int)local_d4 \u003c (int)pppppppiVar11) {\n    local_dc \u003d pppppppiVar11;\n  }\n  if (cVar4 !\u003d \u0027\\0\u0027) {\n    local_dc \u003d (int *******)((int)local_dc + 1);\n  }\nLAB_00082b1e:\n  if (bVar5) {\n    local_dc \u003d (int *******)((int)local_dc + 2);\n  }\n  if ((uVar14 \u003d\u003d 0) \u0026\u0026\n     (pppppppiVar19 \u003d (int *******)((int)pppppppiVar21 - (int)local_dc), 0 \u003c (int)pppppppiVar19)) {\n    if ((int)pppppppiVar19 \u003c 0x11) {\n      local_98 \u003d local_98 + 1;\n    }\n    else {\n      do {\n        pppppppiVar24 \u003d pppppppiVar19;\n        iVar9 \u003d local_98 + 1;\n        local_94 \u003d local_94 + 4;\n        *ppppppppiVar7 \u003d (int *******)0x856f0;\n        ppppppppiVar7[1] \u003d (int *******)0x10;\n        if (iVar9 \u003c 8) {\n          iVar16 \u003d local_98 + 2;\n          ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n          local_98 \u003d iVar9;\n        }\n        else if (local_94 \u003d\u003d (int *******)0x0) {\n          iVar16 \u003d 1;\n          ppppppppiVar7 \u003d (int ********)local_68;\n          local_98 \u003d 0;\n        }\n        else {\n          local_98 \u003d iVar9;\n          iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n          if (iVar9 !\u003d 0) goto LAB_00083142;\n          iVar16 \u003d local_98 + 1;\n          ppppppppiVar7 \u003d (int ********)local_68;\n        }\n        pppppppiVar19 \u003d pppppppiVar24 + -4;\n      } while (0x10 \u003c (int)pppppppiVar19);\n      pppppppiVar19 \u003d pppppppiVar24 + -4;\n      local_98 \u003d iVar16;\n    }\n    local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar19);\n    *ppppppppiVar7 \u003d (int *******)0x856f0;\n    ppppppppiVar7[1] \u003d pppppppiVar19;\n    if (local_98 \u003c 8) {\n      iVar9 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n    }\n    else if (local_94 \u003d\u003d (int *******)0x0) {\n      iVar9 \u003d 1;\n      local_98 \u003d 0;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n    else {\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_00083142;\n      iVar9 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n  }\n  else {\n    iVar9 \u003d local_98 + 1;\n  }\n  iVar16 \u003d iVar9;\n  if (local_a1 !\u003d \u0027\\0\u0027) {\n    local_94 \u003d (int *******)((int)local_94 + 1);\n    iVar16 \u003d 1;\n    *ppppppppiVar7 \u003d (int *******)\u0026local_a1;\n    ppppppppiVar7[1] \u003d (int *******)0x1;\n    local_98 \u003d iVar9;\n    if (iVar9 \u003c 8) {\n      iVar16 \u003d iVar9 + 1;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n    }\n    else if (local_94 \u003d\u003d (int *******)0x0) {\n      local_98 \u003d 0;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n    else {\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_00083142;\n      iVar16 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n  }\n  iVar9 \u003d iVar16;\n  iVar18 \u003d local_98;\n  if (bVar5) {\n    local_94 \u003d (int *******)((int)local_94 + 2);\n    *ppppppppiVar7 \u003d (int *******)\u0026local_a0;\n    ppppppppiVar7[1] \u003d (int *******)0x2;\n    if (iVar16 \u003c 8) {\n      iVar9 \u003d iVar16 + 1;\n      iVar18 \u003d iVar16;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n    }\n    else if (local_94 \u003d\u003d (int *******)0x0) {\n      iVar9 \u003d 1;\n      iVar18 \u003d 0;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n    else {\n      local_98 \u003d iVar16;\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_00083142;\n      iVar9 \u003d local_98 + 1;\n      iVar18 \u003d local_98;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n  }\n  local_98 \u003d iVar18;\n  if ((uVar14 \u003d\u003d 0x80) \u0026\u0026\n     (pppppppiVar19 \u003d (int *******)((int)pppppppiVar21 - (int)local_dc), 0 \u003c (int)pppppppiVar19)) {\n    if (0x10 \u003c (int)pppppppiVar19) {\n      do {\n        while( true ) {\n          pppppppiVar24 \u003d pppppppiVar19;\n          local_98 \u003d iVar18 + 1;\n          local_94 \u003d local_94 + 4;\n          *ppppppppiVar7 \u003d (int *******)\"0000000000000000\";\n          ppppppppiVar7[1] \u003d (int *******)0x10;\n          if (7 \u003c local_98) break;\n          iVar9 \u003d iVar18 + 2;\n          ppppppppiVar7 \u003d ppppppppiVar7 + 2;\nLAB_000831f2:\n          iVar18 \u003d local_98;\n          pppppppiVar19 \u003d pppppppiVar24 + -4;\n          if ((int)(pppppppiVar24 + -4) \u003c 0x11) goto LAB_00083218;\n        }\n        if (local_94 !\u003d (int *******)0x0) {\n          iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n          if (iVar9 \u003d\u003d 0) {\n            iVar9 \u003d local_98 + 1;\n            ppppppppiVar7 \u003d (int ********)local_68;\n            goto LAB_000831f2;\n          }\n          goto LAB_00083142;\n        }\n        iVar9 \u003d 1;\n        iVar18 \u003d 0;\n        pppppppiVar19 \u003d pppppppiVar24 + -4;\n        ppppppppiVar7 \u003d (int ********)local_68;\n      } while (0x10 \u003c (int)(pppppppiVar24 + -4));\nLAB_00083218:\n      pppppppiVar19 \u003d pppppppiVar24 + -4;\n    }\n    local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar19);\n    *ppppppppiVar7 \u003d (int *******)\"0000000000000000\";\n    ppppppppiVar7[1] \u003d pppppppiVar19;\n    local_98 \u003d iVar9;\n    if (iVar9 \u003c 8) {\n      iVar9 \u003d iVar9 + 1;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n    }\n    else if (local_94 \u003d\u003d (int *******)0x0) {\n      iVar9 \u003d 1;\n      local_98 \u003d 0;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n    else {\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_00083142;\n      iVar9 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d (int ********)local_68;\n    }\n  }\n  pppppppiVar11 \u003d (int *******)((int)pppppppiVar11 - (int)local_d4);\n  ppppppppiVar17 \u003d (int ********)local_68;\n  if ((int)pppppppiVar11 \u003c 1) {\nLAB_0008302a:\n    local_94 \u003d (int *******)((int)local_94 + (int)local_d4);\n    *ppppppppiVar7 \u003d (int *******)__s;\n    ppppppppiVar7[1] \u003d local_d4;\n    local_d4 \u003d local_94;\n    local_98 \u003d iVar9;\n    if (iVar9 \u003c 8) goto LAB_000831be;\n    if (local_94 \u003d\u003d (int *******)0x0) {\n      local_98 \u003d 0;\n    }\n    else {\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_00083142;\n    }\n  }\n  else {\n    iVar16 \u003d local_98;\n    if (0x10 \u003c (int)pppppppiVar11) {\n      do {\n        while( true ) {\n          pppppppiVar19 \u003d pppppppiVar11;\n          local_98 \u003d iVar16 + 1;\n          local_94 \u003d local_94 + 4;\n          *ppppppppiVar7 \u003d (int *******)\"0000000000000000\";\n          ppppppppiVar7[1] \u003d (int *******)0x10;\n          if (7 \u003c local_98) break;\n          iVar9 \u003d iVar16 + 2;\n          ppppppppiVar7 \u003d ppppppppiVar7 + 2;\nLAB_00082fe6:\n          iVar16 \u003d local_98;\n          pppppppiVar11 \u003d pppppppiVar19 + -4;\n          if ((int)(pppppppiVar19 + -4) \u003c 0x11) goto LAB_0008300e;\n        }\n        if (local_94 !\u003d (int *******)0x0) {\n          iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n          if (iVar9 \u003d\u003d 0) {\n            iVar9 \u003d local_98 + 1;\n            ppppppppiVar7 \u003d (int ********)local_68;\n            goto LAB_00082fe6;\n          }\n          goto LAB_00083142;\n        }\n        iVar9 \u003d 1;\n        ppppppppiVar7 \u003d (int ********)local_68;\n        iVar16 \u003d 0;\n        pppppppiVar11 \u003d pppppppiVar19 + -4;\n      } while (0x10 \u003c (int)(pppppppiVar19 + -4));\nLAB_0008300e:\n      pppppppiVar11 \u003d pppppppiVar19 + -4;\n    }\n    local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar11);\n    *ppppppppiVar7 \u003d (int *******)\"0000000000000000\";\n    ppppppppiVar7[1] \u003d pppppppiVar11;\n    if (iVar9 \u003c 8) {\n      iVar9 \u003d iVar9 + 1;\n      ppppppppiVar7 \u003d ppppppppiVar7 + 2;\n      goto LAB_0008302a;\n    }\n    if (local_94 !\u003d (int *******)0x0) {\n      local_98 \u003d iVar9;\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_00083142;\n      iVar9 \u003d local_98 + 1;\n      ppppppppiVar7 \u003d (int ********)local_68;\n      goto LAB_0008302a;\n    }\n    local_64[0] \u003d local_d4;\n    local_98 \u003d 1;\n    ppppppppiVar7 \u003d (int ********)local_68;\n    local_68 \u003d (undefined  [4])__s;\nLAB_000831be:\n    ppppppppiVar17 \u003d ppppppppiVar7 + 2;\n    local_94 \u003d local_d4;\n  }\n  if (((uVar14 \u0026 4) !\u003d 0) \u0026\u0026\n     (pppppppiVar11 \u003d (int *******)((int)pppppppiVar21 - (int)local_dc), 0 \u003c (int)pppppppiVar11)) {\n    iVar9 \u003d local_98;\n    if ((int)pppppppiVar11 \u003c 0x11) {\n      iVar16 \u003d local_98 + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          local_98 \u003d iVar9 + 1;\n          local_94 \u003d local_94 + 4;\n          *ppppppppiVar17 \u003d (int *******)0x856f0;\n          ppppppppiVar17[1] \u003d (int *******)0x10;\n          if (7 \u003c local_98) break;\n          iVar16 \u003d iVar9 + 2;\n          ppppppppiVar17 \u003d ppppppppiVar17 + 2;\nLAB_0008307a:\n          pppppppiVar11 \u003d pppppppiVar11 + -4;\n          iVar9 \u003d local_98;\n          if ((int)pppppppiVar11 \u003c 0x11) goto LAB_000830a2;\n        }\n        if (local_94 !\u003d (int *******)0x0) {\n          iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n          if (iVar9 \u003d\u003d 0) {\n            iVar16 \u003d local_98 + 1;\n            ppppppppiVar17 \u003d (int ********)local_68;\n            goto LAB_0008307a;\n          }\n          goto LAB_00083142;\n        }\n        pppppppiVar11 \u003d pppppppiVar11 + -4;\n        iVar16 \u003d 1;\n        iVar9 \u003d 0;\n        ppppppppiVar17 \u003d (int ********)local_68;\n      } while (0x10 \u003c (int)pppppppiVar11);\n    }\nLAB_000830a2:\n    local_94 \u003d (int *******)((int)local_94 + (int)pppppppiVar11);\n    *ppppppppiVar17 \u003d (int *******)0x856f0;\n    ppppppppiVar17[1] \u003d pppppppiVar11;\n    local_98 \u003d iVar16;\n    if (7 \u003c iVar16) {\n      if (local_94 \u003d\u003d (int *******)0x0) {\n        if ((int)local_dc \u003c (int)pppppppiVar21) {\n          local_dc \u003d pppppppiVar21;\n        }\n        local_c4 \u003d local_c4 + (int)local_dc;\n        goto LAB_00083186;\n      }\n      iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c);\n      if (iVar9 !\u003d 0) goto LAB_00083142;\n    }\n  }\n  if ((int)local_dc \u003c (int)pppppppiVar21) {\n    local_dc \u003d pppppppiVar21;\n  }\n  local_c4 \u003d local_c4 + (int)local_dc;\n  if ((local_94 !\u003d (int *******)0x0) \u0026\u0026\n     (iVar9 \u003d __sprint_r_part_0(param_1,param_2,\u0026local_9c), iVar9 !\u003d 0)) goto LAB_00083142;\nLAB_00083186:\n  local_98 \u003d 0;\n  ppppppppiVar7 \u003d (int ********)local_68;\n  goto LAB_00082902;\nswitchD_00082984_caseD_31:\n  uVar12 \u003d uVar15 - 0x30;\n  pppppppiVar21 \u003d (int *******)0x0;\n  pppppppiVar11 \u003d param_3;\n  do {\n    param_3 \u003d (int *******)((int)pppppppiVar11 + 1);\n    uVar15 \u003d (uint)*(byte *)pppppppiVar11;\n    pppppppiVar21 \u003d (int *******)(uVar12 + (int)pppppppiVar21 * 10);\n    uVar12 \u003d uVar15 - 0x30;\n    pppppppiVar11 \u003d param_3;\n  } while (uVar12 \u003c 10);\n  goto LAB_0008297a;\nswitchD_00082984_caseD_20:\n  uVar15 \u003d (uint)*(byte *)param_3;\n  if (local_a1 \u003d\u003d \u0027\\0\u0027) {\n    local_a1 \u003d \u0027 \u0027;\n  }\n  goto LAB_00082976;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sbprintf",
        "iprintf",
        "fiprintf"
      ],
      "called": [
        "__sbprintf",
        "__sprint_r.part.0",
        "__aeabi_uldivmod",
        "memchr",
        "__swsetup_r",
        "__sinit",
        "strlen"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sbprintf": {
      "entrypoint": "0x000834f0",
      "current_name": "__sbprintf",
      "code": "\nint __sbprintf(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  undefined *local_488 [2];\n  undefined4 local_480;\n  ushort local_47c;\n  undefined2 local_47a;\n  undefined *local_478;\n  undefined4 local_474;\n  undefined4 local_470;\n  undefined4 local_46c;\n  undefined4 local_464;\n  undefined4 local_424;\n  undefined auStack_420 [1024];\n  \n  local_424 \u003d *(undefined4 *)(param_2 + 100);\n  local_46c \u003d *(undefined4 *)(param_2 + 0x1c);\n  local_47a \u003d *(undefined2 *)(param_2 + 0xe);\n  local_464 \u003d *(undefined4 *)(param_2 + 0x24);\n  local_488[0] \u003d auStack_420;\n  local_47c \u003d *(ushort *)(param_2 + 0xc) \u0026 0xfffd;\n  local_480 \u003d 0x400;\n  local_474 \u003d 0x400;\n  local_470 \u003d 0;\n  local_478 \u003d local_488[0];\n  iVar1 \u003d _vfiprintf_r(param_1,local_488);\n  if ((-1 \u003c iVar1) \u0026\u0026 (iVar2 \u003d _fflush_r(param_1,local_488), iVar2 !\u003d 0)) {\n    iVar1 \u003d -1;\n  }\n  if ((int)((uint)local_47c \u003c\u003c 0x19) \u003c 0) {\n    *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) | 0x40;\n  }\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "_fflush_r",
        "_vfiprintf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swsetup_r": {
      "entrypoint": "0x0008356c",
      "current_name": "__swsetup_r",
      "code": "\nundefined4 __swsetup_r(undefined4 *param_1,int *param_2)\n\n{\n  int iVar1;\n  int iVar2;\n  uint uVar3;\n  ushort uVar4;\n  \n  if ((_impure_ptr !\u003d 0) \u0026\u0026 (*(int *)(_impure_ptr + 0x38) \u003d\u003d 0)) {\n    __sinit();\n  }\n  uVar4 \u003d *(ushort *)(param_2 + 3);\n  uVar3 \u003d (uint)uVar4;\n  if ((int)(uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar2 \u003d param_2[4];\n  }\n  else {\n    if (-1 \u003c (int)(uVar3 \u003c\u003c 0x1b)) {\n      *param_1 \u003d 9;\n      *(ushort *)(param_2 + 3) \u003d uVar4 | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(uVar3 \u003c\u003c 0x1d) \u003c 0) {\n      if ((int *)param_2[0xc] !\u003d (int *)0x0) {\n        if ((int *)param_2[0xc] !\u003d param_2 + 0x10) {\n          _free_r(param_1);\n          uVar4 \u003d *(ushort *)(param_2 + 3);\n        }\n        param_2[0xc] \u003d 0;\n      }\n      iVar2 \u003d param_2[4];\n      uVar4 \u003d uVar4 \u0026 0xffdb;\n      *param_2 \u003d iVar2;\n      param_2[1] \u003d 0;\n    }\n    else {\n      iVar2 \u003d param_2[4];\n    }\n    *(ushort *)(param_2 + 3) \u003d uVar4 | 8;\n    uVar3 \u003d (uint)(uVar4 | 8);\n  }\n  if ((iVar2 \u003d\u003d 0) \u0026\u0026 ((uVar3 \u0026 0x280) !\u003d 0x200)) {\n    __smakebuf_r(param_1,param_2);\n    uVar3 \u003d (uint)*(ushort *)(param_2 + 3);\n    iVar2 \u003d param_2[4];\n  }\n  if ((uVar3 \u0026 1) \u003d\u003d 0) {\n    iVar1 \u003d 0;\n    if (-1 \u003c (int)(uVar3 \u003c\u003c 0x1e)) {\n      iVar1 \u003d param_2[5];\n    }\n    param_2[2] \u003d iVar1;\n  }\n  else {\n    param_2[6] \u003d -param_2[5];\n    param_2[2] \u003d 0;\n  }\n  if ((iVar2 \u003d\u003d 0) \u0026\u0026 ((int)((uint)*(ushort *)(param_2 + 3) \u003c\u003c 0x18) \u003c 0)) {\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "_vfiprintf_r",
        "__swbuf_r"
      ],
      "called": [
        "__smakebuf_r",
        "__sinit",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__register_exitproc": {
      "entrypoint": "0x00083630",
      "current_name": "__register_exitproc",
      "code": "\nundefined4 __register_exitproc(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  undefined4 *puVar1;\n  uint uVar2;\n  uint uVar3;\n  \n  if (DAT_20070180 \u003d\u003d (undefined4 *)0x0) {\n    DAT_20070180 \u003d (undefined4 *)\u0026DAT_20070184;\n  }\n  uVar2 \u003d DAT_20070180[1];\n  puVar1 \u003d DAT_20070180;\n  if (0x1f \u003c (int)uVar2) {\n    puVar1 \u003d (undefined4 *)malloc(400);\n    if (puVar1 \u003d\u003d (undefined4 *)0x0) {\n      return 0xffffffff;\n    }\n    *puVar1 \u003d DAT_20070180;\n    puVar1[1] \u003d 0;\n    uVar2 \u003d 0;\n    DAT_20070180 \u003d puVar1;\n    puVar1[0x62] \u003d 0;\n    puVar1[99] \u003d 0;\n  }\n  if (param_1 !\u003d 0) {\n    uVar3 \u003d 1 \u003c\u003c (uVar2 \u0026 0xff);\n    puVar1[uVar2 + 0x22] \u003d param_3;\n    puVar1[0x62] \u003d puVar1[0x62] | uVar3;\n    puVar1[uVar2 + 0x42] \u003d param_4;\n    if (param_1 \u003d\u003d 2) {\n      puVar1[99] \u003d uVar3 | puVar1[99];\n    }\n  }\n  puVar1[1] \u003d uVar2 + 1;\n  puVar1[uVar2 + 2] \u003d param_2;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__cxa_atexit",
        "atexit"
      ],
      "called": [
        "malloc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "register_fini": {
      "entrypoint": "0x000836d8",
      "current_name": "register_fini",
      "code": "\n/* WARNING: Removing unreachable block (ram,0x000836dc) */\n\nvoid register_fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [
        "atexit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "abort": {
      "entrypoint": "0x000836ec",
      "current_name": "abort",
      "code": "\n\n\nvoid abort(void)\n\n{\n  raise(6);\n                    \n  _exit(1);\n}\n\n",
      "renaming": {},
      "calling": [
        "__assert_func"
      ],
      "called": [
        "_exit",
        "raise"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "atexit": {
      "entrypoint": "0x000836fc",
      "current_name": "atexit",
      "code": "\nint atexit(__func *__func)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d __register_exitproc(0,__func,0,0);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "register_fini"
      ],
      "called": [
        "__register_exitproc"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sflush_r": {
      "entrypoint": "0x00083708",
      "current_name": "__sflush_r",
      "code": "\nundefined4 __sflush_r(int *param_1,int *param_2)\n\n{\n  int *piVar1;\n  int iVar2;\n  ushort uVar3;\n  uint uVar4;\n  int iVar5;\n  code *pcVar6;\n  int iVar7;\n  \n  uVar3 \u003d *(ushort *)(param_2 + 3);\n  if ((int)((uint)uVar3 \u003c\u003c 0x1c) \u003c 0) {\n    iVar7 \u003d param_2[4];\n    if (iVar7 \u003d\u003d 0) {\n      return 0;\n    }\n    iVar2 \u003d *param_2;\n    if ((uVar3 \u0026 3) \u003d\u003d 0) {\n      iVar5 \u003d param_2[5];\n    }\n    else {\n      iVar5 \u003d 0;\n    }\n    *param_2 \u003d iVar7;\n    iVar2 \u003d iVar2 - iVar7;\n    param_2[2] \u003d iVar5;\n    do {\n      if (iVar2 \u003c 1) {\n        return 0;\n      }\n      iVar5 \u003d (*(code *)param_2[9])(param_1,param_2[7],iVar7,iVar2);\n      iVar2 \u003d iVar2 - iVar5;\n      iVar7 \u003d iVar7 + iVar5;\n    } while (0 \u003c iVar5);\nLAB_000837c8:\n    *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(param_2 + 3) \u003d uVar3 | 0x800;\n  if ((param_2[1] \u003c 1) \u0026\u0026 (param_2[0xf] \u003c 1)) {\n    return 0;\n  }\n  pcVar6 \u003d (code *)param_2[10];\n  if (pcVar6 \u003d\u003d (code *)0x0) {\n    return 0;\n  }\n  uVar4 \u003d (uint)(uVar3 | 0x800);\n  iVar7 \u003d *param_1;\n  *param_1 \u003d 0;\n  if ((uVar3 \u0026 0x1000) \u003d\u003d 0) {\n    iVar2 \u003d (*pcVar6)(param_1,param_2[7],uVar4 \u0026 0x1000,1);\n    if ((iVar2 \u003d\u003d -1) \u0026\u0026 (iVar5 \u003d *param_1, iVar5 !\u003d 0)) {\n      if ((iVar5 \u003d\u003d 0x1d) || (iVar5 \u003d\u003d 0x16)) {\n        *param_1 \u003d iVar7;\n        return 0;\n      }\n      goto LAB_000837c8;\n    }\n    uVar4 \u003d (uint)*(ushort *)(param_2 + 3);\n    pcVar6 \u003d (code *)param_2[10];\n  }\n  else {\n    iVar2 \u003d param_2[0x14];\n  }\n  if (((int)(uVar4 \u003c\u003c 0x1d) \u003c 0) \u0026\u0026 (iVar2 \u003d iVar2 - param_2[1], param_2[0xc] !\u003d 0)) {\n    iVar2 \u003d iVar2 - param_2[0xf];\n  }\n  iVar2 \u003d (*pcVar6)(param_1,param_2[7],iVar2,0);\n  if (iVar2 \u003d\u003d -1) {\n    iVar5 \u003d *param_1;\n    if (iVar5 !\u003d 0) {\n      if ((iVar5 !\u003d 0x1d) \u0026\u0026 (iVar5 !\u003d 0x16)) {\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xf7ff;\n      *param_2 \u003d param_2[4];\n      param_2[1] \u003d 0;\n      goto LAB_00083774;\n    }\n    uVar3 \u003d *(ushort *)(param_2 + 3) \u0026 0xf7ff;\n    param_2[1] \u003d 0;\n    *(ushort *)(param_2 + 3) \u003d uVar3;\n    *param_2 \u003d param_2[4];\n  }\n  else {\n    uVar3 \u003d *(ushort *)(param_2 + 3) \u0026 0xf7ff;\n    *param_2 \u003d param_2[4];\n    *(ushort *)(param_2 + 3) \u003d uVar3;\n    param_2[1] \u003d 0;\n  }\n  if ((int)((uint)uVar3 \u003c\u003c 0x13) \u003c 0) {\n    param_2[0x14] \u003d iVar2;\n  }\nLAB_00083774:\n  piVar1 \u003d (int *)param_2[0xc];\n  *param_1 \u003d iVar7;\n  if (piVar1 \u003d\u003d (int *)0x0) {\n    return 0;\n  }\n  if (piVar1 !\u003d param_2 + 0x10) {\n    _free_r(param_1);\n  }\n  param_2[0xc] \u003d 0;\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r"
      ],
      "called": [
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fflush_r": {
      "entrypoint": "0x00083850",
      "current_name": "_fflush_r",
      "code": "\nvoid _fflush_r(int param_1,int param_2)\n\n{\n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x38) \u003d\u003d 0)) {\n    __sinit();\n  }\n  if (*(short *)(param_2 + 0xc) \u003d\u003d 0) {\n    return;\n  }\n  __sflush_r(param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "__sbprintf",
        "_fclose_r",
        "__swbuf_r"
      ],
      "called": [
        "__sinit",
        "__sflush_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_cleanup_r": {
      "entrypoint": "0x0008387c",
      "current_name": "_cleanup_r",
      "code": "\nvoid _cleanup_r(undefined4 param_1)\n\n{\n  _fwalk(param_1,0x84485);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fwalk"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sinit": {
      "entrypoint": "0x00083888",
      "current_name": "__sinit",
      "code": "\nvoid __sinit(int param_1)\n\n{\n  undefined4 *puVar1;\n  undefined4 *puVar2;\n  \n  if (*(int *)(param_1 + 0x38) \u003d\u003d 0) {\n    puVar1 \u003d *(undefined4 **)(param_1 + 4);\n    *(undefined4 *)(param_1 + 0x3c) \u003d 0x8387d;\n    *(undefined4 *)(param_1 + 0x2e4) \u003d 3;\n    *(int *)(param_1 + 0x2e8) \u003d param_1 + 0x2ec;\n    *(undefined4 *)(param_1 + 0x2e0) \u003d 0;\n    *(undefined2 *)(puVar1 + 3) \u003d 4;\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d 0;\n    puVar1[2] \u003d 0;\n    puVar1[0x19] \u003d 0;\n    *(undefined2 *)((int)puVar1 + 0xe) \u003d 0;\n    puVar1[4] \u003d 0;\n    puVar1[5] \u003d 0;\n    puVar1[6] \u003d 0;\n    memset(puVar1 + 0x17,0,8);\n    puVar2 \u003d *(undefined4 **)(param_1 + 8);\n    puVar1[7] \u003d puVar1;\n    puVar1[8] \u003d 0x84221;\n    puVar1[9] \u003d 0x84245;\n    puVar1[10] \u003d 0x8427d;\n    puVar1[0xb] \u003d 0x8429d;\n    *(undefined2 *)((int)puVar2 + 0xe) \u003d 1;\n    *(undefined2 *)(puVar2 + 3) \u003d 9;\n    *puVar2 \u003d 0;\n    puVar2[1] \u003d 0;\n    puVar2[2] \u003d 0;\n    puVar2[0x19] \u003d 0;\n    puVar2[4] \u003d 0;\n    puVar2[5] \u003d 0;\n    puVar2[6] \u003d 0;\n    memset(puVar2 + 0x17,0,8);\n    puVar1 \u003d *(undefined4 **)(param_1 + 0xc);\n    puVar2[7] \u003d puVar2;\n    puVar2[8] \u003d 0x84221;\n    puVar2[9] \u003d 0x84245;\n    puVar2[10] \u003d 0x8427d;\n    puVar2[0xb] \u003d 0x8429d;\n    *(undefined2 *)(puVar1 + 3) \u003d 0x12;\n    *(undefined2 *)((int)puVar1 + 0xe) \u003d 2;\n    *puVar1 \u003d 0;\n    puVar1[1] \u003d 0;\n    puVar1[2] \u003d 0;\n    puVar1[0x19] \u003d 0;\n    puVar1[4] \u003d 0;\n    puVar1[5] \u003d 0;\n    puVar1[6] \u003d 0;\n    memset(puVar1 + 0x17,0,8);\n    puVar1[7] \u003d puVar1;\n    puVar1[8] \u003d 0x84221;\n    puVar1[9] \u003d 0x84245;\n    puVar1[10] \u003d 0x8427d;\n    puVar1[0xb] \u003d 0x8429d;\n    *(undefined4 *)(param_1 + 0x38) \u003d 1;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fflush_r",
        "_fclose_r",
        "__swsetup_r",
        "_vfiprintf_r",
        "__swbuf_r"
      ],
      "called": [
        "memset"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp_lock_acquire": {
      "entrypoint": "0x0008397c",
      "current_name": "__sfp_lock_acquire",
      "code": "\nvoid __sfp_lock_acquire(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fclose_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfp_lock_release": {
      "entrypoint": "0x00083980",
      "current_name": "__sfp_lock_release",
      "code": "\nvoid __sfp_lock_release(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fclose_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__libc_fini_array": {
      "entrypoint": "0x00083984",
      "current_name": "__libc_fini_array",
      "code": "\nvoid __libc_fini_array(void)\n\n{\n  int iVar1;\n  code **ppcVar2;\n  \n  iVar1 \u003d 1;\n  ppcVar2 \u003d (code **)\u0026__fini_array_end;\n  do {\n    iVar1 \u003d iVar1 + -1;\n    ppcVar2 \u003d ppcVar2 + -1;\n    (**ppcVar2)();\n  } while (iVar1 !\u003d 0);\n  _fini();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fini",
        "__do_global_dtors_aux"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fputwc_r": {
      "entrypoint": "0x000839b4",
      "current_name": "_fputwc_r",
      "code": "\nuint _fputwc_r(undefined4 param_1,uint param_2,byte **param_3)\n\n{\n  int iVar1;\n  uint uVar2;\n  uint uVar3;\n  byte *pbVar4;\n  uint uVar5;\n  byte local_1c;\n  byte abStack_1b [3];\n  \n  if (-1 \u003c (int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x12)) {\n    *(ushort *)(param_3 + 3) \u003d *(ushort *)(param_3 + 3) | 0x2000;\n    param_3[0x19] \u003d (byte *)((uint)param_3[0x19] | 0x2000);\n  }\n  iVar1 \u003d __locale_mb_cur_max();\n  if ((iVar1 \u003d\u003d 1) \u0026\u0026 (param_2 - 1 \u003c 0xff)) {\n    uVar3 \u003d param_2 \u0026 0xff;\n    local_1c \u003d (byte)uVar3;\n    uVar2 \u003d 1;\n  }\n  else {\n    uVar2 \u003d _wcrtomb_r(param_1,\u0026local_1c,param_2,param_3 + 0x17);\n    if (uVar2 \u003d\u003d 0xffffffff) {\n      *(ushort *)(param_3 + 3) \u003d *(ushort *)(param_3 + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (uVar2 \u003d\u003d 0) {\n      return param_2;\n    }\n    uVar3 \u003d (uint)local_1c;\n  }\n  uVar5 \u003d 0;\n  do {\n    pbVar4 \u003d param_3[2] + -1;\n    param_3[2] \u003d pbVar4;\n    if ((int)pbVar4 \u003c 0) {\n      if ((int)param_3[6] \u003c\u003d (int)pbVar4) {\n        **param_3 \u003d (byte)uVar3;\n        pbVar4 \u003d *param_3;\n        uVar3 \u003d (uint)*pbVar4;\n        if (uVar3 !\u003d 10) goto LAB_00083a04;\n      }\n      iVar1 \u003d __swbuf_r(param_1,uVar3,param_3);\n      if (iVar1 \u003d\u003d -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **param_3 \u003d (byte)uVar3;\n      pbVar4 \u003d *param_3;\nLAB_00083a04:\n      *param_3 \u003d pbVar4 + 1;\n    }\n    if (uVar2 \u003c\u003d uVar5 + 1) {\n      return param_2;\n    }\n    uVar3 \u003d (uint)abStack_1b[uVar5];\n    uVar5 \u003d uVar5 + 1;\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "__sprint_r.part.0"
      ],
      "called": [
        "_wcrtomb_r",
        "__locale_mb_cur_max",
        "__swbuf_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_malloc_trim_r": {
      "entrypoint": "0x00083a74",
      "current_name": "_malloc_trim_r",
      "code": "\nundefined4 _malloc_trim_r(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  uint uVar2;\n  int iVar3;\n  \n  __malloc_lock();\n  uVar2 \u003d *(uint *)(DAT_2007046c + 4) \u0026 0xfffffffc;\n  iVar3 \u003d ((uVar2 - param_2) + 0xfef \u0026 0xfffff000) - 0x1000;\n  if (0xfff \u003c iVar3) {\n    iVar1 \u003d _sbrk_r(param_1,0);\n    if (iVar1 \u003d\u003d DAT_2007046c + uVar2) {\n      iVar1 \u003d _sbrk_r(param_1,-iVar3);\n      if (iVar1 !\u003d -1) {\n        __malloc_current_mallinfo \u003d __malloc_current_mallinfo - iVar3;\n        *(uint *)(DAT_2007046c + 4) \u003d uVar2 - iVar3 | 1;\n        __malloc_unlock(param_1);\n        return 1;\n      }\n      iVar3 \u003d _sbrk_r(param_1,0);\n      if (0xf \u003c iVar3 - DAT_2007046c) {\n        __malloc_current_mallinfo \u003d iVar3 - __malloc_sbrk_base;\n        *(uint *)(DAT_2007046c + 4) \u003d iVar3 - DAT_2007046c | 1;\n      }\n    }\n  }\n  __malloc_unlock(param_1);\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_free_r"
      ],
      "called": [
        "_sbrk_r",
        "__malloc_lock",
        "__malloc_unlock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_free_r": {
      "entrypoint": "0x00083b10",
      "current_name": "_free_r",
      "code": "\nvoid _free_r(undefined4 param_1,int param_2)\n\n{\n  undefined4 *puVar1;\n  bool bVar2;\n  uint uVar3;\n  int iVar4;\n  int iVar5;\n  undefined1 *puVar6;\n  uint uVar7;\n  undefined1 *puVar8;\n  int iVar9;\n  uint uVar10;\n  \n  if (param_2 \u003d\u003d 0) {\n    return;\n  }\n  __malloc_lock();\n  uVar3 \u003d *(uint *)(param_2 + -4);\n  iVar9 \u003d param_2 + -8;\n  uVar7 \u003d uVar3 \u0026 0xfffffffe;\n  iVar5 \u003d iVar9 + uVar7;\n  uVar10 \u003d *(uint *)(iVar5 + 4) \u0026 0xfffffffc;\n  if (DAT_2007046c \u003d\u003d iVar5) {\n    uVar10 \u003d uVar10 + uVar7;\n    if (-1 \u003c (int)(uVar3 \u003c\u003c 0x1f)) {\n      iVar9 \u003d iVar9 - *(int *)(param_2 + -8);\n      iVar4 \u003d *(int *)(iVar9 + 0xc);\n      iVar5 \u003d *(int *)(iVar9 + 8);\n      uVar10 \u003d uVar10 + *(int *)(param_2 + -8);\n      *(int *)(iVar5 + 0xc) \u003d iVar4;\n      *(int *)(iVar4 + 8) \u003d iVar5;\n    }\n    uVar3 \u003d __malloc_trim_threshold;\n    *(uint *)(iVar9 + 4) \u003d uVar10 | 1;\n    DAT_2007046c \u003d iVar9;\n    if (uVar3 \u003c\u003d uVar10) {\n      _malloc_trim_r(param_1,__malloc_top_pad);\n    }\n  }\n  else {\n    *(uint *)(iVar5 + 4) \u003d uVar10;\n    if ((uVar3 \u0026 1) \u003d\u003d 0) {\n      iVar9 \u003d iVar9 - *(int *)(param_2 + -8);\n      puVar1 \u003d *(undefined4 **)(iVar9 + 8);\n      uVar7 \u003d uVar7 + *(int *)(param_2 + -8);\n      if (puVar1 \u003d\u003d \u0026DAT_2007046c) {\n        bVar2 \u003d true;\n      }\n      else {\n        iVar4 \u003d *(int *)(iVar9 + 0xc);\n        puVar1[3] \u003d iVar4;\n        *(undefined4 **)(iVar4 + 8) \u003d puVar1;\n        bVar2 \u003d false;\n      }\n    }\n    else {\n      bVar2 \u003d false;\n    }\n    if (-1 \u003c *(int *)(iVar5 + uVar10 + 4) \u003c\u003c 0x1f) {\n      uVar7 \u003d uVar7 + uVar10;\n      puVar1 \u003d *(undefined4 **)(iVar5 + 8);\n      if ((!bVar2) \u0026\u0026 (puVar1 \u003d\u003d \u0026DAT_2007046c)) {\n        DAT_20070474 \u003d iVar9;\n        DAT_20070478 \u003d iVar9;\n        *(int **)(iVar9 + 0xc) \u003d \u0026DAT_2007046c;\n        *(int **)(iVar9 + 8) \u003d \u0026DAT_2007046c;\n        *(uint *)(iVar9 + 4) \u003d uVar7 | 1;\n        *(uint *)(iVar9 + uVar7) \u003d uVar7;\n        goto LAB_00083ba4;\n      }\n      iVar5 \u003d *(int *)(iVar5 + 0xc);\n      puVar1[3] \u003d iVar5;\n      *(undefined4 **)(iVar5 + 8) \u003d puVar1;\n    }\n    *(uint *)(iVar9 + 4) \u003d uVar7 | 1;\n    *(uint *)(iVar9 + uVar7) \u003d uVar7;\n    if (!bVar2) {\n      if (uVar7 \u003c 0x200) {\n        uVar3 \u003d uVar7 \u0026 0xfffffff8;\n        iVar5 \u003d *(int *)((int)\u0026DAT_2007046c + uVar3);\n        DAT_20070468 \u003d DAT_20070468 | 1 \u003c\u003c ((int)(uVar7 \u003e\u003e 3) \u003e\u003e 2 \u0026 0xffU);\n        *(int *)(iVar9 + 8) \u003d iVar5;\n        *(undefined1 **)(iVar9 + 0xc) \u003d \u0026__malloc_av_ + uVar3;\n        *(int *)((int)\u0026DAT_2007046c + uVar3) \u003d iVar9;\n        *(int *)(iVar5 + 0xc) \u003d iVar9;\n        __malloc_unlock(param_1);\n        return;\n      }\n      uVar3 \u003d uVar7 \u003e\u003e 9;\n      if (uVar3 \u003c 5) {\n        iVar5 \u003d (uVar7 \u003e\u003e 6) + 0x38;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else if (uVar3 \u003c 0x15) {\n        iVar5 \u003d uVar3 + 0x5b;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else if (uVar3 \u003c 0x55) {\n        iVar5 \u003d (uVar7 \u003e\u003e 0xc) + 0x6e;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else if (uVar3 \u003c 0x155) {\n        iVar5 \u003d (uVar7 \u003e\u003e 0xf) + 0x77;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else if (uVar3 \u003c 0x555) {\n        iVar5 \u003d (uVar7 \u003e\u003e 0x12) + 0x7c;\n        iVar4 \u003d iVar5 * 2;\n      }\n      else {\n        iVar4 \u003d 0xfc;\n        iVar5 \u003d 0x7e;\n      }\n      puVar6 \u003d (undefined1 *)(\u0026DAT_2007046c)[iVar4];\n      if (puVar6 \u003d\u003d \u0026__malloc_av_ + iVar4 * 4) {\n        DAT_20070468 \u003d DAT_20070468 | 1 \u003c\u003c (iVar5 \u003e\u003e 2 \u0026 0xffU);\n        puVar8 \u003d puVar6;\n      }\n      else {\n        do {\n          if ((*(uint *)(puVar6 + 4) \u0026 0xfffffffc) \u003c\u003d uVar7) break;\n          puVar6 \u003d *(undefined1 **)(puVar6 + 8);\n        } while (\u0026__malloc_av_ + iVar4 * 4 !\u003d puVar6);\n        puVar8 \u003d *(undefined1 **)(puVar6 + 0xc);\n      }\n      *(undefined1 **)(iVar9 + 0xc) \u003d puVar8;\n      *(undefined1 **)(iVar9 + 8) \u003d puVar6;\n      *(int *)(puVar8 + 8) \u003d iVar9;\n      *(int *)(puVar6 + 0xc) \u003d iVar9;\n    }\n  }\nLAB_00083ba4:\n  __malloc_unlock(param_1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "_malloc_r",
        "_fclose_r",
        "_realloc_r",
        "__swsetup_r",
        "__sflush_r",
        "free"
      ],
      "called": [
        "__malloc_lock",
        "_malloc_trim_r",
        "__malloc_unlock"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sfvwrite_r": {
      "entrypoint": "0x00083ca8",
      "current_name": "__sfvwrite_r",
      "code": "\nundefined4 __sfvwrite_r(undefined4 *param_1,void **param_2,undefined4 *param_3)\n\n{\n  void **ppvVar1;\n  int iVar2;\n  void *pvVar3;\n  void *pvVar4;\n  void *pvVar5;\n  void *pvVar6;\n  ushort uVar7;\n  uint uVar8;\n  int iVar9;\n  void **ppvVar10;\n  void *pvVar11;\n  void *pvVar12;\n  void *__n;\n  size_t __n_00;\n  void *local_2c;\n  \n  if (param_3[2] !\u003d 0) {\n    uVar7 \u003d *(ushort *)(param_2 + 3);\n    uVar8 \u003d (uint)uVar7;\n    if (((int)(uVar8 \u003c\u003c 0x1c) \u003c 0) \u0026\u0026 (param_2[4] !\u003d (void *)0x0)) {\n      ppvVar10 \u003d (void **)*param_3;\n    }\n    else {\n      iVar2 \u003d __swsetup_r(param_1,param_2);\n      if (iVar2 !\u003d 0) {\n        return 0xffffffff;\n      }\n      uVar7 \u003d *(ushort *)(param_2 + 3);\n      uVar8 \u003d (uint)uVar7;\n      ppvVar10 \u003d (void **)*param_3;\n    }\n    if ((uVar7 \u0026 2) \u003d\u003d 0) {\n      pvVar5 \u003d (void *)(uVar8 \u0026 2);\n      pvVar12 \u003d pvVar5;\n      pvVar11 \u003d pvVar5;\n      local_2c \u003d pvVar5;\n      if ((uVar8 \u0026 1) \u003d\u003d 0) {\n        pvVar5 \u003d (void *)0x0;\n        pvVar12 \u003d (void *)0x0;\n        while( true ) {\n          while (pvVar5 \u003d\u003d (void *)0x0) {\n            pvVar12 \u003d *ppvVar10;\n            ppvVar1 \u003d ppvVar10 + 1;\n            ppvVar10 \u003d ppvVar10 + 2;\n            pvVar5 \u003d *ppvVar1;\n          }\n          pvVar11 \u003d param_2[2];\n          if ((int)(uVar8 \u003c\u003c 0x16) \u003c 0) {\n            if (pvVar5 \u003c pvVar11) {\n              pvVar3 \u003d *param_2;\n              pvVar11 \u003d pvVar5;\n            }\n            else if ((uVar8 \u0026 0x480) \u003d\u003d 0) {\n              pvVar3 \u003d *param_2;\n            }\n            else {\n              __n_00 \u003d (int)*param_2 - (int)param_2[4];\n              pvVar11 \u003d (void *)(__n_00 + 1 + (int)pvVar5);\n              pvVar3 \u003d (void *)(((int)param_2[5] * 3) / 2);\n              if (pvVar11 \u003c\u003d pvVar3) {\n                pvVar11 \u003d pvVar3;\n              }\n              if ((int)(uVar8 \u003c\u003c 0x15) \u003c 0) {\n                pvVar4 \u003d (void *)_malloc_r(param_1,pvVar11);\n                if (pvVar4 \u003d\u003d (void *)0x0) {\n                  *param_1 \u003d 0xc;\n                  uVar7 \u003d *(ushort *)(param_2 + 3);\n                  goto LAB_00083da4;\n                }\n                memcpy(pvVar4,param_2[4],__n_00);\n                *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) \u0026 0xfb7f | 0x80;\n              }\n              else {\n                pvVar4 \u003d (void *)_realloc_r(param_1);\n                if (pvVar4 \u003d\u003d (void *)0x0) {\n                  _free_r(param_1,param_2[4]);\n                  uVar7 \u003d *(ushort *)(param_2 + 3) \u0026 0xff7f;\n                  *param_1 \u003d 0xc;\n                  goto LAB_00083da4;\n                }\n              }\n              pvVar3 \u003d (void *)((int)pvVar4 + __n_00);\n              param_2[4] \u003d pvVar4;\n              param_2[5] \u003d pvVar11;\n              *param_2 \u003d pvVar3;\n              param_2[2] \u003d (void *)((int)pvVar11 - __n_00);\n              pvVar11 \u003d pvVar5;\n            }\n            memmove(pvVar3,pvVar12,(size_t)pvVar11);\n            param_2[2] \u003d (void *)((int)param_2[2] - (int)pvVar11);\n            *param_2 \u003d (void *)((int)*param_2 + (int)pvVar11);\n            pvVar11 \u003d pvVar5;\n          }\n          else if ((param_2[4] \u003c *param_2) || (pvVar3 \u003d param_2[5], pvVar5 \u003c pvVar3)) {\n            if (pvVar5 \u003c pvVar11) {\n              pvVar11 \u003d pvVar5;\n            }\n            memmove(*param_2,pvVar12,(size_t)pvVar11);\n            pvVar3 \u003d param_2[2];\n            param_2[2] \u003d (void *)((int)pvVar3 - (int)pvVar11);\n            *param_2 \u003d (void *)((int)*param_2 + (int)pvVar11);\n            if (((void *)((int)pvVar3 - (int)pvVar11) \u003d\u003d (void *)0x0) \u0026\u0026\n               (iVar2 \u003d _fflush_r(param_1,param_2), iVar2 !\u003d 0)) goto LAB_00083da2;\n          }\n          else {\n            pvVar11 \u003d (void *)0x7fffffff;\n            if (pvVar5 \u003c (void *)0x7fffffff) {\n              pvVar11 \u003d pvVar5;\n            }\n            pvVar11 \u003d (void *)(*(code *)param_2[9])\n                                        (param_1,param_2[7],pvVar12,\n                                         ((uint)pvVar11 / (uint)pvVar3) * (int)pvVar3);\n            if ((int)pvVar11 \u003c 1) goto LAB_00083da2;\n          }\n          iVar2 \u003d param_3[2];\n          pvVar12 \u003d (void *)((int)pvVar12 + (int)pvVar11);\n          pvVar5 \u003d (void *)((int)pvVar5 - (int)pvVar11);\n          param_3[2] \u003d iVar2 - (int)pvVar11;\n          if (iVar2 - (int)pvVar11 \u003d\u003d 0) break;\n          uVar8 \u003d (uint)*(ushort *)(param_2 + 3);\n        }\n      }\n      else {\n        do {\n          while (pvVar5 \u003d\u003d (void *)0x0) {\n            pvVar11 \u003d *ppvVar10;\n            pvVar5 \u003d ppvVar10[1];\n            local_2c \u003d (void *)0x0;\n            ppvVar10 \u003d ppvVar10 + 2;\n          }\n          if (local_2c \u003d\u003d (void *)0x0) {\n            pvVar12 \u003d memchr(pvVar11,10,(size_t)pvVar5);\n            if (pvVar12 \u003d\u003d (void *)0x0) {\n              pvVar12 \u003d (void *)((int)pvVar5 + 1);\n              local_2c \u003d (void *)0x1;\n            }\n            else {\n              pvVar12 \u003d (void *)((int)pvVar12 + (1 - (int)pvVar11));\n              local_2c \u003d (void *)0x1;\n            }\n          }\n          pvVar4 \u003d *param_2;\n          pvVar3 \u003d pvVar12;\n          if (pvVar5 \u003c\u003d pvVar12) {\n            pvVar3 \u003d pvVar5;\n          }\n          pvVar6 \u003d param_2[5];\n          if ((param_2[4] \u003c pvVar4) \u0026\u0026\n             (__n \u003d (void *)((int)param_2[2] + (int)pvVar6), (int)__n \u003c (int)pvVar3)) {\n            memmove(pvVar4,pvVar11,(size_t)__n);\n            *param_2 \u003d (void *)((int)*param_2 + (int)__n);\n            iVar2 \u003d _fflush_r(param_1,param_2);\n            if (iVar2 !\u003d 0) goto LAB_00083da2;\n          }\n          else if ((int)pvVar3 \u003c (int)pvVar6) {\n            memmove(pvVar4,pvVar11,(size_t)pvVar3);\n            param_2[2] \u003d (void *)((int)param_2[2] - (int)pvVar3);\n            *param_2 \u003d (void *)((int)pvVar3 + (int)*param_2);\n            __n \u003d pvVar3;\n          }\n          else {\n            __n \u003d (void *)(*(code *)param_2[9])(param_1,param_2[7],pvVar11,pvVar6);\n            if ((int)__n \u003c 1) goto LAB_00083da2;\n          }\n          pvVar12 \u003d (void *)((int)pvVar12 - (int)__n);\n          if (pvVar12 \u003d\u003d (void *)0x0) {\n            iVar2 \u003d _fflush_r(param_1,param_2);\n            if (iVar2 !\u003d 0) goto LAB_00083da2;\n            local_2c \u003d (void *)0x0;\n          }\n          iVar2 \u003d param_3[2];\n          pvVar11 \u003d (void *)((int)pvVar11 + (int)__n);\n          pvVar5 \u003d (void *)((int)pvVar5 - (int)__n);\n          param_3[2] \u003d iVar2 - (int)__n;\n        } while (iVar2 - (int)__n !\u003d 0);\n      }\n    }\n    else {\n      pvVar12 \u003d (void *)0x0;\n      pvVar5 \u003d (void *)0x0;\n      do {\n        while( true ) {\n          pvVar11 \u003d pvVar5;\n          if ((void *)0x7ffffbff \u003c pvVar5) {\n            pvVar11 \u003d (void *)0x7ffffc00;\n          }\n          if (pvVar5 !\u003d (void *)0x0) break;\n          pvVar12 \u003d *ppvVar10;\n          pvVar5 \u003d ppvVar10[1];\n          ppvVar10 \u003d ppvVar10 + 2;\n        }\n        iVar2 \u003d (*(code *)param_2[9])(param_1,param_2[7],pvVar12,pvVar11);\n        if (iVar2 \u003c 1) {\nLAB_00083da2:\n          uVar7 \u003d *(ushort *)(param_2 + 3);\nLAB_00083da4:\n          *(ushort *)(param_2 + 3) \u003d uVar7 | 0x40;\n          return 0xffffffff;\n        }\n        iVar9 \u003d param_3[2];\n        pvVar12 \u003d (void *)((int)pvVar12 + iVar2);\n        pvVar5 \u003d (void *)((int)pvVar5 - iVar2);\n        param_3[2] \u003d iVar9 - iVar2;\n      } while (iVar9 - iVar2 !\u003d 0);\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sprint_r.part.0"
      ],
      "called": [
        "_malloc_r",
        "_fflush_r",
        "_realloc_r",
        "memcpy",
        "__swsetup_r",
        "memchr",
        "memmove",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fwalk": {
      "entrypoint": "0x00083fbc",
      "current_name": "_fwalk",
      "code": "\nuint _fwalk(int param_1,code *param_2)\n\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  int *piVar5;\n  \n  piVar5 \u003d (int *)(param_1 + 0x2e0);\n  if (piVar5 !\u003d (int *)0x0) {\n    uVar4 \u003d 0;\n    do {\n      iVar2 \u003d piVar5[2];\n      iVar3 \u003d piVar5[1] + -1;\n      if (-1 \u003c iVar3) {\n        do {\n          iVar3 \u003d iVar3 + -1;\n          if ((1 \u003c *(ushort *)(iVar2 + 0xc)) \u0026\u0026 (*(short *)(iVar2 + 0xe) !\u003d -1)) {\n            uVar1 \u003d (*param_2)(iVar2);\n            uVar4 \u003d uVar4 | uVar1;\n          }\n          iVar2 \u003d iVar2 + 0x68;\n        } while (iVar3 !\u003d -1);\n      }\n      piVar5 \u003d (int *)*piVar5;\n    } while (piVar5 !\u003d (int *)0x0);\n    return uVar4;\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "_cleanup_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__locale_charset": {
      "entrypoint": "0x00084004",
      "current_name": "__locale_charset",
      "code": "\nchar * __locale_charset(void)\n\n{\n  return lc_ctype_charset;\n}\n\n",
      "renaming": {},
      "calling": [
        "_wcrtomb_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__locale_mb_cur_max": {
      "entrypoint": "0x0008400c",
      "current_name": "__locale_mb_cur_max",
      "code": "\nundefined4 __locale_mb_cur_max(void)\n\n{\n  return __mb_cur_max;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fputwc_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__smakebuf_r": {
      "entrypoint": "0x00084018",
      "current_name": "__smakebuf_r",
      "code": "\nvoid __smakebuf_r(int param_1,int *param_2)\n\n{\n  ushort uVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  bool bVar5;\n  undefined auStack_54 [4];\n  uint local_50;\n  \n  uVar1 \u003d *(ushort *)(param_2 + 3);\n  uVar4 \u003d (uint)uVar1;\n  if ((int)(uVar4 \u003c\u003c 0x1e) \u003c 0) {\n    *param_2 \u003d (int)param_2 + 0x43;\n    param_2[4] \u003d (int)param_2 + 0x43;\n    param_2[5] \u003d 1;\n    return;\n  }\n  if (-1 \u003c *(short *)((int)param_2 + 0xe)) {\n    iVar2 \u003d _fstat_r(param_1,(int)*(short *)((int)param_2 + 0xe),auStack_54);\n    if (-1 \u003c iVar2) {\n      bVar5 \u003d (local_50 \u0026 0xf000) \u003d\u003d 0x2000;\n      if (((local_50 \u0026 0xf000) \u003d\u003d 0x8000) \u0026\u0026 (param_2[10] \u003d\u003d 0x8427d)) {\n        iVar2 \u003d 0x400;\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x400;\n        param_2[0x13] \u003d 0x400;\n      }\n      else {\n        iVar2 \u003d 0x400;\n        *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 0x800;\n      }\n      goto LAB_00084074;\n    }\n    uVar1 \u003d *(ushort *)(param_2 + 3);\n    uVar4 \u003d (uint)uVar1;\n  }\n  *(ushort *)(param_2 + 3) \u003d uVar1 | 0x800;\n  if ((uVar4 \u0026 0x80) \u003d\u003d 0) {\n    iVar2 \u003d 0x400;\n  }\n  else {\n    iVar2 \u003d 0x40;\n  }\n  bVar5 \u003d false;\nLAB_00084074:\n  iVar3 \u003d _malloc_r(param_1,iVar2);\n  uVar1 \u003d *(ushort *)(param_2 + 3);\n  if (iVar3 \u003d\u003d 0) {\n    if (-1 \u003c (int)((uint)uVar1 \u003c\u003c 0x16)) {\n      *(ushort *)(param_2 + 3) \u003d uVar1 | 2;\n      *param_2 \u003d (int)param_2 + 0x43;\n      param_2[4] \u003d (int)param_2 + 0x43;\n      param_2[5] \u003d 1;\n    }\n  }\n  else {\n    *(undefined4 *)(param_1 + 0x3c) \u003d 0x8387d;\n    *(ushort *)(param_2 + 3) \u003d uVar1 | 0x80;\n    *param_2 \u003d iVar3;\n    param_2[4] \u003d iVar3;\n    param_2[5] \u003d iVar2;\n    if ((bVar5) \u0026\u0026 (iVar2 \u003d _isatty_r(param_1,(int)*(short *)((int)param_2 + 0xe)), iVar2 !\u003d 0)) {\n      *(ushort *)(param_2 + 3) \u003d *(ushort *)(param_2 + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swsetup_r"
      ],
      "called": [
        "_fstat_r",
        "_malloc_r",
        "_isatty_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "memchr": {
      "entrypoint": "0x000840f8",
      "current_name": "memchr",
      "code": "\nvoid * memchr(void *__s,int __c,size_t __n)\n\n{\n  uint uVar1;\n  uint uVar2;\n  int iVar3;\n  uint *puVar4;\n  uint uVar5;\n  bool bVar6;\n  \n  uVar1 \u003d __c \u0026 0xff;\n  if (((uint)__s \u0026 3) \u003d\u003d 0) {\nLAB_00084128:\n    if (3 \u003c __n) {\n      uVar5 \u003d uVar1 | uVar1 \u003c\u003c 8;\n      puVar4 \u003d (uint *)__s;\n      do {\n        uVar2 \u003d *puVar4 ^ (uVar5 | uVar5 \u003c\u003c 0x10);\n        __s \u003d puVar4;\n        if ((uVar2 + 0xfefefeff \u0026 ~uVar2 \u0026 0x80808080) !\u003d 0) break;\n        __n \u003d __n - 4;\n        __s \u003d puVar4 + 1;\n        puVar4 \u003d puVar4 + 1;\n      } while (3 \u003c __n);\n    }\n    if (__n \u003d\u003d 0) {\n      __s \u003d (uint *)0x0;\n    }\n    else {\n                    /* WARNING: Load size is inaccurate */\n      if (*__s !\u003d uVar1) {\n        iVar3 \u003d 0;\n        do {\n          __s \u003d (void *)((int)__s + 1);\n          bVar6 \u003d iVar3 \u003d\u003d __n - 1;\n          iVar3 \u003d iVar3 + 1;\n          if (bVar6) goto LAB_00084150;\n                    /* WARNING: Load size is inaccurate */\n        } while (*__s !\u003d uVar1);\n      }\n    }\n  }\n  else if (__n \u003d\u003d 0) {\nLAB_00084150:\n    __s \u003d (uint *)0x0;\n  }\n  else {\n                    /* WARNING: Load size is inaccurate */\n    if (*__s !\u003d uVar1) {\n      puVar4 \u003d (uint *)((int)__s + 1);\n      __n \u003d __n - 1;\n      do {\n        __s \u003d puVar4;\n        if (((uint)__s \u0026 3) \u003d\u003d 0) goto LAB_00084128;\n        if (__n \u003d\u003d 0) goto LAB_00084150;\n                    /* WARNING: Load size is inaccurate */\n        puVar4 \u003d (uint *)((int)__s + 1);\n        __n \u003d __n - 1;\n      } while (*__s !\u003d uVar1);\n    }\n  }\n  return __s;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sfvwrite_r",
        "_vfiprintf_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_raise_r": {
      "entrypoint": "0x0008418c",
      "current_name": "_raise_r",
      "code": "\nundefined4 _raise_r(undefined4 *param_1,uint param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  __pid_t _Var1;\n  undefined4 uVar2;\n  int iVar3;\n  code *pcVar4;\n  \n  if (0x1f \u003c param_2) {\n    *param_1 \u003d 0x16;\n    return 0xffffffff;\n  }\n  iVar3 \u003d param_1[0xb7];\n  if ((iVar3 \u003d\u003d 0) || (pcVar4 \u003d *(code **)(iVar3 + param_2 * 4), pcVar4 \u003d\u003d (code *)0x0)) {\n    _Var1 \u003d _getpid_r();\n    uVar2 \u003d _kill_r(param_1,_Var1,param_2,param_4);\n    return uVar2;\n  }\n  if (pcVar4 \u003d\u003d (code *)0x1) {\n    return 0;\n  }\n  if (pcVar4 !\u003d (code *)0xffffffff) {\n    *(undefined4 *)(iVar3 + param_2 * 4) \u003d 0;\n    (*pcVar4)(param_2);\n    return 0;\n  }\n  *param_1 \u003d 0x16;\n  return 1;\n}\n\n",
      "renaming": {},
      "calling": [
        "raise"
      ],
      "called": [
        "_kill_r",
        "_getpid_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "raise": {
      "entrypoint": "0x000841e4",
      "current_name": "raise",
      "code": "\nint raise(int __sig)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _raise_r(_impure_ptr,__sig);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [
        "abort"
      ],
      "called": [
        "_raise_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_kill_r": {
      "entrypoint": "0x000841f4",
      "current_name": "_kill_r",
      "code": "\nvoid _kill_r(int *param_1,int param_2,int param_3)\n\n{\n  errno \u003d 0;\n  _kill(param_2,param_3);\n  if ((param_2 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_raise_r",
        "kill"
      ],
      "called": [
        "_kill"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_getpid_r": {
      "entrypoint": "0x0008421c",
      "current_name": "_getpid_r",
      "code": "\n\n\n__pid_t _getpid_r(void)\n\n{\n  return -1;\n}\n\n",
      "renaming": {},
      "calling": [
        "_raise_r"
      ],
      "called": [
        "_getpid"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sread": {
      "entrypoint": "0x00084220",
      "current_name": "__sread",
      "code": "\nvoid __sread(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _read_r(param_1,(int)*(short *)(param_2 + 0xe));\n  if (-1 \u003c iVar1) {\n    *(int *)(param_2 + 0x50) \u003d *(int *)(param_2 + 0x50) + iVar1;\n    return;\n  }\n  *(ushort *)(param_2 + 0xc) \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_read_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swrite": {
      "entrypoint": "0x00084244",
      "current_name": "__swrite",
      "code": "\nvoid __swrite(undefined4 param_1,int param_2,undefined4 param_3,undefined4 param_4)\n\n{\n  ushort uVar1;\n  \n  uVar1 \u003d *(ushort *)(param_2 + 0xc);\n  if ((int)((uint)uVar1 \u003c\u003c 0x17) \u003c 0) {\n    _lseek_r(param_1,(int)*(short *)(param_2 + 0xe),0,2);\n    uVar1 \u003d *(ushort *)(param_2 + 0xc);\n  }\n  *(ushort *)(param_2 + 0xc) \u003d uVar1 \u0026 0xefff;\n  _write_r(param_1,(int)*(short *)(param_2 + 0xe),param_3,param_4);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r",
        "_write_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sseek": {
      "entrypoint": "0x0008427c",
      "current_name": "__sseek",
      "code": "\nvoid __sseek(undefined4 param_1,int param_2)\n\n{\n  int iVar1;\n  ushort uVar2;\n  \n  iVar1 \u003d _lseek_r(param_1,(int)*(short *)(param_2 + 0xe));\n  if (iVar1 \u003d\u003d -1) {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) \u0026 0xefff;\n  }\n  else {\n    uVar2 \u003d *(ushort *)(param_2 + 0xc) | 0x1000;\n  }\n  if (iVar1 !\u003d -1) {\n    *(int *)(param_2 + 0x50) \u003d iVar1;\n  }\n  *(ushort *)(param_2 + 0xc) \u003d uVar2;\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_lseek_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__sclose": {
      "entrypoint": "0x0008429c",
      "current_name": "__sclose",
      "code": "\nvoid __sclose(undefined4 param_1,int param_2)\n\n{\n  _close_r(param_1,(int)*(short *)(param_2 + 0xe));\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_close_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__swbuf_r": {
      "entrypoint": "0x000842a4",
      "current_name": "__swbuf_r",
      "code": "\nuint __swbuf_r(int param_1,uint param_2,undefined4 *param_3,undefined4 param_4)\n\n{\n  ushort uVar1;\n  uint uVar2;\n  undefined *puVar3;\n  int iVar4;\n  \n  if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x38) \u003d\u003d 0)) {\n    __sinit();\n  }\n  uVar1 \u003d *(ushort *)(param_3 + 3);\n  uVar2 \u003d (uint)uVar1;\n  param_3[2] \u003d param_3[6];\n  if ((-1 \u003c (int)(uVar2 \u003c\u003c 0x1c)) || (iVar4 \u003d param_3[4], iVar4 \u003d\u003d 0)) {\n    iVar4 \u003d __swsetup_r(param_1,param_3,uVar1,uVar2,param_4);\n    if (iVar4 !\u003d 0) {\n      return 0xffffffff;\n    }\n    uVar1 \u003d *(ushort *)(param_3 + 3);\n    iVar4 \u003d param_3[4];\n    uVar2 \u003d (uint)uVar1;\n  }\n  param_2 \u003d param_2 \u0026 0xff;\n  if ((int)(uVar2 \u003c\u003c 0x12) \u003c 0) {\n    puVar3 \u003d (undefined *)*param_3;\n    iVar4 \u003d (int)puVar3 - iVar4;\n    if (iVar4 \u003c (int)param_3[5]) {\nLAB_000842d6:\n      iVar4 \u003d iVar4 + 1;\n      goto LAB_000842d8;\n    }\n  }\n  else {\n    param_3[0x19] \u003d param_3[0x19] \u0026 0xffffdfff;\n    puVar3 \u003d (undefined *)*param_3;\n    *(ushort *)(param_3 + 3) \u003d uVar1 | 0x2000;\n    iVar4 \u003d (int)puVar3 - iVar4;\n    if (iVar4 \u003c (int)param_3[5]) goto LAB_000842d6;\n  }\n  iVar4 \u003d _fflush_r(param_1,param_3);\n  if (iVar4 !\u003d 0) {\n    return 0xffffffff;\n  }\n  puVar3 \u003d (undefined *)*param_3;\n  iVar4 \u003d 1;\nLAB_000842d8:\n  param_3[2] \u003d param_3[2] + -1;\n  *param_3 \u003d puVar3 + 1;\n  *puVar3 \u003d (char)param_2;\n  if (((param_3[5] \u003d\u003d iVar4) ||\n      (((int)((uint)*(ushort *)(param_3 + 3) \u003c\u003c 0x1f) \u003c 0 \u0026\u0026 (param_2 \u003d\u003d 10)))) \u0026\u0026\n     (iVar4 \u003d _fflush_r(param_1,param_3), iVar4 !\u003d 0)) {\n    return 0xffffffff;\n  }\n  return param_2;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fputwc_r"
      ],
      "called": [
        "_fflush_r",
        "__swsetup_r",
        "__sinit"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_wcrtomb_r": {
      "entrypoint": "0x0008434c",
      "current_name": "_wcrtomb_r",
      "code": "\nvoid _wcrtomb_r(undefined4 *param_1,int param_2,undefined4 param_3,undefined4 *param_4)\n\n{\n  code *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  undefined auStack_24 [12];\n  \n  pcVar1 \u003d __wctomb;\n  if (param_2 \u003d\u003d 0) {\n    uVar2 \u003d __locale_charset();\n    iVar3 \u003d (*pcVar1)(param_1,auStack_24,0,uVar2,param_4);\n  }\n  else {\n    uVar2 \u003d __locale_charset();\n    iVar3 \u003d (*pcVar1)(param_1,param_2,param_3,uVar2,param_4);\n  }\n  if (iVar3 \u003d\u003d -1) {\n    *param_4 \u003d 0;\n    *param_1 \u003d 0x8a;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_fputwc_r"
      ],
      "called": [
        "__locale_charset",
        "__ascii_wctomb"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__ascii_wctomb": {
      "entrypoint": "0x0008439c",
      "current_name": "__ascii_wctomb",
      "code": "\nundefined4 __ascii_wctomb(undefined4 *param_1,undefined *param_2,uint param_3)\n\n{\n  if (param_2 \u003d\u003d (undefined *)0x0) {\n    return 0;\n  }\n  if (param_3 \u003c 0x100) {\n    *param_2 \u003d (char)param_3;\n    return 1;\n  }\n  *param_1 \u003d 0x8a;\n  return 0xffffffff;\n}\n\n",
      "renaming": {},
      "calling": [
        "_wcrtomb_r"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_write_r": {
      "entrypoint": "0x000843b8",
      "current_name": "_write_r",
      "code": "\nvoid _write_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _write(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__swrite"
      ],
      "called": [
        "_write"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_close_r": {
      "entrypoint": "0x000843e0",
      "current_name": "_close_r",
      "code": "\nvoid _close_r(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _close(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sclose"
      ],
      "called": [
        "_close"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fclose_r": {
      "entrypoint": "0x00084404",
      "current_name": "_fclose_r",
      "code": "\nundefined4 _fclose_r(int param_1,int param_2)\n\n{\n  undefined4 uVar1;\n  int iVar2;\n  \n  if (param_2 !\u003d 0) {\n    if ((param_1 !\u003d 0) \u0026\u0026 (*(int *)(param_1 + 0x38) \u003d\u003d 0)) {\n      __sinit();\n    }\n    if (*(short *)(param_2 + 0xc) !\u003d 0) {\n      uVar1 \u003d _fflush_r(param_1,param_2);\n      if ((*(code **)(param_2 + 0x2c) !\u003d (code *)0x0) \u0026\u0026\n         (iVar2 \u003d (**(code **)(param_2 + 0x2c))(param_1,*(undefined4 *)(param_2 + 0x1c)), iVar2 \u003c 0)\n         ) {\n        uVar1 \u003d 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(param_2 + 0xc) \u003c\u003c 0x18) \u003c 0) {\n        _free_r(param_1,*(undefined4 *)(param_2 + 0x10));\n      }\n      if (*(int *)(param_2 + 0x30) !\u003d 0) {\n        if (*(int *)(param_2 + 0x30) !\u003d param_2 + 0x40) {\n          _free_r(param_1);\n        }\n        *(undefined4 *)(param_2 + 0x30) \u003d 0;\n      }\n      if (*(int *)(param_2 + 0x44) !\u003d 0) {\n        _free_r(param_1);\n        *(undefined4 *)(param_2 + 0x44) \u003d 0;\n      }\n      __sfp_lock_acquire();\n      *(undefined2 *)(param_2 + 0xc) \u003d 0;\n      __sfp_lock_release();\n      return uVar1;\n    }\n  }\n  return 0;\n}\n\n",
      "renaming": {},
      "calling": [
        "fclose"
      ],
      "called": [
        "_fflush_r",
        "__sfp_lock_acquire",
        "__sinit",
        "__sfp_lock_release",
        "_free_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "fclose": {
      "entrypoint": "0x00084484",
      "current_name": "fclose",
      "code": "\nint fclose(FILE *__stream)\n\n{\n  int iVar1;\n  \n  iVar1 \u003d _fclose_r(_impure_ptr,__stream);\n  return iVar1;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "_fclose_r"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fstat_r": {
      "entrypoint": "0x00084494",
      "current_name": "_fstat_r",
      "code": "\nvoid _fstat_r(int *param_1,int param_2,stat *param_3)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _fstat(param_2,param_3);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_fstat"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_isatty_r": {
      "entrypoint": "0x000844bc",
      "current_name": "_isatty_r",
      "code": "\nvoid _isatty_r(int *param_1,int param_2)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _isatty(param_2);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__smakebuf_r"
      ],
      "called": [
        "_isatty"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_lseek_r": {
      "entrypoint": "0x000844e0",
      "current_name": "_lseek_r",
      "code": "\nvoid _lseek_r(int *param_1,int param_2,__off_t param_3,int param_4)\n\n{\n  __off_t _Var1;\n  \n  errno \u003d 0;\n  _Var1 \u003d _lseek(param_2,param_3,param_4);\n  if ((_Var1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sseek",
        "__swrite"
      ],
      "called": [
        "_lseek"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_read_r": {
      "entrypoint": "0x00084508",
      "current_name": "_read_r",
      "code": "\nvoid _read_r(int *param_1,int param_2,char *param_3,int param_4)\n\n{\n  int iVar1;\n  \n  errno \u003d 0;\n  iVar1 \u003d _read(param_2,param_3,param_4);\n  if ((iVar1 \u003d\u003d -1) \u0026\u0026 (errno !\u003d 0)) {\n    *param_1 \u003d errno;\n    return;\n  }\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__sread"
      ],
      "called": [
        "_read"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_uldivmod": {
      "entrypoint": "0x00084530",
      "current_name": "__aeabi_uldivmod",
      "code": "\nvoid __aeabi_uldivmod(int param_1,int param_2,int param_3,int param_4)\n\n{\n  if ((param_4 \u003d\u003d 0) \u0026\u0026 (param_3 \u003d\u003d 0)) {\n    if (param_2 !\u003d 0 || param_1 !\u003d 0) {\n      param_1 \u003d -1;\n    }\n    __aeabi_idiv0(param_1);\n    return;\n  }\n  __gnu_uldivmod_helper();\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "_vfiprintf_r"
      ],
      "called": [
        "__gnu_uldivmod_helper",
        "__aeabi_idiv0"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__gnu_ldivmod_helper": {
      "entrypoint": "0x0008455c",
      "current_name": "__gnu_ldivmod_helper",
      "code": "\nvoid __gnu_ldivmod_helper\n               (uint param_1,int param_2,undefined4 param_3,undefined4 param_4,int *param_5)\n\n{\n  uint uVar1;\n  longlong lVar2;\n  \n  lVar2 \u003d __divdi3();\n  lVar2 \u003d lVar2 * CONCAT44(param_4,param_3);\n  uVar1 \u003d (uint)lVar2;\n  *param_5 \u003d param_1 - uVar1;\n  param_5[1] \u003d (param_2 - (int)((ulonglong)lVar2 \u003e\u003e 0x20)) - (uint)(param_1 \u003c uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [],
      "called": [
        "__divdi3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__gnu_uldivmod_helper": {
      "entrypoint": "0x0008458c",
      "current_name": "__gnu_uldivmod_helper",
      "code": "\nvoid __gnu_uldivmod_helper\n               (uint param_1,int param_2,undefined4 param_3,undefined4 param_4,int *param_5)\n\n{\n  uint uVar1;\n  longlong lVar2;\n  \n  lVar2 \u003d __udivdi3();\n  lVar2 \u003d lVar2 * CONCAT44(param_4,param_3);\n  uVar1 \u003d (uint)lVar2;\n  *param_5 \u003d param_1 - uVar1;\n  param_5[1] \u003d (param_2 - (int)((ulonglong)lVar2 \u003e\u003e 0x20)) - (uint)(param_1 \u003c uVar1);\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_uldivmod"
      ],
      "called": [
        "__udivdi3"
      ],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__aeabi_idiv0": {
      "entrypoint": "0x000845bc",
      "current_name": "__aeabi_idiv0",
      "code": "\nvoid __aeabi_idiv0(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__aeabi_uldivmod"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__divdi3": {
      "entrypoint": "0x000845c0",
      "current_name": "__divdi3",
      "code": "\nundefined8 __divdi3(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  int iVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  uint uVar10;\n  uint uVar11;\n  uint uVar12;\n  bool bVar13;\n  \n  if ((int)param_2 \u003c 0) {\n    bVar13 \u003d param_1 !\u003d 0;\n    param_1 \u003d -param_1;\n    param_2 \u003d -param_2 - (uint)bVar13;\n    uVar9 \u003d 0xffffffff;\n  }\n  else {\n    uVar9 \u003d 0;\n  }\n  if ((int)param_4 \u003c 0) {\n    uVar9 \u003d ~uVar9;\n    bVar13 \u003d param_3 !\u003d 0;\n    param_3 \u003d -param_3;\n    param_4 \u003d -param_4 - (uint)bVar13;\n  }\n  if (param_4 \u003d\u003d 0) {\n    if (param_2 \u003c param_3) {\n      iVar6 \u003d LZCOUNT(param_3);\n      if (iVar6 !\u003d 0) {\n        uVar3 \u003d param_1 \u003e\u003e (0x20U - iVar6 \u0026 0xff);\n        param_3 \u003d param_3 \u003c\u003c iVar6;\n        param_1 \u003d param_1 \u003c\u003c iVar6;\n        param_2 \u003d param_2 \u003c\u003c iVar6 | uVar3;\n      }\n      uVar2 \u003d param_3 \u003e\u003e 0x10;\n      uVar4 \u003d param_2 / uVar2;\n      uVar7 \u003d (param_3 \u0026 0xffff) * uVar4;\n      uVar10 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar2 * uVar4) * 0x10000;\n      uVar3 \u003d uVar4;\n      if (uVar10 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar10 !\u003d 0) {\n        bVar13 \u003d CARRY4(uVar10,param_3);\n        uVar10 \u003d uVar10 + param_3;\n        uVar3 \u003d uVar4 - 1;\n        if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar10 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar10 !\u003d 0)) {\n          uVar3 \u003d uVar4 - 2;\n          uVar10 \u003d uVar10 + param_3;\n        }\n      }\n      uVar8 \u003d (uVar10 - uVar7) / uVar2;\n      uVar4 \u003d (param_3 \u0026 0xffff) * uVar8;\n      uVar7 \u003d param_1 \u0026 0xffff | ((uVar10 - uVar7) - uVar2 * uVar8) * 0x10000;\n      uVar2 \u003d uVar8;\n      if (uVar7 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar7 !\u003d 0) {\n        uVar2 \u003d uVar8 - 1;\n        if ((CARRY4(uVar7,param_3) \u003d\u003d false) \u0026\u0026\n           (uVar7 + param_3 \u003c\u003d uVar4 \u0026\u0026 uVar4 - (uVar7 + param_3) !\u003d 0)) {\n          uVar2 \u003d uVar8 - 2;\n        }\n      }\n      uVar2 \u003d uVar2 | uVar3 \u003c\u003c 0x10;\n      uVar3 \u003d 0;\n    }\n    else {\n      if (param_3 \u003d\u003d 0) {\n        param_3 \u003d 1 / 0;\n      }\n      iVar6 \u003d LZCOUNT(param_3);\n      if (iVar6 \u003d\u003d 0) {\n        param_2 \u003d param_2 - param_3;\n        uVar4 \u003d param_3 \u003e\u003e 0x10;\n        uVar12 \u003d param_3 \u0026 0xffff;\n        uVar3 \u003d 1;\n      }\n      else {\n        param_3 \u003d param_3 \u003c\u003c iVar6;\n        uVar3 \u003d param_2 \u003e\u003e (0x20U - iVar6 \u0026 0xff);\n        uVar4 \u003d param_3 \u003e\u003e 0x10;\n        uVar10 \u003d uVar3 / uVar4;\n        uVar12 \u003d param_3 \u0026 0xffff;\n        uVar7 \u003d uVar12 * uVar10;\n        uVar8 \u003d param_1 \u003e\u003e (0x20U - iVar6 \u0026 0xff) | param_2 \u003c\u003c iVar6;\n        uVar3 \u003d uVar8 \u003e\u003e 0x10 | (uVar3 - uVar4 * uVar10) * 0x10000;\n        param_1 \u003d param_1 \u003c\u003c iVar6;\n        uVar2 \u003d uVar10;\n        if (uVar3 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar3 !\u003d 0) {\n          bVar13 \u003d CARRY4(uVar3,param_3);\n          uVar3 \u003d uVar3 + param_3;\n          uVar2 \u003d uVar10 - 1;\n          if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar3 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar3 !\u003d 0)) {\n            uVar2 \u003d uVar10 - 2;\n            uVar3 \u003d uVar3 + param_3;\n          }\n        }\n        uVar5 \u003d (uVar3 - uVar7) / uVar4;\n        uVar10 \u003d uVar12 * uVar5;\n        param_2 \u003d uVar8 \u0026 0xffff | ((uVar3 - uVar7) - uVar4 * uVar5) * 0x10000;\n        uVar3 \u003d uVar5;\n        if (param_2 \u003c\u003d uVar10 \u0026\u0026 uVar10 - param_2 !\u003d 0) {\n          bVar13 \u003d CARRY4(param_2,param_3);\n          param_2 \u003d param_2 + param_3;\n          uVar3 \u003d uVar5 - 1;\n          if ((bVar13 \u003d\u003d false) \u0026\u0026 (param_2 \u003c\u003d uVar10 \u0026\u0026 uVar10 - param_2 !\u003d 0)) {\n            uVar3 \u003d uVar5 - 2;\n            param_2 \u003d param_2 + param_3;\n          }\n        }\n        param_2 \u003d param_2 - uVar10;\n        uVar3 \u003d uVar3 | uVar2 \u003c\u003c 0x10;\n      }\n      uVar2 \u003d param_2 / uVar4;\n      uVar10 \u003d uVar12 * uVar2;\n      uVar8 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar4 * uVar2) * 0x10000;\n      uVar7 \u003d uVar2;\n      if (uVar8 \u003c\u003d uVar10 \u0026\u0026 uVar10 - uVar8 !\u003d 0) {\n        bVar13 \u003d CARRY4(uVar8,param_3);\n        uVar8 \u003d uVar8 + param_3;\n        uVar7 \u003d uVar2 - 1;\n        if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar8 \u003c\u003d uVar10 \u0026\u0026 uVar10 - uVar8 !\u003d 0)) {\n          uVar7 \u003d uVar2 - 2;\n          uVar8 \u003d uVar8 + param_3;\n        }\n      }\n      uVar5 \u003d (uVar8 - uVar10) / uVar4;\n      uVar12 \u003d uVar12 * uVar5;\n      uVar4 \u003d param_1 \u0026 0xffff | ((uVar8 - uVar10) - uVar4 * uVar5) * 0x10000;\n      uVar2 \u003d uVar5;\n      if (uVar4 \u003c\u003d uVar12 \u0026\u0026 uVar12 - uVar4 !\u003d 0) {\n        uVar2 \u003d uVar5 - 1;\n        if ((CARRY4(uVar4,param_3) \u003d\u003d false) \u0026\u0026\n           (uVar4 + param_3 \u003c\u003d uVar12 \u0026\u0026 uVar12 - (uVar4 + param_3) !\u003d 0)) {\n          uVar2 \u003d uVar5 - 2;\n        }\n      }\n      uVar2 \u003d uVar2 | uVar7 \u003c\u003c 0x10;\n    }\n  }\n  else if (param_2 \u003c param_4) {\n    uVar3 \u003d 0;\n    uVar2 \u003d 0;\n  }\n  else {\n    iVar6 \u003d LZCOUNT(param_4);\n    if (iVar6 \u003d\u003d 0) {\n      if ((param_4 \u003c param_2) || (param_3 \u003c\u003d param_1)) {\n        uVar3 \u003d 0;\n        uVar2 \u003d 1;\n      }\n      else {\n        uVar2 \u003d 0;\n        uVar3 \u003d 0;\n      }\n    }\n    else {\n      uVar3 \u003d 0x20 - iVar6;\n      uVar4 \u003d param_2 \u003e\u003e (uVar3 \u0026 0xff);\n      uVar12 \u003d param_3 \u003e\u003e (uVar3 \u0026 0xff) | param_4 \u003c\u003c iVar6;\n      uVar10 \u003d uVar12 \u003e\u003e 0x10;\n      uVar2 \u003d uVar4 / uVar10;\n      uVar8 \u003d (uVar12 \u0026 0xffff) * uVar2;\n      uVar7 \u003d param_2 \u003c\u003c iVar6 | param_1 \u003e\u003e (uVar3 \u0026 0xff);\n      uVar4 \u003d uVar7 \u003e\u003e 0x10 | (uVar4 - uVar10 * uVar2) * 0x10000;\n      uVar3 \u003d uVar2;\n      if (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0) {\n        bVar13 \u003d CARRY4(uVar4,uVar12);\n        uVar4 \u003d uVar4 + uVar12;\n        uVar3 \u003d uVar2 - 1;\n        if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar8 \u0026\u0026 uVar8 - uVar4 !\u003d 0)) {\n          uVar3 \u003d uVar2 - 2;\n          uVar4 \u003d uVar4 + uVar12;\n        }\n      }\n      uVar5 \u003d (uVar4 - uVar8) / uVar10;\n      uVar11 \u003d (uVar12 \u0026 0xffff) * uVar5;\n      uVar4 \u003d uVar7 \u0026 0xffff | ((uVar4 - uVar8) - uVar10 * uVar5) * 0x10000;\n      uVar2 \u003d uVar5;\n      if (uVar4 \u003c\u003d uVar11 \u0026\u0026 uVar11 - uVar4 !\u003d 0) {\n        bVar13 \u003d CARRY4(uVar4,uVar12);\n        uVar4 \u003d uVar4 + uVar12;\n        uVar2 \u003d uVar5 - 1;\n        if ((bVar13 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar11 \u0026\u0026 uVar11 - uVar4 !\u003d 0)) {\n          uVar2 \u003d uVar5 - 2;\n          uVar4 \u003d uVar4 + uVar12;\n        }\n      }\n      uVar2 \u003d uVar2 | uVar3 \u003c\u003c 0x10;\n      lVar1 \u003d (ulonglong)uVar2 * (ulonglong)(param_3 \u003c\u003c iVar6);\n      uVar7 \u003d (uint)((ulonglong)lVar1 \u003e\u003e 0x20);\n      uVar3 \u003d 0;\n      if ((uVar4 - uVar11 \u003c uVar7) ||\n         ((uVar4 - uVar11 \u003d\u003d uVar7 \u0026\u0026 (param_1 \u003c\u003c iVar6 \u003c (uint)lVar1)))) {\n        uVar2 \u003d uVar2 - 1;\n        uVar3 \u003d 0;\n      }\n    }\n  }\n  if (uVar9 !\u003d 0) {\n    bVar13 \u003d uVar2 !\u003d 0;\n    uVar2 \u003d -uVar2;\n    uVar3 \u003d -uVar3 - (uint)bVar13;\n  }\n  return CONCAT44(uVar3,uVar2);\n}\n\n",
      "renaming": {},
      "calling": [
        "__gnu_ldivmod_helper"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "__udivdi3": {
      "entrypoint": "0x00084860",
      "current_name": "__udivdi3",
      "code": "\nulonglong __udivdi3(uint param_1,uint param_2,uint param_3,uint param_4)\n\n{\n  longlong lVar1;\n  uint uVar2;\n  uint uVar3;\n  uint uVar4;\n  uint uVar5;\n  uint uVar6;\n  uint uVar7;\n  uint uVar8;\n  uint uVar9;\n  int iVar10;\n  bool bVar11;\n  \n  if (param_4 \u003d\u003d 0) {\n    if (param_3 \u003c\u003d param_2) {\n      if (param_3 \u003d\u003d 0) {\n        param_3 \u003d 1 / 0;\n      }\n      iVar10 \u003d LZCOUNT(param_3);\n      if (iVar10 \u003d\u003d 0) {\n        param_2 \u003d param_2 - param_3;\n        uVar3 \u003d param_3 \u003e\u003e 0x10;\n        uVar5 \u003d param_3 \u0026 0xffff;\n        uVar2 \u003d 1;\n      }\n      else {\n        param_3 \u003d param_3 \u003c\u003c iVar10;\n        uVar8 \u003d param_2 \u003e\u003e (0x20U - iVar10 \u0026 0xff);\n        uVar3 \u003d param_3 \u003e\u003e 0x10;\n        uVar9 \u003d uVar8 / uVar3;\n        uVar5 \u003d param_3 \u0026 0xffff;\n        uVar2 \u003d uVar5 * uVar9;\n        uVar6 \u003d param_1 \u003e\u003e (0x20U - iVar10 \u0026 0xff) | param_2 \u003c\u003c iVar10;\n        uVar4 \u003d uVar6 \u003e\u003e 0x10 | (uVar8 - uVar3 * uVar9) * 0x10000;\n        param_1 \u003d param_1 \u003c\u003c iVar10;\n        uVar8 \u003d uVar9;\n        if (uVar4 \u003c\u003d uVar2 \u0026\u0026 uVar2 - uVar4 !\u003d 0) {\n          bVar11 \u003d CARRY4(uVar4,param_3);\n          uVar4 \u003d uVar4 + param_3;\n          uVar8 \u003d uVar9 - 1;\n          if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar4 \u003c\u003d uVar2 \u0026\u0026 uVar2 - uVar4 !\u003d 0)) {\n            uVar8 \u003d uVar9 - 2;\n            uVar4 \u003d uVar4 + param_3;\n          }\n        }\n        uVar7 \u003d (uVar4 - uVar2) / uVar3;\n        uVar9 \u003d uVar5 * uVar7;\n        param_2 \u003d uVar6 \u0026 0xffff | ((uVar4 - uVar2) - uVar3 * uVar7) * 0x10000;\n        uVar2 \u003d uVar7;\n        if (param_2 \u003c\u003d uVar9 \u0026\u0026 uVar9 - param_2 !\u003d 0) {\n          bVar11 \u003d CARRY4(param_2,param_3);\n          param_2 \u003d param_2 + param_3;\n          uVar2 \u003d uVar7 - 1;\n          if ((bVar11 \u003d\u003d false) \u0026\u0026 (param_2 \u003c\u003d uVar9 \u0026\u0026 uVar9 - param_2 !\u003d 0)) {\n            uVar2 \u003d uVar7 - 2;\n            param_2 \u003d param_2 + param_3;\n          }\n        }\n        param_2 \u003d param_2 - uVar9;\n        uVar2 \u003d uVar2 | uVar8 \u003c\u003c 0x10;\n      }\n      uVar9 \u003d param_2 / uVar3;\n      uVar4 \u003d uVar5 * uVar9;\n      uVar6 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar3 * uVar9) * 0x10000;\n      uVar8 \u003d uVar9;\n      if (uVar6 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar6 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar6,param_3);\n        uVar6 \u003d uVar6 + param_3;\n        uVar8 \u003d uVar9 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar6 \u003c\u003d uVar4 \u0026\u0026 uVar4 - uVar6 !\u003d 0)) {\n          uVar8 \u003d uVar9 - 2;\n          uVar6 \u003d uVar6 + param_3;\n        }\n      }\n      uVar9 \u003d (uVar6 - uVar4) / uVar3;\n      uVar5 \u003d uVar5 * uVar9;\n      uVar6 \u003d param_1 \u0026 0xffff | ((uVar6 - uVar4) - uVar3 * uVar9) * 0x10000;\n      uVar3 \u003d uVar9;\n      if (uVar6 \u003c\u003d uVar5 \u0026\u0026 uVar5 - uVar6 !\u003d 0) {\n        uVar3 \u003d uVar9 - 1;\n        if ((CARRY4(uVar6,param_3) \u003d\u003d false) \u0026\u0026\n           (uVar6 + param_3 \u003c\u003d uVar5 \u0026\u0026 uVar5 - (uVar6 + param_3) !\u003d 0)) {\n          uVar3 \u003d uVar9 - 2;\n        }\n      }\n      return CONCAT44(uVar2,uVar3 | uVar8 \u003c\u003c 0x10);\n    }\n    iVar10 \u003d LZCOUNT(param_3);\n    if (iVar10 !\u003d 0) {\n      uVar8 \u003d param_1 \u003e\u003e (0x20U - iVar10 \u0026 0xff);\n      param_3 \u003d param_3 \u003c\u003c iVar10;\n      param_1 \u003d param_1 \u003c\u003c iVar10;\n      param_2 \u003d uVar8 | param_2 \u003c\u003c iVar10;\n    }\n    uVar2 \u003d param_3 \u003e\u003e 0x10;\n    uVar3 \u003d param_2 / uVar2;\n    uVar5 \u003d (param_3 \u0026 0xffff) * uVar3;\n    uVar9 \u003d param_1 \u003e\u003e 0x10 | (param_2 - uVar2 * uVar3) * 0x10000;\n    uVar8 \u003d uVar3;\n    if (uVar9 \u003c\u003d uVar5 \u0026\u0026 uVar5 - uVar9 !\u003d 0) {\n      bVar11 \u003d CARRY4(uVar9,param_3);\n      uVar9 \u003d uVar9 + param_3;\n      uVar8 \u003d uVar3 - 1;\n      if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar9 \u003c\u003d uVar5 \u0026\u0026 uVar5 - uVar9 !\u003d 0)) {\n        uVar8 \u003d uVar3 - 2;\n        uVar9 \u003d uVar9 + param_3;\n      }\n    }\n    uVar6 \u003d (uVar9 - uVar5) / uVar2;\n    uVar3 \u003d (param_3 \u0026 0xffff) * uVar6;\n    uVar5 \u003d param_1 \u0026 0xffff | ((uVar9 - uVar5) - uVar2 * uVar6) * 0x10000;\n    uVar2 \u003d uVar6;\n    if (uVar5 \u003c\u003d uVar3 \u0026\u0026 uVar3 - uVar5 !\u003d 0) {\n      uVar2 \u003d uVar6 - 1;\n      if ((CARRY4(uVar5,param_3) \u003d\u003d false) \u0026\u0026\n         (uVar5 + param_3 \u003c\u003d uVar3 \u0026\u0026 uVar3 - (uVar5 + param_3) !\u003d 0)) {\n        uVar2 \u003d uVar6 - 2;\n      }\n    }\n    uVar2 \u003d uVar2 | uVar8 \u003c\u003c 0x10;\n  }\n  else {\n    if (param_2 \u003c param_4) {\n      return 0;\n    }\n    iVar10 \u003d LZCOUNT(param_4);\n    if (iVar10 \u003d\u003d 0) {\n      if ((param_4 \u003c param_2) || (param_3 \u003c\u003d param_1)) {\n        return 1;\n      }\n      uVar2 \u003d 0;\n    }\n    else {\n      uVar2 \u003d 0x20 - iVar10;\n      uVar8 \u003d param_2 \u003e\u003e (uVar2 \u0026 0xff);\n      uVar3 \u003d param_4 \u003c\u003c iVar10 | param_3 \u003e\u003e (uVar2 \u0026 0xff);\n      uVar5 \u003d uVar3 \u003e\u003e 0x10;\n      uVar4 \u003d uVar8 / uVar5;\n      uVar9 \u003d (uVar3 \u0026 0xffff) * uVar4;\n      uVar6 \u003d param_1 \u003e\u003e (uVar2 \u0026 0xff) | param_2 \u003c\u003c iVar10;\n      uVar2 \u003d uVar6 \u003e\u003e 0x10 | (uVar8 - uVar5 * uVar4) * 0x10000;\n      uVar8 \u003d uVar4;\n      if (uVar2 \u003c\u003d uVar9 \u0026\u0026 uVar9 - uVar2 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar2,uVar3);\n        uVar2 \u003d uVar2 + uVar3;\n        uVar8 \u003d uVar4 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar2 \u003c\u003d uVar9 \u0026\u0026 uVar9 - uVar2 !\u003d 0)) {\n          uVar8 \u003d uVar4 - 2;\n          uVar2 \u003d uVar2 + uVar3;\n        }\n      }\n      uVar4 \u003d (uVar2 - uVar9) / uVar5;\n      uVar7 \u003d (uVar3 \u0026 0xffff) * uVar4;\n      uVar5 \u003d uVar6 \u0026 0xffff | ((uVar2 - uVar9) - uVar5 * uVar4) * 0x10000;\n      uVar2 \u003d uVar4;\n      if (uVar5 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar5 !\u003d 0) {\n        bVar11 \u003d CARRY4(uVar5,uVar3);\n        uVar5 \u003d uVar5 + uVar3;\n        uVar2 \u003d uVar4 - 1;\n        if ((bVar11 \u003d\u003d false) \u0026\u0026 (uVar5 \u003c\u003d uVar7 \u0026\u0026 uVar7 - uVar5 !\u003d 0)) {\n          uVar2 \u003d uVar4 - 2;\n          uVar5 \u003d uVar5 + uVar3;\n        }\n      }\n      uVar2 \u003d uVar2 | uVar8 \u003c\u003c 0x10;\n      lVar1 \u003d (ulonglong)uVar2 * (ulonglong)(param_3 \u003c\u003c iVar10);\n      uVar8 \u003d (uint)((ulonglong)lVar1 \u003e\u003e 0x20);\n      if ((uVar5 - uVar7 \u003c uVar8) || ((uVar5 - uVar7 \u003d\u003d uVar8 \u0026\u0026 (param_1 \u003c\u003c iVar10 \u003c (uint)lVar1)))\n         ) {\n        uVar2 \u003d uVar2 - 1;\n      }\n    }\n  }\n  return (ulonglong)uVar2;\n}\n\n",
      "renaming": {},
      "calling": [
        "__gnu_uldivmod_helper"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_init": {
      "entrypoint": "0x00085844",
      "current_name": "_init",
      "code": "\nvoid _init(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_init_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "_fini": {
      "entrypoint": "0x00085860",
      "current_name": "_fini",
      "code": "\nvoid _fini(void)\n\n{\n  return;\n}\n\n",
      "renaming": {},
      "calling": [
        "__libc_fini_array"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    },
    "banzai": {
      "entrypoint": "0x20070000",
      "current_name": "banzai",
      "code": "\n/* WARNING: Unknown calling convention */\n\nvoid banzai(void)\n\n{\n  disableIRQinterrupts();\n  do {\n  } while (-1 \u003c *(int *)(DAT_2007001c + 8) \u003c\u003c 0x1f);\n  *(undefined4 *)(DAT_2007001c + 4) \u003d DAT_20070020;\n  do {\n  } while (-1 \u003c *(int *)(DAT_2007001c + 8) \u003c\u003c 0x1f);\n  *DAT_20070028 \u003d DAT_20070024;\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
      "renaming": {},
      "calling": [
        "Reset_Handler",
        "tickReset"
      ],
      "called": [],
      "improved": true,
      "skipped": false,
      "imported": false,
      "tags": []
    }
  },
  "layers": [],
  "locked_functions": [],
  "used_tokens": 0
}