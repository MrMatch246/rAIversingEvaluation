{
    "functions": {
        "FUN_000800f4": {
            "entrypoint": "0x000800f4",
            "current_name": "initialize_flag_000800f4",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080100) */\n\nundefined4 initializeFlag_000800f4(undefined4 flag)\n\n{\n  if ((char)DAT_200708a0 == '\\0') {\n    DAT_200708a0._0_1_ = '\\x01';\n  }\n  return flag;\n}\n\n",
            "renaming": {
                "FUN_000800f4": "initialize_flag_000800f4",
                "param_1": "flag"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080118": {
            "entrypoint": "0x00080118",
            "current_name": "FUNC_00080118",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x0008011e) */\n/* WARNING: Removing unreachable block (ram,0x00080130) */\n\n\nvoid FUNC_00080118(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080118": "FUNC_00080118"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080164": {
            "entrypoint": "0x00080164",
            "current_name": "initialize_data_00080164",
            "code": "\nvoid initializeData_00080164(undefined4 arg1,undefined4 arg2,undefined4 arg3,undefined4 arg4)\n\n{\n  FUN_000806f8(&DAT_200708e8,0x5a);\n  FUN_000806f8(&DAT_200708d4,0x5a,arg3,arg4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080164": "initialize_data_00080164",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "param_4": "arg4"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000806f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000801e0": {
            "entrypoint": "0x000801e0",
            "current_name": "initialize_system_000801e0",
            "code": "\nundefined8 initialize_system_000801e0(undefined4 config_param_1,undefined4 config_param_2,undefined4 config_param_3,undefined4 config_param_4)\n\n{\n  FUN_000813dc(&DAT_20070be8,0xe100,config_param_3,config_param_4,config_param_4);\n  FUN_00080f0c(0xd,1);\n  FUN_00080f0c(6,1);\n  FUN_00080f0c(0x39,0);\n  FUN_00080f0c(4,0);\n  FUN_00080f0c(3,0);\n  FUN_00080f0c(2,0);\n  FUN_000806a0(&DAT_200708d4,5);\n  FUN_000806a0(&DAT_200708e8,6);\n  FUN_00080164();\n  FUNC_00080f08(1000);\n  if (DAT_200708bc == 0) {\n    software_interrupt(0x3f);\n    return 1;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_000801e0": "initialize_system_000801e0",
                "param_1": "config_param_1",
                "param_2": "config_param_2",
                "param_3": "config_param_3",
                "param_4": "config_param_4"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_000806a0",
                "FUN_00080f0c",
                "FUN_00080f08",
                "FUN_00080164",
                "FUN_000813dc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080250": {
            "entrypoint": "0x00080250",
            "current_name": "control_function_00080250",
            "code": "\nvoid controlFunction_00080250(void)\n\n{\n  undefined4 returnValue;\n  int loopCounter;\n  undefined *pointerVariable;\n  undefined localArray [12];\n  \n  DAT_200708c0 = FUN_00081624(4,1,20000);\n  FUNC_00080f08(10);\n  DAT_200708c4 = DAT_200708c4 ^ 1;\n  FUN_00081014(0xd);\n  if (DAT_200708c0 < 0x641) {\n    if (DAT_200708c0 - 0x385U < 299) {\n      if (DAT_200708eb != '\\0') {\n        FUN_00080164();\n        FUN_000810e8(&DAT_20070be8,\"Entered manual control mode.\");\n        DAT_200708eb = '\\0';\n      }\n      FUNC_00080f08(10);\n      returnValue = FUN_00081624(3,1,20000);\n      DAT_200708d8 = FUN_0008145c(0,1000,2000,0x28,0x96);\n      DAT_200708ec = FUN_0008145c(returnValue,1000,2000,0x28,0x96);\n      while (loopCounter = FUN_00081248(&DAT_20070be8), 0 < loopCounter) {\n        FUN_00081276(&DAT_20070be8);\n        thunk_FUN_0008113a(&DAT_20070be8,DAT_200708d8,10);\n        FUN_000810c4(&DAT_20070be8,&DAT_00084b13);\n        FUN_0008117a(&DAT_20070be8,DAT_200708ec,10);\n      }\n      FUN_000806f8(&DAT_200708e8,DAT_200708ec);\n      FUN_000806f8(&DAT_200708d4,DAT_200708d8);\n    }\n    else {\n      if (DAT_200708eb == '\\0') {\n        FUN_00080164();\n        FUN_000810e8(&DAT_20070be8,\"Entered autonomous control mode.\");\n      }\n      DAT_200708eb = '\\x01';\nLAB_00080346:\n      loopCounter = FUN_00081248(&DAT_20070be8);\n      if (0 < loopCounter) {\n        FUN_00081214(localArray,&DAT_20070be8,0x2c);\n        FUN_00081560(&DAT_200708dc,localArray);\n        FUN_00081472(localArray);\n        FUN_00081214(localArray,&DAT_20070be8,10);\n        FUN_00081560(&DAT_200708c8,localArray);\n        FUN_00081472(localArray);\n        FUN_00081276(&DAT_20070be8);\n        loopCounter = FUN_000815b8(&DAT_200708dc,\"steer\");\n        if (loopCounter == 0) goto LAB_0008039c;\n        returnValue = FUN_000815de(&DAT_200708c8);\n        pointerVariable = &DAT_200708d4;\n        goto LAB_000803b2;\n      }\n    }\n  }\n  else {\n    FUN_00080164();\n    FUN_000810e8(&DAT_20070be8,\"error\");\n  }\n  return;\nLAB_0008039c:\n  loopCounter = FUN_000815b8(&DAT_200708dc,\"motor\");\n  if (loopCounter != 0) {\n    returnValue = FUN_000815de(&DAT_200708c8);\n    pointerVariable = &DAT_200708e8;\nLAB_000803b2:\n    FUN_000806f8(pointerVariable,returnValue);\n  }\n  goto LAB_00080346;\n}\n\n",
            "renaming": {
                "FUN_00080250": "control_function_00080250",
                "uVar1": "returnValue",
                "iVar2": "loopCounter",
                "puVar3": "pointerVariable",
                "auStack_1c": "localArray"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_000810c4",
                "FUN_00081472",
                "FUN_000815b8",
                "FUN_00081248",
                "FUN_000806f8",
                "FUN_00081214",
                "FUN_00080164",
                "FUN_000810e8",
                "FUN_00080f08",
                "FUN_00081276",
                "FUN_00081560",
                "FUN_00081014",
                "FUN_00081624",
                "thunk_FUN_0008113a",
                "FUN_000815de",
                "FUN_0008117a",
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000803fc": {
            "entrypoint": "0x000803fc",
            "current_name": "initialize_channel_000803fc",
            "code": "\nvoid initializeChannel_000803fc(int channelData,uint channelIndex,undefined4 param3Value,uint param4Value)\n\n{\n  undefined4 tempReg4;\n  undefined4 linkRegister;\n  undefined8 combinedParams;\n  \n  combinedParams = CONCAT44(channelIndex,channelData);\n  FUN_00080aa8(param3Value);\n  FUN_00080b2c(channelData,channelIndex,0xc002);\n  FUN_00080b90(channelData,channelIndex,0xa41);\n  *(int *)((param4Value >> 5) * 4 + -0x1fff1f00) = 1 << (param4Value & 0x1f);\n  *(undefined4 *)(channelData + channelIndex * 0x40 + 0x24) = 4;\n  if (2 < channelIndex) {\n    combinedParams = FUN_000816f8(\"../source/tc.c\",0x5c,\"TC_Start\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\",\n                         tempReg4,linkRegister);\n  }\n  *(undefined4 *)((int)combinedParams + (int)((ulonglong)combinedParams >> 0x20) * 0x40) = 5;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000803fc": "initialize_channel_000803fc",
                "param_1": "channelData",
                "param_2": "channelIndex",
                "param_3": "param3Value",
                "param_4": "param4Value",
                "unaff_r4": "tempReg4",
                "in_lr": "linkRegister",
                "uVar1": "combinedParams"
            },
            "calling": [
                "FUN_000806a0"
            ],
            "called": [
                "FUN_00080b90",
                "FUN_00080b2c",
                "FUN_00080aa8",
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008044c": {
            "entrypoint": "0x0008044c",
            "current_name": "update_flag_0008044c",
            "code": "\nvoid updateFlag_0008044c(int index,int array,int offset)\n\n{\n  uint limit;\n  int offset2;\n  \n  offset = offset * 0x40;\n  if (((&DAT_200708f1)[index] & 0x80) == 0) {\n    offset2 = index * 0xc;\n    if (((char)(&DAT_200708f1)[index] + offset2 < (int)(uint)DAT_200708f0) &&\n       ((int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + offset2) * 8] << 0x19) < 0\n       )) {\n      FUN_00081014((&DAT_200708f8)[(offset2 + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,0);\n    }\n  }\n  else {\n    *(uint *)(array + offset) = *(uint *)(array + offset) | 4;\n  }\n  limit = (uint)DAT_200708f0;\n  (&DAT_200708f1)[index] = (&DAT_200708f1)[index] + '\\x01';\n  offset2 = index * 0xc;\n  if (((char)(&DAT_200708f1)[index] + offset2 < (int)limit) &&\n     ((char)(&DAT_200708f1)[index] < '\\f')) {\n    *(int *)(array + offset + 0x14) =\n         *(int *)(array + offset + 0x10) +\n         *(int *)(&DAT_200708fc + ((char)(&DAT_200708f1)[index] + offset2) * 8);\n    if (-1 < (int)((uint)(byte)(&DAT_200708f8)[((char)(&DAT_200708f1)[index] + offset2) * 8] << 0x19\n                  )) {\n      return;\n    }\n    FUN_00081014((&DAT_200708f8)[(offset2 + (char)(&DAT_200708f1)[index]) * 8] & 0x3f,1);\n    return;\n  }\n  array = array + offset;\n  limit = (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * 20000 >> 5;\n  if (limit <= *(int *)(array + 0x10) + 4U) {\n    limit = *(int *)(array + 0x10) + 4;\n  }\n  *(uint *)(array + 0x14) = limit;\n  (&DAT_200708f1)[index] = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008044c": "update_flag_0008044c",
                "param_1": "index",
                "param_2": "array",
                "param_3": "offset",
                "uVar1": "limit",
                "iVar2": "offset2"
            },
            "calling": [],
            "called": [
                "FUN_00081014"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000805a8": {
            "entrypoint": "0x000805a8",
            "current_name": "update_parameter_000805a8",
            "code": "\nvoid updateParameter_000805a8(byte *output)\n\n{\n  char newValue;\n  uint currentValue;\n  \n  currentValue = (uint)DAT_200708f0;\n  if (currentValue < 0x3c) {\n    newValue = DAT_200708f0 + 1;\n    *output = DAT_200708f0;\n    DAT_200708f0 = newValue;\n    *(uint *)(&DAT_200708fc + currentValue * 8) =\n         (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * 0x5dc >> 5;\n    return;\n  }\n  *output = 0xff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000805a8": "update_parameter_000805a8",
                "param_1": "output",
                "cVar1": "newValue",
                "uVar2": "currentValue"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806a0": {
            "entrypoint": "0x000806a0",
            "current_name": "process_byte_000806a0",
            "code": "\nbyte processByte_000806a0(byte *byteArray,undefined4 param2)\n\n{\n  byte result;\n  undefined4 address;\n  uint index;\n  undefined4 value;\n  int counter;\n  uint byteValue;\n  \n  if (0x3b < *byteArray) goto LAB_00080660;\n  FUN_00080f0c(param2,1,0x220,*byteArray,0x960);\n  byteValue = (uint)*byteArray;\n  result = (&DAT_200708f8)[byteValue * 8];\n  byteArray[2] = 0;\n  index = byteValue / 0xc;\n  (&DAT_200708f8)[byteValue * 8] = result & 0xc0 | (byte)param2 & 0x3f;\n  byteArray[1] = 0;\n  counter = 0;\n  do {\n    if ((int)((uint)(byte)(&DAT_200708f8)[(counter + index * 0xc) * 8] << 0x19) < 0)\n    goto LAB_00080652;\n    counter = counter + 1;\n  } while (counter != 0xc);\n  if (index == 0) {\n    address = 0x40084000;\n    value = 0x1e;\nLAB_0008064c:\n    FUN_000803fc(address,index,value,value);\n  }\n  else {\n    if (index == 1) {\n      address = 0x40084000;\n      value = 0x1f;\n      goto LAB_0008064c;\n    }\n    if (index == 2) {\n      address = 0x40084000;\n      value = 0x20;\n      goto LAB_0008064c;\n    }\n    if (index == 3) {\n      address = 0x40080000;\n      index = 2;\n      value = 0x1d;\n      goto LAB_0008064c;\n    }\n    if (index == 4) {\n      address = 0x40080000;\n      index = 0;\n      value = 0x1b;\n      goto LAB_0008064c;\n    }\n  }\nLAB_00080652:\n  (&DAT_200708f8)[(uint)*byteArray * 8] = (&DAT_200708f8)[(uint)*byteArray * 8] | 0x40;\nLAB_00080660:\n  return *byteArray;\n}\n\n",
            "renaming": {
                "FUN_000806a0": "process_byte_000806a0",
                "param_1": "byteArray",
                "param_2": "param2",
                "bVar1": "result",
                "uVar2": "address",
                "uVar3": "index",
                "uVar4": "value",
                "iVar5": "counter",
                "uVar6": "byteValue"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_000803fc",
                "FUN_00080f0c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000806f8": {
            "entrypoint": "0x000806f8",
            "current_name": "process_data_000806f8",
            "code": "\nvoid processData_000806f8(byte *data,uint size)\n\n{\n  uint adjustedSize;\n  \n  if ((int)size < 0x220) {\n    adjustedSize = size;\n    if (0xb3 < (int)size) {\n      adjustedSize = 0xb4;\n    }\n    size = FUN_0008145c(adjustedSize & ~((int)adjustedSize >> 0x1f),0,0xb4,(0x88 - (char)data[1]) * 4,\n                           (600 - (char)data[2]) * 4,size);\n  }\n  if (*data < 0x3c) {\n    adjustedSize = (0x88 - (char)data[1]) * 4;\n    if (((int)(size + (0x88 - (char)data[1]) * -4) < 0 == SBORROW4(size,adjustedSize)) &&\n       (adjustedSize = (600 - (char)data[2]) * 4, (int)size <= (int)adjustedSize)) {\n      adjustedSize = size;\n    }\n    *(uint *)(&DAT_200708fc + (uint)*data * 8) =\n         (Elf32_Rel_ARRAY_20070000[6].r_offset / 1000000) * (adjustedSize - 2) >> 5;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000806f8": "process_data_000806f8",
                "param_1": "data",
                "param_2": "size",
                "uVar1": "adjustedSize"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080164"
            ],
            "called": [
                "FUN_0008145c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008073a": {
            "entrypoint": "0x0008073a",
            "current_name": "FUNC_0008073a",
            "code": "\nvoid FUNC_0008073a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008073a": "FUNC_0008073a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080748": {
            "entrypoint": "0x00080748",
            "current_name": "FUNC_00080748",
            "code": "\nvoid FUNC_00080748(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080748": "FUNC_00080748"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074a": {
            "entrypoint": "0x0008074a",
            "current_name": "FUNC_0008074a",
            "code": "\nvoid FUNC_0008074a(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074a": "FUNC_0008074a"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_0008074c": {
            "entrypoint": "0x0008074c",
            "current_name": "FUNC_0008074c",
            "code": "\nvoid FUNC_0008074c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008074c": "FUNC_0008074c"
            },
            "calling": [
                "FUN_00080970"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080774": {
            "entrypoint": "0x00080774",
            "current_name": "initialize_system_00080774",
            "code": "\n\n\nvoid initializeSystem_00080774(void)\n\n{\n  int iterationCount;\n  int nextIterationCount;\n  \n  FUN_00080b98();\n  _DAT_e000e014 = Elf32_Rel_ARRAY_20070000[6].r_offset / 1000 - 1;\n  DAT_e000ed23 = 0xf0;\n  _DAT_e000e018 = 0;\n  _DAT_e000e010 = 7;\n  FUN_00081778();\n  iterationCount = 0;\n  do {\n    nextIterationCount = iterationCount + 1;\n    FUN_00081014(iterationCount,0);\n    iterationCount = nextIterationCount;\n  } while (nextIterationCount != 0x4f);\n  _DAT_400e0ea0 = 0xffffffff;\n  _DAT_400e10a0 = 0xffffffff;\n  _DAT_400e12a0 = 0xffffffff;\n  _DAT_400e14a0 = 0xffffffff;\n  FUN_00080a30(0x400e0e00,1,0x300,0);\n  FUN_00081014(0,1);\n  FUN_00080a30(0x400e0e00,1,0xc00,0);\n  FUN_00080a30(0x400e0e00,1,0x3000,0);\n  FUN_00080a30(0x400e1400,2,0x30,0);\n  FUN_00080a30(0x400e1000,1,0xc00,0);\n  FUN_00080a30(0x400e0e00,1,3,0);\n  FUN_00080a30(0x400e1000,1,0xc000,0);\n  FUN_00080aa8(0x25);\n  FUN_00080c98(0x400c0000,Elf32_Rel_ARRAY_20070000[6].r_offset,20000000,0xc);\n  FUN_00080d3e(0x400c0000,0,0x300000,1);\n  FUN_00080d30(0x400c0000,0,0);\n  FUN_00080d6a(0x400c0000,0xffffffff);\n  FUN_00080d62(0x400c0000);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080774": "initialize_system_00080774",
                "iVar1": "iterationCount",
                "iVar2": "nextIterationCount"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_00080d3e",
                "FUN_00081778",
                "FUN_00081014",
                "FUN_00080c98",
                "FUN_00080b98",
                "FUN_00080a30",
                "FUN_00080d30",
                "FUN_00080aa8",
                "FUN_00080d6a",
                "FUN_00080d62"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008089c": {
            "entrypoint": "0x0008089c",
            "current_name": "initialize_components_0008089c",
            "code": "\nvoid initializeComponents_0008089c(undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  FUN_000811b0(&DAT_20070c0c);\n  FUN_000811b0(&DAT_20070b60);\n  FUN_00081348(&DAT_20070be8,0x400e0800,8,8,&DAT_20070c0c,&DAT_20070b60,arg3);\n  FUN_000811b0(&DAT_20070e6c);\n  FUN_000811b0(&DAT_20070ef4);\n  FUN_000811b0(&DAT_20070f7c);\n  FUN_000811b0(&DAT_20070ad8);\n  FUN_000811b0(&DAT_20070d0c);\n  FUN_000811b0(&DAT_20070d94);\n  FUN_00081438(&DAT_20070c94,0x40098000,0x11,0x11,&DAT_20070e6c,&DAT_20070ad8);\n  FUN_00081438(&DAT_20070cbc,0x4009c000,0x12,0x12,&DAT_20070ef4,&DAT_20070d0c);\n  FUN_00081438(&DAT_20070ce4,0x400a4000,0x14,0x14,&DAT_20070f7c,&DAT_20070d94);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008089c": "initialize_components_0008089c",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3"
            },
            "calling": [],
            "called": [
                "FUN_000811b0",
                "FUN_00081348",
                "FUN_00081438"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080970": {
            "entrypoint": "0x00080970",
            "current_name": "check_data_validity_00080970",
            "code": "\nvoid checkDataValidity_00080970(void)\n\n{\n  int result;\n  \n  result = FUN_00081248(&DAT_20070be8);\n  if (result != 0) {\n    FUNC_0008073a();\n  }\n  result = FUN_00081248(&DAT_20070c94);\n  if (result != 0) {\n    FUNC_00080748();\n  }\n  result = FUN_00081248(&DAT_20070cbc);\n  if (result != 0) {\n    FUNC_0008074a();\n  }\n  result = FUN_00081248(&DAT_20070ce4);\n  if (result != 0) {\n    FUNC_0008074c();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080970": "check_data_validity_00080970",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [
                "FUN_0008074a",
                "FUN_0008073a",
                "FUN_00081248",
                "FUN_00080748",
                "FUN_0008074c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809be": {
            "entrypoint": "0x000809be",
            "current_name": "update_parameter_000809be",
            "code": "\nvoid updateParameter_000809be(int baseAddress,undefined4 operationType,uint newValue)\n\n{\n  uint updatedValue;\n  \n  *(uint *)(baseAddress + 0x44) = newValue;\n  switch(operationType) {\n  case 0:\n  case 3:\n  case 4:\n  case 5:\n    return;\n  case 1:\n    updatedValue = *(uint *)(baseAddress + 0x70) & *(uint *)(baseAddress + 0x70) & ~newValue;\n    break;\n  case 2:\n    updatedValue = *(uint *)(baseAddress + 0x70) | newValue;\n    break;\n  default:\n    goto switchD_000809c4_caseD_6;\n  }\n  *(uint *)(baseAddress + 0x70) = updatedValue;\nswitchD_000809c4_caseD_6:\n  *(uint *)(baseAddress + 4) = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809be": "update_parameter_000809be",
                "param_1": "baseAddress",
                "param_2": "operationType",
                "param_3": "newValue",
                "uVar1": "updatedValue"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000809e4": {
            "entrypoint": "0x000809e4",
            "current_name": "initialize_data_000809e4",
            "code": "\nvoid initializeData_000809e4(undefined4 *dataPtr,undefined4 newValue,uint flags)\n\n{\n  bool isNegativeFlag;\n  \n  isNegativeFlag = (int)(flags << 0x1f) < 0;\n  element1 = newValue;\n  if (isNegativeFlag) {\n    element2 = newValue;\n  }\n  if (!isNegativeFlag) {\n    element3 = newValue;\n  }\n  isNegativeFlag = (flags & 10) != 0;\n  if (isNegativeFlag) {\n    element4 = newValue;\n  }\n  if (!isNegativeFlag) {\n    element5 = newValue;\n  }\n  if (((int)(flags << 0x1e) < 0) || ((int)(flags << 0x1c) < 0)) {\n    element6 = newValue;\n  }\n  element7 = newValue;\n  *dataPtr = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000809e4": "initialize_data_000809e4",
                "param_1": "dataPtr",
                "param_2": "newValue",
                "param_3": "flags",
                "bVar1": "isNegativeFlag",
                "param_1[0x11]": "element1",
                "param_1[0x19]": "element2",
                "param_1[0x18]": "element3",
                "param_1[8]": "element4",
                "param_1[9]": "element5",
                "param_1[0x20]": "element6",
                "param_1[5]": "element7"
            },
            "calling": [
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a0a": {
            "entrypoint": "0x00080a0a",
            "current_name": "update_param_values_00080a0a",
            "code": "\nvoid updateParamValues_00080a0a(undefined4 *paramArray,undefined4 newValue,int check1,int check2,int check3)\n\n{\n  paramArray[0x11] = newValue;\n  if (check3 == 0) {\n    paramArray[0x18] = newValue;\n  }\n  else {\n    paramArray[0x19] = newValue;\n  }\n  if (check2 == 0) {\n    paramArray[0x15] = newValue;\n  }\n  else {\n    paramArray[0x14] = newValue;\n  }\n  if (check1 == 0) {\n    paramArray[0xd] = newValue;\n  }\n  else {\n    paramArray[0xc] = newValue;\n  }\n  paramArray[4] = newValue;\n  *paramArray = newValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080a0a": "update_param_values_00080a0a",
                "param_1": "paramArray",
                "param_2": "newValue",
                "param_3": "check1",
                "param_4": "check2",
                "param_5": "check3"
            },
            "calling": [
                "FUN_00081014",
                "FUN_00080a30"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a30": {
            "entrypoint": "0x00080a30",
            "current_name": "update_param_00080a30",
            "code": "\nundefined4 updateParam_00080a30(int devicePtr,int paramType,undefined4 newValue,uint flags)\n\n{\n  bool isNegative;\n  \n  switch(paramType) {\n  case 1:\n  case 2:\n    FUN_000809be(devicePtr,paramType,newValue);\n    isNegative = (int)(flags << 0x1f) < 0;\n    *(undefined4 *)(devicePtr + 0x44) = newValue;\n    if (isNegative) {\n      *(undefined4 *)(devicePtr + 100) = newValue;\n    }\n    if (!isNegative) {\n      *(undefined4 *)(devicePtr + 0x60) = newValue;\n    }\n    break;\n  case 3:\n    FUN_000809e4(devicePtr,newValue,flags,0x809e5,devicePtr);\n    break;\n  case 4:\n  case 5:\n    FUN_00080a0a(devicePtr,newValue,paramType == 5,(flags << 0x1d) >> 0x1f,flags & 1,paramType,newValue)\n    ;\n    break;\n  default:\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080a30": "update_param_00080a30",
                "param_1": "devicePtr",
                "param_2": "paramType",
                "param_3": "newValue",
                "param_4": "flags",
                "bVar1": "isNegative"
            },
            "calling": [
                "FUN_00080f0c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080a0a",
                "FUN_000809e4",
                "FUN_000809be"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080a94": {
            "entrypoint": "0x00080a94",
            "current_name": "check_bitwise_conditions_00080a94",
            "code": "\nuint checkBitwiseConditions_00080a94(int inputValue,uint bitMask)\n\n{\n  uint result;\n  \n  result = *(uint *)(inputValue + 8) & bitMask;\n  if (result != 0) {\n    if ((bitMask & *(uint *)(inputValue + 0x18)) == 0) {\n      result = 0;\n    }\n    else {\n      result = 1;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080a94": "check_bitwise_conditions_00080a94",
                "param_1": "inputValue",
                "param_2": "bitMask",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00081014"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080aa8": {
            "entrypoint": "0x00080aa8",
            "current_name": "check_and_set_bit_00080aa8",
            "code": "\n\n\nundefined4 checkAndSetBit_00080aa8(uint value)\n\n{\n  uint bitMask;\n  \n  if (value < 0x2d) {\n    if (value < 0x20) {\n      bitMask = 1 << (value & 0xff);\n      if ((bitMask & _DAT_400e0618) != bitMask) {\n        _DAT_400e0610 = bitMask;\n      }\n    }\n    else {\n      bitMask = 1 << (value - 0x20 & 0xff);\n      if ((bitMask & _DAT_400e0708) != bitMask) {\n        _DAT_400e0700 = bitMask;\n      }\n    }\n    return 0;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00080aa8": "check_and_set_bit_00080aa8",
                "param_1": "value",
                "uVar1": "bitMask"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080f0c",
                "FUN_00080774",
                "FUN_000813dc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b2c": {
            "entrypoint": "0x00080b2c",
            "current_name": "configure_tc_00080b2c",
            "code": "\nvoid configureTC_00080b2c(undefined4 param_1,uint param_2,char *param_3)\n\n{\n  int offset;\n  int address;\n  undefined8 combinedParams;\n  \n  combinedParams = combineParams(param_2,param_1);\n  if (2 < param_2) {\n    param_3 = \"TC_Configure\";\n    combinedParams = FUN_000816f8(\"../source/tc.c\",0x40,\"TC_Configure\",\n                         \"dwChannel < (sizeof( pTc->TC_CHANNEL )/sizeof( pTc->TC_CHANNEL[0] ))\");\n  }\n  offset = (int)((ulonglong)combinedParams >> 0x20) * 0x40;\n  address = (int)combinedParams + offset;\n  *(undefined4 *)((int)combinedParams + offset) = 2;\n  *(undefined4 *)(address + 0x28) = 0xffffffff;\n  *(char **)(address + 4) = param_3;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b2c": "configure_tc_00080b2c",
                "uVar3": "combinedParams",
                "iVar1": "offset",
                "iVar2": "address",
                "CONCAT44": "combineParams"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [
                "FUN_000816f8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b90": {
            "entrypoint": "0x00080b90",
            "current_name": "set_param_value_00080b90",
            "code": "\nvoid setParamValue_00080b90(int baseAddress,int offset,undefined4 value)\n\n{\n  *(undefined4 *)(baseAddress + offset * 0x40 + 0x14) = value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b90": "set_param_value_00080b90",
                "param_1": "baseAddress",
                "param_2": "offset",
                "param_3": "value"
            },
            "calling": [
                "FUN_000803fc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080b98": {
            "entrypoint": "0x00080b98",
            "current_name": "initialize_memory_00080b98",
            "code": "\n\n\nvoid initializeMemory_00080b98(void)\n\n{\n  _DAT_400e0a00 = 0x400;\n  _DAT_400e0c00 = 0x400;\n  _DAT_400e0620 = _DAT_400e0620 << 7;\n  while (-1 < _DAT_400e0620) {\n    _DAT_400e0620 = _DAT_400e0668 << 0x1f;\n  }\n  _DAT_400e0620 = 0x1370809;\n  do {\n  } while (-1 < _DAT_400e0668 << 0xf);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0628 = 0x200d3f01;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1e);\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  _DAT_400e0630 = 0x12;\n  do {\n  } while (-1 < _DAT_400e0668 << 0x1c);\n  elfRelArray[6].r_offset = 84000000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080b98": "initialize_memory_00080b98",
                "Elf32_Rel_ARRAY_20070000": "elfRelArray"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "entry": {
            "entrypoint": "0x00080c20",
            "current_name": "entry",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00080c6a) */\n\n\nvoid entry(void)\n\n{\n  int iVar1;\n  undefined4 *puVar2;\n  \n  for (iVar1 = 0; (undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) < &DAT_200708a0\n      ; iVar1 = iVar1 + 4) {\n    *(undefined4 *)((int)&Elf32_Rel_ARRAY_20070000[0].r_offset + iVar1) =\n         *(undefined4 *)(&DAT_00085878 + iVar1);\n  }\n  for (puVar2 = &DAT_200708a0; puVar2 < (undefined4 *)0x20071248; puVar2 = puVar2 + 1) {\n    *puVar2 = 0;\n  }\n  _DAT_e000ed08 = 0x80000;\n  FUN_000815ec();\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {},
            "calling": [],
            "called": [
                "FUN_000815ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080c98": {
            "entrypoint": "0x00080c98",
            "current_name": "calculate_threshold_00080c98",
            "code": "\nundefined4 calculateThreshold_00080c98(undefined4 *threshold,uint dataSize,int blockSize,int timeInterval)\n\n{\n  uint numBlocks;\n  uint index;\n  uint thresholdTable [16];\n  \n  thresholdTable[0] = 0;\n  thresholdTable[1] = 8;\n  thresholdTable[2] = 0x10;\n  thresholdTable[3] = 0x18;\n  thresholdTable[4] = 0x40;\n  thresholdTable[5] = 0x50;\n  thresholdTable[6] = 0x60;\n  thresholdTable[7] = 0x70;\n  thresholdTable[8] = 0x200;\n  thresholdTable[9] = 0x240;\n  thresholdTable[10] = 0x280;\n  thresholdTable[11] = 0x2c0;\n  thresholdTable[12] = 0x300;\n  thresholdTable[13] = 0x340;\n  thresholdTable[14] = 0x380;\n  thresholdTable[15] = 0x3c0;\n  *threshold = 1;\n  threshold[1] = 0;\n  threshold[0x48] = 0x202;\n  threshold[0x41] = 0;\n  threshold[0x45] = 0;\n  numBlocks = dataSize / (uint)(blockSize * 2);\n  if (dataSize == blockSize * 2 * numBlocks) {\n    numBlocks = numBlocks - 1;\n  }\n  index = 0;\n  do {\n    if ((uint)(timeInterval * (int)(((ulonglong)dataSize / (ulonglong)((numBlocks + 1) * 2)) / 1000000)) <=\n        thresholdTable[index]) {\n      threshold[1] = (index & 0xf) << 0x10 | (numBlocks & 0xff) << 8 | threshold[1];\n      return 0;\n    }\n    index = index + 1;\n  } while (index != 0x10);\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080c98": "calculate_threshold_00080c98",
                "param_1": "threshold",
                "param_2": "dataSize",
                "param_3": "blockSize",
                "param_4": "timeInterval",
                "uVar1": "numBlocks",
                "uVar2": "index",
                "local_58": "thresholdTable"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d30": {
            "entrypoint": "0x00080d30",
            "current_name": "update_flags_00080d30",
            "code": "\nvoid updateFlags_00080d30(int baseAddress,uint value1,uint value2)\n\n{\n  *(uint *)(baseAddress + 4) = value1 | *(uint *)(baseAddress + 4) | (value2 & 1) << 7;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d30": "update_flags_00080d30",
                "param_1": "baseAddress",
                "param_2": "value1",
                "param_3": "value2"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d3e": {
            "entrypoint": "0x00080d3e",
            "current_name": "update_configuration_00080d3e",
            "code": "\nvoid updateConfiguration_00080d3e(int configPtr,uint param2Value,uint param3Value,uint param4Value)\n\n{\n  *(uint *)(configPtr + 4) =\n       param3Value | *(uint *)(configPtr + 4) | (param2Value & 0xf) << 0x18 | (param4Value & 3) << 0x1c;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d3e": "update_configuration_00080d3e",
                "param_1": "configPtr",
                "param_2": "param2Value",
                "param_3": "param3Value",
                "param_4": "param4Value"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d58": {
            "entrypoint": "0x00080d58",
            "current_name": "set_bit_00080d58",
            "code": "\nvoid setBit_00080d58(int baseAddress,uint bitIndex)\n\n{\n  *(int *)(baseAddress + 0x14) = 1 << (bitIndex & 0xff);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d58": "set_bit_00080d58",
                "param_1": "baseAddress",
                "param_2": "bitIndex"
            },
            "calling": [
                "FUN_00080f0c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d62": {
            "entrypoint": "0x00080d62",
            "current_name": "initialize_data_00080d62",
            "code": "\nvoid initializeData_00080d62(int data)\n\n{\n  *(undefined4 *)(data + 0x14) = 0xffff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d62": "initialize_data_00080d62",
                "param_1": "data"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080d6a": {
            "entrypoint": "0x00080d6a",
            "current_name": "set_param_value_00080d6a",
            "code": "\nvoid set_param_value_00080d6a(int ptr_to_param,undefined4 new_param_value)\n\n{\n  *(undefined4 *)(ptr_to_param + 0x28) = new_param_value;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080d6a": "set_param_value_00080d6a",
                "param_1": "ptr_to_param",
                "param_2": "new_param_value"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e80": {
            "entrypoint": "0x00080e80",
            "current_name": "initialize_program_00080e80",
            "code": "\nundefined4 initializeProgram_00080e80(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080e80": "initialize_program_00080e80"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080e88": {
            "entrypoint": "0x00080e88",
            "current_name": "calculate_sum_00080e88",
            "code": "\nint calculateSum_00080e88(int inputValue)\n\n{\n  int oldValue;\n  \n  if (DAT_20071208 == 0) {\n    DAT_20071208 = 0x20071248;\n  }\n  oldValue = DAT_20071208;\n  DAT_20071208 = inputValue + DAT_20071208;\n  return oldValue;\n}\n\n",
            "renaming": {
                "FUN_00080e88": "calculate_sum_00080e88",
                "param_1": "inputValue",
                "iVar1": "oldValue"
            },
            "calling": [
                "FUN_0008236c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eaa": {
            "entrypoint": "0x00080eaa",
            "current_name": "get_default_value_00080eaa",
            "code": "\nundefined4 get_default_value_00080eaa(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080eaa": "get_default_value_00080eaa"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eb0": {
            "entrypoint": "0x00080eb0",
            "current_name": "initialize_memory_region_00080eb0",
            "code": "\nundefined4 initializeMemoryRegion_00080eb0(undefined4 arg1,int memoryAddress)\n\n{\n  *(undefined4 *)(memoryAddress + 4) = 0x2000;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080eb0": "initialize_memory_region_00080eb0",
                "param_1": "arg1",
                "param_2": "memoryAddress"
            },
            "calling": [
                "FUN_00084494"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eba": {
            "entrypoint": "0x00080eba",
            "current_name": "initialize_program_00080eba",
            "code": "\nundefined4 initializeProgram_00080eba(void)\n\n{\n  status 1;\n}\n\n",
            "renaming": {
                "FUN_00080eba": "initialize_program_00080eba",
                "return": "status"
            },
            "calling": [
                "FUN_000844bc"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ebe": {
            "entrypoint": "0x00080ebe",
            "current_name": "initialize_00080ebe",
            "code": "\nundefined4 initialize_00080ebe(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ebe": "initialize_00080ebe"
            },
            "calling": [
                "FUN_000844e0"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec2": {
            "entrypoint": "0x00080ec2",
            "current_name": "initialize_00080ec2",
            "code": "\nundefined4 initialize_00080ec2(void)\n\n{\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00080ec2": "initialize_00080ec2"
            },
            "calling": [
                "FUN_00084508"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080ec8": {
            "entrypoint": "0x00080ec8",
            "current_name": "copy_bytes_to_memory_00080ec8",
            "code": "\n\n\nuint copyBytesToMemory_00080ec8(undefined4 param_1,int source,uint numBytes)\n\n{\n  int index;\n  \n  for (index = 0; index < (int)numBytes; index = index + 1) {\n    do {\n    } while (-1 < _DAT_400e0814 << 0x1e);\n    _DAT_400e081c = (uint)*(byte *)(source + index);\n  }\n  return numBytes & ~((int)numBytes >> 0x1f);\n}\n\n",
            "renaming": {
                "FUN_00080ec8": "copy_bytes_to_memory_00080ec8",
                "param_2": "source",
                "param_3": "numBytes",
                "iVar1": "index"
            },
            "calling": [
                "FUN_00084244"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080eec": {
            "entrypoint": "0x00080eec",
            "current_name": "exit_with_status_00080eec",
            "code": "\nvoid exitWithStatus_00080eec(undefined4 status,undefined4 unused,undefined4 unused1,undefined4 unused2)\n\n{\n  FUN_000817c8(\"Exiting with status %d.\\n\",status,unused1,unused2,unused2);\n  do {\n                    /* WARNING: Do nothing block with infinite loop */\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_00080eec": "exit_with_status_00080eec",
                "param_1": "status",
                "param_2": "unused",
                "param_3": "unused1",
                "param_4": "unused2"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_000817c8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080efc": {
            "entrypoint": "0x00080efc",
            "current_name": "FUNC_00080efc",
            "code": "\nvoid FUNC_00080efc(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080efc": "FUNC_00080efc"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080efe": {
            "entrypoint": "0x00080efe",
            "current_name": "get_error_code_00080efe",
            "code": "\nundefined4 get_error_code_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00080efe": "get_error_code_00080efe"
            },
            "calling": [
                "thunk_FUN_00080efe"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_000816d8": {
            "entrypoint": "0x00080f04",
            "current_name": "get_data_value_thunk_000816d8",
            "code": "\nundefined4 get_data_value_thunk_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "thunk_FUN_000816d8": "get_data_value_thunk_000816d8"
            },
            "calling": [
                "FUN_000811e8"
            ],
            "called": [
                "FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00080f08": {
            "entrypoint": "0x00080f08",
            "current_name": "FUNC_00080f08",
            "code": "\nvoid FUNC_00080f08(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00080f08": "FUNC_00080f08"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000801e0",
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00080f0c": {
            "entrypoint": "0x00080f0c",
            "current_name": "check_and_update_status_00080f0c",
            "code": "\n\n\nint checkAndUpdateStatus_00080f0c(int deviceIndex,int status)\n\n{\n  int result;\n  uint bitMask;\n  undefined4 switchCase;\n  uint flag;\n  byte lowerNibble;\n  byte statusByte;\n  int tempVar1;\n  int tempVar2;\n  \n  result = deviceIndex;\n  if ((&DAT_00084b50)[deviceIndex * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[deviceIndex] & 0xf) == 4) {\n      result = FUN_00080d58(0x400c0000,(&DAT_00084b5d)[deviceIndex * 0x1c]);\n    }\n    statusByte = (&DAT_20070e1c)[deviceIndex];\n    lowerNibble = statusByte & 0xf;\n    if ((lowerNibble < 3) && (statusByte != 0)) {\n      if (lowerNibble == 2) {\n        if (status == 0) {\n          return result;\n        }\n      }\n      else if (lowerNibble == 1) {\n        if (status == 2) {\n          return result;\n        }\n      }\n      else if (lowerNibble == 3) {\n        if (status == 1) {\n          return result;\n        }\n        goto LAB_00080f68;\n      }\n    }\n    if (status != 1) {\nLAB_00080f68:\n      if (status == 0) {\n        result = deviceIndex * 0x1c;\n        FUN_00080aa8(*(undefined4 *)(&DAT_00084b4c + result));\n        result = FUN_00080a30(*(undefined4 *)(&DAT_00084b44 + result),3,\n                             *(undefined4 *)(&DAT_00084b48 + result),0);\n        statusByte = (&DAT_20070e1c)[deviceIndex] & 0xf0 | 2;\n      }\n      else {\n        if (status != 2) {\n          return result;\n        }\n        result = deviceIndex * 0x1c;\n        FUN_00080aa8(*(undefined4 *)(&DAT_00084b4c + result));\n        result = FUN_00080a30(*(undefined4 *)(&DAT_00084b44 + result),3,\n                             *(undefined4 *)(&DAT_00084b48 + result),1);\n        statusByte = (&DAT_20070e1c)[deviceIndex] & 0xf0 | 1;\n      }\n      (&DAT_20070e1c)[deviceIndex] = statusByte;\n      return result;\n    }\n    tempVar1 = deviceIndex * 0x1c;\n    tempVar2 = *(int *)(&DAT_00084b44 + tempVar1);\n    if (statusByte >> 4 == 0) {\n      switchCase = 4;\n    }\n    else {\n      switchCase = 5;\n    }\n    result = FUN_00080a30(tempVar2,switchCase,*(undefined4 *)(&DAT_00084b48 + tempVar1),\n                         *(undefined4 *)(&DAT_00084b54 + tempVar1));\n    (&DAT_20070e1c)[deviceIndex] = (&DAT_20070e1c)[deviceIndex] & 0xf0 | 3;\n    if (*(int *)(tempVar2 + 0x18) == -1) {\n      bitMask = *(uint *)(&DAT_00084b4c + tempVar1);\n      if (0x2c < bitMask) {\n        return 1;\n      }\n      if (bitMask < 0x20) {\n        bitMask = 1 << (bitMask & 0xff);\n        flag = _DAT_400e0618 & bitMask;\n        if (flag == bitMask) {\n          _DAT_400e0614 = flag;\n        }\n      }\n      else {\n        bitMask = 1 << (bitMask - 0x20 & 0xff);\n        flag = _DAT_400e0708 & bitMask;\n        if (flag == bitMask) {\n          _DAT_400e0704 = flag;\n        }\n      }\n      return 0;\n    }\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00080f0c": "check_and_update_status_00080f0c",
                "param_1": "deviceIndex",
                "param_2": "status",
                "iVar1": "result",
                "uVar2": "bitMask",
                "uVar3": "switchCase",
                "uVar4": "flag",
                "bVar5": "lowerNibble",
                "bVar6": "statusByte",
                "iVar7": "tempVar1",
                "iVar8": "tempVar2"
            },
            "calling": [
                "FUN_00081014",
                "FUN_000806a0",
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080a30",
                "FUN_00080aa8",
                "FUN_00080d58"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081014": {
            "entrypoint": "0x00081014",
            "current_name": "update_data_00081014",
            "code": "\nvoid updateData_00081014(int index,int value,undefined4 param)\n\n{\n  int result;\n  undefined4 data;\n  int ptr;\n  \n  if ((&DAT_00084b50)[index * 0x1c] != '\\0') {\n    if (((&DAT_20070e1c)[index] & 0xf) == 5) {\n      FUN_00080f0c(index,1,param,5,index,value,param);\n    }\n    (&DAT_20070e1c)[index] = (&DAT_20070e1c)[index] & 0xf | (byte)(value << 4);\n    ptr = *(int *)(&DAT_00084b44 + index * 0x1c);\n    data = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n    result = FUN_00080a94(ptr,data);\n    if (result == 0) {\n      if (value != 0) {\n        *(undefined4 *)(ptr + 100) = data;\n        return;\n      }\n      *(undefined4 *)(ptr + 0x60) = data;\n      return;\n    }\n    FUN_00080a0a(ptr,data,value,0,1);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081014": "update_data_00081014",
                "param_1": "index",
                "param_2": "value",
                "param_3": "param",
                "iVar1": "result",
                "uVar2": "data",
                "iVar3": "ptr"
            },
            "calling": [
                "FUN_00080250",
                "FUN_0008044c",
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080a0a",
                "FUN_00080f0c",
                "FUN_00080a94"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810a6": {
            "entrypoint": "0x000810a6",
            "current_name": "execute_function_000810a6",
            "code": "\nvoid executeFunction_000810a6(int *functionPointer,int numParams,undefined4 param3,undefined4 param4)\n\n{\n  undefined4 result;\n  \n  if (numParams != 0) {\n    result = FUN_00082688(numParams);\n    (**(code **)(*functionPointer + 4))(functionPointer,numParams,result,*(code **)(*functionPointer + 4),param4);\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810a6": "execute_function_000810a6",
                "param_1": "functionPointer",
                "param_2": "numParams",
                "param_3": "param3",
                "param_4": "param4",
                "uVar1": "result"
            },
            "calling": [
                "FUN_000810c4",
                "FUN_000810d8",
                "FUN_000810fc",
                "FUN_000810e8"
            ],
            "called": [
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810c4": {
            "entrypoint": "0x000810c4",
            "current_name": "initialize_system_000810c4",
            "code": "\nvoid initializeSystem_000810c4(void)\n\n{\n  FUN_000810a6();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810c4": "initialize_system_000810c4"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810cc": {
            "entrypoint": "0x000810cc",
            "current_name": "execute_function_000810cc",
            "code": "\nvoid executeFunction_000810cc(undefined4 *functionPointer)\n\n{\n  (**(code **)*functionPointer)();\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810cc": "execute_function_000810cc",
                "param_1": "functionPointer"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810d8": {
            "entrypoint": "0x000810d8",
            "current_name": "initialize_data_000810d8",
            "code": "\nvoid initializeData_000810d8(undefined4 value1,undefined4 value2,undefined4 value3,undefined4 value4)\n\n{\n  FUN_000810a6(value1,&DAT_00085635,value3,value4,value4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810d8": "initialize_data_000810d8",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "value3",
                "param_4": "value4"
            },
            "calling": [
                "FUN_0008117a",
                "FUN_000810e8"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810e8": {
            "entrypoint": "0x000810e8",
            "current_name": "calculate_sum_000810e8",
            "code": "\nint calculateSum_000810e8(undefined4 inputValue)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = FUN_000810a6();\n  result2 = FUN_000810d8(inputValue);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_000810e8": "calculate_sum_000810e8",
                "param_1": "inputValue",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810a6",
                "FUN_000810d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000810fc": {
            "entrypoint": "0x000810fc",
            "current_name": "convert_number_to_base_000810fc",
            "code": "\nvoid convertNumberToBase_000810fc(undefined4 outputBuffer,uint number,uint base)\n\n{\n  char *currentChar;\n  uint quotient;\n  char *previousChar;\n  char currentDigit;\n  uint remainder;\n  char charArray [5];\n  \n  charArray[1] = 0;\n  if (base < 2) {\n    base = 10;\n  }\n  currentChar = charArray;\n  do {\n    previousChar = currentChar;\n    quotient = number / base;\n    remainder = number - base * quotient & 0xff;\n    currentDigit = (char)remainder;\n    if (remainder < 10) {\n      currentDigit = currentDigit + '0';\n    }\n    else {\n      currentDigit = currentDigit + '7';\n    }\n    *previousChar = currentDigit;\n    number = quotient;\n    currentChar = previousChar + -1;\n  } while (quotient != 0);\n  FUN_000810a6(outputBuffer,previousChar);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000810fc": "convert_number_to_base_000810fc",
                "param_1": "outputBuffer",
                "param_2": "number",
                "param_3": "base",
                "pcVar1": "currentChar",
                "uVar2": "quotient",
                "pcVar3": "previousChar",
                "cVar4": "currentDigit",
                "uVar5": "remainder",
                "local_15": "charArray"
            },
            "calling": [
                "FUN_0008113a"
            ],
            "called": [
                "FUN_000810a6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008113a": {
            "entrypoint": "0x0008113a",
            "current_name": "convert_number_to_base_0008113a",
            "code": "\nint convertNumberToBase_0008113a(undefined4 *outputBuffer,uint number,uint base,undefined4 param_4)\n\n{\n  int result;\n  int negativeFlag;\n  \n  if (base == 0) {\n    result = (**(code **)*outputBuffer)(outputBuffer,number & 0xff);\n    return result;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)number < 0) {\n      result = FUN_000810cc(outputBuffer,0x2d);\n      negativeFlag = FUN_000810fc(outputBuffer,-number,10);\n      return negativeFlag + result;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  result = FUN_000810fc(outputBuffer,number,base,param_4);\n  return result;\n}\n\n",
            "renaming": {
                "FUN_0008113a": "convert_number_to_base_0008113a",
                "param_1": "outputBuffer",
                "param_2": "number",
                "param_3": "base",
                "iVar1": "result",
                "iVar2": "negativeFlag"
            },
            "calling": [
                "thunk_FUN_0008113a",
                "FUN_0008117a"
            ],
            "called": [
                "FUN_000810cc",
                "FUN_000810fc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_0008113a": {
            "entrypoint": "0x00081176",
            "current_name": "process_number_thunk_0008113a",
            "code": "\nint process_number_thunk_0008113a(undefined4 *function_ptr,uint number,uint base,undefined4 extra_param)\n\n{\n  int result;\n  int negative_result;\n  \n  if (base == 0) {\n    result = (**(code **)*function_ptr)(function_ptr,number & 0xff);\n    return result;\n  }\n  if (base == 10) {\n    base = 10;\n    if ((int)number < 0) {\n      result = FUN_000810cc(function_ptr,0x2d);\n      negative_result = FUN_000810fc(function_ptr,-number,10);\n      return negative_result + result;\n    }\n  }\n  else {\n    base = base & 0xff;\n  }\n  result = FUN_000810fc(function_ptr,number,base,extra_param);\n  return result;\n}\n\n",
            "renaming": {
                "thunk_FUN_0008113a": "process_number_thunk_0008113a",
                "param_1": "function_ptr",
                "param_2": "number",
                "param_3": "base",
                "param_4": "extra_param",
                "iVar1": "result",
                "iVar2": "negative_result"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008117a": {
            "entrypoint": "0x0008117a",
            "current_name": "calculate_sum_0008117a",
            "code": "\nint calculate_sum_0008117a(undefined4 input_value)\n\n{\n  int result1;\n  int result2;\n  \n  result1 = FUN_0008113a();\n  result2 = FUN_000810d8(input_value);\n  return result2 + result1;\n}\n\n",
            "renaming": {
                "FUN_0008117a": "calculate_sum_0008117a",
                "param_1": "input_value",
                "iVar1": "result1",
                "iVar2": "result2"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_000810d8",
                "FUN_0008113a"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081190": {
            "entrypoint": "0x00081190",
            "current_name": "check_and_call_function_00081190",
            "code": "\nvoid check_and_call_function_00081190(void)\n\n{\n  if ((rel_array[6].r_info != 0xffffffff) &&\n     (rel_array[6].r_info = rel_array[6].r_info - 1,\n     rel_array[6].r_info == 0)) {\n    (*(code *)((int)&rel_array[0].r_offset + 1))();\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081190": "check_and_call_function_00081190",
                "Elf32_Rel_ARRAY_20070000": "rel_array"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811b0": {
            "entrypoint": "0x000811b0",
            "current_name": "initialize_data_000811b0",
            "code": "\nint initializeData_000811b0(int inputData)\n\n{\n  FUN_00081f00(inputData,0,0x80);\n  *(undefined4 *)(inputData + 0x80) = 0;\n  *(undefined4 *)(inputData + 0x84) = 0;\n  return inputData;\n}\n\n",
            "renaming": {
                "FUN_000811b0": "initialize_data_000811b0",
                "param_1": "inputData"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811ca": {
            "entrypoint": "0x000811ca",
            "current_name": "update_buffer_000811ca",
            "code": "\nvoid updateBuffer_000811ca(int bufferAddr,undefined newValue)\n\n{\n  uint updatedIndex;\n  \n  updatedIndex = *(int *)(bufferAddr + 0x80) + 1U & 0x7f;\n  if (updatedIndex != *(uint *)(bufferAddr + 0x84)) {\n    *(undefined *)(bufferAddr + *(int *)(bufferAddr + 0x80)) = newValue;\n    *(uint *)(bufferAddr + 0x80) = updatedIndex;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000811ca": "update_buffer_000811ca",
                "param_1": "bufferAddr",
                "param_2": "newValue",
                "uVar1": "updatedIndex"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000811e8": {
            "entrypoint": "0x000811e8",
            "current_name": "check_param_000811e8",
            "code": "\nint check_param_000811e8(int *param_array)\n\n{\n  int result;\n  \n  result = thunk_FUN_000816d8();\n  initial_value = result;\n  do {\n    result = (**(code **)(*param_array + 0xc))(param_array);\n    if (-1 < result) {\n      return result;\n    }\n    result = thunk_FUN_000816d8();\n  } while ((unsigned_integer)(result - initial_value) < (unsigned_integer)param_array[2]);\n  return -1;\n}\n\n",
            "renaming": {
                "FUN_000811e8": "check_param_000811e8",
                "param_1": "param_array",
                "iVar1": "result",
                "param_1[3]": "initial_value",
                "uint": "unsigned_integer"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "thunk_FUN_000816d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081214": {
            "entrypoint": "0x00081214",
            "current_name": "process_function_00081214",
            "code": "\nvoid processFunction_00081214(undefined4 input1,undefined4 input2,uint targetValue)\n\n{\n  uint returnValue;\n  \n  FUN_000814f6(input1,&DAT_00085637);\n  while ((returnValue = FUN_000811e8(input2), -1 < (int)returnValue && (returnValue != targetValue))) {\n    FUN_0008159e(input1,returnValue & 0xff);\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081214": "process_function_00081214",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "targetValue",
                "uVar1": "returnValue"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008159e",
                "FUN_000811e8",
                "FUN_000814f6"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081248": {
            "entrypoint": "0x00081248",
            "current_name": "calculate_difference_and_mask_00081248",
            "code": "\nuint calculateDifferenceAndMask_00081248(int input)\n\n{\n  return *(int *)(*(int *)(input + 0x10) + 0x80) - *(int *)(*(int *)(input + 0x10) + 0x84) &\n         0x7f;\n}\n\n",
            "renaming": {
                "FUN_00081248": "calculate_difference_and_mask_00081248",
                "param_1": "input"
            },
            "calling": [
                "FUN_00080250",
                "FUN_00080970"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081276": {
            "entrypoint": "0x00081276",
            "current_name": "get_value_from_buffer_00081276",
            "code": "\nuint getValueFromBuffer_00081276(int bufferAddress)\n\n{\n  byte valueFromBuffer;\n  int bufferPtr;\n  \n  bufferPtr = *(int *)(bufferAddress + 0x10);\n  if (*(int *)(bufferPtr + 0x80) != *(int *)(bufferPtr + 0x84)) {\n    valueFromBuffer = *(byte *)(bufferPtr + *(int *)(bufferPtr + 0x84));\n    *(uint *)(bufferPtr + 0x84) = *(int *)(bufferPtr + 0x84) + 1U & 0x7f;\n    return (uint)valueFromBuffer;\n  }\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_00081276": "get_value_from_buffer_00081276",
                "param_1": "bufferAddress",
                "bVar1": "valueFromBuffer",
                "iVar2": "bufferPtr"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000812b8": {
            "entrypoint": "0x000812b8",
            "current_name": "update_value_000812b8",
            "code": "\nundefined4 updateValue_000812b8(int input,undefined4 newValue)\n\n{\n  int ptr1;\n  uint temp;\n  \n  ptr1 = *(int *)(input + 0x14);\n  if ((*(int *)(*(int *)(input + 0x18) + 0x14) << 0x1e < 0) &&\n     (*(int *)(ptr1 + 0x84) == *(int *)(ptr1 + 0x80))) {\n    *(undefined4 *)(*(int *)(input + 0x18) + 0x1c) = newValue;\n  }\n  else {\n    temp = *(int *)(ptr1 + 0x80) + 1U & 0x8000007f;\n    if ((int)temp < 0) {\n      temp = (temp - 1 | 0xffffff80) + 1;\n    }\n    do {\n    } while (*(uint *)(ptr1 + 0x84) == temp);\n    *(char *)(ptr1 + *(int *)(ptr1 + 0x80)) = (char)newValue;\n    *(uint *)(*(int *)(input + 0x14) + 0x80) = temp;\n    *(undefined4 *)(*(int *)(input + 0x18) + 8) = 2;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000812b8": "update_value_000812b8",
                "param_1": "input",
                "param_2": "newValue",
                "iVar1": "ptr1",
                "uVar2": "temp"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081348": {
            "entrypoint": "0x00081348",
            "current_name": "initialize_function_00081348",
            "code": "\nvoid initializeFunction_00081348(undefined4 *functionParams,undefined4 param2,undefined param3,undefined4 param4,\n                 undefined4 param5,undefined4 param6)\n\n{\n  functionParams[1] = 0;\n  functionParams[2] = 1000;\n  functionParams[6] = param2;\n  *functionParams = &PTR_FUN_000812b8_1_00085650;\n  *(undefined *)(functionParams + 7) = param3;\n  functionParams[4] = param5;\n  functionParams[8] = param4;\n  functionParams[5] = param6;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081348": "initialize_function_00081348",
                "param_1": "functionParams",
                "param_2": "param2",
                "param_3": "param3",
                "param_4": "param4",
                "param_5": "param5",
                "param_6": "param6"
            },
            "calling": [
                "FUN_00081438",
                "FUN_0008089c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000813dc": {
            "entrypoint": "0x000813dc",
            "current_name": "initialize_data_000813dc",
            "code": "\nvoid initializeData_000813dc(int dataAddress,uint offset)\n\n{\n  int tempVar1;\n  undefined4 *dataPtr;\n  \n  FUN_00080aa8(*(undefined4 *)(dataAddress + 0x20));\n  dataPtr = *(undefined4 **)(dataAddress + 0x18);\n  dataPtr[0x48] = 0x202;\n  *dataPtr = 0xac;\n  dataPtr[1] = 0x800;\n  dataPtr[8] = Elf32_Rel_ARRAY_20070000[6].r_offset / offset >> 4;\n  dataPtr[3] = 0xffffffff;\n  dataPtr[2] = 0x61;\n  *(int *)(((uint)(int)(char)*(byte *)(dataAddress + 0x1c) >> 5) * 4 + -0x1fff1f00) =\n       1 << (uint)(*(byte *)(dataAddress + 0x1c) & 0x1f);\n  tempVar1 = *(int *)(dataAddress + 0x10);\n  *(undefined4 *)(tempVar1 + 0x84) = 0;\n  *(undefined4 *)(tempVar1 + 0x80) = 0;\n  tempVar1 = *(int *)(dataAddress + 0x14);\n  *(undefined4 *)(tempVar1 + 0x84) = 0;\n  *(undefined4 *)(tempVar1 + 0x80) = 0;\n  *dataPtr = 0x50;\n  return;\n}\n\n",
            "renaming": {
                "FUN_000813dc": "initialize_data_000813dc",
                "param_1": "dataAddress",
                "param_2": "offset",
                "iVar1": "tempVar1",
                "puVar2": "dataPtr"
            },
            "calling": [
                "FUN_000801e0"
            ],
            "called": [
                "FUN_00080aa8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081438": {
            "entrypoint": "0x00081438",
            "current_name": "initialize_function_00081438",
            "code": "\nundefined4 * initializeFunction_00081438(undefined4 *outputPointer,undefined4 inputValue)\n\n{\n  FUN_00081348();\n  *outputPointer = &PTR_FUN_000812b8_1_00085680;\n  outputPointer[9] = inputValue;\n  return outputPointer;\n}\n\n",
            "renaming": {
                "FUN_00081438": "initialize_function_00081438",
                "param_1": "outputPointer",
                "param_2": "inputValue"
            },
            "calling": [
                "FUN_0008089c"
            ],
            "called": [
                "FUN_00081348"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008145c": {
            "entrypoint": "0x0008145c",
            "current_name": "calculate_parameter_0008145c",
            "code": "\nint calculate_parameter_0008145c(int start_value,int initial_offset,int end_value,int start_offset,int end_offset)\n\n{\n  return (uint)((start_value - initial_offset) * (end_offset - start_offset)) / (uint)(end_value - initial_offset) + start_offset;\n}\n\n",
            "renaming": {
                "FUN_0008145c": "calculate_parameter_0008145c",
                "param_1": "start_value",
                "param_2": "initial_offset",
                "param_3": "end_value",
                "param_4": "start_offset",
                "param_5": "end_offset"
            },
            "calling": [
                "FUN_00080250",
                "FUN_000806f8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081472": {
            "entrypoint": "0x00081472",
            "current_name": "execute_function_00081472",
            "code": "\nundefined4 * execute_function_00081472(undefined4 *function_parameter)\n\n{\n  FUN_00081800(*function_parameter);\n  return function_parameter;\n}\n\n",
            "renaming": {
                "FUN_00081472": "execute_function_00081472",
                "param_1": "function_parameter"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081480": {
            "entrypoint": "0x00081480",
            "current_name": "FUNC_00081480",
            "code": "\nvoid FUNC_00081480(int *param_1)\n\n{\n  if (*param_1 != 0) {\n    FUN_00081800();\n  }\n  *param_1 = 0;\n  param_1[2] = 0;\n  param_1[1] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081480": "FUNC_00081480"
            },
            "calling": [
                "FUN_000814d0"
            ],
            "called": [
                "FUN_00081800"
            ],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081496": {
            "entrypoint": "0x00081496",
            "current_name": "update_and_check_array_element_00081496",
            "code": "\nint updateAndCheckArrayElement_00081496(int *array,int index,undefined4 value1,undefined4 value2)\n\n{\n  int result;\n  \n  result = FUN_00081f9c(*array,index + 1,value1,value2,value2);\n  if (result != 0) {\n    *array = result;\n    array[1] = index;\n    result = 1;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081496": "update_and_check_array_element_00081496",
                "param_1": "array",
                "param_2": "index",
                "param_3": "value1",
                "param_4": "value2",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814ae"
            ],
            "called": [
                "FUN_00081f9c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814ae": {
            "entrypoint": "0x000814ae",
            "current_name": "check_validity_000814ae",
            "code": "\nundefined4 checkValidity_000814ae(int *array,uint threshold)\n\n{\n  int result;\n  \n  if ((*array == 0) || ((uint)array[1] < threshold)) {\n    result = FUN_00081496(array);\n    if (result == 0) {\n      return 0;\n    }\n    if (array[2] == 0) {\n      *(undefined *)*array = 0;\n    }\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000814ae": "check_validity_000814ae",
                "param_1": "array",
                "param_2": "threshold",
                "iVar1": "result"
            },
            "calling": [
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [
                "FUN_00081496"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814d0": {
            "entrypoint": "0x000814d0",
            "current_name": "validate_and_process_000814d0",
            "code": "\nundefined4 * validate_and_process_000814d0(undefined4 *result,undefined4 input1,undefined4 input2)\n\n{\n  int validation_result;\n  \n  validation_result = FUN_000814ae(result,input2);\n  if (validation_result == 0) {\n    FUN_00081480(result);\n  }\n  else {\n    result[2] = input2;\n    FUN_000825cc(*result,input1);\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000814d0": "validate_and_process_000814d0",
                "param_1": "result",
                "param_2": "input1",
                "param_3": "input2",
                "iVar1": "validation_result"
            },
            "calling": [
                "FUN_000814f6"
            ],
            "called": [
                "FUN_00081480",
                "FUN_000814ae",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000814f6": {
            "entrypoint": "0x000814f6",
            "current_name": "init_param_with_zeros_000814f6",
            "code": "\nundefined4 * initParamWithZeros_000814f6(undefined4 *paramArray,int inputValue)\n\n{\n  undefined4 result;\n  \n  *paramArray = 0;\n  paramArray[1] = 0;\n  paramArray[2] = 0;\n  if (inputValue != 0) {\n    result = FUN_00082688(inputValue);\n    FUN_000814d0(paramArray,inputValue,result);\n  }\n  return paramArray;\n}\n\n",
            "renaming": {
                "FUN_000814f6": "init_param_with_zeros_000814f6",
                "param_1": "paramArray",
                "param_2": "inputValue",
                "uVar1": "result"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_000814d0",
                "FUN_00082688"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008151c": {
            "entrypoint": "0x0008151c",
            "current_name": "update_parameters_0008151c",
            "code": "\nvoid updateParameters_0008151c(int *sourceParams,int *newParams)\n\n{\n  if (*sourceParams != 0) {\n    if ((*newParams != 0) && ((uint)newParams[2] <= (uint)sourceParams[1])) {\n      FUN_000825cc();\n      sourceParams[2] = newParams[2];\n      goto resetParams;\n    }\n    FUN_00081800();\n  }\n  *sourceParams = *newParams;\n  sourceParams[1] = newParams[1];\n  sourceParams[2] = newParams[2];\n  *newParams = 0;\n  newParams[1] = 0;\nresetParams:\n  newParams[2] = 0;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008151c": "update_parameters_0008151c",
                "param_1": "sourceParams",
                "param_2": "newParams",
                "LAB_00081558": "resetParams",
                "(uint)param_2[2]": "(uint)newParams[2]",
                "(uint)param_1[1]": "(uint)sourceParams[1]",
                "param_1[2]": "sourceParams[2]",
                "param_1[1]": "sourceParams[1]"
            },
            "calling": [
                "FUN_00081560"
            ],
            "called": [
                "FUN_00081800",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081560": {
            "entrypoint": "0x00081560",
            "current_name": "check_and_execute_00081560",
            "code": "\nint check_and_execute_00081560(int input_value,int expected_value)\n\n{\n  if (input_value != expected_value) {\n    FUN_0008151c();\n  }\n  return input_value;\n}\n\n",
            "renaming": {
                "FUN_00081560": "check_and_execute_00081560",
                "param_1": "input_value",
                "param_2": "expected_value"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_0008151c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081570": {
            "entrypoint": "0x00081570",
            "current_name": "process_data_00081570",
            "code": "\nundefined4 process_data_00081570(int *data_array,int data_length,int offset)\n\n{\n  int result;\n  int array_offset;\n  \n  array_offset = data_array[2];\n  if (data_length == 0) {\n    return 0;\n  }\n  if (offset != 0) {\n    result = FUN_000814ae(data_array,array_offset + offset);\n    if (result == 0) {\n      return 0;\n    }\n    FUN_000825cc(*data_array + data_array[2],data_length);\n    data_array[2] = array_offset + offset;\n  }\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_00081570": "process_data_00081570",
                "param_1": "data_array",
                "param_2": "data_length",
                "param_3": "offset",
                "iVar1": "result",
                "iVar2": "array_offset"
            },
            "calling": [
                "FUN_0008159e"
            ],
            "called": [
                "FUN_000814ae",
                "FUN_000825cc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008159e": {
            "entrypoint": "0x0008159e",
            "current_name": "initialize_local_variables_0008159e",
            "code": "\nvoid initializeLocalVariables_0008159e(undefined4 arg1,undefined4 arg2,undefined4 arg3)\n\n{\n  undefined4 localVar1;\n  undefined4 localVar2;\n  \n  localVar2 = arg3;\n  FUN_00081570(arg1,&localVar1,1,0,arg1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008159e": "initialize_local_variables_0008159e",
                "param_1": "arg1",
                "param_2": "arg2",
                "param_3": "arg3",
                "local_c": "localVar1",
                "uStack_8": "localVar2"
            },
            "calling": [
                "FUN_00081214"
            ],
            "called": [
                "FUN_00081570"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815b8": {
            "entrypoint": "0x000815b8",
            "current_name": "check_if_byte_is_greater_than_one_000815b8",
            "code": "\nint checkIfByteIsGreaterThanOne_000815b8(byte **inputArray,byte *inputByte)\n\n{\n  uint convertedValue;\n  int result;\n  \n  if (inputArray[2] == (byte *)0x0) {\n    if (inputByte == (byte *)0x0) {\n      return 1;\n    }\n  }\n  else {\n    if (inputByte != (byte *)0x0) {\n      convertedValue = FUN_00082390(*inputArray);\n      goto LAB_000815d4;\n    }\n    inputByte = *inputArray;\n  }\n  convertedValue = (uint)*inputByte;\nLAB_000815d4:\n  result = 1 - convertedValue;\n  if (1 < convertedValue) {\n    result = 0;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000815b8": "check_if_byte_is_greater_than_one_000815b8",
                "param_1": "inputArray",
                "param_2": "inputByte",
                "uVar1": "convertedValue",
                "iVar2": "result"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00082390"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815de": {
            "entrypoint": "0x000815de",
            "current_name": "parse_integer_from_string_000815de",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x000827e8) */\n/* WARNING: Removing unreachable block (ram,0x000827a8) */\n/* WARNING: Removing unreachable block (ram,0x000827a0) */\n/* WARNING: Removing unreachable block (ram,0x000827da) */\n/* WARNING: Removing unreachable block (ram,0x000827ec) */\n/* WARNING: Removing unreachable block (ram,0x000827e4) */\n/* WARNING: Removing unreachable block (ram,0x000827a4) */\n/* WARNING: Removing unreachable block (ram,0x0008278a) */\n/* WARNING: Removing unreachable block (ram,0x000827c8) */\n/* WARNING: Removing unreachable block (ram,0x0008278c) */\n\nuint parse_integer_from_string_000815de(byte **input_string)\n\n{\n  byte current_byte;\n  byte is_negative;\n  uint parsed_integer;\n  byte *input_ptr;\n  uint current_byte_value;\n  byte *next_byte_ptr;\n  int difference;\n  int is_valid;\n  uint max_div_ten;\n  uint max_value;\n  \n  input_ptr = *input_string;\n  if (*input_string == (byte *)0x0) {\n    return 0;\n  }\n  do {\n    next_byte_ptr = input_ptr;\n    input_ptr = next_byte_ptr + 1;\n    current_byte_value = (uint)*next_byte_ptr;\n    current_byte = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + current_byte_value + 1);\n    is_negative = current_byte & 8;\n  } while ((current_byte & 8) != 0);\n  if (current_byte_value == 0x2d) {\n    input_ptr = next_byte_ptr + 2;\n    current_byte_value = (uint)next_byte_ptr[1];\n    is_negative = 1;\n  }\n  else if (current_byte_value == 0x2b) {\n    current_byte_value = (uint)next_byte_ptr[1];\n    input_ptr = next_byte_ptr + 2;\n  }\n  if (is_negative == 0) {\n    max_value = 0x7fffffff;\n  }\n  else {\n    max_value = 0x80000000;\n  }\n  max_div_ten = max_value / 10;\n  is_valid = 0;\n  parsed_integer = 0;\n  do {\n    current_byte = *(byte *)(Elf32_Rel_ARRAY_20070000[270].r_info + current_byte_value + 1);\n    if ((current_byte & 4) == 0) {\n      if ((current_byte & 3) == 0) {\nLAB_0008277e:\n        if (is_valid == -1) {\n          if (is_negative == 0) {\n            parsed_integer = 0x7fffffff;\n          }\n          else {\n            parsed_integer = 0x80000000;\n          }\n          *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x22;\n        }\n        else if (is_negative != 0) {\n          parsed_integer = -parsed_integer;\n        }\n        return parsed_integer;\n      }\n      if ((current_byte & 3) == 1) {\n        difference = 0x37;\n      }\n      else {\n        difference = 0x57;\n      }\n      difference = current_byte_value - difference;\n    }\n    else {\n      difference = current_byte_value - 0x30;\n    }\n    if (9 < difference) goto LAB_0008277e;\n    if (is_valid != -1) {\n      if ((max_div_ten <= parsed_integer && parsed_integer != max_div_ten) || ((parsed_integer == max_div_ten && ((int)(max_value % 10) < difference))))\n      {\n        is_valid = -1;\n      }\n      else {\n        parsed_integer = parsed_integer * 10 + difference;\n        is_valid = 1;\n      }\n    }\n    current_byte_value = (uint)*input_ptr;\n    input_ptr = input_ptr + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815de": "parse_integer_from_string_000815de",
                "param_1": "input_string",
                "bVar1": "current_byte",
                "bVar2": "is_negative",
                "uVar3": "parsed_integer",
                "pbVar4": "input_ptr",
                "uVar5": "current_byte_value",
                "pbVar6": "next_byte_ptr",
                "iVar7": "difference",
                "iVar8": "is_valid",
                "uVar9": "max_div_ten",
                "uVar10": "max_value"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000815e8": {
            "entrypoint": "0x000815e8",
            "current_name": "FUNC_000815e8",
            "code": "\nvoid FUNC_000815e8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000815e8": "FUNC_000815e8"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000815ec": {
            "entrypoint": "0x000815ec",
            "current_name": "run_main_loop_000815ec",
            "code": "\nvoid runMainLoop_000815ec(void)\n\n{\n  FUN_00081618();\n  FUN_00080774();\n  FUNC_000815e8();\n  FUNC_00080f08(1);\n  FUN_000801e0();\n  do {\n    FUN_00080250();\n    FUN_00080970();\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000815ec": "run_main_loop_000815ec"
            },
            "calling": [
                "entry"
            ],
            "called": [
                "FUN_00080250",
                "FUN_00080970",
                "FUN_000801e0",
                "FUN_000815e8",
                "FUN_00081618",
                "FUN_00080f08",
                "FUN_00080774"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081618": {
            "entrypoint": "0x00081618",
            "current_name": "initialize_memory_address_00081618",
            "code": "\n\n\nvoid initializeMemoryAddress_00081618(void)\n\n{\n  _DAT_400e1a54 = 0x8000;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081618": "initialize_memory_address_00081618"
            },
            "calling": [
                "FUN_000815ec"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081624": {
            "entrypoint": "0x00081624",
            "current_name": "calculate_result_00081624",
            "code": "\nint calculateResult_00081624(int index,int condition,int multiplier,undefined4 parameter)\n\n{\n  int result;\n  undefined4 offset;\n  \n  offset = *(undefined4 *)(&DAT_00084b48 + index * 0x1c);\n  if (condition == 0) {\n    offset = 0;\n  }\n  result = FUN_00081684(*(int *)(&DAT_00084b44 + index * 0x1c) + 0x3c,\n                       *(undefined4 *)(&DAT_00084b48 + index * 0x1c),offset,\n                       ((array3[6].r_offset / 1000000) * multiplier) / 0x12,parameter);\n  if (result != 0) {\n    result = (int)((ulonglong)(result * 18000 + 16000) /\n                 ((ulonglong)array3[6].r_offset / 1000));\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00081624": "calculate_result_00081624",
                "param_1": "index",
                "param_2": "condition",
                "param_3": "multiplier",
                "param_4": "parameter",
                "iVar1": "result",
                "uVar2": "offset",
                "Elf32_Rel_ARRAY_20070000": "array3"
            },
            "calling": [
                "FUN_00080250"
            ],
            "called": [
                "FUN_00081684"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081684": {
            "entrypoint": "0x00081684",
            "current_name": "check_bit_pattern_00081684",
            "code": "\nint check_bit_pattern_00081684(uint *bit_array,uint bit_mask,uint required_pattern,int num_iterations)\n\n{\n  int match_count;\n  \n  do {\n    if ((*bit_array & bit_mask) != required_pattern) {\n      do {\n        if ((*bit_array & bit_mask) == required_pattern) {\n          match_count = 0;\n          do {\n            if ((*bit_array & bit_mask) != required_pattern) {\n              return match_count;\n            }\n            match_count = match_count + 1;\n          } while (num_iterations != match_count);\n          return 0;\n        }\n        num_iterations = num_iterations + -1;\n      } while (num_iterations != 0);\n      return 0;\n    }\n    num_iterations = num_iterations + -1;\n  } while (num_iterations != 0);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00081684": "check_bit_pattern_00081684",
                "param_1": "bit_array",
                "param_2": "bit_mask",
                "param_3": "required_pattern",
                "param_4": "num_iterations",
                "iVar1": "match_count"
            },
            "calling": [
                "FUN_00081624"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816d8": {
            "entrypoint": "0x000816d8",
            "current_name": "get_data_000816d8",
            "code": "\nundefined4 get_data_000816d8(void)\n\n{\n  return DAT_2007120c;\n}\n\n",
            "renaming": {
                "FUN_000816d8": "get_data_000816d8"
            },
            "calling": [
                "thunk_FUN_000816d8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816ec": {
            "entrypoint": "0x000816ec",
            "current_name": "update_memory_block_000816ec",
            "code": "\nvoid updateMemoryBlock_000816ec(dword newData,dword offset,dword newValue)\n\n{\n  dword *memoryBlock;\n  uint index;\n  uint bitMask;\n  code *jumpTableFunc;\n  \n  if (Elf32_Rel_ARRAY_20070000[48].r_offset == 0) {\n    Elf32_Rel_ARRAY_20070000[48].r_offset = 0x20070184;\n  }\n  index = *(uint *)(Elf32_Rel_ARRAY_20070000[48].r_offset + 4);\n  memoryBlock = (dword *)Elf32_Rel_ARRAY_20070000[48].r_offset;\n  if (0x1f < (int)index) {\n    memoryBlock = (dword *)FUN_000817f0(400);\n    if (memoryBlock == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTableFunc)(0xffffffff);\n      return;\n    }\n    *memoryBlock = Elf32_Rel_ARRAY_20070000[48].r_offset;\n    memoryBlock[1] = 0;\n    index = 0;\n    Elf32_Rel_ARRAY_20070000[48].r_offset = (dword)memoryBlock;\n    memoryBlock[0x62] = 0;\n    memoryBlock[99] = 0;\n  }\n  bitMask = 1 << (index & 0xff);\n  memoryBlock[index + 0x22] = newData;\n  memoryBlock[0x62] = memoryBlock[0x62] | bitMask;\n  memoryBlock[index + 0x42] = newValue;\n  memoryBlock[99] = bitMask | memoryBlock[99];\n  memoryBlock[1] = index + 1;\n  memoryBlock[index + 2] = offset;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTableFunc)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000816ec": "update_memory_block_000816ec",
                "param_1": "newData",
                "param_2": "offset",
                "param_3": "newValue",
                "pdVar1": "memoryBlock",
                "uVar2": "index",
                "uVar3": "bitMask",
                "UNRECOVERED_JUMPTABLE_00": "jumpTableFunc"
            },
            "calling": [],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000816f8": {
            "entrypoint": "0x000816f8",
            "current_name": "assertion_failed_000816f8",
            "code": "\nvoid assertionFailed_000816f8(undefined4 file,undefined4 line,char *assertion,undefined4 function)\n\n{\n  undefined4 assertionText;\n  undefined4 functionName;\n  char *additionalMsg;\n  undefined8 result;\n  \n  assertionText = *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0xc);\n  if (assertion == (char *)0x0) goto LAB_0008171c;\n  functionName = function;\n  additionalMsg = \", function: \";\n  do {\n    function = file;\n    FUN_00081750(assertionText,\"assertion \\\"%s\\\" failed: file \\\"%s\\\", line %d%s%s\\n\",functionName,file,line,\n                 additionalMsg,assertion);\n    result = FUN_000836ec();\n    line = (undefined4)((ulonglong)result >> 0x20);\n    assertionText = (undefined4)result;\nLAB_0008171c:\n    assertion = \"\";\n    functionName = function;\n    additionalMsg = assertion;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000816f8": "assertion_failed_000816f8",
                "param_1": "file",
                "param_2": "line",
                "param_3": "assertion",
                "param_4": "function",
                "uVar1": "assertionText",
                "uVar2": "functionName",
                "pcVar3": "additionalMsg",
                "uVar4": "result"
            },
            "calling": [
                "FUN_000803fc",
                "FUN_00080b2c"
            ],
            "called": [
                "FUN_00081750",
                "FUN_000836ec"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081750": {
            "entrypoint": "0x00081750",
            "current_name": "process_data_00081750",
            "code": "\nvoid processData_00081750(undefined4 paramA,undefined4 paramB,undefined4 paramC,undefined4 paramD)\n\n{\n  undefined4 tempC;\n  undefined4 tempD;\n  \n  tempC = paramC;\n  tempD = paramD;\n  FUN_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,paramA,paramB,&tempC);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081750": "process_data_00081750",
                "param_1": "paramA",
                "param_2": "paramB",
                "param_3": "paramC",
                "param_4": "paramD",
                "uStack_8": "tempC",
                "uStack_4": "tempD"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081778": {
            "entrypoint": "0x00081778",
            "current_name": "execute_functions_sequentially_00081778",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00081784) */\n/* WARNING: Removing unreachable block (ram,0x00081788) */\n/* WARNING: Removing unreachable block (ram,0x000817b4) */\n\nvoid executeFunctionsSequentially_00081778(void)\n\n{\n  int iterationCount;\n  code **functionArray;\n  \n  FUNC_00085844();\n  functionArray = (code **)0x8584c;\n  iterationCount = 0;\n  do {\n    iterationCount = iterationCount + 1;\n    functionArray = functionArray + 1;\n    (**functionArray)();\n  } while (iterationCount != 4);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081778": "execute_functions_sequentially_00081778",
                "ppcVar2": "functionArray",
                "iVar1": "iterationCount"
            },
            "calling": [
                "FUN_00080774"
            ],
            "called": [
                "FUN_00080118",
                "FUN_00085844",
                "FUN_000836d8"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817c8": {
            "entrypoint": "0x000817c8",
            "current_name": "execute_function_000817c8",
            "code": "\nvoid executeFunction_000817c8(undefined4 inputParam,undefined4 stackParam1,undefined4 stackParam2,undefined4 stackParam3)\n\n{\n  undefined4 stackVar1;\n  undefined4 stackVar2;\n  undefined4 stackVar3;\n  \n  stackVar1 = stackParam1;\n  stackVar2 = stackParam2;\n  stackVar3 = stackParam3;\n  FUN_0008289c(Elf32_Rel_ARRAY_20070000[140].r_offset,\n               *(undefined4 *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 8),inputParam,&stackVar1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817c8": "execute_function_000817c8",
                "param_1": "inputParam",
                "param_2": "stackParam1",
                "param_3": "stackParam2",
                "param_4": "stackParam3",
                "uStack_c": "stackVar1",
                "uStack_8": "stackVar2",
                "uStack_4": "stackVar3"
            },
            "calling": [
                "FUN_00080eec"
            ],
            "called": [
                "FUN_0008289c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000817f0": {
            "entrypoint": "0x000817f0",
            "current_name": "update_relocation_entry_000817f0",
            "code": "\nvoid update_relocation_entry_000817f0(undefined4 arg)\n\n{\n  FUN_00081810(relocation_array[140].r_offset,arg);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000817f0": "update_relocation_entry_000817f0",
                "param_1": "arg",
                "Elf32_Rel_ARRAY_20070000": "relocation_array"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00081810"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081800": {
            "entrypoint": "0x00081800",
            "current_name": "execute_function_00081800",
            "code": "\nvoid executeFunction_00081800(undefined4 param)\n\n{\n  FUN_00083b10(relArray[140]offset,param);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081800": "execute_function_00081800",
                "param_1": "param",
                "Elf32_Rel_ARRAY_20070000": "relArray",
                ".r_offset": "offset"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_00081472",
                "FUN_00081480"
            ],
            "called": [
                "FUN_00083b10"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081810": {
            "entrypoint": "0x00081810",
            "current_name": "allocate_and_insert_memory_block_00081810",
            "code": "\n/* WARNING: Restarted to delay deadcode elimination for space: ram */\n\nint * allocate_and_insert_memory_block_00081810(undefined4 *input_ptr,uint size)\n\n{\n  dword current_info;\n  int first_offset;\n  uint current_size;\n  uint new_size;\n  int prev_info;\n  uint diff;\n  dword next_info;\n  uint info_offset;\n  int next_size;\n  undefined *block_ptr;\n  dword prev_info_ptr;\n  dword current_info_ptr;\n  int index;\n  dword *info_array_ptr;\n  uint aligned_size;\n  undefined *new_block_ptr;\n  dword *info_ptr;\n  uint uVar18;\n  \n  if (size + 0xb < 0x17) {\n    aligned_size = 0x10;\n    if (0x10 < size) goto LAB_00081876;\n  }\n  else {\n    aligned_size = size + 0xb & 0xfffffff8;\n    if (((int)aligned_size < 0) || (aligned_size < size)) {\nLAB_00081876:\n      *input_ptr = 0xc;\n      return (int *)0x0;\n    }\n  }\n  FUNC_00081f94(input_ptr);\n  current_info = Elf32_Rel_ARRAY_20070000[142].r_info;\n  if (aligned_size < 0x1f8) {\n    index = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8e].r_offset + aligned_size);\n    if ((index != aligned_size + 0x20070464) ||\n       (first_offset = index + 8, index = *(int *)(index + 0x14), first_offset != index)) {\n      prev_info = *(int *)(index + 0xc);\n      next_size = (*(uint *)(index + 4) & 0xfffffffc) + index;\n      aligned_size = *(uint *)(next_size + 4);\n      first_offset = *(int *)(index + 8);\n      *(int *)(first_offset + 0xc) = prev_info;\n      *(int *)(prev_info + 8) = first_offset;\n      *(uint *)(next_size + 4) = aligned_size | 1;\n      FUNC_00081f98(input_ptr);\n      return (int *)(index + 8);\n    }\n    uVar18 = (aligned_size >> 3) + 2;\n  }\n  else {\n    uVar18 = aligned_size >> 9;\n    if (uVar18 == 0) {\n      first_offset = 0x7e;\n      index = 0x3f;\n    }\n    else if (uVar18 < 5) {\n      index = (aligned_size >> 6) + 0x38;\n      first_offset = index * 2;\n    }\n    else if (uVar18 < 0x15) {\n      index = uVar18 + 0x5b;\n      first_offset = index * 2;\n    }\n    else if (uVar18 < 0x55) {\n      index = (aligned_size >> 0xc) + 0x6e;\n      first_offset = index * 2;\n    }\n    else if (uVar18 < 0x155) {\n      index = (aligned_size >> 0xf) + 0x77;\n      first_offset = index * 2;\n    }\n    else if (uVar18 < 0x555) {\n      index = (aligned_size >> 0x12) + 0x7c;\n      first_offset = index * 2;\n    }\n    else {\n      first_offset = 0xfc;\n      index = 0x7e;\n    }\n    for (next_info = (&Elf32_Rel_ARRAY_20070000[0x8e].r_offset)[first_offset]; first_offset * 4 + 0x20070464U != next_info\n        ; next_info = *(dword *)(next_info + 0xc)) {\n      uVar18 = *(uint *)(next_info + 4) & 0xfffffffc;\n      prev_info = uVar18 - aligned_size;\n      if (0xf < prev_info) {\n        index = index + -1;\n        break;\n      }\n      if (-1 < prev_info) {\n        first_offset = uVar18 + next_info;\n        aligned_size = *(uint *)(first_offset + 4);\n        prev_info = *(int *)(next_info + 0xc);\n        index = *(int *)(next_info + 8);\n        *(int *)(index + 0xc) = prev_info;\n        *(int *)(prev_info + 8) = index;\n        *(uint *)(first_offset + 4) = aligned_size | 1;\n        FUNC_00081f98(input_ptr);\n        return (int *)(next_info + 8);\n      }\n    }\n    uVar18 = index + 1;\n  }\n  next_info = Elf32_Rel_ARRAY_20070000[141].r_offset;\n  if (Elf32_Rel_ARRAY_20070000[142].r_info != 0x2007046c) {\n    current_size = *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4);\n    new_size = current_size & 0xfffffffc;\n    diff = new_size - aligned_size;\n    if (0xf < (int)diff) {\n      next_info = aligned_size + Elf32_Rel_ARRAY_20070000[142].r_info;\n      *(uint *)(Elf32_Rel_ARRAY_20070000[142].r_info + 4) = aligned_size | 1;\n      Elf32_Rel_ARRAY_20070000[142].r_info = next_info;\n      Elf32_Rel_ARRAY_20070000[143].r_offset = next_info;\n      *(undefined4 *)(next_info + 0xc) = 0x2007046c;\n      *(undefined4 *)(next_info + 8) = 0x2007046c;\n      *(uint *)(next_info + 4) = diff | 1;\n      *(uint *)(next_info + diff) = diff;\n      FUNC_00081f98(input_ptr);\n      return (int *)(current_info + 8);\n    }\n    Elf32_Rel_ARRAY_20070000[143].r_offset = 0x2007046c;\n    Elf32_Rel_ARRAY_20070000[142].r_info = 0x2007046c;\n    if (-1 < (int)diff) {\n      *(uint *)(new_size + current_info + 4) = *(uint *)(new_size + current_info + 4) | 1;\n      FUNC_00081f98(input_ptr);\n      return (int *)(current_info + 8);\n    }\n    if (new_size < 0x200) {\n      new_size = current_size & 0xfffffff8;\n      index = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + new_size);\n      next_info = 1 << ((int)(current_size >> 3) >> 2 & 0xffU) | Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(int *)(current_info + 8) = index;\n      *(uint *)(current_info + 0xc) = new_size + 0x20070464;\n      Elf32_Rel_ARRAY_20070000[141].r_offset = next_info;\n      *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + new_size) = current_info;\n      *(dword *)(index + 0xc) = current_info;\n    }\n    else {\n      diff = current_size >> 9;\n      if (diff < 5) {\n        first_offset = (current_size >> 6) + 0x38;\n        index = first_offset * 2;\n      }\n      else if (diff < 0x15) {\n        first_offset = diff + 0x5b;\n        index = first_offset * 2;\n      }\n      else if (diff < 0x55) {\n        first_offset = (current_size >> 0xc) + 0x6e;\n        index = first_offset * 2;\n      }\n      else if (diff < 0x155) {\n        first_offset = (current_size >> 0xf) + 0x77;\n        index = first_offset * 2;\n      }\n      else if (diff < 0x555) {\n        first_offset = (current_size >> 0x12) + 0x7c;\n        index = first_offset * 2;\n      }\n      else {\n        index = 0xfc;\n        first_offset = 0x7e;\n      }\n      next_info = index * 4 + 0x20070464;\n      prev_info_ptr = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[index];\n      if (prev_info_ptr == next_info) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (first_offset >> 2 & 0xffU);\n        current_info_ptr = prev_info_ptr;\n      }\n      else {\n        do {\n          current_info_ptr = prev_info_ptr;\n          if ((*(uint *)(prev_info_ptr + 4) & 0xfffffffc) <= new_size) break;\n          prev_info_ptr = *(dword *)(prev_info_ptr + 8);\n          current_info_ptr = prev_info_ptr;\n        } while (next_info != prev_info_ptr);\n        prev_info_ptr = *(dword *)(current_info_ptr + 0xc);\n      }\n      next_info = Elf32_Rel_ARRAY_20070000[141].r_offset;\n      *(dword *)(current_info + 0xc) = prev_info_ptr;\n      *(dword *)(current_info + 8) = current_info_ptr;\n      *(dword *)(prev_info_ptr + 8) = current_info;\n      *(dword *)(current_info_ptr + 0xc) = current_info;\n    }\n  }\n  current_info = Elf32_Rel_ARRAY_20070000[141].r_info;\n  current_size = 1 << ((int)uVar18 >> 2 & 0xffU);\n  if (current_size <= next_info) {\n    if ((next_info & current_size) == 0) {\n      uVar18 = uVar18 & 0xfffffffc;\n      do {\n        current_size = current_size << 1;\n        uVar18 = uVar18 + 4;\n      } while ((next_info & current_size) == 0);\n    }\n    do {\n      info_ptr = &Elf32_Rel_ARRAY_20070000[uVar18 + 0x8c].r_info;\n      info_array_ptr = info_ptr;\n      new_size = uVar18;\n      do {\n        for (block_ptr = (undefined *)info_array_ptr[3]; info_array_ptr != (dword *)block_ptr;\n            block_ptr = *(undefined **)(block_ptr + 0xc)) {\n          diff = *(uint *)(block_ptr + 4) & 0xfffffffc;\n          info_offset = diff - aligned_size;\n          if (0xf < (int)info_offset) {\n            first_offset = *(int *)(block_ptr + 8);\n            index = *(int *)(block_ptr + 0xc);\n            new_block_ptr = block_ptr + aligned_size;\n            *(uint *)(block_ptr + 4) = aligned_size | 1;\n            *(int *)(first_offset + 0xc) = index;\n            *(int *)(index + 8) = first_offset;\n            Elf32_Rel_ARRAY_20070000[142].r_info = (dword)new_block_ptr;\n            Elf32_Rel_ARRAY_20070000[143].r_offset = (dword)new_block_ptr;\n            *(undefined4 *)(new_block_ptr + 0xc) = 0x2007046c;\n            *(undefined4 *)(new_block_ptr + 8) = 0x2007046c;\n            *(uint *)(new_block_ptr + 4) = info_offset | 1;\n            *(uint *)(new_block_ptr + info_offset) = info_offset;\n            FUNC_00081f98(input_ptr);\n            return (int *)(block_ptr + 8);\n          }\n          if (-1 < (int)info_offset) {\n            index = *(int *)(block_ptr + 8);\n            first_offset = *(int *)(block_ptr + 0xc);\n            *(uint *)(block_ptr + diff + 4) = *(uint *)(block_ptr + diff + 4) | 1;\n            *(int *)(index + 0xc) = first_offset;\n            *(int *)(first_offset + 8) = index;\n            FUNC_00081f98(input_ptr);\n            return (int *)(block_ptr + 8);\n          }\n        }\n        new_size = new_size + 1;\n        info_array_ptr = info_array_ptr + 2;\n      } while ((new_size & 3) != 0);\n      do {\n        diff = uVar18 & 3;\n        block_ptr = (undefined *)(info_ptr + -2);\n        uVar18 = uVar18 - 1;\n        if (diff == 0) {\n          Elf32_Rel_ARRAY_20070000[141].r_offset = Elf32_Rel_ARRAY_20070000[141].r_offset & ~current_size;\n          break;\n        }\n        info_ptr = (dword *)*info_ptr;\n      } while (info_ptr == (dword *)block_ptr);\n      current_size = current_size * 2;\n      if ((Elf32_Rel_ARRAY_20070000[141].r_offset <= current_size &&\n           current_size - Elf32_Rel_ARRAY_20070000[141].r_offset != 0) || (uVar18 = new_size, current_size == 0))\n      break;\n      for (; (Elf32_Rel_ARRAY_20070000[141].r_offset & current_size) == 0; current_size = current_size << 1) {\n        uVar18 = uVar18 + 4;\n      }\n    } while( true );\n  }\n  uVar18 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  if ((aligned_size <= uVar18) &&\n     (current_size = uVar18 - aligned_size, next_info = Elf32_Rel_ARRAY_20070000[141].r_info, 0xf < (int)current_size))\n  goto LAB_00081b1a;\n  current_size = Elf32_Rel_ARRAY_20070000[141].r_info + uVar18;\n  if (Elf32_Rel_ARRAY_20070000[270].r_offset == 0xffffffff) {\n    new_size = aligned_size + DAT_20071218 + 0x10;\n  }\n  else {\n    new_size = aligned_size + DAT_20071218 + 0x100f & 0xfffff000;\n  }\n  next_info = FUN_0008236c(input_ptr,new_size);\n  if ((next_info == 0xffffffff) || ((next_info < current_size && (current_info != 0x20070464)))) {\n    uVar18 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    next_info = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\n  else {\n    diff = DAT_2007121c + new_size;\n    DAT_2007121c = diff;\n    if ((current_size == next_info) && ((current_size & 0xfff) == 0)) {\n      *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = new_size + uVar18 | 1;\n    }\n    else {\n      prev_info_ptr = next_info;\n      if (Elf32_Rel_ARRAY_20070000[270].r_offset != 0xffffffff) {\n        prev_info_ptr = Elf32_Rel_ARRAY_20070000[270].r_offset;\n        DAT_2007121c = diff + (next_info - current_size);\n      }\n      Elf32_Rel_ARRAY_20070000[270].r_offset = prev_info_ptr;\n      current_size = next_info & 7;\n      if (current_size == 0) {\n        index = 0x1000;\n      }\n      else {\n        next_info = next_info + (8 - current_size);\n        index = 0x1008 - current_size;\n      }\n      index = index - (new_size + next_info & 0xfff);\n      first_offset = FUN_0008236c(input_ptr,index);\n      if (first_offset == -1) {\n        current_size = 1;\n        index = 0;\n      }\n      else {\n        current_size = (first_offset - next_info) + index | 1;\n      }\n      diff = DAT_2007121c + index;\n      Elf32_Rel_ARRAY_20070000[141].r_info = next_info;\n      DAT_2007121c = diff;\n      *(uint *)(next_info + 4) = current_size;\n      if (current_info != 0x20070464) {\n        if (uVar18 < 0x10) {\n          *(undefined4 *)(next_info + 4) = 1;\n          uVar18 = 0;\n          goto LAB_00081b04;\n        }\n        uVar18 = uVar18 - 0xc & 0xfffffff8;\n        *(uint *)(current_info + 4) = uVar18 | *(uint *)(current_info + 4) & 1;\n        *(undefined4 *)(current_info + uVar18 + 4) = 5;\n        *(undefined4 *)(current_info + uVar18 + 8) = 5;\n        if (0xf < uVar18) {\n          FUN_00083b10(input_ptr,current_info + 8);\n          diff = DAT_2007121c;\n        }\n      }\n    }\n    if (DAT_20071214 < diff) {\n      DAT_20071214 = diff;\n    }\n    if (DAT_20071210 < diff) {\n      DAT_20071210 = diff;\n    }\n    uVar18 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n    next_info = Elf32_Rel_ARRAY_20070000[141].r_info;\n  }\nLAB_00081b04:\n  current_size = uVar18 - aligned_size;\n  if ((uVar18 < aligned_size) || ((int)current_size < 0x10)) {\n    FUNC_00081f98(input_ptr);\n    return (int *)0x0;\n  }\nLAB_00081b1a:\n  Elf32_Rel_ARRAY_20070000[141].r_info = aligned_size + next_info;\n  *(uint *)(next_info + 4) = aligned_size | 1;\n  *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = current_size | 1;\n  FUNC_00081f98(input_ptr);\n  return (int *)(next_info + 8);\n}\n\n",
            "renaming": {
                "FUN_00081810": "allocate_and_insert_memory_block_00081810",
                "param_1": "input_ptr",
                "param_2": "size",
                "dVar1": "current_info",
                "iVar2": "first_offset",
                "uVar3": "current_size",
                "uVar4": "new_size",
                "iVar5": "prev_info",
                "uVar6": "diff",
                "dVar7": "next_info",
                "uVar8": "info_offset",
                "iVar9": "next_size",
                "puVar10": "block_ptr",
                "dVar11": "prev_info_ptr",
                "dVar12": "current_info_ptr",
                "iVar13": "index",
                "pdVar14": "info_array_ptr",
                "uVar15": "aligned_size",
                "puVar16": "new_block_ptr",
                "pdVar17": "info_ptr"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00084018",
                "FUN_00083ca8",
                "FUN_000817f0"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_0008236c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081d48": {
            "entrypoint": "0x00081d48",
            "current_name": "copy_memory_00081d48",
            "code": "\nundefined4 * copyMemory_00081d48(undefined4 *dest,undefined4 *src,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *destEndPtr;\n  undefined4 *srcPtr;\n  uint tempSize;\n  uint bytesRemaining;\n  bool isRemainingBytes;\n  \n  destEndPtr = dest;\n  if ((((uint)src | (uint)dest) & 3) != 0) {\n    if (size < 8) {\n      bytesRemaining = size - 4;\n      if (3 < size) {\n        do {\n          destPtr = src;\n          srcPtr = destEndPtr;\n          isRemainingBytes = bytesRemaining != 0;\n          bytesRemaining = bytesRemaining - 1;\n          *(undefined *)srcPtr = *(undefined *)destPtr;\n          destEndPtr = (undefined4 *)((int)srcPtr + 1);\n          src = (undefined4 *)((int)destPtr + 1);\n        } while (isRemainingBytes);\n        *(undefined *)(undefined4 *)((int)srcPtr + 1) =\n             *(undefined *)(undefined4 *)((int)destPtr + 1);\n        *(undefined *)((int)srcPtr + 2) = *(undefined *)((int)destPtr + 2);\n        *(undefined *)((int)srcPtr + 3) = *(undefined *)((int)destPtr + 3);\n        return dest;\n      }\n      goto remainingBytesLoop;\n    }\n    if ((((uint)src & 3) != 0) && (((uint)dest & 3) != 0)) {\n      bytesRemaining = 4 - ((uint)dest & 3);\n      size = size - bytesRemaining;\n      destPtr = dest;\n      srcPtr = src;\n      if (((uint)dest & 1) != 0) {\n        srcPtr = (undefined4 *)((int)src + 1);\n        destPtr = (undefined4 *)((int)dest + 1);\n        *(undefined *)dest = *(undefined *)src;\n      }\n      destEndPtr = destPtr;\n      src = srcPtr;\n      if ((bytesRemaining & 2) != 0) {\n        src = (undefined4 *)((int)srcPtr + 2);\n        destEndPtr = (undefined4 *)((int)destPtr + 2);\n        *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n      }\n    }\n  }\n  while (0x3f < size) {\n    *destEndPtr = *src;\n    destEndPtr[1] = src[1];\n    destEndPtr[2] = src[2];\n    destEndPtr[3] = src[3];\n    destEndPtr[4] = src[4];\n    destEndPtr[5] = src[5];\n    destEndPtr[6] = src[6];\n    destEndPtr[7] = src[7];\n    destEndPtr[8] = src[8];\n    destEndPtr[9] = src[9];\n    destEndPtr[10] = src[10];\n    destEndPtr[0xb] = src[0xb];\n    destEndPtr[0xc] = src[0xc];\n    destEndPtr[0xd] = src[0xd];\n    destEndPtr[0xe] = src[0xe];\n    destEndPtr[0xf] = src[0xf];\n    destEndPtr = destEndPtr + 0x10;\n    src = src + 0x10;\n    size = size - 0x40;\n  }\n  tempSize = size - 0x10;\n  if (0xffffffcf < size - 0x40) {\n    do {\n      *destEndPtr = *src;\n      destEndPtr[1] = src[1];\n      destEndPtr[2] = src[2];\n      destEndPtr[3] = src[3];\n      destEndPtr = destEndPtr + 4;\n      src = src + 4;\n      isRemainingBytes = 0xf < tempSize;\n      tempSize = tempSize - 0x10;\n    } while (isRemainingBytes);\n  }\n  bytesRemaining = tempSize + 0xc;\n  srcPtr = destEndPtr;\n  destPtr = src;\n  if (0xfffffff3 < tempSize) {\n    do {\n      src = destPtr + 1;\n      *srcPtr = *destPtr;\n      isRemainingBytes = 3 < bytesRemaining;\n      bytesRemaining = bytesRemaining - 4;\n      destEndPtr = srcPtr + 1;\n      srcPtr = srcPtr + 1;\n      destPtr = src;\n    } while (isRemainingBytes);\n  }\nremainingBytesLoop:\n  if (bytesRemaining + 4 != 0) {\n    destPtr = destEndPtr;\n    srcPtr = src;\n    if ((bytesRemaining & 1) != 0) {\n      srcPtr = (undefined4 *)((int)src + 1);\n      destPtr = (undefined4 *)((int)destEndPtr + 1);\n      *(undefined *)destEndPtr = *(undefined *)src;\n    }\n    if ((bytesRemaining + 4 & 2) != 0) {\n      *(undefined2 *)destPtr = *(undefined2 *)srcPtr;\n    }\n  }\n  return dest;\n}\n\n",
            "renaming": {
                "FUN_00081d48": "copy_memory_00081d48",
                "param_1": "dest",
                "param_2": "src",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "destEndPtr",
                "puVar3": "srcPtr",
                "uVar4": "tempSize",
                "uVar5": "bytesRemaining",
                "bVar6": "isRemainingBytes",
                "LAB_00081dcc": "remainingBytesLoop"
            },
            "calling": [
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081e34": {
            "entrypoint": "0x00081e34",
            "current_name": "copy_memory_00081e34",
            "code": "\nvoid copyMemory_00081e34(undefined4 *destination,undefined4 *source,uint length)\n\n{\n  int index;\n  undefined4 *destPtr;\n  undefined4 *srcPtr;\n  undefined4 *tempPtr;\n  uint tempLength;\n  undefined *tempChar;\n  uint remaining;\n  \n  if ((source < destination) && (tempPtr = (undefined4 *)((int)source + length), destination < tempPtr)) {\n    tempChar = (undefined *)((int)destination + length);\n    index = length - 1;\n    if (length != 0) {\n      do {\n        tempPtr = (undefined4 *)((int)tempPtr + -1);\n        index = index + -1;\n        tempChar = tempChar + -1;\n        *tempChar = *(undefined *)tempPtr;\n      } while (index != -1);\n    }\n    return;\n  }\n  if (length < 0x10) {\n    if (length == 0) {\n      return;\n    }\n  }\n  else if ((((uint)destination | (uint)source) & 3) == 0) {\n    tempPtr = destination;\n    srcPtr = source;\n    do {\n      destPtr = tempPtr + 4;\n      *tempPtr = *srcPtr;\n      tempPtr[1] = srcPtr[1];\n      tempPtr[2] = srcPtr[2];\n      tempPtr[3] = srcPtr[3];\n      tempPtr = destPtr;\n      srcPtr = srcPtr + 4;\n    } while (destPtr != (undefined4 *)((int)destination + (length - 0x10 & 0xfffffff0) + 0x10));\n    index = (length - 0x10 >> 4) + 1;\n    remaining = length & 0xf;\n    source = source + index * 4;\n    destination = destination + index * 4;\n    tempLength = remaining;\n    tempPtr = destination;\n    srcPtr = source;\n    if (3 < remaining) {\n      do {\n        tempLength = tempLength - 4;\n        *tempPtr = *srcPtr;\n        tempPtr = tempPtr + 1;\n        srcPtr = srcPtr + 1;\n      } while (3 < tempLength);\n      index = (remaining - 4 & 0xfffffffc) + 4;\n      destination = (undefined4 *)((int)destination + index);\n      source = (undefined4 *)((int)source + index);\n      remaining = length & 3;\n    }\n    length = remaining;\n    if (length == 0) {\n      return;\n    }\n  }\n  tempPtr = destination;\n  do {\n    srcPtr = (undefined4 *)((int)tempPtr + 1);\n    *(undefined *)tempPtr = *(undefined *)source;\n    source = (undefined4 *)((int)source + 1);\n    tempPtr = srcPtr;\n  } while (srcPtr != (undefined4 *)(length + (int)destination));\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081e34": "copy_memory_00081e34",
                "param_1": "destination",
                "param_2": "source",
                "param_3": "length",
                "iVar1": "index",
                "puVar2": "destPtr",
                "puVar3": "srcPtr",
                "puVar4": "tempPtr",
                "uVar5": "tempLength",
                "puVar6": "tempChar",
                "uVar7": "remaining"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f00": {
            "entrypoint": "0x00081f00",
            "current_name": "fill_memory_00081f00",
            "code": "\nvoid fillMemory_00081f00(undefined4 *dest,undefined value,uint size)\n\n{\n  undefined4 *destPtr;\n  undefined4 *nextDestPtr;\n  undefined4 valuePattern;\n  uint remainingSize;\n  bool isZero;\n  \n  if (((uint)dest & 3) != 0) {\n    isZero = size == 0;\n    destPtr = dest;\n    size = size - 1;\n    if (isZero) {\n      return;\n    }\n    while( true ) {\n      dest = (undefined4 *)((int)destPtr + 1);\n      *(undefined *)destPtr = value;\n      if (((uint)dest & 3) == 0) break;\n      isZero = size == 0;\n      destPtr = dest;\n      size = size - 1;\n      if (isZero) {\n        return;\n      }\n    }\n  }\n  if (3 < size) {\n    valuePattern = concatenate(concatenateByte(value,value),concatenateByte(value,value));\n    remainingSize = size;\n    destPtr = dest;\n    if (0xf < size) {\n      remainingSize = size - 0x10;\n      do {\n        *destPtr = valuePattern;\n        destPtr[1] = valuePattern;\n        destPtr[2] = valuePattern;\n        destPtr[3] = valuePattern;\n        destPtr = destPtr + 4;\n      } while (destPtr != (undefined4 *)((int)dest + (remainingSize & 0xfffffff0) + 0x10));\n      size = size & 0xf;\n      dest = dest + ((remainingSize >> 4) + 1) * 4;\n      remainingSize = size;\n      destPtr = dest;\n      if (size < 4) goto skipLoop;\n    }\n    do {\n      size = size - 4;\n      *dest = valuePattern;\n      dest = dest + 1;\n    } while (3 < size);\n    dest = (undefined4 *)((int)destPtr + (remainingSize - 4 & 0xfffffffc) + 4);\n    size = remainingSize & 3;\n  }\nskipLoop:\n  if (size != 0) {\n    destPtr = dest;\n    do {\n      nextDestPtr = (undefined4 *)((int)destPtr + 1);\n      *(undefined *)destPtr = value;\n      destPtr = nextDestPtr;\n    } while (nextDestPtr != (undefined4 *)(size + (int)dest));\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f00": "fill_memory_00081f00",
                "param_1": "dest",
                "param_2": "value",
                "param_3": "size",
                "puVar1": "destPtr",
                "puVar2": "nextDestPtr",
                "uVar3": "valuePattern",
                "uVar4": "remainingSize",
                "bVar5": "isZero",
                "CONCAT22": "concatenate",
                "CONCAT11": "concatenateByte",
                "LAB_00081f7c": "skipLoop"
            },
            "calling": [
                "FUN_000811b0",
                "FUN_00083888"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081f94": {
            "entrypoint": "0x00081f94",
            "current_name": "FUNC_00081f94",
            "code": "\nvoid FUNC_00081f94(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f94": "FUNC_00081f94"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00083b10",
                "FUN_00081810",
                "FUN_00083a74"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f98": {
            "entrypoint": "0x00081f98",
            "current_name": "FUNC_00081f98",
            "code": "\nvoid FUNC_00081f98(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f98": "FUNC_00081f98"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00081810",
                "FUN_00083b10",
                "FUN_00083a74"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00081f9c": {
            "entrypoint": "0x00081f9c",
            "current_name": "execute_relocation_00081f9c",
            "code": "\nvoid executeRelocation_00081f9c(undefined4 param1,undefined4 param2)\n\n{\n  FUN_00081fac(Elf32_Rel_ARRAY_20070000[140].r_offset,param1,param2);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00081f9c": "execute_relocation_00081f9c",
                "param_1": "param1",
                "param_2": "param2"
            },
            "calling": [
                "FUN_00081496"
            ],
            "called": [
                "FUN_00081fac"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00081fac": {
            "entrypoint": "0x00081fac",
            "current_name": "improve_and_resize_memory_block_00081fac",
            "code": "\nint * improve_and_resize_memory_block_00081fac(undefined4 *param_address,int *memory_block,uint required_size)\n\n{\n  dword temp_var1;\n  int *new_memory_block;\n  uint temp_var2;\n  int temp_var3;\n  uint temp_var4;\n  int temp_var5;\n  int *temp_var6;\n  uint allocated_size;\n  uint aligned_size;\n  int *temp_var7;\n  \n  if (memory_block == (int *)0x0) {\n    new_memory_block = (int *)FUN_00081810(param_address,required_size);\n    return new_memory_block;\n  }\n  FUNC_00081f94();\n  temp_var4 = memory_block[-1];\n  allocated_size = temp_var4 & 0xfffffffc;\n  new_memory_block = memory_block + -2;\n  if (required_size + 0xb < 0x17) {\n    aligned_size = 0x10;\n  }\n  else {\n    aligned_size = required_size + 0xb & 0xfffffff8;\n    if ((int)aligned_size < 0) goto LAB_00082078;\n  }\n  if (aligned_size < required_size) {\nLAB_00082078:\n    *param_address = 0xc;\n    return (int *)0x0;\n  }\n  if ((int)allocated_size < (int)aligned_size) {\n    temp_var1 = (int)new_memory_block + allocated_size;\n    if (Elf32_Rel_ARRAY_20070000[141].r_info == temp_var1) {\n      temp_var2 = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n      temp_var1 = Elf32_Rel_ARRAY_20070000[141].r_info;\n      if ((int)(aligned_size + 0x10) <= (int)(temp_var2 + allocated_size)) {\n        Elf32_Rel_ARRAY_20070000[141].r_info = (int)new_memory_block + aligned_size;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (temp_var2 + allocated_size) - aligned_size | 1;\n        memory_block[-1] = aligned_size | memory_block[-1] & 1U;\n        FUNC_00081f98(param_address);\n        return memory_block;\n      }\n    }\n    else if ((*(uint *)((*(uint *)(temp_var1 + 4) & 0xfffffffe) + temp_var1 + 4) & 1) == 0) {\n      temp_var2 = *(uint *)(temp_var1 + 4) & 0xfffffffc;\n      if ((int)aligned_size <= (int)(temp_var2 + allocated_size)) {\n        temp_var5 = *(int *)(temp_var1 + 0xc);\n        temp_var3 = *(int *)(temp_var1 + 8);\n        *(int *)(temp_var3 + 0xc) = temp_var5;\n        *(int *)(temp_var5 + 8) = temp_var3;\n        allocated_size = temp_var2 + allocated_size;\n        goto LAB_00082088;\n      }\n    }\n    else {\n      temp_var2 = 0;\n      temp_var1 = 0;\n    }\n    if (-1 < (int)(temp_var4 << 0x1f)) {\n      temp_var7 = (int *)((int)new_memory_block - memory_block[-2]);\n      temp_var4 = (temp_var7[1] & 0xfffffffcU) + allocated_size;\n      if (temp_var1 != 0) {\n        if (temp_var1 == Elf32_Rel_ARRAY_20070000[141].r_info) {\n          if ((int)(aligned_size + 0x10) <= (int)(temp_var2 + temp_var4)) {\n            new_memory_block = temp_var7 + 2;\n            temp_var3 = *new_memory_block;\n            temp_var5 = temp_var7[3];\n            allocated_size = allocated_size - 4;\n            *(int *)(temp_var3 + 0xc) = temp_var5;\n            *(int *)(temp_var5 + 8) = temp_var3;\n            if (allocated_size < 0x25) {\n              temp_var6 = new_memory_block;\n              if (0x13 < allocated_size) {\n                temp_var7[2] = *memory_block;\n                temp_var7[3] = memory_block[1];\n                if (allocated_size < 0x1c) {\n                  memory_block = memory_block + 2;\n                  temp_var6 = temp_var7 + 4;\n                }\n                else {\n                  temp_var7[4] = memory_block[2];\n                  temp_var7[5] = memory_block[3];\n                  if (allocated_size == 0x24) {\n                    temp_var7[6] = memory_block[4];\n                    temp_var6 = memory_block + 5;\n                    memory_block = memory_block + 6;\n                    temp_var7[7] = *temp_var6;\n                    temp_var6 = temp_var7 + 8;\n                  }\n                  else {\n                    memory_block = memory_block + 4;\n                    temp_var6 = temp_var7 + 6;\n                  }\n                }\n              }\n              *temp_var6 = *memory_block;\n              temp_var6[1] = memory_block[1];\n              temp_var6[2] = memory_block[2];\n            }\n            else {\n              FUN_00081e34(new_memory_block,memory_block);\n            }\n            Elf32_Rel_ARRAY_20070000[141].r_info = (int)temp_var7 + aligned_size;\n            *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = (temp_var2 + temp_var4) - aligned_size | 1;\n            temp_var7[1] = aligned_size | temp_var7[1] & 1U;\n            FUNC_00081f98(param_address);\n            return new_memory_block;\n          }\n        }\n        else {\n          temp_var2 = temp_var2 + temp_var4;\n          if ((int)aligned_size <= (int)temp_var2) {\n            temp_var5 = *(int *)(temp_var1 + 0xc);\n            temp_var3 = *(int *)(temp_var1 + 8);\n            *(int *)(temp_var3 + 0xc) = temp_var5;\n            *(int *)(temp_var5 + 8) = temp_var3;\n            temp_var6 = temp_var7 + 2;\n            temp_var3 = *temp_var6;\n            temp_var5 = temp_var7[3];\n            temp_var4 = allocated_size - 4;\n            *(int *)(temp_var3 + 0xc) = temp_var5;\n            *(int *)(temp_var5 + 8) = temp_var3;\n            allocated_size = temp_var2;\n            if (temp_var4 < 0x25) {\n              new_memory_block = temp_var6;\n              if (0x13 < temp_var4) {\n                temp_var7[2] = *memory_block;\n                temp_var7[3] = memory_block[1];\n                if (temp_var4 < 0x1c) {\n                  memory_block = memory_block + 2;\n                  new_memory_block = temp_var7 + 4;\n                }\n                else {\n                  temp_var7[4] = memory_block[2];\n                  temp_var7[5] = memory_block[3];\n                  if (temp_var4 == 0x24) {\n                    temp_var7[6] = memory_block[4];\n                    new_memory_block = memory_block + 5;\n                    memory_block = memory_block + 6;\n                    temp_var7[7] = *new_memory_block;\n                    new_memory_block = temp_var7 + 8;\n                  }\n                  else {\n                    memory_block = memory_block + 4;\n                    new_memory_block = temp_var7 + 6;\n                  }\n                }\n              }\n              *new_memory_block = *memory_block;\n              new_memory_block[1] = memory_block[1];\n              new_memory_block[2] = memory_block[2];\n              temp_var4 = temp_var7[1];\n              new_memory_block = temp_var7;\n              memory_block = temp_var6;\n            }\n            else {\n              FUN_00081e34(temp_var6,memory_block);\n              temp_var4 = temp_var7[1];\n              new_memory_block = temp_var7;\n              memory_block = temp_var6;\n            }\n            goto LAB_00082088;\n          }\n        }\n      }\n      if ((int)aligned_size <= (int)temp_var4) {\n        temp_var6 = temp_var7 + 2;\n        temp_var3 = *temp_var6;\n        temp_var5 = temp_var7[3];\n        temp_var2 = allocated_size - 4;\n        *(int *)(temp_var3 + 0xc) = temp_var5;\n        *(int *)(temp_var5 + 8) = temp_var3;\n        allocated_size = temp_var4;\n        if (temp_var2 < 0x25) {\n          new_memory_block = temp_var6;\n          if (0x13 < temp_var2) {\n            temp_var7[2] = *memory_block;\n            temp_var7[3] = memory_block[1];\n            if (temp_var2 < 0x1c) {\n              memory_block = memory_block + 2;\n              new_memory_block = temp_var7 + 4;\n            }\n            else {\n              temp_var7[4] = memory_block[2];\n              temp_var7[5] = memory_block[3];\n              if (temp_var2 == 0x24) {\n                temp_var7[6] = memory_block[4];\n                new_memory_block = memory_block + 5;\n                memory_block = memory_block + 6;\n                temp_var7[7] = *new_memory_block;\n                new_memory_block = temp_var7 + 8;\n              }\n              else {\n                memory_block = memory_block + 4;\n                new_memory_block = temp_var7 + 6;\n              }\n            }\n          }\n          *new_memory_block = *memory_block;\n          new_memory_block[1] = memory_block[1];\n          new_memory_block[2] = memory_block[2];\n          temp_var4 = temp_var7[1];\n          new_memory_block = temp_var7;\n          memory_block = temp_var6;\n        }\n        else {\n          FUN_00081e34(temp_var6,memory_block);\n          temp_var4 = temp_var7[1];\n          new_memory_block = temp_var7;\n          memory_block = temp_var6;\n        }\n        goto LAB_00082088;\n      }\n    }\n    temp_var7 = (int *)FUN_00081810(param_address,required_size);\n    if (temp_var7 == (int *)0x0) goto LAB_000820a0;\n    temp_var4 = memory_block[-1];\n    if (temp_var7 + -2 != (int *)((temp_var4 & 0xfffffffe) + (int)new_memory_block)) {\n      allocated_size = allocated_size - 4;\n      if (allocated_size < 0x25) {\n        new_memory_block = memory_block;\n        temp_var6 = temp_var7;\n        if (0x13 < allocated_size) {\n          *temp_var7 = *memory_block;\n          temp_var7[1] = memory_block[1];\n          if (allocated_size < 0x1c) {\n            new_memory_block = memory_block + 2;\n            temp_var6 = temp_var7 + 2;\n          }\n          else {\n            temp_var7[2] = memory_block[2];\n            temp_var7[3] = memory_block[3];\n            if (allocated_size == 0x24) {\n              temp_var7[4] = memory_block[4];\n              temp_var7[5] = memory_block[5];\n              new_memory_block = memory_block + 6;\n              temp_var6 = temp_var7 + 6;\n            }\n            else {\n              new_memory_block = memory_block + 4;\n              temp_var6 = temp_var7 + 4;\n            }\n          }\n        }\n        *temp_var6 = *new_memory_block;\n        temp_var6[1] = new_memory_block[1];\n        temp_var6[2] = new_memory_block[2];\n      }\n      else {\n        FUN_00081e34(temp_var7,memory_block);\n      }\n      FUN_00083b10(param_address,memory_block);\n      goto LAB_000820a0;\n    }\n    allocated_size = allocated_size + (temp_var7[-1] & 0xfffffffcU);\n  }\nLAB_00082088:\n  temp_var2 = allocated_size - aligned_size;\n  temp_var7 = memory_block;\n  if (temp_var2 < 0x10) {\n    new_memory_block[1] = temp_var4 & 1 | allocated_size;\n    *(uint *)((int)new_memory_block + allocated_size + 4) = *(uint *)((int)new_memory_block + allocated_size + 4) | 1;\n  }\n  else {\n    new_memory_block[1] = temp_var4 & 1 | aligned_size;\n    *(uint *)((int)new_memory_block + aligned_size + 4) = temp_var2 | 1;\n    *(uint *)((int)new_memory_block + temp_var2 + aligned_size + 4) = *(uint *)((int)new_memory_block + temp_var2 + aligned_size + 4) | 1;\n    FUN_00083b10(param_address,(int)new_memory_block + aligned_size + 8);\n  }\nLAB_000820a0:\n  FUNC_00081f98(param_address);\n  return temp_var7;\n}\n\n",
            "renaming": {
                "FUN_00081fac": "improve_and_resize_memory_block_00081fac",
                "param_1": "param_address",
                "param_2": "memory_block",
                "param_3": "required_size",
                "dVar1": "temp_var1",
                "piVar2": "new_memory_block",
                "uVar3": "temp_var2",
                "iVar4": "temp_var3",
                "uVar5": "temp_var4",
                "iVar6": "temp_var5",
                "piVar7": "temp_var6",
                "uVar8": "allocated_size",
                "uVar9": "aligned_size",
                "piVar10": "temp_var7"
            },
            "calling": [
                "FUN_00081f9c",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00081810",
                "FUN_00083b10",
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_00081e34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008236c": {
            "entrypoint": "0x0008236c",
            "current_name": "initialize_value_0008236c",
            "code": "\nvoid initializeValue_0008236c(int *outputValue,undefined4 inputValue)\n\n{\n  int result;\n  \n  DAT_20071244 = 0;\n  result = FUN_00080e88(inputValue);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *outputValue = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008236c": "initialize_value_0008236c",
                "param_1": "outputValue",
                "param_2": "inputValue",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00081810",
                "FUN_00083a74"
            ],
            "called": [
                "FUN_00080e88"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082390": {
            "entrypoint": "0x00082390",
            "current_name": "compare_uint_arrays_00082390",
            "code": "\nint compare_uint_arrays_00082390(uint *array1,uint *array2)\n\n{\n  uint *ptr1;\n  int result;\n  uint *ptr2;\n  uint *ptr3;\n  uint value1;\n  uint byte1;\n  uint byte2;\n  uint byte3;\n  uint flag;\n  \n  if ((((uint)array1 | (uint)array2) & 7) != 0) {\n    ptr1 = array1;\n    if (((uint)array1 & 3) != 0) {\n      ptr1 = (uint *)((uint)array1 & 0xfffffffc) + 1;\n      value1 = *(uint *)((uint)array1 & 0xfffffffc);\n      ptr2 = array2;\n      if (((uint)array1 & 1) == 0) {\nLAB_00082410:\n        ptr3 = (uint *)((int)ptr2 + 1);\n        byte1 = value1 >> 0x10 & 0xff;\n        result = byte1 - *(byte *)ptr2;\n        if (result != 0) {\n          return result;\n        }\n        if (byte1 == 0) {\n          return 0;\n        }\n      }\n      else {\n        ptr3 = array2;\n        if (((uint)array1 & 2) == 0) {\n          ptr2 = (uint *)((int)array2 + 1);\n          byte1 = value1 >> 8 & 0xff;\n          result = byte1 - *(byte *)array2;\n          if (result != 0) {\n            return result;\n          }\n          if (byte1 == 0) {\n            return 0;\n          }\n          goto LAB_00082410;\n        }\n      }\n      array2 = (uint *)((int)ptr3 + 1);\n      result = (value1 >> 0x18) - (uint)*(byte *)ptr3;\n      if ((result != 0) || (value1 >> 0x18 == 0)) {\n        return result;\n      }\n    }\n    value1 = (uint)array2 & 3;\n    if (value1 != 0) {\n      array2 = (uint *)((uint)array2 & 0xfffffffc);\n      if (value1 == 2) {\n        value1 = *array2;\n        do {\n          array2 = array2 + 1;\n          byte2 = *ptr1;\n          value1 = value1 >> 0x10;\n          byte3 = byte2 + 0xfefefeff & ~byte2;\n          flag = byte3 & 0x80808080;\n          byte1 = byte2 & 0xffff;\n          if ((byte3 & 0x8080) != 0 || byte1 != value1) goto LAB_0008258e;\n          value1 = *array2;\n          byte1 = byte1 ^ byte2;\n          byte2 = value1 * 0x10000;\n          ptr1 = ptr1 + 1;\n        } while (flag == 0 && byte1 == byte2);\n      }\n      else if (value1 < 2) {\n        value1 = *array2;\n        do {\n          array2 = array2 + 1;\n          byte2 = *ptr1;\n          value1 = value1 >> 8;\n          byte3 = byte2 + 0xfefefeff & ~byte2;\n          flag = byte3 & 0x80808080;\n          byte1 = byte2 & 0xffffff;\n          if ((byte3 & 0x808080) != 0 || byte1 != value1) goto LAB_0008258e;\n          value1 = *array2;\n          byte1 = byte1 ^ byte2;\n          byte2 = value1 * 0x1000000;\n          ptr1 = ptr1 + 1;\n        } while (flag == 0 && byte1 == byte2);\n      }\n      else {\n        value1 = *array2;\n        do {\n          array2 = array2 + 1;\n          byte2 = *ptr1;\n          value1 = value1 >> 0x18;\n          byte3 = byte2 + 0xfefefeff & ~byte2;\n          flag = byte3 & 0x80808080;\n          byte1 = byte2 & 0xff;\n          if ((byte3 & 0x80) != 0 || byte1 != value1) goto LAB_0008258e;\n          value1 = *array2;\n          byte1 = byte1 ^ byte2;\n          byte2 = value1 * 0x100;\n          ptr1 = ptr1 + 1;\n        } while (flag == 0 && byte1 == byte2);\n      }\n      byte1 = byte1 << 0x18 | (byte1 >> 8 & 0xff) << 0x10 | (byte1 >> 0x10 & 0xff) << 8 |\n              byte1 >> 0x18;\n      value1 = (byte2 >> 8 & 0xff) << 0x10 | (byte2 >> 0x10 & 0xff) << 8 | byte2 >> 0x18;\n      goto LAB_0008259e;\n    }\n    array1 = ptr1;\n    ptr2 = array2;\n    if (((uint)ptr1 & 4) != 0) {\n      array1 = ptr1 + 1;\n      value1 = *ptr1;\n      ptr2 = array2 + 1;\n      byte2 = *array2;\n      flag = value1 + 0xfefefeff & ~value1 & 0x80808080;\n      if (value1 != byte2 || flag != 0) {\nLAB_0008259a:\n        byte1 = value1 << 0x18 | (value1 >> 8 & 0xff) << 0x10 | (value1 >> 0x10 & 0xff) << 8 |\n                value1 >> 0x18;\n        value1 = byte2 << 0x18 | (byte2 >> 8 & 0xff) << 0x10 | (byte2 >> 0x10 & 0xff) << 8 |\n                byte2 >> 0x18;\n        goto LAB_0008259e;\n      }\n    }\n    array2 = ptr2;\n    if (((uint)ptr2 & 4) != 0) {\n      value1 = *ptr2;\n      ptr1 = ptr2 + 1;\n      do {\n        byte1 = *array1;\n        byte2 = array1[1];\n        flag = byte1 + 0xfefefeff & ~byte1 & 0x80808080;\n        if (byte1 != value1 || flag != 0) goto LAB_0008258e;\n        byte3 = *ptr1;\n        value1 = ptr1[1];\n        flag = byte2 + 0xfefefeff & ~byte2 & 0x80808080;\n        array1 = array1 + 2;\n        ptr1 = ptr1 + 2;\n      } while (byte2 == byte3 && flag == 0);\n      byte1 = byte2 << 0x18 | (byte2 >> 8 & 0xff) << 0x10 | (byte2 >> 0x10 & 0xff) << 8 |\n              byte2 >> 0x18;\n      value1 = byte3 << 0x18 | (byte3 >> 8 & 0xff) << 0x10 | (byte3 >> 0x10 & 0xff) << 8 |\n              byte3 >> 0x18;\n      goto LAB_0008259e;\n    }\n  }\n  do {\n    value1 = *array1;\n    byte1 = array1[1];\n    byte2 = *array2;\n    byte3 = array2[1];\n    flag = value1 + 0xfefefeff & ~value1 & 0x80808080;\n    if (value1 != byte2 || flag != 0) goto LAB_0008259a;\n    flag = byte1 + 0xfefefeff & ~byte1 & 0x80808080;\n    array1 = array1 + 2;\n    array2 = array2 + 2;\n  } while (byte1 == byte3 && flag == 0);\n  byte1 = byte1 << 0x18 | (byte1 >> 8 & 0xff) << 0x10 | (byte1 >> 0x10 & 0xff) << 8 | byte1 >> 0x18;\n  value1 = byte3 << 0x18 | (byte3 >> 8 & 0xff) << 0x10 | (byte3 >> 0x10 & 0xff) << 8 | byte3 >> 0x18;\nLAB_0008259e:\n  byte2 = flag << 0x18 | (flag >> 8 & 0xff) << 0x10 | (flag >> 0x10 & 0xff) << 8 | flag >> 0x18;\n  if (byte2 != 0) {\n    byte2 = 0x18 - LZCOUNT(byte2);\n    byte1 = byte1 >> (byte2 & 0xff);\n    value1 = value1 >> (byte2 & 0xff);\n  }\n  result = 1;\n  if (byte1 <= value1) {\n    result = -(uint)(byte1 < value1);\n  }\n  return result;\nLAB_0008258e:\n  byte1 = byte1 << 0x18 | (byte1 >> 8 & 0xff) << 0x10 | (byte1 >> 0x10 & 0xff) << 8 | byte1 >> 0x18;\n  value1 = value1 << 0x18 | (value1 >> 8 & 0xff) << 0x10 | (value1 >> 0x10 & 0xff) << 8 | value1 >> 0x18;\n  goto LAB_0008259e;\n}\n\n",
            "renaming": {
                "FUN_00082390": "compare_uint_arrays_00082390",
                "param_1": "array1",
                "param_2": "array2",
                "puVar1": "ptr1",
                "iVar2": "result",
                "puVar3": "ptr2",
                "puVar4": "ptr3",
                "uVar5": "value1",
                "uVar6": "byte1",
                "uVar7": "byte2",
                "uVar8": "byte3",
                "uVar9": "flag"
            },
            "calling": [
                "FUN_000815b8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000825cc": {
            "entrypoint": "0x000825cc",
            "current_name": "copy_string_000825cc",
            "code": "\nvoid copyString_000825cc(uint *dest,uint *src)\n\n{\n  char currentChar;\n  ushort currentShort;\n  uint *srcPtr;\n  uint *srcPtr2;\n  uint currentWord;\n  uint temp;\n  uint *destPtr;\n  bool isZeroByte;\n  \n  if ((((uint)dest ^ (uint)src) & 3) != 0) {\n    do {\n      currentChar = *(char *)src;\n      *(char *)dest = currentChar;\n      src = (uint *)((int)src + 1);\n      dest = (uint *)((int)dest + 1);\n    } while (currentChar != '\\0');\n    return;\n  }\n  if (((uint)src & 3) != 0) {\n    srcPtr2 = src;\n    if (((uint)src & 1) != 0) {\n      srcPtr2 = (uint *)((int)src + 1);\n      currentChar = *(char *)src;\n      *(char *)dest = currentChar;\n      dest = (uint *)((int)dest + 1);\n      if (currentChar == '\\0') {\n        return;\n      }\n    }\n    src = srcPtr2;\n    if (((uint)srcPtr2 & 2) != 0) {\n      src = (uint *)((int)srcPtr2 + 2);\n      currentShort = *(ushort *)srcPtr2;\n      isZeroByte = (currentShort & 0xff) == 0;\n      if (isZeroByte) {\n        *(char *)dest = (char)currentShort;\n      }\n      else {\n        *(ushort *)dest = currentShort;\n        isZeroByte = (currentShort & 0xff00) == 0;\n        dest = (uint *)((int)dest + 2);\n      }\n      if (isZeroByte) {\n        return;\n      }\n    }\n  }\n  currentWord = *src;\n  srcPtr2 = src + 1;\n  destPtr = dest;\n  if (((uint)src & 4) != 0) {\n    if ((currentWord + 0xfefefeff & ~currentWord & 0x80808080) != 0) goto LAB_00082630;\n    destPtr = dest + 1;\n    *dest = currentWord;\n    srcPtr2 = src + 2;\n    currentWord = src[1];\n  }\n  while( true ) {\n    srcPtr = srcPtr2 + 1;\n    temp = *srcPtr2;\n    dest = destPtr;\n    if ((currentWord + 0xfefefeff & ~currentWord & 0x80808080) != 0) break;\n    dest = destPtr + 1;\n    *destPtr = currentWord;\n    currentWord = temp;\n    if ((temp + 0xfefefeff & ~temp & 0x80808080) != 0) break;\n    srcPtr2 = srcPtr2 + 2;\n    currentWord = *srcPtr;\n    destPtr = destPtr + 2;\n    *dest = temp;\n  }\nLAB_00082630:\n  do {\n    *(char *)dest = (char)currentWord;\n    temp = currentWord & 0xff;\n    currentWord = currentWord >> 8 | currentWord << 0x18;\n    dest = (uint *)((int)dest + 1);\n  } while (temp != 0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000825cc": "copy_string_000825cc",
                "param_1": "dest",
                "param_2": "src",
                "cVar1": "currentChar",
                "uVar2": "currentShort",
                "puVar3": "srcPtr",
                "puVar4": "srcPtr2",
                "uVar5": "currentWord",
                "uVar6": "temp",
                "puVar7": "destPtr",
                "bVar8": "isZeroByte"
            },
            "calling": [
                "FUN_0008151c",
                "FUN_000814d0",
                "FUN_00081570"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082688": {
            "entrypoint": "0x00082688",
            "current_name": "count_trailing_zeros_00082688",
            "code": "\nint countTrailingZeros_00082688(uint input)\n\n{\n  int count;\n  uint *ptr;\n  uint value;\n  bool isZero;\n  \n  ptr = (uint *)(input & 0xfffffffc);\n  count = -(input & 3);\n  value = *ptr;\n  if ((input & 3) != 0) {\n    value = value | 0xffffffffU >> ((count + 4U & 0x1f) << 3);\n  }\n  while (ptr = ptr + 1, (value + 0xfefefeff & ~value & 0x80808080) == 0) {\n    count = count + 4;\n    value = *ptr;\n  }\n  isZero = (value & 0xff) == 0;\n  if (!isZero) {\n    count = count + 1;\n    isZero = (value & 0xff00) == 0;\n  }\n  if (!isZero) {\n    count = count + 1;\n    isZero = (value & 0xff0000) == 0;\n  }\n  if (!isZero) {\n    count = count + 1;\n  }\n  return count;\n}\n\n",
            "renaming": {
                "FUN_00082688": "count_trailing_zeros_00082688",
                "param_1": "input",
                "iVar1": "count",
                "puVar2": "ptr",
                "uVar3": "value",
                "bVar4": "isZero"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_000814f6",
                "FUN_000810a6"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00082824": {
            "entrypoint": "0x00082824",
            "current_name": "process_data_00082824",
            "code": "\nint processData_00082824(undefined4 data,int size,int **dataArray)\n\n{\n  int *currentDataPtr;\n  int result;\n  int *currentSizePtr;\n  uint count;\n  undefined4 *currentPtr;\n  uint currentValue;\n  uint loopCounter;\n  \n  if (-1 < *(int *)(size + 100) << 0x12) {\n    result = FUN_00083ca8();\n    dataArray[2] = (int *)0x0;\n    dataArray[1] = (int *)0x0;\n    return result;\n  }\n  currentSizePtr = dataArray[2];\n  currentDataPtr = *dataArray;\n  while (currentSizePtr != (int *)0x0) {\n    currentValue = currentDataPtr[1];\n    loopCounter = currentValue >> 2;\n    if (loopCounter != 0) {\n      currentPtr = (undefined4 *)(*currentDataPtr + -4);\n      count = 0;\n      do {\n        currentPtr = currentPtr + 1;\n        result = FUN_000839b4(data,*currentPtr,size);\n        count = count + 1;\n        if (result == -1) goto LAB_00082864;\n      } while (loopCounter != count);\n      currentSizePtr = dataArray[2];\n    }\n    currentSizePtr = (int *)((int)currentSizePtr - (currentValue & 0xfffffffc));\n    dataArray[2] = currentSizePtr;\n    currentDataPtr = currentDataPtr + 2;\n  }\n  result = 0;\nLAB_00082864:\n  dataArray[2] = (int *)0x0;\n  dataArray[1] = (int *)0x0;\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00082824": "process_data_00082824",
                "param_1": "data",
                "param_2": "size",
                "param_3": "dataArray",
                "piVar1": "currentDataPtr",
                "iVar2": "result",
                "piVar3": "currentSizePtr",
                "uVar4": "count",
                "puVar5": "currentPtr",
                "uVar6": "currentValue",
                "uVar7": "loopCounter"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_00083ca8",
                "FUN_000839b4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008289c": {
            "entrypoint": "0x0008289c",
            "current_name": "parse_formatted_string_0008289c",
            "code": "\n/* WARNING: Type propagation algorithm not settling */\n\nint parseFormattedString_0008289c(int str,int formatStr,int *******args,int **varArgs)\n\n{\n  bool isFlagMinus;\n  bool isFlagPlus;\n  bool isFlagSpace;\n  char signChar;\n  bool isFlagZero;\n  int ********formatModifiers;\n  int *intPtr;\n  int result;\n  char tempChar;\n  int *******currentArg;\n  uint digitValue;\n  int **argPtr;\n  uint flags;\n  uint ch;\n  int tempValue;\n  int ********ptempAddr;\n  int loopIndex;\n  int *******remainingArgs;\n  int *intPtr1;\n  int *******pppppppiVar20;\n  uint uVar21;\n  int *intPtr2;\n  int *******tempAddr2;\n  undefined4 tempValue2;\n  int ********strPtr;\n  bool isFlagHash;\n  longlong combinedValue;\n  int *******maxWidth;\n  int *******minWidth;\n  int **argPtrArray;\n  int totalWidth;\n  char *digits;\n  char local_a1;\n  undefined local_a0;\n  undefined local_9f;\n  int ********formatModifiersPtr;\n  int argCount;\n  int *******argPtrArrayPtr;\n  undefined argSize;\n  char tempChar2;\n  undefined local_69;\n  undefined local_68 [4];\n  int *******local_64 [16];\n  \n  if ((str != 0) && (*(int *)(str + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  flags = (uint)*(ushort *)(formatStr + 0xc);\n  if (-1 < (int)((uint)*(ushort *)(formatStr + 0xc) << 0x12)) {\n    flags = flags | 0x2000;\n    *(short *)(formatStr + 0xc) = (short)flags;\n    *(uint *)(formatStr + 100) = *(uint *)(formatStr + 100) & 0xffffdfff;\n  }\n  if (((int)(flags << 0x1c) < 0) && (*(int *)(formatStr + 0x10) != 0)) {\n    if ((flags & 0x1a) != 10) goto LAB_000828ee;\n  }\n  else {\n    result = FUN_0008356c(str,formatStr);\n    if (result != 0) {\n      return -1;\n    }\n    if ((*(ushort *)(formatStr + 0xc) & 0x1a) != 10) goto LAB_000828ee;\n  }\n  if (-1 < *(short *)(formatStr + 0xe)) {\n    result = FUN_000834f0(str,formatStr,args,varArgs);\n    return result;\n  }\nLAB_000828ee:\n  digits = (char *)0x0;\n  argPtrArrayPtr = (int *******)0x0;\n  argCount = 0;\n  totalWidth = 0;\n  formatModifiers = (int ********)local_68;\n  argPtrArray = varArgs;\n  formatModifiersPtr = (int ********)local_68;\nLAB_00082902:\n  currentArg = args;\n  if ((*(char *)args != '\\0') && (*(char *)args != '%')) {\n    do {\n      currentArg = (int *******)((int)currentArg + 1);\n      if (*(char *)currentArg == '\\0') break;\n    } while (*(char *)currentArg != '%');\n    pppppppiVar20 = (int *******)((int)currentArg - (int)args);\n    if (pppppppiVar20 != (int *******)0x0) {\n      argCount = argCount + 1;\n      argPtrArrayPtr = (int *******)((int)argPtrArrayPtr + (int)pppppppiVar20);\n      *formatModifiers = args;\n      formatModifiers[1] = pppppppiVar20;\n      if (argCount < 8) {\n        formatModifiers = formatModifiers + 2;\n      }\n      else {\n        if (argPtrArrayPtr == (int *******)0x0) {\n          totalWidth = totalWidth + (int)pppppppiVar20;\n          argCount = 0;\n          formatModifiers = (int ********)local_68;\n          goto LAB_00082952;\n        }\n        result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n        formatModifiers = (int ********)local_68;\n        if (result != 0) goto LAB_00083142;\n      }\n      totalWidth = totalWidth + (int)pppppppiVar20;\n    }\n  }\nLAB_00082952:\n  if (*(char *)currentArg != '\\0') {\n    local_a1 = '\\0';\n    ch = (uint)*(byte *)((int)currentArg + 1);\n    flags = 0;\n    isFlagZero = false;\n    isFlagPlus = false;\n    isFlagMinus = false;\n    isFlagSpace = false;\n    isFlagHash = false;\n    pppppppiVar20 = (int *******)0x0;\n    minWidth = (int *******)0xffffffff;\n    args = (int *******)((int)currentArg + 1);\nLAB_00082976:\n    args = (int *******)((int)args + 1);\nLAB_0008297a:\n    switch(ch) {\n    case 0x20:\n      goto switchD_00082984_caseD_20;\n    default:\n      if (ch != 0) {\n        maxWidth = (int *******)0x1;\n        minWidth = (int *******)0x1;\n        strPtr = (int ********)&argSize;\n        argSize = (char)ch;\n        goto LAB_00082d76;\n      }\n      goto LAB_00083134;\n    case 0x23:\n      isFlagSpace = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2a:\n      pppppppiVar20 = (int *******)*argPtrArray;\n      argPtrArray = argPtrArray + 1;\n      if ((int)pppppppiVar20 < 0) {\n        pppppppiVar20 = (int *******)-(int)pppppppiVar20;\n        goto switchD_00082984_caseD_2d;\n      }\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2b:\n      ch = (uint)*(byte *)args;\n      local_a1 = '+';\n      goto LAB_00082976;\n    case 0x2d:\nswitchD_00082984_caseD_2d:\n      flags = flags | 4;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x2e:\n      ch = (uint)*(byte *)args;\n      currentArg = (int *******)((int)args + 1);\n      if (ch == 0x2a) {\n        ch = (uint)*(byte *)((int)args + 1);\n        minWidth = (int *******)*argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        args = currentArg;\n        if ((int)minWidth < 0) {\n          minWidth = (int *******)0xffffffff;\n        }\n        goto LAB_00082976;\n      }\n      digitValue = ch - 0x30;\n      if (digitValue < 10) {\n        uVar21 = 0;\n        do {\n          args = (int *******)((int)currentArg + 1);\n          ch = (uint)*(byte *)currentArg;\n          uVar21 = digitValue + uVar21 * 10;\n          digitValue = ch - 0x30;\n          currentArg = args;\n        } while (digitValue < 10);\n        minWidth = (int *******)(uVar21 | (int)uVar21 >> 0x1f);\n      }\n      else {\n        minWidth = (int *******)0x0;\n        args = currentArg;\n      }\n      goto LAB_0008297a;\n    case 0x30:\n      flags = flags | 0x80;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x31:\n    case 0x32:\n    case 0x33:\n    case 0x34:\n    case 0x35:\n    case 0x36:\n    case 0x37:\n    case 0x38:\n    case 0x39:\n      goto switchD_00082984_caseD_31;\n    case 0x44:\n      isFlagPlus = true;\n      if (isFlagMinus == false) goto LAB_00082d8c;\nLAB_00082bfc:\n      argPtrArray = (int **)((int)argPtrArray + 7U & 0xfffffff8);\n      intPtr1 = *argPtrArray;\n      intPtr2 = argPtrArray[1];\n      argPtrArray = argPtrArray + 2;\n      goto LAB_00082c10;\n    case 0x4f:\n      isFlagPlus = true;\n      if (isFlagMinus != false) goto LAB_00082aa6;\nLAB_00082c8e:\n      result = (uint)isFlagPlus << 4;\n      tempValue = (uint)isFlagMinus << 5;\n      if ((isFlagPlus == 0) && (tempValue = (uint)isFlagHash << 6, isFlagHash != 0)) {\n        intPtr1 = (int *)(uint)*(ushort *)argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        intPtr2 = (int *)0x0;\n      }\n      else {\n        result = tempValue;\n        intPtr1 = *argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        intPtr2 = (int *)0x0;\n      }\n      break;\n    case 0x55:\n      isFlagPlus = true;\n      if (isFlagMinus != false) goto LAB_00082bc6;\nLAB_00082ce0:\n      if ((isFlagPlus) || (isFlagHash == false)) {\n        result = 1;\n        intPtr1 = *argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        intPtr2 = (int *)0x0;\n      }\n      else {\n        intPtr2 = (int *)0x0;\n        intPtr1 = (int *)(uint)*(ushort *)argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        result = 1;\n      }\n      break;\n    case 0x58:\n      digits = \"0123456789ABCDEF\";\n      if (isFlagMinus == false) goto LAB_00082efa;\nLAB_00082d1a:\n      argPtr = (int **)((int)argPtrArray + 7U & 0xfffffff8);\n      argPtrArray = argPtr + 2;\n      intPtr1 = *argPtr;\n      intPtr2 = argPtr[1];\n      goto LAB_00082d2e;\n    case 99:\n      intPtr1 = *argPtrArray;\n      argPtrArray = argPtrArray + 1;\n      maxWidth = (int *******)0x1;\n      argSize = SUB41(intPtr1,0);\n      minWidth = (int *******)0x1;\n      strPtr = (int ********)&argSize;\n      goto LAB_00082d76;\n    case 100:\n    case 0x69:\n      if (isFlagMinus != false) goto LAB_00082bfc;\nLAB_00082d8c:\n      if ((isFlagPlus == false) && (isFlagHash != false)) {\n        intPtr1 = (int *)(int)*(short *)argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        intPtr2 = (int *)((int)intPtr1 >> 0x1f);\n      }\n      else {\n        intPtr1 = *argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        intPtr2 = (int *)((int)intPtr1 >> 0x1f);\n      }\nLAB_00082c10:\n      if ((int)intPtr2 < 0) {\n        isFlagHash = intPtr1 != (int *)0x0;\n        intPtr1 = (int *)-(int)intPtr1;\n        intPtr2 = (int *)(-(int)intPtr2 - (uint)isFlagHash);\n        local_a1 = '-';\n        signChar = '-';\n        result = 1;\n        goto LAB_00082ace;\n      }\n      if (-1 < (int)minWidth) {\n        flags = flags & 0xffffff7f;\n      }\n      isFlagZero = false;\n      ch = (uint)intPtr1 | (uint)intPtr2;\n      result = 1;\n      signChar = local_a1;\n      goto joined_r0x00082adc;\n    case 0x68:\n      isFlagHash = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x6c:\n      ch = (uint)*(byte *)args;\n      if (ch == 0x6c) {\n        isFlagMinus = true;\n        ch = (uint)*(byte *)((int)args + 1);\n        args = (int *******)((int)args + 1);\n      }\n      else {\n        isFlagPlus = true;\n      }\n      goto LAB_00082976;\n    case 0x6e:\n      if (isFlagMinus == false) {\n        if (isFlagPlus == false) {\n          if (isFlagHash) {\n            intPtr1 = *argPtrArray;\n            argPtrArray = argPtrArray + 1;\n            *(short *)intPtr1 = (short)totalWidth;\n          }\n          else {\n            intPtr1 = *argPtrArray;\n            argPtrArray = argPtrArray + 1;\n            *intPtr1 = totalWidth;\n          }\n        }\n        else {\n          intPtr1 = *argPtrArray;\n          argPtrArray = argPtrArray + 1;\n          *intPtr1 = totalWidth;\n        }\n      }\n      else {\n        intPtr1 = *argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        *intPtr1 = totalWidth;\n        intPtr1[1] = totalWidth >> 0x1f;\n      }\n      goto LAB_00082902;\n    case 0x6f:\n      if (isFlagMinus == false) goto LAB_00082c8e;\nLAB_00082aa6:\n      argPtr = (int **)((int)argPtrArray + 7U & 0xfffffff8);\n      argPtrArray = argPtr + 2;\n      intPtr1 = *argPtr;\n      intPtr2 = argPtr[1];\n      result = 0;\n      break;\n    case 0x70:\n      intPtr1 = *argPtrArray;\n      argPtrArray = argPtrArray + 1;\n      local_9f = 0x78;\n      isFlagZero = true;\n      intPtr2 = (int *)0x0;\n      local_a0 = 0x30;\n      digits = \"0123456789abcdef\";\n      result = 2;\n      break;\n    case 0x71:\n      isFlagMinus = true;\n      ch = (uint)*(byte *)args;\n      goto LAB_00082976;\n    case 0x73:\n      strPtr = (int ********)*argPtrArray;\n      local_a1 = '\\0';\n      argPtrArray = argPtrArray + 1;\n      if (strPtr != (int ********)0x0) {\n        if ((int)minWidth < 0) {\n          minWidth = (int *******)FUN_00082688(strPtr);\n          currentArg = (int *******)0x0;\n          signChar = local_a1;\n        }\n        else {\n          result = FUN_000840f8(strPtr,0,minWidth);\n          signChar = local_a1;\n          if (result == 0) {\n            currentArg = (int *******)0x0;\n          }\n          else {\n            remainingArgs = (int *******)(result - (int)strPtr);\n            if ((int)minWidth <= (int)(int *******)(result - (int)strPtr)) {\n              remainingArgs = minWidth;\n            }\n            currentArg = (int *******)0x0;\n            minWidth = remainingArgs;\n          }\n        }\n        goto LAB_00082b04;\n      }\n      if ((int *******)0x5 < minWidth) {\n        minWidth = (int *******)0x6;\n      }\n      maxWidth = (int *******)((uint)minWidth & ~((int)minWidth >> 0x1f));\n      strPtr = (int ********)&UNK_00085728;\nLAB_00082d76:\n      local_a1 = '\\0';\n      currentArg = (int *******)0x0;\n      goto LAB_00082b1e;\n    case 0x75:\n      if (!isFlagMinus) goto LAB_00082ce0;\nLAB_00082bc6:\n      argPtr = (int **)((int)argPtrArray + 7U & 0xfffffff8);\n      argPtrArray = argPtr + 2;\n      intPtr1 = *argPtr;\n      intPtr2 = argPtr[1];\n      result = 1;\n      break;\n    case 0x78:\n      digits = \"0123456789abcdef\";\n      if (isFlagMinus != false) goto LAB_00082d1a;\nLAB_00082efa:\n      if ((isFlagPlus == false) && (isFlagHash != false)) {\n        intPtr2 = (int *)0x0;\n        intPtr1 = (int *)(uint)*(ushort *)argPtrArray;\n        argPtrArray = argPtrArray + 1;\n      }\n      else {\n        intPtr1 = *argPtrArray;\n        argPtrArray = argPtrArray + 1;\n        intPtr2 = (int *)0x0;\n      }\nLAB_00082d2e:\n      if ((isFlagSpace) && (((uint)intPtr1 | (uint)intPtr2) != 0)) {\n        isFlagZero = true;\n        local_a0 = 0x30;\n        result = 2;\n        local_9f = (char)ch;\n      }\n      else {\n        result = 2;\n      }\n    }\n    local_a1 = '\\0';\n    signChar = '\\0';\nLAB_00082ace:\n    if (-1 < (int)minWidth) {\n      flags = flags & 0xffffff7f;\n    }\n    ch = (uint)intPtr1 | (uint)intPtr2;\njoined_r0x00082adc:\n    combinedValue = CONCAT44(intPtr2,intPtr1);\n    currentArg = minWidth;\n    if ((ch == 0) && (minWidth == (int *******)0x0)) {\n      strPtr = (int ********)local_68;\n      if ((result != 0) || (!isFlagSpace)) goto LAB_00082b04;\n      strPtr = (int ********)(&tempChar2 + 1);\n      local_69 = '0';\n      goto LAB_00082afe;\n    }\n    if (result == 1) {\n      if (intPtr2 != (int *)0x0 || (int *)0x9 < intPtr1) {\n        ptempAddr = (int ********)(&tempChar2 + 1);\n        do {\n          strPtr = ptempAddr;\n          tempValue2 = (undefined4)((ulonglong)combinedValue >> 0x20);\n          tempChar = '\\n';\n          FUN_00084530((int)combinedValue,tempValue2,10,0);\n          *(char *)strPtr = tempChar + '0';\n          combinedValue = FUN_00084530((int)combinedValue,tempValue2,10,0);\n          ptempAddr = (int ********)((int)strPtr + -1);\n        } while (combinedValue != 0);\n        minWidth = (int *******)((int)local_68 - (int)strPtr);\n        goto LAB_00082b04;\n      }\n      local_69 = (char)intPtr1 + '0';\n      strPtr = (int ********)(&tempChar2 + 1);\n      goto LAB_00083282;\n    }\n    ptempAddr = (int ********)(&tempChar2 + 1);\n    if (result != 2) goto LAB_000830e2;\n    do {\n      strPtr = ptempAddr;\n      ch = (uint)intPtr1 & 0xf;\n      intPtr1 = (int *)((uint)intPtr1 >> 4 | (int)intPtr2 << 0x1c);\n      intPtr2 = (int *)((uint)intPtr2 >> 4);\n      *(char *)strPtr = digits[ch];\n      ptempAddr = (int ********)((int)strPtr + -1);\n    } while (((uint)intPtr1 | (uint)intPtr2) != 0);\n    minWidth = (int *******)((int)local_68 - (int)strPtr);\n    goto LAB_00082b04;\n  }\nLAB_00083134:\n  if (argPtrArrayPtr != (int *******)0x0) {\n    FUN_00082824(str,formatStr,&formatModifiersPtr);\n  }\nLAB_00083142:\n  if ((int)((uint)*(ushort *)(formatStr + 0xc) << 0x19) < 0) {\n    return -1;\n  }\n  return totalWidth;\nLAB_000830e2:\n  do {\n    strPtr = ptempAddr;\n    intPtr = (int *)((uint)intPtr1 >> 3 | (int)intPtr2 << 0x1d);\n    intPtr2 = (int *)((uint)intPtr2 >> 3);\n    result = ((uint)intPtr1 & 7) + 0x30;\n    *(char *)strPtr = (char)result;\n    ptempAddr = (int ********)((int)strPtr + -1);\n    intPtr1 = intPtr;\n  } while (((uint)intPtr | (uint)intPtr2) != 0);\n  if (isFlagSpace) {\n    if (result == 0x30) {\nLAB_00082afe:\n      minWidth = (int *******)((int)local_68 - (int)strPtr);\n    }\n    else {\n      *(undefined *)((int)strPtr + -1) = 0x30;\n      strPtr = ptempAddr;\n      minWidth = (int *******)((int)local_68 - (int)ptempAddr);\n    }\n  }\n  else {\nLAB_00083282:\n    minWidth = (int *******)((int)local_68 - (int)strPtr);\n  }\nLAB_00082b04:\n  maxWidth = minWidth;\n  if ((int)minWidth < (int)currentArg) {\n    maxWidth = currentArg;\n  }\n  if (signChar != '\\0') {\n    maxWidth = (int *******)((int)maxWidth + 1);\n  }\nLAB_00082b1e:\n  if (isFlagZero) {\n    maxWidth = (int *******)((int)maxWidth + 2);\n  }\n  if ((flags == 0) &&\n     (remainingArgs = (int *******)((int)pppppppiVar20 - (int)maxWidth), 0 < (int)remainingArgs)) {\n    if ((int)remainingArgs < 0x11) {\n      argCount = argCount + 1;\n    }\n    else {\n      do {\n        tempAddr2 = remainingArgs;\n        result = argCount + 1;\n        argPtrArrayPtr = argPtrArrayPtr + 4;\n        *formatModifiers = (int *******)0x856f0;\n        formatModifiers[1] = (int *******)0x10;\n        if (result < 8) {\n          tempValue = argCount + 2;\n          formatModifiers = formatModifiers + 2;\n          argCount = result;\n        }\n        else if (argPtrArrayPtr == (int *******)0x0) {\n          tempValue = 1;\n          formatModifiers = (int ********)local_68;\n          argCount = 0;\n        }\n        else {\n          argCount = result;\n          result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n          if (result != 0) goto LAB_00083142;\n          tempValue = argCount + 1;\n          formatModifiers = (int ********)local_68;\n        }\n        remainingArgs = tempAddr2 + -4;\n      } while (0x10 < (int)remainingArgs);\n      remainingArgs = tempAddr2 + -4;\n      argCount = tempValue;\n    }\n    argPtrArrayPtr = (int *******)((int)argPtrArrayPtr + (int)remainingArgs);\n    *formatModifiers = (int *******)0x856f0;\n    formatModifiers[1] = remainingArgs;\n    if (argCount < 8) {\n      result = argCount + 1;\n      formatModifiers = formatModifiers + 2;\n    }\n    else if (argPtrArrayPtr == (int *******)0x0) {\n      result = 1;\n      argCount = 0;\n      formatModifiers = (int ********)local_68;\n    }\n    else {\n      result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n      if (result != 0) goto LAB_00083142;\n      result = argCount + 1;\n      formatModifiers = (int ********)local_68;\n    }\n  }\n  else {\n    result = argCount + 1;\n  }\n  tempValue = result;\n  if (local_a1 != '\\0') {\n    argPtrArrayPtr = (int *******)((int)argPtrArrayPtr + 1);\n    tempValue = 1;\n    *formatModifiers = (int *******)&local_a1;\n    formatModifiers[1] = (int *******)0x1;\n    argCount = result;\n    if (result < 8) {\n      tempValue = result + 1;\n      formatModifiers = formatModifiers + 2;\n    }\n    else if (argPtrArrayPtr == (int *******)0x0) {\n      argCount = 0;\n      formatModifiers = (int ********)local_68;\n    }\n    else {\n      result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n      if (result != 0) goto LAB_00083142;\n      tempValue = argCount + 1;\n      formatModifiers = (int ********)local_68;\n    }\n  }\n  result = tempValue;\n  loopIndex = argCount;\n  if (isFlagZero) {\n    argPtrArrayPtr = (int *******)((int)argPtrArrayPtr + 2);\n    *formatModifiers = (int *******)&local_a0;\n    formatModifiers[1] = (int *******)0x2;\n    if (tempValue < 8) {\n      result = tempValue + 1;\n      loopIndex = tempValue;\n      formatModifiers = formatModifiers + 2;\n    }\n    else if (argPtrArrayPtr == (int *******)0x0) {\n      result = 1;\n      loopIndex = 0;\n      formatModifiers = (int ********)local_68;\n    }\n    else {\n      argCount = tempValue;\n      result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n      if (result != 0) goto LAB_00083142;\n      result = argCount + 1;\n      loopIndex = argCount;\n      formatModifiers = (int ********)local_68;\n    }\n  }\n  argCount = loopIndex;\n  if ((flags == 0x80) &&\n     (remainingArgs = (int *******)((int)pppppppiVar20 - (int)maxWidth), 0 < (int)remainingArgs)) {\n    if (0x10 < (int)remainingArgs) {\n      do {\n        while( true ) {\n          tempAddr2 = remainingArgs;\n          argCount = loopIndex + 1;\n          argPtrArrayPtr = argPtrArrayPtr + 4;\n          *formatModifiers = (int *******)\"0000000000000000\";\n          formatModifiers[1] = (int *******)0x10;\n          if (7 < argCount) break;\n          result = loopIndex + 2;\n          formatModifiers = formatModifiers + 2;\nLAB_000831f2:\n          loopIndex = argCount;\n          remainingArgs = tempAddr2 + -4;\n          if ((int)(tempAddr2 + -4) < 0x11) goto LAB_00083218;\n        }\n        if (argPtrArrayPtr != (int *******)0x0) {\n          result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n          if (result == 0) {\n            result = argCount + 1;\n            formatModifiers = (int ********)local_68;\n            goto LAB_000831f2;\n          }\n          goto LAB_00083142;\n        }\n        result = 1;\n        loopIndex = 0;\n        remainingArgs = tempAddr2 + -4;\n        formatModifiers = (int ********)local_68;\n      } while (0x10 < (int)(tempAddr2 + -4));\nLAB_00083218:\n      remainingArgs = tempAddr2 + -4;\n    }\n    argPtrArrayPtr = (int *******)((int)argPtrArrayPtr + (int)remainingArgs);\n    *formatModifiers = (int *******)\"0000000000000000\";\n    formatModifiers[1] = remainingArgs;\n    argCount = result;\n    if (result < 8) {\n      result = result + 1;\n      formatModifiers = formatModifiers + 2;\n    }\n    else if (argPtrArrayPtr == (int *******)0x0) {\n      result = 1;\n      argCount = 0;\n      formatModifiers = (int ********)local_68;\n    }\n    else {\n      result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n      if (result != 0) goto LAB_00083142;\n      result = argCount + 1;\n      formatModifiers = (int ********)local_68;\n    }\n  }\n  currentArg = (int *******)((int)currentArg - (int)minWidth);\n  ptempAddr = (int ********)local_68;\n  if ((int)currentArg < 1) {\nLAB_0008302a:\n    argPtrArrayPtr = (int *******)((int)argPtrArrayPtr + (int)minWidth);\n    *formatModifiers = (int *******)strPtr;\n    formatModifiers[1] = minWidth;\n    minWidth = argPtrArrayPtr;\n    argCount = result;\n    if (result < 8) goto LAB_000831be;\n    if (argPtrArrayPtr == (int *******)0x0) {\n      argCount = 0;\n    }\n    else {\n      result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n      if (result != 0) goto LAB_00083142;\n    }\n  }\n  else {\n    tempValue = argCount;\n    if (0x10 < (int)currentArg) {\n      do {\n        while( true ) {\n          remainingArgs = currentArg;\n          argCount = tempValue + 1;\n          argPtrArrayPtr = argPtrArrayPtr + 4;\n          *formatModifiers = (int *******)\"0000000000000000\";\n          formatModifiers[1] = (int *******)0x10;\n          if (7 < argCount) break;\n          result = tempValue + 2;\n          formatModifiers = formatModifiers + 2;\nLAB_00082fe6:\n          tempValue = argCount;\n          currentArg = remainingArgs + -4;\n          if ((int)(remainingArgs + -4) < 0x11) goto LAB_0008300e;\n        }\n        if (argPtrArrayPtr != (int *******)0x0) {\n          result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n          if (result == 0) {\n            result = argCount + 1;\n            formatModifiers = (int ********)local_68;\n            goto LAB_00082fe6;\n          }\n          goto LAB_00083142;\n        }\n        result = 1;\n        formatModifiers = (int ********)local_68;\n        tempValue = 0;\n        currentArg = remainingArgs + -4;\n      } while (0x10 < (int)(remainingArgs + -4));\nLAB_0008300e:\n      currentArg = remainingArgs + -4;\n    }\n    argPtrArrayPtr = (int *******)((int)argPtrArrayPtr + (int)currentArg);\n    *formatModifiers = (int *******)\"0000000000000000\";\n    formatModifiers[1] = currentArg;\n    if (result < 8) {\n      result = result + 1;\n      formatModifiers = formatModifiers + 2;\n      goto LAB_0008302a;\n    }\n    if (argPtrArrayPtr != (int *******)0x0) {\n      argCount = result;\n      result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n      if (result != 0) goto LAB_00083142;\n      result = argCount + 1;\n      formatModifiers = (int ********)local_68;\n      goto LAB_0008302a;\n    }\n    local_64[0] = minWidth;\n    argCount = 1;\n    formatModifiers = (int ********)local_68;\n    local_68 = (undefined  [4])strPtr;\nLAB_000831be:\n    ptempAddr = formatModifiers + 2;\n    argPtrArrayPtr = minWidth;\n  }\n  if (((flags & 4) != 0) &&\n     (currentArg = (int *******)((int)pppppppiVar20 - (int)maxWidth), 0 < (int)currentArg)) {\n    result = argCount;\n    if ((int)currentArg < 0x11) {\n      tempValue = argCount + 1;\n    }\n    else {\n      do {\n        while( true ) {\n          argCount = result + 1;\n          argPtrArrayPtr = argPtrArrayPtr + 4;\n          *ptempAddr = (int *******)0x856f0;\n          ptempAddr[1] = (int *******)0x10;\n          if (7 < argCount) break;\n          tempValue = result + 2;\n          ptempAddr = ptempAddr + 2;\nLAB_0008307a:\n          currentArg = currentArg + -4;\n          result = argCount;\n          if ((int)currentArg < 0x11) goto LAB_000830a2;\n        }\n        if (argPtrArrayPtr != (int *******)0x0) {\n          result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n          if (result == 0) {\n            tempValue = argCount + 1;\n            ptempAddr = (int ********)local_68;\n            goto LAB_0008307a;\n          }\n          goto LAB_00083142;\n        }\n        currentArg = currentArg + -4;\n        tempValue = 1;\n        result = 0;\n        ptempAddr = (int ********)local_68;\n      } while (0x10 < (int)currentArg);\n    }\nLAB_000830a2:\n    argPtrArrayPtr = (int *******)((int)argPtrArrayPtr + (int)currentArg);\n    *ptempAddr = (int *******)0x856f0;\n    ptempAddr[1] = currentArg;\n    argCount = tempValue;\n    if (7 < tempValue) {\n      if (argPtrArrayPtr == (int *******)0x0) {\n        if ((int)maxWidth < (int)pppppppiVar20) {\n          maxWidth = pppppppiVar20;\n        }\n        totalWidth = totalWidth + (int)maxWidth;\n        goto LAB_00083186;\n      }\n      result = FUN_00082824(str,formatStr,&formatModifiersPtr);\n      if (result != 0) goto LAB_00083142;\n    }\n  }\n  if ((int)maxWidth < (int)pppppppiVar20) {\n    maxWidth = pppppppiVar20;\n  }\n  totalWidth = totalWidth + (int)maxWidth;\n  if ((argPtrArrayPtr != (int *******)0x0) &&\n     (result = FUN_00082824(str,formatStr,&formatModifiersPtr), result != 0)) goto LAB_00083142;\nLAB_00083186:\n  argCount = 0;\n  formatModifiers = (int ********)local_68;\n  goto LAB_00082902;\nswitchD_00082984_caseD_31:\n  digitValue = ch - 0x30;\n  pppppppiVar20 = (int *******)0x0;\n  currentArg = args;\n  do {\n    args = (int *******)((int)currentArg + 1);\n    ch = (uint)*(byte *)currentArg;\n    pppppppiVar20 = (int *******)(digitValue + (int)pppppppiVar20 * 10);\n    digitValue = ch - 0x30;\n    currentArg = args;\n  } while (digitValue < 10);\n  goto LAB_0008297a;\nswitchD_00082984_caseD_20:\n  ch = (uint)*(byte *)args;\n  if (local_a1 == '\\0') {\n    local_a1 = ' ';\n  }\n  goto LAB_00082976;\n}\n\n",
            "renaming": {
                "FUN_0008289c": "parse_formatted_string_0008289c",
                "param_1": "str",
                "param_2": "formatStr",
                "param_3": "args",
                "param_4": "varArgs",
                "bVar1": "isFlagMinus",
                "bVar2": "isFlagPlus",
                "bVar3": "isFlagSpace",
                "cVar4": "signChar",
                "bVar5": "isFlagZero",
                "ppppppppiVar6": "formatModifiers",
                "piVar7": "intPtr",
                "iVar8": "result",
                "cVar9": "tempChar",
                "pppppppiVar10": "currentArg",
                "uVar11": "digitValue",
                "ppiVar12": "argPtr",
                "uVar13": "flags",
                "uVar14": "ch",
                "iVar15": "tempValue",
                "pppppppiVar16": "tempAddr",
                "iVar17": "loopIndex",
                "pppppppiVar18": "remainingArgs",
                "piVar19": "intPtr1",
                "piVar22": "intPtr2",
                "pppppppiVar23": "tempAddr2",
                "uVar24": "tempValue2",
                "ppppppppiVar25": "strPtr",
                "bVar26": "isFlagHash",
                "lVar27": "combinedValue",
                "local_dc": "maxWidth",
                "local_d4": "minWidth",
                "local_c8": "argPtrArray",
                "local_c4": "totalWidth",
                "local_c0": "digits",
                "local_9c": "formatModifiersPtr",
                "local_98": "argCount",
                "local_94": "argPtrArrayPtr",
                "local_90": "argSize",
                "cStack_6a": "tempChar2"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00081750",
                "FUN_000817c8"
            ],
            "called": [
                "FUN_000834f0",
                "FUN_00082824",
                "FUN_0008356c",
                "FUN_000840f8",
                "FUN_00084530",
                "FUN_00082688",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000834f0": {
            "entrypoint": "0x000834f0",
            "current_name": "decode_and_process_data_000834f0",
            "code": "\nint decode_and_process_data_000834f0(undefined4 input_buffer,int memory_offset)\n\n{\n  int result;\n  int check_result;\n  undefined *stack_buffers [2];\n  undefined4 buffer_size1;\n  ushort flag;\n  undefined2 value;\n  undefined *buffer_pointer;\n  undefined4 buffer_size2;\n  undefined4 counter;\n  undefined4 value2;\n  undefined4 value3;\n  undefined4 variable1;\n  undefined stack_array [1024];\n  \n  variable1 = *(undefined4 *)(memory_offset + 100);\n  value2 = *(undefined4 *)(memory_offset + 0x1c);\n  value = *(undefined2 *)(memory_offset + 0xe);\n  value3 = *(undefined4 *)(memory_offset + 0x24);\n  stack_buffers[0] = stack_array;\n  flag = *(ushort *)(memory_offset + 0xc) & 0xfffd;\n  buffer_size1 = 0x400;\n  buffer_size2 = 0x400;\n  counter = 0;\n  buffer_pointer = stack_buffers[0];\n  result = FUN_0008289c(input_buffer,stack_buffers);\n  if ((-1 < result) && (check_result = FUN_00083850(input_buffer,stack_buffers), check_result != 0)) {\n    result = -1;\n  }\n  if ((int)((uint)flag << 0x19) < 0) {\n    *(ushort *)(memory_offset + 0xc) = *(ushort *)(memory_offset + 0xc) | 0x40;\n  }\n  return result;\n}\n\n",
            "renaming": {
                "FUN_000834f0": "decode_and_process_data_000834f0",
                "param_1": "input_buffer",
                "param_2": "memory_offset",
                "iVar1": "result",
                "iVar2": "check_result",
                "local_488": "stack_buffers",
                "local_480": "buffer_size1",
                "local_47c": "flag",
                "local_47a": "value",
                "local_478": "buffer_pointer",
                "local_474": "buffer_size2",
                "local_470": "counter",
                "local_46c": "value2",
                "local_464": "value3",
                "local_424": "variable1",
                "auStack_420": "stack_array"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008289c",
                "FUN_00083850"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008356c": {
            "entrypoint": "0x0008356c",
            "current_name": "process_binary_function_0008356c",
            "code": "\nundefined4 processBinaryFunction_0008356c(undefined4 *outputCode,int *inputData)\n\n{\n  int tempVar1;\n  int tempVar2;\n  uint tempVar3;\n  ushort tempVar4;\n  \n  if ((Elf32_Rel_ARRAY_20070000[140].r_offset != 0) &&\n     (*(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  tempVar4 = *(ushort *)(inputData + 3);\n  tempVar3 = (uint)tempVar4;\n  if ((int)(tempVar3 << 0x1c) < 0) {\n    tempVar2 = inputData[4];\n  }\n  else {\n    if (-1 < (int)(tempVar3 << 0x1b)) {\n      *outputCode = 9;\n      *(ushort *)(inputData + 3) = tempVar4 | 0x40;\n      return 0xffffffff;\n    }\n    if ((int)(tempVar3 << 0x1d) < 0) {\n      if ((int *)inputData[0xc] != (int *)0x0) {\n        if ((int *)inputData[0xc] != inputData + 0x10) {\n          FUN_00083b10(outputCode);\n          tempVar4 = *(ushort *)(inputData + 3);\n        }\n        inputData[0xc] = 0;\n      }\n      tempVar2 = inputData[4];\n      tempVar4 = tempVar4 & 0xffdb;\n      *inputData = tempVar2;\n      inputData[1] = 0;\n    }\n    else {\n      tempVar2 = inputData[4];\n    }\n    *(ushort *)(inputData + 3) = tempVar4 | 8;\n    tempVar3 = (uint)(tempVar4 | 8);\n  }\n  if ((tempVar2 == 0) && ((tempVar3 & 0x280) != 0x200)) {\n    FUN_00084018(outputCode,inputData);\n    tempVar3 = (uint)*(ushort *)(inputData + 3);\n    tempVar2 = inputData[4];\n  }\n  if ((tempVar3 & 1) == 0) {\n    tempVar1 = 0;\n    if (-1 < (int)(tempVar3 << 0x1e)) {\n      tempVar1 = inputData[5];\n    }\n    inputData[2] = tempVar1;\n  }\n  else {\n    inputData[6] = -inputData[5];\n    inputData[2] = 0;\n  }\n  if ((tempVar2 == 0) && ((int)((uint)*(ushort *)(inputData + 3) << 0x18) < 0)) {\n    *(ushort *)(inputData + 3) = *(ushort *)(inputData + 3) | 0x40;\n    return 0xffffffff;\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_0008356c": "process_binary_function_0008356c",
                "param_1": "outputCode",
                "param_2": "inputData",
                "iVar1": "tempVar1",
                "iVar2": "tempVar2",
                "uVar3": "tempVar3",
                "uVar4": "tempVar4"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_000842a4",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00084018",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000836d8": {
            "entrypoint": "0x000836d8",
            "current_name": "FUNC_000836d8",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x00083630) */\n/* WARNING: Removing unreachable block (ram,0x000836c4) */\n/* WARNING: Removing unreachable block (ram,0x00083642) */\n/* WARNING: Removing unreachable block (ram,0x00083648) */\n/* WARNING: Removing unreachable block (ram,0x00083654) */\n/* WARNING: Removing unreachable block (ram,0x0008366e) */\n/* WARNING: Removing unreachable block (ram,0x0008364c) */\n/* WARNING: Removing unreachable block (ram,0x00083686) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n/* WARNING: Removing unreachable block (ram,0x00083688) */\n\nvoid FUNC_000836d8(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836d8": "FUNC_000836d8"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000836ec": {
            "entrypoint": "0x000836ec",
            "current_name": "initialize_relocation_000836ec",
            "code": "\n/* WARNING: Removing unreachable block (ram,0x00083698) */\n/* WARNING: Removing unreachable block (ram,0x000836b8) */\n\nvoid initializeRelocation_000836ec(void)\n\n{\n  dword *relocatedDataPtr;\n  dword offset;\n  int index;\n  code *jumpTable;\n  \n  FUN_000841e4(6);\n  jumpTable = (code *)0x836fb;\n  offset = FUN_00080eec(1);\n  if (relocationTable[48].r_offset == 0) {\n    relocationTable[48].r_offset = 0x20070184;\n  }\n  index = *(int *)(relocationTable[48].r_offset + 4);\n  relocatedDataPtr = (dword *)relocationTable[48].r_offset;\n  if (0x1f < index) {\n    relocatedDataPtr = (dword *)FUN_000817f0(400);\n    if (relocatedDataPtr == (dword *)0x0) {\n                    /* WARNING: Could not recover jumptable at 0x00083652. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n      (*jumpTable)(0xffffffff);\n      return;\n    }\n    *relocatedDataPtr = relocationTable[48].r_offset;\n    relocatedDataPtr[1] = 0;\n    index = 0;\n    relocationTable[48].r_offset = (dword)relocatedDataPtr;\n    relocatedDataPtr[0x62] = 0;\n    relocatedDataPtr[99] = 0;\n  }\n  relocatedDataPtr[1] = index + 1;\n  relocatedDataPtr[index + 2] = offset;\n                    /* WARNING: Could not recover jumptable at 0x00083696. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  (*jumpTable)(0);\n  return;\n}\n\n",
            "renaming": {
                "FUN_000836ec": "initialize_relocation_000836ec",
                "pdVar1": "relocatedDataPtr",
                "dVar2": "offset",
                "iVar3": "index",
                "UNRECOVERED_JUMPTABLE_00": "jumpTable",
                "Elf32_Rel_ARRAY_20070000": "relocationTable"
            },
            "calling": [
                "FUN_000816f8"
            ],
            "called": [
                "FUN_000841e4",
                "FUN_00080eec",
                "FUN_000817f0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083850": {
            "entrypoint": "0x00083850",
            "current_name": "process_data_00083850",
            "code": "\nundefined4 processData_00083850(int *inputData,int *outputData)\n\n{\n  int *tempPtr1;\n  int tempVar1;\n  ushort tempVar2;\n  uint tempVar3;\n  int tempVar4;\n  code *callbackFunc;\n  undefined4 result;\n  int tempVar5;\n  \n  if ((inputData != (int *)0x0) && (inputData[0xe] == 0)) {\n    FUN_00083888();\n  }\n  if (*(short *)(outputData + 3) == 0) {\n    return 0;\n  }\n  tempVar2 = *(ushort *)(outputData + 3);\n  if ((int)((uint)tempVar2 << 0x1c) < 0) {\n    tempVar5 = outputData[4];\n    if (tempVar5 == 0) {\n      return 0;\n    }\n    tempVar1 = *outputData;\n    if ((tempVar2 & 3) == 0) {\n      tempVar4 = outputData[5];\n    }\n    else {\n      tempVar4 = 0;\n    }\n    *outputData = tempVar5;\n    tempVar1 = tempVar1 - tempVar5;\n    outputData[2] = tempVar4;\n    do {\n      if (tempVar1 < 1) {\n        return 0;\n      }\n      tempVar4 = (*(code *)outputData[9])(inputData,outputData[7],tempVar5,tempVar1,result);\n      tempVar1 = tempVar1 - tempVar4;\n      tempVar5 = tempVar5 + tempVar4;\n    } while (0 < tempVar4);\nLAB_000837c8:\n    *(ushort *)(outputData + 3) = *(ushort *)(outputData + 3) | 0x40;\n    return 0xffffffff;\n  }\n  *(ushort *)(outputData + 3) = tempVar2 | 0x800;\n  if ((outputData[1] < 1) && (outputData[0xf] < 1)) {\n    return 0;\n  }\n  callbackFunc = (code *)outputData[10];\n  if (callbackFunc == (code *)0x0) {\n    return 0;\n  }\n  tempVar3 = (uint)(tempVar2 | 0x800);\n  tempVar5 = *inputData;\n  *inputData = 0;\n  if ((tempVar2 & 0x1000) == 0) {\n    tempVar1 = (*callbackFunc)(inputData,outputData[7],tempVar3 & 0x1000,1);\n    if ((tempVar1 == -1) && (tempVar4 = *inputData, tempVar4 != 0)) {\n      if ((tempVar4 == 0x1d) || (tempVar4 == 0x16)) {\n        *inputData = tempVar5;\n        return 0;\n      }\n      goto LAB_000837c8;\n    }\n    tempVar3 = (uint)*(ushort *)(outputData + 3);\n    callbackFunc = (code *)outputData[10];\n  }\n  else {\n    tempVar1 = outputData[0x14];\n  }\n  if (((int)(tempVar3 << 0x1d) < 0) && (tempVar1 = tempVar1 - outputData[1], outputData[0xc] != 0)) {\n    tempVar1 = tempVar1 - outputData[0xf];\n  }\n  tempVar1 = (*callbackFunc)(inputData,outputData[7],tempVar1,0);\n  if (tempVar1 == -1) {\n    tempVar4 = *inputData;\n    if (tempVar4 != 0) {\n      if ((tempVar4 != 0x1d) && (tempVar4 != 0x16)) {\n        *(ushort *)(outputData + 3) = *(ushort *)(outputData + 3) | 0x40;\n        return 0xffffffff;\n      }\n      *(ushort *)(outputData + 3) = *(ushort *)(outputData + 3) & 0xf7ff;\n      *outputData = outputData[4];\n      outputData[1] = 0;\n      goto LAB_00083774;\n    }\n    tempVar2 = *(ushort *)(outputData + 3) & 0xf7ff;\n    outputData[1] = 0;\n    *(ushort *)(outputData + 3) = tempVar2;\n    *outputData = outputData[4];\n  }\n  else {\n    tempVar2 = *(ushort *)(outputData + 3) & 0xf7ff;\n    *outputData = outputData[4];\n    *(ushort *)(outputData + 3) = tempVar2;\n    outputData[1] = 0;\n  }\n  if ((int)((uint)tempVar2 << 0x13) < 0) {\n    outputData[0x14] = tempVar1;\n  }\nLAB_00083774:\n  tempPtr1 = (int *)outputData[0xc];\n  *inputData = tempVar5;\n  if (tempPtr1 == (int *)0x0) {\n    return 0;\n  }\n  if (tempPtr1 != outputData + 0x10) {\n    FUN_00083b10(inputData);\n  }\n  outputData[0xc] = 0;\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083850": "process_data_00083850",
                "param_1": "inputData",
                "param_2": "outputData",
                "piVar1": "tempPtr1",
                "iVar2": "tempVar1",
                "uVar3": "tempVar2",
                "uVar4": "tempVar3",
                "iVar5": "tempVar4",
                "pcVar6": "callbackFunc",
                "unaff_r4": "result",
                "iVar7": "tempVar5"
            },
            "calling": [
                "FUN_000834f0",
                "FUN_00084484",
                "FUN_000842a4",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00083b10",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083888": {
            "entrypoint": "0x00083888",
            "current_name": "initialize_function_00083888",
            "code": "\nvoid initializeFunction_00083888(int functionPtr)\n\n{\n  undefined4 *firstArray;\n  undefined4 *secondArray;\n  \n  if (*(int *)(functionPtr + 0x38) == 0) {\n    firstArray = *(undefined4 **)(functionPtr + 4);\n    *(undefined **)(functionPtr + 0x3c) = &LAB_0008387c_1;\n    *(undefined4 *)(functionPtr + 0x2e4) = 3;\n    *(int *)(functionPtr + 0x2e8) = functionPtr + 0x2ec;\n    *(undefined4 *)(functionPtr + 0x2e0) = 0;\n    *(undefined2 *)(firstArray + 3) = 4;\n    *firstArray = 0;\n    firstArray[1] = 0;\n    firstArray[2] = 0;\n    firstArray[0x19] = 0;\n    *(undefined2 *)((int)firstArray + 0xe) = 0;\n    firstArray[4] = 0;\n    firstArray[5] = 0;\n    firstArray[6] = 0;\n    FUN_00081f00(firstArray + 0x17,0,8);\n    secondArray = *(undefined4 **)(functionPtr + 8);\n    firstArray[7] = firstArray;\n    firstArray[8] = 0x84221;\n    firstArray[9] = 0x84245;\n    firstArray[10] = 0x8427d;\n    firstArray[0xb] = &LAB_0008429c_1;\n    *(undefined2 *)((int)secondArray + 0xe) = 1;\n    *(undefined2 *)(secondArray + 3) = 9;\n    *secondArray = 0;\n    secondArray[1] = 0;\n    secondArray[2] = 0;\n    secondArray[0x19] = 0;\n    secondArray[4] = 0;\n    secondArray[5] = 0;\n    secondArray[6] = 0;\n    FUN_00081f00(secondArray + 0x17,0,8);\n    firstArray = *(undefined4 **)(functionPtr + 0xc);\n    secondArray[7] = secondArray;\n    secondArray[8] = 0x84221;\n    secondArray[9] = 0x84245;\n    secondArray[10] = 0x8427d;\n    secondArray[0xb] = &LAB_0008429c_1;\n    *(undefined2 *)(firstArray + 3) = 0x12;\n    *(undefined2 *)((int)firstArray + 0xe) = 2;\n    *firstArray = 0;\n    firstArray[1] = 0;\n    firstArray[2] = 0;\n    firstArray[0x19] = 0;\n    firstArray[4] = 0;\n    firstArray[5] = 0;\n    firstArray[6] = 0;\n    FUN_00081f00(firstArray + 0x17,0,8);\n    firstArray[7] = firstArray;\n    firstArray[8] = 0x84221;\n    firstArray[9] = 0x84245;\n    firstArray[10] = 0x8427d;\n    firstArray[0xb] = &LAB_0008429c_1;\n    *(undefined4 *)(functionPtr + 0x38) = 1;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083888": "initialize_function_00083888",
                "param_1": "functionPtr",
                "puVar1": "firstArray",
                "puVar2": "secondArray"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00084484",
                "FUN_000842a4"
            ],
            "called": [
                "FUN_00081f00"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008397c": {
            "entrypoint": "0x0008397c",
            "current_name": "FUNC_0008397c",
            "code": "\nvoid FUNC_0008397c(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008397c": "FUNC_0008397c"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_00083980": {
            "entrypoint": "0x00083980",
            "current_name": "FUNC_00083980",
            "code": "\nvoid FUNC_00083980(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083980": "FUNC_00083980"
            },
            "calling": [
                "FUN_00084484"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        },
        "FUN_000839b4": {
            "entrypoint": "0x000839b4",
            "current_name": "process_data_000839b4",
            "code": "\nuint processData_000839b4(undefined4 param1,uint param2,byte **param3)\n\n{\n  int index;\n  uint flag;\n  uint value;\n  byte *ptrByte;\n  uint counter;\n  byte byteValue;\n  byte byteArray [3];\n  \n  if (-1 < (int)((uint)*(ushort *)(param3 + 3) << 0x12)) {\n    *(ushort *)(param3 + 3) = *(ushort *)(param3 + 3) | 0x2000;\n    param3[0x19] = (byte *)((uint)param3[0x19] | 0x2000);\n  }\n  index = FUN_0008400c();\n  if ((index == 1) && (param2 - 1 < 0xff)) {\n    value = param2 & 0xff;\n    byteValue = (byte)value;\n    flag = 1;\n  }\n  else {\n    flag = FUN_0008434c(param1,&byteValue,param2,param3 + 0x17);\n    if (flag == 0xffffffff) {\n      *(ushort *)(param3 + 3) = *(ushort *)(param3 + 3) | 0x40;\n      return 0xffffffff;\n    }\n    if (flag == 0) {\n      return param2;\n    }\n    value = (uint)byteValue;\n  }\n  counter = 0;\n  do {\n    ptrByte = param3[2] + -1;\n    param3[2] = ptrByte;\n    if ((int)ptrByte < 0) {\n      if ((int)param3[6] <= (int)ptrByte) {\n        **param3 = (byte)value;\n        ptrByte = *param3;\n        value = (uint)*ptrByte;\n        if (value != 10) goto LAB_00083a04;\n      }\n      index = FUN_000842a4(param1,value,param3);\n      if (index == -1) {\n        return 0xffffffff;\n      }\n    }\n    else {\n      **param3 = (byte)value;\n      ptrByte = *param3;\nLAB_00083a04:\n      *param3 = ptrByte + 1;\n    }\n    if (flag <= counter + 1) {\n      return param2;\n    }\n    value = (uint)byteArray[counter];\n    counter = counter + 1;\n  } while( true );\n}\n\n",
            "renaming": {
                "FUN_000839b4": "process_data_000839b4",
                "param_1": "param1",
                "param_2": "param2",
                "param_3": "param3",
                "iVar1": "index",
                "uVar2": "flag",
                "uVar3": "value",
                "pbVar4": "ptrByte",
                "uVar5": "counter",
                "local_1c": "byteValue",
                "abStack_1b": "byteArray"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_0008434c",
                "FUN_0008400c",
                "FUN_000842a4"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083a74": {
            "entrypoint": "0x00083a74",
            "current_name": "update_relocation_entry_00083a74",
            "code": "\nundefined4 updateRelocationEntry_00083a74(undefined4 param,int size)\n\n{\n  int result;\n  uint relInfo;\n  int offset;\n  \n  FUNC_00081f94();\n  relInfo = *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) & 0xfffffffc;\n  offset = ((relInfo - size) + 0xfef & 0xfffff000) - 0x1000;\n  if (0xfff < offset) {\n    result = FUN_0008236c(param,0);\n    if (result == Elf32_Rel_ARRAY_20070000[141].r_info + relInfo) {\n      result = FUN_0008236c(param,-offset);\n      if (result != -1) {\n        DAT_2007121c = DAT_2007121c - offset;\n        *(uint *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) = relInfo - offset | 1;\n        FUNC_00081f98(param);\n        return 1;\n      }\n      offset = FUN_0008236c(param,0);\n      if (0xf < (int)(offset - Elf32_Rel_ARRAY_20070000[141].r_info)) {\n        DAT_2007121c = offset - Elf32_Rel_ARRAY_20070000[270].r_offset;\n        *(dword *)(Elf32_Rel_ARRAY_20070000[141].r_info + 4) =\n             offset - Elf32_Rel_ARRAY_20070000[141].r_info | 1;\n      }\n    }\n  }\n  FUNC_00081f98(param);\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083a74": "update_relocation_entry_00083a74",
                "param_1": "param",
                "param_2": "size",
                "iVar1": "result",
                "uVar2": "relInfo",
                "iVar3": "offset"
            },
            "calling": [
                "FUN_00083b10"
            ],
            "called": [
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_0008236c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083b10": {
            "entrypoint": "0x00083b10",
            "current_name": "update_relocation_entries_00083b10",
            "code": "\nvoid updateRelocationEntries_00083b10(undefined4 param1,int param2)\n\n{\n  int currentEntry;\n  bool hasNextEntry;\n  uint entrySize;\n  dword currentRelocation;\n  int previousEntry;\n  uint relativeOffset;\n  dword relocationSection;\n  uint newRelativeOffset;\n  dword newRelocationSection;\n  \n  if (param2 == 0) {\n    return;\n  }\n  FUNC_00081f94();\n  entrySize = *(uint *)(param2 + -4);\n  relocationSection = param2 - 8;\n  relativeOffset = entrySize & 0xfffffffe;\n  currentRelocation = relocationSection + relativeOffset;\n  newRelativeOffset = *(uint *)(currentRelocation + 4) & 0xfffffffc;\n  if (Elf32_Rel_ARRAY_20070000[141].r_info == currentRelocation) {\n    newRelativeOffset = newRelativeOffset + relativeOffset;\n    if (-1 < (int)(entrySize << 0x1f)) {\n      relocationSection = relocationSection - *(int *)(param2 + -8);\n      previousEntry = *(int *)(relocationSection + 0xc);\n      currentEntry = *(int *)(relocationSection + 8);\n      newRelativeOffset = newRelativeOffset + *(int *)(param2 + -8);\n      *(int *)(currentEntry + 0xc) = previousEntry;\n      *(int *)(previousEntry + 8) = currentEntry;\n    }\n    currentRelocation = Elf32_Rel_ARRAY_20070000[269].r_info;\n    *(uint *)(relocationSection + 4) = newRelativeOffset | 1;\n    Elf32_Rel_ARRAY_20070000[141].r_info = relocationSection;\n    if (currentRelocation <= newRelativeOffset) {\n      FUN_00083a74(param1,DAT_20071218);\n    }\n  }\n  else {\n    *(uint *)(currentRelocation + 4) = newRelativeOffset;\n    if ((entrySize & 1) == 0) {\n      relocationSection = relocationSection - *(int *)(param2 + -8);\n      currentEntry = *(int *)(relocationSection + 8);\n      relativeOffset = relativeOffset + *(int *)(param2 + -8);\n      if (currentEntry == 0x2007046c) {\n        hasNextEntry = true;\n      }\n      else {\n        previousEntry = *(int *)(relocationSection + 0xc);\n        *(int *)(currentEntry + 0xc) = previousEntry;\n        *(int *)(previousEntry + 8) = currentEntry;\n        hasNextEntry = false;\n      }\n    }\n    else {\n      hasNextEntry = false;\n    }\n    if (-1 < *(int *)(currentRelocation + newRelativeOffset + 4) << 0x1f) {\n      relativeOffset = relativeOffset + newRelativeOffset;\n      currentEntry = *(int *)(currentRelocation + 8);\n      if ((!hasNextEntry) && (currentEntry == 0x2007046c)) {\n        Elf32_Rel_ARRAY_20070000[142].r_info = relocationSection;\n        Elf32_Rel_ARRAY_20070000[143].r_offset = relocationSection;\n        *(undefined4 *)(relocationSection + 0xc) = 0x2007046c;\n        *(undefined4 *)(relocationSection + 8) = 0x2007046c;\n        *(uint *)(relocationSection + 4) = relativeOffset | 1;\n        *(uint *)(relocationSection + relativeOffset) = relativeOffset;\n        goto LAB_00083ba4;\n      }\n      previousEntry = *(int *)(currentRelocation + 0xc);\n      *(int *)(currentEntry + 0xc) = previousEntry;\n      *(int *)(previousEntry + 8) = currentEntry;\n    }\n    *(uint *)(relocationSection + 4) = relativeOffset | 1;\n    *(uint *)(relocationSection + relativeOffset) = relativeOffset;\n    if (!hasNextEntry) {\n      if (relativeOffset < 0x200) {\n        entrySize = relativeOffset & 0xfffffff8;\n        currentEntry = *(int *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + entrySize);\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << ((int)(relativeOffset >> 3) >> 2 & 0xffU);\n        *(int *)(relocationSection + 8) = currentEntry;\n        *(uint *)(relocationSection + 0xc) = entrySize + 0x20070464;\n        *(dword *)((int)&Elf32_Rel_ARRAY_20070000[0x8d].r_info + entrySize) = relocationSection;\n        *(dword *)(currentEntry + 0xc) = relocationSection;\n        FUNC_00081f98(param1);\n        return;\n      }\n      entrySize = relativeOffset >> 9;\n      if (entrySize < 5) {\n        currentEntry = (relativeOffset >> 6) + 0x38;\n        previousEntry = currentEntry * 2;\n      }\n      else if (entrySize < 0x15) {\n        currentEntry = entrySize + 0x5b;\n        previousEntry = currentEntry * 2;\n      }\n      else if (entrySize < 0x55) {\n        currentEntry = (relativeOffset >> 0xc) + 0x6e;\n        previousEntry = currentEntry * 2;\n      }\n      else if (entrySize < 0x155) {\n        currentEntry = (relativeOffset >> 0xf) + 0x77;\n        previousEntry = currentEntry * 2;\n      }\n      else if (entrySize < 0x555) {\n        currentEntry = (relativeOffset >> 0x12) + 0x7c;\n        previousEntry = currentEntry * 2;\n      }\n      else {\n        previousEntry = 0xfc;\n        currentEntry = 0x7e;\n      }\n      newRelocationSection = previousEntry * 4 + 0x20070464;\n      currentRelocation = (&Elf32_Rel_ARRAY_20070000[0x8d].r_info)[previousEntry];\n      if (currentRelocation == newRelocationSection) {\n        Elf32_Rel_ARRAY_20070000[141].r_offset =\n             Elf32_Rel_ARRAY_20070000[141].r_offset | 1 << (currentEntry >> 2 & 0xffU);\n        newRelocationSection = currentRelocation;\n      }\n      else {\n        do {\n          if ((*(uint *)(currentRelocation + 4) & 0xfffffffc) <= relativeOffset) break;\n          currentRelocation = *(dword *)(currentRelocation + 8);\n        } while (newRelocationSection != currentRelocation);\n        newRelocationSection = *(dword *)(currentRelocation + 0xc);\n      }\n      *(dword *)(relocationSection + 0xc) = newRelocationSection;\n      *(dword *)(relocationSection + 8) = currentRelocation;\n      *(dword *)(newRelocationSection + 8) = relocationSection;\n      *(dword *)(currentRelocation + 0xc) = relocationSection;\n    }\n  }\nLAB_00083ba4:\n  FUNC_00081f98(param1);\n  return;\n}\n\n",
            "renaming": {
                "FUN_00083b10": "update_relocation_entries_00083b10",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "currentEntry",
                "bVar2": "hasNextEntry",
                "uVar3": "entrySize",
                "dVar4": "currentRelocation",
                "iVar5": "previousEntry",
                "uVar6": "relativeOffset",
                "dVar7": "relocationSection",
                "uVar8": "newRelativeOffset",
                "dVar9": "newRelocationSection"
            },
            "calling": [
                "FUN_00081fac",
                "FUN_00081800",
                "FUN_00081810",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00084484",
                "FUN_00083ca8"
            ],
            "called": [
                "FUN_00081f98",
                "FUN_00081f94",
                "FUN_00083a74"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00083ca8": {
            "entrypoint": "0x00083ca8",
            "current_name": "reverse_extracted_code_00083ca8",
            "code": "\nundefined4 reverseExtractedCode_00083ca8(undefined4 *output,uint *input1,uint **input2)\n\n{\n  int returnValue;\n  uint var1;\n  uint var2;\n  ushort var3;\n  uint var4;\n  uint *pointer1;\n  uint *pointer2;\n  uint var5;\n  uint var6;\n  uint var7;\n  uint var8;\n  uint var9;\n  \n  if (input2[2] != (uint *)0x0) {\n    var3 = *(ushort *)(input1 + 3);\n    var4 = (uint)var3;\n    if (((int)(var4 << 0x1c) < 0) && (input1[4] != 0)) {\n      pointer2 = *input2;\n    }\n    else {\n      returnValue = FUN_0008356c(output,input1);\n      if (returnValue != 0) {\n        return 0xffffffff;\n      }\n      var3 = *(ushort *)(input1 + 3);\n      var4 = (uint)var3;\n      pointer2 = *input2;\n    }\n    if ((var3 & 2) == 0) {\n      var1 = var4 & 2;\n      var7 = var1;\n      var5 = var1;\n      var9 = var1;\n      if ((var4 & 1) == 0) {\n        var1 = 0;\n        var7 = 0;\n        while( true ) {\n          while (var1 == 0) {\n            var7 = *pointer2;\n            pointer1 = pointer2 + 1;\n            pointer2 = pointer2 + 2;\n            var1 = *pointer1;\n          }\n          var5 = input1[2];\n          if ((int)(var4 << 0x16) < 0) {\n            if (var1 < var5) {\n              var4 = *input1;\n              var5 = var1;\n            }\n            else if ((var4 & 0x480) == 0) {\n              var4 = *input1;\n            }\n            else {\n              returnValue = *input1 - input1[4];\n              var5 = returnValue + 1 + var1;\n              var6 = (int)(input1[5] * 3) / 2;\n              if (var5 <= var6) {\n                var5 = var6;\n              }\n              if ((int)(var4 << 0x15) < 0) {\n                var6 = FUN_00081810(output,var5);\n                if (var6 == 0) {\n                  *output = 0xc;\n                  var3 = *(ushort *)(input1 + 3);\n                  goto LAB_00083da4;\n                }\n                FUN_00081d48(var6,input1[4],returnValue);\n                *(ushort *)(input1 + 3) = *(ushort *)(input1 + 3) & 0xfb7f | 0x80;\n              }\n              else {\n                var6 = FUN_00081fac(output);\n                if (var6 == 0) {\n                  FUN_00083b10(output,input1[4]);\n                  var3 = *(ushort *)(input1 + 3) & 0xff7f;\n                  *output = 0xc;\n                  goto LAB_00083da4;\n                }\n              }\n              var4 = var6 + returnValue;\n              input1[4] = var6;\n              input1[5] = var5;\n              *input1 = var4;\n              input1[2] = var5 - returnValue;\n              var5 = var1;\n            }\n            FUN_00081e34(var4,var7,var5);\n            input1[2] = input1[2] - var5;\n            *input1 = *input1 + var5;\n            var5 = var1;\n          }\n          else if ((input1[4] < *input1) || (var4 = input1[5], var1 < var4)) {\n            if (var1 < var5) {\n              var5 = var1;\n            }\n            FUN_00081e34(*input1,var7,var5);\n            var4 = input1[2];\n            input1[2] = var4 - var5;\n            *input1 = *input1 + var5;\n            if ((var4 - var5 == 0) && (returnValue = FUN_00083850(output,input1), returnValue != 0))\n            goto LAB_00083da2;\n          }\n          else {\n            var5 = 0x7fffffff;\n            if (var1 < 0x7fffffff) {\n              var5 = var1;\n            }\n            var5 = (*(code *)input1[9])(output,input1[7],var7,(var5 / var4) * var4);\n            if ((int)var5 < 1) goto LAB_00083da2;\n          }\n          pointer1 = input2[2];\n          var7 = var7 + var5;\n          var1 = var1 - var5;\n          input2[2] = (uint *)((int)pointer1 - var5);\n          if ((uint *)((int)pointer1 - var5) == (uint *)0x0) break;\n          var4 = (uint)*(ushort *)(input1 + 3);\n        }\n      }\n      else {\n        do {\n          while (var1 == 0) {\n            var5 = *pointer2;\n            var1 = pointer2[1];\n            var9 = 0;\n            pointer2 = pointer2 + 2;\n          }\n          if (var9 == 0) {\n            returnValue = FUN_000840f8(var5,10,var1);\n            if (returnValue == 0) {\n              var7 = var1 + 1;\n              var9 = 1;\n            }\n            else {\n              var7 = (returnValue + 1) - var5;\n              var9 = 1;\n            }\n          }\n          var6 = *input1;\n          var4 = var7;\n          if (var1 <= var7) {\n            var4 = var1;\n          }\n          var2 = input1[5];\n          if ((input1[4] < var6) && (var8 = input1[2] + var2, (int)var8 < (int)var4)) {\n            FUN_00081e34(var6,var5,var8);\n            *input1 = *input1 + var8;\n            returnValue = FUN_00083850(output,input1);\n            if (returnValue != 0) goto LAB_00083da2;\n          }\n          else if ((int)var4 < (int)var2) {\n            FUN_00081e34(var6,var5,var4);\n            input1[2] = input1[2] - var4;\n            *input1 = var4 + *input1;\n            var8 = var4;\n          }\n          else {\n            var8 = (*(code *)input1[9])(output,input1[7],var5,var2);\n            if ((int)var8 < 1) goto LAB_00083da2;\n          }\n          var7 = var7 - var8;\n          if (var7 == 0) {\n            returnValue = FUN_00083850(output,input1);\n            if (returnValue != 0) goto LAB_00083da2;\n            var9 = 0;\n          }\n          pointer1 = input2[2];\n          var5 = var5 + var8;\n          var1 = var1 - var8;\n          input2[2] = (uint *)((int)pointer1 - var8);\n        } while ((uint *)((int)pointer1 - var8) != (uint *)0x0);\n      }\n    }\n    else {\n      var1 = 0;\n      var4 = 0;\n      do {\n        while( true ) {\n          var7 = var4;\n          if (0x7ffffbff < var4) {\n            var7 = 0x7ffffc00;\n          }\n          if (var4 != 0) break;\n          var1 = *pointer2;\n          var4 = pointer2[1];\n          pointer2 = pointer2 + 2;\n        }\n        returnValue = (*(code *)input1[9])(output,input1[7],var1,var7);\n        if (returnValue < 1) {\nLAB_00083da2:\n          var3 = *(ushort *)(input1 + 3);\nLAB_00083da4:\n          *(ushort *)(input1 + 3) = var3 | 0x40;\n          return 0xffffffff;\n        }\n        pointer1 = input2[2];\n        var1 = var1 + returnValue;\n        var4 = var4 - returnValue;\n        input2[2] = (uint *)((int)pointer1 - returnValue);\n      } while ((uint *)((int)pointer1 - returnValue) != (uint *)0x0);\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00083ca8": "reverse_extracted_code_00083ca8",
                "param_1": "output",
                "param_2": "input1",
                "param_3": "input2",
                "iVar1": "returnValue",
                "uVar2": "var1",
                "uVar3": "var2",
                "uVar4": "var3",
                "uVar5": "var4",
                "puVar6": "pointer1",
                "puVar7": "pointer2",
                "uVar8": "var5",
                "uVar9": "var6",
                "uVar10": "var7",
                "uVar11": "var8",
                "local_2c": "var9"
            },
            "calling": [
                "FUN_00082824"
            ],
            "called": [
                "FUN_00081d48",
                "FUN_00081fac",
                "FUN_00083b10",
                "FUN_00081810",
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_000840f8",
                "FUN_00081e34"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084004": {
            "entrypoint": "0x00084004",
            "current_name": "get_memory_address_00084004",
            "code": "\nuint32_t getMemoryAddress_00084004(void)\n\n{\n  return 0x20070878;\n}\n\n",
            "renaming": {
                "FUN_00084004": "get_memory_address_00084004",
                "undefined4": "uint32_t"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008400c": {
            "entrypoint": "0x0008400c",
            "current_name": "get_rel_offset_0008400c",
            "code": "\ndword getRelOffset_0008400c(void)\n\n{\n  return relTableindex.r_offset;\n}\n\n",
            "renaming": {
                "FUN_0008400c": "get_rel_offset_0008400c",
                "Elf32_Rel_ARRAY_20070000": "relTable",
                "[275]": "index"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084018": {
            "entrypoint": "0x00084018",
            "current_name": "process_data_00084018",
            "code": "\nvoid processData_00084018(int input,int *output)\n\n{\n  ushort value;\n  int status;\n  int result;\n  uint value1;\n  bool flag;\n  undefined stack [4];\n  uint localValue;\n  \n  value = *(ushort *)(output + 3);\n  value1 = (uint)value;\n  if ((int)(value1 << 0x1e) < 0) {\n    *output = (int)output + 0x43;\n    output[4] = (int)output + 0x43;\n    output[5] = 1;\n    return;\n  }\n  if (-1 < *(short *)((int)output + 0xe)) {\n    status = FUN_00084494(input,(int)*(short *)((int)output + 0xe),stack);\n    if (-1 < status) {\n      flag = (localValue & 0xf000) == 0x2000;\n      if (((localValue & 0xf000) == 0x8000) && (output[10] == 0x8427d)) {\n        status = 0x400;\n        *(ushort *)(output + 3) = *(ushort *)(output + 3) | 0x400;\n        output[0x13] = 0x400;\n      }\n      else {\n        status = 0x400;\n        *(ushort *)(output + 3) = *(ushort *)(output + 3) | 0x800;\n      }\n      goto LAB_00084074;\n    }\n    value = *(ushort *)(output + 3);\n    value1 = (uint)value;\n  }\n  *(ushort *)(output + 3) = value | 0x800;\n  if ((value1 & 0x80) == 0) {\n    status = 0x400;\n  }\n  else {\n    status = 0x40;\n  }\n  flag = false;\nLAB_00084074:\n  result = FUN_00081810(input,status);\n  value = *(ushort *)(output + 3);\n  if (result == 0) {\n    if (-1 < (int)((uint)value << 0x16)) {\n      *(ushort *)(output + 3) = value | 2;\n      *output = (int)output + 0x43;\n      output[4] = (int)output + 0x43;\n      output[5] = 1;\n    }\n  }\n  else {\n    *(undefined **)(input + 0x3c) = &LAB_0008387c_1;\n    *(ushort *)(output + 3) = value | 0x80;\n    *output = result;\n    output[4] = result;\n    output[5] = status;\n    if ((flag) && (status = FUN_000844bc(input,(int)*(short *)((int)output + 0xe)), status != 0))\n    {\n      *(ushort *)(output + 3) = *(ushort *)(output + 3) | 1;\n    }\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084018": "process_data_00084018",
                "param_1": "input",
                "param_2": "output",
                "uVar1": "value",
                "iVar2": "status",
                "iVar3": "result",
                "uVar4": "value1",
                "bVar5": "flag",
                "auStack_54": "stack",
                "local_50": "localValue"
            },
            "calling": [
                "FUN_0008356c"
            ],
            "called": [
                "FUN_00081810",
                "FUN_00084494",
                "FUN_000844bc"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000840f8": {
            "entrypoint": "0x000840f8",
            "current_name": "find_character_sequence_000840f8",
            "code": "\nuint * find_character_sequence_000840f8(uint *input_array,char target_character,uint array_length)\n\n{\n  uint temp_result;\n  int index;\n  uint *current_pointer;\n  bool is_last_element;\n  \n  if (((uint)input_array & 3) == 0) {\nLAB_00084128:\n    if (3 < array_length) {\n      current_pointer = input_array;\n      do {\n        temp_result = *current_pointer ^ CONCAT22(CONCAT11(target_character,target_character),CONCAT11(target_character,target_character));\n        input_array = current_pointer;\n        if ((temp_result + 0xfefefeff & ~temp_result & 0x80808080) != 0) break;\n        array_length = array_length - 4;\n        input_array = current_pointer + 1;\n        current_pointer = current_pointer + 1;\n      } while (3 < array_length);\n    }\n    if (array_length == 0) {\n      input_array = (uint *)0x0;\n    }\n    else if (*(char *)input_array != target_character) {\n      index = 0;\n      do {\n        input_array = (uint *)((int)input_array + 1);\n        is_last_element = index == array_length - 1;\n        index = index + 1;\n        if (is_last_element) goto LAB_00084150;\n      } while (*(char *)input_array != target_character);\n    }\n  }\n  else if (array_length == 0) {\nLAB_00084150:\n    input_array = (uint *)0x0;\n  }\n  else if (*(char *)input_array != target_character) {\n    current_pointer = (uint *)((int)input_array + 1);\n    array_length = array_length - 1;\n    do {\n      input_array = current_pointer;\n      if (((uint)input_array & 3) == 0) goto LAB_00084128;\n      if (array_length == 0) goto LAB_00084150;\n      current_pointer = (uint *)((int)input_array + 1);\n      array_length = array_length - 1;\n    } while (*(char *)input_array != target_character);\n  }\n  return input_array;\n}\n\n",
            "renaming": {
                "FUN_000840f8": "find_character_sequence_000840f8",
                "param_1": "input_array",
                "param_2": "target_character",
                "param_3": "array_length",
                "uVar1": "temp_result",
                "iVar2": "index",
                "puVar3": "current_pointer",
                "bVar4": "is_last_element"
            },
            "calling": [
                "FUN_0008289c",
                "FUN_00083ca8"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000841e4": {
            "entrypoint": "0x000841e4",
            "current_name": "process_param_000841e4",
            "code": "\nint processParam_000841e4(uint param)\n\n{\n  dword offset;\n  undefined4 result;\n  int ptr;\n  code *codePtr;\n  undefined4 unusedVar1;\n  undefined4 unusedVar2;\n  undefined4 unusedVar3;\n  undefined4 baseAddr;\n  \n  offset = Elf32_Rel_ARRAY_20070000[140].r_offset;\n  baseAddr = 0x20070460;\n  if (0x1f < param) {\n    *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n    return -1;\n  }\n  ptr = *(int *)(Elf32_Rel_ARRAY_20070000[140].r_offset + 0x2dc);\n  if ((ptr == 0) || (codePtr = *(code **)(ptr + param * 4), codePtr == (code *)0x0)) {\n    result = thunk_FUN_00080efe(Elf32_Rel_ARRAY_20070000[140].r_offset);\n    DAT_20071244 = 0;\n    ptr = FUNC_00080efc(result,param,param,0,baseAddr,unusedVar1,unusedVar2,unusedVar3);\n    if ((ptr == -1) && (DAT_20071244 != 0)) {\n      *(int *)offset = DAT_20071244;\n      return -1;\n    }\n    return ptr;\n  }\n  if (codePtr == (code *)0x1) {\n    return 0;\n  }\n  if (codePtr != (code *)0xffffffff) {\n    *(undefined4 *)(ptr + param * 4) = 0;\n    (*codePtr)(param);\n    return 0;\n  }\n  *(undefined4 *)Elf32_Rel_ARRAY_20070000[140].r_offset = 0x16;\n  return 1;\n}\n\n",
            "renaming": {
                "FUN_000841e4": "process_param_000841e4",
                "param_1": "param",
                "dVar1": "offset",
                "uVar2": "result",
                "iVar3": "ptr",
                "pcVar4": "codePtr",
                "unaff_r4": "unusedVar1",
                "unaff_r5": "unusedVar2",
                "in_lr": "unusedVar3",
                "uVar5": "baseAddr"
            },
            "calling": [
                "FUN_000836ec"
            ],
            "called": [
                "FUN_00080efc",
                "thunk_FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "thunk_FUN_00080efe": {
            "entrypoint": "0x0008421c",
            "current_name": "get_default_value_thunk_00080efe",
            "code": "\nundefined4 get_default_value_thunk_00080efe(void)\n\n{\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "thunk_FUN_00080efe": "get_default_value_thunk_00080efe"
            },
            "calling": [
                "FUN_000841e4"
            ],
            "called": [
                "FUN_00080efe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084220": {
            "entrypoint": "0x00084220",
            "current_name": "update_variable_00084220",
            "code": "\nvoid updateVariable_00084220(undefined4 arg1,int arg2)\n\n{\n  int returnValue;\n  \n  returnValue = FUN_00084508(arg1,(int)*(short *)(arg2 + 0xe));\n  if (-1 < returnValue) {\n    *(int *)(arg2 + 0x50) = *(int *)(arg2 + 0x50) + returnValue;\n    return;\n  }\n  *(ushort *)(arg2 + 0xc) = *(ushort *)(arg2 + 0xc) & 0xefff;\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084220": "update_variable_00084220",
                "param_1": "arg1",
                "param_2": "arg2",
                "iVar1": "returnValue"
            },
            "calling": [],
            "called": [
                "FUN_00084508"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084244": {
            "entrypoint": "0x00084244",
            "current_name": "update_data_00084244",
            "code": "\nvoid updateData_00084244(int *output,int dataBuffer,undefined4 param1,undefined4 param2)\n\n{\n  int result;\n  ushort dataValue;\n  undefined4 unused1;\n  undefined4 unused2;\n  undefined4 unused3;\n  undefined4 unused4;\n  \n  dataValue = *(ushort *)(dataBuffer + 0xc);\n  if ((int)((uint)dataValue << 0x17) < 0) {\n    FUN_000844e0(output,(int)*(short *)(dataBuffer + 0xe),0,2);\n    dataValue = *(ushort *)(dataBuffer + 0xc);\n  }\n  *(ushort *)(dataBuffer + 0xc) = dataValue & 0xefff;\n  DAT_20071244 = 0;\n  result = FUN_00080ec8((int)*(short *)(dataBuffer + 0xe),param1,param2,param2,unused1,unused2,\n                       unused3,unused4);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *output = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084244": "update_data_00084244",
                "param_1": "output",
                "param_2": "dataBuffer",
                "param_3": "param1",
                "param_4": "param2",
                "unaff_r4": "unused1",
                "unaff_r5": "unused2",
                "unaff_r6": "unused3",
                "in_lr": "unused4",
                "uVar2": "dataValue",
                "iVar1": "result"
            },
            "calling": [],
            "called": [
                "FUN_00080ec8",
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008427c": {
            "entrypoint": "0x0008427c",
            "current_name": "update_status_0008427c",
            "code": "\nvoid updateStatus_0008427c(undefined4 param1,int param2)\n\n{\n  int result;\n  ushort updatedValue;\n  \n  result = FUN_000844e0(param1,(int)*(short *)(param2 + 0xe));\n  if (result == -1) {\n    updatedValue = *(ushort *)(param2 + 0xc) & 0xefff;\n  }\n  else {\n    updatedValue = *(ushort *)(param2 + 0xc) | 0x1000;\n  }\n  if (result != -1) {\n    *(int *)(param2 + 0x50) = result;\n  }\n  *(ushort *)(param2 + 0xc) = updatedValue;\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008427c": "update_status_0008427c",
                "param_1": "param1",
                "param_2": "param2",
                "iVar1": "result",
                "uVar2": "updatedValue"
            },
            "calling": [],
            "called": [
                "FUN_000844e0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000842a4": {
            "entrypoint": "0x000842a4",
            "current_name": "process_data_000842a4",
            "code": "\nuint processData_000842a4(int value1,uint value2,undefined4 *data,undefined4 value3)\n\n{\n  ushort ushortValue;\n  uint uintValue;\n  undefined *pointer;\n  int intValue;\n  \n  if ((value1 != 0) && (*(int *)(value1 + 0x38) == 0)) {\n    FUN_00083888();\n  }\n  ushortValue = *(ushort *)(data + 3);\n  uintValue = (uint)ushortValue;\n  data[2] = data[6];\n  if ((-1 < (int)(uintValue << 0x1c)) || (intValue = data[4], intValue == 0)) {\n    intValue = FUN_0008356c(value1,data,ushortValue,uintValue,value3);\n    if (intValue != 0) {\n      return 0xffffffff;\n    }\n    ushortValue = *(ushort *)(data + 3);\n    intValue = data[4];\n    uintValue = (uint)ushortValue;\n  }\n  value2 = value2 & 0xff;\n  if ((int)(uintValue << 0x12) < 0) {\n    pointer = (undefined *)*data;\n    intValue = (int)pointer - intValue;\n    if (intValue < (int)data[5]) {\nLAB_000842d6:\n      intValue = intValue + 1;\n      goto LAB_000842d8;\n    }\n  }\n  else {\n    data[0x19] = data[0x19] & 0xffffdfff;\n    pointer = (undefined *)*data;\n    *(ushort *)(data + 3) = ushortValue | 0x2000;\n    intValue = (int)pointer - intValue;\n    if (intValue < (int)data[5]) goto LAB_000842d6;\n  }\n  intValue = FUN_00083850(value1,data);\n  if (intValue != 0) {\n    return 0xffffffff;\n  }\n  pointer = (undefined *)*data;\n  intValue = 1;\nLAB_000842d8:\n  data[2] = data[2] + -1;\n  *data = pointer + 1;\n  *pointer = (char)value2;\n  if (((data[5] == intValue) ||\n      (((int)((uint)*(ushort *)(data + 3) << 0x1f) < 0 && (value2 == 10)))) &&\n     (intValue = FUN_00083850(value1,data), intValue != 0)) {\n    return 0xffffffff;\n  }\n  return value2;\n}\n\n",
            "renaming": {
                "FUN_000842a4": "process_data_000842a4",
                "param_1": "value1",
                "param_2": "value2",
                "param_3": "data",
                "param_4": "value3",
                "uVar1": "ushortValue",
                "uVar2": "uintValue",
                "puVar3": "pointer",
                "iVar4": "intValue"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008356c",
                "FUN_00083850",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008434c": {
            "entrypoint": "0x0008434c",
            "current_name": "process_function_0008434c",
            "code": "\nvoid processFunction_0008434c(undefined4 *output,int value,undefined4 parameter,undefined4 *result)\n\n{\n  dword rInfo;\n  undefined4 helper;\n  int returnValue;\n  undefined stackData [12];\n  \n  rInfo = Elf32_Rel_ARRAY_20070000[275].r_info;\n  if (value == 0) {\n    helper = FUN_00084004();\n    returnValue = (*(code *)rInfo)(output,stackData,0,helper,result);\n  }\n  else {\n    helper = FUN_00084004();\n    returnValue = (*(code *)rInfo)(output,value,parameter,helper,result);\n  }\n  if (returnValue == -1) {\n    *result = 0;\n    *output = 0x8a;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008434c": "process_function_0008434c",
                "param_1": "output",
                "param_2": "value",
                "param_3": "parameter",
                "param_4": "result",
                "dVar1": "rInfo",
                "uVar2": "helper",
                "iVar3": "returnValue",
                "auStack_24": "stackData"
            },
            "calling": [
                "FUN_000839b4"
            ],
            "called": [
                "FUN_0008439c",
                "FUN_00084004"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008439c": {
            "entrypoint": "0x0008439c",
            "current_name": "write_byte_to_memory_0008439c",
            "code": "\nundefined4 write_byte_to_memory_0008439c(undefined4 *memory_address,undefined *data,uint value)\n\n{\n  if (data == (undefined *)0x0) {\n    return 0;\n  }\n  if (value < 0x100) {\n    *data = (char)value;\n    return 1;\n  }\n  *memory_address = 0x8a;\n  return 0xffffffff;\n}\n\n",
            "renaming": {
                "FUN_0008439c": "write_byte_to_memory_0008439c",
                "param_1": "memory_address",
                "param_2": "data",
                "param_3": "value"
            },
            "calling": [
                "FUN_0008434c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084484": {
            "entrypoint": "0x00084484",
            "current_name": "check_and_process_param_00084484",
            "code": "\nundefined4 check_and_process_param_00084484(int param)\n\n{\n  dword r_offset;\n  undefined4 result;\n  int temp;\n  \n  r_offset = rel_array[140].r_offset;\n  if (param != 0) {\n    if ((rel_array[140].r_offset != 0) &&\n       (*(int *)(rel_array[140].r_offset + 0x38) == 0)) {\n      FUN_00083888();\n    }\n    if (*(short *)(param + 0xc) != 0) {\n      result = FUN_00083850(r_offset,param);\n      if ((*(code **)(param + 0x2c) != (code *)0x0) &&\n         (temp = (**(code **)(param + 0x2c))(r_offset,*(undefined4 *)(param + 0x1c)), temp < 0))\n      {\n        result = 0xffffffff;\n      }\n      if ((int)((uint)*(ushort *)(param + 0xc) << 0x18) < 0) {\n        FUN_00083b10(r_offset,*(undefined4 *)(param + 0x10));\n      }\n      if (*(int *)(param + 0x30) != 0) {\n        if (*(int *)(param + 0x30) != param + 0x40) {\n          FUN_00083b10(r_offset);\n        }\n        *(undefined4 *)(param + 0x30) = 0;\n      }\n      if (*(int *)(param + 0x44) != 0) {\n        FUN_00083b10(r_offset);\n        *(undefined4 *)(param + 0x44) = 0;\n      }\n      FUNC_0008397c();\n      *(undefined2 *)(param + 0xc) = 0;\n      FUNC_00083980();\n      return result;\n    }\n  }\n  return 0;\n}\n\n",
            "renaming": {
                "FUN_00084484": "check_and_process_param_00084484",
                "param_1": "param",
                "dVar1": "r_offset",
                "uVar2": "result",
                "iVar3": "temp",
                "Elf32_Rel_ARRAY_20070000": "rel_array"
            },
            "calling": [],
            "called": [
                "FUN_00083b10",
                "FUN_00083850",
                "FUN_00083980",
                "FUN_0008397c",
                "FUN_00083888"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084494": {
            "entrypoint": "0x00084494",
            "current_name": "find_and_update_value_00084494",
            "code": "\nvoid find_and_update_value_00084494(int *result,undefined4 value_1,undefined4 value_2,undefined4 value_3)\n\n{\n  int func_result;\n  \n  DAT_20071244 = 0;\n  func_result = FUN_00080eb0(value_1,value_2,value_2,0,value_3);\n  if ((func_result == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084494": "find_and_update_value_00084494",
                "param_1": "result",
                "param_2": "value_1",
                "param_3": "value_2",
                "param_4": "value_3",
                "iVar1": "func_result"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eb0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844bc": {
            "entrypoint": "0x000844bc",
            "current_name": "check_and_update_value_000844bc",
            "code": "\nvoid checkAndUpdateValue_000844bc(int *outputValue,undefined4 inputValue)\n\n{\n  int result;\n  \n  DAT_20071244 = 0;\n  result = FUN_00080eba(inputValue);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *outputValue = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844bc": "check_and_update_value_000844bc",
                "param_1": "outputValue",
                "param_2": "inputValue",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00084018"
            ],
            "called": [
                "FUN_00080eba"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000844e0": {
            "entrypoint": "0x000844e0",
            "current_name": "check_and_update_result_000844e0",
            "code": "\nvoid checkAndUpdateResult_000844e0(int *result,undefined4 value1,undefined4 value2,undefined4 value3)\n\n{\n  int status;\n  \n  DAT_20071244 = 0;\n  status = FUN_00080ebe(value1,value2,value3);\n  if ((status == -1) && (DAT_20071244 != 0)) {\n    *result = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_000844e0": "check_and_update_result_000844e0",
                "param_1": "result",
                "param_2": "value1",
                "param_3": "value2",
                "param_4": "value3",
                "iVar1": "status"
            },
            "calling": [
                "FUN_0008427c",
                "FUN_00084244"
            ],
            "called": [
                "FUN_00080ebe"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084508": {
            "entrypoint": "0x00084508",
            "current_name": "check_and_set_param_00084508",
            "code": "\nvoid checkAndSetParam_00084508(int *outputParam,undefined4 input1,undefined4 input2,undefined4 input3)\n\n{\n  int result;\n  \n  DAT_20071244 = 0;\n  result = FUN_00080ec2(input1,input2,input3);\n  if ((result == -1) && (DAT_20071244 != 0)) {\n    *outputParam = DAT_20071244;\n    return;\n  }\n  return;\n}\n\n",
            "renaming": {
                "FUN_00084508": "check_and_set_param_00084508",
                "param_1": "outputParam",
                "param_2": "input1",
                "param_3": "input2",
                "param_4": "input3",
                "iVar1": "result"
            },
            "calling": [
                "FUN_00084220"
            ],
            "called": [
                "FUN_00080ec2"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084530": {
            "entrypoint": "0x00084530",
            "current_name": "handle_zero_params_00084530",
            "code": "\nint handleZeroParams_00084530(int input1,int input2,int input3,int input4)\n\n{\n  int result;\n  \n  if ((input4 == 0) && (input3 == 0)) {\n    if (input2 != 0 || input1 != 0) {\n      input1 = -1;\n    }\n    return input1;\n  }\n  result = FUN_0008458c();\n  return result;\n}\n\n",
            "renaming": {
                "FUN_00084530": "handle_zero_params_00084530",
                "param_1": "input1",
                "param_2": "input2",
                "param_3": "input3",
                "param_4": "input4",
                "iVar1": "result"
            },
            "calling": [
                "FUN_0008289c"
            ],
            "called": [
                "FUN_0008458c"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008455c": {
            "entrypoint": "0x0008455c",
            "current_name": "subtract_and_store_0008455c",
            "code": "\nvoid subtractAndStore_0008455c(uint inputValue,int subtractValue,undefined4 lowParam,undefined4 highParam,int *outputArray)\n\n{\n  uint result;\n  longlong calculatedValue;\n  \n  calculatedValue = FUN_000845c0();\n  calculatedValue = calculatedValue * CONCAT44(highParam,lowParam);\n  result = (uint)calculatedValue;\n  *outputArray = inputValue - result;\n  outputArray[1] = (subtractValue - (int)((ulonglong)calculatedValue >> 0x20)) - (uint)(inputValue < result);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008455c": "subtract_and_store_0008455c",
                "param_1": "inputValue",
                "param_2": "subtractValue",
                "param_3": "lowParam",
                "param_4": "highParam",
                "param_5": "outputArray",
                "uVar1": "result",
                "lVar2": "calculatedValue"
            },
            "calling": [],
            "called": [
                "FUN_000845c0"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_0008458c": {
            "entrypoint": "0x0008458c",
            "current_name": "calculate_difference_0008458c",
            "code": "\nvoid calculateDifference_0008458c(uint inputValue,int anotherValue,undefined4 multiplier1,undefined4 multiplier2,int *resultArray)\n\n{\n  uint calculatedValue;\n  longlong tempResult;\n  \n  tempResult = FUN_00084860();\n  tempResult = tempResult * CONCAT44(multiplier2,multiplier1);\n  calculatedValue = (uint)tempResult;\n  *resultArray = inputValue - calculatedValue;\n  resultArray[1] = (anotherValue - (int)((ulonglong)tempResult >> 0x20)) - (uint)(inputValue < calculatedValue);\n  return;\n}\n\n",
            "renaming": {
                "FUN_0008458c": "calculate_difference_0008458c",
                "param_1": "inputValue",
                "param_2": "anotherValue",
                "param_3": "multiplier1",
                "param_4": "multiplier2",
                "param_5": "resultArray",
                "uVar1": "calculatedValue",
                "lVar2": "tempResult"
            },
            "calling": [
                "FUN_00084530"
            ],
            "called": [
                "FUN_00084860"
            ],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_000845c0": {
            "entrypoint": "0x000845c0",
            "current_name": "divide_with_overflow_check_000845c0",
            "code": "\nundefined8 divideWithOverflowCheck_000845c0(uint dividend,uint dividend_high,uint divisor_low,uint divisor_high)\n\n{\n  longlong temp_long;\n  uint quotient_low;\n  uint quotient_high;\n  uint temp1;\n  uint temp2;\n  int shift_count;\n  uint temp3;\n  uint temp4;\n  uint is_negative_dividend;\n  uint temp5;\n  uint temp6;\n  uint temp7;\n  bool carry_flag;\n  \n  if ((int)dividend_high < 0) {\n    carry_flag = dividend != 0;\n    dividend = -dividend;\n    dividend_high = -dividend_high - (uint)carry_flag;\n    is_negative_dividend = 0xffffffff;\n  }\n  else {\n    is_negative_dividend = 0;\n  }\n  if ((int)divisor_high < 0) {\n    is_negative_dividend = ~is_negative_dividend;\n    carry_flag = divisor_low != 0;\n    divisor_low = -divisor_low;\n    divisor_high = -divisor_high - (uint)carry_flag;\n  }\n  if (divisor_high == 0) {\n    if (dividend_high < divisor_low) {\n      shift_count = LZCOUNT(divisor_low);\n      if (shift_count != 0) {\n        quotient_high = dividend >> (0x20U - shift_count & 0xff);\n        divisor_low = divisor_low << shift_count;\n        dividend = dividend << shift_count;\n        dividend_high = dividend_high << shift_count | quotient_high;\n      }\n      quotient_low = divisor_low >> 0x10;\n      temp1 = dividend_high / quotient_low;\n      temp3 = (divisor_low & 0xffff) * temp1;\n      temp5 = dividend >> 0x10 | (dividend_high - quotient_low * temp1) * 0x10000;\n      quotient_high = temp1;\n      if (temp5 <= temp3 && temp3 - temp5 != 0) {\n        carry_flag = CARRY4(temp5,divisor_low);\n        temp5 = temp5 + divisor_low;\n        quotient_high = temp1 - 1;\n        if ((carry_flag == false) && (temp5 <= temp3 && temp3 - temp5 != 0)) {\n          quotient_high = temp1 - 2;\n          temp5 = temp5 + divisor_low;\n        }\n      }\n      temp4 = (temp5 - temp3) / quotient_low;\n      temp1 = (divisor_low & 0xffff) * temp4;\n      temp3 = dividend & 0xffff | ((temp5 - temp3) - quotient_low * temp4) * 0x10000;\n      quotient_low = temp4;\n      if (temp3 <= temp1 && temp1 - temp3 != 0) {\n        quotient_low = temp4 - 1;\n        if ((CARRY4(temp3,divisor_low) == false) &&\n           (temp3 + divisor_low <= temp1 && temp1 - (temp3 + divisor_low) != 0)) {\n          quotient_low = temp4 - 2;\n        }\n      }\n      quotient_low = quotient_low | quotient_high << 0x10;\n      quotient_high = 0;\n    }\n    else {\n      if (divisor_low == 0) {\n        divisor_low = 1 / 0;\n      }\n      shift_count = LZCOUNT(divisor_low);\n      if (shift_count == 0) {\n        dividend_high = dividend_high - divisor_low;\n        temp1 = divisor_low >> 0x10;\n        temp7 = divisor_low & 0xffff;\n        quotient_high = 1;\n      }\n      else {\n        divisor_low = divisor_low << shift_count;\n        quotient_high = dividend_high >> (0x20U - shift_count & 0xff);\n        temp1 = divisor_low >> 0x10;\n        temp5 = quotient_high / temp1;\n        temp7 = divisor_low & 0xffff;\n        temp3 = temp7 * temp5;\n        temp4 = dividend >> (0x20U - shift_count & 0xff) | dividend_high << shift_count;\n        quotient_high = temp4 >> 0x10 | (quotient_high - temp1 * temp5) * 0x10000;\n        dividend = dividend << shift_count;\n        quotient_low = temp5;\n        if (quotient_high <= temp3 && temp3 - quotient_high != 0) {\n          carry_flag = CARRY4(quotient_high,divisor_low);\n          quotient_high = quotient_high + divisor_low;\n          quotient_low = temp5 - 1;\n          if ((carry_flag == false) && (quotient_high <= temp3 && temp3 - quotient_high != 0)) {\n            quotient_low = temp5 - 2;\n            quotient_high = quotient_high + divisor_low;\n          }\n        }\n        temp2 = (quotient_high - temp3) / temp1;\n        temp5 = temp7 * temp2;\n        dividend_high = temp4 & 0xffff | ((quotient_high - temp3) - temp1 * temp2) * 0x10000;\n        quotient_high = temp2;\n        if (dividend_high <= temp5 && temp5 - dividend_high != 0) {\n          carry_flag = CARRY4(dividend_high,divisor_low);\n          dividend_high = dividend_high + divisor_low;\n          quotient_high = temp2 - 1;\n          if ((carry_flag == false) && (dividend_high <= temp5 && temp5 - dividend_high != 0)) {\n            quotient_high = temp2 - 2;\n            dividend_high = dividend_high + divisor_low;\n          }\n        }\n        dividend_high = dividend_high - temp5;\n        quotient_high = quotient_high | quotient_low << 0x10;\n      }\n      quotient_low = dividend_high / temp1;\n      temp5 = temp7 * quotient_low;\n      temp4 = dividend >> 0x10 | (dividend_high - temp1 * quotient_low) * 0x10000;\n      temp3 = quotient_low;\n      if (temp4 <= temp5 && temp5 - temp4 != 0) {\n        carry_flag = CARRY4(temp4,divisor_low);\n        temp4 = temp4 + divisor_low;\n        temp3 = quotient_low - 1;\n        if ((carry_flag == false) && (temp4 <= temp5 && temp5 - temp4 != 0)) {\n          temp3 = quotient_low - 2;\n          temp4 = temp4 + divisor_low;\n        }\n      }\n      temp2 = (temp4 - temp5) / temp1;\n      temp7 = temp7 * temp2;\n      temp1 = dividend & 0xffff | ((temp4 - temp5) - temp1 * temp2) * 0x10000;\n      quotient_low = temp2;\n      if (temp1 <= temp7 && temp7 - temp1 != 0) {\n        quotient_low = temp2 - 1;\n        if ((CARRY4(temp1,divisor_low) == false) &&\n           (temp1 + divisor_low <= temp7 && temp7 - (temp1 + divisor_low) != 0)) {\n          quotient_low = temp2 - 2;\n        }\n      }\n      quotient_low = quotient_low | temp3 << 0x10;\n    }\n  }\n  else if (dividend_high < divisor_high) {\n    quotient_high = 0;\n    quotient_low = 0;\n  }\n  else {\n    shift_count = LZCOUNT(divisor_high);\n    if (shift_count == 0) {\n      if ((divisor_high < dividend_high) || (divisor_low <= dividend)) {\n        quotient_high = 0;\n        quotient_low = 1;\n      }\n      else {\n        quotient_low = 0;\n        quotient_high = 0;\n      }\n    }\n    else {\n      quotient_high = 0x20 - shift_count;\n      temp1 = dividend_high >> (quotient_high & 0xff);\n      temp7 = divisor_low >> (quotient_high & 0xff) | divisor_high << shift_count;\n      temp5 = temp7 >> 0x10;\n      quotient_low = temp1 / temp5;\n      temp4 = (temp7 & 0xffff) * quotient_low;\n      temp3 = dividend_high << shift_count | dividend >> (quotient_high & 0xff);\n      temp1 = temp3 >> 0x10 | (temp1 - temp5 * quotient_low) * 0x10000;\n      quotient_high = quotient_low;\n      if (temp1 <= temp4 && temp4 - temp1 != 0) {\n        carry_flag = CARRY4(temp1,temp7);\n        temp1 = temp1 + temp7;\n        quotient_high = quotient_low - 1;\n        if ((carry_flag == false) && (temp1 <= temp4 && temp4 - temp1 != 0)) {\n          quotient_high = quotient_low - 2;\n          temp1 = temp1 + temp7;\n        }\n      }\n      temp2 = (temp1 - temp4) / temp5;\n      temp6 = (temp7 & 0xffff) * temp2;\n      temp1 = temp3 & 0xffff | ((temp1 - temp4) - temp5 * temp2) * 0x10000;\n      quotient_low = temp2;\n      if (temp1 <= temp6 && temp6 - temp1 != 0) {\n        carry_flag = CARRY4(temp1,temp7);\n        temp1 = temp1 + temp7;\n        quotient_low = temp2 - 1;\n        if ((carry_flag == false) && (temp1 <= temp6 && temp6 - temp1 != 0)) {\n          quotient_low = temp2 - 2;\n          temp1 = temp1 + temp7;\n        }\n      }\n      quotient_low = quotient_low | quotient_high << 0x10;\n      temp_long = (ulonglong)quotient_low * (ulonglong)(divisor_low << shift_count);\n      temp3 = (uint)((ulonglong)temp_long >> 0x20);\n      quotient_high = 0;\n      if ((temp1 - temp6 < temp3) ||\n         ((temp1 - temp6 == temp3 && (dividend << shift_count < (uint)temp_long)))) {\n        quotient_low = quotient_low - 1;\n        quotient_high = 0;\n      }\n    }\n  }\n  if (is_negative_dividend != 0) {\n    carry_flag = quotient_low != 0;\n    quotient_low = -quotient_low;\n    quotient_high = -quotient_high - (uint)carry_flag;\n  }\n  return CONCAT44(quotient_high,quotient_low);\n}\n\n",
            "renaming": {
                "FUN_000845c0": "divide_with_overflow_check_000845c0",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor_low",
                "param_4": "divisor_high",
                "lVar1": "temp_long",
                "uVar2": "quotient_low",
                "uVar3": "quotient_high",
                "uVar4": "temp1",
                "uVar5": "temp2",
                "iVar6": "shift_count",
                "uVar7": "temp3",
                "uVar8": "temp4",
                "uVar9": "is_negative_dividend",
                "uVar10": "temp5",
                "uVar11": "temp6",
                "uVar12": "temp7",
                "bVar13": "carry_flag"
            },
            "calling": [
                "FUN_0008455c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00084860": {
            "entrypoint": "0x00084860",
            "current_name": "divide_and_calculate_remainder_00084860",
            "code": "\nulonglong divideAndCalculateRemainder_00084860(uint dividend,uint dividend_high,uint divisor,uint divisor_high)\n\n{\n  longlong result;\n  uint quotient_low;\n  uint quotient_high;\n  uint remainder_low;\n  uint remainder_high;\n  uint temp1;\n  uint temp2;\n  uint temp3;\n  uint temp4;\n  int shift_amount;\n  bool carry_flag;\n  \n  if (divisor_high == 0) {\n    if (divisor <= dividend_high) {\n      if (divisor == 0) {\n        divisor = 1 / 0;\n      }\n      shift_amount = LZCOUNT(divisor);\n      if (shift_amount == 0) {\n        dividend_high = dividend_high - divisor;\n        quotient_high = divisor >> 0x10;\n        remainder_high = divisor & 0xffff;\n        quotient_low = 1;\n      }\n      else {\n        divisor = divisor << shift_amount;\n        temp3 = dividend_high >> (0x20U - shift_amount & 0xff);\n        quotient_high = divisor >> 0x10;\n        temp4 = temp3 / quotient_high;\n        remainder_high = divisor & 0xffff;\n        quotient_low = remainder_high * temp4;\n        temp1 = dividend >> (0x20U - shift_amount & 0xff) | dividend_high << shift_amount;\n        remainder_low = temp1 >> 0x10 | (temp3 - quotient_high * temp4) * 0x10000;\n        dividend = dividend << shift_amount;\n        temp3 = temp4;\n        if (remainder_low <= quotient_low && quotient_low - remainder_low != 0) {\n          carry_flag = CARRY4(remainder_low,divisor);\n          remainder_low = remainder_low + divisor;\n          temp3 = temp4 - 1;\n          if ((carry_flag == false) && (remainder_low <= quotient_low && quotient_low - remainder_low != 0)) {\n            temp3 = temp4 - 2;\n            remainder_low = remainder_low + divisor;\n          }\n        }\n        temp2 = (remainder_low - quotient_low) / quotient_high;\n        temp4 = remainder_high * temp2;\n        dividend_high = temp1 & 0xffff | ((remainder_low - quotient_low) - quotient_high * temp2) * 0x10000;\n        quotient_low = temp2;\n        if (dividend_high <= temp4 && temp4 - dividend_high != 0) {\n          carry_flag = CARRY4(dividend_high,divisor);\n          dividend_high = dividend_high + divisor;\n          quotient_low = temp2 - 1;\n          if ((carry_flag == false) && (dividend_high <= temp4 && temp4 - dividend_high != 0)) {\n            quotient_low = temp2 - 2;\n            dividend_high = dividend_high + divisor;\n          }\n        }\n        dividend_high = dividend_high - temp4;\n        quotient_low = quotient_low | temp3 << 0x10;\n      }\n      temp4 = dividend_high / quotient_high;\n      remainder_low = remainder_high * temp4;\n      temp1 = dividend >> 0x10 | (dividend_high - quotient_high * temp4) * 0x10000;\n      temp3 = temp4;\n      if (temp1 <= remainder_low && remainder_low - temp1 != 0) {\n        carry_flag = CARRY4(temp1,divisor);\n        temp1 = temp1 + divisor;\n        temp3 = temp4 - 1;\n        if ((carry_flag == false) && (temp1 <= remainder_low && remainder_low - temp1 != 0)) {\n          temp3 = temp4 - 2;\n          temp1 = temp1 + divisor;\n        }\n      }\n      temp4 = (temp1 - remainder_low) / quotient_high;\n      remainder_high = remainder_high * temp4;\n      temp1 = dividend & 0xffff | ((temp1 - remainder_low) - quotient_high * temp4) * 0x10000;\n      quotient_high = temp4;\n      if (temp1 <= remainder_high && remainder_high - temp1 != 0) {\n        quotient_high = temp4 - 1;\n        if ((CARRY4(temp1,divisor) == false) &&\n           (temp1 + divisor <= remainder_high && remainder_high - (temp1 + divisor) != 0)) {\n          quotient_high = temp4 - 2;\n        }\n      }\n      return CONCAT44(quotient_low,quotient_high | temp3 << 0x10);\n    }\n    shift_amount = LZCOUNT(divisor);\n    if (shift_amount != 0) {\n      temp3 = dividend >> (0x20U - shift_amount & 0xff);\n      divisor = divisor << shift_amount;\n      dividend = dividend << shift_amount;\n      dividend_high = temp3 | dividend_high << shift_amount;\n    }\n    quotient_low = divisor >> 0x10;\n    quotient_high = dividend_high / quotient_low;\n    remainder_high = (divisor & 0xffff) * quotient_high;\n    temp4 = dividend >> 0x10 | (dividend_high - quotient_low * quotient_high) * 0x10000;\n    temp3 = quotient_high;\n    if (temp4 <= remainder_high && remainder_high - temp4 != 0) {\n      carry_flag = CARRY4(temp4,divisor);\n      temp4 = temp4 + divisor;\n      temp3 = quotient_high - 1;\n      if ((carry_flag == false) && (temp4 <= remainder_high && remainder_high - temp4 != 0)) {\n        temp3 = quotient_high - 2;\n        temp4 = temp4 + divisor;\n      }\n    }\n    temp1 = (temp4 - remainder_high) / quotient_low;\n    quotient_high = (divisor & 0xffff) * temp1;\n    remainder_high = dividend & 0xffff | ((temp4 - remainder_high) - quotient_low * temp1) * 0x10000;\n    quotient_low = temp1;\n    if (remainder_high <= quotient_high && quotient_high - remainder_high != 0) {\n      quotient_low = temp1 - 1;\n      if ((CARRY4(remainder_high,divisor) == false) &&\n         (remainder_high + divisor <= quotient_high && quotient_high - (remainder_high + divisor) != 0)) {\n        quotient_low = temp1 - 2;\n      }\n    }\n    quotient_low = quotient_low | temp3 << 0x10;\n  }\n  else {\n    if (dividend_high < divisor_high) {\n      return 0;\n    }\n    shift_amount = LZCOUNT(divisor_high);\n    if (shift_amount == 0) {\n      if ((divisor_high < dividend_high) || (divisor <= dividend)) {\n        return 1;\n      }\n      quotient_low = 0;\n    }\n    else {\n      quotient_low = 0x20 - shift_amount;\n      temp3 = dividend_high >> (quotient_low & 0xff);\n      quotient_high = divisor_high << shift_amount | divisor >> (quotient_low & 0xff);\n      remainder_high = quotient_high >> 0x10;\n      remainder_low = temp3 / remainder_high;\n      temp4 = (quotient_high & 0xffff) * remainder_low;\n      temp1 = dividend >> (quotient_low & 0xff) | dividend_high << shift_amount;\n      quotient_low = temp1 >> 0x10 | (temp3 - remainder_high * remainder_low) * 0x10000;\n      temp3 = remainder_low;\n      if (quotient_low <= temp4 && temp4 - quotient_low != 0) {\n        carry_flag = CARRY4(quotient_low,quotient_high);\n        quotient_low = quotient_low + quotient_high;\n        temp3 = remainder_low - 1;\n        if ((carry_flag == false) && (quotient_low <= temp4 && temp4 - quotient_low != 0)) {\n          temp3 = remainder_low - 2;\n          quotient_low = quotient_low + quotient_high;\n        }\n      }\n      remainder_low = (quotient_low - temp4) / remainder_high;\n      temp2 = (quotient_high & 0xffff) * remainder_low;\n      remainder_high = temp1 & 0xffff | ((quotient_low - temp4) - remainder_high * remainder_low) * 0x10000;\n      quotient_low = remainder_low;\n      if (remainder_high <= temp2 && temp2 - remainder_high != 0) {\n        carry_flag = CARRY4(remainder_high,quotient_high);\n        remainder_high = remainder_high + quotient_high;\n        quotient_low = remainder_low - 1;\n        if ((carry_flag == false) && (remainder_high <= temp2 && temp2 - remainder_high != 0)) {\n          quotient_low = remainder_low - 2;\n          remainder_high = remainder_high + quotient_high;\n        }\n      }\n      quotient_low = quotient_low | temp3 << 0x10;\n      result = (ulonglong)quotient_low * (ulonglong)(divisor << shift_amount);\n      temp3 = (uint)((ulonglong)result >> 0x20);\n      if ((remainder_high - temp2 < temp3) || ((remainder_high - temp2 == temp3 && (dividend << shift_amount < (uint)result)))\n         ) {\n        quotient_low = quotient_low - 1;\n      }\n    }\n  }\n  return (ulonglong)quotient_low;\n}\n\n",
            "renaming": {
                "FUN_00084860": "divide_and_calculate_remainder_00084860",
                "param_1": "dividend",
                "param_2": "dividend_high",
                "param_3": "divisor",
                "param_4": "divisor_high",
                "lVar1": "result",
                "uVar2": "quotient_low",
                "uVar3": "quotient_high",
                "uVar4": "remainder_low",
                "uVar5": "remainder_high",
                "uVar6": "temp1",
                "uVar7": "temp2",
                "uVar8": "temp3",
                "uVar9": "temp4",
                "iVar10": "shift_amount",
                "bVar11": "carry_flag"
            },
            "calling": [
                "FUN_0008458c"
            ],
            "called": [],
            "improved": true,
            "skipped": false,
            "imported": false,
            "tags": []
        },
        "FUN_00085844": {
            "entrypoint": "0x00085844",
            "current_name": "FUNC_00085844",
            "code": "\nvoid FUNC_00085844(void)\n\n{\n  return;\n}\n\n",
            "renaming": {
                "FUN_00085844": "FUNC_00085844"
            },
            "calling": [
                "FUN_00081778"
            ],
            "called": [],
            "improved": false,
            "skipped": true,
            "imported": false,
            "tags": []
        }
    },
    "used_tokens": 101189,
    "layers": [
        [
            "FUN_000800f4",
            "FUN_00080164",
            "FUN_000801e0",
            "FUN_00080250",
            "FUN_000803fc",
            "FUN_0008044c",
            "FUN_000805a8",
            "FUN_000806a0",
            "FUN_000806f8",
            "FUN_00080774",
            "FUN_0008089c",
            "FUN_00080970",
            "FUN_000809be",
            "FUN_000809e4",
            "FUN_00080a0a",
            "FUN_00080a30",
            "FUN_00080a94",
            "FUN_00080aa8",
            "FUN_00080b2c",
            "FUN_00080b90",
            "FUN_00080b98",
            "FUN_00080c98",
            "FUN_00080d30",
            "FUN_00080d3e",
            "FUN_00080d58",
            "FUN_00080d62",
            "FUN_00080d6a",
            "FUN_00080e80",
            "FUN_00080e88",
            "FUN_00080eaa",
            "FUN_00080eb0",
            "FUN_00080eba",
            "FUN_00080ebe",
            "FUN_00080ec2",
            "FUN_00080ec8",
            "FUN_00080eec",
            "FUN_00080efe",
            "thunk_FUN_000816d8",
            "FUN_00080f0c",
            "FUN_00081014",
            "FUN_000810a6",
            "FUN_000810c4",
            "FUN_000810cc",
            "FUN_000810d8",
            "FUN_000810e8",
            "FUN_000810fc",
            "FUN_0008113a",
            "thunk_FUN_0008113a",
            "FUN_0008117a",
            "FUN_00081190",
            "FUN_000811b0",
            "FUN_000811ca",
            "FUN_000811e8",
            "FUN_00081214",
            "FUN_00081248",
            "FUN_00081276",
            "FUN_000812b8",
            "FUN_00081348",
            "FUN_000813dc",
            "FUN_00081438",
            "FUN_0008145c",
            "FUN_00081472",
            "FUN_00081480",
            "FUN_00081496",
            "FUN_000814ae",
            "FUN_000814d0",
            "FUN_000814f6",
            "FUN_0008151c",
            "FUN_00081560",
            "FUN_00081570",
            "FUN_0008159e",
            "FUN_000815b8",
            "FUN_000815de",
            "FUN_000815ec",
            "FUN_00081618",
            "FUN_00081624",
            "FUN_00081684",
            "FUN_000816d8",
            "FUN_000816ec",
            "FUN_000816f8",
            "FUN_00081750",
            "FUN_00081778",
            "FUN_000817c8",
            "FUN_000817f0",
            "FUN_00081800",
            "FUN_00081810",
            "FUN_00081d48",
            "FUN_00081e34",
            "FUN_00081f00",
            "FUN_00081f9c",
            "FUN_00081fac",
            "FUN_0008236c",
            "FUN_00082390",
            "FUN_000825cc",
            "FUN_00082688",
            "FUN_00082824",
            "FUN_0008289c",
            "FUN_000834f0",
            "FUN_0008356c",
            "FUN_000836ec",
            "FUN_00083850",
            "FUN_00083888",
            "FUN_000839b4",
            "FUN_00083a74",
            "FUN_00083b10",
            "FUN_00083ca8",
            "FUN_00084004",
            "FUN_0008400c",
            "FUN_00084018",
            "FUN_000840f8",
            "FUN_000841e4",
            "thunk_FUN_00080efe",
            "FUN_00084220",
            "FUN_00084244",
            "FUN_0008427c",
            "FUN_000842a4",
            "FUN_0008434c",
            "FUN_0008439c",
            "FUN_00084484",
            "FUN_00084494",
            "FUN_000844bc",
            "FUN_000844e0",
            "FUN_00084508",
            "FUN_00084530",
            "FUN_0008455c",
            "FUN_0008458c",
            "FUN_000845c0",
            "FUN_00084860"
        ]
    ],
    "locked_functions": []
}